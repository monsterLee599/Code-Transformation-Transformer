{"0": "public class QueueDrainObserver { \nprotected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { \nfinal Observer < ? super V > observer = downstream ; \nfinal SimplePlainQueue < U > q = queue ; \nif ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) if ( q . isEmpty ( ) ) { \naccept ( observer , value ) ; \nif ( leave ( - 1 ) == 0 ) return ; \n} \nelse q . offer ( value ) ; \nelse { \nq . offer ( value ) ; \nif ( ! enter ( ) ) return ; \n} \nQueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; \n} \n} \n"}
{"1": "public class Observable { \n@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { \nObjectHelper . requireNonNull ( source , \"source is null\" ) ; \nif ( source instanceof Observable ) return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; \nreturn RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; \n} \n} \n"}
{"6": "public class FlowableScalarXMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { \nif ( source instanceof Callable ) { \nT t ; \ntry { \nt = ( ( Callable < T > ) source ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \nreturn true ; \n} \nif ( t == null ) { \nEmptySubscription . complete ( subscriber ) ; \nreturn true ; \n} \nPublisher < ? extends R > r ; \ntry { \nr = ObjectHelper . requireNonNull ( mapper . apply ( t ) , \"The mapper returned a null Publisher\" ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \nreturn true ; \n} \nif ( r instanceof Callable ) { \nR u ; \ntry { \nu = ( ( Callable < R > ) r ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \nreturn true ; \n} \nif ( u == null ) { \nEmptySubscription . complete ( subscriber ) ; \nreturn true ; \n} \nsubscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; \n} \nelse r . subscribe ( subscriber ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"12": "public class ObjectHelper { \npublic static < T > T requireNonNull ( T object , String message ) { \nif ( object == null ) throw new NullPointerException ( message ) ; \nreturn object ; \n} \n} \n"}
{"21": "public class BlockingMultiObserver { \npublic Throwable blockingGetError ( ) { \nif ( getCount ( ) != 0 ) try { \nBlockingHelper . verifyNonBlocking ( ) ; \nawait ( ) ; \n} \ncatch ( InterruptedException ex ) { \ndispose ( ) ; \nreturn ex ; \n} \nreturn error ; \n} \n} \n"}
{"22": "public class BlockingMultiObserver { \npublic Throwable blockingGetError ( long timeout , TimeUnit unit ) { \nif ( getCount ( ) != 0 ) try { \nBlockingHelper . verifyNonBlocking ( ) ; \nif ( ! await ( timeout , unit ) ) { \ndispose ( ) ; \nthrow ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; \n} \n} \ncatch ( InterruptedException ex ) { \ndispose ( ) ; \nthrow ExceptionHelper . wrapOrThrow ( ex ) ; \n} \nreturn error ; \n} \n} \n"}
{"23": "public class BlockingMultiObserver { \npublic boolean blockingAwait ( long timeout , TimeUnit unit ) { \nif ( getCount ( ) != 0 ) try { \nBlockingHelper . verifyNonBlocking ( ) ; \nif ( ! await ( timeout , unit ) ) { \ndispose ( ) ; \nreturn false ; \n} \n} \ncatch ( InterruptedException ex ) { \ndispose ( ) ; \nthrow ExceptionHelper . wrapOrThrow ( ex ) ; \n} \nThrowable ex = error ; \nif ( ex != null ) throw ExceptionHelper . wrapOrThrow ( ex ) ; \nreturn true ; \n} \n} \n"}
{"24": "public class QueueDrainHelper { \npublic static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { \nint missed = 1 ; \nfor ( ; \n; \n) { \nfor ( ; \n; \n) { \nboolean d = qd . done ( ) ; \nT v = q . poll ( ) ; \nboolean empty = v == null ; \nif ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { \nif ( dispose != null ) dispose . dispose ( ) ; \nreturn ; \n} \nif ( empty ) break ; \nlong r = qd . requested ( ) ; \nif ( r != 0L ) if ( qd . accept ( a , v ) ) if ( r != Long . MAX_VALUE ) qd . produced ( 1 ) ; \nelse { \nq . clear ( ) ; \nif ( dispose != null ) dispose . dispose ( ) ; \na . onError ( new MissingBackpressureException ( \"Could not emit value due to lack of requests.\" ) ) ; \nreturn ; \n} \n} \nmissed = qd . leave ( - missed ) ; \nif ( missed == 0 ) break ; \n} \n} \n} \n"}
{"26": "public class QueueDrainHelper { \npublic static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { \nif ( queue . isEmpty ( ) ) { \nactual . onComplete ( ) ; \nreturn ; \n} \nif ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) return ; \nfor ( ; \n; \n) { \nlong r = state . get ( ) ; \nif ( ( r & COMPLETED_MASK ) != 0L ) return ; \nlong u = r | COMPLETED_MASK ; \nif ( state . compareAndSet ( r , u ) ) { \nif ( r != 0L ) postCompleteDrain ( u , actual , queue , state , isCancelled ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"27": "public class SinglePostCompleteSubscriber { \nprotected final void complete ( R n ) { \nlong p = produced ; \nif ( p != 0 ) BackpressureHelper . produced ( this , p ) ; \nfor ( ; \n; \n) { \nlong r = get ( ) ; \nif ( ( r & COMPLETE_MASK ) != 0 ) { \nonDrop ( n ) ; \nreturn ; \n} \nif ( ( r & REQUEST_MASK ) != 0 ) { \nlazySet ( COMPLETE_MASK + 1 ) ; \ndownstream . onNext ( n ) ; \ndownstream . onComplete ( ) ; \nreturn ; \n} \nvalue = n ; \nif ( compareAndSet ( 0 , COMPLETE_MASK ) ) return ; \nvalue = null ; \n} \n} \n} \n"}
{"28": "public class Notification { \n@ SuppressWarnings ( \"unchecked\" ) @ Nullable public T getValue ( ) { \nObject o = value ; \nif ( o != null && ! NotificationLite . isError ( o ) ) return ( T ) value ; \nreturn null ; \n} \n} \n"}
{"29": "public class Notification { \n@ Nullable public Throwable getError ( ) { \nObject o = value ; \nif ( NotificationLite . isError ( o ) ) return NotificationLite . getError ( o ) ; \nreturn null ; \n} \n} \n"}
{"30": "public class EndConsumerHelper { \npublic static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( upstream != null ) { \nnext . dispose ( ) ; \nif ( upstream != DisposableHelper . DISPOSED ) reportDoubleSubscription ( observer ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"31": "public class EndConsumerHelper { \npublic static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( ! upstream . compareAndSet ( null , next ) ) { \nnext . dispose ( ) ; \nif ( upstream . get ( ) != DisposableHelper . DISPOSED ) reportDoubleSubscription ( observer ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"32": "public class EndConsumerHelper { \npublic static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( upstream != null ) { \nnext . cancel ( ) ; \nif ( upstream != SubscriptionHelper . CANCELLED ) reportDoubleSubscription ( subscriber ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"33": "public class EndConsumerHelper { \npublic static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( ! upstream . compareAndSet ( null , next ) ) { \nnext . cancel ( ) ; \nif ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) reportDoubleSubscription ( subscriber ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"34": "public class BackpressureHelper { \npublic static long addCap ( long a , long b ) { \nlong u = a + b ; \nif ( u < 0L ) return Long . MAX_VALUE ; \nreturn u ; \n} \n} \n"}
{"35": "public class BackpressureHelper { \npublic static long multiplyCap ( long a , long b ) { \nlong u = a * b ; \nif ( ( ( a | b ) >>> 31 ) != 0 ) if ( u / a != b ) return Long . MAX_VALUE ; \nreturn u ; \n} \n} \n"}
{"36": "public class BackpressureHelper { \npublic static long add ( AtomicLong requested , long n ) { \nfor ( ; \n; \n) { \nlong r = requested . get ( ) ; \nif ( r == Long . MAX_VALUE ) return Long . MAX_VALUE ; \nlong u = addCap ( r , n ) ; \nif ( requested . compareAndSet ( r , u ) ) return r ; \n} \n} \n} \n"}
{"39": "public class SchedulerPoolFactory { \npublic static void shutdown ( ) { \nScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; \nif ( exec != null ) exec . shutdownNow ( ) ; \nPOOLS . clear ( ) ; \n} \n} \n"}
{"41": "public class SubscriptionArbiter { \npublic final void setSubscription ( Subscription s ) { \nif ( cancelled ) { \ns . cancel ( ) ; \nreturn ; \n} \nObjectHelper . requireNonNull ( s , \"s is null\" ) ; \nif ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { \nSubscription a = actual ; \nif ( a != null && cancelOnReplace ) a . cancel ( ) ; \nactual = s ; \nlong r = requested ; \nif ( decrementAndGet ( ) != 0 ) drainLoop ( ) ; \nif ( r != 0L ) s . request ( r ) ; \nreturn ; \n} \nSubscription a = missedSubscription . getAndSet ( s ) ; \nif ( a != null && cancelOnReplace ) a . cancel ( ) ; \ndrain ( ) ; \n} \n} \n"}
{"43": "public class ExceptionHelper { \npublic static RuntimeException wrapOrThrow ( Throwable error ) { \nif ( error instanceof Error ) throw ( Error ) error ; \nif ( error instanceof RuntimeException ) return ( RuntimeException ) error ; \nreturn new RuntimeException ( error ) ; \n} \n} \n"}
{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nwhile ( ! deque . isEmpty ( ) ) { \nThrowable e = deque . removeFirst ( ) ; \nif ( e instanceof CompositeException ) { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \nfor ( int i = exceptions . size ( ) - 1 ; \ni >= 0 ; \ni -- ) deque . offerFirst ( exceptions . get ( i ) ) ; \n} \nelse list . add ( e ) ; \n} \nreturn list ; \n} \n} \n"}
{"45": "public class ExceptionHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { \nif ( e instanceof Exception ) return ( Exception ) e ; \nthrow ( E ) e ; \n} \n} \n"}
{"46": "public class CompositeDisposable { \npublic void clear ( ) { \nif ( disposed ) return ; \nOpenHashSet < Disposable > set ; \nsynchronized ( this ) { \nif ( disposed ) return ; \nset = resources ; \nresources = null ; \n} \ndispose ( set ) ; \n} \n} \n"}
{"47": "public class CompositeDisposable { \npublic int size ( ) { \nif ( disposed ) return 0 ; \nsynchronized ( this ) { \nif ( disposed ) return 0 ; \nOpenHashSet < Disposable > set = resources ; \nreturn set != null ? set . size ( ) : 0 ; \n} \n} \n} \n"}
{"48": "public class ObservableScalarXMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { \nif ( source instanceof Callable ) { \nT t ; \ntry { \nt = ( ( Callable < T > ) source ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \nreturn true ; \n} \nif ( t == null ) { \nEmptyDisposable . complete ( observer ) ; \nreturn true ; \n} \nObservableSource < ? extends R > r ; \ntry { \nr = ObjectHelper . requireNonNull ( mapper . apply ( t ) , \"The mapper returned a null ObservableSource\" ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \nreturn true ; \n} \nif ( r instanceof Callable ) { \nR u ; \ntry { \nu = ( ( Callable < R > ) r ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \nreturn true ; \n} \nif ( u == null ) { \nEmptyDisposable . complete ( observer ) ; \nreturn true ; \n} \nScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; \nobserver . onSubscribe ( sd ) ; \nsd . run ( ) ; \n} \nelse r . subscribe ( observer ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) break ; \nif ( NotificationLite . acceptFull ( o , subscriber ) ) return true ; \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) break ; \nif ( NotificationLite . acceptFull ( o , observer ) ) return true ; \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"52": "public class MulticastProcessor { \npublic void start ( ) { \nif ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) queue = new SpscArrayQueue < T > ( bufferSize ) ; \n} \n} \n"}
{"53": "public class MulticastProcessor { \npublic void startUnbounded ( ) { \nif ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; \n} \n} \n"}
{"54": "public class MulticastProcessor { \npublic boolean offer ( T t ) { \nif ( once . get ( ) ) return false ; \nObjectHelper . requireNonNull ( t , \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\" ) ; \nif ( fusionMode == QueueSubscription . NONE ) if ( queue . offer ( t ) ) { \ndrain ( ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"55": "public class SerialDisposable { \n@ Nullable public Disposable get ( ) { \nDisposable d = resource . get ( ) ; \nif ( d == DisposableHelper . DISPOSED ) return Disposables . disposed ( ) ; \nreturn d ; \n} \n} \n"}
{"56": "public class DeferredScalarDisposable { \npublic final void complete ( T value ) { \nint state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) return ; \nObserver < ? super T > a = downstream ; \nif ( state == FUSED_EMPTY ) { \nthis . value = value ; \nlazySet ( FUSED_READY ) ; \na . onNext ( null ) ; \n} \nelse { \nlazySet ( TERMINATED ) ; \na . onNext ( value ) ; \n} \nif ( get ( ) != DISPOSED ) a . onComplete ( ) ; \n} \n} \n"}
{"58": "public class DeferredScalarDisposable { \npublic final void complete ( ) { \nint state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) return ; \nlazySet ( TERMINATED ) ; \ndownstream . onComplete ( ) ; \n} \n} \n"}
{"62": "public class PerfAsyncConsumer { \npublic PerfAsyncConsumer await ( int count ) { \nif ( count <= 1000 ) while ( getCount ( ) != 0 ) { \n} \nelse try { \nawait ( ) ; \n} \ncatch ( InterruptedException ex ) { \nthrow new RuntimeException ( ex ) ; \n} \nreturn this ; \n} \n} \n"}
{"63": "public class DefaultSubscriber { \nprotected final void request ( long n ) { \nSubscription s = this . upstream ; \nif ( s != null ) s . request ( n ) ; \n} \n} \n"}
{"64": "public class PublishSubject { \nboolean add ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED ) return false ; \nint n = a . length ; \n@ SuppressWarnings ( \"unchecked\" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , n ) ; \nb [ n ] = ps ; \nif ( subscribers . compareAndSet ( a , b ) ) return true ; \n} \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) return ; \nint n = a . length ; \nint j = - 1 ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) if ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \nif ( j < 0 ) return ; \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) b = EMPTY ; \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) return ; \n} \n} \n} \n"}
{"67": "public class HttpServiceMethod { \nstatic < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { \nboolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; \nboolean continuationWantsResponse = false ; \nboolean continuationBodyNullable = false ; \nAnnotation [ ] annotations = method . getAnnotations ( ) ; \nType adapterType ; \nif ( isKotlinSuspendFunction ) { \nType [ ] parameterTypes = method . getGenericParameterTypes ( ) ; \nType responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; \nif ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { \nresponseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; \ncontinuationWantsResponse = true ; \n} \nelse { \n} \nadapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; \nannotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; \n} \nelse adapterType = method . getGenericReturnType ( ) ; \nCallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; \nType responseType = callAdapter . responseType ( ) ; \nif ( responseType == okhttp3 . Response . class ) throw methodError ( method , \"'\" + getRawType ( responseType ) . getName ( ) + \"' is not a valid response body type. Did you mean ResponseBody?\" ) ; \nif ( responseType == Response . class ) throw methodError ( method , \"Response must include generic type (e.g., Response<String>)\" ) ; \nif ( requestFactory . httpMethod . equals ( \"HEAD\" ) && ! Void . class . equals ( responseType ) ) throw methodError ( method , \"HEAD method must use Void as response type.\" ) ; \nConverter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; \nokhttp3 . Call . Factory callFactory = retrofit . callFactory ; \nif ( ! isKotlinSuspendFunction ) return new CallAdapted < > ( requestFactory , callFactory , responseConverter , callAdapter ) ; \nelse if ( continuationWantsResponse ) return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; \nelse return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; \n} \n} \n"}
{"68": "public class NetworkBehavior { \npublic void setDelay ( long amount , TimeUnit unit ) { \nif ( amount < 0 ) throw new IllegalArgumentException ( \"Amount must be positive value.\" ) ; \nthis . delayMs = unit . toMillis ( amount ) ; \n} \n} \n"}
{"69": "public class NetworkBehavior { \npublic Response < ? > createErrorResponse ( ) { \nResponse < ? > call ; \ntry { \ncall = errorFactory . call ( ) ; \n} \ncatch ( Exception e ) { \nthrow new IllegalStateException ( \"Error factory threw an exception.\" , e ) ; \n} \nif ( call == null ) throw new IllegalStateException ( \"Error factory returned null.\" ) ; \nif ( call . isSuccessful ( ) ) throw new IllegalStateException ( \"Error factory returned successful response.\" ) ; \nreturn call ; \n} \n} \n"}
{"73": "public class FilterBasedLdapUserSearch { \n@ Override public DirContextOperations searchForUser ( String username ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Searching for user '\" + username + \"', with user search \" + this ) ; \nSpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; \ntemplate . setSearchControls ( searchControls ) ; \ntry { \nreturn template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { \nusername } \n) ; \n} \ncatch ( IncorrectResultSizeDataAccessException notFound ) { \nif ( notFound . getActualSize ( ) == 0 ) throw new UsernameNotFoundException ( \"User \" + username + \" not found in directory.\" ) ; \nthrow notFound ; \n} \n} \n} \n"}
{"76": "public class SpringSecurityCoreVersion { \nprivate static void performVersionChecks ( String minSpringVersion ) { \nif ( minSpringVersion == null ) return ; \nString springVersion = SpringVersion . getVersion ( ) ; \nString version = getVersion ( ) ; \nif ( disableChecks ( springVersion , version ) ) return ; \nlogger . info ( \"You are running with Spring Security Core \" + version ) ; \nif ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) < 0 ) logger . warn ( \"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion ) ; \n} \n} \n"}
{"77": "public class SpringSecurityCoreVersion { \nprivate static boolean disableChecks ( String springVersion , String springSecurityVersion ) { \nif ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) return true ; \nreturn Boolean . getBoolean ( DISABLE_CHECKS ) ; \n} \n} \n"}
{"85": "public class SpringSecurityLdapTemplate { \npublic Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { \nString [ ] attributeNames = new String [ ] { \nattributeName } \n; \nSet < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; \nSet < String > result = new HashSet < > ( ) ; \nfor ( Map < String , List < String > > map : multipleAttributeValues ) { \nList < String > values = map . get ( attributeName ) ; \nif ( values != null ) result . addAll ( values ) ; \n} \nreturn result ; \n} \n} \n"}
{"86": "public class SpringSecurityLdapTemplate { \npublic Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { \nObject [ ] encodedParams = new String [ params . length ] ; \nfor ( int i = 0 ; \ni < params . length ; \ni ++ ) encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; \nString formattedFilter = MessageFormat . format ( filter , encodedParams ) ; \nlogger . debug ( \"Using filter: \" + formattedFilter ) ; \nfinal HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; \nContextMapper roleMapper = new ContextMapper ( ) { \npublic Object mapFromContext ( Object ctx ) { \nDirContextAdapter adapter = ( DirContextAdapter ) ctx ; \nMap < String , List < String > > record = new HashMap < String , List < String > > ( ) ; \nif ( attributeNames == null || attributeNames . length == 0 ) try { \nfor ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; \nae . hasMore ( ) ; \n) { \nAttribute attr = ( Attribute ) ae . next ( ) ; \nextractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; \n} \n} \ncatch ( NamingException x ) { \norg . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; \n} \nelse for ( String attributeName : attributeNames ) { \nextractStringAttributeValues ( adapter , record , attributeName ) ; \n} \nrecord . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; \nset . add ( record ) ; \nreturn null ; \n} \n} \n; \nSearchControls ctls = new SearchControls ( ) ; \nctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; \nctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; \nsearch ( base , formattedFilter , ctls , roleMapper ) ; \nreturn set ; \n} \n} \n"}
{"87": "public class SpringSecurityLdapTemplate { \npublic static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { \nfinal DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; \nfinal DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; \nfinal NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\" ) ; \nSet < DirContextOperations > results = new HashSet < > ( ) ; \ntry { \nwhile ( resultsEnum . hasMore ( ) ) { \nSearchResult searchResult = resultsEnum . next ( ) ; \nDirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; \nAssert . notNull ( dca , \"No object returned by search, DirContext is not correctly configured\" ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Found DN: \" + dca . getDn ( ) ) ; \nresults . add ( dca ) ; \n} \n} \ncatch ( PartialResultException e ) { \nLdapUtils . closeEnumeration ( resultsEnum ) ; \nlogger . info ( \"Ignoring PartialResultException\" ) ; \n} \nif ( results . size ( ) == 0 ) throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; \nif ( results . size ( ) > 1 ) throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; \nreturn results . iterator ( ) . next ( ) ; \n} \n} \n"}
{"89": "public class BasicLookupStrategy { \nprivate void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { \nAssert . notNull ( acls , \"ACLs are required\" ) ; \nAssert . notEmpty ( findNow , \"Items to find now required\" ) ; \nString sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; \nSet < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { \npublic void setValues ( PreparedStatement ps ) throws SQLException { \nint i = 0 ; \nfor ( Long toFind : findNow ) { \ni ++ ; \nps . setLong ( i , toFind ) ; \n} \n} \n} \n, new ProcessResultSet ( acls , sids ) ) ; \nif ( parentsToLookup . size ( ) > 0 ) lookupPrimaryKeys ( acls , parentsToLookup , sids ) ; \n} \n} \n"}
{"90": "public class J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource { \npublic PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { \nCollection < String > j2eeUserRoles = getUserRoles ( context ) ; \nCollection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\" ) ; \nPreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; \nreturn result ; \n} \n} \n"}
{"91": "public class LdapServerBeanDefinitionParser { \nprivate RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { \nObject source = parserContext . extractSource ( element ) ; \nString suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; \nif ( ! StringUtils . hasText ( suffix ) ) suffix = OPT_DEFAULT_ROOT_SUFFIX ; \nString port = element . getAttribute ( ATT_PORT ) ; \nif ( ! StringUtils . hasText ( port ) ) { \nport = getDefaultPort ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Using default port of \" + port ) ; \n} \nString url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix ; \nBeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; \ncontextSource . addConstructorArgValue ( url ) ; \ncontextSource . addPropertyValue ( \"userDn\" , \"uid=admin,ou=system\" ) ; \ncontextSource . addPropertyValue ( \"password\" , \"secret\" ) ; \nRootBeanDefinition apacheContainer = new RootBeanDefinition ( \"org.springframework.security.ldap.server.ApacheDSContainer\" , null , null ) ; \napacheContainer . setSource ( source ) ; \napacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; \nString ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; \nif ( ! StringUtils . hasText ( ldifs ) ) ldifs = OPT_DEFAULT_LDIF_FILE ; \napacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; \napacheContainer . getPropertyValues ( ) . addPropertyValue ( \"port\" , port ) ; \nlogger . info ( \"Embedded LDAP server bean definition created for URL: \" + url ) ; \nif ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) parserContext . getReaderContext ( ) . error ( \"Only one embedded server bean is allowed per application context\" , element ) ; \nparserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; \nreturn ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; \n} \n} \n"}
{"92": "public class HttpConfigurationBuilder { \nprivate void createServletApiFilter ( BeanReference authenticationManager ) { \nfinal String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\" ; \nfinal String DEF_SERVLET_API_PROVISION = \"true\" ; \nString provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; \nif ( ! StringUtils . hasText ( provideServletApi ) ) provideServletApi = DEF_SERVLET_API_PROVISION ; \nif ( \"true\" . equals ( provideServletApi ) ) { \nservApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; \nservApiFilter . getPropertyValues ( ) . add ( \"authenticationManager\" , authenticationManager ) ; \n} \n} \n} \n"}
{"93": "public class HttpConfigurationBuilder { \nprivate void createJaasApiFilter ( ) { \nfinal String ATT_JAAS_API_PROVISION = \"jaas-api-provision\" ; \nfinal String DEF_JAAS_API_PROVISION = \"false\" ; \nString provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; \nif ( ! StringUtils . hasText ( provideJaasApi ) ) provideJaasApi = DEF_JAAS_API_PROVISION ; \nif ( \"true\" . equals ( provideJaasApi ) ) jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; \n} \n} \n"}
{"95": "public class AbstractSecurityWebApplicationInitializer { \nprivate void insertSpringSecurityFilterChain ( ServletContext servletContext ) { \nString filterName = DEFAULT_FILTER_NAME ; \nDelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; \nString contextAttribute = getWebApplicationContextAttribute ( ) ; \nif ( contextAttribute != null ) springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; \nregisterFilter ( servletContext , true , filterName , springSecurityFilterChain ) ; \n} \n} \n"}
{"96": "public class JdbcTokenRepositoryImpl { \npublic PersistentRememberMeToken getTokenForSeries ( String seriesId ) { \ntry { \nreturn getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { \npublic PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { \nreturn new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; \n} \n} \n, seriesId ) ; \n} \ncatch ( EmptyResultDataAccessException zeroResults ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Querying token for series '\" + seriesId + \"' returned no results.\" , zeroResults ) ; \n} \ncatch ( IncorrectResultSizeDataAccessException moreThanOne ) { \nlogger . error ( \"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\" ) ; \n} \ncatch ( DataAccessException e ) { \nlogger . error ( \"Failed to load token for series \" + seriesId , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"100": "public class AbstractPreAuthenticatedProcessingFilter { \npublic void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Checking secure context token: \" + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; \nif ( requiresAuthentication ( ( HttpServletRequest ) request ) ) doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; \nchain . doFilter ( request , response ) ; \n} \n} \n"}
{"101": "public class AbstractPreAuthenticatedProcessingFilter { \nprotected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { \nObject principal = getPreAuthenticatedPrincipal ( request ) ; \nif ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) return false ; \nif ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) return false ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\" ) ; \nreturn true ; \n} \n} \n"}
{"102": "public class AbstractPreAuthenticatedProcessingFilter { \nprivate void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { \nAuthentication authResult ; \nObject principal = getPreAuthenticatedPrincipal ( request ) ; \nObject credentials = getPreAuthenticatedCredentials ( request ) ; \nif ( principal == null ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"No pre-authenticated principal found in request\" ) ; \nreturn ; \n} \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\" ) ; \ntry { \nPreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; \nauthRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; \nauthResult = authenticationManager . authenticate ( authRequest ) ; \nsuccessfulAuthentication ( request , response , authResult ) ; \n} \ncatch ( AuthenticationException failed ) { \nunsuccessfulAuthentication ( request , response , failed ) ; \nif ( ! continueFilterChainOnUnsuccessfulAuthentication ) throw failed ; \n} \n} \n} \n"}
{"103": "public class OnCommittedResponseWrapper { \nprivate void checkContentLength ( long contentLengthToWrite ) { \nthis . contentWritten += contentLengthToWrite ; \nboolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; \nint bufferSize = getBufferSize ( ) ; \nboolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; \nif ( isBodyFullyWritten || requiresFlush ) doOnResponseCommitted ( ) ; \n} \n} \n"}
{"104": "public class SimpleAuthorityMapper { \npublic Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { \nHashSet < GrantedAuthority > mapped = new HashSet < > ( authorities . size ( ) ) ; \nfor ( GrantedAuthority authority : authorities ) { \nmapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; \n} \nif ( defaultAuthority != null ) mapped . add ( defaultAuthority ) ; \nreturn mapped ; \n} \n} \n"}
{"106": "public class AbstractAuthenticationFilterConfigurer { \nprotected final void updateAuthenticationDefaults ( ) { \nif ( loginProcessingUrl == null ) loginProcessingUrl ( loginPage ) ; \nif ( failureHandler == null ) failureUrl ( loginPage + \"?error\" ) ; \nfinal LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; \nif ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) logoutConfigurer . logoutSuccessUrl ( loginPage + \"?logout\" ) ; \n} \n} \n"}
{"107": "public class AbstractAuthenticationFilterConfigurer { \nprotected final void updateAccessDefaults ( B http ) { \nif ( permitAll ) PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; \n} \n} \n"}
{"108": "public class LdapUserDetailsMapper { \nprotected String mapPassword ( Object passwordValue ) { \nif ( ! ( passwordValue instanceof String ) ) passwordValue = new String ( ( byte [ ] ) passwordValue ) ; \nreturn ( String ) passwordValue ; \n} \n} \n"}
{"109": "public class AbstractRememberMeServices { \nprotected String extractRememberMeCookie ( HttpServletRequest request ) { \nCookie [ ] cookies = request . getCookies ( ) ; \nif ( ( cookies == null ) || ( cookies . length == 0 ) ) return null ; \nfor ( Cookie cookie : cookies ) { \nif ( cookieName . equals ( cookie . getName ( ) ) ) return cookie . getValue ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"110": "public class AbstractRememberMeServices { \nprotected String encodeCookie ( String [ ] cookieTokens ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < cookieTokens . length ; \ni ++ ) { \ntry { \nsb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( i < cookieTokens . length - 1 ) sb . append ( DELIMITER ) ; \n} \nString value = sb . toString ( ) ; \nsb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; \nwhile ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"111": "public class AbstractRememberMeServices { \nprotected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { \nString cookieValue = encodeCookie ( tokens ) ; \nCookie cookie = new Cookie ( cookieName , cookieValue ) ; \ncookie . setMaxAge ( maxAge ) ; \ncookie . setPath ( getCookiePath ( request ) ) ; \nif ( cookieDomain != null ) cookie . setDomain ( cookieDomain ) ; \nif ( maxAge < 1 ) cookie . setVersion ( 1 ) ; \nif ( useSecureCookie == null ) cookie . setSecure ( request . isSecure ( ) ) ; \nelse cookie . setSecure ( useSecureCookie ) ; \ncookie . setHttpOnly ( true ) ; \nresponse . addCookie ( cookie ) ; \n} \n} \n"}
{"112": "public class CurrentSecurityContextArgumentResolver { \n@ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { \nReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; \nMono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; \nif ( reactiveSecurityContext == null ) return null ; \nreturn reactiveSecurityContext . flatMap ( a -> { \nObject p = resolveSecurityContext ( parameter , a ) ; \nMono < Object > o = Mono . justOrEmpty ( p ) ; \nreturn adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; \n} \n) ; \n} \n} \n"}
{"113": "public class DefaultServiceAuthenticationDetails { \nprivate String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { \nfinal String query = request . getQueryString ( ) ; \nif ( query == null ) return null ; \nfinal String result = artifactPattern . matcher ( query ) . replaceFirst ( \"\" ) ; \nif ( result . length ( ) == 0 ) return null ; \nreturn result . startsWith ( \"&\" ) ? result . substring ( 1 ) : result ; \n} \n} \n"}
{"114": "public class DefaultServiceAuthenticationDetails { \nprivate static int getServicePort ( URL casServiceUrl ) { \nint port = casServiceUrl . getPort ( ) ; \nif ( port == - 1 ) port = casServiceUrl . getDefaultPort ( ) ; \nreturn port ; \n} \n} \n"}
{"115": "public class SpringSecurityAuthenticationSource { \npublic String getPrincipal ( ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( authentication == null ) { \nlog . warn ( \"No Authentication object set in SecurityContext - returning empty String as Principal\" ) ; \nreturn \"\" ; \n} \nObject principal = authentication . getPrincipal ( ) ; \nif ( principal instanceof LdapUserDetails ) { \nLdapUserDetails details = ( LdapUserDetails ) principal ; \nreturn details . getDn ( ) ; \n} \nelse if ( authentication instanceof AnonymousAuthenticationToken ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Anonymous Authentication, returning empty String as Principal\" ) ; \nreturn \"\" ; \n} \nelse throw new IllegalArgumentException ( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\" ) ; \n} \n} \n"}
{"117": "public class AbstractJaasAuthenticationProvider { \npublic Authentication authenticate ( Authentication auth ) throws AuthenticationException { \nif ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) return null ; \nUsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; \nSet < GrantedAuthority > authorities ; \ntry { \nLoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; \nloginContext . login ( ) ; \nauthorities = new HashSet < > ( ) ; \nSet < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; \nfor ( Principal principal : principals ) { \nfor ( AuthorityGranter granter : this . authorityGranters ) { \nSet < String > roles = granter . grant ( principal ) ; \nif ( ( roles != null ) && ! roles . isEmpty ( ) ) for ( String role : roles ) { \nauthorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; \n} \n} \n} \nJaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList < > ( authorities ) , loginContext ) ; \npublishSuccessEvent ( result ) ; \nreturn result ; \n} \ncatch ( LoginException loginException ) { \nAuthenticationException ase = this . loginExceptionResolver . resolveException ( loginException ) ; \npublishFailureEvent ( request , ase ) ; \nthrow ase ; \n} \n} \n} \n"}
{"118": "public class DefaultSpringSecurityContextSource { \nprivate static String buildProviderUrl ( List < String > urls , String baseDn ) { \nAssert . notNull ( baseDn , \"The Base DN for the LDAP server must not be null.\" ) ; \nAssert . notEmpty ( urls , \"At least one LDAP server URL must be provided.\" ) ; \nString trimmedBaseDn = baseDn . trim ( ) ; \nStringBuilder providerUrl = new StringBuilder ( ) ; \nfor ( String serverUrl : urls ) { \nString trimmedUrl = serverUrl . trim ( ) ; \nif ( \"\" . equals ( trimmedUrl ) ) continue ; \nproviderUrl . append ( trimmedUrl ) ; \nif ( ! trimmedUrl . endsWith ( \"/\" ) ) providerUrl . append ( \"/\" ) ; \nproviderUrl . append ( trimmedBaseDn ) ; \nproviderUrl . append ( \" \" ) ; \n} \nreturn providerUrl . toString ( ) ; \n} \n} \n"}
{"121": "public class JspAuthorizeTag { \npublic int doEndTag ( ) throws JspException { \ntry { \nif ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; \n} \ncatch ( IOException e ) { \nthrow new JspException ( e ) ; \n} \nreturn EVAL_PAGE ; \n} \n} \n"}
{"123": "public class UserDetailsServiceFactoryBean { \nprivate UserDetailsService getUserDetailsService ( ) { \nMap < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; \nif ( beans . size ( ) == 0 ) beans = getBeansOfType ( UserDetailsService . class ) ; \nif ( beans . size ( ) == 0 ) throw new ApplicationContextException ( \"No UserDetailsService registered.\" ) ; \nelse if ( beans . size ( ) > 1 ) throw new ApplicationContextException ( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\" ) ; \nreturn ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; \n} \n} \n"}
{"125": "public class CasAuthenticationFilter { \nprotected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { \nfinal boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; \nfinal boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"requiresAuthentication = \" + result ) ; \nreturn result ; \n} \n} \n"}
{"126": "public class CasAuthenticationFilter { \nprivate boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { \nboolean result = super . requiresAuthentication ( request , response ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"serviceTicketRequest = \" + result ) ; \nreturn result ; \n} \n} \n"}
{"127": "public class CasAuthenticationFilter { \nprivate boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { \nif ( serviceTicketRequest ) return false ; \nfinal boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"proxyTicketRequest = \" + result ) ; \nreturn result ; \n} \n} \n"}
{"129": "public class CasAuthenticationFilter { \nprivate boolean proxyReceptorRequest ( final HttpServletRequest request ) { \nfinal boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"proxyReceptorRequest = \" + result ) ; \nreturn result ; \n} \n} \n"}
{"133": "public class WebSpherePreAuthenticatedWebAuthenticationDetailsSource { \nprivate Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { \nList < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; \nCollection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas ) ; \nreturn userGas ; \n} \n} \n"}
{"135": "public class WebSpherePreAuthenticatedProcessingFilter { \nprotected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { \nObject principal = wasHelper . getCurrentUserName ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"PreAuthenticated WebSphere principal: \" + principal ) ; \nreturn principal ; \n} \n} \n"}
{"138": "public class MapBasedAttributes2GrantedAuthoritiesMapper { \npublic List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { \nArrayList < GrantedAuthority > gaList = new ArrayList < > ( ) ; \nfor ( String attribute : attributes ) { \nCollection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; \nif ( c != null ) gaList . addAll ( c ) ; \n} \ngaList . trimToSize ( ) ; \nreturn gaList ; \n} \n} \n"}
{"141": "public class MapBasedAttributes2GrantedAuthoritiesMapper { \nprivate void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { \nif ( value == null ) return ; \nif ( value instanceof Collection < ? > ) addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; \nelse if ( value instanceof Object [ ] ) addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; \nelse if ( value instanceof String ) addGrantedAuthorityCollection ( result , ( String ) value ) ; \nelse if ( value instanceof GrantedAuthority ) result . add ( ( GrantedAuthority ) value ) ; \nelse throw new IllegalArgumentException ( \"Invalid object type: \" + value . getClass ( ) . getName ( ) ) ; \n} \n} \n"}
{"142": "public class J2eePreAuthenticatedProcessingFilter { \nprotected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { \nObject principal = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"PreAuthenticated J2EE principal: \" + principal ) ; \nreturn principal ; \n} \n} \n"}
{"147": "public class UrlAuthorizationConfigurer { \nprivate static String [ ] hasAnyRole ( String ... roles ) { \nfor ( int i = 0 ; \ni < roles . length ; \ni ++ ) roles [ i ] = \"ROLE_\" + roles [ i ] ; \nreturn roles ; \n} \n} \n"}
{"148": "public class PersistentTokenBasedRememberMeServices { \nprotected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { \nif ( cookieTokens . length != 2 ) throw new InvalidCookieException ( \"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays . asList ( cookieTokens ) + \"'\" ) ; \nfinal String presentedSeries = cookieTokens [ 0 ] ; \nfinal String presentedToken = cookieTokens [ 1 ] ; \nPersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; \nif ( token == null ) throw new RememberMeAuthenticationException ( \"No persistent token found for series id: \" + presentedSeries ) ; \nif ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { \ntokenRepository . removeUserTokens ( token . getUsername ( ) ) ; \nthrow new CookieTheftException ( messages . getMessage ( \"PersistentTokenBasedRememberMeServices.cookieStolen\" , \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\" ) ) ; \n} \nif ( token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L < System . currentTimeMillis ( ) ) throw new RememberMeAuthenticationException ( \"Remember-me login has expired\" ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Refreshing persistent login token for user '\" + token . getUsername ( ) + \"', series '\" + token . getSeries ( ) + \"'\" ) ; \nPersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; \ntry { \ntokenRepository . updateToken ( newToken . getSeries ( ) , newToken . getTokenValue ( ) , newToken . getDate ( ) ) ; \naddCookie ( newToken , request , response ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Failed to update token: \" , e ) ; \nthrow new RememberMeAuthenticationException ( \"Autologin failed due to data access problem\" ) ; \n} \nreturn getUserDetailsService ( ) . loadUserByUsername ( token . getUsername ( ) ) ; \n} \n} \n"}
{"150": "public class SwitchUserFilter { \nprotected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { \nUsernamePasswordAuthenticationToken targetUserRequest ; \nString username = request . getParameter ( this . usernameParameter ) ; \nif ( username == null ) username = \"\" ; \nif ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( \"Attempt to switch to user [\" + username + \"]\" ) ; \nUserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; \nthis . userDetailsChecker . check ( targetUser ) ; \ntargetUserRequest = createSwitchUserToken ( request , targetUser ) ; \nif ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( \"Switch User Token [\" + targetUserRequest + \"]\" ) ; \nif ( this . eventPublisher != null ) this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) , targetUser ) ) ; \nreturn targetUserRequest ; \n} \n} \n"}
{"151": "public class SwitchUserFilter { \nprotected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { \nAuthentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( null == current ) throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( \"SwitchUserFilter.noCurrentUser\" , \"No current user associated with this request\" ) ) ; \nAuthentication original = getSourceAuthentication ( current ) ; \nif ( original == null ) { \nthis . logger . debug ( \"Could not find original user Authentication object!\" ) ; \nthrow new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( \"SwitchUserFilter.noOriginalAuthentication\" , \"Could not find original Authentication object\" ) ) ; \n} \nUserDetails originalUser = null ; \nObject obj = original . getPrincipal ( ) ; \nif ( ( obj != null ) && obj instanceof UserDetails ) originalUser = ( UserDetails ) obj ; \nif ( this . eventPublisher != null ) this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( current , originalUser ) ) ; \nreturn original ; \n} \n} \n"}
{"156": "public class AbstractAuthorizeTag { \npublic boolean authorizeUsingAccessExpression ( ) throws IOException { \nif ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) return false ; \nSecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; \nExpression accessExpression ; \ntry { \naccessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; \n} \ncatch ( ParseException e ) { \nIOException ioException = new IOException ( ) ; \nioException . initCause ( e ) ; \nthrow ioException ; \n} \nreturn ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; \n} \n} \n"}
{"164": "public class SecurityExpressionRoot { \nprivate static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { \nif ( role == null ) return role ; \nif ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) return role ; \nif ( role . startsWith ( defaultRolePrefix ) ) return role ; \nreturn defaultRolePrefix + role ; \n} \n} \n"}
{"166": "public class LdapAuthority { \npublic List < String > getAttributeValues ( String name ) { \nList < String > result = null ; \nif ( attributes != null ) result = attributes . get ( name ) ; \nif ( result == null ) result = Collections . emptyList ( ) ; \nreturn result ; \n} \n} \n"}
{"167": "public class LdapAuthority { \npublic String getFirstAttributeValue ( String name ) { \nList < String > result = getAttributeValues ( name ) ; \nif ( result . isEmpty ( ) ) return null ; \nelse return result . get ( 0 ) ; \n} \n} \n"}
{"171": "public class AddDeleteContactController { \n@ RequestMapping ( value = \"/secure/add.htm\" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { \nvalidator . validate ( form , result ) ; \nif ( result . hasErrors ( ) ) return \"add\" ; \nContact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; \ncontactManager . create ( contact ) ; \nreturn \"redirect:/secure/index.htm\" ; \n} \n} \n"}
{"172": "public class MapBasedMethodSecurityMetadataSource { \n@ Override protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { \nif ( targetClass == null ) return null ; \nreturn findAttributesSpecifiedAgainst ( method , targetClass ) ; \n} \n} \n"}
{"173": "public class MapBasedMethodSecurityMetadataSource { \nprivate void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { \nAssert . notNull ( method , \"RegisteredMethod required\" ) ; \nAssert . notNull ( attr , \"Configuration attribute required\" ) ; \nif ( logger . isInfoEnabled ( ) ) logger . info ( \"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\" ) ; \nthis . methodMap . put ( method , attr ) ; \n} \n} \n"}
{"177": "public class BindAuthenticator { \nprotected void handleBindException ( String userDn , String username , Throwable cause ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Failed to bind as \" + userDn + \": \" + cause ) ; \n} \n} \n"}
{"179": "public class SimpleUrlAuthenticationSuccessHandler { \nprotected final void clearAuthenticationAttributes ( HttpServletRequest request ) { \nHttpSession session = request . getSession ( false ) ; \nif ( session == null ) return ; \nsession . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; \n} \n} \n"}
{"180": "public class FieldUtils { \npublic static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { \nAssert . notNull ( clazz , \"Class required\" ) ; \nAssert . hasText ( fieldName , \"Field name required\" ) ; \ntry { \nreturn clazz . getDeclaredField ( fieldName ) ; \n} \ncatch ( NoSuchFieldException nsf ) { \nif ( clazz . getSuperclass ( ) != null ) return getField ( clazz . getSuperclass ( ) , fieldName ) ; \nthrow new IllegalStateException ( \"Could not locate field '\" + fieldName + \"' on class \" + clazz ) ; \n} \n} \n} \n"}
{"183": "public class LdapShaPasswordEncoder { \nprivate String extractPrefix ( String encPass ) { \nif ( ! encPass . startsWith ( \"{\" ) ) return null ; \nint secondBrace = encPass . lastIndexOf ( '}' ) ; \nif ( secondBrace < 0 ) throw new IllegalArgumentException ( \"Couldn't find closing brace for SHA prefix\" ) ; \nreturn encPass . substring ( 0 , secondBrace + 1 ) ; \n} \n} \n"}
{"184": "public class Http403ForbiddenEntryPoint { \npublic void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Pre-authenticated entry point called. Rejecting access\" ) ; \nresponse . sendError ( HttpServletResponse . SC_FORBIDDEN , \"Access Denied\" ) ; \n} \n} \n"}
{"188": "public class GlobalMethodSecurityBeanDefinitionParser { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { \nBeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; \nManagedList voters = new ManagedList ( 4 ) ; \nif ( expressionVoter != null ) voters . add ( expressionVoter ) ; \nvoters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; \nvoters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; \nif ( jsr250Enabled ) voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; \naccessMgrBuilder . addConstructorArgValue ( voters ) ; \nBeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; \nString id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; \npc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; \nreturn id ; \n} \n} \n"}
{"190": "public class StandardPasswordEncoder { \nprivate boolean matches ( byte [ ] expected , byte [ ] actual ) { \nif ( expected . length != actual . length ) return false ; \nint result = 0 ; \nfor ( int i = 0 ; \ni < expected . length ; \ni ++ ) result |= expected [ i ] ^ actual [ i ] ; \nreturn result == 0 ; \n} \n} \n"}
{"193": "public class UrlUtils { \nprivate static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { \nStringBuilder url = new StringBuilder ( ) ; \nif ( servletPath != null ) { \nurl . append ( servletPath ) ; \nif ( pathInfo != null ) url . append ( pathInfo ) ; \n} \nelse url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; \nif ( queryString != null ) url . append ( \"?\" ) . append ( queryString ) ; \nreturn url . toString ( ) ; \n} \n} \n"}
{"194": "public class UrlUtils { \npublic static boolean isAbsoluteUrl ( String url ) { \nif ( url == null ) return false ; \nfinal Pattern ABSOLUTE_URL = Pattern . compile ( \"\\\\A[a-z0-9.+-]+://.*\" , Pattern . CASE_INSENSITIVE ) ; \nreturn ABSOLUTE_URL . matcher ( url ) . matches ( ) ; \n} \n} \n"}
{"195": "public class RegexBasedAxFetchListFactory { \npublic List < OpenIDAttribute > createAttributeList ( String identifier ) { \nfor ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { \nif ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) return entry . getValue ( ) ; \n} \nreturn Collections . emptyList ( ) ; \n} \n} \n"}
{"196": "public class AclClassIdUtils { \nSerializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { \nif ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; \nelse identifier = convertToLong ( identifier ) ; \nreturn identifier ; \n} \n} \n"}
{"197": "public class JdbcMutableAclService { \nprotected void createEntries ( final MutableAcl acl ) { \nif ( acl . getEntries ( ) . isEmpty ( ) ) return ; \njdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { \npublic int getBatchSize ( ) { \nreturn acl . getEntries ( ) . size ( ) ; \n} \npublic void setValues ( PreparedStatement stmt , int i ) throws SQLException { \nAccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; \nAssert . isTrue ( entry_ instanceof AccessControlEntryImpl , \"Unknown ACE class\" ) ; \nAccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; \nstmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; \nstmt . setInt ( 2 , i ) ; \nstmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; \nstmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; \nstmt . setBoolean ( 5 , entry . isGranting ( ) ) ; \nstmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; \nstmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"199": "public class JdbcMutableAclService { \nprotected void updateObjectIdentity ( MutableAcl acl ) { \nLong parentId = null ; \nif ( acl . getParentAcl ( ) != null ) { \nAssert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , \"Implementation only supports ObjectIdentityImpl\" ) ; \nObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; \nparentId = retrieveObjectIdentityPrimaryKey ( oii ) ; \n} \nAssert . notNull ( acl . getOwner ( ) , \"Owner is required in this implementation\" ) ; \nLong ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; \nint count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; \nif ( count != 1 ) throw new NotFoundException ( \"Unable to locate ACL to update\" ) ; \n} \n} \n"}
{"200": "public class HttpSessionRequestCache { \npublic void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { \nif ( requestMatcher . matches ( request ) ) { \nDefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; \nif ( createSessionAllowed || request . getSession ( false ) != null ) { \nrequest . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; \nlogger . debug ( \"DefaultSavedRequest added to Session: \" + savedRequest ) ; \n} \n} \nelse logger . debug ( \"Request not saved as configured RequestMatcher did not match\" ) ; \n} \n} \n"}
{"206": "public class XFrameOptionsHeaderWriter { \npublic void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { \nif ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { \nString allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; \nif ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; \nelse if ( allowFromValue != null ) if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + \" \" + allowFromValue ) ; \n} \nelse response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; \n} \n} \n"}
{"208": "public class AbstractAuthenticationTargetUrlRequestHandler { \nprotected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { \nif ( isAlwaysUseDefaultTargetUrl ( ) ) return defaultTargetUrl ; \nString targetUrl = null ; \nif ( targetUrlParameter != null ) { \ntargetUrl = request . getParameter ( targetUrlParameter ) ; \nif ( StringUtils . hasText ( targetUrl ) ) { \nlogger . debug ( \"Found targetUrlParameter in request: \" + targetUrl ) ; \nreturn targetUrl ; \n} \n} \nif ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { \ntargetUrl = request . getHeader ( \"Referer\" ) ; \nlogger . debug ( \"Using Referer header: \" + targetUrl ) ; \n} \nif ( ! StringUtils . hasText ( targetUrl ) ) { \ntargetUrl = defaultTargetUrl ; \nlogger . debug ( \"Using default Url: \" + targetUrl ) ; \n} \nreturn targetUrl ; \n} \n} \n"}
{"209": "public class AbstractAuthenticationTargetUrlRequestHandler { \npublic void setTargetUrlParameter ( String targetUrlParameter ) { \nif ( targetUrlParameter != null ) Assert . hasText ( targetUrlParameter , \"targetUrlParameter cannot be empty\" ) ; \nthis . targetUrlParameter = targetUrlParameter ; \n} \n} \n"}
{"210": "public class DocumentDaoImpl { \nprivate Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { \nreturn getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { \nid } \n, new RowMapper < Directory > ( ) { \npublic Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { \nLong parentDirectoryId = new Long ( rs . getLong ( \"parent_directory_id\" ) ) ; \nDirectory parentDirectory = Directory . ROOT_DIRECTORY ; \nif ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) parentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; \nDirectory directory = new Directory ( rs . getString ( \"directory_name\" ) , parentDirectory ) ; \nFieldUtils . setProtectedFieldValue ( \"id\" , directory , new Long ( rs . getLong ( \"id\" ) ) ) ; \nreturn directory ; \n} \n} \n) ; \n} \n} \n"}
{"213": "public class JaasAuthenticationProvider { \nprivate void configureJaasUsingLoop ( ) throws IOException { \nString loginConfigUrl = convertLoginConfigToUrl ( ) ; \nboolean alreadySet = false ; \nint n = 1 ; \nfinal String prefix = \"login.config.url.\" ; \nString existing ; \nwhile ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { \nalreadySet = existing . equals ( loginConfigUrl ) ; \nif ( alreadySet ) break ; \nn ++ ; \n} \nif ( ! alreadySet ) { \nString key = prefix + n ; \nlog . debug ( \"Setting security property [\" + key + \"] to: \" + loginConfigUrl ) ; \nSecurity . setProperty ( key , loginConfigUrl ) ; \n} \n} \n} \n"}
{"214": "public class FastHttpDateFormat { \npublic static String getCurrentDate ( ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( ( now - currentDateGenerated ) > 1000 ) synchronized ( format ) { \nif ( ( now - currentDateGenerated ) > 1000 ) { \ncurrentDateGenerated = now ; \ncurrentDate = format . format ( new Date ( now ) ) ; \n} \n} \nreturn currentDate ; \n} \n} \n"}
{"215": "public class FastHttpDateFormat { \nprivate static Long internalParseDate ( String value , DateFormat [ ] formats ) { \nDate date = null ; \nfor ( int i = 0 ; \n( date == null ) && ( i < formats . length ) ; \ni ++ ) try { \ndate = formats [ i ] . parse ( value ) ; \n} \ncatch ( ParseException ignored ) { \n} \nif ( date == null ) return null ; \nreturn new Long ( date . getTime ( ) ) ; \n} \n} \n"}
{"216": "public class FastHttpDateFormat { \n@ SuppressWarnings ( \"unchecked\" ) private static void updateCache ( HashMap cache , Object key , Object value ) { \nif ( value == null ) return ; \nif ( cache . size ( ) > 1000 ) cache . clear ( ) ; \ncache . put ( key , value ) ; \n} \n} \n"}
{"218": "public class DefaultWASUsernameAndGroupsExtractor { \nprivate static String getSecurityName ( final Subject subject ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Determining Websphere security name for subject \" + subject ) ; \nString userSecurityName = null ; \nif ( subject != null ) { \nObject credential = subject . getPublicCredentials ( getWSCredentialClass ( ) ) . iterator ( ) . next ( ) ; \nif ( credential != null ) userSecurityName = ( String ) invokeMethod ( getSecurityNameMethod ( ) , credential ) ; \n} \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Websphere security name is \" + userSecurityName + \" for subject \" + subject ) ; \nreturn userSecurityName ; \n} \n} \n"}
{"219": "public class DefaultWASUsernameAndGroupsExtractor { \n@ SuppressWarnings ( \"unchecked\" ) private static List < String > getWebSphereGroups ( final String securityName ) { \nContext ic = null ; \ntry { \nic = new InitialContext ( ) ; \nObject objRef = ic . lookup ( USER_REGISTRY ) ; \nObject userReg = invokeMethod ( getNarrowMethod ( ) , null , objRef , Class . forName ( \"com.ibm.websphere.security.UserRegistry\" ) ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg ) ; \nfinal Collection groups = ( Collection ) invokeMethod ( getGroupsForUserMethod ( ) , userReg , new Object [ ] { \nsecurityName } \n) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Groups for user \" + securityName + \": \" + groups . toString ( ) ) ; \nreturn new ArrayList ( groups ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Exception occured while looking up groups for user\" , e ) ; \nthrow new RuntimeException ( \"Exception occured while looking up groups for user\" , e ) ; \n} \nfinally { \ntry { \nif ( ic != null ) ic . close ( ) ; \n} \ncatch ( NamingException e ) { \nlogger . debug ( \"Exception occured while closing context\" , e ) ; \n} \n} \n} \n} \n"}
{"220": "public class LdapUserDetailsManager { \npublic void changePassword ( final String oldPassword , final String newPassword ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nAssert . notNull ( authentication , \"No authentication object found in security context. Can't change current user's password!\" ) ; \nString username = authentication . getName ( ) ; \nlogger . debug ( \"Changing password for user '\" + username ) ; \nDistinguishedName userDn = usernameMapper . buildDn ( username ) ; \nif ( usePasswordModifyExtensionOperation ) changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; \nelse changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; \n} \n} \n"}
{"222": "public class ConcurrentSessionControlAuthenticationStrategy { \nprotected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { \nif ( exceptionIfMaximumExceeded || ( sessions == null ) ) throw new SessionAuthenticationException ( messages . getMessage ( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\" , new Object [ ] { \nInteger . valueOf ( allowableSessions ) } \n, \"Maximum sessions of {0} for this principal exceeded\" ) ) ; \nSessionInformation leastRecentlyUsed = null ; \nfor ( SessionInformation session : sessions ) { \nif ( ( leastRecentlyUsed == null ) || session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) leastRecentlyUsed = session ; \n} \nleastRecentlyUsed . expireNow ( ) ; \n} \n} \n"}
{"224": "public class FilterChainProxy { \nprivate List < Filter > getFilters ( HttpServletRequest request ) { \nfor ( SecurityFilterChain chain : filterChains ) { \nif ( chain . matches ( request ) ) return chain . getFilters ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"227": "public class LdapUtils { \npublic static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { \nDistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; \nif ( dn . contains ( baseDn ) ) return dn ; \nbaseDn . append ( dn ) ; \nreturn baseDn ; \n} \n} \n"}
{"231": "public class RestAssured { \npublic static void filters ( Filter filter , Filter ... additionalFilters ) { \nValidate . notNull ( filter , \"Filter cannot be null\" ) ; \nRestAssured . filters . add ( filter ) ; \nif ( additionalFilters != null ) Collections . addAll ( RestAssured . filters , additionalFilters ) ; \n} \n} \n"}
{"234": "public class RestAssured { \npublic static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { \nif ( userName == null ) throw new IllegalArgumentException ( \"Username cannot be null\" ) ; \nif ( password == null ) throw new IllegalArgumentException ( \"Password cannot be null\" ) ; \nfinal FormAuthScheme scheme = new FormAuthScheme ( ) ; \nscheme . setUserName ( userName ) ; \nscheme . setPassword ( password ) ; \nscheme . setConfig ( config ) ; \nreturn scheme ; \n} \n} \n"}
{"235": "public class RestAssured { \npublic static void proxy ( URI uri ) { \nif ( uri == null ) throw new IllegalArgumentException ( \"Proxy URI cannot be null\" ) ; \nproxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; \n} \n} \n"}
{"236": "public class ResponsePrinter { \npublic static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nif ( logDetail == ALL || logDetail == STATUS ) builder . append ( responseOptions . statusLine ( ) ) ; \nif ( logDetail == ALL || logDetail == HEADERS ) { \nfinal Headers headers = responseOptions . headers ( ) ; \nif ( headers . exist ( ) ) appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; \n} \nelse if ( logDetail == COOKIES ) { \nfinal Cookies cookies = responseOptions . detailedCookies ( ) ; \nif ( cookies . exist ( ) ) appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; \n} \nif ( logDetail == ALL || logDetail == BODY ) { \nString responseBodyToAppend ; \nif ( shouldPrettyPrint ) responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; \nelse responseBodyToAppend = responseBody . asString ( ) ; \nif ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; \nbuilder . append ( responseBodyToAppend ) ; \n} \nString response = builder . toString ( ) ; \nstream . println ( response ) ; \nreturn response ; \n} \n} \n"}
{"260": "public class MultiPartSpecBuilder { \npublic MultiPartSpecBuilder header ( String name , String value ) { \nValidate . notEmpty ( name , \"Header name cannot be empty\" ) ; \nValidate . notEmpty ( value , \"Header value cannot be empty\" ) ; \nfinal Set < String > headerNames = headers . keySet ( ) ; \nfinal String trimmedName = name . trim ( ) ; \nfor ( String headerName : headerNames ) { \nif ( headerName . equalsIgnoreCase ( trimmedName ) ) headers . remove ( headerName ) ; \n} \nheaders . put ( name , value ) ; \nreturn this ; \n} \n} \n"}
{"263": "public class Headers { \npublic static Headers headers ( Header header , Header ... additionalHeaders ) { \nnotNull ( header , \"Header\" ) ; \nfinal List < Header > headerList = new LinkedList < Header > ( ) ; \nheaderList . add ( header ) ; \nif ( additionalHeaders != null ) Collections . addAll ( headerList , additionalHeaders ) ; \nreturn new Headers ( headerList ) ; \n} \n} \n"}
{"265": "public class ResponseBuilder { \npublic ResponseBuilder setHeader ( String name , String value ) { \nnotNull ( name , \"Header name\" ) ; \nnotNull ( value , \"Header value\" ) ; \nList < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; \nnewHeaders . add ( new Header ( name , value ) ) ; \nrestAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; \nif ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) restAssuredResponse . setContentType ( value ) ; \nreturn this ; \n} \n} \n"}
{"266": "public class ResponseBuilder { \npublic Response build ( ) { \nfinal int statusCode = restAssuredResponse . statusCode ( ) ; \nif ( statusCode < 100 || statusCode >= 600 ) throw new IllegalArgumentException ( format ( \"Status code must be greater than 100 and less than 600, was %d.\" , statusCode ) ) ; \nif ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; \nrestAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; \nreturn restAssuredResponse ; \n} \n} \n"}
{"284": "public class HttpRequestFactory { \nstatic HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { \nString method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , \"Http method\" ) ; \nClass < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; \nfinal HttpRequestBase httpRequest ; \nif ( type == null || ( ! ( type . isInstance ( HttpEntityEnclosingRequest . class ) ) && hasBody ) ) httpRequest = new CustomHttpMethod ( method , uri ) ; \nelse { \ntry { \nhttpRequest = type . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nhttpRequest . setURI ( uri ) ; \n} \nreturn httpRequest ; \n} \n} \n"}
{"295": "public class JsonPath { \npublic int getInt ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Integer ) return ( Integer ) value ; \nelse if ( value instanceof Short ) return ( ( Short ) value ) . intValue ( ) ; \nelse if ( value instanceof Long ) return ( ( Long ) value ) . intValue ( ) ; \nelse return ObjectConverter . convertObjectTo ( value , Integer . class ) ; \n} \n} \n"}
{"296": "public class JsonPath { \npublic byte getByte ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Byte ) return ( Byte ) value ; \nelse if ( value instanceof Long ) return ( ( Long ) value ) . byteValue ( ) ; \nelse if ( value instanceof Integer ) return ( ( Integer ) value ) . byteValue ( ) ; \nelse return ObjectConverter . convertObjectTo ( value , Byte . class ) ; \n} \n} \n"}
{"297": "public class JsonPath { \npublic short getShort ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Short ) return ( Short ) value ; \nelse if ( value instanceof Long ) return ( ( Long ) value ) . shortValue ( ) ; \nelse if ( value instanceof Integer ) return ( ( Integer ) value ) . shortValue ( ) ; \nelse return ObjectConverter . convertObjectTo ( value , Short . class ) ; \n} \n} \n"}
{"298": "public class JsonPath { \npublic float getFloat ( String path ) { \nfinal Object value = get ( path ) ; \nif ( value instanceof Double ) return ( ( Double ) value ) . floatValue ( ) ; \nelse return ObjectConverter . convertObjectTo ( value , Float . class ) ; \n} \n} \n"}
{"299": "public class JsonPath { \npublic double getDouble ( String path ) { \nfinal Object value = get ( path ) ; \nif ( value instanceof Double ) return ( Double ) value ; \nreturn ObjectConverter . convertObjectTo ( value , Double . class ) ; \n} \n} \n"}
{"300": "public class JsonPath { \npublic long getLong ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Long ) return ( Long ) value ; \nelse if ( value instanceof Short ) return ( ( Short ) value ) . longValue ( ) ; \nelse if ( value instanceof Integer ) return ( ( Integer ) value ) . longValue ( ) ; \nelse return ObjectConverter . convertObjectTo ( value , Long . class ) ; \n} \n} \n"}
{"301": "public class JsonPath { \npublic < T > List < T > getList ( String path , Class < T > genericType ) { \nif ( genericType == null ) throw new IllegalArgumentException ( \"Generic type cannot be null\" ) ; \nfinal List < T > original = get ( path ) ; \nfinal List < T > newList = new LinkedList < T > ( ) ; \nif ( original != null ) for ( T t : original ) { \nT e ; \nif ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) { \nString str = objectToString ( t ) ; \ne = ( T ) jsonStringToObject ( str , genericType ) ; \n} \nelse e = ObjectConverter . convertObjectTo ( t , genericType ) ; \nnewList . add ( e ) ; \n} \nreturn Collections . unmodifiableList ( newList ) ; \n} \n} \n"}
{"311": "public class WeakKeySet { \nprivate void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { \nsynchronized ( lock ) { \nfor ( KeyAndSource keyAndSource : keysAndSources ) { \nMultiset < Object > set = backingMap . get ( keyAndSource . key ) ; \nif ( set != null ) { \nset . remove ( keyAndSource . source ) ; \nif ( set . isEmpty ( ) ) backingMap . remove ( keyAndSource . key ) ; \n} \n} \n} \n} \n} \n"}
{"313": "public class InjectorImpl { \n< T > BindingImpl < T > getBindingOrThrow ( Key < T > key , Errors errors , JitLimitation jitType ) throws ErrorsException { \nBindingImpl < T > binding = state . getExplicitBinding ( key ) ; \nif ( binding != null ) return binding ; \nreturn getJustInTimeBinding ( key , errors , jitType ) ; \n} \n} \n"}
{"314": "public class InjectorImpl { \nprivate < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { \nKey < String > stringKey = key . ofType ( STRING_TYPE ) ; \nBindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; \nif ( stringBinding == null || ! stringBinding . isConstant ( ) ) return null ; \n@ SuppressWarnings ( \"unchecked\" ) String stringValue = ( ( InstanceBinding < String > ) stringBinding ) . getInstance ( ) ; \nObject source = stringBinding . getSource ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nTypeConverterBinding typeConverterBinding = state . getConverter ( stringValue , type , errors , source ) ; \nif ( typeConverterBinding == null ) return null ; \ntry { \n@ SuppressWarnings ( \"unchecked\" ) T converted = ( T ) typeConverterBinding . getTypeConverter ( ) . convert ( stringValue , type ) ; \nif ( converted == null ) throw errors . converterReturnedNull ( stringValue , source , type , typeConverterBinding ) . toException ( ) ; \nif ( ! type . getRawType ( ) . isInstance ( converted ) ) throw errors . conversionTypeError ( stringValue , source , type , typeConverterBinding , converted ) . toException ( ) ; \nreturn new ConvertedConstantBindingImpl < T > ( this , key , converted , stringBinding , typeConverterBinding ) ; \n} \ncatch ( ErrorsException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nthrow errors . conversionError ( stringValue , source , type , typeConverterBinding , e ) . toException ( ) ; \n} \n} \n} \n"}
{"315": "public class InjectorImpl { \nprivate boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { \nboolean bindingFailed = false ; \nSet < Dependency < ? > > deps = getInternalDependencies ( binding ) ; \nfor ( Dependency dep : deps ) { \nKey < ? > depKey = dep . getKey ( ) ; \nInjectionPoint ip = dep . getInjectionPoint ( ) ; \nif ( encountered . add ( depKey ) ) { \nBindingImpl depBinding = jitBindings . get ( depKey ) ; \nif ( depBinding != null ) { \nboolean failed = cleanup ( depBinding , encountered ) ; \nif ( depBinding instanceof ConstructorBindingImpl ) { \nConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; \nip = ctorBinding . getInternalConstructor ( ) ; \nif ( ! ctorBinding . isInitialized ( ) ) failed = true ; \n} \nif ( failed ) { \nremoveFailedJitBinding ( depBinding , ip ) ; \nbindingFailed = true ; \n} \n} \nelse if ( state . getExplicitBinding ( depKey ) == null ) bindingFailed = true ; \n} \n} \nreturn bindingFailed ; \n} \n} \n"}
{"316": "public class InjectorImpl { \nprivate void removeFailedJitBinding ( Binding < ? > binding , InjectionPoint ip ) { \nfailedJitBindings . add ( binding . getKey ( ) ) ; \njitBindings . remove ( binding . getKey ( ) ) ; \nmembersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; \nprovisionListenerStore . remove ( binding ) ; \nif ( ip != null ) constructors . remove ( ip ) ; \n} \n} \n"}
{"317": "public class InjectorImpl { \n@ SuppressWarnings ( \"unchecked\" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { \nif ( binding instanceof ConstructorBindingImpl ) return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; \nelse if ( binding instanceof HasDependencies ) return ( ( HasDependencies ) binding ) . getDependencies ( ) ; \nelse return ImmutableSet . of ( ) ; \n} \n} \n"}
{"318": "public class InjectorImpl { \n< T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { \nClass < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; \nImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; \nif ( rawType . isArray ( ) || ( rawType . isEnum ( ) && implementedBy != null ) ) throw errors . missingImplementationWithHint ( key , this ) . toException ( ) ; \nif ( rawType == TypeLiteral . class ) { \n@ SuppressWarnings ( \"unchecked\" ) BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; \nreturn binding ; \n} \nif ( implementedBy != null ) { \nAnnotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; \nreturn createImplementedByBinding ( key , scoping , implementedBy , errors ) ; \n} \nProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; \nif ( providedBy != null ) { \nAnnotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; \nreturn createProvidedByBinding ( key , scoping , providedBy , errors ) ; \n} \nreturn ConstructorBindingImpl . create ( this , key , null , source , scoping , errors , jitBinding && options . jitDisabled , options . atInjectRequired ) ; \n} \n} \n"}
{"319": "public class SingleParameterInjector { \nstatic Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { \nif ( parameterInjectors == null ) return NO_ARGUMENTS ; \nint size = parameterInjectors . length ; \nObject [ ] parameters = new Object [ size ] ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) parameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; \nreturn parameters ; \n} \n} \n"}
{"322": "public class InjectionPoint { \nprivate static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { \nAnnotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; \nif ( misplacedBindingAnnotation == null ) return false ; \nif ( member instanceof Method ) try { \nif ( member . getDeclaringClass ( ) . getDeclaredField ( member . getName ( ) ) != null ) return false ; \n} \ncatch ( NoSuchFieldException ignore ) { \n} \nerrors . misplacedBindingAnnotation ( member , misplacedBindingAnnotation ) ; \nreturn true ; \n} \n} \n"}
{"323": "public class InjectionPoint { \nprivate static boolean overrides ( Method a , Method b ) { \nint modifiers = b . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) return true ; \nif ( Modifier . isPrivate ( modifiers ) ) return false ; \nreturn a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; \n} \n} \n"}
{"326": "public class TypeLiteral { \nprivate List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { \nTypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; \nfor ( int t = 0 ; \nt < types . length ; \nt ++ ) result [ t ] = resolve ( types [ t ] ) ; \nreturn ImmutableList . copyOf ( result ) ; \n} \n} \n"}
{"327": "public class MoreTypes { \npublic static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { \nType type = typeLiteral . getType ( ) ; \nif ( ! isFullySpecified ( type ) ) { \nErrors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; \nthrow new ConfigurationException ( errors . getMessages ( ) ) ; \n} \nif ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { \nParameterizedType parameterizedType = ( ParameterizedType ) type ; \n@ SuppressWarnings ( \"unchecked\" ) TypeLiteral < T > guiceProviderType = ( TypeLiteral < T > ) TypeLiteral . get ( Types . providerOf ( parameterizedType . getActualTypeArguments ( ) [ 0 ] ) ) ; \nreturn guiceProviderType ; \n} \n@ SuppressWarnings ( \"unchecked\" ) TypeLiteral < T > wrappedPrimitives = ( TypeLiteral < T > ) PRIMITIVE_TO_WRAPPER . get ( typeLiteral ) ; \nif ( wrappedPrimitives != null ) return wrappedPrimitives ; \nif ( typeLiteral . getClass ( ) == TypeLiteral . class ) return typeLiteral ; \n@ SuppressWarnings ( \"unchecked\" ) TypeLiteral < T > recreated = ( TypeLiteral < T > ) TypeLiteral . get ( typeLiteral . getType ( ) ) ; \nreturn recreated ; \n} \n} \n"}
{"328": "public class TypeConverterBindingProcessor { \nstatic void prepareBuiltInConverters ( InjectorImpl injector ) { \nconvertToPrimitiveType ( injector , int . class , Integer . class ) ; \nconvertToPrimitiveType ( injector , long . class , Long . class ) ; \nconvertToPrimitiveType ( injector , boolean . class , Boolean . class ) ; \nconvertToPrimitiveType ( injector , byte . class , Byte . class ) ; \nconvertToPrimitiveType ( injector , short . class , Short . class ) ; \nconvertToPrimitiveType ( injector , float . class , Float . class ) ; \nconvertToPrimitiveType ( injector , double . class , Double . class ) ; \nconvertToClass ( injector , Character . class , new TypeConverter ( ) { \n@ Override public Object convert ( String value , TypeLiteral < ? > toType ) { \nvalue = value . trim ( ) ; \nif ( value . length ( ) != 1 ) throw new RuntimeException ( \"Length != 1.\" ) ; \nreturn value . charAt ( 0 ) ; \n} \n@ Override public String toString ( ) { \nreturn \"TypeConverter<Character>\" ; \n} \n} \n) ; \nconvertToClasses ( injector , Matchers . subclassesOf ( Enum . class ) , new TypeConverter ( ) { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public Object convert ( String value , TypeLiteral < ? > toType ) { \nreturn Enum . valueOf ( ( Class ) toType . getRawType ( ) , value ) ; \n} \n@ Override public String toString ( ) { \nreturn \"TypeConverter<E extends Enum<E>>\" ; \n} \n} \n) ; \ninternalConvertToTypes ( injector , new AbstractMatcher < TypeLiteral < ? > > ( ) { \n@ Override public boolean matches ( TypeLiteral < ? > typeLiteral ) { \nreturn typeLiteral . getRawType ( ) == Class . class ; \n} \n@ Override public String toString ( ) { \nreturn \"Class<?>\" ; \n} \n} \n, new TypeConverter ( ) { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public Object convert ( String value , TypeLiteral < ? > toType ) { \ntry { \nreturn Class . forName ( value ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new RuntimeException ( e . getMessage ( ) ) ; \n} \n} \n@ Override public String toString ( ) { \nreturn \"TypeConverter<Class<?>>\" ; \n} \n} \n) ; \n} \n} \n"}
{"331": "public class BytecodeGen { \nprivate static boolean isPubliclyCallable ( Member member ) { \nif ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) return false ; \nClass < ? > [ ] parameterTypes ; \nif ( member instanceof Constructor ) parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; \nelse { \nMethod method = ( Method ) member ; \nif ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) return false ; \nparameterTypes = method . getParameterTypes ( ) ; \n} \nfor ( Class < ? > type : parameterTypes ) { \nif ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"333": "public class Initializer { \n< T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { \ncheckNotNull ( source ) ; \nPreconditions . checkState ( ! validationStarted , \"Member injection could not be requested after validation is started\" ) ; \nProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; \nif ( instance == null || ( injectionPoints . isEmpty ( ) && ! injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) ) return Initializables . of ( instance ) ; \nif ( initializablesCache . containsKey ( instance ) ) { \n@ SuppressWarnings ( \"unchecked\" ) Initializable < T > cached = ( Initializable < T > ) initializablesCache . get ( instance ) ; \nreturn cached ; \n} \nInjectableReference < T > injectableReference = new InjectableReference < T > ( injector , instance , binding == null ? null : binding . getKey ( ) , provisionCallback , source , cycleDetectingLockFactory . create ( instance . getClass ( ) ) ) ; \ninitializablesCache . put ( instance , injectableReference ) ; \npendingInjections . add ( injectableReference ) ; \nreturn injectableReference ; \n} \n} \n"}
{"336": "public class ManagedFilterPipeline { \n@ SuppressWarnings ( { \n\"JavaDoc\" , \"deprecation\" } \n) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) { \nif ( ! servletPipeline . hasServletsMapped ( ) ) return servletRequest ; \nHttpServletRequest request = ( HttpServletRequest ) servletRequest ; \nreturn new HttpServletRequestWrapper ( request ) { \n@ Override public RequestDispatcher getRequestDispatcher ( String path ) { \nfinal RequestDispatcher dispatcher = servletPipeline . getRequestDispatcher ( path ) ; \nreturn ( null != dispatcher ) ? dispatcher : super . getRequestDispatcher ( path ) ; \n} \n} \n; \n} \n} \n"}
{"337": "public class Scoping { \nstatic < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { \nif ( scoping . isNoScope ( ) ) return creator ; \nScope scope = scoping . getScopeInstance ( ) ; \nProvider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T > ( injector , creator ) ) ; \nreturn new InternalFactoryToProviderAdapter < T > ( scoped , source ) ; \n} \n} \n"}
{"338": "public class Scoping { \nstatic Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { \nClass < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; \nif ( scopeAnnotation == null ) return scoping ; \nScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; \nif ( scope != null ) return forInstance ( scope . getScope ( ) ) ; \nerrors . scopeNotFound ( scopeAnnotation ) ; \nreturn UNSCOPED ; \n} \n} \n"}
{"339": "public class ServletUtils { \nstatic String normalizePath ( String path ) { \nStringBuilder sb = new StringBuilder ( path . length ( ) ) ; \nint queryStart = path . indexOf ( '?' ) ; \nString query = null ; \nif ( queryStart != - 1 ) { \nquery = path . substring ( queryStart ) ; \npath = path . substring ( 0 , queryStart ) ; \n} \nList < String > segments = new ArrayList < > ( ) ; \nfor ( String segment : SLASH_SPLITTER . split ( path ) ) { \nString normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; \nif ( \".\" . equals ( normalized ) ) { \n} \nelse if ( \"..\" . equals ( normalized ) ) if ( segments . size ( ) > 1 ) segments . remove ( segments . size ( ) - 1 ) ; \nelse segments . add ( normalized ) ; \n} \nSLASH_JOINER . appendTo ( sb , segments ) ; \nif ( query != null ) sb . append ( query ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"342": "public class Annotations { \npublic static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { \nClass < ? extends Annotation > found = null ; \nfor ( Annotation annotation : annotations ) { \nClass < ? extends Annotation > annotationType = annotation . annotationType ( ) ; \nif ( isScopeAnnotation ( annotationType ) ) if ( found != null ) errors . duplicateScopeAnnotations ( found , annotationType ) ; \nelse found = annotationType ; \n} \nreturn found ; \n} \n} \n"}
{"344": "public class Annotations { \npublic static String nameOf ( Key < ? > key ) { \nAnnotation annotation = key . getAnnotation ( ) ; \nClass < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; \nif ( annotation != null && ! isMarker ( annotationType ) ) return key . getAnnotation ( ) . toString ( ) ; \nelse if ( key . getAnnotationType ( ) != null ) return \"@\" + key . getAnnotationType ( ) . getName ( ) ; \nelse return \"\" ; \n} \n} \n"}
{"348": "public class Struts2Factory { \nprivate static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { \nfor ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { \nif ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"352": "public class Message { \nprivate Object writeReplace ( ) throws ObjectStreamException { \nObject [ ] sourcesAsStrings = sources . toArray ( ) ; \nfor ( int i = 0 ; \ni < sourcesAsStrings . length ; \ni ++ ) sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; \nreturn new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; \n} \n} \n"}
{"353": "public class CheckedProviderMethodsModule { \nstatic Module forModule ( Module module ) { \nif ( module instanceof CheckedProviderMethodsModule ) return Modules . EMPTY_MODULE ; \nreturn new CheckedProviderMethodsModule ( module ) ; \n} \n} \n"}
{"355": "public class FactoryProvider2 { \nprivate boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { \nCollection < Message > messages = ce . getErrorMessages ( ) ; \nif ( messages . size ( ) == 1 ) { \nMessage msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; \nreturn msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; \n} \nelse return false ; \n} \n} \n"}
{"356": "public class FactoryProvider2 { \nprivate boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { \nList < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; \nAnnotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; \nint p = 0 ; \nList < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; \nfor ( TypeLiteral < ? > param : params ) { \nKey < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; \nconstructorKeys . add ( paramKey ) ; \n} \nfor ( Key < ? > key : paramList ) { \nif ( ! constructorKeys . remove ( key ) ) return false ; \n} \nfor ( Key < ? > key : constructorKeys ) { \nif ( key . getAnnotationType ( ) == Assisted . class ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"357": "public class FactoryProvider2 { \nprivate Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { \nImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; \nbuilder . addAll ( ctorPoint . getDependencies ( ) ) ; \nif ( ! implementation . getRawType ( ) . isInterface ( ) ) for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { \nbuilder . addAll ( ip . getDependencies ( ) ) ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"358": "public class FactoryProvider2 { \nprivate Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { \nImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; \nfor ( Dependency < ? > dep : deps ) { \nClass < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; \nif ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) builder . add ( dep ) ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"359": "public class FactoryProvider2 { \nprivate boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { \nSet < Dependency < ? > > badDeps = null ; \nfor ( Dependency < ? > dep : dependencies ) { \nif ( isInjectorOrAssistedProvider ( dep ) ) { \nif ( badDeps == null ) badDeps = Sets . newHashSet ( ) ; \nbadDeps . add ( dep ) ; \n} \n} \nif ( badDeps != null && ! badDeps . isEmpty ( ) ) { \nlogger . log ( Level . WARNING , \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!)  \" + \"The exact offending deps are: {2}\" , new Object [ ] { \nfactoryType , implementation , badDeps } \n) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"360": "public class FactoryProvider2 { \npublic Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { \ncheckState ( injector != null , \"Factories.create() factories cannot be used until they're initialized by Guice.\" ) ; \nfinal Key < ? > returnType = data . returnType ; \nfinal Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; \nModule assistedModule = new AbstractModule ( ) { \n@ Override @ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) protected void configure ( ) { \nBinder binder = binder ( ) . withSource ( method ) ; \nint p = 0 ; \nif ( ! data . optimized ) for ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; \n} \nelse for ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; \n} \nConstructor constructor = data . constructor ; \nif ( constructor != null ) binder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; \n} \n} \n; \nInjector forCreate = injector . createChildInjector ( assistedModule ) ; \nBinding < ? > binding = forCreate . getBinding ( returnKey ) ; \nif ( data . optimized ) data . cachedBinding = binding ; \nreturn binding ; \n} \n} \n"}
{"361": "public class FactoryProvider2 { \n@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { \nif ( methodHandleByMethod . containsKey ( method ) ) return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; \nif ( method . getDeclaringClass ( ) . equals ( Object . class ) ) if ( \"equals\" . equals ( method . getName ( ) ) ) return proxy == args [ 0 ] ; \nelse if ( \"hashCode\" . equals ( method . getName ( ) ) ) return System . identityHashCode ( proxy ) ; \nelse return method . invoke ( this , args ) ; \nAssistData data = assistDataByMethod . get ( method ) ; \ncheckState ( data != null , \"No data for method: %s\" , method ) ; \nProvider < ? > provider ; \nif ( data . cachedBinding != null ) provider = data . cachedBinding . getProvider ( ) ; \nelse provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; \ntry { \nint p = 0 ; \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . set ( args [ p ++ ] ) ; \n} \nreturn provider . get ( ) ; \n} \ncatch ( ProvisionException e ) { \nif ( e . getErrorMessages ( ) . size ( ) == 1 ) { \nMessage onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; \nThrowable cause = onlyError . getCause ( ) ; \nif ( cause != null && canRethrow ( method , cause ) ) throw cause ; \n} \nthrow e ; \n} \nfinally { \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . remove ( ) ; \n} \n} \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! sameTypes . isEmpty ( ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nint howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \nfor ( int i = 0 ; \ni < howMany ; \n++ i ) sb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \nint remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( remaining > 0 ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nelse { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) || want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) break ; \n} \n} \nif ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) sb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"365": "public class FilterChainInvocation { \nprivate Filter findNextFilter ( HttpServletRequest request ) { \nwhile ( ++ index < filterDefinitions . length ) { \nFilter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; \nif ( filter != null ) return filter ; \n} \nreturn null ; \n} \n} \n"}
{"367": "public class ConstructorBindingImpl { \nInjectionPoint getInternalConstructor ( ) { \nif ( factory . constructorInjector != null ) return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; \nelse return constructorInjectionPoint ; \n} \n} \n"}
{"368": "public class ConstructorBindingImpl { \nSet < Dependency < ? > > getInternalDependencies ( ) { \nImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; \nif ( factory . constructorInjector == null ) { \nbuilder . add ( constructorInjectionPoint ) ; \ntry { \nbuilder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; \n} \ncatch ( ConfigurationException ignored ) { \n} \n} \nelse builder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers ( ) ) ; \nreturn Dependency . forInjectionPoints ( builder . build ( ) ) ; \n} \n} \n"}
{"370": "public class ProviderMethodsModule { \nprivate Annotation getAnnotation ( Binder binder , Method method ) { \nif ( method . isBridge ( ) || method . isSynthetic ( ) ) return null ; \nAnnotation annotation = null ; \nfor ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { \nAnnotation foundAnnotation = method . getAnnotation ( annotationClass ) ; \nif ( foundAnnotation != null ) { \nif ( annotation != null ) { \nbinder . addError ( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\" , scanner , method ) ; \nreturn null ; \n} \nannotation = foundAnnotation ; \n} \n} \nreturn annotation ; \n} \n} \n"}
{"375": "public class ServletScopes { \nprivate static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { \nif ( object == null || object == NullObject . INSTANCE ) return NullObject . INSTANCE ; \nif ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) throw new IllegalArgumentException ( \"Value[\" + object + \"] of type[\" + object . getClass ( ) . getName ( ) + \"] is not compatible with key[\" + key + \"]\" ) ; \nreturn object ; \n} \n} \n"}
{"380": "public class Key { \nstatic AnnotationStrategy strategyFor ( Annotation annotation ) { \ncheckNotNull ( annotation , \"annotation\" ) ; \nClass < ? extends Annotation > annotationType = annotation . annotationType ( ) ; \nensureRetainedAtRuntime ( annotationType ) ; \nensureIsBindingAnnotation ( annotationType ) ; \nif ( Annotations . isMarker ( annotationType ) ) return new AnnotationTypeStrategy ( annotationType , annotation ) ; \nreturn new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; \n} \n} \n"}
{"381": "public class Key { \nstatic AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { \nannotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; \nif ( isAllDefaultMethods ( annotationType ) ) return strategyFor ( generateAnnotation ( annotationType ) ) ; \ncheckNotNull ( annotationType , \"annotation type\" ) ; \nensureRetainedAtRuntime ( annotationType ) ; \nensureIsBindingAnnotation ( annotationType ) ; \nreturn new AnnotationTypeStrategy ( annotationType , null ) ; \n} \n} \n"}
{"382": "public class InterceptorStackCallback { \nprivate void pruneStacktrace ( Throwable throwable ) { \nfor ( Throwable t = throwable ; \nt != null ; \nt = t . getCause ( ) ) { \nStackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; \nList < StackTraceElement > pruned = Lists . newArrayList ( ) ; \nfor ( StackTraceElement element : stackTrace ) { \nString className = element . getClassName ( ) ; \nif ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( \"$EnhancerByGuice$\" ) ) pruned . add ( element ) ; \n} \nt . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; \n} \n} \n} \n"}
{"383": "public class DependencyAndSource { \npublic String getBindingSource ( ) { \nif ( source instanceof Class ) return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; \nelse if ( source instanceof Member ) return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; \nelse return source . toString ( ) ; \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nint index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nint thisIdx = index ++ ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \nfor ( int i = dependencies . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses && cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! causes . containsKey ( causeEquivalence ) ) { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \nelse { \nint causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( errorMessages . size ( ) == 1 ) fmt . format ( \"1 error\" ) ; \nelse fmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"390": "public class SourceProvider { \npublic Object getFromClassNames ( List < String > moduleClassNames ) { \nPreconditions . checkNotNull ( moduleClassNames , \"The list of module class names cannot be null.\" ) ; \nfor ( final String moduleClassName : moduleClassNames ) { \nif ( ! shouldBeSkipped ( moduleClassName ) ) return new StackTraceElement ( moduleClassName , \"configure\" , null , - 1 ) ; \n} \nreturn UNKNOWN_SOURCE ; \n} \n} \n"}
{"395": "public class ProviderInternalFactory { \nprotected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { \nT t = provider . get ( ) ; \nif ( t == null && ! dependency . isNullable ( ) ) InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; \nconstructionContext . setProxyDelegates ( t ) ; \nreturn t ; \n} \n} \n"}
{"396": "public class ConnectionEventListener { \npublic void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { \nList < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; \nif ( processorList != null ) for ( ConnectionEventProcessor processor : processorList ) { \nprocessor . onEvent ( remoteAddr , conn ) ; \n} \n} \n} \n"}
{"398": "public class FutureTaskUtil { \npublic static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { \nT t = null ; \nif ( null != task ) try { \nt = task . getAfterRun ( ) ; \n} \ncatch ( InterruptedException e ) { \nlogger . error ( \"Future task interrupted!\" , e ) ; \n} \ncatch ( ExecutionException e ) { \nlogger . error ( \"Future task execute failed!\" , e ) ; \n} \ncatch ( FutureTaskNotRunYetException e ) { \nlogger . error ( \"Future task has not run yet!\" , e ) ; \n} \ncatch ( FutureTaskNotCompleted e ) { \nlogger . error ( \"Future task has not completed!\" , e ) ; \n} \nreturn t ; \n} \n} \n"}
{"399": "public class FutureTaskUtil { \npublic static void launderThrowable ( Throwable t ) { \nif ( t instanceof RuntimeException ) throw ( RuntimeException ) t ; \nelse if ( t instanceof Error ) throw ( Error ) t ; \nelse throw new IllegalStateException ( \"Not unchecked!\" , t ) ; \n} \n} \n"}
{"400": "public class ProcessorManager { \npublic void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { \nif ( this . cmd2processors . containsKey ( cmdCode ) ) logger . warn ( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; \nthis . cmd2processors . put ( cmdCode , processor ) ; \n} \n} \n"}
{"401": "public class ProcessorManager { \npublic void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { \nif ( this . defaultProcessor == null ) this . defaultProcessor = processor ; \nelse throw new IllegalStateException ( \"The defaultProcessor has already been registered: \" + this . defaultProcessor . getClass ( ) ) ; \n} \n} \n"}
{"402": "public class ProcessorManager { \npublic RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { \nRemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; \nif ( processor != null ) return processor ; \nreturn this . defaultProcessor ; \n} \n} \n"}
{"405": "public class DefaultConnectionManager { \n@ Override public Map < String , List < Connection > > getAll ( ) { \nMap < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nif ( null != pool ) allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; \n} \nreturn allConnections ; \n} \n} \n"}
{"406": "public class DefaultConnectionManager { \n@ Override public void scan ( ) { \nif ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { \nIterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString poolKey = iter . next ( ) ; \nConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; \nif ( null != pool ) { \npool . scan ( ) ; \nif ( pool . isEmpty ( ) ) if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { \niter . remove ( ) ; \nlogger . warn ( \"Remove expired pool task of poolKey {} which is empty.\" , poolKey ) ; \n} \n} \n} \n} \n} \n} \n"}
{"407": "public class DefaultConnectionManager { \n@ Override public Connection getAndCreateIfAbsent ( Url url ) throws InterruptedException , RemotingException { \nConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; \nif ( null != pool ) return pool . get ( ) ; \nelse { \nlogger . error ( \"[NOTIFYME] bug detected! pool here must not be null!\" ) ; \nreturn null ; \n} \n} \n} \n"}
{"408": "public class DefaultConnectionManager { \n@ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { \nConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; \nif ( null != pool ) healIfNeed ( pool , url ) ; \nelse logger . error ( \"[NOTIFYME] bug detected! pool here must not be null!\" ) ; \n} \n} \n"}
{"409": "public class DefaultConnectionManager { \nprivate void removeTask ( String poolKey ) { \nRunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; \nif ( null != task ) { \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; \nif ( null != pool ) pool . removeAllAndTryClose ( ) ; \n} \n} \n} \n"}
{"410": "public class DefaultConnectionManager { \nprivate void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { \nString poolKey = url . getUniqueKey ( ) ; \nif ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { \nFutureTask < Integer > task = this . healTasks . get ( poolKey ) ; \nif ( null == task ) { \ntask = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; \ntask = this . healTasks . putIfAbsent ( poolKey , task ) ; \nif ( null == task ) { \ntask = this . healTasks . get ( poolKey ) ; \ntask . run ( ) ; \n} \n} \ntry { \nint numAfterHeal = task . get ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; \n} \ncatch ( InterruptedException e ) { \nthis . healTasks . remove ( poolKey ) ; \nthrow e ; \n} \ncatch ( ExecutionException e ) { \nthis . healTasks . remove ( poolKey ) ; \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RemotingException ) throw ( RemotingException ) cause ; \nelse FutureTaskUtil . launderThrowable ( cause ) ; \n} \nthis . healTasks . remove ( poolKey ) ; \n} \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \nif ( url . isConnWarmup ( ) ) for ( int i = actualNum ; \ni < expectNum ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nelse { \nif ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) throw new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \nif ( syncCreateNumWhenNotWarmup > 0 ) { \nfor ( int i = 0 ; \ni < syncCreateNumWhenNotWarmup ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) return ; \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( int i = pool . size ( ) ; \ni < url . getConnNum ( ) ; \n++ i ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \n} \n} \n"}
{"414": "public class Connection { \npublic void close ( ) { \nif ( closed . compareAndSet ( false , true ) ) try { \nif ( this . getChannel ( ) != null ) this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture future ) throws Exception { \nif ( logger . isInfoEnabled ( ) ) logger . info ( \"Close the connection to remote address={}, result={}, cause={}\" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nlogger . warn ( \"Exception caught when closing connection {}\" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; \n} \n} \n} \n"}
{"416": "public class UserProcessorRegisterHelper { \npublic static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { \nif ( null == processor ) throw new RuntimeException ( \"User processor should not be null!\" ) ; \nif ( processor instanceof MultiInterestUserProcessor ) registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; \nelse { \nif ( StringUtils . isBlank ( processor . interest ( ) ) ) throw new RuntimeException ( \"Processor interest should not be blank!\" ) ; \nUserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; \nif ( preProcessor != null ) { \nString errMsg = \"Processor with interest key [\" + processor . interest ( ) + \"] has already been registered to rpc server, can not register again!\" ; \nthrow new RuntimeException ( errMsg ) ; \n} \n} \n} \n} \n"}
{"417": "public class UserProcessorRegisterHelper { \nprivate static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { \nif ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) throw new RuntimeException ( \"Processor interest should not be blank!\" ) ; \nfor ( String interest : processor . multiInterest ( ) ) { \nUserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; \nif ( preProcessor != null ) { \nString errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\" ; \nthrow new RuntimeException ( errMsg ) ; \n} \n} \n} \n} \n"}
{"418": "public class RpcRequestProcessor { \nprivate void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { \nfinal int id = cmd . getId ( ) ; \nfinal byte type = cmd . getType ( ) ; \nUserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; \nif ( processor instanceof AsyncUserProcessor ) try { \nprocessor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \nelse try { \nObject responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \n} \n"}
{"421": "public class RpcRequestProcessor { \nprivate void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\" , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; \nString remoteAddr = \"UNKNOWN\" ; \nif ( null != ctx ) { \nChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; \nChannel channel = channelCtx . channel ( ) ; \nif ( null != channel ) remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; \n} \nlogger . warn ( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\" , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; \n} \n} \n"}
{"423": "public class AbstractRemotingProcessor { \n@ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { \nProcessTask task = new ProcessTask ( ctx , msg ) ; \nif ( this . getExecutor ( ) != null ) this . getExecutor ( ) . execute ( task ) ; \nelse defaultExecutor . execute ( task ) ; \n} \n} \n"}
{"425": "public class BaseRemoting { \nprotected void oneway ( final Connection conn , final RemotingCommand request ) { \ntry { \nconn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture f ) throws Exception { \nif ( ! f . isSuccess ( ) ) logger . error ( \"Invoke send failed. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nif ( null == conn ) logger . error ( \"Conn is null\" ) ; \nelse logger . error ( \"Exception caught when sending invocation. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; \n} \n} \n} \n"}
{"426": "public class ProtocolSwitch { \npublic static byte toByte ( BitSet bs ) { \nint value = 0 ; \nfor ( int i = 0 ; \ni < bs . length ( ) ; \n++ i ) if ( bs . get ( i ) ) value += 1 << i ; \nif ( bs . length ( ) > 7 ) throw new IllegalArgumentException ( \"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \nreturn ( byte ) value ; \n} \n} \n"}
{"427": "public class ProtocolSwitch { \npublic static BitSet toBitSet ( int value ) { \nif ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) throw new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \nBitSet bs = new BitSet ( ) ; \nint index = 0 ; \nwhile ( value != 0 ) { \nif ( value % 2 != 0 ) bs . set ( index ) ; \n++ index ; \nvalue = ( byte ) ( value >> 1 ) ; \n} \nreturn bs ; \n} \n} \n"}
{"429": "public class ReconnectManager { \npublic void stop ( ) { \nif ( ! this . started ) return ; \nthis . started = false ; \nhealConnectionThreads . interrupt ( ) ; \nthis . tasks . clear ( ) ; \nthis . canceled . clear ( ) ; \n} \n} \n"}
{"430": "public class RpcRemoting { \nprotected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { \nRpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; \nif ( null != invokeContext ) { \nObject clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; \nif ( null != clientCustomSerializer ) try { \ncommand . setSerializer ( ( Byte ) clientCustomSerializer ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new IllegalArgumentException ( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer . getClass ( ) . getName ( ) + \"].\" ) ; \n} \nBoolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; \nif ( null != crcSwitch && crcSwitch ) command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { \nProtocolSwitch . CRC_SWITCH_INDEX } \n) ) ; \n} \nelse command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { \nProtocolSwitch . CRC_SWITCH_INDEX } \n) ) ; \ncommand . setTimeout ( timeoutMillis ) ; \ncommand . setRequestClass ( request . getClass ( ) . getName ( ) ) ; \ncommand . setInvokeContext ( invokeContext ) ; \ncommand . serialize ( ) ; \nlogDebugInfo ( command ) ; \nreturn command ; \n} \n} \n"}
{"431": "public class ScheduledDisconnectStrategy { \n@ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { \nList < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; \nList < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; \nMap < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; \nfor ( Connection connection : connections ) { \nString serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; \nif ( serviceStatus != null ) if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) serviceOffConnections . add ( connection ) ; \nelse serviceOnConnections . add ( connection ) ; \n} \nfilteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; \nfilteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; \nreturn filteredConnections ; \n} \n} \n"}
{"432": "public class ScheduledDisconnectStrategy { \n@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { \ntry { \nif ( null != connPools && ! connPools . isEmpty ( ) ) { \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; \nString poolKey = entry . getKey ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nList < Connection > connections = pool . getAll ( ) ; \nMap < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; \nList < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; \nList < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; \nif ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { \nConnection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; \nfreshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \nfreshSelectConnections . put ( poolKey , freshSelectConnect ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nelse { \nif ( freshSelectConnections . containsKey ( poolKey ) ) { \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nif ( logger . isInfoEnabled ( ) ) logger . info ( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\" , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; \n} \nfor ( Connection offConn : serviceOffConnections ) { \nif ( offConn . isFine ( ) ) offConn . close ( ) ; \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"ScheduledDisconnectStrategy monitor error\" , e ) ; \n} \n} \n} \n"}
{"433": "public class ScheduledDisconnectStrategy { \nprivate void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { \nif ( null != lastSelectConnect ) if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) serviceOffConnections . add ( lastSelectConnect ) ; \nelse { \nThread . sleep ( RETRY_DETECT_PERIOD ) ; \nif ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) serviceOffConnections . add ( lastSelectConnect ) ; \nelse if ( logger . isInfoEnabled ( ) ) logger . info ( \"Address={} won't close at this schedule turn\" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; \n} \n} \n} \n"}
{"435": "public class ConnectionEventHandler { \nprivate void infoLog ( String format , String addr ) { \nif ( logger . isInfoEnabled ( ) ) if ( StringUtils . isNotEmpty ( addr ) ) logger . info ( format , addr ) ; \nelse logger . info ( format , \"UNKNOWN-ADDR\" ) ; \n} \n} \n"}
{"436": "public class RemotingContext { \npublic boolean isRequestTimeout ( ) { \nif ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) return true ; \nreturn false ; \n} \n} \n"}
{"438": "public class RandomSelectStrategy { \nprivate Connection randomGet ( List < Connection > conns ) { \nif ( null == conns || conns . isEmpty ( ) ) return null ; \nint size = conns . size ( ) ; \nint tries = 0 ; \nConnection result = null ; \nwhile ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) result = conns . get ( this . random . nextInt ( size ) ) ; \nif ( result != null && ! result . isFine ( ) ) result = null ; \nreturn result ; \n} \n} \n"}
{"440": "public class Url { \npublic String getProperty ( String key ) { \nif ( properties == null ) return null ; \nreturn properties . getProperty ( key ) ; \n} \n} \n"}
{"441": "public class RpcResponseResolver { \npublic static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { \npreProcess ( responseCommand , addr ) ; \nif ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) return toResponseObject ( responseCommand ) ; \nelse { \nString msg = String . format ( \"Rpc invocation exception: %s, the address is %s, id=%s\" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; \nlogger . warn ( msg ) ; \nif ( responseCommand . getCause ( ) != null ) throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; \nelse throw new InvokeException ( msg + \", please check the server log for more.\" ) ; \n} \n} \n} \n"}
{"443": "public class RpcResponseResolver { \nprivate static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { \nRpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; \nresp . deserialize ( ) ; \nObject ex = resp . getResponseObject ( ) ; \nif ( ex != null && ex instanceof Throwable ) return ( Throwable ) ex ; \nreturn null ; \n} \n} \n"}
{"444": "public class RpcResponseResolver { \nprivate static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { \nRpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; \nif ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) return String . format ( \"%s, ServerErrorMsg:%s\" , clientErrMsg , resp . getErrorMsg ( ) ) ; \nelse return String . format ( \"%s, ServerErrorMsg:null\" , clientErrMsg ) ; \n} \n} \n"}
{"446": "public class TraceLogUtil { \npublic static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { \nString sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; \nInteger sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; \nString targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; \nInteger targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; \nStringBuilder logMsg = new StringBuilder ( ) ; \nlogMsg . append ( traceId ) . append ( \",\" ) ; \nlogMsg . append ( sourceIp ) . append ( \",\" ) ; \nlogMsg . append ( sourcePort ) . append ( \",\" ) ; \nlogMsg . append ( targetIp ) . append ( \",\" ) ; \nlogMsg . append ( targetPort ) ; \nif ( logger . isInfoEnabled ( ) ) logger . info ( logMsg . toString ( ) ) ; \n} \n} \n"}
{"448": "public class RemotingUtil { \npublic static String parseRemoteAddress ( final Channel channel ) { \nif ( null == channel ) return StringUtils . EMPTY ; \nfinal SocketAddress remote = channel . remoteAddress ( ) ; \nreturn doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; \n} \n} \n"}
{"449": "public class RemotingUtil { \npublic static String parseLocalAddress ( final Channel channel ) { \nif ( null == channel ) return StringUtils . EMPTY ; \nfinal SocketAddress local = channel . localAddress ( ) ; \nreturn doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; \n} \n} \n"}
{"450": "public class RemotingUtil { \npublic static String parseRemoteIP ( final Channel channel ) { \nif ( null == channel ) return StringUtils . EMPTY ; \nfinal InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; \nif ( remote != null ) return remote . getAddress ( ) . getHostAddress ( ) ; \nreturn StringUtils . EMPTY ; \n} \n} \n"}
{"451": "public class RemotingUtil { \npublic static String parseRemoteHostName ( final Channel channel ) { \nif ( null == channel ) return StringUtils . EMPTY ; \nfinal InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; \nif ( remote != null ) return remote . getAddress ( ) . getHostName ( ) ; \nreturn StringUtils . EMPTY ; \n} \n} \n"}
{"452": "public class RemotingUtil { \npublic static String parseLocalIP ( final Channel channel ) { \nif ( null == channel ) return StringUtils . EMPTY ; \nfinal InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; \nif ( local != null ) return local . getAddress ( ) . getHostAddress ( ) ; \nreturn StringUtils . EMPTY ; \n} \n} \n"}
{"453": "public class RemotingUtil { \npublic static int parseRemotePort ( final Channel channel ) { \nif ( null == channel ) return - 1 ; \nfinal InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; \nif ( remote != null ) return remote . getPort ( ) ; \nreturn - 1 ; \n} \n} \n"}
{"454": "public class RemotingUtil { \npublic static int parseLocalPort ( final Channel channel ) { \nif ( null == channel ) return - 1 ; \nfinal InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; \nif ( local != null ) return local . getPort ( ) ; \nreturn - 1 ; \n} \n} \n"}
{"455": "public class RemotingUtil { \npublic static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { \nfinal InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; \nif ( addrs != null ) { \nInetAddress addr = addrs . getAddress ( ) ; \nif ( null != addr ) return addr . getHostAddress ( ) ; \n} \nreturn StringUtils . EMPTY ; \n} \n} \n"}
{"456": "public class ConnectionPool { \npublic void add ( Connection connection ) { \nmarkAccess ( ) ; \nif ( null == connection ) return ; \nboolean res = this . conns . addIfAbsent ( connection ) ; \nif ( res ) connection . increaseRef ( ) ; \n} \n} \n"}
{"457": "public class ConnectionPool { \npublic void removeAndTryClose ( Connection connection ) { \nif ( null == connection ) return ; \nboolean res = this . conns . remove ( connection ) ; \nif ( res ) connection . decreaseRef ( ) ; \nif ( connection . noRef ( ) ) connection . close ( ) ; \n} \n} \n"}
{"458": "public class ConnectionPool { \npublic Connection get ( ) { \nmarkAccess ( ) ; \nif ( null != this . conns ) { \nList < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; \nif ( snapshot . size ( ) > 0 ) return this . strategy . select ( snapshot ) ; \nelse return null ; \n} \nelse return null ; \n} \n} \n"}
{"459": "public class CustomSerializerManager { \npublic static void registerCustomSerializer ( String className , CustomSerializer serializer ) { \nCustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; \nif ( prevSerializer != null ) throw new RuntimeException ( \"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer . getClass ( ) . getName ( ) ) ; \n} \n} \n"}
{"460": "public class CustomSerializerManager { \npublic static CustomSerializer getCustomSerializer ( String className ) { \nif ( ! classCustomSerializer . isEmpty ( ) ) return classCustomSerializer . get ( className ) ; \nreturn null ; \n} \n} \n"}
{"461": "public class CustomSerializerManager { \npublic static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { \nCustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; \nif ( prevSerializer != null ) throw new RuntimeException ( \"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer . getClass ( ) . getName ( ) ) ; \n} \n} \n"}
{"462": "public class CustomSerializerManager { \npublic static CustomSerializer getCustomSerializer ( CommandCode code ) { \nif ( ! commandCustomSerializer . isEmpty ( ) ) return commandCustomSerializer . get ( code ) ; \nreturn null ; \n} \n} \n"}
{"465": "public class RpcServer { \nprivate void initWriteBufferWaterMark ( ) { \nint lowWaterMark = this . netty_buffer_low_watermark ( ) ; \nint highWaterMark = this . netty_buffer_high_watermark ( ) ; \nif ( lowWaterMark > highWaterMark ) throw new IllegalArgumentException ( String . format ( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\" , highWaterMark , lowWaterMark ) ) ; \nelse logger . warn ( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\" , lowWaterMark , highWaterMark ) ; \nthis . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; \n} \n} \n"}
{"466": "public class FramedataImpl1 { \npublic static FramedataImpl1 get ( Opcode opcode ) { \nif ( opcode == null ) throw new IllegalArgumentException ( \"Supplied opcode cannot be null\" ) ; \nswitch ( opcode ) { \ncase PING : return new PingFrame ( ) ; \ncase PONG : return new PongFrame ( ) ; \ncase TEXT : return new TextFrame ( ) ; \ncase BINARY : return new BinaryFrame ( ) ; \ncase CLOSING : return new CloseFrame ( ) ; \ncase CONTINUOUS : return new ContinuousFrame ( ) ; \ndefault : throw new IllegalArgumentException ( \"Supplied opcode is invalid\" ) ; \n} \n} \n} \n"}
{"467": "public class SocketChannelIOHelper { \npublic static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { \nif ( ws == null ) return false ; \nByteBuffer buffer = ws . outQueue . peek ( ) ; \nWrappedByteChannel c = null ; \nif ( buffer == null ) if ( sockchannel instanceof WrappedByteChannel ) { \nc = ( WrappedByteChannel ) sockchannel ; \nif ( c . isNeedWrite ( ) ) c . writeMore ( ) ; \n} \nelse do { \nsockchannel . write ( buffer ) ; \nif ( buffer . remaining ( ) > 0 ) return false ; \nelse { \nws . outQueue . poll ( ) ; \nbuffer = ws . outQueue . peek ( ) ; \n} \n} \nwhile ( buffer != null ) ; \nif ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) ws . closeConnection ( ) ; \nreturn c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; \n} \n} \n"}
{"475": "public class Draft_6455 { \nprivate void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { \nif ( curop != Opcode . CONTINUOUS ) processFrameIsNotFin ( frame ) ; \nelse if ( frame . isFin ( ) ) processFrameIsFin ( webSocketImpl , frame ) ; \nelse if ( currentContinuousFrame == null ) { \nlog . error ( \"Protocol error: Continuous frame sequence was not started.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \nif ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { \nlog . error ( \"Protocol error: Payload is not UTF8\" ) ; \nthrow new InvalidDataException ( CloseFrame . NO_UTF8 ) ; \n} \nif ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) addToBufferList ( frame . getPayloadData ( ) ) ; \n} \n} \n"}
{"481": "public class Draft_6455 { \nprivate void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { \nint code = CloseFrame . NOCODE ; \nString reason = \"\" ; \nif ( frame instanceof CloseFrame ) { \nCloseFrame cf = ( CloseFrame ) frame ; \ncode = cf . getCloseCode ( ) ; \nreason = cf . getMessage ( ) ; \n} \nif ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) webSocketImpl . closeConnection ( code , reason , true ) ; \nelse if ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; \nelse webSocketImpl . flushAndClose ( code , reason , false ) ; \n} \n} \n"}
{"485": "public class Draft { \nprivate static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { \nif ( ! \"GET\" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) throw new InvalidHandshakeException ( String . format ( \"Invalid request method received: %s Status line: %s\" , firstLineTokens [ 0 ] , line ) ) ; \nif ( ! \"HTTP/1.1\" . equalsIgnoreCase ( firstLineTokens [ 2 ] ) ) throw new InvalidHandshakeException ( String . format ( \"Invalid status line received: %s Status line: %s\" , firstLineTokens [ 2 ] , line ) ) ; \nClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client ( ) ; \nclienthandshake . setResourceDescriptor ( firstLineTokens [ 1 ] ) ; \nreturn clienthandshake ; \n} \n} \n"}
{"486": "public class Draft { \nprivate static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { \nif ( ! \"101\" . equals ( firstLineTokens [ 1 ] ) ) throw new InvalidHandshakeException ( String . format ( \"Invalid status code received: %s Status line: %s\" , firstLineTokens [ 1 ] , line ) ) ; \nif ( ! \"HTTP/1.1\" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) throw new InvalidHandshakeException ( String . format ( \"Invalid status line received: %s Status line: %s\" , firstLineTokens [ 0 ] , line ) ) ; \nHandshakeBuilder handshake = new HandshakeImpl1Server ( ) ; \nServerHandshakeBuilder serverhandshake = ( ServerHandshakeBuilder ) handshake ; \nserverhandshake . setHttpStatus ( Short . parseShort ( firstLineTokens [ 1 ] ) ) ; \nserverhandshake . setHttpStatusMessage ( firstLineTokens [ 2 ] ) ; \nreturn handshake ; \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( readyState != ReadyState . NOT_YET_CONNECTED ) if ( readyState == ReadyState . OPEN ) decodeFrames ( socketBuffer ) ; \nelse if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( socketBuffer . hasRemaining ( ) ) decodeFrames ( socketBuffer ) ; \nelse if ( tmpHandshakeBytes . hasRemaining ( ) ) decodeFrames ( tmpHandshakeBytes ) ; \n} \n} \n} \n"}
{"492": "public class WebSocketClient { \nprivate void reset ( ) { \nThread current = Thread . currentThread ( ) ; \nif ( current == writeThread || current == connectReadThread ) throw new IllegalStateException ( \"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\" ) ; \ntry { \ncloseBlocking ( ) ; \nif ( writeThread != null ) { \nthis . writeThread . interrupt ( ) ; \nthis . writeThread = null ; \n} \nif ( connectReadThread != null ) { \nthis . connectReadThread . interrupt ( ) ; \nthis . connectReadThread = null ; \n} \nthis . draft . reset ( ) ; \nif ( this . socket != null ) { \nthis . socket . close ( ) ; \nthis . socket = null ; \n} \n} \ncatch ( Exception e ) { \nonError ( e ) ; \nengine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; \nreturn ; \n} \nconnectLatch = new CountDownLatch ( 1 ) ; \ncloseLatch = new CountDownLatch ( 1 ) ; \nthis . engine = new WebSocketImpl ( this , this . draft ) ; \n} \n} \n"}
{"494": "public class WebSocketClient { \nprivate int getPort ( ) { \nint port = uri . getPort ( ) ; \nif ( port == - 1 ) { \nString scheme = uri . getScheme ( ) ; \nif ( \"wss\" . equals ( scheme ) ) return WebSocketImpl . DEFAULT_WSS_PORT ; \nelse if ( \"ws\" . equals ( scheme ) ) return WebSocketImpl . DEFAULT_PORT ; \nelse throw new IllegalArgumentException ( \"unknown scheme: \" + scheme ) ; \n} \nreturn port ; \n} \n} \n"}
{"495": "public class WebSocketClient { \nprivate void sendHandshake ( ) throws InvalidHandshakeException { \nString path ; \nString part1 = uri . getRawPath ( ) ; \nString part2 = uri . getRawQuery ( ) ; \nif ( part1 == null || part1 . length ( ) == 0 ) path = \"/\" ; \nelse path = part1 ; \nif ( part2 != null ) path += '?' + part2 ; \nint port = getPort ( ) ; \nString host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? \":\" + port : \"\" ) ; \nHandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; \nhandshake . setResourceDescriptor ( path ) ; \nhandshake . put ( \"Host\" , host ) ; \nif ( headers != null ) for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { \nhandshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; \n} \nengine . startHandshake ( handshake ) ; \n} \n} \n"}
{"500": "public class AbstractWebSocket { \nprivate void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { \nif ( ! ( webSocket instanceof WebSocketImpl ) ) return ; \nWebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; \nif ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { \nlog . trace ( \"Closing connection due to no pong received: {}\" , webSocketImpl ) ; \nwebSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ) ; \n} \nelse if ( webSocketImpl . isOpen ( ) ) webSocketImpl . sendPing ( ) ; \nelse log . trace ( \"Trying to ping a non open connection: {}\" , webSocketImpl ) ; \n} \n} \n"}
{"504": "public class WebSocketServer { \npublic void stop ( int timeout ) throws InterruptedException { \nif ( ! isclosed . compareAndSet ( false , true ) ) return ; \nList < WebSocket > socketsToClose ; \nsynchronized ( connections ) { \nsocketsToClose = new ArrayList < WebSocket > ( connections ) ; \n} \nfor ( WebSocket ws : socketsToClose ) { \nws . close ( CloseFrame . GOING_AWAY ) ; \n} \nwsf . close ( ) ; \nsynchronized ( this ) { \nif ( selectorthread != null && selector != null ) { \nselector . wakeup ( ) ; \nselectorthread . join ( timeout ) ; \n} \n} \n} \n} \n"}
{"505": "public class WebSocketServer { \npublic int getPort ( ) { \nint port = getAddress ( ) . getPort ( ) ; \nif ( port == 0 && server != null ) port = server . socket ( ) . getLocalPort ( ) ; \nreturn port ; \n} \n} \n"}
{"506": "public class WebSocketServer { \nprivate void doAdditionalRead ( ) throws InterruptedException , IOException { \nWebSocketImpl conn ; \nwhile ( ! iqueue . isEmpty ( ) ) { \nconn = iqueue . remove ( 0 ) ; \nWrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; \nByteBuffer buf = takeBuffer ( ) ; \ntry { \nif ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; \nif ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \n} \nelse pushBuffer ( buf ) ; \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \n} \n} \n} \n"}
{"507": "public class WebSocketServer { \nprivate void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { \nif ( ! onConnect ( key ) ) { \nkey . cancel ( ) ; \nreturn ; \n} \nSocketChannel channel = server . accept ( ) ; \nif ( channel == null ) return ; \nchannel . configureBlocking ( false ) ; \nSocket socket = channel . socket ( ) ; \nsocket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; \nsocket . setKeepAlive ( true ) ; \nWebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; \nw . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; \ntry { \nw . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; \ni . remove ( ) ; \nallocateBuffers ( w ) ; \n} \ncatch ( IOException ex ) { \nif ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; \nhandleIOException ( w . getSelectionKey ( ) , null , ex ) ; \n} \n} \n} \n"}
{"508": "public class WebSocketServer { \nprivate boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { \nWebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; \nByteBuffer buf = takeBuffer ( ) ; \nif ( conn . getChannel ( ) == null ) { \nkey . cancel ( ) ; \nhandleIOException ( key , conn , new IOException ( ) ) ; \nreturn false ; \n} \ntry { \nif ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) if ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \ni . remove ( ) ; \nif ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) iqueue . add ( conn ) ; \n} \nelse pushBuffer ( buf ) ; \nelse pushBuffer ( buf ) ; \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \nreturn true ; \n} \n} \n"}
{"509": "public class WebSocketServer { \nprivate void doWrite ( SelectionKey key ) throws IOException { \nWebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; \nif ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) if ( key . isValid ( ) ) key . interestOps ( SelectionKey . OP_READ ) ; \n} \n} \n"}
{"511": "public class WebSocketServer { \nprivate boolean doEnsureSingleThread ( ) { \nsynchronized ( this ) { \nif ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + \" can only be started once.\" ) ; \nselectorthread = Thread . currentThread ( ) ; \nif ( isclosed . get ( ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"512": "public class WebSocketServer { \nprivate void doServerShutdown ( ) { \nstopConnectionLostTimer ( ) ; \nif ( decoders != null ) for ( WebSocketWorker w : decoders ) { \nw . interrupt ( ) ; \n} \nif ( selector != null ) try { \nselector . close ( ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"IOException during selector.close\" , e ) ; \nonError ( null , e ) ; \n} \nif ( server != null ) try { \nserver . close ( ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"IOException during server.close\" , e ) ; \nonError ( null , e ) ; \n} \n} \n} \n"}
{"514": "public class WebSocketServer { \npublic void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { \nif ( data == null || clients == null ) throw new IllegalArgumentException ( ) ; \nbroadcast ( ByteBuffer . wrap ( data ) , clients ) ; \n} \n} \n"}
{"515": "public class WebSocketServer { \npublic void broadcast ( String text , Collection < WebSocket > clients ) { \nif ( text == null || clients == null ) throw new IllegalArgumentException ( ) ; \ndoBroadcast ( text , clients ) ; \n} \n} \n"}
{"516": "public class WebSocketServer { \nprivate void doBroadcast ( Object data , Collection < WebSocket > clients ) { \nString sData = null ; \nif ( data instanceof String ) sData = ( String ) data ; \nByteBuffer bData = null ; \nif ( data instanceof ByteBuffer ) bData = ( ByteBuffer ) data ; \nif ( sData == null && bData == null ) return ; \nMap < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; \nfor ( WebSocket client : clients ) { \nif ( client != null ) { \nDraft draft = client . getDraft ( ) ; \nfillFrames ( draft , draftFrames , sData , bData ) ; \ntry { \nclient . sendFrame ( draftFrames . get ( draft ) ) ; \n} \ncatch ( WebsocketNotConnectedException e ) { \n} \n} \n} \n} \n} \n"}
{"517": "public class WebSocketServer { \nprivate void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { \nif ( ! draftFrames . containsKey ( draft ) ) { \nList < Framedata > frames = null ; \nif ( sData != null ) frames = draft . createFrames ( sData , false ) ; \nif ( bData != null ) frames = draft . createFrames ( bData , false ) ; \nif ( frames != null ) draftFrames . put ( draft , frames ) ; \n} \n} \n} \n"}
{"518": "public class ByteBufferUtils { \npublic static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { \nif ( source == null || dest == null ) throw new IllegalArgumentException ( ) ; \nint fremain = source . remaining ( ) ; \nint toremain = dest . remaining ( ) ; \nif ( fremain > toremain ) { \nint limit = Math . min ( fremain , toremain ) ; \nsource . limit ( limit ) ; \ndest . put ( source ) ; \nreturn limit ; \n} \nelse { \ndest . put ( source ) ; \nreturn fremain ; \n} \n} \n} \n"}
{"520": "public class DefaultJPAApi { \npublic EntityManager em ( String name ) { \nEntityManagerFactory emf = emfs . get ( name ) ; \nif ( emf == null ) return null ; \nreturn emf . createEntityManager ( ) ; \n} \n} \n"}
{"523": "public class MessagesApi { \n@ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { \nList < T > out ; \nif ( args != null && args . length == 1 && args [ 0 ] instanceof List ) out = ( List < T > ) args [ 0 ] ; \nelse out = Arrays . asList ( args ) ; \nreturn out ; \n} \n} \n"}
{"543": "public class F { \nprivate static Executor toExecutor ( ExecutionContext ec ) { \nExecutionContext prepared = ec . prepare ( ) ; \nif ( prepared instanceof Executor ) return ( Executor ) prepared ; \nelse return prepared :: execute ; \n} \n} \n"}
{"551": "public class MethodUtils { \npublic static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { \ntry { \nfinal Method method = cls . getMethod ( methodName , parameterTypes ) ; \nMemberUtils . setAccessibleWorkaround ( method ) ; \nreturn method ; \n} \ncatch ( final NoSuchMethodException e ) { \n} \nMethod bestMatch = null ; \nfinal Method [ ] methods = cls . getMethods ( ) ; \nfor ( final Method method : methods ) { \nif ( method . getName ( ) . equals ( methodName ) && MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { \nfinal Method accessibleMethod = getAccessibleMethod ( method ) ; \nif ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) < 0 ) ) bestMatch = accessibleMethod ; \n} \n} \nif ( bestMatch != null ) MemberUtils . setAccessibleWorkaround ( bestMatch ) ; \nif ( bestMatch != null && bestMatch . isVarArgs ( ) && bestMatch . getParameterTypes ( ) . length > 0 && parameterTypes . length > 0 ) { \nfinal Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; \nfinal Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; \nfinal String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; \nfinal String parameterTypeName = parameterTypes [ parameterTypes . length - 1 ] . getName ( ) ; \nfinal String parameterTypeSuperClassName = parameterTypes [ parameterTypes . length - 1 ] . getSuperclass ( ) . getName ( ) ; \nif ( ! methodParameterComponentTypeName . equals ( parameterTypeName ) && ! methodParameterComponentTypeName . equals ( parameterTypeSuperClassName ) ) return null ; \n} \nreturn bestMatch ; \n} \n} \n"}
{"552": "public class DefaultHttpErrorHandler { \n@ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { \nif ( statusCode == 400 ) return onBadRequest ( request , message ) ; \nelse if ( statusCode == 403 ) return onForbidden ( request , message ) ; \nelse if ( statusCode == 404 ) return onNotFound ( request , message ) ; \nelse if ( statusCode >= 400 && statusCode < 500 ) return onOtherClientError ( request , statusCode , message ) ; \nelse throw new IllegalArgumentException ( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message ) ; \n} \n} \n"}
{"555": "public class DefaultHttpErrorHandler { \nprotected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { \nif ( environment . isProd ( ) ) return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; \nelse return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; \n} \n} \n"}
{"561": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { \nassert ( files . length == baseDirs . length ) ; \nFileRepository [ ] repositories = new FileRepository [ files . length ] ; \nList < JarFile > jarFiles = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nString baseDir = baseDirs [ i ] ; \nif ( file . isDirectory ( ) ) repositories [ i ] = new FilesystemRepository ( file ) ; \nelse { \nJarFile jarFile = new JarFile ( file ) ; \njarFiles . add ( jarFile ) ; \nrepositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; \n} \n} \nreturn new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { \nfor ( JarFile jarFile : jarFiles ) { \njarFile . close ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"564": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { \nFileRepository fileRepo = new FilesystemRepository ( directory ) ; \nFileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; \nFileRepository manualRepo ; \nif ( fallbackToJar ) manualRepo = new AggregateFileRepository ( new FileRepository [ ] { \nfileRepo , jarRepo } \n) ; \nelse manualRepo = fileRepo ; \nreturn new DocumentationHandler ( manualRepo , jarRepo ) ; \n} \n} \n"}
{"567": "public class HttpEntity { \npublic static final HttpEntity fromContent ( Content content , String charset ) { \nString body ; \nif ( content instanceof Xml ) body = content . body ( ) . trim ( ) ; \nelse body = content . body ( ) ; \nreturn new Strict ( ByteString . fromString ( body , charset ) , Optional . of ( content . contentType ( ) + \"; charset=\" + charset ) ) ; \n} \n} \n"}
{"571": "public class Results { \npublic static Result status ( int status , JsonNode content , JsonEncoding encoding ) { \nif ( content == null ) throw new NullPointerException ( \"Null content\" ) ; \nreturn status ( status ) . sendJson ( content , encoding ) ; \n} \n} \n"}
{"572": "public class Results { \npublic static Result status ( int status , byte [ ] content ) { \nif ( content == null ) throw new NullPointerException ( \"Null content\" ) ; \nreturn new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; \n} \n} \n"}
{"588": "public class Paths { \npublic static String relative ( String startPath , String targetPath ) { \nif ( startPath . equals ( targetPath ) ) return CURRENT_DIR ; \nString [ ] start = toSegments ( canonical ( startPath ) ) ; \nString [ ] target = toSegments ( canonical ( targetPath ) ) ; \nif ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; \nString targetFile = \"\" ; \nif ( ! targetPath . endsWith ( SEPARATOR ) ) { \ntargetFile = target [ target . length - 1 ] ; \ntarget = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; \n} \nString [ ] common = commonPrefix ( start , target ) ; \nString [ ] parents = toParentDirs ( start . length - common . length ) ; \nint relativeStartIdx = common . length ; \nString [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; \nString [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; \nSystem . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; \nString trailingSep = \"\" ; \nif ( relativePath . length > 0 ) trailingSep = SEPARATOR ; \nreturn Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; \n} \n} \n"}
{"593": "public class ClassUtils { \npublic static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { \nif ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) return false ; \nif ( classArray == null ) classArray = EMPTY_CLASS_ARRAY ; \nif ( toClassArray == null ) toClassArray = EMPTY_CLASS_ARRAY ; \nfor ( int i = 0 ; \ni < classArray . length ; \ni ++ ) if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) return false ; \nreturn true ; \n} \n} \n"}
{"620": "public class ClientCookieEncoder { \npublic String encode ( Cookie cookie ) { \nif ( cookie == null ) throw new NullPointerException ( \"cookie\" ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nencode ( buf , cookie ) ; \nreturn stripTrailingSeparator ( buf ) ; \n} \n} \n"}
{"621": "public class JPAEntityManagerContext { \npublic EntityManager em ( ) { \nDeque < EntityManager > ems = this . emStack ( true ) ; \nif ( ems . isEmpty ( ) ) Http . Context . safeCurrent ( ) . map ( ctx -> { \nthrow new RuntimeException ( \"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\" ) ; \n} \n) . orElseGet ( ( ) -> { \nthrow new RuntimeException ( \"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\" ) ; \n} \n) ; \nreturn ems . peekFirst ( ) ; \n} \n} \n"}
{"622": "public class JPAEntityManagerContext { \n@ SuppressWarnings ( \"unchecked\" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { \nreturn Http . Context . safeCurrent ( ) . map ( context -> { \nObject emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; \nif ( emsObject != null ) return ( Deque < EntityManager > ) emsObject ; \nelse { \nDeque < EntityManager > ems = new ArrayDeque < > ( ) ; \ncontext . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; \nreturn ems ; \n} \n} \n) . orElseGet ( ( ) -> { \nif ( threadLocalFallback ) return this . get ( ) ; \nelse throw new RuntimeException ( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\" ) ; \n} \n) ; \n} \n} \n"}
{"623": "public class JPAEntityManagerContext { \nvoid pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { \nDeque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; \nif ( em != null ) ems . push ( em ) ; \nelse { \nif ( ems . isEmpty ( ) ) throw new IllegalStateException ( \"Tried to remove the EntityManager, but none was set.\" ) ; \nems . pop ( ) ; \n} \n} \n} \n"}
{"625": "public class AkkaStreams { \npublic static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { \nreturn splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> { \nUniformFanOutShape < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > > broadcast = builder . add ( Broadcast . create ( 2 , true ) ) ; \nUniformFanInShape < Out , Out > merge = builder . add ( mergeStrategy ) ; \nFlow < F . Either < FlowIn , Out > , FlowIn , ? > collectIn = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { \nif ( x . left . isPresent ( ) ) return x . left . get ( ) ; \nelse throw Scala . noMatch ( ) ; \n} \n) ) ; \nFlow < F . Either < FlowIn , Out > , Out , ? > collectOut = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { \nif ( x . right . isPresent ( ) ) return x . right . get ( ) ; \nelse throw Scala . noMatch ( ) ; \n} \n) ) ; \nFlow < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > , ? > blockCancel = play . api . libs . streams . AkkaStreams . < F . Either < FlowIn , Out > > ignoreAfterCancellation ( ) . asJava ( ) ; \nbuilder . from ( broadcast . out ( 0 ) ) . via ( builder . add ( collectIn ) ) . via ( builder . add ( flow ) ) . toInlet ( merge . in ( 0 ) ) ; \nbuilder . from ( broadcast . out ( 1 ) ) . via ( builder . add ( blockCancel ) ) . via ( builder . add ( collectOut ) ) . toInlet ( merge . in ( 1 ) ) ; \nreturn new FlowShape < > ( broadcast . in ( ) , merge . out ( ) ) ; \n} \n) ) ) ; \n} \n} \n"}
{"627": "public class Form { \nprivate List < Object > convertErrorArguments ( Object [ ] arguments ) { \nif ( arguments == null ) return Collections . emptyList ( ) ; \nList < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; \nreturn Collections . unmodifiableList ( converted ) ; \n} \n} \n"}
{"628": "public class Form { \npublic Form < T > fill ( T value ) { \nif ( value == null ) throw new RuntimeException ( \"Cannot fill a form with a null value\" ) ; \nreturn new Form < > ( rootName , backedType , new HashMap < > ( ) , new HashMap < > ( ) , new ArrayList < > ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; \n} \n} \n"}
{"630": "public class Form { \npublic JsonNode errorsAsJson ( Lang lang ) { \nMap < String , List < String > > allMessages = new HashMap < > ( ) ; \nerrors . forEach ( error -> { \nif ( error != null ) { \nfinal List < String > messages = new ArrayList < > ( ) ; \nif ( messagesApi != null && lang != null ) { \nfinal List < String > reversedMessages = new ArrayList < > ( error . messages ( ) ) ; \nCollections . reverse ( reversedMessages ) ; \nmessages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; \n} \nelse messages . add ( error . message ( ) ) ; \nallMessages . put ( error . key ( ) , messages ) ; \n} \n} \n) ; \nreturn play . libs . Json . toJson ( allMessages ) ; \n} \n} \n"}
{"635": "public class Formatters { \npublic < T > String print ( T t ) { \nif ( t == null ) return \"\" ; \nif ( conversion . canConvert ( t . getClass ( ) , String . class ) ) return conversion . convert ( t , String . class ) ; \nelse return t . toString ( ) ; \n} \n} \n"}
{"637": "public class Formatters { \npublic < T > String print ( TypeDescriptor desc , T t ) { \nif ( t == null ) return \"\" ; \nif ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; \nelse if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) return conversion . convert ( t , String . class ) ; \nelse return t . toString ( ) ; \n} \n} \n"}
{"641": "public class ServerCookieEncoder { \npublic String encode ( Cookie cookie ) { \nif ( cookie == null ) throw new NullPointerException ( \"cookie\" ) ; \nfinal String name = cookie . name ( ) ; \nfinal String value = cookie . value ( ) != null ? cookie . value ( ) : \"\" ; \nvalidateCookie ( name , value ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nif ( cookie . wrap ( ) ) addQuoted ( buf , name , value ) ; \nelse add ( buf , name , value ) ; \nif ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { \nadd ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; \nDate expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 ) : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; \nadd ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; \n} \nif ( cookie . sameSite ( ) != null ) add ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; \nif ( cookie . path ( ) != null ) add ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; \nif ( cookie . domain ( ) != null ) add ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; \nif ( cookie . isSecure ( ) ) add ( buf , CookieHeaderNames . SECURE ) ; \nif ( cookie . isHttpOnly ( ) ) add ( buf , CookieHeaderNames . HTTPONLY ) ; \nreturn stripTrailingSeparator ( buf ) ; \n} \n} \n"}
{"646": "public class WebSocket { \npublic static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { \nreturn new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { \ntry { \nif ( message instanceof Message . Binary ) return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; \nelse if ( message instanceof Message . Text ) return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; \n} \ncatch ( Exception e ) { \nreturn F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; \n} \nthrow Scala . noMatch ( ) ; \n} \n) , outMessage -> { \ntry { \nreturn new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n) ; \n} \n} \n"}
{"647": "public class WebSocket { \nprivate static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { \nreturn new WebSocket ( ) { \n@ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { \nreturn f . apply ( request ) . thenApply ( resultOrFlow -> { \nif ( resultOrFlow . left . isPresent ( ) ) return F . Either . Left ( resultOrFlow . left . get ( ) ) ; \nelse { \nFlow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; \nreturn F . Either . Right ( flow ) ; \n} \n} \n) ; \n} \n} \n; \n} \n} \n"}
{"648": "public class MemberUtils { \nstatic boolean setAccessibleWorkaround ( final AccessibleObject o ) { \nif ( o == null || o . isAccessible ( ) ) return false ; \nfinal Member m = ( Member ) o ; \nif ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) try { \no . setAccessible ( true ) ; \nreturn true ; \n} \ncatch ( final SecurityException e ) { \n} \nreturn false ; \n} \n} \n"}
{"649": "public class MemberUtils { \nprivate static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { \nfloat cost = 0.0f ; \nClass < ? > cls = srcClass ; \nif ( ! cls . isPrimitive ( ) ) { \ncost += 0.1f ; \ncls = ClassUtils . wrapperToPrimitive ( cls ) ; \n} \nfor ( int i = 0 ; \ncls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; \ni ++ ) if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { \ncost += 0.1f ; \nif ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) cls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; \n} \nreturn cost ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) return Float . MAX_VALUE ; \nfor ( int i = 0 ; \ni < normalArgsLen ; \ni ++ ) totalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) totalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \nelse if ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse for ( int i = destArgs . length - 1 ; \ni < srcArgs . length ; \ni ++ ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"651": "public class MemberUtils { \nprivate static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { \nif ( destClass . isPrimitive ( ) ) return getPrimitivePromotionCost ( srcClass , destClass ) ; \nfloat cost = 0.0f ; \nwhile ( srcClass != null && ! destClass . equals ( srcClass ) ) { \nif ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { \ncost += 0.25f ; \nbreak ; \n} \ncost ++ ; \nsrcClass = srcClass . getSuperclass ( ) ; \n} \nif ( srcClass == null ) cost += 1.5f ; \nreturn cost ; \n} \n} \n"}
{"659": "public class CodeEmitter { \npublic void cast_numeric ( Type from , Type to ) { \nif ( from != to ) if ( from == Type . DOUBLE_TYPE ) if ( to == Type . FLOAT_TYPE ) mv . visitInsn ( Constants . D2F ) ; \nelse if ( to == Type . LONG_TYPE ) mv . visitInsn ( Constants . D2L ) ; \nelse { \nmv . visitInsn ( Constants . D2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \nelse if ( from == Type . FLOAT_TYPE ) if ( to == Type . DOUBLE_TYPE ) mv . visitInsn ( Constants . F2D ) ; \nelse if ( to == Type . LONG_TYPE ) mv . visitInsn ( Constants . F2L ) ; \nelse { \nmv . visitInsn ( Constants . F2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \nelse if ( from == Type . LONG_TYPE ) if ( to == Type . DOUBLE_TYPE ) mv . visitInsn ( Constants . L2D ) ; \nelse if ( to == Type . FLOAT_TYPE ) mv . visitInsn ( Constants . L2F ) ; \nelse { \nmv . visitInsn ( Constants . L2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \nelse if ( to == Type . BYTE_TYPE ) mv . visitInsn ( Constants . I2B ) ; \nelse if ( to == Type . CHAR_TYPE ) mv . visitInsn ( Constants . I2C ) ; \nelse if ( to == Type . DOUBLE_TYPE ) mv . visitInsn ( Constants . I2D ) ; \nelse if ( to == Type . FLOAT_TYPE ) mv . visitInsn ( Constants . I2F ) ; \nelse if ( to == Type . LONG_TYPE ) mv . visitInsn ( Constants . I2L ) ; \nelse if ( to == Type . SHORT_TYPE ) mv . visitInsn ( Constants . I2S ) ; \n} \n} \n"}
{"662": "public class CodeEmitter { \npublic void zero_or_null ( Type type ) { \nif ( TypeUtils . isPrimitive ( type ) ) switch ( type . getSort ( ) ) { \ncase Type . DOUBLE : push ( 0d ) ; \nbreak ; \ncase Type . LONG : push ( 0L ) ; \nbreak ; \ncase Type . FLOAT : push ( 0f ) ; \nbreak ; \ncase Type . VOID : aconst_null ( ) ; \ndefault : push ( 0 ) ; \n} \nelse aconst_null ( ) ; \n} \n} \n"}
{"663": "public class CodeEmitter { \npublic void unbox_or_zero ( Type type ) { \nif ( TypeUtils . isPrimitive ( type ) ) if ( type != Type . VOID_TYPE ) { \nLabel nonNull = make_label ( ) ; \nLabel end = make_label ( ) ; \ndup ( ) ; \nifnonnull ( nonNull ) ; \npop ( ) ; \nzero_or_null ( type ) ; \ngoTo ( end ) ; \nmark ( nonNull ) ; \nunbox ( type ) ; \nmark ( end ) ; \n} \nelse checkcast ( type ) ; \n} \n} \n"}
{"666": "public class BridgeMethodResolver { \npublic Map resolveAll ( ) { \nMap resolved = new HashMap ( ) ; \nfor ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; \nentryIter . hasNext ( ) ; \n) { \nMap . Entry entry = ( Map . Entry ) entryIter . next ( ) ; \nClass owner = ( Class ) entry . getKey ( ) ; \nSet bridges = ( Set ) entry . getValue ( ) ; \ntry { \nInputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( '.' , '/' ) + \".class\" ) ; \nif ( is == null ) return resolved ; \ntry { \nnew ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; \n} \nfinally { \nis . close ( ) ; \n} \n} \ncatch ( IOException ignored ) { \n} \n} \nreturn resolved ; \n} \n} \n"}
{"669": "public class BeanGenerator { \npublic void setSuperclass ( Class superclass ) { \nif ( superclass != null && superclass . equals ( Object . class ) ) superclass = null ; \nthis . superclass = superclass ; \n} \n} \n"}
{"675": "public class PathUtil { \npublic static Path resolve ( final Path base , String child ) { \nif ( StringUtil . startsWithChar ( child , File . separatorChar ) ) child = child . substring ( 1 ) ; \nreturn base . resolve ( child ) ; \n} \n} \n"}
{"677": "public class HttpRequest { \npublic HttpRequest host ( final String host ) { \nthis . host = host ; \nif ( headers . contains ( HEADER_HOST ) ) headerOverwrite ( HEADER_HOST , host ) ; \nreturn this ; \n} \n} \n"}
{"688": "public class HttpRequest { \npublic HttpRequest path ( String path ) { \nif ( ! path . startsWith ( StringPool . SLASH ) ) path = StringPool . SLASH + path ; \nint ndx = path . indexOf ( '?' ) ; \nif ( ndx != - 1 ) { \nString queryString = path . substring ( ndx + 1 ) ; \npath = path . substring ( 0 , ndx ) ; \nquery = HttpUtil . parseQuery ( queryString , true ) ; \n} \nelse query = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nthis . path = path ; \nreturn this ; \n} \n} \n"}
{"689": "public class HttpRequest { \npublic HttpRequest cookies ( final Cookie ... cookies ) { \nif ( cookies . length == 0 ) return this ; \nStringBuilder cookieString = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( Cookie cookie : cookies ) { \nInteger maxAge = cookie . getMaxAge ( ) ; \nif ( maxAge != null && maxAge . intValue ( ) == 0 ) continue ; \nif ( ! first ) cookieString . append ( \"; \" ) ; \nfirst = false ; \ncookieString . append ( cookie . getName ( ) ) ; \ncookieString . append ( '=' ) ; \ncookieString . append ( cookie . getValue ( ) ) ; \n} \nheaderOverwrite ( \"cookie\" , cookieString . toString ( ) ) ; \nreturn this ; \n} \n} \n"}
{"693": "public class HttpRequest { \npublic String queryString ( ) { \nif ( query == null ) return StringPool . EMPTY ; \nreturn HttpUtil . buildQuery ( query , queryEncoding ) ; \n} \n} \n"}
{"694": "public class HttpRequest { \npublic String hostUrl ( ) { \nStringBand url = new StringBand ( 8 ) ; \nif ( protocol != null ) { \nurl . append ( protocol ) ; \nurl . append ( \"://\" ) ; \n} \nif ( host != null ) url . append ( host ) ; \nif ( port != Defaults . DEFAULT_PORT ) { \nurl . append ( ':' ) ; \nurl . append ( port ) ; \n} \nreturn url . toString ( ) ; \n} \n} \n"}
{"696": "public class HttpRequest { \npublic HttpRequest setHostHeader ( ) { \nString hostPort = this . host ; \nif ( port != Defaults . DEFAULT_PORT ) hostPort += StringPool . COLON + port ; \nheaderOverwrite ( HEADER_HOST , hostPort ) ; \nreturn this ; \n} \n} \n"}
{"697": "public class HttpRequest { \n@ Override protected Buffer buffer ( final boolean fullRequest ) { \nif ( header ( HEADER_HOST ) == null ) setHostHeader ( ) ; \nBuffer formBuffer = formBuffer ( ) ; \nString queryString = queryString ( ) ; \nif ( header ( \"User-Agent\" ) == null ) header ( \"User-Agent\" , Defaults . userAgent ) ; \nif ( method . equals ( \"POST\" ) && ( contentLength ( ) == null ) ) contentLength ( 0 ) ; \nBuffer request = new Buffer ( ) ; \nrequest . append ( method ) . append ( SPACE ) . append ( path ) ; \nif ( query != null && ! query . isEmpty ( ) ) { \nrequest . append ( '?' ) ; \nrequest . append ( queryString ) ; \n} \nrequest . append ( SPACE ) . append ( httpVersion ) . append ( CRLF ) ; \npopulateHeaderAndBody ( request , formBuffer , fullRequest ) ; \nreturn request ; \n} \n} \n"}
{"699": "public class Handler { \nstatic Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { \nif ( firstHandler == null ) return null ; \nelse firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; \nint handlerStart = firstHandler . startPc . bytecodeOffset ; \nint handlerEnd = firstHandler . endPc . bytecodeOffset ; \nint rangeStart = start . bytecodeOffset ; \nint rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; \nif ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) return firstHandler ; \nif ( rangeStart <= handlerStart ) if ( rangeEnd >= handlerEnd ) return firstHandler . nextHandler ; \nelse return new Handler ( firstHandler , end , firstHandler . endPc ) ; \nelse if ( rangeEnd >= handlerEnd ) return new Handler ( firstHandler , firstHandler . startPc , start ) ; \nelse { \nfirstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \n} \n} \n"}
{"705": "public class BeanUtilBean { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { \nSetter setter = bp . getSetter ( isDeclared ) ; \nif ( setter != null ) { \ninvokeSetter ( setter , bp , value ) ; \nreturn ; \n} \nif ( bp . isMap ( ) ) { \n( ( Map ) bp . bean ) . put ( bp . name , value ) ; \nreturn ; \n} \nif ( isSilent ) return ; \nthrow new BeanException ( \"Simple property not found: \" + bp . name , bp ) ; \n} \n} \n"}
{"706": "public class BeanUtilBean { \n@ Override public < T > T getProperty ( final Object bean , final String name ) { \nBeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; \nif ( ! isSilent ) { \nresolveNestedProperties ( beanProperty ) ; \nreturn ( T ) getIndexProperty ( beanProperty ) ; \n} \nelse try { \nresolveNestedProperties ( beanProperty ) ; \nreturn ( T ) getIndexProperty ( beanProperty ) ; \n} \ncatch ( Exception ignore ) { \nreturn null ; \n} \n} \n} \n"}
{"707": "public class BeanUtilBean { \n@ Override public String extractThisReference ( final String propertyName ) { \nint ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; \nif ( ndx == - 1 ) return propertyName ; \nreturn propertyName . substring ( 0 , ndx ) ; \n} \n} \n"}
{"709": "public class TemplateData { \npublic void setObjectReference ( final String name , final Object object ) { \nif ( objectRefs == null ) objectRefs = new HashMap < > ( ) ; \nobjectRefs . put ( name , object ) ; \n} \n} \n"}
{"710": "public class TemplateData { \npublic Object getObjectReference ( final String name ) { \nif ( objectRefs == null ) return null ; \nreturn objectRefs . get ( name ) ; \n} \n} \n"}
{"711": "public class TemplateData { \npublic Object lookupObject ( final String ref ) { \nObject value = getObjectReference ( ref ) ; \nif ( value == null ) throw new DbSqlBuilderException ( \"Invalid object reference: \" + ref ) ; \nreturn value ; \n} \n} \n"}
{"712": "public class TemplateData { \npublic DbEntityDescriptor getTableDescriptor ( final String tableRef ) { \nif ( tableRefs == null ) return null ; \nTableRefData t = tableRefs . get ( tableRef ) ; \nreturn t == null ? null : t . desc ; \n} \n} \n"}
{"713": "public class TemplateData { \npublic DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { \nfor ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { \nDbEntityDescriptor ded = entry . getValue ( ) . desc ; \nif ( ded . findByPropertyName ( columnRef ) != null ) return ded ; \n} \nreturn null ; \n} \n} \n"}
{"714": "public class TemplateData { \npublic String getTableAlias ( final String tableRef ) { \nif ( tableRefs == null ) return null ; \nTableRefData t = tableRefs . get ( tableRef ) ; \nreturn t == null ? null : t . alias ; \n} \n} \n"}
{"715": "public class TemplateData { \npublic void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { \nif ( tableRefs == null ) tableRefs = new HashMap < > ( ) ; \nTableRefData t = new TableRefData ( ded , tableAlias ) ; \nif ( tableRefs . put ( tableReference , t ) != null ) throw new DbSqlBuilderException ( \"Duplicated table reference: \" + tableReference ) ; \n} \n} \n"}
{"716": "public class TemplateData { \nprotected DbEntityDescriptor lookupTableRef ( final String tableRef ) { \nDbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; \nif ( ded == null ) throw new DbSqlBuilderException ( \"Table reference not used in this query: \" + tableRef ) ; \nreturn ded ; \n} \n} \n"}
{"717": "public class TemplateData { \npublic void registerHint ( final String hint ) { \nif ( hints == null ) hints = new ArrayList < > ( hintCount ) ; \nhints . add ( hint ) ; \n} \n} \n"}
{"718": "public class ValueJsonSerializer { \n@ Override public final boolean serialize ( final JsonContext jsonContext , final T value ) { \nif ( jsonContext . pushValue ( value ) ) return false ; \nserializeValue ( jsonContext , value ) ; \njsonContext . popValue ( ) ; \nreturn true ; \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) continue ; \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) for ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) return ; \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) return ; \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) continue ; \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) for ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) paramValues [ j ] = null ; \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"722": "public class ColumnNamingStrategy { \npublic String convertPropertyNameToColumnName ( final String propertyName ) { \nStringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; \nif ( splitCamelCase ) { \nString convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; \ntableName . append ( convertedTableName ) ; \n} \nelse tableName . append ( propertyName ) ; \nif ( ! changeCase ) return tableName . toString ( ) ; \nreturn uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; \n} \n} \n"}
{"723": "public class ColumnNamingStrategy { \npublic String convertColumnNameToPropertyName ( final String columnName ) { \nStringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; \nint len = columnName . length ( ) ; \nif ( splitCamelCase ) { \nboolean toUpper = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = columnName . charAt ( i ) ; \nif ( c == separatorChar ) { \ntoUpper = true ; \ncontinue ; \n} \nif ( toUpper ) { \npropertyName . append ( Character . toUpperCase ( c ) ) ; \ntoUpper = false ; \n} \nelse propertyName . append ( Character . toLowerCase ( c ) ) ; \n} \nreturn propertyName . toString ( ) ; \n} \nreturn columnName ; \n} \n} \n"}
{"726": "public class SqlType { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { \nif ( t == null ) return null ; \nif ( destinationType == null ) return ( E ) t ; \nreturn TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; \n} \n} \n"}
{"730": "public class FileNameUtil { \npublic static String separatorsToSystem ( final String path ) { \nif ( path == null ) return null ; \nif ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) return separatorsToWindows ( path ) ; \nelse return separatorsToUnix ( path ) ; \n} \n} \n"}
{"731": "public class FileNameUtil { \nprivate static String doGetPath ( final String filename , final int separatorAdd ) { \nif ( filename == null ) return null ; \nint prefix = getPrefixLength ( filename ) ; \nif ( prefix < 0 ) return null ; \nint index = indexOfLastSeparator ( filename ) ; \nint endIndex = index + separatorAdd ; \nif ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) return StringPool . EMPTY ; \nreturn filename . substring ( prefix , endIndex ) ; \n} \n} \n"}
{"732": "public class FileNameUtil { \npublic static String [ ] split ( final String filename ) { \nString prefix = getPrefix ( filename ) ; \nif ( prefix == null ) prefix = StringPool . EMPTY ; \nint lastSeparatorIndex = indexOfLastSeparator ( filename ) ; \nint lastExtensionIndex = indexOfExtension ( filename ) ; \nString path ; \nString baseName ; \nString extension ; \nif ( lastSeparatorIndex == - 1 ) { \npath = StringPool . EMPTY ; \nif ( lastExtensionIndex == - 1 ) { \nbaseName = filename . substring ( prefix . length ( ) ) ; \nextension = StringPool . EMPTY ; \n} \nelse { \nbaseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; \nextension = filename . substring ( lastExtensionIndex + 1 ) ; \n} \n} \nelse { \npath = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; \nif ( lastExtensionIndex == - 1 ) { \nbaseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; \nextension = StringPool . EMPTY ; \n} \nelse { \nbaseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; \nextension = filename . substring ( lastExtensionIndex + 1 ) ; \n} \n} \nreturn new String [ ] { \nprefix , path , baseName , extension } \n; \n} \n} \n"}
{"738": "public class WebApp { \nprotected void registerMadvocComponents ( ) { \nif ( madvocContainer == null ) throw new MadvocException ( \"Madvoc WebApp not initialized.\" ) ; \nlog . debug ( \"Registering Madvoc WebApp components\" ) ; \nmadvocContainer . registerComponent ( MadvocEncoding . class ) ; \nmadvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; \nmadvocContainer . registerComponent ( ActionConfigManager . class ) ; \nmadvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; \nmadvocContainer . registerComponent ( ActionMethodParser . class ) ; \nmadvocContainer . registerComponent ( ActionPathRewriter . class ) ; \nmadvocContainer . registerComponent ( ActionsManager . class ) ; \nmadvocContainer . registerComponent ( ContextInjectorComponent . class ) ; \nmadvocContainer . registerComponent ( InterceptorsManager . class ) ; \nmadvocContainer . registerComponent ( FiltersManager . class ) ; \nmadvocContainer . registerComponent ( MadvocController . class ) ; \nmadvocContainer . registerComponent ( RootPackages . class ) ; \nmadvocContainer . registerComponent ( ResultsManager . class ) ; \nmadvocContainer . registerComponent ( ResultMapper . class ) ; \nmadvocContainer . registerComponent ( ScopeResolver . class ) ; \nmadvocContainer . registerComponent ( ScopeDataInspector . class ) ; \nmadvocContainer . registerComponent ( AsyncActionExecutor . class ) ; \nmadvocContainer . registerComponent ( FileUploader . class ) ; \n} \n} \n"}
{"743": "public class ClassScanner { \nprotected void scanJarFile ( final File file ) { \nfinal ZipFile zipFile ; \ntry { \nzipFile = new ZipFile ( file ) ; \n} \ncatch ( IOException ioex ) { \nif ( ! ignoreException ) throw new FindFileException ( \"Invalid zip: \" + file . getName ( ) , ioex ) ; \nreturn ; \n} \nfinal Enumeration entries = zipFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nfinal ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; \nfinal String zipEntryName = zipEntry . getName ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { \nfinal String entryName = prepareEntryName ( zipEntryName , true ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \nelse if ( includeResources ) { \nfinal String entryName = prepareEntryName ( zipEntryName , false ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nZipUtil . close ( zipFile ) ; \nthrow rex ; \n} \n} \n} \nZipUtil . close ( zipFile ) ; \n} \n} \n"}
{"744": "public class ClassScanner { \nprotected void scanClassPath ( final File root ) { \nString rootPath = root . getAbsolutePath ( ) ; \nif ( ! rootPath . endsWith ( File . separator ) ) rootPath += File . separatorChar ; \nfinal FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; \nFile file ; \nwhile ( ( file = ff . nextFile ( ) ) != null ) { \nfinal String filePath = file . getAbsolutePath ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) scanClassFile ( filePath , rootPath , file , true ) ; \nelse if ( includeResources ) scanClassFile ( filePath , rootPath , file , false ) ; \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) throw rex ; \n} \n} \n} \n} \n"}
{"747": "public class ClassScanner { \npublic void start ( ) { \nif ( detectEntriesMode ) rulesEntries . detectMode ( ) ; \nfilesToScan . forEach ( file -> { \nfinal String path = file . getAbsolutePath ( ) ; \nif ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { \nif ( ! acceptJar ( file ) ) return ; \nscanJarFile ( file ) ; \n} \nelse if ( file . isDirectory ( ) ) scanClassPath ( file ) ; \n} \n) ; \n} \n} \n"}
{"749": "public class ScopeResolver { \n@ SuppressWarnings ( \"unchecked\" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { \nif ( scopeClass == null ) return ( S ) getOrInitScope ( RequestScope . class ) ; \nreturn ( S ) getOrInitScope ( scopeClass ) ; \n} \n} \n"}
{"750": "public class ScopeResolver { \nprotected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { \nfor ( final MadvocScope s : allScopes ) { \nif ( s . getClass ( ) . equals ( madvocScopeType ) ) return s ; \n} \nfinal MadvocScope newScope ; \ntry { \nnewScope = madpc . createBean ( madvocScopeType ) ; \n} \ncatch ( Exception ex ) { \nthrow new MadvocException ( \"Unable to create scope: \" + madvocScopeType , ex ) ; \n} \nallScopes . add ( newScope ) ; \nreturn newScope ; \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nint length = arr . length ; \nif ( length == 0 ) return new byte [ 0 ] ; \nint sndx = 0 , endx = length - 1 ; \nint pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nint cnt = endx - sndx + 1 ; \nint sepCnt = length > 76 ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nint len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nint d = 0 ; \nfor ( int cc = 0 , eLen = ( len / 3 ) * 3 ; \nd < eLen ; \n) { \nint i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; \ndest [ d ++ ] = ( byte ) ( i >> 16 ) ; \ndest [ d ++ ] = ( byte ) ( i >> 8 ) ; \ndest [ d ++ ] = ( byte ) i ; \nif ( sepCnt > 0 && ++ cc == 19 ) { \nsndx += 2 ; \ncc = 0 ; \n} \n} \nif ( d < len ) { \nint i = 0 ; \nfor ( int j = 0 ; \nsndx <= endx - pad ; \nj ++ ) i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; \nfor ( int r = 16 ; \nd < len ; \nr -= 8 ) dest [ d ++ ] = ( byte ) ( i >> r ) ; \n} \nreturn dest ; \n} \n} \n"}
{"754": "public class CsrfShield { \nprotected static void assureSize ( final Set < Token > tokenSet ) { \nif ( tokenSet . size ( ) < maxTokensPerSession ) return ; \nlong validUntilMin = Long . MAX_VALUE ; \nToken tokenToRemove = null ; \nIterator < Token > iterator = tokenSet . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nToken token = iterator . next ( ) ; \nif ( token . isExpired ( ) ) { \niterator . remove ( ) ; \ncontinue ; \n} \nif ( token . validUntil < validUntilMin ) { \nvalidUntilMin = token . validUntil ; \ntokenToRemove = token ; \n} \n} \nif ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) tokenSet . remove ( tokenToRemove ) ; \n} \n} \n"}
{"755": "public class CsrfShield { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { \nSet < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; \nif ( ( tokenSet == null ) && ( tokenValue == null ) ) return true ; \nif ( ( tokenSet == null ) || ( tokenValue == null ) ) return false ; \nboolean found = false ; \nIterator < Token > it = tokenSet . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nToken t = it . next ( ) ; \nif ( t . isExpired ( ) ) { \nit . remove ( ) ; \ncontinue ; \n} \nif ( t . getValue ( ) . equals ( tokenValue ) ) { \nit . remove ( ) ; \nfound = true ; \n} \n} \nreturn found ; \n} \n} \n"}
{"758": "public class BeanCopy { \n@ Override protected boolean visitProperty ( String name , final Object value ) { \nif ( isTargetMap ) name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; \nbeanUtil . setProperty ( destination , name , value ) ; \nreturn true ; \n} \n} \n"}
{"759": "public class TableChunk { \n@ Override public void init ( final TemplateData templateData ) { \nsuper . init ( templateData ) ; \nif ( entity != null ) ded = lookupType ( entity ) ; \nelse { \nObject object = templateData . getObjectReference ( entityName ) ; \nif ( object != null ) ded = lookupType ( resolveClass ( object ) ) ; \nelse ded = lookupName ( entityName ) ; \n} \nString tableReference = this . tableReference ; \nif ( tableReference == null ) tableReference = tableAlias ; \nif ( tableReference == null ) tableReference = entityName ; \nif ( tableReference == null ) tableReference = ded . getEntityName ( ) ; \ntemplateData . registerTableReference ( tableReference , ded , tableAlias ) ; \n} \n} \n"}
{"761": "public class PetiteBeans { \npublic < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { \nif ( name == null ) name = resolveBeanName ( type ) ; \nif ( wiringMode == null ) wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; \nif ( wiringMode == WiringMode . DEFAULT ) wiringMode = petiteConfig . getDefaultWiringMode ( ) ; \nif ( scopeType == null ) scopeType = annotationResolver . resolveBeanScopeType ( type ) ; \nif ( scopeType == null ) scopeType = SingletonScope . class ; \nBeanDefinition existing = removeBean ( name ) ; \nif ( existing != null ) if ( petiteConfig . getDetectDuplicatedBeanNames ( ) ) throw new PetiteException ( \"Duplicated bean name detected while registering class '\" + type . getName ( ) + \"'. Petite bean class '\" + existing . type . getName ( ) + \"' is already registered with the name: \" + name ) ; \nif ( type . isInterface ( ) ) throw new PetiteException ( \"PetiteBean can not be an interface: \" + type . getName ( ) ) ; \nif ( log . isDebugEnabled ( ) ) log . info ( \"Petite bean: [\" + name + \"] --> \" + type . getName ( ) + \" @ \" + scopeType . getSimpleName ( ) + \":\" + wiringMode . toString ( ) ) ; \nScope scope = resolveScope ( scopeType ) ; \nBeanDefinition < T > beanDefinition = createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; \nregisterBean ( name , beanDefinition ) ; \nProviderDefinition [ ] providerDefinitions = petiteResolvers . resolveProviderDefinitions ( type , name ) ; \nif ( providerDefinitions != null ) for ( ProviderDefinition providerDefinition : providerDefinitions ) { \nproviders . put ( providerDefinition . name , providerDefinition ) ; \n} \nif ( define ) { \nbeanDefinition . ctor = petiteResolvers . resolveCtorInjectionPoint ( beanDefinition . type ( ) ) ; \nbeanDefinition . properties = PropertyInjectionPoint . EMPTY ; \nbeanDefinition . methods = MethodInjectionPoint . EMPTY ; \nbeanDefinition . initMethods = InitMethodPoint . EMPTY ; \nbeanDefinition . destroyMethods = DestroyMethodPoint . EMPTY ; \n} \nreturn beanDefinition ; \n} \n} \n"}
{"762": "public class PetiteBeans { \nprotected void registerBean ( final String name , final BeanDefinition beanDefinition ) { \nbeans . put ( name , beanDefinition ) ; \nif ( ! petiteConfig . isUseAltBeanNames ( ) ) return ; \nClass type = beanDefinition . type ( ) ; \nif ( annotationResolver . beanHasAnnotationName ( type ) ) return ; \nClass [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; \nfor ( Class anInterface : interfaces ) { \nString altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; \nif ( name . equals ( altName ) ) continue ; \nif ( beans . containsKey ( altName ) ) continue ; \nif ( beansAlt . containsKey ( altName ) ) { \nBeanDefinition existing = beansAlt . get ( altName ) ; \nif ( existing != null ) beansAlt . put ( altName , null ) ; \n} \nelse beansAlt . put ( altName , beanDefinition ) ; \n} \n} \n} \n"}
{"763": "public class PetiteBeans { \npublic void removeBean ( final Class type ) { \nSet < String > beanNames = new HashSet < > ( ) ; \nfor ( BeanDefinition def : beans . values ( ) ) { \nif ( def . type . equals ( type ) ) beanNames . add ( def . name ) ; \n} \nfor ( String beanName : beanNames ) { \nremoveBean ( beanName ) ; \n} \n} \n} \n"}
{"764": "public class PetiteBeans { \nprotected String [ ] resolveBeanNamesForType ( final Class type ) { \nString [ ] beanNames = beanCollections . get ( type ) ; \nif ( beanNames != null ) return beanNames ; \nArrayList < String > list = new ArrayList < > ( ) ; \nfor ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { \nBeanDefinition beanDefinition = entry . getValue ( ) ; \nif ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { \nString beanName = entry . getKey ( ) ; \nlist . add ( beanName ) ; \n} \n} \nif ( list . isEmpty ( ) ) beanNames = StringPool . EMPTY_ARRAY ; \nelse beanNames = list . toArray ( new String [ 0 ] ) ; \nbeanCollections . put ( type , beanNames ) ; \nreturn beanNames ; \n} \n} \n"}
{"765": "public class PetiteBeans { \npublic void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nConstructor constructor = null ; \nif ( paramTypes == null ) { \nCtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; \nif ( ctors != null && ctors . length > 0 ) { \nif ( ctors . length > 1 ) throw new PetiteException ( ctors . length + \" suitable constructor found as injection point for: \" + beanDefinition . type . getName ( ) ) ; \nconstructor = ctors [ 0 ] . getConstructor ( ) ; \n} \n} \nelse { \nCtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; \nif ( ctorDescriptor != null ) constructor = ctorDescriptor . getConstructor ( ) ; \n} \nif ( constructor == null ) throw new PetiteException ( \"Constructor not found: \" + beanDefinition . type . getName ( ) ) ; \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; \nbeanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; \n} \n} \n"}
{"766": "public class PetiteBeans { \npublic void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nPropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; \nif ( propertyDescriptor == null ) throw new PetiteException ( \"Property not found: \" + beanDefinition . type . getName ( ) + '#' + property ) ; \nBeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; \nPropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; \nbeanDefinition . addPropertyInjectionPoint ( pip ) ; \n} \n} \n"}
{"767": "public class PetiteBeans { \npublic void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nPropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; \nif ( propertyDescriptor == null ) throw new PetiteException ( \"Property not found: \" + beanDefinition . type . getName ( ) + '#' + property ) ; \nSetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; \nbeanDefinition . addSetInjectionPoint ( sip ) ; \n} \n} \n"}
{"768": "public class PetiteBeans { \npublic void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nMethod method = null ; \nif ( arguments == null ) { \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; \nif ( methods != null && methods . length > 0 ) { \nif ( methods . length > 1 ) throw new PetiteException ( methods . length + \" suitable methods found as injection points for: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \nmethod = methods [ 0 ] . getMethod ( ) ; \n} \n} \nelse { \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md != null ) method = md . getMethod ( ) ; \n} \nif ( method == null ) throw new PetiteException ( \"Method not found: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; \nMethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; \nbeanDefinition . addMethodInjectionPoint ( mip ) ; \n} \n} \n"}
{"769": "public class PetiteBeans { \npublic void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( initMethodNames == null ) initMethodNames = StringPool . EMPTY_ARRAY ; \nint total = initMethodNames . length ; \nInitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ni < initMethodNames . length ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) throw new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; \ninitMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; \n} \nbeanDefinition . addInitMethodPoints ( initMethodPoints ) ; \n} \n} \n"}
{"770": "public class PetiteBeans { \npublic void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( destroyMethodNames == null ) destroyMethodNames = StringPool . EMPTY_ARRAY ; \nint total = destroyMethodNames . length ; \nDestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ni < destroyMethodNames . length ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) throw new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; \ndestroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; \n} \nbeanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; \n} \n} \n"}
{"771": "public class PetiteBeans { \npublic void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { \nBeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; \nif ( beanDefinition == null ) throw new PetiteException ( \"Bean not found: \" + beanName ) ; \nClass beanType = beanDefinition . type ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md == null ) throw new PetiteException ( \"Provider method not found: \" + methodName ) ; \nProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; \nproviders . put ( providerName , providerDefinition ) ; \n} \n} \n"}
{"772": "public class PetiteBeans { \npublic void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nMethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; \nif ( md == null ) throw new PetiteException ( \"Provider method not found: \" + staticMethodName ) ; \nProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; \nproviders . put ( providerName , providerDefinition ) ; \n} \n} \n"}
{"773": "public class PetiteBeans { \npublic void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { \nforEachBean ( bd -> { \nif ( ClassUtil . isTypeOf ( bd . type , type ) ) beanNameConsumer . accept ( bd . name ) ; \n} \n) ; \n} \n} \n"}
{"777": "public class ProxettaAsmUtil { \npublic static void pushInt ( final MethodVisitor mv , final int value ) { \nif ( value <= 5 ) mv . visitInsn ( ICONST_0 + value ) ; \nelse if ( value <= Byte . MAX_VALUE ) mv . visitIntInsn ( BIPUSH , value ) ; \nelse mv . visitIntInsn ( SIPUSH , value ) ; \n} \n} \n"}
{"778": "public class ProxettaAsmUtil { \npublic static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { \nif ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) throw new ProxettaException ( \"Invalid argument index: \" + argIndex ) ; \n} \n} \n"}
{"781": "public class ProxettaAsmUtil { \npublic static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nfor ( int i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni ++ ) loadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n"}
{"782": "public class ProxettaAsmUtil { \npublic static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 0 ; \ni < methodInfo . getArgumentsCount ( ) ; \ni ++ ) loadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n"}
{"783": "public class ProxettaAsmUtil { \npublic static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni ++ ) loadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n"}
{"790": "public class EmailUtil { \npublic static String extractEncoding ( final String contentType , String defaultEncoding ) { \nString encoding = extractEncoding ( contentType ) ; \nif ( encoding == null ) { \nif ( defaultEncoding == null ) defaultEncoding = JoddCore . encoding ; \nencoding = defaultEncoding ; \n} \nreturn encoding ; \n} \n} \n"}
{"791": "public class EmailUtil { \npublic static boolean isEmptyFlags ( Flags flags ) { \nif ( flags == null ) return true ; \nFlags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; \nif ( systemFlags != null && systemFlags . length > 0 ) return false ; \nString [ ] userFlags = flags . getUserFlags ( ) ; \nif ( userFlags != null && userFlags . length > 0 ) return false ; \nreturn true ; \n} \n} \n"}
{"792": "public class ServletUtil { \npublic static String resolveAuthBearerToken ( final HttpServletRequest request ) { \nString header = request . getHeader ( HEADER_AUTHORIZATION ) ; \nif ( header == null ) return null ; \nint ndx = header . indexOf ( \"Bearer \" ) ; \nif ( ndx == - 1 ) return null ; \nreturn header . substring ( ndx + 7 ) . trim ( ) ; \n} \n} \n"}
{"794": "public class ServletUtil { \npublic static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { \nif ( ! file . exists ( ) ) throw new IllegalArgumentException ( \"File not found: \" + file ) ; \nif ( file . length ( ) > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"File too big: \" + file ) ; \nprepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; \n} \n} \n"}
{"795": "public class ServletUtil { \npublic static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { \nif ( ( mimeType == null ) && ( fileName != null ) ) { \nString extension = FileNameUtil . getExtension ( fileName ) ; \nmimeType = MimeTypes . getMimeType ( extension ) ; \n} \nif ( mimeType != null ) response . setContentType ( mimeType ) ; \nif ( fileSize >= 0 ) response . setContentLength ( fileSize ) ; \nif ( fileName != null ) { \nString name = FileNameUtil . getName ( fileName ) ; \nString encodedFileName = URLCoder . encode ( name ) ; \nresponse . setHeader ( CONTENT_DISPOSITION , \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName ) ; \n} \n} \n} \n"}
{"796": "public class ServletUtil { \npublic static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { \nCookie [ ] cookies = request . getCookies ( ) ; \nif ( cookies == null ) return null ; \nArrayList < Cookie > list = new ArrayList < > ( cookies . length ) ; \nfor ( Cookie cookie : cookies ) { \nif ( cookie . getName ( ) . equals ( cookieName ) ) list . add ( cookie ) ; \n} \nif ( list . isEmpty ( ) ) return null ; \nreturn list . toArray ( new Cookie [ 0 ] ) ; \n} \n} \n"}
{"798": "public class ServletUtil { \npublic static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { \nString charEncoding = request . getCharacterEncoding ( ) ; \nif ( charEncoding == null ) charEncoding = JoddCore . encoding ; \nCharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; \nBufferedReader bufferedReader = null ; \ntry { \nInputStream inputStream = request . getInputStream ( ) ; \nif ( inputStream != null ) { \nbufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; \nStreamUtil . copy ( bufferedReader , charArrayWriter ) ; \n} \nelse return StringPool . EMPTY ; \n} \nfinally { \nStreamUtil . close ( bufferedReader ) ; \n} \nreturn charArrayWriter . toString ( ) ; \n} \n} \n"}
{"801": "public class ServletUtil { \npublic boolean isGetParameter ( final HttpServletRequest request , String name ) { \nname = URLCoder . encodeQueryParam ( name ) + '=' ; \nString query = request . getQueryString ( ) ; \nString [ ] nameValuePairs = StringUtil . splitc ( query , '&' ) ; \nfor ( String nameValuePair : nameValuePairs ) { \nif ( nameValuePair . startsWith ( name ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"802": "public class ServletUtil { \npublic static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nif ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { \nint emptyCount = 0 ; \nint total = paramValues . length ; \nfor ( int i = 0 ; \ni < paramValues . length ; \ni ++ ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount ++ ; \ncontinue ; \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount ++ ; \nif ( treatEmptyParamsAsNull ) paramValue = null ; \n} \nparamValues [ i ] = paramValue ; \n} \nif ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) return null ; \n} \nreturn paramValues ; \n} \n} \n"}
{"803": "public class ServletUtil { \npublic static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nEnumeration paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nString paramName = ( String ) paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) continue ; \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues == null ) continue ; \nservletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \n} \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) return ; \nMultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) return ; \nparamNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nString paramName = ( String ) paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) continue ; \nFileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nservletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \n} \n} \n} \n"}
{"804": "public class TagUtil { \npublic static void invokeBody ( final JspFragment body ) throws JspException { \nif ( body == null ) return ; \ntry { \nbody . invoke ( null ) ; \n} \ncatch ( IOException ioex ) { \nthrow new JspException ( \"Tag body failed\" , ioex ) ; \n} \n} \n} \n"}
{"807": "public class BeanData { \npublic void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { \nfor ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { \nif ( invocationStrategy != initMethod . invocationStrategy ) continue ; \ntry { \ninitMethod . method . invoke ( bean ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid init method: \" + initMethod , ex ) ; \n} \n} \n} \n} \n"}
{"809": "public class BeanData { \npublic Object newBeanInstance ( ) { \nif ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) throw new PetiteException ( \"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition . type . getName ( ) ) ; \nint paramNo = beanDefinition . ctor . references . length ; \nObject [ ] args = new Object [ paramNo ] ; \nif ( beanDefinition . wiringMode != WiringMode . NONE ) for ( int i = 0 ; \ni < paramNo ; \ni ++ ) { \nargs [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; \nif ( args [ i ] == null ) if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) throw new PetiteException ( \"Wiring constructor failed. References '\" + beanDefinition . ctor . references [ i ] + \"' not found for constructor: \" + beanDefinition . ctor . constructor ) ; \n} \nfinal Object bean ; \ntry { \nbean = beanDefinition . ctor . constructor . newInstance ( args ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Failed to create new bean instance '\" + beanDefinition . type . getName ( ) + \"' using constructor: \" + beanDefinition . ctor . constructor , ex ) ; \n} \nreturn bean ; \n} \n} \n"}
{"810": "public class BeanData { \npublic void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { \nif ( beanDefinition . name == null ) return ; \nif ( implicitParamInjection ) { \nfinal int len = beanDefinition . name . length ( ) + 1 ; \nfor ( final String param : beanDefinition . params ) { \nfinal Object value = paramManager . get ( param ) ; \nfinal String destination = param . substring ( len ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , destination , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition . name , ex ) ; \n} \n} \n} \nfor ( final ValueInjectionPoint pip : beanDefinition . values ) { \nfinal String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , pip . property , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Unable to set value for: '\" + pip . valueTemplate + \"' to bean: \" + beanDefinition . name , ex ) ; \n} \n} \n} \n} \n"}
{"813": "public class PropsData { \nprotected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { \nString realValue = value ; \nif ( append || appendDuplicateProps ) { \nPropsEntry pv = map . get ( key ) ; \nif ( pv != null ) realValue = pv . value + APPEND_SEPARATOR + realValue ; \n} \nPropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; \nif ( first == null ) first = propsEntry ; \nelse last . next = propsEntry ; \nlast = propsEntry ; \nmap . put ( key , propsEntry ) ; \n} \n} \n"}
{"816": "public class PropsData { \npublic PropsEntry getProfileProperty ( final String profile , final String key ) { \nfinal Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; \nif ( profileMap == null ) return null ; \nreturn profileMap . get ( key ) ; \n} \n} \n"}
{"817": "public class PropsData { \npublic String resolveMacros ( String value , final String ... profiles ) { \nStringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; \nstringTemplateParser . setResolveEscapes ( false ) ; \nif ( ! ignoreMissingMacros ) stringTemplateParser . setReplaceMissingKey ( false ) ; \nelse { \nstringTemplateParser . setReplaceMissingKey ( true ) ; \nstringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; \n} \nfinal Function < String , String > macroResolver = macroName -> { \nString [ ] lookupProfiles = profiles ; \nint leftIndex = macroName . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = macroName . indexOf ( '>' ) ; \nString profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; \nmacroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nreturn lookupValue ( macroName , lookupProfiles ) ; \n} \n; \nint loopCount = 0 ; \nwhile ( loopCount ++ < MAX_INNER_MACROS ) { \nfinal String newValue = stringTemplateParser . parse ( value , macroResolver ) ; \nif ( newValue . equals ( value ) ) break ; \nif ( skipEmptyProps ) if ( newValue . length ( ) == 0 ) return null ; \nvalue = newValue ; \n} \nreturn value ; \n} \n} \n"}
{"818": "public class PropsData { \npublic Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { \nif ( target == null ) target = new HashMap ( ) ; \nif ( prefix != null ) if ( ! StringUtil . endsWithChar ( prefix , '.' ) ) prefix += StringPool . DOT ; \nif ( profiles != null ) for ( String profile : profiles ) { \nwhile ( true ) { \nfinal Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; \nif ( map != null ) extractMap ( target , map , profiles , wildcardPatterns , prefix ) ; \nfinal int ndx = profile . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) break ; \nprofile = profile . substring ( 0 , ndx ) ; \n} \n} \nextractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; \nreturn target ; \n} \n} \n"}
{"820": "public class BCrypt { \npublic static String hashpw ( String password , String salt ) { \nBCrypt B ; \nString real_salt ; \nbyte [ ] passwordb , saltb , hashed ; \nchar minor = ( char ) 0 ; \nint rounds , off ; \nStringBuffer rs = new StringBuffer ( ) ; \nif ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) throw new IllegalArgumentException ( \"Invalid salt version\" ) ; \nif ( salt . charAt ( 2 ) == '$' ) off = 3 ; \nelse { \nminor = salt . charAt ( 2 ) ; \nif ( minor != 'a' || salt . charAt ( 3 ) != '$' ) throw new IllegalArgumentException ( \"Invalid salt revision\" ) ; \noff = 4 ; \n} \nif ( salt . charAt ( off + 2 ) > '$' ) throw new IllegalArgumentException ( \"Missing salt rounds\" ) ; \nrounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; \nreal_salt = salt . substring ( off + 3 , off + 25 ) ; \ntry { \npasswordb = ( password + ( minor >= 'a' ? \"\\000\" : \"\" ) ) . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nthrow new AssertionError ( \"UTF-8 is not supported\" ) ; \n} \nsaltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; \nB = new BCrypt ( ) ; \nhashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; \nrs . append ( \"$2\" ) ; \nif ( minor >= 'a' ) rs . append ( minor ) ; \nrs . append ( '$' ) ; \nif ( rounds < 10 ) rs . append ( '0' ) ; \nif ( rounds > 30 ) throw new IllegalArgumentException ( \"rounds exceeds maximum (30)\" ) ; \nrs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; \nreturn rs . toString ( ) ; \n} \n} \n"}
{"821": "public class BCrypt { \npublic static boolean checkpw ( String plaintext , String hashed ) { \nbyte [ ] hashed_bytes ; \nbyte [ ] try_bytes ; \ntry { \nString try_pw = hashpw ( plaintext , hashed ) ; \nhashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; \ntry_bytes = try_pw . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nreturn false ; \n} \nif ( hashed_bytes . length != try_bytes . length ) return false ; \nbyte ret = 0 ; \nfor ( int i = 0 ; \ni < try_bytes . length ; \ni ++ ) ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; \nreturn ret == 0 ; \n} \n} \n"}
{"822": "public class MultipartRequestInputStream { \npublic int copyAll ( final OutputStream out ) throws IOException { \nint count = 0 ; \nwhile ( true ) { \nbyte b = readByte ( ) ; \nif ( isBoundary ( b ) ) break ; \nout . write ( b ) ; \ncount ++ ; \n} \nreturn count ; \n} \n} \n"}
{"823": "public class MultipartRequestInputStream { \npublic int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { \nint count = 0 ; \nwhile ( true ) { \nbyte b = readByte ( ) ; \nif ( isBoundary ( b ) ) break ; \nout . write ( b ) ; \ncount ++ ; \nif ( count == maxBytes ) return count ; \n} \nreturn count ; \n} \n} \n"}
{"824": "public class ActionMethodParser { \npublic ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { \nfinal ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; \nfinal ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ; \nActionInterceptor [ ] actionInterceptors = parseActionInterceptors ( actionClass , actionMethod , actionConfig ) ; \nActionFilter [ ] actionFilters = parseActionFilters ( actionClass , actionMethod , actionConfig ) ; \nif ( actionDefinition == null ) actionDefinition = parseActionDefinition ( actionClass , actionMethod ) ; \ndetectAndRegisterAlias ( annotationValues , actionDefinition ) ; \nfinal boolean async = parseMethodAsyncFlag ( actionMethod ) ; \nfinal boolean auth = parseMethodAuthFlag ( actionMethod ) ; \nfinal Class < ? extends ActionResult > actionResult = parseActionResult ( actionMethod ) ; \nfinal Class < ? extends ActionResult > defaultActionResult = actionConfig . getActionResult ( ) ; \nreturn createActionRuntime ( null , actionClass , actionMethod , actionResult , defaultActionResult , actionFilters , actionInterceptors , actionDefinition , async , auth ) ; \n} \n} \n"}
{"825": "public class ActionMethodParser { \nprotected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { \nfinal Class < ? extends Annotation > annotationType ; \nif ( annotationValues == null ) annotationType = Action . class ; \nelse annotationType = annotationValues . annotationType ( ) ; \nreturn actionConfigManager . lookup ( annotationType ) ; \n} \n} \n"}
{"827": "public class ActionMethodParser { \nprotected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { \nClass < ? extends ActionInterceptor > [ ] result = null ; \nInterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; \nif ( interceptedBy != null ) { \nresult = interceptedBy . value ( ) ; \nif ( result . length == 0 ) result = null ; \n} \nreturn result ; \n} \n} \n"}
{"828": "public class ActionMethodParser { \nprotected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { \nClass < ? extends ActionFilter > [ ] result = null ; \nFilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; \nif ( filteredBy != null ) { \nresult = filteredBy . value ( ) ; \nif ( result . length == 0 ) result = null ; \n} \nreturn result ; \n} \n} \n"}
{"829": "public class ActionMethodParser { \nprotected String [ ] readPackageActionPath ( final Class actionClass ) { \nPackage actionPackage = actionClass . getPackage ( ) ; \nfinal String actionPackageName = actionPackage . getName ( ) ; \nString packageActionPathFromAnnotation ; \nmainloop : while ( true ) { \nMadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; \npackageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; \nif ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) packageActionPathFromAnnotation = null ; \nif ( packageActionPathFromAnnotation == null ) { \nString newPackage = actionPackage . getName ( ) ; \nactionPackage = null ; \nwhile ( actionPackage == null ) { \nfinal int ndx = newPackage . lastIndexOf ( '.' ) ; \nif ( ndx == - 1 ) break mainloop ; \nnewPackage = newPackage . substring ( 0 , ndx ) ; \nactionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; \n} \n} \nelse { \nrootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; \nbreak ; \n} \n} \nString packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; \nif ( packagePath == null ) return ArraysUtil . array ( null , null ) ; \nreturn ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; \n} \n} \n"}
{"830": "public class ActionMethodParser { \nprotected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { \nString methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; \nif ( methodActionPath == null ) methodActionPath = methodName ; \nelse if ( methodActionPath . equals ( Action . NONE ) ) return ArraysUtil . array ( null , null ) ; \nfor ( String path : actionConfig . getActionMethodNames ( ) ) { \nif ( methodActionPath . equals ( path ) ) { \nmethodActionPath = null ; \nbreak ; \n} \n} \nreturn ArraysUtil . array ( methodName , methodActionPath ) ; \n} \n} \n"}
{"831": "public class ActionMethodParser { \nprotected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { \nString alias = null ; \nif ( annotationValues != null ) alias = annotationValues . alias ( ) ; \nreturn alias ; \n} \n} \n"}
{"832": "public class ActionMethodParser { \npublic ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { \nif ( actionHandler != null ) return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; \nfinal Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; \nfinal MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; \nfinal Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; \nString [ ] methodParamNames = null ; \nfor ( int ndx = 0 ; \nndx < paramTypes . length ; \nndx ++ ) { \nClass paramType = paramTypes [ ndx ] ; \nif ( methodParamNames == null ) methodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; \nfinal String paramName = methodParamNames [ ndx ] ; \nfinal Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; \nfinal ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; \nMapperFunction mapperFunction = null ; \nfor ( final Annotation annotation : parameterAnnotations ) { \nif ( annotation instanceof Mapper ) { \nmapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; \nbreak ; \n} \n} \nparams [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; \n} \nreturn new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; \n} \n} \n"}
{"833": "public class DecoraResponseWrapper { \n@ Override protected void preResponseCommit ( ) { \nlong lastModified = lastModifiedData . getLastModified ( ) ; \nlong ifModifiedSince = request . getDateHeader ( \"If-Modified-Since\" ) ; \nif ( lastModified > - 1 && ! response . containsHeader ( \"Last-Modified\" ) ) if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) response . setDateHeader ( \"Last-Modified\" , lastModified ) ; \nelse { \nresponse . reset ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \n} \n} \n} \n"}
{"836": "public class FieldVisitor { \npublic AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { \nif ( fv != null ) return fv . visitAnnotation ( descriptor , visible ) ; \nreturn null ; \n} \n} \n"}
{"837": "public class TypeData { \npublic String resolveRealName ( final String jsonName ) { \nif ( jsonNames == null ) return jsonName ; \nint jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; \nif ( jsonIndex == - 1 ) return jsonName ; \nreturn realNames [ jsonIndex ] ; \n} \n} \n"}
{"838": "public class TypeData { \npublic String resolveJsonName ( final String realName ) { \nif ( realNames == null ) return realName ; \nint realIndex = ArraysUtil . indexOf ( realNames , realName ) ; \nif ( realIndex == - 1 ) return realName ; \nreturn jsonNames [ realIndex ] ; \n} \n} \n"}
{"839": "public class JsonAnnotationManager { \npublic TypeData lookupTypeData ( final Class type ) { \nTypeData typeData = typeDataMap . get ( type ) ; \nif ( typeData == null ) { \nif ( serializationSubclassAware ) typeData = findSubclassTypeData ( type ) ; \nif ( typeData == null ) { \ntypeData = scanClassForAnnotations ( type ) ; \ntypeDataMap . put ( type , typeData ) ; \n} \n} \nreturn typeData ; \n} \n} \n"}
{"841": "public class JsonAnnotationManager { \nprotected TypeData findSubclassTypeData ( final Class type ) { \nfinal Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; \nif ( type . getAnnotation ( defaultAnnotation ) != null ) return null ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nClass [ ] superClasses = cd . getAllSuperclasses ( ) ; \nfor ( Class superClass : superClasses ) { \nif ( superClass . getAnnotation ( defaultAnnotation ) != null ) return _lookupTypeData ( superClass ) ; \n} \nClass [ ] interfaces = cd . getAllInterfaces ( ) ; \nfor ( Class interfaze : interfaces ) { \nif ( interfaze . getAnnotation ( defaultAnnotation ) != null ) return _lookupTypeData ( interfaze ) ; \n} \nreturn null ; \n} \n} \n"}
{"844": "public class AdaptiveFileUpload { \n@ Override public byte [ ] getFileContent ( ) throws IOException { \nif ( data != null ) return data ; \nif ( tempFile != null ) return FileUtil . readBytes ( tempFile ) ; \nreturn null ; \n} \n} \n"}
{"848": "public class SymbolTable { \nvoid putBootstrapMethods ( final ByteVector output ) { \nif ( bootstrapMethods != null ) output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; \n} \n} \n"}
{"851": "public class SymbolTable { \nprivate Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { \nint hashCode = hash ( tag , owner , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry ; \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; \n} \n} \n"}
{"853": "public class SymbolTable { \nprivate Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) return entry ; \nentry = entry . next ; \n} \nconstantPool . putByte ( tag ) . putInt ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"855": "public class SymbolTable { \nprivate Symbol addConstantLongOrDouble ( final int tag , final long value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) return entry ; \nentry = entry . next ; \n} \nint index = constantPoolCount ; \nconstantPool . putByte ( tag ) . putLong ( value ) ; \nconstantPoolCount += 2 ; \nreturn put ( new Entry ( index , tag , value , hashCode ) ) ; \n} \n} \n"}
{"857": "public class SymbolTable { \nint addConstantNameAndType ( final String name , final String descriptor ) { \nfinal int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nint hashCode = hash ( tag , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry . index ; \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; \n} \n} \n"}
{"859": "public class SymbolTable { \nint addConstantUtf8 ( final String value ) { \nint hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) return entry . index ; \nentry = entry . next ; \n} \nconstantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry ; \nentry = entry . next ; \n} \nif ( referenceKind <= Opcodes . H_PUTSTATIC ) constantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \nelse constantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"865": "public class SymbolTable { \nprivate Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nint hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry ; \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \n} \n} \n"}
{"867": "public class SymbolTable { \nprivate Symbol addConstantUtf8Reference ( final int tag , final String value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) return entry ; \nentry = entry . next ; \n} \nconstantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"869": "public class SymbolTable { \nSymbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { \nByteVector bootstrapMethodsAttribute = bootstrapMethods ; \nif ( bootstrapMethodsAttribute == null ) bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; \nfor ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { \naddConstant ( bootstrapMethodArgument ) ; \n} \nint bootstrapMethodOffset = bootstrapMethodsAttribute . length ; \nbootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; \nint numBootstrapArguments = bootstrapMethodArguments . length ; \nbootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; \nfor ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { \nbootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index ) ; \n} \nint bootstrapMethodlength = bootstrapMethodsAttribute . length - bootstrapMethodOffset ; \nint hashCode = bootstrapMethodHandle . hashCode ( ) ; \nfor ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { \nhashCode ^= bootstrapMethodArgument . hashCode ( ) ; \n} \nhashCode &= 0x7FFFFFFF ; \nreturn addBootstrapMethod ( bootstrapMethodOffset , bootstrapMethodlength , hashCode ) ; \n} \n} \n"}
{"870": "public class SymbolTable { \nint addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { \nlong data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; \nint hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) return entry . info ; \nentry = entry . next ; \n} \nString type1 = typeTable [ typeTableIndex1 ] . value ; \nString type2 = typeTable [ typeTableIndex2 ] . value ; \nint commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; \nput ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; \nreturn commonSuperTypeIndex ; \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nint h = 0 ; \nfor ( int i = name . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) if ( c >= 'A' && c <= 'Z' ) c += 32 ; \nh = 31 * h + c ; \n} \nif ( h > 0 ) return h ; \nif ( h == Integer . MIN_VALUE ) return Integer . MAX_VALUE ; \nreturn - h ; \n} \n} \n"}
{"872": "public class HttpMultiMap { \npublic HttpMultiMap < V > clear ( ) { \nfor ( int i = 0 ; \ni < entries . length ; \ni ++ ) entries [ i ] = null ; \nhead . before = head . after = head ; \nreturn this ; \n} \n} \n"}
{"873": "public class HttpMultiMap { \npublic List < V > getAll ( final String name ) { \nLinkedList < V > values = new LinkedList < > ( ) ; \nint h = hash ( name ) ; \nint i = index ( h ) ; \nMapEntry < V > e = entries [ i ] ; \nwhile ( e != null ) { \nif ( e . hash == h && eq ( name , e . key ) ) values . addFirst ( e . getValue ( ) ) ; \ne = e . next ; \n} \nreturn values ; \n} \n} \n"}
{"874": "public class HttpMultiMap { \n@ Override public Iterator < Map . Entry < String , V > > iterator ( ) { \nfinal MapEntry [ ] e = { \nhead . after } \n; \nreturn new Iterator < Map . Entry < String , V > > ( ) { \n@ Override public boolean hasNext ( ) { \nreturn e [ 0 ] != head ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public Map . Entry < String , V > next ( ) { \nif ( ! hasNext ( ) ) throw new NoSuchElementException ( \"No next() entry in the iteration\" ) ; \nMapEntry < V > next = e [ 0 ] ; \ne [ 0 ] = e [ 0 ] . after ; \nreturn next ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"876": "public class FastCharBuffer { \nprivate void grow ( final int minCapacity ) { \nfinal int oldCapacity = buffer . length ; \nint newCapacity = oldCapacity << 1 ; \nif ( newCapacity - minCapacity < 0 ) newCapacity = minCapacity + 512 ; \nbuffer = Arrays . copyOf ( buffer , newCapacity ) ; \n} \n} \n"}
{"877": "public class FastCharBuffer { \n@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { \nfor ( int i = start ; \ni < end ; \ni ++ ) append ( csq . charAt ( i ) ) ; \nreturn this ; \n} \n} \n"}
{"880": "public class ProxettaMethodBuilder { \nprotected void createFirstChainDelegate_Start ( ) { \nint access = msign . getAccessFlags ( ) ; \nif ( ! wd . allowFinalMethods ) if ( ( access & AsmUtil . ACC_FINAL ) != 0 ) throw new ProxettaException ( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\" ) ; \ntmd = new TargetMethodData ( msign , aspectList ) ; \naccess &= ~ ACC_NATIVE ; \naccess &= ~ ACC_ABSTRACT ; \nmethodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; \n} \n} \n"}
{"883": "public class Path { \npublic Path push ( final CharSequence field ) { \n_push ( field ) ; \nif ( altPath != null ) altPath . push ( field ) ; \nreturn this ; \n} \n} \n"}
{"889": "public class BeanSerializer { \nprivate Object readProperty ( final Object source , final PropertyDescriptor propertyDescriptor ) { \nGetter getter = propertyDescriptor . getGetter ( declared ) ; \nif ( getter != null ) try { \nreturn getter . invokeGetter ( source ) ; \n} \ncatch ( Exception ex ) { \nthrow new JsonException ( ex ) ; \n} \nreturn null ; \n} \n} \n"}
{"891": "public class Buffer { \npublic Buffer append ( final Buffer buffer ) { \nif ( buffer . list . isEmpty ( ) ) return buffer ; \nlist . addAll ( buffer . list ) ; \nlast = buffer . last ; \nsize += buffer . size ; \nreturn this ; \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nwhile ( offset < bytes . length ) { \nint chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) chunk = bytes . length - offset ; \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( remaining > 0 ) { \nint chunk = callbackSize - step ; \nif ( chunk > remaining ) chunk = remaining ; \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nif ( step != 0 ) progressListener . transferred ( count ) ; \n} \n} \n"}
{"896": "public class JsonObject { \npublic Integer getInteger ( final String key ) { \nNumber number = ( Number ) map . get ( key ) ; \nif ( number == null ) return null ; \nif ( number instanceof Integer ) return ( Integer ) number ; \nreturn number . intValue ( ) ; \n} \n} \n"}
{"897": "public class JsonObject { \npublic Long getLong ( final String key ) { \nNumber number = ( Number ) map . get ( key ) ; \nif ( number == null ) return null ; \nif ( number instanceof Long ) return ( Long ) number ; \nreturn number . longValue ( ) ; \n} \n} \n"}
{"898": "public class JsonObject { \npublic Double getDouble ( final String key ) { \nNumber number = ( Number ) map . get ( key ) ; \nif ( number == null ) return null ; \nif ( number instanceof Double ) return ( Double ) number ; \nreturn number . doubleValue ( ) ; \n} \n} \n"}
{"899": "public class JsonObject { \npublic Float getFloat ( final String key ) { \nNumber number = ( Number ) map . get ( key ) ; \nif ( number == null ) return null ; \nif ( number instanceof Float ) return ( Float ) number ; \nreturn number . floatValue ( ) ; \n} \n} \n"}
{"900": "public class JsonObject { \n@ SuppressWarnings ( \"unchecked\" ) public < T > T getValue ( final String key ) { \nT val = ( T ) map . get ( key ) ; \nif ( val instanceof Map ) return ( T ) new JsonObject ( ( Map ) val ) ; \nif ( val instanceof List ) return ( T ) new JsonArray ( ( List ) val ) ; \nreturn val ; \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( filter == null ) messages = folder . getMessages ( ) ; \nelse messages = folder . search ( filter . getSearchTerm ( ) ) ; \nif ( messages . length == 0 ) return ReceivedEmail . EMPTY_ARRAY ; \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \nfor ( int i = 0 ; \ni < messages . length ; \ni ++ ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) msg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \nif ( processedMessageConsumer != null ) processedMessageConsumer . accept ( messages ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) if ( flagsToSet . contains ( Flags . Flag . DELETED ) ) folder . expunge ( ) ; \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"905": "public class ReceiveMailSession { \nprotected void closeFolderIfOpened ( final Folder folder ) { \nif ( folder != null ) try { \nfolder . close ( true ) ; \n} \ncatch ( final MessagingException ignore ) { \n} \n} \n} \n"}
{"906": "public class DbQueryParser { \nDbQueryNamedParameter lookupNamedParameter ( final String name ) { \nDbQueryNamedParameter p = rootNP ; \nwhile ( p != null ) { \nif ( p . equalsName ( name ) ) return p ; \np = p . next ; \n} \nreturn null ; \n} \n} \n"}
{"910": "public class RawData { \npublic RawData as ( final String mimeOrExtension ) { \nif ( mimeOrExtension . contains ( StringPool . SLASH ) ) this . mimeType = mimeOrExtension ; \nelse this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; \nreturn this ; \n} \n} \n"}
{"913": "public class ProxettaFactory { \nprotected T setTarget ( final String targetName ) { \nassertTargetIsNotDefined ( ) ; \ntry { \ntargetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; \nif ( targetInputStream == null ) throw new ProxettaException ( \"Target class not found: \" + targetName ) ; \ntargetClassName = targetName ; \ntargetClass = null ; \n} \ncatch ( IOException ioex ) { \nStreamUtil . close ( targetInputStream ) ; \nthrow new ProxettaException ( \"Unable to get stream class name: \" + targetName , ioex ) ; \n} \nreturn _this ( ) ; \n} \n} \n"}
{"914": "public class ProxettaFactory { \npublic T setTarget ( final Class target ) { \nassertTargetIsNotDefined ( ) ; \ntry { \ntargetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; \nif ( targetInputStream == null ) throw new ProxettaException ( \"Target class not found: \" + target . getName ( ) ) ; \ntargetClass = target ; \ntargetClassName = target . getName ( ) ; \n} \ncatch ( IOException ioex ) { \nStreamUtil . close ( targetInputStream ) ; \nthrow new ProxettaException ( \"Unable to stream class: \" + target . getName ( ) , ioex ) ; \n} \nreturn _this ( ) ; \n} \n} \n"}
{"915": "public class ProxettaFactory { \nprotected void process ( ) { \nif ( targetInputStream == null ) throw new ProxettaException ( \"Target missing: \" + targetClassName ) ; \nfinal ClassReader classReader ; \ntry { \nclassReader = new ClassReader ( targetInputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Error reading class input stream\" , ioex ) ; \n} \nfinal TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader ( proxetta . getClassLoader ( ) ) ; \nclassReader . accept ( targetClassInfoReader , 0 ) ; \nthis . destClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS | ClassWriter . COMPUTE_FRAMES ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"processing: \" + classReader . getClassName ( ) ) ; \nWorkData wd = process ( classReader , targetClassInfoReader ) ; \nproxyApplied = wd . proxyApplied ; \nproxyClassName = wd . thisReference . replace ( '/' , '.' ) ; \n} \n} \n"}
{"916": "public class ProxettaFactory { \npublic byte [ ] create ( ) { \nprocess ( ) ; \nbyte [ ] result = toByteArray ( ) ; \ndumpClassInDebugFolder ( result ) ; \nif ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Proxy not applied: \" + StringUtil . toSafeString ( targetClassName ) ) ; \nreturn null ; \n} \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Proxy created \" + StringUtil . toSafeString ( targetClassName ) ) ; \nreturn result ; \n} \n} \n"}
{"917": "public class ProxettaFactory { \npublic Class define ( ) { \nprocess ( ) ; \nif ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Proxy not applied: \" + StringUtil . toSafeString ( targetClassName ) ) ; \nif ( targetClass != null ) return targetClass ; \nif ( targetClassName != null ) try { \nreturn ClassLoaderUtil . loadClass ( targetClassName ) ; \n} \ncatch ( ClassNotFoundException cnfex ) { \nthrow new ProxettaException ( cnfex ) ; \n} \n} \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Proxy created: \" + StringUtil . toSafeString ( targetClassName ) ) ; \ntry { \nClassLoader classLoader = proxetta . getClassLoader ( ) ; \nif ( classLoader == null ) { \nclassLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; \nif ( ( classLoader == null ) && ( targetClass != null ) ) classLoader = targetClass . getClassLoader ( ) ; \n} \nfinal byte [ ] bytes = toByteArray ( ) ; \ndumpClassInDebugFolder ( bytes ) ; \nreturn DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; \n} \ncatch ( Exception ex ) { \nthrow new ProxettaException ( \"Class definition failed\" , ex ) ; \n} \n} \n} \n"}
{"919": "public class ProxettaFactory { \nprotected void dumpClassInDebugFolder ( final byte [ ] bytes ) { \nFile debugFolder = proxetta . getDebugFolder ( ) ; \nif ( debugFolder == null ) return ; \nif ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) log . warn ( \"Invalid debug folder: \" + debugFolder ) ; \nString fileName = proxyClassName ; \nif ( fileName == null ) fileName = \"proxetta-\" + System . currentTimeMillis ( ) ; \nfileName += \".class\" ; \nFile file = new File ( debugFolder , fileName ) ; \ntry { \nFileUtil . writeBytes ( file , bytes ) ; \n} \ncatch ( IOException ioex ) { \nlog . warn ( \"Error writing class as \" + file , ioex ) ; \n} \n} \n} \n"}
{"928": "public class SystemUtil { \npublic static String get ( final String name , final String defaultValue ) { \nObjects . requireNonNull ( name ) ; \nString value = null ; \ntry { \nif ( System . getSecurityManager ( ) == null ) value = System . getProperty ( name ) ; \nelse value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( value == null ) return defaultValue ; \nreturn value ; \n} \n} \n"}
{"929": "public class SystemUtil { \npublic static boolean getBoolean ( final String name , final boolean defaultValue ) { \nString value = get ( name ) ; \nif ( value == null ) return defaultValue ; \nvalue = value . trim ( ) . toLowerCase ( ) ; \nswitch ( value ) { \ncase \"true\" : case \"yes\" : case \"1\" : case \"on\" : return true ; \ncase \"false\" : case \"no\" : case \"0\" : case \"off\" : return false ; \ndefault : return defaultValue ; \n} \n} \n} \n"}
{"930": "public class SystemUtil { \npublic static long getInt ( final String name , final int defaultValue ) { \nString value = get ( name ) ; \nif ( value == null ) return defaultValue ; \nvalue = value . trim ( ) . toLowerCase ( ) ; \ntry { \nreturn Integer . parseInt ( value ) ; \n} \ncatch ( NumberFormatException nfex ) { \nreturn defaultValue ; \n} \n} \n} \n"}
{"931": "public class SystemUtil { \npublic static long getLong ( final String name , final long defaultValue ) { \nString value = get ( name ) ; \nif ( value == null ) return defaultValue ; \nvalue = value . trim ( ) . toLowerCase ( ) ; \ntry { \nreturn Long . parseLong ( value ) ; \n} \ncatch ( NumberFormatException nfex ) { \nreturn defaultValue ; \n} \n} \n} \n"}
{"932": "public class MethodFinder { \nMethodParameter [ ] getResolvedParameters ( ) { \nif ( paramExtractor == null ) return MethodParameter . EMPTY_ARRAY ; \nif ( ! paramExtractor . debugInfoPresent ) throw new ParamoException ( \"Parameter names not available for method: \" + declaringClass . getName ( ) + '#' + methodName ) ; \nreturn paramExtractor . getMethodParameters ( ) ; \n} \n} \n"}
{"933": "public class KeyValueJsonSerializer { \nprotected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { \nif ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) return count ; \nif ( key != null ) currentPath . push ( key . toString ( ) ) ; \nelse currentPath . push ( StringPool . NULL ) ; \nboolean include = true ; \nif ( value != null ) { \ninclude = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; \ninclude = jsonContext . matchPathToQueries ( include ) ; \n} \nif ( ! include ) { \ncurrentPath . pop ( ) ; \nreturn count ; \n} \nif ( key == null ) jsonContext . pushName ( null , count > 0 ) ; \nelse jsonContext . pushName ( key . toString ( ) , count > 0 ) ; \njsonContext . serialize ( value ) ; \nif ( jsonContext . isNamePopped ( ) ) count ++ ; \ncurrentPath . pop ( ) ; \nreturn count ; \n} \n} \n"}
{"934": "public class ResultMapper { \nprotected String lookupAlias ( final String alias ) { \nString value = actionsManager . lookupPathAlias ( alias ) ; \nif ( value == null ) { \nActionRuntime cfg = actionsManager . lookup ( alias ) ; \nif ( cfg != null ) value = cfg . getActionPath ( ) ; \n} \nreturn value ; \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nint i = 0 ; \nint len = value . length ( ) ; \nwhile ( i < len ) { \nint ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( i == 0 ) { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nelse result . append ( value . substring ( i ) ) ; \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx ++ ; \nint ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( alias != null ) result . append ( alias ) ; \nelse if ( log . isWarnEnabled ( ) ) log . warn ( \"Alias not found: \" + aliasName ) ; \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nwhile ( i < len ) { \nif ( result . charAt ( i ) != '/' ) break ; \ni ++ ; \n} \nif ( i > 1 ) return result . substring ( i - 1 , len ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( StringUtil . startsWithChar ( value , '/' ) ) { \nabsolutePath = true ; \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \npath = value ; \nvalue = null ; \n} \n} \nelse { \nint i = 0 ; \nwhile ( i < value . length ( ) ) { \nif ( value . charAt ( i ) != '#' ) break ; \nint dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) path = path . substring ( 0 , dotNdx ) ; \ni ++ ; \n} \nif ( i > 0 ) { \nvalue = value . substring ( i ) ; \nif ( StringUtil . startsWithChar ( value , '.' ) ) value = value . substring ( 1 ) ; \nelse { \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath += '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \nif ( value . length ( ) > 0 ) if ( StringUtil . endsWithChar ( path , '/' ) ) path += value ; \nelse path += '.' + value ; \nvalue = null ; \n} \n} \n} \n} \n} \nif ( ! absolutePath ) if ( resultPathPrefix != null ) path = resultPathPrefix + path ; \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"938": "public class MadvocUtil { \npublic static int lastIndexOfSlashDot ( final String str ) { \nint slashNdx = str . lastIndexOf ( '/' ) ; \nint dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \nif ( dotNdx == - 1 ) { \nif ( slashNdx == - 1 ) return - 1 ; \nslashNdx ++ ; \nif ( slashNdx < str . length ( ) - 1 ) dotNdx = slashNdx ; \nelse dotNdx = - 1 ; \n} \nreturn dotNdx ; \n} \n} \n"}
{"940": "public class MadvocUtil { \npublic static int indexOfDotAfterSlash ( final String str ) { \nint slashNdx = str . lastIndexOf ( '/' ) ; \nif ( slashNdx == - 1 ) slashNdx = 0 ; \nreturn str . indexOf ( '.' , slashNdx ) ; \n} \n} \n"}
{"941": "public class MadvocUtil { \npublic static String stripLastCamelWord ( String name ) { \nint ndx = name . length ( ) - 1 ; \nwhile ( ndx >= 0 ) { \nif ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) break ; \nndx -- ; \n} \nif ( ndx >= 0 ) name = name . substring ( 0 , ndx ) ; \nreturn name ; \n} \n} \n"}
{"942": "public class DbMetaUtil { \npublic static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { \nString schemaName = null ; \nfinal DbTable dbTable = type . getAnnotation ( DbTable . class ) ; \nif ( dbTable != null ) schemaName = dbTable . schema ( ) . trim ( ) ; \nif ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) schemaName = defaultSchemaName ; \nreturn schemaName ; \n} \n} \n"}
{"943": "public class DbMetaUtil { \npublic static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { \nString columnName = null ; \nboolean isId = false ; \nClass < ? extends SqlType > sqlTypeClass = null ; \nDbId dbId = null ; \nif ( property . getFieldDescriptor ( ) != null ) dbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; \nif ( dbId == null && property . getReadMethodDescriptor ( ) != null ) dbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \nif ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) dbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \nif ( dbId != null ) { \ncolumnName = dbId . value ( ) . trim ( ) ; \nsqlTypeClass = dbId . sqlType ( ) ; \nisId = true ; \n} \nelse { \nDbColumn dbColumn = null ; \nif ( property . getFieldDescriptor ( ) != null ) dbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; \nif ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) dbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \nif ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) dbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \nif ( dbColumn != null ) { \ncolumnName = dbColumn . value ( ) . trim ( ) ; \nsqlTypeClass = dbColumn . sqlType ( ) ; \n} \nelse if ( isAnnotated ) return null ; \n} \nif ( StringUtil . isEmpty ( columnName ) ) columnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; \nelse if ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) columnName = columnNamingStrategy . applyToColumnName ( columnName ) ; \nif ( sqlTypeClass == SqlType . class ) sqlTypeClass = null ; \nreturn new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; \n} \n} \n"}
{"944": "public class Threefish { \npublic void init ( final long [ ] key , final long [ ] tweak ) { \nfinal int newNw = key . length ; \nif ( nw != newNw ) { \nnw = newNw ; \nswitch ( nw ) { \ncase WORDS_4 : pi = PI4 ; \nrpi = RPI4 ; \nr = R4 ; \nbreak ; \ncase WORDS_8 : pi = PI8 ; \nrpi = RPI8 ; \nr = R8 ; \nbreak ; \ncase WORDS_16 : pi = PI16 ; \nrpi = RPI16 ; \nr = R16 ; \nbreak ; \ndefault : throw new RuntimeException ( \"Invalid threefish key\" ) ; \n} \nthis . k = new long [ nw + 1 ] ; \nvd = new long [ nw ] ; \ned = new long [ nw ] ; \nfd = new long [ nw ] ; \nksd = new long [ nw ] ; \n} \nSystem . arraycopy ( key , 0 , this . k , 0 , key . length ) ; \nlong knw = EXTENDED_KEY_SCHEDULE_CONST ; \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) knw ^= this . k [ i ] ; \nthis . k [ nw ] = knw ; \nt [ 0 ] = tweak [ 0 ] ; \nt [ 1 ] = tweak [ 1 ] ; \nt [ 2 ] = t [ 0 ] ^ t [ 1 ] ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) ksd [ i ] += t [ s % TWEAK_VALUES ] ; \nelse if ( i == nw - 2 ) ksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \nelse if ( i == nw - 1 ) ksd [ i ] += s ; \n} \n} \n} \n"}
{"951": "public class RFC2822AddressParser { \nprivate static String removeAnyBounding ( final char s , final char e , final String str ) { \nif ( str == null || str . length ( ) < 2 ) return str ; \nif ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) return str . substring ( 1 , str . length ( ) - 1 ) ; \nreturn str ; \n} \n} \n"}
{"953": "public class ZipUtil { \npublic static File zlib ( final File file ) throws IOException { \nif ( file . isDirectory ( ) ) throw new IOException ( \"Can't zlib folder\" ) ; \nFileInputStream fis = new FileInputStream ( file ) ; \nDeflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; \nString zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; \nDeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; \ntry { \nStreamUtil . copy ( fis , dos ) ; \n} \nfinally { \nStreamUtil . close ( dos ) ; \nStreamUtil . close ( fis ) ; \n} \nreturn new File ( zlibFileName ) ; \n} \n} \n"}
{"954": "public class ZipUtil { \npublic static File gzip ( final File file ) throws IOException { \nif ( file . isDirectory ( ) ) throw new IOException ( \"Can't gzip folder\" ) ; \nFileInputStream fis = new FileInputStream ( file ) ; \nString gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; \nGZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; \ntry { \nStreamUtil . copy ( fis , gzos ) ; \n} \nfinally { \nStreamUtil . close ( gzos ) ; \nStreamUtil . close ( fis ) ; \n} \nreturn new File ( gzipName ) ; \n} \n} \n"}
{"958": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { \nif ( ! file . exists ( ) ) throw new FileNotFoundException ( file . toString ( ) ) ; \nif ( path == null ) path = file . getName ( ) ; \nwhile ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nboolean isDir = file . isDirectory ( ) ; \nif ( isDir ) if ( ! StringUtil . endsWithChar ( path , '/' ) ) path += '/' ; \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( file . lastModified ( ) ) ; \nif ( comment != null ) zipEntry . setComment ( comment ) ; \nif ( isDir ) { \nzipEntry . setSize ( 0 ) ; \nzipEntry . setCrc ( 0 ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nif ( ! isDir ) { \nInputStream is = new FileInputStream ( file ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \n} \nzos . closeEntry ( ) ; \nif ( recursive && file . isDirectory ( ) ) { \nboolean noRelativePath = StringUtil . isEmpty ( path ) ; \nfinal File [ ] children = file . listFiles ( ) ; \nif ( children != null && children . length != 0 ) for ( File child : children ) { \nString childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; \naddToZip ( zos , child , childRelativePath , comment , recursive ) ; \n} \n} \n} \n} \n"}
{"959": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { \nwhile ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nif ( StringUtil . endsWithChar ( path , '/' ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( System . currentTimeMillis ( ) ) ; \nif ( comment != null ) zipEntry . setComment ( comment ) ; \nzos . putNextEntry ( zipEntry ) ; \nInputStream is = new ByteArrayInputStream ( content ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \nzos . closeEntry ( ) ; \n} \n} \n"}
{"960": "public class ClassDescriptor { \npublic FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { \nfinal FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; \nif ( fieldDescriptor != null ) if ( ! fieldDescriptor . matchDeclared ( declared ) ) return null ; \nreturn fieldDescriptor ; \n} \n} \n"}
{"961": "public class ClassDescriptor { \npublic PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { \nPropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; \nif ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) return propertyDescriptor ; \nreturn null ; \n} \n} \n"}
{"962": "public class LocalizationUtil { \npublic static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Bundle name for this request: \" + bundleName ) ; \nrequest . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; \n} \n} \n"}
{"963": "public class LocalizationUtil { \npublic static void setSessionLocale ( final HttpSession session , final String localeCode ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Locale stored to session: \" + localeCode ) ; \nLocale locale = Locale . forLanguageTag ( localeCode ) ; \nsession . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; \n} \n} \n"}
{"965": "public class ParamManager { \npublic String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { \nbeanName = beanName + '.' ; \nList < String > list = new ArrayList < > ( ) ; \nfor ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { \nString key = entry . getKey ( ) ; \nif ( ! key . startsWith ( beanName ) ) continue ; \nlist . add ( key ) ; \nif ( ! resolveReferenceParams ) continue ; \nString value = PropertiesUtil . resolveProperty ( params , key ) ; \nentry . setValue ( value ) ; \n} \nif ( list . isEmpty ( ) ) return StringPool . EMPTY_ARRAY ; \nelse return list . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"966": "public class PropsEntries { \npublic PropsEntries profile ( final String ... profiles ) { \nif ( profiles == null ) return this ; \nfor ( String profile : profiles ) { \naddProfiles ( profile ) ; \n} \nreturn this ; \n} \n} \n"}
{"968": "public class ClassReader { \nprivate static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { \nif ( inputStream == null ) throw new IOException ( \"Class not found\" ) ; \ntry { \nByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; \nbyte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; \nint bytesRead ; \nwhile ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) outputStream . write ( data , 0 , bytesRead ) ; \noutputStream . flush ( ) ; \nreturn outputStream . toByteArray ( ) ; \n} \nfinally { \nif ( close ) inputStream . close ( ) ; \n} \n} \n} \n"}
{"969": "public class ClassReader { \nprotected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { \nif ( labels [ bytecodeOffset ] == null ) labels [ bytecodeOffset ] = new Label ( ) ; \nreturn labels [ bytecodeOffset ] ; \n} \n} \n"}
{"970": "public class ClassReader { \nprivate int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { \nif ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) return - 1 ; \nreturn readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nint currentOffset = annotationOffset ; \nint numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nif ( named ) while ( numElementValuePairs -- > 0 ) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \nelse while ( numElementValuePairs -- > 0 ) currentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \nif ( annotationVisitor != null ) annotationVisitor . visitEnd ( ) ; \nreturn currentOffset ; \n} \n} \n"}
{"974": "public class Ctors { \nprotected CtorDescriptor [ ] inspectConstructors ( ) { \nClass type = classDescriptor . getType ( ) ; \nConstructor [ ] ctors = type . getDeclaredConstructors ( ) ; \nCtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; \nfor ( int i = 0 ; \ni < ctors . length ; \ni ++ ) { \nConstructor ctor = ctors [ i ] ; \nCtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; \nallCtors [ i ] = ctorDescriptor ; \nif ( ctorDescriptor . isDefault ( ) ) defaultCtor = ctorDescriptor ; \n} \nreturn allCtors ; \n} \n} \n"}
{"975": "public class Ctors { \npublic CtorDescriptor getCtorDescriptor ( final Class ... args ) { \nctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { \nClass [ ] arg = ctorDescriptor . getParameters ( ) ; \nif ( arg . length != args . length ) continue ; \nfor ( int j = 0 ; \nj < arg . length ; \nj ++ ) if ( arg [ j ] != args [ j ] ) continue ctors ; \nreturn ctorDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"978": "public class LongArrayConverter { \nprotected long [ ] convertArrayToArray ( final Object value ) { \nfinal Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; \nfinal long [ ] result ; \nif ( valueComponentType . isPrimitive ( ) ) result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; \nelse { \nfinal Object [ ] array = ( Object [ ] ) value ; \nresult = new long [ array . length ] ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) result [ i ] = convertType ( array [ i ] ) ; \n} \nreturn result ; \n} \n} \n"}
{"979": "public class DecoraServletFilter { \n@ Override public void init ( final FilterConfig filterConfig ) throws ServletException { \nfinal String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; \nif ( decoraManagerClass != null ) try { \nfinal Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; \ndecoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Unable to load Decora manager class: \" + decoraManagerClass , ex ) ; \nthrow new ServletException ( ex ) ; \n} \nelse decoraManager = createDecoraManager ( ) ; \nfinal String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; \nif ( decoraParserClass != null ) try { \nfinal Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; \ndecoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Unable to load Decora parser class: \" + decoraParserClass , ex ) ; \nthrow new ServletException ( ex ) ; \n} \nelse decoraParser = createDecoraParser ( ) ; \nfinal String decoraCache = filterConfig . getInitParameter ( PARAM_DECORA_CACHE ) ; \nif ( decoraCache != null ) cached = Converter . get ( ) . toBoolean ( decoraCache , false ) ; \n} \n} \n"}
{"980": "public class FindFile { \npublic FindFile onFile ( final Consumer < File > fileConsumer ) { \nif ( consumers == null ) consumers = Consumers . of ( fileConsumer ) ; \nelse consumers . add ( fileConsumer ) ; \nreturn this ; \n} \n} \n"}
{"982": "public class FindFile { \npublic FindFile searchPath ( final URL searchPath ) { \nFile file = FileUtil . toContainerFile ( searchPath ) ; \nif ( file == null ) throw new FindFileException ( \"URL error: \" + searchPath ) ; \naddPath ( file ) ; \nreturn this ; \n} \n} \n"}
{"985": "public class FindFile { \nprotected void addPath ( final File path ) { \nif ( ! path . exists ( ) ) return ; \nif ( pathList == null ) pathList = new LinkedList < > ( ) ; \npathList . add ( path ) ; \n} \n} \n"}
{"986": "public class FindFile { \npublic List < File > findAll ( ) { \nList < File > allFiles = new ArrayList < > ( ) ; \nFile file ; \nwhile ( ( file = nextFile ( ) ) != null ) allFiles . add ( file ) ; \nreturn allFiles ; \n} \n} \n"}
{"987": "public class FindFile { \nprotected void init ( ) { \nrules . detectMode ( ) ; \ntodoFiles = new LinkedList < > ( ) ; \ntodoFolders = new LinkedList < > ( ) ; \nif ( pathList == null ) { \npathList = new LinkedList < > ( ) ; \nreturn ; \n} \nif ( pathListOriginal == null ) pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; \nString [ ] files = new String [ pathList . size ( ) ] ; \nint index = 0 ; \nIterator < File > iterator = pathList . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nFile file = iterator . next ( ) ; \nif ( file . isFile ( ) ) { \nfiles [ index ++ ] = file . getAbsolutePath ( ) ; \niterator . remove ( ) ; \n} \n} \nif ( index != 0 ) { \nFilesIterator filesIterator = new FilesIterator ( files ) ; \ntodoFiles . add ( filesIterator ) ; \n} \n} \n} \n"}
{"988": "public class FindFile { \n@ Override public Iterator < File > iterator ( ) { \nreturn new Iterator < File > ( ) { \nprivate File nextFile ; \n@ Override public boolean hasNext ( ) { \nnextFile = nextFile ( ) ; \nreturn nextFile != null ; \n} \n@ Override public File next ( ) { \nif ( nextFile == null ) throw new NoSuchElementException ( ) ; \nreturn nextFile ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"990": "public class AnnotationResolver { \npublic String resolveBeanName ( final Class type , final boolean useLongTypeName ) { \nPetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; \nString name = null ; \nif ( petiteBean != null ) name = petiteBean . value ( ) . trim ( ) ; \nif ( ( name == null ) || ( name . length ( ) == 0 ) ) if ( useLongTypeName ) name = type . getName ( ) ; \nelse name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; \nreturn name ; \n} \n} \n"}
{"991": "public class Buffer { \npublic PrintWriter getWriter ( ) { \nif ( outWriter == null ) { \nif ( outStream != null ) throw new IllegalStateException ( \"Can't call getWriter() after getOutputStream()\" ) ; \nbufferedWriter = new FastCharArrayWriter ( ) ; \noutWriter = new PrintWriter ( bufferedWriter ) { \n@ Override public void close ( ) { \n} \n} \n; \n} \nreturn outWriter ; \n} \n} \n"}
{"992": "public class Buffer { \npublic ServletOutputStream getOutputStream ( ) { \nif ( outStream == null ) { \nif ( outWriter != null ) throw new IllegalStateException ( \"Can't call getOutputStream() after getWriter()\" ) ; \nbufferOutputStream = new FastByteArrayServletOutputStream ( ) ; \noutStream = bufferOutputStream ; \n} \nreturn outStream ; \n} \n} \n"}
{"993": "public class Type { \npublic String getClassName ( ) { \nswitch ( sort ) { \ncase VOID : return \"void\" ; \ncase BOOLEAN : return \"boolean\" ; \ncase CHAR : return \"char\" ; \ncase BYTE : return \"byte\" ; \ncase SHORT : return \"short\" ; \ncase INT : return \"int\" ; \ncase FLOAT : return \"float\" ; \ncase LONG : return \"long\" ; \ncase DOUBLE : return \"double\" ; \ncase ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; \nfor ( int i = getDimensions ( ) ; \ni > 0 ; \n-- i ) stringBuilder . append ( \"[]\" ) ; \nreturn stringBuilder . toString ( ) ; \ncase OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n"}
{"997": "public class Type { \nprivate void appendDescriptor ( final StringBuilder stringBuilder ) { \nif ( sort == OBJECT ) stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; \nelse if ( sort == INTERNAL ) stringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; \nelse stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; \n} \n} \n"}
{"999": "public class Type { \npublic static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { \nint argumentsSize = 1 ; \nint currentOffset = 1 ; \nint currentChar = methodDescriptor . charAt ( currentOffset ) ; \nwhile ( currentChar != ')' ) { \nif ( currentChar == 'J' || currentChar == 'D' ) { \ncurrentOffset ++ ; \nargumentsSize += 2 ; \n} \nelse { \nwhile ( methodDescriptor . charAt ( currentOffset ) == '[' ) currentOffset ++ ; \nif ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) currentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; \nargumentsSize += 1 ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset ) ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; \nif ( currentChar == 'V' ) return argumentsSize << 2 ; \nelse { \nint returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; \nreturn argumentsSize << 2 | returnSize ; \n} \n} \n} \n"}
{"1000": "public class JtxTransaction { \npublic void setRollbackOnly ( final Throwable th ) { \nif ( ! isNoTransaction ( ) ) if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) throw new JtxException ( \"TNo active TX that can be marked as rollback only\" ) ; \nrollbackCause = th ; \nstatus = STATUS_MARKED_ROLLBACK ; \n} \n} \n"}
{"1001": "public class JtxTransaction { \nprotected void commitOrRollback ( boolean doCommit ) { \nif ( log . isDebugEnabled ( ) ) if ( doCommit ) log . debug ( \"Commit JTX\" ) ; \nelse log . debug ( \"Rollback JTX\" ) ; \nboolean forcedRollback = false ; \nif ( ! isNoTransaction ( ) ) if ( isRollbackOnly ( ) ) if ( doCommit ) { \ndoCommit = false ; \nforcedRollback = true ; \n} \nelse if ( ! isActive ( ) ) { \nif ( isCompleted ( ) ) throw new JtxException ( \"TX is already completed, commit or rollback should be called once per TX\" ) ; \nthrow new JtxException ( \"No active TX to \" + ( doCommit ? \"commit\" : \"rollback\" ) ) ; \n} \nif ( doCommit ) commitAllResources ( ) ; \nelse rollbackAllResources ( forcedRollback ) ; \n} \n} \n"}
{"1002": "public class JtxTransaction { \nprotected void rollbackAllResources ( final boolean wasForced ) { \nstatus = STATUS_ROLLING_BACK ; \nException lastException = null ; \nIterator < JtxResource > it = resources . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nJtxResource resource = it . next ( ) ; \ntry { \nresource . rollbackTransaction ( ) ; \n} \ncatch ( Exception ex ) { \nlastException = ex ; \n} \nfinally { \nit . remove ( ) ; \n} \n} \ntxManager . removeTransaction ( this ) ; \nstatus = STATUS_ROLLEDBACK ; \nif ( lastException != null ) { \nstatus = STATUS_UNKNOWN ; \nthrow new JtxException ( \"Rollback failed: one or more TX resources couldn't rollback a TX\" , lastException ) ; \n} \nif ( wasForced ) throw new JtxException ( \"TX rolled back because it has been marked as rollback-only\" , rollbackCause ) ; \n} \n} \n"}
{"1003": "public class JtxTransaction { \npublic < E > E requestResource ( final Class < E > resourceType ) { \nif ( isCompleted ( ) ) throw new JtxException ( \"TX is already completed, resource are not available after commit or rollback\" ) ; \nif ( isRollbackOnly ( ) ) throw new JtxException ( \"TX is marked as rollback only, resource are not available\" , rollbackCause ) ; \nif ( ! isNoTransaction ( ) && ! isActive ( ) ) throw new JtxException ( \"Resources are not available since TX is not active\" ) ; \ncheckTimeout ( ) ; \nE resource = lookupResource ( resourceType ) ; \nif ( resource == null ) { \nint maxResources = txManager . getMaxResourcesPerTransaction ( ) ; \nif ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) throw new JtxException ( \"TX already has attached max. number of resources\" ) ; \nJtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; \nresource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; \nresources . add ( new JtxResource < > ( this , resourceManager , resource ) ) ; \n} \nreturn resource ; \n} \n} \n"}
{"1004": "public class JsonWriter { \nprotected void popName ( ) { \nif ( isPushed ) { \nif ( pushedComma ) writeComma ( ) ; \nString name = pushedName ; \npushedName = null ; \nisPushed = false ; \nwriteName ( name ) ; \n} \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nint len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( strictStringEncoding ) write ( \"\\\\/\" ) ; \nelse write ( c ) ; \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( Character . isISOControl ( c ) ) unicode ( c ) ; \nelse write ( c ) ; \n} \n} \nwrite ( StringPool . QUOTE ) ; \n} \n} \n"}
{"1010": "public class Attribute { \npublic boolean isContaining ( final String include ) { \nif ( value == null ) return false ; \nif ( splits == null ) splits = StringUtil . splitc ( value , ' ' ) ; \nfor ( String s : splits ) { \nif ( s . equals ( include ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"1012": "public class PseudoFunctionSelector { \npublic static PseudoFunction < ? > lookupPseudoFunction ( final String pseudoFunctionName ) { \nPseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP . get ( pseudoFunctionName ) ; \nif ( pseudoFunction == null ) throw new CSSellyException ( \"Unsupported pseudo function: \" + pseudoFunctionName ) ; \nreturn pseudoFunction ; \n} \n} \n"}
{"1013": "public class ProxettaClassBuilder { \n@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \nwd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; \naccess &= ~ AsmUtil . ACC_ABSTRACT ; \nfinal int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; \nwd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; \nwd . proxyAspects = new ProxyAspectData [ aspects . length ] ; \nfor ( int i = 0 ; \ni < aspects . length ; \ni ++ ) wd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; \n} \n} \n"}
{"1016": "public class ProxettaClassBuilder { \nprotected void makeProxyConstructor ( ) { \nMethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_PRIVATE | AsmUtil . ACC_FINAL , ProxettaNames . initMethodName , DESC_VOID , null , null ) ; \nmv . visitCode ( ) ; \nif ( wd . adviceInits != null ) for ( String name : wd . adviceInits ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nmv . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , name , DESC_VOID , false ) ; \n} \nmv . visitInsn ( RETURN ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \n} \n} \n"}
{"1017": "public class ProxettaClassBuilder { \nprotected void processSuperMethods ( ) { \nfor ( ClassReader cr : targetClassInfo . superClassReaders ) { \ncr . accept ( new EmptyClassVisitor ( ) { \nString declaredClassName ; \n@ Override public void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \ndeclaredClassName = name ; \n} \n@ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { \nif ( name . equals ( INIT ) || name . equals ( CLINIT ) ) return null ; \nMethodSignatureVisitor msign = targetClassInfo . lookupMethodSignatureVisitor ( access , name , desc , declaredClassName ) ; \nif ( msign == null ) return null ; \nreturn applyProxy ( msign ) ; \n} \n} \n, 0 ) ; \n} \n} \n} \n"}
{"1018": "public class BinarySearchBase { \npublic int findLast ( int low , int high ) { \nint ndx = - 1 ; \nwhile ( low <= high ) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( mid ) ; \nif ( delta > 0 ) high = mid - 1 ; \nelse { \nif ( delta == 0 ) ndx = mid ; \nlow = mid + 1 ; \n} \n} \nif ( ndx == - 1 ) return - ( low + 1 ) ; \nreturn ndx ; \n} \n} \n"}
{"1019": "public class Chalk { \npublic String on ( final String string ) { \nif ( ! enabled ) return string ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nif ( prefix != null ) sb . append ( prefix ) . append ( \"m\" ) ; \nsb . append ( string ) ; \nif ( suffix != null ) sb . append ( suffix ) . append ( \"m\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1024": "public class SqlTypeManager { \npublic SqlType lookup ( final Class clazz ) { \nSqlType sqlType ; \nfor ( Class x = clazz ; \nx != null ; \nx = x . getSuperclass ( ) ) { \nsqlType = types . get ( clazz ) ; \nif ( sqlType != null ) return sqlType ; \nClass [ ] interfaces = x . getInterfaces ( ) ; \nfor ( Class i : interfaces ) { \nsqlType = types . get ( i ) ; \nif ( sqlType != null ) return sqlType ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1029": "public class JtxTransactionManager { \npublic int totalThreadTransactions ( ) { \nArrayList < JtxTransaction > txList = txStack . get ( ) ; \nif ( txList == null ) return 0 ; \nreturn txList . size ( ) ; \n} \n} \n"}
{"1030": "public class JtxTransactionManager { \npublic int totalThreadTransactionsWithStatus ( final JtxStatus status ) { \nArrayList < JtxTransaction > txlist = txStack . get ( ) ; \nif ( txlist == null ) return 0 ; \nint count = 0 ; \nfor ( JtxTransaction tx : txlist ) { \nif ( tx . getStatus ( ) == status ) count ++ ; \n} \nreturn count ; \n} \n} \n"}
{"1032": "public class JtxTransactionManager { \nprotected void continueTx ( final JtxTransaction sourceTx , final JtxTransactionMode destMode ) { \nif ( ! validateExistingTransaction ) return ; \nJtxTransactionMode sourceMode = sourceTx . getTransactionMode ( ) ; \nJtxIsolationLevel destIsolationLevel = destMode . getIsolationLevel ( ) ; \nif ( destIsolationLevel != ISOLATION_DEFAULT ) { \nJtxIsolationLevel currentIsolationLevel = sourceMode . getIsolationLevel ( ) ; \nif ( currentIsolationLevel != destIsolationLevel ) throw new JtxException ( \"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel ) ; \n} \nif ( ( ! destMode . isReadOnly ( ) ) && ( sourceMode . isReadOnly ( ) ) ) throw new JtxException ( \"Participating TX is not marked as read-only, but existing TX is\" ) ; \n} \n} \n"}
{"1033": "public class JtxTransactionManager { \nprotected < E > JtxResourceManager < E > lookupResourceManager ( final Class < E > resourceType ) { \nJtxResourceManager < E > resourceManager = this . resourceManagers . get ( resourceType ) ; \nif ( resourceManager == null ) throw new JtxException ( \"No registered resource manager for resource type: \" + resourceType . getSimpleName ( ) ) ; \nreturn resourceManager ; \n} \n} \n"}
{"1035": "public class Pathref { \nprotected void append ( final String methodName ) { \nif ( path . length ( ) != 0 ) path += StringPool . DOT ; \nif ( methodName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ) path = StringUtil . substring ( path , 0 , - 1 ) ; \npath += methodName ; \n} \n} \n"}
{"1036": "public class Format { \npublic static String alignLeftAndPad ( final String text , final int size ) { \nint textLength = text . length ( ) ; \nif ( textLength > size ) return text . substring ( 0 , size ) ; \nfinal StringBuilder sb = new StringBuilder ( size ) ; \nsb . append ( text ) ; \nwhile ( textLength ++ < size ) sb . append ( ' ' ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) return StringPool . NULL ; \nfinal Class < ? > type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( componentType == int . class ) sb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \nelse if ( componentType == long . class ) sb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \nelse if ( componentType == double . class ) sb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \nelse if ( componentType == float . class ) sb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \nelse if ( componentType == boolean . class ) sb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \nelse if ( componentType == short . class ) sb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \nelse if ( componentType == byte . class ) sb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \nelse throw new IllegalArgumentException ( ) ; \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( i > 0 ) sb . append ( ',' ) ; \nsb . append ( toPrettyString ( array [ i ] ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse if ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nint i = 0 ; \nfor ( final Object o : iterable ) { \nif ( i > 0 ) sb . append ( ',' ) ; \nsb . append ( toPrettyString ( o ) ) ; \ni ++ ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal int length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ch == separator ) upperCase = true ; \nelse if ( upperCase ) { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse sb . append ( ch ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1039": "public class Format { \npublic static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { \nStringBuilder str = new StringBuilder ( ) ; \nint total = src . length ( ) ; \nint from = 0 ; \nwhile ( from < total ) { \nint to = from + len ; \nif ( to >= total ) to = total ; \nelse if ( breakOnWhitespace ) { \nint ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; \nif ( ndx != - 1 ) to = ndx + 1 ; \n} \nint cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; \nif ( cutFrom != - 1 ) { \nint cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; \nstr . append ( src , cutFrom , cutTo ) ; \n} \nstr . append ( '\\n' ) ; \nfrom = to ; \n} \nreturn str . toString ( ) ; \n} \n} \n"}
{"1040": "public class Format { \npublic static String convertTabsToSpaces ( final String line , final int tabWidth ) { \nint tab_index , tab_size ; \nint last_tab_index = 0 ; \nint added_chars = 0 ; \nif ( tabWidth == 0 ) return StringUtil . remove ( line , '\\t' ) ; \nStringBuilder result = new StringBuilder ( ) ; \nwhile ( ( tab_index = line . indexOf ( '\\t' , last_tab_index ) ) != - 1 ) { \ntab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; \nif ( tab_size == 0 ) tab_size = tabWidth ; \nadded_chars += tab_size - 1 ; \nresult . append ( line , last_tab_index , tab_index ) ; \nresult . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; \nlast_tab_index = tab_index + 1 ; \n} \nif ( last_tab_index == 0 ) return line ; \nresult . append ( line . substring ( last_tab_index ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1041": "public class Format { \npublic static String escapeJava ( final String string ) { \nint strLen = string . length ( ) ; \nStringBuilder sb = new StringBuilder ( strLen ) ; \nfor ( int i = 0 ; \ni < strLen ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nswitch ( c ) { \ncase '\\b' : sb . append ( \"\\\\b\" ) ; \nbreak ; \ncase '\\t' : sb . append ( \"\\\\t\" ) ; \nbreak ; \ncase '\\n' : sb . append ( \"\\\\n\" ) ; \nbreak ; \ncase '\\f' : sb . append ( \"\\\\f\" ) ; \nbreak ; \ncase '\\r' : sb . append ( \"\\\\r\" ) ; \nbreak ; \ncase '\\\"' : sb . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : sb . append ( \"\\\\\\\\\" ) ; \nbreak ; \ndefault : if ( ( c < 32 ) || ( c > 127 ) ) { \nString hex = Integer . toHexString ( c ) ; \nsb . append ( \"\\\\u\" ) ; \nfor ( int k = hex . length ( ) ; \nk < 4 ; \nk ++ ) sb . append ( '0' ) ; \nsb . append ( hex ) ; \n} \nelse sb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1044": "public class PetiteContainer { \npublic < T > T getBean ( final String name ) { \nBeanDefinition def = lookupBeanDefinition ( name ) ; \nif ( def == null ) { \nProviderDefinition providerDefinition = providers . get ( name ) ; \nif ( providerDefinition != null ) return ( T ) invokeProvider ( providerDefinition ) ; \nreturn null ; \n} \nObject bean = def . scopeLookup ( ) ; \nif ( bean == null ) { \ninitBeanDefinition ( def ) ; \nfinal BeanData beanData = new BeanData ( this , def ) ; \nregisterBeanAndWireAndInjectParamsAndInvokeInitMethods ( beanData ) ; \nbean = beanData . bean ( ) ; \n} \nreturn ( T ) bean ; \n} \n} \n"}
{"1045": "public class PetiteContainer { \nprotected void initBeanDefinition ( final BeanDefinition def ) { \nif ( def . initMethods == null ) def . initMethods = petiteResolvers . resolveInitMethodPoint ( def . type ) ; \nif ( def . destroyMethods == null ) def . destroyMethods = petiteResolvers . resolveDestroyMethodPoint ( def . type ) ; \nif ( def . properties == null ) def . properties = petiteResolvers . resolvePropertyInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; \nif ( def . methods == null ) def . methods = petiteResolvers . resolveMethodInjectionPoint ( def . type ) ; \nif ( def . ctor == null ) def . ctor = petiteResolvers . resolveCtorInjectionPoint ( def . type ) ; \nif ( def . values == null ) def . values = paramManager . resolveParamInjectionPoints ( def . type ) ; \nif ( def . sets == null ) def . sets = petiteResolvers . resolveSetInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; \nif ( def . params == null ) def . params = paramManager . filterParametersForBeanName ( def . name , petiteConfig . getResolveReferenceParameters ( ) ) ; \n} \n} \n"}
{"1046": "public class PetiteContainer { \nprotected Object invokeProvider ( final ProviderDefinition provider ) { \nif ( provider . method != null ) { \nfinal Object bean ; \nif ( provider . beanName != null ) bean = getBean ( provider . beanName ) ; \nelse bean = null ; \ntry { \nreturn provider . method . invoke ( bean ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid provider method: \" + provider . method . getName ( ) , ex ) ; \n} \n} \nthrow new PetiteException ( \"Invalid provider\" ) ; \n} \n} \n"}
{"1048": "public class PetiteContainer { \npublic void setBeanProperty ( final String name , final Object value ) { \nObject bean = null ; \nint ndx = name . length ( ) ; \nwhile ( true ) { \nndx = name . lastIndexOf ( '.' , ndx ) ; \nif ( ndx == - 1 ) break ; \nString beanName = name . substring ( 0 , ndx ) ; \nbean = getBean ( beanName ) ; \nif ( bean != null ) break ; \nndx -- ; \n} \nif ( bean == null ) throw new PetiteException ( \"Invalid bean property: \" + name ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \n} \n} \n"}
{"1049": "public class PetiteContainer { \npublic Object getBeanProperty ( final String name ) { \nint ndx = name . indexOf ( '.' ) ; \nif ( ndx == - 1 ) throw new PetiteException ( \"Only bean name is specified, missing property name: \" + name ) ; \nString beanName = name . substring ( 0 , ndx ) ; \nObject bean = getBean ( beanName ) ; \nif ( bean == null ) throw new PetiteException ( \"Bean doesn't exist: \" + name ) ; \ntry { \nreturn BeanUtil . declared . getProperty ( bean , name . substring ( ndx + 1 ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \n} \n} \n"}
{"1051": "public class Paramo { \npublic static MethodParameter [ ] resolveParameters ( final AccessibleObject methodOrCtor ) { \nClass [ ] paramTypes ; \nClass declaringClass ; \nString name ; \nif ( methodOrCtor instanceof Method ) { \nMethod method = ( Method ) methodOrCtor ; \nparamTypes = method . getParameterTypes ( ) ; \nname = method . getName ( ) ; \ndeclaringClass = method . getDeclaringClass ( ) ; \n} \nelse { \nConstructor constructor = ( Constructor ) methodOrCtor ; \nparamTypes = constructor . getParameterTypes ( ) ; \ndeclaringClass = constructor . getDeclaringClass ( ) ; \nname = CTOR_METHOD ; \n} \nif ( paramTypes . length == 0 ) return MethodParameter . EMPTY_ARRAY ; \nInputStream stream ; \ntry { \nstream = ClassLoaderUtil . getClassAsStream ( declaringClass ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ParamoException ( \"Failed to read class bytes: \" + declaringClass . getName ( ) , ioex ) ; \n} \nif ( stream == null ) throw new ParamoException ( \"Class not found: \" + declaringClass ) ; \ntry { \nClassReader reader = new ClassReader ( stream ) ; \nMethodFinder visitor = new MethodFinder ( declaringClass , name , paramTypes ) ; \nreader . accept ( visitor , 0 ) ; \nreturn visitor . getResolvedParameters ( ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ParamoException ( ioex ) ; \n} \nfinally { \nStreamUtil . close ( stream ) ; \n} \n} \n} \n"}
{"1053": "public class PropsEntry { \npublic String getValue ( final String ... profiles ) { \nif ( hasMacro ) return propsData . resolveMacros ( value , profiles ) ; \nreturn value ; \n} \n} \n"}
{"1054": "public class LagartoDOMBuilderTagVisitor { \n@ Override public void end ( ) { \nif ( parentNode != rootNode ) { \nNode thisNode = parentNode ; \nwhile ( thisNode != rootNode ) { \nif ( domBuilder . config . isImpliedEndTags ( ) ) if ( implRules . implicitlyCloseTagOnEOF ( thisNode . getNodeName ( ) ) ) { \nthisNode = thisNode . getParentNode ( ) ; \ncontinue ; \n} \nerror ( \"Unclosed tag closed: <\" + thisNode . getNodeName ( ) + \">\" ) ; \nthisNode = thisNode . getParentNode ( ) ; \n} \n} \nif ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , true ) ; \nif ( domBuilder . config . isUseFosterRules ( ) ) { \nHtmlFosterRules fosterRules = new HtmlFosterRules ( ) ; \nfosterRules . fixFosterElements ( rootNode ) ; \n} \nrootNode . end ( ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"LagartoDom tree created in \" + rootNode . getElapsedTime ( ) + \" ms\" ) ; \n} \n} \n"}
{"1055": "public class LagartoDOMBuilderTagVisitor { \nprotected Element createElementNode ( final Tag tag ) { \nboolean hasVoidTags = htmlVoidRules != null ; \nboolean isVoid = false ; \nboolean selfClosed = false ; \nif ( hasVoidTags ) { \nisVoid = htmlVoidRules . isVoidTag ( tag . getName ( ) ) ; \nif ( isVoid ) selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; \n} \nelse selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; \nreturn new Element ( rootNode , tag , isVoid , selfClosed ) ; \n} \n} \n"}
{"1056": "public class LagartoDOMBuilderTagVisitor { \n@ Override public void tag ( final Tag tag ) { \nif ( ! enabled ) return ; \nTagType tagType = tag . getType ( ) ; \nElement node ; \nswitch ( tagType ) { \ncase START : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , false ) ; \nnode = createElementNode ( tag ) ; \nif ( domBuilder . config . isImpliedEndTags ( ) ) while ( true ) { \nString parentNodeName = parentNode . getNodeName ( ) ; \nif ( ! implRules . implicitlyCloseParentTagOnNewTag ( parentNodeName , node . getNodeName ( ) ) ) break ; \nparentNode = parentNode . getParentNode ( ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Implicitly closed tag <\" + node . getNodeName ( ) + \"> \" ) ; \n} \nparentNode . addChild ( node ) ; \nif ( ! node . isVoidElement ( ) ) parentNode = node ; \nbreak ; \ncase END : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , true ) ; \nString tagName = tag . getName ( ) . toString ( ) ; \nNode matchingParent = findMatchingParentOpenTag ( tagName ) ; \nif ( matchingParent == parentNode ) { \nparentNode = parentNode . getParentNode ( ) ; \nbreak ; \n} \nif ( matchingParent == null ) { \nerror ( \"Orphan closed tag ignored: </\" + tagName + \"> \" + tag . getTagPosition ( ) ) ; \nbreak ; \n} \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nboolean fixed = false ; \nwhile ( implRules . implicitlyCloseParentTagOnTagEnd ( parentNode . getNodeName ( ) , tagName ) ) { \nparentNode = parentNode . getParentNode ( ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Implicitly closed tag <\" + tagName + \">\" ) ; \nif ( parentNode == matchingParent ) { \nparentNode = matchingParent . parentNode ; \nfixed = true ; \nbreak ; \n} \n} \nif ( fixed ) break ; \n} \nfixUnclosedTagsUpToMatchingParent ( tag , matchingParent ) ; \nbreak ; \ncase SELF_CLOSING : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , false ) ; \nnode = createElementNode ( tag ) ; \nparentNode . addChild ( node ) ; \nbreak ; \n} \n} \n} \n"}
{"1057": "public class LagartoDOMBuilderTagVisitor { \nprotected void removeLastChildNodeIfEmptyText ( final Node parentNode , final boolean closedTag ) { \nif ( parentNode == null ) return ; \nNode lastChild = parentNode . getLastChild ( ) ; \nif ( lastChild == null ) return ; \nif ( lastChild . getNodeType ( ) != Node . NodeType . TEXT ) return ; \nif ( closedTag ) if ( parentNode . getChildNodesCount ( ) == 1 ) return ; \nText text = ( Text ) lastChild ; \nif ( text . isBlank ( ) ) lastChild . detachFromParent ( ) ; \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) return toString ( ) ; \nif ( parameterValues == null ) return sqlTemplate ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nint qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nwhile ( tok . hasMoreTokens ( ) ) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( parameterValues . size ( ) > 1 + qMarkCount ) { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount ++ ; \n} \nelse if ( ! tok . hasMoreTokens ( ) ) value = \"\" ; \nif ( value == null ) value = \"?\" ; \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1060": "public class IteratorTag { \nprotected int calculateTo ( final int from , final int count , final int size ) { \nint to = size ; \nif ( count != - 1 ) { \nto = from + count ; \nif ( to > size ) to = size ; \n} \nreturn to ; \n} \n} \n"}
{"1061": "public class IteratorTag { \nprotected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nIterator iter = collection . iterator ( ) ; \nint i = 0 ; \nint to = calculateTo ( from , count , collection . size ( ) ) ; \nwhile ( i < to ) { \nObject item = iter . next ( ) ; \nif ( i >= from ) { \nif ( status != null ) iteratorStatus . next ( ! iter . hasNext ( ) ) ; \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \ni ++ ; \n} \n} \n} \n"}
{"1062": "public class IteratorTag { \nprotected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nint len = array . length ; \nint to = calculateTo ( from , count , len ) ; \nint last = to - 1 ; \nfor ( int i = from ; \ni < to ; \ni ++ ) { \nObject item = array [ i ] ; \nif ( status != null ) iteratorStatus . next ( i == last ) ; \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \n} \n} \n"}
{"1063": "public class StringUtil { \npublic static String replace ( final String s , final String sub , final String with ) { \nif ( sub . isEmpty ( ) ) return s ; \nint c = 0 ; \nint i = s . indexOf ( sub , c ) ; \nif ( i == - 1 ) return s ; \nint length = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( length + with . length ( ) ) ; \ndo { \nsb . append ( s , c , i ) ; \nsb . append ( with ) ; \nc = i + sub . length ( ) ; \n} \nwhile ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; \nif ( c < length ) sb . append ( s , c , length ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1064": "public class StringUtil { \npublic static String replaceChar ( final String s , final char sub , final char with ) { \nint startIndex = s . indexOf ( sub ) ; \nif ( startIndex == - 1 ) return s ; \nchar [ ] str = s . toCharArray ( ) ; \nfor ( int i = startIndex ; \ni < str . length ; \ni ++ ) if ( str [ i ] == sub ) str [ i ] = with ; \nreturn new String ( str ) ; \n} \n} \n"}
{"1065": "public class StringUtil { \npublic static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { \nchar [ ] str = s . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < str . length ; \ni ++ ) { \nchar c = str [ i ] ; \nfor ( int j = 0 ; \nj < sub . length ; \nj ++ ) if ( c == sub [ j ] ) { \nstr [ i ] = with [ j ] ; \nbreak ; \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1066": "public class StringUtil { \npublic static String replaceFirst ( final String s , final String sub , final String with ) { \nint i = s . indexOf ( sub ) ; \nif ( i == - 1 ) return s ; \nreturn s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; \n} \n} \n"}
{"1067": "public class StringUtil { \npublic static String replaceFirst ( final String s , final char sub , final char with ) { \nint index = s . indexOf ( sub ) ; \nif ( index == - 1 ) return s ; \nchar [ ] str = s . toCharArray ( ) ; \nstr [ index ] = with ; \nreturn new String ( str ) ; \n} \n} \n"}
{"1068": "public class StringUtil { \npublic static String replaceLast ( final String s , final String sub , final String with ) { \nint i = s . lastIndexOf ( sub ) ; \nif ( i == - 1 ) return s ; \nreturn s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; \n} \n} \n"}
{"1069": "public class StringUtil { \npublic static String replaceLast ( final String s , final char sub , final char with ) { \nint index = s . lastIndexOf ( sub ) ; \nif ( index == - 1 ) return s ; \nchar [ ] str = s . toCharArray ( ) ; \nstr [ index ] = with ; \nreturn new String ( str ) ; \n} \n} \n"}
{"1070": "public class StringUtil { \npublic static String remove ( final String s , final String sub ) { \nint c = 0 ; \nint sublen = sub . length ( ) ; \nif ( sublen == 0 ) return s ; \nint i = s . indexOf ( sub , c ) ; \nif ( i == - 1 ) return s ; \nStringBuilder sb = new StringBuilder ( s . length ( ) ) ; \ndo { \nsb . append ( s , c , i ) ; \nc = i + sublen ; \n} \nwhile ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; \nif ( c < s . length ( ) ) sb . append ( s , c , s . length ( ) ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1071": "public class StringUtil { \npublic static String remove ( final String string , final char ch ) { \nint stringLen = string . length ( ) ; \nchar [ ] result = new char [ stringLen ] ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < stringLen ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nif ( c == ch ) continue ; \nresult [ offset ] = c ; \noffset ++ ; \n} \nif ( offset == stringLen ) return string ; \nreturn new String ( result , 0 , offset ) ; \n} \n} \n"}
{"1072": "public class StringUtil { \npublic static boolean isAllEmpty ( final String ... strings ) { \nfor ( String string : strings ) { \nif ( ! isEmpty ( string ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1073": "public class StringUtil { \npublic static boolean isAllBlank ( final String ... strings ) { \nfor ( String string : strings ) { \nif ( ! isBlank ( string ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1074": "public class StringUtil { \npublic static String [ ] toStringArray ( final Object value ) { \nif ( value == null ) return new String [ 0 ] ; \nClass < ? > type = value . getClass ( ) ; \nif ( ! type . isArray ( ) ) return new String [ ] { \nvalue . toString ( ) } \n; \nClass componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) if ( componentType == int . class ) return ArraysUtil . toStringArray ( ( int [ ] ) value ) ; \nelse if ( componentType == long . class ) return ArraysUtil . toStringArray ( ( long [ ] ) value ) ; \nelse if ( componentType == double . class ) return ArraysUtil . toStringArray ( ( double [ ] ) value ) ; \nelse if ( componentType == float . class ) return ArraysUtil . toStringArray ( ( float [ ] ) value ) ; \nelse if ( componentType == boolean . class ) return ArraysUtil . toStringArray ( ( boolean [ ] ) value ) ; \nelse if ( componentType == short . class ) return ArraysUtil . toStringArray ( ( short [ ] ) value ) ; \nelse if ( componentType == byte . class ) return ArraysUtil . toStringArray ( ( byte [ ] ) value ) ; \nelse throw new IllegalArgumentException ( ) ; \nelse return ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; \n} \n} \n"}
{"1075": "public class StringUtil { \nprivate static String changeFirstCharacterCase ( final boolean capitalize , final String string ) { \nint strLen = string . length ( ) ; \nif ( strLen == 0 ) return string ; \nchar ch = string . charAt ( 0 ) ; \nchar modifiedCh ; \nif ( capitalize ) modifiedCh = Character . toUpperCase ( ch ) ; \nelse modifiedCh = Character . toLowerCase ( ch ) ; \nif ( modifiedCh == ch ) return string ; \nchar [ ] chars = string . toCharArray ( ) ; \nchars [ 0 ] = modifiedCh ; \nreturn new String ( chars ) ; \n} \n} \n"}
{"1076": "public class StringUtil { \npublic static String title ( final String string ) { \nchar [ ] chars = string . toCharArray ( ) ; \nboolean wasWhitespace = true ; \nfor ( int i = 0 ; \ni < chars . length ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( CharUtil . isWhitespace ( c ) ) wasWhitespace = true ; \nelse { \nif ( wasWhitespace ) chars [ i ] = Character . toUpperCase ( c ) ; \nelse chars [ i ] = Character . toLowerCase ( c ) ; \nwasWhitespace = false ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1077": "public class StringUtil { \npublic static String compressChars ( final String s , final char c ) { \nint len = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( len ) ; \nboolean wasChar = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c1 = s . charAt ( i ) ; \nif ( c1 == c ) { \nif ( wasChar ) continue ; \nwasChar = true ; \n} \nelse wasChar = false ; \nsb . append ( c1 ) ; \n} \nif ( sb . length ( ) == len ) return s ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1078": "public class StringUtil { \npublic static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { \nString sub = subS . toLowerCase ( ) ; \nint sublen = sub . length ( ) ; \nif ( startIndex + sublen > src . length ( ) ) return false ; \nint j = 0 ; \nint i = startIndex ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( src . charAt ( i ) ) ; \nif ( sub . charAt ( j ) != source ) return false ; \nj ++ ; \ni ++ ; \n} \nreturn true ; \n} \n} \n"}
{"1079": "public class StringUtil { \npublic static boolean endsWithChar ( final String s , final char c ) { \nif ( s . length ( ) == 0 ) return false ; \nreturn s . charAt ( s . length ( ) - 1 ) == c ; \n} \n} \n"}
{"1080": "public class StringUtil { \npublic static int countIgnoreCase ( final String source , final String sub ) { \nint count = 0 ; \nint j = 0 ; \nint sublen = sub . length ( ) ; \nif ( sublen == 0 ) return 0 ; \nwhile ( true ) { \nint i = indexOfIgnoreCase ( source , sub , j ) ; \nif ( i == - 1 ) break ; \ncount ++ ; \nj = i + sublen ; \n} \nreturn count ; \n} \n} \n"}
{"1081": "public class StringUtil { \npublic static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { \nif ( as . length != as1 . length ) return false ; \nfor ( int i = 0 ; \ni < as . length ; \ni ++ ) if ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) return false ; \nreturn true ; \n} \n} \n"}
{"1082": "public class StringUtil { \npublic static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { \nfor ( int i = startindex ; \ni < endindex ; \ni ++ ) if ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"1083": "public class StringUtil { \npublic static String stripLeadingChar ( final String string , final char c ) { \nif ( string . length ( ) > 0 ) if ( string . charAt ( 0 ) == c ) return string . substring ( 1 ) ; \nreturn string ; \n} \n} \n"}
{"1084": "public class StringUtil { \npublic static String stripTrailingChar ( final String string , final char c ) { \nif ( string . length ( ) > 0 ) if ( string . charAt ( string . length ( ) - 1 ) == c ) return string . substring ( 0 , string . length ( ) - 1 ) ; \nreturn string ; \n} \n} \n"}
{"1085": "public class StringUtil { \npublic static String stripChar ( final String string , final char c ) { \nif ( string . length ( ) == 0 ) return string ; \nif ( string . length ( ) == 1 ) { \nif ( string . charAt ( 0 ) == c ) return StringPool . EMPTY ; \nreturn string ; \n} \nint left = 0 ; \nint right = string . length ( ) ; \nif ( string . charAt ( left ) == c ) left ++ ; \nif ( string . charAt ( right - 1 ) == c ) right -- ; \nreturn string . substring ( left , right ) ; \n} \n} \n"}
{"1086": "public class StringUtil { \npublic static String stripToChar ( final String string , final char c ) { \nint ndx = string . indexOf ( c ) ; \nif ( ndx == - 1 ) return string ; \nreturn string . substring ( ndx ) ; \n} \n} \n"}
{"1087": "public class StringUtil { \npublic static String stripFromChar ( final String string , final char c ) { \nint ndx = string . indexOf ( c ) ; \nif ( ndx == - 1 ) return string ; \nreturn string . substring ( 0 , ndx ) ; \n} \n} \n"}
{"1088": "public class StringUtil { \npublic static void cropAll ( final String ... strings ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni ++ ) { \nString string = strings [ i ] ; \nif ( string != null ) string = crop ( strings [ i ] ) ; \nstrings [ i ] = string ; \n} \n} \n} \n"}
{"1089": "public class StringUtil { \npublic static String trimLeft ( final String src ) { \nint len = src . length ( ) ; \nint st = 0 ; \nwhile ( ( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) st ++ ; \nreturn st > 0 ? src . substring ( st ) : src ; \n} \n} \n"}
{"1090": "public class StringUtil { \npublic static String trimRight ( final String src ) { \nint len = src . length ( ) ; \nint count = len ; \nwhile ( ( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) len -- ; \nreturn ( len < count ) ? src . substring ( 0 , len ) : src ; \n} \n} \n"}
{"1091": "public class StringUtil { \npublic static int [ ] indexOfRegion ( final String string , final String leftBoundary , final String rightBoundary , final int offset ) { \nint ndx = offset ; \nint [ ] res = new int [ 4 ] ; \nndx = string . indexOf ( leftBoundary , ndx ) ; \nif ( ndx == - 1 ) return null ; \nres [ 0 ] = ndx ; \nndx += leftBoundary . length ( ) ; \nres [ 1 ] = ndx ; \nndx = string . indexOf ( rightBoundary , ndx ) ; \nif ( ndx == - 1 ) return null ; \nres [ 2 ] = ndx ; \nres [ 3 ] = ndx + rightBoundary . length ( ) ; \nreturn res ; \n} \n} \n"}
{"1092": "public class StringUtil { \npublic static String join ( final Collection collection , final char separator ) { \nif ( collection == null ) return null ; \nif ( collection . size ( ) == 0 ) return StringPool . EMPTY ; \nfinal StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; \nfinal Iterator it = collection . iterator ( ) ; \nfor ( int i = 0 ; \ni < collection . size ( ) ; \ni ++ ) { \nif ( i > 0 ) sb . append ( separator ) ; \nsb . append ( it . next ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1093": "public class StringUtil { \npublic static String join ( final Object [ ] array , final String separator ) { \nif ( array == null ) return null ; \nif ( array . length == 0 ) return StringPool . EMPTY ; \nif ( array . length == 1 ) return String . valueOf ( array [ 0 ] ) ; \nfinal StringBuilder sb = new StringBuilder ( array . length * 16 ) ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( i > 0 ) sb . append ( separator ) ; \nsb . append ( array [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1094": "public class StringUtil { \npublic static String convertCharset ( final String source , final String srcCharsetName , final String newCharsetName ) { \nif ( srcCharsetName . equals ( newCharsetName ) ) return source ; \nreturn StringUtil . newString ( StringUtil . getBytes ( source , srcCharsetName ) , newCharsetName ) ; \n} \n} \n"}
{"1095": "public class StringUtil { \npublic static boolean isCharAtEqual ( final String string , final int index , final char charToCompare ) { \nif ( ( index < 0 ) || ( index >= string . length ( ) ) ) return false ; \nreturn string . charAt ( index ) == charToCompare ; \n} \n} \n"}
{"1096": "public class StringUtil { \npublic static String surround ( String string , final String prefix , final String suffix ) { \nif ( ! string . startsWith ( prefix ) ) string = prefix + string ; \nif ( ! string . endsWith ( suffix ) ) string += suffix ; \nreturn string ; \n} \n} \n"}
{"1097": "public class StringUtil { \npublic static String prefix ( String string , final String prefix ) { \nif ( ! string . startsWith ( prefix ) ) string = prefix + string ; \nreturn string ; \n} \n} \n"}
{"1098": "public class StringUtil { \npublic static String suffix ( String string , final String suffix ) { \nif ( ! string . endsWith ( suffix ) ) string += suffix ; \nreturn string ; \n} \n} \n"}
{"1099": "public class StringUtil { \npublic static String cutToIndexOf ( String string , final String substring ) { \nint i = string . indexOf ( substring ) ; \nif ( i != - 1 ) string = string . substring ( 0 , i ) ; \nreturn string ; \n} \n} \n"}
{"1100": "public class StringUtil { \npublic static String cutFromIndexOf ( String string , final String substring ) { \nint i = string . indexOf ( substring ) ; \nif ( i != - 1 ) string = string . substring ( i ) ; \nreturn string ; \n} \n} \n"}
{"1101": "public class StringUtil { \npublic static String cutPrefix ( String string , final String prefix ) { \nif ( string . startsWith ( prefix ) ) string = string . substring ( prefix . length ( ) ) ; \nreturn string ; \n} \n} \n"}
{"1102": "public class StringUtil { \npublic static String cutSuffix ( String string , final String suffix ) { \nif ( string . endsWith ( suffix ) ) string = string . substring ( 0 , string . length ( ) - suffix . length ( ) ) ; \nreturn string ; \n} \n} \n"}
{"1103": "public class StringUtil { \npublic static String cutSurrounding ( final String string , final String prefix , final String suffix ) { \nint start = 0 ; \nint end = string . length ( ) ; \nif ( string . startsWith ( prefix ) ) start = prefix . length ( ) ; \nif ( string . endsWith ( suffix ) ) end -= suffix . length ( ) ; \nif ( end <= start ) return StringPool . EMPTY ; \nreturn string . substring ( start , end ) ; \n} \n} \n"}
{"1104": "public class StringUtil { \npublic static String insert ( final String src , final String insert , int offset ) { \nif ( offset < 0 ) offset = 0 ; \nif ( offset > src . length ( ) ) offset = src . length ( ) ; \nStringBuilder sb = new StringBuilder ( src ) ; \nsb . insert ( offset , insert ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1106": "public class StringUtil { \npublic static String reverse ( final String s ) { \nStringBuilder result = new StringBuilder ( s . length ( ) ) ; \nfor ( int i = s . length ( ) - 1 ; \ni >= 0 ; \ni -- ) result . append ( s . charAt ( i ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1107": "public class StringUtil { \npublic static String maxCommonPrefix ( final String one , final String two ) { \nfinal int minLength = Math . min ( one . length ( ) , two . length ( ) ) ; \nfinal StringBuilder sb = new StringBuilder ( minLength ) ; \nfor ( int pos = 0 ; \npos < minLength ; \npos ++ ) { \nfinal char currentChar = one . charAt ( pos ) ; \nif ( currentChar != two . charAt ( pos ) ) break ; \nsb . append ( currentChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni ++ ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) break loop ; \nif ( i == 0 ) c = s . charAt ( index ) ; \nelse if ( s . charAt ( index ) != c ) break loop ; \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1109": "public class StringUtil { \npublic static String shorten ( String s , int length , final String suffix ) { \nlength -= suffix . length ( ) ; \nif ( s . length ( ) > length ) { \nfor ( int j = length ; \nj >= 0 ; \nj -- ) if ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { \nlength = j ; \nbreak ; \n} \nString temp = s . substring ( 0 , length ) ; \ns = temp . concat ( suffix ) ; \n} \nreturn s ; \n} \n} \n"}
{"1110": "public class StringUtil { \npublic static String toUpperCase ( final String s , Locale locale ) { \nif ( s == null ) return null ; \nStringBuilder sb = null ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c > 127 ) { \nif ( locale == null ) locale = Locale . getDefault ( ) ; \nreturn s . toUpperCase ( locale ) ; \n} \nif ( ( c >= 'a' ) && ( c <= 'z' ) ) { \nif ( sb == null ) sb = new StringBuilder ( s ) ; \nsb . setCharAt ( i , ( char ) ( c - 32 ) ) ; \n} \n} \nif ( sb == null ) return s ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1111": "public class StringUtil { \npublic static String removeQuotes ( final String string ) { \nif ( ( startsWithChar ( string , '\\'' ) && endsWithChar ( string , '\\'' ) ) || ( startsWithChar ( string , '\"' ) && endsWithChar ( string , '\"' ) ) || ( startsWithChar ( string , '`' ) && endsWithChar ( string , '`' ) ) ) return substring ( string , 1 , - 1 ) ; \nreturn string ; \n} \n} \n"}
{"1114": "public class StringUtil { \npublic static char detectQuoteChar ( final String str ) { \nif ( str . length ( ) < 2 ) return 0 ; \nfinal char c = str . charAt ( 0 ) ; \nif ( c != str . charAt ( str . length ( ) - 1 ) ) return 0 ; \nif ( c == '\\'' || c == '\"' || c == '`' ) return c ; \nreturn 0 ; \n} \n} \n"}
{"1115": "public class AnnotationVisitor { \npublic void visit ( final String name , final Object value ) { \nif ( av != null ) av . visit ( name , value ) ; \n} \n} \n"}
{"1116": "public class AnnotationVisitor { \npublic void visitEnum ( final String name , final String descriptor , final String value ) { \nif ( av != null ) av . visitEnum ( name , descriptor , value ) ; \n} \n} \n"}
{"1117": "public class AnnotationVisitor { \npublic AnnotationVisitor visitAnnotation ( final String name , final String descriptor ) { \nif ( av != null ) return av . visitAnnotation ( name , descriptor ) ; \nreturn null ; \n} \n} \n"}
{"1118": "public class DbEntityManager { \npublic < E > DbEntityDescriptor < E > registerType ( final Class < E > type ) { \nDbEntityDescriptor < E > ded = createDbEntityDescriptor ( type ) ; \nDbEntityDescriptor < E > existing = descriptorsMap . put ( type , ded ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Register \" + type . getName ( ) + \" as \" + ded . getTableName ( ) ) ; \nif ( existing != null ) { \nif ( ded . getType ( ) == type ) return ded ; \nthrow new DbOomException ( \"Type already registered: \" + existing . getType ( ) ) ; \n} \nexisting = entityNamesMap . put ( ded . getEntityName ( ) , ded ) ; \nif ( existing != null ) throw new DbOomException ( \"Name '\" + ded . getEntityName ( ) + \"' already mapped to an entity: \" + existing . getType ( ) ) ; \nreturn ded ; \n} \n} \n"}
{"1119": "public class DbEntityManager { \npublic < E > DbEntityDescriptor < E > registerEntity ( final Class < E > type , final boolean force ) { \nif ( force ) removeEntity ( type ) ; \nreturn registerEntity ( type ) ; \n} \n} \n"}
{"1120": "public class DbEntityManager { \npublic < E > DbEntityDescriptor < E > removeEntity ( final Class < E > type ) { \nDbEntityDescriptor < E > ded = descriptorsMap . remove ( type ) ; \nif ( ded == null ) ded = createDbEntityDescriptor ( type ) ; \nentityNamesMap . remove ( ded . getEntityName ( ) ) ; \ntableNamesMap . remove ( ded . getTableName ( ) ) ; \nreturn ded ; \n} \n} \n"}
{"1122": "public class WrapperProxettaFactory { \npublic WrapperProxettaFactory setTargetInterface ( final Class targetInterface ) { \nif ( ! targetInterface . isInterface ( ) ) throw new ProxettaException ( \"Not an interface: \" + targetInterface . getName ( ) ) ; \nthis . targetInterface = targetInterface ; \nreturn this ; \n} \n} \n"}
{"1124": "public class AnnotatedPropertyInterceptor { \nprotected PropertyDescriptor [ ] lookupAnnotatedProperties ( final Class type ) { \nPropertyDescriptor [ ] properties = annotatedProperties . get ( type ) ; \nif ( properties != null ) return properties ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nPropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nList < PropertyDescriptor > list = new ArrayList < > ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nAnnotation ann = null ; \nif ( propertyDescriptor . getFieldDescriptor ( ) != null ) ann = propertyDescriptor . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( annotations ) ; \nif ( ann == null && propertyDescriptor . getWriteMethodDescriptor ( ) != null ) ann = propertyDescriptor . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; \nif ( ann == null && propertyDescriptor . getReadMethodDescriptor ( ) != null ) ann = propertyDescriptor . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; \nif ( ann != null ) list . add ( propertyDescriptor ) ; \n} \nif ( list . isEmpty ( ) ) properties = EMPTY ; \nelse properties = list . toArray ( new PropertyDescriptor [ 0 ] ) ; \nannotatedProperties . put ( type , properties ) ; \nreturn properties ; \n} \n} \n"}
{"1126": "public class GzipResponseStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) return ; \nif ( gzipstream != null ) { \nflushToGZip ( ) ; \ngzipstream . close ( ) ; \ngzipstream = null ; \n} \nelse if ( bufferCount > 0 ) { \noutput . write ( buffer , 0 , bufferCount ) ; \nbufferCount = 0 ; \n} \noutput . close ( ) ; \nclosed = true ; \n} \n} \n"}
{"1127": "public class GzipResponseStream { \n@ Override public void write ( final int b ) throws IOException { \nif ( closed ) throw new IOException ( \"Cannot write to a closed output stream\" ) ; \nif ( bufferCount >= buffer . length ) flushToGZip ( ) ; \nbuffer [ bufferCount ++ ] = ( byte ) b ; \n} \n} \n"}
{"1128": "public class RemoveSessionFromUrlFilter { \n@ Override public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain chain ) throws IOException , ServletException { \nHttpServletRequest httpRequest = ( HttpServletRequest ) request ; \nHttpServletResponse httpResponse = ( HttpServletResponse ) response ; \nif ( isRequestedSessionIdFromURL ( httpRequest ) ) { \nHttpSession session = httpRequest . getSession ( false ) ; \nif ( session != null ) session . invalidate ( ) ; \n} \nHttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper ( httpResponse ) { \n@ Override public String encodeRedirectUrl ( final String url ) { \nreturn url ; \n} \n@ Override public String encodeRedirectURL ( final String url ) { \nreturn url ; \n} \n@ Override public String encodeUrl ( final String url ) { \nreturn url ; \n} \n@ Override public String encodeURL ( final String url ) { \nreturn url ; \n} \n} \n; \nchain . doFilter ( request , wrappedResponse ) ; \n} \n} \n"}
{"1129": "public class EmailAttachment { \npublic String getEncodedName ( ) { \nif ( name == null ) return null ; \ntry { \nreturn MimeUtility . encodeText ( name ) ; \n} \ncatch ( final UnsupportedEncodingException ueex ) { \nthrow new MailException ( ueex ) ; \n} \n} \n} \n"}
{"1130": "public class EmailAttachment { \npublic byte [ ] toByteArray ( ) { \nfinal FastByteArrayOutputStream out ; \nif ( size != - 1 ) out = new FastByteArrayOutputStream ( size ) ; \nelse out = new FastByteArrayOutputStream ( ) ; \nwriteToStream ( out ) ; \nreturn out . toByteArray ( ) ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \nfor ( int i = 0 ; \ni < textLength ; \ni ++ ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) if ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse continue ; \nelse regularChar = true ; \ndest [ ndx ] = c ; \nndx ++ ; \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \nelse strippedCharsCount += textLength ; \n} \n} \n"}
{"1141": "public class NodeSelector { \nprotected void processSelectors ( final List < Node > results , final List < CssSelector > selectors ) { \nList < Node > selectedNodes = select ( rootNode , selectors ) ; \nfor ( Node selectedNode : selectedNodes ) { \nif ( ! results . contains ( selectedNode ) ) results . add ( selectedNode ) ; \n} \n} \n} \n"}
{"1142": "public class NodeSelector { \npublic Node selectFirst ( final String query ) { \nList < Node > selectedNodes = select ( query ) ; \nif ( selectedNodes . isEmpty ( ) ) return null ; \nreturn selectedNodes . get ( 0 ) ; \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nwhile ( ! nodes . isEmpty ( ) ) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = childCount - 1 ; \ni >= 0 ; \ni -- ) nodes . addFirst ( node . getChild ( i ) ) ; \n} \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nint childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) nodes . add ( rootNode . getChild ( i ) ) ; \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) selectAndAdd ( node , cssSelector , result ) ; \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nwhile ( true ) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) break ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \n} \n} \n"}
{"1145": "public class NodeSelector { \nprotected void selectAndAdd ( final Node node , final CssSelector cssSelector , final List < Node > result ) { \nif ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) return ; \nboolean matched = cssSelector . accept ( node ) ; \nif ( matched ) { \nif ( result . contains ( node ) ) return ; \nresult . add ( node ) ; \n} \n} \n} \n"}
{"1149": "public class DbPager { \nprotected < T > PageData < T > page ( String sql , final Map params , final int page , final int pageSize , final String sortColumnName , final boolean ascending , final Class [ ] target ) { \nif ( sortColumnName != null ) sql = buildOrderSql ( sql , sortColumnName , ascending ) ; \nint from = ( page - 1 ) * pageSize ; \nString pageSql = buildPageSql ( sql , from , pageSize ) ; \nDbSqlBuilder dbsql = sql ( pageSql ) ; \nDbOomQuery query = query ( dbsql ) ; \nquery . setMaxRows ( pageSize ) ; \nquery . setFetchSize ( pageSize ) ; \nquery . setMap ( params ) ; \nList < T > list = query . list ( pageSize , target ) ; \nquery . close ( ) ; \nString countSql = buildCountSql ( sql ) ; \ndbsql = sql ( countSql ) ; \nquery = query ( dbsql ) ; \nquery . setMap ( params ) ; \nlong count = query . executeCount ( ) ; \nquery . close ( ) ; \nreturn new PageData < > ( page , ( int ) count , pageSize , list ) ; \n} \n} \n"}
{"1150": "public class DbPager { \nprotected String removeSelect ( String sql ) { \nint ndx = StringUtil . indexOfIgnoreCase ( sql , \"select\" ) ; \nif ( ndx != - 1 ) sql = sql . substring ( ndx + 6 ) ; \nreturn sql ; \n} \n} \n"}
{"1151": "public class DbPager { \nprotected String removeToFrom ( String sql ) { \nint from = 0 ; \nint fromCount = 1 ; \nint selectCount = 0 ; \nint lastNdx = 0 ; \nwhile ( true ) { \nint ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; \nif ( ndx == - 1 ) break ; \nString left = sql . substring ( lastNdx , ndx ) ; \nselectCount += StringUtil . countIgnoreCase ( left , \"select\" ) ; \nif ( fromCount >= selectCount ) { \nsql = sql . substring ( ndx ) ; \nbreak ; \n} \nlastNdx = ndx ; \nfrom = ndx + 4 ; \nfromCount ++ ; \n} \nreturn sql ; \n} \n} \n"}
{"1152": "public class DbPager { \nprotected String removeLastOrderBy ( String sql ) { \nint ndx = StringUtil . lastIndexOfIgnoreCase ( sql , \"order by\" ) ; \nif ( ndx != - 1 ) { \nint ndx2 = sql . lastIndexOf ( sql , ')' ) ; \nif ( ndx > ndx2 ) sql = sql . substring ( 0 , ndx ) ; \n} \nreturn sql ; \n} \n} \n"}
{"1153": "public class HtmlDecoder { \npublic static String decode ( final String html ) { \nint ndx = html . indexOf ( '&' ) ; \nif ( ndx == - 1 ) return html ; \nStringBuilder result = new StringBuilder ( html . length ( ) ) ; \nint lastIndex = 0 ; \nint len = html . length ( ) ; \nmainloop : while ( ndx != - 1 ) { \nresult . append ( html . substring ( lastIndex , ndx ) ) ; \nlastIndex = ndx ; \nwhile ( html . charAt ( lastIndex ) != ';' ) { \nlastIndex ++ ; \nif ( lastIndex == len ) { \nlastIndex = ndx ; \nbreak mainloop ; \n} \n} \nif ( html . charAt ( ndx + 1 ) == '#' ) { \nchar c = html . charAt ( ndx + 2 ) ; \nint radix ; \nif ( ( c == 'x' ) || ( c == 'X' ) ) { \nradix = 16 ; \nndx += 3 ; \n} \nelse { \nradix = 10 ; \nndx += 2 ; \n} \nString number = html . substring ( ndx , lastIndex ) ; \nint i = Integer . parseInt ( number , radix ) ; \nresult . append ( ( char ) i ) ; \nlastIndex ++ ; \n} \nelse { \nString encodeToken = html . substring ( ndx + 1 , lastIndex ) ; \nchar [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; \nif ( replacement == null ) { \nresult . append ( '&' ) ; \nlastIndex = ndx + 1 ; \n} \nelse { \nresult . append ( replacement ) ; \nlastIndex ++ ; \n} \n} \nndx = html . indexOf ( '&' , lastIndex ) ; \n} \nresult . append ( html . substring ( lastIndex ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1154": "public class HtmlDecoder { \npublic static String detectName ( final char [ ] input , int ndx ) { \nfinal Ptr ptr = new Ptr ( ) ; \nint firstIndex = 0 ; \nint lastIndex = ENTITY_NAMES . length - 1 ; \nint len = input . length ; \nchar [ ] lastName = null ; \nfinal BinarySearchBase binarySearch = new BinarySearchBase ( ) { \n@ Override protected int compare ( final int index ) { \nchar [ ] name = ENTITY_NAMES [ index ] ; \nif ( ptr . offset >= name . length ) return - 1 ; \nreturn name [ ptr . offset ] - ptr . c ; \n} \n} \n; \nwhile ( true ) { \nptr . c = input [ ndx ] ; \nif ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) return lastName != null ? new String ( lastName ) : null ; \nfirstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; \nif ( firstIndex < 0 ) return lastName != null ? new String ( lastName ) : null ; \nchar [ ] element = ENTITY_NAMES [ firstIndex ] ; \nif ( element . length == ptr . offset + 1 ) lastName = ENTITY_NAMES [ firstIndex ] ; \nlastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; \nif ( firstIndex == lastIndex ) { \nfor ( int i = ptr . offset ; \ni < element . length ; \ni ++ ) { \nif ( element [ i ] != input [ ndx ] ) return lastName != null ? new String ( lastName ) : null ; \nndx ++ ; \n} \nreturn new String ( element ) ; \n} \nptr . offset ++ ; \nndx ++ ; \nif ( ndx == len ) return lastName != null ? new String ( lastName ) : null ; \n} \n} \n} \n"}
{"1155": "public class HsqlDbPager { \n@ Override protected String buildOrderSql ( String sql , final String column , final boolean ascending ) { \nsql += \" order by \" + column ; \nif ( ! ascending ) sql += \" desc\" ; \nreturn sql ; \n} \n} \n"}
{"1157": "public class DbEntityDescriptor { \nprivate void resolveColumnsAndProperties ( final Class type ) { \nPropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; \nList < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; \nint idcount = 0 ; \nHashSet < String > names = new HashSet < > ( allProperties . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nDbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; \nif ( dec != null ) { \nif ( ! names . add ( dec . getColumnName ( ) ) ) throw new DbOomException ( \"Duplicate column name: \" + dec . getColumnName ( ) ) ; \ndecList . add ( dec ) ; \nif ( dec . isId ) idcount ++ ; \n} \n} \nif ( decList . isEmpty ( ) ) throw new DbOomException ( \"No column mappings in entity: \" + type ) ; \ncolumnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; \nArrays . sort ( columnDescriptors ) ; \nif ( idcount > 0 ) { \nidColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; \nidcount = 0 ; \nfor ( DbEntityColumnDescriptor dec : columnDescriptors ) { \nif ( dec . isId ) idColumnDescriptors [ idcount ++ ] = dec ; \n} \n} \n} \n} \n"}
{"1158": "public class DbEntityDescriptor { \npublic DbEntityColumnDescriptor findByColumnName ( final String columnName ) { \nif ( columnName == null ) return null ; \ninit ( ) ; \nfor ( DbEntityColumnDescriptor columnDescriptor : columnDescriptors ) { \nif ( columnDescriptor . columnName . equalsIgnoreCase ( columnName ) ) return columnDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"1159": "public class DbEntityDescriptor { \npublic DbEntityColumnDescriptor findByPropertyName ( final String propertyName ) { \nif ( propertyName == null ) return null ; \ninit ( ) ; \nfor ( DbEntityColumnDescriptor columnDescriptor : columnDescriptors ) { \nif ( columnDescriptor . propertyName . equals ( propertyName ) ) return columnDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"1165": "public class StringBand { \npublic StringBand append ( String s ) { \nif ( s == null ) s = StringPool . NULL ; \nif ( index >= array . length ) expandCapacity ( ) ; \narray [ index ++ ] = s ; \nlength += s . length ( ) ; \nreturn this ; \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) throw new ArrayIndexOutOfBoundsException ( newIndex ) ; \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( newIndex > index ) for ( int i = index ; \ni < newIndex ; \ni ++ ) array [ i ] = StringPool . EMPTY ; \nelse if ( newIndex < index ) for ( int i = newIndex ; \ni < index ; \ni ++ ) array [ i ] = null ; \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1168": "public class StringBand { \nprotected int calculateLength ( ) { \nint len = 0 ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) len += array [ i ] . length ( ) ; \nreturn len ; \n} \n} \n"}
{"1170": "public class ScopedProxyManager { \nprotected Object createScopedProxyBean ( final PetiteContainer petiteContainer , final BeanDefinition refBeanDefinition ) { \nClass beanType = refBeanDefinition . type ; \nClass proxyClass = proxyClasses . get ( beanType ) ; \nif ( proxyClass == null ) if ( refBeanDefinition instanceof ProxettaBeanDefinition ) { \nProxettaBeanDefinition pbd = ( ProxettaBeanDefinition ) refBeanDefinition ; \nProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspects ( ArraysUtil . insert ( pbd . proxyAspects , aspect , 0 ) ) ; \nproxetta . setClassNameSuffix ( \"$ScopedProxy\" ) ; \nproxetta . setVariableClassName ( true ) ; \nProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( pbd . originalTarget ) ; \nproxyClass = builder . define ( ) ; \nproxyClasses . put ( beanType , proxyClass ) ; \n} \nelse { \nProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspect ( aspect ) ; \nproxetta . setClassNameSuffix ( \"$ScopedProxy\" ) ; \nproxetta . setVariableClassName ( true ) ; \nProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( beanType ) ; \nproxyClass = builder . define ( ) ; \nproxyClasses . put ( beanType , proxyClass ) ; \n} \nObject proxy ; \ntry { \nproxy = ClassUtil . newInstance ( proxyClass ) ; \nField field = proxyClass . getField ( \"$__petiteContainer$0\" ) ; \nfield . set ( proxy , petiteContainer ) ; \nfield = proxyClass . getField ( \"$__name$0\" ) ; \nfield . set ( proxy , refBeanDefinition . name ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( ex ) ; \n} \nreturn proxy ; \n} \n} \n"}
{"1171": "public class LoopingTagSupport { \nprotected void loopBody ( ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nif ( body == null ) return ; \nLoopIterator loopIterator = new LoopIterator ( start , end , step , modulus ) ; \nif ( status != null ) getJspContext ( ) . setAttribute ( status , loopIterator ) ; \nwhile ( loopIterator . next ( ) ) TagUtil . invokeBody ( body ) ; \nif ( status != null ) getJspContext ( ) . removeAttribute ( status ) ; \n} \n} \n"}
{"1172": "public class DirWatcher { \nprotected void init ( ) { \nFile [ ] filesArray = dir . listFiles ( ) ; \nfilesCount = 0 ; \nif ( filesArray != null ) { \nfilesCount = filesArray . length ; \nfor ( File file : filesArray ) { \nif ( ! acceptFile ( file ) ) continue ; \nmap . put ( file , new MutableLong ( file . lastModified ( ) ) ) ; \n} \n} \n} \n} \n"}
{"1173": "public class DirWatcher { \nprotected boolean acceptFile ( final File file ) { \nif ( ! file . isFile ( ) ) return false ; \nString fileName = file . getName ( ) ; \nif ( ignoreDotFiles ) if ( fileName . startsWith ( StringPool . DOT ) ) return false ; \nif ( patterns == null ) return true ; \nreturn Wildcard . matchOne ( fileName , patterns ) != - 1 ; \n} \n} \n"}
{"1174": "public class DirWatcher { \npublic DirWatcher useWatchFile ( final String name ) { \nwatchFile = new File ( dir , name ) ; \nif ( ! watchFile . isFile ( ) || ! watchFile . exists ( ) ) try { \nFileUtil . touch ( watchFile ) ; \n} \ncatch ( IOException ioex ) { \nthrow new DirWatcherException ( \"Invalid watch file: \" + name , ioex ) ; \n} \nwatchFileLastAccessTime = watchFile . lastModified ( ) ; \nreturn this ; \n} \n} \n"}
{"1175": "public class DirWatcher { \npublic void start ( final long pollingInterval ) { \nif ( timer == null ) { \nif ( ! startBlank ) init ( ) ; \ntimer = new Timer ( true ) ; \ntimer . schedule ( new WatchTask ( ) , 0 , pollingInterval ) ; \n} \n} \n} \n"}
{"1177": "public class CompositeEnumeration { \npublic void add ( final Enumeration < T > enumeration ) { \nif ( allEnumerations . contains ( enumeration ) ) throw new IllegalArgumentException ( \"Duplicate enumeration\" ) ; \nallEnumerations . add ( enumeration ) ; \n} \n} \n"}
{"1178": "public class FieldWriter { \nint computeFieldInfoSize ( ) { \nint size = 8 ; \nif ( constantValueIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { \nsymbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; \nsize += 6 ; \n} \nif ( signatureIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; \nsize += 6 ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) size += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; \nif ( lastRuntimeInvisibleAnnotation != null ) size += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; \nif ( lastRuntimeVisibleTypeAnnotation != null ) size += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; \nif ( lastRuntimeInvisibleTypeAnnotation != null ) size += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; \nif ( firstAttribute != null ) size += firstAttribute . computeAttributesSize ( symbolTable ) ; \nreturn size ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; \nint mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nint attributesCount = 0 ; \nif ( constantValueIndex != 0 ) ++ attributesCount ; \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) ++ attributesCount ; \nif ( signatureIndex != 0 ) ++ attributesCount ; \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) ++ attributesCount ; \nif ( lastRuntimeVisibleAnnotation != null ) ++ attributesCount ; \nif ( lastRuntimeInvisibleAnnotation != null ) ++ attributesCount ; \nif ( lastRuntimeVisibleTypeAnnotation != null ) ++ attributesCount ; \nif ( lastRuntimeInvisibleTypeAnnotation != null ) ++ attributesCount ; \nif ( firstAttribute != null ) attributesCount += firstAttribute . getAttributeCount ( ) ; \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \nif ( signatureIndex != 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \nif ( lastRuntimeVisibleAnnotation != null ) lastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \nif ( lastRuntimeInvisibleAnnotation != null ) lastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \nif ( lastRuntimeVisibleTypeAnnotation != null ) lastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \nif ( lastRuntimeInvisibleTypeAnnotation != null ) lastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \nif ( firstAttribute != null ) firstAttribute . putAttributes ( symbolTable , output ) ; \n} \n} \n"}
{"1184": "public class DecoraParser { \nprotected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { \nint ndx = 0 ; \nfor ( DecoraTag decoraTag : decoraTags ) { \nint decoratorLen = decoraTag . getStartIndex ( ) - ndx ; \nif ( decoratorLen <= 0 ) continue ; \nout . write ( decoratorContent , ndx , decoratorLen ) ; \nndx = decoraTag . getEndIndex ( ) ; \nint regionLen = decoraTag . getRegionLength ( ) ; \nif ( regionLen == 0 ) if ( decoraTag . hasDefaultValue ( ) ) out . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; \nelse writeRegion ( out , pageContent , decoraTag , decoraTags ) ; \n} \nout . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; \n} \n} \n"}
{"1185": "public class DecoraParser { \nprotected void writeRegion ( final Writer out , final char [ ] pageContent , final DecoraTag decoraTag , final DecoraTag [ ] decoraTags ) throws IOException { \nint regionStart = decoraTag . getRegionStart ( ) ; \nint regionLen = decoraTag . getRegionLength ( ) ; \nint regionEnd = regionStart + regionLen ; \nfor ( DecoraTag innerDecoraTag : decoraTags ) { \nif ( decoraTag == innerDecoraTag ) continue ; \nif ( decoraTag . isRegionUndefined ( ) ) continue ; \nif ( innerDecoraTag . isInsideOtherTagRegion ( decoraTag ) ) { \nout . write ( pageContent , regionStart , innerDecoraTag . getRegionTagStart ( ) - regionStart ) ; \nregionStart = innerDecoraTag . getRegionTagEnd ( ) ; \n} \n} \nout . write ( pageContent , regionStart , regionEnd - regionStart ) ; \n} \n} \n"}
{"1188": "public class ImapSslServer { \n@ Override protected IMAPSSLStore getStore ( final Session session ) { \nSimpleAuthenticator simpleAuthenticator = ( SimpleAuthenticator ) authenticator ; \nfinal URLName url ; \nif ( simpleAuthenticator == null ) url = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , null , null ) ; \nelse { \nfinal PasswordAuthentication pa = simpleAuthenticator . getPasswordAuthentication ( ) ; \nurl = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , pa . getUserName ( ) , pa . getPassword ( ) ) ; \n} \nreturn new IMAPSSLStore ( session , url ) ; \n} \n} \n"}
{"1190": "public class ColumnsSelectChunk { \n@ Override public void init ( final TemplateData templateData ) { \nsuper . init ( templateData ) ; \nif ( hint != null ) templateData . incrementHintsCount ( ) ; \n} \n} \n"}
{"1193": "public class InExRules { \nprotected void addRule ( final D ruleDefinition , final boolean include ) { \nif ( rules == null ) rules = new ArrayList < > ( ) ; \nif ( include ) includesCount ++ ; \nelse excludesCount ++ ; \nRule < R > newRule = new Rule < > ( makeRule ( ruleDefinition ) , include ) ; \nif ( rules . contains ( newRule ) ) return ; \nrules . add ( newRule ) ; \n} \n} \n"}
{"1194": "public class InExRules { \npublic boolean apply ( final V value , final boolean blacklist , boolean flag ) { \nif ( rules == null ) return flag ; \nif ( blacklist ) { \nflag = processExcludes ( value , flag ) ; \nflag = processIncludes ( value , flag ) ; \n} \nelse { \nflag = processIncludes ( value , flag ) ; \nflag = processExcludes ( value , flag ) ; \n} \nreturn flag ; \n} \n} \n"}
{"1195": "public class InExRules { \nprotected boolean processIncludes ( final V value , boolean include ) { \nif ( includesCount > 0 ) if ( ! include ) for ( Rule < R > rule : rules ) { \nif ( ! rule . include ) continue ; \nif ( inExRuleMatcher . accept ( value , rule . value , true ) ) { \ninclude = true ; \nbreak ; \n} \n} \nreturn include ; \n} \n} \n"}
{"1196": "public class InExRules { \nprotected boolean processExcludes ( final V value , boolean include ) { \nif ( excludesCount > 0 ) if ( include ) for ( Rule < R > rule : rules ) { \nif ( rule . include ) continue ; \nif ( inExRuleMatcher . accept ( value , rule . value , false ) ) { \ninclude = false ; \nbreak ; \n} \n} \nreturn include ; \n} \n} \n"}
{"1198": "public class SortedArrayList { \n@ Override public boolean addAll ( final Collection < ? extends E > c ) { \nIterator < ? extends E > i = c . iterator ( ) ; \nboolean changed = false ; \nwhile ( i . hasNext ( ) ) { \nboolean ret = add ( i . next ( ) ) ; \nif ( ! changed ) changed = ret ; \n} \nreturn changed ; \n} \n} \n"}
{"1199": "public class SortedArrayList { \nprotected int findInsertionPoint ( final E o , int low , int high ) { \nwhile ( low <= high ) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( get ( mid ) , o ) ; \nif ( delta > 0 ) high = mid - 1 ; \nelse low = mid + 1 ; \n} \nreturn low ; \n} \n} \n"}
{"1200": "public class ActionConfigManager { \npublic void bindAnnotationConfig ( final Class < ? extends Annotation > annotationType , final Class < ? extends ActionConfig > actionConfigClass ) { \nfinal ActionConfig actionConfig = registerNewActionConfiguration ( actionConfigClass ) ; \nactionConfigs . put ( annotationType , actionConfig ) ; \nfor ( final AnnotationParser annotationParser : annotationParsers ) { \nif ( annotationType . equals ( annotationParser . getAnnotationType ( ) ) ) return ; \n} \nannotationParsers = ArraysUtil . append ( annotationParsers , new AnnotationParser ( annotationType , Action . class ) ) ; \n} \n} \n"}
{"1202": "public class ActionConfigManager { \npublic ActionConfig lookup ( final Class actionTypeOrAnnotationType ) { \nfinal ActionConfig actionConfig = actionConfigs . get ( actionTypeOrAnnotationType ) ; \nif ( actionConfig == null ) throw new MadvocException ( \"ActionConfiguration not registered:\" + actionTypeOrAnnotationType . getName ( ) ) ; \nreturn actionConfig ; \n} \n} \n"}
{"1206": "public class HtmlFosterRules { \nprotected Element findLastTable ( final Node node ) { \nNode tableNode = node ; \nwhile ( tableNode != null ) { \nif ( tableNode . getNodeType ( ) == Node . NodeType . ELEMENT ) { \nString tableNodeName = tableNode . getNodeName ( ) . toLowerCase ( ) ; \nif ( tableNodeName . equals ( \"table\" ) ) break ; \n} \ntableNode = tableNode . getParentNode ( ) ; \n} \nreturn ( Element ) tableNode ; \n} \n} \n"}
{"1207": "public class HtmlFosterRules { \nprotected void fixElements ( ) { \nfor ( Element fosterElement : fosterElements ) { \nElement lastTable = findLastTable ( fosterElement ) ; \nNode fosterElementParent = fosterElement . getParentNode ( ) ; \nNode [ ] fosterChilds = fosterElement . getChildNodes ( ) ; \nfor ( Node fosterChild : fosterChilds ) { \nif ( fosterChild . getNodeType ( ) == Node . NodeType . ELEMENT ) if ( isOneOfTableElements ( ( Element ) fosterChild ) ) { \nfosterChild . detachFromParent ( ) ; \nfosterElementParent . insertBefore ( fosterChild , fosterElement ) ; \n} \n} \nfosterElement . detachFromParent ( ) ; \nlastTable . getParentNode ( ) . insertBefore ( fosterElement , lastTable ) ; \n} \n} \n} \n"}
{"1209": "public class SessionScope { \n@ SuppressWarnings ( \"unchecked\" ) protected Map < String , BeanData > getSessionMap ( final HttpSession session ) { \nSessionBeans sessionBeans = ( SessionBeans ) session . getAttribute ( SESSION_BEANS_NAME ) ; \nif ( sessionBeans == null ) return null ; \nreturn sessionBeans . getBeanMap ( ) ; \n} \n} \n"}
{"1210": "public class WorkData { \npublic void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { \nint lastSlash = name . lastIndexOf ( '/' ) ; \nthis . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; \nthis . targetClassname = name . substring ( lastSlash + 1 ) ; \nthis . nextSupername = superName ; \nthis . superName = name ; \nif ( reqProxyClassName != null ) if ( reqProxyClassName . startsWith ( DOT ) ) name = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; \nelse if ( reqProxyClassName . endsWith ( DOT ) ) name = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; \nelse name = reqProxyClassName . replace ( '.' , '/' ) ; \nif ( suffix != null ) name += suffix ; \nthis . thisReference = name ; \nthis . superReference = this . superName ; \n} \n} \n"}
{"1211": "public class WorkData { \nvoid addAdviceInitMethod ( final String name ) { \nif ( adviceInits == null ) adviceInits = new ArrayList < > ( ) ; \nadviceInits . add ( name ) ; \n} \n} \n"}
{"1212": "public class BundleAction { \npublic void end ( ) { \nif ( newAction ) bundleId = bundlesManager . registerBundle ( contextPath , actionPath , bundleId , bundleContentType , sources ) ; \n} \n} \n"}
{"1213": "public class PropsParser { \nprotected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { \nif ( key == null ) return ; \nString fullKey = key ; \nif ( section != null ) if ( fullKey . length ( ) != 0 ) fullKey = section + '.' + fullKey ; \nelse fullKey = section ; \nString v = value . toString ( ) ; \nif ( trim ) if ( valueTrimLeft && valueTrimRight ) v = v . trim ( ) ; \nelse if ( valueTrimLeft ) v = StringUtil . trimLeft ( v ) ; \nelse v = StringUtil . trimRight ( v ) ; \nif ( v . length ( ) == 0 && skipEmptyProps ) return ; \nextractProfilesAndAdd ( fullKey , v , operator ) ; \n} \n} \n"}
{"1214": "public class PropsParser { \nprotected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { \nString fullKey = key ; \nint ndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \njustAdd ( fullKey , value , null , operator ) ; \nreturn ; \n} \nArrayList < String > keyProfiles = new ArrayList < > ( ) ; \nwhile ( true ) { \nndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) break ; \nfinal int len = fullKey . length ( ) ; \nint ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; \nif ( ndx2 == - 1 ) ndx2 = len ; \nfinal String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; \nkeyProfiles . add ( profile ) ; \nndx2 ++ ; \nfinal String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; \nfullKey = fullKey . substring ( 0 , ndx ) + right ; \n} \nif ( fullKey . startsWith ( StringPool . DOT ) ) fullKey = fullKey . substring ( 1 ) ; \njustAdd ( fullKey , value , keyProfiles , operator ) ; \n} \n} \n"}
{"1215": "public class PropsParser { \nprotected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { \nif ( operator == Operator . COPY ) { \nHashMap < String , Object > target = new HashMap < > ( ) ; \nString [ ] profiles = null ; \nif ( keyProfiles != null ) profiles = keyProfiles . toArray ( new String [ 0 ] ) ; \nString [ ] sources = StringUtil . splitc ( value , ',' ) ; \nfor ( String source : sources ) { \nsource = source . trim ( ) ; \nString [ ] lookupProfiles = profiles ; \nString lookupProfilesString = null ; \nint leftIndex = source . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = source . indexOf ( '>' ) ; \nlookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; \nsource = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nString [ ] wildcards = new String [ ] { \nsource + \".*\" } \n; \npropsData . extract ( target , lookupProfiles , wildcards , null ) ; \nfor ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { \nString entryKey = entry . getKey ( ) ; \nString suffix = entryKey . substring ( source . length ( ) ) ; \nString newKey = key + suffix ; \nString newValue = \"${\" + entryKey ; \nif ( lookupProfilesString != null ) newValue += \"<\" + lookupProfilesString + \">\" ; \nnewValue += \"}\" ; \nif ( profiles == null ) propsData . putBaseProperty ( newKey , newValue , false ) ; \nelse for ( final String p : profiles ) { \npropsData . putProfileProperty ( newKey , newValue , p , false ) ; \n} \n} \n} \nreturn ; \n} \nboolean append = operator == Operator . QUICK_APPEND ; \nif ( keyProfiles == null ) { \npropsData . putBaseProperty ( key , value , append ) ; \nreturn ; \n} \nfor ( final String p : keyProfiles ) { \npropsData . putProfileProperty ( key , value , p , append ) ; \n} \n} \n} \n"}
{"1216": "public class AsmUtil { \npublic static String typedesc2ClassName ( final String desc ) { \nString className = desc ; \nswitch ( desc . charAt ( 0 ) ) { \ncase 'B' : case 'C' : case 'D' : case 'F' : case 'I' : case 'J' : case 'S' : case 'Z' : case 'V' : if ( desc . length ( ) != 1 ) throw new IllegalArgumentException ( INVALID_BASE_TYPE + desc ) ; \nbreak ; \ncase 'L' : className = className . substring ( 1 , className . length ( ) - 1 ) ; \nbreak ; \ncase '[' : className = className . replace ( '/' , '.' ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nreturn className ; \n} \n} \n"}
{"1217": "public class AsmUtil { \npublic static String typeref2Name ( final String desc ) { \nif ( desc . charAt ( 0 ) != TYPE_REFERENCE ) throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \nString name = desc . substring ( 1 , desc . length ( ) - 1 ) ; \nreturn name . replace ( '/' , '.' ) ; \n} \n} \n"}
{"1218": "public class AsmUtil { \npublic static String typedescToSignature ( final String desc , final MutableInteger from ) { \nint fromIndex = from . get ( ) ; \nfrom . value ++ ; \nswitch ( desc . charAt ( fromIndex ) ) { \ncase 'B' : return \"byte\" ; \ncase 'C' : return \"char\" ; \ncase 'D' : return \"double\" ; \ncase 'F' : return \"float\" ; \ncase 'I' : return \"int\" ; \ncase 'J' : return \"long\" ; \ncase 'S' : return \"short\" ; \ncase 'Z' : return \"boolean\" ; \ncase 'V' : return \"void\" ; \ncase 'L' : int index = desc . indexOf ( ';' , fromIndex ) ; \nif ( index < 0 ) throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \nfrom . set ( index + 1 ) ; \nString str = desc . substring ( fromIndex + 1 , index ) ; \nreturn str . replace ( '/' , '.' ) ; \ncase 'T' : return desc . substring ( from . value ) ; \ncase '[' : StringBuilder brackets = new StringBuilder ( ) ; \nint n = fromIndex ; \nwhile ( desc . charAt ( n ) == '[' ) { \nbrackets . append ( \"[]\" ) ; \nn ++ ; \n} \nfrom . value = n ; \nString type = typedescToSignature ( desc , from ) ; \nreturn type + brackets ; \ndefault : if ( from . value == 0 ) throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \nreturn desc . substring ( from . value ) ; \n} \n} \n} \n"}
{"1219": "public class AsmUtil { \npublic static String typeToTyperef ( final Class type ) { \nif ( ! type . isArray ( ) ) { \nif ( ! type . isPrimitive ( ) ) return 'L' + typeToSignature ( type ) + ';' ; \nif ( type == int . class ) return \"I\" ; \nif ( type == long . class ) return \"J\" ; \nif ( type == boolean . class ) return \"Z\" ; \nif ( type == double . class ) return \"D\" ; \nif ( type == float . class ) return \"F\" ; \nif ( type == short . class ) return \"S\" ; \nif ( type == void . class ) return \"V\" ; \nif ( type == byte . class ) return \"B\" ; \nif ( type == char . class ) return \"C\" ; \n} \nreturn type . getName ( ) ; \n} \n} \n"}
{"1221": "public class CollectionConverter { \n@ SuppressWarnings ( \"unchecked\" ) protected Collection < T > createCollection ( final int length ) { \nif ( collectionType . isInterface ( ) ) { \nif ( collectionType == List . class ) if ( length > 0 ) return new ArrayList < > ( length ) ; \nelse return new ArrayList < > ( ) ; \nif ( collectionType == Set . class ) if ( length > 0 ) return new HashSet < > ( length ) ; \nelse return new HashSet < > ( ) ; \nthrow new TypeConversionException ( \"Unknown collection: \" + collectionType . getName ( ) ) ; \n} \nif ( length > 0 ) try { \nConstructor < Collection < T > > ctor = ( Constructor < Collection < T > > ) collectionType . getConstructor ( int . class ) ; \nreturn ctor . newInstance ( Integer . valueOf ( length ) ) ; \n} \ncatch ( Exception ex ) { \n} \ntry { \nreturn collectionType . getDeclaredConstructor ( ) . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new TypeConversionException ( ex ) ; \n} \n} \n} \n"}
{"1223": "public class CollectionConverter { \nprotected Collection < T > convertValueToCollection ( Object value ) { \nif ( value instanceof Iterable ) { \nIterable iterable = ( Iterable ) value ; \nCollection < T > collection = createCollection ( 0 ) ; \nfor ( Object element : iterable ) { \ncollection . add ( convertType ( element ) ) ; \n} \nreturn collection ; \n} \nif ( value instanceof CharSequence ) value = CsvUtil . toStringArray ( value . toString ( ) ) ; \nClass type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nClass componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) return convertPrimitiveArrayToCollection ( value , componentType ) ; \nelse { \nObject [ ] array = ( Object [ ] ) value ; \nCollection < T > result = createCollection ( array . length ) ; \nfor ( Object a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \nreturn result ; \n} \n} \nreturn convertToSingleElementCollection ( value ) ; \n} \n} \n"}
{"1226": "public class Label { \nfinal void addLineNumber ( final int lineNumber ) { \nif ( this . lineNumber == 0 ) this . lineNumber = ( short ) lineNumber ; \nelse { \nif ( otherLineNumbers == null ) otherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nint otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; \nif ( otherLineNumberIndex >= otherLineNumbers . length ) { \nint [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; \notherLineNumbers = newLineNumbers ; \n} \notherLineNumbers [ otherLineNumberIndex ] = lineNumber ; \n} \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers && lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) for ( int i = 1 ; \ni <= otherLineNumbers [ 0 ] ; \n++ i ) methodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n} \n} \n} \n"}
{"1228": "public class Label { \nfinal void put ( final ByteVector code , final int sourceInsnBytecodeOffset , final boolean wideReference ) { \nif ( ( flags & FLAG_RESOLVED ) == 0 ) if ( wideReference ) { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_WIDE , code . length ) ; \ncode . putInt ( - 1 ) ; \n} \nelse { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_SHORT , code . length ) ; \ncode . putShort ( - 1 ) ; \n} \nelse if ( wideReference ) code . putInt ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \nelse code . putShort ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \n} \n"}
{"1229": "public class Label { \nprivate void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { \nif ( forwardReferences == null ) forwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \nint lastElementIndex = forwardReferences [ 0 ] ; \nif ( lastElementIndex + 2 >= forwardReferences . length ) { \nint [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; \nforwardReferences = newValues ; \n} \nforwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; \nforwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; \nforwardReferences [ 0 ] = lastElementIndex ; \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) return false ; \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \ni > 0 ; \ni -= 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \nelse code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1232": "public class Label { \nfinal void addSubroutineRetSuccessors ( final Label subroutineCaller ) { \nLabel listOfProcessedBlocks = EMPTY_LIST ; \nLabel listOfBlocksToProcess = this ; \nlistOfBlocksToProcess . nextListElement = EMPTY_LIST ; \nwhile ( listOfBlocksToProcess != EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = basicBlock . nextListElement ; \nbasicBlock . nextListElement = listOfProcessedBlocks ; \nlistOfProcessedBlocks = basicBlock ; \nif ( ( basicBlock . flags & FLAG_SUBROUTINE_END ) != 0 && basicBlock . subroutineId != subroutineCaller . subroutineId ) basicBlock . outgoingEdges = new Edge ( basicBlock . outputStackSize , subroutineCaller . outgoingEdges . successor , basicBlock . outgoingEdges ) ; \nlistOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; \n} \nwhile ( listOfProcessedBlocks != EMPTY_LIST ) { \nLabel newListOfProcessedBlocks = listOfProcessedBlocks . nextListElement ; \nlistOfProcessedBlocks . nextListElement = null ; \nlistOfProcessedBlocks = newListOfProcessedBlocks ; \n} \n} \n} \n"}
{"1233": "public class NaturalOrderComparator { \nprotected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { \nint zeroCount1 = 0 ; \nwhile ( charAt ( str1 , ndx1 ) == '0' ) { \nzeroCount1 ++ ; \nndx1 ++ ; \n} \nint len1 = 0 ; \nwhile ( true ) { \nfinal char char1 = charAt ( str1 , ndx1 ) ; \nfinal boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; \nif ( ! isDigitChar1 ) break ; \nlen1 ++ ; \nndx1 ++ ; \n} \nint zeroCount2 = 0 ; \nwhile ( charAt ( str2 , ndx2 ) == '0' ) { \nzeroCount2 ++ ; \nndx2 ++ ; \n} \nint len2 = 0 ; \nint ndx1_new = ndx1 - len1 ; \nint equalNumbers = 0 ; \nwhile ( true ) { \nfinal char char2 = charAt ( str2 , ndx2 ) ; \nfinal boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; \nif ( ! isDigitChar2 ) break ; \nif ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) equalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; \nlen2 ++ ; \nndx2 ++ ; \n} \nif ( len1 != len2 ) return new int [ ] { \nlen1 - len2 } \n; \nif ( equalNumbers != 0 ) return new int [ ] { \nequalNumbers } \n; \nreturn new int [ ] { \n0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } \n; \n} \n} \n"}
{"1234": "public class NaturalOrderComparator { \nprivate char fixAccent ( final char c ) { \nfor ( int i = 0 ; \ni < ACCENT_CHARS . length ; \ni += 2 ) { \nfinal char accentChar = ACCENT_CHARS [ i ] ; \nif ( accentChar == c ) return ACCENT_CHARS [ i + 1 ] ; \n} \nreturn c ; \n} \n} \n"}
{"1235": "public class ByteVector { \npublic ByteVector putByte ( final int byteValue ) { \nint currentLength = length ; \nif ( currentLength + 1 > data . length ) enlarge ( 1 ) ; \ndata [ currentLength ++ ] = ( byte ) byteValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1236": "public class ByteVector { \nfinal ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { \nint currentLength = length ; \nif ( currentLength + 2 > data . length ) enlarge ( 2 ) ; \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1237": "public class ByteVector { \npublic ByteVector putShort ( final int shortValue ) { \nint currentLength = length ; \nif ( currentLength + 2 > data . length ) enlarge ( 2 ) ; \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1238": "public class ByteVector { \nfinal ByteVector put12 ( final int byteValue , final int shortValue ) { \nint currentLength = length ; \nif ( currentLength + 3 > data . length ) enlarge ( 3 ) ; \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1239": "public class ByteVector { \nfinal ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { \nint currentLength = length ; \nif ( currentLength + 4 > data . length ) enlarge ( 4 ) ; \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue2 ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1240": "public class ByteVector { \npublic ByteVector putInt ( final int intValue ) { \nint currentLength = length ; \nif ( currentLength + 4 > data . length ) enlarge ( 4 ) ; \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1241": "public class ByteVector { \nfinal ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { \nint currentLength = length ; \nif ( currentLength + 5 > data . length ) enlarge ( 5 ) ; \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue1 >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue2 >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1242": "public class ByteVector { \npublic ByteVector putLong ( final long longValue ) { \nint currentLength = length ; \nif ( currentLength + 8 > data . length ) enlarge ( 8 ) ; \nbyte [ ] currentData = data ; \nint intValue = ( int ) ( longValue >>> 32 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nintValue = ( int ) longValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1243": "public class ByteVector { \npublic ByteVector putByteArray ( final byte [ ] byteArrayValue , final int byteOffset , final int byteLength ) { \nif ( length + byteLength > data . length ) enlarge ( byteLength ) ; \nif ( byteArrayValue != null ) System . arraycopy ( byteArrayValue , byteOffset , data , length , byteLength ) ; \nlength += byteLength ; \nreturn this ; \n} \n} \n"}
{"1245": "public class AuthInterceptor { \nprotected T authenticateUserViaHttpSession ( final ActionRequest actionRequest ) { \nfinal HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; \nfinal UserSession < T > userSession = UserSession . get ( servletRequest ) ; \nif ( userSession == null ) return null ; \nfinal T authToken = userSession . getAuthToken ( ) ; \nif ( authToken == null ) return null ; \nfinal T newAuthToken = userAuth ( ) . rotateToken ( authToken ) ; \nif ( newAuthToken != authToken ) { \nfinal UserSession < T > newUserSesion = new UserSession < > ( newAuthToken , userAuth ( ) . tokenValue ( newAuthToken ) ) ; \nnewUserSesion . start ( servletRequest , actionRequest . getHttpServletResponse ( ) ) ; \n} \nreturn newAuthToken ; \n} \n} \n"}
{"1246": "public class AuthInterceptor { \nprotected T authenticateUserViaToken ( final ActionRequest actionRequest ) { \nfinal HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; \nfinal String token = ServletUtil . resolveAuthBearerToken ( servletRequest ) ; \nif ( token == null ) return null ; \nfinal T authToken = userAuth ( ) . validateToken ( token ) ; \nif ( authToken == null ) return null ; \nfinal T newAuthToken = userAuth ( ) . rotateToken ( authToken ) ; \nactionRequest . getHttpServletResponse ( ) . setHeader ( \"Authentication\" , \"Bearer: \" + userAuth ( ) . tokenValue ( newAuthToken ) ) ; \nreturn newAuthToken ; \n} \n} \n"}
{"1247": "public class AuthInterceptor { \nprotected T authenticateUserViaBasicAuth ( final ActionRequest actionRequest ) { \nfinal HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; \nfinal String username = ServletUtil . resolveAuthUsername ( servletRequest ) ; \nif ( username == null ) return null ; \nfinal String password = ServletUtil . resolveAuthPassword ( servletRequest ) ; \nfinal T authToken = userAuth ( ) . login ( username , password ) ; \nif ( authToken == null ) return null ; \nreturn authToken ; \n} \n} \n"}
{"1248": "public class ResourceBundleMessageResolver { \npublic String findDefaultMessage ( final Locale locale , final String key ) { \nString indexedKey = calcIndexKey ( key ) ; \nString msg = getMessage ( fallbackBundlename , locale , key , indexedKey ) ; \nif ( msg != null ) return msg ; \nfor ( String bname : defaultBundles ) { \nmsg = getMessage ( bname , locale , key , indexedKey ) ; \nif ( msg != null ) return msg ; \n} \nreturn null ; \n} \n} \n"}
{"1266": "public class StringKeyedMapAdapter { \n@ Override public void clear ( ) { \nentries = null ; \nIterator < String > keys = getAttributeNames ( ) ; \nwhile ( keys . hasNext ( ) ) removeAttribute ( keys . next ( ) ) ; \n} \n} \n"}
{"1267": "public class StringKeyedMapAdapter { \n@ Override public Set < Entry < String , Object > > entrySet ( ) { \nif ( entries == null ) { \nentries = new HashSet < > ( ) ; \nIterator < String > iterator = getAttributeNames ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nfinal String key = iterator . next ( ) ; \nfinal Object value = getAttribute ( key ) ; \nentries . add ( new Entry < String , Object > ( ) { \n@ Override public boolean equals ( final Object obj ) { \nif ( obj == null ) return false ; \nif ( this . getClass ( ) != obj . getClass ( ) ) return false ; \nEntry entry = ( Entry ) obj ; \nreturn ( ( key == null ) ? ( entry . getKey ( ) == null ) : key . equals ( entry . getKey ( ) ) ) && ( ( value == null ) ? ( entry . getValue ( ) == null ) : value . equals ( entry . getValue ( ) ) ) ; \n} \n@ Override public int hashCode ( ) { \nreturn ( ( key == null ) ? 0 : key . hashCode ( ) ) ^ ( ( value == null ) ? 0 : value . hashCode ( ) ) ; \n} \n@ Override public String getKey ( ) { \nreturn key ; \n} \n@ Override public Object getValue ( ) { \nreturn value ; \n} \n@ Override public Object setValue ( final Object obj ) { \nsetAttribute ( key , obj ) ; \nreturn value ; \n} \n} \n) ; \n} \n} \nreturn entries ; \n} \n} \n"}
{"1270": "public class ExceptionUtil { \n@ SuppressWarnings ( { \n\"ThrowCaughtLocally\" } \n) public static StackTraceElement [ ] getCurrentStackTrace ( ) { \nStackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; \nif ( ste . length > 1 ) { \nStackTraceElement [ ] result = new StackTraceElement [ ste . length - 1 ] ; \nSystem . arraycopy ( ste , 1 , result , 0 , ste . length - 1 ) ; \nreturn result ; \n} \nelse return ste ; \n} \n} \n"}
{"1271": "public class ExceptionUtil { \npublic static StackTraceElement [ ] getStackTrace ( final Throwable t , final String [ ] allow , final String [ ] deny ) { \nStackTraceElement [ ] st = t . getStackTrace ( ) ; \nArrayList < StackTraceElement > result = new ArrayList < > ( st . length ) ; \nelementLoop : for ( StackTraceElement element : st ) { \nString className = element . getClassName ( ) ; \nif ( allow != null ) { \nboolean validElemenet = false ; \nfor ( String filter : allow ) { \nif ( className . contains ( filter ) ) { \nvalidElemenet = true ; \nbreak ; \n} \n} \nif ( ! validElemenet ) continue ; \n} \nif ( deny != null ) for ( String filter : deny ) { \nif ( className . contains ( filter ) ) continue elementLoop ; \n} \nresult . add ( element ) ; \n} \nst = new StackTraceElement [ result . size ( ) ] ; \nreturn result . toArray ( st ) ; \n} \n} \n"}
{"1272": "public class ExceptionUtil { \npublic static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { \nArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; \nwhile ( t != null ) { \nStackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; \nresult . add ( stack ) ; \nt = t . getCause ( ) ; \n} \nStackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; \nfor ( int i = 0 ; \ni < allStacks . length ; \ni ++ ) allStacks [ i ] = result . get ( i ) ; \nreturn allStacks ; \n} \n} \n"}
{"1273": "public class ExceptionUtil { \npublic static Throwable [ ] getExceptionChain ( Throwable throwable ) { \nArrayList < Throwable > list = new ArrayList < > ( ) ; \nlist . add ( throwable ) ; \nwhile ( ( throwable = throwable . getCause ( ) ) != null ) list . add ( throwable ) ; \nThrowable [ ] result = new Throwable [ list . size ( ) ] ; \nreturn list . toArray ( result ) ; \n} \n} \n"}
{"1276": "public class ExceptionUtil { \npublic static String buildMessage ( final String message , Throwable cause ) { \nif ( cause != null ) { \ncause = getRootCause ( cause ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nif ( message != null ) buf . append ( message ) . append ( \"; \" ) ; \nbuf . append ( \"<--- \" ) . append ( cause ) ; \nreturn buf . toString ( ) ; \n} \nelse return message ; \n} \n} \n"}
{"1277": "public class ExceptionUtil { \npublic static Throwable unwrapThrowable ( final Throwable wrappedThrowable ) { \nThrowable unwrapped = wrappedThrowable ; \nwhile ( true ) if ( unwrapped instanceof InvocationTargetException ) unwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; \nelse if ( unwrapped instanceof UndeclaredThrowableException ) unwrapped = ( ( UndeclaredThrowableException ) unwrapped ) . getUndeclaredThrowable ( ) ; \nelse return unwrapped ; \n} \n} \n"}
{"1278": "public class AutomagicMadvocConfigurator { \nprotected void registerAsConsumer ( final ClassScanner classScanner ) { \nclassScanner . registerEntryConsumer ( classPathEntry -> { \nfinal String entryName = classPathEntry . name ( ) ; \nif ( entryName . endsWith ( actionClassSuffix ) ) try { \nacceptActionClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc action, ignoring: \" + entryName ) ; \n} \nelse if ( classPathEntry . isTypeSignatureInUse ( MADVOC_COMPONENT_ANNOTATION ) ) try { \nacceptMadvocComponentClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc component ignoring: {}\" + entryName ) ; \n} \n} \n) ; \n} \n} \n"}
{"1279": "public class AutomagicMadvocConfigurator { \nprotected void acceptMadvocComponentClass ( final Class componentClass ) { \nif ( componentClass == null ) return ; \nif ( ! checkClass ( componentClass ) ) return ; \nmadvocComponents . add ( ( ) -> madvocContainer . registerComponent ( componentClass ) ) ; \n} \n} \n"}
{"1280": "public class ClassLoaderUtil { \npublic static ClassLoader getSystemClassLoader ( ) { \nif ( System . getSecurityManager ( ) == null ) return ClassLoader . getSystemClassLoader ( ) ; \nelse return AccessController . doPrivileged ( ( PrivilegedAction < ClassLoader > ) ClassLoader :: getSystemClassLoader ) ; \n} \n} \n"}
{"1281": "public class ClassLoaderUtil { \npublic static InputStream getResourceAsStream ( final String resourceName , final ClassLoader callingClass ) throws IOException { \nURL url = getResourceUrl ( resourceName , callingClass ) ; \nif ( url != null ) return url . openStream ( ) ; \nreturn null ; \n} \n} \n"}
{"1285": "public class RouteChunk { \npublic RouteChunk add ( final String newValue ) { \nRouteChunk routeChunk = new RouteChunk ( routes , this , newValue ) ; \nif ( children == null ) children = new RouteChunk [ ] { \nrouteChunk } \n; \nelse children = ArraysUtil . append ( children , routeChunk ) ; \nreturn routeChunk ; \n} \n} \n"}
{"1286": "public class RouteChunk { \npublic RouteChunk findOrCreateChild ( final String value ) { \nif ( children != null ) for ( RouteChunk child : children ) { \nif ( child . get ( ) . equals ( value ) ) return child ; \n} \nreturn add ( value ) ; \n} \n} \n"}
{"1287": "public class MultipartRequest { \npublic void parseRequest ( ) throws IOException { \nif ( ServletUtil . isMultipartRequest ( request ) ) parseRequestStream ( request . getInputStream ( ) , characterEncoding ) ; \nelse { \nEnumeration names = request . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString paramName = ( String ) names . nextElement ( ) ; \nString [ ] values = request . getParameterValues ( paramName ) ; \nputParameters ( paramName , values ) ; \n} \n} \n} \n} \n"}
{"1289": "public class BeanUtilUtil { \nprotected Object invokeSetter ( final Setter setter , final BeanProperty bp , Object value ) { \ntry { \nfinal MapperFunction setterMapperFunction = setter . getMapperFunction ( ) ; \nif ( setterMapperFunction != null ) value = setterMapperFunction . apply ( value ) ; \nfinal Class type = setter . getSetterRawType ( ) ; \nif ( ClassUtil . isTypeOf ( type , Collection . class ) ) { \nClass componentType = setter . getSetterRawComponentType ( ) ; \nvalue = convertToCollection ( value , type , componentType ) ; \n} \nelse value = convertType ( value , type ) ; \nsetter . invokeSetter ( bp . bean , value ) ; \n} \ncatch ( Exception ex ) { \nif ( isSilent ) return null ; \nthrow new BeanException ( \"Setter failed: \" + setter , ex ) ; \n} \nreturn value ; \n} \n} \n"}
{"1291": "public class BeanUtilUtil { \nprotected Object createBeanProperty ( final BeanProperty bp ) { \nSetter setter = bp . getSetter ( true ) ; \nif ( setter == null ) return null ; \nClass type = setter . getSetterRawType ( ) ; \nObject newInstance ; \ntry { \nnewInstance = ClassUtil . newInstance ( type ) ; \n} \ncatch ( Exception ex ) { \nif ( isSilent ) return null ; \nthrow new BeanException ( \"Invalid property: \" + bp . name , bp , ex ) ; \n} \nnewInstance = invokeSetter ( setter , bp , newInstance ) ; \nreturn newInstance ; \n} \n} \n"}
{"1293": "public class UserSession { \npublic static void stop ( final HttpServletRequest servletRequest , final HttpServletResponse servletResponse ) { \nfinal HttpSession httpSession = servletRequest . getSession ( false ) ; \nif ( httpSession != null ) httpSession . removeAttribute ( AUTH_SESSION_NAME ) ; \nfinal Cookie cookie = ServletUtil . getCookie ( servletRequest , AUTH_COOKIE_NAME ) ; \nif ( cookie == null ) return ; \ncookie . setMaxAge ( 0 ) ; \ncookie . setPath ( \"/\" ) ; \nservletResponse . addCookie ( cookie ) ; \n} \n} \n"}
{"1302": "public class ValidationContext { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected void collectAnnotationChecks ( final List < Check > annChecks , final Class targetType , final String targetName , final Annotation [ ] annotations ) { \nfor ( Annotation annotation : annotations ) { \nConstraint c = annotation . annotationType ( ) . getAnnotation ( Constraint . class ) ; \nClass < ? extends ValidationConstraint > constraintClass ; \nif ( c == null ) { \nString constraintClassName = annotation . annotationType ( ) . getName ( ) + \"Constraint\" ; \ntry { \nconstraintClass = ClassLoaderUtil . loadClass ( constraintClassName , this . getClass ( ) . getClassLoader ( ) ) ; \n} \ncatch ( ClassNotFoundException ingore ) { \ncontinue ; \n} \n} \nelse constraintClass = c . value ( ) ; \nValidationConstraint vc ; \ntry { \nvc = newConstraint ( constraintClass , targetType ) ; \n} \ncatch ( Exception ex ) { \nthrow new VtorException ( \"Invalid constraint: \" + constraintClass . getClass ( ) . getName ( ) , ex ) ; \n} \nvc . configure ( annotation ) ; \nCheck check = new Check ( targetName , vc ) ; \ncopyDefaultCheckProperties ( check , annotation ) ; \nannChecks . add ( check ) ; \n} \n} \n} \n"}
{"1304": "public class URLCoder { \nprivate static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { \nif ( source == null ) return null ; \nbyte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; \nchar [ ] chars = new char [ bytes . length ] ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni ++ ) chars [ i ] = ( char ) bytes [ i ] ; \nreturn new String ( chars ) ; \n} \n} \n"}
{"1313": "public class Properties { \nprotected HashMap < String , PropertyDescriptor > inspectProperties ( ) { \nboolean scanAccessible = classDescriptor . isScanAccessible ( ) ; \nClass type = classDescriptor . getType ( ) ; \nHashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; \nMethod [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; \nfor ( int iteration = 0 ; \niteration < 2 ; \niteration ++ ) for ( Method method : methods ) { \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) continue ; \nboolean add = false ; \nboolean issetter = false ; \nString propertyName ; \nif ( iteration == 0 ) { \npropertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = false ; \n} \n} \nelse { \npropertyName = ClassUtil . getBeanPropertySetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = true ; \n} \n} \nif ( add ) { \nMethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; \naddProperty ( map , propertyName , methodDescriptor , issetter ) ; \n} \n} \nif ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { \nFieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; \nString [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; \nfor ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { \nField field = fieldDescriptor . getField ( ) ; \nif ( Modifier . isStatic ( field . getModifiers ( ) ) ) continue ; \nString name = field . getName ( ) ; \nif ( prefix != null ) for ( String p : prefix ) { \nif ( ! name . startsWith ( p ) ) continue ; \nname = name . substring ( p . length ( ) ) ; \nbreak ; \n} \nif ( ! map . containsKey ( name ) ) map . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; \n} \n} \nreturn map ; \n} \n} \n"}
{"1315": "public class HttpResponse { \npublic Cookie [ ] cookies ( ) { \nList < String > newCookies = headers ( \"set-cookie\" ) ; \nif ( newCookies == null ) return new Cookie [ 0 ] ; \nList < Cookie > cookieList = new ArrayList < > ( newCookies . size ( ) ) ; \nfor ( String cookieValue : newCookies ) { \ntry { \nCookie cookie = new Cookie ( cookieValue ) ; \ncookieList . add ( cookie ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nreturn cookieList . toArray ( new Cookie [ 0 ] ) ; \n} \n} \n"}
{"1316": "public class HttpResponse { \npublic HttpResponse unzip ( ) { \nString contentEncoding = contentEncoding ( ) ; \nif ( contentEncoding != null && contentEncoding ( ) . equals ( \"gzip\" ) ) if ( body != null ) { \nheaderRemove ( HEADER_CONTENT_ENCODING ) ; \ntry { \nByteArrayInputStream in = new ByteArrayInputStream ( body . getBytes ( StringPool . ISO_8859_1 ) ) ; \nGZIPInputStream gzipInputStream = new GZIPInputStream ( in ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nStreamUtil . copy ( gzipInputStream , out ) ; \nbody ( out . toString ( StringPool . ISO_8859_1 ) ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HttpException ( ioex ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1318": "public class ThreadLocalScope { \n@ Override public boolean accept ( final Scope referenceScope ) { \nClass < ? extends Scope > refScopeType = referenceScope . getClass ( ) ; \nif ( refScopeType == ProtoScope . class ) return true ; \nif ( refScopeType == SingletonScope . class ) return true ; \nif ( refScopeType == ThreadLocalScope . class ) return true ; \nreturn false ; \n} \n} \n"}
{"1319": "public class JoyMadvoc { \nprotected void printRoutes ( final int width ) { \nfinal ActionsManager actionsManager = webApp . madvocContainer ( ) . lookupComponent ( ActionsManager . class ) ; \nfinal List < ActionRuntime > actions = actionsManager . getAllActionRuntimes ( ) ; \nfinal Map < String , String > aliases = actionsManager . getAllAliases ( ) ; \nif ( actions . isEmpty ( ) ) return ; \nfinal Print print = new Print ( ) ; \nprint . line ( \"Routes\" , width ) ; \nactions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { \nfinal String actionMethod = ar . getActionMethod ( ) ; \nprint . out ( Chalk256 . chalk ( ) . yellow ( ) , actionMethod == null ? \"*\" : actionMethod , 7 ) ; \nprint . space ( ) ; \nfinal String signature = ClassUtil . getShortClassName ( ProxettaUtil . resolveTargetClass ( ar . getActionClass ( ) ) , 2 ) + '#' + ar . getActionClassMethod ( ) . getName ( ) ; \nprint . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , ar . getActionPath ( ) , Chalk256 . chalk ( ) . blue ( ) , signature , width - 7 - 1 ) ; \n} \n) ; \nif ( ! aliases . isEmpty ( ) ) { \nprint . line ( \"Aliases\" , width ) ; \nactions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { \nfinal String actionPath = ar . getActionPath ( ) ; \nfor ( final Map . Entry < String , String > entry : aliases . entrySet ( ) ) { \nif ( entry . getValue ( ) . equals ( actionPath ) ) { \nprint . space ( 8 ) ; \nprint . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , entry . getValue ( ) , Chalk256 . chalk ( ) . blue ( ) , entry . getKey ( ) , width - 8 ) ; \n} \n} \n} \n) ; \n} \nprint . line ( width ) ; \n} \n} \n"}
{"1320": "public class BlockCipher { \npublic byte [ ] encrypt ( final byte [ ] content ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = content . length + 1 ; \nint blockCount = length / blockSizeInBytes ; \nint remaining = length ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount ; \ni ++ ) { \nif ( remaining == blockSizeInBytes ) break ; \nbyte [ ] encrypted = encryptBlock ( content , offset ) ; \nfbb . append ( encrypted ) ; \noffset += blockSizeInBytes ; \nremaining -= blockSizeInBytes ; \n} \nif ( remaining != 0 ) { \nbyte [ ] block = new byte [ blockSizeInBytes ] ; \nSystem . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; \nblock [ remaining - 1 ] = TERMINATOR ; \nbyte [ ] encrypted = encryptBlock ( block , 0 ) ; \nfbb . append ( encrypted ) ; \n} \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = encryptedContent . length ; \nint blockCount = length / blockSizeInBytes ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount - 1 ; \ni ++ ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset += blockSizeInBytes ; \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nint ndx = blockSizeInBytes - 1 ; \nwhile ( ndx >= 0 ) { \nif ( decrypted [ ndx ] == TERMINATOR ) break ; \nndx -- ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1322": "public class MapToBean { \npublic Object map2bean ( final Map map , Class targetType ) { \nObject target = null ; \nString className = ( String ) map . get ( classMetadataName ) ; \nif ( className == null ) if ( targetType == null ) target = map ; \nelse { \ncheckClassName ( jsonParser . classnameWhitelist , className ) ; \ntry { \ntargetType = ClassLoaderUtil . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException cnfex ) { \nthrow new JsonException ( cnfex ) ; \n} \n} \nif ( target == null ) target = jsonParser . newObjectInstance ( targetType ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target . getClass ( ) ) ; \nboolean targetIsMap = target instanceof Map ; \nfor ( Object key : map . keySet ( ) ) { \nString keyName = key . toString ( ) ; \nif ( classMetadataName != null ) if ( keyName . equals ( classMetadataName ) ) continue ; \nPropertyDescriptor pd = cd . getPropertyDescriptor ( keyName , declared ) ; \nif ( ! targetIsMap && pd == null ) continue ; \nObject value = map . get ( key ) ; \nClass propertyType = pd == null ? null : pd . getType ( ) ; \nClass componentType = pd == null ? null : pd . resolveComponentType ( true ) ; \nif ( value != null ) if ( value instanceof List ) if ( componentType != null && componentType != String . class ) value = generifyList ( ( List ) value , componentType ) ; \nelse if ( value instanceof Map ) if ( ! ClassUtil . isTypeOf ( propertyType , Map . class ) ) value = map2bean ( ( Map ) value , propertyType ) ; \nelse { \nClass keyType = pd == null ? null : pd . resolveKeyType ( true ) ; \nif ( keyType != String . class || componentType != String . class ) value = generifyMap ( ( Map ) value , keyType , componentType ) ; \n} \nif ( targetIsMap ) ( ( Map ) target ) . put ( keyName , value ) ; \nelse try { \nsetValue ( target , pd , value ) ; \n} \ncatch ( Exception ignore ) { \nignore . printStackTrace ( ) ; \n} \n} \nreturn target ; \n} \n} \n"}
{"1323": "public class MapToBean { \nprivate Object generifyList ( final List list , final Class componentType ) { \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nObject element = list . get ( i ) ; \nif ( element != null ) if ( element instanceof Map ) { \nObject bean = map2bean ( ( Map ) element , componentType ) ; \nlist . set ( i , bean ) ; \n} \nelse { \nObject value = convert ( element , componentType ) ; \nlist . set ( i , value ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"1325": "public class MapToBean { \nprotected < K , V > Map < K , V > generifyMap ( final Map < Object , Object > map , final Class < K > keyType , final Class < V > valueType ) { \nif ( keyType == String . class ) { \nfor ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { \nObject value = entry . getValue ( ) ; \nObject newValue = convert ( value , valueType ) ; \nif ( value != newValue ) entry . setValue ( newValue ) ; \n} \nreturn ( Map < K , V > ) map ; \n} \nMap < K , V > newMap = new HashMap < > ( map . size ( ) ) ; \nfor ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { \nObject key = entry . getKey ( ) ; \nObject newKey = convert ( key , keyType ) ; \nObject value = entry . getValue ( ) ; \nObject newValue = convert ( value , valueType ) ; \nnewMap . put ( ( K ) newKey , ( V ) newValue ) ; \n} \nreturn newMap ; \n} \n} \n"}
{"1326": "public class DbEntityColumnDescriptor { \n@ Override public int compareTo ( final Object o ) { \nDbEntityColumnDescriptor that = ( DbEntityColumnDescriptor ) o ; \nif ( this . isId != that . isId ) return this . isId ? - 1 : 1 ; \nreturn this . columnName . compareTo ( that . columnName ) ; \n} \n} \n"}
{"1328": "public class HttpBrowser { \npublic HttpResponse sendRequest ( HttpRequest httpRequest ) { \nelapsedTime = System . currentTimeMillis ( ) ; \nhttpRequest . followRedirects ( false ) ; \nwhile ( true ) { \nthis . httpRequest = httpRequest ; \nHttpResponse previousResponse = this . httpResponse ; \nthis . httpResponse = null ; \naddDefaultHeaders ( httpRequest ) ; \naddCookies ( httpRequest ) ; \nif ( catchTransportExceptions ) try { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \ncatch ( HttpException httpException ) { \nhttpResponse = new HttpResponse ( ) ; \nhttpResponse . assignHttpRequest ( httpRequest ) ; \nhttpResponse . statusCode ( 503 ) ; \nhttpResponse . statusPhrase ( \"Service unavailable. \" + ExceptionUtil . message ( httpException ) ) ; \n} \nelse this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \nreadCookies ( httpResponse ) ; \nint statusCode = httpResponse . statusCode ( ) ; \nif ( statusCode == 301 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) break ; \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 302 || statusCode == 303 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) break ; \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 307 || statusCode == 308 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) break ; \nString originalMethod = httpRequest . method ( ) ; \nhttpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; \ncontinue ; \n} \nbreak ; \n} \nelapsedTime = System . currentTimeMillis ( ) - elapsedTime ; \nreturn this . httpResponse ; \n} \n} \n"}
{"1329": "public class HttpBrowser { \nprotected HttpResponse _sendRequest ( final HttpRequest httpRequest , final HttpResponse previouseResponse ) { \nif ( ! keepAlive ) httpRequest . open ( httpConnectionProvider ) ; \nelse if ( previouseResponse == null ) httpRequest . open ( httpConnectionProvider ) . connectionKeepAlive ( true ) ; \nelse httpRequest . keepAlive ( previouseResponse , true ) ; \nreturn httpRequest . send ( ) ; \n} \n} \n"}
{"1330": "public class HttpBrowser { \nprotected void addDefaultHeaders ( final HttpRequest httpRequest ) { \nfor ( Map . Entry < String , String > entry : defaultHeaders . entries ( ) ) { \nString name = entry . getKey ( ) ; \nif ( ! httpRequest . headers . contains ( name ) ) httpRequest . headers . add ( name , entry . getValue ( ) ) ; \n} \n} \n} \n"}
{"1334": "public class SendMailSession { \nprivate void setSubject ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nif ( emailWithData . subjectEncoding ( ) != null ) msgToSet . setSubject ( emailWithData . subject ( ) , emailWithData . subjectEncoding ( ) ) ; \nelse msgToSet . setSubject ( emailWithData . subject ( ) ) ; \n} \n} \n"}
{"1335": "public class SendMailSession { \nprivate void setSentDate ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nDate date = emailWithData . sentDate ( ) ; \nif ( date == null ) date = new Date ( ) ; \nmsgToSet . setSentDate ( date ) ; \n} \n} \n"}
{"1336": "public class SendMailSession { \nprivate void setHeaders ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal Map < String , String > headers = emailWithData . headers ( ) ; \nif ( headers != null ) for ( final Map . Entry < String , String > entry : headers . entrySet ( ) ) { \nmsgToSet . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \n} \n"}
{"1338": "public class SendMailSession { \nprivate void setRecipients ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal InternetAddress [ ] to = EmailAddress . convert ( emailWithData . to ( ) ) ; \nif ( to . length > 0 ) msgToSet . setRecipients ( RecipientType . TO , to ) ; \nfinal InternetAddress [ ] cc = EmailAddress . convert ( emailWithData . cc ( ) ) ; \nif ( cc . length > 0 ) msgToSet . setRecipients ( RecipientType . CC , cc ) ; \nfinal InternetAddress [ ] bcc = EmailAddress . convert ( emailWithData . bcc ( ) ) ; \nif ( bcc . length > 0 ) msgToSet . setRecipients ( RecipientType . BCC , bcc ) ; \n} \n} \n"}
{"1339": "public class SendMailSession { \nprivate void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal List < EmailMessage > messages = emailWithData . messages ( ) ; \nfinal int totalMessages = messages . size ( ) ; \nfinal List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList < > ( emailWithData . attachments ( ) ) ; \nif ( attachments . isEmpty ( ) && totalMessages == 1 ) setContent ( messages . get ( 0 ) , msgToSet ) ; \nelse { \nfinal MimeMultipart multipart = new MimeMultipart ( ) ; \nfinal MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; \nmultipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; \nfor ( final EmailMessage emailMessage : messages ) { \nmsgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; \n} \naddAnyAttachments ( attachments , multipart ) ; \nmsgToSet . setContent ( multipart ) ; \n} \n} \n} \n"}
{"1341": "public class SendMailSession { \nprotected MimeBodyPart createAttachmentBodyPart ( final EmailAttachment < ? extends DataSource > attachment ) throws MessagingException { \nfinal MimeBodyPart part = new MimeBodyPart ( ) ; \nfinal String attachmentName = attachment . getEncodedName ( ) ; \nif ( attachmentName != null ) part . setFileName ( attachmentName ) ; \npart . setDataHandler ( new DataHandler ( attachment . getDataSource ( ) ) ) ; \nif ( attachment . getContentId ( ) != null ) part . setContentID ( StringPool . LEFT_CHEV + attachment . getContentId ( ) + StringPool . RIGHT_CHEV ) ; \nif ( attachment . isInline ( ) ) part . setDisposition ( INLINE ) ; \nreturn part ; \n} \n} \n"}
{"1342": "public class FileUploadHeader { \nprivate String getContentType ( final String dataHeader ) { \nString token = \"Content-Type:\" ; \nint start = dataHeader . indexOf ( token ) ; \nif ( start == - 1 ) return StringPool . EMPTY ; \nstart += token . length ( ) ; \nreturn dataHeader . substring ( start ) . trim ( ) ; \n} \n} \n"}
{"1343": "public class DbQueryBase { \nprotected void saveResultSet ( final ResultSet rs ) { \nif ( resultSets == null ) resultSets = new HashSet < > ( ) ; \nresultSets . add ( rs ) ; \n} \n} \n"}
{"1344": "public class DbQueryBase { \npublic Q closeAllResultSets ( ) { \nfinal SQLException sex = closeQueryResultSets ( ) ; \nif ( sex != null ) throw new DbSqlException ( \"Close associated ResultSets error\" , sex ) ; \nreturn _this ( ) ; \n} \n} \n"}
{"1345": "public class DbQueryBase { \nprotected SQLException closeQuery ( ) { \nSQLException sqlException = closeQueryResultSets ( ) ; \nif ( statement != null ) { \ntry { \nstatement . close ( ) ; \n} \ncatch ( SQLException sex ) { \nif ( sqlException == null ) sqlException = sex ; \nelse sqlException . setNextException ( sex ) ; \n} \nstatement = null ; \n} \nquery = null ; \nqueryState = CLOSED ; \nreturn sqlException ; \n} \n} \n"}
{"1346": "public class DbQueryBase { \n@ Override @ SuppressWarnings ( { \n\"ClassReferencesSubclass\" } \n) public void close ( ) { \nfinal SQLException sqlException = closeQuery ( ) ; \nconnection = null ; \nif ( this . session != null ) this . session . detachQuery ( this ) ; \nif ( sqlException != null ) throw new DbSqlException ( \"Close query error\" , sqlException ) ; \n} \n} \n"}
{"1347": "public class DbQueryBase { \npublic Q setFetchSize ( final int rows ) { \ncheckNotClosed ( ) ; \nthis . fetchSize = rows ; \nif ( statement != null ) try { \nstatement . setFetchSize ( fetchSize ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Unable to set fetch size: \" + fetchSize , sex ) ; \n} \nreturn _this ( ) ; \n} \n} \n"}
{"1348": "public class DbQueryBase { \npublic Q setMaxRows ( final int maxRows ) { \ncheckNotClosed ( ) ; \nthis . maxRows = maxRows ; \nif ( statement != null ) try { \nstatement . setMaxRows ( maxRows ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Unable to set max rows: \" + maxRows , sex ) ; \n} \nreturn _this ( ) ; \n} \n} \n"}
{"1349": "public class DbQueryBase { \nprotected int executeUpdate ( final boolean closeQuery ) { \nstart = System . currentTimeMillis ( ) ; \ninit ( ) ; \nfinal int result ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Executing update: \" + getQueryString ( ) ) ; \ntry { \nif ( preparedStatement == null ) if ( generatedColumns != null ) if ( generatedColumns . length == 0 ) result = statement . executeUpdate ( query . sql , Statement . RETURN_GENERATED_KEYS ) ; \nelse result = statement . executeUpdate ( query . sql , generatedColumns ) ; \nelse result = statement . executeUpdate ( query . sql ) ; \nelse result = preparedStatement . executeUpdate ( ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Query execution failed\" , sex ) ; \n} \nif ( closeQuery ) close ( ) ; \nelapsed = System . currentTimeMillis ( ) - start ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"execution time: \" + elapsed + \"ms\" ) ; \nreturn result ; \n} \n} \n"}
{"1350": "public class DbQueryBase { \nprotected long executeCount ( final boolean close ) { \nstart = System . currentTimeMillis ( ) ; \ninit ( ) ; \nResultSet rs = null ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"Executing prepared count: \" + getQueryString ( ) ) ; \ntry { \nif ( preparedStatement == null ) rs = statement . executeQuery ( query . sql ) ; \nelse rs = preparedStatement . executeQuery ( ) ; \nfinal long firstLong = DbUtil . getFirstLong ( rs ) ; \nelapsed = System . currentTimeMillis ( ) - start ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"execution time: \" + elapsed + \"ms\" ) ; \nreturn firstLong ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"Count query failed\" , sex ) ; \n} \nfinally { \nDbUtil . close ( rs ) ; \nif ( close ) close ( ) ; \n} \n} \n} \n"}
{"1351": "public class DbQueryBase { \npublic ResultSet getGeneratedColumns ( ) { \ncheckInitialized ( ) ; \nif ( generatedColumns == null ) throw new DbSqlException ( this , \"No column is specified as auto-generated\" ) ; \nfinal ResultSet rs ; \ntry { \nrs = statement . getGeneratedKeys ( ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"No generated keys\" , sex ) ; \n} \nsaveResultSet ( rs ) ; \ntotalOpenResultSetCount ++ ; \nreturn rs ; \n} \n} \n"}
{"1352": "public class DbQueryBase { \npublic String getQueryString ( ) { \nif ( debug ) { \nif ( ( callableStatement != null ) ) if ( preparedStatement instanceof LoggableCallableStatement ) return ( ( LoggableCallableStatement ) callableStatement ) . getQueryString ( ) ; \nif ( preparedStatement != null ) if ( preparedStatement instanceof LoggablePreparedStatement ) return ( ( LoggablePreparedStatement ) preparedStatement ) . getQueryString ( ) ; \n} \nif ( query != null ) return query . sql ; \nreturn sqlString ; \n} \n} \n"}
{"1354": "public class CollectionUtil { \npublic static < T > Collection < T > collectionOf ( final Iterator < ? extends T > iterator ) { \nfinal List < T > list = new ArrayList < > ( ) ; \nwhile ( iterator . hasNext ( ) ) list . add ( iterator . next ( ) ) ; \nreturn list ; \n} \n} \n"}
{"1356": "public class MultiComparator { \n@ Override public int compare ( final T o1 , final T o2 ) { \nfor ( Comparator < T > comparator : comparators ) { \nint result = comparator . compare ( o1 , o2 ) ; \nif ( result != 0 ) return result ; \n} \nreturn 0 ; \n} \n} \n"}
{"1357": "public class PetiteConfig { \npublic PetiteConfig setDefaultWiringMode ( final WiringMode defaultWiringMode ) { \nif ( ( defaultWiringMode == null ) || ( defaultWiringMode == WiringMode . DEFAULT ) ) throw new PetiteException ( \"Invalid default wiring mode: \" + defaultWiringMode ) ; \nthis . defaultWiringMode = defaultWiringMode ; \nreturn this ; \n} \n} \n"}
{"1358": "public class SimpleLogger { \nprotected void print ( final Level level , final String message , final Throwable throwable ) { \nif ( ! isEnabled ( level ) ) return ; \nStringBuilder msg = new StringBuilder ( ) . append ( slf . getElapsedTime ( ) ) . append ( ' ' ) . append ( '[' ) . append ( level ) . append ( ']' ) . append ( ' ' ) . append ( getCallerClass ( ) ) . append ( ' ' ) . append ( '-' ) . append ( ' ' ) . append ( message ) ; \nSystem . out . println ( msg . toString ( ) ) ; \nif ( throwable != null ) throwable . printStackTrace ( System . out ) ; \n} \n} \n"}
{"1359": "public class SimpleLogger { \nprotected String getCallerClass ( ) { \nException exception = new Exception ( ) ; \nStackTraceElement [ ] stackTrace = exception . getStackTrace ( ) ; \nfor ( StackTraceElement stackTraceElement : stackTrace ) { \nString className = stackTraceElement . getClassName ( ) ; \nif ( className . equals ( SimpleLoggerProvider . class . getName ( ) ) ) continue ; \nif ( className . equals ( SimpleLogger . class . getName ( ) ) ) continue ; \nif ( className . equals ( Logger . class . getName ( ) ) ) continue ; \nreturn shortenClassName ( className ) + '.' + stackTraceElement . getMethodName ( ) + ':' + stackTraceElement . getLineNumber ( ) ; \n} \nreturn \"N/A\" ; \n} \n} \n"}
{"1360": "public class SimpleLogger { \nprotected String shortenClassName ( final String className ) { \nint lastDotIndex = className . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 ) return className ; \nStringBuilder shortClassName = new StringBuilder ( className . length ( ) ) ; \nint start = 0 ; \nwhile ( true ) { \nshortClassName . append ( className . charAt ( start ) ) ; \nint next = className . indexOf ( '.' , start ) ; \nif ( next == lastDotIndex ) break ; \nstart = next + 1 ; \nshortClassName . append ( '.' ) ; \n} \nshortClassName . append ( className . substring ( lastDotIndex ) ) ; \nreturn shortClassName . toString ( ) ; \n} \n} \n"}
{"1361": "public class JsonSerializer { \npublic JsonSerializer excludeTypes ( final Class ... types ) { \nif ( excludedTypes == null ) excludedTypes = types ; \nelse excludedTypes = ArraysUtil . join ( excludedTypes , types ) ; \nreturn this ; \n} \n} \n"}
{"1369": "public class DefaultResultSetMapper { \nprotected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { \nif ( cachedMappedNames == null ) { \nString [ ] [ ] names = new String [ types . length ] [ ] ; \nfor ( int i = 0 ; \ni < types . length ; \ni ++ ) { \nClass type = types [ i ] ; \nif ( type != null ) { \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded != null ) { \nClass [ ] mappedTypes = ded . getMappedTypes ( ) ; \nif ( mappedTypes != null ) names [ i ] = createTypesTableNames ( mappedTypes ) ; \n} \n} \n} \ncachedMappedNames = names ; \n} \nreturn cachedMappedNames ; \n} \n} \n"}
{"1371": "public class DefaultResultSetMapper { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected Object readColumnValue ( final int colNdx , final Class destinationType , final Class < ? extends SqlType > sqlTypeClass , final int columnDbSqlType ) { \nif ( colNdx != cachedColumnNdx ) { \ntry { \nSqlType sqlType ; \nif ( sqlTypeClass != null ) sqlType = SqlTypeManager . get ( ) . lookupSqlType ( sqlTypeClass ) ; \nelse sqlType = SqlTypeManager . get ( ) . lookup ( destinationType ) ; \nif ( sqlType != null ) cachedColumnValue = sqlType . readValue ( resultSet , colNdx + 1 , destinationType , columnDbSqlType ) ; \nelse { \ncachedColumnValue = resultSet . getObject ( colNdx + 1 ) ; \ncachedColumnValue = TypeConverterManager . get ( ) . convertType ( cachedColumnValue , destinationType ) ; \n} \n} \ncatch ( SQLException sex ) { \nthrow new DbOomException ( dbOomQuery , \"Invalid value for column #\" + ( colNdx + 1 ) , sex ) ; \n} \ncachedColumnNdx = colNdx ; \n} \nreturn cachedColumnValue ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) entitiesCache = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) { \nObject object = result [ i ] ; \nif ( object == null ) continue ; \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) continue ; \nObject key ; \nif ( ded . hasIdColumn ( ) ) key = ded . getKeyValue ( object ) ; \nelse key = object ; \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( cachedObject == null ) entitiesCache . put ( key , object ) ; \nelse result [ i ] = cachedObject ; \n} \n} \n} \n"}
{"1373": "public class ProviderResolver { \npublic ProviderDefinition [ ] resolve ( final Class type , final String name ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( ) ; \nList < ProviderDefinition > list = new ArrayList < > ( ) ; \nfor ( MethodDescriptor methodDescriptor : methods ) { \nMethod method = methodDescriptor . getMethod ( ) ; \nPetiteProvider petiteProvider = method . getAnnotation ( PetiteProvider . class ) ; \nif ( petiteProvider == null ) continue ; \nString providerName = petiteProvider . value ( ) ; \nif ( StringUtil . isBlank ( providerName ) ) { \nproviderName = method . getName ( ) ; \nif ( providerName . endsWith ( \"Provider\" ) ) providerName = StringUtil . substring ( providerName , 0 , - 8 ) ; \n} \nProviderDefinition providerDefinition ; \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) providerDefinition = new ProviderDefinition ( providerName , method ) ; \nelse providerDefinition = new ProviderDefinition ( providerName , name , method ) ; \nlist . add ( providerDefinition ) ; \n} \nProviderDefinition [ ] providers ; \nif ( list . isEmpty ( ) ) providers = ProviderDefinition . EMPTY ; \nelse providers = list . toArray ( new ProviderDefinition [ 0 ] ) ; \nreturn providers ; \n} \n} \n"}
{"1375": "public class CoreConnectionPool { \nprivate boolean isConnectionValid ( final ConnectionData connectionData , final long now ) { \nif ( ! validateConnection ) return true ; \nif ( now < connectionData . lastUsed + validationTimeout ) return true ; \nConnection conn = connectionData . connection ; \nif ( validationQuery == null ) try { \nreturn ! conn . isClosed ( ) ; \n} \ncatch ( SQLException sex ) { \nreturn false ; \n} \nboolean valid = true ; \nStatement st = null ; \ntry { \nst = conn . createStatement ( ) ; \nst . execute ( validationQuery ) ; \n} \ncatch ( SQLException sex ) { \nvalid = false ; \n} \nfinally { \nif ( st != null ) try { \nst . close ( ) ; \n} \ncatch ( SQLException ignore ) { \n} \n} \nreturn valid ; \n} \n} \n"}
{"1376": "public class ServletDispatcherActionResult { \n@ Override protected void renderView ( final ActionRequest actionRequest , final String target ) throws Exception { \nHttpServletRequest request = actionRequest . getHttpServletRequest ( ) ; \nHttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; \nRequestDispatcher dispatcher = request . getRequestDispatcher ( target ) ; \nif ( dispatcher == null ) { \nresponse . sendError ( SC_NOT_FOUND , \"Result not found: \" + target ) ; \nreturn ; \n} \nif ( DispatcherUtil . isPageIncluded ( request , response ) ) dispatcher . include ( request , response ) ; \nelse dispatcher . forward ( request , response ) ; \n} \n} \n"}
{"1377": "public class ServletDispatcherActionResult { \n@ Override protected String locateTarget ( final ActionRequest actionRequest , String path ) { \nString target ; \nif ( path . endsWith ( StringPool . SLASH ) ) path = path + defaultViewPageName ; \nfor ( final String ext : defaultViewExtensions ) { \ntarget = path + ext ; \nif ( targetExists ( actionRequest , target ) ) return target ; \n} \nreturn null ; \n} \n} \n"}
{"1378": "public class BufferResponseWrapper { \n@ Override public PrintWriter getWriter ( ) throws IOException { \npreResponseCommit ( ) ; \nif ( buffer == null ) return getResponse ( ) . getWriter ( ) ; \nreturn buffer . getWriter ( ) ; \n} \n} \n"}
{"1379": "public class BufferResponseWrapper { \n@ Override public ServletOutputStream getOutputStream ( ) throws IOException { \npreResponseCommit ( ) ; \nif ( buffer == null ) return getResponse ( ) . getOutputStream ( ) ; \nreturn buffer . getOutputStream ( ) ; \n} \n} \n"}
{"1380": "public class BufferResponseWrapper { \npublic void writeContentToResponse ( final char [ ] content ) throws IOException { \nif ( buffer == null ) return ; \nif ( buffer . isUsingStream ( ) ) { \nServletOutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; \nString encoding = getContentTypeEncoding ( ) ; \nif ( encoding == null ) outputStream . write ( CharUtil . toByteArray ( content ) ) ; \nelse outputStream . write ( CharUtil . toByteArray ( content , encoding ) ) ; \noutputStream . flush ( ) ; \n} \nelse { \nWriter out = getResponse ( ) . getWriter ( ) ; \nout . write ( content ) ; \nout . flush ( ) ; \n} \n} \n} \n"}
{"1381": "public class BufferResponseWrapper { \n@ Override public void setContentType ( final String type ) { \nsuper . setContentType ( type ) ; \ncontentTypeResolver = new ContentTypeHeaderResolver ( type ) ; \nif ( bufferContentType ( type , contentTypeResolver . getMimeType ( ) , contentTypeResolver . getEncoding ( ) ) ) enableBuffering ( ) ; \nelse disableBuffering ( ) ; \n} \n} \n"}
{"1382": "public class BufferResponseWrapper { \npublic void print ( final String string ) throws IOException { \nif ( isBufferStreamBased ( ) ) { \nString encoding = getContentTypeEncoding ( ) ; \nbyte [ ] bytes ; \nif ( encoding == null ) bytes = string . getBytes ( ) ; \nelse bytes = string . getBytes ( encoding ) ; \nbuffer . getOutputStream ( ) . write ( bytes ) ; \nreturn ; \n} \nbuffer . getWriter ( ) . write ( string ) ; \n} \n} \n"}
{"1383": "public class AuthAction { \nprotected JsonResult login ( ) { \nT authToken ; \nauthToken = loginViaBasicAuth ( servletRequest ) ; \nif ( authToken == null ) authToken = loginViaRequestParams ( servletRequest ) ; \nif ( authToken == null ) { \nlog . warn ( \"Login failed.\" ) ; \nreturn JsonResult . of ( HttpStatus . error401 ( ) . unauthorized ( \"Login failed.\" ) ) ; \n} \nlog . info ( \"login OK!\" ) ; \nfinal UserSession < T > userSession = new UserSession < > ( authToken , userAuth . tokenValue ( authToken ) ) ; \nuserSession . start ( servletRequest , servletResponse ) ; \nreturn tokenAsJson ( authToken ) ; \n} \n} \n"}
{"1385": "public class AuthAction { \nprotected T loginViaBasicAuth ( final HttpServletRequest servletRequest ) { \nfinal String username = ServletUtil . resolveAuthUsername ( servletRequest ) ; \nif ( username == null ) return null ; \nfinal String password = ServletUtil . resolveAuthPassword ( servletRequest ) ; \nreturn userAuth . login ( username , password ) ; \n} \n} \n"}
{"1387": "public class FileUtil { \npublic static File toContainerFile ( final URL url ) { \nString protocol = url . getProtocol ( ) ; \nif ( protocol . equals ( FILE_PROTOCOL ) ) return toFile ( url ) ; \nString path = url . getPath ( ) ; \nreturn new File ( URI . create ( path . substring ( ZERO , path . lastIndexOf ( \"!/\" ) ) ) ) ; \n} \n} \n"}
{"1390": "public class FileUtil { \nprivate static void _copyFile ( final File srcFile , final File destFile ) throws IOException { \nif ( destFile . exists ( ) ) if ( destFile . isDirectory ( ) ) throw new IOException ( \"Destination '\" + destFile + \"' is a directory\" ) ; \nFileInputStream input = null ; \nFileOutputStream output = null ; \ntry { \ninput = new FileInputStream ( srcFile ) ; \noutput = new FileOutputStream ( destFile , false ) ; \nStreamUtil . copy ( input , output ) ; \n} \nfinally { \nStreamUtil . close ( output ) ; \nStreamUtil . close ( input ) ; \n} \nif ( srcFile . length ( ) != destFile . length ( ) ) throw new IOException ( \"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\" ) ; \ndestFile . setLastModified ( srcFile . lastModified ( ) ) ; \n} \n} \n"}
{"1394": "public class FileUtil { \npublic static void cleanDir ( final File destDir ) throws IOException { \ncheckExists ( destDir ) ; \ncheckIsDirectory ( destDir ) ; \nFile [ ] files = destDir . listFiles ( ) ; \nif ( files == null ) throw new IOException ( \"Failed to list contents of: \" + destDir ) ; \nIOException exception = null ; \nfor ( File file : files ) { \ntry { \nif ( file . isDirectory ( ) ) deleteDir ( file ) ; \nelse file . delete ( ) ; \n} \ncatch ( IOException ioex ) { \nexception = ioex ; \ncontinue ; \n} \n} \nif ( exception != null ) throw exception ; \n} \n} \n"}
{"1400": "public class FileUtil { \npublic static byte [ ] readBytes ( final File file , final int count ) throws IOException { \ncheckExists ( file ) ; \ncheckIsFile ( file ) ; \nlong numToRead = file . length ( ) ; \nif ( numToRead >= Integer . MAX_VALUE ) throw new IOException ( \"File is larger then max array size\" ) ; \nif ( count > NEGATIVE_ONE && count < numToRead ) numToRead = count ; \nbyte [ ] bytes = new byte [ ( int ) numToRead ] ; \nRandomAccessFile randomAccessFile = new RandomAccessFile ( file , \"r\" ) ; \nrandomAccessFile . readFully ( bytes ) ; \nrandomAccessFile . close ( ) ; \nreturn bytes ; \n} \n} \n"}
{"1406": "public class FileUtil { \npublic static boolean isBinary ( final File file ) throws IOException { \nbyte [ ] bytes = readBytes ( file , 128 ) ; \nfor ( byte b : bytes ) { \nif ( b < 32 && b != 9 && b != 10 && b != 13 ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"1407": "public class FileUtil { \nprivate static void checkDirCopy ( final File srcDir , final File destDir ) throws IOException { \ncheckExists ( srcDir ) ; \ncheckIsDirectory ( srcDir ) ; \nif ( equals ( srcDir , destDir ) ) throw new IOException ( \"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\" ) ; \n} \n} \n"}
{"1408": "public class FileUtil { \nprivate static void checkFileCopy ( final File srcFile , final File destFile ) throws IOException { \ncheckExists ( srcFile ) ; \ncheckIsFile ( srcFile ) ; \nif ( equals ( srcFile , destFile ) ) throw new IOException ( \"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\" ) ; \nFile destParent = destFile . getParentFile ( ) ; \nif ( destParent != null && ! destParent . exists ( ) ) checkCreateDirectory ( destParent ) ; \n} \n} \n"}
{"1409": "public class Cli { \npublic void printUsage ( final String commandName ) { \nfinal StringBuilder usage = new StringBuilder ( commandName ) ; \nfor ( final Option option : options ) { \nif ( option . shortName != null ) usage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; \nelse if ( option . longName != null ) usage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; \n} \nfor ( final Param param : params ) { \nusage . append ( \" \" ) . append ( param . label ) ; \n} \nSystem . out . println ( usage ) ; \n} \n} \n"}
{"1410": "public class ActionsManager { \npublic Method resolveActionMethod ( final Class < ? > actionClass , final String methodName ) { \nMethodDescriptor methodDescriptor = ClassIntrospector . get ( ) . lookup ( actionClass ) . getMethodDescriptor ( methodName , false ) ; \nif ( methodDescriptor == null ) throw new MadvocException ( \"Public method not found: \" + actionClass . getSimpleName ( ) + \"#\" + methodName ) ; \nreturn methodDescriptor . getMethod ( ) ; \n} \n} \n"}
{"1412": "public class ActionsManager { \npublic void registerPathAlias ( final String alias , final String path ) { \nfinal String existing = pathAliases . put ( alias , path ) ; \nif ( existing != null ) throw new MadvocException ( \"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing ) ; \n} \n} \n"}
{"1413": "public class LoopIterator { \npublic boolean next ( ) { \nif ( ! looping ) return false ; \nif ( last ) return false ; \nif ( count == 0 ) { \nvalue = start ; \nfirst = true ; \n} \nelse { \nvalue += step ; \nfirst = false ; \n} \ncount ++ ; \nlast = isLastIteration ( value + step ) ; \nreturn true ; \n} \n} \n"}
{"1416": "public class Scanner { \npublic final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { \nif ( ndx + uppercaseTarget . length > total ) return false ; \nint j = ndx ; \nfor ( int i = 0 ; \ni < uppercaseTarget . length ; \ni ++ , j ++ ) { \nfinal char c = CharUtil . toUpperAscii ( input [ j ] ) ; \nif ( c != uppercaseTarget [ i ] ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1417": "public class Scanner { \nprotected final CharSequence charSequence ( final int from , final int to ) { \nif ( from == to ) return CharArraySequence . EMPTY ; \nreturn CharArraySequence . of ( input , from , to - from ) ; \n} \n} \n"}
{"1418": "public class ClassPathURLs { \npublic static URL [ ] of ( ClassLoader classLoader , Class clazz ) { \nif ( clazz == null ) clazz = ClassPathURLs . class ; \nif ( classLoader == null ) classLoader = clazz . getClassLoader ( ) ; \nfinal Set < URL > urls = new LinkedHashSet < > ( ) ; \nwhile ( classLoader != null ) { \nif ( classLoader instanceof URLClassLoader ) { \nURLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; \nURL [ ] allURLS = urlClassLoader . getURLs ( ) ; \nCollections . addAll ( urls , allURLS ) ; \nbreak ; \n} \nURL classUrl = classModuleUrl ( classLoader , clazz ) ; \nif ( classUrl != null ) urls . add ( classUrl ) ; \nclassUrl = classModuleUrl ( classLoader , ClassPathURLs . class ) ; \nif ( classUrl != null ) urls . add ( classUrl ) ; \nModuleDescriptor moduleDescriptor = clazz . getModule ( ) . getDescriptor ( ) ; \nif ( moduleDescriptor != null ) moduleDescriptor . requires ( ) . forEach ( req -> { \nModuleLayer . boot ( ) . findModule ( req . name ( ) ) . ifPresent ( mod -> { \nClassLoader moduleClassLoader = mod . getClassLoader ( ) ; \nif ( moduleClassLoader != null ) { \nURL url = moduleClassLoader . getResource ( MANIFEST ) ; \nif ( url != null ) { \nurl = fixManifestUrl ( url ) ; \nurls . add ( url ) ; \n} \n} \n} \n) ; \n} \n) ; \nclassLoader = classLoader . getParent ( ) ; \n} \nreturn urls . toArray ( new URL [ 0 ] ) ; \n} \n} \n"}
{"1421": "public class TypeJsonSerializerMap { \nprotected TypeJsonSerializer lookupSerializer ( final Class type ) { \nTypeJsonSerializer tjs = map . get ( type ) ; \nif ( tjs == null ) if ( defaultSerializerMap != null ) tjs = defaultSerializerMap . map . get ( type ) ; \nreturn tjs ; \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nwhile ( true ) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) break ; \nif ( header . isFile ) { \nString fileName = header . fileName ; \nif ( fileName . length ( ) > 0 ) if ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) input . skipBytes ( 128 ) ; \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) if ( newFile . getSize ( ) == 0 ) newFile . size = - 1 ; \nputFile ( header . formFieldName , newFile ) ; \n} \nelse { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nint nextByte = input . read ( ) ; \nif ( nextByte == - 1 || nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \n} \n} \n"}
{"1423": "public class MultipartStreamParser { \npublic String getParameter ( final String paramName ) { \nif ( requestParameters == null ) return null ; \nString [ ] values = requestParameters . get ( paramName ) ; \nif ( ( values != null ) && ( values . length > 0 ) ) return values [ 0 ] ; \nreturn null ; \n} \n} \n"}
{"1424": "public class MultipartStreamParser { \npublic String [ ] getParameterValues ( final String paramName ) { \nif ( requestParameters == null ) return null ; \nreturn requestParameters . get ( paramName ) ; \n} \n} \n"}
{"1425": "public class MultipartStreamParser { \npublic FileUpload getFile ( final String paramName ) { \nif ( requestFiles == null ) return null ; \nFileUpload [ ] values = requestFiles . get ( paramName ) ; \nif ( ( values != null ) && ( values . length > 0 ) ) return values [ 0 ] ; \nreturn null ; \n} \n} \n"}
{"1426": "public class MultipartStreamParser { \npublic FileUpload [ ] getFiles ( final String paramName ) { \nif ( requestFiles == null ) return null ; \nreturn requestFiles . get ( paramName ) ; \n} \n} \n"}
{"1427": "public class CharacterEncodingFilter { \n@ Override public void init ( final FilterConfig filterConfig ) { \nthis . filterConfig = filterConfig ; \nthis . encoding = filterConfig . getInitParameter ( \"encoding\" ) ; \nif ( this . encoding == null ) this . encoding = JoddCore . encoding ; \nthis . ignore = Converter . get ( ) . toBooleanValue ( filterConfig . getInitParameter ( \"ignore\" ) , true ) ; \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) sqlBuilder . appendRaw ( template . substring ( last ) ) ; \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse sqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) break ; \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1429": "public class TemplateParser { \nprotected int findMacroEnd ( final String template , final int fromIndex ) { \nint endIndex = template . indexOf ( '}' , fromIndex ) ; \nif ( endIndex == - 1 ) throw new DbSqlBuilderException ( \"Template syntax error, some macros are not closed. Error at: '...\" + template . substring ( fromIndex ) ) ; \nreturn endIndex ; \n} \n} \n"}
{"1430": "public class TemplateParser { \nprotected int countEscapes ( final String template , int macroIndex ) { \nmacroIndex -- ; \nint escapeCount = 0 ; \nwhile ( macroIndex >= 0 ) { \nif ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) break ; \nescapeCount ++ ; \nmacroIndex -- ; \n} \nreturn escapeCount ; \n} \n} \n"}
{"1431": "public class HttpUtil { \npublic static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { \nif ( queryMap . isEmpty ( ) ) return StringPool . EMPTY ; \nint queryMapSize = queryMap . size ( ) ; \nStringBand query = new StringBand ( queryMapSize * 4 ) ; \nint count = 0 ; \nfor ( Map . Entry < String , ? > entry : queryMap ) { \nString key = entry . getKey ( ) ; \nkey = URLCoder . encodeQueryParam ( key , encoding ) ; \nObject value = entry . getValue ( ) ; \nif ( value == null ) { \nif ( count != 0 ) query . append ( '&' ) ; \nquery . append ( key ) ; \ncount ++ ; \n} \nelse { \nif ( count != 0 ) query . append ( '&' ) ; \nquery . append ( key ) ; \ncount ++ ; \nquery . append ( '=' ) ; \nString valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; \nquery . append ( valueString ) ; \n} \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"1432": "public class HttpUtil { \npublic static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { \nfinal HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nif ( StringUtil . isBlank ( query ) ) return queryMap ; \nint lastNdx = 0 ; \nwhile ( lastNdx < query . length ( ) ) { \nint ndx = query . indexOf ( '&' , lastNdx ) ; \nif ( ndx == - 1 ) ndx = query . length ( ) ; \nfinal String paramAndValue = query . substring ( lastNdx , ndx ) ; \nndx = paramAndValue . indexOf ( '=' ) ; \nif ( ndx == - 1 ) queryMap . add ( paramAndValue , null ) ; \nelse { \nString name = paramAndValue . substring ( 0 , ndx ) ; \nif ( decode ) name = URLDecoder . decodeQuery ( name ) ; \nString value = paramAndValue . substring ( ndx + 1 ) ; \nif ( decode ) value = URLDecoder . decodeQuery ( value ) ; \nqueryMap . add ( name , value ) ; \n} \nlastNdx += paramAndValue . length ( ) + 1 ; \n} \nreturn queryMap ; \n} \n} \n"}
{"1433": "public class HttpUtil { \npublic static String prepareHeaderParameterName ( final String headerName ) { \nif ( headerName . equals ( \"etag\" ) ) return HttpBase . HEADER_ETAG ; \nif ( headerName . equals ( \"www-authenticate\" ) ) return \"WWW-Authenticate\" ; \nchar [ ] name = headerName . toCharArray ( ) ; \nboolean capitalize = true ; \nfor ( int i = 0 ; \ni < name . length ; \ni ++ ) { \nchar c = name [ i ] ; \nif ( c == '-' ) { \ncapitalize = true ; \ncontinue ; \n} \nif ( capitalize ) { \nname [ i ] = Character . toUpperCase ( c ) ; \ncapitalize = false ; \n} \nelse name [ i ] = Character . toLowerCase ( c ) ; \n} \nreturn new String ( name ) ; \n} \n} \n"}
{"1434": "public class HttpUtil { \npublic static String extractMediaType ( final String contentType ) { \nint index = contentType . indexOf ( ';' ) ; \nif ( index == - 1 ) return contentType ; \nreturn contentType . substring ( 0 , index ) ; \n} \n} \n"}
{"1438": "public class JsonParser { \nprotected void reset ( ) { \nthis . ndx = 0 ; \nthis . textLen = 0 ; \nthis . path = new Path ( ) ; \nthis . notFirstObject = false ; \nif ( useAltPaths ) path . altPath = new Path ( ) ; \nif ( classMetadataName != null ) mapToBean = createMapToBean ( classMetadataName ) ; \n} \n} \n"}
{"1440": "public class JsonParser { \nprotected Class replaceWithMappedTypeForPath ( final Class target ) { \nif ( mappings == null ) return target ; \nClass newType ; \nPath altPath = path . getAltPath ( ) ; \nif ( altPath != null ) if ( ! altPath . equals ( path ) ) { \nnewType = mappings . get ( altPath ) ; \nif ( newType != null ) return newType ; \n} \nnewType = mappings . get ( path ) ; \nif ( newType != null ) return newType ; \nreturn target ; \n} \n} \n"}
{"1443": "public class JsonParser { \nprivate Object resolveLazyValue ( Object value ) { \nif ( value instanceof Supplier ) value = ( ( Supplier ) value ) . get ( ) ; \nreturn value ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) if ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) insideString = false ; \nelse if ( c == '\\\"' ) insideString = true ; \nelse if ( c == '{' ) bracketCount ++ ; \nelse if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1445": "public class JsonParser { \nprotected String parseString ( ) { \nchar quote = '\\\"' ; \nif ( looseMode ) { \nquote = consumeOneOf ( '\\\"' , '\\'' ) ; \nif ( quote == 0 ) return parseUnquotedStringContent ( ) ; \n} \nelse consume ( quote ) ; \nreturn parseStringContent ( quote ) ; \n} \n} \n"}
{"1446": "public class JsonParser { \nprotected String parseStringContent ( final char quote ) { \nfinal int startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nreturn new String ( input , startNdx , ndx - 1 - startNdx ) ; \n} \nif ( c == '\\\\' ) break ; \nndx ++ ; \n} \ntextLen = ndx - startNdx ; \ngrowEmpty ( ) ; \nSystem . arraycopy ( input , startNdx , text , 0 , textLen ) ; \nwhile ( true ) { \nchar c = input [ ndx ] ; \nif ( c == quote ) { \nndx ++ ; \nfinal String str = new String ( text , 0 , textLen ) ; \ntextLen = 0 ; \nreturn str ; \n} \nif ( c == '\\\\' ) { \nndx ++ ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase '\\\"' : c = '\\\"' ; \nbreak ; \ncase '\\\\' : c = '\\\\' ; \nbreak ; \ncase '/' : c = '/' ; \nbreak ; \ncase 'b' : c = '\\b' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'u' : ndx ++ ; \nc = parseUnicode ( ) ; \nbreak ; \ndefault : if ( looseMode ) if ( c != '\\'' ) { \nc = '\\\\' ; \nndx -- ; \n} \nelse syntaxError ( \"Invalid escape char: \" + c ) ; \n} \n} \ntext [ textLen ] = c ; \ntextLen ++ ; \ngrowAndCopy ( ) ; \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) ndx ++ ; \nwhile ( true ) { \nif ( isEOF ( ) ) break ; \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \nif ( c <= 32 ) break ; \nif ( c == ',' || c == '}' || c == ']' ) break ; \nif ( c == '.' ) isDouble = true ; \nelse if ( c == 'e' || c == 'E' ) isExp = true ; \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) return Double . valueOf ( value ) ; \nlong longNumber ; \nif ( isExp ) longNumber = Double . valueOf ( value ) . longValue ( ) ; \nelse if ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) return bigInteger ; \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse longNumber = Long . parseLong ( value ) ; \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) return ( int ) longNumber ; \nreturn longNumber ; \n} \n} \n"}
{"1450": "public class JsonParser { \nprotected Object parseArrayContent ( Class targetType , Class componentType ) { \nif ( targetType == Object . class ) targetType = List . class ; \ntargetType = replaceWithMappedTypeForPath ( targetType ) ; \nif ( componentType == null && targetType != null && targetType . isArray ( ) ) componentType = targetType . getComponentType ( ) ; \npath . push ( VALUES ) ; \ncomponentType = replaceWithMappedTypeForPath ( componentType ) ; \nCollection < Object > target = newArrayInstance ( targetType ) ; \nboolean koma = false ; \nmainloop : while ( true ) { \nskipWhiteSpaces ( ) ; \nchar c = input [ ndx ] ; \nif ( c == ']' ) { \nif ( koma ) syntaxError ( \"Trailing comma\" ) ; \nndx ++ ; \npath . pop ( ) ; \nreturn target ; \n} \nObject value = parseValue ( componentType , null , null ) ; \ntarget . add ( value ) ; \nskipWhiteSpaces ( ) ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase ']' : ndx ++ ; \nbreak mainloop ; \ncase ',' : ndx ++ ; \nkoma = true ; \nbreak ; \ndefault : syntaxError ( \"Invalid char: expected ] or ,\" ) ; \n} \n} \npath . pop ( ) ; \nif ( targetType != null ) return convertType ( target , targetType ) ; \nreturn target ; \n} \n} \n"}
{"1452": "public class ProxettaWrapperClassBuilder { \nprotected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { \nint access = msign . getAccessFlags ( ) ; \naccess &= ~ ACC_ABSTRACT ; \naccess &= ~ ACC_NATIVE ; \nMethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; \nmv . visitCode ( ) ; \nmv . visitVarInsn ( ALOAD , 0 ) ; \nmv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; \nloadVirtualMethodArguments ( mv , msign ) ; \nif ( wd . wrapInterface ) mv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; \nelse mv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; \nProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; \nvisitReturn ( mv , msign , true ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \n} \n} \n"}
{"1453": "public class MethodSignatureVisitor { \nprivate String resolveRawTypeName ( String typeName ) { \nif ( typeName == null ) return null ; \nboolean isArray = typeName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ; \nif ( isArray ) typeName = typeName . substring ( 1 ) ; \nString rawTypeName ; \nif ( generics . containsKey ( typeName ) ) rawTypeName = generics . get ( typeName ) ; \nelse rawTypeName = declaredTypeGeneric . getOrDefault ( typeName , typeName ) ; \nif ( isArray ) rawTypeName = '[' + rawTypeName ; \nreturn rawTypeName ; \n} \n} \n"}
{"1454": "public class ReferencesResolver { \npublic BeanReferences resolveReferenceFromValue ( final PropertyDescriptor propertyDescriptor , final String refName ) { \nBeanReferences references ; \nif ( refName == null || refName . isEmpty ( ) ) references = buildDefaultReference ( propertyDescriptor ) ; \nelse references = BeanReferences . of ( refName ) ; \nreferences = references . removeDuplicateNames ( ) ; \nreturn references ; \n} \n} \n"}
{"1455": "public class ReferencesResolver { \npublic BeanReferences [ ] resolveReferenceFromValues ( final Executable methodOrCtor , final String ... parameterReferences ) { \nBeanReferences [ ] references = convertRefToReferences ( parameterReferences ) ; \nif ( references == null || references . length == 0 ) references = buildDefaultReferences ( methodOrCtor ) ; \nif ( methodOrCtor . getParameterTypes ( ) . length != references . length ) throw new PetiteException ( \"Different number of method parameters and references for: \" + methodOrCtor . getDeclaringClass ( ) . getName ( ) + '#' + methodOrCtor . getName ( ) ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1456": "public class ReferencesResolver { \npublic BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { \nPetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; \nfinal Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; \nBeanReferences [ ] references ; \nfinal boolean hasAnnotationOnMethodOrCtor ; \nif ( petiteInject != null ) { \nreferences = convertAnnValueToReferences ( petiteInject . value ( ) ) ; \nhasAnnotationOnMethodOrCtor = true ; \n} \nelse { \nreferences = new BeanReferences [ parameters . length ] ; \nhasAnnotationOnMethodOrCtor = false ; \n} \nint parametersWithAnnotationCount = 0 ; \nfor ( int i = 0 ; \ni < parameters . length ; \ni ++ ) { \nParameter parameter = parameters [ i ] ; \npetiteInject = parameter . getAnnotation ( PetiteInject . class ) ; \nif ( petiteInject == null ) continue ; \nString annotationValue = readAnnotationValue ( petiteInject ) ; \nif ( annotationValue != null ) references [ i ] = BeanReferences . of ( annotationValue ) ; \nparametersWithAnnotationCount ++ ; \n} \nif ( ! hasAnnotationOnMethodOrCtor ) { \nif ( parametersWithAnnotationCount == 0 ) return null ; \nif ( parametersWithAnnotationCount != parameters . length ) throw new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; \n} \nreferences = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1457": "public class ReferencesResolver { \nprivate BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { \nfinal boolean useParamo = petiteConfig . getUseParamo ( ) ; \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nMethodParameter [ ] methodParameters = null ; \nif ( useParamo ) methodParameters = Paramo . resolveParameters ( methodOrCtor ) ; \nfinal Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; \nfinal BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; \nfor ( int j = 0 ; \nj < paramTypes . length ; \nj ++ ) { \nString [ ] ref = new String [ lookupReferences . length ] ; \nreferences [ j ] = BeanReferences . of ( ref ) ; \nfor ( int i = 0 ; \ni < ref . length ; \ni ++ ) switch ( lookupReferences [ i ] ) { \ncase NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; \nbreak ; \ncase TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; \nbreak ; \n} \n} \nreturn references ; \n} \n} \n"}
{"1458": "public class ReferencesResolver { \npublic BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nfinal String [ ] references = new String [ lookupReferences . length ] ; \nfor ( int i = 0 ; \ni < references . length ; \ni ++ ) switch ( lookupReferences [ i ] ) { \ncase NAME : references [ i ] = propertyDescriptor . getName ( ) ; \nbreak ; \ncase TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; \nbreak ; \n} \nreturn BeanReferences . of ( references ) ; \n} \n} \n"}
{"1460": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { \nif ( references == null ) return null ; \nBeanReferences [ ] ref = new BeanReferences [ references . length ] ; \nfor ( int i = 0 ; \ni < references . length ; \ni ++ ) ref [ i ] = BeanReferences . of ( references [ i ] ) ; \nreturn ref ; \n} \n} \n"}
{"1461": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertAnnValueToReferences ( String value ) { \nif ( value == null ) return null ; \nvalue = value . trim ( ) ; \nif ( value . length ( ) == 0 ) return null ; \nString [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; \nBeanReferences [ ] references = new BeanReferences [ refNames . length ] ; \nfor ( int i = 0 ; \ni < refNames . length ; \ni ++ ) references [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; \nreturn references ; \n} \n} \n"}
{"1462": "public class StandaloneJoddJoy { \npublic void runJoy ( final Consumer < JoddJoyRuntime > consumer ) { \nfinal JoddJoy joddJoy = new JoddJoy ( ) ; \nfinal JoddJoyRuntime joyRuntime = joddJoy . startOnlyBackend ( ) ; \njoddJoy . withDb ( joyDb -> setJtxManager ( joyRuntime . getJtxManager ( ) ) ) ; \nfinal JtxTransaction tx = startRwTx ( ) ; \nfinal Print print = new Print ( ) ; \ntry { \nprint . line ( \"START\" , 80 ) ; \nprint . newLine ( ) ; \nconsumer . accept ( joyRuntime ) ; \nprint . newLine ( ) ; \nprint . line ( \"END\" , 80 ) ; \nif ( tx != null ) tx . commit ( ) ; \n} \ncatch ( Throwable throwable ) { \nthrowable . printStackTrace ( ) ; \nif ( tx != null ) tx . rollback ( ) ; \n} \njoddJoy . stop ( ) ; \n} \n} \n"}
{"1464": "public class ClassUtil { \npublic static < T > Constructor < T > findConstructor ( final Class < T > clazz , final Class < ? > ... parameterTypes ) { \nfinal Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; \nClass < ? > [ ] pts ; \nfor ( Constructor < ? > constructor : constructors ) { \npts = constructor . getParameterTypes ( ) ; \nif ( isAllAssignableFrom ( pts , parameterTypes ) ) return ( Constructor < T > ) constructor ; \n} \nreturn null ; \n} \n} \n"}
{"1466": "public class ClassUtil { \npublic static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { \nif ( first . length != second . length ) return false ; \nfor ( int i = 0 ; \ni < first . length ; \ni ++ ) if ( first [ i ] != second [ i ] ) return false ; \nreturn true ; \n} \n} \n"}
{"1467": "public class ClassUtil { \npublic static void forceAccess ( final AccessibleObject accObject ) { \ntry { \nif ( System . getSecurityManager ( ) == null ) accObject . setAccessible ( true ) ; \nelse AccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { \naccObject . setAccessible ( true ) ; \nreturn null ; \n} \n) ; \n} \ncatch ( SecurityException sex ) { \n} \n} \n} \n"}
{"1468": "public class ClassUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > T newInstance ( final Class < T > clazz , final Object ... params ) throws InstantiationException , IllegalAccessException , InvocationTargetException , NoSuchMethodException { \nif ( params . length == 0 ) return newInstance ( clazz ) ; \nfinal Class < ? > [ ] paramTypes = getClasses ( params ) ; \nfinal Constructor < ? > constructor = findConstructor ( clazz , paramTypes ) ; \nif ( constructor == null ) throw new InstantiationException ( \"No constructor matched parameter types.\" ) ; \nreturn ( T ) constructor . newInstance ( params ) ; \n} \n} \n"}
{"1469": "public class ClassUtil { \npublic static Class [ ] getSuperclasses ( final Class type ) { \nint i = 0 ; \nfor ( Class x = type . getSuperclass ( ) ; \nx != null ; \nx = x . getSuperclass ( ) ) i ++ ; \nClass [ ] result = new Class [ i ] ; \ni = 0 ; \nfor ( Class x = type . getSuperclass ( ) ; \nx != null ; \nx = x . getSuperclass ( ) ) { \nresult [ i ] = x ; \ni ++ ; \n} \nreturn result ; \n} \n} \n"}
{"1470": "public class ClassUtil { \npublic static Class < ? > childClassOf ( final Class < ? > parentClass , final Object instance ) { \nif ( instance == null || instance == Object . class ) return null ; \nif ( parentClass != null ) if ( parentClass . isInterface ( ) ) return null ; \nClass < ? > childClass = instance . getClass ( ) ; \nwhile ( true ) { \nClass < ? > parent = childClass . getSuperclass ( ) ; \nif ( parent == parentClass ) return childClass ; \nif ( parent == null ) return null ; \nchildClass = parent ; \n} \n} \n} \n"}
{"1471": "public class ClassUtil { \npublic static JarFile jarFileOf ( final Class < ? > klass ) { \nURL url = klass . getResource ( \"/\" + klass . getName ( ) . replace ( '.' , '/' ) + \".class\" ) ; \nif ( url == null ) return null ; \nString s = url . getFile ( ) ; \nint beginIndex = s . indexOf ( \"file:\" ) + \"file:\" . length ( ) ; \nint endIndex = s . indexOf ( \".jar!\" ) ; \nif ( endIndex == - 1 ) return null ; \nendIndex += \".jar\" . length ( ) ; \nString f = s . substring ( beginIndex , endIndex ) ; \nf = URLDecoder . decode ( f , \"UTF-8\" ) ; \nFile file = new File ( f ) ; \ntry { \nreturn file . exists ( ) ? new JarFile ( file ) : null ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"1476": "public class LazyValue { \n@ Override public T get ( ) { \nif ( ! initialized ) synchronized ( this ) { \nif ( ! initialized ) { \nfinal T t = supplier . get ( ) ; \nvalue = t ; \ninitialized = true ; \nsupplier = null ; \nreturn t ; \n} \n} \nreturn value ; \n} \n} \n"}
{"1477": "public class MethodVisitor { \npublic void visitParameter ( final String name , final int access ) { \nif ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \nif ( mv != null ) mv . visitParameter ( name , access ) ; \n} \n} \n"}
{"1478": "public class MethodVisitor { \npublic AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { \nif ( mv != null ) return mv . visitAnnotation ( descriptor , visible ) ; \nreturn null ; \n} \n} \n"}
{"1479": "public class MethodVisitor { \npublic AnnotationVisitor visitTypeAnnotation ( final int typeRef , final TypePath typePath , final String descriptor , final boolean visible ) { \nif ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \nif ( mv != null ) return mv . visitTypeAnnotation ( typeRef , typePath , descriptor , visible ) ; \nreturn null ; \n} \n} \n"}
{"1480": "public class MethodVisitor { \npublic AnnotationVisitor visitParameterAnnotation ( final int parameter , final String descriptor , final boolean visible ) { \nif ( mv != null ) return mv . visitParameterAnnotation ( parameter , descriptor , visible ) ; \nreturn null ; \n} \n} \n"}
{"1481": "public class MethodVisitor { \npublic void visitFieldInsn ( final int opcode , final String owner , final String name , final String descriptor ) { \nif ( mv != null ) mv . visitFieldInsn ( opcode , owner , name , descriptor ) ; \n} \n} \n"}
{"1482": "public class MethodVisitor { \npublic void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nif ( api < Opcodes . ASM5 ) { \nif ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) throw new IllegalArgumentException ( \"INVOKESPECIAL/STATIC on interfaces requires ASM5\" ) ; \nvisitMethodInsn ( opcode , owner , name , descriptor ) ; \nreturn ; \n} \nif ( mv != null ) mv . visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; \n} \n} \n"}
{"1483": "public class MethodVisitor { \npublic void visitInvokeDynamicInsn ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { \nif ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \nif ( mv != null ) mv . visitInvokeDynamicInsn ( name , descriptor , bootstrapMethodHandle , bootstrapMethodArguments ) ; \n} \n} \n"}
{"1484": "public class MethodVisitor { \npublic void visitJumpInsn ( final int opcode , final Label label ) { \nif ( mv != null ) mv . visitJumpInsn ( opcode , label ) ; \n} \n} \n"}
{"1485": "public class MethodVisitor { \npublic void visitMultiANewArrayInsn ( final String descriptor , final int numDimensions ) { \nif ( mv != null ) mv . visitMultiANewArrayInsn ( descriptor , numDimensions ) ; \n} \n} \n"}
{"1486": "public class MethodVisitor { \npublic void visitTryCatchBlock ( final Label start , final Label end , final Label handler , final String type ) { \nif ( mv != null ) mv . visitTryCatchBlock ( start , end , handler , type ) ; \n} \n} \n"}
{"1487": "public class MethodVisitor { \npublic AnnotationVisitor visitLocalVariableAnnotation ( final int typeRef , final TypePath typePath , final Label [ ] start , final Label [ ] end , final int [ ] index , final String descriptor , final boolean visible ) { \nif ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \nif ( mv != null ) return mv . visitLocalVariableAnnotation ( typeRef , typePath , start , end , index , descriptor , visible ) ; \nreturn null ; \n} \n} \n"}
{"1489": "public class MemoryFileUpload { \n@ Override public void processStream ( ) throws IOException { \nFastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; \nsize = 0 ; \nif ( maxFileSize == - 1 ) size += input . copyAll ( out ) ; \nelse { \nsize += input . copyMax ( out , maxFileSize + 1 ) ; \nif ( size > maxFileSize ) { \nfileTooBig = true ; \nvalid = false ; \ninput . skipToBoundary ( ) ; \nreturn ; \n} \n} \ndata = out . toByteArray ( ) ; \nsize = data . length ; \nvalid = true ; \n} \n} \n"}
{"1490": "public class DbListIterator { \n@ Override public T next ( ) { \nif ( hasNext == null ) hasNext = Boolean . valueOf ( moveToNext ( ) ) ; \nif ( hasNext == false ) throw new NoSuchElementException ( ) ; \nif ( ! entityAwareMode ) { \nhasNext = null ; \nreturn newElement ; \n} \ncount ++ ; \nT result = previousElement ; \npreviousElement = newElement ; \nhasNext = null ; \nreturn result ; \n} \n} \n"}
{"1491": "public class DbListIterator { \nprivate boolean moveToNext ( ) { \nif ( last ) { \nif ( closeOnEnd ) query . close ( ) ; \nelse query . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; \nreturn false ; \n} \nwhile ( true ) { \nif ( ! resultSetMapper . next ( ) ) { \nlast = true ; \nreturn entityAwareMode ; \n} \nObject [ ] objects = resultSetMapper . parseObjects ( types ) ; \nObject row = query . resolveRowResults ( objects ) ; \nnewElement = ( T ) row ; \nif ( entityAwareMode ) { \nif ( count == 0 && previousElement == null ) { \npreviousElement = newElement ; \ncontinue ; \n} \nif ( previousElement != null && newElement != null ) { \nboolean equals ; \nif ( newElement . getClass ( ) . isArray ( ) ) equals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; \nelse equals = previousElement . equals ( newElement ) ; \nif ( equals ) continue ; \n} \n} \nbreak ; \n} \nreturn true ; \n} \n} \n"}
{"1493": "public class ArraysUtil { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static < T > T [ ] join ( Class < T > componentType , T [ ] [ ] arrays ) { \nif ( arrays . length == 1 ) return arrays [ 0 ] ; \nint length = 0 ; \nfor ( T [ ] array : arrays ) { \nlength += array . length ; \n} \nT [ ] result = ( T [ ] ) Array . newInstance ( componentType , length ) ; \nlength = 0 ; \nfor ( T [ ] array : arrays ) { \nSystem . arraycopy ( array , 0 , result , length , array . length ) ; \nlength += array . length ; \n} \nreturn result ; \n} \n} \n"}
{"1497": "public class ArraysUtil { \npublic static int indexOf ( char [ ] array , char value ) { \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) if ( array [ i ] == value ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"1498": "public class ArraysUtil { \npublic static int indexOf ( Object [ ] array , Object value ) { \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) if ( array [ i ] . equals ( value ) ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) handlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \nelse handlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) jsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) maxStackSize = maxBlockStackSize ; \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) outgoingEdge = outgoingEdge . nextEdge ; \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1506": "public class ContextInjectorComponent { \npublic void injectContext ( final Object targetObject ) { \nfinal Class targetType = targetObject . getClass ( ) ; \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopesWithCache ( targetType ) ; \nfinal Targets targets = new Targets ( targetObject , scopeData ) ; \nscopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( targets ) ) ; \nscopeResolver . forScope ( ParamsScope . class , scope -> scope . inject ( targets ) ) ; \nfinal ServletContext servletContext = madvocController . getApplicationContext ( ) ; \nif ( servletContext != null ) scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( servletContext , targets ) ) ; \n} \n} \n"}
{"1508": "public class PseudoClassSelector { \npublic static PseudoClass lookupPseudoClass ( final String pseudoClassName ) { \nPseudoClass pseudoClass = PSEUDO_CLASS_MAP . get ( pseudoClassName ) ; \nif ( pseudoClass == null ) throw new CSSellyException ( \"Unsupported pseudo class: \" + pseudoClassName ) ; \nreturn pseudoClass ; \n} \n} \n"}
{"1509": "public class AsyncActionExecutor { \npublic void invoke ( final ActionRequest actionRequest ) { \nif ( executorService == null ) throw new MadvocException ( \"No action is marked as async!\" ) ; \nfinal HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; \nlog . debug ( ( ) -> \"Async call to: \" + actionRequest ) ; \nfinal AsyncContext asyncContext = servletRequest . startAsync ( ) ; \nexecutorService . submit ( ( ) -> { \ntry { \nactionRequest . invoke ( ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Invoking async action path failed: \" , ExceptionUtil . unwrapThrowable ( ex ) ) ; \n} \nfinally { \nasyncContext . complete ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"1510": "public class BeanVisitor { \nprotected String [ ] getAllBeanPropertyNames ( final Class type , final boolean declared ) { \nClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; \nPropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; \nArrayList < String > names = new ArrayList < > ( propertyDescriptors . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { \nMethodDescriptor getter = propertyDescriptor . getReadMethodDescriptor ( ) ; \nif ( getter != null ) if ( getter . matchDeclared ( declared ) ) names . add ( propertyDescriptor . getName ( ) ) ; \nelse if ( includeFields ) { \nFieldDescriptor field = propertyDescriptor . getFieldDescriptor ( ) ; \nif ( field != null ) if ( field . matchDeclared ( declared ) ) names . add ( field . getName ( ) ) ; \n} \n} \nreturn names . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1511": "public class BeanVisitor { \npublic void visit ( ) { \nString [ ] properties = resolveProperties ( source , declared ) ; \nfor ( String name : properties ) { \nif ( name == null ) continue ; \nif ( ! rules . match ( name , blacklist ) ) continue ; \nObject value ; \nString propertyName = name ; \nif ( isSourceMap ) propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; \nif ( declared ) value = BeanUtil . declared . getProperty ( source , propertyName ) ; \nelse value = BeanUtil . pojo . getProperty ( source , propertyName ) ; \nif ( value == null && ignoreNullValues ) continue ; \nif ( value instanceof String && StringUtil . isEmpty ( ( String ) value ) ) continue ; \nvisitProperty ( name , value ) ; \n} \n} \n} \n"}
{"1513": "public class MethodResolver { \npublic MethodInjectionPoint [ ] resolve ( final Class type ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nList < MethodInjectionPoint > list = new ArrayList < > ( ) ; \nMethodDescriptor [ ] allMethods = cd . getAllMethodDescriptors ( ) ; \nfor ( MethodDescriptor methodDescriptor : allMethods ) { \nMethod method = methodDescriptor . getMethod ( ) ; \nif ( ClassUtil . isBeanPropertySetter ( method ) ) continue ; \nif ( method . getParameterTypes ( ) . length == 0 ) continue ; \nBeanReferences [ ] references = referencesResolver . readAllReferencesFromAnnotation ( method ) ; \nif ( references != null ) { \nMethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint ( method , references ) ; \nlist . add ( methodInjectionPoint ) ; \n} \n} \nfinal MethodInjectionPoint [ ] methodInjectionPoints ; \nif ( list . isEmpty ( ) ) methodInjectionPoints = MethodInjectionPoint . EMPTY ; \nelse methodInjectionPoints = list . toArray ( new MethodInjectionPoint [ 0 ] ) ; \nreturn methodInjectionPoints ; \n} \n} \n"}
{"1514": "public class HtmlStaplerFilter { \nprotected void readFilterConfigParameters ( final FilterConfig filterConfig , final Object target , final String ... parameters ) { \nfor ( String parameter : parameters ) { \nString value = filterConfig . getInitParameter ( parameter ) ; \nif ( value != null ) BeanUtil . declared . setProperty ( target , parameter , value ) ; \n} \n} \n} \n"}
{"1516": "public class HtmlStaplerBundlesManager { \npublic File lookupBundleFile ( String bundleId ) { \nif ( ( mirrors != null ) && ( ! mirrors . isEmpty ( ) ) ) { \nString realBundleId = mirrors . remove ( bundleId ) ; \nif ( realBundleId != null ) bundleId = realBundleId ; \n} \nreturn createBundleFile ( bundleId ) ; \n} \n} \n"}
{"1517": "public class HtmlStaplerBundlesManager { \npublic File lookupGzipBundleFile ( final File file ) throws IOException { \nString path = file . getPath ( ) + ZipUtil . GZIP_EXT ; \nFile gzipFile = new File ( path ) ; \nif ( ! gzipFile . exists ( ) ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"gzip bundle to \" + path ) ; \nZipUtil . gzip ( file ) ; \n} \nreturn gzipFile ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null || sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) actionBundles . put ( actionPath , StringPool . EMPTY ) ; \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \nfor ( int i = 0 , sourcesArrayLength = sourcesArray . length ; \ni < sourcesArrayLength ; \ni ++ ) sourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \nif ( sortResources ) Arrays . sort ( sourcesArray ) ; \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId += '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1519": "public class HtmlStaplerBundlesManager { \nprotected String createDigest ( final String source ) { \nfinal DigestEngine digestEngine = DigestEngine . sha256 ( ) ; \nfinal byte [ ] bytes = digestEngine . digest ( CharUtil . toSimpleByteArray ( source ) ) ; \nString digest = Base32 . encode ( bytes ) ; \nif ( uniqueDigestKey != null ) digest += uniqueDigestKey ; \nreturn digest ; \n} \n} \n"}
{"1520": "public class HtmlStaplerBundlesManager { \nprotected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { \nfinal File bundleFile = createBundleFile ( bundleId ) ; \nif ( bundleFile . exists ( ) ) return ; \nStringBand sb = new StringBand ( sources . size ( ) * 2 ) ; \nfor ( String src : sources ) { \nif ( sb . length ( ) != 0 ) sb . append ( StringPool . NEWLINE ) ; \nString content ; \nif ( isExternalResource ( src ) ) content = downloadString ( src ) ; \nelse { \nif ( ! downloadLocal ) { \nString localFile = webRoot ; \nif ( src . startsWith ( contextPath + '/' ) ) src = src . substring ( contextPath . length ( ) ) ; \nif ( src . startsWith ( StringPool . SLASH ) ) localFile += src ; \nelse localFile += '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; \nint qmndx = localFile . indexOf ( '?' ) ; \nif ( qmndx != - 1 ) localFile = localFile . substring ( 0 , qmndx ) ; \ntry { \ncontent = FileUtil . readString ( localFile ) ; \n} \ncatch ( IOException ioex ) { \nif ( notFoundExceptionEnabled ) throw ioex ; \nif ( log . isWarnEnabled ( ) ) log . warn ( ioex . getMessage ( ) ) ; \ncontent = null ; \n} \n} \nelse { \nString localUrl = localAddressAndPort ; \nif ( src . startsWith ( StringPool . SLASH ) ) localUrl += contextPath + src ; \nelse localUrl += contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; \ncontent = downloadString ( localUrl ) ; \n} \nif ( content != null ) if ( isCssResource ( src ) ) content = fixCssRelativeUrls ( content , src ) ; \n} \nif ( content != null ) { \ncontent = onResourceContent ( content ) ; \nsb . append ( content ) ; \n} \n} \nFileUtil . writeString ( bundleFile , sb . toString ( ) ) ; \nif ( log . isInfoEnabled ( ) ) log . info ( \"Bundle created: \" + bundleId ) ; \n} \n} \n"}
{"1521": "public class HtmlStaplerBundlesManager { \npublic synchronized void reset ( ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . clear ( ) ; \nmirrors . clear ( ) ; \n} \nfinal FindFile ff = new FindFile ( ) ; \nff . includeDirs ( false ) ; \nff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; \nFile f ; \nint count = 0 ; \nwhile ( ( f = ff . nextFile ( ) ) != null ) { \nf . delete ( ) ; \ncount ++ ; \n} \nif ( log . isInfoEnabled ( ) ) log . info ( \"reset: \" + count + \" bundle files deleted.\" ) ; \n} \n} \n"}
{"1522": "public class HtmlStaplerBundlesManager { \nprotected String fixCssRelativeUrls ( final String content , final String src ) { \nfinal String path = FileNameUtil . getPath ( src ) ; \nfinal Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; \nfinal StringBuilder sb = new StringBuilder ( content . length ( ) ) ; \nint start = 0 ; \nwhile ( matcher . find ( ) ) { \nsb . append ( content , start , matcher . start ( ) ) ; \nfinal String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , \"'\\\"\" ) ; \nfinal String url ; \nif ( matchedUrl . startsWith ( \"https://\" ) || matchedUrl . startsWith ( \"http://\" ) || matchedUrl . startsWith ( \"data:\" ) ) url = \"url('\" + matchedUrl + \"')\" ; \nelse url = fixRelativeUrl ( matchedUrl , path ) ; \nsb . append ( url ) ; \nstart = matcher . end ( ) ; \n} \nsb . append ( content . substring ( start ) ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1525": "public class DbJtxSessionProvider { \n@ Override public DbSession getDbSession ( ) { \nlog . debug ( \"Requesting db TX manager session\" ) ; \nfinal DbJtxTransaction jtx = ( DbJtxTransaction ) jtxTxManager . getTransaction ( ) ; \nif ( jtx == null ) throw new DbSqlException ( \"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\" ) ; \nreturn jtx . requestResource ( ) ; \n} \n} \n"}
{"1527": "public class GenericsReader { \npublic Map < String , String > parseSignatureForGenerics ( final String signature , final boolean isInterface ) { \nif ( signature == null ) return Collections . emptyMap ( ) ; \nfinal Map < String , String > genericsMap = new HashMap < > ( ) ; \nSignatureReader sr = new SignatureReader ( signature ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nTraceSignatureVisitor v = new TraceSignatureVisitor ( sb , isInterface ) { \nString genericName ; \n@ Override public void visitFormalTypeParameter ( final String name ) { \ngenericName = name ; \nsuper . visitFormalTypeParameter ( name ) ; \n} \n@ Override public void visitClassType ( final String name ) { \nif ( genericName != null ) { \ngenericsMap . put ( genericName , 'L' + name + ';' ) ; \ngenericName = null ; \n} \nsuper . visitClassType ( name ) ; \n} \n} \n; \nsr . accept ( v ) ; \nreturn genericsMap ; \n} \n} \n"}
{"1528": "public class SetResolver { \npublic SetInjectionPoint [ ] resolve ( final Class type , final boolean autowire ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nList < SetInjectionPoint > list = new ArrayList < > ( ) ; \nPropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nif ( propertyDescriptor . isGetterOnly ( ) ) continue ; \nClass propertyType = propertyDescriptor . getType ( ) ; \nif ( ! ClassUtil . isTypeOf ( propertyType , Collection . class ) ) continue ; \nMethodDescriptor writeMethodDescriptor = propertyDescriptor . getWriteMethodDescriptor ( ) ; \nFieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; \nPetiteInject ref = null ; \nif ( writeMethodDescriptor != null ) ref = writeMethodDescriptor . getMethod ( ) . getAnnotation ( PetiteInject . class ) ; \nif ( ref == null && fieldDescriptor != null ) ref = fieldDescriptor . getField ( ) . getAnnotation ( PetiteInject . class ) ; \nif ( ( ! autowire ) && ( ref == null ) ) continue ; \nlist . add ( new SetInjectionPoint ( propertyDescriptor ) ) ; \n} \nSetInjectionPoint [ ] fields ; \nif ( list . isEmpty ( ) ) fields = SetInjectionPoint . EMPTY ; \nelse fields = list . toArray ( new SetInjectionPoint [ 0 ] ) ; \nreturn fields ; \n} \n} \n"}
{"1529": "public class JsonContext { \npublic boolean matchIgnoredPropertyTypes ( final Class propertyType , final boolean excludeMaps , final boolean include ) { \nif ( ! include ) return false ; \nif ( propertyType != null ) { \nif ( ! jsonSerializer . deep ) { \nClassDescriptor propertyTypeClassDescriptor = ClassIntrospector . get ( ) . lookup ( propertyType ) ; \nif ( propertyTypeClassDescriptor . isArray ( ) ) return false ; \nif ( propertyTypeClassDescriptor . isCollection ( ) ) return false ; \nif ( excludeMaps ) if ( propertyTypeClassDescriptor . isMap ( ) ) return false ; \n} \nif ( jsonSerializer . excludedTypes != null ) for ( Class excludedType : jsonSerializer . excludedTypes ) { \nif ( ClassUtil . isTypeOf ( propertyType , excludedType ) ) return false ; \n} \nfinal String propertyTypeName = propertyType . getName ( ) ; \nif ( jsonSerializer . excludedTypeNames != null ) for ( String excludedTypeName : jsonSerializer . excludedTypeNames ) { \nif ( Wildcard . match ( propertyTypeName , excludedTypeName ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1531": "public class DbSession { \nprotected void openTx ( ) { \nif ( connection == null ) connection = connectionProvider . getConnection ( ) ; \ntxActive = true ; \ntry { \nconnection . setAutoCommit ( false ) ; \nif ( txMode . getIsolation ( ) != DbTransactionMode . ISOLATION_DEFAULT ) connection . setTransactionIsolation ( txMode . getIsolation ( ) ) ; \nconnection . setReadOnly ( txMode . isReadOnly ( ) ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( \"Open TX failed\" , sex ) ; \n} \n} \n} \n"}
{"1538": "public class PropertiesUtil { \npublic static Properties subset ( final Properties p , String prefix , final boolean stripPrefix ) { \nif ( StringUtil . isBlank ( prefix ) ) return p ; \nif ( ! prefix . endsWith ( StringPool . DOT ) ) prefix += '.' ; \nProperties result = new Properties ( ) ; \nint baseLen = prefix . length ( ) ; \nfor ( Object o : p . keySet ( ) ) { \nString key = ( String ) o ; \nif ( key . startsWith ( prefix ) ) result . setProperty ( stripPrefix ? key . substring ( baseLen ) : key , p . getProperty ( key ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"1542": "public class PropertiesUtil { \npublic static String resolveProperty ( final Map map , final String key ) { \nString value = getProperty ( map , key ) ; \nif ( value == null ) return null ; \nvalue = stp . parse ( value , macroName -> getProperty ( map , macroName ) ) ; \nreturn value ; \n} \n} \n"}
{"1543": "public class AnnotationTxAdviceManager { \npublic String resolveScope ( final Class type , final String methodName ) { \nif ( scopePattern == null ) return null ; \nString ctx = scopePattern ; \nctx = StringUtil . replace ( ctx , JTXCTX_PATTERN_CLASS , type . getName ( ) ) ; \nctx = StringUtil . replace ( ctx , JTXCTX_PATTERN_METHOD , methodName ) ; \nreturn ctx ; \n} \n} \n"}
{"1544": "public class AnnotationTxAdviceManager { \npublic synchronized JtxTransactionMode getTxMode ( final Class type , final String methodName , final Class [ ] methodArgTypes , final String unique ) { \nString signature = type . getName ( ) + '#' + methodName + '%' + unique ; \nJtxTransactionMode txMode = txmap . get ( signature ) ; \nif ( txMode == null ) if ( ! txmap . containsKey ( signature ) ) { \nfinal Method m ; \ntry { \nm = type . getMethod ( methodName , methodArgTypes ) ; \n} \ncatch ( NoSuchMethodException nsmex ) { \nthrow new ProxettaException ( nsmex ) ; \n} \nfinal TransactionAnnotationValues txAnn = readTransactionAnnotation ( m ) ; \nif ( txAnn != null ) txMode = new JtxTransactionMode ( txAnn . propagation ( ) , txAnn . isolation ( ) , txAnn . readOnly ( ) , txAnn . timeout ( ) ) ; \nelse txMode = defaultTransactionMode ; \ntxmap . put ( signature , txMode ) ; \n} \nreturn txMode ; \n} \n} \n"}
{"1545": "public class AnnotationTxAdviceManager { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { \nthis . annotations = annotations ; \nthis . annotationParsers = new AnnotationParser [ annotations . length ] ; \nfor ( int i = 0 ; \ni < annotations . length ; \ni ++ ) annotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; \n} \n} \n"}
{"1546": "public class AnnotationTxAdviceManager { \nprotected TransactionAnnotationValues readTransactionAnnotation ( final Method method ) { \nfor ( AnnotationParser annotationParser : annotationParsers ) { \nTransactionAnnotationValues tad = TransactionAnnotationValues . of ( annotationParser , method ) ; \nif ( tad != null ) return tad ; \n} \nreturn null ; \n} \n} \n"}
{"1547": "public class CssSelector { \n@ Override public boolean accept ( final Node node ) { \nif ( ! matchElement ( node ) ) return false ; \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ni < totalSelectors ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) return false ; \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) return false ; \nbreak ; \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) return false ; \nbreak ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1548": "public class CssSelector { \nprotected boolean matchElement ( final Node node ) { \nif ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) return false ; \nString element = getElement ( ) ; \nString nodeName = node . getNodeName ( ) ; \nreturn element . equals ( StringPool . STAR ) || element . equals ( nodeName ) ; \n} \n} \n"}
{"1549": "public class CssSelector { \npublic boolean accept ( final List < Node > currentResults , final Node node , final int index ) { \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ni < totalSelectors ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) return false ; \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) return false ; \nbreak ; \ndefault : } \n} \nreturn true ; \n} \n} \n"}
{"1550": "public class CssSelector { \nprotected String unescape ( final String value ) { \nif ( value . indexOf ( '\\\\' ) == - 1 ) return value ; \nreturn StringUtil . remove ( value , '\\\\' ) ; \n} \n} \n"}
{"1553": "public class Node { \npublic void detachFromParent ( ) { \nif ( parentNode == null ) return ; \nif ( parentNode . childNodes != null ) { \nparentNode . childNodes . remove ( siblingIndex ) ; \nparentNode . reindexChildren ( ) ; \n} \nparentNode = null ; \n} \n} \n"}
{"1554": "public class Node { \npublic void addChild ( final Node ... nodes ) { \nif ( nodes . length == 0 ) return ; \nfor ( Node node : nodes ) { \nnode . detachFromParent ( ) ; \nnode . parentNode = this ; \ninitChildNodes ( node ) ; \nchildNodes . add ( node ) ; \n} \nreindexChildrenOnAdd ( nodes . length ) ; \n} \n} \n"}
{"1557": "public class Node { \npublic void insertBefore ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) return ; \nint siblingIndex = refChild . getSiblingIndex ( ) ; \nrefChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \n} \n} \n"}
{"1558": "public class Node { \npublic void insertAfter ( final Node newChild , final Node refChild ) { \nint siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) refChild . parentNode . addChild ( newChild ) ; \nelse refChild . parentNode . insertChild ( newChild , siblingIndex ) ; \n} \n} \n"}
{"1559": "public class Node { \npublic void insertAfter ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) return ; \nint siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) refChild . parentNode . addChild ( newChilds ) ; \nelse refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \n} \n} \n"}
{"1560": "public class Node { \npublic void removeAllChilds ( ) { \nList < Node > removedNodes = childNodes ; \nchildNodes = null ; \nchildElementNodes = null ; \nchildElementNodesCount = 0 ; \nif ( removedNodes != null ) for ( int i = 0 , removedNodesSize = removedNodes . size ( ) ; \ni < removedNodesSize ; \ni ++ ) { \nNode removedNode = removedNodes . get ( i ) ; \nremovedNode . detachFromParent ( ) ; \n} \n} \n} \n"}
{"1561": "public class Node { \npublic Node findChildNodeWithName ( final String name ) { \nif ( childNodes == null ) return null ; \nfor ( final Node childNode : childNodes ) { \nif ( childNode . getNodeName ( ) . equals ( name ) ) return childNode ; \n} \nreturn null ; \n} \n} \n"}
{"1562": "public class Node { \npublic Node [ ] filterChildNodes ( final Predicate < Node > nodePredicate ) { \nif ( childNodes == null ) return new Node [ 0 ] ; \nreturn childNodes . stream ( ) . filter ( nodePredicate ) . toArray ( Node [ ] :: new ) ; \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) return true ; \nint siblingElementIndex = 0 ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) return false ; \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) return false ; \nsiblingElementIndex ++ ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) return false ; \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) return false ; \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) if ( childElementNodes [ child . siblingElementIndex ] != child ) return false ; \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) if ( sibling . siblingNameIndex != index ++ ) return false ; \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1564": "public class Node { \nprotected void initChildElementNodes ( ) { \nif ( childElementNodes == null ) { \nchildElementNodes = new Element [ childElementNodesCount ] ; \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) childElementNodes [ child . siblingElementIndex ] = ( Element ) child ; \n} \n} \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) sibling . siblingNameIndex = index ++ ; \n} \n} \n} \n} \n"}
{"1566": "public class Node { \nprotected void initChildNodes ( final Node newNode ) { \nif ( childNodes == null ) childNodes = new ArrayList < > ( ) ; \nif ( ownerDocument != null ) if ( newNode . ownerDocument != ownerDocument ) changeOwnerDocument ( newNode , ownerDocument ) ; \n} \n} \n"}
{"1568": "public class Node { \npublic Node getPreviousSiblingName ( ) { \nif ( nodeName == null ) return null ; \ninitSiblingNames ( ) ; \nint index = siblingNameIndex - 1 ; \nfor ( int i = siblingIndex ; \ni >= 0 ; \ni -- ) { \nNode sibling = parentNode . childNodes . get ( i ) ; \nif ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) return sibling ; \n} \nreturn null ; \n} \n} \n"}
{"1570": "public class Node { \npublic String getHtml ( ) { \nLagartoDomBuilderConfig lagartoDomBuilderConfig ; \nif ( ownerDocument == null ) lagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; \nelse lagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; \nLagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; \nreturn lagartoHtmlRenderer . toHtml ( this , new StringBuilder ( ) ) ; \n} \n} \n"}
{"1571": "public class Node { \npublic String getInnerHtml ( ) { \nLagartoDomBuilderConfig lagartoDomBuilderConfig ; \nif ( ownerDocument == null ) lagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; \nelse lagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; \nLagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; \nreturn lagartoHtmlRenderer . toInnerHtml ( this , new StringBuilder ( ) ) ; \n} \n} \n"}
{"1572": "public class Node { \nprotected void visitChildren ( final NodeVisitor nodeVisitor ) { \nif ( childNodes != null ) for ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nchildNode . visit ( nodeVisitor ) ; \n} \n} \n} \n"}
{"1573": "public class Node { \npublic String getCssPath ( ) { \nStringBuilder path = new StringBuilder ( ) ; \nNode node = this ; \nwhile ( node != null ) { \nString nodeName = node . getNodeName ( ) ; \nif ( nodeName != null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( ' ' ) . append ( nodeName ) ; \nString id = node . getAttribute ( \"id\" ) ; \nif ( id != null ) sb . append ( '#' ) . append ( id ) ; \npath . insert ( 0 , sb ) ; \n} \nnode = node . getParentNode ( ) ; \n} \nif ( path . charAt ( 0 ) == ' ' ) return path . substring ( 1 ) ; \nreturn path . toString ( ) ; \n} \n} \n"}
{"1578": "public class RootPackages { \npublic void addRootPackage ( final String rootPackage , String mapping ) { \nif ( packages == null ) packages = new String [ 0 ] ; \nif ( mappings == null ) mappings = new String [ 0 ] ; \nif ( mapping . length ( ) > 0 ) { \nif ( ! mapping . startsWith ( StringPool . SLASH ) ) mapping = StringPool . SLASH + mapping ; \nif ( mapping . endsWith ( StringPool . SLASH ) ) mapping = StringUtil . substring ( mapping , 0 , - 1 ) ; \n} \nfor ( int i = 0 ; \ni < packages . length ; \ni ++ ) if ( packages [ i ] . equals ( rootPackage ) ) { \nif ( mappings [ i ] . equals ( mapping ) ) return ; \nthrow new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; \n} \npackages = ArraysUtil . append ( packages , rootPackage ) ; \nmappings = ArraysUtil . append ( mappings , mapping ) ; \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) return null ; \nint ndx = - 1 ; \nint delta = Integer . MAX_VALUE ; \nfor ( int i = 0 ; \ni < mappings . length ; \ni ++ ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( actionPath . equals ( mapping ) ) found = true ; \nelse { \nmapping += StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) found = true ; \n} \nif ( found ) { \nint distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( distance < delta ) { \nndx = i ; \ndelta = distance ; \n} \n} \n} \nif ( ndx == - 1 ) return null ; \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1581": "public class VtorUtil { \npublic static String resolveValidationMessage ( final HttpServletRequest request , final Violation violation ) { \nValidationConstraint vc = violation . getConstraint ( ) ; \nString key = vc != null ? vc . getClass ( ) . getName ( ) : violation . getName ( ) ; \nString msg = LocalizationUtil . findMessage ( request , key ) ; \nif ( msg != null ) return beanTemplateParser . parseWithBean ( msg , violation ) ; \nreturn null ; \n} \n} \n"}
{"1582": "public class BeanReferences { \npublic BeanReferences removeDuplicateNames ( ) { \nif ( names . length < 2 ) return this ; \nint nullCount = 0 ; \nfor ( int i = 1 ; \ni < names . length ; \ni ++ ) { \nString thisRef = names [ i ] ; \nif ( thisRef == null ) { \nnullCount ++ ; \ncontinue ; \n} \nfor ( int j = 0 ; \nj < i ; \nj ++ ) { \nif ( names [ j ] == null ) continue ; \nif ( thisRef . equals ( names [ j ] ) ) { \nnames [ i ] = null ; \nbreak ; \n} \n} \n} \nif ( nullCount == 0 ) return this ; \nString [ ] newRefs = new String [ names . length - nullCount ] ; \nint ndx = 0 ; \nfor ( String name : names ) { \nif ( name == null ) continue ; \nnewRefs [ ndx ] = name ; \nndx ++ ; \n} \nreturn new BeanReferences ( newRefs ) ; \n} \n} \n"}
{"1585": "public class Targets { \npublic void forEachTargetAndIn ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { \nfor ( final Target target : targets ) { \nfinal ScopeData scopeData = target . scopeData ( ) ; \nif ( scopeData . in ( ) == null ) continue ; \nfor ( final InjectionPoint in : scopeData . in ( ) ) { \nif ( in . scope ( ) != scope ) continue ; \nbiConsumer . accept ( target , in ) ; \n} \n} \n} \n} \n"}
{"1586": "public class Targets { \npublic void forEachTargetAndOut ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { \nfor ( final Target target : targets ) { \nfinal ScopeData scopeData = target . scopeData ( ) ; \nif ( scopeData . out ( ) == null ) continue ; \nfor ( final InjectionPoint out : scopeData . out ( ) ) { \nif ( out . scope ( ) != scope ) continue ; \nbiConsumer . accept ( target , out ) ; \n} \n} \n} \n} \n"}
{"1587": "public class Targets { \npublic Object [ ] extractParametersValues ( ) { \nfinal Object [ ] values = new Object [ targets . length - 1 ] ; \nfor ( int i = 1 ; \ni < targets . length ; \ni ++ ) values [ i - 1 ] = targets [ i ] . value ( ) ; \nreturn values ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) return new Target [ ] { \nactionTarget } \n; \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \nfor ( int i = 0 ; \ni < methodParams . length ; \ni ++ ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( methodParam . annotationType ( ) == null ) { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \nelse if ( methodParam . annotationType ( ) == Out . class ) paramTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \nelse paramTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \ntarget [ i + 1 ] = paramTarget ; \n} \nreturn target ; \n} \n} \n"}
{"1589": "public class Targets { \n@ SuppressWarnings ( { \n\"unchecked\" , \"NullArgumentToVariableArgMethod\" } \n) protected Object createActionMethodArgument ( final Class type , final Object action ) { \ntry { \nif ( type . getEnclosingClass ( ) == null || Modifier . isStatic ( type . getModifiers ( ) ) ) return ClassUtil . newInstance ( type ) ; \nelse { \nConstructor ctor = type . getDeclaredConstructor ( type . getDeclaringClass ( ) ) ; \nctor . setAccessible ( true ) ; \nreturn ctor . newInstance ( action ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow new MadvocException ( ex ) ; \n} \n} \n} \n"}
{"1594": "public class JsonArray { \npublic Object remove ( final int pos ) { \nObject removed = list . remove ( pos ) ; \nif ( removed instanceof Map ) return new JsonObject ( ( Map ) removed ) ; \nif ( removed instanceof ArrayList ) return new JsonArray ( ( List ) removed ) ; \nreturn removed ; \n} \n} \n"}
{"1595": "public class AbstractTemplateViewActionResult { \nprotected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { \nString resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; \nResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; \nString actionPath = resultPath . path ( ) ; \nString path = actionPath ; \nString value = resultPath . value ( ) ; \nif ( StringUtil . isEmpty ( value ) ) value = null ; \nString target ; \nwhile ( true ) { \nif ( value != null ) { \nif ( path == null ) { \nint lastSlashNdx = actionPath . lastIndexOf ( '/' ) ; \nif ( lastSlashNdx != - 1 ) target = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; \nelse target = '/' + value ; \n} \nelse target = path + '.' + value ; \ntarget = locateTarget ( actionRequest , target ) ; \nif ( target != null ) break ; \n} \nif ( path != null ) { \ntarget = locateTarget ( actionRequest , path ) ; \nif ( target != null ) break ; \n} \nif ( path == null ) return null ; \nint dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; \nif ( dotNdx == - 1 ) path = null ; \nelse path = path . substring ( 0 , dotNdx ) ; \n} \nreturn target ; \n} \n} \n"}
{"1596": "public class AbstractTemplateViewActionResult { \nprotected void targetNotFound ( final ActionRequest actionRequest , final String actionAndResultPath ) throws IOException { \nfinal HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; \nif ( ! response . isCommitted ( ) ) response . sendError ( SC_NOT_FOUND , \"Result not found: \" + actionAndResultPath ) ; \n} \n} \n"}
{"1597": "public class FormProcessorVisitor { \nprotected String valueToString ( final String name , final Object valueObject ) { \nif ( ! valueObject . getClass ( ) . isArray ( ) ) return valueObject . toString ( ) ; \nString [ ] array = ( String [ ] ) valueObject ; \nif ( valueNameIndexes == null ) valueNameIndexes = new HashMap < > ( ) ; \nMutableInteger index = valueNameIndexes . get ( name ) ; \nif ( index == null ) { \nindex = new MutableInteger ( 0 ) ; \nvalueNameIndexes . put ( name , index ) ; \n} \nif ( index . value >= array . length ) return null ; \nString result = array [ index . value ] ; \nindex . value ++ ; \nreturn result ; \n} \n} \n"}
{"1600": "public class PropertyResolver { \npublic PropertyInjectionPoint [ ] resolve ( Class type , final boolean autowire ) { \nfinal List < PropertyInjectionPoint > list = new ArrayList < > ( ) ; \nfinal Set < String > usedPropertyNames = new HashSet < > ( ) ; \nwhile ( type != Object . class ) { \nfinal ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nfinal PropertyDescriptor [ ] allPropertyDescriptors = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allPropertyDescriptors ) { \nif ( propertyDescriptor . isGetterOnly ( ) ) continue ; \nif ( usedPropertyNames . contains ( propertyDescriptor . getName ( ) ) ) continue ; \nClass propertyType = propertyDescriptor . getType ( ) ; \nif ( ClassUtil . isTypeOf ( propertyType , Collection . class ) ) continue ; \nBeanReferences reference = referencesResolver . readReferenceFromAnnotation ( propertyDescriptor ) ; \nif ( reference == null ) if ( ! autowire ) continue ; \nelse reference = referencesResolver . buildDefaultReference ( propertyDescriptor ) ; \nlist . add ( new PropertyInjectionPoint ( propertyDescriptor , reference ) ) ; \nusedPropertyNames . add ( propertyDescriptor . getName ( ) ) ; \n} \ntype = type . getSuperclass ( ) ; \n} \nfinal PropertyInjectionPoint [ ] fields ; \nif ( list . isEmpty ( ) ) fields = PropertyInjectionPoint . EMPTY ; \nelse fields = list . toArray ( new PropertyInjectionPoint [ 0 ] ) ; \nreturn fields ; \n} \n} \n"}
{"1601": "public class Socks4ProxySocketFactory { \nprivate Socket createSocks4ProxySocket ( final String host , final int port ) { \nSocket socket = null ; \nfinal String proxyHost = proxy . getProxyAddress ( ) ; \nfinal int proxyPort = proxy . getProxyPort ( ) ; \nfinal String user = proxy . getProxyUsername ( ) ; \ntry { \nsocket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; \nfinal InputStream in = socket . getInputStream ( ) ; \nfinal OutputStream out = socket . getOutputStream ( ) ; \nsocket . setTcpNoDelay ( true ) ; \nbyte [ ] buf = new byte [ 1024 ] ; \nint index = 0 ; \nbuf [ index ++ ] = 4 ; \nbuf [ index ++ ] = 1 ; \nbuf [ index ++ ] = ( byte ) ( port >>> 8 ) ; \nbuf [ index ++ ] = ( byte ) ( port & 0xff ) ; \nInetAddress addr = InetAddress . getByName ( host ) ; \nbyte [ ] byteAddress = addr . getAddress ( ) ; \nfor ( byte byteAddres : byteAddress ) { \nbuf [ index ++ ] = byteAddres ; \n} \nif ( user != null ) { \nSystem . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; \nindex += user . length ( ) ; \n} \nbuf [ index ++ ] = 0 ; \nout . write ( buf , 0 , index ) ; \nint len = 6 ; \nint s = 0 ; \nwhile ( s < len ) { \nint i = in . read ( buf , s , len - s ) ; \nif ( i <= 0 ) throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; \ns += i ; \n} \nif ( buf [ 0 ] != 0 ) throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; \nif ( buf [ 1 ] != 90 ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; \n} \nbyte [ ] temp = new byte [ 2 ] ; \nin . read ( temp , 0 , 2 ) ; \nreturn socket ; \n} \ncatch ( RuntimeException rtex ) { \ncloseSocket ( socket ) ; \nthrow rtex ; \n} \ncatch ( Exception ex ) { \ncloseSocket ( socket ) ; \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1604": "public class CharSequenceUtil { \npublic static boolean equalsOne ( final char c , final CharSequence match ) { \nfor ( int i = 0 ; \ni < match . length ( ) ; \ni ++ ) { \nchar aMatch = match . charAt ( i ) ; \nif ( c == aMatch ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"1605": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { \nfor ( int i = index ; \ni < source . length ( ) ; \ni ++ ) if ( equalsOne ( source . charAt ( i ) , match ) ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"1606": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final char [ ] source , final int index , final char match ) { \nfor ( int i = index ; \ni < source . length ; \ni ++ ) if ( source [ i ] == match ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"1607": "public class CommandLine { \npublic CommandLine args ( final String ... arguments ) { \nif ( arguments != null && arguments . length > 0 ) Collections . addAll ( cmdLine , arguments ) ; \nreturn this ; \n} \n} \n"}
{"1608": "public class CommandLine { \npublic CommandLine env ( final String key , final String value ) { \nif ( env == null ) env = new HashMap < > ( ) ; \nenv . put ( key , value ) ; \nreturn this ; \n} \n} \n"}
{"1609": "public class CommandLine { \npublic ProcessRunner . ProcessResult run ( ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nout = err = baos ; \ntry { \nbaos . write ( StringUtil . join ( cmdLine , ' ' ) . getBytes ( ) ) ; \nbaos . write ( StringPool . BYTES_NEW_LINE ) ; \n} \ncatch ( IOException ignore ) { \n} \nProcessBuilder processBuilder = new ProcessBuilder ( ) ; \nprocessBuilder . command ( cmdLine ) ; \nif ( cleanEnvironment ) processBuilder . environment ( ) . clear ( ) ; \nif ( env != null ) processBuilder . environment ( ) . putAll ( env ) ; \nprocessBuilder . directory ( workingDirectory ) ; \nProcess process = null ; \ntry { \nprocess = processBuilder . start ( ) ; \n} \ncatch ( IOException ioex ) { \nreturn writeException ( baos , ioex ) ; \n} \nStreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , out , outPrefix ) ; \nStreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , err , errPrefix ) ; \noutputGobbler . start ( ) ; \nerrorGobbler . start ( ) ; \nint result ; \ntry { \nresult = process . waitFor ( ) ; \n} \ncatch ( InterruptedException iex ) { \nreturn writeException ( baos , iex ) ; \n} \noutputGobbler . waitFor ( ) ; \nerrorGobbler . waitFor ( ) ; \nreturn new ProcessRunner . ProcessResult ( result , baos . toString ( ) ) ; \n} \n} \n"}
{"1612": "public class Frame { \nstatic int getAbstractTypeFromApiFormat ( final SymbolTable symbolTable , final Object type ) { \nif ( type instanceof Integer ) return CONSTANT_KIND | ( ( Integer ) type ) . intValue ( ) ; \nelse if ( type instanceof String ) { \nString descriptor = Type . getObjectType ( ( String ) type ) . getDescriptor ( ) ; \nreturn getAbstractTypeFromDescriptor ( symbolTable , descriptor , 0 ) ; \n} \nelse return UNINITIALIZED_KIND | symbolTable . addUninitializedType ( \"\" , ( ( Label ) type ) . bytecodeOffset ) ; \n} \n} \n"}
{"1613": "public class Frame { \nprivate static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { \nString internalName ; \nswitch ( buffer . charAt ( offset ) ) { \ncase 'V' : return 0 ; \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; \ncase 'F' : return FLOAT ; \ncase 'J' : return LONG ; \ncase 'D' : return DOUBLE ; \ncase 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; \nreturn REFERENCE_KIND | symbolTable . addType ( internalName ) ; \ncase '[' : int elementDescriptorOffset = offset + 1 ; \nwhile ( buffer . charAt ( elementDescriptorOffset ) == '[' ) ++ elementDescriptorOffset ; \nint typeValue ; \nswitch ( buffer . charAt ( elementDescriptorOffset ) ) { \ncase 'Z' : typeValue = BOOLEAN ; \nbreak ; \ncase 'C' : typeValue = CHAR ; \nbreak ; \ncase 'B' : typeValue = BYTE ; \nbreak ; \ncase 'S' : typeValue = SHORT ; \nbreak ; \ncase 'I' : typeValue = INTEGER ; \nbreak ; \ncase 'F' : typeValue = FLOAT ; \nbreak ; \ncase 'J' : typeValue = LONG ; \nbreak ; \ncase 'D' : typeValue = DOUBLE ; \nbreak ; \ncase 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; \ntypeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \nfor ( int i = 0 ; \ni < numLocal ; \n++ i ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) inputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nwhile ( inputLocalIndex < inputLocals . length ) inputLocals [ inputLocalIndex ++ ] = TOP ; \nint numStackTop = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) ++ numStackTop ; \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) inputStack [ inputStackIndex ++ ] = TOP ; \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1615": "public class Frame { \nprivate int getLocal ( final int localIndex ) { \nif ( outputLocals == null || localIndex >= outputLocals . length ) return LOCAL_KIND | localIndex ; \nelse { \nint abstractType = outputLocals [ localIndex ] ; \nif ( abstractType == 0 ) abstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; \nreturn abstractType ; \n} \n} \n} \n"}
{"1616": "public class Frame { \nprivate void setLocal ( final int localIndex , final int abstractType ) { \nif ( outputLocals == null ) outputLocals = new int [ 10 ] ; \nint outputLocalsLength = outputLocals . length ; \nif ( localIndex >= outputLocalsLength ) { \nint [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; \nSystem . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; \noutputLocals = newOutputLocals ; \n} \noutputLocals [ localIndex ] = abstractType ; \n} \n} \n"}
{"1617": "public class Frame { \nprivate void push ( final int abstractType ) { \nif ( outputStack == null ) outputStack = new int [ 10 ] ; \nint outputStackLength = outputStack . length ; \nif ( outputStackTop >= outputStackLength ) { \nint [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; \nSystem . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; \noutputStack = newOutputStack ; \n} \noutputStack [ outputStackTop ++ ] = abstractType ; \nshort outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; \nif ( outputStackSize > owner . outputStackMax ) owner . outputStackMax = outputStackSize ; \n} \n} \n"}
{"1618": "public class Frame { \nprivate void push ( final SymbolTable symbolTable , final String descriptor ) { \nint typeDescriptorOffset = descriptor . charAt ( 0 ) == '(' ? descriptor . indexOf ( ')' ) + 1 : 0 ; \nint abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; \nif ( abstractType != 0 ) { \npush ( abstractType ) ; \nif ( abstractType == LONG || abstractType == DOUBLE ) push ( TOP ) ; \n} \n} \n} \n"}
{"1619": "public class Frame { \nprivate void pop ( final int elements ) { \nif ( outputStackTop >= elements ) outputStackTop -= elements ; \nelse { \noutputStackStart -= elements - outputStackTop ; \noutputStackTop = 0 ; \n} \n} \n} \n"}
{"1620": "public class Frame { \nprivate void pop ( final String descriptor ) { \nchar firstDescriptorChar = descriptor . charAt ( 0 ) ; \nif ( firstDescriptorChar == '(' ) pop ( ( Type . getArgumentsAndReturnSizes ( descriptor ) >> 2 ) - 1 ) ; \nelse if ( firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ) pop ( 2 ) ; \nelse pop ( 1 ) ; \n} \n} \n"}
{"1621": "public class Frame { \nprivate void addInitializedType ( final int abstractType ) { \nif ( initializations == null ) initializations = new int [ 2 ] ; \nint initializationsLength = initializations . length ; \nif ( initializationCount >= initializationsLength ) { \nint [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; \nSystem . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; \ninitializations = newInitializations ; \n} \ninitializations [ initializationCount ++ ] = abstractType ; \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) for ( int i = 0 ; \ni < initializationCount ; \n++ i ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) initializedType = dim + inputLocals [ value ] ; \nelse if ( kind == STACK_KIND ) initializedType = dim + inputStack [ inputStack . length - value ] ; \nif ( abstractType == initializedType ) if ( abstractType == UNINITIALIZED_THIS ) return REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \nelse return REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \nreturn abstractType ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nint arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( arrayDimensions == 0 ) { \nint typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nwhile ( arrayDimensions -- > 0 ) typeDescriptor . append ( '[' ) ; \nif ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) typeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \nelse switch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \n} \n} \n"}
{"1625": "public class TimedCache { \npublic void schedulePrune ( final long delay ) { \nif ( pruneTimer != null ) pruneTimer . cancel ( ) ; \npruneTimer = new Timer ( ) ; \npruneTimer . schedule ( new TimerTask ( ) { \n@ Override public void run ( ) { \nprune ( ) ; \n} \n} \n, delay , delay ) ; \n} \n} \n"}
{"1626": "public class ClassVisitor { \npublic ModuleVisitor visitModule ( final String name , final int access , final String version ) { \nif ( api < Opcodes . ASM6 ) throw new UnsupportedOperationException ( \"This feature requires ASM6\" ) ; \nif ( cv != null ) return cv . visitModule ( name , access , version ) ; \nreturn null ; \n} \n} \n"}
{"1627": "public class ClassVisitor { \npublic void visitNestHost ( final String nestHost ) { \nif ( api < Opcodes . ASM7 ) throw new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; \nif ( cv != null ) cv . visitNestHost ( nestHost ) ; \n} \n} \n"}
{"1628": "public class ClassVisitor { \npublic void visitOuterClass ( final String owner , final String name , final String descriptor ) { \nif ( cv != null ) cv . visitOuterClass ( owner , name , descriptor ) ; \n} \n} \n"}
{"1629": "public class ClassVisitor { \npublic AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { \nif ( cv != null ) return cv . visitAnnotation ( descriptor , visible ) ; \nreturn null ; \n} \n} \n"}
{"1630": "public class ClassVisitor { \npublic void visitNestMember ( final String nestMember ) { \nif ( api < Opcodes . ASM7 ) throw new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; \nif ( cv != null ) cv . visitNestMember ( nestMember ) ; \n} \n} \n"}
{"1631": "public class ClassVisitor { \npublic void visitInnerClass ( final String name , final String outerName , final String innerName , final int access ) { \nif ( cv != null ) cv . visitInnerClass ( name , outerName , innerName , access ) ; \n} \n} \n"}
{"1632": "public class ClassVisitor { \npublic FieldVisitor visitField ( final int access , final String name , final String descriptor , final String signature , final Object value ) { \nif ( cv != null ) return cv . visitField ( access , name , descriptor , signature , value ) ; \nreturn null ; \n} \n} \n"}
{"1633": "public class DbThreadSession { \npublic static DbThreadSession getThreadSession ( ) { \nDbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; \nif ( session == null ) session = new DbThreadSession ( ) ; \nreturn session ; \n} \n} \n"}
{"1634": "public class DbThreadSession { \npublic static void closeThreadSession ( ) { \nDbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; \nif ( session != null ) session . closeSession ( ) ; \n} \n} \n"}
{"1637": "public class ActionRequest { \npublic String readRequestBody ( ) { \nif ( requestBody == null ) try { \nrequestBody = ServletUtil . readRequestBodyFromStream ( getHttpServletRequest ( ) ) ; \n} \ncatch ( IOException ioex ) { \nrequestBody = StringPool . EMPTY ; \n} \nreturn requestBody ; \n} \n} \n"}
{"1638": "public class PageData { \npublic static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { \nif ( total == 0 ) return 0 ; \nif ( page < 1 ) page = 1 ; \nint first = ( page - 1 ) * pageSize ; \nif ( first >= total ) first = ( ( total - 1 ) / pageSize ) * pageSize ; \nreturn first ; \n} \n} \n"}
{"1640": "public class PseudoFunctionExpression { \npublic boolean match ( final int value ) { \nif ( a == 0 ) return value == b ; \nif ( a > 0 ) { \nif ( value < b ) return false ; \nreturn ( value - b ) % a == 0 ; \n} \nif ( value > b ) return false ; \nreturn ( b - value ) % ( - a ) == 0 ; \n} \n} \n"}
{"1642": "public class CharUtil { \npublic static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { \nfor ( int i = index ; \ni < source . length ; \ni ++ ) if ( ! equalsOne ( source [ i ] , match ) ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"1646": "public class Props { \npublic Props load ( final File file ) throws IOException { \nfinal String extension = FileNameUtil . getExtension ( file . getAbsolutePath ( ) ) ; \nfinal String data ; \nif ( extension . equalsIgnoreCase ( \"properties\" ) ) data = FileUtil . readString ( file , StringPool . ISO_8859_1 ) ; \nelse data = FileUtil . readString ( file ) ; \nparse ( data ) ; \nreturn this ; \n} \n} \n"}
{"1649": "public class Props { \npublic Props load ( final Map < ? , ? > p ) { \nfor ( final Map . Entry < ? , ? > entry : p . entrySet ( ) ) { \nfinal String name = entry . getKey ( ) . toString ( ) ; \nfinal Object value = entry . getValue ( ) ; \nif ( value == null ) continue ; \ndata . putBaseProperty ( name , value . toString ( ) , false ) ; \n} \nreturn this ; \n} \n} \n"}
{"1650": "public class Props { \n@ SuppressWarnings ( \"unchecked\" ) public Props load ( final Map < ? , ? > map , final String prefix ) { \nString realPrefix = prefix ; \nrealPrefix += '.' ; \nfor ( final Map . Entry entry : map . entrySet ( ) ) { \nfinal String name = entry . getKey ( ) . toString ( ) ; \nfinal Object value = entry . getValue ( ) ; \nif ( value == null ) continue ; \ndata . putBaseProperty ( realPrefix + name , value . toString ( ) , false ) ; \n} \nreturn this ; \n} \n} \n"}
{"1651": "public class Props { \npublic Props loadFromClasspath ( final String ... patterns ) { \nClassScanner . create ( ) . registerEntryConsumer ( entryData -> { \nString usedEncoding = JoddCore . encoding ; \nif ( StringUtil . endsWithIgnoreCase ( entryData . name ( ) , \".properties\" ) ) usedEncoding = StringPool . ISO_8859_1 ; \nfinal String encoding = usedEncoding ; \nUncheckedException . runAndWrapException ( ( ) -> load ( entryData . openInputStream ( ) , encoding ) ) ; \n} \n) . includeResources ( true ) . ignoreException ( true ) . excludeCommonJars ( ) . excludeAllEntries ( true ) . includeEntries ( patterns ) . scanDefaultClasspath ( ) . start ( ) ; \nreturn this ; \n} \n} \n"}
{"1652": "public class Props { \npublic String getValueOrDefault ( final String key , final String defaultValue ) { \ninitialize ( ) ; \nfinal String value = data . lookupValue ( key , activeProfiles ) ; \nif ( value == null ) return defaultValue ; \nreturn value ; \n} \n} \n"}
{"1653": "public class Props { \npublic void setValue ( final String key , final String value , final String profile ) { \nif ( profile == null ) data . putBaseProperty ( key , value , false ) ; \nelse data . putProfileProperty ( key , value , profile , false ) ; \ninitialized = false ; \n} \n} \n"}
{"1658": "public class Props { \npublic void addInnerMap ( String prefix , final Map < ? , ? > map , final String profile ) { \nif ( ! StringUtil . endsWithChar ( prefix , '.' ) ) prefix += StringPool . DOT ; \nfor ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { \nString key = entry . getKey ( ) . toString ( ) ; \nkey = prefix + key ; \nsetValue ( key , entry . getValue ( ) . toString ( ) , profile ) ; \n} \n} \n} \n"}
{"1659": "public class Props { \nprotected void resolveActiveProfiles ( ) { \nif ( activeProfilesProp == null ) { \nactiveProfiles = null ; \nreturn ; \n} \nfinal PropsEntry pv = data . getBaseProperty ( activeProfilesProp ) ; \nif ( pv == null ) return ; \nfinal String value = pv . getValue ( ) ; \nif ( StringUtil . isBlank ( value ) ) { \nactiveProfiles = null ; \nreturn ; \n} \nactiveProfiles = StringUtil . splitc ( value , ',' ) ; \nStringUtil . trimAll ( activeProfiles ) ; \n} \n} \n"}
{"1662": "public class BeanDefinition { \nprotected void addPropertyInjectionPoint ( final PropertyInjectionPoint pip ) { \nif ( properties == null ) { \nproperties = new PropertyInjectionPoint [ 1 ] ; \nproperties [ 0 ] = pip ; \n} \nelse properties = ArraysUtil . append ( properties , pip ) ; \n} \n} \n"}
{"1663": "public class BeanDefinition { \nprotected void addSetInjectionPoint ( final SetInjectionPoint sip ) { \nif ( sets == null ) { \nsets = new SetInjectionPoint [ 1 ] ; \nsets [ 0 ] = sip ; \n} \nelse sets = ArraysUtil . append ( sets , sip ) ; \n} \n} \n"}
{"1664": "public class BeanDefinition { \nprotected void addMethodInjectionPoint ( final MethodInjectionPoint mip ) { \nif ( methods == null ) { \nmethods = new MethodInjectionPoint [ 1 ] ; \nmethods [ 0 ] = mip ; \n} \nelse methods = ArraysUtil . append ( methods , mip ) ; \n} \n} \n"}
{"1665": "public class BeanDefinition { \nprotected void addInitMethodPoints ( final InitMethodPoint [ ] methods ) { \nif ( initMethods == null ) initMethods = methods ; \nelse initMethods = ArraysUtil . join ( initMethods , methods ) ; \n} \n} \n"}
{"1666": "public class BeanDefinition { \nprotected void addDestroyMethodPoints ( final DestroyMethodPoint [ ] methods ) { \nif ( destroyMethods == null ) destroyMethods = methods ; \nelse destroyMethods = ArraysUtil . join ( destroyMethods , methods ) ; \n} \n} \n"}
{"1667": "public class ProxettaUtil { \npublic static Class resolveTargetClass ( final Class proxy ) { \nfinal String name = proxy . getName ( ) ; \nif ( name . endsWith ( ProxettaNames . proxyClassNameSuffix ) ) return proxy . getSuperclass ( ) ; \nif ( name . endsWith ( ProxettaNames . wrapperClassNameSuffix ) ) return getTargetWrapperType ( proxy ) ; \nreturn proxy ; \n} \n} \n"}
{"1670": "public class PropertyDescriptor { \nprotected FieldDescriptor findField ( final String fieldName ) { \nFieldDescriptor fieldDescriptor = classDescriptor . getFieldDescriptor ( fieldName , true ) ; \nif ( fieldDescriptor != null ) return fieldDescriptor ; \nClass [ ] superclasses = classDescriptor . getAllSuperclasses ( ) ; \nfor ( Class superclass : superclasses ) { \nClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( superclass ) ; \nfieldDescriptor = classDescriptor . getFieldDescriptor ( fieldName , true ) ; \nif ( fieldDescriptor != null ) return fieldDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"1671": "public class PropertyDescriptor { \npublic Class getType ( ) { \nif ( type == null ) if ( fieldDescriptor != null ) type = fieldDescriptor . getRawType ( ) ; \nelse if ( readMethodDescriptor != null ) type = getGetter ( true ) . getGetterRawType ( ) ; \nelse if ( writeMethodDescriptor != null ) type = getSetter ( true ) . getSetterRawType ( ) ; \nreturn type ; \n} \n} \n"}
{"1672": "public class PropertyDescriptor { \npublic Class resolveKeyType ( final boolean declared ) { \nClass keyType = null ; \nGetter getter = getGetter ( declared ) ; \nif ( getter != null ) keyType = getter . getGetterRawKeyComponentType ( ) ; \nif ( keyType == null ) { \nFieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; \nif ( fieldDescriptor != null ) keyType = fieldDescriptor . getRawKeyComponentType ( ) ; \n} \nreturn keyType ; \n} \n} \n"}
{"1673": "public class PropertyDescriptor { \npublic Class resolveComponentType ( final boolean declared ) { \nClass componentType = null ; \nGetter getter = getGetter ( declared ) ; \nif ( getter != null ) componentType = getter . getGetterRawComponentType ( ) ; \nif ( componentType == null ) { \nFieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; \nif ( fieldDescriptor != null ) componentType = fieldDescriptor . getRawComponentType ( ) ; \n} \nreturn componentType ; \n} \n} \n"}
{"1676": "public class RestActionNamingStrategy { \nprotected String resolveHttpMethodFromMethodName ( final String methodName ) { \nint i = 0 ; \nwhile ( i < methodName . length ( ) ) { \nif ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) break ; \ni ++ ; \n} \nfinal String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; \nfor ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { \nif ( httpMethod . equalsName ( name ) ) return httpMethod . name ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) if ( pattern . charAt ( 0 ) == '*' ) return true ; \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sNdx >= sLen ) ) { \nwhile ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) pNdx ++ ; \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) return false ; \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) pNext = pattern . charAt ( pNdx + 1 ) ; \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nint i ; \npNdx ++ ; \nfor ( i = string . length ( ) ; \ni >= sNdx ; \ni -- ) if ( match ( string , pattern , i , pNdx ) ) return true ; \nreturn false ; \n} \n} \nelse nextIsNotWildcard = false ; \nif ( p != string . charAt ( sNdx ) ) return false ; \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1678": "public class ExtendedURLClassLoader { \nprotected Loading resolveLoading ( final boolean parentFirstStrategy , final String className ) { \nboolean withParent = true ; \nboolean withLoader = true ; \nif ( parentFirstStrategy ) if ( isMatchingRules ( className , loaderOnlyRules ) ) withParent = false ; \nelse if ( isMatchingRules ( className , parentOnlyRules ) ) withLoader = false ; \nelse if ( isMatchingRules ( className , parentOnlyRules ) ) withLoader = false ; \nelse if ( isMatchingRules ( className , loaderOnlyRules ) ) withParent = false ; \nreturn new Loading ( withParent , withLoader ) ; \n} \n} \n"}
{"1679": "public class ExtendedURLClassLoader { \nprotected Loading resolveResourceLoading ( final boolean parentFirstStrategy , String resourceName ) { \nif ( matchResourcesAsPackages ) resourceName = StringUtil . replaceChar ( resourceName , '/' , '.' ) ; \nreturn resolveLoading ( parentFirstStrategy , resourceName ) ; \n} \n} \n"}
{"1680": "public class ExtendedURLClassLoader { \n@ Override protected synchronized Class < ? > loadClass ( final String className , final boolean resolve ) throws ClassNotFoundException { \nClass < ? > c = findLoadedClass ( className ) ; \nif ( c != null ) { \nif ( resolve ) resolveClass ( c ) ; \nreturn c ; \n} \nLoading loading = resolveLoading ( parentFirst , className ) ; \nif ( parentFirst ) { \nif ( loading . withParent ) try { \nc = parentClassLoader . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \nif ( c == null ) if ( loading . withLoader ) c = this . findClass ( className ) ; \nelse throw new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \nelse { \nif ( loading . withLoader ) try { \nc = this . findClass ( className ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \nif ( c == null ) if ( loading . withParent ) c = parentClassLoader . loadClass ( className ) ; \nelse throw new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \nif ( resolve ) resolveClass ( c ) ; \nreturn c ; \n} \n} \n"}
{"1681": "public class ExtendedURLClassLoader { \n@ Override public URL getResource ( final String resourceName ) { \nURL url = null ; \nLoading loading = resolveResourceLoading ( parentFirst , resourceName ) ; \nif ( parentFirst ) { \nif ( loading . withParent ) url = parentClassLoader . getResource ( resourceName ) ; \nif ( url == null ) if ( loading . withLoader ) url = this . findResource ( resourceName ) ; \n} \nelse { \nif ( loading . withLoader ) url = this . findResource ( resourceName ) ; \nif ( url == null ) if ( loading . withParent ) url = parentClassLoader . getResource ( resourceName ) ; \n} \nreturn url ; \n} \n} \n"}
{"1682": "public class StreamGobbler { \npublic void waitFor ( ) { \ntry { \nsynchronized ( lock ) { \nif ( ! end ) lock . wait ( ) ; \n} \n} \ncatch ( InterruptedException ignore ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \n} \n} \n"}
{"1683": "public class ScopeDataInspector { \npublic Class < ? extends Annotation > detectAnnotationType ( final Annotation [ ] annotations ) { \nfor ( final Annotation annotation : annotations ) { \nif ( annotation instanceof In ) return annotation . annotationType ( ) ; \nelse if ( annotation instanceof Out ) return annotation . annotationType ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"1685": "public class TypeJsonVisitor { \npublic void visit ( ) { \nClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; \nif ( classMetadataName != null ) onProperty ( classMetadataName , null , false ) ; \nPropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { \nGetter getter = propertyDescriptor . getGetter ( declared ) ; \nif ( getter != null ) { \nString propertyName = propertyDescriptor . getName ( ) ; \nboolean isTransient = false ; \nFieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; \nif ( fieldDescriptor != null ) isTransient = Modifier . isTransient ( fieldDescriptor . getField ( ) . getModifiers ( ) ) ; \nonProperty ( propertyName , propertyDescriptor , isTransient ) ; \n} \n} \n} \n} \n"}
{"1686": "public class ClassPathURLs { \npublic static URL [ ] of ( ClassLoader classLoader , Class clazz ) { \nif ( clazz == null ) clazz = ClassPathURLs . class ; \nif ( classLoader == null ) classLoader = clazz . getClassLoader ( ) ; \nfinal Set < URL > urls = new LinkedHashSet < > ( ) ; \nwhile ( classLoader != null ) { \nif ( classLoader instanceof URLClassLoader ) { \nfinal URLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; \nreturn urlClassLoader . getURLs ( ) ; \n} \nfinal URL url = classModuleUrl ( classLoader , clazz ) ; \nif ( url != null ) urls . add ( url ) ; \nclassLoader = classLoader . getParent ( ) ; \n} \nreturn urls . toArray ( new URL [ 0 ] ) ; \n} \n} \n"}
{"1689": "public class BeanProperty { \nprivate void loadPropertyDescriptor ( ) { \nif ( updateProperty ) { \nif ( cd == null ) propertyDescriptor = null ; \nelse propertyDescriptor = cd . getPropertyDescriptor ( name , true ) ; \nupdateProperty = false ; \n} \n} \n} \n"}
{"1693": "public class CompositeIterator { \npublic void add ( final Iterator < T > iterator ) { \nif ( allIterators . contains ( iterator ) ) throw new IllegalArgumentException ( \"Duplicate iterator\" ) ; \nallIterators . add ( iterator ) ; \n} \n} \n"}
{"1695": "public class JoddJoy { \npublic void stop ( ) { \njoyProps . stop ( ) ; \ntry { \njoyDb . stop ( ) ; \njoyPetite . stop ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( log != null ) log . info ( \"Joy is down. Bye, bye!\" ) ; \n} \n} \n"}
{"1696": "public class SocketHttpConnectionProvider { \nprotected Socket createSocket ( final String host , final int port , final int connectionTimeout ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , false , false , connectionTimeout ) ; \nif ( connectionTimeout < 0 ) return socketFactory . createSocket ( host , port ) ; \nelse { \nSocket socket = socketFactory . createSocket ( ) ; \nsocket . connect ( new InetSocketAddress ( host , port ) , connectionTimeout ) ; \nreturn socket ; \n} \n} \n} \n"}
{"1697": "public class SocketHttpConnectionProvider { \nprotected SSLSocket createSSLSocket ( final String host , final int port , final int connectionTimeout , final boolean trustAll , final boolean verifyHttpsHost ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , true , trustAll , connectionTimeout ) ; \nfinal Socket socket ; \nif ( connectionTimeout < 0 ) socket = socketFactory . createSocket ( host , port ) ; \nelse socket = Sockets . connect ( host , port , connectionTimeout ) ; \nSSLSocket sslSocket ; \nif ( socket instanceof SSLSocket ) sslSocket = ( SSLSocket ) socket ; \nelse if ( socketFactory instanceof SSLSocketFactory ) sslSocket = ( SSLSocket ) ( ( SSLSocketFactory ) socketFactory ) . createSocket ( socket , host , port , true ) ; \nelse sslSocket = ( SSLSocket ) ( getDefaultSSLSocketFactory ( trustAll ) ) . createSocket ( socket , host , port , true ) ; \nif ( secureEnabledProtocols != null ) { \nfinal String [ ] values = StringUtil . splitc ( secureEnabledProtocols , ',' ) ; \nStringUtil . trimAll ( values ) ; \nsslSocket . setEnabledProtocols ( values ) ; \n} \nif ( verifyHttpsHost ) { \nfinal SSLParameters sslParams = new SSLParameters ( ) ; \nsslParams . setEndpointIdentificationAlgorithm ( \"HTTPS\" ) ; \nsslSocket . setSSLParameters ( sslParams ) ; \n} \nreturn sslSocket ; \n} \n} \n"}
{"1698": "public class SocketHttpConnectionProvider { \nprotected SSLSocketFactory getDefaultSSLSocketFactory ( final boolean trustAllCertificates ) throws IOException { \nif ( trustAllCertificates ) try { \nSSLContext sc = SSLContext . getInstance ( sslProtocol ) ; \nsc . init ( null , TrustManagers . TRUST_ALL_CERTS , new java . security . SecureRandom ( ) ) ; \nreturn sc . getSocketFactory ( ) ; \n} \ncatch ( NoSuchAlgorithmException | KeyManagementException e ) { \nthrow new IOException ( e ) ; \n} \nelse return ( SSLSocketFactory ) SSLSocketFactory . getDefault ( ) ; \n} \n} \n"}
{"1699": "public class SocketHttpConnectionProvider { \nprotected SocketFactory getSocketFactory ( final ProxyInfo proxy , final boolean ssl , final boolean trustAllCertificates , final int connectionTimeout ) throws IOException { \nswitch ( proxy . getProxyType ( ) ) { \ncase NONE : if ( ssl ) return getDefaultSSLSocketFactory ( trustAllCertificates ) ; \nelse return SocketFactory . getDefault ( ) ; \ncase HTTP : return new HTTPProxySocketFactory ( proxy , connectionTimeout ) ; \ncase SOCKS4 : return new Socks4ProxySocketFactory ( proxy , connectionTimeout ) ; \ncase SOCKS5 : return new Socks5ProxySocketFactory ( proxy , connectionTimeout ) ; \ndefault : return null ; \n} \n} \n} \n"}
{"1700": "public class RandomString { \npublic String random ( int count , final char [ ] chars ) { \nif ( count == 0 ) return StringPool . EMPTY ; \nfinal char [ ] result = new char [ count ] ; \nwhile ( count -- > 0 ) result [ count ] = chars [ rnd . nextInt ( chars . length ) ] ; \nreturn new String ( result ) ; \n} \n} \n"}
{"1701": "public class RandomString { \npublic String random ( int count , final char start , final char end ) { \nif ( count == 0 ) return StringPool . EMPTY ; \nfinal char [ ] result = new char [ count ] ; \nfinal int len = end - start + 1 ; \nwhile ( count -- > 0 ) result [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; \nreturn new String ( result ) ; \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) return StringPool . EMPTY ; \nint i = 0 ; \nint len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nwhile ( i < ranges . length ) { \nint gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen += gap ; \nlens [ i ] = len ; \ni += 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( count -- > 0 ) { \nchar c = 0 ; \nint r = rnd . nextInt ( len ) ; \nfor ( i = 0 ; \ni < ranges . length ; \ni += 2 ) if ( r < lens [ i ] ) { \nr += ranges [ i ] ; \nif ( i != 0 ) r -= lens [ i - 2 ] ; \nc = ( char ) r ; \nbreak ; \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1703": "public class JsonParserBase { \n@ SuppressWarnings ( \"unchecked\" ) protected Collection < Object > newArrayInstance ( final Class targetType ) { \nif ( targetType == null || targetType == List . class || targetType == Collection . class || targetType . isArray ( ) ) return listSupplier . get ( ) ; \nif ( targetType == Set . class ) return new HashSet < > ( ) ; \ntry { \nreturn ( Collection < Object > ) targetType . getDeclaredConstructor ( ) . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new JsonException ( e ) ; \n} \n} \n} \n"}
{"1704": "public class JsonParserBase { \nprotected void injectValueIntoObject ( final Object target , final PropertyDescriptor pd , final Object value ) { \nObject convertedValue = value ; \nif ( value != null ) { \nClass targetClass = pd . getType ( ) ; \nconvertedValue = convertType ( value , targetClass ) ; \n} \ntry { \nSetter setter = pd . getSetter ( true ) ; \nif ( setter != null ) setter . invokeSetter ( target , convertedValue ) ; \n} \ncatch ( Exception ex ) { \nthrow new JsonException ( ex ) ; \n} \n} \n} \n"}
{"1705": "public class JsonParserBase { \nprotected Object convertType ( final Object value , final Class targetType ) { \nfinal Class valueClass = value . getClass ( ) ; \nif ( valueClass == targetType ) return value ; \ntry { \nreturn TypeConverterManager . get ( ) . convertType ( value , targetType ) ; \n} \ncatch ( Exception ex ) { \nif ( ! strictTypes ) return null ; \nthrow new JsonException ( \"Type conversion failed\" , ex ) ; \n} \n} \n} \n"}
{"1706": "public class ModuleVisitor { \npublic void visitProvide ( final String service , final String ... providers ) { \nif ( mv != null ) mv . visitProvide ( service , providers ) ; \n} \n} \n"}
{"1710": "public class NetUtil { \npublic static String resolveIpAddress ( final String hostname ) { \ntry { \nInetAddress netAddress ; \nif ( hostname == null || hostname . equalsIgnoreCase ( LOCAL_HOST ) ) netAddress = InetAddress . getLocalHost ( ) ; \nelse netAddress = Inet4Address . getByName ( hostname ) ; \nreturn netAddress . getHostAddress ( ) ; \n} \ncatch ( UnknownHostException ignore ) { \nreturn null ; \n} \n} \n} \n"}
{"1711": "public class NetUtil { \npublic static int getIpAsInt ( final String ipAddress ) { \nint ipIntValue = 0 ; \nString [ ] tokens = StringUtil . splitc ( ipAddress , '.' ) ; \nfor ( String token : tokens ) { \nif ( ipIntValue > 0 ) ipIntValue <<= 8 ; \nipIntValue += Integer . parseInt ( token ) ; \n} \nreturn ipIntValue ; \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) return false ; \nint hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) { \nchar c = data [ i ] ; \nint b = 0 ; \ndo { \nif ( c < '0' || c > '9' ) return false ; \nb = ( b * 10 + c ) - 48 ; \nif ( ++ i >= data . length ) break ; \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( b > 255 ) return false ; \nhitDots ++ ; \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1720": "public class Sockets { \npublic static Socket connect ( final String hostname , final int port , final int connectionTimeout ) throws IOException { \nfinal Socket socket = new Socket ( ) ; \nif ( connectionTimeout <= 0 ) socket . connect ( new InetSocketAddress ( hostname , port ) ) ; \nelse socket . connect ( new InetSocketAddress ( hostname , port ) , connectionTimeout ) ; \nreturn socket ; \n} \n} \n"}
{"1721": "public class DefaultClassLoaderStrategy { \nprivate static int getPrimitiveClassNameIndex ( final String className ) { \nint dotIndex = className . indexOf ( '.' ) ; \nif ( dotIndex != - 1 ) return - 1 ; \nreturn Arrays . binarySearch ( PRIMITIVE_TYPE_NAMES , className ) ; \n} \n} \n"}
{"1722": "public class DefaultClassLoaderStrategy { \n@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nString arrayClassName = prepareArrayClassnameForLoading ( className ) ; \nif ( ( className . indexOf ( '.' ) == - 1 ) && ( arrayClassName == null ) ) { \nint primitiveNdx = getPrimitiveClassNameIndex ( className ) ; \nif ( primitiveNdx >= 0 ) return PRIMITIVE_TYPES [ primitiveNdx ] ; \n} \nif ( classLoader != null ) { \nClass klass = loadClass ( className , arrayClassName , classLoader ) ; \nif ( klass != null ) return klass ; \n} \nClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( ( currentThreadClassLoader != null ) && ( currentThreadClassLoader != classLoader ) ) { \nClass klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; \nif ( klass != null ) return klass ; \n} \nClass callerClass = ClassUtil . getCallerClass ( ) ; \nClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; \nif ( ( callerClassLoader != classLoader ) && ( callerClassLoader != currentThreadClassLoader ) ) { \nClass klass = loadClass ( className , arrayClassName , callerClassLoader ) ; \nif ( klass != null ) return klass ; \n} \nif ( arrayClassName != null ) try { \nreturn loadArrayClassByComponentType ( className , classLoader ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \nthrow new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \n} \n"}
{"1723": "public class DefaultClassLoaderStrategy { \nprotected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nint ndx = className . indexOf ( '[' ) ; \nint multi = StringUtil . count ( className , '[' ) ; \nString componentTypeName = className . substring ( 0 , ndx ) ; \nClass componentType = loadClass ( componentTypeName , classLoader ) ; \nif ( multi == 1 ) return Array . newInstance ( componentType , 0 ) . getClass ( ) ; \nint [ ] multiSizes ; \nif ( multi == 2 ) multiSizes = new int [ ] { \n0 , 0 } \n; \nelse if ( multi == 3 ) multiSizes = new int [ ] { \n0 , 0 , 0 } \n; \nelse multiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; \nreturn Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; \n} \n} \n"}
{"1732": "public class DbOomQuery { \nprotected void resolveColumnDbSqlType ( final Connection connection , final DbEntityColumnDescriptor dec ) { \nif ( dec . dbSqlType != SqlType . DB_SQLTYPE_UNKNOWN ) return ; \nResultSet rs = null ; \nDbEntityDescriptor ded = dec . getDbEntityDescriptor ( ) ; \ntry { \nDatabaseMetaData dmd = connection . getMetaData ( ) ; \nrs = dmd . getColumns ( null , ded . getSchemaName ( ) , ded . getTableName ( ) , dec . getColumnName ( ) ) ; \nif ( rs . next ( ) ) dec . dbSqlType = rs . getInt ( \"DATA_TYPE\" ) ; \nelse { \ndec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; \nif ( log . isWarnEnabled ( ) ) log . warn ( \"Column SQL type not available: \" + ded . toString ( ) + '.' + dec . getColumnName ( ) ) ; \n} \n} \ncatch ( SQLException sex ) { \ndec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; \nif ( log . isWarnEnabled ( ) ) log . warn ( \"Column SQL type not resolved: \" + ded . toString ( ) + '.' + dec . getColumnName ( ) , sex ) ; \n} \nfinally { \nDbUtil . close ( rs ) ; \n} \n} \n} \n"}
{"1733": "public class DbOomQuery { \nprotected String preprocessSql ( String sqlString ) { \nif ( sqlString . charAt ( 0 ) == '{' ) return sqlString ; \nif ( ! CharUtil . isAlpha ( sqlString . charAt ( 0 ) ) ) sqlString = sqlString . substring ( 1 ) ; \nelse if ( sqlString . indexOf ( ' ' ) != - 1 ) return sqlString ; \nfinal String sqlFromMap = dbOom . queryMap ( ) . getQuery ( sqlString ) ; \nif ( sqlFromMap != null ) sqlString = sqlFromMap . trim ( ) ; \nreturn sqlString ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) return ; \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \nfor ( int i = 0 ; \ni < generatedColumns . length ; \ni ++ ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! keyValues . getClass ( ) . isArray ( ) ) BeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \nelse for ( int i = 0 ; \ni < properties . length ; \ni ++ ) BeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \n} \n} \n"}
{"1738": "public class DbQuery { \npublic Q setBean ( final String beanName , final Object bean ) { \nif ( bean == null ) return _this ( ) ; \ninit ( ) ; \nfinal String beanNamePrefix = beanName + '.' ; \nquery . forEachNamedParameter ( p -> { \nfinal String paramName = p . name ; \nif ( paramName . startsWith ( beanNamePrefix ) ) { \nfinal String propertyName = paramName . substring ( beanNamePrefix . length ( ) ) ; \nif ( BeanUtil . declared . hasRootProperty ( bean , propertyName ) ) { \nfinal Object value = BeanUtil . declared . getProperty ( bean , propertyName ) ; \nsetObject ( paramName , value ) ; \n} \n} \n} \n) ; \nreturn _this ( ) ; \n} \n} \n"}
{"1739": "public class DbQuery { \npublic Q setMap ( final Map parameters ) { \nif ( parameters == null ) return _this ( ) ; \ninit ( ) ; \nquery . forEachNamedParameter ( p -> { \nfinal String paramName = p . name ; \nsetObject ( paramName , parameters . get ( paramName ) ) ; \n} \n) ; \nreturn _this ( ) ; \n} \n} \n"}
{"1742": "public class SqlChunk { \nprotected DbEntityDescriptor lookupType ( final Class entity ) { \nfinal DbEntityDescriptor ded = dbEntityManager . lookupType ( entity ) ; \nif ( ded == null ) throw new DbSqlBuilderException ( \"Invalid or not-persistent entity: \" + entity . getName ( ) ) ; \nreturn ded ; \n} \n} \n"}
{"1743": "public class SqlChunk { \nprotected DbEntityDescriptor findColumnRef ( final String columnRef ) { \nDbEntityDescriptor ded = templateData . findTableDescriptorByColumnRef ( columnRef ) ; \nif ( ded == null ) throw new DbSqlBuilderException ( \"Invalid column reference: [\" + columnRef + \"]\" ) ; \nreturn ded ; \n} \n} \n"}
{"1744": "public class SqlChunk { \nprotected String resolveTable ( final String tableRef , final DbEntityDescriptor ded ) { \nString tableAlias = templateData . getTableAlias ( tableRef ) ; \nif ( tableAlias != null ) return tableAlias ; \nreturn ded . getTableNameForQuery ( ) ; \n} \n} \n"}
{"1746": "public class SqlChunk { \nprotected void appendMissingSpace ( final StringBuilder out ) { \nint len = out . length ( ) ; \nif ( len == 0 ) return ; \nlen -- ; \nif ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) out . append ( ' ' ) ; \n} \n} \n"}
{"1747": "public class MultipartRequestWrapper { \npublic Enumeration < String > getFileParameterNames ( ) { \nif ( mreq == null ) return null ; \nreturn Collections . enumeration ( mreq . getFileParameterNames ( ) ) ; \n} \n} \n"}
{"1749": "public class DispatcherUtil { \npublic static String getUrl ( final HttpServletRequest request ) { \nString servletPath = request . getServletPath ( ) ; \nString query = request . getQueryString ( ) ; \nif ( ( query != null ) && ( query . length ( ) != 0 ) ) servletPath += '?' + query ; \nreturn servletPath ; \n} \n} \n"}
{"1750": "public class DispatcherUtil { \npublic static String getRequestUri ( final HttpServletRequest request ) { \nString result = getIncludeRequestUri ( request ) ; \nif ( result == null ) result = request . getRequestURI ( ) ; \nreturn result ; \n} \n} \n"}
{"1751": "public class ActionMethodParamNameResolver { \npublic String [ ] resolveParamNames ( final Method actionClassMethod ) { \nMethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; \nString [ ] names = new String [ methodParameters . length ] ; \nfor ( int i = 0 ; \ni < methodParameters . length ; \ni ++ ) names [ i ] = methodParameters [ i ] . getName ( ) ; \nreturn names ; \n} \n} \n"}
{"1752": "public class JoyPetite { \n@ Override public void start ( ) { \ninitLogger ( ) ; \nlog . info ( \"PETITE start  ----------\" ) ; \npetiteContainer = createPetiteContainer ( ) ; \nif ( externalsCache ) petiteContainer . setExternalsCache ( TypeCache . createDefault ( ) ) ; \nlog . info ( \"Web application? \" + isWebApplication ) ; \nif ( ! isWebApplication ) petiteContainer . registerScope ( SessionScope . class , new SingletonScope ( petiteContainer ) ) ; \npetiteContainer . defineParameters ( joyPropsSupplier . get ( ) . getProps ( ) ) ; \nif ( autoConfiguration ) { \nfinal AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator ( petiteContainer ) ; \nautomagicPetiteConfigurator . registerAsConsumer ( joyScannerSupplier . get ( ) . getClassScanner ( ) ) ; \n} \npetiteContainerConsumers . accept ( this . petiteContainer ) ; \nlog . info ( \"PETITE OK!\" ) ; \n} \n} \n"}
{"1753": "public class JoyPetite { \n@ Override public void stop ( ) { \nif ( log != null ) log . info ( \"PETITE stop\" ) ; \nif ( petiteContainer != null ) petiteContainer . shutdown ( ) ; \npetiteContainer = null ; \n} \n} \n"}
{"1765": "public class EmailFilter { \npublic EmailFilter and ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( int i = 0 ; \ni < emailFilters . length ; \ni ++ ) searchTerms [ i ] = emailFilters [ i ] . searchTerm ; \nconcat ( new AndTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1766": "public class EmailFilter { \npublic EmailFilter or ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( int i = 0 ; \ni < emailFilters . length ; \ni ++ ) searchTerms [ i ] = emailFilters [ i ] . searchTerm ; \nconcat ( new OrTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1768": "public class EmailFilter { \nprotected void concat ( SearchTerm searchTerm ) { \nif ( nextIsNot ) { \nsearchTerm = new NotTerm ( searchTerm ) ; \nnextIsNot = false ; \n} \nif ( operatorAnd ) and ( searchTerm ) ; \nelse or ( searchTerm ) ; \n} \n} \n"}
{"1770": "public class ByteArrayConverter { \nprotected byte [ ] convertValueToArray ( final Object value ) { \nif ( value instanceof Blob ) { \nfinal Blob blob = ( Blob ) value ; \ntry { \nfinal long length = blob . length ( ) ; \nif ( length > Integer . MAX_VALUE ) throw new TypeConversionException ( \"Blob is too big.\" ) ; \nreturn blob . getBytes ( 1 , ( int ) length ) ; \n} \ncatch ( SQLException sex ) { \nthrow new TypeConversionException ( value , sex ) ; \n} \n} \nif ( value instanceof File ) try { \nreturn FileUtil . readBytes ( ( File ) value ) ; \n} \ncatch ( IOException ioex ) { \nthrow new TypeConversionException ( value , ioex ) ; \n} \nif ( value instanceof Collection ) { \nfinal Collection collection = ( Collection ) value ; \nfinal byte [ ] target = new byte [ collection . size ( ) ] ; \nint i = 0 ; \nfor ( final Object element : collection ) { \ntarget [ i ] = convertType ( element ) ; \ni ++ ; \n} \nreturn target ; \n} \nif ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; \nfor ( final Object element : iterable ) { \nfinal byte convertedValue = convertType ( element ) ; \nbyteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; \n} \nfinal byte [ ] array = new byte [ byteArrayList . size ( ) ] ; \nfor ( int i = 0 ; \ni < byteArrayList . size ( ) ; \ni ++ ) { \nfinal Byte b = byteArrayList . get ( i ) ; \narray [ i ] = b . byteValue ( ) ; \n} \nreturn array ; \n} \nif ( value instanceof CharSequence ) { \nfinal String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; \nreturn convertArrayToArray ( strings ) ; \n} \nreturn convertToSingleElementArray ( value ) ; \n} \n} \n"}
{"1771": "public class GzipFilter { \nprotected boolean isGzipEligible ( final HttpServletRequest request ) { \nif ( requestParameterName . length ( ) != 0 ) { \nString forceGzipString = request . getParameter ( requestParameterName ) ; \nif ( forceGzipString != null ) return Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; \n} \nString uri = request . getRequestURI ( ) ; \nif ( uri == null ) return false ; \nuri = uri . toLowerCase ( ) ; \nboolean result = false ; \nif ( matches == null ) { \nif ( extensions == null ) return true ; \nString extension = FileNameUtil . getExtension ( uri ) ; \nif ( extension . length ( ) > 0 ) { \nextension = extension . toLowerCase ( ) ; \nif ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) result = true ; \n} \n} \nelse if ( wildcards ) result = Wildcard . matchPathOne ( uri , matches ) != - 1 ; \nelse for ( String match : matches ) { \nif ( uri . contains ( match ) ) { \nresult = true ; \nbreak ; \n} \n} \nif ( ( result ) && ( excludes != null ) ) if ( wildcards ) if ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) result = false ; \nelse for ( String exclude : excludes ) { \nif ( uri . contains ( exclude ) ) { \nresult = false ; \nbreak ; \n} \n} \nreturn result ; \n} \n} \n"}
{"1773": "public class Vtor { \npublic List < Violation > validate ( final ValidationContext ctx , final Object target , final String targetName ) { \nfor ( Map . Entry < String , List < Check > > entry : ctx . map . entrySet ( ) ) { \nString name = entry . getKey ( ) ; \nObject value = BeanUtil . declaredSilent . getProperty ( target , name ) ; \nString valueName = targetName != null ? ( targetName + '.' + name ) : name ; \nValidationConstraintContext vcc = new ValidationConstraintContext ( this , target , valueName ) ; \nfor ( Check check : entry . getValue ( ) ) { \nString [ ] checkProfiles = check . getProfiles ( ) ; \nif ( ! matchProfiles ( checkProfiles ) ) continue ; \nif ( check . getSeverity ( ) < severity ) continue ; \nValidationConstraint constraint = check . getConstraint ( ) ; \nif ( ! constraint . isValid ( vcc , value ) ) addViolation ( new Violation ( valueName , target , value , check ) ) ; \n} \n} \nreturn getViolations ( ) ; \n} \n} \n"}
{"1774": "public class Vtor { \npublic void useProfile ( final String profile ) { \nif ( profile == null ) return ; \nif ( this . enabledProfiles == null ) this . enabledProfiles = new HashSet < > ( ) ; \nthis . enabledProfiles . add ( profile ) ; \n} \n} \n"}
{"1775": "public class Vtor { \npublic void useProfiles ( final String ... enabledProfiles ) { \nif ( enabledProfiles == null ) return ; \nif ( this . enabledProfiles == null ) this . enabledProfiles = new HashSet < > ( ) ; \nCollections . addAll ( this . enabledProfiles , enabledProfiles ) ; \n} \n} \n"}
{"1776": "public class Vtor { \nprotected boolean matchProfiles ( final String [ ] checkProfiles ) { \nif ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) return true ; \nif ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { \nif ( validateAllProfilesByDefault ) return true ; \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) return true ; \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) return true ; \nif ( profile . equals ( DEFAULT_PROFILE ) ) return true ; \n} \nreturn false ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) return enabledProfiles . contains ( DEFAULT_PROFILE ) ; \nboolean result = false ; \nfor ( String profile : checkProfiles ) { \nboolean b = true ; \nboolean must = false ; \nif ( StringUtil . isEmpty ( profile ) ) profile = DEFAULT_PROFILE ; \nelse if ( profile . charAt ( 0 ) == '-' ) { \nprofile = profile . substring ( 1 ) ; \nb = false ; \n} \nelse if ( profile . charAt ( 0 ) == '+' ) { \nprofile = profile . substring ( 1 ) ; \nmust = true ; \n} \nif ( enabledProfiles . contains ( profile ) ) { \nif ( ! b ) return false ; \nresult = true ; \n} \nelse if ( must ) return false ; \n} \nreturn result ; \n} \n} \n"}
{"1783": "public class LagartoParser { \nprotected void emitComment ( final int from , final int to ) { \nif ( config . enableConditionalComments ) { \nif ( match ( CC_IF , from ) ) { \nint endBracketNdx = find ( ']' , from + 3 , to ) ; \nCharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; \nndx = endBracketNdx + 1 ; \nchar c = input [ ndx ] ; \nif ( c != '>' ) errorInvalidToken ( ) ; \nvisitor . condComment ( expression , true , true , false ) ; \nstate = DATA_STATE ; \nreturn ; \n} \nif ( to > CC_ENDIF2 . length && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { \nvisitor . condComment ( _ENDIF , false , true , true ) ; \nstate = DATA_STATE ; \nreturn ; \n} \n} \nCharSequence comment = charSequence ( from , to ) ; \nvisitor . comment ( comment ) ; \ncommentStart = - 1 ; \n} \n} \n"}
{"1784": "public class LagartoParser { \nprotected void _error ( String message ) { \nif ( config . calculatePosition ) { \nPosition currentPosition = position ( ndx ) ; \nmessage = message . concat ( StringPool . SPACE ) . concat ( currentPosition . toString ( ) ) ; \n} \nelse message = message . concat ( \" [@\" ) . concat ( Integer . toString ( ndx ) ) . concat ( StringPool . RIGHT_SQ_BRACKET ) ; \nvisitor . error ( message ) ; \n} \n} \n"}
{"1787": "public class PBKDF2Hash { \nprivate static byte [ ] fromHex ( final String hex ) { \nfinal byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; \nfor ( int i = 0 ; \ni < binary . length ; \ni ++ ) binary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; \nreturn binary ; \n} \n} \n"}
{"1789": "public class EmailAttachmentBuilder { \npublic EmailAttachmentBuilder name ( final String name ) { \nif ( name != null && ! name . trim ( ) . isEmpty ( ) ) this . name = name ; \nreturn this ; \n} \n} \n"}
{"1790": "public class EmailAttachmentBuilder { \nprotected EmailAttachmentBuilder setContentIdFromNameIfMissing ( ) { \nif ( contentId == null ) if ( name != null ) contentId ( FileNameUtil . getName ( name ) ) ; \nelse contentId ( NO_NAME ) ; \nreturn this ; \n} \n} \n"}
{"1791": "public class EmailAttachmentBuilder { \nprotected String resolveContentType ( final String contentType ) { \nif ( contentType != null ) return contentType ; \nif ( name == null ) return MimeTypes . MIME_APPLICATION_OCTET_STREAM ; \nfinal String extension = FileNameUtil . getExtension ( name ) ; \nreturn MimeTypes . getMimeType ( extension ) ; \n} \n} \n"}
{"1792": "public class SignatureReader { \nprivate static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { \nint offset = startOffset ; \nchar currentChar = signature . charAt ( offset ++ ) ; \nswitch ( currentChar ) { \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; \nreturn offset ; \ncase '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; \ncase 'T' : int endOffset = signature . indexOf ( ';' , offset ) ; \nsignatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; \nreturn endOffset + 1 ; \ncase 'L' : int start = offset ; \nboolean visited = false ; \nboolean inner = false ; \nwhile ( true ) { \ncurrentChar = signature . charAt ( offset ++ ) ; \nif ( currentChar == '.' || currentChar == ';' ) { \nif ( ! visited ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) signatureVisitor . visitInnerClassType ( name ) ; \nelse signatureVisitor . visitClassType ( name ) ; \n} \nif ( currentChar == ';' ) { \nsignatureVisitor . visitEnd ( ) ; \nbreak ; \n} \nstart = offset ; \nvisited = false ; \ninner = true ; \n} \nelse if ( currentChar == '<' ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) signatureVisitor . visitInnerClassType ( name ) ; \nelse signatureVisitor . visitClassType ( name ) ; \nvisited = true ; \nwhile ( ( currentChar = signature . charAt ( offset ) ) != '>' ) switch ( currentChar ) { \ncase '*' : ++ offset ; \nsignatureVisitor . visitTypeArgument ( ) ; \nbreak ; \ncase '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; \nbreak ; \ndefault : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; \nbreak ; \n} \n} \n} \nreturn offset ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1794": "public class ModuleWriter { \nvoid putAttributes ( final ByteVector output ) { \nint moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; \nif ( packageCount > 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; \nif ( mainClassIndex > 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; \n} \n} \n"}
{"1798": "public class JoyDb { \nprotected void checkConnectionProvider ( ) { \nfinal Connection connection = connectionProvider . getConnection ( ) ; \ntry { \nfinal DatabaseMetaData databaseMetaData = connection . getMetaData ( ) ; \nString name = databaseMetaData . getDatabaseProductName ( ) ; \nString version = databaseMetaData . getDatabaseProductVersion ( ) ; \nif ( log . isInfoEnabled ( ) ) log . info ( \"Connected to database: \" + name + \" v\" + version ) ; \n} \ncatch ( SQLException sex ) { \nlog . error ( \"DB connection failed: \" , sex ) ; \n} \nfinally { \nconnectionProvider . closeConnection ( connection ) ; \n} \n} \n} \n"}
{"1800": "public class TargetClassInfoReader { \n@ Override public void visitEnd ( ) { \nif ( classAnnotations != null ) { \nannotations = classAnnotations . toArray ( new AnnotationInfo [ 0 ] ) ; \nclassAnnotations = null ; \n} \nList < String > superList = new ArrayList < > ( ) ; \nSet < String > allInterfaces = new HashSet < > ( ) ; \nif ( nextInterfaces != null ) allInterfaces . addAll ( nextInterfaces ) ; \nwhile ( nextSupername != null ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( nextSupername , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super class: \" + nextSupername , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperList . add ( nextSupername ) ; \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) Collections . addAll ( allInterfaces , cr . getInterfaces ( ) ) ; \n} \nsuperClasses = superList . toArray ( new String [ 0 ] ) ; \nSet < String > todoInterfaces = new HashSet < > ( allInterfaces ) ; \nSet < String > newCollectedInterfaces = new HashSet < > ( ) ; \nwhile ( true ) { \nfor ( String next : todoInterfaces ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( next , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super interface: \" + next , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) for ( String newInterface : cr . getInterfaces ( ) ) { \nif ( ! allInterfaces . contains ( newInterface ) && ! todoInterfaces . contains ( newInterface ) ) newCollectedInterfaces . add ( newInterface ) ; \n} \n} \nallInterfaces . addAll ( todoInterfaces ) ; \nif ( newCollectedInterfaces . isEmpty ( ) ) break ; \ntodoInterfaces . clear ( ) ; \ntodoInterfaces . addAll ( newCollectedInterfaces ) ; \nnewCollectedInterfaces . clear ( ) ; \n} \n} \n} \n"}
{"1802": "public class CsvUtil { \npublic static String toCsvString ( final Object ... elements ) { \nStringBuilder line = new StringBuilder ( ) ; \nint last = elements . length - 1 ; \nfor ( int i = 0 ; \ni < elements . length ; \ni ++ ) { \nif ( elements [ i ] == null ) { \nif ( i != last ) line . append ( FIELD_SEPARATOR ) ; \ncontinue ; \n} \nString field = elements [ i ] . toString ( ) ; \nint ndx = field . indexOf ( FIELD_SEPARATOR ) ; \nif ( ndx == - 1 ) ndx = field . indexOf ( FIELD_QUOTE ) ; \nif ( ndx == - 1 ) if ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) ndx = 1 ; \nif ( ndx == - 1 ) ndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; \nif ( ndx != - 1 ) line . append ( FIELD_QUOTE ) ; \nfield = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; \nline . append ( field ) ; \nif ( ndx != - 1 ) line . append ( FIELD_QUOTE ) ; \nif ( i != last ) line . append ( FIELD_SEPARATOR ) ; \n} \nreturn line . toString ( ) ; \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) if ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \nelse if ( c == FIELD_QUOTE ) if ( inQuotedField ) if ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \nelse if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \n} \nif ( len > 0 && fieldStart <= len ) addField ( row , line , fieldStart , len , inQuotedField ) ; \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1804": "public class CtorResolver { \npublic CtorInjectionPoint resolve ( final Class type , final boolean useAnnotation ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nCtorDescriptor [ ] allCtors = cd . getAllCtorDescriptors ( ) ; \nConstructor foundedCtor = null ; \nConstructor defaultCtor = null ; \nBeanReferences [ ] references = null ; \nfor ( CtorDescriptor ctorDescriptor : allCtors ) { \nConstructor < ? > ctor = ctorDescriptor . getConstructor ( ) ; \nClass < ? > [ ] paramTypes = ctor . getParameterTypes ( ) ; \nif ( paramTypes . length == 0 ) defaultCtor = ctor ; \nif ( ! useAnnotation ) continue ; \nBeanReferences [ ] ctorReferences = referencesResolver . readAllReferencesFromAnnotation ( ctor ) ; \nif ( ctorReferences == null ) continue ; \nif ( foundedCtor != null ) throw new PetiteException ( \"Two or more constructors are annotated as injection points in the bean: \" + type . getName ( ) ) ; \nfoundedCtor = ctor ; \nreferences = ctorReferences ; \n} \nif ( foundedCtor == null ) { \nif ( allCtors . length == 1 ) foundedCtor = allCtors [ 0 ] . getConstructor ( ) ; \nelse foundedCtor = defaultCtor ; \nif ( foundedCtor == null ) return CtorInjectionPoint . EMPTY ; \nreferences = referencesResolver . readAllReferencesFromAnnotation ( foundedCtor ) ; \nif ( references == null ) references = new BeanReferences [ 0 ] ; \n} \nreturn new CtorInjectionPoint ( foundedCtor , references ) ; \n} \n} \n"}
{"1806": "public class ProxyAspectData { \nprivate ClassReader getCachedAdviceClassReader ( final Class < ? extends ProxyAdvice > advice ) { \nif ( adviceClassReaderCache == null ) adviceClassReaderCache = TypeCache . createDefault ( ) ; \nClassReader adviceReader = adviceClassReaderCache . get ( advice ) ; \nif ( adviceReader == null ) { \nadviceReader = createAdviceClassReader ( advice ) ; \nadviceClassReaderCache . put ( advice , adviceReader ) ; \n} \nreturn adviceReader ; \n} \n} \n"}
{"1809": "public class LoggerFactory { \npublic static Logger getLogger ( final String name ) { \nif ( loggers == null ) return loggerProvider . apply ( name ) ; \nreturn loggers . computeIfAbsent ( name , loggerProvider ) ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) throw new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \nfor ( int n = 0 ; \nn < name . length ( ) ; \nn ++ ) { \nchar c = name . charAt ( n ) ; \nif ( c <= 0x20 || c >= 0x7f ) throw new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nthis . name = name ; \n} \n} \n"}
{"1813": "public class ShutdownAwareScope { \nprotected void destroyBean ( final BeanData beanData ) { \nif ( destroyableBeans == null ) return ; \nif ( ! isBeanDestroyable ( beanData ) ) return ; \nif ( destroyableBeans . remove ( beanData ) ) beanData . callDestroyMethods ( ) ; \n} \n} \n"}
{"1814": "public class ShutdownAwareScope { \n@ Override public void shutdown ( ) { \nif ( destroyableBeans == null ) return ; \nfor ( final BeanData destroyableBean : destroyableBeans ) { \ndestroyableBean . callDestroyMethods ( ) ; \n} \ndestroyableBeans . clear ( ) ; \n} \n} \n"}
{"1815": "public class ReceiverBuilder { \npublic ReceivedEmail [ ] get ( ) { \nif ( fromFolder != null ) session . useFolder ( fromFolder ) ; \nreturn session . receiveMessages ( filter , flagsToSet , flagsToUnset , envelopeOnly , messages -> { \nif ( targetFolder != null ) try { \nsession . folder . copyMessages ( messages , session . getFolder ( targetFolder ) ) ; \n} \ncatch ( MessagingException e ) { \nthrow new MailException ( \"Copying messages failed\" ) ; \n} \n} \n) ; \n} \n} \n"}
{"1821": "public class ReplayMerge { \npublic void close ( ) { \nfinal State state = this . state ; \nif ( State . CLOSED != state ) { \nif ( isReplayActive ) { \nisReplayActive = false ; \narchive . stopReplay ( replaySessionId ) ; \n} \nif ( State . MERGED != state ) subscription . removeDestination ( replayDestination ) ; \nstate ( State . CLOSED ) ; \n} \n} \n} \n"}
{"1823": "public class Publication { \npublic long position ( ) { \nif ( isClosed ) return CLOSED ; \nfinal long rawTail = rawTailVolatile ( logMetaDataBuffer ) ; \nfinal int termOffset = termOffset ( rawTail , termBufferLength ) ; \nreturn computePosition ( termId ( rawTail ) , termOffset , positionBitsToShift , initialTermId ) ; \n} \n} \n"}
{"1824": "public class ExclusivePublication { \npublic long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { \nfinal int length = DirectBufferVector . validateAndComputeLength ( vectors ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( position < limit ) { \nfinal int result ; \nif ( length <= maxPayloadLength ) result = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; \nelse { \ncheckMaxMessageLength ( length ) ; \nresult = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; \n} \nnewPosition = newPosition ( result ) ; \n} \nelse newPosition = backPressureStatus ( position , length ) ; \n} \nreturn newPosition ; \n} \n} \n"}
{"1825": "public class ExclusivePublication { \npublic long appendPadding ( final int length ) { \ncheckMaxMessageLength ( length ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( position < limit ) { \ncheckPositiveLength ( length ) ; \nfinal int result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; \nnewPosition = newPosition ( result ) ; \n} \nelse newPosition = backPressureStatus ( position , length ) ; \n} \nreturn newPosition ; \n} \n} \n"}
{"1827": "public class AeronArchive { \npublic String pollForErrorResponse ( ) { \nlock . lock ( ) ; \ntry { \nensureOpen ( ) ; \nif ( controlResponsePoller . poll ( ) != 0 && controlResponsePoller . isPollComplete ( ) ) if ( controlResponsePoller . controlSessionId ( ) == controlSessionId && controlResponsePoller . templateId ( ) == ControlResponseDecoder . TEMPLATE_ID && controlResponsePoller . code ( ) == ControlResponseCode . ERROR ) return controlResponsePoller . errorMessage ( ) ; \nreturn null ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"1828": "public class AeronArchive { \npublic void stopReplay ( final long replaySessionId ) { \nlock . lock ( ) ; \ntry { \nensureOpen ( ) ; \nfinal long correlationId = aeron . nextCorrelationId ( ) ; \nif ( ! archiveProxy . stopReplay ( replaySessionId , correlationId , controlSessionId ) ) throw new ArchiveException ( \"failed to send stop replay request\" ) ; \npollForResponse ( correlationId ) ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"1831": "public class StatusUtil { \npublic static StatusIndicatorReader sendChannelStatus ( final CountersReader countersReader , final String channel ) { \nStatusIndicatorReader statusReader = null ; \nfinal MutableInteger id = new MutableInteger ( - 1 ) ; \ncountersReader . forEach ( ( counterId , typeId , keyBuffer , label ) -> { \nif ( typeId == SendChannelStatus . SEND_CHANNEL_STATUS_TYPE_ID ) if ( channel . startsWith ( keyBuffer . getStringAscii ( ChannelEndpointStatus . CHANNEL_OFFSET ) ) ) id . value = counterId ; \n} \n) ; \nif ( Aeron . NULL_VALUE != id . value ) statusReader = new UnsafeBufferStatusIndicator ( countersReader . valuesBuffer ( ) , id . value ) ; \nreturn statusReader ; \n} \n} \n"}
{"1832": "public class StatusUtil { \npublic static StatusIndicatorReader receiveChannelStatus ( final CountersReader countersReader , final String channel ) { \nStatusIndicatorReader statusReader = null ; \nfinal MutableInteger id = new MutableInteger ( - 1 ) ; \ncountersReader . forEach ( ( counterId , typeId , keyBuffer , label ) -> { \nif ( typeId == ReceiveChannelStatus . RECEIVE_CHANNEL_STATUS_TYPE_ID ) if ( channel . startsWith ( keyBuffer . getStringAscii ( ChannelEndpointStatus . CHANNEL_OFFSET ) ) ) id . value = counterId ; \n} \n) ; \nif ( Aeron . NULL_VALUE != id . value ) statusReader = new UnsafeBufferStatusIndicator ( countersReader . valuesBuffer ( ) , id . value ) ; \nreturn statusReader ; \n} \n} \n"}
{"1833": "public class BufferBuilder { \npublic void limit ( final int limit ) { \nif ( limit < 0 || limit >= buffer . capacity ( ) ) throw new IllegalArgumentException ( \"limit outside range: capacity=\" + buffer . capacity ( ) + \" limit=\" + limit ) ; \nthis . limit = limit ; \n} \n} \n"}
{"1839": "public class CounterMessageFlyweight { \npublic CounterMessageFlyweight keyBuffer ( final DirectBuffer keyBuffer , final int keyOffset , final int keyLength ) { \nbuffer . putInt ( KEY_LENGTH_OFFSET , keyLength ) ; \nif ( null != keyBuffer && keyLength > 0 ) buffer . putBytes ( keyBufferOffset ( ) , keyBuffer , keyOffset , keyLength ) ; \nreturn this ; \n} \n} \n"}
{"1855": "public class UdpChannel { \npublic boolean matchesTag ( final UdpChannel udpChannel ) { \nif ( ! hasTag || ! udpChannel . hasTag ( ) || tag != udpChannel . tag ( ) ) return false ; \nif ( udpChannel . remoteData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . remoteData ( ) . getPort ( ) == 0 && udpChannel . localData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . localData ( ) . getPort ( ) == 0 ) return true ; \nthrow new IllegalArgumentException ( \"matching tag has set endpoint or control address\" ) ; \n} \n} \n"}
{"1857": "public class UdpChannel { \npublic String description ( ) { \nfinal StringBuilder builder = new StringBuilder ( \"UdpChannel - \" ) ; \nif ( null != localInterface ) builder . append ( \"interface: \" ) . append ( localInterface . getDisplayName ( ) ) . append ( \", \" ) ; \nbuilder . append ( \"localData: \" ) . append ( localData ) . append ( \", remoteData: \" ) . append ( remoteData ) . append ( \", ttl: \" ) . append ( multicastTtl ) ; \nreturn builder . toString ( ) ; \n} \n} \n"}
{"1858": "public class PublicationImage { \nvoid addDestination ( final int transportIndex , final ReceiveDestinationUdpTransport transport ) { \nimageConnections = ArrayUtil . ensureCapacity ( imageConnections , transportIndex + 1 ) ; \nif ( transport . isMulticast ( ) ) imageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . udpChannel ( ) . remoteControl ( ) ) ; \nelse if ( transport . hasExplicitControl ( ) ) imageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . explicitControlAddress ( ) ) ; \n} \n} \n"}
{"1860": "public class ClusterControl { \npublic static AtomicCounter findControlToggle ( final CountersReader counters ) { \nfinal AtomicBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) return new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; \n} \nreturn null ; \n} \n} \n"}
{"1866": "public class ExclusiveTermAppender { \npublic int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { \nfinal int frameLength = length + HEADER_LENGTH ; \nfinal int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nfinal UnsafeBuffer termBuffer = this . termBuffer ; \nfinal int termLength = termBuffer . capacity ( ) ; \nint resultingOffset = termOffset + alignedLength ; \nputRawTailOrdered ( termId , resultingOffset ) ; \nif ( resultingOffset > termLength ) resultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; \nelse { \nheader . write ( termBuffer , termOffset , frameLength , termId ) ; \nframeType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; \nframeLengthOrdered ( termBuffer , termOffset , frameLength ) ; \n} \nreturn resultingOffset ; \n} \n} \n"}
{"1867": "public class NetworkPublication { \nfinal int updatePublisherLimit ( ) { \nint workCount = 0 ; \nfinal long senderPosition = this . senderPosition . getVolatile ( ) ; \nif ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) { \nlong minConsumerPosition = senderPosition ; \nfor ( final ReadablePosition spyPosition : spyPositions ) { \nminConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; \n} \nfinal long proposedPublisherLimit = minConsumerPosition + termWindowLength ; \nif ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { \ncleanBuffer ( proposedPublisherLimit ) ; \nworkCount = 1 ; \n} \n} \nelse if ( publisherLimit . get ( ) > senderPosition ) publisherLimit . setOrdered ( senderPosition ) ; \nreturn workCount ; \n} \n} \n"}
{"1870": "public class TermScanner { \npublic static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { \nfinal int limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; \nint available = 0 ; \nint padding = 0 ; \ndo { \nfinal int termOffset = offset + available ; \nfinal int frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; \nif ( frameLength <= 0 ) break ; \nint alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nif ( isPaddingFrame ( termBuffer , termOffset ) ) { \npadding = alignedFrameLength - HEADER_LENGTH ; \nalignedFrameLength = HEADER_LENGTH ; \n} \navailable += alignedFrameLength ; \nif ( available > limit ) { \navailable -= alignedFrameLength ; \npadding = 0 ; \nbreak ; \n} \n} \nwhile ( 0 == padding && available < limit ) ; \nreturn pack ( padding , available ) ; \n} \n} \n"}
{"1872": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder validate ( ) { \nif ( null == media ) throw new IllegalStateException ( \"media type is mandatory\" ) ; \nif ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) throw new IllegalStateException ( \"either 'endpoint' or 'control' must be specified for UDP.\" ) ; \nint count = 0 ; \ncount += null == initialTermId ? 0 : 1 ; \ncount += null == termId ? 0 : 1 ; \ncount += null == termOffset ? 0 : 1 ; \nif ( count > 0 ) { \nif ( count < 3 ) throw new IllegalStateException ( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\" ) ; \nif ( termId - initialTermId < 0 ) throw new IllegalStateException ( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId ) ; \nif ( null != termLength && termOffset > termLength ) throw new IllegalStateException ( \"termOffset=\" + termOffset + \" > termLength=\" + termLength ) ; \n} \nreturn this ; \n} \n} \n"}
{"1873": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder prefix ( final String prefix ) { \nif ( null != prefix && ! prefix . equals ( \"\" ) && ! prefix . equals ( SPY_QUALIFIER ) ) throw new IllegalArgumentException ( \"invalid prefix: \" + prefix ) ; \nthis . prefix = prefix ; \nreturn this ; \n} \n} \n"}
{"1875": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder controlMode ( final String controlMode ) { \nif ( null != controlMode && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_MANUAL ) && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_DYNAMIC ) ) throw new IllegalArgumentException ( \"invalid control mode: \" + controlMode ) ; \nthis . controlMode = controlMode ; \nreturn this ; \n} \n} \n"}
{"1876": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder termLength ( final Integer termLength ) { \nif ( null != termLength ) LogBufferDescriptor . checkTermLength ( termLength ) ; \nthis . termLength = termLength ; \nreturn this ; \n} \n} \n"}
{"1877": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder termOffset ( final Integer termOffset ) { \nif ( null != termOffset ) { \nif ( ( termOffset < 0 || termOffset > LogBufferDescriptor . TERM_MAX_LENGTH ) ) throw new IllegalArgumentException ( \"term offset not in range 0-1g: \" + termOffset ) ; \nif ( 0 != ( termOffset & ( FRAME_ALIGNMENT - 1 ) ) ) throw new IllegalArgumentException ( \"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset ) ; \n} \nthis . termOffset = termOffset ; \nreturn this ; \n} \n} \n"}
{"1878": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder linger ( final Long lingerNs ) { \nif ( null != lingerNs && lingerNs < 0 ) throw new IllegalArgumentException ( \"linger value cannot be negative: \" + lingerNs ) ; \nthis . linger = lingerNs ; \nreturn this ; \n} \n} \n"}
{"1879": "public class UdpChannelTransport { \npublic void openDatagramChannel ( final AtomicCounter statusIndicator ) { \ntry { \nsendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \nreceiveDatagramChannel = sendDatagramChannel ; \nif ( udpChannel . isMulticast ( ) ) { \nif ( null != connectAddress ) receiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \nreceiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; \nreceiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; \nreceiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( ) ) ; \nif ( udpChannel . isHasMulticastTtl ( ) ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , udpChannel . multicastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \nelse if ( context . socketMulticastTtl ( ) != 0 ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , context . socketMulticastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \n} \nelse sendDatagramChannel . bind ( bindAddress ) ; \nif ( null != connectAddress ) sendDatagramChannel . connect ( connectAddress ) ; \nif ( 0 != context . socketSndbufLength ( ) ) sendDatagramChannel . setOption ( SO_SNDBUF , context . socketSndbufLength ( ) ) ; \nif ( 0 != context . socketRcvbufLength ( ) ) receiveDatagramChannel . setOption ( SO_RCVBUF , context . socketRcvbufLength ( ) ) ; \nsendDatagramChannel . configureBlocking ( false ) ; \nreceiveDatagramChannel . configureBlocking ( false ) ; \n} \ncatch ( final IOException ex ) { \nif ( null != statusIndicator ) statusIndicator . setOrdered ( ChannelEndpointStatus . ERRORED ) ; \nCloseHelper . quietClose ( sendDatagramChannel ) ; \nif ( receiveDatagramChannel != sendDatagramChannel ) CloseHelper . quietClose ( receiveDatagramChannel ) ; \nsendDatagramChannel = null ; \nreceiveDatagramChannel = null ; \nthrow new AeronException ( \"channel error - \" + ex . getMessage ( ) + \" (at \" + ex . getStackTrace ( ) [ 0 ] . toString ( ) + \"): \" + udpChannel . originalUriString ( ) , ex ) ; \n} \n} \n} \n"}
{"1880": "public class UdpChannelTransport { \npublic void close ( ) { \nif ( ! isClosed ) { \nisClosed = true ; \ntry { \nif ( null != selectionKey ) selectionKey . cancel ( ) ; \nif ( null != transportPoller ) { \ntransportPoller . cancelRead ( this ) ; \ntransportPoller . selectNowWithoutProcessing ( ) ; \n} \nif ( null != sendDatagramChannel ) sendDatagramChannel . close ( ) ; \nif ( receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel ) receiveDatagramChannel . close ( ) ; \nif ( null != transportPoller ) transportPoller . selectNowWithoutProcessing ( ) ; \n} \ncatch ( final IOException ex ) { \nerrorLog . record ( ex ) ; \n} \n} \n} \n} \n"}
{"1882": "public class UdpChannelTransport { \npublic InetSocketAddress receive ( final ByteBuffer buffer ) { \nbuffer . clear ( ) ; \nInetSocketAddress address = null ; \ntry { \nif ( receiveDatagramChannel . isOpen ( ) ) address = ( InetSocketAddress ) receiveDatagramChannel . receive ( buffer ) ; \n} \ncatch ( final PortUnreachableException ignored ) { \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \nreturn address ; \n} \n} \n"}
{"1883": "public class RetransmitHandler { \npublic void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { \nif ( ! isInvalid ( termOffset , termLength ) ) if ( null == activeRetransmitsMap . get ( termId , termOffset ) && activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { \nfinal RetransmitAction action = assignRetransmitAction ( ) ; \naction . termId = termId ; \naction . termOffset = termOffset ; \naction . length = Math . min ( length , termLength - termOffset ) ; \nfinal long delay = delayGenerator . generateDelay ( ) ; \nif ( 0 == delay ) { \nretransmitSender . resend ( termId , termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse action . delay ( delay , nanoClock . nanoTime ( ) ) ; \nactiveRetransmitsMap . put ( termId , termOffset , action ) ; \n} \n} \n} \n"}
{"1884": "public class RetransmitHandler { \npublic void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { \nif ( activeRetransmitsMap . size ( ) > 0 ) for ( final RetransmitAction action : retransmitActionPool ) { \nif ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { \nretransmitSender . resend ( action . termId , action . termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse if ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { \naction . cancel ( ) ; \nactiveRetransmitsMap . remove ( action . termId , action . termOffset ) ; \n} \n} \n} \n} \n"}
{"1885": "public class ChannelEndpointStatus { \npublic static String status ( final long status ) { \nif ( INITIALIZING == status ) return \"INITIALIZING\" ; \nif ( ERRORED == status ) return \"ERRORED\" ; \nif ( ACTIVE == status ) return \"ACTIVE\" ; \nif ( CLOSING == status ) return \"CLOSING\" ; \nreturn \"unknown id=\" + status ; \n} \n} \n"}
{"1888": "public class DirectBufferVector { \npublic DirectBufferVector validate ( ) { \nfinal int capacity = buffer . capacity ( ) ; \nif ( offset < 0 || offset >= capacity ) throw new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity ) ; \nif ( length < 0 || length > ( capacity - offset ) ) throw new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length ) ; \nreturn this ; \n} \n} \n"}
{"1889": "public class DirectBufferVector { \npublic static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { \nint messageLength = 0 ; \nfor ( final DirectBufferVector vector : vectors ) { \nvector . validate ( ) ; \nmessageLength += vector . length ; \nif ( messageLength < 0 ) throw new IllegalStateException ( \"length overflow: \" + Arrays . toString ( vectors ) ) ; \n} \nreturn messageLength ; \n} \n} \n"}
{"1890": "public class Configuration { \npublic static int producerWindowLength ( final int termBufferLength , final int defaultTermWindowLength ) { \nint termWindowLength = termBufferLength / 2 ; \nif ( 0 != defaultTermWindowLength ) termWindowLength = Math . min ( defaultTermWindowLength , termWindowLength ) ; \nreturn termWindowLength ; \n} \n} \n"}
{"1891": "public class Configuration { \npublic static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { \ntry ( DatagramChannel probe = DatagramChannel . open ( ) ) { \nfinal int defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nprobe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; \nfinal int maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nif ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) System . err . format ( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; \nprobe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; \nfinal int maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; \nif ( maxSoRcvBuf < ctx . socketRcvbufLength ( ) ) System . err . format ( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; \nfinal int soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; \nif ( ctx . mtuLength ( ) > soSndBuf ) throw new ConfigurationException ( String . format ( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; \nif ( ctx . initialWindowLength ( ) > maxSoRcvBuf ) throw new ConfigurationException ( \"window length greater than socket SO_RCVBUF, increase '\" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx . initialWindowLength ( ) + \", SO_RCVBUF=\" + maxSoRcvBuf ) ; \n} \ncatch ( final IOException ex ) { \nthrow new AeronException ( \"probe socket: \" + ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1892": "public class Configuration { \npublic static void validatePageSize ( final int pageSize ) { \nif ( pageSize < PAGE_MIN_SIZE ) throw new ConfigurationException ( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize ) ; \nif ( pageSize > PAGE_MAX_SIZE ) throw new ConfigurationException ( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize ) ; \nif ( ! BitUtil . isPowerOfTwo ( pageSize ) ) throw new ConfigurationException ( \"page size not a power of 2: \" + pageSize ) ; \n} \n} \n"}
{"1893": "public class Configuration { \npublic static void validateSessionIdRange ( final int low , final int high ) { \nif ( low > high ) throw new ConfigurationException ( \"low session id value \" + low + \" must be <= high value \" + high ) ; \nif ( Math . abs ( ( long ) high - low ) > Integer . MAX_VALUE ) throw new ConfigurationException ( \"reserved range to too large\" ) ; \n} \n} \n"}
{"1894": "public class Configuration { \npublic static void validateUnblockTimeout ( final long publicationUnblockTimeoutNs , final long clientLivenessTimeoutNs , final long timerIntervalNs ) { \nif ( publicationUnblockTimeoutNs <= clientLivenessTimeoutNs ) throw new ConfigurationException ( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs ) ; \nif ( clientLivenessTimeoutNs <= timerIntervalNs ) throw new ConfigurationException ( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs ) ; \n} \n} \n"}
{"1897": "public class ClusterMember { \npublic static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( int i = 0 , length = clusterMembers . length ; \ni < length ; \ni ++ ) { \nfinal ClusterMember member = clusterMembers [ i ] ; \nbuilder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; \nif ( ( length - 1 ) != i ) builder . append ( '|' ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"1900": "public class ClusterMember { \npublic static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { \nint threshold = quorumThreshold ( clusterMembers . length ) ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) if ( -- threshold <= 0 ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"1901": "public class ClusterMember { \npublic static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { \nfinal int length = rankedPositions . length ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) rankedPositions [ i ] = 0 ; \nfor ( final ClusterMember member : members ) { \nlong newPosition = member . logPosition ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nfinal long rankedPosition = rankedPositions [ i ] ; \nif ( newPosition > rankedPosition ) { \nrankedPositions [ i ] = newPosition ; \nnewPosition = rankedPosition ; \n} \n} \n} \nreturn rankedPositions [ length - 1 ] ; \n} \n} \n"}
{"1903": "public class ClusterMember { \npublic static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . vote != null && ( member . logPosition < position || member . leadershipTermId != leadershipTermId ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1904": "public class ClusterMember { \npublic static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : members ) { \nif ( null == member . vote || member . candidateTermId != candidateTermId ) return false ; \nvotes += member . vote ? 1 : 0 ; \n} \nreturn votes >= ClusterMember . quorumThreshold ( members . length ) ; \n} \n} \n"}
{"1905": "public class ClusterMember { \npublic static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) ++ votes ; \n} \nreturn votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1906": "public class ClusterMember { \npublic static ClusterMember determineMember ( final ClusterMember [ ] clusterMembers , final int memberId , final String memberEndpoints ) { \nClusterMember member = NULL_VALUE != memberId ? ClusterMember . findMember ( clusterMembers , memberId ) : null ; \nif ( ( null == clusterMembers || 0 == clusterMembers . length ) && null == member ) member = ClusterMember . parseEndpoints ( NULL_VALUE , memberEndpoints ) ; \nelse { \nif ( null == member ) throw new ClusterException ( \"memberId=\" + memberId + \" not found in clusterMembers\" ) ; \nif ( ! \"\" . equals ( memberEndpoints ) ) ClusterMember . validateMemberEndpoints ( member , memberEndpoints ) ; \n} \nreturn member ; \n} \n} \n"}
{"1907": "public class ClusterMember { \npublic static void validateMemberEndpoints ( final ClusterMember member , final String memberEndpoints ) { \nfinal ClusterMember endpointMember = ClusterMember . parseEndpoints ( Aeron . NULL_VALUE , memberEndpoints ) ; \nif ( ! areSameEndpoints ( member , endpointMember ) ) throw new ClusterException ( \"clusterMembers and memberEndpoints differ: \" + member . endpointsDetail ( ) + \" != \" + memberEndpoints ) ; \n} \n} \n"}
{"1909": "public class ClusterMember { \npublic static boolean isUnanimousCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1910": "public class ClusterMember { \npublic static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nint possibleVotes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) continue ; \n++ possibleVotes ; \n} \nreturn possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1911": "public class ClusterMember { \npublic static boolean isNotDuplicateEndpoints ( final ClusterMember [ ] members , final String memberEndpoints ) { \nfor ( final ClusterMember member : members ) { \nif ( member . endpointsDetail ( ) . equals ( memberEndpoints ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"1912": "public class ClusterMember { \npublic static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { \nfinal int length = clusterMembers . length ; \nint index = ArrayUtil . UNKNOWN_INDEX ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) if ( clusterMembers [ i ] . id ( ) == memberId ) index = i ; \nreturn index ; \n} \n} \n"}
{"1915": "public class CommonContext { \npublic MappedByteBuffer mapExistingCncFile ( final Consumer < String > logger ) { \nfinal File cncFile = new File ( aeronDirectory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { \nif ( null != logger ) logger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; \nreturn IoUtil . mapExistingFile ( cncFile , CncFileDescriptor . CNC_FILE ) ; \n} \nreturn null ; \n} \n} \n"}
{"1918": "public class CommonContext { \npublic static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { \nif ( null == cncByteBuffer ) return false ; \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal long startTimeMs = System . currentTimeMillis ( ) ; \nint cncVersion ; \nwhile ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { \nif ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) throw new DriverTimeoutException ( \"CnC file is created but not initialised.\" ) ; \nsleep ( 1 ) ; \n} \nif ( CNC_VERSION != cncVersion ) throw new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; \nfinal long now = System . currentTimeMillis ( ) ; \nfinal long timestampAge = now - timestamp ; \nlogger . accept ( \"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge ) ; \nreturn timestampAge <= driverTimeoutMs ; \n} \n} \n"}
{"1919": "public class CommonContext { \npublic static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal int cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; \nif ( CncFileDescriptor . CNC_VERSION != cncVersion ) throw new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long clientId = toDriverBuffer . nextCorrelationId ( ) ; \nfinal DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; \nreturn driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1920": "public class FrameDescriptor { \npublic static int frameLengthVolatile ( final UnsafeBuffer buffer , final int termOffset ) { \nint frameLength = buffer . getIntVolatile ( termOffset ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) frameLength = Integer . reverseBytes ( frameLength ) ; \nreturn frameLength ; \n} \n} \n"}
{"1921": "public class FrameDescriptor { \npublic static void frameLengthOrdered ( final UnsafeBuffer buffer , final int termOffset , final int frameLength ) { \nint length = frameLength ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) length = Integer . reverseBytes ( frameLength ) ; \nbuffer . putIntOrdered ( termOffset , length ) ; \n} \n} \n"}
{"1926": "public class RecordingPos { \npublic static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni ++ ) if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) return i ; \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1927": "public class RecordingPos { \npublic static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni ++ ) if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) return i ; \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1928": "public class RecordingPos { \npublic static long getRecordingId ( final CountersReader countersReader , final int counterId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nif ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) return buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) ; \n} \nreturn NULL_RECORDING_ID ; \n} \n} \n"}
{"1932": "public class RecordingLog { \npublic Entry findLastTerm ( ) { \nfor ( int i = entries . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( ENTRY_TYPE_TERM == entry . type ) return entry ; \n} \nreturn null ; \n} \n} \n"}
{"1935": "public class RecordingLog { \npublic void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { \nfinal int size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry lastEntry = entries . get ( size - 1 ) ; \nif ( lastEntry . type != NULL_VALUE && lastEntry . leadershipTermId >= leadershipTermId ) throw new ClusterException ( \"leadershipTermId out of sequence: previous \" + lastEntry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \nindexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; \nappend ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; \n} \n} \n"}
{"1936": "public class RecordingLog { \npublic void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { \nfinal int size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry entry = entries . get ( size - 1 ) ; \nif ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) throw new ClusterException ( \"leadershipTermId out of sequence: previous \" + entry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \nappend ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nint index = - 1 ; \nfor ( int i = 0 , size = entries . size ( ) ; \ni < size ; \ni ++ ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) indexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \nbreak ; \n} \n} \nif ( - 1 == index ) throw new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) throw new ClusterException ( \"failed to write field atomically\" ) ; \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1939": "public class AeronCluster { \npublic void close ( ) { \nif ( null != publication && publication . isConnected ( ) ) closeSession ( ) ; \nif ( ! ctx . ownsAeronClient ( ) ) { \nCloseHelper . close ( subscription ) ; \nCloseHelper . close ( publication ) ; \n} \nctx . close ( ) ; \n} \n} \n"}
{"1940": "public class AeronCluster { \npublic long offer ( final DirectBufferVector [ ] vectors ) { \nif ( headerVector != vectors [ 0 ] ) vectors [ 0 ] = headerVector ; \nreturn publication . offer ( vectors , null ) ; \n} \n} \n"}
{"1944": "public class LogBufferDescriptor { \npublic static void checkTermLength ( final int termLength ) { \nif ( termLength < TERM_MIN_LENGTH ) throw new IllegalStateException ( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength ) ; \nif ( termLength > TERM_MAX_LENGTH ) throw new IllegalStateException ( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength ) ; \nif ( ! BitUtil . isPowerOfTwo ( termLength ) ) throw new IllegalStateException ( \"Term length not a power of 2: length=\" + termLength ) ; \n} \n} \n"}
{"1945": "public class LogBufferDescriptor { \npublic static void checkPageSize ( final int pageSize ) { \nif ( pageSize < PAGE_MIN_SIZE ) throw new IllegalStateException ( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize ) ; \nif ( pageSize > PAGE_MAX_SIZE ) throw new IllegalStateException ( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize ) ; \nif ( ! BitUtil . isPowerOfTwo ( pageSize ) ) throw new IllegalStateException ( \"Page size not a power of 2: page size=\" + pageSize ) ; \n} \n} \n"}
{"1948": "public class LogBufferDescriptor { \npublic static long computeLogLength ( final int termLength , final int filePageSize ) { \nif ( termLength < ( 1024 * 1024 * 1024 ) ) return align ( ( termLength * PARTITION_COUNT ) + LOG_META_DATA_LENGTH , filePageSize ) ; \nreturn ( PARTITION_COUNT * ( long ) termLength ) + align ( LOG_META_DATA_LENGTH , filePageSize ) ; \n} \n} \n"}
{"1949": "public class LogBufferDescriptor { \npublic static void storeDefaultFrameHeader ( final UnsafeBuffer metadataBuffer , final DirectBuffer defaultHeader ) { \nif ( defaultHeader . capacity ( ) != HEADER_LENGTH ) throw new IllegalArgumentException ( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader . capacity ( ) ) ; \nmetadataBuffer . putInt ( LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET , HEADER_LENGTH ) ; \nmetadataBuffer . putBytes ( LOG_DEFAULT_FRAME_HEADER_OFFSET , defaultHeader , 0 , HEADER_LENGTH ) ; \n} \n} \n"}
{"1951": "public class LogBufferDescriptor { \npublic static boolean rotateLog ( final UnsafeBuffer metadataBuffer , final int termCount , final int termId ) { \nfinal int nextTermId = termId + 1 ; \nfinal int nextTermCount = termCount + 1 ; \nfinal int nextIndex = indexByTermCount ( nextTermCount ) ; \nfinal int expectedTermId = nextTermId - PARTITION_COUNT ; \nlong rawTail ; \ndo { \nrawTail = rawTail ( metadataBuffer , nextIndex ) ; \nif ( expectedTermId != termId ( rawTail ) ) break ; \n} \nwhile ( ! casRawTail ( metadataBuffer , nextIndex , rawTail , packTail ( nextTermId , 0 ) ) ) ; \nreturn casActiveTermCount ( metadataBuffer , termCount , nextTermCount ) ; \n} \n} \n"}
{"1956": "public class TerminateDriverFlyweight { \npublic TerminateDriverFlyweight tokenBuffer ( final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nbuffer . putInt ( TOKEN_LENGTH_OFFSET , tokenLength ) ; \nif ( null != tokenBuffer && tokenLength > 0 ) buffer . putBytes ( tokenBufferOffset ( ) , tokenBuffer , tokenOffset , tokenLength ) ; \nreturn this ; \n} \n} \n"}
{"1957": "public class RecoveryState { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { \ntempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; \ntempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; \ntempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; \ntempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; \nfinal int serviceCount = snapshotRecordingIds . length ; \ntempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; \nfinal int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; \nif ( keyLength > MAX_KEY_LENGTH ) throw new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; \nfor ( int i = 0 ; \ni < serviceCount ; \ni ++ ) tempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; \nfinal int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; \nint labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; \nlabelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; \nreturn aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1958": "public class RecoveryState { \npublic static int findCounterId ( final CountersReader counters ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) return i ; \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1959": "public class RecoveryState { \npublic static boolean hasReplay ( final CountersReader counters , final int counterId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) return buffer . getInt ( recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET ) == 1 ; \n} \nreturn false ; \n} \n} \n"}
{"1960": "public class RecoveryState { \npublic static long getSnapshotRecordingId ( final CountersReader counters , final int counterId , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nfinal int serviceCount = buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET ) ; \nif ( serviceId < 0 || serviceId >= serviceCount ) throw new ClusterException ( \"invalid serviceId \" + serviceId + \" for count of \" + serviceCount ) ; \nreturn buffer . getLong ( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceId * SIZE_OF_LONG ) ) ; \n} \n} \nthrow new ClusterException ( \"Active counter not found \" + counterId ) ; \n} \n} \n"}
{"1961": "public class HeaderFlyweight { \npublic static char [ ] flagsToChars ( final short flags ) { \nfinal char [ ] chars = new char [ ] { \n'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } \n; \nfinal int length = chars . length ; \nshort mask = ( short ) ( 1 << ( length - 1 ) ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nif ( ( flags & mask ) == mask ) chars [ i ] = '1' ; \nmask >>= 1 ; \n} \nreturn chars ; \n} \n} \n"}
{"1965": "public class BufferClaim { \npublic final void commit ( ) { \nint frameLength = buffer . capacity ( ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) frameLength = Integer . reverseBytes ( frameLength ) ; \nbuffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; \n} \n} \n"}
{"1966": "public class BufferClaim { \npublic final void abort ( ) { \nint frameLength = buffer . capacity ( ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) frameLength = Integer . reverseBytes ( frameLength ) ; \nbuffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_PAD , LITTLE_ENDIAN ) ; \nbuffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; \n} \n} \n"}
{"1968": "public class MediaDriver { \npublic void close ( ) { \nCloseHelper . close ( sharedRunner ) ; \nCloseHelper . close ( sharedNetworkRunner ) ; \nCloseHelper . close ( receiverRunner ) ; \nCloseHelper . close ( senderRunner ) ; \nCloseHelper . close ( conductorRunner ) ; \nCloseHelper . close ( sharedInvoker ) ; \nif ( ctx . useWindowsHighResTimer ( ) && SystemUtil . osName ( ) . startsWith ( \"win\" ) ) if ( ! wasHighResTimerEnabled ) HighResolutionTimer . disable ( ) ; \n} \n} \n"}
{"1971": "public class ServiceHeartbeat { \npublic static int findCounterId ( final CountersReader counters , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) return i ; \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nint nextSlabSize ; \nif ( bytesUsed == 0 ) nextSlabSize = initialSlabSize ; \nelse if ( bytesUsed > maxCapacityHint / 5 ) nextSlabSize = maxCapacityHint / 5 ; \nelse nextSlabSize = bytesUsed ; \nif ( nextSlabSize < minimumSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated += nextSlabSize ; \nthis . currentSlabIndex = 0 ; \n} \n} \n"}
{"1978": "public class ColumnIndexBuilder { \npublic void add ( Statistics < ? > stats ) { \nif ( stats . hasNonNullValue ( ) ) { \nnullPages . add ( false ) ; \nObject min = stats . genericGetMin ( ) ; \nObject max = stats . genericGetMax ( ) ; \naddMinMax ( min , max ) ; \npageIndexes . add ( nextPageIndex ) ; \nminMaxSize += sizeOf ( min ) ; \nminMaxSize += sizeOf ( max ) ; \n} \nelse nullPages . add ( true ) ; \nnullCounts . add ( stats . getNumNulls ( ) ) ; \n++ nextPageIndex ; \n} \n} \n"}
{"1982": "public class GlobParser { \nprivate static String annotateMessage ( String message , int pos ) { \nStringBuilder sb = new StringBuilder ( message ) ; \nsb . append ( '\\n' ) ; \nfor ( int i = 0 ; \ni < pos ; \ni ++ ) sb . append ( '-' ) ; \nsb . append ( '^' ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1983": "public class RunLengthBitPackingHybridEncoder { \nprivate void endPreviousBitPackedRun ( ) { \nif ( bitPackedRunHeaderPointer == - 1 ) return ; \nbyte bitPackHeader = ( byte ) ( ( bitPackedGroupCount << 1 ) | 1 ) ; \nbaos . setByte ( bitPackedRunHeaderPointer , bitPackHeader ) ; \nbitPackedRunHeaderPointer = - 1 ; \nbitPackedGroupCount = 0 ; \n} \n} \n"}
{"1987": "public class ParquetFileReader { \n@ Deprecated public static final ParquetMetadata readFooter ( InputFile file , MetadataFilter filter ) throws IOException { \nParquetReadOptions options ; \nif ( file instanceof HadoopInputFile ) options = HadoopReadOptions . builder ( ( ( HadoopInputFile ) file ) . getConfiguration ( ) ) . withMetadataFilter ( filter ) . build ( ) ; \nelse options = ParquetReadOptions . builder ( ) . withMetadataFilter ( filter ) . build ( ) ; \ntry ( SeekableInputStream in = file . newStream ( ) ) { \nreturn readFooter ( file , options , in ) ; \n} \n} \n} \n"}
{"1988": "public class ParquetFileReader { \npublic PageReadStore readNextRowGroup ( ) throws IOException { \nif ( currentBlock == blocks . size ( ) ) return null ; \nBlockMetaData block = blocks . get ( currentBlock ) ; \nif ( block . getRowCount ( ) == 0 ) throw new RuntimeException ( \"Illegal row group of 0 rows\" ) ; \nthis . currentRowGroup = new ColumnChunkPageReadStore ( block . getRowCount ( ) ) ; \nList < ConsecutivePartList > allParts = new ArrayList < ConsecutivePartList > ( ) ; \nConsecutivePartList currentParts = null ; \nfor ( ColumnChunkMetaData mc : block . getColumns ( ) ) { \nColumnPath pathKey = mc . getPath ( ) ; \nBenchmarkCounter . incrementTotalBytes ( mc . getTotalSize ( ) ) ; \nColumnDescriptor columnDescriptor = paths . get ( pathKey ) ; \nif ( columnDescriptor != null ) { \nlong startingPos = mc . getStartingPos ( ) ; \nif ( currentParts == null || currentParts . endPos ( ) != startingPos ) { \ncurrentParts = new ConsecutivePartList ( startingPos ) ; \nallParts . add ( currentParts ) ; \n} \ncurrentParts . addChunk ( new ChunkDescriptor ( columnDescriptor , mc , startingPos , ( int ) mc . getTotalSize ( ) ) ) ; \n} \n} \nChunkListBuilder builder = new ChunkListBuilder ( ) ; \nfor ( ConsecutivePartList consecutiveChunks : allParts ) { \nconsecutiveChunks . readAll ( f , builder ) ; \n} \nfor ( Chunk chunk : builder . build ( ) ) { \ncurrentRowGroup . addColumn ( chunk . descriptor . col , chunk . readAllPages ( ) ) ; \n} \nif ( nextDictionaryReader != null ) nextDictionaryReader . setRowGroup ( currentRowGroup ) ; \nadvanceToNextBlock ( ) ; \nreturn currentRowGroup ; \n} \n} \n"}
{"1989": "public class ParquetFileReader { \npublic PageReadStore readNextFilteredRowGroup ( ) throws IOException { \nif ( currentBlock == blocks . size ( ) ) return null ; \nif ( ! options . useColumnIndexFilter ( ) ) return readNextRowGroup ( ) ; \nBlockMetaData block = blocks . get ( currentBlock ) ; \nif ( block . getRowCount ( ) == 0 ) throw new RuntimeException ( \"Illegal row group of 0 rows\" ) ; \nColumnIndexStore ciStore = getColumnIndexStore ( currentBlock ) ; \nRowRanges rowRanges = getRowRanges ( currentBlock ) ; \nlong rowCount = rowRanges . rowCount ( ) ; \nif ( rowCount == 0 ) { \nadvanceToNextBlock ( ) ; \nreturn readNextFilteredRowGroup ( ) ; \n} \nif ( rowCount == block . getRowCount ( ) ) return readNextRowGroup ( ) ; \nthis . currentRowGroup = new ColumnChunkPageReadStore ( rowRanges ) ; \nChunkListBuilder builder = new ChunkListBuilder ( ) ; \nList < ConsecutivePartList > allParts = new ArrayList < ConsecutivePartList > ( ) ; \nConsecutivePartList currentParts = null ; \nfor ( ColumnChunkMetaData mc : block . getColumns ( ) ) { \nColumnPath pathKey = mc . getPath ( ) ; \nColumnDescriptor columnDescriptor = paths . get ( pathKey ) ; \nif ( columnDescriptor != null ) { \nOffsetIndex offsetIndex = ciStore . getOffsetIndex ( mc . getPath ( ) ) ; \nOffsetIndex filteredOffsetIndex = filterOffsetIndex ( offsetIndex , rowRanges , block . getRowCount ( ) ) ; \nfor ( OffsetRange range : calculateOffsetRanges ( filteredOffsetIndex , mc , offsetIndex . getOffset ( 0 ) ) ) { \nBenchmarkCounter . incrementTotalBytes ( range . getLength ( ) ) ; \nlong startingPos = range . getOffset ( ) ; \nif ( currentParts == null || currentParts . endPos ( ) != startingPos ) { \ncurrentParts = new ConsecutivePartList ( startingPos ) ; \nallParts . add ( currentParts ) ; \n} \nChunkDescriptor chunkDescriptor = new ChunkDescriptor ( columnDescriptor , mc , startingPos , ( int ) range . getLength ( ) ) ; \ncurrentParts . addChunk ( chunkDescriptor ) ; \nbuilder . setOffsetIndex ( chunkDescriptor , filteredOffsetIndex ) ; \n} \n} \n} \nfor ( ConsecutivePartList consecutiveChunks : allParts ) { \nconsecutiveChunks . readAll ( f , builder ) ; \n} \nfor ( Chunk chunk : builder . build ( ) ) { \ncurrentRowGroup . addColumn ( chunk . descriptor . col , chunk . readAllPages ( ) ) ; \n} \nif ( nextDictionaryReader != null ) nextDictionaryReader . setRowGroup ( currentRowGroup ) ; \nadvanceToNextBlock ( ) ; \nreturn currentRowGroup ; \n} \n} \n"}
{"1990": "public class ParquetFileReader { \nDictionaryPage readDictionary ( ColumnChunkMetaData meta ) throws IOException { \nif ( ! meta . getEncodings ( ) . contains ( Encoding . PLAIN_DICTIONARY ) && ! meta . getEncodings ( ) . contains ( Encoding . RLE_DICTIONARY ) ) return null ; \nif ( f . getPos ( ) != meta . getStartingPos ( ) ) f . seek ( meta . getStartingPos ( ) ) ; \nPageHeader pageHeader = Util . readPageHeader ( f ) ; \nif ( ! pageHeader . isSetDictionary_page_header ( ) ) return null ; \nDictionaryPage compressedPage = readCompressedDictionary ( pageHeader , f ) ; \nBytesInputDecompressor decompressor = options . getCodecFactory ( ) . getDecompressor ( meta . getCodec ( ) ) ; \nreturn new DictionaryPage ( decompressor . decompress ( compressedPage . getBytes ( ) , compressedPage . getUncompressedSize ( ) ) , compressedPage . getDictionarySize ( ) , compressedPage . getEncoding ( ) ) ; \n} \n} \n"}
{"1991": "public class MemoryManager { \nsynchronized void addWriter ( InternalParquetRecordWriter writer , Long allocation ) { \nLong oldValue = writerList . get ( writer ) ; \nif ( oldValue == null ) writerList . put ( writer , allocation ) ; \nelse throw new IllegalArgumentException ( \"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer ) ; \nupdateAllocation ( ) ; \n} \n} \n"}
{"1992": "public class MemoryManager { \nsynchronized void removeWriter ( InternalParquetRecordWriter writer ) { \nif ( writerList . containsKey ( writer ) ) writerList . remove ( writer ) ; \nif ( ! writerList . isEmpty ( ) ) updateAllocation ( ) ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations += allocation ; \n} \nif ( totalAllocations <= totalMemoryPool ) scale = 1.0 ; \nelse { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nint maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) throw new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"1994": "public class MemoryManager { \npublic void registerScaleCallBack ( String callBackName , Runnable callBack ) { \nPreconditions . checkNotNull ( callBackName , \"callBackName\" ) ; \nPreconditions . checkNotNull ( callBack , \"callBack\" ) ; \nif ( callBacks . containsKey ( callBackName ) ) throw new IllegalArgumentException ( \"The callBackName \" + callBackName + \" is duplicated and has been registered already.\" ) ; \nelse callBacks . put ( callBackName , callBack ) ; \n} \n} \n"}
{"2000": "public class ParquetFileWriter { \nvoid writeColumnChunk ( ColumnDescriptor descriptor , long valueCount , CompressionCodecName compressionCodecName , DictionaryPage dictionaryPage , BytesInput bytes , long uncompressedTotalPageSize , long compressedTotalPageSize , Statistics < ? > totalStats , ColumnIndexBuilder columnIndexBuilder , OffsetIndexBuilder offsetIndexBuilder , Set < Encoding > rlEncodings , Set < Encoding > dlEncodings , List < Encoding > dataEncodings ) throws IOException { \nstartColumn ( descriptor , valueCount , compressionCodecName ) ; \nstate = state . write ( ) ; \nif ( dictionaryPage != null ) writeDictionaryPage ( dictionaryPage ) ; \nLOG . debug ( \"{}: write data pages\" , out . getPos ( ) ) ; \nlong headersSize = bytes . size ( ) - compressedTotalPageSize ; \nthis . uncompressedLength += uncompressedTotalPageSize + headersSize ; \nthis . compressedLength += compressedTotalPageSize + headersSize ; \nLOG . debug ( \"{}: write data pages content\" , out . getPos ( ) ) ; \nfirstPageOffset = out . getPos ( ) ; \nbytes . writeAllTo ( out ) ; \nencodingStatsBuilder . addDataEncodings ( dataEncodings ) ; \nif ( rlEncodings . isEmpty ( ) ) encodingStatsBuilder . withV2Pages ( ) ; \ncurrentEncodings . addAll ( rlEncodings ) ; \ncurrentEncodings . addAll ( dlEncodings ) ; \ncurrentEncodings . addAll ( dataEncodings ) ; \ncurrentStatistics = totalStats ; \nthis . columnIndexBuilder = columnIndexBuilder ; \nthis . offsetIndexBuilder = offsetIndexBuilder ; \nendColumn ( ) ; \n} \n} \n"}
{"2002": "public class ParquetFileWriter { \nprivate static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { \nLOG . debug ( \"Copying {} bytes at {} to {}\" , length , start , to . getPos ( ) ) ; \nfrom . seek ( start ) ; \nlong bytesCopied = 0 ; \nbyte [ ] buffer = COPY_BUFFER . get ( ) ; \nwhile ( bytesCopied < length ) { \nlong bytesLeft = length - bytesCopied ; \nint bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; \nif ( bytesRead < 0 ) throw new IllegalArgumentException ( \"Unexpected end of input file at \" + start + bytesCopied ) ; \nto . write ( buffer , 0 , bytesRead ) ; \nbytesCopied += bytesRead ; \n} \n} \n} \n"}
{"2008": "public class ColumnReaderBase { \npublic void readValue ( ) { \ntry { \nif ( ! valueRead ) { \nbinding . read ( ) ; \nvalueRead = true ; \n} \n} \ncatch ( RuntimeException e ) { \nif ( CorruptDeltaByteArrays . requiresSequentialReads ( writerVersion , currentEncoding ) && e instanceof ArrayIndexOutOfBoundsException ) throw new ParquetDecodingException ( \"Read failure possibly due to \" + \"PARQUET-246: try setting parquet.split.files to false\" , new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ) ; \nthrow new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ; \n} \n} \n} \n"}
{"2009": "public class Schemas { \npublic static boolean nullOk ( Schema schema ) { \nif ( Schema . Type . NULL == schema . getType ( ) ) return true ; \nelse if ( Schema . Type . UNION == schema . getType ( ) ) for ( Schema possible : schema . getTypes ( ) ) { \nif ( nullOk ( possible ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"2010": "public class Schemas { \n@ SafeVarargs private static < E > E coalesce ( E ... objects ) { \nfor ( E object : objects ) { \nif ( object != null ) return object ; \n} \nreturn null ; \n} \n} \n"}
{"2011": "public class RecordBuilder { \nprivate static Object makeValue ( String string , Schema schema ) { \nif ( string == null ) return null ; \ntry { \nswitch ( schema . getType ( ) ) { \ncase BOOLEAN : return Boolean . valueOf ( string ) ; \ncase STRING : return string ; \ncase FLOAT : return Float . valueOf ( string ) ; \ncase DOUBLE : return Double . valueOf ( string ) ; \ncase INT : return Integer . valueOf ( string ) ; \ncase LONG : return Long . valueOf ( string ) ; \ncase ENUM : if ( schema . hasEnumSymbol ( string ) ) return string ; \nelse try { \nreturn schema . getEnumSymbols ( ) . get ( Integer . parseInt ( string ) ) ; \n} \ncatch ( IndexOutOfBoundsException ex ) { \nreturn null ; \n} \ncase UNION : Object value = null ; \nfor ( Schema possible : schema . getTypes ( ) ) { \nvalue = makeValue ( string , possible ) ; \nif ( value != null ) return value ; \n} \nreturn null ; \ncase NULL : return null ; \ndefault : throw new RecordException ( \"Unsupported field type:\" + schema . getType ( ) ) ; \n} \n} \ncatch ( NumberFormatException e ) { \nif ( string . isEmpty ( ) ) return null ; \nelse throw e ; \n} \n} \n} \n"}
{"2012": "public class ThriftMetaData { \npublic static ThriftMetaData fromExtraMetaData ( Map < String , String > extraMetaData ) { \nfinal String thriftClassName = extraMetaData . get ( THRIFT_CLASS ) ; \nfinal String thriftDescriptorString = extraMetaData . get ( THRIFT_DESCRIPTOR ) ; \nif ( thriftClassName == null || thriftDescriptorString == null ) return null ; \nfinal StructType descriptor = parseDescriptor ( thriftDescriptorString ) ; \nreturn new ThriftMetaData ( thriftClassName , descriptor ) ; \n} \n} \n"}
{"2016": "public class ColumnWriterBase { \nvoid writePage ( ) { \nif ( valueCount == 0 ) throw new ParquetEncodingException ( \"writing empty page\" ) ; \nthis . rowsWrittenSoFar += pageRowCount ; \nif ( DEBUG ) LOG . debug ( \"write page\" ) ; \ntry { \nwritePage ( pageRowCount , valueCount , statistics , repetitionLevelColumn , definitionLevelColumn , dataColumn ) ; \n} \ncatch ( IOException e ) { \nthrow new ParquetEncodingException ( \"could not write page for \" + path , e ) ; \n} \nrepetitionLevelColumn . reset ( ) ; \ndefinitionLevelColumn . reset ( ) ; \ndataColumn . reset ( ) ; \nvalueCount = 0 ; \nresetStatistics ( ) ; \npageRowCount = 0 ; \n} \n} \n"}
{"2017": "public class DeltaBinaryPackingValuesReader { \n@ Override public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { \nthis . in = stream ; \nlong startPos = in . position ( ) ; \nthis . config = DeltaBinaryPackingConfig . readConfig ( in ) ; \nthis . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; \nallocateValuesBuffer ( ) ; \nbitWidths = new int [ config . miniBlockNumInABlock ] ; \nvaluesBuffer [ valuesBuffered ++ ] = BytesUtils . readZigZagVarLong ( in ) ; \nwhile ( valuesBuffered < totalValueCount ) loadNewBlockToBuffer ( ) ; \nupdateNextOffset ( ( int ) ( in . position ( ) - startPos ) ) ; \n} \n} \n"}
{"2019": "public class BufferedProtocolReadToWrite { \nprivate void checkEnum ( ThriftType expectedType , int i ) { \nif ( expectedType . getType ( ) == ThriftTypeID . ENUM ) { \nThriftType . EnumType expectedEnumType = ( ThriftType . EnumType ) expectedType ; \nif ( expectedEnumType . getEnumValueById ( i ) == null ) throw new DecodingSchemaMismatchException ( \"can not find index \" + i + \" in enum \" + expectedType ) ; \n} \n} \n} \n"}
{"2020": "public class DeltaBinaryPackingValuesWriterForInteger { \nprivate void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { \nfor ( int miniBlockIndex = 0 ; \nminiBlockIndex < miniBlocksToFlush ; \nminiBlockIndex ++ ) { \nint mask = 0 ; \nint miniStart = miniBlockIndex * config . miniBlockSizeInValues ; \nint miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; \nfor ( int i = miniStart ; \ni < miniEnd ; \ni ++ ) mask |= deltaBlockBuffer [ i ] ; \nbitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; \n} \n} \n} \n"}
{"2021": "public class Exceptions { \npublic static < E extends Exception > void throwIfInstance ( Throwable t , Class < E > excClass ) throws E { \nif ( excClass . isAssignableFrom ( t . getClass ( ) ) ) throw excClass . cast ( t ) ; \n} \n} \n"}
{"2024": "public class Statistics { \npublic void mergeStatistics ( Statistics stats ) { \nif ( stats . isEmpty ( ) ) return ; \nif ( type . equals ( stats . type ) ) { \nincrementNumNulls ( stats . getNumNulls ( ) ) ; \nif ( stats . hasNonNullValue ( ) ) { \nmergeStatisticsMinMax ( stats ) ; \nmarkAsNotEmpty ( ) ; \n} \n} \nelse throw StatisticsClassException . create ( this , stats ) ; \n} \n} \n"}
{"2025": "public class AvroSchemaConverter { \npublic static Schema getNonNull ( Schema schema ) { \nif ( schema . getType ( ) . equals ( Schema . Type . UNION ) ) { \nList < Schema > schemas = schema . getTypes ( ) ; \nif ( schemas . size ( ) == 2 ) if ( schemas . get ( 0 ) . getType ( ) . equals ( Schema . Type . NULL ) ) return schemas . get ( 1 ) ; \nelse if ( schemas . get ( 1 ) . getType ( ) . equals ( Schema . Type . NULL ) ) return schemas . get ( 0 ) ; \nelse return schema ; \nelse return schema ; \n} \nelse return schema ; \n} \n} \n"}
{"2028": "public class GroupType { \nvoid membersDisplayString ( StringBuilder sb , String indent ) { \nfor ( Type field : fields ) { \nfield . writeToStringBuilder ( sb , indent ) ; \nif ( field . isPrimitive ( ) ) sb . append ( \";\" ) ; \nsb . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"2029": "public class GroupType { \nList < Type > mergeFields ( GroupType toMerge , boolean strict ) { \nList < Type > newFields = new ArrayList < Type > ( ) ; \nfor ( Type type : this . getFields ( ) ) { \nType merged ; \nif ( toMerge . containsField ( type . getName ( ) ) ) { \nType fieldToMerge = toMerge . getType ( type . getName ( ) ) ; \nif ( type . getLogicalTypeAnnotation ( ) != null && ! type . getLogicalTypeAnnotation ( ) . equals ( fieldToMerge . getLogicalTypeAnnotation ( ) ) ) throw new IncompatibleSchemaModificationException ( \"cannot merge logical type \" + fieldToMerge . getLogicalTypeAnnotation ( ) + \" into \" + type . getLogicalTypeAnnotation ( ) ) ; \nmerged = type . union ( fieldToMerge , strict ) ; \n} \nelse merged = type ; \nnewFields . add ( merged ) ; \n} \nfor ( Type type : toMerge . getFields ( ) ) { \nif ( ! this . containsField ( type . getName ( ) ) ) newFields . add ( type ) ; \n} \nreturn newFields ; \n} \n} \n"}
{"2039": "public class ProtocolEventsAmender { \nprivate void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { \nTSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; \nThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; \nint setSize = thriftSet . size ; \nfor ( int i = 0 ; \ni < setSize ; \ni ++ ) checkField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; \nacceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; \n} \n} \n"}
{"2040": "public class Util { \npublic static FileMetaData readFileMetaData ( InputStream from , boolean skipRowGroups ) throws IOException { \nFileMetaData md = new FileMetaData ( ) ; \nif ( skipRowGroups ) readFileMetaData ( from , new DefaultFileMetaDataConsumer ( md ) , skipRowGroups ) ; \nelse read ( from , md ) ; \nreturn md ; \n} \n} \n"}
{"2044": "public class ValidTypeMap { \npublic static < T extends Comparable < T > > void assertTypeValid ( Column < T > foundColumn , PrimitiveTypeName primitiveType ) { \nClass < T > foundColumnType = foundColumn . getColumnType ( ) ; \nColumnPath columnPath = foundColumn . getColumnPath ( ) ; \nSet < PrimitiveTypeName > validTypeDescriptors = classToParquetType . get ( foundColumnType ) ; \nif ( validTypeDescriptors == null ) { \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"Column \" ) . append ( columnPath . toDotString ( ) ) . append ( \" was declared as type: \" ) . append ( foundColumnType . getName ( ) ) . append ( \" which is not supported in FilterPredicates.\" ) ; \nSet < Class < ? > > supportedTypes = parquetTypeToClass . get ( primitiveType ) ; \nif ( supportedTypes != null ) message . append ( \" Supported types for this column are: \" ) . append ( supportedTypes ) ; \nelse message . append ( \" There are no supported types for columns of \" + primitiveType ) ; \nthrow new IllegalArgumentException ( message . toString ( ) ) ; \n} \nif ( ! validTypeDescriptors . contains ( primitiveType ) ) { \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"FilterPredicate column: \" ) . append ( columnPath . toDotString ( ) ) . append ( \"'s declared type (\" ) . append ( foundColumnType . getName ( ) ) . append ( \") does not match the schema found in file metadata. Column \" ) . append ( columnPath . toDotString ( ) ) . append ( \" is of type: \" ) . append ( primitiveType ) . append ( \"\\nValid types for this column are: \" ) . append ( parquetTypeToClass . get ( primitiveType ) ) ; \nthrow new IllegalArgumentException ( message . toString ( ) ) ; \n} \n} \n} \n"}
{"2045": "public class Ints { \npublic static int checkedCast ( long value ) { \nint valueI = ( int ) value ; \nif ( valueI != value ) throw new IllegalArgumentException ( String . format ( \"Overflow casting %d to an int\" , value ) ) ; \nreturn valueI ; \n} \n} \n"}
{"2050": "public class FilteredRecordReader { \nprivate void skipToMatch ( ) { \nwhile ( recordsRead < recordCount && ! recordFilter . isMatch ( ) ) { \nState currentState = getState ( 0 ) ; \ndo { \nColumnReader columnReader = currentState . column ; \nif ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) columnReader . skip ( ) ; \ncolumnReader . consume ( ) ; \nint nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; \ncurrentState = currentState . getNextState ( nextR ) ; \n} \nwhile ( currentState != null ) ; \n++ recordsRead ; \n} \n} \n} \n"}
{"2052": "public class LruCache { \npublic V remove ( final K key ) { \nV oldValue = cacheMap . remove ( key ) ; \nif ( oldValue != null ) LOG . debug ( \"Removed cache entry for '{}'\" , key ) ; \nreturn oldValue ; \n} \n} \n"}
{"2053": "public class LruCache { \npublic void put ( final K key , final V newValue ) { \nif ( newValue == null || ! newValue . isCurrent ( key ) ) { \nif ( LOG . isWarnEnabled ( ) ) LOG . warn ( \"Ignoring new cache entry for '{}' because it is {}\" , key , ( newValue == null ? \"null\" : \"not current\" ) ) ; \nreturn ; \n} \nV oldValue = cacheMap . get ( key ) ; \nif ( oldValue != null && oldValue . isNewerThan ( newValue ) ) { \nif ( LOG . isWarnEnabled ( ) ) LOG . warn ( \"Ignoring new cache entry for '{}' because \" + \"existing cache entry is newer\" , key ) ; \nreturn ; \n} \noldValue = cacheMap . put ( key , newValue ) ; \nif ( LOG . isDebugEnabled ( ) ) if ( oldValue == null ) LOG . debug ( \"Added new cache entry for '{}'\" , key ) ; \nelse LOG . debug ( \"Overwrote existing cache entry for '{}'\" , key ) ; \n} \n} \n"}
{"2055": "public class AvroWriteSupport { \nprivate void writeValue ( Type type , Schema avroSchema , Object value ) { \nSchema nonNullAvroSchema = AvroSchemaConverter . getNonNull ( avroSchema ) ; \nLogicalType logicalType = nonNullAvroSchema . getLogicalType ( ) ; \nif ( logicalType != null ) { \nConversion < ? > conversion = model . getConversionByClass ( value . getClass ( ) , logicalType ) ; \nwriteValueWithoutConversion ( type , nonNullAvroSchema , convert ( nonNullAvroSchema , logicalType , conversion , value ) ) ; \n} \nelse writeValueWithoutConversion ( type , nonNullAvroSchema , value ) ; \n} \n} \n"}
{"2056": "public class AvroWriteSupport { \n@ SuppressWarnings ( \"unchecked\" ) private void writeValueWithoutConversion ( Type type , Schema avroSchema , Object value ) { \nswitch ( avroSchema . getType ( ) ) { \ncase BOOLEAN : recordConsumer . addBoolean ( ( Boolean ) value ) ; \nbreak ; \ncase INT : if ( value instanceof Character ) recordConsumer . addInteger ( ( Character ) value ) ; \nelse recordConsumer . addInteger ( ( ( Number ) value ) . intValue ( ) ) ; \nbreak ; \ncase LONG : recordConsumer . addLong ( ( ( Number ) value ) . longValue ( ) ) ; \nbreak ; \ncase FLOAT : recordConsumer . addFloat ( ( ( Number ) value ) . floatValue ( ) ) ; \nbreak ; \ncase DOUBLE : recordConsumer . addDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; \nbreak ; \ncase FIXED : recordConsumer . addBinary ( Binary . fromReusedByteArray ( ( ( GenericFixed ) value ) . bytes ( ) ) ) ; \nbreak ; \ncase BYTES : if ( value instanceof byte [ ] ) recordConsumer . addBinary ( Binary . fromReusedByteArray ( ( byte [ ] ) value ) ) ; \nelse recordConsumer . addBinary ( Binary . fromReusedByteBuffer ( ( ByteBuffer ) value ) ) ; \nbreak ; \ncase STRING : recordConsumer . addBinary ( fromAvroString ( value ) ) ; \nbreak ; \ncase RECORD : writeRecord ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \ncase ENUM : recordConsumer . addBinary ( Binary . fromString ( value . toString ( ) ) ) ; \nbreak ; \ncase ARRAY : listWriter . writeList ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \ncase MAP : writeMap ( type . asGroupType ( ) , avroSchema , ( Map < CharSequence , ? > ) value ) ; \nbreak ; \ncase UNION : writeUnion ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \n} \n} \n\n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nint setOpen = 0 ; \nint curlyOpen = 0 ; \nint len = glob . length ( ) ; \nhasWildcard = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( ++ i >= len ) error ( \"Missing escaped character\" , glob , i ) ; \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \ncontinue ; \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni ++ ; \nbreak ; \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \ncontinue ; \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen ++ ; \nhasWildcard = true ; \ncontinue ; \ncase ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; \ncontinue ; \ncase '}' : if ( curlyOpen > 0 ) { \ncurlyOpen -- ; \nregex . append ( \")\" ) ; \ncontinue ; \n} \nbreak ; \ncase '[' : if ( setOpen > 0 ) error ( \"Unclosed character class\" , glob , i ) ; \nsetOpen ++ ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) regex . append ( BACKSLASH ) ; \nbreak ; \ncase '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \ncontinue ; \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \n} \nif ( setOpen > 0 ) error ( \"Unclosed character class\" , glob , len ) ; \nif ( curlyOpen > 0 ) error ( \"Unclosed group\" , glob , len ) ; \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \n} \n} \n"}
{"2058": "public class BaseCommand { \npublic void output ( String content , Logger console , String filename ) throws IOException { \nif ( filename == null || \"-\" . equals ( filename ) ) console . info ( content ) ; \nelse { \nFSDataOutputStream outgoing = create ( filename ) ; \ntry { \noutgoing . write ( content . getBytes ( StandardCharsets . UTF_8 ) ) ; \n} \nfinally { \noutgoing . close ( ) ; \n} \n} \n} \n} \n"}
{"2059": "public class BaseCommand { \npublic InputStream open ( String filename ) throws IOException { \nif ( STDIN_AS_SOURCE . equals ( filename ) ) return System . in ; \nURI uri = qualifiedURI ( filename ) ; \nif ( RESOURCE_URI_SCHEME . equals ( uri . getScheme ( ) ) ) return Resources . getResource ( uri . getRawSchemeSpecificPart ( ) ) . openStream ( ) ; \nelse { \nPath filePath = new Path ( uri ) ; \nFileSystem fs = filePath . getFileSystem ( getConf ( ) ) ; \nreturn fs . open ( filePath ) ; \n} \n} \n} \n"}
{"2060": "public class ColumnRecordFilter { \npublic static final UnboundRecordFilter column ( final String columnPath , final ColumnPredicates . Predicate predicate ) { \ncheckNotNull ( columnPath , \"columnPath\" ) ; \ncheckNotNull ( predicate , \"predicate\" ) ; \nreturn new UnboundRecordFilter ( ) { \nfinal String [ ] filterPath = columnPath . split ( \"\\\\.\" ) ; \n@ Override public RecordFilter bind ( Iterable < ColumnReader > readers ) { \nfor ( ColumnReader reader : readers ) { \nif ( Arrays . equals ( reader . getDescriptor ( ) . getPath ( ) , filterPath ) ) return new ColumnRecordFilter ( reader , predicate ) ; \n} \nthrow new IllegalArgumentException ( \"Column \" + columnPath + \" does not exist.\" ) ; \n} \n} \n; \n} \n} \n"}
{"2062": "public class ConversionPatterns { \nprivate static GroupType listWrapper ( Repetition repetition , String alias , LogicalTypeAnnotation logicalTypeAnnotation , Type nested ) { \nif ( ! nested . isRepetition ( Repetition . REPEATED ) ) throw new IllegalArgumentException ( \"Nested type should be repeated: \" + nested ) ; \nreturn new GroupType ( repetition , alias , logicalTypeAnnotation , nested ) ; \n} \n} \n"}
{"2064": "public class InitContext { \n@ Deprecated public Map < String , String > getMergedKeyValueMetaData ( ) { \nif ( mergedKeyValueMetadata == null ) { \nMap < String , String > mergedKeyValues = new HashMap < String , String > ( ) ; \nfor ( Entry < String , Set < String > > entry : keyValueMetadata . entrySet ( ) ) { \nif ( entry . getValue ( ) . size ( ) > 1 ) throw new RuntimeException ( \"could not merge metadata: key \" + entry . getKey ( ) + \" has conflicting values: \" + entry . getValue ( ) ) ; \nmergedKeyValues . put ( entry . getKey ( ) , entry . getValue ( ) . iterator ( ) . next ( ) ) ; \n} \nmergedKeyValueMetadata = mergedKeyValues ; \n} \nreturn mergedKeyValueMetadata ; \n} \n} \n"}
{"2065": "public class ParquetRecordReaderWrapper { \nprotected ParquetInputSplit getSplit ( final InputSplit oldSplit , final JobConf conf ) throws IOException { \nif ( oldSplit instanceof FileSplit ) { \nFileSplit fileSplit = ( FileSplit ) oldSplit ; \nfinal long splitStart = fileSplit . getStart ( ) ; \nfinal long splitLength = fileSplit . getLength ( ) ; \nfinal Path finalPath = fileSplit . getPath ( ) ; \nfinal JobConf cloneJob = hiveBinding . pushProjectionsAndFilters ( conf , finalPath . getParent ( ) ) ; \nfinal ParquetMetadata parquetMetadata = ParquetFileReader . readFooter ( cloneJob , finalPath , SKIP_ROW_GROUPS ) ; \nfinal FileMetaData fileMetaData = parquetMetadata . getFileMetaData ( ) ; \nfinal ReadContext readContext = new DataWritableReadSupport ( ) . init ( cloneJob , fileMetaData . getKeyValueMetaData ( ) , fileMetaData . getSchema ( ) ) ; \nschemaSize = MessageTypeParser . parseMessageType ( readContext . getReadSupportMetadata ( ) . get ( DataWritableReadSupport . HIVE_SCHEMA_KEY ) ) . getFieldCount ( ) ; \nreturn new ParquetInputSplit ( finalPath , splitStart , splitStart + splitLength , splitLength , fileSplit . getLocations ( ) , null ) ; \n} \nelse throw new IllegalArgumentException ( \"Unknown split type: \" + oldSplit ) ; \n} \n} \n"}
{"2066": "public class AvroRecordConverter { \nprivate static Map < String , Class < ? > > getFieldsByName ( Class < ? > recordClass , boolean excludeJava ) { \nMap < String , Class < ? > > fields = new LinkedHashMap < String , Class < ? > > ( ) ; \nif ( recordClass != null ) { \nClass < ? > current = recordClass ; \ndo { \nif ( excludeJava && current . getPackage ( ) != null && current . getPackage ( ) . getName ( ) . startsWith ( \"java.\" ) ) break ; \nfor ( Field field : current . getDeclaredFields ( ) ) { \nif ( field . isAnnotationPresent ( AvroIgnore . class ) || isTransientOrStatic ( field ) ) continue ; \nAvroName altName = field . getAnnotation ( AvroName . class ) ; \nClass < ? > existing = fields . put ( altName != null ? altName . value ( ) : field . getName ( ) , field . getType ( ) ) ; \nif ( existing != null ) throw new AvroTypeException ( current + \" contains two fields named: \" + field . getName ( ) ) ; \n} \ncurrent = current . getSuperclass ( ) ; \n} \nwhile ( current != null ) ; \n} \nreturn fields ; \n} \n} \n"}
{"2068": "public class MergeCommand { \nprivate List < Path > getInputFiles ( List < String > input ) throws IOException { \nList < Path > inputFiles = null ; \nif ( input . size ( ) == 1 ) { \nPath p = new Path ( input . get ( 0 ) ) ; \nFileSystem fs = p . getFileSystem ( conf ) ; \nFileStatus status = fs . getFileStatus ( p ) ; \nif ( status . isDir ( ) ) inputFiles = getInputFilesFromDirectory ( status ) ; \n} \nelse inputFiles = parseInputFiles ( input ) ; \ncheckParquetFiles ( inputFiles ) ; \nreturn inputFiles ; \n} \n} \n"}
{"2069": "public class MergeCommand { \nprivate void checkParquetFiles ( List < Path > inputFiles ) throws IOException { \nif ( inputFiles == null || inputFiles . size ( ) <= 1 ) throw new IllegalArgumentException ( \"Not enough files to merge\" ) ; \nfor ( Path inputFile : inputFiles ) { \nFileSystem fs = inputFile . getFileSystem ( conf ) ; \nFileStatus status = fs . getFileStatus ( inputFile ) ; \nif ( status . isDir ( ) ) throw new IllegalArgumentException ( \"Illegal parquet file: \" + inputFile . toUri ( ) ) ; \n} \n} \n} \n"}
{"2078": "public class ByteBasedBitPackingEncoder { \npublic void writeInt ( int value ) throws IOException { \ninput [ inputSize ] = value ; \n++ inputSize ; \nif ( inputSize == VALUES_WRITTEN_AT_A_TIME ) { \npack ( ) ; \nif ( packedPosition == slabSize ) { \nslabs . add ( BytesInput . from ( packed ) ) ; \ntotalFullSlabSize += slabSize ; \nif ( slabSize < bitWidth * MAX_SLAB_SIZE_MULT ) slabSize *= 2 ; \ninitPackedSlab ( ) ; \n} \n} \n} \n} \n"}
{"2081": "public class MapR52StreamsValidationUtil09 { \n@ Override public void createTopicIfNotExists ( String topic , Map < String , Object > kafkaClientConfigs , String metadataBrokerList ) throws StageException { \nif ( topic . startsWith ( \"/\" ) && topic . contains ( \":\" ) ) { \nString [ ] path = topic . split ( \":\" ) ; \nif ( path . length != 2 ) throw new StageException ( MapRStreamsErrors . MAPRSTREAMS_21 , topic ) ; \nString streamPath = path [ 0 ] ; \nif ( ! streamCache . contains ( streamPath ) ) { \nConfiguration conf = new Configuration ( ) ; \nkafkaClientConfigs . forEach ( ( k , v ) -> { \nconf . set ( k , v . toString ( ) ) ; \n} \n) ; \nAdmin streamAdmin = null ; \ntry { \nstreamAdmin = Streams . newAdmin ( conf ) ; \nstreamAdmin . countTopics ( streamPath ) ; \nstreamCache . add ( streamPath ) ; \n} \ncatch ( TableNotFoundException e ) { \nLOG . debug ( \"Stream not found. Creating a new stream: \" + streamPath ) ; \ntry { \nstreamAdmin . createStream ( streamPath , Streams . newStreamDescriptor ( ) ) ; \nstreamCache . add ( streamPath ) ; \n} \ncatch ( IOException ioex ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_22 , streamPath , e . getMessage ( ) , e ) ; \n} \n} \ncatch ( IOException | IllegalArgumentException e ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_23 , e . getMessage ( ) , e ) ; \n} \nfinally { \nif ( streamAdmin != null ) streamAdmin . close ( ) ; \n} \n} \n} \nKafkaProducer < String , String > kafkaProducer = createProducerTopicMetadataClient ( kafkaClientConfigs ) ; \nkafkaProducer . partitionsFor ( topic ) ; \n} \n} \n"}
{"2082": "public class PipelineBeanCreator { \npublic PipelineStageBeans duplicatePipelineStageBeans ( StageLibraryTask stageLib , PipelineStageBeans pipelineStageBeans , InterceptorCreatorContextBuilder interceptorCreatorContextBuilder , Map < String , Object > constants , List < Issue > errors ) { \nList < StageBean > stageBeans = new ArrayList < > ( pipelineStageBeans . size ( ) ) ; \nfor ( StageBean original : pipelineStageBeans . getStages ( ) ) { \nMap < Class , ServiceDefinition > services = original . getServices ( ) . stream ( ) . collect ( Collectors . toMap ( c -> c . getDefinition ( ) . getProvides ( ) , ServiceBean :: getDefinition ) ) ; \nStageBean stageBean = createStage ( stageLib , original . getDefinition ( ) , ClassLoaderReleaser . NOOP_RELEASER , original . getConfiguration ( ) , services :: get , interceptorCreatorContextBuilder , constants , errors ) ; \nif ( stageBean != null ) stageBeans . add ( stageBean ) ; \n} \nreturn new PipelineStageBeans ( stageBeans ) ; \n} \n} \n"}
{"2083": "public class PipelineBeanCreator { \npublic StageBean createStageBean ( boolean forExecution , StageLibraryTask library , StageConfiguration stageConf , boolean validateAnnotations , boolean errorStage , boolean pipelineLifecycleStage , Map < String , Object > constants , InterceptorCreatorContextBuilder interceptorContextBuilder , List < Issue > errors ) { \nIssueCreator issueCreator = IssueCreator . getStage ( stageConf . getInstanceName ( ) ) ; \nStageBean bean = null ; \nStageDefinition stageDef = library . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , forExecution ) ; \nif ( stageDef != null ) { \nif ( validateAnnotations ) if ( pipelineLifecycleStage ) if ( ! stageDef . isPipelineLifecycleStage ( ) ) errors . add ( issueCreator . create ( CreationError . CREATION_018 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \nelse if ( stageDef . isErrorStage ( ) != errorStage ) if ( stageDef . isErrorStage ( ) ) errors . add ( issueCreator . create ( CreationError . CREATION_007 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \nelse errors . add ( issueCreator . create ( CreationError . CREATION_008 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \nbean = createStage ( library , stageDef , library , stageConf , serviceClass -> library . getServiceDefinition ( serviceClass , true ) , interceptorContextBuilder , constants , errors ) ; \n} \nelse errors . add ( issueCreator . create ( CreationError . CREATION_006 , stageConf . getLibrary ( ) , stageConf . getStageName ( ) , stageConf . getStageVersion ( ) ) ) ; \nreturn bean ; \n} \n} \n"}
{"2084": "public class PipelineBeanCreator { \npublic List < InterceptorBean > createInterceptors ( StageLibraryTask stageLib , StageConfiguration stageConfiguration , StageDefinition stageDefinition , InterceptorCreatorContextBuilder contextBuilder , InterceptorCreator . InterceptorType interceptorType , List < Issue > issues ) { \nList < InterceptorBean > beans = new ArrayList < > ( ) ; \nif ( contextBuilder == null ) return beans ; \nfor ( InterceptorDefinition definition : stageLib . getInterceptorDefinitions ( ) ) { \nInterceptorBean bean = createInterceptor ( stageLib , definition , stageConfiguration , stageDefinition , contextBuilder , interceptorType , issues ) ; \nif ( bean != null ) beans . add ( bean ) ; \n} \nreturn beans ; \n} \n} \n"}
{"2085": "public class PipelineBeanCreator { \npublic InterceptorBean createInterceptor ( StageLibraryTask stageLib , InterceptorDefinition definition , StageConfiguration stageConfiguration , StageDefinition stageDefinition , InterceptorCreatorContextBuilder contextBuilder , InterceptorCreator . InterceptorType interceptorType , List < Issue > issues ) { \nClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nInterceptorCreator . Context context = contextBuilder . buildFor ( definition . getLibraryDefinition ( ) . getName ( ) , definition . getKlass ( ) . getName ( ) , stageConfiguration , stageDefinition , interceptorType ) ; \ntry { \nThread . currentThread ( ) . setContextClassLoader ( definition . getStageClassLoader ( ) ) ; \nInterceptorCreator creator = definition . getDefaultCreator ( ) . newInstance ( ) ; \nInterceptor interceptor = creator . create ( context ) ; \nif ( interceptor == null ) return null ; \nreturn new InterceptorBean ( definition , interceptor , stageLib ) ; \n} \ncatch ( IllegalAccessException | InstantiationException e ) { \nLOG . debug ( \"Can't instantiate interceptor: {}\" , e . toString ( ) , e ) ; \nIssueCreator issueCreator = IssueCreator . getStage ( stageDefinition . getName ( ) ) ; \nissues . add ( issueCreator . create ( CreationError . CREATION_000 , \"interceptor\" , definition . getKlass ( ) . getName ( ) , e . toString ( ) ) ) ; \n} \nfinally { \nThread . currentThread ( ) . setContextClassLoader ( classLoader ) ; \n} \nreturn null ; \n} \n} \n"}
{"2087": "public class AvroTypeUtil { \nprivate static int millisToDays ( long millisLocal ) { \nlong millisUtc = millisLocal + localTimeZone . getOffset ( millisLocal ) ; \nint days ; \nif ( millisUtc >= 0L ) days = ( int ) ( millisUtc / MILLIS_PER_DAY ) ; \nelse days = ( int ) ( ( millisUtc - 86399999 ) / MILLIS_PER_DAY ) ; \nreturn days ; \n} \n} \n"}
{"2088": "public class AvroTypeUtil { \npublic static String getAvroSchemaFromHeader ( Record record , String headerName ) throws DataGeneratorException { \nString jsonSchema = record . getHeader ( ) . getAttribute ( headerName ) ; \nif ( jsonSchema == null || jsonSchema . isEmpty ( ) ) throw new DataGeneratorException ( Errors . AVRO_GENERATOR_03 , record . getHeader ( ) . getSourceId ( ) ) ; \nreturn jsonSchema ; \n} \n} \n"}
{"2090": "public class RecordWriter { \npublic long getLength ( ) throws IOException { \nlong length = - 1 ; \nif ( generator != null ) length = textOutputStream . getByteCount ( ) ; \nelse if ( seqWriter != null ) length = seqWriter . getLength ( ) ; \nreturn length ; \n} \n} \n"}
{"2091": "public class BaseClusterProvider { \nprivate void copyBlobstore ( List < String > blobStoreResources , File rootDataDir , File pipelineDir ) throws IOException { \nif ( blobStoreResources == null ) return ; \nFile blobstoreDir = new File ( runtimeInfo . getDataDir ( ) , BLOBSTORE_BASE_DIR ) ; \nFile stagingBlobstoreDir = new File ( rootDataDir , BLOBSTORE_BASE_DIR ) ; \nif ( ! stagingBlobstoreDir . exists ( ) ) if ( ! stagingBlobstoreDir . mkdirs ( ) ) throw new RuntimeException ( \"Failed to create blobstore directory: \" + pipelineDir . getPath ( ) ) ; \nfor ( String blobstoreFile : blobStoreResources ) { \nFile srcFile = new File ( blobstoreDir , blobstoreFile ) ; \nif ( srcFile . exists ( ) ) { \nfinal File dstFile = new File ( stagingBlobstoreDir , srcFile . getName ( ) ) ; \nif ( srcFile . canRead ( ) ) try ( InputStream in = new FileInputStream ( ( srcFile ) ) ) { \ntry ( OutputStream out = new FileOutputStream ( ( dstFile ) ) ) { \nIOUtils . copy ( in , out ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2094": "public class ThreadHealthReporter { \npublic boolean register ( String threadName ) { \nif ( threadToGaugeMap . containsKey ( threadName ) ) return false ; \nThreadHealthReportGauge threadHealthReportGauge = new ThreadHealthReportGauge ( ) ; \nMetricsConfigurator . createGauge ( metrics , getHealthGaugeName ( threadName ) , threadHealthReportGauge , name , rev ) ; \nthreadToGaugeMap . put ( threadName , threadHealthReportGauge ) ; \nreturn true ; \n} \n} \n"}
{"2095": "public class RuntimeInfo { \npublic static void storeControlHubConfigs ( RuntimeInfo runtimeInfo , Map < String , String > newConfigs ) throws IOException { \nFile configFile = new File ( runtimeInfo . getDataDir ( ) , SCH_CONF_OVERRIDE ) ; \nProperties properties = new Properties ( ) ; \nif ( configFile . exists ( ) ) try ( FileReader reader = new FileReader ( configFile ) ) { \nproperties . load ( reader ) ; \n} \nfor ( Map . Entry < String , String > entry : newConfigs . entrySet ( ) ) { \nif ( entry . getValue ( ) == null ) properties . remove ( entry . getKey ( ) ) ; \nelse properties . setProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \ntry ( FileWriter writer = new FileWriter ( configFile ) ) { \nproperties . store ( writer , null ) ; \n} \n} \n} \n"}
{"2096": "public class LdapLoginModule { \nprotected boolean credentialLogin ( Object webCredential ) throws LoginException { \nboolean credResult = getCurrentUser ( ) . checkCredential ( webCredential ) ; \nsetAuthenticated ( credResult ) ; \nif ( ! credResult ) LOG . warn ( \"Authentication failed - Possibly the user password is wrong\" ) ; \nreturn isAuthenticated ( ) ; \n} \n} \n"}
{"2097": "public class PipelineConfigurationUpgrader { \npublic PipelineConfiguration upgradeIfNecessary ( StageLibraryTask library , PipelineConfiguration pipelineConf , List < Issue > issues ) { \nPreconditions . checkArgument ( issues . isEmpty ( ) , \"Given list of issues must be empty.\" ) ; \nboolean upgrade ; \nupgrade = needsSchemaUpgrade ( pipelineConf , issues ) ; \nif ( upgrade && issues . isEmpty ( ) ) pipelineConf = upgradeSchema ( library , pipelineConf , issues ) ; \nif ( ! issues . isEmpty ( ) ) return null ; \nupgrade = needsUpgrade ( library , pipelineConf , issues ) ; \nif ( upgrade && issues . isEmpty ( ) ) pipelineConf = upgrade ( library , pipelineConf , issues ) ; \nreturn ( issues . isEmpty ( ) ) ? pipelineConf : null ; \n} \n} \n"}
{"2100": "public class PipelineConfigurationUpgrader { \nprivate static ServiceConfiguration upgradeServicesIfNeeded ( StageLibraryTask library , StageConfiguration stageConf , ServiceConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { \nServiceDefinition def = library . getServiceDefinition ( conf . getService ( ) , false ) ; \nif ( def == null ) issues . add ( issueCreator . create ( ContainerError . CONTAINER_0903 , conf . getService ( ) . getName ( ) ) ) ; \nint fromVersion = conf . getServiceVersion ( ) ; \nint toVersion = def . getVersion ( ) ; \nif ( ! needsUpgrade ( toVersion , fromVersion , issueCreator , issues ) ) return conf ; \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \ntry { \nLOG . warn ( \"Upgrading service instance from version '{}' to version '{}'\" , conf . getServiceVersion ( ) , def . getVersion ( ) ) ; \nUpgradeContext upgradeContext = new UpgradeContext ( \"\" , def . getName ( ) , stageConf . getInstanceName ( ) , fromVersion , toVersion ) ; \nList < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; \nif ( ! upgradeContext . registeredServices . isEmpty ( ) ) throw new StageException ( ContainerError . CONTAINER_0904 ) ; \nconf . setServiceVersion ( toVersion ) ; \nconf . setConfig ( configs ) ; \n} \ncatch ( StageException ex ) { \nissues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; \n} \nfinally { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nreturn conf ; \n} \n} \n"}
{"2101": "public class PipelineConfigurationUpgrader { \nstatic private void upgradeStageIfNeeded ( StageDefinition def , StageConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { \nint fromVersion = conf . getStageVersion ( ) ; \nint toVersion = def . getVersion ( ) ; \nif ( ! needsUpgrade ( toVersion , fromVersion , IssueCreator . getStage ( conf . getInstanceName ( ) ) , issues ) ) return ; \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \ntry { \nThread . currentThread ( ) . setContextClassLoader ( def . getStageClassLoader ( ) ) ; \nLOG . warn ( \"Upgrading stage instance '{}' from version '{}' to version '{}'\" , conf . getInstanceName ( ) , fromVersion , toVersion ) ; \nUpgradeContext upgradeContext = new UpgradeContext ( def . getLibrary ( ) , def . getName ( ) , conf . getInstanceName ( ) , fromVersion , toVersion ) ; \nList < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; \nconf . setStageVersion ( def . getVersion ( ) ) ; \nconf . setConfig ( configs ) ; \nif ( ! upgradeContext . registeredServices . isEmpty ( ) ) { \nList < ServiceConfiguration > services = new ArrayList < > ( ) ; \nservices . addAll ( conf . getServices ( ) ) ; \nupgradeContext . registeredServices . forEach ( ( s , c ) -> services . add ( new ServiceConfiguration ( s , - 1 , c ) ) ) ; \nconf . setServices ( services ) ; \n} \n} \ncatch ( StageException ex ) { \nissues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; \n} \nfinally { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \n} \n} \n"}
{"2102": "public class FieldValueReplacerProcessor { \nprivate List < String > getFieldsToNull ( List < NullReplacerConditionalConfig > nullReplacerConditionalConfigs , Set < String > fieldsThatDoNotExist , Set < String > fieldPaths , Record record ) throws OnRecordErrorException { \nList < String > fieldsToNull = new ArrayList < > ( ) ; \nfor ( NullReplacerConditionalConfig nullReplacerConditionalConfig : nullReplacerConditionalConfigs ) { \nList < String > fieldNamesToNull = nullReplacerConditionalConfig . fieldsToNull ; \nList < String > fieldPathsToNull = new ArrayList < > ( ) ; \nfor ( String fieldNameToNull : fieldNamesToNull ) { \ntry { \nfinal List < String > matchingPaths = FieldPathExpressionUtil . evaluateMatchingFieldPaths ( fieldNameToNull , fieldPathEval , fieldPathVars , record , fieldPaths ) ; \nif ( matchingPaths . isEmpty ( ) ) fieldsThatDoNotExist . add ( fieldNameToNull ) ; \nelse for ( String matchingField : matchingPaths ) { \nif ( record . has ( matchingField ) ) fieldPathsToNull . add ( matchingField ) ; \nelse fieldsThatDoNotExist . add ( matchingField ) ; \n} \n} \ncatch ( ELEvalException e ) { \nLOG . error ( \"Error evaluating condition: \" + nullReplacerConditionalConfig . condition , e ) ; \nthrow new OnRecordErrorException ( record , Errors . VALUE_REPLACER_07 , fieldNameToNull , e . toString ( ) , e ) ; \n} \n} \ntry { \nboolean evaluatedCondition = true ; \nif ( ! StringUtils . isEmpty ( nullReplacerConditionalConfig . condition ) ) evaluatedCondition = nullConditionELEval . eval ( nullConditionELVars , nullReplacerConditionalConfig . condition , Boolean . class ) ; \nif ( evaluatedCondition ) fieldsToNull . addAll ( fieldPathsToNull ) ; \n} \ncatch ( ELEvalException e ) { \nLOG . error ( \"Error evaluating condition: \" + nullReplacerConditionalConfig . condition , e ) ; \nthrow new OnRecordErrorException ( record , Errors . VALUE_REPLACER_06 , nullReplacerConditionalConfig . condition , e . toString ( ) ) ; \n} \n} \nreturn fieldsToNull ; \n} \n} \n"}
{"2103": "public class SystemPackage { \nprivate static boolean isSystemClass ( String name , List < String > packageList ) { \nboolean result = false ; \nif ( packageList != null ) { \nString canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; \nfor ( String c : packageList ) { \nboolean shouldInclude = true ; \nif ( c . startsWith ( \"-\" ) ) { \nc = c . substring ( 1 ) ; \nshouldInclude = false ; \n} \nif ( canonicalName . startsWith ( c ) ) if ( c . endsWith ( \".\" ) || canonicalName . length ( ) == c . length ( ) || canonicalName . length ( ) > c . length ( ) && canonicalName . charAt ( c . length ( ) ) == '$' ) if ( shouldInclude ) result = true ; \nelse return false ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2104": "public class XEvictingQueue { \n@ Override public boolean add ( E e ) { \ncheckNotNull ( e ) ; \nif ( maxSize == 0 ) return true ; \nif ( size ( ) == maxSize ) delegate . remove ( ) ; \ndelegate . add ( e ) ; \nreturn true ; \n} \n} \n"}
{"2105": "public class XEvictingQueue { \npublic E addAndGetEvicted ( E e ) { \ncheckNotNull ( e ) ; \nif ( maxSize == 0 ) return null ; \nE evicted = null ; \nif ( size ( ) == maxSize ) evicted = delegate . remove ( ) ; \ndelegate . add ( e ) ; \nreturn evicted ; \n} \n} \n"}
{"2106": "public class OptionalLoadingCache { \nprivate Optional < Value > valueOrDefault ( Key key , Optional < Value > value ) { \nif ( value . isPresent ( ) ) return value ; \nif ( ! cacheMissingValues ) delegate . invalidate ( key ) ; \nreturn defaultValue ; \n} \n} \n"}
{"2107": "public class PreviewPipelineRunner { \nprivate List < StageOutput > addReportedErrorsIfNeeded ( List < StageOutput > snapshotsOfAllStagesOutput ) { \nsynchronized ( this . reportedErrors ) { \nif ( reportedErrors . isEmpty ( ) ) return snapshotsOfAllStagesOutput ; \ntry { \nreturn snapshotsOfAllStagesOutput . stream ( ) . map ( so -> new StageOutput ( so . getInstanceName ( ) , so . getOutput ( ) , so . getErrorRecords ( ) , reportedErrors . get ( so . getInstanceName ( ) ) , so . getEventRecords ( ) ) ) . collect ( Collectors . toList ( ) ) ; \n} \nfinally { \nreportedErrors . clear ( ) ; \n} \n} \n} \n} \n"}
{"2110": "public class ProtobufTypeUtil { \npublic static void populateDefaultsAndExtensions ( Map < String , Descriptors . FileDescriptor > fileDescriptorMap , Map < String , Set < Descriptors . FieldDescriptor > > typeToExtensionMap , Map < String , Object > defaultValueMap ) { \nfor ( Descriptors . FileDescriptor f : fileDescriptorMap . values ( ) ) { \nfor ( Descriptors . FieldDescriptor fieldDescriptor : f . getExtensions ( ) ) { \nString containingType = fieldDescriptor . getContainingType ( ) . getFullName ( ) ; \nSet < Descriptors . FieldDescriptor > fieldDescriptors = typeToExtensionMap . get ( containingType ) ; \nif ( fieldDescriptors == null ) { \nfieldDescriptors = new LinkedHashSet < > ( ) ; \ntypeToExtensionMap . put ( containingType , fieldDescriptors ) ; \n} \nfieldDescriptors . add ( fieldDescriptor ) ; \nif ( fieldDescriptor . hasDefaultValue ( ) ) defaultValueMap . put ( containingType + \".\" + fieldDescriptor . getName ( ) , fieldDescriptor . getDefaultValue ( ) ) ; \n} \nfor ( Descriptors . Descriptor d : f . getMessageTypes ( ) ) { \naddDefaultsAndExtensions ( typeToExtensionMap , defaultValueMap , d ) ; \n} \n} \n} \n} \n"}
{"2111": "public class ProtobufTypeUtil { \npublic static Descriptors . Descriptor getDescriptor ( DescriptorProtos . FileDescriptorSet set , Map < String , Descriptors . FileDescriptor > fileDescriptorMap , String descriptorFile , String qualifiedMessageType ) throws StageException { \nString packageName = null ; \nString messageType = qualifiedMessageType ; \nint lastIndex = qualifiedMessageType . lastIndexOf ( '.' ) ; \nif ( lastIndex != - 1 ) { \npackageName = qualifiedMessageType . substring ( 0 , lastIndex ) ; \nmessageType = qualifiedMessageType . substring ( lastIndex + 1 ) ; \n} \nDescriptorProtos . FileDescriptorProto file = getFileDescProtoForMsgType ( packageName , messageType , set ) ; \nif ( file == null ) throw new StageException ( Errors . PROTOBUF_00 , qualifiedMessageType , descriptorFile ) ; \nDescriptors . FileDescriptor fileDescriptor = fileDescriptorMap . get ( file . getName ( ) ) ; \nreturn fileDescriptor . findMessageTypeByName ( messageType ) ; \n} \n} \n"}
{"2112": "public class ProtobufTypeUtil { \npublic static Field protobufToSdcField ( Record record , String fieldPath , Descriptors . Descriptor descriptor , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Object message ) throws DataParserException { \nLinkedHashMap < String , Field > sdcRecordMapFieldValue = new LinkedHashMap < > ( ) ; \nMap < String , Descriptors . FieldDescriptor > protobufFields = new LinkedHashMap < > ( ) ; \nfor ( Descriptors . FieldDescriptor fieldDescriptor : descriptor . getFields ( ) ) { \nprotobufFields . put ( fieldDescriptor . getName ( ) , fieldDescriptor ) ; \n} \nMap < Descriptors . FieldDescriptor , Object > values = ( ( DynamicMessage ) message ) . getAllFields ( ) ; \nfor ( Descriptors . FieldDescriptor fieldDescriptor : protobufFields . values ( ) ) { \nObject value = values . get ( fieldDescriptor ) ; \nsdcRecordMapFieldValue . put ( fieldDescriptor . getName ( ) , createField ( record , fieldPath , fieldDescriptor , messageTypeToExtensionMap , value ) ) ; \n} \nif ( messageTypeToExtensionMap . containsKey ( descriptor . getFullName ( ) ) ) for ( Descriptors . FieldDescriptor fieldDescriptor : messageTypeToExtensionMap . get ( descriptor . getFullName ( ) ) ) { \nif ( values . containsKey ( fieldDescriptor ) ) { \nObject value = values . get ( fieldDescriptor ) ; \nsdcRecordMapFieldValue . put ( fieldDescriptor . getName ( ) , createField ( record , fieldPath , fieldDescriptor , messageTypeToExtensionMap , value ) ) ; \n} \n} \nUnknownFieldSet unknownFields = ( ( DynamicMessage ) message ) . getUnknownFields ( ) ; \nif ( ! unknownFields . asMap ( ) . isEmpty ( ) ) { \nByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; \ntry { \nunknownFields . writeDelimitedTo ( bOut ) ; \nbOut . flush ( ) ; \nbOut . close ( ) ; \n} \ncatch ( IOException e ) { \nthrow new DataParserException ( Errors . PROTOBUF_10 , e . toString ( ) , e ) ; \n} \nString path = fieldPath . isEmpty ( ) ? FORWARD_SLASH : fieldPath ; \nbyte [ ] bytes = org . apache . commons . codec . binary . Base64 . encodeBase64 ( bOut . toByteArray ( ) ) ; \nrecord . getHeader ( ) . setAttribute ( PROTOBUF_UNKNOWN_FIELDS_PREFIX + path , new String ( bytes , StandardCharsets . UTF_8 ) ) ; \n} \nreturn Field . createListMap ( sdcRecordMapFieldValue ) ; \n} \n} \n"}
{"2114": "public class ProtobufTypeUtil { \nprivate static DynamicMessage sdcFieldToProtobufMsg ( Record record , Field field , String fieldPath , Descriptors . Descriptor desc , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Map < String , Object > defaultValueMap ) throws DataGeneratorException { \nif ( field == null ) return null ; \nDynamicMessage . Builder builder = DynamicMessage . newBuilder ( desc ) ; \nList < Descriptors . FieldDescriptor > fields = new ArrayList < > ( ) ; \nfields . addAll ( desc . getFields ( ) ) ; \nif ( messageTypeToExtensionMap . containsKey ( desc . getFullName ( ) ) ) fields . addAll ( messageTypeToExtensionMap . get ( desc . getFullName ( ) ) ) ; \nMap < String , Field > valueAsMap = field . getValueAsMap ( ) ; \nfor ( Descriptors . FieldDescriptor f : fields ) { \nField mapField = valueAsMap . get ( f . getName ( ) ) ; \nif ( f . isMapField ( ) ) handleMapField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; \nelse if ( f . isRepeated ( ) ) if ( mapField != null ) handleRepeatedField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; \nelse handleNonRepeatedField ( record , valueAsMap , fieldPath , messageTypeToExtensionMap , defaultValueMap , desc , f , builder ) ; \n} \ntry { \nhandleUnknownFields ( record , fieldPath , builder ) ; \n} \ncatch ( IOException e ) { \nthrow new DataGeneratorException ( Errors . PROTOBUF_05 , e . toString ( ) , e ) ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"2117": "public class KuduUtils { \npublic static Field . Type convertFromKuduType ( Type kuduType ) { \nswitch ( kuduType ) { \ncase BINARY : return Field . Type . BYTE_ARRAY ; \ncase BOOL : return Field . Type . BOOLEAN ; \ncase DOUBLE : return Field . Type . DOUBLE ; \ncase FLOAT : return Field . Type . FLOAT ; \ncase INT8 : return Field . Type . BYTE ; \ncase INT16 : return Field . Type . SHORT ; \ncase INT32 : return Field . Type . INTEGER ; \ncase INT64 : return Field . Type . LONG ; \ncase STRING : return Field . Type . STRING ; \ncase UNIXTIME_MICROS : return Field . Type . DATETIME ; \ndefault : if ( \"DECIMAL\" . equals ( kuduType . name ( ) ) ) return Field . Type . DECIMAL ; \nthrow new UnsupportedOperationException ( \"Unknown data type: \" + kuduType . getName ( ) ) ; \n} \n} \n} \n"}
{"2118": "public class KuduUtils { \npublic static Field createField ( RowResult result , String fieldName , Type type ) throws StageException { \nswitch ( type ) { \ncase INT8 : return Field . create ( Field . Type . BYTE , result . getByte ( fieldName ) ) ; \ncase INT16 : return Field . create ( Field . Type . SHORT , result . getShort ( fieldName ) ) ; \ncase INT32 : return Field . create ( Field . Type . INTEGER , result . getInt ( fieldName ) ) ; \ncase INT64 : return Field . create ( Field . Type . LONG , result . getLong ( fieldName ) ) ; \ncase BINARY : try { \nreturn Field . create ( Field . Type . BYTE_ARRAY , result . getBinary ( fieldName ) ) ; \n} \ncatch ( IllegalArgumentException ex ) { \nthrow new OnRecordErrorException ( Errors . KUDU_35 , fieldName ) ; \n} \ncase STRING : return Field . create ( Field . Type . STRING , result . getString ( fieldName ) ) ; \ncase BOOL : return Field . create ( Field . Type . BOOLEAN , result . getBoolean ( fieldName ) ) ; \ncase FLOAT : return Field . create ( Field . Type . FLOAT , result . getFloat ( fieldName ) ) ; \ncase DOUBLE : return Field . create ( Field . Type . DOUBLE , result . getDouble ( fieldName ) ) ; \ncase UNIXTIME_MICROS : return Field . create ( Field . Type . DATETIME , new Date ( result . getLong ( fieldName ) / 1000L ) ) ; \ndefault : if ( \"DECIMAL\" . equals ( type . name ( ) ) ) return Field . create ( Field . Type . DECIMAL , result . getDecimal ( fieldName ) ) ; \nthrow new StageException ( Errors . KUDU_10 , fieldName , type . getName ( ) ) ; \n} \n} \n} \n"}
{"2120": "public class FileLine { \npublic String getText ( ) { \nif ( line == null ) line = new String ( buffer , offsetInChunk , length , charset ) ; \nreturn line ; \n} \n} \n"}
{"2121": "public class ValidationUtil { \npublic static void addMissingConfigsToStage ( StageLibraryTask stageLibrary , StageConfiguration stageConf ) { \nStageDefinition stageDef = stageLibrary . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , false ) ; \nif ( stageDef != null ) for ( ConfigDefinition configDef : stageDef . getConfigDefinitions ( ) ) { \nString configName = configDef . getName ( ) ; \nConfig config = stageConf . getConfig ( configName ) ; \nif ( config == null ) { \nObject defaultValue = configDef . getDefaultValue ( ) ; \nLOG . warn ( \"Stage '{}' missing configuration '{}', adding with '{}' as default\" , stageConf . getInstanceName ( ) , configName , defaultValue ) ; \nconfig = new Config ( configName , defaultValue ) ; \nstageConf . addConfig ( config ) ; \n} \n} \n} \n} \n"}
{"2122": "public class HttpProcessor { \nprivate Record parseResponse ( InputStream response ) throws StageException { \nRecord record = null ; \nif ( conf . httpMethod == HttpMethod . HEAD ) { \nrecord = getContext ( ) . createRecord ( \"\" ) ; \nrecord . set ( Field . create ( new HashMap ( ) ) ) ; \n} \nelse if ( response != null ) try ( DataParser parser = parserFactory . getParser ( \"\" , response , \"0\" ) ) { \nrecord = parser . parse ( ) ; \nif ( conf . dataFormat == DataFormat . TEXT ) record . set ( record . get ( \"/text\" ) ) ; \n} \ncatch ( IOException | DataParserException e ) { \nerrorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; \n} \nreturn record ; \n} \n} \n"}
{"2123": "public class HttpProcessor { \nprivate void addResponseHeaders ( Record record , Response response ) throws StageException { \nif ( conf . headerOutputLocation == HeaderOutputLocation . NONE ) return ; \nRecord . Header header = record . getHeader ( ) ; \nif ( conf . headerOutputLocation == HeaderOutputLocation . FIELD ) writeResponseHeaderToField ( record , response ) ; \nelse if ( conf . headerOutputLocation == HeaderOutputLocation . HEADER ) writeResponseHeaderToRecordHeader ( response , header ) ; \n} \n} \n"}
{"2124": "public class HttpProcessor { \nprivate void writeResponseHeaderToField ( Record record , Response response ) throws StageException { \nif ( record . has ( conf . headerOutputField ) ) throw new StageException ( Errors . HTTP_11 , conf . headerOutputField ) ; \nMap < String , Field > headers = new HashMap < > ( response . getStringHeaders ( ) . size ( ) ) ; \nfor ( Map . Entry < String , List < String > > entry : response . getStringHeaders ( ) . entrySet ( ) ) { \nif ( ! entry . getValue ( ) . isEmpty ( ) ) { \nString firstValue = entry . getValue ( ) . get ( 0 ) ; \nheaders . put ( entry . getKey ( ) , Field . create ( firstValue ) ) ; \n} \n} \nrecord . set ( conf . headerOutputField , Field . create ( headers ) ) ; \n} \n} \n"}
{"2126": "public class BlobStoreTaskImpl { \nsynchronized private void saveMetadata ( ) throws StageException { \nif ( Files . exists ( newMetadataFile ) ) throw new StageException ( BlobStoreError . BLOB_STORE_0010 ) ; \ntry ( OutputStream os = Files . newOutputStream ( newMetadataFile , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING ) ) { \njsonMapper . writeValue ( os , metadata ) ; \n} \ncatch ( IOException e ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0001 , e . toString ( ) , e ) ; \n} \ntry { \nif ( Files . exists ( metadataFile ) ) Files . delete ( metadataFile ) ; \n} \ncatch ( IOException e ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0011 , e . toString ( ) , e ) ; \n} \ntry { \nFiles . move ( newMetadataFile , metadataFile ) ; \n} \ncatch ( IOException e ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0012 , e . toString ( ) , e ) ; \n} \n} \n} \n"}
{"2129": "public class HttpClientSource { \nprivate void incrementSourceOffset ( HttpSourceOffset sourceOffset , int increment ) { \nif ( conf . pagination . mode == PaginationMode . BY_PAGE ) sourceOffset . incrementStartAt ( 1 ) ; \nelse if ( conf . pagination . mode == PaginationMode . BY_OFFSET ) sourceOffset . incrementStartAt ( increment ) ; \n} \n} \n"}
{"2130": "public class HttpClientSource { \nprivate int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { \nint numSubRecords = 0 ; \nif ( ! record . has ( conf . pagination . resultFieldPath ) ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nField resultField = record . get ( conf . pagination . resultFieldPath ) ; \nif ( resultField . getType ( ) != Field . Type . LIST ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nList < Field > results = resultField . getValueAsList ( ) ; \nint subRecordIdx = 0 ; \nfor ( Field result : results ) { \nRecord r = getContext ( ) . createRecord ( sourceOffset + \"::\" + subRecordIdx ++ ) ; \nif ( conf . pagination . keepAllFields ) { \nr . set ( record . get ( ) . clone ( ) ) ; \nr . set ( conf . pagination . resultFieldPath , result ) ; \n} \nelse r . set ( result ) ; \naddResponseHeaders ( r . getHeader ( ) ) ; \nbatchMaker . addRecord ( r ) ; \n++ numSubRecords ; \n} \nif ( conf . pagination . mode != PaginationMode . LINK_FIELD ) haveMorePages = numSubRecords > 0 ; \nreturn numSubRecords ; \n} \n} \n"}
{"2131": "public class HttpClientSource { \nprivate void addResponseHeaders ( Record . Header header ) { \nfinal MultivaluedMap < String , String > headers = getResponse ( ) . getStringHeaders ( ) ; \nif ( headers == null ) return ; \nfor ( Map . Entry < String , List < String > > entry : headers . entrySet ( ) ) { \nif ( ! entry . getValue ( ) . isEmpty ( ) ) { \nString firstValue = entry . getValue ( ) . get ( 0 ) ; \nheader . setAttribute ( entry . getKey ( ) , firstValue ) ; \n} \n} \n} \n} \n"}
{"2133": "public class HttpClientSource { \nprivate Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { \nOptional < String > newSourceOffset = Optional . empty ( ) ; \nif ( getResponse ( ) == null ) return newSourceOffset ; \nint status = getResponse ( ) . getStatus ( ) ; \nif ( status < 200 || status >= 300 ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nif ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { \nnext = getResponse ( ) . getLink ( \"next\" ) ; \nif ( next == null ) haveMorePages = false ; \n} \nif ( getResponse ( ) . hasEntity ( ) ) newSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; \nelse if ( conf . httpMethod . getLabel ( ) == \"HEAD\" ) newSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; \nreturn newSourceOffset ; \n} \n} \n"}
{"2135": "public class ShimUtil { \npublic static DataParserException convert ( com . streamsets . pipeline . lib . parser . DataParserException original ) { \nif ( original instanceof com . streamsets . pipeline . lib . parser . RecoverableDataParserException ) return new RecoverableDataParserException ( ( ( com . streamsets . pipeline . lib . parser . RecoverableDataParserException ) original ) . getUnparsedRecord ( ) , original . getErrorCode ( ) , original . getParams ( ) ) ; \nreturn new DataParserException ( original . getErrorCode ( ) , original . getParams ( ) ) ; \n} \n} \n"}
{"2137": "public class GoogleCloudCredentialsConfig { \nprivate Credentials getCredentials ( Stage . Context context , List < Stage . ConfigIssue > issues ) { \nCredentials credentials = null ; \nFile credentialsFile ; \nif ( Paths . get ( path ) . isAbsolute ( ) ) credentialsFile = new File ( path ) ; \nelse credentialsFile = new File ( context . getResourcesDirectory ( ) , path ) ; \nif ( ! credentialsFile . exists ( ) || ! credentialsFile . isFile ( ) ) { \nLOG . error ( GOOGLE_01 . getMessage ( ) , credentialsFile . getPath ( ) ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_01 , credentialsFile . getPath ( ) ) ) ; \nreturn null ; \n} \ntry ( InputStream in = new FileInputStream ( credentialsFile ) ) { \ncredentials = ServiceAccountCredentials . fromStream ( in ) ; \n} \ncatch ( IOException | IllegalArgumentException e ) { \nLOG . error ( GOOGLE_02 . getMessage ( ) , e ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_02 ) ) ; \n} \nreturn credentials ; \n} \n} \n"}
{"2138": "public class PreviewApi { \npublic PreviewInfoJson previewWithOverride ( String pipelineId , List < StageOutputJson > stageOutputsToOverrideJson , String rev , Integer batchSize , Integer batches , Boolean skipTargets , String endStage , Long timeout ) throws ApiException { \nObject postBody = stageOutputsToOverrideJson ; \nbyte [ ] postBinaryBody = null ; \nif ( pipelineId == null ) throw new ApiException ( 400 , \"Missing the required parameter 'pipelineId' when calling previewWithOverride\" ) ; \nif ( stageOutputsToOverrideJson == null ) throw new ApiException ( 400 , \"Missing the required parameter 'stageOutputsToOverrideJson' when calling previewWithOverride\" ) ; \nString path = \"/v1/pipeline/{pipelineId}/preview\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) . replaceAll ( \"\\\\{\" + \"pipelineId\" + \"\\\\}\" , apiClient . escapeString ( pipelineId . toString ( ) ) ) ; \nList < Pair > queryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > headerParams = new HashMap < String , String > ( ) ; \nMap < String , Object > formParams = new HashMap < String , Object > ( ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"rev\" , rev ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"batchSize\" , batchSize ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"batches\" , batches ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"skipTargets\" , skipTargets ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"endStage\" , endStage ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"timeout\" , timeout ) ) ; \nfinal String [ ] accepts = { \n\"application/json\" } \n; \nfinal String accept = apiClient . selectHeaderAccept ( accepts ) ; \nfinal String [ ] contentTypes = { \n} \n; \nfinal String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; \nString [ ] authNames = new String [ ] { \n\"basic\" } \n; \nTypeRef returnType = new TypeRef < PreviewInfoJson > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( path , \"POST\" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; \n} \n} \n"}
{"2139": "public class AbstractOverrunDelimitedReader { \nprotected int copyToBuffer ( StringBuilder s , int initialLen , int startChar , int currentChar ) { \nint overrun = 0 ; \nint currentSize = s . length ( ) - initialLen ; \nint readSize = currentChar - startChar ; \nif ( maxLine > - 1 && currentSize + readSize > maxLine ) { \nint adjustedReadSize = maxLine - currentSize ; \nif ( adjustedReadSize > 0 ) { \ns . append ( cb , startChar , adjustedReadSize ) ; \noverrun = readSize - adjustedReadSize ; \n} \nelse overrun = readSize ; \n} \nelse s . append ( cb , startChar , readSize ) ; \nreturn overrun ; \n} \n} \n"}
{"2140": "public class ApplicationPackage { \nstatic void removeLogicalDuplicates ( SortedSet < String > packages ) { \nIterator < String > iterator = packages . iterator ( ) ; \nif ( ! iterator . hasNext ( ) ) return ; \nString last = iterator . next ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nString current = iterator . next ( ) ; \nif ( current . startsWith ( last ) ) iterator . remove ( ) ; \nelse last = current ; \n} \n} \n} \n"}
{"2141": "public class HdfsTarget { \nprotected void emptyBatch ( ) throws StageException { \nsetBatchTime ( ) ; \ntry { \nhdfsTargetConfigBean . getUGI ( ) . doAs ( new PrivilegedExceptionAction < Void > ( ) { \n@ Override public Void run ( ) throws Exception { \nhdfsTargetConfigBean . getCurrentWriters ( ) . purge ( ) ; \nif ( hdfsTargetConfigBean . getLateWriters ( ) != null ) hdfsTargetConfigBean . getLateWriters ( ) . purge ( ) ; \nreturn null ; \n} \n} \n) ; \n} \ncatch ( Exception ex ) { \nthrow throwStageException ( ex ) ; \n} \n} \n} \n"}
{"2142": "public class MultiLineLiveFileReader { \nint findNextMainLine ( LiveFileChunk chunk , int startIdx ) { \nList < FileLine > lines = chunk . getLines ( ) ; \nint found = - 1 ; \nfor ( int i = startIdx ; \nfound == - 1 && i < lines . size ( ) ; \ni ++ ) if ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) found = i ; \nreturn found ; \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nwhile ( idx > - 1 ) { \nfor ( int i = pos ; \ni < idx ; \ni ++ ) incompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( int i = pos ; \ni < chunkLines . size ( ) ; \ni ++ ) incompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \nif ( completeLines . isEmpty ( ) ) chunk = null ; \nelse chunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \nreturn chunk ; \n} \n} \n"}
{"2144": "public class ConnectionManager { \npublic void closeConnection ( ) { \nLOGGER . debug ( \"Closing connection\" ) ; \nConnection connectionToRemove = threadLocalConnection . get ( ) ; \njdbcUtil . closeQuietly ( connectionToRemove ) ; \nif ( connectionToRemove != null ) synchronized ( this ) { \nconnectionsToCloseDuringDestroy . remove ( connectionToRemove ) ; \n} \nthreadLocalConnection . set ( null ) ; \n} \n} \n"}
{"2145": "public class FieldRenamerProcessor { \nprivate static String escapeQuotedSubstring ( String input ) { \nString [ ] parts = input . split ( \"'\" ) ; \nStringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) if ( ( i % 2 ) == 1 ) output . append ( \"'\" ) . append ( parts [ i ] . replace ( \"|\" , \"\\\\|\" ) ) . append ( \"'\" ) ; \nelse output . append ( parts [ i ] ) ; \nreturn output . toString ( ) ; \n} \n} \n"}
{"2148": "public class Producer { \npublic Object put ( OffsetAndResult < Map . Entry > batch ) { \nif ( consumerError != null ) throw new RuntimeException ( Utils . format ( \"Consumer encountered error: {}\" , consumerError ) , consumerError ) ; \nif ( producerError != null ) throw new RuntimeException ( Utils . format ( \"Producer encountered error: {}\" , producerError ) , producerError ) ; \ntry { \nObject expectedOffset = \"EMPTY_BATCH\" ; \nif ( ! batch . getResult ( ) . isEmpty ( ) ) expectedOffset = batch . getResult ( ) . get ( batch . getResult ( ) . size ( ) - 1 ) . getKey ( ) ; \nwhile ( ! dataChannel . offer ( batch , 10 , TimeUnit . MILLISECONDS ) ) for ( ControlChannel . Message controlMessage : controlChannel . getProducerMessages ( ) ) { \nswitch ( controlMessage . getType ( ) ) { \ncase CONSUMER_ERROR : Throwable throwable = ( Throwable ) controlMessage . getPayload ( ) ; \nconsumerError = throwable ; \nthrow new ConsumerRuntimeException ( Utils . format ( \"Consumer encountered error: {}\" , throwable ) , throwable ) ; \ndefault : String msg = Utils . format ( \"Illegal control message type: '{}'\" , controlMessage . getType ( ) ) ; \nthrow new IllegalStateException ( msg ) ; \n} \n} \nreturn expectedOffset ; \n} \ncatch ( Throwable throwable ) { \ncontrolChannel . producerComplete ( ) ; \nif ( ! ( throwable instanceof ConsumerRuntimeException ) ) { \nString msg = \"Error caught in producer: \" + throwable ; \nLOG . error ( msg , throwable ) ; \ncontrolChannel . producerError ( throwable ) ; \nif ( producerError == null ) producerError = throwable ; \n} \nthrow Throwables . propagate ( throwable ) ; \n} \n} \n} \n"}
{"2150": "public class GrokDictionary { \nprivate String digestExpressionAux ( String originalExpression ) { \nfinal String PATTERN_START = \"%{\" ; \nfinal String PATTERN_STOP = \"}\" ; \nfinal char PATTERN_DELIMITER = ':' ; \nwhile ( true ) { \nint PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; \nint PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; \nif ( PATTERN_START_INDEX < 0 || PATTERN_STOP_INDEX < 0 ) break ; \nString grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; \nint PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; \nString regexName = grokPattern ; \nString groupName = null ; \nif ( PATTERN_DELIMITER_INDEX >= 0 ) { \nregexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; \ngroupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; \n} \nfinal String dictionaryValue = regexDictionary . get ( regexName ) ; \nif ( dictionaryValue == null ) throw new GrokCompilationException ( \"Missing value for regex name : \" + regexName ) ; \nif ( dictionaryValue . contains ( PATTERN_START ) ) break ; \nString replacement = dictionaryValue ; \nif ( null != groupName ) replacement = \"(?<\" + groupName + \">\" + dictionaryValue + \")\" ; \noriginalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; \n} \nreturn originalExpression ; \n} \n} \n"}
{"2154": "public class AggregatorDataProvider { \npublic Map < Aggregator , AggregatorData > roll ( long newDataWindowEndTimeMillis ) { \nUtils . checkState ( started , \"Not started\" ) ; \nUtils . checkState ( ! stopped , \"Already stopped\" ) ; \nMap < Aggregator , AggregatorData > result = data ; \nMap < Aggregator , AggregatorData > newData = new ConcurrentHashMap < > ( ) ; \nfor ( Aggregator aggregator : aggregators ) { \nnewData . put ( aggregator , aggregator . createAggregatorData ( newDataWindowEndTimeMillis ) ) ; \n} \ndata = newData ; \nMap < Aggregator , AggregatorData > oldData = result ; \nresult = aggregateDataWindows ( result ) ; \nif ( currentDataWindow != null ) currentDataWindow . setDataAndClose ( oldData ) ; \nDataWindow newDataWindow = createDataWindow ( newDataWindowEndTimeMillis ) ; \nsynchronized ( dataWindowQueue ) { \ndataWindowQueue . add ( newDataWindow ) ; \ndataWindowList = new ArrayList < > ( dataWindowQueue ) ; \n} \ncurrentDataWindow = newDataWindow ; \nreturn result ; \n} \n} \n"}
{"2158": "public class SampleTarget { \nprivate void write ( Record record ) throws OnRecordErrorException { \nif ( ! record . has ( \"/someField\" ) ) throw new OnRecordErrorException ( Errors . SAMPLE_01 , record , \"exception detail message.\" ) ; \n} \n} \n"}
{"2160": "public class HiveMetastoreUtil { \nprivate static < T > Field generateInnerFieldFromTheList ( LinkedHashMap < String , T > original , String innerPairFirstFieldName , String innerPairSecondFieldName , boolean isSecondFieldHiveType ) throws HiveStageCheckedException { \nList < Field > columnList = new LinkedList < > ( ) ; \nfor ( Map . Entry < String , T > pair : original . entrySet ( ) ) { \nLinkedHashMap < String , Field > entry = new LinkedHashMap < > ( ) ; \nentry . put ( innerPairFirstFieldName , Field . create ( pair . getKey ( ) ) ) ; \nif ( isSecondFieldHiveType ) { \nHiveTypeInfo hiveTypeInfo = ( HiveTypeInfo ) pair . getValue ( ) ; \nentry . put ( innerPairSecondFieldName , hiveTypeInfo . getHiveType ( ) . getSupport ( ) . generateHiveTypeInfoFieldForMetadataRecord ( hiveTypeInfo ) ) ; \n} \nelse entry . put ( innerPairSecondFieldName , Field . create ( pair . getValue ( ) . toString ( ) ) ) ; \ncolumnList . add ( Field . createListMap ( entry ) ) ; \n} \nreturn ! columnList . isEmpty ( ) ? Field . create ( columnList ) : null ; \n} \n} \n"}
{"2161": "public class HiveMetastoreUtil { \npublic static String getTableName ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( metadataRecord . has ( SEP + TABLE_FIELD ) ) return metadataRecord . get ( SEP + TABLE_FIELD ) . getValueAsString ( ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , TABLE_FIELD , metadataRecord ) ; \n} \n} \n"}
{"2163": "public class HiveMetastoreUtil { \npublic static boolean getInternalField ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( metadataRecord . has ( SEP + INTERNAL_FIELD ) ) return metadataRecord . get ( SEP + INTERNAL_FIELD ) . getValueAsBoolean ( ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , INTERNAL_FIELD , metadataRecord ) ; \n} \n} \n"}
{"2164": "public class HiveMetastoreUtil { \npublic static String getLocation ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( metadataRecord . has ( SEP + LOCATION_FIELD ) ) return metadataRecord . get ( SEP + LOCATION_FIELD ) . getValueAsString ( ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , LOCATION_FIELD , metadataRecord ) ; \n} \n} \n"}
{"2165": "public class HiveMetastoreUtil { \npublic static boolean getCustomLocation ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( metadataRecord . get ( SEP + VERSION ) . getValueAsInteger ( ) < 3 ) return DEFAULT_CUSTOM_LOCATION ; \nif ( metadataRecord . has ( SEP + CUSTOM_LOCATION ) ) return metadataRecord . get ( SEP + CUSTOM_LOCATION ) . getValueAsBoolean ( ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , CUSTOM_LOCATION , metadataRecord ) ; \n} \n} \n"}
{"2166": "public class HiveMetastoreUtil { \npublic static String getAvroSchema ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( metadataRecord . has ( SEP + AVRO_SCHEMA ) ) return metadataRecord . get ( SEP + AVRO_SCHEMA ) . getValueAsString ( ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , AVRO_SCHEMA , metadataRecord ) ; \n} \n} \n"}
{"2167": "public class HiveMetastoreUtil { \npublic static String getDataFormat ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( metadataRecord . get ( SEP + VERSION ) . getValueAsInteger ( ) == 1 ) return DEFAULT_DATA_FORMAT ; \nif ( metadataRecord . has ( SEP + DATA_FORMAT ) ) return metadataRecord . get ( SEP + DATA_FORMAT ) . getValueAsString ( ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , DATA_FORMAT , metadataRecord ) ; \n} \n} \n"}
{"2168": "public class HiveMetastoreUtil { \npublic static Field newSchemaMetadataFieldBuilder ( String database , String tableName , LinkedHashMap < String , HiveTypeInfo > columnList , LinkedHashMap < String , HiveTypeInfo > partitionTypeList , boolean internal , String location , String avroSchema , HMPDataFormat dataFormat ) throws HiveStageCheckedException { \nLinkedHashMap < String , Field > metadata = new LinkedHashMap < > ( ) ; \nmetadata . put ( VERSION , Field . create ( SCHEMA_CHANGE_METADATA_RECORD_VERSION ) ) ; \nmetadata . put ( METADATA_RECORD_TYPE , Field . create ( MetadataRecordType . TABLE . name ( ) ) ) ; \nmetadata . put ( DATABASE_FIELD , Field . create ( database ) ) ; \nmetadata . put ( TABLE_FIELD , Field . create ( tableName ) ) ; \nmetadata . put ( LOCATION_FIELD , Field . create ( location ) ) ; \nmetadata . put ( DATA_FORMAT , Field . create ( dataFormat . name ( ) ) ) ; \nmetadata . put ( COLUMNS_FIELD , generateInnerFieldFromTheList ( columnList , COLUMN_NAME , TYPE_INFO , true ) ) ; \nif ( partitionTypeList != null && ! partitionTypeList . isEmpty ( ) ) metadata . put ( PARTITION_FIELD , generateInnerFieldFromTheList ( partitionTypeList , PARTITION_NAME , TYPE_INFO , true ) ) ; \nmetadata . put ( INTERNAL_FIELD , Field . create ( internal ) ) ; \nmetadata . put ( AVRO_SCHEMA , Field . create ( avroSchema ) ) ; \nreturn Field . createListMap ( metadata ) ; \n} \n} \n"}
{"2171": "public class HiveMetastoreUtil { \npublic static String serializeSchemaToHDFS ( UserGroupInformation loginUGI , final FileSystem fs , final String location , final String schemaFolder , final String databaseName , final String tableName , final String schemaJson ) throws StageException { \nString folderLocation ; \nif ( schemaFolder . startsWith ( SEP ) ) folderLocation = schemaFolder ; \nelse folderLocation = location + SEP + schemaFolder ; \nfinal Path schemasFolderPath = new Path ( folderLocation ) ; \nfinal String path = folderLocation + SEP + String . format ( AVRO_SCHEMA_FILE_FORMAT , databaseName , tableName , UUID . randomUUID ( ) . toString ( ) ) ; \ntry { \nloginUGI . doAs ( new PrivilegedExceptionAction < Void > ( ) { \n@ Override public Void run ( ) throws Exception { \nif ( ! fs . exists ( schemasFolderPath ) ) fs . mkdirs ( schemasFolderPath ) ; \nPath schemaFilePath = new Path ( path ) ; \nif ( ! fs . exists ( schemaFilePath ) ) try ( FSDataOutputStream os = fs . create ( schemaFilePath ) ) { \nbyte [ ] schemaBytes = schemaJson . getBytes ( \"UTF-8\" ) ; \nos . write ( schemaBytes , 0 , schemaBytes . length ) ; \n} \nelse { \nLOG . error ( Utils . format ( \"Already schema file {} exists in HDFS\" , path ) ) ; \nthrow new IOException ( \"Already schema file exists\" ) ; \n} \nreturn null ; \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nLOG . error ( \"Error in Writing Schema to HDFS: \" + e . toString ( ) , e ) ; \nthrow new StageException ( Errors . HIVE_18 , path , e . getMessage ( ) ) ; \n} \nreturn path ; \n} \n} \n"}
{"2172": "public class JdbcGenericRecordWriter { \n@ VisibleForTesting @ SuppressWarnings ( \"unchecked\" ) int setParameters ( int opCode , SortedMap < String , String > columnsToParameters , final Record record , final Connection connection , PreparedStatement statement ) throws OnRecordErrorException { \nint paramIdx = 1 ; \nif ( opCode != OperationType . DELETE_CODE ) paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , record , connection , opCode ) ; \nif ( opCode != OperationType . INSERT_CODE ) paramIdx = setPrimaryKeys ( paramIdx , record , statement , opCode ) ; \nreturn paramIdx ; \n} \n} \n"}
{"2174": "public class SyslogDecoder { \npublic static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { \nLocalDateTime now = LocalDateTime . now ( ) ; \nint year = now . getYear ( ) ; \nts = TWO_SPACES . matcher ( ts ) . replaceFirst ( \" \" ) ; \nLocalDateTime date ; \ntry { \nMonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; \nLocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; \ndate = now ; \ndate = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; \ndate = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; \ndate = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; \n} \ncatch ( DateTimeParseException e ) { \nthrow new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; \n} \nLocalDateTime fixed = date ; \nif ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) fixed = date . withYear ( year - 1 ) ; \nelse if ( fixed . isBefore ( now ) && fixed . plusMonths ( 11 ) . isBefore ( now ) ) fixed = date . withYear ( year + 1 ) ; \ndate = fixed ; \nreturn date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; \n} \n} \n"}
{"2175": "public class Utils { \npublic static String format ( String template , Object ... args ) { \nString [ ] templateArr = TEMPLATES . get ( template ) ; \nif ( templateArr == null ) { \ntemplateArr = prepareTemplate ( template ) ; \nTEMPLATES . put ( template , templateArr ) ; \n} \nStringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ni < templateArr . length ; \ni ++ ) { \nsb . append ( templateArr [ i ] ) ; \nif ( args != null && ( i < templateArr . length - 1 ) ) sb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2177": "public class SolrTarget { \nprivate boolean checkRecordContainsSolrFields ( Map < String , Field > recordFieldMap , Record record , List < String > solrFieldsMap , Errors errorToThrow ) throws StageException { \nList < String > fieldsFound = new ArrayList < > ( ) ; \nrecordFieldMap . keySet ( ) . forEach ( recordFieldKey -> { \nif ( solrFieldsMap . contains ( recordFieldKey ) ) fieldsFound . add ( recordFieldKey ) ; \n} \n) ; \nif ( solrFieldsMap . size ( ) != fieldsFound . size ( ) ) { \nSet < String > missingFields = new HashSet < > ( ) ; \nsolrFieldsMap . forEach ( requiredField -> { \nif ( ! fieldsFound . contains ( requiredField ) ) missingFields . add ( requiredField ) ; \n} \n) ; \nhandleError ( record , errorToThrow , Joiner . on ( \",\" ) . join ( missingFields ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"2178": "public class SolrTarget { \nprivate List < String > filterAutogeneratedFieldNames ( List < String > fieldNames ) { \nList < String > result = new ArrayList < > ( ) ; \nfieldNames . forEach ( name -> { \nif ( ! autogeneratedFieldNamesMap . contains ( name ) ) result . add ( name ) ; \n} \n) ; \nreturn result ; \n} \n} \n"}
{"2182": "public class CouchbaseConnector { \npublic static synchronized CouchbaseConnector getInstance ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { \nMap < String , Object > runnerSharedMap = context . getStageRunnerSharedMap ( ) ; \nif ( runnerSharedMap . containsKey ( INSTANCE ) ) LOG . debug ( \"Using existing instance of CouchbaseConnector\" ) ; \nelse { \nLOG . debug ( \"CouchbaseConnector not yet instantiated. Creating new instance\" ) ; \nvalidateConfig ( config , issues , context ) ; \nif ( issues . isEmpty ( ) ) runnerSharedMap . put ( INSTANCE , new CouchbaseConnector ( config , issues , context ) ) ; \n} \nreturn ( CouchbaseConnector ) runnerSharedMap . get ( INSTANCE ) ; \n} \n} \n"}
{"2184": "public class CouchbaseConnector { \nprivate static void validateConfig ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { \nif ( config . couchbase . nodes == null ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.nodes\" , Errors . COUCHBASE_29 ) ) ; \nif ( config . couchbase . kvTimeout < 0 ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.kvTimeout\" , Errors . COUCHBASE_30 ) ) ; \nif ( config . couchbase . connectTimeout < 0 ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.connectTimeout\" , Errors . COUCHBASE_31 ) ) ; \nif ( config . couchbase . disconnectTimeout < 0 ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.disconnectTimeout\" , Errors . COUCHBASE_32 ) ) ; \nif ( config . couchbase . tls . tlsEnabled ) config . couchbase . tls . init ( context , Groups . COUCHBASE . name ( ) , \"config.couchbase.tls.\" , issues ) ; \nif ( config . credentials . version == null ) issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.version\" , Errors . COUCHBASE_33 ) ) ; \nif ( config . credentials . version == AuthenticationType . USER ) { \nif ( config . credentials . userName == null ) issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.userName\" , Errors . COUCHBASE_34 ) ) ; \nif ( config . credentials . userPassword == null ) issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.userPassword\" , Errors . COUCHBASE_35 ) ) ; \n} \n} \n} \n"}
{"2187": "public class Vault { \npublic String read ( String path , String key , long delay ) { \nif ( ! secrets . containsKey ( path ) ) { \nVaultClient vault = new VaultClient ( getConfig ( ) ) ; \nSecret secret ; \ntry { \nsecret = vault . logical ( ) . read ( path ) ; \n} \ncatch ( VaultException e ) { \nLOG . error ( e . toString ( ) , e ) ; \nthrow new VaultRuntimeException ( e . toString ( ) ) ; \n} \nString leaseId ; \nif ( secret . isRenewable ( ) ) leaseId = secret . getLeaseId ( ) ; \nelse leaseId = path + \"/\" ; \nleases . put ( leaseId , System . currentTimeMillis ( ) + ( secret . getLeaseDuration ( ) * 1000 ) ) ; \nsecrets . put ( path , secret ) ; \ntry { \nThread . sleep ( delay ) ; \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \n} \nMap < String , Object > data = secrets . get ( path ) . getData ( ) ; \nString value = getSecretValue ( data , key ) . orElseThrow ( ( ) -> new VaultRuntimeException ( \"Value not found for key\" ) ) ; \nLOG . trace ( \"CredentialStore '{}' Vault, retrieved value for key '{}'\" , csId , key ) ; \nreturn value ; \n} \n} \n"}
{"2188": "public class CouchbaseTarget { \nprivate WriteOperationType getOperationFromHeader ( Record record , String key ) { \nString op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; \nif ( op == null || op . isEmpty ( ) ) return config . defaultWriteOperation ; \nint opCode ; \ntry { \nopCode = Integer . parseInt ( op ) ; \n} \ncatch ( NumberFormatException e ) { \nLOG . debug ( \"Unparsable CDC operation. Sending record to error.\" ) ; \nhandleError ( record , Errors . COUCHBASE_08 , e ) ; \nreturn null ; \n} \nswitch ( opCode ) { \ncase OperationType . INSERT_CODE : return WriteOperationType . INSERT ; \ncase OperationType . UPDATE_CODE : return WriteOperationType . REPLACE ; \ncase OperationType . UPSERT_CODE : return WriteOperationType . UPSERT ; \ncase OperationType . DELETE_CODE : return WriteOperationType . DELETE ; \ndefault : switch ( config . unsupportedOperation ) { \ncase DISCARD : LOG . debug ( \"Unsupported CDC operation for key: {}. Discarding record per configuration.\" , key ) ; \nreturn null ; \ncase TOERROR : LOG . debug ( \"Unsupported CDC operation for key: {}. Sending record to error configuration.\" , key ) ; \nhandleError ( record , Errors . COUCHBASE_09 , new RuntimeException ( ) ) ; \nreturn null ; \ndefault : LOG . debug ( \"Unsupported CDC operation for key: {}. Using default write operation per configuration.\" , key ) ; \nreturn config . defaultWriteOperation ; \n} \n} \n} \n} \n"}
{"2189": "public class CouchbaseTarget { \nprivate Observable < AbstractDocument > writeDoc ( String key , int ttl , long cas , ByteArrayOutputStream baos , Record record ) { \nWriteOperationType opType = getOperationFromHeader ( record , key ) ; \nif ( opType == null ) return Observable . empty ( ) ; \nAbstractDocument doc ; \nif ( config . dataFormat == DataFormat . JSON ) try { \ndoc = JsonDocument . create ( key , ttl , JsonObject . fromJson ( baos . toString ( config . dataFormatConfig . charset ) ) , cas ) ; \n} \ncatch ( Exception e ) { \nreturn handleError ( record , Errors . COUCHBASE_10 , e ) ; \n} \nelse doc = ByteArrayDocument . create ( key , ttl , baos . toByteArray ( ) , cas ) ; \nswitch ( opType ) { \ncase DELETE : { \nLOG . debug ( \"DELETE key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . remove ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ncase INSERT : { \nLOG . debug ( \"INSERT key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . insert ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ncase REPLACE : { \nLOG . debug ( \"REPLACE key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . replace ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ncase UPSERT : { \nLOG . debug ( \"UPSERT key: {}, TTL: {}, CAS: {}\" , key , ttl , cas ) ; \nreturn connector . bucket ( ) . upsert ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; \n} \ndefault : return Observable . empty ( ) ; \n} \n} \n} \n"}
{"2191": "public class H2SchemaWriter { \n@ Override protected String makeAlterTableSqlString ( String schema , String tableName , LinkedHashMap < String , JdbcTypeInfo > columnDiff ) { \nString tableSchema = ( schema == null ) ? getDefaultSchema ( ) : schema ; \nStringBuilder sqlString = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( Map . Entry < String , JdbcTypeInfo > entry : columnDiff . entrySet ( ) ) { \nif ( first ) first = false ; \nelse sqlString . append ( \"\\n\" ) ; \nsqlString . append ( ALTER_TABLE ) . append ( \" \" ) ; \nif ( tableSchema != null ) { \nsqlString . append ( tableSchema ) ; \nsqlString . append ( \".\" ) ; \n} \nsqlString . append ( tableName ) . append ( \" \" ) . append ( \"ADD COLUMN\" ) . append ( \" \" ) . append ( entry . getKey ( ) ) . append ( \" \" ) . append ( entry . getValue ( ) . toString ( ) ) . append ( \";\" ) ; \n} \nreturn sqlString . toString ( ) ; \n} \n} \n"}
{"2193": "public class Consumer { \npublic OffsetAndResult < Map . Entry > take ( ) { \nif ( producerError != null ) throw new RuntimeException ( Utils . format ( \"Producer encountered error: {}\" , producerError ) , producerError ) ; \nif ( consumerError != null ) throw new RuntimeException ( Utils . format ( \"Consumer encountered error: {}\" , consumerError ) , consumerError ) ; \ntry { \nUtils . checkState ( batchCommitted , \"Cannot take messages when last batch is uncommitted\" ) ; \nwhile ( running ) { \nfor ( ControlChannel . Message controlMessage : controlChannel . getConsumerMessages ( ) ) { \nswitch ( controlMessage . getType ( ) ) { \ncase PRODUCER_COMPLETE : running = false ; \nbreak ; \ncase PRODUCER_ERROR : running = false ; \nThrowable throwable = ( Throwable ) controlMessage . getPayload ( ) ; \nproducerError = throwable ; \nthrow new ProducerRuntimeException ( Utils . format ( \"Producer encountered error: {}\" , throwable ) , throwable ) ; \ndefault : String msg = Utils . format ( \"Illegal control message type: '{}'\" , controlMessage . getType ( ) ) ; \nthrow new IllegalStateException ( msg ) ; \n} \n} \nOffsetAndResult < Map . Entry > batch = dataChannel . take ( 10 , TimeUnit . MILLISECONDS ) ; \nLOG . trace ( \"Received batch: {}\" , batch ) ; \nif ( batch != null ) { \nbatchCommitted = false ; \nreturn batch ; \n} \n} \nLOG . trace ( \"Returning null\" ) ; \nreturn null ; \n} \ncatch ( Throwable throwable ) { \nif ( ! ( throwable instanceof ProducerRuntimeException ) ) { \nString msg = \"Error caught in consumer: \" + throwable ; \nLOG . error ( msg , throwable ) ; \nerror ( throwable ) ; \n} \nthrow Throwables . propagate ( throwable ) ; \n} \n} \n} \n"}
{"2197": "public class DefinitionsApi { \npublic DefinitionsJson getDefinitions ( HideStage . Type hideStage ) throws ApiException { \nObject postBody = null ; \nbyte [ ] postBinaryBody = null ; \nString path = \"/v1/definitions\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) ; \nList < Pair > queryParams = new ArrayList < Pair > ( ) ; \nif ( hideStage != null ) queryParams . add ( new Pair ( \"hideStage\" , hideStage . name ( ) ) ) ; \nMap < String , String > headerParams = new HashMap < String , String > ( ) ; \nMap < String , Object > formParams = new HashMap < String , Object > ( ) ; \nfinal String [ ] accepts = { \n\"application/json\" } \n; \nfinal String accept = apiClient . selectHeaderAccept ( accepts ) ; \nfinal String [ ] contentTypes = { \n} \n; \nfinal String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; \nString [ ] authNames = new String [ ] { \n\"basic\" } \n; \nTypeRef returnType = new TypeRef < DefinitionsJson > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( path , \"GET\" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; \n} \n} \n"}
{"2198": "public class LineagePublisherTaskImpl { \nprivate LineagePublisherDefinition getDefinition ( String name ) { \nString defConfig = LineagePublisherConstants . configDef ( name ) ; \nString publisherDefinition = configuration . get ( defConfig , null ) ; \nif ( StringUtils . isEmpty ( publisherDefinition ) ) throw new IllegalArgumentException ( Utils . format ( \"Missing definition '{}'\" , defConfig ) ) ; \nString [ ] lineagePluginDefs = publisherDefinition . split ( \"::\" ) ; \nif ( lineagePluginDefs . length != 2 ) throw new IllegalStateException ( Utils . format ( \"Invalid definition '{}', expected $libraryName::$publisherName\" , publisherDefinition ) ) ; \nLineagePublisherDefinition def = stageLibraryTask . getLineagePublisherDefinition ( lineagePluginDefs [ 0 ] , lineagePluginDefs [ 1 ] ) ; \nif ( def == null ) throw new IllegalStateException ( Utils . format ( \"Can't find publisher '{}'\" , publisherDefinition ) ) ; \nreturn def ; \n} \n} \n"}
{"2199": "public class SQLParserUtils { \nprivate static String formatName ( String columnName , boolean caseSensitive ) { \nString returnValue = format ( columnName ) ; \nif ( caseSensitive ) return returnValue ; \nreturn returnValue . toUpperCase ( ) ; \n} \n} \n"}
{"2200": "public class SQLParserUtils { \nprivate static String formatValue ( String value ) { \nif ( value == null || NULL_STRING . equalsIgnoreCase ( value ) ) return null ; \nString returnValue = format ( value ) ; \nreturn returnValue . replaceAll ( \"''\" , \"'\" ) ; \n} \n} \n"}
{"2201": "public class StoreApi { \npublic PipelineConfigurationJson getPipelineInfo ( String pipelineId , String rev , String get , Boolean attachment ) throws ApiException { \nObject postBody = null ; \nbyte [ ] postBinaryBody = null ; \nif ( pipelineId == null ) throw new ApiException ( 400 , \"Missing the required parameter 'pipelineId' when calling getPipelineInfo\" ) ; \nString path = \"/v1/pipeline/{pipelineId}\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) . replaceAll ( \"\\\\{\" + \"pipelineId\" + \"\\\\}\" , apiClient . escapeString ( pipelineId . toString ( ) ) ) ; \nList < Pair > queryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > headerParams = new HashMap < String , String > ( ) ; \nMap < String , Object > formParams = new HashMap < String , Object > ( ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"rev\" , rev ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"get\" , get ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"attachment\" , attachment ) ) ; \nfinal String [ ] accepts = { \n\"application/json\" } \n; \nfinal String accept = apiClient . selectHeaderAccept ( accepts ) ; \nfinal String [ ] contentTypes = { \n} \n; \nfinal String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; \nString [ ] authNames = new String [ ] { \n\"basic\" } \n; \nTypeRef returnType = new TypeRef < PipelineConfigurationJson > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( path , \"GET\" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; \n} \n} \n"}
{"2202": "public class StoreApi { \npublic PipelineFragmentEnvelopeJson createDraftPipelineFragment ( String fragmentId , String description , List < StageConfigurationJson > stageInstances ) throws ApiException { \nObject postBody = stageInstances ; \nbyte [ ] postBinaryBody = null ; \nif ( fragmentId == null ) throw new ApiException ( 400 , \"Missing the required parameter 'fragmentId' when calling createPipelineFragment\" ) ; \nString path = \"/v1/fragment/{fragmentId}\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) . replaceAll ( \"\\\\{\" + \"fragmentId\" + \"\\\\}\" , apiClient . escapeString ( fragmentId . toString ( ) ) ) ; \nList < Pair > queryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > headerParams = new HashMap < String , String > ( ) ; \nMap < String , Object > formParams = new HashMap < String , Object > ( ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"description\" , description ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"draft\" , true ) ) ; \nfinal String [ ] accepts = { \n\"application/json\" } \n; \nfinal String accept = apiClient . selectHeaderAccept ( accepts ) ; \nfinal String [ ] contentTypes = { \n} \n; \nfinal String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; \nString [ ] authNames = new String [ ] { \n\"basic\" } \n; \nTypeRef returnType = new TypeRef < PipelineFragmentEnvelopeJson > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( path , \"PUT\" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; \n} \n} \n"}
{"2204": "public class StoreApi { \npublic PipelineFragmentEnvelopeJson importPipelineFragment ( String fragmentId , boolean draft , boolean includeLibraryDefinitions , PipelineFragmentEnvelopeJson fragmentEnvelope ) throws ApiException { \nObject postBody = fragmentEnvelope ; \nbyte [ ] postBinaryBody = null ; \nif ( fragmentId == null ) throw new ApiException ( 400 , \"Missing the required parameter 'fragmentId' when calling importPipelineFragment\" ) ; \nif ( fragmentEnvelope == null ) throw new ApiException ( 400 , \"Missing the required parameter 'pipelineEnvelope' when calling importPipelineFragment\" ) ; \nString path = \"/v1/fragment/{fragmentId}/import\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) . replaceAll ( \"\\\\{\" + \"fragmentId\" + \"\\\\}\" , apiClient . escapeString ( fragmentId . toString ( ) ) ) ; \nList < Pair > queryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > headerParams = new HashMap < String , String > ( ) ; \nMap < String , Object > formParams = new HashMap < String , Object > ( ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"draft\" , draft ) ) ; \nqueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"includeLibraryDefinitions\" , includeLibraryDefinitions ) ) ; \nfinal String [ ] accepts = { \n\"application/json\" } \n; \nfinal String accept = apiClient . selectHeaderAccept ( accepts ) ; \nfinal String [ ] contentTypes = { \n\"application/json\" } \n; \nfinal String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; \nString [ ] authNames = new String [ ] { \n\"basic\" } \n; \nTypeRef returnType = new TypeRef < PipelineFragmentEnvelopeJson > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( path , \"POST\" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; \n} \n} \n"}
{"2205": "public class DataLakeGeneratorManager { \npublic String getFilePath ( String dirPathTemplate , Record record , Date recordTime ) throws StageException { \nString dirPath ; \nif ( dirPathTemplateInHeader ) { \ndirPath = record . getHeader ( ) . getAttribute ( DataLakeTarget . TARGET_DIRECTORY_HEADER ) ; \nUtils . checkArgument ( ! ( dirPath == null || dirPath . isEmpty ( ) ) , \"Directory Path cannot be null\" ) ; \n} \nelse dirPath = resolvePath ( dirPathTemplateEval , dirPathTemplateVars , dirPathTemplate , recordTime , record ) ; \ndirPath = dirPath . replaceAll ( \"/+\" , \"/\" ) ; \nif ( dirPath . endsWith ( \"/\" ) ) dirPath = dirPath . substring ( 0 , dirPath . length ( ) - 1 ) ; \nreturn outputStreamHelper . getTempFilePath ( dirPath , record , recordTime ) ; \n} \n} \n"}
{"2206": "public class JdbcRecordReader { \nint getOperationFromRecord ( Record record , int defaultOpCode , UnsupportedOperationAction unsupportedAction , List < OnRecordErrorException > errorRecords ) { \nString op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; \nint opCode = - 1 ; \nif ( Strings . isNullOrEmpty ( op ) ) return defaultOpCode ; \ntry { \nopCode = JDBCOperationType . convertToIntCode ( op ) ; \n} \ncatch ( NumberFormatException | UnsupportedOperationException ex ) { \nLOG . debug ( \"Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}\" , unsupportedAction . getLabel ( ) , ex ) ; \nswitch ( unsupportedAction ) { \ncase SEND_TO_ERROR : LOG . debug ( \"Sending record to error due to unsupported operation {}\" , op ) ; \nerrorRecords . add ( new OnRecordErrorException ( record , JdbcErrors . JDBC_70 , op ) ) ; \nbreak ; \ncase USE_DEFAULT : opCode = defaultOpCode ; \nbreak ; \ncase DISCARD : default : LOG . debug ( \"Discarding record with unsupported operation {}\" , op ) ; \n} \n} \nreturn opCode ; \n} \n} \n"}
{"2210": "public class RunnerPool { \npublic T getIdleRunner ( long idleTime ) { \nQueueItem < T > item = queue . poll ( ) ; \nif ( item == null ) return null ; \nif ( ( System . currentTimeMillis ( ) - item . timestamp ) < idleTime ) { \nqueue . add ( item ) ; \nreturn null ; \n} \nreturn item . runner ; \n} \n} \n"}
{"2212": "public class RunnerPool { \npublic void destroy ( ) throws PipelineRuntimeException { \ndestroyed . set ( true ) ; \nif ( queue . size ( ) < runtimeStats . getTotalRunners ( ) ) throw new PipelineRuntimeException ( ContainerError . CONTAINER_0802 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; \n} \n} \n"}
{"2213": "public class RunnerPool { \nprivate void validateNotDestroyed ( ) throws PipelineRuntimeException { \nif ( destroyed . get ( ) ) throw new PipelineRuntimeException ( ContainerError . CONTAINER_0803 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; \n} \n} \n"}
{"2215": "public class KinesisUtil { \npublic static String getLastShardId ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName ) throws StageException { \nAmazonKinesis kinesisClient = getKinesisClient ( awsClientConfig , conf ) ; \nString lastShardId = null ; \ntry { \nStreamDescription description ; \ndo { \nif ( lastShardId == null ) description = kinesisClient . describeStream ( streamName ) . getStreamDescription ( ) ; \nelse description = kinesisClient . describeStream ( streamName , lastShardId ) . getStreamDescription ( ) ; \nint pageSize = description . getShards ( ) . size ( ) ; \nlastShardId = description . getShards ( ) . get ( pageSize - 1 ) . getShardId ( ) ; \n} \nwhile ( description . getHasMoreShards ( ) ) ; \nreturn lastShardId ; \n} \nfinally { \nkinesisClient . shutdown ( ) ; \n} \n} \n} \n"}
{"2216": "public class JdbcMultiRowRecordWriter { \nprivate void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { \nif ( queue . isEmpty ( ) ) return ; \nint rowCount = 0 ; \nfinal Record first = queue . getFirst ( ) ; \nSortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; \nif ( columnsToParameters . isEmpty ( ) ) { \nif ( LOG . isWarnEnabled ( ) ) LOG . warn ( \"No parameters found for record with ID {}; skipping\" , first . getHeader ( ) . getSourceId ( ) ) ; \nreturn ; \n} \nString query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; \nLinkedList < Record > removed = new LinkedList < > ( ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nwhile ( ! queue . isEmpty ( ) ) { \nRecord r = queue . removeFirst ( ) ; \nif ( opCode != DELETE_CODE ) paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \nif ( opCode != OperationType . INSERT_CODE ) paramIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \nremoved . add ( r ) ; \n++ rowCount ; \nif ( rowCount == maxRowsPerBatch ) { \nprocessBatch ( removed , errorRecords , statement , connection ) ; \nrowCount = 0 ; \nparamIdx = 1 ; \nremoved . clear ( ) ; \n} \n} \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \nif ( ! removed . isEmpty ( ) ) { \nquery = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nfor ( Record r : removed ) { \nif ( opCode != DELETE_CODE ) paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \nif ( opCode != OperationType . INSERT_CODE ) paramIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \nprocessBatch ( removed , errorRecords , statement , connection ) ; \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \n} \n} \n} \n"}
{"2219": "public class SpoolDirUtil { \npublic static boolean compareFiles ( WrappedFileSystem fs , WrappedFile f1 , WrappedFile f2 ) { \nif ( ! fs . exists ( f2 ) ) return true ; \ntry { \nlong mtime1 = fs . getLastModifiedTime ( f1 ) ; \nlong mtime2 = fs . getLastModifiedTime ( f2 ) ; \nlong ctime1 = fs . getChangedTime ( f1 ) ; \nlong ctime2 = fs . getChangedTime ( f2 ) ; \nlong time1 = Math . max ( mtime1 , ctime1 ) ; \nlong time2 = Math . max ( mtime2 , ctime2 ) ; \nint compares = Long . compare ( time1 , time2 ) ; \nif ( compares != 0 ) return compares > 0 ; \n} \ncatch ( IOException ex ) { \nLOG . error ( \"Failed to get ctime: '{}'\" , f1 . getFileName ( ) , ex ) ; \nreturn false ; \n} \nreturn f1 . getAbsolutePath ( ) . compareTo ( f2 . getAbsolutePath ( ) ) > 0 ; \n} \n} \n"}
{"2220": "public class ShellExecutor { \nprivate static int retrievePidIfFeasible ( Process process ) { \nif ( unixProcessClass == null ) return UNDETERMINED_PID ; \nif ( ! unixProcessClass . isInstance ( process ) ) { \nLOG . debug ( \"Do not support retrieving PID from {}\" , process . getClass ( ) . getName ( ) ) ; \nreturn UNDETERMINED_PID ; \n} \ntry { \nreturn ( int ) pidField . get ( process ) ; \n} \ncatch ( IllegalAccessException e ) { \nLOG . debug ( \"Can't retrieve PID value from the field\" , e ) ; \nreturn UNDETERMINED_PID ; \n} \n} \n} \n"}
{"2221": "public class FieldHasherProcessor { \nprivate Set < String > validateAndExtractFieldsToHash ( Record record , Set < String > fieldsDontExist , Set < String > fieldsWithListOrMapType , Set < String > fieldsWithNull , Collection < String > matchingFieldsPath ) { \nSet < String > validFieldsToHashForThisConfig = new HashSet < String > ( ) ; \nfor ( String matchingFieldPath : matchingFieldsPath ) { \nif ( record . has ( matchingFieldPath ) ) { \nField field = record . get ( matchingFieldPath ) ; \nif ( UNSUPPORTED_FIELD_TYPES . contains ( field . getType ( ) ) ) fieldsWithListOrMapType . add ( matchingFieldPath ) ; \nelse if ( field . getValue ( ) == null ) fieldsWithNull . add ( matchingFieldPath ) ; \nelse validFieldsToHashForThisConfig . add ( matchingFieldPath ) ; \n} \nelse fieldsDontExist . add ( matchingFieldPath ) ; \n} \nreturn validFieldsToHashForThisConfig ; \n} \n} \n"}
{"2222": "public class HadoopSecurityUtil { \npublic static UserGroupInformation getProxyUser ( String user , Stage . Context context , UserGroupInformation loginUser , List < Stage . ConfigIssue > issues , String configGroup , String configName ) { \nboolean alwaysImpersonate = context . getConfiguration ( ) . get ( HadoopConfigConstants . IMPERSONATION_ALWAYS_CURRENT_USER , false ) ; \nif ( alwaysImpersonate ) { \nif ( ! StringUtils . isEmpty ( user ) ) issues . add ( context . createConfigIssue ( configGroup , configName , Errors . HADOOP_00001 ) ) ; \nuser = context . getUserContext ( ) . getAliasName ( ) ; \n} \nif ( StringUtils . isEmpty ( user ) ) return loginUser ; \nboolean lowerCase = context . getConfiguration ( ) . get ( HadoopConfigConstants . LOWERCASE_USER , false ) ; \nif ( lowerCase ) user = user . toLowerCase ( ) ; \nreturn UserGroupInformation . createProxyUser ( user , loginUser ) ; \n} \n} \n"}
{"2225": "public class HdfsMetadataExecutor { \nprivate void ensureDirectoryExists ( FileSystem fs , Path path ) throws IOException { \nif ( ! fs . exists ( path ) ) { \nLOG . debug ( \"Creating directory: {}\" , path ) ; \nif ( ! fs . mkdirs ( path ) ) throw new IOException ( \"Can't create directory: \" + path ) ; \n} \n} \n} \n"}
{"2230": "public class HiveMetadataProcessor { \nprivate Map < PartitionInfoCacheSupport . PartitionValues , String > detectNewPartition ( PartitionInfoCacheSupport . PartitionValues partitionValues , PartitionInfoCacheSupport . PartitionInfo pCache , String location ) throws StageException { \nMap < PartitionInfoCacheSupport . PartitionValues , String > partitionInfoDiff = new HashMap < > ( ) ; \npartitionInfoDiff . put ( partitionValues , location ) ; \npartitionInfoDiff = ( pCache != null ) ? pCache . getDiff ( partitionInfoDiff ) : partitionInfoDiff ; \nif ( pCache == null || ! partitionInfoDiff . isEmpty ( ) ) return partitionInfoDiff ; \nreturn null ; \n} \n} \n"}
{"2231": "public class HiveMetadataProcessor { \n@ VisibleForTesting static void updateRecordForHDFS ( Record record , boolean roll , String avroSchema , String location ) { \nif ( roll ) record . getHeader ( ) . setAttribute ( HDFS_HEADER_ROLL , \"true\" ) ; \nrecord . getHeader ( ) . setAttribute ( HDFS_HEADER_AVROSCHEMA , avroSchema ) ; \nrecord . getHeader ( ) . setAttribute ( HDFS_HEADER_TARGET_DIRECTORY , location ) ; \nLOG . trace ( \"Record {} will be stored in {} path: roll({}), avro schema: {}\" , record . getHeader ( ) . getSourceId ( ) , location , roll , avroSchema ) ; \n} \n} \n"}
{"2234": "public class BootstrapMesosDriver { \npublic static void main ( String [ ] args ) throws Exception { \nBootstrapCluster . printSystemPropsEnvVariables ( ) ; \nString mesosDir = System . getenv ( \"MESOS_DIRECTORY\" ) ; \nif ( mesosDir == null ) throw new IllegalStateException ( \"Expected the env. variable MESOS_DIRECTORY to be defined\" ) ; \nFile mesosHomeDir = new File ( mesosDir ) ; \nString sparkDir = System . getenv ( \"SPARK_HOME\" ) ; \nif ( sparkDir == null ) throw new IllegalStateException ( \"Expected the env. variable SPARK_HOME to be defined\" ) ; \nFile sparkHomeDir = new File ( sparkDir ) ; \nint processExitValue = BootstrapCluster . findAndExtractJar ( mesosHomeDir , sparkHomeDir ) ; \nif ( processExitValue != 0 ) throw new IllegalStateException ( \"Process extracting archives from uber jar exited abnormally; check Mesos driver stdout file\" ) ; \nSystem . setProperty ( \"SDC_MESOS_BASE_DIR\" , new File ( mesosHomeDir , BootstrapCluster . SDC_MESOS_BASE_DIR ) . getAbsolutePath ( ) ) ; \nfinal Class < ? > clazz = Class . forName ( \"com.streamsets.pipeline.BootstrapClusterStreaming\" ) ; \nfinal Method method = clazz . getMethod ( \"main\" , String [ ] . class ) ; \nmethod . invoke ( null , new Object [ ] { \nargs } \n) ; \n} \n} \n"}
{"2235": "public class HttpClientCommon { \nprivate void configureAuthAndBuildClient ( ClientBuilder clientBuilder , List < Stage . ConfigIssue > issues ) { \nif ( jerseyClientConfig . authType == AuthenticationType . OAUTH ) { \nString consumerKey = jerseyClientConfig . oauth . resolveConsumerKey ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString consumerSecret = jerseyClientConfig . oauth . resolveConsumerSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString token = jerseyClientConfig . oauth . resolveToken ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString tokenSecret = jerseyClientConfig . oauth . resolveTokenSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) authToken = JerseyClientUtil . configureOAuth1 ( consumerKey , consumerSecret , token , tokenSecret , clientBuilder ) ; \n} \nelse if ( jerseyClientConfig . authType . isOneOf ( AuthenticationType . DIGEST , AuthenticationType . BASIC , AuthenticationType . UNIVERSAL ) ) { \nString username = jerseyClientConfig . basicAuth . resolveUsername ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nString password = jerseyClientConfig . basicAuth . resolvePassword ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) JerseyClientUtil . configurePasswordAuth ( jerseyClientConfig . authType , username , password , clientBuilder ) ; \n} \ntry { \nbuildNewAuthenticatedClient ( issues , false ) ; \nclientInitialized = true ; \n} \ncatch ( StageException e ) { \nExceptionUtils . throwUndeclared ( e ) ; \n} \n} \n} \n"}
{"2237": "public class HttpClientCommon { \npublic HttpMethod getHttpMethod ( HttpMethod httpMethod , String methodExpression , Record record ) throws ELEvalException { \nif ( httpMethod != HttpMethod . EXPRESSION ) return httpMethod ; \nRecordEL . setRecordInContext ( methodVars , record ) ; \nreturn HttpMethod . valueOf ( methodEval . eval ( methodVars , methodExpression , String . class ) ) ; \n} \n} \n"}
{"2239": "public class ScriptTypedNullObject { \npublic static Object getFieldNull ( Record record , String fieldPath ) { \nField f = record . get ( fieldPath ) ; \nif ( f != null ) return f . getValue ( ) == null ? getTypedNullFromField ( f ) : f . getValue ( ) ; \nreturn null ; \n} \n} \n"}
{"2240": "public class AvroSchemaHelper { \npublic Schema loadFromRegistry ( String subject , int schemaId ) throws SchemaRegistryException { \ntry { \nif ( isEmpty ( subject ) ) return loadFromRegistry ( schemaId ) ; \nelse return loadFromRegistry ( subject ) ; \n} \ncatch ( SchemaRegistryException e ) { \nthrow new SchemaRegistryException ( e ) ; \n} \n} \n} \n"}
{"2246": "public class AvroSchemaHelper { \npublic Optional < Integer > detectSchemaId ( byte [ ] data ) { \nif ( data . length < 5 ) return Optional . empty ( ) ; \nByteBuffer wrapped = ByteBuffer . wrap ( data ) ; \nif ( wrapped . get ( ) != MAGIC_BYTE ) return Optional . empty ( ) ; \nreturn Optional . of ( wrapped . getInt ( ) ) ; \n} \n} \n"}
{"2248": "public class ServicesUtil { \npublic static List < Record > parseAll ( Stage . Context stageContext , ToErrorContext toErrorContext , boolean produceSingleRecordPerMessage , String messageId , byte [ ] payload ) throws StageException { \nList < Record > records = new ArrayList < > ( ) ; \ntry ( DataParser parser = stageContext . getService ( DataFormatParserService . class ) . getParser ( messageId , payload ) ) { \nRecord record = null ; \ndo { \ntry { \nrecord = parser . parse ( ) ; \n} \ncatch ( RecoverableDataParserException e ) { \nhandleException ( stageContext , toErrorContext , messageId , e , e . getUnparsedRecord ( ) ) ; \ncontinue ; \n} \nif ( record != null ) records . add ( record ) ; \n} \nwhile ( record != null ) ; \n} \ncatch ( IOException | DataParserException ex ) { \nRecord record = stageContext . createRecord ( messageId ) ; \nrecord . set ( Field . create ( payload ) ) ; \nhandleException ( stageContext , toErrorContext , messageId , ex , record ) ; \nreturn records ; \n} \nif ( produceSingleRecordPerMessage ) { \nList < Field > list = new ArrayList < > ( ) ; \nfor ( Record record : records ) { \nlist . add ( record . get ( ) ) ; \n} \nRecord record = records . get ( 0 ) ; \nrecord . set ( Field . create ( list ) ) ; \nrecords . clear ( ) ; \nrecords . add ( record ) ; \n} \nreturn records ; \n} \n} \n"}
{"2249": "public class ClasspathValidatorResult { \npublic void logDetails ( ) { \nif ( isValid ( ) ) return ; \nLOG . warn ( \"Validation results for {}\" , name ) ; \nif ( ! unparseablePaths . isEmpty ( ) ) { \nLOG . warn ( \"Can't parse the following artifacts:\" ) ; \nfor ( String path : unparseablePaths ) { \nLOG . warn ( \"  {}\" , path ) ; \n} \n} \nif ( ! versionCollisions . isEmpty ( ) ) { \nLOG . warn ( \"Detected colliding dependency versions:\" ) ; \nfor ( Map . Entry < String , Map < String , List < Dependency > > > entry : versionCollisions . entrySet ( ) ) { \nLOG . warn ( \"  Dependency {} have versions: {}\" , entry . getKey ( ) , StringUtils . join ( entry . getValue ( ) . keySet ( ) , \", \" ) ) ; \nfor ( Map . Entry < String , List < Dependency > > versionEntry : entry . getValue ( ) . entrySet ( ) ) { \nLOG . warn ( \"    Version: {}\" , versionEntry . getKey ( ) ) ; \nfor ( Dependency dependency : versionEntry . getValue ( ) ) { \nLOG . warn ( \"      {}\" , dependency . getSourceName ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2255": "public class OffsetUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static Map < String , String > deserializeOffsetMap ( String lastSourceOffset ) throws IOException { \nMap < String , String > offsetMap ; \nif ( lastSourceOffset == null || lastSourceOffset . isEmpty ( ) ) offsetMap = new HashMap < > ( ) ; \nelse offsetMap = JSON_MAPPER . readValue ( lastSourceOffset , Map . class ) ; \nreturn offsetMap ; \n} \n} \n"}
{"2256": "public class OmniturePollingConsumer { \npublic int queueReport ( ) throws IOException , InterruptedException , ExecutionException , TimeoutException , StageException { \nfinal AsyncInvoker asyncInvoker = queueResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Queueing report using URL {} with description {}\" , queueResource . getUri ( ) . toURL ( ) . toString ( ) , reportDescription ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( reportDescription ) ) ; \nResponse response = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( response == null ) { \nLOG . error ( \"Failed to get response using URL {}\" , queueResource . getUri ( ) . toURL ( ) . toString ( ) ) ; \nthrow new StageException ( Errors . OMNITURE_01 , \"HTTP response was null\" ) ; \n} \nLOG . debug ( \"Received response: status {}\" , response . getStatus ( ) ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nString json = response . readEntity ( String . class ) ; \nLOG . trace ( \"Response JSON: {}\" , json ) ; \nJsonNode root = mapper . readTree ( json ) ; \nif ( root == null ) { \nLOG . error ( \"Invalid JSON in response: {}\" , json ) ; \nthrow new StageException ( Errors . OMNITURE_01 , json ) ; \n} \nif ( root . has ( \"error\" ) ) throw new StageException ( Errors . OMNITURE_01 , root . get ( \"error_description\" ) . asText ( ) ) ; \nLOG . info ( \"Omniture report queued\" ) ; \nreturn root . get ( \"reportID\" ) . asInt ( ) ; \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nint waitTime = 1000 ; \nResponse response = null ; \nwhile ( ! stop ) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! root . has ( \"error\" ) ) { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) LOG . warn ( \"Response buffer full, dropped record.\" ) ; \nbreak ; \n} \nelse if ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) { \nwaitTime *= 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \nelse throw new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \nresponse . close ( ) ; \n} \n} \n"}
{"2260": "public class GcsObjectPostProcessingHandler { \nprivate void delete ( BlobId blobId ) { \nLOG . debug ( \"Deleting object '{}'\" , String . format ( BLOB_PATH_TEMPLATE , blobId . getBucket ( ) , blobId . getName ( ) ) ) ; \nboolean deleted = storage . delete ( blobId ) ; \nif ( ! deleted ) LOG . error ( \"Cannot delete object '{}'\" , String . format ( BLOB_PATH_TEMPLATE , blobId . getBucket ( ) , blobId . getName ( ) ) ) ; \n} \n} \n"}
{"2263": "public class FileContext { \npublic LiveFileReader getReader ( ) throws IOException { \nUtils . checkState ( open , \"FileContext is closed\" ) ; \nif ( reader == null ) { \ncurrentFile = getStartingCurrentFileName ( ) ; \nlong fileOffset = getStartingOffset ( ) ; \nboolean needsToScan = currentFile == null || fileOffset == Long . MAX_VALUE ; \nif ( needsToScan ) { \nif ( currentFile != null ) currentFile = currentFile . refresh ( ) ; \ncurrentFile = scanner . scan ( currentFile ) ; \nfileOffset = 0 ; \n} \nif ( currentFile != null ) { \nreader = new SingleLineLiveFileReader ( getRollMode ( ) , getMultiFileInfo ( ) . getTag ( ) , currentFile , charset , fileOffset , maxLineLength ) ; \nif ( ! multiFileInfo . getMultiLineMainLinePatter ( ) . isEmpty ( ) ) reader = new MultiLineLiveFileReader ( getMultiFileInfo ( ) . getTag ( ) , reader , Pattern . compile ( multiFileInfo . getMultiLineMainLinePatter ( ) ) ) ; \nif ( fileOffset == 0 ) eventPublisher . publish ( new FileEvent ( currentFile , FileEvent . Action . START ) ) ; \n} \n} \nreturn reader ; \n} \n} \n"}
{"2264": "public class FileContext { \npublic void releaseReader ( boolean inErrorDiscardReader ) throws IOException { \nUtils . checkState ( open , \"FileContext is closed\" ) ; \nboolean hasNext ; \ntry { \nhasNext = reader != null && reader . hasNext ( ) ; \n} \ncatch ( IOException ex ) { \nIOUtils . closeQuietly ( reader ) ; \nreader = null ; \nhasNext = false ; \n} \nboolean doneWithFile = ! hasNext || inErrorDiscardReader ; \nif ( doneWithFile ) { \nIOUtils . closeQuietly ( reader ) ; \nreader = null ; \nsetStartingCurrentFileName ( currentFile ) ; \nsetStartingOffset ( Long . MAX_VALUE ) ; \nif ( currentFile == null ) return ; \nLiveFile file = currentFile . refresh ( ) ; \nif ( inErrorDiscardReader ) { \nLOG . warn ( \"Processing file '{}' produced an error, skipping '{}' post processing on that file\" , file , postProcessing ) ; \neventPublisher . publish ( new FileEvent ( file , FileEvent . Action . ERROR ) ) ; \n} \nelse { \neventPublisher . publish ( new FileEvent ( file , FileEvent . Action . END ) ) ; \nswitch ( postProcessing ) { \ncase NONE : LOG . debug ( \"File '{}' processing completed, post processing action 'NONE'\" , file ) ; \nbreak ; \ncase DELETE : if ( ! inPreviewMode ) try { \nFiles . delete ( file . getPath ( ) ) ; \nLOG . debug ( \"File '{}' processing completed, post processing action 'DELETED'\" , file ) ; \n} \ncatch ( IOException ex ) { \nthrow new IOException ( Utils . format ( \"Could not delete '{}': {}\" , file , ex . toString ( ) ) , ex ) ; \n} \nbreak ; \ncase ARCHIVE : if ( ! inPreviewMode ) { \nPath fileArchive = Paths . get ( archiveDir , file . getPath ( ) . toString ( ) ) ; \nif ( fileArchive == null ) throw new IOException ( \"Could not find archive file\" ) ; \ntry { \nFiles . createDirectories ( fileArchive . getParent ( ) ) ; \nFiles . move ( file . getPath ( ) , fileArchive ) ; \nLOG . debug ( \"File '{}' processing completed, post processing action 'ARCHIVED' as\" , file ) ; \n} \ncatch ( IOException ex ) { \nthrow new IOException ( Utils . format ( \"Could not archive '{}': {}\" , file , ex . toString ( ) ) , ex ) ; \n} \n} \nbreak ; \n} \n} \n} \nelse { \nsetStartingCurrentFileName ( currentFile ) ; \nsetStartingOffset ( getReader ( ) . getOffset ( ) ) ; \n} \n} \n} \n"}
{"2265": "public class ApiClient { \npublic ApiClient setDPMBaseURL ( String dpmBaseURL ) { \nif ( dpmBaseURL != null && authentication != null ) authentication . setDPMBaseURL ( dpmBaseURL ) ; \nreturn this ; \n} \n} \n"}
{"2274": "public class AvroSchemaGenerator { \npublic static Schema buildSchema ( Map < String , Schema > fields , Object ... levels ) { \nList < Schema . Field > recordFields = new ArrayList < > ( fields . size ( ) ) ; \nfor ( Map . Entry < String , Schema > entry : fields . entrySet ( ) ) { \nrecordFields . add ( new Schema . Field ( entry . getKey ( ) , entry . getValue ( ) , null , entry . getValue ( ) . getJsonProp ( \"default\" ) ) ) ; \n} \nSchema recordSchema ; \nif ( levels . length == 0 ) recordSchema = Schema . createRecord ( schemaName , null , null , false ) ; \nelse { \nLinkedList < String > lvl = ( LinkedList < String > ) levels [ 0 ] ; \nrecordSchema = Schema . createRecord ( joiner . join ( lvl ) , null , null , false ) ; \n} \nrecordSchema . setFields ( recordFields ) ; \nreturn recordSchema ; \n} \n} \n"}
{"2277": "public class MapreduceUtils { \npublic static void addJarsToJob ( Configuration conf , boolean allowMultiple , String ... jarPatterns ) { \nfinal ClassLoader loader = MapreduceUtils . class . getClassLoader ( ) ; \nif ( ! ( loader instanceof URLClassLoader ) ) throw new IllegalStateException ( String . format ( \"ClassLoader for %s is not an instance of URLClassLoader (it is %s), and thus this method cannot be used\" , MapreduceUtils . class . getCanonicalName ( ) , loader . getClass ( ) . getCanonicalName ( ) ) ) ; \nfinal URLClassLoader urlClassLoader = ( URLClassLoader ) loader ; \naddJarsToJob ( conf , allowMultiple , urlClassLoader . getURLs ( ) , jarPatterns ) ; \n} \n} \n"}
{"2279": "public class ForceSource { \nprivate boolean checkConditionExpressions ( SOQLParser . ConditionExpressionsContext conditionExpressions , String fieldName ) { \nfor ( SOQLParser . ConditionExpressionContext ce : conditionExpressions . conditionExpression ( ) ) { \nif ( ( ce . conditionExpressions ( ) != null && checkConditionExpressions ( ce . conditionExpressions ( ) , fieldName ) ) || ( ce . fieldExpression ( ) != null && ce . fieldExpression ( ) . fieldElement ( ) . getText ( ) . equalsIgnoreCase ( fieldName ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"2281": "public class BootstrapMain { \npublic static void premain ( String args , Instrumentation instrumentation ) { \nif ( BootstrapMain . instrumentation == null ) BootstrapMain . instrumentation = instrumentation ; \nelse throw new IllegalStateException ( \"Premain method cannot be called twice (\" + BootstrapMain . instrumentation + \")\" ) ; \n} \n} \n"}
{"2282": "public class BaseKafkaSource { \npublic int getParallelism ( ) throws StageException { \nif ( originParallelism == 0 ) { \noriginParallelism = kafkaValidationUtil . getPartitionCount ( conf . metadataBrokerList , conf . topic , new HashMap < String , Object > ( conf . kafkaConsumerConfigs ) , 3 , 1000 ) ; \nif ( originParallelism < 1 ) throw new StageException ( KafkaErrors . KAFKA_42 , conf . topic ) ; \n} \nreturn originParallelism ; \n} \n} \n"}
{"2283": "public class BigQueryDelegate { \npublic TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { \ncheckArgument ( timeout >= 1000 , \"Timeout must be at least one second.\" ) ; \nInstant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; \nJobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; \nJobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; \nJob queryJob = bigquery . create ( jobInfo ) ; \nif ( queryJob == null ) { \nLOG . error ( \"Job no longer exists: {}\" , jobInfo ) ; \nthrow new RuntimeException ( \"Job no longer exists: \" + jobInfo ) ; \n} \nelse if ( queryJob . getStatus ( ) . getError ( ) != null ) { \nBigQueryError error = queryJob . getStatus ( ) . getError ( ) ; \nLOG . error ( \"Query Job execution error: {}\" , error ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , error ) ; \n} \nwhile ( ! queryJob . isDone ( ) ) if ( Instant . now ( clock ) . isAfter ( maxTime ) || ! ThreadUtil . sleep ( 100 ) ) { \nif ( bigquery . cancel ( queryJob . getJobId ( ) ) ) LOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \nelse LOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nString errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nTableResult result = null ; \ntry { \nresult = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; \n} \ncatch ( InterruptedException e ) { \nString errorMsg = e . getMessage ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nreturn result ; \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) root . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) root . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) root . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \nreturn root ; \n} \n} \n"}
{"2285": "public class KineticaTableUtils { \nprivate List < String > getTableDescription ( ) throws GPUdbException { \nList < List < String > > descriptions = showTableResponse . getTableDescriptions ( ) ; \nif ( descriptions == null || descriptions . size ( ) != 1 ) throw new GPUdbException ( \"Error getting description for table \" + tableName ) ; \nreturn descriptions . get ( 0 ) ; \n} \n} \n"}
{"2286": "public class KineticaTableUtils { \nprivate void validateTableAcceptsInserts ( ) throws GPUdbException { \nfor ( String s : tableDescription ) { \nif ( s . equalsIgnoreCase ( \"COLLECTION\" ) ) throw new GPUdbException ( \"Error: table \" + tableName + \" is a Collection\" ) ; \nelse if ( s . equalsIgnoreCase ( \"VIEW\" ) ) throw new GPUdbException ( \"Error: table \" + tableName + \" is a View\" ) ; \nelse if ( s . equalsIgnoreCase ( \"JOIN\" ) ) throw new GPUdbException ( \"Error: table \" + tableName + \" is a Join Table\" ) ; \nelse if ( s . equalsIgnoreCase ( \"RESULT_TABLE\" ) ) throw new GPUdbException ( \"Error: table \" + tableName + \" is a Result Table\" ) ; \n} \n} \n} \n"}
{"2287": "public class KineticaTableUtils { \nprivate Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { \nClass < ? > columnType = null ; \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \nj < columnTypes . length ( ) ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ! ct . equals ( \"null\" ) ) { \ncolumnType = getClassForType ( ct ) ; \nbreak ; \n} \n} \n} \nelse columnType = getClassForType ( field . getString ( \"type\" ) ) ; \nif ( columnType == null ) throw new GPUdbException ( \"Error getting column type for field: \" + field . toString ( ) ) ; \nreturn columnType ; \n} \n} \n"}
{"2288": "public class KineticaTableUtils { \nprivate boolean typeIsNullable ( JSONObject field ) throws GPUdbException { \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \nj < columnTypes . length ( ) ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ct . equals ( \"null\" ) ) return true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2289": "public class KineticaTableUtils { \nprivate JSONObject getTableSchema ( String tableName , ShowTableResponse showTableResponse ) throws GPUdbException { \nList < String > schemas = showTableResponse . getTypeSchemas ( ) ; \nif ( schemas == null || schemas . size ( ) != 1 ) throw new GPUdbException ( \"Error getting schema for table \" + tableName ) ; \nreturn new JSONObject ( schemas . get ( 0 ) ) ; \n} \n} \n"}
{"2290": "public class KineticaTableUtils { \nprivate Map < String , List < String > > getColumnProperties ( String tableName , ShowTableResponse showTableResponse ) throws GPUdbException { \nList < Map < String , List < String > > > columnPropertiesList = showTableResponse . getProperties ( ) ; \nif ( columnPropertiesList == null || columnPropertiesList . size ( ) != 1 ) throw new GPUdbException ( \"Error getting properties for table \" + tableName ) ; \nreturn columnPropertiesList . get ( 0 ) ; \n} \n} \n"}
{"2291": "public class KineticaTableUtils { \nprivate Class < ? > getClassForType ( String typeName ) throws GPUdbException { \ntypeName = typeName . replace ( \" \" , \"\" ) ; \nif ( typeName . equalsIgnoreCase ( STRING_TYPE_NAME ) ) return String . class ; \nelse if ( typeName . equalsIgnoreCase ( LONG_TYPE_NAME ) ) return Long . class ; \nelse if ( typeName . equalsIgnoreCase ( INTEGER_TYPE_NAME ) ) return Integer . class ; \nelse if ( typeName . equalsIgnoreCase ( FLOAT_TYPE_NAME ) ) return Float . class ; \nelse if ( typeName . equalsIgnoreCase ( DOUBLE_TYPE_NAME ) ) return Double . class ; \nelse if ( typeName . equalsIgnoreCase ( BYTES_TYPE_NAME ) ) return ByteBuffer . class ; \nelse throw new GPUdbException ( \"Error: unknown type '\" + typeName + \"' in table schema\" ) ; \n} \n} \n"}
{"2293": "public class MqttClientTarget { \nString getTopic ( Record record ) throws StageException { \nString result = publisherConf . topic ; \nif ( publisherConf . runtimeTopicResolution ) { \nRecordEL . setRecordInContext ( topicVars , record ) ; \ntry { \nresult = topicEval . eval ( topicVars , publisherConf . topicExpression , String . class ) ; \nif ( isEmpty ( result ) ) throw new StageException ( Errors . MQTT_08 , publisherConf . topicExpression , record . getHeader ( ) . getSourceId ( ) ) ; \nif ( ! allowedTopics . contains ( result ) && ! allowAllTopics ) throw new StageException ( Errors . MQTT_09 , result , record . getHeader ( ) . getSourceId ( ) ) ; \n} \ncatch ( ELEvalException e ) { \nthrow new StageException ( Errors . MQTT_10 , publisherConf . topicExpression , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2294": "public class JmsSourceUpgrader { \nprivate static void upgradeV5ToV6 ( List < Config > configs , Context context ) { \nList < Config > dataFormatConfigs = configs . stream ( ) . filter ( c -> c . getName ( ) . startsWith ( \"dataFormat\" ) ) . collect ( Collectors . toList ( ) ) ; \nconfigs . removeAll ( dataFormatConfigs ) ; \nif ( dataFormatConfigs . stream ( ) . noneMatch ( c -> \"dataFormatConfig.compression\" . equals ( c . getName ( ) ) ) ) dataFormatConfigs . add ( new Config ( \"dataFormatConfig.compression\" , \"NONE\" ) ) ; \ncontext . registerService ( DataFormatParserService . class , dataFormatConfigs ) ; \n} \n} \n"}
{"2295": "public class DataStore { \npublic InputStream getInputStream ( ) throws IOException { \nacquireLock ( ) ; \ntry { \nisClosed = false ; \nforWrite = false ; \nLOG . trace ( \"Starts read '{}'\" , file ) ; \nverifyAndRecover ( ) ; \nInputStream is = new ProxyInputStream ( new FileInputStream ( file . toFile ( ) ) ) { \n@ Override public void close ( ) throws IOException { \nif ( isClosed ) return ; \ntry { \nsuper . close ( ) ; \n} \nfinally { \nrelease ( ) ; \nisClosed = true ; \nstream = null ; \n} \nLOG . trace ( \"Finishes read '{}'\" , file ) ; \n} \n} \n; \nstream = is ; \nreturn is ; \n} \ncatch ( Exception ex ) { \nrelease ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2296": "public class DataStore { \npublic OutputStream getOutputStream ( ) throws IOException { \nacquireLock ( ) ; \ntry { \nisClosed = false ; \nforWrite = true ; \nLOG . trace ( \"Starts write '{}'\" , file ) ; \nverifyAndRecover ( ) ; \nif ( Files . exists ( file ) ) { \nFiles . move ( file , fileOld ) ; \nLOG . trace ( \"Starting write, move '{}' to '{}'\" , file , fileOld ) ; \n} \nOutputStream os = new ProxyOutputStream ( new FileOutputStream ( fileTmp . toFile ( ) ) ) { \n@ Override public void close ( ) throws IOException { \nif ( isClosed ) return ; \ntry { \nsuper . close ( ) ; \n} \nfinally { \nisClosed = true ; \nstream = null ; \n} \nLOG . trace ( \"Finishes write '{}'\" , file ) ; \n} \n} \n; \nstream = os ; \nreturn os ; \n} \ncatch ( Exception ex ) { \nrelease ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2298": "public class HdfsUtils { \npublic static FsPermission parseFsPermission ( String permissions ) throws IllegalArgumentException { \ntry { \nreturn new FsPermission ( permissions ) ; \n} \ncatch ( IllegalArgumentException e ) { \nif ( permissions . length ( ) == 9 ) permissions = \"-\" + permissions ; \nreturn FsPermission . valueOf ( permissions ) ; \n} \n} \n} \n"}
{"2299": "public class ClassLoaderStageLibraryTask { \nprivate void validateAllServicesAvailable ( ) { \nList < String > missingServices = new LinkedList < > ( ) ; \nfor ( StageDefinition stage : stageList ) { \nfor ( ServiceDependencyDefinition service : stage . getServices ( ) ) { \nif ( ! serviceMap . containsKey ( service . getService ( ) ) ) missingServices . add ( Utils . format ( \"Stage {} is missing service {}\" , stage . getName ( ) , service . getService ( ) . getName ( ) ) ) ; \n} \n} \nif ( ! missingServices . isEmpty ( ) ) throw new RuntimeException ( \"Missing services: \" + StringUtils . join ( missingServices , \", \" ) ) ; \nList < String > unsupportedServices = new LinkedList < > ( ) ; \nfor ( ServiceDefinition serviceDefinition : serviceList ) { \nif ( ! ServiceRuntime . supports ( serviceDefinition . getProvides ( ) ) ) unsupportedServices . add ( serviceDefinition . getProvides ( ) . toString ( ) ) ; \n} \nif ( ! unsupportedServices . isEmpty ( ) ) throw new RuntimeException ( \"Unsupported services: \" + StringUtils . join ( unsupportedServices , \", \" ) ) ; \n} \n} \n"}
{"2309": "public class FileFilter { \nprivate static String globToRegex ( String glob ) { \nif ( glob . charAt ( 0 ) == '.' || glob . contains ( \"/\" ) || glob . contains ( \"~\" ) ) throw new IllegalArgumentException ( \"Invalid character in file glob\" ) ; \nglob = glob . replace ( \".\" , \"\\\\.\" ) ; \nglob = glob . replace ( \"*\" , \".+\" ) ; \nglob = glob . replace ( \"?\" , \".{1}+\" ) ; \nreturn glob ; \n} \n} \n"}
{"2310": "public class AmazonS3Util { \nstatic List < S3ObjectSummary > listObjectsLexicographically ( AmazonS3 s3Client , S3ConfigBean s3ConfigBean , AntPathMatcher pathMatcher , S3Offset s3Offset , int fetchSize ) { \nList < S3ObjectSummary > list = new ArrayList < > ( fetchSize ) ; \nListObjectsRequest listObjectsRequest = new ListObjectsRequest ( ) ; \nlistObjectsRequest . setBucketName ( s3ConfigBean . s3Config . bucket ) ; \nlistObjectsRequest . setPrefix ( s3ConfigBean . s3Config . commonPrefix ) ; \nlistObjectsRequest . setMaxKeys ( BATCH_SIZE ) ; \nif ( s3Offset . getKey ( ) != null ) listObjectsRequest . setMarker ( s3Offset . getKey ( ) ) ; \nObjectListing objectListing = s3Client . listObjects ( listObjectsRequest ) ; \nwhile ( true ) { \nfor ( S3ObjectSummary s : objectListing . getObjectSummaries ( ) ) { \nString fullPrefix = s . getKey ( ) ; \nString remainingPrefix = fullPrefix . substring ( s3ConfigBean . s3Config . commonPrefix . length ( ) , fullPrefix . length ( ) ) ; \nif ( ! remainingPrefix . isEmpty ( ) ) { \nif ( pathMatcher . match ( s3ConfigBean . s3FileConfig . prefixPattern , remainingPrefix ) ) list . add ( s ) ; \nif ( list . size ( ) == fetchSize ) return list ; \n} \n} \nif ( ! objectListing . isTruncated ( ) ) break ; \nobjectListing = s3Client . listNextBatchOfObjects ( objectListing ) ; \n} \nreturn list ; \n} \n} \n"}
{"2312": "public class ProductionPipelineRunner { \npublic int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { \nLOG . debug ( \"Checking if any active runner is idle\" ) ; \nint counter = 0 ; \ntry { \ndestroyLock . lock ( ) ; \nwhile ( running && counter < pipes . size ( ) ) { \ncounter ++ ; \nPipeRunner runner = null ; \ntry { \nrunner = runnerPool . getIdleRunner ( idleTime ) ; \nif ( runner == null ) return counter ; \nLOG . debug ( \"Generating empty batch for runner: {}\" , runner . getRunnerId ( ) ) ; \npipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; \nFullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; \npipeBatch . setIdleBatch ( true ) ; \npipeBatch . skipStage ( originPipe ) ; \nexecuteRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; \n} \nfinally { \nif ( runner != null ) runnerPool . returnRunner ( runner ) ; \n} \n} \n} \nfinally { \ndestroyLock . unlock ( ) ; \n} \nreturn counter ; \n} \n} \n"}
{"2313": "public class ProductionPipelineRunner { \nprivate void createFailureBatch ( FullPipeBatch pipeBatch ) { \nif ( ! pipelineConfigBean . shouldCreateFailureSnapshot ) return ; \ntry { \nfor ( SnapshotInfo info : snapshotStore . getSummaryForPipeline ( pipelineName , revision ) ) { \nif ( info . isFailureSnapshot ( ) ) { \nLOG . trace ( \"Skipping creation of failure snapshot as {} already exists.\" , info . getId ( ) ) ; \nreturn ; \n} \n} \nString snapshotName = \"Failure_\" + UUID . randomUUID ( ) . toString ( ) ; \nString snapshotLabel = \"Failure at \" + LocalDateTime . now ( ) . toString ( ) ; \nsnapshotStore . create ( \"\" , pipelineName , revision , snapshotName , snapshotLabel , true ) ; \nsnapshotStore . save ( pipelineName , revision , snapshotName , - 1 , ImmutableList . of ( pipeBatch . createFailureSnapshot ( ) ) ) ; \n} \ncatch ( PipelineException ex ) { \nLOG . error ( \"Can't serialize failure snapshot\" , ex ) ; \n} \n} \n} \n"}
{"2314": "public class CassandraTarget { \n@ SuppressWarnings ( \"unchecked\" ) private BoundStatement recordToBoundStatement ( Record record ) throws StageException { \nImmutableList . Builder < Object > values = new ImmutableList . Builder < > ( ) ; \nSortedSet < String > columnsPresent = Sets . newTreeSet ( columnMappings . keySet ( ) ) ; \nfor ( Map . Entry < String , String > mapping : columnMappings . entrySet ( ) ) { \nString columnName = mapping . getKey ( ) ; \nString fieldPath = mapping . getValue ( ) ; \nif ( ! record . has ( fieldPath ) || record . get ( fieldPath ) . getValue ( ) == null ) { \ncolumnsPresent . remove ( columnName ) ; \ncontinue ; \n} \nfinal Object value = record . get ( fieldPath ) . getValue ( ) ; \nif ( value instanceof List ) { \nList < Object > unpackedList = new ArrayList < > ( ) ; \nfor ( Field item : ( List < Field > ) value ) { \nunpackedList . add ( item . getValue ( ) ) ; \n} \nvalues . add ( unpackedList ) ; \n} \nelse if ( value instanceof Map ) { \nMap < Object , Object > unpackedMap = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Field > entry : ( ( Map < String , Field > ) value ) . entrySet ( ) ) { \nunpackedMap . put ( entry . getKey ( ) , entry . getValue ( ) . getValue ( ) ) ; \n} \nvalues . add ( unpackedMap ) ; \n} \nelse values . add ( value ) ; \n} \nPreparedStatement stmt = statementCache . getUnchecked ( columnsPresent ) ; \nObject [ ] valuesArray = values . build ( ) . toArray ( ) ; \nBoundStatement boundStmt = null ; \ntry { \nboundStmt = stmt . bind ( valuesArray ) ; \n} \ncatch ( CodecNotFoundException | InvalidTypeException | NullPointerException e ) { \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) , e ) ) ; \n} \nreturn boundStmt ; \n} \n} \n"}
{"2315": "public class Configuration { \npublic void set ( Map < String , String > newConfiguration ) { \nfor ( Map . Entry < String , String > entry : newConfiguration . entrySet ( ) ) { \nif ( entry . getValue ( ) == null ) this . unset ( entry . getKey ( ) ) ; \nelse this . set ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \n} \n"}
{"2316": "public class KuduLookupProcessor { \nprivate KuduLookupKey generateLookupKey ( final Record record , final String tableName ) throws OnRecordErrorException { \nMap < String , Field > keyList = new HashMap < > ( ) ; \nfor ( Map . Entry < String , String > key : columnToField . entrySet ( ) ) { \nString fieldName = key . getValue ( ) ; \nif ( ! record . has ( fieldName ) ) throw new OnRecordErrorException ( record , Errors . KUDU_32 , fieldName ) ; \nkeyList . put ( key . getKey ( ) , record . get ( fieldName ) ) ; \n} \nreturn new KuduLookupKey ( tableName , keyList ) ; \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff && ! partitioningTurnedOn ) continue ; \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal int newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( partitioningTurnedOff ) { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nelse if ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) throw new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \n} \n} \n"}
{"2320": "public class SchAdmin { \npublic static void enableDPM ( DPMInfoJson dpmInfo , Context context ) throws IOException { \nUtils . checkNotNull ( dpmInfo , \"DPMInfo\" ) ; \nString dpmBaseURL = normalizeDpmBaseURL ( dpmInfo . getBaseURL ( ) ) ; \nString currentDPMBaseURL = context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , \"\" ) ; \nString currentAppAuthToken = context . configuration . get ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , \"\" ) . trim ( ) ; \nif ( ! currentDPMBaseURL . equals ( dpmBaseURL ) || currentAppAuthToken . length ( ) == 0 ) { \nString userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; \nString appAuthToken = null ; \nResponse response = null ; \ntry { \nMap < String , Object > newComponentJson = new HashMap < > ( ) ; \nnewComponentJson . put ( \"organization\" , dpmInfo . getOrganization ( ) ) ; \nnewComponentJson . put ( \"componentType\" , \"dc\" ) ; \nnewComponentJson . put ( \"numberOfComponents\" , 1 ) ; \nnewComponentJson . put ( \"active\" , true ) ; \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/rest/v1/organization/\" + dpmInfo . getOrganization ( ) + \"/components\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) throw new RuntimeException ( Utils . format ( \"DPM Create Application Token failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \nList < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { \n} \n) ; \nif ( newComponent . size ( ) > 0 ) appAuthToken = ( String ) newComponent . get ( 0 ) . get ( \"fullAuthToken\" ) ; \nelse throw new RuntimeException ( \"DPM Create Application Token failed: No token data from DPM Server.\" ) ; \n} \nfinally { \nif ( response != null ) response . close ( ) ; \nlogout ( dpmBaseURL , userAuthToken ) ; \n} \nupdateTokenFile ( context , appAuthToken ) ; \n} \nupdateDpmProperties ( context , dpmBaseURL , dpmInfo . getLabels ( ) , true ) ; \n} \n} \n"}
{"2322": "public class SchAdmin { \nprivate static String normalizeDpmBaseURL ( String url ) { \nif ( url . endsWith ( \"/\" ) ) url = url . substring ( 0 , url . length ( ) - 1 ) ; \nreturn url ; \n} \n} \n"}
{"2323": "public class SchAdmin { \nprivate static String retrieveUserToken ( String url , String username , String password ) { \nResponse response = null ; \ntry { \nMap < String , String > loginJson = new HashMap < > ( ) ; \nloginJson . put ( \"userName\" , username ) ; \nloginJson . put ( \"password\" , password ) ; \nresponse = ClientBuilder . newClient ( ) . target ( url + \"/security/public-rest/v1/authentication/login\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . post ( Entity . json ( loginJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . OK . getStatusCode ( ) ) throw new RuntimeException ( Utils . format ( \"DPM Login failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \n} \nfinally { \nif ( response != null ) response . close ( ) ; \n} \nreturn response . getHeaderString ( SSOConstants . X_USER_AUTH_TOKEN ) ; \n} \n} \n"}
{"2324": "public class SchAdmin { \nprivate static void logout ( String dpmBaseURL , String userAuthToken ) { \nResponse response = null ; \ntry { \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/_logout\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . cookie ( SSOConstants . AUTHENTICATION_COOKIE_PREFIX + \"LOGIN\" , userAuthToken ) . get ( ) ; \n} \nfinally { \nif ( response != null ) response . close ( ) ; \n} \n} \n} \n"}
{"2326": "public class SchAdmin { \nprivate static void updateDpmProperties ( Context context , String dpmBaseURL , List < String > labels , boolean enableSch ) { \nif ( context . skipUpdatingDpmProperties ) return ; \ntry { \nFileBasedConfigurationBuilder < PropertiesConfiguration > builder = new FileBasedConfigurationBuilder < > ( PropertiesConfiguration . class ) . configure ( new Parameters ( ) . properties ( ) . setFileName ( context . runtimeInfo . getConfigDir ( ) + \"/dpm.properties\" ) . setThrowExceptionOnMissing ( true ) . setListDelimiterHandler ( new DefaultListDelimiterHandler ( ';' ) ) . setIncludesAllowed ( false ) ) ; \nPropertiesConfiguration config = null ; \nconfig = builder . getConfiguration ( ) ; \nconfig . setProperty ( RemoteSSOService . DPM_ENABLED , Boolean . toString ( enableSch ) ) ; \nconfig . setProperty ( RemoteSSOService . DPM_BASE_URL_CONFIG , dpmBaseURL ) ; \nconfig . setProperty ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , APP_TOKEN_FILE_PROP_VAL ) ; \nif ( labels != null && labels . size ( ) > 0 ) config . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , StringUtils . join ( labels , ',' ) ) ; \nelse config . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , \"\" ) ; \nbuilder . save ( ) ; \n} \ncatch ( ConfigurationException e ) { \nthrow new RuntimeException ( Utils . format ( \"Updating dpm.properties file failed: {}\" , e . getMessage ( ) ) , e ) ; \n} \n} \n} \n"}
{"2327": "public class AvroSchemaGenerator { \nprivate Schema . Field schemaFieldForType ( String fieldPath , Record record , String fieldName , Field field ) throws OnRecordErrorException { \nSchema simpleSchema = simpleSchemaForType ( fieldPath , record , field ) ; \nSchema finalSchema = simpleSchema ; \nif ( getConfig ( ) . avroNullableFields ) finalSchema = Schema . createUnion ( ImmutableList . of ( Schema . create ( Schema . Type . NULL ) , simpleSchema ) ) ; \nreturn new Schema . Field ( fieldName , finalSchema , null , getDefaultValue ( simpleSchema ) ) ; \n} \n} \n"}
{"2328": "public class AvroSchemaGenerator { \nprivate Schema complexSchemaForType ( String fieldPath , Record record , Field field ) throws OnRecordErrorException { \nSchema simpleSchema = simpleSchemaForType ( fieldPath , record , field ) ; \nSchema finalSchema = simpleSchema ; \nif ( getConfig ( ) . avroNullableFields ) finalSchema = Schema . createUnion ( ImmutableList . of ( Schema . create ( Schema . Type . NULL ) , simpleSchema ) ) ; \nJsonNode defaultValue = getDefaultValue ( simpleSchema ) ; \nif ( defaultValue != null ) finalSchema . addProp ( \"defaultValue\" , defaultValue ) ; \nreturn finalSchema ; \n} \n} \n"}
{"2329": "public class AvroSchemaGenerator { \nprivate int getDecimalScaleOrPrecision ( Record record , Field field , String attributeName , int defaultValue , int minAllowed ) throws OnRecordErrorException { \nint finalValue = - 1 ; \nString stringValue = field . getAttribute ( attributeName ) ; \nif ( ! StringUtils . isEmpty ( stringValue ) ) finalValue = Integer . valueOf ( stringValue ) ; \nif ( finalValue < minAllowed ) finalValue = defaultValue ; \nif ( finalValue < minAllowed ) throw new OnRecordErrorException ( record , Errors . SCHEMA_GEN_0004 , finalValue , field ) ; \nreturn finalValue ; \n} \n} \n"}
{"2330": "public class AvroSchemaGenerator { \nprivate JsonNode getDefaultValue ( Schema schema ) { \nif ( getConfig ( ) . avroNullableFields && getConfig ( ) . avroDefaultNullable ) return NullNode . getInstance ( ) ; \nif ( ! getConfig ( ) . avroNullableFields && defaultValuesForTypes . containsKey ( schema . getType ( ) ) ) return defaultValuesForTypes . get ( schema . getType ( ) ) ; \nreturn null ; \n} \n} \n"}
{"2331": "public class FileRefUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static synchronized void initMetricsIfNeeded ( ProtoConfigurableEntity . Context context ) { \nGauge < Map < String , Object > > gauge = context . getGauge ( fileStatisticGaugeName ( context ) ) ; \nif ( gauge == null ) { \ngauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; \nMap < String , Object > gaugeStatistics = gauge . getValue ( ) ; \ngaugeStatistics . put ( FileRefUtil . FILE , \"\" ) ; \ngaugeStatistics . put ( FileRefUtil . TRANSFER_THROUGHPUT , 0L ) ; \ngaugeStatistics . put ( FileRefUtil . SENT_BYTES , String . format ( FileRefUtil . BRACKETED_TEMPLATE , 0 , 0 ) ) ; \ngaugeStatistics . put ( FileRefUtil . REMAINING_BYTES , 0L ) ; \ngaugeStatistics . put ( FileRefUtil . COMPLETED_FILE_COUNT , 0L ) ; \n} \nMeter dataTransferMeter = context . getMeter ( FileRefUtil . TRANSFER_THROUGHPUT_METER ) ; \nif ( dataTransferMeter == null ) context . createMeter ( FileRefUtil . TRANSFER_THROUGHPUT_METER ) ; \n} \n} \n"}
{"2332": "public class LocalFileSystem { \npublic int compare ( WrappedFile path1 , WrappedFile path2 , boolean useLastModified ) { \ntry { \nif ( useLastModified && ! exists ( path2 ) ) return 1 ; \nreturn getComparator ( useLastModified ) . compare ( path1 , path2 ) ; \n} \ncatch ( RuntimeException ex ) { \nThrowable cause = ex . getCause ( ) ; \nif ( cause != null && cause instanceof NoSuchFileException ) { \nLOG . debug ( \"Starting file may have already been archived.\" , cause ) ; \nreturn 1 ; \n} \nLOG . warn ( \"Error while comparing files\" , ex ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2334": "public class Pattern { \npublic List < String > groupNames ( ) { \nif ( groupNames == null ) groupNames = new ArrayList < String > ( groupInfo . keySet ( ) ) ; \nreturn groupNames ; \n} \n} \n"}
{"2337": "public class Pattern { \nstatic private boolean isInsideCharClass ( String s , int pos ) { \nboolean openBracketFound = false ; \nboolean closeBracketFound = false ; \nString s2 = s . substring ( 0 , pos ) ; \nint posOpen = pos ; \nwhile ( ( posOpen = s2 . lastIndexOf ( '[' , posOpen - 1 ) ) != - 1 ) if ( ! isEscapedChar ( s2 , posOpen ) ) { \nopenBracketFound = true ; \nbreak ; \n} \nif ( openBracketFound ) { \nString s3 = s . substring ( posOpen , pos ) ; \nint posClose = - 1 ; \nwhile ( ( posClose = s3 . indexOf ( ']' , posClose + 1 ) ) != - 1 ) if ( ! isEscapedChar ( s3 , posClose ) ) { \ncloseBracketFound = true ; \nbreak ; \n} \n} \nreturn openBracketFound && ! closeBracketFound ; \n} \n} \n"}
{"2338": "public class Pattern { \nstatic private int countOpenParens ( String s , int pos ) { \njava . util . regex . Pattern p = java . util . regex . Pattern . compile ( \"\\\\(\" ) ; \njava . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; \nint numParens = 0 ; \nwhile ( m . find ( ) ) { \nif ( isInsideCharClass ( s , m . start ( ) ) ) continue ; \nif ( isEscapedChar ( s , m . start ( ) ) ) continue ; \nif ( ! isNoncapturingParen ( s , m . start ( ) ) ) numParens ++ ; \n} \nreturn numParens ; \n} \n} \n"}
{"2339": "public class Pattern { \nstatic public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { \nMap < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; \njava . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; \nwhile ( matcher . find ( ) ) { \nint pos = matcher . start ( ) ; \nif ( isEscapedChar ( namedPattern , pos ) ) continue ; \nString name = matcher . group ( INDEX_GROUP_NAME ) ; \nint groupIndex = countOpenParens ( namedPattern , pos ) ; \nList < GroupInfo > list ; \nif ( groupInfo . containsKey ( name ) ) list = groupInfo . get ( name ) ; \nelse list = new ArrayList < GroupInfo > ( ) ; \nlist . add ( new GroupInfo ( groupIndex , pos ) ) ; \ngroupInfo . put ( name , list ) ; \n} \nreturn groupInfo ; \n} \n} \n"}
{"2340": "public class Pattern { \nstatic private StringBuilder replace ( StringBuilder input , java . util . regex . Pattern pattern , String replacement ) { \njava . util . regex . Matcher m = pattern . matcher ( input ) ; \nwhile ( m . find ( ) ) { \nif ( isEscapedChar ( input . toString ( ) , m . start ( ) ) ) continue ; \ninput . replace ( m . start ( ) , m . end ( ) , replacement ) ; \nm . reset ( input ) ; \n} \nreturn input ; \n} \n} \n"}
{"2341": "public class JMXJsonServlet { \n@ Override public void doGet ( HttpServletRequest request , HttpServletResponse response ) { \ntry { \nJsonGenerator jg = null ; \nString jsonpcb = null ; \nPrintWriter writer = null ; \ntry { \nwriter = response . getWriter ( ) ; \njsonpcb = request . getParameter ( CALLBACK_PARAM ) ; \nif ( jsonpcb != null ) { \nresponse . setContentType ( \"application/javascript; charset=utf8\" ) ; \nwriter . write ( jsonpcb + \"(\" ) ; \n} \nelse response . setContentType ( \"application/json; charset=utf8\" ) ; \njg = jsonFactory . createGenerator ( writer ) ; \njg . disable ( JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ; \njg . useDefaultPrettyPrinter ( ) ; \njg . writeStartObject ( ) ; \nString getmethod = request . getParameter ( \"get\" ) ; \nif ( getmethod != null ) { \nString [ ] splitStrings = getmethod . split ( \"\\\\:\\\\:\" ) ; \nif ( splitStrings . length != 2 ) { \njg . writeStringField ( \"result\" , \"ERROR\" ) ; \njg . writeStringField ( \"message\" , \"query format is not as expected.\" ) ; \njg . flush ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nlistBeans ( jg , new ObjectName ( splitStrings [ 0 ] ) , splitStrings [ 1 ] , response ) ; \nreturn ; \n} \nString qry = request . getParameter ( \"qry\" ) ; \nif ( qry == null ) qry = \"*:*\" ; \nlistBeans ( jg , new ObjectName ( qry ) , null , response ) ; \n} \nfinally { \nif ( jg != null ) jg . close ( ) ; \nif ( jsonpcb != null ) writer . write ( \");\" ) ; \nif ( writer != null ) writer . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nresponse . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; \n} \ncatch ( MalformedObjectNameException e ) { \nresponse . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; \n} \n} \n} \n"}
{"2342": "public class OracleCDCSource { \nprivate boolean refreshSchema ( BigDecimal scnDecimal , SchemaAndTable schemaAndTable ) throws SQLException { \ntry { \nif ( ! tableSchemaLastUpdate . containsKey ( schemaAndTable ) || scnDecimal . compareTo ( tableSchemaLastUpdate . get ( schemaAndTable ) ) > 0 ) { \nif ( containerized ) try ( Statement switchToPdb = connection . createStatement ( ) ) { \nswitchToPdb . execute ( \"ALTER SESSION SET CONTAINER = \" + configBean . pdb ) ; \n} \ntableSchemas . put ( schemaAndTable , getTableSchema ( schemaAndTable ) ) ; \ntableSchemaLastUpdate . put ( schemaAndTable , scnDecimal ) ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nalterSession ( ) ; \n} \n} \n} \n"}
{"2347": "public class MathEL { \nprivate static Object convertStringToAppropriateNumber ( String value ) { \nif ( value . contains ( \".\" ) ) return Double . valueOf ( value ) ; \nelse return Long . valueOf ( value ) ; \n} \n} \n"}
{"2348": "public class CollectdParser { \nprivate int parsePart ( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { \nint offset = startOffset ; \nint type = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nfinal int length = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nswitch ( type ) { \ncase HOST : case PLUGIN : case PLUGIN_INSTANCE : case TYPE : case TYPE_INSTANCE : case MESSAGE : pruneFields ( type ) ; \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseString ( offset , length , buf ) ) ) ; \noffset += length - 4 ; \nbreak ; \ncase TIME_HIRES : case INTERVAL_HIRES : if ( type != INTERVAL_HIRES || ! excludeInterval ) { \nlong value = parseNumeric ( offset , buf ) ; \nif ( convertTime ) { \nvalue *= ( Math . pow ( 2 , - 30 ) * 1000 ) ; \ntype = type == TIME_HIRES ? TIME : INTERVAL ; \n} \nfields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; \n} \noffset += 8 ; \nbreak ; \ncase TIME : case INTERVAL : case SEVERITY : if ( type != INTERVAL || ! excludeInterval ) fields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; \noffset += 8 ; \nbreak ; \ncase VALUES : offset = parseValues ( offset , buf ) ; \nstartNewRecord ( ) ; \nbreak ; \ncase SIGNATURE : if ( ! verifySignature ( offset , length , buf ) ) throw new OnRecordErrorException ( Errors . COLLECTD_02 ) ; \noffset += length - 4 ; \nbreak ; \ncase ENCRYPTION : String user = parseUser ( offset , buf ) ; \noffset += ( 2 + user . length ( ) ) ; \nbyte [ ] iv = parseIv ( offset , buf ) ; \noffset += 16 ; \ndecrypt ( offset , length , buf , user , iv ) ; \noffset += 20 ; \nbreak ; \ndefault : LOG . warn ( \"Unrecognized part type: {}\" , type ) ; \noffset += length - 4 ; \nbreak ; \n} \nreturn offset ; \n} \n} \n"}
{"2350": "public class JdbcBaseRecordWriter { \nvoid lookupPrimaryKeys ( ) throws StageException { \nConnection connection = null ; \ntry { \nconnection = dataSource . getConnection ( ) ; \nprimaryKeyColumns = jdbcUtil . getPrimaryKeys ( connection , schema , tableName ) ; \n} \ncatch ( SQLException e ) { \nString formattedError = jdbcUtil . formatSqlException ( e ) ; \nLOG . error ( formattedError , e ) ; \nthrow new StageException ( JdbcErrors . JDBC_17 , tableName , formattedError ) ; \n} \nfinally { \nif ( connection != null ) try { \nconnection . close ( ) ; \n} \ncatch ( SQLException e ) { \nString formattedError = jdbcUtil . formatSqlException ( e ) ; \nLOG . error ( formattedError , e ) ; \n} \n} \n} \n} \n"}
{"2353": "public class JdbcBaseRecordWriter { \nprotected String getTableName ( ) { \nif ( ! Strings . isNullOrEmpty ( schema ) ) if ( caseSensitive ) return \"\\\"\" + schema + \"\\\".\" + \"\\\"\" + tableName + \"\\\"\" ; \nelse return schema + \".\" + tableName ; \nif ( caseSensitive ) return \"\\\"\" + tableName + \"\\\"\" ; \nreturn tableName ; \n} \n} \n"}
{"2361": "public class SampleExecutor { \nprivate void execute ( Record record ) throws OnRecordErrorException { \nif ( ! record . has ( \"/someField\" ) ) throw new OnRecordErrorException ( Errors . SAMPLE_01 , record , \"exception detail message.\" ) ; \n} \n} \n"}
{"2362": "public class JdbcMySqlBinLogRecordReader { \n@ Override public SortedMap < String , String > getColumnsToParameters ( final Record record , int op , Map < String , String > parameters , Map < String , String > columnsToFields ) { \nSortedMap < String , String > columnsToParameters = new TreeMap < > ( ) ; \nfor ( Map . Entry < String , String > entry : columnsToFields . entrySet ( ) ) { \nString columnName = entry . getKey ( ) ; \nString fieldPath = entry . getValue ( ) ; \nif ( op == OperationType . DELETE_CODE ) fieldPath = fieldPath . replace ( DATA_FIELD , OLD_DATA_FIELD ) ; \nif ( record . has ( fieldPath ) ) columnsToParameters . put ( columnName , parameters . get ( columnName ) ) ; \n} \nreturn columnsToParameters ; \n} \n} \n"}
{"2364": "public class OffsetQueryUtil { \npublic static Map < String , String > validateStoredAndSpecifiedOffset ( TableContext tableContext , String offset ) throws StageException { \nSet < String > expectedColumns = Sets . newHashSet ( tableContext . getOffsetColumns ( ) ) ; \nfinal Map < String , String > actualOffsets = getColumnsToOffsetMapFromOffsetFormat ( offset ) ; \nif ( actualOffsets . size ( ) == 0 ) return actualOffsets ; \nSet < String > actualColumns = actualOffsets . keySet ( ) ; \nSet < String > expectedSetDifference = Sets . difference ( expectedColumns , actualColumns ) ; \nSet < String > actualSetDifference = Sets . difference ( actualColumns , expectedColumns ) ; \nif ( expectedSetDifference . size ( ) > 0 || actualSetDifference . size ( ) > 0 ) throw new StageException ( JdbcErrors . JDBC_71 , tableContext . getQualifiedName ( ) , COMMA_SPACE_JOINER . join ( actualColumns ) , COMMA_SPACE_JOINER . join ( expectedColumns ) ) ; \nreturn actualOffsets ; \n} \n} \n"}
{"2365": "public class SupportBundleManager { \nprivate List < BundleContentGeneratorDefinition > getRequestedDefinitions ( List < String > generators ) { \nStream < BundleContentGeneratorDefinition > stream = definitions . stream ( ) ; \nif ( generators == null || generators . isEmpty ( ) ) stream = stream . filter ( BundleContentGeneratorDefinition :: isEnabledByDefault ) ; \nelse stream = stream . filter ( def -> generators . contains ( def . getId ( ) ) ) ; \nreturn stream . sorted ( Comparator . comparingInt ( BundleContentGeneratorDefinition :: getOrder ) ) . collect ( Collectors . toList ( ) ) ; \n} \n} \n"}
{"2366": "public class YarnAppLauncher { \nprivate String [ ] getNonEmptyArgs ( List < String > appArgs ) { \nList < String > nonEmpty = new ArrayList < > ( ) ; \nappArgs . forEach ( ( String val ) -> { \nif ( ! StringUtils . isEmpty ( val ) ) nonEmpty . add ( val ) ; \n} \n) ; \nreturn nonEmpty . toArray ( new String [ nonEmpty . size ( ) ] ) ; \n} \n} \n"}
{"2370": "public class LiveDirectoryScanner { \npublic long getPendingFiles ( LiveFile current ) throws IOException { \nif ( current == null || rollMode . isCurrentAcceptable ( current . getPath ( ) . getFileName ( ) . toString ( ) ) ) return findToBeProcessedMatchingFiles ( current != null ? current . refresh ( ) : null ) . size ( ) ; \nreturn 0 ; \n} \n} \n"}
{"2371": "public class CollisionWhitelist { \npublic static boolean isWhitelisted ( String name , Properties specificWhitelist , Map < String , List < Dependency > > dependencies ) { \nif ( specificWhitelist != null && specificWhitelist . containsKey ( name ) ) return versionsMatch ( specificWhitelist . getProperty ( name ) , dependencies . keySet ( ) ) ; \nWhitelistRule rule = WHITELIST_RULES . get ( name ) ; \nreturn rule != null && rule . isWhitelisted ( dependencies ) ; \n} \n} \n"}
{"2373": "public class BootstrapClusterStreaming { \npublic static void main ( String [ ] args ) throws Exception { \nSparkStreamingBinding binding = null ; \ntry { \nbinding = SparkStreamingBindingFactory . build ( BootstrapCluster . getProperties ( ) ) ; \nbinding . init ( ) ; \nBootstrapCluster . createTransformers ( binding . getStreamingContext ( ) . sparkContext ( ) , binding . getSparkSession ( ) ) ; \nbinding . startContext ( ) ; \nbinding . awaitTermination ( ) ; \n} \ncatch ( Throwable error ) { \nString msg = \"Error trying to invoke BootstrapClusterStreaming.main: \" + error ; \nSystem . err . println ( new Date ( ) + \": \" + msg ) ; \nerror . printStackTrace ( System . err ) ; \nLOG . error ( msg , error ) ; \nthrow new IllegalStateException ( msg , error ) ; \n} \nfinally { \ntry { \nif ( binding != null ) binding . close ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . warn ( \"Error on binding close: \" + ex , ex ) ; \n} \n} \n} \n} \n"}
{"2374": "public class PipelineConfigurationValidator { \nprivate void propagateRuntimeConfiguration ( ) { \nif ( pipelineBean == null || pipelineBean . getPipelineStageBeans ( ) == null ) return ; \nfor ( StageBean stageBean : pipelineBean . getPipelineStageBeans ( ) . getStages ( ) ) { \nfor ( ServiceDependencyDefinition serviceDependency : stageBean . getDefinition ( ) . getServices ( ) ) { \nServiceBean stageService = stageBean . getService ( serviceDependency . getService ( ) ) ; \nif ( stageService == null ) continue ; \nServiceConfiguration serviceConfiguration = stageService . getConf ( ) ; \nList < Config > configs = serviceConfiguration . getConfiguration ( ) ; \nconfigs . removeAll ( serviceDependency . getConfiguration ( ) . keySet ( ) . stream ( ) . map ( serviceConfiguration :: getConfig ) . collect ( Collectors . toList ( ) ) ) ; \nserviceDependency . getConfiguration ( ) . forEach ( ( key , value ) -> configs . add ( new Config ( key , value ) ) ) ; \nserviceConfiguration . setConfig ( configs ) ; \n} \n} \n} \n} \n"}
{"2375": "public class OmnitureSource { \nprivate void validateReportDescription ( List < ConfigIssue > issues ) { \nif ( ! jsonMapper . isValidJson ( this . reportDescription ) ) issues . add ( getContext ( ) . createConfigIssue ( Groups . REPORT . name ( ) , \"reportDescription\" , Errors . OMNITURE_03 ) ) ; \n} \n} \n"}
{"2376": "public class JdbcRecordReaderWriterFactory { \npublic static JdbcRecordWriter createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , DuplicateKeyAction duplicateKeyAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { \nif ( defaultOpCode == OperationType . LOAD_CODE ) return new JdbcLoadRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , duplicateKeyAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; \nelse return createJdbcRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , null , rollbackOnError , useMultiRowOp , maxPrepStmtParameters , defaultOpCode , unsupportedAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; \n} \n} \n"}
{"2377": "public class JdbcRecordReaderWriterFactory { \npublic static JdbcRecordWriter createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , List < JdbcFieldColumnMapping > generatedColumnMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { \nJdbcRecordWriter recordWriter ; \nif ( useMultiRowOp ) recordWriter = new JdbcMultiRowRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , maxPrepStmtParameters , defaultOpCode , unsupportedAction , generatedColumnMappings , recordReader , caseSensitive , customDataSqlStateCodes ) ; \nelse recordWriter = new JdbcGenericRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , defaultOpCode , unsupportedAction , generatedColumnMappings , recordReader , caseSensitive , customDataSqlStateCodes ) ; \nreturn recordWriter ; \n} \n} \n"}
{"2379": "public class Grok { \npublic Map < String , String > extractNamedGroups ( final CharSequence rawData ) { \nMatcher matcher = compiledPattern . matcher ( rawData ) ; \nif ( matcher . find ( ) ) { \nMatchResult r = matcher . toMatchResult ( ) ; \nif ( r != null && r . namedGroups ( ) != null ) return r . namedGroups ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2380": "public class ControlChannel { \npublic void consumerCommit ( String offset ) { \nObject offsetValue = offset ; \nif ( offsetValue == null ) offsetValue = new NullOffset ( ) ; \nLOG . trace ( \"Commit Offset: '{}'\" , offsetValue ) ; \ntry { \nproducerQueue . put ( new Message ( MessageType . CONSUMER_COMMIT , offsetValue ) ) ; \n} \ncatch ( InterruptedException e ) { \nLOG . info ( \"Interrupted while queuing '{}'\" , MessageType . CONSUMER_COMMIT . name ( ) , offsetValue ) ; \nThread . currentThread ( ) . interrupt ( ) ; \n} \n} \n} \n"}
{"2381": "public class EmbeddedSDCPool { \n@ SuppressWarnings ( \"unchecked\" ) protected EmbeddedSDC create ( ) throws Exception { \nUtils . checkState ( open , \"Not open\" ) ; \nfinal EmbeddedSDC embeddedSDC = new EmbeddedSDC ( ) ; \nObject source ; \nObject pipelineStartResult = BootstrapCluster . startPipeline ( ( ) -> LOG . debug ( \"Batch completed\" ) ) ; \nsource = pipelineStartResult . getClass ( ) . getDeclaredField ( \"source\" ) . get ( pipelineStartResult ) ; \nif ( source instanceof DSource ) { \nlong startTime = System . currentTimeMillis ( ) ; \nlong endTime = startTime ; \nlong diff = 0 ; \nSource actualSource = ( ( DSource ) source ) . getSource ( ) ; \nwhile ( actualSource == null && diff < 60000 ) { \nThread . sleep ( 100 ) ; \nactualSource = ( ( DSource ) source ) . getSource ( ) ; \nendTime = System . currentTimeMillis ( ) ; \ndiff = endTime - startTime ; \n} \nif ( actualSource == null ) throw new IllegalStateException ( \"Actual source is null, pipeline may not have been initialized\" ) ; \nsource = actualSource ; \n} \nif ( ! ( source instanceof ClusterSource ) ) throw new IllegalArgumentException ( \"Source is not of type ClusterSource: \" + source . getClass ( ) . getName ( ) ) ; \nembeddedSDC . setSource ( ( ClusterSource ) source ) ; \nembeddedSDC . setSparkProcessors ( ( List < Object > ) pipelineStartResult . getClass ( ) . getDeclaredField ( \"sparkProcessors\" ) . get ( pipelineStartResult ) ) ; \nreturn embeddedSDC ; \n} \n} \n"}
{"2383": "public class RemoteDataCollector { \n@ Override public List < PipelineAndValidationStatus > getRemotePipelinesWithChanges ( ) throws PipelineException { \nList < PipelineAndValidationStatus > pipelineAndValidationStatuses = new ArrayList < > ( ) ; \nfor ( Pair < PipelineState , Map < String , String > > pipelineStateAndOffset : stateEventListener . getPipelineStateEvents ( ) ) { \nPipelineState pipelineState = pipelineStateAndOffset . getLeft ( ) ; \nMap < String , String > offset = pipelineStateAndOffset . getRight ( ) ; \nString name = pipelineState . getPipelineId ( ) ; \nString rev = pipelineState . getRev ( ) ; \nboolean isClusterMode = ( pipelineState . getExecutionMode ( ) != ExecutionMode . STANDALONE ) ? true : false ; \nList < WorkerInfo > workerInfos = new ArrayList < > ( ) ; \nString title ; \nint runnerCount = 0 ; \nif ( pipelineStore . hasPipeline ( name ) ) { \ntitle = pipelineStore . getInfo ( name ) . getTitle ( ) ; \nRunner runner = manager . getRunner ( name , rev ) ; \nif ( isClusterMode ) workerInfos = getWorkers ( runner . getSlaveCallbackList ( CallbackObjectType . METRICS ) ) ; \nrunnerCount = runner . getRunnerCount ( ) ; \n} \nelse title = null ; \npipelineAndValidationStatuses . add ( new PipelineAndValidationStatus ( getSchGeneratedPipelineName ( name , rev ) , title , rev , pipelineState . getTimeStamp ( ) , true , pipelineState . getStatus ( ) , pipelineState . getMessage ( ) , workerInfos , isClusterMode , getSourceOffset ( name , offset ) , null , runnerCount ) ) ; \n} \nreturn pipelineAndValidationStatuses ; \n} \n} \n"}
{"2386": "public class JdbcMongoDBOplogRecordReader { \n@ Override public SortedMap < String , String > getColumnsToParameters ( final Record record , int op , Map < String , String > parameters , Map < String , String > columnsToFields ) { \nSortedMap < String , String > columnsToParameters = new TreeMap < > ( ) ; \nfor ( Map . Entry < String , String > entry : columnsToFields . entrySet ( ) ) { \nString columnName = entry . getKey ( ) ; \nString fieldPath = getFieldPath ( columnName , columnsToFields , op ) ; \nif ( record . has ( fieldPath ) ) columnsToParameters . put ( columnName , parameters . get ( columnName ) ) ; \nelse LOG . trace ( \"Record is missing a field for column {} for the operation code {}\" , columnName , op ) ; \n} \nreturn columnsToParameters ; \n} \n} \n"}
{"2394": "public class FieldEncrypter { \npublic Optional < Field > checkInputEncrypt ( Field field ) throws StageException { \nif ( UNSUPPORTED_TYPES . contains ( field . getType ( ) ) ) throw new StageException ( CRYPTO_03 , field . getType ( ) ) ; \nreturn Optional . of ( field ) ; \n} \n} \n"}
{"2396": "public class FieldEncrypter { \npublic Optional < Field > checkInputDecrypt ( Field field ) throws StageException { \nif ( field . getType ( ) != Field . Type . BYTE_ARRAY ) throw new StageException ( CRYPTO_02 , field . getType ( ) ) ; \nreturn Optional . of ( field ) ; \n} \n} \n"}
{"2397": "public class FieldEncrypter { \npublic byte [ ] prepareEncrypt ( Field field , Map < String , String > context ) { \ncontext . put ( SDC_FIELD_TYPE , field . getType ( ) . name ( ) ) ; \nif ( field . getType ( ) == Field . Type . BYTE_ARRAY ) return field . getValueAsByteArray ( ) ; \nelse return field . getValueAsString ( ) . getBytes ( Charsets . UTF_8 ) ; \n} \n} \n"}
{"2398": "public class Matcher { \npublic Matcher usePattern ( Pattern newPattern ) { \nif ( newPattern == null ) throw new IllegalArgumentException ( \"newPattern cannot be null\" ) ; \nthis . parentPattern = newPattern ; \nmatcher . usePattern ( newPattern . pattern ( ) ) ; \nreturn this ; \n} \n} \n"}
{"2400": "public class Matcher { \n@ Override public Map < String , String > namedGroups ( ) { \nMap < String , String > result = new LinkedHashMap < String , String > ( ) ; \nif ( matcher . find ( 0 ) ) for ( String groupName : parentPattern . groupNames ( ) ) { \nString groupValue = matcher . group ( groupIndex ( groupName ) ) ; \nresult . put ( groupName , groupValue ) ; \n} \nreturn result ; \n} \n} \n"}
{"2402": "public class DataFormatUpgradeHelper { \npublic static void ensureAvroSchemaExists ( List < Config > configs , String prefix ) { \nOptional < Config > avroSchema = findByName ( configs , \"avroSchema\" ) ; \nif ( ! avroSchema . isPresent ( ) ) configs . add ( new Config ( prefix + \".avroSchema\" , null ) ) ; \n} \n} \n"}
{"2403": "public class Util { \npublic static String getGlobalVariable ( DataSource dataSource , String variable ) throws SQLException { \ntry ( Connection conn = dataSource . getConnection ( ) ) { \ntry ( Statement stmt = conn . createStatement ( ) ; \nResultSet rs = stmt . executeQuery ( String . format ( \"show global variables like '%s'\" , variable ) ) ; \n) { \nif ( rs . next ( ) ) return rs . getString ( 2 ) ; \nelse return \"\" ; \n} \n} \n} \n} \n"}
{"2404": "public class Pipeline { \nprivate Record createStartEvent ( ) { \nPreconditions . checkState ( startEventStage != null , \"Start Event Stage is not set!\" ) ; \nEventRecord eventRecord = new EventRecordImpl ( \"pipeline-start\" , 1 , startEventStage . getInfo ( ) . getInstanceName ( ) , \"\" , null , null ) ; \nMap < String , Field > rootField = new LinkedHashMap < > ( ) ; \nrootField . put ( \"user\" , Field . create ( Field . Type . STRING , userContext . getUser ( ) ) ) ; \nrootField . put ( \"pipelineId\" , Field . create ( Field . Type . STRING , name ) ) ; \nrootField . put ( \"pipelineTitle\" , Field . create ( Field . Type . STRING , pipelineConf . getTitle ( ) ) ) ; \nMap < String , Field > parameters = new LinkedHashMap < > ( ) ; \nif ( runtimeParameters != null ) for ( Map . Entry < String , Object > entry : runtimeParameters . entrySet ( ) ) { \nparameters . put ( entry . getKey ( ) , Field . create ( Field . Type . STRING , entry . getValue ( ) . toString ( ) ) ) ; \n} \nrootField . put ( \"parameters\" , Field . create ( parameters ) ) ; \neventRecord . set ( Field . create ( rootField ) ) ; \nreturn eventRecord ; \n} \n} \n"}
{"2406": "public class SobjectRecordCreator { \nprotected String fixOffset ( String offsetColumn , String offset ) { \ncom . sforce . soap . partner . Field sfdcField = getFieldMetadata ( sobjectType , offsetColumn ) ; \nif ( SobjectRecordCreator . DECIMAL_TYPES . contains ( sfdcField . getType ( ) . toString ( ) ) && offset . contains ( \"E\" ) ) { \nBigDecimal val = new BigDecimal ( offset ) ; \noffset = val . toPlainString ( ) ; \nif ( val . compareTo ( MAX_OFFSET_INT ) > 0 && ! offset . contains ( \".\" ) ) offset += \".0\" ; \n} \nreturn offset ; \n} \n} \n"}
{"2407": "public class ConfigValueExtractor { \nprivate Object extractAsRuntime ( Field field , String valueStr ) { \nif ( field . getType ( ) == Byte . TYPE || field . getType ( ) == Byte . class || field . getType ( ) == Short . TYPE || field . getType ( ) == Short . class || field . getType ( ) == Integer . TYPE || field . getType ( ) == Integer . class || field . getType ( ) == Long . TYPE || field . getType ( ) == Long . class || field . getType ( ) == Float . TYPE || field . getType ( ) == Float . class || field . getType ( ) == Double . TYPE || field . getType ( ) == Double . class ) return extractAsNumber ( field , valueStr ) ; \nelse if ( String . class . isAssignableFrom ( field . getType ( ) ) ) return valueStr ; \nthrow new IllegalArgumentException ( Utils . format ( \"Invalid type for RUNTIME type: {}\" , field . getType ( ) ) ) ; \n} \n} \n"}
{"2410": "public class HiveQueryExecutor { \npublic String executeDescribeDatabase ( String dbName ) throws StageException { \nString sql = buildDescribeDatabase ( dbName ) ; \nreturn executeQuery ( sql , rs -> { \nif ( ! rs . next ( ) ) throw new HiveStageCheckedException ( Errors . HIVE_35 , \"Database doesn't exists.\" ) ; \nreturn HiveMetastoreUtil . stripHdfsHostAndPort ( rs . getString ( RESULT_SET_LOCATION ) ) ; \n} \n) ; \n} \n} \n"}
{"2413": "public class PipeRunner { \npublic void executeBatch ( String offsetKey , String offsetValue , long batchStartTime , ThrowingConsumer < Pipe > consumer ) throws PipelineRuntimeException , StageException { \nMDC . put ( LogConstants . RUNNER , String . valueOf ( runnerId ) ) ; \nthis . runtimeMetricGauge . put ( METRIC_BATCH_START_TIME , batchStartTime ) ; \nthis . runtimeMetricGauge . put ( METRIC_OFFSET_KEY , Optional . ofNullable ( offsetKey ) . orElse ( \"\" ) ) ; \nthis . runtimeMetricGauge . put ( METRIC_OFFSET_VALUE , Optional . ofNullable ( offsetValue ) . orElse ( \"\" ) ) ; \nthis . runtimeMetricGauge . put ( METRIC_STAGE_START_TIME , System . currentTimeMillis ( ) ) ; \ntry { \nfor ( Pipe p : pipes ) { \nString instanceName = p . getStage ( ) . getInfo ( ) . getInstanceName ( ) ; \nthis . runtimeMetricGauge . put ( METRIC_CURRENT_STAGE , instanceName ) ; \nMDC . put ( LogConstants . STAGE , instanceName ) ; \nif ( p instanceof StagePipe ) this . runtimeMetricGauge . put ( METRIC_STAGE_START_TIME , System . currentTimeMillis ( ) ) ; \nacceptConsumer ( consumer , p ) ; \n} \nthis . runtimeMetricGauge . computeIfPresent ( METRIC_BATCH_COUNT , ( key , value ) -> ( ( long ) value ) + 1 ) ; \n} \nfinally { \nresetBatchSpecificMetrics ( ) ; \nMDC . put ( LogConstants . RUNNER , \"\" ) ; \nMDC . put ( LogConstants . STAGE , \"\" ) ; \n} \n} \n} \n"}
{"2415": "public class PipeRunner { \npublic OffsetCommitTrigger getOffsetCommitTrigger ( ) { \nfor ( Pipe pipe : pipes ) { \nStage stage = pipe . getStage ( ) . getStage ( ) ; \nif ( stage instanceof Target && stage instanceof OffsetCommitTrigger ) return ( OffsetCommitTrigger ) stage ; \n} \nreturn null ; \n} \n} \n"}
{"2416": "public class PipeRunner { \npublic boolean onRecordErrorStopPipeline ( ) { \nfor ( Pipe pipe : pipes ) { \nStageContext stageContext = pipe . getStage ( ) . getContext ( ) ; \nif ( stageContext . getOnErrorRecord ( ) == OnRecordError . STOP_PIPELINE ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"2418": "public class BigQueryTarget { \nprivate String getInsertIdForRecord ( ELVars elVars , Record record ) throws OnRecordErrorException { \nString recordId = null ; \nRecordEL . setRecordInContext ( elVars , record ) ; \ntry { \nif ( ! ( StringUtils . isEmpty ( conf . rowIdExpression ) ) ) { \nrecordId = rowIdELEval . eval ( elVars , conf . rowIdExpression , String . class ) ; \nif ( StringUtils . isEmpty ( recordId ) ) throw new OnRecordErrorException ( record , Errors . BIGQUERY_15 ) ; \n} \n} \ncatch ( ELEvalException e ) { \nLOG . error ( \"Error evaluating Row Expression EL\" , e ) ; \nthrow new OnRecordErrorException ( record , Errors . BIGQUERY_10 , e ) ; \n} \nreturn recordId ; \n} \n} \n"}
{"2420": "public class CouchbaseProcessor { \nprivate Observable < Record > setFragmentInRecord ( Record record , DocumentFragment < Lookup > frag ) { \nif ( frag . content ( 0 ) == null ) { \nLOG . debug ( \"Sub-document path not found\" ) ; \nreturn handleError ( record , Errors . COUCHBASE_25 , true ) ; \n} \nfor ( SubdocMappingConfig subdocMapping : config . subdocMappingConfigs ) { \nObject fragJson = frag . content ( subdocMapping . subdocPath ) ; \nif ( fragJson == null ) return handleError ( record , Errors . COUCHBASE_25 , true ) ; \ntry { \nrecord . set ( subdocMapping . sdcField , jsonToField ( fragJson ) ) ; \nrecord . getHeader ( ) . setAttribute ( config . CAS_HEADER_ATTRIBUTE , String . valueOf ( frag . cas ( ) ) ) ; \n} \ncatch ( IOException e ) { \ntry { \nrecord . set ( subdocMapping . sdcField , jsonToField ( JsonObject . fromJson ( fragJson . toString ( ) ) . toMap ( ) ) ) ; \nrecord . getHeader ( ) . setAttribute ( config . CAS_HEADER_ATTRIBUTE , String . valueOf ( frag . cas ( ) ) ) ; \n} \ncatch ( IOException ex ) { \nreturn handleError ( record , Errors . COUCHBASE_19 , ex , false ) ; \n} \n} \n} \nreturn Observable . just ( record ) ; \n} \n} \n"}
{"2423": "public class AmazonS3Runnable { \nprivate void handleWholeFileDataFormat ( S3ObjectSummary s3ObjectSummary , String recordId ) throws StageException { \nS3Object partialS3ObjectForMetadata ; \npartialS3ObjectForMetadata = AmazonS3Util . getObjectRange ( s3Client , s3ConfigBean . s3Config . bucket , s3ObjectSummary . getKey ( ) , 1 , s3ConfigBean . sseConfig . useCustomerSSEKey , s3ConfigBean . sseConfig . customerKey , s3ConfigBean . sseConfig . customerKeyMd5 ) ; \nS3FileRef . Builder s3FileRefBuilder = new S3FileRef . Builder ( ) . s3Client ( s3Client ) . s3ObjectSummary ( s3ObjectSummary ) . useSSE ( s3ConfigBean . sseConfig . useCustomerSSEKey ) . customerKey ( s3ConfigBean . sseConfig . customerKey ) . customerKeyMd5 ( s3ConfigBean . sseConfig . customerKeyMd5 ) . bufferSize ( ( int ) dataParser . suggestedWholeFileBufferSize ( ) ) . createMetrics ( true ) . totalSizeInBytes ( s3ObjectSummary . getSize ( ) ) . rateLimit ( dataParser . wholeFileRateLimit ( ) ) ; \nif ( dataParser . isWholeFileChecksumRequired ( ) ) s3FileRefBuilder . verifyChecksum ( true ) . checksumAlgorithm ( HashingUtil . HashType . MD5 ) . checksum ( partialS3ObjectForMetadata . getObjectMetadata ( ) . getETag ( ) ) ; \nMap < String , Object > metadata = AmazonS3Util . getMetaData ( partialS3ObjectForMetadata ) ; \nmetadata . put ( S3Constants . BUCKET , s3ObjectSummary . getBucketName ( ) ) ; \nmetadata . put ( S3Constants . OBJECT_KEY , s3ObjectSummary . getKey ( ) ) ; \nmetadata . put ( S3Constants . OWNER , s3ObjectSummary . getOwner ( ) ) ; \nmetadata . put ( S3Constants . SIZE , s3ObjectSummary . getSize ( ) ) ; \nmetadata . put ( HeaderAttributeConstants . FILE_NAME , s3ObjectSummary . getKey ( ) ) ; \nmetadata . remove ( S3Constants . CONTENT_LENGTH ) ; \nparser = dataParser . getParser ( recordId , metadata , s3FileRefBuilder . build ( ) ) ; \nobject = partialS3ObjectForMetadata ; \n} \n} \n"}
{"2427": "public class SecurityContext { \npublic synchronized void logout ( ) { \nif ( subject != null ) { \nLOG . debug ( \"Logout. Kerberos enabled '{}', Principal '{}'\" , securityConfiguration . isKerberosEnabled ( ) , subject . getPrincipals ( ) ) ; \nif ( loginContext != null ) try { \nloginContext . logout ( ) ; \n} \ncatch ( LoginException ex ) { \nLOG . warn ( \"Error while doing logout from Kerberos: {}\" , ex . toString ( ) , ex ) ; \n} \nfinally { \nloginContext = null ; \n} \nsubject = null ; \n} \n} \n} \n"}
{"2430": "public class SdcSecurityManager { \nprivate void ensureProperPermissions ( String path ) { \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( cl instanceof ContainerClassLoader ) return ; \nif ( exceptions . contains ( path ) ) return ; \nif ( cl instanceof SDCClassLoader ) { \nString libraryName = ( ( SDCClassLoader ) cl ) . getName ( ) ; \nif ( stageLibExceptions . containsKey ( libraryName ) && stageLibExceptions . get ( libraryName ) . contains ( path ) ) return ; \n} \nthrow new SecurityException ( Utils . format ( \"Classloader {} is not allowed access to Data Collector internal directories ({}).\" , cl . toString ( ) , path ) ) ; \n} \n} \n"}
{"2431": "public class BootstrapEmrBatch { \npublic static void main ( String [ ] args ) throws Exception { \nEmrBinding binding = null ; \ntry { \nbinding = new EmrBinding ( args ) ; \nbinding . init ( ) ; \nbinding . awaitTermination ( ) ; \n} \ncatch ( Exception ex ) { \nString msg = \"Error trying to invoke BootstrapEmrBatch.main: \" + ex ; \nthrow new IllegalStateException ( msg , ex ) ; \n} \nfinally { \ntry { \nif ( binding != null ) binding . close ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . warn ( \"Error on binding close: \" + ex , ex ) ; \n} \n} \n} \n} \n"}
{"2432": "public class RecordWriterManager { \nString getDirPath ( Date date , Record record ) throws StageException { \nif ( dirPathTemplateInHeader ) return record . getHeader ( ) . getAttribute ( HdfsTarget . TARGET_DIRECTORY_HEADER ) ; \nreturn pathResolver . resolvePath ( date , record ) ; \n} \n} \n"}
{"2439": "public class StageLibraryDelegateCreator { \npublic < R > R createAndInitialize ( StageLibraryTask stageLib , Configuration configuration , String stageLibraryName , Class < R > exportedInterface ) { \nStageLibraryDelegate instance = create ( stageLib , stageLibraryName , exportedInterface ) ; \nif ( instance == null ) return null ; \nStageLibraryDelegateContext context = new StageLibraryDelegateContext ( configuration ) ; \ninstance . setContext ( context ) ; \nreturn ( R ) new StageLibraryDelegateRuntime ( instance . getClass ( ) . getClassLoader ( ) , instance ) ; \n} \n} \n"}
{"2440": "public class StageLibraryDelegateCreator { \npublic StageLibraryDelegate create ( StageLibraryTask stageLib , String stageLibraryName , Class exportedInterface ) { \nStageLibraryDelegateDefinitition def = stageLib . getStageLibraryDelegateDefinition ( stageLibraryName , exportedInterface ) ; \nif ( def == null ) return null ; \nreturn createInstance ( def ) ; \n} \n} \n"}
{"2442": "public class MetricRuleEvaluatorHelper { \npublic static Object getMetricValue ( MetricRegistry metrics , String metricId , MetricType metricType , MetricElement metricElement ) throws ObserverException { \nif ( metricElement . isOneOf ( MetricElement . CURRENT_BATCH_AGE , MetricElement . TIME_IN_CURRENT_STAGE ) ) switch ( metricElement ) { \ncase CURRENT_BATCH_AGE : return getTimeFromRunner ( metrics , PipeRunner . METRIC_BATCH_START_TIME ) ; \ncase TIME_IN_CURRENT_STAGE : return getTimeFromRunner ( metrics , PipeRunner . METRIC_STAGE_START_TIME ) ; \ndefault : throw new IllegalStateException ( Utils . format ( \"Unknown metric type '{}'\" , metricType ) ) ; \n} \nMetric metric = getMetric ( metrics , metricId , metricType ) ; \nif ( metric != null ) return getMetricValue ( metricElement , metricType , metric ) ; \nreturn null ; \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nint splitbyte = 0 ; \nwhile ( splitbyte + 1 < rlen ) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\\r' && buf [ splitbyte + 3 ] == '\\n' ) return splitbyte + 4 ; \nif ( buf [ splitbyte ] == '\\n' && buf [ splitbyte + 1 ] == '\\n' ) return splitbyte + 2 ; \nsplitbyte ++ ; \n} \nreturn 0 ; \n} \n} \n"}
{"2444": "public class HTTPSession { \npublic long getBodySize ( ) { \nif ( this . headers . containsKey ( \"content-length\" ) ) return Long . parseLong ( this . headers . get ( \"content-length\" ) ) ; \nelse if ( this . splitbyte < this . rlen ) return this . rlen - this . splitbyte ; \nreturn 0 ; \n} \n} \n"}
{"2446": "public class NanoHTTPD { \npublic static SSLServerSocketFactory makeSSLSocketFactory ( String keyAndTrustStoreClasspathPath , char [ ] passphrase ) throws IOException { \ntry { \nKeyStore keystore = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; \nInputStream keystoreStream = NanoHTTPD . class . getResourceAsStream ( keyAndTrustStoreClasspathPath ) ; \nif ( keystoreStream == null ) throw new IOException ( \"Unable to load keystore from classpath: \" + keyAndTrustStoreClasspathPath ) ; \nkeystore . load ( keystoreStream , passphrase ) ; \nKeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; \nkeyManagerFactory . init ( keystore , passphrase ) ; \nreturn makeSSLSocketFactory ( keystore , keyManagerFactory ) ; \n} \ncatch ( Exception e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"2447": "public class NanoHTTPD { \npublic static String getMimeTypeForFile ( String uri ) { \nint dot = uri . lastIndexOf ( '.' ) ; \nString mime = null ; \nif ( dot >= 0 ) mime = mimeTypes ( ) . get ( uri . substring ( dot + 1 ) . toLowerCase ( ) ) ; \nreturn mime == null ? \"application/octet-stream\" : mime ; \n} \n} \n"}
{"2449": "public class NanoHTTPD { \npublic void stop ( ) { \ntry { \nsafeClose ( this . myServerSocket ) ; \nthis . asyncRunner . closeAll ( ) ; \nif ( this . myThread != null ) this . myThread . join ( ) ; \n} \ncatch ( Exception e ) { \nNanoHTTPD . LOG . log ( Level . SEVERE , \"Could not stop all connections\" , e ) ; \n} \n} \n} \n"}
{"2451": "public class Response { \npublic void send ( OutputStream outputStream ) { \nSimpleDateFormat gmtFrmt = new SimpleDateFormat ( \"E, d MMM yyyy HH:mm:ss 'GMT'\" , Locale . US ) ; \ngmtFrmt . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; \ntry { \nif ( this . status == null ) throw new Error ( \"sendResponse(): Status can't be null.\" ) ; \nPrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( outputStream , new ContentType ( this . mimeType ) . getEncoding ( ) ) ) , false ) ; \npw . append ( \"HTTP/1.1 \" ) . append ( this . status . getDescription ( ) ) . append ( \" \\r\\n\" ) ; \nif ( this . mimeType != null ) printHeader ( pw , \"Content-Type\" , this . mimeType ) ; \nif ( getHeader ( \"date\" ) == null ) printHeader ( pw , \"Date\" , gmtFrmt . format ( new Date ( ) ) ) ; \nfor ( Entry < String , String > entry : this . header . entrySet ( ) ) { \nprintHeader ( pw , entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nfor ( String cookieHeader : this . cookieHeaders ) { \nprintHeader ( pw , \"Set-Cookie\" , cookieHeader ) ; \n} \nif ( getHeader ( \"connection\" ) == null ) printHeader ( pw , \"Connection\" , ( this . keepAlive ? \"keep-alive\" : \"close\" ) ) ; \nif ( getHeader ( \"content-length\" ) != null ) setUseGzip ( false ) ; \nif ( useGzipWhenAccepted ( ) ) { \nprintHeader ( pw , \"Content-Encoding\" , \"gzip\" ) ; \nsetChunkedTransfer ( true ) ; \n} \nlong pending = this . data != null ? this . contentLength : 0 ; \nif ( this . requestMethod != Method . HEAD && this . chunkedTransfer ) printHeader ( pw , \"Transfer-Encoding\" , \"chunked\" ) ; \nelse if ( ! useGzipWhenAccepted ( ) ) pending = sendContentLengthHeaderIfNotAlreadyPresent ( pw , pending ) ; \npw . append ( \"\\r\\n\" ) ; \npw . flush ( ) ; \nsendBodyWithCorrectTransferAndEncoding ( outputStream , pending ) ; \noutputStream . flush ( ) ; \nNanoHTTPD . safeClose ( this . data ) ; \n} \ncatch ( IOException ioe ) { \nNanoHTTPD . LOG . log ( Level . SEVERE , \"Could not send response to the client\" , ioe ) ; \n} \n} \n} \n"}
{"2452": "public class Response { \nprivate void sendBody ( OutputStream outputStream , long pending ) throws IOException { \nlong BUFFER_SIZE = 16 * 1024 ; \nbyte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; \nboolean sendEverything = pending == - 1 ; \nwhile ( pending > 0 || sendEverything ) { \nlong bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; \nint read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; \nif ( read <= 0 ) break ; \ntry { \noutputStream . write ( buff , 0 , read ) ; \n} \ncatch ( Exception e ) { \nif ( this . data != null ) this . data . close ( ) ; \n} \nif ( ! sendEverything ) pending -= read ; \n} \n} \n} \n"}
{"2460": "public class SpringSessionBackedSessionRegistry { \nprotected String name ( Object principal ) { \nif ( principal instanceof UserDetails ) return ( ( UserDetails ) principal ) . getUsername ( ) ; \nif ( principal instanceof Principal ) return ( ( Principal ) principal ) . getName ( ) ; \nreturn principal . toString ( ) ; \n} \n} \n"}
{"2461": "public class AbstractHttpSessionApplicationInitializer { \nprivate void insertSessionRepositoryFilter ( ServletContext servletContext ) { \nString filterName = DEFAULT_FILTER_NAME ; \nDelegatingFilterProxy springSessionRepositoryFilter = new DelegatingFilterProxy ( filterName ) ; \nString contextAttribute = getWebApplicationContextAttribute ( ) ; \nif ( contextAttribute != null ) springSessionRepositoryFilter . setContextAttribute ( contextAttribute ) ; \nregisterFilter ( servletContext , true , filterName , springSessionRepositoryFilter ) ; \n} \n} \n"}
{"2462": "public class SpringSessionBackedSessionInformation { \nprivate static String resolvePrincipal ( Session session ) { \nString principalName = session . getAttribute ( FindByIndexNameSessionRepository . PRINCIPAL_NAME_INDEX_NAME ) ; \nif ( principalName != null ) return principalName ; \nSecurityContext securityContext = session . getAttribute ( SPRING_SECURITY_CONTEXT ) ; \nif ( securityContext != null && securityContext . getAuthentication ( ) != null ) return securityContext . getAuthentication ( ) . getName ( ) ; \nreturn \"\" ; \n} \n} \n"}
{"2463": "public class RedisOperationsSessionRepository { \nprivate RedisSession getSession ( String id , boolean allowExpired ) { \nMap < Object , Object > entries = getSessionBoundHashOperations ( id ) . entries ( ) ; \nif ( entries . isEmpty ( ) ) return null ; \nMapSession loaded = loadSession ( id , entries ) ; \nif ( ! allowExpired && loaded . isExpired ( ) ) return null ; \nRedisSession result = new RedisSession ( loaded ) ; \nresult . originalLastAccessTime = loaded . getLastAccessedTime ( ) ; \nreturn result ; \n} \n} \n"}
{"2465": "public class MethodInfoHelper { \npublic static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { \nClass < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; \nif ( parameterTypes == null ) return NO_STRINGS ; \nString [ ] canonicalNames = new String [ parameterTypes . length ] ; \nfor ( int i = 0 ; \ni < parameterTypes . length ; \ni ++ ) canonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; \nreturn canonicalNames ; \n} \n} \n"}
{"2466": "public class JCAOrderedLastSynchronizationList { \npublic void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { \nint status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; \nswitch ( status ) { \ncase javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; \ncase Status . STATUS_MARKED_ROLLBACK : return ; \ndefault : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; \n} \nif ( synchronization . getClass ( ) . getName ( ) . startsWith ( \"org.jboss.jca\" ) ) { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \njcaSyncs . add ( synchronization ) ; \n} \nelse { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \npreJcaSyncs . add ( synchronization ) ; \n} \n} \n} \n"}
{"2467": "public class JCAOrderedLastSynchronizationList { \n@ Override public void beforeCompletion ( ) { \nint lastIndexProcessed = 0 ; \nwhile ( ( lastIndexProcessed < preJcaSyncs . size ( ) ) ) { \nSynchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: \" + preJcaSync . getClass ( ) + \" HashCode: \" + preJcaSync . hashCode ( ) + \" toString: \" + preJcaSync ) ; \npreJcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \nlastIndexProcessed = 0 ; \nwhile ( ( lastIndexProcessed < jcaSyncs . size ( ) ) ) { \nSynchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: \" + jcaSync . getClass ( ) + \" HashCode: \" + jcaSync . hashCode ( ) + \" toString: \" + jcaSync ) ; \njcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \n} \n} \n"}
{"2468": "public class TxServerInterceptor { \npublic static Transaction getCurrentTransaction ( ) { \nTransaction tx = null ; \nif ( piCurrent != null ) try { \nAny any = piCurrent . get_slot ( slotId ) ; \nif ( any . type ( ) . kind ( ) . value ( ) != TCKind . _tk_null ) tx = ForeignTransaction . INSTANCE ; \n} \ncatch ( InvalidSlot e ) { \nthrow IIOPLogger . ROOT_LOGGER . errorGettingSlotInTxInterceptor ( e ) ; \n} \nreturn tx ; \n} \n} \n"}
{"2471": "public class WSSubsystemAdd { \nprivate static List < ServiceName > getServerConfigDependencies ( OperationContext context , boolean appclient ) { \nfinal List < ServiceName > serviceNames = new ArrayList < ServiceName > ( ) ; \nfinal Resource subsystemResource = context . readResourceFromRoot ( PathAddress . pathAddress ( WSExtension . SUBSYSTEM_PATH ) , false ) ; \nreadConfigServiceNames ( serviceNames , subsystemResource , Constants . CLIENT_CONFIG ) ; \nreadConfigServiceNames ( serviceNames , subsystemResource , Constants . ENDPOINT_CONFIG ) ; \nif ( ! appclient ) serviceNames . add ( CommonWebServer . SERVICE_NAME ) ; \nreturn serviceNames ; \n} \n} \n"}
{"2475": "public class CalendarTimer { \npublic void handleRestorationCalculation ( ) { \nif ( nextExpiration == null ) return ; \nif ( nextExpiration . getTime ( ) >= System . currentTimeMillis ( ) ) return ; \nnextExpiration = new Date ( System . currentTimeMillis ( ) - 1 ) ; \n} \n} \n"}
{"2476": "public class HibernateSearchProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nif ( JPADeploymentMarker . isJPADeployment ( deploymentUnit ) ) addSearchDependency ( moduleSpecification , moduleLoader , deploymentUnit ) ; \n} \n} \n"}
{"2477": "public class WeldDeployment { \nprivate void makeTopLevelBdasVisibleFromStaticModules ( ) { \nfor ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { \nif ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL ) || bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ) ) for ( BeanDeploymentArchiveImpl topLevelBda : rootBeanDeploymentModule . getBeanDeploymentArchives ( ) ) { \nbda . addBeanDeploymentArchive ( topLevelBda ) ; \n} \n} \n} \n} \n"}
{"2478": "public class AbstractMetaDataBuilderPOJO { \nJSEArchiveMetaData create ( final Deployment dep ) { \nif ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) WSLogger . ROOT_LOGGER . tracef ( \"Creating JBoss agnostic meta data for POJO webservice deployment: %s\" , dep . getSimpleName ( ) ) ; \nfinal JBossWebMetaData jbossWebMD = WSHelper . getRequiredAttachment ( dep , JBossWebMetaData . class ) ; \nfinal DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; \nfinal List < POJOEndpoint > pojoEndpoints = getPojoEndpoints ( unit ) ; \nfinal JSEArchiveMetaData . Builder builder = new JSEArchiveMetaData . Builder ( ) ; \nfinal String contextRoot = getContextRoot ( dep , jbossWebMD ) ; \nbuilder . setContextRoot ( contextRoot ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting context root: %s\" , contextRoot ) ; \nfinal Map < String , String > servletMappings = getServletUrlPatternsMappings ( jbossWebMD , pojoEndpoints ) ; \nbuilder . setServletMappings ( servletMappings ) ; \nfinal Map < String , String > servletClassNamesMappings = getServletClassMappings ( jbossWebMD , pojoEndpoints ) ; \nbuilder . setServletClassNames ( servletClassNamesMappings ) ; \nfinal String securityDomain = jbossWebMD . getSecurityDomain ( ) ; \nbuilder . setSecurityDomain ( securityDomain ) ; \nfinal JBossWebservicesMetaData jbossWebservicesMD = WSHelper . getOptionalAttachment ( dep , JBossWebservicesMetaData . class ) ; \nif ( jbossWebservicesMD != null ) { \nfinal PublishLocationAdapter resolver = new PublishLocationAdapterImpl ( jbossWebservicesMD . getWebserviceDescriptions ( ) ) ; \nbuilder . setPublishLocationAdapter ( resolver ) ; \n} \nfinal List < JSESecurityMetaData > jseSecurityMDs = getSecurityMetaData ( jbossWebMD . getSecurityConstraints ( ) ) ; \nbuilder . setSecurityMetaData ( jseSecurityMDs ) ; \nsetConfigNameAndFile ( builder , jbossWebMD , jbossWebservicesMD ) ; \nreturn builder . build ( ) ; \n} \n} \n"}
{"2479": "public class AbstractMetaDataBuilderPOJO { \nprivate void setConfigNameAndFile ( final JSEArchiveMetaData . Builder builder , final JBossWebMetaData jbossWebMD , final JBossWebservicesMetaData jbossWebservicesMD ) { \nif ( jbossWebservicesMD != null ) if ( jbossWebservicesMD . getConfigName ( ) != null ) { \nfinal String configName = jbossWebservicesMD . getConfigName ( ) ; \nbuilder . setConfigName ( configName ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config name: %s\" , configName ) ; \nfinal String configFile = jbossWebservicesMD . getConfigFile ( ) ; \nbuilder . setConfigFile ( configFile ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config file: %s\" , configFile ) ; \nreturn ; \n} \nfinal List < ParamValueMetaData > contextParams = jbossWebMD . getContextParams ( ) ; \nif ( contextParams != null ) for ( final ParamValueMetaData contextParam : contextParams ) { \nif ( WSConstants . JBOSSWS_CONFIG_NAME . equals ( contextParam . getParamName ( ) ) ) { \nfinal String configName = contextParam . getParamValue ( ) ; \nbuilder . setConfigName ( configName ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config name: %s\" , configName ) ; \n} \nif ( WSConstants . JBOSSWS_CONFIG_FILE . equals ( contextParam . getParamName ( ) ) ) { \nfinal String configFile = contextParam . getParamValue ( ) ; \nbuilder . setConfigFile ( configFile ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config file: %s\" , configFile ) ; \n} \n} \n} \n} \n"}
{"2480": "public class AbstractMetaDataBuilderPOJO { \nprivate List < JSESecurityMetaData > getSecurityMetaData ( final List < SecurityConstraintMetaData > securityConstraintsMD ) { \nfinal List < JSESecurityMetaData > jseSecurityMDs = new LinkedList < JSESecurityMetaData > ( ) ; \nif ( securityConstraintsMD != null ) for ( final SecurityConstraintMetaData securityConstraintMD : securityConstraintsMD ) { \nfinal JSESecurityMetaData . Builder jseSecurityMDBuilder = new JSESecurityMetaData . Builder ( ) ; \njseSecurityMDBuilder . setTransportGuarantee ( securityConstraintMD . getTransportGuarantee ( ) . name ( ) ) ; \nfor ( final WebResourceCollectionMetaData webResourceMD : securityConstraintMD . getResourceCollections ( ) ) { \njseSecurityMDBuilder . addWebResource ( webResourceMD . getName ( ) , webResourceMD . getUrlPatterns ( ) ) ; \n} \njseSecurityMDs . add ( jseSecurityMDBuilder . build ( ) ) ; \n} \nreturn jseSecurityMDs ; \n} \n} \n"}
{"2483": "public class EjbInjectionSource { \nprivate void resolve ( ) { \nif ( ! resolved ) synchronized ( this ) { \nif ( ! resolved ) { \nfinal Set < ViewDescription > views = getViews ( ) ; \nfinal Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( view instanceof EJBViewDescription ) { \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) continue ; \nejbsForViewName . add ( ( EJBViewDescription ) view ) ; \n} \n} \nif ( ejbsForViewName . isEmpty ( ) ) if ( beanName == null ) error = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; \nelse error = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; \nelse if ( ejbsForViewName . size ( ) > 1 ) if ( beanName == null ) error = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; \nelse error = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; \nelse { \nfinal EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; \nfinal EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; \nif ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nfinal ServiceName serviceName = description . getServiceName ( ) ; \nresolvedViewName = serviceName ; \n} \nresolved = true ; \n} \n} \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) throw duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) throw missingRequiredElement ( reader , required ) ; \n} \n} \n"}
{"2486": "public class TransactionSubsystem10Parser { \nstatic void parseProcessIdEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { \nif ( reader . getAttributeCount ( ) > 0 ) throw unexpectedAttribute ( reader , 0 ) ; \nboolean encountered = false ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nswitch ( element ) { \ncase UUID : if ( encountered ) throw unexpectedElement ( reader ) ; \nencountered = true ; \nif ( reader . getAttributeCount ( ) > 0 ) throw unexpectedAttribute ( reader , 0 ) ; \ncoreEnvironmentAdd . get ( TransactionSubsystemRootResourceDefinition . PROCESS_ID_UUID . getName ( ) ) . set ( true ) ; \nrequireNoContent ( reader ) ; \nbreak ; \ncase SOCKET : { \nif ( encountered ) throw unexpectedElement ( reader ) ; \nencountered = true ; \nparseSocketProcessIdElement ( reader , coreEnvironmentAdd ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! encountered ) throw missingOneOf ( reader , EnumSet . of ( Element . UUID , Element . SOCKET ) ) ; \n} \n} \n"}
{"2499": "public class InitialContext { \npublic static synchronized void removeUrlContextFactory ( final String scheme , ObjectFactory factory ) { \nMap < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; \nObjectFactory f = factories . get ( scheme ) ; \nif ( f == factory ) { \nfactories . remove ( scheme ) ; \nurlContextFactories = Collections . unmodifiableMap ( factories ) ; \nreturn ; \n} \nelse throw new IllegalArgumentException ( ) ; \n} \n} \n"}
{"2500": "public class WildFlyProviderResolver { \nprivate List < ValidationProvider < ? > > loadProviders ( ClassLoader classLoader ) { \n@ SuppressWarnings ( \"rawtypes\" ) Iterator < ValidationProvider > providerIterator = ServiceLoader . load ( ValidationProvider . class , classLoader ) . iterator ( ) ; \nLinkedList < ValidationProvider < ? > > providers = new LinkedList < ValidationProvider < ? > > ( ) ; \nwhile ( providerIterator . hasNext ( ) ) try { \nValidationProvider < ? > provider = providerIterator . next ( ) ; \nif ( provider . getClass ( ) . getName ( ) . equals ( \"org.hibernate.validator.HibernateValidator\" ) ) providers . addFirst ( provider ) ; \nelse providers . add ( provider ) ; \n} \ncatch ( ServiceConfigurationError e ) { \n} \nreturn providers ; \n} \n} \n"}
{"2502": "public class WebMetaDataModifier { \nprivate void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String transportClassName = this . getTransportClassName ( dep ) ; \nWSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; \nfinal Set < String > epNames = new HashSet < String > ( ) ; \nfor ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { \nepNames . add ( ep . getTargetBeanName ( ) ) ; \n} \nfor ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { \nfinal String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; \nif ( endpointClassName != null && endpointClassName . length ( ) > 0 ) if ( epNames . contains ( endpointClassName ) ) { \nservletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; \nfinal List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; \nWebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; \nWebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; \n} \nelse if ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) throw WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; \n} \n} \n} \n"}
{"2503": "public class WebMetaDataModifier { \nprivate void modifyContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String contextRoot = dep . getService ( ) . getContextRoot ( ) ; \nif ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) WSLogger . ROOT_LOGGER . tracef ( \"Setting context root: %s for deployment: %s\" , contextRoot , dep . getSimpleName ( ) ) ; \njbossWebMD . setContextRoot ( contextRoot ) ; \n} \n} \n"}
{"2505": "public class SecurityActions { \nstatic RunAs setRunAsIdentity ( final RunAs principal , final SecurityContext sc ) { \nif ( WildFlySecurityManager . isChecking ( ) ) return WildFlySecurityManager . doUnchecked ( new PrivilegedAction < RunAs > ( ) { \n@ Override public RunAs run ( ) { \nif ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \nRunAs old = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( principal ) ; \nreturn old ; \n} \n} \n) ; \nelse { \nif ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \nRunAs old = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( principal ) ; \nreturn old ; \n} \n} \n} \n"}
{"2506": "public class SecurityActions { \nstatic RunAs popRunAsIdentity ( final SecurityContext sc ) { \nif ( WildFlySecurityManager . isChecking ( ) ) return AccessController . doPrivileged ( new PrivilegedAction < RunAs > ( ) { \n@ Override public RunAs run ( ) { \nif ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \nRunAs principal = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( null ) ; \nreturn principal ; \n} \n} \n) ; \nelse { \nif ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; \nRunAs principal = sc . getOutgoingRunAs ( ) ; \nsc . setOutgoingRunAs ( null ) ; \nreturn principal ; \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) if ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \nif ( hits != null ) if ( hits . size ( ) == 1 ) return hits . get ( 0 ) ; \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) for ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \nreturn hits . get ( 0 ) ; \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \ni < fields . length ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) if ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \nif ( hits != null ) if ( hits . size ( ) == 1 ) return hits . get ( 0 ) ; \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) for ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \nreturn hits . get ( 0 ) ; \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2513": "public class AuditNotificationReceiver { \nprivate static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; \nsb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; \nEnumeration < ? > en = httpRequest . getHeaderNames ( ) ; \nwhile ( en . hasMoreElements ( ) ) { \nString headerName = ( String ) en . nextElement ( ) ; \nsb . append ( headerName ) . append ( \"=\" ) ; \nif ( ! headerName . contains ( \"authorization\" ) ) sb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nsb . append ( \"[parameters=\" ) ; \nEnumeration < ? > enparam = httpRequest . getParameterNames ( ) ; \nwhile ( enparam . hasMoreElements ( ) ) { \nString paramName = ( String ) enparam . nextElement ( ) ; \nString [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; \nint len = paramValues != null ? paramValues . length : 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) sb . append ( paramValues [ i ] ) . append ( \"::\" ) ; \nsb . append ( \",\" ) ; \n} \nsb . append ( \"][attributes=\" ) ; \nEnumeration < ? > enu = httpRequest . getAttributeNames ( ) ; \nwhile ( enu . hasMoreElements ( ) ) { \nString attrName = ( String ) enu . nextElement ( ) ; \nsb . append ( attrName ) . append ( \"=\" ) ; \nsb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2519": "public class StubStrategy { \npublic void writeParams ( OutputStream out , Object [ ] params ) { \nint len = params . length ; \nif ( len != paramWriters . length ) throw IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject param = params [ i ] ; \nif ( param instanceof PortableRemoteObject ) try { \nparam = PortableRemoteObject . toStub ( ( Remote ) param ) ; \n} \ncatch ( NoSuchObjectException e ) { \nthrow new RuntimeException ( e ) ; \n} \nparamWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; \n} \n} \n} \n"}
{"2520": "public class StubStrategy { \npublic Exception readException ( String id , InputStream in ) { \nExceptionReader exceptionReader = ( ExceptionReader ) exceptionMap . get ( id ) ; \nif ( exceptionReader == null ) return new UnexpectedException ( id ) ; \nelse return exceptionReader . read ( in ) ; \n} \n} \n"}
{"2524": "public class JSFDependencyProcessor { \nprivate void addCDIFlag ( WarMetaData warMetaData , DeploymentUnit deploymentUnit ) { \nJBossWebMetaData webMetaData = warMetaData . getMergedJBossWebMetaData ( ) ; \nif ( webMetaData == null ) { \nwebMetaData = new JBossWebMetaData ( ) ; \nwarMetaData . setMergedJBossWebMetaData ( webMetaData ) ; \n} \nList < ParamValueMetaData > contextParams = webMetaData . getContextParams ( ) ; \nif ( contextParams == null ) contextParams = new ArrayList < ParamValueMetaData > ( ) ; \nboolean isCDI = false ; \nfinal CapabilityServiceSupport support = deploymentUnit . getAttachment ( Attachments . CAPABILITY_SERVICE_SUPPORT ) ; \nif ( support . hasCapability ( WELD_CAPABILITY_NAME ) ) isCDI = support . getOptionalCapabilityRuntimeAPI ( WELD_CAPABILITY_NAME , WeldCapability . class ) . get ( ) . isPartOfWeldDeployment ( deploymentUnit ) ; \nParamValueMetaData param = new ParamValueMetaData ( ) ; \nparam . setParamName ( IS_CDI_PARAM ) ; \nparam . setParamValue ( Boolean . toString ( isCDI ) ) ; \ncontextParams . add ( param ) ; \nwebMetaData . setContextParams ( contextParams ) ; \n} \n} \n"}
{"2525": "public class AbstractInvocationHandler { \nprotected ComponentView getComponentView ( ) { \nComponentView cv = componentView ; \nif ( cv == null ) synchronized ( this ) { \ncv = componentView ; \nif ( cv == null ) { \ncv = getMSCService ( componentViewName , ComponentView . class ) ; \nif ( cv == null ) throw WSLogger . ROOT_LOGGER . cannotFindComponentView ( componentViewName ) ; \nif ( reference == null ) try { \nreference = cv . createInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \ncomponentView = cv ; \n} \n} \nreturn cv ; \n} \n} \n"}
{"2526": "public class AbstractInvocationHandler { \npublic void invoke ( final Endpoint endpoint , final Invocation wsInvocation ) throws Exception { \ntry { \nif ( ! EndpointState . STARTED . equals ( endpoint . getState ( ) ) ) throw WSLogger . ROOT_LOGGER . endpointAlreadyStopped ( endpoint . getShortName ( ) ) ; \nSecurityDomainContext securityDomainContext = endpoint . getSecurityDomainContext ( ) ; \nsecurityDomainContext . runAs ( ( Callable < Void > ) ( ) -> { \ninvokeInternal ( endpoint , wsInvocation ) ; \nreturn null ; \n} \n) ; \n} \ncatch ( Throwable t ) { \nhandleInvocationException ( t ) ; \n} \nfinally { \nonAfterInvocation ( wsInvocation ) ; \n} \n} \n} \n"}
{"2527": "public class AbstractInvocationHandler { \nprotected Method getComponentViewMethod ( final Method seiMethod , final Collection < Method > viewMethods ) { \nfor ( final Method viewMethod : viewMethods ) { \nif ( matches ( seiMethod , viewMethod ) ) return viewMethod ; \n} \nthrow new IllegalStateException ( ) ; \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) return false ; \nfor ( int i = 0 ; \ni < sourceParams . length ; \ni ++ ) if ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; \nreturn true ; \n} \n} \n"}
{"2529": "public class JPAService { \npublic static Resource createManagementStatisticsResource ( final ManagementAdaptor managementAdaptor , final String scopedPersistenceUnitName , final DeploymentUnit deploymentUnit ) { \nsynchronized ( existingResourceDescriptionResolver ) { \nfinal EntityManagerFactoryLookup entityManagerFactoryLookup = new EntityManagerFactoryLookup ( ) ; \nfinal Statistics statistics = managementAdaptor . getStatistics ( ) ; \nif ( false == existingResourceDescriptionResolver . contains ( managementAdaptor . getVersion ( ) ) ) { \nResourceDescriptionResolver resourceDescriptionResolver = new StandardResourceDescriptionResolver ( statistics . getResourceBundleKeyPrefix ( ) , statistics . getResourceBundleName ( ) , statistics . getClass ( ) . getClassLoader ( ) ) { \nprivate ResourceDescriptionResolver fallback = JPAExtension . getResourceDescriptionResolver ( ) ; \n@ Override public String getResourceAttributeDescription ( String attributeName , Locale locale , ResourceBundle bundle ) { \nif ( bundle . containsKey ( getBundleKey ( attributeName ) ) ) return super . getResourceAttributeDescription ( attributeName , locale , bundle ) ; \nelse return fallback . getResourceAttributeDescription ( attributeName , locale , fallback . getResourceBundle ( locale ) ) ; \n} \n} \n; \nPathElement subsystemPE = PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM , JPAExtension . SUBSYSTEM_NAME ) ; \nManagementResourceRegistration deploymentResourceRegistration = deploymentUnit . getAttachment ( DeploymentModelUtils . MUTABLE_REGISTRATION_ATTACHMENT ) ; \nManagementResourceRegistration deploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( subsystemPE ) ) ; \nManagementResourceRegistration subdeploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBDEPLOYMENT ) , subsystemPE ) ) ; \nManagementResourceRegistration providerResource = deploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; \nproviderResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; \nproviderResource = subdeploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; \nproviderResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; \nexistingResourceDescriptionResolver . add ( managementAdaptor . getVersion ( ) ) ; \n} \nreturn new DynamicManagementStatisticsResource ( statistics , scopedPersistenceUnitName , managementAdaptor . getIdentificationLabel ( ) , entityManagerFactoryLookup ) ; \n} \n} \n} \n"}
{"2531": "public class AbstractSecurityMetaDataAccessorEJB { \nprivate String getDomain ( final String oldSecurityDomain , final String nextSecurityDomain ) { \nif ( nextSecurityDomain == null ) return oldSecurityDomain ; \nif ( oldSecurityDomain == null ) return nextSecurityDomain ; \nensureSameDomains ( oldSecurityDomain , nextSecurityDomain ) ; \nreturn oldSecurityDomain ; \n} \n} \n"}
{"2533": "public class AttributeAnalysis { \nvoid setIDLName ( String idlName ) { \nsuper . setIDLName ( idlName ) ; \nif ( idlName . charAt ( 0 ) >= 0x41 && idlName . charAt ( 0 ) <= 0x5a && ( idlName . length ( ) <= 1 || idlName . charAt ( 1 ) < 0x41 || idlName . charAt ( 1 ) > 0x5a ) ) idlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; \nif ( accessorAnalysis != null ) accessorAnalysis . setIDLName ( \"_get_\" + idlName ) ; \nif ( mutatorAnalysis != null ) mutatorAnalysis . setIDLName ( \"_set_\" + idlName ) ; \n} \n} \n"}
{"2534": "public class JndiName { \npublic String getAbsoluteName ( ) { \nfinal StringBuilder absolute = new StringBuilder ( ) ; \nif ( parent != null ) absolute . append ( parent ) . append ( ENTRY_SEPARATOR ) ; \nabsolute . append ( local ) ; \nreturn absolute . toString ( ) ; \n} \n} \n"}
{"2536": "public class IronJacamarDeploymentParsingProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ResourceRoot resourceRoot = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; \nfinal VirtualFile deploymentRoot = resourceRoot . getRoot ( ) ; \nfinal boolean resolveProperties = Util . shouldResolveJBoss ( deploymentUnit ) ; \nIronJacamarXmlDescriptor xmlDescriptor = process ( deploymentRoot , resolveProperties ) ; \nif ( xmlDescriptor != null ) deploymentUnit . putAttachment ( IronJacamarXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \n} \n} \n"}
{"2549": "public class AbstractActiveMQComponentControlHandler { \nprotected final T getActiveMQComponentControl ( final OperationContext context , final ModelNode operation , final boolean forWrite ) throws OperationFailedException { \nfinal ServiceName artemisServiceName = MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP_ADDR ) ) ) ; \nServiceController < ? > artemisService = context . getServiceRegistry ( forWrite ) . getService ( artemisServiceName ) ; \nActiveMQServer server = ActiveMQServer . class . cast ( artemisService . getValue ( ) ) ; \nPathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; \nT control = getActiveMQComponentControl ( server , address ) ; \nif ( control == null ) throw ControllerLogger . ROOT_LOGGER . managementResourceNotFound ( address ) ; \nreturn control ; \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nint attributeSize = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeSize ; \ni ++ ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \n} \nif ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) if ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) if ( jndiName . contains ( \"/\" ) ) poolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \nelse poolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \nelse throw ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \nreturn poolName ; \n} \n} \n"}
{"2552": "public class JaxrsSpringProcessor { \nprotected synchronized VirtualFile getResteasySpringVirtualFile ( ) throws DeploymentUnitProcessingException { \nif ( resourceRoot != null ) return resourceRoot ; \ntry { \nModule module = Module . getBootModuleLoader ( ) . loadModule ( MODULE ) ; \nURL fileUrl = module . getClassLoader ( ) . getResource ( JAR_LOCATION ) ; \nif ( fileUrl == null ) throw JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; \nFile dir = new File ( fileUrl . toURI ( ) ) ; \nFile file = null ; \nfor ( String jar : dir . list ( ) ) { \nif ( jar . endsWith ( \".jar\" ) ) { \nfile = new File ( dir , jar ) ; \nbreak ; \n} \n} \nif ( file == null ) throw JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; \nVirtualFile vf = VFS . getChild ( file . toURI ( ) ) ; \nfinal Closeable mountHandle = VFS . mountZip ( file , vf , TempFileProviderService . provider ( ) ) ; \nService < Closeable > mountHandleService = new Service < Closeable > ( ) { \npublic void start ( StartContext startContext ) throws StartException { \n} \npublic void stop ( StopContext stopContext ) { \nVFSUtils . safeClose ( mountHandle ) ; \n} \npublic Closeable getValue ( ) throws IllegalStateException , IllegalArgumentException { \nreturn mountHandle ; \n} \n} \n; \nServiceBuilder < Closeable > builder = serviceTarget . addService ( ServiceName . JBOSS . append ( SERVICE_NAME ) , mountHandleService ) ; \nbuilder . setInitialMode ( ServiceController . Mode . ACTIVE ) . install ( ) ; \nresourceRoot = vf ; \nreturn resourceRoot ; \n} \ncatch ( Exception e ) { \nthrow new DeploymentUnitProcessingException ( e ) ; \n} \n} \n} \n"}
{"2556": "public class ShutDownInterceptorFactory { \npublic void shutdown ( ) { \nint value ; \nint oldValue ; \ndo { \noldValue = invocationCount ; \nvalue = SHUTDOWN_FLAG | oldValue ; \nif ( oldValue == value ) return ; \n} \nwhile ( ! updater . compareAndSet ( this , oldValue , value ) ) ; \nsynchronized ( lock ) { \nvalue = invocationCount ; \nwhile ( value != SHUTDOWN_FLAG ) { \ntry { \nlock . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \nvalue = invocationCount ; \nif ( ( value & SHUTDOWN_FLAG ) == 0 ) return ; \n} \n} \n} \n} \n"}
{"2573": "public class JPAInterceptorProcessor { \nprivate void registerSessionBeanInterceptors ( SessionBeanComponentDescription componentDescription , final DeploymentUnit deploymentUnit ) { \nif ( componentDescription . isStateful ( ) ) componentDescription . getConfigurators ( ) . addFirst ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addPostConstructInterceptor ( SFSBPreCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_PRE_CREATE ) ; \nconfiguration . addPostConstructInterceptor ( SFSBCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_CREATE ) ; \nconfiguration . addPreDestroyInterceptor ( SFSBDestroyInterceptor . FACTORY , InterceptorOrder . ComponentPreDestroy . JPA_SFSB_DESTROY ) ; \nconfiguration . addComponentInterceptor ( SFSBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SFSB_INTERCEPTOR , false ) ; \nconfiguration . getInterceptorContextKeys ( ) . add ( SFSBInvocationInterceptor . CONTEXT_KEY ) ; \n} \n} \n) ; \nif ( ( componentDescription . isStateful ( ) || componentDescription . isStateless ( ) ) ) componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addComponentInterceptor ( SBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SESSION_BEAN_INTERCEPTOR , false ) ; \n} \n} \n) ; \n} \n} \n"}
{"2574": "public class AbstractDeploymentDescriptorBindingsProcessor { \nprotected Class < ? > processInjectionTargets ( final ResourceInjectionTarget resourceInjectionTarget , InjectionSource injectionSource , ClassLoader classLoader , DeploymentReflectionIndex deploymentReflectionIndex , ResourceInjectionMetaData entry , Class < ? > classType ) throws DeploymentUnitProcessingException { \nif ( entry . getInjectionTargets ( ) != null ) for ( ResourceInjectionTargetMetaData injectionTarget : entry . getInjectionTargets ( ) ) { \nfinal String injectionTargetClassName = injectionTarget . getInjectionTargetClass ( ) ; \nfinal String injectionTargetName = injectionTarget . getInjectionTargetName ( ) ; \nfinal AccessibleObject fieldOrMethod = getInjectionTarget ( injectionTargetClassName , injectionTargetName , classLoader , deploymentReflectionIndex ) ; \nfinal Class < ? > injectionTargetType = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getType ( ) : ( ( Method ) fieldOrMethod ) . getParameterTypes ( ) [ 0 ] ; \nfinal String memberName = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getName ( ) : ( ( Method ) fieldOrMethod ) . getName ( ) ; \nif ( classType != null ) if ( ! injectionTargetType . isAssignableFrom ( classType ) ) { \nboolean ok = false ; \nif ( classType . isPrimitive ( ) ) if ( BOXED_TYPES . get ( classType ) . equals ( injectionTargetType ) ) ok = true ; \nelse if ( injectionTargetType . isPrimitive ( ) ) if ( BOXED_TYPES . get ( injectionTargetType ) . equals ( classType ) ) ok = true ; \nif ( ! ok ) throw EeLogger . ROOT_LOGGER . invalidInjectionTarget ( injectionTarget . getInjectionTargetName ( ) , injectionTarget . getInjectionTargetClass ( ) , classType ) ; \nclassType = injectionTargetType ; \n} \nelse classType = injectionTargetType ; \nfinal InjectionTarget injectionTargetDescription = fieldOrMethod instanceof Field ? new FieldInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) : new MethodInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) ; \nfinal ResourceInjectionConfiguration injectionConfiguration = new ResourceInjectionConfiguration ( injectionTargetDescription , injectionSource ) ; \nresourceInjectionTarget . addResourceInjection ( injectionConfiguration ) ; \n} \nreturn classType ; \n} \n} \n"}
{"2575": "public class WeldStartService { \n@ Override public void stop ( final StopContext context ) { \nfinal WeldBootstrapService bootstrapService = bootstrapSupplier . get ( ) ; \nif ( ! bootstrapService . isStarted ( ) ) throw WeldLogger . ROOT_LOGGER . notStarted ( \"WeldContainer\" ) ; \nWeldLogger . DEPLOYMENT_LOGGER . stoppingWeldService ( bootstrapService . getDeploymentName ( ) ) ; \nClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \ntry { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; \nWeldProvider . containerShutDown ( Container . instance ( bootstrapService . getDeploymentName ( ) ) ) ; \nbootstrapService . getBootstrap ( ) . shutdown ( ) ; \n} \nfinally { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; \nModuleGroupSingletonProvider . removeClassLoader ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; \n} \nbootstrapService . setStarted ( false ) ; \n} \n} \n"}
{"2579": "public class JMSConnectionFactoryDefinitionInjectionSource { \nstatic boolean targetsPooledConnectionFactory ( String server , String resourceAdapter , ServiceRegistry serviceRegistry ) { \nif ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) return true ; \nServiceName activeMQServiceName = MessagingServices . getActiveMQServiceName ( server ) ; \nServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( activeMQServiceName ) . append ( resourceAdapter ) ; \nreturn serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; \n} \n} \n"}
{"2580": "public class JMSConnectionFactoryDefinitionInjectionSource { \nstatic boolean targetsExternalPooledConnectionFactory ( String resourceAdapter , ServiceRegistry serviceRegistry ) { \nif ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) return false ; \nServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( MessagingServices . getActiveMQServiceName ( \"\" ) ) . append ( resourceAdapter ) ; \nreturn serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; \n} \n} \n"}
{"2582": "public class PersistenceUnitSearch { \nprivate static String defaultPersistenceUnitName ( String persistenceUnitName , PersistenceUnitMetadataHolder holder ) { \nif ( ( persistenceUnitName == null || persistenceUnitName . length ( ) == 0 ) ) for ( PersistenceUnitMetadata persistenceUnit : holder . getPersistenceUnits ( ) ) { \nString defaultPU = persistenceUnit . getProperties ( ) . getProperty ( Configuration . JPA_DEFAULT_PERSISTENCE_UNIT ) ; \nif ( Boolean . TRUE . toString ( ) . equals ( defaultPU ) ) persistenceUnitName = persistenceUnit . getPersistenceUnitName ( ) ; \n} \nreturn persistenceUnitName ; \n} \n} \n"}
{"2585": "public class EJBSuspendHandlerService { \n@ Override public void suspended ( ServerActivityCallback listener ) { \nthis . suspended = true ; \nlistenerUpdater . set ( this , listener ) ; \nlocalTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; \nfinal int activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; \nif ( activeInvocationCount == 0 ) if ( gracefulTxnShutdown ) if ( activeTransactionCountUpdater . get ( this ) == 0 ) this . doneSuspended ( ) ; \nelse EjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; \nelse this . doneSuspended ( ) ; \n} \n} \n"}
{"2586": "public class EJBSuspendHandlerService { \n@ Override public void resume ( ) { \nthis . suspended = false ; \nlocalTransactionContextInjectedValue . getValue ( ) . resumeRequests ( ) ; \nServerActivityCallback listener = listenerUpdater . get ( this ) ; \nif ( listener != null ) listenerUpdater . compareAndSet ( this , listener , null ) ; \ndeploymentRepositoryInjectedValue . getValue ( ) . resume ( ) ; \n} \n} \n"}
{"2587": "public class EJBSuspendHandlerService { \npublic void invocationComplete ( ) { \nint activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; \nif ( suspended && activeInvocations == 0 && ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) ) doneSuspended ( ) ; \n} \n} \n"}
{"2591": "public class MessagingServices { \npublic static ServiceName getCapabilityServiceName ( String capabilityBaseName , String ... dynamicParts ) { \nif ( capabilityServiceSupport == null ) throw new IllegalStateException ( ) ; \nif ( dynamicParts == null || dynamicParts . length == 0 ) return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; \nreturn capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName , dynamicParts ) ; \n} \n} \n"}
{"2592": "public class WarStructureDeploymentProcessor { \nprivate List < ResourceRoot > createResourceRoots ( final VirtualFile deploymentRoot , final DeploymentUnit deploymentUnit ) throws IOException , DeploymentUnitProcessingException { \nfinal List < ResourceRoot > entries = new ArrayList < ResourceRoot > ( ) ; \nfinal VirtualFile webinfClasses = deploymentRoot . getChild ( WEB_INF_CLASSES ) ; \nif ( webinfClasses . exists ( ) ) { \nfinal ResourceRoot webInfClassesRoot = new ResourceRoot ( webinfClasses . getName ( ) , webinfClasses , null ) ; \nModuleRootMarker . mark ( webInfClassesRoot ) ; \nentries . add ( webInfClassesRoot ) ; \n} \nMap < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_OVERLAY_LOCATIONS ) ; \nfinal VirtualFile webinfLib = deploymentRoot . getChild ( WEB_INF_LIB ) ; \nif ( webinfLib . exists ( ) ) { \nfinal List < VirtualFile > archives = webinfLib . getChildren ( DEFAULT_WEB_INF_LIB_FILTER ) ; \nfor ( final VirtualFile archive : archives ) { \ntry { \nString relativeName = archive . getPathNameRelativeTo ( deploymentRoot ) ; \nMountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; \nCloseable closable = null ; \nif ( overlay != null ) overlay . remountAsZip ( false ) ; \nelse if ( archive . isFile ( ) ) closable = VFS . mountZip ( archive , archive , TempFileProviderService . provider ( ) ) ; \nelse closable = null ; \nfinal ResourceRoot webInfArchiveRoot = new ResourceRoot ( archive . getName ( ) , archive , new MountHandle ( closable ) ) ; \nModuleRootMarker . mark ( webInfArchiveRoot ) ; \nentries . add ( webInfArchiveRoot ) ; \n} \ncatch ( IOException e ) { \nthrow new DeploymentUnitProcessingException ( UndertowLogger . ROOT_LOGGER . failToProcessWebInfLib ( archive ) , e ) ; \n} \n} \n} \nreturn entries ; \n} \n} \n"}
{"2593": "public class PersistenceProviderHandler { \nprivate static Set < ClassLoader > allDeploymentModuleClassLoaders ( DeploymentUnit deploymentUnit ) { \nSet < ClassLoader > deploymentClassLoaders = new HashSet < ClassLoader > ( ) ; \nfinal DeploymentUnit topDeploymentUnit = DeploymentUtils . getTopDeploymentUnit ( deploymentUnit ) ; \nfinal Module toplevelModule = topDeploymentUnit . getAttachment ( Attachments . MODULE ) ; \nif ( toplevelModule != null ) { \ndeploymentClassLoaders . add ( toplevelModule . getClassLoader ( ) ) ; \nfinal List < DeploymentUnit > subDeployments = topDeploymentUnit . getAttachmentList ( Attachments . SUB_DEPLOYMENTS ) ; \nfor ( DeploymentUnit subDeploymentUnit : subDeployments ) { \nfinal Module subDeploymentModule = subDeploymentUnit . getAttachment ( Attachments . MODULE ) ; \nif ( subDeploymentModule != null ) deploymentClassLoaders . add ( subDeploymentModule . getClassLoader ( ) ) ; \n} \n} \nreturn deploymentClassLoaders ; \n} \n} \n"}
{"2594": "public class Configuration { \npublic static boolean needClassFileTransformer ( PersistenceUnitMetadata pu ) { \nboolean result = true ; \nString provider = pu . getPersistenceProviderClassName ( ) ; \nif ( pu . getProperties ( ) . containsKey ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) ; \nelse if ( isHibernateProvider ( provider ) ) result = ( Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_USE_CLASS_ENHANCER ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_DIRTY_TRACKING ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_LAZY_INITIALIZATION ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT ) ) ) ; \nreturn result ; \n} \n} \n"}
{"2595": "public class Configuration { \npublic static boolean allowTwoPhaseBootstrap ( PersistenceUnitMetadata pu ) { \nboolean result = true ; \nif ( EE_DEFAULT_DATASOURCE . equals ( pu . getJtaDataSourceName ( ) ) ) result = false ; \nif ( pu . getProperties ( ) . containsKey ( Configuration . JPA_ALLOW_TWO_PHASE_BOOTSTRAP ) ) result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_ALLOW_TWO_PHASE_BOOTSTRAP ) ) ; \nreturn result ; \n} \n} \n"}
{"2596": "public class Configuration { \npublic static boolean allowDefaultDataSourceUse ( PersistenceUnitMetadata pu ) { \nboolean result = true ; \nif ( pu . getProperties ( ) . containsKey ( Configuration . JPA_ALLOW_DEFAULT_DATA_SOURCE_USE ) ) result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_ALLOW_DEFAULT_DATA_SOURCE_USE ) ) ; \nreturn result ; \n} \n} \n"}
{"2597": "public class Configuration { \npublic static boolean skipMixedSynchronizationTypeCheck ( EntityManagerFactory emf , Map targetEntityManagerProperties ) { \nboolean result = false ; \nif ( targetEntityManagerProperties != null && targetEntityManagerProperties . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) result = Boolean . parseBoolean ( ( String ) targetEntityManagerProperties . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \nelse if ( emf . getProperties ( ) != null && emf . getProperties ( ) . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) result = Boolean . parseBoolean ( ( String ) emf . getProperties ( ) . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \nreturn result ; \n} \n} \n"}
{"2598": "public class CorbaUtils { \npublic static ORB getOrb ( String server , int port , Hashtable env ) { \nProperties orbProp ; \nif ( env != null ) { \norbProp = new Properties ( ) ; \nfinal Enumeration envProp = env . keys ( ) ; \nwhile ( envProp . hasMoreElements ( ) ) { \nString key = ( String ) envProp . nextElement ( ) ; \nObject val = env . get ( key ) ; \nif ( val instanceof String ) orbProp . put ( key , val ) ; \n} \nfinal Enumeration mainProps = orbProperties . keys ( ) ; \nwhile ( mainProps . hasMoreElements ( ) ) { \nString key = ( String ) mainProps . nextElement ( ) ; \nObject val = orbProperties . get ( key ) ; \nif ( val instanceof String ) orbProp . put ( key , val ) ; \n} \n} \nelse orbProp = orbProperties ; \nif ( server != null ) orbProp . put ( \"org.omg.CORBA.ORBInitialHost\" , server ) ; \nif ( port >= 0 ) orbProp . put ( \"org.omg.CORBA.ORBInitialPort\" , \"\" + port ) ; \nif ( env != null ) { \nObject applet = env . get ( Context . APPLET ) ; \nif ( applet != null ) return initAppletORB ( applet , orbProp ) ; \n} \nreturn ORB . init ( new String [ 0 ] , orbProp ) ; \n} \n} \n"}
{"2599": "public class CorbaUtils { \nprivate static ORB initAppletORB ( Object applet , Properties orbProp ) { \ntry { \nClass < ? > appletClass = Class . forName ( \"java.applet.Applet\" , true , null ) ; \nif ( ! appletClass . isInstance ( applet ) ) throw new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; \nMethod method = ORB . class . getMethod ( \"init\" , appletClass , Properties . class ) ; \nreturn ( ORB ) method . invoke ( null , applet , orbProp ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RuntimeException ) throw ( RuntimeException ) cause ; \nelse if ( cause instanceof Error ) throw ( Error ) cause ; \nthrow new AssertionError ( e ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new AssertionError ( iae ) ; \n} \n} \n} \n"}
{"2601": "public class NamingContext { \npublic static void setActiveNamingStore ( final NamingStore namingStore ) { \nif ( WildFlySecurityManager . isChecking ( ) ) System . getSecurityManager ( ) . checkPermission ( SET_ACTIVE_NAMING_STORE ) ; \nACTIVE_NAMING_STORE = namingStore ; \n} \n} \n"}
{"2602": "public class JaxrsMethodParameterProcessor { \nprivate void validateDefaultValues ( List < ParamDetail > detailList , HashMap < String , List < Validator > > paramConverterMap ) throws DeploymentUnitProcessingException { \nfor ( ParamDetail detail : detailList ) { \nList < Validator > validators = paramConverterMap . get ( detail . parameter . getName ( ) ) ; \nif ( validators == null ) validators = paramConverterMap . get ( Object . class . getName ( ) ) ; \nboolean isCheckClazzMethods = true ; \nif ( validators != null ) for ( Validator v : validators ) { \nif ( ! v . isLazyLoad ( ) ) try { \nObject obj = v . verify ( detail ) ; \nif ( obj != null ) { \nisCheckClazzMethods = false ; \nbreak ; \n} \n} \ncatch ( Exception e ) { \nJAXRS_LOGGER . paramConverterFailed ( detail . defaultValue . value ( ) , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , v . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; \n} \n} \nif ( isCheckClazzMethods ) { \nClass baseType = detail . parameter ; \nMethod valueOf = null ; \ntry { \nConstructor < ? > ctor = baseType . getConstructor ( String . class ) ; \nif ( Modifier . isPublic ( ctor . getModifiers ( ) ) ) continue ; \n} \ncatch ( NoSuchMethodException ignored ) { \n} \ntry { \nMethod fromValue = baseType . getDeclaredMethod ( \"fromValue\" , String . class ) ; \nif ( Modifier . isPublic ( fromValue . getModifiers ( ) ) ) { \nfor ( Annotation ann : baseType . getAnnotations ( ) ) { \nif ( ann . annotationType ( ) . getName ( ) . equals ( \"javax.xml.bind.annotation.XmlEnum\" ) ) valueOf = fromValue ; \n} \nvalidateBaseType ( fromValue , detail . defaultValue . value ( ) , detail ) ; \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignoredA ) { \n} \nMethod fromString = null ; \ntry { \nfromString = baseType . getDeclaredMethod ( \"fromString\" , String . class ) ; \nif ( Modifier . isStatic ( fromString . getModifiers ( ) ) ) { \nvalidateBaseType ( fromString , detail . defaultValue . value ( ) , detail ) ; \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignoredB ) { \n} \ntry { \nvalueOf = baseType . getDeclaredMethod ( \"valueOf\" , String . class ) ; \nif ( Modifier . isStatic ( valueOf . getModifiers ( ) ) ) { \nvalidateBaseType ( valueOf , detail . defaultValue . value ( ) , detail ) ; \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignored ) { \n} \n} \n} \n} \n} \n"}
{"2603": "public class JaxrsMethodParameterProcessor { \nprivate Class checkParamType ( Type genParamType , final Method method , final int paramPos , final ClassLoader classLoader ) { \nClass paramClazz = null ; \nif ( genParamType instanceof ParameterizedType ) { \nParameterizedType pType = ( ParameterizedType ) genParamType ; \nType [ ] actualTypeArgs = pType . getActualTypeArguments ( ) ; \nif ( actualTypeArgs . length == 1 ) try { \nparamClazz = classLoader . loadClass ( actualTypeArgs [ 0 ] . getTypeName ( ) ) ; \n} \ncatch ( Exception ee ) { \nJAXRS_LOGGER . classIntrospectionFailure ( ee . getClass ( ) . getName ( ) , ee . getMessage ( ) ) ; \n} \n} \nelse { \nClass < ? > [ ] paramArr = method . getParameterTypes ( ) ; \nif ( paramArr [ paramPos ] . isArray ( ) ) { \nClass compClazz = paramArr [ paramPos ] . getComponentType ( ) ; \nif ( ! compClazz . isPrimitive ( ) ) paramClazz = compClazz ; \n} \nelse if ( ! paramArr [ paramPos ] . isPrimitive ( ) ) paramClazz = paramArr [ paramPos ] ; \n} \nreturn paramClazz ; \n} \n} \n"}
{"2604": "public class JaxrsMethodParameterProcessor { \nprivate DefaultValue lookupDefaultValueAnn ( Annotation [ ] annotationArr ) { \nfor ( Annotation ann : annotationArr ) { \nif ( ann instanceof DefaultValue ) return ( DefaultValue ) ann ; \n} \nreturn null ; \n} \n} \n"}
{"2605": "public class JaxrsMethodParameterProcessor { \nprivate void validateBaseType ( Method method , String defaultValue , ParamDetail detail ) throws DeploymentUnitProcessingException { \nif ( defaultValue != null ) try { \nmethod . invoke ( method . getDeclaringClass ( ) , defaultValue ) ; \n} \ncatch ( Exception e ) { \nJAXRS_LOGGER . baseTypeMethodFailed ( defaultValue , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , method . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"2606": "public class CreatedEntityManagers { \npublic static ExtendedEntityManager [ ] getDeferredEntityManagers ( ) { \nList < ExtendedEntityManager > store = deferToPostConstruct . get ( ) ; \ntry { \nif ( store . isEmpty ( ) ) return EMPTY ; \nelse return store . toArray ( new ExtendedEntityManager [ store . size ( ) ] ) ; \n} \nfinally { \nstore . clear ( ) ; \n} \n} \n} \n"}
{"2607": "public class StatusHelper { \npublic static String statusAsString ( int status ) { \nif ( status >= Status . STATUS_ACTIVE && status <= Status . STATUS_ROLLING_BACK ) return TxStatusStrings [ status ] ; \nelse return \"STATUS_INVALID(\" + status + \")\" ; \n} \n} \n"}
{"2609": "public class DatabaseTimerPersistence { \nprivate void extractDialects ( ) { \nfor ( Object prop : sql . keySet ( ) ) { \nint dot = ( ( String ) prop ) . indexOf ( '.' ) ; \nif ( dot > 0 ) databaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; \n} \n} \n} \n"}
{"2610": "public class DatabaseTimerPersistence { \nprivate void investigateDialect ( ) { \nConnection connection = null ; \nif ( database == null ) { \ntry { \nconnection = dataSource . getConnection ( ) ; \nDatabaseMetaData metaData = connection . getMetaData ( ) ; \nString dbProduct = metaData . getDatabaseProductName ( ) ; \ndatabase = identifyDialect ( dbProduct ) ; \nif ( database == null ) { \nEjbLogger . EJB3_TIMER_LOGGER . debug ( \"Attempting to guess on driver name.\" ) ; \ndatabase = identifyDialect ( metaData . getDriverName ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nEjbLogger . EJB3_TIMER_LOGGER . debug ( \"Unable to read JDBC metadata.\" , e ) ; \n} \nfinally { \nsafeClose ( connection ) ; \n} \nif ( database == null ) EjbLogger . EJB3_TIMER_LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString ( ) ) ; \nelse EjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Detect database dialect as '%s'.  If this is incorrect, please specify the correct dialect using the 'database' attribute in your configuration.  Supported database dialect strings are %s\" , database , databaseDialects ) ; \n} \nelse { \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Database dialect '%s' read from configuration, adjusting it to match the final database valid value.\" , database ) ; \ndatabase = identifyDialect ( database ) ; \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"New Database dialect is '%s'.\" , database ) ; \n} \n} \n} \n"}
{"2611": "public class DatabaseTimerPersistence { \nprivate String identifyDialect ( String name ) { \nString unified = null ; \nif ( name != null ) if ( name . toLowerCase ( ) . contains ( \"postgres\" ) ) unified = \"postgresql\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"mysql\" ) ) unified = \"mysql\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"mariadb\" ) ) unified = \"mariadb\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"db2\" ) ) unified = \"db2\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"hsql\" ) || name . toLowerCase ( ) . contains ( \"hypersonic\" ) ) unified = \"hsql\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"h2\" ) ) unified = \"h2\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"oracle\" ) ) unified = \"oracle\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"microsoft\" ) ) unified = \"mssql\" ; \nelse if ( name . toLowerCase ( ) . contains ( \"jconnect\" ) ) unified = \"sybase\" ; \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Check dialect for '%s', result is '%s'\" , name , unified ) ; \nreturn unified ; \n} \n} \n"}
{"2612": "public class DatabaseTimerPersistence { \nprivate void checkDatabase ( ) { \nString loadTimer = sql ( LOAD_TIMER ) ; \nConnection connection = null ; \nStatement statement = null ; \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nconnection = dataSource . getConnection ( ) ; \nif ( connection . getTransactionIsolation ( ) < Connection . TRANSACTION_READ_COMMITTED ) EjbLogger . EJB3_TIMER_LOGGER . wrongTransactionIsolationConfiguredForTimer ( ) ; \npreparedStatement = connection . prepareStatement ( loadTimer ) ; \npreparedStatement . setString ( 1 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 2 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 3 , \"NON-EXISTENT\" ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \n} \ncatch ( SQLException e ) { \nif ( connection != null ) try { \nString createTable = sql ( CREATE_TABLE ) ; \nString [ ] statements = createTable . split ( \";\" ) ; \nfor ( final String sql : statements ) { \ntry { \nstatement = connection . createStatement ( ) ; \nstatement . executeUpdate ( sql ) ; \n} \nfinally { \nsafeClose ( statement ) ; \n} \n} \n} \ncatch ( SQLException e1 ) { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e1 ) ; \n} \nelse EjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e ) ; \n} \nfinally { \nsafeClose ( resultSet ) ; \nsafeClose ( preparedStatement ) ; \nsafeClose ( statement ) ; \nsafeClose ( connection ) ; \n} \n} \n} \n"}
{"2613": "public class DatabaseTimerPersistence { \nprivate Date stringAsSchedulerDate ( final String date , final String timerId ) { \nif ( date == null ) return null ; \ntry { \nreturn new SimpleDateFormat ( SCHEDULER_DATE_FORMAT ) . parse ( date ) ; \n} \ncatch ( ParseException e ) { \nEjbLogger . EJB3_TIMER_LOGGER . scheduleExpressionDateFromTimerPersistenceInvalid ( timerId , e . getMessage ( ) ) ; \nreturn null ; \n} \n} \n} \n"}
{"2614": "public class DatabaseTimerPersistence { \nprivate void setNodeName ( final TimerState timerState , PreparedStatement statement , int paramIndex ) throws SQLException { \nif ( timerState == TimerState . IN_TIMEOUT || timerState == TimerState . RETRY_TIMEOUT ) statement . setString ( paramIndex , nodeName ) ; \nelse statement . setNull ( paramIndex , Types . VARCHAR ) ; \n} \n} \n"}
{"2615": "public class WeldDeploymentMarker { \npublic static void mark ( DeploymentUnit unit ) { \nunit . putAttachment ( MARKER , Boolean . TRUE ) ; \nif ( unit . getParent ( ) != null ) mark ( unit . getParent ( ) ) ; \n} \n} \n"}
{"2616": "public class SkeletonStrategy { \npublic Object [ ] readParams ( InputStream in ) { \nint len = paramReaders . length ; \nObject [ ] params = new Object [ len ] ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) params [ i ] = paramReaders [ i ] . read ( in ) ; \nreturn params ; \n} \n} \n"}
{"2618": "public class SkeletonStrategy { \npublic void writeException ( OutputStream out , Throwable e ) { \nint len = excepWriters . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) if ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { \nexcepWriters [ i ] . write ( out , e ) ; \nreturn ; \n} \nthrow new UnknownException ( e ) ; \n} \n} \n"}
{"2621": "public class SFSBCallStack { \npublic static void endSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nno -- ; \ndata . creationBeanNestingLevel = no ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = null ; \ndata . creationTimeInjectedXPCs = null ; \n} \nelse data . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; \n} \n} \n"}
{"2622": "public class SFSBCallStack { \npublic static Map < String , ExtendedEntityManager > currentSFSBCallStackInvocation ( ) { \nArrayList < Map < String , ExtendedEntityManager > > stack = CURRENT . get ( ) . invocationStack ; \nif ( stack != null && stack . size ( ) > 0 ) return stack . get ( stack . size ( ) - 1 ) ; \nreturn null ; \n} \n} \n"}
{"2623": "public class SFSBCallStack { \npublic static void pushCall ( Map < String , ExtendedEntityManager > entityManagers ) { \ncurrentSFSBCallStack ( ) . add ( entityManagers ) ; \nif ( entityManagers != null ) for ( ExtendedEntityManager extendedEntityManager : entityManagers . values ( ) ) { \nextendedEntityManager . internalAssociateWithJtaTx ( ) ; \n} \n} \n} \n"}
{"2625": "public class SFSBCallStack { \nstatic Map < String , ExtendedEntityManager > getCurrentCall ( ) { \nArrayList < Map < String , ExtendedEntityManager > > stack = currentSFSBCallStack ( ) ; \nMap < String , ExtendedEntityManager > result = null ; \nif ( stack != null ) result = stack . get ( stack . size ( ) - 1 ) ; \nreturn result ; \n} \n} \n"}
{"2626": "public class WeldDependencyProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \naddDependency ( moduleSpecification , moduleLoader , JAVAX_ENTERPRISE_API ) ; \naddDependency ( moduleSpecification , moduleLoader , JAVAX_INJECT_API ) ; \nif ( ! WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit ) ) return ; \naddDependency ( moduleSpecification , moduleLoader , JAVAX_PERSISTENCE_API_ID ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_CORE_ID ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_PROBE_ID , true ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_API_ID ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_SPI_ID ) ; \nModuleDependency weldSubsystemDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_ID , false , false , false , false ) ; \nweldSubsystemDependency . addImportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; \nweldSubsystemDependency . addImportFilter ( PathFilters . is ( \"org/jboss/as/weld/injection\" ) , true ) ; \nweldSubsystemDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; \nweldSubsystemDependency . addExportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; \nmoduleSpecification . addSystemDependency ( weldSubsystemDependency ) ; \nModuleDependency weldEjbDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_EJB_ID , true , false , false , false ) ; \nweldEjbDependency . addImportFilter ( PathFilters . is ( \"org/jboss/as/weld/ejb\" ) , true ) ; \nweldEjbDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( weldEjbDependency ) ; \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) managedBean = true ; \nelse if ( indent == 3 && managedBean ) if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) managedBean = false ; \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) className . append ( parser . getText ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) is . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) if ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) lifecycle = true ; \nelse if ( indent == 3 && lifecycle ) if ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) lifecycle = false ; \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) phaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) is . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2629": "public class Util { \npublic static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { \nif ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; \nif ( cls . isArray ( ) ) { \nClass componentClass = cls ; \nint sequence = 0 ; \nwhile ( componentClass . isArray ( ) ) { \ncomponentClass = componentClass . getComponentType ( ) ; \n++ sequence ; \n} \nString idlName = getTypeIDLName ( componentClass ) ; \nint idx = idlName . lastIndexOf ( \"::\" ) ; \nString idlModule = idlName . substring ( 0 , idx + 2 ) ; \nString baseName = idlName . substring ( idx + 2 ) ; \nreturn \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; \n} \nif ( cls == java . lang . String . class ) return \"::CORBA::WStringValue\" ; \nif ( cls == java . lang . Object . class ) return \"::java::lang::_Object\" ; \nif ( cls == java . lang . Class . class ) return \"::javax::rmi::CORBA::ClassDesc\" ; \nif ( cls == java . io . Serializable . class ) return \"::java::io::Serializable\" ; \nif ( cls == java . io . Externalizable . class ) return \"::java::io::Externalizable\" ; \nif ( cls == java . rmi . Remote . class ) return \"::java::rmi::Remote\" ; \nif ( cls == org . omg . CORBA . Object . class ) return \"::CORBA::Object\" ; \nif ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( Throwable . class . isAssignableFrom ( cls ) ) if ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \nreturn ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; \n} \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \nreturn va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; \n} \n} \n"}
{"2637": "public class TransactionScopedEntityManager { \nprivate EntityManager getOrCreateTransactionScopedEntityManager ( final EntityManagerFactory emf , final String scopedPuName , final Map properties , final SynchronizationType synchronizationType ) { \nEntityManager entityManager = TransactionUtil . getTransactionScopedEntityManager ( puScopedName , transactionSynchronizationRegistry ) ; \nif ( entityManager == null ) { \nentityManager = createEntityManager ( emf , properties , synchronizationType ) ; \nif ( ROOT_LOGGER . isDebugEnabled ( ) ) ROOT_LOGGER . debugf ( \"%s: created entity manager session %s\" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; \nTransactionUtil . registerSynchronization ( entityManager , scopedPuName , transactionSynchronizationRegistry , transactionManager ) ; \nTransactionUtil . putEntityManagerInTransactionRegistry ( scopedPuName , entityManager , transactionSynchronizationRegistry ) ; \n} \nelse { \ntestForMixedSynchronizationTypes ( emf , entityManager , puScopedName , synchronizationType , properties ) ; \nif ( ROOT_LOGGER . isDebugEnabled ( ) ) ROOT_LOGGER . debugf ( \"%s: reuse entity manager session already in tx %s\" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; \n} \nreturn entityManager ; \n} \n} \n"}
{"2639": "public class ManagementUtil { \nstatic ModelNode convertSecurityRole ( final ModelNode camelCase ) { \nfinal ModelNode result = new ModelNode ( ) ; \nresult . setEmptyList ( ) ; \nif ( camelCase . isDefined ( ) ) for ( ModelNode role : camelCase . asList ( ) ) { \nfinal ModelNode roleNode = result . add ( ) ; \nfor ( Property prop : role . asPropertyList ( ) ) { \nString key = prop . getName ( ) ; \nif ( \"createDurableQueue\" . equals ( key ) ) key = SecurityRoleDefinition . CREATE_DURABLE_QUEUE . getName ( ) ; \nelse if ( \"deleteDurableQueue\" . equals ( key ) ) key = SecurityRoleDefinition . DELETE_DURABLE_QUEUE . getName ( ) ; \nelse if ( \"createNonDurableQueue\" . equals ( key ) ) key = SecurityRoleDefinition . CREATE_NON_DURABLE_QUEUE . getName ( ) ; \nelse if ( \"deleteNonDurableQueue\" . equals ( key ) ) key = SecurityRoleDefinition . DELETE_NON_DURABLE_QUEUE . getName ( ) ; \nroleNode . get ( key ) . set ( prop . getValue ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2640": "public class FileTimerPersistence { \nprivate TimerImpl mostRecentEntityVersion ( final TimerImpl timerImpl ) { \ntry { \nfinal int status = ContextTransactionManager . getInstance ( ) . getStatus ( ) ; \nif ( status == Status . STATUS_UNKNOWN || status == Status . STATUS_NO_TRANSACTION ) return timerImpl ; \nfinal String key = timerTransactionKey ( timerImpl ) ; \nTimerImpl existing = ( TimerImpl ) transactionSynchronizationRegistry . getValue ( ) . getResource ( key ) ; \nreturn existing != null ? existing : timerImpl ; \n} \ncatch ( SystemException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"2642": "public class FileTimerPersistence { \nprivate String getDirectory ( String timedObjectId ) { \nString dirName = directories . get ( timedObjectId ) ; \nif ( dirName == null ) { \ndirName = baseDir . getAbsolutePath ( ) + File . separator + timedObjectId . replace ( File . separator , \"-\" ) ; \nFile file = new File ( dirName ) ; \nif ( ! file . exists ( ) ) if ( ! file . mkdirs ( ) ) EJB3_TIMER_LOGGER . failToCreateDirectoryForPersistTimers ( file ) ; \ndirectories . put ( timedObjectId , dirName ) ; \n} \nreturn dirName ; \n} \n} \n"}
{"2643": "public class NamingEventCoordinator { \nsynchronized void addListener ( final String target , final int scope , final NamingListener namingListener ) { \nfinal TargetScope targetScope = new TargetScope ( target , scope ) ; \nListenerHolder holder = holdersByListener . get ( namingListener ) ; \nif ( holder == null ) { \nholder = new ListenerHolder ( namingListener , targetScope ) ; \nfinal Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; \nbyListenerCopy . put ( namingListener , holder ) ; \nholdersByListener = byListenerCopy ; \n} \nelse holder . addTarget ( targetScope ) ; \nList < ListenerHolder > holdersForTarget = holdersByTarget . get ( targetScope ) ; \nif ( holdersForTarget == null ) { \nholdersForTarget = new CopyOnWriteArrayList < ListenerHolder > ( ) ; \nfinal Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; \nbyTargetCopy . put ( targetScope , holdersForTarget ) ; \nholdersByTarget = byTargetCopy ; \n} \nholdersForTarget . add ( holder ) ; \n} \n} \n"}
{"2644": "public class NamingEventCoordinator { \nsynchronized void removeListener ( final NamingListener namingListener ) { \nfinal ListenerHolder holder = holdersByListener . get ( namingListener ) ; \nif ( holder == null ) return ; \nfinal Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; \nbyListenerCopy . remove ( namingListener ) ; \nholdersByListener = byListenerCopy ; \nfinal Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; \nfor ( TargetScope targetScope : holder . targets ) { \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nholders . remove ( holder ) ; \nif ( holders . isEmpty ( ) ) byTargetCopy . remove ( targetScope ) ; \n} \nholdersByTarget = byTargetCopy ; \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) for ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) for ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) for ( int i = 1 ; \ni < name . size ( ) ; \ni ++ ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) for ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \n} \n} \n"}
{"2647": "public class ElytronSubjectFactory { \nprivate void addPrivateCredential ( final Subject subject , final Object credential ) { \nif ( ! WildFlySecurityManager . isChecking ( ) ) subject . getPrivateCredentials ( ) . add ( credential ) ; \nelse AccessController . doPrivileged ( ( PrivilegedAction < Void > ) ( ) -> { \nsubject . getPrivateCredentials ( ) . add ( credential ) ; \nreturn null ; \n} \n) ; \n} \n} \n"}
{"2648": "public class ObjectFactoryBuilder { \npublic Object getObjectInstance ( final Object ref , final Name name , final Context nameCtx , final Hashtable < ? , ? > environment ) throws Exception { \nfinal ClassLoader classLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \nif ( classLoader == null ) return ref ; \nfinal String factoriesProp = ( String ) environment . get ( Context . OBJECT_FACTORIES ) ; \nif ( factoriesProp != null ) { \nfinal String [ ] classes = factoriesProp . split ( \":\" ) ; \nfor ( String className : classes ) { \ntry { \nfinal Class < ? > factoryClass = classLoader . loadClass ( className ) ; \nfinal ObjectFactory objectFactory = ObjectFactory . class . cast ( factoryClass . newInstance ( ) ) ; \nfinal Object result = objectFactory . getObjectInstance ( ref , name , nameCtx , environment ) ; \nif ( result != null ) return result ; \n} \ncatch ( Throwable ignored ) { \n} \n} \n} \nreturn ref ; \n} \n} \n"}
{"2649": "public class SessionBeanComponentDescription { \nprotected static void addTxManagementInterceptorForView ( ViewDescription view ) { \nview . getConfigurators ( ) . add ( new ViewConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentConfiguration componentConfiguration , ViewDescription description , ViewConfiguration configuration ) throws DeploymentUnitProcessingException { \nEJBComponentDescription ejbComponentDescription = ( EJBComponentDescription ) componentConfiguration . getComponentDescription ( ) ; \nif ( TransactionManagementType . CONTAINER . equals ( ejbComponentDescription . getTransactionManagementType ( ) ) ) configuration . addViewInterceptor ( CMTTxInterceptor . FACTORY , InterceptorOrder . View . CMT_TRANSACTION_INTERCEPTOR ) ; \n} \n} \n) ; \n} \n} \n"}
{"2651": "public class ImportJournalOperation { \nprivate TransportConfiguration createInVMTransportConfiguration ( OperationContext context ) throws OperationFailedException { \nfinal Resource serverResource = context . readResource ( EMPTY_ADDRESS , false ) ; \nSet < Resource . ResourceEntry > invmConnectors = serverResource . getChildren ( CommonAttributes . IN_VM_CONNECTOR ) ; \nif ( invmConnectors . isEmpty ( ) ) throw MessagingLogger . ROOT_LOGGER . noInVMConnector ( ) ; \nResource . ResourceEntry connectorEntry = invmConnectors . iterator ( ) . next ( ) ; \nResource connectorResource = context . readResource ( PathAddress . pathAddress ( connectorEntry . getPathElement ( ) ) , false ) ; \nModelNode model = connectorResource . getModel ( ) ; \nMap < String , Object > params = new HashMap < > ( CommonAttributes . PARAMS . unwrap ( context , model ) ) ; \nparams . put ( InVMTransportDefinition . SERVER_ID . getName ( ) , InVMTransportDefinition . SERVER_ID . resolveModelAttribute ( context , model ) . asInt ( ) ) ; \nTransportConfiguration transportConfiguration = new TransportConfiguration ( InVMConnectorFactory . class . getName ( ) , params ) ; \nreturn transportConfiguration ; \n} \n} \n"}
{"2652": "public class ResourceAdaptorMergingProcessor { \nprivate String addEarPrefixIfRelativeName ( final String configuredName , final DeploymentUnit deploymentUnit , final Class < ? > componentClass ) throws DeploymentUnitProcessingException { \nif ( ! configuredName . startsWith ( \"#\" ) ) return configuredName ; \nfinal DeploymentUnit parent = deploymentUnit . getParent ( ) ; \nif ( parent == null ) throw EjbLogger . ROOT_LOGGER . relativeResourceAdapterNameInStandaloneModule ( deploymentUnit . getName ( ) , componentClass . getName ( ) , configuredName ) ; \nreturn new StringBuilder ( ) . append ( parent . getName ( ) ) . append ( configuredName ) . toString ( ) ; \n} \n} \n"}
{"2653": "public class Utils { \npublic static DeploymentUnit getRootDeploymentUnit ( DeploymentUnit deploymentUnit ) { \nif ( deploymentUnit . getParent ( ) == null ) return deploymentUnit ; \nreturn deploymentUnit . getParent ( ) ; \n} \n} \n"}
{"2654": "public class ViewDescription { \npublic ServiceName getServiceName ( ) { \nif ( ! viewNameParts . isEmpty ( ) ) return componentDescription . getServiceName ( ) . append ( \"VIEW\" ) . append ( viewNameParts . toArray ( new String [ viewNameParts . size ( ) ] ) ) ; \nelse return componentDescription . getServiceName ( ) . append ( \"VIEW\" ) . append ( viewClassName ) ; \n} \n} \n"}
{"2657": "public class ViewConfiguration { \npublic List < InterceptorFactory > getViewInterceptors ( Method method ) { \nOrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; \nif ( container == null ) return Collections . emptyList ( ) ; \nreturn container . getSortedItems ( ) ; \n} \n} \n"}
{"2659": "public class ViewConfiguration { \npublic void addViewInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { \nOrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; \nif ( container == null ) viewInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; \ncontainer . add ( interceptorFactory , priority ) ; \n} \n} \n"}
{"2660": "public class ViewConfiguration { \npublic List < InterceptorFactory > getClientInterceptors ( Method method ) { \nOrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; \nif ( container == null ) return Collections . emptyList ( ) ; \nreturn container . getSortedItems ( ) ; \n} \n} \n"}
{"2662": "public class ViewConfiguration { \npublic void addClientInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { \nOrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; \nif ( container == null ) clientInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; \ncontainer . add ( interceptorFactory , priority ) ; \n} \n} \n"}
{"2669": "public class ASHelper { \npublic static ServletMetaData getServletForName ( final JBossWebMetaData jbossWebMD , final String servletName ) { \nfor ( JBossServletMetaData servlet : jbossWebMD . getServlets ( ) ) { \nif ( servlet . getName ( ) . equals ( servletName ) ) return servlet ; \n} \nreturn null ; \n} \n} \n"}
{"2670": "public class ASHelper { \npublic static < A > A getRequiredAttachment ( final DeploymentUnit unit , final AttachmentKey < A > key ) { \nfinal A value = unit . getAttachment ( key ) ; \nif ( value == null ) throw new IllegalStateException ( ) ; \nreturn value ; \n} \n} \n"}
{"2672": "public class ASHelper { \npublic static JBossWebMetaData getJBossWebMetaData ( final DeploymentUnit unit ) { \nfinal WarMetaData warMetaData = getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; \nJBossWebMetaData result = null ; \nif ( warMetaData != null ) { \nresult = warMetaData . getMergedJBossWebMetaData ( ) ; \nif ( result == null ) result = warMetaData . getJBossWebMetaData ( ) ; \n} \nelse result = getOptionalAttachment ( unit , WSAttachmentKeys . JBOSSWEB_METADATA_KEY ) ; \nreturn result ; \n} \n} \n"}
{"2673": "public class ASHelper { \npublic static JBossPortComponentMetaData getJBossWebserviceMetaDataPortComponent ( final DeploymentUnit unit , final String name ) { \nif ( name != null ) { \nfinal JBossWebservicesMetaData jbossWebserviceMetaData = unit . getAttachment ( JBOSS_WEBSERVICES_METADATA_KEY ) ; \nif ( jbossWebserviceMetaData != null ) { \nJBossPortComponentMetaData [ ] portComponent = jbossWebserviceMetaData . getPortComponents ( ) ; \nif ( portComponent != null ) for ( JBossPortComponentMetaData component : portComponent ) { \nif ( name . equals ( component . getEjbName ( ) ) ) return component ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"2674": "public class ASHelper { \npublic static EJBEndpoint getWebserviceMetadataEJBEndpoint ( final JAXWSDeployment jaxwsDeployment , final String className ) { \njava . util . List < EJBEndpoint > ejbEndpointList = jaxwsDeployment . getEjbEndpoints ( ) ; \nfor ( EJBEndpoint ejbEndpoint : ejbEndpointList ) { \nif ( className . equals ( ejbEndpoint . getClassName ( ) ) ) return ejbEndpoint ; \n} \nreturn null ; \n} \n} \n"}
{"2675": "public class ASHelper { \npublic static String getContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; \nfinal JBossAppMetaData jbossAppMD = unit . getParent ( ) == null ? null : ASHelper . getOptionalAttachment ( unit . getParent ( ) , WSAttachmentKeys . JBOSS_APP_METADATA_KEY ) ; \nString contextRoot = null ; \nif ( jbossAppMD != null ) { \nfinal ModuleMetaData moduleMD = jbossAppMD . getModules ( ) . get ( dep . getSimpleName ( ) ) ; \nif ( moduleMD != null ) { \nfinal WebModuleMetaData webModuleMD = ( WebModuleMetaData ) moduleMD . getValue ( ) ; \ncontextRoot = webModuleMD . getContextRoot ( ) ; \n} \n} \nif ( contextRoot == null ) contextRoot = jbossWebMD != null ? jbossWebMD . getContextRoot ( ) : null ; \nreturn contextRoot ; \n} \n} \n"}
{"2676": "public class WeldModuleResourceLoader { \n@ Override public Class < ? > classForName ( String name ) { \ntry { \nif ( classes . containsKey ( name ) ) return classes . get ( name ) ; \nfinal Class < ? > clazz = module . getClassLoader ( ) . loadClass ( name ) ; \nclasses . put ( name , clazz ) ; \nreturn clazz ; \n} \ncatch ( ClassNotFoundException | LinkageError e ) { \nthrow new ResourceLoadingException ( e ) ; \n} \n} \n} \n"}
{"2678": "public class WeldModuleResourceLoader { \n@ Override public Collection < URL > getResources ( String name ) { \ntry { \nfinal HashSet < URL > resources = new HashSet < URL > ( ) ; \nEnumeration < URL > urls = module . getClassLoader ( ) . getResources ( name ) ; \nwhile ( urls . hasMoreElements ( ) ) resources . add ( urls . nextElement ( ) ) ; \nreturn resources ; \n} \ncatch ( Exception e ) { \nthrow new ResourceLoadingException ( e ) ; \n} \n} \n} \n"}
{"2679": "public class ServletResourceManager { \npublic List < Resource > list ( String path ) { \ntry { \nfinal List < Resource > ret = new ArrayList < > ( ) ; \nResource res = deploymentResourceManager . getResource ( path ) ; \nif ( res != null ) for ( Resource child : res . list ( ) ) { \nret . add ( new ServletResource ( this , child ) ) ; \n} \nString p = path ; \nif ( p . startsWith ( \"/\" ) ) p = p . substring ( 1 ) ; \nif ( overlays != null ) for ( VirtualFile overlay : overlays ) { \nVirtualFile child = overlay . getChild ( p ) ; \nif ( child . exists ( ) ) { \nVirtualFileResource vfsResource = new VirtualFileResource ( overlay . getPhysicalFile ( ) , child , path ) ; \nfor ( Resource c : vfsResource . list ( ) ) { \nret . add ( new ServletResource ( this , c ) ) ; \n} \n} \n} \nreturn ret ; \n} \ncatch ( IOException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"2680": "public class NonTxEmCloser { \npublic static void popCall ( ) { \nMap < String , EntityManager > emStack = nonTxStack . pop ( ) ; \nif ( emStack != null ) for ( EntityManager entityManager : emStack . values ( ) ) { \ntry { \nif ( entityManager . isOpen ( ) ) entityManager . close ( ) ; \n} \ncatch ( RuntimeException safeToIgnore ) { \nif ( ROOT_LOGGER . isTraceEnabled ( ) ) ROOT_LOGGER . trace ( \"Could not close (non-transactional) container managed entity manager.\" + \"  This shouldn't impact application functionality (only read \" + \"operations occur in non-transactional mode)\" , safeToIgnore ) ; \n} \n} \n} \n} \n"}
{"2681": "public class NonTxEmCloser { \npublic static EntityManager get ( String puScopedName ) { \nMap < String , EntityManager > map = nonTxStack . peek ( ) ; \nif ( map != null ) return map . get ( puScopedName ) ; \nreturn null ; \n} \n} \n"}
{"2683": "public class WarAnnotationDeploymentProcessor { \npublic void deploy ( final DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nif ( ! DeploymentTypeMarker . isType ( DeploymentType . WAR , deploymentUnit ) ) return ; \nWarMetaData warMetaData = deploymentUnit . getAttachment ( WarMetaData . ATTACHMENT_KEY ) ; \nassert warMetaData != null ; \nMap < String , WebMetaData > annotationsMetaData = warMetaData . getAnnotationsMetaData ( ) ; \nif ( annotationsMetaData == null ) { \nannotationsMetaData = new HashMap < String , WebMetaData > ( ) ; \nwarMetaData . setAnnotationsMetaData ( annotationsMetaData ) ; \n} \nMap < ResourceRoot , Index > indexes = AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit ) ; \nfor ( final Entry < ResourceRoot , Index > entry : indexes . entrySet ( ) ) { \nfinal Index jarIndex = entry . getValue ( ) ; \nannotationsMetaData . put ( entry . getKey ( ) . getRootName ( ) , processAnnotations ( jarIndex ) ) ; \n} \nMap < ModuleIdentifier , CompositeIndex > additionalModelAnnotations = deploymentUnit . getAttachment ( Attachments . ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE ) ; \nif ( additionalModelAnnotations != null ) { \nfinal List < WebMetaData > additional = new ArrayList < WebMetaData > ( ) ; \nfor ( Entry < ModuleIdentifier , CompositeIndex > entry : additionalModelAnnotations . entrySet ( ) ) { \nfor ( Index index : entry . getValue ( ) . getIndexes ( ) ) { \nadditional . add ( processAnnotations ( index ) ) ; \n} \n} \nwarMetaData . setAdditionalModuleAnnotationsMetadata ( additional ) ; \n} \n} \n} \n"}
{"2684": "public class WSServerConfigAttributeHandler { \nprivate boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { \nfinal ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; \ntry { \nif ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { \nfinal boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; \nconfig . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; \n} \nelse if ( WSDL_HOST . equals ( attributeName ) ) { \nfinal String host = value != null ? value : null ; \ntry { \nconfig . setWebServiceHost ( host , isRevert ) ; \n} \ncatch ( final UnknownHostException e ) { \nthrow new OperationFailedException ( e . getMessage ( ) , e ) ; \n} \n} \nelse if ( WSDL_PORT . equals ( attributeName ) ) { \nfinal int port = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServicePort ( port , isRevert ) ; \n} \nelse if ( WSDL_SECURE_PORT . equals ( attributeName ) ) { \nfinal int securePort = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServiceSecurePort ( securePort , isRevert ) ; \n} \nelse if ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { \nfinal String path = value != null ? value : null ; \nconfig . setWebServicePathRewriteRule ( path , isRevert ) ; \n} \nelse if ( WSDL_URI_SCHEME . equals ( attributeName ) ) if ( value == null || value . equals ( \"http\" ) || value . equals ( \"https\" ) ) config . setWebServiceUriScheme ( value , isRevert ) ; \nelse throw new IllegalArgumentException ( attributeName + \" = \" + value ) ; \nelse if ( STATISTICS_ENABLED . equals ( attributeName ) ) { \nfinal boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; \nconfig . setStatisticsEnabled ( enabled ) ; \n} \nelse throw new IllegalArgumentException ( attributeName ) ; \n} \ncatch ( DisabledOperationException doe ) { \nif ( ! isRevert ) return false ; \nelse throw doe ; \n} \nreturn true ; \n} \n} \n"}
{"2687": "public class AbstractDeploymentModelBuilder { \nprivate ArchiveDeployment newDeployment ( final DeploymentUnit unit ) { \nWSLogger . ROOT_LOGGER . tracef ( \"Creating new unified WS deployment model for %s\" , unit ) ; \nfinal ResourceRoot deploymentRoot = unit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; \nfinal VirtualFile root = deploymentRoot != null ? deploymentRoot . getRoot ( ) : null ; \nfinal ClassLoader classLoader ; \nfinal Module module = unit . getAttachment ( Attachments . MODULE ) ; \nif ( module == null ) { \nclassLoader = unit . getAttachment ( CLASSLOADER_KEY ) ; \nif ( classLoader == null ) throw WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( unit ) ; \n} \nelse classLoader = module . getClassLoader ( ) ; \nArchiveDeployment parentDep = null ; \nif ( unit . getParent ( ) != null ) { \nfinal Module parentModule = unit . getParent ( ) . getAttachment ( Attachments . MODULE ) ; \nif ( parentModule == null ) throw WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( deploymentRoot ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Creating new unified WS deployment model for %s\" , unit . getParent ( ) ) ; \nparentDep = this . newDeployment ( null , unit . getParent ( ) . getName ( ) , parentModule . getClassLoader ( ) , null ) ; \n} \nfinal UnifiedVirtualFile uvf = root != null ? new VirtualFileAdaptor ( root ) : new ResourceLoaderAdapter ( classLoader ) ; \nfinal ArchiveDeployment dep = this . newDeployment ( parentDep , unit . getName ( ) , classLoader , uvf ) ; \ndep . addAttachment ( AnnotationsInfo . class , new JandexAnnotationsInfo ( unit ) ) ; \nreturn dep ; \n} \n} \n"}
{"2689": "public class TimerImpl { \npublic void setNextTimeout ( Date next ) { \nif ( next == null ) setTimerState ( TimerState . EXPIRED , null ) ; \nthis . nextExpiration = next ; \n} \n} \n"}
{"2691": "public class ResteasyDeploymentData { \npublic void merge ( final List < ResteasyDeploymentData > deploymentData ) throws DeploymentUnitProcessingException { \nfor ( ResteasyDeploymentData data : deploymentData ) { \nscannedApplicationClasses . addAll ( data . getScannedApplicationClasses ( ) ) ; \nif ( scanResources ) { \nscannedResourceClasses . addAll ( data . getScannedResourceClasses ( ) ) ; \nscannedJndiComponentResources . addAll ( data . getScannedJndiComponentResources ( ) ) ; \n} \nif ( scanProviders ) scannedProviderClasses . addAll ( data . getScannedProviderClasses ( ) ) ; \n} \n} \n} \n"}
{"2693": "public class EJBComponentDescription { \nprotected void addRemoteTransactionsDependency ( ) { \nthis . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration componentConfiguration ) throws DeploymentUnitProcessingException { \nif ( this . hasRemoteView ( ( EJBComponentDescription ) description ) ) componentConfiguration . getCreateDependencies ( ) . add ( ( sb , cs ) -> sb . requires ( TxnServices . JBOSS_TXN_REMOTE_TRANSACTION_SERVICE ) ) ; \n} \nprivate boolean hasRemoteView ( final EJBComponentDescription ejbComponentDescription ) { \nfinal Set < ViewDescription > views = ejbComponentDescription . getViews ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( ! ( view instanceof EJBViewDescription ) ) continue ; \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . REMOTE || viewType == MethodIntf . HOME ) return true ; \n} \nreturn false ; \n} \n} \n) ; \n} \n} \n"}
{"2694": "public class EJBComponentDescription { \npublic Set < InterceptorDescription > getAllContainerInterceptors ( ) { \nif ( this . allContainerInterceptors == null ) { \nthis . allContainerInterceptors = new HashSet < InterceptorDescription > ( ) ; \nthis . allContainerInterceptors . addAll ( this . classLevelContainerInterceptors ) ; \nif ( ! this . excludeDefaultContainerInterceptors ) this . allContainerInterceptors . addAll ( this . defaultContainerInterceptors ) ; \nfor ( List < InterceptorDescription > interceptors : this . methodLevelContainerInterceptors . values ( ) ) { \nthis . allContainerInterceptors . addAll ( interceptors ) ; \n} \n} \nreturn this . allContainerInterceptors ; \n} \n} \n"}
{"2695": "public class ApplicableMethodInformation { \npublic boolean isMethodLevel ( MethodIntf methodIntf , Method method , MethodIntf defaultMethodIntf ) { \nassert methodIntf != null : \"methodIntf is null\" ; \nassert method != null : \"method is null\" ; \nMethod classMethod = resolveRealMethod ( method ) ; \nString [ ] methodParams = MethodInfoHelper . getCanonicalParameterTypes ( classMethod ) ; \nfinal String methodName = classMethod . getName ( ) ; \nfinal String className = classMethod . getDeclaringClass ( ) . getName ( ) ; \nArrayKey methodParamsKey = new ArrayKey ( ( Object [ ] ) methodParams ) ; \nT attr = get ( get ( get ( perViewStyle3 , methodIntf ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) return true ; \nattr = get ( get ( perViewStyle2 , methodIntf ) , methodName ) ; \nif ( attr != null ) return true ; \nattr = get ( perViewStyle1 , methodIntf ) ; \nif ( attr != null ) return false ; \nattr = get ( get ( get ( style3 , className ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) return true ; \nattr = get ( style2 , methodName ) ; \nif ( attr != null ) return true ; \nattr = get ( style1 , className ) ; \nif ( attr != null ) return false ; \nif ( defaultMethodIntf == null ) return false ; \nelse return isMethodLevel ( defaultMethodIntf , method , null ) ; \n} \n} \n"}
{"2696": "public class MessagingSubsystemParser { \nprotected static void checkOnlyOneOfElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { \nif ( ! seen . contains ( element1 ) && ! seen . contains ( element2 ) ) throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . required ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \nif ( seen . contains ( element1 ) && seen . contains ( element2 ) ) throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \n} \n"}
{"2697": "public class AbstractConfigVisitorNode { \nprotected static Class < ? > getType ( ConfigVisitor visitor , String className ) { \nif ( className != null ) try { \nreturn visitor . getModule ( ) . getClassLoader ( ) . loadClass ( className ) ; \n} \ncatch ( Exception e ) { \nthrow new IllegalArgumentException ( e ) ; \n} \nreturn null ; \n} \n} \n"}
{"2699": "public class ElytronIntegrationResourceDefinitions { \npublic static ResourceDefinition getElytronKeyStoreResourceDefinition ( ) { \nfinal AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { \nLEGACY_JSSE_CONFIG } \n; \nfinal AbstractAddStepHandler addHandler = new BasicAddHandler < KeyStore > ( attributes , KEY_STORE_RUNTIME_CAPABILITY ) { \n@ Override protected BasicService . ValueSupplier < KeyStore > getValueSupplier ( ServiceBuilder < KeyStore > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { \nfinal String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; \nfinal InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; \nif ( legacyJSSEConfig != null ) serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; \nreturn ( ) -> { \nfinal SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; \nfinal JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; \nif ( jsseDomain == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; \nfinal KeyStore keyStore = jsseDomain . getKeyStore ( ) ; \nif ( keyStore == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"KeyStore\" , legacyJSSEConfig ) ; \nreturn keyStore ; \n} \n; \n} \n} \n; \nreturn new BasicResourceDefinition ( Constants . ELYTRON_KEY_STORE , addHandler , attributes , KEY_STORE_RUNTIME_CAPABILITY ) ; \n} \n} \n"}
{"2700": "public class ElytronIntegrationResourceDefinitions { \npublic static ResourceDefinition getElytronKeyManagersResourceDefinition ( ) { \nfinal AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { \nLEGACY_JSSE_CONFIG } \n; \nfinal AbstractAddStepHandler addHandler = new BasicAddHandler < KeyManager > ( attributes , KEY_MANAGER_RUNTIME_CAPABILITY ) { \n@ Override protected BasicService . ValueSupplier < KeyManager > getValueSupplier ( ServiceBuilder < KeyManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { \nfinal String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; \nfinal InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; \nif ( legacyJSSEConfig != null ) serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; \nreturn ( ) -> { \nfinal SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; \nfinal JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; \nif ( jsseDomain == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; \nfinal KeyManager [ ] keyManagers = jsseDomain . getKeyManagers ( ) ; \nif ( keyManagers == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"KeyManager\" , legacyJSSEConfig ) ; \nfor ( KeyManager keyManager : keyManagers ) { \nif ( keyManager instanceof X509ExtendedKeyManager ) return keyManager ; \n} \nthrow SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( \"KeyManager\" , X509ExtendedKeyManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; \n} \n; \n} \n} \n; \nreturn new BasicResourceDefinition ( Constants . ELYTRON_KEY_MANAGER , addHandler , attributes , KEY_MANAGER_RUNTIME_CAPABILITY ) ; \n} \n} \n"}
{"2701": "public class ElytronIntegrationResourceDefinitions { \npublic static ResourceDefinition getElytronTrustManagersResourceDefinition ( ) { \nfinal AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { \nLEGACY_JSSE_CONFIG } \n; \nfinal AbstractAddStepHandler addHandler = new BasicAddHandler < TrustManager > ( attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) { \n@ Override protected BasicService . ValueSupplier < TrustManager > getValueSupplier ( ServiceBuilder < TrustManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { \nfinal String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; \nfinal InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; \nif ( legacyJSSEConfig != null ) serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; \nreturn ( ) -> { \nfinal SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; \nfinal JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; \nif ( jsseDomain == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; \nfinal TrustManager [ ] trustManagers = jsseDomain . getTrustManagers ( ) ; \nif ( trustManagers == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"TrustManager\" , legacyJSSEConfig ) ; \nfor ( TrustManager trustManager : trustManagers ) { \nif ( trustManager instanceof X509ExtendedTrustManager ) return trustManager ; \n} \nthrow SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( \"TrustManager\" , X509ExtendedTrustManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; \n} \n; \n} \n} \n; \nreturn new BasicResourceDefinition ( Constants . ELYTRON_TRUST_MANAGER , addHandler , attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) if ( str . charAt ( i ) == compSeparator ) break ; \nelse if ( str . charAt ( i ) == escapeChar ) if ( i + 1 >= len ) throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) id [ idCount ++ ] = str . charAt ( i ++ ) ; \nelse kind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse if ( idMode ) id [ idCount ++ ] = str . charAt ( i ++ ) ; \nelse kind [ kindCount ++ ] = str . charAt ( i ++ ) ; \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) ++ i ; \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nint kindSep = - 1 ; \nint len = compStr . length ( ) ; \nint j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \nfor ( int i = 0 ; \ni < len && kindSep < 0 ; \ni ++ ) if ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) if ( i + 1 >= len ) throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) escaped = true ; \nelse throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \nelse if ( compStr . charAt ( i ) == kindSeparator ) kindSep = i ; \nelse newStr [ j ++ ] = compStr . charAt ( i ) ; \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( kindSep < 0 ) comp . kind = \"\" ; \nelse { \nj = 0 ; \nescaped = false ; \nfor ( int i = kindSep + 1 ; \ni < len ; \ni ++ ) if ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) if ( i + 1 >= len ) throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) escaped = true ; \nelse throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \nelse newStr [ j ++ ] = compStr . charAt ( i ) ; \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nreturn comp ; \n} \n} \n"}
{"2707": "public class ElytronSecurityManager { \nprivate SecurityIdentity authenticate ( final String username , final String password ) { \nServerAuthenticationContext context = this . securityDomain . createNewAuthenticationContext ( ) ; \nPasswordGuessEvidence evidence = null ; \ntry { \nif ( password == null ) if ( username == null ) if ( context . authorizeAnonymous ( ) ) { \ncontext . succeed ( ) ; \nreturn context . getAuthorizedIdentity ( ) ; \n} \nelse { \ncontext . fail ( ) ; \nreturn null ; \n} \nelse { \ncontext . fail ( ) ; \nreturn null ; \n} \ncontext . setAuthenticationName ( username ) ; \nevidence = new PasswordGuessEvidence ( password . toCharArray ( ) ) ; \nif ( context . verifyEvidence ( evidence ) ) if ( context . authorize ( ) ) { \ncontext . succeed ( ) ; \nreturn context . getAuthorizedIdentity ( ) ; \n} \nelse { \ncontext . fail ( ) ; \nMessagingLogger . ROOT_LOGGER . failedAuthorization ( username ) ; \n} \nelse { \ncontext . fail ( ) ; \nMessagingLogger . ROOT_LOGGER . failedAuthentication ( username ) ; \n} \n} \ncatch ( IllegalArgumentException | IllegalStateException | RealmUnavailableException e ) { \ncontext . fail ( ) ; \nMessagingLogger . ROOT_LOGGER . failedAuthenticationWithException ( e , username , e . getMessage ( ) ) ; \n} \nfinally { \nif ( evidence != null ) evidence . destroy ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2708": "public class GetDataSourceClassInfoOperationHandler { \nprivate static boolean isTypeMatched ( Class < ? > clz ) { \nif ( clz . equals ( String . class ) ) return true ; \nelse if ( clz . equals ( byte . class ) || clz . equals ( Byte . class ) ) return true ; \nelse if ( clz . equals ( short . class ) || clz . equals ( Short . class ) ) return true ; \nelse if ( clz . equals ( int . class ) || clz . equals ( Integer . class ) ) return true ; \nelse if ( clz . equals ( long . class ) || clz . equals ( Long . class ) ) return true ; \nelse if ( clz . equals ( float . class ) || clz . equals ( Float . class ) ) return true ; \nelse if ( clz . equals ( double . class ) || clz . equals ( Double . class ) ) return true ; \nelse if ( clz . equals ( boolean . class ) || clz . equals ( Boolean . class ) ) return true ; \nelse if ( clz . equals ( char . class ) || clz . equals ( Character . class ) ) return true ; \nelse if ( clz . equals ( InetAddress . class ) ) return true ; \nelse if ( clz . equals ( Class . class ) ) return true ; \nelse if ( clz . equals ( Properties . class ) ) return true ; \nreturn false ; \n} \n} \n"}
{"2709": "public class WildFlyBindingRegistry { \n@ Override public Object lookup ( String name ) { \nfinal ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; \nServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; \nif ( bindingService == null ) return null ; \nManagedReferenceFactory managedReferenceFactory = ManagedReferenceFactory . class . cast ( bindingService . getValue ( ) ) ; \nreturn managedReferenceFactory . getReference ( ) . getInstance ( ) ; \n} \n} \n"}
{"2710": "public class WildFlyBindingRegistry { \n@ Override public void unbind ( String name ) { \nif ( name == null || name . isEmpty ( ) ) throw MessagingLogger . ROOT_LOGGER . cannotUnbindJndiName ( ) ; \nfinal ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; \nServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; \nif ( bindingService == null ) { \nROOT_LOGGER . debugf ( \"Cannot unbind %s since no binding exists with that name\" , name ) ; \nreturn ; \n} \nbindingService . setMode ( ServiceController . Mode . REMOVE ) ; \nfinal StabilityMonitor monitor = new StabilityMonitor ( ) ; \nmonitor . addController ( bindingService ) ; \ntry { \nmonitor . awaitStability ( ) ; \nROOT_LOGGER . unboundJndiName ( bindInfo . getAbsoluteJndiName ( ) ) ; \n} \ncatch ( InterruptedException e ) { \nROOT_LOGGER . failedToUnbindJndiName ( name , 5 , SECONDS . toString ( ) . toLowerCase ( Locale . US ) ) ; \n} \nfinally { \nmonitor . removeController ( bindingService ) ; \n} \n} \n} \n"}
{"2714": "public class NamespaceContextSelector { \npublic static NamespaceContextSelector getCurrentSelector ( ) { \nNamespaceContextSelector selector = currentSelector . peek ( ) ; \nif ( selector != null ) return selector ; \nreturn defaultSelector ; \n} \n} \n"}
{"2717": "public class EEApplicationClasses { \npublic EEModuleClassDescription getClassByName ( String name ) { \nfor ( EEModuleDescription module : availableModules ) { \nfinal EEModuleClassDescription desc = module . getClassDescription ( name ) ; \nif ( desc != null ) return desc ; \n} \nreturn null ; \n} \n} \n"}
{"2718": "public class SessionBeanComponentDescriptionFactory { \n@ Override protected void processAnnotations ( final DeploymentUnit deploymentUnit , final CompositeIndex compositeIndex ) throws DeploymentUnitProcessingException { \nif ( MetadataCompleteMarker . isMetadataComplete ( deploymentUnit ) ) return ; \nfinal List < AnnotationInstance > slsbAnnotations = compositeIndex . getAnnotations ( STATELESS_ANNOTATION ) ; \nif ( ! slsbAnnotations . isEmpty ( ) ) processSessionBeans ( deploymentUnit , slsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATELESS ) ; \nfinal List < AnnotationInstance > sfsbAnnotations = compositeIndex . getAnnotations ( STATEFUL_ANNOTATION ) ; \nif ( ! sfsbAnnotations . isEmpty ( ) ) processSessionBeans ( deploymentUnit , sfsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATEFUL ) ; \nfinal List < AnnotationInstance > sbAnnotations = compositeIndex . getAnnotations ( SINGLETON_ANNOTATION ) ; \nif ( ! sbAnnotations . isEmpty ( ) ) processSessionBeans ( deploymentUnit , sbAnnotations , SessionBeanComponentDescription . SessionBeanType . SINGLETON ) ; \n} \n} \n"}
{"2719": "public class PersistenceUnitParseProcessor { \nprivate void postParseSteps ( final VirtualFile persistence_xml , final PersistenceUnitMetadataHolder puHolder , final DeploymentUnit deploymentUnit ) { \nfor ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { \nList < URL > jarfilesUrls = new ArrayList < URL > ( ) ; \nif ( pu . getJarFiles ( ) != null ) for ( String jar : pu . getJarFiles ( ) ) { \njarfilesUrls . add ( getRelativeURL ( persistence_xml , jar ) ) ; \n} \npu . setJarFileUrls ( jarfilesUrls ) ; \nURL url = getPersistenceUnitURL ( persistence_xml ) ; \npu . setPersistenceUnitRootUrl ( url ) ; \nString scopedPersistenceUnitName ; \nscopedPersistenceUnitName = Configuration . getScopedPersistenceUnitName ( pu ) ; \nif ( scopedPersistenceUnitName == null ) scopedPersistenceUnitName = createBeanName ( deploymentUnit , pu . getPersistenceUnitName ( ) ) ; \nelse { \nROOT_LOGGER . tracef ( \"persistence unit '%s' specified a custom scoped persistence unit name hint \" + \"(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments.\" , pu . getPersistenceUnitName ( ) , scopedPersistenceUnitName ) ; \nif ( scopedPersistenceUnitName . indexOf ( '/' ) != - 1 ) throw JpaLogger . ROOT_LOGGER . invalidScopedName ( scopedPersistenceUnitName , '/' ) ; \n} \npu . setScopedPersistenceUnitName ( scopedPersistenceUnitName ) ; \n} \n} \n} \n"}
{"2720": "public class DescriptorUtils { \npublic static String validateDescriptor ( String descriptor ) { \nif ( descriptor . length ( ) == 0 ) throw EeLogger . ROOT_LOGGER . cannotBeEmpty ( \"descriptors\" ) ; \nif ( descriptor . length ( ) > 1 ) if ( descriptor . startsWith ( \"L\" ) ) if ( ! descriptor . endsWith ( \";\" ) ) throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \nelse if ( descriptor . startsWith ( \"[\" ) ) { \n} \nelse throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \nelse { \nchar type = descriptor . charAt ( 0 ) ; \nswitch ( type ) { \ncase 'I' : case 'Z' : case 'S' : case 'B' : case 'F' : case 'D' : case 'V' : case 'J' : case 'C' : break ; \ndefault : throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nreturn descriptor ; \n} \n} \n"}
{"2721": "public class WebMetaDataCreator { \nvoid create ( final Deployment dep ) { \nfinal DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; \nWarMetaData warMD = ASHelper . getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; \nJBossWebMetaData jbossWebMD = warMD != null ? warMD . getMergedJBossWebMetaData ( ) : null ; \nif ( warMD == null ) warMD = new WarMetaData ( ) ; \nif ( jbossWebMD == null ) { \njbossWebMD = new JBossWebMetaData ( ) ; \nwarMD . setMergedJBossWebMetaData ( jbossWebMD ) ; \nunit . putAttachment ( WarMetaData . ATTACHMENT_KEY , warMD ) ; \n} \ncreateWebAppDescriptor ( dep , jbossWebMD ) ; \ncreateJBossWebAppDescriptor ( dep , jbossWebMD ) ; \ndep . addAttachment ( JBossWebMetaData . class , jbossWebMD ) ; \n} \n} \n"}
{"2723": "public class WebMetaDataCreator { \nprivate String getAuthMethod ( final Deployment dep ) { \nfor ( final Endpoint ejbEndpoint : dep . getService ( ) . getEndpoints ( ) ) { \nfinal String beanAuthMethod = ejb3SecurityAccessor . getAuthMethod ( ejbEndpoint ) ; \nfinal boolean hasBeanAuthMethod = beanAuthMethod != null ; \nif ( hasBeanAuthMethod ) return beanAuthMethod ; \n} \nreturn null ; \n} \n} \n"}
{"2724": "public class ServiceDeploymentParsingProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; \nif ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; \nVirtualFile serviceXmlFile = null ; \nif ( deploymentRoot . isDirectory ( ) ) serviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; \nelse if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) serviceXmlFile = deploymentRoot ; \nif ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; \nfinal XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; \nfinal JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; \nxmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nxmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nInputStream xmlStream = null ; \ntry { \nxmlStream = serviceXmlFile . openStream ( ) ; \nfinal XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; \nfinal ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; \nxmlMapper . parseDocument ( result , reader ) ; \nfinal JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; \nif ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \nelse throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; \n} \ncatch ( Exception e ) { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; \n} \nfinally { \nVFSUtils . safeClose ( xmlStream ) ; \n} \n} \n} \n"}
{"2726": "public class DynamicStubFactoryFactory { \npublic static Class < ? > makeStubClass ( final Class < ? > myClass ) { \nfinal String stubClassName = myClass + \"_Stub\" ; \nClassLoader cl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \nif ( cl == null ) cl = myClass . getClassLoader ( ) ; \nif ( cl == null ) throw EjbLogger . ROOT_LOGGER . couldNotFindClassLoaderForStub ( stubClassName ) ; \nClass < ? > theClass ; \ntry { \ntheClass = cl . loadClass ( stubClassName ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntry { \nfinal ClassFile clazz = IIOPStubCompiler . compile ( myClass , stubClassName ) ; \ntheClass = clazz . define ( cl , myClass . getProtectionDomain ( ) ) ; \n} \ncatch ( Throwable ex ) { \ntry { \ntheClass = cl . loadClass ( stubClassName ) ; \n} \ncatch ( ClassNotFoundException e1 ) { \nEjbLogger . ROOT_LOGGER . dynamicStubCreationFailed ( stubClassName , ex ) ; \nthrow ex ; \n} \n} \n} \nreturn theClass ; \n} \n} \n"}
{"2728": "public class PersistenceProviderResolverImpl { \n@ Override public List < PersistenceProvider > getPersistenceProviders ( ) { \nList < PersistenceProvider > providersCopy = new ArrayList < > ( providers . size ( ) ) ; \nsynchronized ( persistenceProviderPerClassLoader ) { \nif ( persistenceProviderPerClassLoader . size ( ) > 0 ) { \nClassLoader deploymentClassLoader = findParentModuleCl ( WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ) ; \nROOT_LOGGER . tracef ( \"get application level Persistence Provider for classloader %s\" , deploymentClassLoader ) ; \nList < Class < ? extends PersistenceProvider > > deploymentSpecificPersistenceProviders = persistenceProviderPerClassLoader . get ( deploymentClassLoader ) ; \nROOT_LOGGER . tracef ( \"got application level Persistence Provider list %s\" , deploymentSpecificPersistenceProviders ) ; \nif ( deploymentSpecificPersistenceProviders != null ) for ( Class < ? extends PersistenceProvider > providerClass : deploymentSpecificPersistenceProviders ) { \ntry { \nROOT_LOGGER . tracef ( \"application has its own Persistence Provider %s\" , providerClass . getName ( ) ) ; \nprovidersCopy . add ( providerClass . newInstance ( ) ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \n} \n} \n} \nfor ( Class < ? > providerClass : providers ) { \ntry { \nprovidersCopy . add ( ( PersistenceProvider ) providerClass . newInstance ( ) ) ; \nROOT_LOGGER . tracef ( \"returning global (module) Persistence Provider %s\" , providerClass . getName ( ) ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \n} \nreturn providersCopy ; \n} \n} \n"}
{"2731": "public class PersistenceProviderResolverImpl { \nprivate ClassLoader findParentModuleCl ( ClassLoader classLoader ) { \nClassLoader c = classLoader ; \nwhile ( c != null && ! ( c instanceof ModuleClassLoader ) ) c = c . getParent ( ) ; \nreturn c ; \n} \n} \n"}
{"2732": "public class SarModuleDependencyProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit . getAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY ) ; \nif ( serviceXmlDescriptor == null ) return ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_MODULES_ID , false , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_AS_SYSTEM_JMX_ID , true , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , PROPERTIES_EDITOR_MODULE_ID , false , false , true , false ) ) ; \nmoduleSpecification . addPermissionFactory ( REGISTER_PERMISSION_FACTORY ) ; \n} \n} \n"}
{"2733": "public class PersistenceUnitServiceHandler { \nprivate static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { \nif ( puList . size ( ) > 0 ) { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nfinal EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; \nfinal ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; \nfinal ModuleClassLoader classLoader = module . getClassLoader ( ) ; \nfor ( PersistenceUnitMetadataHolder holder : puList ) { \nsetAnnotationIndexes ( holder , deploymentUnit ) ; \nfor ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { \nString jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; \nboolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; \nif ( deployPU ) { \nfinal PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; \nfinal PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; \nfinal PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; \nfinal boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; \nif ( startEarly ) if ( twoPhaseBootStrapCapable ) deployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) ROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; \nelse { \nfinal boolean allowCdiBeanManagerAccess = false ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \nelse if ( twoPhaseBootStrapCapable ) deployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nfinal boolean allowCdiBeanManagerAccess = true ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \nelse ROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; \n} \n} \n} \n} \n} \n"}
{"2734": "public class PersistenceUnitServiceHandler { \nprivate static void setAnnotationIndexes ( final PersistenceUnitMetadataHolder puHolder , DeploymentUnit deploymentUnit ) { \nfinal Map < URL , Index > annotationIndexes = new HashMap < > ( ) ; \ndo { \nfor ( ResourceRoot root : DeploymentUtils . allResourceRoots ( deploymentUnit ) ) { \nfinal Index index = root . getAttachment ( Attachments . ANNOTATION_INDEX ) ; \nif ( index != null ) try { \nROOT_LOGGER . tracef ( \"adding '%s' to annotation index map\" , root . getRoot ( ) . toURL ( ) ) ; \nannotationIndexes . put ( root . getRoot ( ) . toURL ( ) , index ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \ndeploymentUnit = deploymentUnit . getParent ( ) ; \n} \nwhile ( deploymentUnit != null ) ; \nfor ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { \npu . setAnnotationIndex ( annotationIndexes ) ; \n} \n} \n} \n"}
{"2735": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProviderAdaptor getPersistenceProviderAdaptor ( final PersistenceUnitMetadata pu , final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , final DeploymentUnit deploymentUnit , final PersistenceProvider provider , final Platform platform ) throws DeploymentUnitProcessingException { \nString adapterClass = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_CLASS ) ; \nif ( persistenceProviderDeploymentHolder != null && adapterClass != null ) { \nList < PersistenceProviderAdaptor > persistenceProviderAdaptors = persistenceProviderDeploymentHolder . getAdapters ( ) ; \nfor ( PersistenceProviderAdaptor persistenceProviderAdaptor : persistenceProviderAdaptors ) { \nif ( adapterClass . equals ( persistenceProviderAdaptor . getClass ( ) . getName ( ) ) ) return persistenceProviderAdaptor ; \n} \n} \nString adaptorModule = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_MODULE ) ; \nPersistenceProviderAdaptor adaptor ; \nadaptor = getPerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , provider ) ; \nif ( adaptor == null ) { \ntry { \nif ( adaptorModule != null ) adaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapterModule ( adaptorModule , platform , createManager ( deploymentUnit ) ) ; \nelse adaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapter ( provider , platform , createManager ( deploymentUnit ) ) ; \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . persistenceProviderAdaptorModuleLoadError ( e , adaptorModule ) ; \n} \nadaptor = savePerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , adaptor , provider ) ; \n} \nif ( adaptor == null ) throw JpaLogger . ROOT_LOGGER . failedToGetAdapter ( pu . getPersistenceProviderClassName ( ) ) ; \nreturn adaptor ; \n} \n} \n"}
{"2736": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor ( DeploymentUnit deploymentUnit , String adaptorModule , PersistenceProviderAdaptor adaptor , PersistenceProvider provider ) { \nif ( deploymentUnit . getParent ( ) != null ) deploymentUnit = deploymentUnit . getParent ( ) ; \nsynchronized ( deploymentUnit ) { \nMap < String , PersistenceProviderAdaptor > map = deploymentUnit . getAttachment ( providerAdaptorMapKey ) ; \nString key ; \nif ( adaptorModule != null ) key = adaptorModule ; \nelse key = provider . getClass ( ) . getName ( ) ; \nPersistenceProviderAdaptor current = map . get ( key ) ; \nif ( current == null ) { \nmap . put ( key , adaptor ) ; \ncurrent = adaptor ; \n} \nreturn current ; \n} \n} \n} \n"}
{"2737": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProvider lookupProvider ( PersistenceUnitMetadata pu , PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { \nMap < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; \nif ( providerMap != null ) synchronized ( providerMap ) { \nif ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { \nROOT_LOGGER . tracef ( \"deployment %s is using %s\" , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; \nreturn providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; \n} \n} \nString configuredPersistenceProviderModule = pu . getProperties ( ) . getProperty ( Configuration . PROVIDER_MODULE ) ; \nString persistenceProviderClassName = pu . getPersistenceProviderClassName ( ) ; \nif ( persistenceProviderClassName == null ) persistenceProviderClassName = Configuration . PROVIDER_CLASS_DEFAULT ; \nif ( configuredPersistenceProviderModule != null ) { \nList < PersistenceProvider > providers ; \nif ( Configuration . PROVIDER_MODULE_APPLICATION_SUPPLIED . equals ( configuredPersistenceProviderModule ) ) try { \nfinal ModuleClassLoader classLoader = deploymentUnit . getAttachment ( Attachments . MODULE ) . getClassLoader ( ) ; \nPersistenceProvider provider = PersistenceProviderLoader . loadProviderFromDeployment ( classLoader , persistenceProviderClassName ) ; \nproviders = new ArrayList < > ( ) ; \nproviders . add ( provider ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nreturn provider ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \nelse try { \nproviders = PersistenceProviderLoader . loadProviderModuleByName ( configuredPersistenceProviderModule ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nPersistenceProvider provider = getProviderByName ( pu , providers ) ; \nif ( provider != null ) return provider ; \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , configuredPersistenceProviderModule , persistenceProviderClassName ) ; \n} \n} \nString providerNameDerivedFromClassName = Configuration . getProviderModuleNameFromProviderClassName ( persistenceProviderClassName ) ; \nPersistenceProvider provider = getProviderByName ( pu ) ; \nif ( provider == null && providerNameDerivedFromClassName != null ) try { \nList < PersistenceProvider > providers = PersistenceProviderLoader . loadProviderModuleByName ( providerNameDerivedFromClassName ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nprovider = getProviderByName ( pu , providers ) ; \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , providerNameDerivedFromClassName , persistenceProviderClassName ) ; \n} \nif ( provider == null ) throw JpaLogger . ROOT_LOGGER . persistenceProviderNotFound ( persistenceProviderClassName ) ; \nreturn provider ; \n} \n} \n"}
{"2739": "public class AbstractMetaDataBuilderEJB { \nfinal EJBArchiveMetaData create ( final Deployment dep ) { \nif ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) WSLogger . ROOT_LOGGER . tracef ( \"Building JBoss agnostic meta data for EJB webservice deployment: %s\" , dep . getSimpleName ( ) ) ; \nfinal EJBArchiveMetaData . Builder ejbArchiveMDBuilder = new EJBArchiveMetaData . Builder ( ) ; \nthis . buildEnterpriseBeansMetaData ( dep , ejbArchiveMDBuilder ) ; \nthis . buildWebservicesMetaData ( dep , ejbArchiveMDBuilder ) ; \nreturn ejbArchiveMDBuilder . build ( ) ; \n} \n} \n"}
{"2742": "public class WorkCacheManager { \nContainerAnalysis getAnalysis ( final Class cls ) throws RMIIIOPViolationException { \nContainerAnalysis ret = null ; \nboolean created = false ; \ntry { \nsynchronized ( this ) { \nret = lookupDone ( cls ) ; \nif ( ret != null ) return ret ; \nfinal ContainerAnalysis inProgress = workInProgress . get ( new InProgressKey ( cls , Thread . currentThread ( ) ) ) ; \nif ( inProgress != null ) return inProgress ; \nret = createWorkInProgress ( cls ) ; \n} \ncreated = true ; \ndoTheWork ( cls , ret ) ; \n} \nfinally { \nsynchronized ( this ) { \nif ( created ) { \nworkInProgress . remove ( new InProgressKey ( cls , Thread . currentThread ( ) ) ) ; \nworkDone . put ( cls , new SoftReference < ContainerAnalysis > ( ret ) ) ; \nClassLoader classLoader = cls . getClassLoader ( ) ; \nif ( classLoader != null ) { \nSet < Class < ? > > classes = classesByLoader . get ( classLoader ) ; \nif ( classes == null ) classesByLoader . put ( classLoader , classes = new HashSet < Class < ? > > ( ) ) ; \nclasses . add ( cls ) ; \n} \n} \nnotifyAll ( ) ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) s = s . substring ( 1 ) ; \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) s = s . substring ( idx + 3 ) ; \nelse s = s . substring ( idx + 2 ) ; \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( int j = 0 ; \nj < i ; \n++ j ) if ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nif ( ! clash [ i ] ) continue ; \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( int j = 0 ; \nj < name . length ( ) ; \n++ j ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; \nif ( noUpper ) noUpper = false ; \nelse b . append ( '_' ) ; \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2757": "public class XTSSubsystemParser { \nprivate void parseDefaultContextPropagationElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { \nprocessAttributes ( reader , ( index , attribute ) -> { \nfinal String value = reader . getAttributeValue ( index ) ; \nswitch ( attribute ) { \ncase ENABLED : if ( value == null || ( ! value . toLowerCase ( ) . equals ( \"true\" ) && ! value . toLowerCase ( ) . equals ( \"false\" ) ) ) throw ParseUtils . invalidAttributeValue ( reader , index ) ; \nDEFAULT_CONTEXT_PROPAGATION . parseAndSetParameter ( value , subsystem , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , index ) ; \n} \n} \n) ; \nParseUtils . requireNoContent ( reader ) ; \n} \n} \n"}
{"2759": "public class PersistenceProviderLoader { \npublic static List < PersistenceProvider > loadProviderModuleByName ( String moduleName ) throws ModuleLoadException { \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nModule module = moduleLoader . loadModule ( ModuleIdentifier . fromString ( moduleName ) ) ; \nfinal ServiceLoader < PersistenceProvider > serviceLoader = module . loadService ( PersistenceProvider . class ) ; \nList < PersistenceProvider > result = new ArrayList < > ( ) ; \nif ( serviceLoader != null ) for ( PersistenceProvider provider1 : serviceLoader ) { \nPersistenceProviderResolverImpl . getInstance ( ) . addPersistenceProvider ( provider1 ) ; \nresult . add ( provider1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"2760": "public class ManagementHelper { \nstatic AbstractAddStepHandler createAddOperation ( final String childType , final boolean allowSibling , Collection < ? extends AttributeDefinition > attributes ) { \nreturn new ActiveMQReloadRequiredHandlers . AddStepHandler ( attributes ) { \n@ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { \nsuper . execute ( context , operation ) ; \nif ( ! allowSibling ) context . addStep ( checkNoOtherSibling ( childType ) , MODEL ) ; \n} \n} \n; \n} \n} \n"}
{"2761": "public class EjbDependencyDeploymentUnitProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nDeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , JAX_RPC_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_NAMING_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_IIOP_CLIENT , false , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_SUBSYSTEM , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_EJB , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_NAMING , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_TRANSACTION , false , false , true , false ) ) ; \nif ( IIOPDeploymentMarker . isIIOPDeployment ( deploymentUnit ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , IIOP_OPENJDK , false , false , false , false ) ) ; \nif ( ! isEjbDeployment ( deploymentUnit ) && ! DeploymentTypeMarker . isType ( DeploymentType . APPLICATION_CLIENT , deploymentUnit ) ) return ; \nif ( Boolean . getBoolean ( \"org.jboss.as.ejb3.EMBEDDED\" ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . CLASSPATH , false , false , false , false ) ) ; \n} \n} \n"}
{"2763": "public class MethodIntfHelper { \npublic static MethodIntf of ( final InterceptorContext invocation ) { \nMethodIntf methodIntf = invocation . getPrivateData ( MethodIntf . class ) ; \nif ( methodIntf == null ) { \nfinal ComponentView componentView = invocation . getPrivateData ( ComponentView . class ) ; \nif ( componentView != null ) methodIntf = componentView . getPrivateData ( MethodIntf . class ) ; \nelse methodIntf = MethodIntf . BEAN ; \n} \nreturn methodIntf ; \n} \n} \n"}
{"2764": "public class StatefulSessionComponent { \npublic SessionID createSessionRemote ( ) { \nControlPoint controlPoint = getControlPoint ( ) ; \nif ( controlPoint == null ) return createSession ( ) ; \nelse try { \nRunResult result = controlPoint . beginRequest ( ) ; \nif ( result == RunResult . REJECTED ) throw EjbLogger . ROOT_LOGGER . containerSuspended ( ) ; \ntry { \nreturn createSession ( ) ; \n} \nfinally { \ncontrolPoint . requestComplete ( ) ; \n} \n} \ncatch ( EJBComponentUnavailableException | ComponentIsStoppedException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nthrow new EJBException ( e ) ; \n} \n} \n} \n"}
{"2765": "public class JMSServerControlHandler { \nprivate String inferDestinationName ( String address ) { \nif ( address . startsWith ( JMS_QUEUE_PREFIX ) ) return address . substring ( JMS_QUEUE_PREFIX . length ( ) ) ; \nelse if ( address . startsWith ( JMS_TOPIC_PREFIX ) ) return address . substring ( JMS_TOPIC_PREFIX . length ( ) ) ; \nelse return address ; \n} \n} \n"}
{"2766": "public class WSEndpointHandlersMapping { \npublic void registerEndpointHandlers ( final String endpointClass , final Set < String > endpointHandlers ) { \nif ( ( endpointClass == null ) || ( endpointHandlers == null ) ) throw new IllegalArgumentException ( ) ; \nendpointHandlersMap . put ( endpointClass , Collections . unmodifiableSet ( endpointHandlers ) ) ; \n} \n} \n"}
{"2767": "public class WildFlyJobXmlResolver { \nSet < String > getJobXmlNames ( final String jobName ) { \nif ( jobNames . containsKey ( jobName ) ) return Collections . unmodifiableSet ( jobNames . get ( jobName ) ) ; \nreturn Collections . emptySet ( ) ; \n} \n} \n"}
{"2769": "public class JbossAuthorizationManager { \nprotected String requestURI ( HttpServerExchange request ) { \nString uri = request . getRelativePath ( ) ; \nif ( uri == null || uri . equals ( \"/\" ) ) uri = \"\" ; \nreturn uri ; \n} \n} \n"}
{"2770": "public class CNCtx { \npublic static ResolveResult createUsingURL ( String url , Hashtable env ) throws NamingException { \nCNCtx ctx = new CNCtx ( ) ; \nif ( env != null ) env = ( Hashtable ) env . clone ( ) ; \nctx . _env = env ; \nString rest = ctx . initUsingUrl ( env != null ? ( org . omg . CORBA . ORB ) env . get ( \"java.naming.corba.orb\" ) : null , url , env ) ; \nreturn new ResolveResult ( ctx , parser . parse ( rest ) ) ; \n} \n} \n"}
{"2773": "public class CNCtx { \nprivate void callUnbind ( NameComponent [ ] path ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; \ntry { \n_nc . unbind ( path ) ; \n} \ncatch ( NotFound e ) { \nif ( leafNotFound ( e , path [ path . length - 1 ] ) ) { \n} \nelse throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \n} \n} \n"}
{"2774": "public class CNCtx { \npublic NamingEnumeration listBindings ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nif ( name . size ( ) > 0 ) try { \njava . lang . Object obj = lookup ( name ) ; \nif ( obj instanceof CNCtx ) return new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; \nelse throw new NotContextException ( name . toString ( ) ) ; \n} \ncatch ( NamingException ne ) { \nthrow ne ; \n} \ncatch ( BAD_PARAM e ) { \nNamingException ne = new NotContextException ( name . toString ( ) ) ; \nne . setRootCause ( e ) ; \nthrow ne ; \n} \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( this , false , _env ) ; \n} \n} \n"}
{"2776": "public class CNCtx { \npublic void destroySubcontext ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nNamingContext the_nc = _nc ; \nNameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; \nif ( name . size ( ) > 0 ) try { \njavax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; \nCNCtx cnc = ( CNCtx ) ctx ; \nthe_nc = cnc . _nc ; \ncnc . close ( ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \ncatch ( CannotProceedException e ) { \njavax . naming . Context cctx = getContinuationContext ( e ) ; \ncctx . destroySubcontext ( e . getRemainingName ( ) ) ; \nreturn ; \n} \ncatch ( NameNotFoundException e ) { \nif ( e . getRootCause ( ) instanceof NotFound && leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) return ; \nthrow e ; \n} \ncatch ( NamingException e ) { \nthrow e ; \n} \ncallDestroy ( the_nc ) ; \ncallUnbind ( path ) ; \n} \n} \n"}
{"2780": "public class CNCtx { \npublic java . lang . Object addToEnvironment ( String propName , java . lang . Object propValue ) throws NamingException { \nif ( _env == null ) _env = new Hashtable ( 7 , 0.75f ) ; \nelse _env = ( Hashtable ) _env . clone ( ) ; \nreturn _env . put ( propName , propValue ) ; \n} \n} \n"}
{"2782": "public class AbstractProtocolResourceDefinition { \n@ SuppressWarnings ( \"deprecation\" ) static void addTransformations ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { \nif ( JGroupsModel . VERSION_5_0_0 . requiresTransformation ( version ) ) builder . getAttributeBuilder ( ) . setDiscard ( DiscardAttributeChecker . UNDEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . end ( ) ; \nif ( JGroupsModel . VERSION_3_0_0 . requiresTransformation ( version ) ) { \nAttributeConverter typeConverter = new AttributeConverter . DefaultAttributeConverter ( ) { \n@ Override protected void convertAttribute ( PathAddress address , String name , ModelNode value , TransformationContext context ) { \nif ( ! value . isDefined ( ) ) value . set ( address . getLastElement ( ) . getValue ( ) ) ; \n} \n} \n; \nbuilder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( Attribute . MODULE . getDefinition ( ) . getDefaultValue ( ) ) , Attribute . MODULE . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . MODULE . getDefinition ( ) ) . setValueConverter ( typeConverter , DeprecatedAttribute . TYPE . getDefinition ( ) ) . end ( ) ; \nbuilder . addRawOperationTransformationOverride ( MapOperations . MAP_GET_DEFINITION . getName ( ) , new SimpleOperationTransformer ( new LegacyPropertyMapGetOperationTransformer ( ) ) ) ; \nfor ( String opName : Operations . getAllWriteAttributeOperationNames ( ) ) { \nbuilder . addOperationTransformationOverride ( opName ) . inheritResourceAttributeDefinitions ( ) . setCustomOperationTransformer ( new LegacyPropertyWriteOperationTransformer ( ) ) ; \n} \n} \nPropertyResourceDefinition . buildTransformation ( version , builder ) ; \n} \n} \n"}
{"2783": "public class DsXmlParser { \n@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { \nString userName = null ; \nString password = null ; \nString securityDomain = null ; \nboolean elytronEnabled = false ; \nString authenticationContext = null ; \nwhile ( reader . hasNext ( ) ) switch ( reader . nextTag ( ) ) { \ncase END_ELEMENT : { \nif ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) return new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; \nelse if ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) throw new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; \nbreak ; \n} \ncase START_ELEMENT : { \nswitch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { \ncase PASSWORD : { \npassword = elementAsString ( reader ) ; \nif ( propertyResolver != null && password != null ) { \nString resolvedPassword = propertyResolver . resolve ( password ) ; \nif ( resolvedPassword != null ) password = resolvedPassword ; \n} \nbreak ; \n} \ncase USER_NAME : { \nuserName = elementAsString ( reader ) ; \nbreak ; \n} \ncase SECURITY_DOMAIN : { \nsecurityDomain = elementAsString ( reader ) ; \nbreak ; \n} \ncase ELYTRON_ENABLED : { \nBoolean value = elementAsBoolean ( reader ) ; \nelytronEnabled = value == null ? true : value ; \nbreak ; \n} \ncase AUTHENTICATION_CONTEXT : { \nauthenticationContext = elementAsString ( reader ) ; \nbreak ; \n} \ndefault : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \n} \nthrow new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; \n} \n} \n"}
{"2789": "public class IDLTypeImpl { \nstatic LocalIDLType getIDLType ( TypeCode typeCode , RepositoryImpl repository ) { \nTCKind tcKind = typeCode . kind ( ) ; \nif ( PrimitiveDefImpl . isPrimitiveTCKind ( tcKind ) ) return new PrimitiveDefImpl ( typeCode , repository ) ; \nif ( tcKind == TCKind . tk_sequence ) return repository . getSequenceImpl ( typeCode ) ; \nif ( tcKind == TCKind . tk_value || tcKind == TCKind . tk_value_box || tcKind == TCKind . tk_alias || tcKind == TCKind . tk_struct || tcKind == TCKind . tk_union || tcKind == TCKind . tk_enum || tcKind == TCKind . tk_objref ) try { \nreturn ( LocalIDLType ) repository . _lookup_id ( typeCode . id ( ) ) ; \n} \ncatch ( BadKind ex ) { \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \n} \n"}
{"2790": "public class SecurityDomainResourceDefinition { \nprivate static void waitForService ( final ServiceController < ? > controller ) throws OperationFailedException { \nif ( controller . getState ( ) == ServiceController . State . UP ) return ; \nfinal StabilityMonitor monitor = new StabilityMonitor ( ) ; \nmonitor . addController ( controller ) ; \ntry { \nmonitor . awaitStability ( 100 , MILLISECONDS ) ; \n} \ncatch ( final InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow SecurityLogger . ROOT_LOGGER . interruptedWaitingForSecurityDomain ( controller . getName ( ) . getSimpleName ( ) ) ; \n} \nfinally { \nmonitor . removeController ( controller ) ; \n} \nif ( controller . getState ( ) != ServiceController . State . UP ) throw SecurityLogger . ROOT_LOGGER . requiredSecurityDomainServiceNotAvailable ( controller . getName ( ) . getSimpleName ( ) ) ; \n} \n} \n"}
{"2793": "public class VaultSession { \npublic void startVaultSession ( String vaultAlias ) throws Exception { \nif ( vaultAlias == null ) throw SecurityLogger . ROOT_LOGGER . vaultAliasNotSpecified ( ) ; \nthis . keystoreMaskedPassword = ( org . jboss . security . Util . isPasswordCommand ( keystorePassword ) ) ? keystorePassword : computeMaskedPassword ( ) ; \nthis . vaultAlias = vaultAlias ; \ninitSecurityVault ( ) ; \n} \n} \n"}
{"2798": "public class ConnectorServices { \npublic static synchronized ServiceName getDeploymentServiceName ( final String raName , final Activation raxml ) { \nif ( raName == null ) throw ConnectorLogger . ROOT_LOGGER . undefinedVar ( \"RaName\" ) ; \nServiceName serviceName = null ; \nModifiableResourceAdapter ra = ( ModifiableResourceAdapter ) raxml ; \nif ( ra != null && ra . getId ( ) != null ) serviceName = getDeploymentServiceName ( raName , ra . getId ( ) ) ; \nelse serviceName = getDeploymentServiceName ( raName , ( String ) null ) ; \nROOT_LOGGER . tracef ( \"ConnectorServices: getDeploymentServiceName(%s,%s) -> %s\" , raName , raxml , serviceName ) ; \nreturn serviceName ; \n} \n} \n"}
{"2801": "public class JndiPermission { \npublic String getActions ( ) { \nfinal String actionString = this . actionString ; \nif ( actionString != null ) return actionString ; \nint actionBits = this . actionBits ; \nif ( actionBits == ACTION_ALL ) return this . actionString = \"*\" ; \nint m = Integer . lowestOneBit ( actionBits ) ; \nif ( m != 0 ) { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \nwhile ( actionBits != 0 ) { \nm = Integer . lowestOneBit ( actionBits ) ; \nb . append ( ',' ) . append ( getAction ( m ) ) ; \nactionBits &= ~ m ; \n} \nreturn this . actionString = b . toString ( ) ; \n} \nelse return this . actionString = \"\" ; \n} \n} \n"}
{"2804": "public class RemoteToCorba { \npublic Object getStateToBind ( Object orig , Name name , Context ctx , Hashtable < ? , ? > env ) throws NamingException { \nif ( orig instanceof org . omg . CORBA . Object ) return null ; \nif ( orig instanceof Remote ) try { \nreturn CorbaUtils . remoteToCorba ( ( Remote ) orig , ( ( CNCtx ) ctx ) . _orb ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow IIOPLogger . ROOT_LOGGER . unavailableRMIPackages ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2805": "public class ValueConfig { \npublic Object getValue ( Type type ) { \nif ( type == null || ( type instanceof Class ) ) return getClassValue ( ( Class ) type ) ; \nelse if ( type instanceof ParameterizedType ) { \nParameterizedType pt = ( ParameterizedType ) type ; \nreturn getPtValue ( pt ) ; \n} \nelse throw PojoLogger . ROOT_LOGGER . unknownType ( type ) ; \n} \n} \n"}
{"2806": "public class ComponentDescription { \npublic ServiceName getContextServiceName ( ) { \nif ( contextServiceName != null ) return contextServiceName ; \nif ( getNamingMode ( ) == ComponentNamingMode . CREATE ) return ContextNames . contextServiceNameOfComponent ( getApplicationName ( ) , getModuleName ( ) , getComponentName ( ) ) ; \nelse if ( getNamingMode ( ) == ComponentNamingMode . USE_MODULE ) return ContextNames . contextServiceNameOfModule ( getApplicationName ( ) , getModuleName ( ) ) ; \nelse throw new IllegalStateException ( ) ; \n} \n} \n"}
{"2807": "public class ComponentDescription { \npublic Set < InterceptorDescription > getAllInterceptors ( ) { \nif ( allInterceptors == null ) { \nallInterceptors = new HashSet < InterceptorDescription > ( ) ; \nallInterceptors . addAll ( classInterceptors ) ; \nif ( ! excludeDefaultInterceptors ) allInterceptors . addAll ( defaultInterceptors ) ; \nfor ( List < InterceptorDescription > interceptors : methodInterceptors . values ( ) ) { \nallInterceptors . addAll ( interceptors ) ; \n} \n} \nreturn allInterceptors ; \n} \n} \n"}
{"2808": "public class ComponentDescription { \npublic void addMethodInterceptor ( MethodIdentifier method , InterceptorDescription description ) { \nList < InterceptorDescription > interceptors = methodInterceptors . get ( method ) ; \nif ( interceptors == null ) methodInterceptors . put ( method , interceptors = new ArrayList < InterceptorDescription > ( ) ) ; \nfinal String name = description . getInterceptorClassName ( ) ; \ninterceptors . add ( description ) ; \nthis . allInterceptors = null ; \n} \n} \n"}
{"2809": "public class ComponentDescription { \npublic void addDependency ( ServiceName serviceName ) { \nif ( serviceName == null ) throw EeLogger . ROOT_LOGGER . nullVar ( \"serviceName\" , \"component\" , componentName ) ; \ndependencies . add ( serviceName ) ; \n} \n} \n"}
{"2810": "public class ComponentConfiguration { \npublic List < InterceptorFactory > getComponentInterceptors ( Method method ) { \nMap < Method , OrderedItemContainer < List < InterceptorFactory > > > map = componentInterceptors ; \nOrderedItemContainer < List < InterceptorFactory > > interceptors = map . get ( method ) ; \nif ( interceptors == null ) return Collections . emptyList ( ) ; \nList < List < InterceptorFactory > > sortedItems = interceptors . getSortedItems ( ) ; \nList < InterceptorFactory > ret = new ArrayList < > ( ) ; \nfor ( List < InterceptorFactory > item : sortedItems ) { \nret . addAll ( item ) ; \n} \nreturn ret ; \n} \n} \n"}
{"2811": "public class ComponentConfiguration { \npublic List < InterceptorFactory > getAroundTimeoutInterceptors ( Method method ) { \nMap < Method , OrderedItemContainer < InterceptorFactory > > map = timeoutInterceptors ; \nOrderedItemContainer < InterceptorFactory > interceptors = map . get ( method ) ; \nif ( interceptors == null ) return Collections . emptyList ( ) ; \nreturn interceptors . getSortedItems ( ) ; \n} \n} \n"}
{"2812": "public class ComponentConfiguration { \npublic void addTimeoutViewInterceptor ( final Method method , InterceptorFactory factory , int priority ) { \nOrderedItemContainer < InterceptorFactory > interceptors = timeoutInterceptors . get ( method ) ; \nif ( interceptors == null ) timeoutInterceptors . put ( method , interceptors = new OrderedItemContainer < InterceptorFactory > ( ) ) ; \ninterceptors . add ( factory , priority ) ; \n} \n} \n"}
{"2818": "public class ComponentConfiguration { \npublic void setComponentCreateServiceFactory ( final ComponentCreateServiceFactory componentCreateServiceFactory ) { \nif ( componentCreateServiceFactory == null ) throw EeLogger . ROOT_LOGGER . nullVar ( \"componentCreateServiceFactory\" , \"component\" , getComponentName ( ) ) ; \nthis . componentCreateServiceFactory = componentCreateServiceFactory ; \n} \n} \n"}
{"2819": "public class PooledConnectionFactoryRemove { \nprotected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { \nif ( entries . size ( ) > 1 ) for ( int i = 1 ; \ni < entries . size ( ) ; \ni ++ ) { \nContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; \ncontext . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; \n} \n} \n} \n"}
{"2823": "public class ContextNames { \npublic static BindInfo bindInfoForEnvEntry ( String app , String module , String comp , boolean useCompNamespace , final String envEntryName ) { \nif ( envEntryName . startsWith ( \"java:\" ) ) if ( useCompNamespace ) return bindInfoFor ( app , module , comp , envEntryName ) ; \nelse if ( envEntryName . startsWith ( \"java:comp\" ) ) return bindInfoFor ( app , module , module , \"java:module\" + envEntryName . substring ( \"java:comp\" . length ( ) ) ) ; \nelse return bindInfoFor ( app , module , module , envEntryName ) ; \nelse if ( useCompNamespace ) return bindInfoFor ( app , module , comp , \"java:comp/env/\" + envEntryName ) ; \nelse return bindInfoFor ( app , module , module , \"java:module/env/\" + envEntryName ) ; \n} \n} \n"}
{"2824": "public class ContextNames { \npublic static BindInfo bindInfoFor ( final String jndiName ) { \nString bindName ; \nif ( jndiName . startsWith ( \"java:\" ) ) bindName = jndiName . substring ( 5 ) ; \nelse if ( ! jndiName . startsWith ( \"jboss\" ) && ! jndiName . startsWith ( \"global\" ) && ! jndiName . startsWith ( \"/\" ) ) bindName = \"/\" + jndiName ; \nelse bindName = jndiName ; \nfinal ServiceName parentContextName ; \nif ( bindName . startsWith ( \"jboss/exported/\" ) ) { \nparentContextName = EXPORTED_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 15 ) ; \n} \nelse if ( bindName . startsWith ( \"jboss/\" ) ) { \nparentContextName = JBOSS_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 6 ) ; \n} \nelse if ( bindName . startsWith ( \"global/\" ) ) { \nparentContextName = GLOBAL_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 7 ) ; \n} \nelse if ( bindName . startsWith ( \"/\" ) ) { \nparentContextName = JAVA_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 1 ) ; \n} \nelse throw NamingLogger . ROOT_LOGGER . illegalContextInName ( jndiName ) ; \nreturn new BindInfo ( parentContextName , bindName ) ; \n} \n} \n"}
{"2825": "public class DefaultAuthenticationCacheFactory { \npublic ConcurrentMap < Principal , DomainInfo > getCache ( ) { \nreturn new LRUCache < > ( 1000 , ( key , value ) -> { \nif ( value != null ) value . logout ( ) ; \n} \n) ; \n} \n} \n"}
{"2829": "public class AbstractFederationSubsystemReader { \nprotected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { \nif ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) return null ; \nModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; \nint attributeCount = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeCount ; \ni ++ ) { \nString attributeLocalName = reader . getAttributeLocalName ( i ) ; \nif ( ModelElement . forName ( attributeLocalName ) == null ) throw unexpectedAttribute ( reader , i ) ; \n} \nfor ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { \nString attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; \nsimpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; \n} \nString name = xmlElement . getName ( ) ; \nif ( key != null ) { \nname = key ; \nif ( modelNode . hasDefined ( key ) ) name = modelNode . get ( key ) . asString ( ) ; \nelse { \nString attributeValue = reader . getAttributeValue ( \"\" , key ) ; \nif ( attributeValue != null ) name = attributeValue ; \n} \n} \nmodelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; \naddOperations . add ( modelNode ) ; \nreturn modelNode ; \n} \n} \n"}
{"2831": "public class WeldComponentIntegrationProcessor { \nprivate void addWeldIntegration ( final Iterable < ComponentIntegrator > componentIntegrators , final ComponentInterceptorSupport componentInterceptorSupport , final ServiceTarget target , final ComponentConfiguration configuration , final ComponentDescription description , final Class < ? > componentClass , final String beanName , final ServiceName weldServiceName , final ServiceName weldStartService , final ServiceName beanManagerService , final Set < Class < ? > > interceptorClasses , final ClassLoader classLoader , final String beanDeploymentArchiveId ) { \nfinal ServiceName serviceName = configuration . getComponentDescription ( ) . getServiceName ( ) . append ( \"WeldInstantiator\" ) ; \nfinal ServiceBuilder < ? > builder = target . addService ( serviceName ) ; \nbuilder . requires ( weldStartService ) ; \nconfiguration . setInstanceFactory ( WeldManagedReferenceFactory . INSTANCE ) ; \nconfiguration . getStartDependencies ( ) . add ( new DependencyConfigurator < ComponentStartService > ( ) { \n@ Override public void configureDependency ( final ServiceBuilder < ? > serviceBuilder , ComponentStartService service ) throws DeploymentUnitProcessingException { \nserviceBuilder . requires ( serviceName ) ; \n} \n} \n) ; \nboolean isComponentIntegrationPerformed = false ; \nfor ( ComponentIntegrator componentIntegrator : componentIntegrators ) { \nSupplier < ServiceName > bindingServiceNameSupplier = ( ) -> { \nif ( componentInterceptorSupport == null ) throw WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; \nreturn addWeldInterceptorBindingService ( target , configuration , componentClass , beanName , weldServiceName , weldStartService , beanDeploymentArchiveId , componentInterceptorSupport ) ; \n} \n; \nDefaultInterceptorIntegrationAction integrationAction = ( bindingServiceName ) -> { \nif ( componentInterceptorSupport == null ) throw WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; \naddJsr299BindingsCreateInterceptor ( configuration , description , beanName , weldServiceName , builder , bindingServiceName , componentInterceptorSupport ) ; \naddCommonLifecycleInterceptionSupport ( configuration , builder , bindingServiceName , beanManagerService , componentInterceptorSupport ) ; \nconfiguration . addComponentInterceptor ( new UserInterceptorFactory ( factory ( InterceptionType . AROUND_INVOKE , builder , bindingServiceName , componentInterceptorSupport ) , factory ( InterceptionType . AROUND_TIMEOUT , builder , bindingServiceName , componentInterceptorSupport ) ) , InterceptorOrder . Component . CDI_INTERCEPTORS , false ) ; \n} \n; \nif ( componentIntegrator . integrate ( beanManagerService , configuration , description , builder , bindingServiceNameSupplier , integrationAction , componentInterceptorSupport ) ) { \nisComponentIntegrationPerformed = true ; \nbreak ; \n} \n} \n} \n\n"}
{"2833": "public class EEApplicationDescription { \npublic void addComponent ( final ComponentDescription description , final VirtualFile deploymentRoot ) { \nfor ( final ViewDescription viewDescription : description . getViews ( ) ) { \nList < ViewInformation > viewComponents = componentsByViewName . get ( viewDescription . getViewClassName ( ) ) ; \nif ( viewComponents == null ) { \nviewComponents = new ArrayList < ViewInformation > ( 1 ) ; \ncomponentsByViewName . put ( viewDescription . getViewClassName ( ) , viewComponents ) ; \n} \nviewComponents . add ( new ViewInformation ( viewDescription , deploymentRoot , description . getComponentName ( ) ) ) ; \n} \nList < Description > components = componentsByName . get ( description . getComponentName ( ) ) ; \nif ( components == null ) componentsByName . put ( description . getComponentName ( ) , components = new ArrayList < Description > ( 1 ) ) ; \ncomponents . add ( new Description ( description , deploymentRoot ) ) ; \n} \n} \n"}
{"2834": "public class EEApplicationDescription { \npublic void addMessageDestination ( final String name , final String resolvedName , final VirtualFile deploymentRoot ) { \nList < MessageDestinationMapping > components = messageDestinationJndiMapping . get ( name ) ; \nif ( components == null ) messageDestinationJndiMapping . put ( name , components = new ArrayList < MessageDestinationMapping > ( 1 ) ) ; \ncomponents . add ( new MessageDestinationMapping ( resolvedName , deploymentRoot ) ) ; \n} \n} \n"}
{"2835": "public class EEApplicationDescription { \npublic Set < ViewDescription > getComponentsForViewName ( final String viewType , final VirtualFile deploymentRoot ) { \nfinal List < ViewInformation > info = componentsByViewName . get ( viewType ) ; \nif ( info == null ) return Collections . < ViewDescription > emptySet ( ) ; \nfinal Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; \nfinal Set < ViewDescription > currentDep = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( deploymentRoot . equals ( i . deploymentRoot ) ) currentDep . add ( i . viewDescription ) ; \nret . add ( i . viewDescription ) ; \n} \nif ( ! currentDep . isEmpty ( ) ) return currentDep ; \nreturn ret ; \n} \n} \n"}
{"2836": "public class EEApplicationDescription { \npublic Set < ComponentDescription > getComponents ( final String componentName , final VirtualFile deploymentRoot ) { \nif ( componentName . contains ( \"#\" ) ) { \nfinal String [ ] parts = componentName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) path = \"../\" + path ; \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal List < Description > info = componentsByName . get ( name ) ; \nif ( info == null ) return Collections . emptySet ( ) ; \nfinal Set < ComponentDescription > ret = new HashSet < ComponentDescription > ( ) ; \nfor ( Description i : info ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) ret . add ( i . componentDescription ) ; \n} \nreturn ret ; \n} \nelse { \nfinal List < Description > info = componentsByName . get ( componentName ) ; \nif ( info == null ) return Collections . emptySet ( ) ; \nfinal Set < ComponentDescription > all = new HashSet < ComponentDescription > ( ) ; \nfinal Set < ComponentDescription > thisDeployment = new HashSet < ComponentDescription > ( ) ; \nfor ( Description i : info ) { \nall . add ( i . componentDescription ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) thisDeployment . add ( i . componentDescription ) ; \n} \nif ( all . size ( ) > 1 ) return thisDeployment ; \nreturn all ; \n} \n} \n} \n"}
{"2837": "public class EEApplicationDescription { \npublic Set < ViewDescription > getComponents ( final String componentName , final String viewName , final VirtualFile deploymentRoot ) { \nfinal List < ViewInformation > info = componentsByViewName . get ( viewName ) ; \nif ( info == null ) return Collections . < ViewDescription > emptySet ( ) ; \nif ( componentName . contains ( \"#\" ) ) { \nfinal String [ ] parts = componentName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) path = \"../\" + path ; \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( i . beanName . equals ( name ) ) if ( virtualPath . equals ( i . deploymentRoot ) ) ret . add ( i . viewDescription ) ; \n} \nreturn ret ; \n} \nelse { \nfinal Set < ViewDescription > all = new HashSet < ViewDescription > ( ) ; \nfinal Set < ViewDescription > thisDeployment = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( i . beanName . equals ( componentName ) ) { \nall . add ( i . viewDescription ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) thisDeployment . add ( i . viewDescription ) ; \n} \n} \nif ( all . size ( ) > 1 ) return thisDeployment ; \nreturn all ; \n} \n} \n} \n"}
{"2838": "public class EEApplicationDescription { \npublic Set < String > resolveMessageDestination ( final String messageDestName , final VirtualFile deploymentRoot ) { \nif ( messageDestName . contains ( \"#\" ) ) { \nfinal String [ ] parts = messageDestName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) path = \"../\" + path ; \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal Set < String > ret = new HashSet < String > ( ) ; \nfinal List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( name ) ; \nif ( data != null ) for ( final MessageDestinationMapping i : data ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) ret . add ( i . jndiName ) ; \n} \nreturn ret ; \n} \nelse { \nfinal Set < String > all = new HashSet < String > ( ) ; \nfinal Set < String > thisDeployment = new HashSet < String > ( ) ; \nfinal List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( messageDestName ) ; \nif ( data != null ) for ( final MessageDestinationMapping i : data ) { \nall . add ( i . jndiName ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) thisDeployment . add ( i . jndiName ) ; \n} \nif ( all . size ( ) > 1 ) return thisDeployment ; \nreturn all ; \n} \n} \n} \n"}
{"2851": "public class InterfaceRepository { \nprivate void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { \nif ( cls . isPrimitive ( ) ) return ; \nif ( cls . isArray ( ) ) addArray ( cls ) ; \nelse if ( cls . isInterface ( ) ) if ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \naddInterface ( ia ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \nelse if ( Exception . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \naddException ( ea ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \n} \n} \n"}
{"2858": "public class NamingStoreService { \npublic void stop ( StopContext context ) { \nif ( store != null ) try { \nstore . close ( ) ; \nstore = null ; \n} \ncatch ( NamingException e ) { \nthrow NamingLogger . ROOT_LOGGER . failedToDestroyRootContext ( e ) ; \n} \n} \n} \n"}
{"2859": "public class AllowedMethodsInformation { \npublic static void checkAllowed ( final MethodType methodType ) { \nfinal InterceptorContext context = CurrentInvocationContext . get ( ) ; \nif ( context == null ) return ; \nfinal Component component = context . getPrivateData ( Component . class ) ; \nif ( ! ( component instanceof EJBComponent ) ) return ; \nfinal InvocationType invocationType = context . getPrivateData ( InvocationType . class ) ; \n( ( EJBComponent ) component ) . getAllowedMethodsInformation ( ) . realCheckPermission ( methodType , invocationType ) ; \n} \n} \n"}
{"2860": "public class AllowedMethodsInformation { \nprivate void checkTransactionSync ( MethodType methodType ) { \nfinal CurrentSynchronizationCallback . CallbackType currentSync = CurrentSynchronizationCallback . get ( ) ; \nif ( currentSync != null ) if ( deniedSyncMethods . contains ( new DeniedSyncMethodKey ( currentSync , methodType ) ) ) throwException ( methodType , currentSync ) ; \n} \n} \n"}
{"2862": "public class TimerServiceImpl { \nprivate Map < String , TimerImpl > getWaitingOnTxCompletionTimers ( ) { \nMap < String , TimerImpl > timers = null ; \nif ( getTransaction ( ) != null ) timers = ( Map < String , TimerImpl > ) tsr . getResource ( waitingOnTxCompletionKey ) ; \nreturn timers == null ? Collections . < String , TimerImpl > emptyMap ( ) : timers ; \n} \n} \n"}
{"2863": "public class TransportConfigOperationHandlers { \nprivate static Map < String , Object > getExtraParameters ( final Set < String > allowedKeys , final Map < String , Object > parameters ) { \nMap < String , Object > extraParameters = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Object > parameter : parameters . entrySet ( ) ) { \nif ( ! allowedKeys . contains ( parameter . getKey ( ) ) ) extraParameters . put ( parameter . getKey ( ) , parameter . getValue ( ) ) ; \n} \nfor ( String extraParam : extraParameters . keySet ( ) ) { \nparameters . remove ( extraParam ) ; \n} \nreturn extraParameters ; \n} \n} \n"}
{"2865": "public class Configurator { \npublic static Class < ? > toClass ( Type type ) { \nif ( type instanceof Class ) return ( Class ) type ; \nelse if ( type instanceof ParameterizedType ) { \nParameterizedType pt = ( ParameterizedType ) type ; \nreturn toClass ( pt . getRawType ( ) ) ; \n} \nelse throw PojoLogger . ROOT_LOGGER . unknownType ( type ) ; \n} \n} \n"}
{"2866": "public class Configurator { \n@ SuppressWarnings ( \"unchecked\" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { \nif ( clazz == null ) return value ; \nif ( value == null ) return null ; \nClass < ? > valueClass = value . getClass ( ) ; \nif ( valueClass == String . class ) { \nString string = ( String ) value ; \nif ( trim ) string = string . trim ( ) ; \nif ( replaceProperties ) value = PropertiesValueResolver . replaceProperties ( string ) ; \n} \nif ( clazz . isAssignableFrom ( valueClass ) ) return value ; \nif ( clazz . isEnum ( ) ) { \nClass < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; \nreturn Enum . valueOf ( eclazz , value . toString ( ) ) ; \n} \nif ( valueClass == String . class ) { \nPropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; \nif ( editor != null ) { \neditor . setAsText ( ( String ) value ) ; \nreturn editor . getValue ( ) ; \n} \n} \ntry { \nMethod method = clazz . getMethod ( \"valueOf\" , valueClass ) ; \nint modifiers = method . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) && clazz . isAssignableFrom ( method . getReturnType ( ) ) ) return method . invoke ( null , value ) ; \n} \ncatch ( Exception ignored ) { \n} \nif ( valueClass == String . class ) try { \nConstructor constructor = clazz . getConstructor ( valueClass ) ; \nif ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) return constructor . newInstance ( value ) ; \n} \ncatch ( Exception ignored ) { \n} \nreturn value ; \n} \n} \n"}
{"2869": "public class CNBindingEnumeration { \npublic java . lang . Object next ( ) throws NamingException { \nif ( more && counter >= _bindingList . value . length ) getMore ( ) ; \nif ( more && counter < _bindingList . value . length ) { \norg . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; \ncounter ++ ; \nreturn mapBinding ( bndg ) ; \n} \nelse throw new NoSuchElementException ( ) ; \n} \n} \n"}
{"2874": "public class EjbIIOPService { \npublic org . omg . CORBA . Object referenceForLocator ( final EJBLocator < ? > locator ) { \nfinal EJBComponent ejbComponent = ejbComponentInjectedValue . getValue ( ) ; \ntry { \nfinal String earApplicationName = ejbComponent . getEarApplicationName ( ) == null ? \"\" : ejbComponent . getEarApplicationName ( ) ; \nif ( locator . getBeanName ( ) . equals ( ejbComponent . getComponentName ( ) ) && locator . getAppName ( ) . equals ( earApplicationName ) && locator . getModuleName ( ) . equals ( ejbComponent . getModuleName ( ) ) && locator . getDistinctName ( ) . equals ( ejbComponent . getDistinctName ( ) ) ) { \nif ( locator instanceof EJBHomeLocator ) return ( org . omg . CORBA . Object ) ejbHome ; \nelse if ( locator instanceof StatelessEJBLocator ) return beanReferenceFactory . createReference ( beanRepositoryIds [ 0 ] ) ; \nelse if ( locator instanceof StatefulEJBLocator ) { \nfinal Marshaller marshaller = factory . createMarshaller ( configuration ) ; \nfinal ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; \nmarshaller . start ( new OutputStreamByteOutput ( stream ) ) ; \nmarshaller . writeObject ( ( ( StatefulEJBLocator < ? > ) locator ) . getSessionId ( ) ) ; \nmarshaller . finish ( ) ; \nreturn beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; \n} \nelse if ( locator instanceof EntityEJBLocator ) { \nfinal Marshaller marshaller = factory . createMarshaller ( configuration ) ; \nfinal ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; \nmarshaller . start ( new OutputStreamByteOutput ( stream ) ) ; \nmarshaller . writeObject ( ( ( EntityEJBLocator < ? > ) locator ) . getPrimaryKey ( ) ) ; \nmarshaller . finish ( ) ; \nreturn beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; \n} \nthrow EjbLogger . ROOT_LOGGER . unknownEJBLocatorType ( locator ) ; \n} \nelse throw EjbLogger . ROOT_LOGGER . incorrectEJBLocatorForBean ( locator , ejbComponent . getComponentName ( ) ) ; \n} \ncatch ( Exception e ) { \nthrow EjbLogger . ROOT_LOGGER . couldNotCreateCorbaObject ( e , locator ) ; \n} \n} \n} \n"}
{"2875": "public class EjbIIOPService { \npublic Object handleForLocator ( final EJBLocator < ? > locator ) { \nfinal org . omg . CORBA . Object reference = referenceForLocator ( locator ) ; \nif ( locator instanceof EJBHomeLocator ) return new HomeHandleImplIIOP ( orb . getValue ( ) . object_to_string ( reference ) ) ; \nreturn new HandleImplIIOP ( orb . getValue ( ) . object_to_string ( reference ) ) ; \n} \n} \n"}
{"2878": "public class Messaging13SubsystemParser { \nprotected static void checkNotBothElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { \nif ( seen . contains ( element1 ) && seen . contains ( element2 ) ) throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \n} \n"}
{"2879": "public class EEModuleDescription { \npublic void addComponent ( ComponentDescription description ) { \nfinal String componentName = description . getComponentName ( ) ; \nfinal String componentClassName = description . getComponentClassName ( ) ; \nif ( componentName == null ) throw EeLogger . ROOT_LOGGER . nullVar ( \"componentName\" , \"module\" , moduleName ) ; \nif ( componentClassName == null ) throw EeLogger . ROOT_LOGGER . nullVar ( \"componentClassName\" , \"module\" , moduleName ) ; \nif ( componentsByName . containsKey ( componentName ) ) throw EeLogger . ROOT_LOGGER . componentAlreadyDefined ( componentName ) ; \ncomponentsByName . put ( componentName , description ) ; \nList < ComponentDescription > list = componentsByClassName . get ( componentClassName ) ; \nif ( list == null ) componentsByClassName . put ( componentClassName , list = new ArrayList < ComponentDescription > ( 1 ) ) ; \nlist . add ( description ) ; \n} \n} \n"}
{"2881": "public class InMemoryNamingStore { \npublic void unbind ( final Name name ) throws NamingException { \nif ( isLastComponentEmpty ( name ) ) throw emptyNameException ( ) ; \nwriteLock . lock ( ) ; \ntry { \nroot . accept ( new UnbindVisitor ( name ) ) ; \n} \nfinally { \nwriteLock . unlock ( ) ; \n} \n} \n} \n"}
{"2885": "public class ConcurrentContext { \npublic synchronized void addFactory ( ContextHandleFactory factory ) { \nfinal String factoryName = factory . getName ( ) ; \nif ( factoryMap . containsKey ( factoryName ) ) throw EeLogger . ROOT_LOGGER . factoryAlreadyExists ( this , factoryName ) ; \nfactoryMap . put ( factoryName , factory ) ; \nfinal Comparator < ContextHandleFactory > comparator = new Comparator < ContextHandleFactory > ( ) { \n@ Override public int compare ( ContextHandleFactory o1 , ContextHandleFactory o2 ) { \nreturn Integer . compare ( o1 . getChainPriority ( ) , o2 . getChainPriority ( ) ) ; \n} \n} \n; \nSortedSet < ContextHandleFactory > sortedSet = new TreeSet < > ( comparator ) ; \nsortedSet . addAll ( factoryMap . values ( ) ) ; \nfactoryOrderedList = new ArrayList < > ( sortedSet ) ; \n} \n} \n"}
{"2887": "public class WebMigrateOperation { \nprivate void createIoSubsystem ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , PathAddress baseAddress ) { \nResource root = context . readResourceFromRoot ( baseAddress , false ) ; \nif ( root . getChildrenNames ( SUBSYSTEM ) . contains ( IOExtension . SUBSYSTEM_NAME ) ) return ; \nPathAddress address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \naddress = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( \"worker\" , \"default\" ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \naddress = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( \"buffer-pool\" , \"default\" ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \n} \n} \n"}
{"2889": "public class StrictMaxPool { \npublic T get ( ) { \ntry { \nboolean acquired = semaphore . tryAcquire ( timeout , timeUnit ) ; \nif ( ! acquired ) throw EjbLogger . ROOT_LOGGER . failedToAcquirePermit ( timeout , timeUnit ) ; \n} \ncatch ( InterruptedException e ) { \nthrow EjbLogger . ROOT_LOGGER . acquireSemaphoreInterrupted ( ) ; \n} \nT bean = pool . poll ( ) ; \nif ( bean != null ) return bean ; \ntry { \nbean = create ( ) ; \n} \nfinally { \nif ( bean == null ) semaphore . release ( ) ; \n} \nreturn bean ; \n} \n} \n"}
{"2893": "public class EndpointPublisherImpl { \nprotected void doDeploy ( ServiceTarget target , DeploymentUnit unit ) { \nList < DeploymentAspect > aspects = getDeploymentAspects ( ) ; \nClassLoader origClassLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \nDeployment dep = null ; \ntry { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( ClassLoaderProvider . getDefaultProvider ( ) . getServerIntegrationClassLoader ( ) ) ; \ndep = unit . getAttachment ( WSAttachmentKeys . DEPLOYMENT_KEY ) ; \ndep . addAttachment ( ServiceTarget . class , target ) ; \nDeploymentAspectManager dam = new DeploymentAspectManagerImpl ( ) ; \ndam . setDeploymentAspects ( aspects ) ; \ndam . deploy ( dep ) ; \n} \nfinally { \nif ( dep != null ) dep . removeAttachment ( ServiceTarget . class ) ; \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( origClassLoader ) ; \n} \n} \n} \n"}
{"2896": "public class WeldBootstrapService { \npublic synchronized void start ( final StartContext context ) { \nif ( started ) throw WeldLogger . ROOT_LOGGER . alreadyRunning ( \"WeldContainer\" ) ; \nstarted = true ; \nWeldLogger . DEPLOYMENT_LOGGER . startingWeldService ( deploymentName ) ; \naddWeldService ( SecurityServices . class , securityServicesSupplier . get ( ) ) ; \nTransactionServices transactionServices = weldTransactionServicesSupplier != null ? weldTransactionServicesSupplier . get ( ) : null ; \nif ( transactionServices != null ) addWeldService ( TransactionServices . class , transactionServices ) ; \nif ( ! deployment . getServices ( ) . contains ( ExecutorServices . class ) ) addWeldService ( ExecutorServices . class , executorServicesSupplier . get ( ) ) ; \nModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule ( ) . getClassLoader ( ) , deployment . getSubDeploymentClassLoaders ( ) ) ; \nClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \ntry { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule ( ) . getClassLoader ( ) ) ; \nbootstrap . startContainer ( deploymentName , environment , deployment ) ; \nWeldProvider . containerInitialized ( Container . instance ( deploymentName ) , getBeanManager ( ) , deployment ) ; \n} \nfinally { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; \n} \nweldBootstrapServiceConsumer . accept ( this ) ; \n} \n} \n"}
{"2897": "public class WSEndpointConfigMapping { \npublic void registerEndpointConfig ( final String endpointClass , final EndpointConfig config ) { \nif ( ( endpointClass == null ) || ( config == null ) ) throw new IllegalArgumentException ( ) ; \nendpointConfigMap . put ( endpointClass , config ) ; \n} \n} \n"}
{"2898": "public class TimerTask { \nprotected void retryTimeout ( TimerImpl timer ) throws Exception { \nboolean callTimeout = false ; \ntimer . lock ( ) ; \ntry { \nif ( timer . isActive ( ) ) { \nEJB3_TIMER_LOGGER . retryingTimeout ( timer ) ; \ntimer . setTimerState ( TimerState . RETRY_TIMEOUT , Thread . currentThread ( ) ) ; \ntimerService . persistTimer ( timer , false ) ; \ncallTimeout = true ; \n} \nelse EJB3_TIMER_LOGGER . timerNotActive ( timer ) ; \n} \nfinally { \ntimer . unlock ( ) ; \n} \nif ( callTimeout ) this . callTimeout ( timer ) ; \n} \n} \n"}
{"2899": "public class TimerTask { \nprotected void postTimeoutProcessing ( TimerImpl timer ) throws InterruptedException { \ntimer . lock ( ) ; \ntry { \nTimerState timerState = timer . getState ( ) ; \nif ( timerState != TimerState . CANCELED && timerState != TimerState . EXPIRED ) { \nif ( timer . getInterval ( ) == 0 ) timerService . expireTimer ( timer ) ; \nelse timer . setTimerState ( TimerState . ACTIVE , null ) ; \ntimerService . persistTimer ( timer , false ) ; \n} \n} \nfinally { \ntimer . unlock ( ) ; \n} \n} \n} \n"}
{"2904": "public class MigrateOperation { \nprivate void addMessagingActiveMQExtension ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , boolean describe ) { \nResource root = context . readResourceFromRoot ( PathAddress . EMPTY_ADDRESS , false ) ; \nif ( root . getChildrenNames ( EXTENSION ) . contains ( MESSAGING_ACTIVEMQ_EXTENSION ) ) return ; \nPathAddress extensionAddress = pathAddress ( EXTENSION , MESSAGING_ACTIVEMQ_EXTENSION ) ; \nOperationEntry addEntry = context . getRootResourceRegistration ( ) . getOperationEntry ( extensionAddress , ADD ) ; \nModelNode addOperation = createAddOperation ( extensionAddress ) ; \naddOperation . get ( MODULE ) . set ( MESSAGING_ACTIVEMQ_MODULE ) ; \nif ( describe ) migrationOperations . put ( extensionAddress , addOperation ) ; \nelse context . addStep ( context . getResult ( ) . get ( extensionAddress . toString ( ) ) , addOperation , addEntry . getOperationHandler ( ) , MODEL ) ; \n} \n} \n"}
{"2905": "public class MigrateOperation { \nprivate boolean parameterIsAllowed ( String name , String resourceType ) { \nswitch ( resourceType ) { \ncase REMOTE_ACCEPTOR : case HTTP_ACCEPTOR : case REMOTE_CONNECTOR : case HTTP_CONNECTOR : if ( \"use-nio\" . equals ( name ) ) return false ; \nelse return true ; \ndefault : return true ; \n} \n} \n} \n"}
{"2907": "public class CancellationFlag { \npublic boolean cancel ( boolean setFlag ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal , newVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_WAITING ) newVal = ST_CANCELLED ; \nelse if ( oldVal == ST_CANCELLED ) { \nif ( ! setFlag ) return true ; \nnewVal = ST_CANCELLED_FLAG_SET ; \n} \nelse if ( oldVal == ST_CANCELLED_FLAG_SET ) return true ; \nelse if ( oldVal == ST_STARTED ) { \nif ( ! setFlag ) return false ; \nnewVal = ST_STARTED_FLAG_SET ; \n} \nelse { \nassert oldVal == ST_STARTED_FLAG_SET ; \nreturn false ; \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; \nreturn newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; \n} \n} \n"}
{"2908": "public class CancellationFlag { \npublic boolean runIfNotCancelled ( ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) return false ; \nelse if ( oldVal != ST_WAITING ) throw Assert . unreachableCode ( ) ; \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; \nreturn true ; \n} \n} \n"}
{"2910": "public class OBaseExpression { \npublic boolean canExecuteIndexedFunctionWithoutIndex ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { \nif ( this . identifier == null ) return false ; \nreturn identifier . canExecuteIndexedFunctionWithoutIndex ( target , context , operator , right ) ; \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( count > 1 ) count = count / 2 ; \nif ( count < threshold ) return count ; \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( indexedFunctConditions != null ) for ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( newCount < conditionEstimation ) conditionEstimation = newCount ; \n} \nelse { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) continue ; \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nint nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( conditions . containsKey ( indexedField ) ) nMatchingKeys ++ ; \nelse break ; \n} \nif ( nMatchingKeys > 0 ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( newCount < conditionEstimation ) conditionEstimation = newCount ; \n} \n} \n} \nif ( conditionEstimation > count ) return count ; \nindexesCount += conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2913": "public class OReflectionHelper { \npublic static List < Class < ? > > getClassessOfInterface ( String thePackage , Class < ? > theInterface , final ClassLoader iClassLoader ) { \nList < Class < ? > > classList = new ArrayList < Class < ? > > ( ) ; \ntry { \nfor ( Class < ? > discovered : getClassesFor ( thePackage , iClassLoader ) ) { \nif ( Arrays . asList ( discovered . getInterfaces ( ) ) . contains ( theInterface ) ) classList . add ( discovered ) ; \n} \n} \ncatch ( ClassNotFoundException ex ) { \nOLogManager . instance ( ) . error ( null , \"Error finding classes\" , ex ) ; \n} \nreturn classList ; \n} \n} \n"}
{"2914": "public class OReflectionHelper { \npublic static Class < ? > getGenericMultivalueType ( final Field p ) { \nif ( p . getType ( ) instanceof Class < ? > ) { \nfinal Type genericType = p . getGenericType ( ) ; \nif ( genericType != null && genericType instanceof ParameterizedType ) { \nfinal ParameterizedType pt = ( ParameterizedType ) genericType ; \nif ( pt . getActualTypeArguments ( ) != null && pt . getActualTypeArguments ( ) . length > 0 ) if ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) return ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; \nelse if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) return ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; \n} \nelse if ( p . getType ( ) . isArray ( ) ) return p . getType ( ) . getComponentType ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2916": "public class ODocumentSimpleFieldHandlingStrategy { \nprotected OType deriveFieldType ( ODocument iRecord , String fieldName , OType requestedFieldType ) { \nif ( iRecord . getSchemaClass ( ) . existsProperty ( fieldName ) ) return iRecord . getSchemaClass ( ) . getProperty ( fieldName ) . getType ( ) ; \nif ( requestedFieldType != null ) return requestedFieldType ; \nreturn iRecord . fieldType ( fieldName ) ; \n} \n} \n"}
{"2917": "public class OLocalRecordCache { \npublic void updateRecord ( final ORecord record ) { \nif ( record . getIdentity ( ) . getClusterId ( ) != excludedCluster && record . getIdentity ( ) . isValid ( ) && ! record . isDirty ( ) && ! ORecordVersionHelper . isTombstone ( record . getVersion ( ) ) ) if ( underlying . get ( record . getIdentity ( ) ) != record ) underlying . put ( record ) ; \n} \n} \n"}
{"2919": "public class OSelectExecutionPlanner { \nprivate Map < String , Set < String > > getMinimalSetOfNodesForShardedQuery ( String localNode , Map < String , Set < String > > clusterMap , Set < String > queryClusters ) { \nMap < String , Set < String > > result = new LinkedHashMap < > ( ) ; \nSet < String > uncovered = new HashSet < > ( ) ; \nuncovered . addAll ( queryClusters ) ; \nuncovered = uncovered . stream ( ) . filter ( x -> x != null ) . map ( x -> x . toLowerCase ( Locale . ENGLISH ) ) . collect ( Collectors . toSet ( ) ) ; \nSet < String > nextNodeClusters = new HashSet < > ( ) ; \nSet < String > clustersForNode = clusterMap . get ( localNode ) ; \nif ( clustersForNode != null ) nextNodeClusters . addAll ( clustersForNode ) ; \nnextNodeClusters . retainAll ( uncovered ) ; \nif ( nextNodeClusters . size ( ) > 0 ) { \nresult . put ( localNode , nextNodeClusters ) ; \nuncovered . removeAll ( nextNodeClusters ) ; \n} \nwhile ( uncovered . size ( ) > 0 ) { \nString nextNode = findItemThatCoversMore ( uncovered , clusterMap ) ; \nnextNodeClusters = new HashSet < > ( ) ; \nnextNodeClusters . addAll ( clusterMap . get ( nextNode ) ) ; \nnextNodeClusters . retainAll ( uncovered ) ; \nif ( nextNodeClusters . size ( ) == 0 ) throw new OCommandExecutionException ( \"Cannot execute a sharded query: clusters [\" + uncovered . stream ( ) . collect ( Collectors . joining ( \", \" ) ) + \"] are not present on any node\" + \"\\n [\" + clusterMap . entrySet ( ) . stream ( ) . map ( x -> \"\" + x . getKey ( ) + \":(\" + x . getValue ( ) . stream ( ) . collect ( Collectors . joining ( \",\" ) ) + \")\" ) . collect ( Collectors . joining ( \", \" ) ) + \"]\" ) ; \nresult . put ( nextNode , nextNodeClusters ) ; \nuncovered . removeAll ( nextNodeClusters ) ; \n} \nreturn result ; \n} \n} \n"}
{"2920": "public class OSelectExecutionPlanner { \nprivate static List < OAndBlock > moveFlattededEqualitiesLeft ( List < OAndBlock > flattenedWhereClause ) { \nif ( flattenedWhereClause == null ) return null ; \nList < OAndBlock > result = new ArrayList < > ( ) ; \nfor ( OAndBlock block : flattenedWhereClause ) { \nList < OBooleanExpression > equalityExpressions = new ArrayList < > ( ) ; \nList < OBooleanExpression > nonEqualityExpressions = new ArrayList < > ( ) ; \nOAndBlock newBlock = block . copy ( ) ; \nfor ( OBooleanExpression exp : newBlock . getSubBlocks ( ) ) { \nif ( exp instanceof OBinaryCondition ) if ( ( ( OBinaryCondition ) exp ) . getOperator ( ) instanceof OEqualsCompareOperator ) equalityExpressions . add ( exp ) ; \nelse nonEqualityExpressions . add ( exp ) ; \nelse nonEqualityExpressions . add ( exp ) ; \n} \nOAndBlock newAnd = new OAndBlock ( - 1 ) ; \nnewAnd . getSubBlocks ( ) . addAll ( equalityExpressions ) ; \nnewAnd . getSubBlocks ( ) . addAll ( nonEqualityExpressions ) ; \nresult . add ( newAnd ) ; \n} \nreturn result ; \n} \n} \n"}
{"2921": "public class OSelectExecutionPlanner { \nprivate static void addOrderByProjections ( QueryPlanningInfo info ) { \nif ( info . orderApplied || info . expand || info . unwind != null || info . orderBy == null || info . orderBy . getItems ( ) . size ( ) == 0 || info . projection == null || info . projection . getItems ( ) == null || ( info . projection . getItems ( ) . size ( ) == 1 && info . projection . getItems ( ) . get ( 0 ) . isAll ( ) ) ) return ; \nOOrderBy newOrderBy = info . orderBy == null ? null : info . orderBy . copy ( ) ; \nList < OProjectionItem > additionalOrderByProjections = calculateAdditionalOrderByProjections ( info . projection . getAllAliases ( ) , newOrderBy ) ; \nif ( additionalOrderByProjections . size ( ) > 0 ) info . orderBy = newOrderBy ; \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . projectionAfterOrderBy = new OProjection ( - 1 ) ; \ninfo . projectionAfterOrderBy . setItems ( new ArrayList < > ( ) ) ; \nfor ( String alias : info . projection . getAllAliases ( ) ) { \ninfo . projectionAfterOrderBy . getItems ( ) . add ( projectionFromAlias ( new OIdentifier ( alias ) ) ) ; \n} \nfor ( OProjectionItem item : additionalOrderByProjections ) { \nif ( info . preAggregateProjection != null ) { \ninfo . preAggregateProjection . getItems ( ) . add ( item ) ; \ninfo . aggregateProjection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \ninfo . projection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \n} \nelse info . projection . getItems ( ) . add ( item ) ; \n} \n} \n} \n} \n"}
{"2922": "public class OSelectExecutionPlanner { \nprivate static void extractSubQueries ( QueryPlanningInfo info ) { \nSubQueryCollector collector = new SubQueryCollector ( ) ; \nif ( info . perRecordLetClause != null ) info . perRecordLetClause . extractSubQueries ( collector ) ; \nint i = 0 ; \nint j = 0 ; \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) addRecordLevelLet ( info , alias , query , j ++ ) ; \nelse addGlobalLet ( info , alias , query , i ++ ) ; \n} \ncollector . reset ( ) ; \nif ( info . whereClause != null ) info . whereClause . extractSubQueries ( collector ) ; \nif ( info . projection != null ) info . projection . extractSubQueries ( collector ) ; \nif ( info . orderBy != null ) info . orderBy . extractSubQueries ( collector ) ; \nif ( info . groupBy != null ) info . groupBy . extractSubQueries ( collector ) ; \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) addRecordLevelLet ( info , alias , query ) ; \nelse addGlobalLet ( info , alias , query ) ; \n} \n} \n} \n"}
{"2923": "public class OSelectExecutionPlanner { \nprivate boolean isFromClusters ( ORid rid , Set < String > filterClusters , ODatabase database ) { \nif ( filterClusters == null ) throw new IllegalArgumentException ( ) ; \nString clusterName = database . getClusterNameById ( rid . getCluster ( ) . getValue ( ) . intValue ( ) ) ; \nreturn filterClusters . contains ( clusterName ) ; \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) throw new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) continue ; \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) return false ; \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) orderType = orderItem . getType ( ) ; \nelse if ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) filterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) info . orderApplied = true ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2925": "public class OSelectExecutionPlanner { \nprivate boolean isDiamondHierarchy ( OClass clazz ) { \nSet < OClass > traversed = new HashSet < > ( ) ; \nList < OClass > stack = new ArrayList < > ( ) ; \nstack . add ( clazz ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nOClass current = stack . remove ( 0 ) ; \ntraversed . add ( current ) ; \nfor ( OClass sub : current . getSubclasses ( ) ) { \nif ( traversed . contains ( sub ) ) return true ; \nstack . add ( sub ) ; \ntraversed . add ( sub ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2926": "public class OSelectExecutionPlanner { \nprivate Boolean getOrderDirection ( QueryPlanningInfo info ) { \nif ( info . orderBy == null ) return null ; \nString result = null ; \nfor ( OOrderByItem item : info . orderBy . getItems ( ) ) { \nif ( result == null ) result = item . getType ( ) == null ? OOrderByItem . ASC : item . getType ( ) ; \nelse { \nString newType = item . getType ( ) == null ? OOrderByItem . ASC : item . getType ( ) ; \nif ( ! newType . equals ( result ) ) return null ; \n} \n} \nreturn result == null || result . equals ( OOrderByItem . ASC ) ; \n} \n} \n"}
{"2927": "public class OSelectExecutionPlanner { \nprivate boolean requiresMultipleIndexLookups ( OAndBlock keyCondition ) { \nfor ( OBooleanExpression oBooleanExpression : keyCondition . getSubBlocks ( ) ) { \nif ( ! ( oBooleanExpression instanceof OBinaryCondition ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"2929": "public class OSelectExecutionPlanner { \nprivate IndexSearchDescriptor buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index , OAndBlock block , OClass clazz ) { \nList < String > indexFields = index . getDefinition ( ) . getFields ( ) ; \nOBinaryCondition keyCondition = new OBinaryCondition ( - 1 ) ; \nOIdentifier key = new OIdentifier ( \"key\" ) ; \nkeyCondition . setLeft ( new OExpression ( key ) ) ; \nboolean found = false ; \nOAndBlock blockCopy = block . copy ( ) ; \nIterator < OBooleanExpression > blockIterator ; \nOAndBlock indexKeyValue = new OAndBlock ( - 1 ) ; \nIndexSearchDescriptor result = new IndexSearchDescriptor ( ) ; \nresult . idx = index ; \nresult . keyCondition = indexKeyValue ; \nfor ( String indexField : indexFields ) { \nblockIterator = blockCopy . getSubBlocks ( ) . iterator ( ) ; \nboolean breakHere = false ; \nboolean indexFieldFound = false ; \nwhile ( blockIterator . hasNext ( ) ) { \nOBooleanExpression singleExp = blockIterator . next ( ) ; \nif ( singleExp instanceof OContainsTextCondition ) { \nOExpression left = ( ( OContainsTextCondition ) singleExp ) . getLeft ( ) ; \nif ( left . isBaseIdentifier ( ) ) { \nString fieldName = left . getDefaultAlias ( ) . getStringValue ( ) ; \nif ( indexField . equals ( fieldName ) ) { \nfound = true ; \nindexFieldFound = true ; \nOContainsTextCondition condition = new OContainsTextCondition ( - 1 ) ; \ncondition . setLeft ( left ) ; \ncondition . setRight ( ( ( OContainsTextCondition ) singleExp ) . getRight ( ) . copy ( ) ) ; \nindexKeyValue . getSubBlocks ( ) . add ( condition ) ; \nblockIterator . remove ( ) ; \nbreak ; \n} \n} \n} \n} \nif ( breakHere || ! indexFieldFound ) break ; \n} \nif ( result . keyCondition . getSubBlocks ( ) . size ( ) < index . getDefinition ( ) . getFields ( ) . size ( ) && ! index . supportsOrderedIterations ( ) ) return null ; \nif ( found ) { \nresult . remainingCondition = blockCopy ; \nreturn result ; \n} \nreturn null ; \n} \n} \n"}
{"2931": "public class ODocumentFieldHandlingStrategyFactory { \npublic ODocumentFieldHandlingStrategy create ( int strategy ) { \nOptional < ODocumentFieldHandlingStrategy > registered = ODocumentFieldHandlingStrategyRegistry . getInstance ( ) . getStrategy ( strategy ) ; \nif ( registered . isPresent ( ) ) return registered . get ( ) ; \nMap < OType , ODocumentFieldOTypeHandlingStrategy > typeHandlingStrategies = new HashMap < OType , ODocumentFieldOTypeHandlingStrategy > ( ) ; \nswitch ( strategy ) { \ncase SINGLE_ORECORD_BYTES : typeHandlingStrategies . put ( OType . BINARY , new ODocumentSingleRecordBytesOTypeHandlingStrategy ( ) ) ; \nbreak ; \ncase SPLIT_ORECORD_BYTES : typeHandlingStrategies . put ( OType . BINARY , new ODocumentSplitRecordBytesOTypeHandlingStrategy ( ) ) ; \nbreak ; \ncase SIMPLE : default : break ; \n} \nODocumentSmartFieldHandlingStrategy strategyInstance = new ODocumentSmartFieldHandlingStrategy ( typeHandlingStrategies ) ; \nODocumentFieldHandlingStrategyRegistry . getInstance ( ) . registerStrategy ( strategy , strategyInstance ) ; \nreturn strategyInstance ; \n} \n} \n"}
{"2932": "public class OUser { \npublic ORole allow ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific , final int iOperation ) { \nif ( roles == null || roles . isEmpty ( ) ) if ( document . field ( \"roles\" ) != null && ! ( ( Collection < OIdentifiable > ) document . field ( \"roles\" ) ) . isEmpty ( ) ) { \nfinal ODocument doc = document ; \ndocument = null ; \nfromStream ( doc ) ; \n} \nelse throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' has no role defined\" ) ; \nfinal ORole role = checkIfAllowed ( resourceGeneric , resourceSpecific , iOperation ) ; \nif ( role == null ) throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' does not have permission to execute the operation '\" + ORole . permissionToString ( iOperation ) + \"' against the resource: \" + resourceGeneric + \".\" + resourceSpecific ) ; \nreturn role ; \n} \n} \n"}
{"2942": "public class OMicroTransaction { \npublic void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { \nif ( oldRid . equals ( newRid ) ) return ; \nfinal List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList < > ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfor ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { \nfinal OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; \nif ( index == null ) throw new OTransactionException ( \"Cannot find index '\" + entry . getValue ( ) + \"' while committing transaction\" ) ; \nfinal Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; \nif ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) continue ; \nfinal OTransactionIndexChanges indexChanges = entry . getValue ( ) ; \nfor ( final Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; \nif ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { \nkeyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; \niterator . remove ( ) ; \n} \n} \n} \nfinal ORecordOperation rec = resolveRecordOperation ( oldRid ) ; \nif ( rec != null ) { \nupdatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; \nif ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { \nORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; \nfinal ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; \nif ( recordId == null ) ORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; \nelse { \nrecordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; \nrecordId . setClusterId ( newRid . getClusterId ( ) ) ; \n} \nORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; \n} \n} \nfor ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; \nfinal List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; \nif ( transactionIndexOperations != null ) for ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { \nOTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; \nif ( indexEntryChanges == null ) continue ; \nfinal OTransactionIndexChangesPerKey keyChanges ; \nif ( indexOperation . key == null ) keyChanges = indexEntryChanges . nullKeyChanges ; \nelse keyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; \nif ( keyChanges != null ) updateChangesIdentity ( oldRid , newRid , keyChanges ) ; \n} \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal int availableNodes = nodes . size ( ) ; \nint maxReadQuorum ; \nif ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \nelse { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nif ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; \nelse if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; \nelse if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2952": "public class OCommandExecutorSQLCreateProperty { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( type == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OClassEmbedded sourceClass = ( OClassEmbedded ) database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( sourceClass == null ) throw new OCommandExecutionException ( \"Source class '\" + className + \"' not found\" ) ; \nOPropertyImpl prop = ( OPropertyImpl ) sourceClass . getProperty ( fieldName ) ; \nif ( prop != null ) { \nif ( ifNotExists ) return sourceClass . properties ( ) . size ( ) ; \nthrow new OCommandExecutionException ( \"Property '\" + className + \".\" + fieldName + \"' already exists. Remove it before to retry.\" ) ; \n} \nOClass linkedClass = null ; \nOType linkedType = null ; \nif ( linked != null ) { \nlinkedClass = database . getMetadata ( ) . getSchema ( ) . getClass ( linked ) ; \nif ( linkedClass == null ) linkedType = OType . valueOf ( linked . toUpperCase ( Locale . ENGLISH ) ) ; \n} \nOPropertyImpl internalProp = sourceClass . addPropertyInternal ( fieldName , type , linkedType , linkedClass , unsafe ) ; \nif ( readonly ) internalProp . setReadonly ( true ) ; \nif ( mandatory ) internalProp . setMandatory ( true ) ; \nif ( notnull ) internalProp . setNotNull ( true ) ; \nif ( max != null ) internalProp . setMax ( max ) ; \nif ( min != null ) internalProp . setMin ( min ) ; \nif ( defaultValue != null ) internalProp . setDefaultValue ( defaultValue ) ; \nreturn sourceClass . properties ( ) . size ( ) ; \n} \n} \n"}
{"2953": "public class OIndexFullText { \n@ Override public OIndexFullText put ( Object key , final OIdentifiable singleValue ) { \nif ( key == null ) return this ; \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( apiVersion == 0 ) doPutV0 ( singleValue , word ) ; \nelse if ( apiVersion == 1 ) doPutV1 ( singleValue , word ) ; \nelse throw new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"2954": "public class OIndexFullText { \n@ Override public boolean remove ( Object key , final OIdentifiable value ) { \nif ( key == null ) return false ; \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfinal OModifiableBoolean removed = new OModifiableBoolean ( false ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( apiVersion == 0 ) removeV0 ( value , removed , word ) ; \nelse if ( apiVersion == 1 ) removeV1 ( value , removed , word ) ; \nelse throw new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn removed . getValue ( ) ; \n} \n} \n"}
{"2955": "public class OSQLQuery { \n@ SuppressWarnings ( \"unchecked\" ) public List < T > run ( final Object ... iArgs ) { \nfinal ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nif ( database == null ) throw new OQueryParsingException ( \"No database configured\" ) ; \n( ( OMetadataInternal ) database . getMetadata ( ) ) . makeThreadLocalSchemaSnapshot ( ) ; \ntry { \nsetParameters ( iArgs ) ; \nObject o = database . getStorage ( ) . command ( this ) ; \nif ( o instanceof List ) return ( List < T > ) o ; \nelse return ( List < T > ) Collections . singletonList ( o ) ; \n} \nfinally { \n( ( OMetadataInternal ) database . getMetadata ( ) ) . clearThreadLocalSchemaSnapshot ( ) ; \n} \n} \n} \n"}
{"2958": "public class OFileClassic { \nprivate long checkRegions ( final long iOffset , final long iLength ) { \nacquireReadLock ( ) ; \ntry { \nif ( iOffset < 0 || iOffset + iLength > size ) throw new OIOException ( \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + ( iOffset + iLength ) + \" bytes. File: \" + this ) ; \nreturn iOffset + HEADER_SIZE ; \n} \nfinally { \nreleaseReadLock ( ) ; \n} \n} \n} \n"}
{"2964": "public class OLazyCollectionUtil { \nprotected static OObjectDatabaseTx getDatabase ( ) { \nODatabaseInternal < ? > databaseOwner = ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ; \nif ( databaseOwner instanceof OObjectDatabaseTx ) return ( OObjectDatabaseTx ) databaseOwner ; \nelse if ( databaseOwner instanceof ODatabaseDocumentInternal ) return new OObjectDatabaseTx ( ( ODatabaseDocumentInternal ) databaseOwner ) ; \nthrow new IllegalStateException ( \"Current database not of expected type\" ) ; \n} \n} \n"}
{"2969": "public class OClientConnectionManager { \npublic void pushDistribCfg2Clients ( final ODocument iConfig ) { \nif ( iConfig == null ) return ; \nfinal Set < String > pushed = new HashSet < String > ( ) ; \nfor ( OClientConnection c : connections . values ( ) ) { \nif ( ! c . getData ( ) . supportsLegacyPushMessages ) continue ; \ntry { \nfinal String remoteAddress = c . getRemoteAddress ( ) ; \nif ( pushed . contains ( remoteAddress ) ) continue ; \n} \ncatch ( Exception e ) { \ncontinue ; \n} \nif ( ! ( c . getProtocol ( ) instanceof ONetworkProtocolBinary ) || c . getData ( ) . getSerializationImpl ( ) == null ) continue ; \nfinal ONetworkProtocolBinary p = ( ONetworkProtocolBinary ) c . getProtocol ( ) ; \nfinal OChannelBinary channel = p . getChannel ( ) ; \nfinal ORecordSerializer ser = ORecordSerializerFactory . instance ( ) . getFormat ( c . getData ( ) . getSerializationImpl ( ) ) ; \nif ( ser == null ) return ; \nfinal byte [ ] content = ser . toStream ( iConfig , false ) ; \ntry { \nif ( channel . tryAcquireWriteLock ( TIMEOUT_PUSH ) ) try { \nchannel . writeByte ( OChannelBinaryProtocol . PUSH_DATA ) ; \nchannel . writeInt ( Integer . MIN_VALUE ) ; \nchannel . writeByte ( OChannelBinaryProtocol . REQUEST_PUSH_DISTRIB_CONFIG ) ; \nchannel . writeBytes ( content ) ; \nchannel . flush ( ) ; \npushed . add ( c . getRemoteAddress ( ) ) ; \nOLogManager . instance ( ) . debug ( this , \"Sent updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \nfinally { \nchannel . releaseWriteLock ( ) ; \n} \nelse OLogManager . instance ( ) . info ( this , \"Timeout on sending updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . warn ( this , \"Cannot push cluster configuration to the client %s\" , e , c . getRemoteAddress ( ) ) ; \n} \n} \n} \n} \n"}
{"2971": "public class OTransactionAbstract { \n@ Override public void close ( ) { \nfor ( Map . Entry < ORID , LockedRecordMetadata > lock : locks . entrySet ( ) ) { \ntry { \nfinal LockedRecordMetadata lockedRecordMetadata = lock . getValue ( ) ; \nif ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . EXCLUSIVE_LOCK ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseWriteLock ( lock . getKey ( ) ) ; \nelse if ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . SHARED_LOCK ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseReadLock ( lock . getKey ( ) ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . debug ( this , \"Error on releasing lock against record \" + lock . getKey ( ) , e ) ; \n} \n} \nlocks . clear ( ) ; \n} \n} \n"}
{"2972": "public class OSchemaProxyObject { \npublic synchronized void synchronizeSchema ( ) { \nOObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; \nCollection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; \nboolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; \nboolean reloadSchema = false ; \nfor ( Class < ? > iClass : registeredEntities ) { \nif ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) || iClass . isAnonymousClass ( ) ) return ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nfor ( Class < ? > currentClass = iClass ; \ncurrentClass != Object . class ; \n) { \nif ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) && ! currentClass . equals ( ODocument . class ) ) ( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; \nString iClassName = currentClass . getSimpleName ( ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \nif ( database != null && ! database . isClosed ( ) && ! currentClass . equals ( Object . class ) ) { \nOClass oSuperClass ; \nOClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nelse { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nif ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { \ncurrentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; \nreloadSchema = true ; \n} \n} \n} \n} \nif ( database != null && ! database . isClosed ( ) && reloadSchema ) database . getMetadata ( ) . getSchema ( ) . reload ( ) ; \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nint read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( int i = 0 ; \ni < 4 ; \n++ i ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse missedChar = c2 ; \n} \n} \ncursor ++ ; \nif ( c == NEW_LINE ) { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nelse ++ columnNumber ; \nreturn ( char ) c ; \n} \n} \n"}
{"2977": "public class OCommandRequestAbstract { \n@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { \nif ( iCallback != null ) onAsyncReplicationError = new OAsyncReplicationError ( ) { \nint retry = 0 ; \n@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { \nswitch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { \ncase RETRY : execute ( ) ; \nbreak ; \ncase IGNORE : } \nreturn ACTION . IGNORE ; \n} \n} \n; \nelse onAsyncReplicationError = null ; \nreturn this ; \n} \n} \n"}
{"2979": "public class ONative { \npublic int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { \nif ( Platform . isLinux ( ) ) { \nfinal OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; \nfinal int result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; \nif ( result == 0 && rlimit . rlim_cur > 0 ) { \nif ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , \"Detected limit of amount of simultaneously open files is %d, \" + \" limit of open files for disk cache will be set to %d\" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; \nif ( rlimit . rlim_cur < recommended ) OLogManager . instance ( ) . warnNoDb ( this , \"Value of limit of simultaneously open files is too small, recommended value is %d\" , recommended ) ; \nreturn ( int ) rlimit . rlim_cur / 2 - 512 ; \n} \nelse if ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , \"Can not detect value of limit of open files.\" ) ; \n} \nelse if ( Platform . isWindows ( ) ) { \nif ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , \"Windows OS is detected, %d limit of open files will be set for the disk cache.\" , recommended ) ; \nreturn recommended ; \n} \nif ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , \"Default limit of open files (%d) will be used.\" , defLimit ) ; \nreturn defLimit ; \n} \n} \n"}
{"2980": "public class OMathExpression { \npublic boolean allowsIndexedFunctionExecutionOnTarget ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { \nif ( this . childExpressions . size ( ) != 1 ) return false ; \nreturn this . childExpressions . get ( 0 ) . allowsIndexedFunctionExecutionOnTarget ( target , context , operator , right ) ; \n} \n} \n"}
{"2983": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeUntilReturn ( ) { \nif ( steps . size ( ) > 0 ) lastStep = steps . get ( steps . size ( ) - 1 ) ; \nfor ( int i = 0 ; \ni < steps . size ( ) - 1 ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nlastStep = returnStep ; \nreturn lastStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) lastResult . next ( ) ; \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nthis . lastStep = steps . get ( steps . size ( ) - 1 ) ; \nreturn lastStep ; \n} \n} \n"}
{"2984": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeFull ( ) { \nfor ( int i = 0 ; \ni < steps . size ( ) ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) return returnStep ; \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) lastResult . next ( ) ; \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2988": "public class OMatchStatement { \n@ Override public < RET extends OCommandExecutor > RET parse ( OCommandRequest iRequest ) { \nfinal OCommandRequestText textRequest = ( OCommandRequestText ) iRequest ; \nif ( iRequest instanceof OSQLSynchQuery ) request = ( OSQLSynchQuery < ODocument > ) iRequest ; \nelse if ( iRequest instanceof OSQLAsynchQuery ) request = ( OSQLAsynchQuery < ODocument > ) iRequest ; \nelse { \nrequest = new OSQLSynchQuery < ODocument > ( textRequest . getText ( ) ) ; \nif ( textRequest . getResultListener ( ) != null ) request . setResultListener ( textRequest . getResultListener ( ) ) ; \n} \nString queryText = textRequest . getText ( ) ; \nfinal InputStream is = new ByteArrayInputStream ( queryText . getBytes ( ) ) ; \nOrientSql osql = null ; \ntry { \nODatabaseDocumentInternal db = getDatabase ( ) ; \nif ( db == null ) osql = new OrientSql ( is ) ; \nelse osql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nOLogManager . instance ( ) . warn ( this , \"Invalid charset for database \" + getDatabase ( ) + \" \" + getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nosql = new OrientSql ( is ) ; \n} \ntry { \nOMatchStatement result = ( OMatchStatement ) osql . parse ( ) ; \nthis . matchExpressions = result . matchExpressions ; \nthis . notMatchExpressions = result . notMatchExpressions ; \nthis . returnItems = result . returnItems ; \nthis . returnAliases = result . returnAliases ; \nthis . limit = result . limit ; \n} \ncatch ( ParseException e ) { \nOCommandSQLParsingException ex = new OCommandSQLParsingException ( e , queryText ) ; \nOErrorCode . QUERY_PARSE_ERROR . throwException ( ex . getMessage ( ) , ex ) ; \n} \nbuildPatterns ( ) ; \npattern . validate ( ) ; \nreturn ( RET ) this ; \n} \n} \n"}
{"2990": "public class OMatchStatement { \nprivate void updateScheduleStartingAt ( PatternNode startNode , Set < PatternNode > visitedNodes , Set < PatternEdge > visitedEdges , Map < String , Set < String > > remainingDependencies , List < EdgeTraversal > resultingSchedule ) { \nvisitedNodes . add ( startNode ) ; \nfor ( Set < String > dependencies : remainingDependencies . values ( ) ) { \ndependencies . remove ( startNode . alias ) ; \n} \nMap < PatternEdge , Boolean > edges = new LinkedHashMap < PatternEdge , Boolean > ( ) ; \nfor ( PatternEdge outEdge : startNode . out ) { \nedges . put ( outEdge , true ) ; \n} \nfor ( PatternEdge inEdge : startNode . in ) { \nedges . put ( inEdge , false ) ; \n} \nfor ( Map . Entry < PatternEdge , Boolean > edgeData : edges . entrySet ( ) ) { \nPatternEdge edge = edgeData . getKey ( ) ; \nboolean isOutbound = edgeData . getValue ( ) ; \nPatternNode neighboringNode = isOutbound ? edge . in : edge . out ; \nif ( ! remainingDependencies . get ( neighboringNode . alias ) . isEmpty ( ) ) continue ; \nif ( visitedNodes . contains ( neighboringNode ) ) if ( ! visitedEdges . contains ( edge ) ) { \nboolean traversalDirection ; \nif ( startNode . optional || edge . item . isBidirectional ( ) ) traversalDirection = ! isOutbound ; \nelse traversalDirection = isOutbound ; \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , traversalDirection ) ) ; \n} \nelse if ( ! startNode . optional ) { \nif ( visitedEdges . contains ( edge ) ) throw new AssertionError ( \"The edge was visited, but the neighboring vertex was not: \" + edge + \" \" + neighboringNode ) ; \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , isOutbound ) ) ; \nupdateScheduleStartingAt ( neighboringNode , visitedNodes , visitedEdges , remainingDependencies , resultingSchedule ) ; \n} \n} \n} \n} \n"}
{"2991": "public class OCompositeIndexDefinition { \npublic void addIndex ( final OIndexDefinition indexDefinition ) { \nindexDefinitions . add ( indexDefinition ) ; \nif ( indexDefinition instanceof OIndexDefinitionMultiValue ) if ( multiValueDefinitionIndex == - 1 ) multiValueDefinitionIndex = indexDefinitions . size ( ) - 1 ; \nelse throw new OIndexException ( \"Composite key cannot contain more than one collection item\" ) ; \ncollate . addCollate ( indexDefinition . getCollate ( ) ) ; \n} \n} \n"}
{"2992": "public class OProjectionItem { \npublic OProjectionItem splitForAggregation ( AggregateProjectionSplit aggregateSplit , OCommandContext ctx ) { \nif ( isAggregate ( ) ) { \nOProjectionItem result = new OProjectionItem ( - 1 ) ; \nresult . alias = getProjectionAlias ( ) ; \nresult . expression = expression . splitForAggregation ( aggregateSplit , ctx ) ; \nresult . nestedProjection = nestedProjection ; \nreturn result ; \n} \nelse return this ; \n} \n} \n"}
{"2993": "public class OJson { \npublic Object toObjectDetermineType ( OResult source , OCommandContext ctx ) { \nString className = getClassNameForDocument ( ctx ) ; \nString type = getTypeForDocument ( ctx ) ; \nif ( className != null || ( type != null && \"d\" . equalsIgnoreCase ( type ) ) ) return toDocument ( source , ctx , className ) ; \nelse return toMap ( source , ctx ) ; \n} \n} \n"}
{"2994": "public class OSQLFilterItemField { \npublic OCollate getCollate ( Object doc ) { \nif ( collate != null || operationsChain == null || ! isFieldChain ( ) ) return collate ; \nif ( ! ( doc instanceof OIdentifiable ) ) return null ; \nFieldChain chain = getFieldChain ( ) ; \nODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; \nfor ( int i = 0 ; \ni < chain . getItemCount ( ) - 1 ; \ni ++ ) { \nif ( lastDoc == null ) return null ; \nObject nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; \nif ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) return null ; \nlastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; \n} \nif ( lastDoc == null ) return null ; \nOClass schemaClass = lastDoc . getSchemaClass ( ) ; \nif ( schemaClass == null ) return null ; \nOProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; \nif ( property == null ) return null ; \nreturn property . getCollate ( ) ; \n} \n} \n"}
{"2995": "public class OIdentifier { \npublic String getStringValue ( ) { \nif ( value == null ) return null ; \nif ( value . contains ( \"`\" ) ) return value . replaceAll ( \"\\\\\\\\`\" , \"`\" ) ; \nreturn value ; \n} \n} \n"}
{"2998": "public class OFileManager { \npublic static ODocument buildJsonFromFile ( String filePath ) throws IOException { \nif ( filePath == null ) return null ; \nFile jsonFile = new File ( filePath ) ; \nif ( ! jsonFile . exists ( ) ) return null ; \nFileInputStream is = new FileInputStream ( jsonFile ) ; \nBufferedReader rd = new BufferedReader ( new InputStreamReader ( is , Charset . forName ( \"UTF-8\" ) ) ) ; \nODocument json = new ODocument ( ) ; \nString jsonText = OFileManager . readAllTextFile ( rd ) ; \njson . fromJSON ( jsonText , \"noMap\" ) ; \nreturn json ; \n} \n} \n"}
{"3000": "public class OSecurityManager { \npublic String createHash ( final String iInput , final String iAlgorithm , final boolean iIncludeAlgorithm ) { \nif ( iInput == null ) throw new IllegalArgumentException ( \"Input string is null\" ) ; \nif ( iAlgorithm == null ) throw new IllegalArgumentException ( \"Algorithm is null\" ) ; \nfinal StringBuilder buffer = new StringBuilder ( 128 ) ; \nfinal String algorithm = validateAlgorithm ( iAlgorithm ) ; \nif ( iIncludeAlgorithm ) { \nbuffer . append ( '{' ) ; \nbuffer . append ( algorithm ) ; \nbuffer . append ( '}' ) ; \n} \nfinal String transformed ; \nif ( HASH_ALGORITHM . equalsIgnoreCase ( algorithm ) ) transformed = createSHA256 ( iInput ) ; \nelse if ( PBKDF2_ALGORITHM . equalsIgnoreCase ( algorithm ) ) transformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \nelse if ( PBKDF2_SHA256_ALGORITHM . equalsIgnoreCase ( algorithm ) ) transformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \nelse throw new IllegalArgumentException ( \"Algorithm '\" + algorithm + \"' is not supported\" ) ; \nbuffer . append ( transformed ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"3001": "public class OSecurityManager { \nprivate static boolean isAlgorithmSupported ( final String algorithm ) { \nif ( Runtime . class . getPackage ( ) != null && Runtime . class . getPackage ( ) . getImplementationVersion ( ) != null ) if ( Runtime . class . getPackage ( ) . getImplementationVersion ( ) . startsWith ( \"1.7\" ) ) if ( algorithm != null && algorithm . equals ( PBKDF2_SHA256_ALGORITHM ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3002": "public class OIndexAbstract { \npublic OIndexInternal < ? > create ( final OIndexDefinition indexDefinition , final String clusterIndexName , final Set < String > clustersToIndex , boolean rebuild , final OProgressListener progressListener , final OBinarySerializer valueSerializer ) { \nacquireExclusiveLock ( ) ; \ntry { \nconfiguration = indexConfigurationInstance ( new ODocument ( ) . setTrackingChanges ( false ) ) ; \nthis . indexDefinition = indexDefinition ; \nif ( clustersToIndex != null ) this . clustersToIndex = new HashSet < > ( clustersToIndex ) ; \nelse this . clustersToIndex = new HashSet < > ( ) ; \ntry { \nif ( apiVersion == 0 ) removeValuesContainer ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during deletion of index '%s'\" , e , name ) ; \n} \nindexId = storage . addIndexEngine ( name , algorithm , type , indexDefinition , valueSerializer , isAutomatic ( ) , true , version , 1 , this instanceof OIndexMultiValues , getEngineProperties ( ) , clustersToIndex , metadata ) ; \napiVersion = OAbstractPaginatedStorage . extractEngineAPIVersion ( indexId ) ; \nassert indexId >= 0 ; \nassert apiVersion >= 0 ; \nonIndexEngineChange ( indexId ) ; \nif ( rebuild ) fillIndex ( progressListener , false ) ; \nupdateConfiguration ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' creation\" , e , name ) ; \nwhile ( true ) try { \nif ( indexId >= 0 ) storage . deleteIndexEngine ( indexId ) ; \nbreak ; \n} \ncatch ( OInvalidIndexEngineIdException ignore ) { \ndoReloadIndexEngine ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' deletion\" , ex , name ) ; \n} \nif ( e instanceof OIndexException ) throw ( OIndexException ) e ; \nthrow OException . wrapException ( new OIndexException ( \"Cannot create the index '\" + name + \"'\" ) , e ) ; \n} \nfinally { \nreleaseExclusiveLock ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"3003": "public class OrientGraphQuery { \n@ Override public Iterable < Vertex > vertices ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nOTransaction transaction = ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) ; \nif ( transaction . isActive ( ) && transaction . getEntryCount ( ) > 0 || hasCustomPredicate ( ) ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) && labels != null && labels . length > 0 ) if ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \nelse { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nelse text . append ( OrientVertexType . CLASS_NAME ) ; \nfinal List < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; \nif ( orderBy . length ( ) > 1 ) { \ntext . append ( ORDERBY ) ; \ntext . append ( orderBy ) ; \ntext . append ( \" \" ) . append ( orderByDir ) . append ( \" \" ) ; \n} \nif ( skip > 0 && skip < Integer . MAX_VALUE ) { \ntext . append ( SKIP ) ; \ntext . append ( skip ) ; \n} \nif ( limit > 0 && limit < Integer . MAX_VALUE ) { \ntext . append ( LIMIT ) ; \ntext . append ( limit ) ; \n} \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nreturn new OrientElementIterable < Vertex > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3004": "public class OrientGraphQuery { \n@ Override public Iterable < Edge > edges ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nif ( ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) . isActive ( ) || hasCustomPredicate ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseLightweightEdges ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) && labels != null && labels . length > 0 ) if ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \nelse return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nelse text . append ( OrientEdgeType . CLASS_NAME ) ; \nList < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nif ( limit > 0 && limit < Integer . MAX_VALUE ) query . setLimit ( limit ) ; \nreturn new OrientElementIterable < Edge > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3008": "public class OAtomicOperation { \nprivate static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { \nif ( changesContainer == null ) return true ; \nelse if ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) return pageIndex < changesContainer . maxNewPageIndex + 1 ; \nelse return ! changesContainer . truncate ; \n} \n} \n"}
{"3011": "public class OSystemDatabase { \npublic void createCluster ( final String className , final String clusterName ) { \nfinal ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal ODatabaseDocumentInternal sysdb = openSystemDatabase ( ) ; \ntry { \nif ( ! sysdb . existsCluster ( clusterName ) ) { \nOSchema schema = sysdb . getMetadata ( ) . getSchema ( ) ; \nOClass cls = schema . getClass ( className ) ; \nif ( cls != null ) cls . addCluster ( clusterName ) ; \nelse OLogManager . instance ( ) . error ( this , \"createCluster() Class name %s does not exist\" , null , className ) ; \n} \n} \nfinally { \nsysdb . close ( ) ; \n} \n} \nfinally { \nif ( currentDB != null ) ODatabaseRecordThreadLocal . instance ( ) . set ( currentDB ) ; \nelse ODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \n} \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) return true ; \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) allDeletedRecords . add ( record ) ; \nif ( ! unsafe && record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) if ( cls . isSubClassOf ( \"V\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse if ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nrecord . delete ( ) ; \nrecordCount ++ ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \nfor ( int i = 0 ; \ni < parameterItems . size ( ) ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) value . setValue ( iArgs . get ( i ) ) ; \nelse value . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \n} \n"}
{"3024": "public class OPropertyImpl { \n@ Deprecated public OPropertyImpl dropIndexes ( ) { \ngetDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_DELETE ) ; \nacquireSchemaReadLock ( ) ; \ntry { \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal ArrayList < OIndex < ? > > relatedIndexes = new ArrayList < OIndex < ? > > ( ) ; \nfor ( final OIndex < ? > index : indexManager . getClassIndexes ( owner . getName ( ) ) ) { \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nif ( OCollections . indexOf ( definition . getFields ( ) , globalRef . getName ( ) , new OCaseInsentiveComparator ( ) ) > - 1 ) if ( definition instanceof OPropertyIndexDefinition ) relatedIndexes . add ( index ) ; \nelse throw new IllegalArgumentException ( \"This operation applicable only for property indexes. \" + index . getName ( ) + \" is \" + index . getDefinition ( ) ) ; \n} \nfor ( final OIndex < ? > index : relatedIndexes ) getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( index . getName ( ) ) ; \nreturn this ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3031": "public class ODatabaseDocumentEmbedded { \npublic ODatabaseDocumentInternal copy ( ) { \nODatabaseDocumentEmbedded database = new ODatabaseDocumentEmbedded ( getSharedContext ( ) . getStorage ( ) ) ; \ndatabase . init ( config , this . sharedContext ) ; \nString user ; \nif ( getUser ( ) != null ) user = getUser ( ) . getName ( ) ; \nelse user = null ; \ndatabase . internalOpen ( user , null , false ) ; \ndatabase . callOnOpenListeners ( ) ; \nthis . activateOnCurrentThread ( ) ; \nreturn database ; \n} \n} \n"}
{"3034": "public class OCommandExecutorUtility { \npublic static Object transformResult ( Object result ) { \nif ( java8MethodIsArray == null || ! ( result instanceof Map ) ) return result ; \ntry { \nif ( ( Boolean ) java8MethodIsArray . invoke ( result ) ) { \nList < ? > partial = new ArrayList ( ( ( Map ) result ) . values ( ) ) ; \nList < Object > finalResult = new ArrayList < Object > ( ) ; \nfor ( Object o : partial ) { \nfinalResult . add ( transformResult ( o ) ) ; \n} \nreturn finalResult ; \n} \nelse { \nMap < Object , Object > mapResult = ( Map ) result ; \nList < Object > keys = new ArrayList < Object > ( mapResult . keySet ( ) ) ; \nfor ( Object key : keys ) { \nmapResult . put ( key , transformResult ( mapResult . get ( key ) ) ) ; \n} \nreturn mapResult ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( OCommandExecutorUtility . class , \"\" , e ) ; \n} \nreturn result ; \n} \n} \n"}
{"3035": "public class OCommandExecutorSQLCreateCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal int clusterId = database . getClusterIdByName ( clusterName ) ; \nif ( clusterId > - 1 ) throw new OCommandSQLParsingException ( \"Cluster '\" + clusterName + \"' already exists\" ) ; \nif ( blob ) if ( requestedId == - 1 ) return database . addBlobCluster ( clusterName ) ; \nelse throw new OCommandExecutionException ( \"Request id not supported by blob cluster creation.\" ) ; \nelse if ( requestedId == - 1 ) return database . addCluster ( clusterName ) ; \nelse return database . addCluster ( clusterName , requestedId , null ) ; \n} \n} \n"}
{"3036": "public class ODatabasePoolAbstract { \npublic void close ( ) { \nlock ( ) ; \ntry { \nif ( this . evictionTask != null ) this . evictionTask . cancel ( ) ; \nfor ( Entry < String , OReentrantResourcePool < String , DB > > pool : pools . entrySet ( ) ) { \nfor ( DB db : pool . getValue ( ) . getResources ( ) ) { \npool . getValue ( ) . close ( ) ; \ntry { \nOLogManager . instance ( ) . debug ( this , \"Closing pooled database '%s'...\" , db . getName ( ) ) ; \n( ( ODatabasePooled ) db ) . forceClose ( ) ; \nOLogManager . instance ( ) . debug ( this , \"OK\" , db . getName ( ) ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . debug ( this , \"Error: %d\" , e . toString ( ) ) ; \n} \n} \n} \n} \nfinally { \nunlock ( ) ; \n} \n} \n} \n"}
{"3038": "public class OSQLEngine { \npublic static Set < String > getFunctionNames ( ) { \nfinal Set < String > types = new HashSet < String > ( ) ; \nfinal Iterator < OSQLFunctionFactory > ite = getFunctionFactories ( ) ; \nwhile ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getFunctionNames ( ) ) ; \nreturn types ; \n} \n} \n"}
{"3039": "public class OSQLEngine { \npublic static Set < String > getCollateNames ( ) { \nfinal Set < String > types = new HashSet < String > ( ) ; \nfinal Iterator < OCollateFactory > ite = getCollateFactories ( ) ; \nwhile ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getNames ( ) ) ; \nreturn types ; \n} \n} \n"}
{"3040": "public class OSQLEngine { \npublic static Set < String > getCommandNames ( ) { \nfinal Set < String > types = new HashSet < String > ( ) ; \nfinal Iterator < OCommandExecutorSQLFactory > ite = getCommandFactories ( ) ; \nwhile ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getCommandNames ( ) ) ; \nreturn types ; \n} \n} \n"}
{"3050": "public class OSBTreeCollectionManagerShared { \n@ Override public UUID listenForChanges ( ORidBag collection ) { \nUUID ownerUUID = collection . getTemporaryId ( ) ; \nif ( ownerUUID != null ) { \nfinal OBonsaiCollectionPointer pointer = collection . getPointer ( ) ; \nMap < UUID , OBonsaiCollectionPointer > changedPointers = collectionPointerChanges . get ( ) ; \nif ( pointer != null && pointer . isValid ( ) ) changedPointers . put ( ownerUUID , pointer ) ; \n} \nreturn null ; \n} \n} \n"}
{"3056": "public class OSessionStoragePerformanceStatistic { \npublic void pushComponentCounters ( String name , PerformanceCountersHolder holder ) { \nif ( snapshot == null ) return ; \nfinal PerformanceCountersHolder countersHolder = snapshot . countersByComponent . get ( name ) ; \nif ( countersHolder != null ) countersHolder . pushData ( holder ) ; \n} \n} \n"}
{"3063": "public class OStatementCache { \nprotected static OStatement parse ( String statement ) throws OCommandSQLParsingException { \ntry { \nODatabaseDocumentInternal db = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \nInputStream is ; \nif ( db == null ) is = new ByteArrayInputStream ( statement . getBytes ( ) ) ; \nelse try { \nis = new ByteArrayInputStream ( statement . getBytes ( db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e2 ) { \nOLogManager . instance ( ) . warn ( null , \"Unsupported charset for database \" + db + \" \" + db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nis = new ByteArrayInputStream ( statement . getBytes ( ) ) ; \n} \nOrientSql osql = null ; \nif ( db == null ) osql = new OrientSql ( is ) ; \nelse try { \nosql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \n} \ncatch ( UnsupportedEncodingException e2 ) { \nOLogManager . instance ( ) . warn ( null , \"Unsupported charset for database \" + db + \" \" + db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nosql = new OrientSql ( is ) ; \n} \nOStatement result = osql . parse ( ) ; \nresult . originalStatement = statement ; \nreturn result ; \n} \ncatch ( ParseException e ) { \nthrowParsingException ( e , statement ) ; \n} \ncatch ( TokenMgrError e2 ) { \nthrowParsingException ( e2 , statement ) ; \n} \nreturn null ; \n} \n} \n"}
{"3064": "public class ONodeManager { \nprotected void initReceiveMessages ( ) throws IOException { \nmessageThread = new Thread ( ( ) -> { \nwhile ( ! Thread . interrupted ( ) ) receiveMessages ( ) ; \n} \n) ; \nmessageThread . setName ( \"OrientDB_DistributedDiscoveryThread\" ) ; \nmessageThread . setDaemon ( true ) ; \nmessageThread . start ( ) ; \n} \n} \n"}
{"3065": "public class ONodeManager { \nprotected void initCheckDisconnect ( ) { \ndisconnectTimer = new TimerTask ( ) { \npublic void run ( ) { \ntry { \ncheckIfKnownServersAreAlive ( ) ; \nif ( running ) initCheckDisconnect ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n; \ntaskScheduler . scheduleOnce ( disconnectTimer , discoveryPingIntervalMillis ) ; \n} \n} \n"}
{"3069": "public class OrientElement { \nprotected String checkForClassInSchema ( final String className ) { \nif ( className == null ) return null ; \nOrientBaseGraph graph = getGraph ( ) ; \nif ( graph == null ) return className ; \nfinal OSchema schema = graph . getRawGraph ( ) . getMetadata ( ) . getSchema ( ) ; \nif ( ! schema . existsClass ( className ) ) try { \ngraph . executeOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nreturn schema . createClass ( className , schema . getClass ( getBaseClassName ( ) ) ) ; \n} \n} \n, \"Committing the active transaction to create the new type '\" , className , \"' as subclass of '\" , getBaseClassName ( ) , \"'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction\" ) ; \n} \ncatch ( OSchemaException e ) { \nif ( ! schema . existsClass ( className ) ) throw e ; \n} \nelse { \nfinal OClass cls = schema . getClass ( className ) ; \nif ( ! cls . isSubClassOf ( getBaseClassName ( ) ) ) throw new IllegalArgumentException ( \"Class '\" + className + \"' is not an instance of \" + getBaseClassName ( ) ) ; \n} \nreturn className ; \n} \n} \n"}
{"3070": "public class OIndexChangesWrapper { \npublic static OIndexCursor wrap ( OIndex < ? > source , OIndexCursor cursor , long indexRebuildVersion ) { \nif ( cursor instanceof OIndexChangesWrapper ) return cursor ; \nif ( cursor instanceof OSizeable ) return new OIndexChangesSizeable ( source , cursor , indexRebuildVersion ) ; \nreturn new OIndexChangesWrapper ( source , cursor , indexRebuildVersion ) ; \n} \n} \n"}
{"3073": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( iClass == null ) for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; \n} \nelse for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) if ( entry . getRecord ( ) != null && entry . getRecord ( ) instanceof ODocument ) if ( iPolymorphic ) if ( iClass . isSuperClassOf ( ( ( ODocument ) entry . getRecord ( ) ) . getSchemaClass ( ) ) ) result . add ( entry ) ; \nelse if ( iClass . getName ( ) . equals ( ( ( ODocument ) entry . getRecord ( ) ) . getClassName ( ) ) ) result . add ( entry ) ; \n} \nreturn result ; \n} \n} \n"}
{"3076": "public class ODirtyManager { \nprivate static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { \nif ( source != null ) if ( target == null ) return source ; \nelse if ( target . size ( ) > source . size ( ) ) { \ntarget . addAll ( source ) ; \nreturn target ; \n} \nelse { \nsource . addAll ( target ) ; \nreturn source ; \n} \nelse return target ; \n} \n} \n"}
{"3077": "public class OCommandExecutorSQLUpdate { \n@ SuppressWarnings ( \"unchecked\" ) public boolean result ( final Object iRecord ) { \nfinal ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( isUpdateEdge ( ) && ! isRecordInstanceOf ( iRecord , \"E\" ) ) throw new OCommandExecutionException ( \"Using UPDATE EDGE on a record that is not an instance of E\" ) ; \nif ( compiledFilter != null ) if ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) return false ; \nparameters . reset ( ) ; \nreturnHandler . beforeUpdate ( record ) ; \nboolean updated = handleContent ( record ) ; \nupdated |= handleMerge ( record ) ; \nupdated |= handleSetEntries ( record ) ; \nupdated |= handleIncrementEntries ( record ) ; \nupdated |= handleAddEntries ( record ) ; \nupdated |= handlePutEntries ( record ) ; \nupdated |= handleRemoveEntries ( record ) ; \nif ( updated ) { \nhandleUpdateEdge ( record ) ; \nrecord . setDirty ( ) ; \nrecord . save ( ) ; \nreturnHandler . afterUpdate ( record ) ; \nthis . updated = true ; \n} \nreturn true ; \n} \n} \n"}
{"3078": "public class OFunctionCall { \npublic boolean canExecuteIndexedFunctionWithoutIndex ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { \nOSQLFunction function = OSQLEngine . getInstance ( ) . getFunction ( name . getStringValue ( ) ) ; \nif ( function instanceof OIndexableSQLFunction ) return ( ( OIndexableSQLFunction ) function ) . canExecuteInline ( target , operator , right , context , this . getParams ( ) . toArray ( new OExpression [ ] { \n} \n) ) ; \nreturn false ; \n} \n} \n"}
{"3079": "public class OChainedIndexProxy { \nprivate Set < Comparable > prepareKeys ( OIndex < ? > index , Object keys ) { \nfinal OIndexDefinition indexDefinition = index . getDefinition ( ) ; \nif ( keys instanceof Collection ) { \nfinal Set < Comparable > newKeys = new TreeSet < Comparable > ( ) ; \nfor ( Object o : ( ( Collection ) keys ) ) { \nnewKeys . add ( ( Comparable ) indexDefinition . createValue ( o ) ) ; \n} \nreturn newKeys ; \n} \nelse return Collections . singleton ( ( Comparable ) indexDefinition . createValue ( keys ) ) ; \n} \n} \n"}
{"3080": "public class OWALSegmentCache { \nvoid writePage ( ByteBuffer page , long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache . size ( ) ) if ( pageIndex < firstCachedPage + pageCache . size ( ) ) pageCache . set ( ( int ) ( pageIndex - firstCachedPage ) , page ) ; \nelse pageCache . add ( page ) ; \nelse if ( pageCache . isEmpty ( ) ) { \npageCache . add ( page ) ; \nfirstCachedPage = pageIndex ; \n} \nlastWrittenPage = page ; \nlastWrittenPageIndex = pageIndex ; \nif ( pageCache . size ( ) * OWALPage . PAGE_SIZE >= bufferSize + OWALPage . PAGE_SIZE ) flushAllBufferPagesExceptLastOne ( ) ; \n} \n} \n} \n"}
{"3081": "public class OWALSegmentCache { \nbyte [ ] readPage ( long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( pageIndex == lastWrittenPageIndex ) return lastWrittenPage . array ( ) ; \nif ( pageIndex >= firstCachedPage && pageIndex < firstCachedPage + pageCache . size ( ) ) { \nfinal ByteBuffer buffer = pageCache . get ( ( int ) ( pageIndex - firstCachedPage ) ) ; \nreturn buffer . array ( ) ; \n} \nfinal ByteBuffer buffer = ByteBuffer . allocate ( OWALPage . PAGE_SIZE ) . order ( ByteOrder . nativeOrder ( ) ) ; \ninitFile ( ) ; \nsegChannel . position ( pageIndex * OWALPage . PAGE_SIZE ) ; \nreadByteBuffer ( buffer , segChannel ) ; \nreturn buffer . array ( ) ; \n} \n} \n} \n"}
{"3084": "public class ODistributedConfiguration { \npublic boolean isReplicationActive ( final String iClusterName , final String iLocalNode ) { \nfinal Collection < String > servers = getClusterConfiguration ( iClusterName ) . field ( SERVERS ) ; \nif ( servers != null && ! servers . isEmpty ( ) ) return true ; \nreturn false ; \n} \n} \n"}
{"3088": "public class ODistributedConfiguration { \npublic Map < String , Collection < String > > getServerClusterMap ( Collection < String > iClusterNames , final String iLocalNode , final boolean optimizeForLocalOnly ) { \nif ( iClusterNames == null || iClusterNames . isEmpty ( ) ) iClusterNames = DEFAULT_CLUSTER_NAME ; \nfinal Map < String , Collection < String > > servers = new HashMap < String , Collection < String > > ( iClusterNames . size ( ) ) ; \nboolean canUseLocalNode = true ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null && ! serverList . contains ( iLocalNode ) ) { \ncanUseLocalNode = false ; \nbreak ; \n} \n} \nif ( optimizeForLocalOnly && canUseLocalNode ) { \nservers . put ( iLocalNode , iClusterNames ) ; \nreturn servers ; \n} \nfinal Map < String , Collection < String > > serverMap = new HashMap < String , Collection < String > > ( ) ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nfor ( String s : serverList ) { \nif ( NEW_NODE_TAG . equalsIgnoreCase ( s ) ) continue ; \nCollection < String > clustersInServer = serverMap . get ( s ) ; \nif ( clustersInServer == null ) { \nclustersInServer = new HashSet < String > ( ) ; \nserverMap . put ( s , clustersInServer ) ; \n} \nclustersInServer . add ( p ) ; \n} \n} \nif ( serverMap . size ( ) == 1 ) return serverMap ; \nif ( ! optimizeForLocalOnly ) return serverMap ; \nfinal List < String > orderedServers = new ArrayList < String > ( serverMap . keySet ( ) ) ; \nCollections . sort ( orderedServers , new Comparator < String > ( ) { \n@ Override public int compare ( final String o1 , final String o2 ) { \nreturn ( ( Integer ) serverMap . get ( o2 ) . size ( ) ) . compareTo ( ( Integer ) serverMap . get ( o1 ) . size ( ) ) ; \n} \n} \n) ; \nfinal Set < String > remainingClusters = new HashSet < String > ( iClusterNames ) ; \nfinal Set < String > includedClusters = new HashSet < String > ( iClusterNames . size ( ) ) ; \nfor ( String s : orderedServers ) { \nfinal Collection < String > clusters = serverMap . get ( s ) ; \nif ( ! servers . isEmpty ( ) ) clusters . removeAll ( includedClusters ) ; \nservers . put ( s , clusters ) ; \nremainingClusters . removeAll ( clusters ) ; \nincludedClusters . addAll ( clusters ) ; \nif ( remainingClusters . isEmpty ( ) ) break ; \n} \nreturn servers ; \n} \n} \n"}
{"3089": "public class ODistributedConfiguration { \npublic Set < String > getServers ( Collection < String > iClusterNames ) { \nif ( iClusterNames == null || iClusterNames . isEmpty ( ) ) return getAllConfiguredServers ( ) ; \nfinal Set < String > partitions = new HashSet < String > ( iClusterNames . size ( ) ) ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null ) for ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) partitions . add ( s ) ; \n} \nreturn partitions ; \n} \n} \n"}
{"3090": "public class ODistributedConfiguration { \npublic boolean isServerContainingAllClusters ( final String server , Collection < String > clusters ) { \nif ( clusters == null || clusters . isEmpty ( ) ) clusters = DEFAULT_CLUSTER_NAME ; \nfor ( String cluster : clusters ) { \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) if ( ! serverList . contains ( server ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3091": "public class ODistributedConfiguration { \npublic boolean isServerContainingCluster ( final String server , String cluster ) { \nif ( cluster == null ) cluster = ALL_WILDCARD ; \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) return serverList . contains ( server ) ; \nreturn true ; \n} \n} \n"}
{"3092": "public class ODistributedConfiguration { \npublic List < String > getMasterServers ( ) { \nfinal List < String > serverList = getClusterConfiguration ( null ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nList < String > masters = new ArrayList < String > ( serverList . size ( ) ) ; \nfor ( String s : serverList ) { \nif ( ! s . equals ( NEW_NODE_TAG ) ) masters . add ( s ) ; \n} \nfinal ROLES defRole = getDefaultServerRole ( ) ; \nfinal ODocument servers = configuration . field ( SERVERS ) ; \nif ( servers != null ) for ( Iterator < String > it = masters . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nfinal String server = it . next ( ) ; \nfinal String roleAsString = servers . field ( server ) ; \nfinal ROLES role = roleAsString != null ? ROLES . valueOf ( roleAsString . toUpperCase ( Locale . ENGLISH ) ) : defRole ; \nif ( role != ROLES . MASTER ) it . remove ( ) ; \n} \nreturn masters ; \n} \nreturn Collections . EMPTY_LIST ; \n} \n} \n"}
{"3093": "public class ODistributedConfiguration { \npublic Set < String > getAllConfiguredServers ( ) { \nfinal Set < String > servers = new HashSet < String > ( ) ; \nfor ( String p : getClusterNames ( ) ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null ) for ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) servers . add ( s ) ; \n} \nreturn servers ; \n} \n} \n"}
{"3101": "public class ODistributedConfiguration { \npublic int getDataCenterWriteQuorum ( final String dataCenter ) { \nfinal ODocument dc = getDataCenterConfiguration ( dataCenter ) ; \nObject wq = dc . field ( WRITE_QUORUM ) ; \nif ( wq instanceof String ) if ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_MAJORITY ) ) { \nfinal List < String > servers = dc . field ( SERVERS ) ; \nwq = servers . size ( ) / 2 + 1 ; \n} \nelse if ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_ALL ) ) { \nfinal List < String > servers = dc . field ( SERVERS ) ; \nwq = servers . size ( ) ; \n} \nreturn ( Integer ) wq ; \n} \n} \n"}
{"3102": "public class ODistributedConfiguration { \npublic boolean isSharded ( ) { \nfinal ODocument allCluster = getClusterConfiguration ( ALL_WILDCARD ) ; \nif ( allCluster != null ) { \nfinal List < String > allServers = allCluster . field ( SERVERS ) ; \nif ( allServers != null && ! allServers . isEmpty ( ) ) for ( String cl : getClusterNames ( ) ) { \nfinal List < String > servers = getServers ( cl , null ) ; \nif ( servers != null && ! servers . isEmpty ( ) && ! allServers . containsAll ( servers ) ) return false ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3104": "public class ODistributedConfiguration { \npublic String getDataCenterOfServer ( final String server ) { \nfinal ODocument dcs = configuration . field ( DCS ) ; \nif ( dcs != null ) for ( String dc : dcs . fieldNames ( ) ) { \nfinal ODocument dcConfig = dcs . field ( dc ) ; \nif ( dcConfig != null ) { \nfinal List < String > dcServers = dcConfig . field ( \"servers\" ) ; \nif ( dcServers != null && ! dcServers . isEmpty ( ) ) if ( dcServers . contains ( server ) ) return dc ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3111": "public class OrientBaseGraph { \npublic void dropIndex ( final String indexName ) { \nmakeActive ( ) ; \nexecuteOutsideTx ( new OCallable < Object , OrientBaseGraph > ( ) { \n@ Override public Object call ( OrientBaseGraph g ) { \ntry { \nfinal OIndexManager indexManager = getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal OIndex index = indexManager . getIndex ( indexName ) ; \nODocument metadata = index . getConfiguration ( ) . field ( \"metadata\" ) ; \nString recordMapIndexName = null ; \nif ( metadata != null ) recordMapIndexName = metadata . field ( OrientIndex . CONFIG_RECORD_MAP_NAME ) ; \nindexManager . dropIndex ( indexName ) ; \nif ( recordMapIndexName != null ) getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( recordMapIndexName ) ; \nsaveIndexConfiguration ( ) ; \nreturn null ; \n} \ncatch ( Exception e ) { \ng . rollback ( ) ; \nthrow new RuntimeException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n, \"drop index '\" , indexName , \"'\" ) ; \n} \n} \n"}
{"3113": "public class OrientBaseGraph { \n@ Override public OrientEdge addEdge ( final Object id , Vertex outVertex , Vertex inVertex , final String label ) { \nmakeActive ( ) ; \nString className = null ; \nString clusterName = null ; \nif ( id != null ) if ( id instanceof String ) { \nfinal String [ ] args = ( ( String ) id ) . split ( \",\" ) ; \nfor ( String s : args ) { \nif ( s . startsWith ( CLASS_PREFIX ) ) className = s . substring ( CLASS_PREFIX . length ( ) ) ; \nelse if ( s . startsWith ( CLUSTER_PREFIX ) ) clusterName = s . substring ( CLUSTER_PREFIX . length ( ) ) ; \n} \n} \nfinal Object [ ] fields = isSaveOriginalIds ( ) && id != null ? new Object [ ] { \nOrientElement . DEF_ORIGINAL_ID_FIELDNAME , id } \n: null ; \nif ( outVertex instanceof PartitionVertex ) outVertex = ( ( PartitionVertex ) outVertex ) . getBaseVertex ( ) ; \nif ( inVertex instanceof PartitionVertex ) inVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; \nreturn ( ( OrientVertex ) outVertex ) . addEdge ( label , ( OrientVertex ) inVertex , className , clusterName , fields ) ; \n} \n} \n"}
{"3114": "public class OrientBaseGraph { \npublic OrientVertex getVertex ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . vertexIdCanNotBeNull ( ) ; \nif ( id instanceof OrientVertex ) return ( OrientVertex ) id ; \nelse if ( id instanceof ODocument ) return getVertexInstance ( ( OIdentifiable ) id ) ; \nsetCurrentGraphInThreadLocal ( ) ; \nORID rid ; \nif ( id instanceof OIdentifiable ) rid = ( ( OIdentifiable ) id ) . getIdentity ( ) ; \nelse try { \nrid = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \nif ( ! rid . isValid ( ) ) return null ; \nfinal ORecord rec = rid . getRecord ( ) ; \nif ( rec == null || ! ( rec instanceof ODocument ) ) return null ; \nfinal OClass cls = ( ( ODocument ) rec ) . getSchemaClass ( ) ; \nif ( cls != null && cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\" ) ; \nreturn getVertexInstance ( rec ) ; \n} \n} \n"}
{"3119": "public class OrientBaseGraph { \npublic void shutdown ( boolean closeDb , boolean commitTx ) { \nmakeActive ( ) ; \ntry { \nif ( ! isClosed ( ) ) if ( commitTx ) { \nfinal OStorage storage = getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ; \nif ( storage instanceof OAbstractPaginatedStorage ) if ( ( ( OAbstractPaginatedStorage ) storage ) . getWALInstance ( ) != null ) getDatabase ( ) . commit ( ) ; \nelse getDatabase ( ) . commit ( ) ; \n} \nelse if ( closeDb ) getDatabase ( ) . rollback ( ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow e ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow OException . wrapException ( new ODatabaseException ( \"Error during context close for db \" + url ) , e ) ; \n} \nfinally { \ntry { \nif ( closeDb ) { \ngetDatabase ( ) . close ( ) ; \nif ( getDatabase ( ) . isPooled ( ) ) database = null ; \n} \npollGraphFromStack ( closeDb ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \n} \n} \nurl = null ; \nusername = null ; \npassword = null ; \nif ( ! closeDb ) getDatabase ( ) . activateOnCurrentThread ( ) ; \n} \n} \n"}
{"3129": "public class OWOWCache { \n@ Override public void removeBackgroundExceptionListener ( final OBackgroundExceptionListener listener ) { \nfinal List < WeakReference < OBackgroundExceptionListener > > itemsToRemove = new ArrayList < > ( 1 ) ; \nfor ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { \nfinal OBackgroundExceptionListener l = ref . get ( ) ; \nif ( l != null && l . equals ( listener ) ) itemsToRemove . add ( ref ) ; \n} \nbackgroundExceptionListeners . removeAll ( itemsToRemove ) ; \n} \n} \n"}
{"3130": "public class OWOWCache { \nprivate void fireBackgroundDataFlushExceptionEvent ( final Throwable e ) { \nfor ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { \nfinal OBackgroundExceptionListener listener = ref . get ( ) ; \nif ( listener != null ) listener . onException ( e ) ; \n} \n} \n} \n"}
{"3132": "public class OPerformanceStatisticManager { \npublic void registerMBean ( String storageName , int storageId ) { \nif ( mbeanIsRegistered . compareAndSet ( false , true ) ) try { \nfinal MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; \nfinal ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; \nif ( ! server . isRegistered ( mbeanName ) ) server . registerMBean ( new OPerformanceStatisticManagerMBean ( this ) , mbeanName ) ; \nelse { \nmbeanIsRegistered . set ( false ) ; \nOLogManager . instance ( ) . warn ( this , \"MBean with name %s has already registered. Probably your system was not shutdown correctly\" + \" or you have several running applications which use OrientDB engine inside\" , mbeanName . getCanonicalName ( ) ) ; \n} \n} \ncatch ( MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during registration of profiler MBean\" ) , e ) ; \n} \n} \n} \n"}
{"3133": "public class OPerformanceStatisticManager { \npublic void unregisterMBean ( String storageName , int storageId ) { \nif ( storageName == null ) OLogManager . instance ( ) . warnNoDb ( this , \"Can not unregister MBean for performance statistics, storage name is null\" ) ; \nif ( mbeanIsRegistered . compareAndSet ( true , false ) ) try { \nfinal MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; \nfinal ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; \nserver . unregisterMBean ( mbeanName ) ; \n} \ncatch ( MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during unregistration of profiler MBean\" ) , e ) ; \n} \n} \n} \n"}
{"3134": "public class OPerformanceStatisticManager { \nprivate WritCacheCountersHolder fetchWriteCacheCounters ( ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nWritCacheCountersHolder holder = null ; \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nif ( snapshot . writCacheCountersHolder != null ) { \nif ( holder == null ) holder = new WritCacheCountersHolder ( ) ; \nsnapshot . writCacheCountersHolder . pushData ( holder ) ; \n} \n} \nelse threadsToRemove . add ( thread ) ; \n} \nif ( ! threadsToRemove . isEmpty ( ) ) updateDeadThreadsStatistic ( threadsToRemove ) ; \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal WritCacheCountersHolder wch = ds . writCacheCountersHolder ; \nif ( wch != null ) { \nif ( holder == null ) holder = new WritCacheCountersHolder ( ) ; \nwch . pushData ( holder ) ; \n} \n} \nreturn holder ; \n} \n} \n"}
{"3135": "public class OPerformanceStatisticManager { \nprivate void fetchSystemCounters ( PerformanceCountersHolder countersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nsnapshot . performanceCountersHolder . pushData ( countersHolder ) ; \n} \nelse threadsToRemove . add ( thread ) ; \n} \nif ( ! threadsToRemove . isEmpty ( ) ) updateDeadThreadsStatistic ( threadsToRemove ) ; \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersHolder ; \ndch . pushData ( countersHolder ) ; \n} \n} \n} \n"}
{"3136": "public class OPerformanceStatisticManager { \nprivate void fetchComponentCounters ( String componentName , PerformanceCountersHolder componentCountersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal List < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nfinal PerformanceCountersHolder holder = snapshot . countersByComponent . get ( componentName ) ; \nif ( holder != null ) holder . pushData ( componentCountersHolder ) ; \n} \nelse threadsToRemove . add ( thread ) ; \n} \nif ( ! threadsToRemove . isEmpty ( ) ) updateDeadThreadsStatistic ( threadsToRemove ) ; \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersByComponents . get ( componentName ) ; \nif ( dch != null ) dch . pushData ( componentCountersHolder ) ; \n} \n} \n} \n"}
{"3137": "public class OHttpResponse { \npublic byte [ ] compress ( String jsonStr ) { \nif ( jsonStr == null || jsonStr . length ( ) == 0 ) return null ; \nGZIPOutputStream gout = null ; \nByteArrayOutputStream baos = null ; \ntry { \nbyte [ ] incoming = jsonStr . getBytes ( \"UTF-8\" ) ; \nbaos = new ByteArrayOutputStream ( ) ; \ngout = new GZIPOutputStream ( baos , 16384 ) ; \ngout . write ( incoming ) ; \ngout . finish ( ) ; \nreturn baos . toByteArray ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Error on compressing HTTP response\" , ex ) ; \n} \nfinally { \ntry { \nif ( gout != null ) gout . close ( ) ; \nif ( baos != null ) baos . close ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nreturn null ; \n} \n} \n"}
{"3144": "public class OIndexes { \nprivate static Set < String > getIndexTypes ( ) { \nfinal Set < String > types = new HashSet < > ( ) ; \nfinal Iterator < OIndexFactory > ite = getAllFactories ( ) ; \nwhile ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getTypes ( ) ) ; \nreturn types ; \n} \n} \n"}
{"3145": "public class OIndexes { \npublic static Set < String > getIndexEngines ( ) { \nfinal Set < String > engines = new HashSet < > ( ) ; \nfinal Iterator < OIndexFactory > ite = getAllFactories ( ) ; \nwhile ( ite . hasNext ( ) ) engines . addAll ( ite . next ( ) . getAlgorithms ( ) ) ; \nreturn engines ; \n} \n} \n"}
{"3147": "public class ODistributedResponseManagerImpl { \nprotected List < ODistributedResponse > getConflictResponses ( ) { \nfinal List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; \nint bestGroupSoFar = getBestResponsesGroup ( ) ; \nfor ( int i = 0 ; \ni < responseGroups . size ( ) ; \n++ i ) if ( i != bestGroupSoFar ) for ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; \nreturn servers ; \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) for ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \nelse if ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3151": "public class OExecutionPlanCache { \npublic static OExecutionPlan get ( String statement , OCommandContext ctx , ODatabaseDocumentInternal db ) { \nif ( db == null ) throw new IllegalArgumentException ( \"DB cannot be null\" ) ; \nif ( statement == null ) return null ; \nOExecutionPlanCache resource = db . getSharedContext ( ) . getExecutionPlanCache ( ) ; \nOExecutionPlan result = resource . getInternal ( statement , ctx , db ) ; \nreturn result ; \n} \n} \n"}
{"3154": "public class OScriptManager { \npublic void releaseDatabaseEngine ( final String iLanguage , final String iDatabaseName , final OPartitionedObjectPool . PoolEntry < ScriptEngine > poolEntry ) { \nfinal ODatabaseScriptManager dbManager = dbManagers . get ( iDatabaseName ) ; \nif ( dbManager != null ) dbManager . releaseEngine ( iLanguage , poolEntry ) ; \n} \n} \n"}
{"3156": "public class OSBTreeRidBag { \nprivate int updateSize ( ) { \nint size = 0 ; \nif ( collectionPointer != null ) { \nfinal OSBTreeBonsai < OIdentifiable , Integer > tree = loadTree ( ) ; \nif ( tree == null ) throw new IllegalStateException ( \"RidBag is not properly initialized, can not load tree implementation\" ) ; \ntry { \nsize = tree . getRealBagSize ( changes ) ; \n} \nfinally { \nreleaseTree ( ) ; \n} \n} \nelse for ( Change change : changes . values ( ) ) { \nsize += change . applyTo ( 0 ) ; \n} \nfor ( OModifiableInteger diff : newEntries . values ( ) ) { \nsize += diff . getValue ( ) ; \n} \nthis . size = size ; \nreturn size ; \n} \n} \n"}
{"3157": "public class OHashIndexBucket { \npublic V getValue ( int index ) { \nint entryPosition = getIntValue ( POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer . INT_SIZE ) ; \nentryPosition += OLongSerializer . LONG_SIZE ; \nif ( encryption == null ) entryPosition += getObjectSizeInDirectMemory ( keySerializer , entryPosition ) ; \nelse { \nfinal int encryptedLength = getIntValue ( entryPosition ) ; \nentryPosition += encryptedLength + OIntegerSerializer . INT_SIZE ; \n} \nreturn deserializeFromDirectMemory ( valueSerializer , entryPosition ) ; \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) return false ; \nif ( ! index . supportsOrderedIterations ( ) ) return false ; \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nint endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \nfor ( int i = 0 ; \ni < endIndex ; \ni ++ ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) return false ; \nfor ( int i = equalsFilterFields . size ( ) ; \ni < endIndex ; \ni ++ ) { \nint fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) if ( iText . charAt ( i + 1 ) == 'u' ) i = readUnicode ( iText , i + 2 , buffer ) ; \nelse escape = true ; \nelse { \nif ( c == '\\'' || c == '\"' ) if ( stringChar == ' ' ) stringChar = c ; \nelse if ( ! escape && c == stringChar ) stringChar = ' ' ; \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nif ( iFrom < iTo ) if ( ++ i > iTo ) break ; \nelse if ( -- i < iFrom ) break ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3161": "public class OStringParser { \npublic static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { \nif ( iCurrentPosition < 0 ) return - 1 ; \nfinal int size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; \nfinal int jumpCharSize = iJumpChars . length ( ) ; \nboolean found = true ; \nchar c ; \nfor ( ; \niCurrentPosition < size ; \n++ iCurrentPosition ) { \nfound = false ; \nc = iText . charAt ( iCurrentPosition ) ; \nfor ( int jumpIndex = 0 ; \njumpIndex < jumpCharSize ; \n++ jumpIndex ) if ( iJumpChars . charAt ( jumpIndex ) == c ) { \nfound = true ; \nbreak ; \n} \nif ( ! found ) break ; \n} \nreturn iCurrentPosition >= size ? - 1 : iCurrentPosition ; \n} \n} \n"}
{"3166": "public class OMatchExecutionPlanner { \nprivate Map < String , Set < String > > getDependencies ( Pattern pattern ) { \nMap < String , Set < String > > result = new HashMap < String , Set < String > > ( ) ; \nfor ( PatternNode node : pattern . aliasToNode . values ( ) ) { \nSet < String > currentDependencies = new HashSet < String > ( ) ; \nOWhereClause filter = aliasFilters . get ( node . alias ) ; \nif ( filter != null && filter . getBaseExpression ( ) != null ) { \nList < String > involvedAliases = filter . getBaseExpression ( ) . getMatchPatternInvolvedAliases ( ) ; \nif ( involvedAliases != null ) currentDependencies . addAll ( involvedAliases ) ; \n} \nresult . put ( node . alias , currentDependencies ) ; \n} \nreturn result ; \n} \n} \n"}
{"3169": "public class OEntityManager { \npublic synchronized void registerEntityClasses ( Class < ? > aClass , boolean recursive ) { \nif ( recursive ) { \nclassHandler . registerEntityClass ( aClass ) ; \nField [ ] declaredFields = aClass . getDeclaredFields ( ) ; \nfor ( Field declaredField : declaredFields ) { \nClass < ? > declaredFieldType = declaredField . getType ( ) ; \nif ( ! classHandler . containsEntityClass ( declaredFieldType ) ) registerEntityClasses ( declaredFieldType , recursive ) ; \n} \n} \nelse classHandler . registerEntityClass ( aClass ) ; \n} \n} \n"}
{"3174": "public class OCommandExecutorSQLHASyncCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \ndatabase . checkSecurity ( ORule . ResourceGeneric . CLUSTER , \"sync\" , ORole . PERMISSION_UPDATE ) ; \nif ( ! ( database instanceof ODatabaseDocumentDistributed ) ) throw new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \nfinal OHazelcastPlugin dManager = ( OHazelcastPlugin ) ( ( ODatabaseDocumentDistributed ) database ) . getDistributedManager ( ) ; \nif ( dManager == null || ! dManager . isEnabled ( ) ) throw new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \nfinal String databaseName = database . getName ( ) ; \ntry { \nif ( this . parsedStatement . modeFull ) return replaceCluster ( dManager , database , dManager . getServerInstance ( ) , databaseName , this . parsedStatement . clusterName . getStringValue ( ) ) ; \n} \ncatch ( Exception e ) { \nthrow OException . wrapException ( new OCommandExecutionException ( \"Cannot execute synchronization of cluster\" ) , e ) ; \n} \nreturn \"Mode not supported\" ; \n} \n} \n"}
{"3182": "public class OETLHandler { \npublic ODocument status ( ) { \nODocument status = new ODocument ( ) ; \nCollection < ODocument > jobs = new ArrayList < ODocument > ( ) ; \nif ( currentJob != null ) jobs . add ( currentJob . status ( ) ) ; \nstatus . field ( \"jobs\" , jobs ) ; \nreturn status ; \n} \n} \n"}
{"3185": "public class OSymmetricKey { \npublic static OSymmetricKey fromConfig ( final OSymmetricKeyConfig keyConfig ) { \nif ( keyConfig . usesKeyString ( ) ) return fromString ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyString ( ) ) ; \nelse if ( keyConfig . usesKeyFile ( ) ) return fromFile ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyFile ( ) ) ; \nelse if ( keyConfig . usesKeystore ( ) ) return fromKeystore ( keyConfig . getKeystoreFile ( ) , keyConfig . getKeystorePassword ( ) , keyConfig . getKeystoreKeyAlias ( ) , keyConfig . getKeystoreKeyPassword ( ) ) ; \nelse throw new OSecurityException ( \"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\" ) ; \n} \n} \n"}
{"3191": "public class OBasicCommandContext { \npublic OCommandContext setChild ( final OCommandContext iContext ) { \nif ( iContext == null ) if ( child != null ) { \nchild . setParent ( null ) ; \nchild = null ; \n} \nelse if ( child != iContext ) { \nchild = iContext ; \niContext . setParent ( this ) ; \n} \nreturn this ; \n} \n} \n"}
{"3192": "public class OBasicCommandContext { \npublic synchronized boolean addToUniqueResult ( Object o ) { \nObject toAdd = o ; \nif ( o instanceof ODocument && ( ( ODocument ) o ) . getIdentity ( ) . isNew ( ) ) toAdd = new ODocumentEqualityWrapper ( ( ODocument ) o ) ; \nreturn this . uniqueResult . add ( toAdd ) ; \n} \n} \n"}
{"3193": "public class ORecordSerializerJSON { \nprivate Object getValueAsObjectOrMap ( ODocument iRecord , String iFieldValue , OType iType , OType iLinkedType , Map < String , Character > iFieldTypes , boolean iNoMap , String iOptions ) { \nfinal String [ ] fields = OStringParser . getWords ( iFieldValue . substring ( 1 , iFieldValue . length ( ) - 1 ) , \":,\" , true ) ; \nif ( fields == null || fields . length == 0 ) if ( iNoMap ) { \nODocument res = new ODocument ( ) ; \nODocumentInternal . addOwner ( res , iRecord ) ; \nreturn res ; \n} \nelse return new HashMap < String , Object > ( ) ; \nif ( iNoMap || hasTypeField ( fields ) ) return getValueAsRecord ( iRecord , iFieldValue , iType , iOptions , fields ) ; \nelse return getValueAsMap ( iRecord , iFieldValue , iLinkedType , iFieldTypes , false , iOptions , fields ) ; \n} \n} \n"}
{"3194": "public class OServerCommandPostAuthToken { \nprotected String authenticate ( final String username , final String password , final String iDatabaseName ) throws IOException { \nODatabaseDocument db = null ; \nString userRid = null ; \ntry { \ndb = ( ODatabaseDocument ) server . openDatabase ( iDatabaseName , username , password ) ; \nuserRid = ( db . getUser ( ) == null ? \"<server user>\" : db . getUser ( ) . getDocument ( ) . getIdentity ( ) . toString ( ) ) ; \n} \ncatch ( OSecurityAccessException e ) { \n} \ncatch ( OLockException e ) { \nOLogManager . instance ( ) . error ( this , \"Cannot access to the database '\" + iDatabaseName + \"'\" , e ) ; \n} \nfinally { \nif ( db != null ) db . close ( ) ; \n} \nreturn userRid ; \n} \n} \n"}
{"3198": "public class OrientGraphFactory { \npublic OrientGraph getTx ( ) { \nfinal OrientGraph g ; \nif ( pool == null ) g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; \nelse g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; \ninitGraph ( g ) ; \nreturn g ; \n} \n} \n"}
{"3199": "public class OrientGraphFactory { \npublic OrientGraphNoTx getNoTx ( ) { \nfinal OrientGraphNoTx g ; \nif ( pool == null ) g = ( OrientGraphNoTx ) getNoTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; \nelse g = ( OrientGraphNoTx ) getNoTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; \ninitGraph ( g ) ; \nreturn g ; \n} \n} \n"}
{"3200": "public class OrientGraphFactory { \npublic OrientGraphFactory setupPool ( final int iMin , final int iMax ) { \nif ( pool != null ) pool . close ( ) ; \npool = new OPartitionedDatabasePool ( url , user , password , 8 , iMax ) . setAutoCreate ( true ) ; \nproperties . entrySet ( ) . forEach ( p -> pool . setProperty ( p . getKey ( ) , p . getValue ( ) ) ) ; \nreturn this ; \n} \n} \n"}
{"3203": "public class OrientSql { \nfinal public OStatement parse ( ) throws ParseException { \nOparse jjtn000 = new Oparse ( JJTPARSE ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \njjtn000 . jjtSetFirstToken ( getToken ( 1 ) ) ; \nOStatement result ; \ntry { \nresult = Statement ( ) ; \njj_consume_token ( 0 ) ; \njjtree . closeNodeScope ( jjtn000 , true ) ; \njjtc000 = false ; \njjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; \n{ \nif ( true ) return result ; \n} \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse jjtree . popNode ( ) ; \nif ( jjte000 instanceof RuntimeException ) { \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \nif ( jjte000 instanceof ParseException ) { \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \njjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; \n} \n} \nthrow new Error ( \"Missing return statement in function\" ) ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) if ( t . next != null ) t = t . next ; \nelse t = t . next = token_source . getNextToken ( ) ; \nreturn t ; \n} \n} \n"}
{"3206": "public class OrientSql { \npublic ParseException generateParseException ( ) { \njj_expentries . clear ( ) ; \nboolean [ ] la1tokens = new boolean [ 279 ] ; \nif ( jj_kind >= 0 ) { \nla1tokens [ jj_kind ] = true ; \njj_kind = - 1 ; \n} \nfor ( int i = 0 ; \ni < 424 ; \ni ++ ) if ( jj_la1 [ i ] == jj_gen ) for ( int j = 0 ; \nj < 32 ; \nj ++ ) { \nif ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ j ] = true ; \nif ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 32 + j ] = true ; \nif ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 64 + j ] = true ; \nif ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 96 + j ] = true ; \nif ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 128 + j ] = true ; \nif ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 160 + j ] = true ; \nif ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 192 + j ] = true ; \nif ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 224 + j ] = true ; \nif ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 256 + j ] = true ; \n} \nfor ( int i = 0 ; \ni < 279 ; \ni ++ ) if ( la1tokens [ i ] ) { \njj_expentry = new int [ 1 ] ; \njj_expentry [ 0 ] = i ; \njj_expentries . add ( jj_expentry ) ; \n} \njj_endpos = 0 ; \njj_rescan_token ( ) ; \njj_add_error_token ( 0 , 0 ) ; \nint [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; \nfor ( int i = 0 ; \ni < jj_expentries . size ( ) ; \ni ++ ) exptokseq [ i ] = jj_expentries . get ( i ) ; \nreturn new ParseException ( token , exptokseq , tokenImage ) ; \n} \n} \n"}
{"3207": "public class OrientVertex { \n@ Override public Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { \nsetCurrentGraphInThreadLocal ( ) ; \nOrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; \nOrientBaseGraph . encodeClassNames ( iLabels ) ; \nfinal ODocument doc = getRecord ( ) ; \nfinal OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; \nfor ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { \nString fieldName = connectionField . getKey ( ) ; \nOPair < Direction , String > connection = connectionField . getValue ( ) ; \nfinal Object fieldValue = doc . rawField ( fieldName ) ; \nif ( fieldValue != null ) if ( fieldValue instanceof OIdentifiable ) addSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; \nelse if ( fieldValue instanceof Collection < ? > ) { \nCollection < ? > coll = ( Collection < ? > ) fieldValue ; \nif ( coll . size ( ) == 1 ) if ( coll instanceof ORecordLazyMultiValue ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) . next ( ) , iLabels ) ; \nelse if ( coll instanceof List < ? > ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( List < ? > ) coll ) . get ( 0 ) , iLabels ) ; \nelse addSingleVertex ( doc , iterable , fieldName , connection , coll . iterator ( ) . next ( ) , iLabels ) ; \nelse if ( coll instanceof ORecordLazyMultiValue ) iterable . add ( new OrientVertexIterator ( this , coll , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) , connection , iLabels , coll . size ( ) ) ) ; \nelse iterable . add ( new OrientVertexIterator ( this , coll , coll . iterator ( ) , connection , iLabels , - 1 ) ) ; \n} \nelse if ( fieldValue instanceof ORidBag ) iterable . add ( new OrientVertexIterator ( this , fieldValue , ( ( ORidBag ) fieldValue ) . rawIterator ( ) , connection , iLabels , - 1 ) ) ; \n} \nreturn iterable ; \n} \n} \n"}
{"3208": "public class OrientVertex { \n@ Override public void remove ( ) { \ncheckClass ( ) ; \nfinal OrientBaseGraph graph = checkIfAttached ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nfinal ODocument doc = getRecord ( ) ; \nif ( doc == null ) throw ExceptionFactory . vertexWithIdDoesNotExist ( this . getId ( ) ) ; \nMap < String , List < ODocument > > treeRidbagEdgesToRemove = new HashMap < String , List < ODocument > > ( ) ; \nif ( ! graph . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) for ( String fieldName : doc . fieldNames ( ) ) { \nfinal OPair < Direction , String > connection = getConnection ( Direction . BOTH , fieldName ) ; \nif ( connection == null ) continue ; \nObject fv = doc . field ( fieldName ) ; \nif ( fv instanceof ORidBag && ! ( ( ORidBag ) fv ) . isEmbedded ( ) ) { \nList < ODocument > docs = new ArrayList < ODocument > ( ) ; \nfor ( OIdentifiable id : ( ORidBag ) fv ) docs . add ( OrientBaseGraph . getDocument ( id , true ) ) ; \ntreeRidbagEdgesToRemove . put ( fieldName , docs ) ; \n} \n} \nsuper . removeRecord ( ) ; \nfinal Iterator < Index < ? extends Element > > it = graph . getIndices ( ) . iterator ( ) ; \nif ( it . hasNext ( ) ) { \nfinal Set < Edge > allEdges = new HashSet < Edge > ( ) ; \nfor ( Edge e : getEdges ( Direction . BOTH ) ) allEdges . add ( e ) ; \nwhile ( it . hasNext ( ) ) { \nfinal Index < ? extends Element > index = it . next ( ) ; \nif ( Vertex . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientVertex > idx = ( OrientIndex < OrientVertex > ) index ; \nidx . removeElement ( this ) ; \n} \nif ( Edge . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientEdge > idx = ( OrientIndex < OrientEdge > ) index ; \nfor ( Edge e : allEdges ) idx . removeElement ( ( OrientEdge ) e ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < ODocument > > entry : treeRidbagEdgesToRemove . entrySet ( ) ) { \ndoc . removeField ( entry . getKey ( ) ) ; \nIterator < ODocument > iter = entry . getValue ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nODocument docEdge = iter . next ( ) ; \nOrientBaseGraph . deleteEdgeIfAny ( docEdge , false ) ; \n} \n} \ngraph . removeEdgesInternal ( this , doc , null , true , settings . isUseVertexFieldsForEdgeLabels ( ) , settings . isAutoScaleEdgeType ( ) ) ; \n} \n} \n"}
{"3211": "public class OrientVertex { \npublic String getConnectionClass ( final Direction iDirection , final String iFieldName ) { \nif ( iDirection == Direction . OUT ) if ( iFieldName . length ( ) > CONNECTION_OUT_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_OUT_PREFIX . length ( ) ) ; \nelse if ( iDirection == Direction . IN ) if ( iFieldName . length ( ) > CONNECTION_IN_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_IN_PREFIX . length ( ) ) ; \nreturn OrientEdgeType . CLASS_NAME ; \n} \n} \n"}
{"3212": "public class OrientVertex { \nprotected OPair < Direction , String > getConnection ( final Direction iDirection , final String iFieldName , String ... iClassNames ) { \nif ( iClassNames != null && iClassNames . length == 1 && iClassNames [ 0 ] . equalsIgnoreCase ( \"E\" ) ) iClassNames = null ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( iDirection == Direction . OUT || iDirection == Direction . BOTH ) if ( settings . isUseVertexFieldsForEdgeLabels ( ) ) if ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) for ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) return new OPair < Direction , String > ( Direction . OUT , null ) ; \nif ( iDirection == Direction . IN || iDirection == Direction . BOTH ) if ( settings . isUseVertexFieldsForEdgeLabels ( ) ) if ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . IN , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) for ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) return new OPair < Direction , String > ( Direction . IN , null ) ; \nreturn null ; \n} \n} \n"}
{"3214": "public class OConsoleApplication { \nprotected Map < Method , Object > getConsoleMethods ( ) { \nif ( methods != null ) return methods ; \nfinal Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; \nfinal Collection < Object > candidates = new ArrayList < Object > ( ) ; \ncandidates . add ( this ) ; \nwhile ( ite . hasNext ( ) ) try { \nfinal OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; \ncc . setContext ( this ) ; \ncandidates . add ( cc ) ; \n} \ncatch ( InstantiationException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \ncatch ( IllegalAccessException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \nmethods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { \npublic int compare ( Method o1 , Method o2 ) { \nfinal ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; \nfinal ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; \nif ( ann1 != null && ann2 != null ) if ( ann1 . priority ( ) != ann2 . priority ( ) ) return ann1 . priority ( ) - ann2 . priority ( ) ; \nint res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; \nif ( res == 0 ) res = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; \nreturn res ; \n} \n} \n) ; \nfor ( final Object candidate : candidates ) { \nfinal Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; \nfor ( Method m : classMethods ) { \nif ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) || ! Modifier . isPublic ( m . getModifiers ( ) ) ) continue ; \nif ( m . getReturnType ( ) != Void . TYPE ) continue ; \nmethods . put ( m , candidate ) ; \n} \n} \nreturn methods ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( collate != null ) { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \nelse collatesList . add ( null ) ; \n} \n} \nif ( fields == null || fields . length == 0 ) { \nOIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; \nif ( keyTypes != null ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \nelse if ( serializerKeyId != 0 ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \nelse throw new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \nelse if ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) idx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \nelse { \nfinal List < OType > fieldTypeList ; \nif ( keyTypes == null ) { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) && ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nelse fieldTypeList = Arrays . asList ( keyTypes ) ; \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \nif ( idx != null ) return idx . getSize ( ) ; \nreturn null ; \n} \n} \n"}
{"3230": "public class OGraphCommandExecutorSQLFactory { \npublic static OrientGraph getGraph ( final boolean autoStartTx , OModifiableBoolean shouldBeShutDown ) { \nfinal ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nfinal OrientBaseGraph result = OrientBaseGraph . getActiveGraph ( ) ; \nif ( result != null && ( result instanceof OrientGraph ) ) { \nfinal ODatabaseDocumentInternal graphDb = result . getRawGraph ( ) ; \nif ( canReuseActiveGraph ( graphDb , database ) ) if ( ! graphDb . isClosed ( ) ) { \nODatabaseRecordThreadLocal . instance ( ) . set ( graphDb ) ; \nif ( autoStartTx && autoTxStartRequired ( graphDb ) ) ( ( OrientGraph ) result ) . begin ( ) ; \nshouldBeShutDown . setValue ( false ) ; \nreturn ( OrientGraph ) result ; \n} \n} \nODatabaseRecordThreadLocal . instance ( ) . set ( database ) ; \nshouldBeShutDown . setValue ( true ) ; \nfinal OrientGraph g = ( OrientGraph ) OrientGraphFactory . getTxGraphImplFactory ( ) . getGraph ( database , false ) ; \nif ( autoStartTx && autoTxStartRequired ( database ) ) g . begin ( ) ; \nreturn g ; \n} \n} \n"}
{"3231": "public class OCommandExecutorSQLRetryAbstract { \nprotected void parseRetry ( ) throws OCommandSQLParsingException { \nretry = Integer . parseInt ( parserNextWord ( true ) ) ; \nString temp = parseOptionalWord ( true ) ; \nif ( temp . equals ( \"WAIT\" ) ) wait = Integer . parseInt ( parserNextWord ( true ) ) ; \nelse parserGoBack ( ) ; \n} \n} \n"}
{"3235": "public class OSystemUserAuthenticator { \npublic String authenticate ( final String username , final String password ) { \nString principal = null ; \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) if ( user . checkPassword ( password ) ) principal = username ; \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"authenticate()\" , ex ) ; \n} \nreturn principal ; \n} \n} \n"}
{"3236": "public class OSystemUserAuthenticator { \npublic boolean isAuthorized ( final String username , final String resource ) { \nif ( username == null || resource == null ) return false ; \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { \nORole role = null ; \nORule . ResourceGeneric rg = ORule . mapLegacyResourceToGenericResource ( resource ) ; \nif ( rg != null ) { \nString specificResource = ORule . mapLegacyResourceToSpecificResource ( resource ) ; \nif ( specificResource == null || specificResource . equals ( \"*\" ) ) specificResource = null ; \nrole = user . checkIfAllowed ( rg , specificResource , ORole . PERMISSION_EXECUTE ) ; \n} \nreturn role != null ; \n} \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"isAuthorized()\" , ex ) ; \n} \nreturn false ; \n} \n} \n"}
{"3237": "public class OServerShutdownHook { \n@ Override public void run ( ) { \nif ( server != null ) if ( ! server . shutdown ( ) ) try { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( bufpos >= tokenBegin ) len = bufpos - tokenBegin + inBuf + 1 ; \nelse len = bufsize - tokenBegin + bufpos + 1 + inBuf ; \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nwhile ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( i ++ < len ) if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; \nelse bufline [ j ] = newLine ; \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3241": "public class OAtomicOperationsManager { \npublic OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { \nfinal OAtomicOperation operation = currentOperation . get ( ) ; \nif ( operation == null ) { \nOLogManager . instance ( ) . error ( this , \"There is no atomic operation active\" , null ) ; \nthrow new ODatabaseException ( \"There is no atomic operation active\" ) ; \n} \nint counter = operation . getCounter ( ) ; \noperation . decrementCounter ( ) ; \nassert counter > 0 ; \nfinal OLogSequenceNumber lsn ; \ntry { \nif ( rollback ) operation . rollback ( ) ; \nif ( counter == 1 ) try { \nfinal boolean useWal = useWal ( ) ; \nif ( ! operation . isRollback ( ) ) lsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; \nelse lsn = null ; \nif ( trackAtomicOperations ) activeAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; \n} \nfinally { \nfinal Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; \nwhile ( lockedObjectIterator . hasNext ( ) ) { \nfinal String lockedObject = lockedObjectIterator . next ( ) ; \nlockedObjectIterator . remove ( ) ; \nlockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \n} \ncurrentOperation . set ( null ) ; \n} \nelse lsn = null ; \n} \ncatch ( Error e ) { \nfinal OAbstractPaginatedStorage st = storage ; \nif ( st != null ) st . handleJVMError ( e ) ; \ncounter = 1 ; \nthrow e ; \n} \nfinally { \nif ( counter == 1 ) atomicOperationsCount . decrement ( ) ; \n} \nreturn lsn ; \n} \n} \n"}
{"3242": "public class OAtomicOperationsManager { \npublic void acquireExclusiveLockTillOperationComplete ( OAtomicOperation operation , String lockName ) { \nif ( operation . containsInLockedObjects ( lockName ) ) return ; \nlockManager . acquireLock ( lockName , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \noperation . addLockedObject ( lockName ) ; \n} \n} \n"}
{"3243": "public class O2QCache { \npublic void changeMaximumAmountOfMemory ( final long readCacheMaxMemory ) throws IllegalStateException { \nMemoryData memoryData ; \nMemoryData newMemoryData ; \nfinal int newMemorySize = normalizeMemory ( readCacheMaxMemory , pageSize ) ; \ndo { \nmemoryData = memoryDataContainer . get ( ) ; \nif ( memoryData . maxSize == newMemorySize ) return ; \nif ( ( 100 * memoryData . pinnedPages / newMemorySize ) > percentOfPinnedPages ) throw new IllegalStateException ( \"Cannot decrease amount of memory used by disk cache \" + \"because limit of pinned pages will be more than allowed limit \" + percentOfPinnedPages ) ; \nnewMemoryData = new MemoryData ( newMemorySize , memoryData . pinnedPages ) ; \n} \nwhile ( ! memoryDataContainer . compareAndSet ( memoryData , newMemoryData ) ) ; \nOLogManager . instance ( ) . info ( this , \"Disk cache size was changed from \" + memoryData . maxSize + \" pages to \" + newMemorySize + \" pages\" ) ; \n} \n} \n"}
{"3245": "public class OServerNetworkListener { \nprivate void readParameters ( final OContextConfiguration iServerConfig , final OServerParameterConfiguration [ ] iParameters ) { \nconfiguration = new OContextConfiguration ( iServerConfig ) ; \nif ( iParameters != null && iParameters . length > 0 ) for ( OServerParameterConfiguration param : iParameters ) configuration . setValue ( param . name , param . value ) ; \nsocketBufferSize = configuration . getValueAsInteger ( OGlobalConfiguration . NETWORK_SOCKET_BUFFER_SIZE ) ; \n} \n} \n"}
{"3246": "public class OLogManager { \npublic void shutdown ( ) { \nif ( shutdownFlag . compareAndSet ( false , true ) ) try { \nif ( LogManager . getLogManager ( ) instanceof ShutdownLogManager ) ( ( ShutdownLogManager ) LogManager . getLogManager ( ) ) . shutdown ( ) ; \n} \ncatch ( NoClassDefFoundError ignore ) { \n} \n} \n} \n"}
{"3247": "public class OClosableLinkedContainer { \npublic void add ( K key , V item ) throws InterruptedException { \nif ( ! item . isOpen ( ) ) throw new IllegalArgumentException ( \"All passed in items should be in open state\" ) ; \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > closableEntry = new OClosableEntry < K , V > ( item ) ; \nfinal OClosableEntry < K , V > oldEntry = data . putIfAbsent ( key , closableEntry ) ; \nif ( oldEntry != null ) throw new IllegalStateException ( \"Item with key \" + key + \" already exists\" ) ; \nlogAdd ( closableEntry ) ; \n} \n} \n"}
{"3248": "public class OClosableLinkedContainer { \npublic V remove ( K key ) { \nfinal OClosableEntry < K , V > removed = data . remove ( key ) ; \nif ( removed != null ) { \nlong preStatus = removed . makeRetired ( ) ; \nif ( OClosableEntry . isOpen ( preStatus ) ) countClosedFiles ( ) ; \nlogRemoved ( removed ) ; \nreturn removed . get ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"3249": "public class OClosableLinkedContainer { \npublic OClosableEntry < K , V > acquire ( K key ) throws InterruptedException { \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry == null ) return null ; \nboolean logOpen = false ; \nentry . acquireStateLock ( ) ; \ntry { \nif ( entry . isRetired ( ) || entry . isDead ( ) ) return null ; \nelse if ( entry . isClosed ( ) ) { \nentry . makeAcquiredFromClosed ( entry . get ( ) ) ; \nlogOpen = true ; \n} \nelse if ( entry . isOpen ( ) ) entry . makeAcquiredFromOpen ( ) ; \nelse entry . incrementAcquired ( ) ; \n} \nfinally { \nentry . releaseStateLock ( ) ; \n} \nif ( logOpen ) logOpen ( entry ) ; \nelse logAcquire ( entry ) ; \nassert entry . get ( ) . isOpen ( ) ; \nreturn entry ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( int i = 0 ; \ni < READ_BUFFER_SIZE ; \ni ++ ) buffer [ i ] . set ( null ) ; \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3264": "public class OProfileStorageStatement { \n@ Override public OResultSet executeSimple ( OCommandContext ctx ) { \nOResultInternal result = new OResultInternal ( ) ; \nresult . setProperty ( \"operation\" , \"optimize database\" ) ; \nOStorage storage = ( ( ODatabaseInternal ) ctx . getDatabase ( ) ) . getStorage ( ) ; \nif ( on ) { \n( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; \nresult . setProperty ( \"value\" , \"on\" ) ; \n} \nelse { \nfinal OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; \nresult . setProperty ( \"value\" , \"off\" ) ; \nif ( performanceStatistic != null ) result . setProperty ( \"result\" , performanceStatistic . toDocument ( ) ) ; \nelse { \nresult . setProperty ( \"result\" , \"error\" ) ; \nresult . setProperty ( \"errorMessage\" , \"profiling of storage was not started\" ) ; \n} \n} \nOInternalResultSet rs = new OInternalResultSet ( ) ; \nrs . add ( result ) ; \nreturn rs ; \n} \n} \n"}
{"3265": "public class OProfileStorageStatement { \n@ Override public Object execute ( OSQLAsynchQuery < ODocument > request , OCommandContext context , OProgressListener progressListener ) { \ntry { \nODatabaseDocumentInternal db = getDatabase ( ) ; \nfinal OStorage storage = db . getStorage ( ) ; \nif ( on ) { \n( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; \nODocument result = new ODocument ( ) ; \nresult . field ( \"result\" , \"OK\" ) ; \nrequest . getResultListener ( ) . result ( result ) ; \n} \nelse { \nfinal OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; \nif ( performanceStatistic != null ) request . getResultListener ( ) . result ( performanceStatistic . toDocument ( ) ) ; \nelse { \nODocument result = new ODocument ( ) ; \nresult . field ( \"result\" , \"Error: profiling of storage was not started.\" ) ; \nrequest . getResultListener ( ) . result ( result ) ; \n} \n} \nreturn getResult ( request ) ; \n} \nfinally { \nif ( request . getResultListener ( ) != null ) request . getResultListener ( ) . end ( ) ; \n} \n} \n} \n"}
{"3267": "public class OSecurityShared { \npublic OUser authenticate ( final OToken authToken ) { \nfinal String dbName = getDatabase ( ) . getName ( ) ; \nif ( authToken . getIsValid ( ) != true ) throw new OSecurityAccessException ( dbName , \"Token not valid\" ) ; \nOUser user = authToken . getUser ( getDatabase ( ) ) ; \nif ( user == null && authToken . getUserName ( ) != null ) user = getUser ( authToken . getUserName ( ) ) ; \nif ( user == null ) throw new OSecurityAccessException ( dbName , \"Authentication failed, could not load user from token\" ) ; \nif ( user . getAccountStatus ( ) != STATUSES . ACTIVE ) throw new OSecurityAccessException ( dbName , \"User '\" + user . getName ( ) + \"' is not active\" ) ; \nreturn user ; \n} \n} \n"}
{"3268": "public class OSecurityShared { \npublic OUser createMetadata ( ) { \nfinal ODatabaseDocument database = getDatabase ( ) ; \nOClass identityClass = database . getMetadata ( ) . getSchema ( ) . getClass ( OIdentity . CLASS_NAME ) ; \nif ( identityClass == null ) identityClass = database . getMetadata ( ) . getSchema ( ) . createAbstractClass ( OIdentity . CLASS_NAME ) ; \nOClass roleClass = createOrUpdateORoleClass ( database , identityClass ) ; \ncreateOrUpdateOUserClass ( database , identityClass , roleClass ) ; \nORole adminRole = getRole ( ORole . ADMIN ) ; \nif ( adminRole == null ) { \nadminRole = createRole ( ORole . ADMIN , ORole . ALLOW_MODES . ALLOW_ALL_BUT ) ; \nadminRole . addRule ( ORule . ResourceGeneric . BYPASS_RESTRICTED , null , ORole . PERMISSION_ALL ) . save ( ) ; \n} \nOUser adminUser = getUser ( OUser . ADMIN ) ; \nif ( adminUser == null ) { \nboolean createDefUsers = getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getContextConfiguration ( ) . getValueAsBoolean ( OGlobalConfiguration . CREATE_DEFAULT_USERS ) ; \nif ( createDefUsers ) adminUser = createUser ( OUser . ADMIN , OUser . ADMIN , adminRole ) ; \n} \ncreateOrUpdateORestrictedClass ( database ) ; \nreturn adminUser ; \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( holds > 0 ) { \nlHolds . increment ( ) ; \nreturn true ; \n} \nelse if ( holds < 0 ) return true ; \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( parkTimeout > 0 ) LockSupport . parkNanos ( this , parkTimeout ) ; \nelse return false ; \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) return false ; \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( int i = 0 ; \ni < parallel - 1 ; \ni ++ ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) synchronized ( runningThreads ) { \nwhile ( runningThreads . get ( ) > 0 ) try { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n"}
{"3277": "public class OGraphBatchInsertBasic { \npublic void createVertex ( final Long v ) { \nlast = last < v ? v : last ; \nfinal List < Long > outList = out . get ( v ) ; \nif ( outList == null ) out . put ( v , new ArrayList < Long > ( averageEdgeNumberPerNode <= 0 ? 4 : averageEdgeNumberPerNode ) ) ; \n} \n} \n"}
{"3280": "public class OCommandExecutorSQLInsert { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( newRecords == null && content == null && subQuery == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal OCommandParameters commandParameters = new OCommandParameters ( iArgs ) ; \nif ( indexName != null ) { \nif ( newRecords == null ) throw new OCommandExecutionException ( \"No key/value found\" ) ; \nfinal OIndex < ? > index = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . getIndex ( indexName ) ; \nif ( index == null ) throw new OCommandExecutionException ( \"Target index '\" + indexName + \"' not found\" ) ; \nMap < String , Object > result = new HashMap < String , Object > ( ) ; \nfor ( Map < String , Object > candidate : newRecords ) { \nObject indexKey = getIndexKeyValue ( commandParameters , candidate ) ; \nOIdentifiable indexValue = getIndexValue ( commandParameters , candidate ) ; \nif ( index instanceof OIndexMultiValues ) { \nfinal Collection < ORID > rids = ( ( OIndexMultiValues ) index ) . get ( indexKey ) ; \nif ( ! rids . contains ( indexValue . getIdentity ( ) ) ) index . put ( indexKey , indexValue ) ; \n} \nelse index . put ( indexKey , indexValue ) ; \nresult . put ( KEYWORD_KEY , indexKey ) ; \nresult . put ( KEYWORD_RID , indexValue ) ; \n} \nreturn prepareReturnItem ( new ODocument ( result ) ) ; \n} \nelse { \nfinal List < ODocument > docs = new ArrayList < ODocument > ( ) ; \nif ( newRecords != null ) { \nfor ( Map < String , Object > candidate : newRecords ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \nOSQLHelper . bindParameters ( doc , candidate , commandParameters , context ) ; \nsaveRecord ( doc ) ; \ndocs . add ( doc ) ; \n} \nif ( docs . size ( ) == 1 ) return prepareReturnItem ( docs . get ( 0 ) ) ; \nelse return prepareReturnResult ( docs ) ; \n} \nelse if ( content != null ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \ndoc . merge ( content , true , false ) ; \nsaveRecord ( doc ) ; \nreturn prepareReturnItem ( doc ) ; \n} \nelse if ( subQuery != null ) { \nsubQuery . execute ( ) ; \nif ( queryResult != null ) return prepareReturnResult ( queryResult ) ; \nreturn saved . longValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3284": "public class ORecordInternal { \npublic static byte getRecordType ( final ORecord record ) { \nif ( record instanceof ORecordAbstract ) return ( ( ORecordAbstract ) record ) . getRecordType ( ) ; \nfinal ORecordAbstract rec = ( ORecordAbstract ) record . getRecord ( ) ; \nreturn rec . getRecordType ( ) ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( int retry = 0 ; \nretry < 100 ; \n++ retry ) try { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n"}
{"3289": "public class OHttpNetworkCommandManager { \npublic void registerCommand ( final OServerCommand iServerCommandInstance ) { \nfor ( String name : iServerCommandInstance . getNames ( ) ) if ( OStringSerializerHelper . contains ( name , '{' ) ) restCommands . put ( name , iServerCommandInstance ) ; \nelse if ( OStringSerializerHelper . contains ( name , '*' ) ) wildcardCommands . put ( name , iServerCommandInstance ) ; \nelse exactCommands . put ( name , iServerCommandInstance ) ; \niServerCommandInstance . configure ( server ) ; \n} \n} \n"}
{"3291": "public class OFilterAnalyzer { \npublic List < OIndexSearchResult > analyzeCondition ( OSQLFilterCondition condition , final OClass schemaClass , OCommandContext context ) { \nfinal List < OIndexSearchResult > indexSearchResults = new ArrayList < OIndexSearchResult > ( ) ; \nOIndexSearchResult lastCondition = analyzeFilterBranch ( schemaClass , condition , indexSearchResults , context ) ; \nif ( indexSearchResults . isEmpty ( ) && lastCondition != null ) indexSearchResults . add ( lastCondition ) ; \nCollections . sort ( indexSearchResults , new Comparator < OIndexSearchResult > ( ) { \npublic int compare ( final OIndexSearchResult searchResultOne , final OIndexSearchResult searchResultTwo ) { \nreturn searchResultTwo . getFieldCount ( ) - searchResultOne . getFieldCount ( ) ; \n} \n} \n) ; \nreturn indexSearchResults ; \n} \n} \n"}
{"3292": "public class OFilterAnalyzer { \nprivate OIndexSearchResult createIndexedProperty ( final OSQLFilterCondition iCondition , final Object iItem , OCommandContext ctx ) { \nif ( iItem == null || ! ( iItem instanceof OSQLFilterItemField ) ) return null ; \nif ( iCondition . getLeft ( ) instanceof OSQLFilterItemField && iCondition . getRight ( ) instanceof OSQLFilterItemField ) return null ; \nfinal OSQLFilterItemField item = ( OSQLFilterItemField ) iItem ; \nif ( item . hasChainOperators ( ) && ! item . isFieldChain ( ) ) return null ; \nboolean inverted = iCondition . getRight ( ) == iItem ; \nfinal Object origValue = inverted ? iCondition . getLeft ( ) : iCondition . getRight ( ) ; \nOQueryOperator operator = iCondition . getOperator ( ) ; \nif ( inverted ) if ( operator instanceof OQueryOperatorIn ) operator = new OQueryOperatorContains ( ) ; \nelse if ( operator instanceof OQueryOperatorContains ) operator = new OQueryOperatorIn ( ) ; \nelse if ( operator instanceof OQueryOperatorMajor ) operator = new OQueryOperatorMinor ( ) ; \nelse if ( operator instanceof OQueryOperatorMinor ) operator = new OQueryOperatorMajor ( ) ; \nelse if ( operator instanceof OQueryOperatorMajorEquals ) operator = new OQueryOperatorMinorEquals ( ) ; \nelse if ( operator instanceof OQueryOperatorMinorEquals ) operator = new OQueryOperatorMajorEquals ( ) ; \nif ( iCondition . getOperator ( ) instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn ) return new OIndexSearchResult ( operator , item . getFieldChain ( ) , origValue ) ; \nfinal Object value = OSQLHelper . getValue ( origValue , null , ctx ) ; \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , value ) ; \n} \n} \n"}
{"3294": "public class OCreateIndexStatement { \nprivate OClass getIndexClass ( OCommandContext ctx ) { \nif ( className == null ) return null ; \nOClass result = ctx . getDatabase ( ) . getMetadata ( ) . getSchema ( ) . getClass ( className . getStringValue ( ) ) ; \nif ( result == null ) throw new OCommandExecutionException ( \"Cannot find class \" + className ) ; \nreturn result ; \n} \n} \n"}
{"3295": "public class OSequenceCached { \nprotected long nextWithNewCurrentValue ( long currentValue , boolean executeViaDistributed ) throws OSequenceLimitReachedException , ODatabaseException { \nif ( ! executeViaDistributed ) synchronized ( this ) { \ncacheStart = currentValue ; \nreturn nextWork ( ) ; \n} \nelse try { \nreturn sendSequenceActionSetAndNext ( currentValue ) ; \n} \ncatch ( InterruptedException | ExecutionException exc ) { \nOLogManager . instance ( ) . error ( this , exc . getMessage ( ) , exc , ( Object [ ] ) null ) ; \nthrow new ODatabaseException ( exc . getMessage ( ) ) ; \n} \n} \n} \n"}
{"3296": "public class OClassImpl { \npublic void truncate ( ) throws IOException { \nODatabaseDocumentInternal db = getDatabase ( ) ; \ndb . checkSecurity ( ORule . ResourceGeneric . CLASS , ORole . PERMISSION_UPDATE ) ; \nif ( isSubClassOf ( OSecurityShared . RESTRICTED_CLASSNAME ) ) throw new OSecurityException ( \"Class '\" + getName ( ) + \"' cannot be truncated because has record level security enabled (extends '\" + OSecurityShared . RESTRICTED_CLASSNAME + \"')\" ) ; \nfinal OStorage storage = db . getStorage ( ) ; \nacquireSchemaReadLock ( ) ; \ntry { \nfor ( int id : clusterIds ) { \nOCluster cl = storage . getClusterById ( id ) ; \ndb . checkForClusterPermissions ( cl . getName ( ) ) ; \ncl . truncate ( ) ; \n} \nfor ( OIndex < ? > index : getClassIndexes ( ) ) index . clear ( ) ; \nSet < OIndex < ? > > superclassIndexes = new HashSet < OIndex < ? > > ( ) ; \nsuperclassIndexes . addAll ( getIndexes ( ) ) ; \nsuperclassIndexes . removeAll ( getClassIndexes ( ) ) ; \nfor ( OIndex index : superclassIndexes ) { \nindex . rebuild ( ) ; \n} \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3298": "public class OClassImpl { \nprotected void addPolymorphicClusterIds ( final OClassImpl iBaseClass ) { \nSet < Integer > clusters = new TreeSet < Integer > ( ) ; \nfor ( int clusterId : polymorphicClusterIds ) { \nclusters . add ( clusterId ) ; \n} \nfor ( int clusterId : iBaseClass . polymorphicClusterIds ) { \nif ( clusters . add ( clusterId ) ) try { \naddClusterIdToIndexes ( clusterId ) ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . warn ( this , \"Error adding clusterId '%d' to index of class '%s'\" , e , clusterId , getName ( ) ) ; \nclusters . remove ( clusterId ) ; \n} \n} \npolymorphicClusterIds = new int [ clusters . size ( ) ] ; \nint i = 0 ; \nfor ( Integer cluster : clusters ) { \npolymorphicClusterIds [ i ] = cluster ; \ni ++ ; \n} \n} \n} \n"}
{"3299": "public class ORecordSerializerCSVAbstract { \nprivate static OIdentifiable linkToStream ( final StringBuilder buffer , final ODocument iParentRecord , Object iLinked ) { \nif ( iLinked == null ) return null ; \nOIdentifiable resultRid = null ; \nORID rid ; \nif ( iLinked instanceof ORID ) { \nrid = ( ORID ) iLinked ; \nassert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : \"Impossible to serialize invalid link \" + rid . getIdentity ( ) ; \nresultRid = rid ; \n} \nelse { \nif ( iLinked instanceof String ) iLinked = new ORecordId ( ( String ) iLinked ) ; \nif ( ! ( iLinked instanceof OIdentifiable ) ) throw new IllegalArgumentException ( \"Invalid object received. Expected a OIdentifiable but received type=\" + iLinked . getClass ( ) . getName ( ) + \" and value=\" + iLinked ) ; \nORecord iLinkedRecord = ( ( OIdentifiable ) iLinked ) . getRecord ( ) ; \nrid = iLinkedRecord . getIdentity ( ) ; \nassert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : \"Impossible to serialize invalid link \" + rid . getIdentity ( ) ; \nfinal ODatabaseDocument database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nif ( iParentRecord != null ) if ( ! database . isRetainRecords ( ) ) resultRid = iLinkedRecord . getIdentity ( ) ; \n} \nif ( rid . isValid ( ) ) rid . toString ( buffer ) ; \nreturn resultRid ; \n} \n} \n"}
{"3300": "public class OByteBufferPool { \npublic final void release ( OPointer pointer ) { \nif ( TRACK ) pointerMapping . remove ( pointer ) ; \nlong poolSize = pointersPoolSize . incrementAndGet ( ) ; \nif ( poolSize > this . poolSize ) { \npointersPoolSize . decrementAndGet ( ) ; \nallocator . deallocate ( pointer ) ; \n} \nelse pointersPool . add ( pointer ) ; \n} \n} \n"}
{"3301": "public class OByteBufferPool { \npublic void checkMemoryLeaks ( ) { \nboolean detected = false ; \nif ( TRACK ) for ( Map . Entry < OPointer , PointerTracker > entry : pointerMapping . entrySet ( ) ) { \nOLogManager . instance ( ) . errorNoDb ( this , \"DIRECT-TRACK: unreleased direct memory pointer `%X` detected.\" , entry . getValue ( ) . allocation , System . identityHashCode ( entry . getKey ( ) ) ) ; \ndetected = true ; \n} \nassert ! detected ; \n} \n} \n"}
{"3307": "public class OCollections { \npublic static int indexOf ( final Object [ ] array , final Comparable object ) { \nfor ( int i = 0 ; \ni < array . length ; \n++ i ) if ( object . compareTo ( array [ i ] ) == 0 ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"3308": "public class OCollections { \npublic static int indexOf ( final int [ ] array , final int object ) { \nfor ( int i = 0 ; \ni < array . length ; \n++ i ) if ( array [ i ] == object ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"3309": "public class OCommandExecutorSQLSelect { \n@ Override public Set < String > getInvolvedClusters ( ) { \nfinal Set < String > clusters = new HashSet < String > ( ) ; \nif ( parsedTarget != null ) { \nfinal ODatabaseDocument db = getDatabase ( ) ; \nif ( parsedTarget . getTargetQuery ( ) != null && parsedTarget . getTargetRecords ( ) instanceof OCommandExecutorSQLResultsetDelegate ) { \nfinal Set < String > clIds = ( ( OCommandExecutorSQLResultsetDelegate ) parsedTarget . getTargetRecords ( ) ) . getInvolvedClusters ( ) ; \nfor ( String c : clIds ) { \nif ( checkClusterAccess ( db , c ) ) clusters . add ( c ) ; \n} \n} \nelse if ( parsedTarget . getTargetRecords ( ) != null ) for ( OIdentifiable identifiable : parsedTarget . getTargetRecords ( ) ) { \nfinal String c = db . getClusterNameById ( identifiable . getIdentity ( ) . getClusterId ( ) ) . toLowerCase ( Locale . ENGLISH ) ; \nif ( checkClusterAccess ( db , c ) ) clusters . add ( c ) ; \n} \nif ( parsedTarget . getTargetClasses ( ) != null ) return getInvolvedClustersOfClasses ( parsedTarget . getTargetClasses ( ) . values ( ) ) ; \nif ( parsedTarget . getTargetClusters ( ) != null ) return getInvolvedClustersOfClusters ( parsedTarget . getTargetClusters ( ) . keySet ( ) ) ; \nif ( parsedTarget . getTargetIndex ( ) != null ) return getInvolvedClustersOfIndex ( parsedTarget . getTargetIndex ( ) ) ; \n} \nreturn clusters ; \n} \n} \n"}
{"3310": "public class OCommandExecutorSQLSelect { \n@ Override protected boolean handleResult ( final OIdentifiable iRecord , final OCommandContext iContext ) { \nlastRecord = iRecord ; \nif ( ( orderedFields . isEmpty ( ) || fullySortedByIndex || isRidOnlySort ( ) ) && skip > 0 && this . unwindFields == null && this . expandTarget == null ) { \nlastRecord = null ; \nskip -- ; \nreturn true ; \n} \nif ( ! addResult ( lastRecord , iContext ) ) return false ; \nreturn continueSearching ( ) ; \n} \n} \n"}
{"3313": "public class OCommandExecutorSQLSelect { \nprotected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_FETCHPLAN ) ) return false ; \nparserSkipWhiteSpaces ( ) ; \nint start = parserGetCurrentPosition ( ) ; \nparserNextWord ( true ) ; \nint end = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nint position = parserGetCurrentPosition ( ) ; \nwhile ( ! parserIsEnded ( ) ) { \nfinal String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; \nif ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) break ; \nend = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nposition = parserGetCurrentPosition ( ) ; \n} \nparserSetCurrentPosition ( position ) ; \nif ( end < 0 ) fetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; \nelse fetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; \nrequest . setFetchPlan ( fetchPlan ) ; \nreturn true ; \n} \n} \n"}
{"3316": "public class OETLJob { \npublic ODocument status ( ) { \nsynchronized ( listener ) { \nODocument status = new ODocument ( ) ; \nstatus . field ( \"cfg\" , cfg ) ; \nstatus . field ( \"status\" , this . status ) ; \nString lastBatchLog = \"\" ; \nif ( this . messageHandler != null ) lastBatchLog = extractBatchLog ( ) ; \nstatus . field ( \"log\" , lastBatchLog ) ; \nif ( this . status == Status . FINISHED ) listener . notifyAll ( ) ; \nreturn status ; \n} \n} \n} \n"}
{"3318": "public class OAbstractPaginatedStorage { \npublic final void handleJVMError ( final Error e ) { \nif ( jvmError . compareAndSet ( null , e ) ) OLogManager . instance ( ) . errorNoDb ( this , \"JVM error was thrown\" , e ) ; \n} \n} \n"}
{"3319": "public class OAbstractPaginatedStorage { \n@ SuppressWarnings ( \"UnusedReturnValue\" ) public boolean validatedPutIndexValue ( int indexId , final Object key , final ORID value , final OBaseIndexEngine . Validator < Object , ORID > validator ) throws OInvalidIndexEngineIdException { \nindexId = extractInternalId ( indexId ) ; \ntry { \nif ( transaction . get ( ) != null ) return doValidatedPutIndexValue ( indexId , key , value , validator ) ; \ncheckOpenness ( ) ; \nstateLock . acquireReadLock ( ) ; \ntry { \ncheckOpenness ( ) ; \ncheckLowDiskSpaceRequestsAndReadOnlyConditions ( ) ; \nreturn doValidatedPutIndexValue ( indexId , key , value , validator ) ; \n} \nfinally { \nstateLock . releaseReadLock ( ) ; \n} \n} \ncatch ( final OInvalidIndexEngineIdException ie ) { \nthrow logAndPrepareForRethrow ( ie ) ; \n} \ncatch ( final RuntimeException ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Error ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Throwable t ) { \nthrow logAndPrepareForRethrow ( t ) ; \n} \n} \n} \n"}
{"3320": "public class OAbstractPaginatedStorage { \npublic void rollback ( final OMicroTransaction microTransaction ) { \ntry { \ncheckOpenness ( ) ; \nstateLock . acquireReadLock ( ) ; \ntry { \ntry { \ncheckOpenness ( ) ; \nif ( transaction . get ( ) == null ) return ; \nif ( transaction . get ( ) . getMicroTransaction ( ) . getId ( ) != microTransaction . getId ( ) ) throw new OStorageException ( \"Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be \" + \"rolled back.\" ) ; \nmakeStorageDirty ( ) ; \nrollbackStorageTx ( ) ; \nmicroTransaction . updateRecordCacheAfterRollback ( ) ; \ntxRollback . incrementAndGet ( ) ; \n} \ncatch ( final IOException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during micro-transaction rollback\" ) , e ) ; \n} \nfinally { \ntransaction . set ( null ) ; \n} \n} \nfinally { \nstateLock . releaseReadLock ( ) ; \n} \n} \ncatch ( final RuntimeException ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Error ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Throwable t ) { \nthrow logAndPrepareForRethrow ( t ) ; \n} \n} \n} \n"}
{"3321": "public class OAbstractPaginatedStorage { \n@ Override public final Object command ( final OCommandRequestText iCommand ) { \ntry { \nwhile ( true ) try { \nfinal OCommandExecutor executor = OCommandManager . instance ( ) . getExecutor ( iCommand ) ; \nexecutor . setContext ( iCommand . getContext ( ) ) ; \nexecutor . setProgressListener ( iCommand . getProgressListener ( ) ) ; \nexecutor . parse ( iCommand ) ; \nreturn executeCommand ( iCommand , executor ) ; \n} \ncatch ( final ORetryQueryException ignore ) { \nif ( iCommand instanceof OQueryAbstract ) { \nfinal OQueryAbstract query = ( OQueryAbstract ) iCommand ; \nquery . reset ( ) ; \n} \n} \n} \ncatch ( final RuntimeException ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Error ee ) { \nthrow logAndPrepareForRethrow ( ee , false ) ; \n} \ncatch ( final Throwable t ) { \nthrow logAndPrepareForRethrow ( t ) ; \n} \n} \n} \n"}
{"3322": "public class OAbstractPaginatedStorage { \nprivate int registerCluster ( final OCluster cluster ) { \nfinal int id ; \nif ( cluster != null ) { \nif ( clusterMap . containsKey ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) ) ) throw new OConfigurationException ( \"Cannot add cluster '\" + cluster . getName ( ) + \"' because it is already registered in database '\" + name + \"'\" ) ; \nclusterMap . put ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) , cluster ) ; \nid = cluster . getId ( ) ; \n} \nelse id = clusters . size ( ) ; \nsetCluster ( id , cluster ) ; \nreturn id ; \n} \n} \n"}
{"3323": "public class OPartitionedDatabasePool { \npublic Object setProperty ( final String iName , final Object iValue ) { \nif ( iValue != null ) return properties . put ( iName . toLowerCase ( Locale . ENGLISH ) , iValue ) ; \nelse return properties . remove ( iName . toLowerCase ( Locale . ENGLISH ) ) ; \n} \n} \n"}
{"3324": "public class OCommandExecutorSQLCreateClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nboolean alreadyExists = database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ; \nif ( ! alreadyExists || ! ifNotExists ) if ( clusters != null ) database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusters , superClasses . toArray ( new OClass [ 0 ] ) ) ; \nelse database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusterIds , superClasses . toArray ( new OClass [ 0 ] ) ) ; \nreturn database . getMetadata ( ) . getSchema ( ) . getClasses ( ) . size ( ) ; \n} \n} \n"}
{"3335": "public class OBaseParser { \nprotected String parserRequiredWord ( final boolean iUpperCase , final String iCustomMessage , String iSeparators ) { \nif ( iSeparators == null ) iSeparators = \" ()=><,\\r\\n\" ; \nparserNextWord ( iUpperCase , iSeparators ) ; \nif ( parserLastWord . length ( ) == 0 ) throwSyntaxErrorException ( iCustomMessage ) ; \nif ( parserLastWord . charAt ( 0 ) == '`' && parserLastWord . charAt ( parserLastWord . length ( ) - 1 ) == '`' ) return parserLastWord . substring ( 1 , parserLastWord . length ( ) - 1 ) ; \nreturn parserLastWord . toString ( ) ; \n} \n} \n"}
{"3338": "public class OBaseParser { \nprivate boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { \nfor ( int sepIndex = 0 ; \nsepIndex < iSeparatorChars . length ( ) ; \n++ sepIndex ) if ( iSeparatorChars . charAt ( sepIndex ) == c ) { \nparserLastSeparator = c ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) return true ; \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) return null ; \nfinal long records = cls . count ( true ) ; \nif ( records > 0 && ! unsafe ) if ( cls . isSubClassOf ( \"V\" ) ) throw new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse if ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( records > 0 && unsafe ) if ( cls . isSubClassOf ( \"V\" ) ) if ( unsafe ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \nelse if ( cls . isSubClassOf ( \"E\" ) ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \nreturn true ; \n} \n} \n"}
{"3343": "public class OAuth2FeignRequestInterceptor { \nprotected OAuth2AccessToken acquireAccessToken ( ) throws UserRedirectRequiredException { \nAccessTokenRequest tokenRequest = oAuth2ClientContext . getAccessTokenRequest ( ) ; \nif ( tokenRequest == null ) throw new AccessTokenRequiredException ( \"Cannot find valid context on request for resource '\" + resource . getId ( ) + \"'.\" , resource ) ; \nString stateKey = tokenRequest . getStateKey ( ) ; \nif ( stateKey != null ) tokenRequest . setPreservedState ( oAuth2ClientContext . removePreservedState ( stateKey ) ) ; \nOAuth2AccessToken existingToken = oAuth2ClientContext . getAccessToken ( ) ; \nif ( existingToken != null ) oAuth2ClientContext . setAccessToken ( existingToken ) ; \nOAuth2AccessToken obtainableAccessToken ; \nobtainableAccessToken = accessTokenProvider . obtainAccessToken ( resource , tokenRequest ) ; \nif ( obtainableAccessToken == null || obtainableAccessToken . getValue ( ) == null ) throw new IllegalStateException ( \" Access token provider returned a null token, which is illegal according to the contract.\" ) ; \noAuth2ClientContext . setAccessToken ( obtainableAccessToken ) ; \nreturn obtainableAccessToken ; \n} \n} \n"}
{"3344": "public class AccessTokenContextRelay { \npublic boolean copyToken ( ) { \nif ( context . getAccessToken ( ) == null ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( authentication != null ) { \nObject details = authentication . getDetails ( ) ; \nif ( details instanceof OAuth2AuthenticationDetails ) { \nOAuth2AuthenticationDetails holder = ( OAuth2AuthenticationDetails ) details ; \nString token = holder . getTokenValue ( ) ; \nDefaultOAuth2AccessToken accessToken = new DefaultOAuth2AccessToken ( token ) ; \nString tokenType = holder . getTokenType ( ) ; \nif ( tokenType != null ) accessToken . setTokenType ( tokenType ) ; \ncontext . setAccessToken ( accessToken ) ; \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) if ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) if ( avail > 0 ) if ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal int m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) if ( result == 0 ) { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip -- ; \n} \nelse toSkip -= result ; \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal int length = to - from ; \nif ( length < MERGESORT_NO_REC ) { \nfor ( int i = from ; \ni < to ; \ni ++ ) for ( int j = i ; \nj > from && ( c . compare ( j - 1 , j ) > 0 ) ; \nj -- ) swapper . swap ( j , j - 1 ) ; \nreturn ; \n} \nint mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( c . compare ( mid - 1 , mid ) <= 0 ) return ; \ninPlaceMerge ( from , mid , to , c , swapper ) ; \n} \n} \n"}
{"3361": "public class HashIndexSelect { \npublic Stream < S > findMatches ( Q query ) { \nObject [ ] queryArray = matchFields . stream ( ) . map ( mf -> mf . extract ( query ) ) . toArray ( ) ; \nHollowHashIndexResult matches = hhi . findMatches ( queryArray ) ; \nif ( matches == null ) return Stream . empty ( ) ; \nreturn matches . stream ( ) . mapToObj ( i -> selectField . extract ( api , i ) ) ; \n} \n} \n"}
{"3362": "public class HollowCompactor { \nprivate Set < String > findCompactionTargets ( ) { \nList < HollowSchema > schemas = HollowSchemaSorter . dependencyOrderedSchemaList ( readEngine . getSchemas ( ) ) ; \nSet < String > typesToCompact = new HashSet < String > ( ) ; \nfor ( HollowSchema schema : schemas ) { \nif ( isCompactionCandidate ( schema . getName ( ) ) ) if ( ! candidateIsDependentOnAnyTargetedType ( schema . getName ( ) , typesToCompact ) ) typesToCompact . add ( schema . getName ( ) ) ; \n} \nreturn typesToCompact ; \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null || files . length <= numOfSnapshotsToKeep ) return ; \nsortByLastModified ( files ) ; \nfor ( int i = numOfSnapshotsToKeep ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) log . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \n} \n} \n"}
{"3366": "public class TransitiveSetTraverser { \npublic static void removeReferencedOutsideClosure ( HollowReadStateEngine stateEngine , Map < String , BitSet > matches ) { \nList < HollowSchema > orderedSchemas = HollowSchemaSorter . dependencyOrderedSchemaList ( stateEngine ) ; \nCollections . reverse ( orderedSchemas ) ; \nfor ( HollowSchema referencedSchema : orderedSchemas ) { \nif ( matches . containsKey ( referencedSchema . getName ( ) ) ) for ( HollowSchema referencerSchema : orderedSchemas ) { \nif ( referencerSchema == referencedSchema ) break ; \nif ( matches . containsKey ( referencedSchema . getName ( ) ) && matches . get ( referencedSchema . getName ( ) ) . cardinality ( ) > 0 ) traverseReferencesOutsideClosure ( stateEngine , referencerSchema . getName ( ) , referencedSchema . getName ( ) , matches , REMOVE_REFERENCED_OUTSIDE_CLOSURE ) ; \n} \n} \n} \n} \n"}
{"3369": "public class HollowBlobHeaderReader { \nprivate Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { \nint numHeaderTags = dis . readShort ( ) ; \nMap < String , String > headerTags = new HashMap < String , String > ( ) ; \nfor ( int i = 0 ; \ni < numHeaderTags ; \ni ++ ) headerTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; \nreturn headerTags ; \n} \n} \n"}
{"3371": "public class ThreadSafeBitSet { \npublic void clearAll ( ) { \nThreadSafeBitSetSegments segments = this . segments . get ( ) ; \nfor ( int i = 0 ; \ni < segments . numSegments ( ) ; \ni ++ ) { \nAtomicLongArray segment = segments . getSegment ( i ) ; \nfor ( int j = 0 ; \nj < segment . length ( ) ; \nj ++ ) segment . set ( j , 0L ) ; \n} \n} \n} \n"}
{"3374": "public class DiffViewOutputGenerator { \nprivate static String getFieldValue ( HollowDiffViewRow row , boolean useFrom ) { \nField field = useFrom ? row . getFieldPair ( ) . getFrom ( ) : row . getFieldPair ( ) . getTo ( ) ; \nif ( row . getFieldPair ( ) . isLeafNode ( ) ) return field . getValue ( ) == null ? \"null\" : field . getValue ( ) . toString ( ) . replace ( \"|\" , \"&#x2502\" ) ; \nelse { \nString suffix = field . getValue ( ) == null ? \" [null]\" : \"\" ; \nreturn \"(\" + field . getTypeName ( ) + \")\" + suffix ; \n} \n} \n} \n"}
{"3375": "public class SegmentedByteArray { \npublic void copy ( ByteData src , long srcPos , long destPos , long length ) { \nfor ( long i = 0 ; \ni < length ; \ni ++ ) set ( destPos ++ , src . get ( srcPos ++ ) ) ; \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint segment = 0 ; \nbyte scratch [ ] = new byte [ segmentSize ] ; \nwhile ( length > 0 ) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nwhile ( bytesCopied < bytesToCopy ) bytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \norderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; \nlength -= bytesCopied ; \n} \n} \n} \n"}
{"3382": "public class SegmentedByteArray { \nprivate void ensureCapacity ( int segmentIndex ) { \nwhile ( segmentIndex >= segments . length ) segments = Arrays . copyOf ( segments , segments . length * 3 / 2 ) ; \nif ( segments [ segmentIndex ] == null ) segments [ segmentIndex ] = memoryRecycler . getByteArray ( ) ; \n} \n} \n"}
{"3383": "public class HollowObjectSchema { \npublic int getPosition ( String fieldName ) { \nInteger index = nameFieldIndexLookup . get ( fieldName ) ; \nif ( index == null ) return - 1 ; \nreturn index ; \n} \n} \n"}
{"3385": "public class HollowAPIGenerator { \nprotected static boolean hasCollectionsInDataSet ( HollowDataset dataset ) { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nif ( ( schema instanceof HollowListSchema ) || ( schema instanceof HollowSetSchema ) || ( schema instanceof HollowMapSchema ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"3386": "public class HollowAPIGenerator { \npublic void generateFiles ( File directory ) throws IOException { \nif ( packageName != null && ! packageName . trim ( ) . isEmpty ( ) ) { \nString packageDir = packageName . replace ( \".\" , File . separator ) ; \nif ( ! directory . getAbsolutePath ( ) . endsWith ( packageDir ) ) directory = new File ( directory , packageDir ) ; \n} \ndirectory . mkdirs ( ) ; \nHollowAPIClassJavaGenerator apiClassGenerator = new HollowAPIClassJavaGenerator ( packageName , apiClassname , dataset , parameterizeClassNames , config ) ; \nHollowAPIFactoryJavaGenerator apiFactoryGenerator = new HollowAPIFactoryJavaGenerator ( packageName , apiClassname , dataset , config ) ; \nHollowHashIndexGenerator hashIndexGenerator = new HollowHashIndexGenerator ( packageName , apiClassname , dataset , config ) ; \ngenerateFile ( directory , apiClassGenerator ) ; \ngenerateFile ( directory , apiFactoryGenerator ) ; \ngenerateFile ( directory , hashIndexGenerator ) ; \ngenerateFilesForHollowSchemas ( directory ) ; \n} \n} \n"}
{"3387": "public class HollowAPIGenerator { \nprotected void generateFilesForHollowSchemas ( File directory ) throws IOException { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nString type = schema . getName ( ) ; \nif ( config . isUseHollowPrimitiveTypes ( ) && HollowCodeGenerationUtils . isPrimitiveType ( type ) ) continue ; \ngenerateFile ( directory , getStaticAPIGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowObjectGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; \nif ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { \nHollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; \ngenerateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nif ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) generateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nelse if ( ( objSchema ) . getPrimaryKey ( ) != null ) { \ngenerateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; \ngenerateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \n} \n} \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) return false ; \nfor ( int i = 0 ; \ni < keys . length ; \ni ++ ) if ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3389": "public class HollowPrimaryKeyValueDeriver { \npublic Object [ ] getRecordKey ( int ordinal ) { \nObject [ ] results = new Object [ fieldPathIndexes . length ] ; \nfor ( int i = 0 ; \ni < fieldPathIndexes . length ; \ni ++ ) results [ i ] = readValue ( ordinal , i ) ; \nreturn results ; \n} \n} \n"}
{"3406": "public class HollowIncrementalProducer { \npublic void restoreFromLastState ( ) { \nproducer . initializeDataModel ( dataModel ) ; \nlong latestAnnouncedVersion = announcementWatcher . getLatestVersion ( ) ; \nif ( latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher . NO_ANNOUNCEMENT_AVAILABLE || latestAnnouncedVersion < 0 ) return ; \nrestore ( latestAnnouncedVersion , blobRetriever ) ; \n} \n} \n"}
{"3407": "public class HollowIncrementalProducer { \npublic long runCycle ( ) { \nlong recordsRemoved = countRecordsToRemove ( ) ; \nlong recordsAddedOrModified = this . mutations . values ( ) . size ( ) - recordsRemoved ; \ntry { \nlong version = producer . runCycle ( populator ) ; \nif ( version == lastSucessfulCycle ) return version ; \nlisteners . fireIncrementalCycleComplete ( version , recordsAddedOrModified , recordsRemoved , new HashMap < String , Object > ( cycleMetadata ) ) ; \nclearChanges ( ) ; \nlastSucessfulCycle = version ; \nreturn version ; \n} \ncatch ( Exception e ) { \nlisteners . fireIncrementalCycleFail ( e , recordsAddedOrModified , recordsRemoved , new HashMap < String , Object > ( cycleMetadata ) ) ; \nreturn FAILED_VERSION ; \n} \nfinally { \nclearCycleMetadata ( ) ; \n} \n} \n} \n"}
{"3412": "public class HollowObjectWriteRecord { \npublic void writeDataTo ( ByteDataBuffer buf ) { \nfor ( int i = 0 ; \ni < fieldData . length ; \ni ++ ) writeField ( buf , i ) ; \n} \n} \n"}
{"3415": "public class FreeOrdinalTracker { \npublic void returnOrdinalToPool ( int ordinal ) { \nif ( size == freeOrdinals . length ) freeOrdinals = Arrays . copyOf ( freeOrdinals , freeOrdinals . length * 3 / 2 ) ; \nfreeOrdinals [ size ] = ordinal ; \nsize ++ ; \n} \n} \n"}
{"3419": "public class FixedLengthMultipleOccurrenceElementArray { \nprivate void resizeStorage ( ) { \nint currentElementsPerNode = maxElementsPerNode ; \nint newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; \nif ( newElementsPerNode <= currentElementsPerNode ) throw new IllegalStateException ( \"cannot resize fixed length array from \" + currentElementsPerNode + \" to \" + newElementsPerNode ) ; \nFixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; \nLongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { \nlong currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; \nlong newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; \nfor ( int offset = 0 ; \noffset < currentElementsPerNode ; \noffset ++ ) { \nlong element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; \nif ( element == NO_ELEMENT ) break ; \nnewStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; \n} \n} \n) ; \nstorage . destroy ( memoryRecycler ) ; \nstorage = newStorage ; \nmaxElementsPerNode = newElementsPerNode ; \n} \n} \n"}
{"3421": "public class ByteArrayOrdinalMap { \npublic void prepareForWrite ( ) { \nint maxOrdinal = 0 ; \nAtomicLongArray pao = pointersAndOrdinals ; \nfor ( int i = 0 ; \ni < pao . length ( ) ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \nif ( ordinal > maxOrdinal ) maxOrdinal = ordinal ; \n} \n} \nlong [ ] pbo = new long [ maxOrdinal + 1 ] ; \nArrays . fill ( pbo , - 1 ) ; \nfor ( int i = 0 ; \ni < pao . length ( ) ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \npbo [ ordinal ] = key & POINTER_MASK ; \n} \n} \npointersByOrdinal = pbo ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) return false ; \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \nfor ( int i = 0 ; \ni < sizeOfData ; \ni ++ ) if ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3423": "public class ByteArrayOrdinalMap { \nprivate void growKeyArray ( ) { \nint newSize = pointersAndOrdinals . length ( ) << 1 ; \nif ( newSize < 0 ) throw new IllegalStateException ( \"New size computed to grow the underlying array for the map is negative. \" + \"This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. \" + \"Current array size :\" + pointersAndOrdinals . length ( ) + \" and size to grow :\" + newSize ) ; \ngrowKeyArray ( newSize ) ; \n} \n} \n"}
{"3425": "public class ByteArrayOrdinalMap { \nprivate AtomicLongArray emptyKeyArray ( int size ) { \nAtomicLongArray arr = new AtomicLongArray ( size ) ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) arr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; \nreturn arr ; \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \nfor ( int i = 0 ; \ni < getNumFieldPaths ( ) ; \ni ++ ) if ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3427": "public class UniqueKeyIndex { \npublic T findMatch ( Q key ) { \nObject [ ] keyArray = matchFields . stream ( ) . map ( mf -> mf . extract ( key ) ) . toArray ( ) ; \nint ordinal = hpki . getMatchingOrdinal ( keyArray ) ; \nif ( ordinal == - 1 ) return null ; \nreturn uniqueTypeExtractor . extract ( api , ordinal ) ; \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( numElements < 0 ) throw new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \nelse if ( numElements > HASH_TABLE_MAX_SIZE ) throw new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \nif ( numElements == 0 ) return 1 ; \nif ( numElements < 3 ) return numElements * 2 ; \nint sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nint bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3430": "public class HollowProducer { \npublic long runCompactionCycle ( HollowCompactor . CompactionConfig config ) { \nif ( config != null && readStates . hasCurrent ( ) ) { \nfinal HollowCompactor compactor = new HollowCompactor ( getWriteEngine ( ) , readStates . current ( ) . getStateEngine ( ) , config ) ; \nif ( compactor . needsCompaction ( ) ) return runCycle ( newState -> compactor . compact ( ) ) ; \n} \nreturn NO_ANNOUNCEMENT_AVAILABLE ; \n} \n} \n"}
{"3433": "public class HollowConsumerJavaFileGenerator { \nprivate void addToSetIfNotPrimitiveOrCollection ( Set < String > schemaNameSet , String ... schemaNames ) { \nfor ( String schemaName : schemaNames ) { \nif ( ! HollowCodeGenerationUtils . isCollectionType ( schemaName , dataset ) && ! HollowCodeGenerationUtils . isPrimitiveType ( schemaName ) ) schemaNameSet . add ( schemaName ) ; \n} \n} \n} \n"}
{"3434": "public class HollowCodeGenerationUtils { \npublic static String normalizeFieldPathToParamName ( String fieldPath ) { \nString result = null ; \nif ( fieldPath . contains ( \".\" ) ) { \nString [ ] parts = fieldPath . split ( \"\\\\.\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( lowercase ( parts [ 0 ] ) ) ; \nfor ( int i = 1 ; \ni < parts . length ; \ni ++ ) sb . append ( uppercase ( parts [ i ] ) ) ; \nresult = sb . toString ( ) ; \n} \nelse result = lowercase ( fieldPath ) ; \nif ( result . endsWith ( \"!\" ) ) return result . substring ( 0 , result . length ( ) - 1 ) ; \nreturn result ; \n} \n} \n"}
{"3447": "public class PullToRefreshBase { \nprotected final void refreshLoadingViewsSize ( ) { \nfinal int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * 1.2f ) ; \nint pLeft = getPaddingLeft ( ) ; \nint pTop = getPaddingTop ( ) ; \nint pRight = getPaddingRight ( ) ; \nint pBottom = getPaddingBottom ( ) ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { \nmHeaderLayout . setWidth ( maximumPullScroll ) ; \npLeft = - maximumPullScroll ; \n} \nelse pLeft = 0 ; \nif ( mMode . showFooterLoadingLayout ( ) ) { \nmFooterLayout . setWidth ( maximumPullScroll ) ; \npRight = - maximumPullScroll ; \n} \nelse pRight = 0 ; \nbreak ; \ncase VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { \nmHeaderLayout . setHeight ( maximumPullScroll ) ; \npTop = - maximumPullScroll ; \n} \nelse pTop = 0 ; \nif ( mMode . showFooterLoadingLayout ( ) ) { \nmFooterLayout . setHeight ( maximumPullScroll ) ; \npBottom = - maximumPullScroll ; \n} \nelse pBottom = 0 ; \nbreak ; \n} \nif ( DEBUG ) Log . d ( LOG_TAG , String . format ( \"Setting Padding. L: %d, T: %d, R: %d, B: %d\" , pLeft , pTop , pRight , pBottom ) ) ; \nsetPadding ( pLeft , pTop , pRight , pBottom ) ; \n} \n} \n"}
{"3448": "public class PullToRefreshBase { \nprotected void updateUIForMode ( ) { \nfinal LinearLayout . LayoutParams lp = getLoadingLayoutLayoutParams ( ) ; \nif ( this == mHeaderLayout . getParent ( ) ) removeView ( mHeaderLayout ) ; \nif ( mMode . showHeaderLoadingLayout ( ) ) addViewInternal ( mHeaderLayout , 0 , lp ) ; \nif ( this == mFooterLayout . getParent ( ) ) removeView ( mFooterLayout ) ; \nif ( mMode . showFooterLoadingLayout ( ) ) addViewInternal ( mFooterLayout , lp ) ; \nrefreshLoadingViewsSize ( ) ; \nmCurrentMode = ( mMode != Mode . BOTH ) ? mMode : Mode . PULL_FROM_START ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal int newScrollValue ; \nfinal int itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 && ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) setState ( State . PULL_TO_REFRESH ) ; \nelse if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) setState ( State . RELEASE_TO_REFRESH ) ; \n} \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal int deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { \nfinal int newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) Log . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \nif ( newScrollValue < ( 0 - fuzzyThreshold ) ) if ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) view . setState ( State . OVERSCROLLING ) ; \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \nelse if ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) if ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) view . setState ( State . OVERSCROLLING ) ; \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \nelse if ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) view . setState ( State . RESET ) ; \n} \nelse if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) view . setState ( State . RESET ) ; \n} \n} \n} \n"}
{"3457": "public class RuleBuilder { \n@ SuppressWarnings ( \"unchecked\" ) public GivenRuleBuilder < T , U > given ( String name , T value ) { \nRule < T , U > rule = _name . map ( ruleName -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , ruleName ) ) . orElse ( newRule ( ) ) ; \nif ( rule == null ) throw new IllegalStateException ( \"No Rule is instantiated; An invalid Rule class may have been provided\" ) ; \nreturn new GivenRuleBuilder < T , U > ( rule , new Fact < T > ( name , value ) ) ; \n} \n} \n"}
{"3458": "public class RuleBuilder { \n@ SuppressWarnings ( \"unchecked\" ) @ SafeVarargs public final GivenRuleBuilder < T , U > given ( NameValueReferable ... facts ) { \nRule < T , U > rule = _name . map ( name -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , name ) ) . orElse ( newRule ( ) ) ; \nif ( rule == null ) throw new IllegalStateException ( \"No Rule is instantiated; An invalid Rule class may have been provided\" ) ; \nreturn new GivenRuleBuilder < T , U > ( rule , facts ) ; \n} \n} \n"}
{"3459": "public class RuleBuilder { \n@ SuppressWarnings ( \"unchecked\" ) public ThenRuleBuilder < T , U > then ( Consumer < NameValueReferableTypeConvertibleMap < T > > action ) { \nRule < T , U > rule = _name . map ( name -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , name ) ) . orElse ( newRule ( ) ) ; \nif ( rule == null ) throw new IllegalStateException ( \"No Rule is instantiated; An invalid Rule class may have been provided\" ) ; \nreturn new ThenRuleBuilder < T , U > ( rule , action ) ; \n} \n} \n"}
{"3470": "public class Result { \npublic void reset ( ) { \n_lock . readLock ( ) . lock ( ) ; \ntry { \nif ( _defaultValue == null ) return ; \n} \nfinally { \n_lock . readLock ( ) . unlock ( ) ; \n} \nsetValue ( _defaultValue ) ; \n} \n} \n"}
{"3473": "public class AsciiDocParser { \nprivate String readEmptyLineOrEndTable ( final BufferedReader tableContent ) throws IOException { \nfinal String column = tableContent . readLine ( ) ; \nif ( column != null && column . startsWith ( END_TABLE ) ) return END_TABLE ; \nif ( column == null || ! column . isEmpty ( ) ) throw new IllegalArgumentException ( String . format ( \"Trying to read an empty line for end of row, but content %s was found or EOF\" , column ) ) ; \nreturn \"\" ; \n} \n} \n"}
{"3474": "public class DefaultServiceEnricher { \nprivate Service [ ] toArray ( List < Service > services ) { \nif ( services == null ) return new Service [ 0 ] ; \nif ( services instanceof ArrayList ) return ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; \nelse { \nService [ ] ret = new Service [ services . size ( ) ] ; \nfor ( int i = 0 ; \ni < services . size ( ) ; \ni ++ ) ret [ i ] = services . get ( i ) ; \nreturn ret ; \n} \n} \n} \n"}
{"3475": "public class DefaultServiceEnricher { \nprivate List < String > getPortsFromBuildConfiguration ( ImageConfiguration image ) { \nBuildImageConfiguration buildConfig = image . getBuildConfiguration ( ) ; \nif ( buildConfig == null ) return Collections . emptyList ( ) ; \nreturn buildConfig . getPorts ( ) ; \n} \n} \n"}
{"3476": "public class DefaultServiceEnricher { \nprivate List < ServicePort > extractPortsFromConfig ( ) { \nList < ServicePort > ret = new LinkedList < > ( ) ; \nString ports = getConfig ( Config . port ) ; \nif ( ports != null ) for ( String port : StringUtils . split ( ports , \",\" ) ) { \nret . add ( parsePortMapping ( port ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3477": "public class DefaultServiceEnricher { \nprivate ServicePort parsePortMapping ( String port ) { \nMatcher matcher = PORT_MAPPING_PATTERN . matcher ( port ) ; \nif ( ! matcher . matches ( ) ) { \nlog . error ( \"Invalid 'port' configuration '%s'. Must match <port>(:<targetPort>)?,<port2>?,...\" , port ) ; \nthrow new IllegalArgumentException ( \"Invalid port mapping specification \" + port ) ; \n} \nint servicePort = Integer . parseInt ( matcher . group ( \"port\" ) ) ; \nString optionalTargetPort = matcher . group ( \"targetPort\" ) ; \nString protocol = getProtocol ( matcher . group ( \"protocol\" ) ) ; \nServicePortBuilder builder = new ServicePortBuilder ( ) . withPort ( servicePort ) . withProtocol ( protocol ) . withName ( getDefaultPortName ( servicePort , protocol ) ) ; \nif ( optionalTargetPort != null ) builder . withNewTargetPort ( Integer . parseInt ( optionalTargetPort ) ) ; \nreturn builder . build ( ) ; \n} \n} \n"}
{"3478": "public class DefaultServiceEnricher { \nprivate void addPortIfNotNull ( List < ServicePort > ret , ServicePort port ) { \nif ( port != null ) ret . add ( port ) ; \n} \n} \n"}
{"3479": "public class DefaultServiceEnricher { \nprivate ServicePort shiftOrNull ( List < ServicePort > ports ) { \nif ( ! ports . isEmpty ( ) ) return ports . remove ( 0 ) ; \nreturn null ; \n} \n} \n"}
{"3482": "public class ServiceUrlUtil { \nprivate static boolean portsMatch ( ServicePort servicePort , IntOrString intOrString ) { \nif ( intOrString != null ) { \nInteger port = servicePort . getPort ( ) ; \nInteger intVal = intOrString . getIntVal ( ) ; \nString strVal = intOrString . getStrVal ( ) ; \nif ( intVal != null ) if ( port != null ) return port . intValue ( ) == intVal . intValue ( ) ; \nelse { \n} \nelse if ( strVal != null ) return Objects . equal ( strVal , servicePort . getName ( ) ) ; \n} \nreturn false ; \n} \n} \n"}
{"3485": "public class MapUtil { \npublic static void putIfAbsent ( Map < String , String > map , String name , String value ) { \nif ( ! map . containsKey ( name ) ) map . put ( name , value ) ; \n} \n} \n"}
{"3487": "public class MapUtil { \npublic static < K , V > Map < K , V > mergeMaps ( Map < K , V > map1 , Map < K , V > map2 ) { \nMap < K , V > answer = new HashMap < > ( ) ; \nif ( map2 != null ) answer . putAll ( map2 ) ; \nif ( map1 != null ) answer . putAll ( map1 ) ; \nreturn answer ; \n} \n} \n"}
{"3488": "public class MapUtil { \npublic static void putAllIfNotNull ( Map < String , String > ret , Map < String , String > toPut ) { \nif ( toPut != null ) ret . putAll ( toPut ) ; \n} \n} \n"}
{"3489": "public class OpenshiftBuildService { \nprivate void waitUntilPodIsReady ( String podName , int nAwaitTimeout , final Logger log ) throws InterruptedException { \nfinal CountDownLatch readyLatch = new CountDownLatch ( 1 ) ; \ntry ( Watch watch = client . pods ( ) . withName ( podName ) . watch ( new Watcher < Pod > ( ) { \n@ Override public void eventReceived ( Action action , Pod aPod ) { \nif ( KubernetesHelper . isPodReady ( aPod ) ) readyLatch . countDown ( ) ; \n} \n@ Override public void onClose ( KubernetesClientException e ) { \n} \n} \n) ) { \nreadyLatch . await ( nAwaitTimeout , TimeUnit . SECONDS ) ; \n} \ncatch ( KubernetesClientException | InterruptedException e ) { \nlog . error ( \"Could not watch pod\" , e ) ; \n} \n} \n} \n"}
{"3490": "public class KubernetesHelper { \npublic static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { \nif ( StringUtils . isBlank ( currentValue ) ) throw new IllegalArgumentException ( \"No \" + description + \" is specified!\" ) ; \nint size = currentValue . length ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nchar ch = currentValue . charAt ( i ) ; \nif ( Character . isUpperCase ( ch ) ) throw new IllegalArgumentException ( \"Invalid upper case letter '\" + ch + \"' at index \" + i + \" for \" + description + \" value: \" + currentValue ) ; \n} \nreturn currentValue ; \n} \n} \n"}
{"3491": "public class KubernetesHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static List < HasMetadata > toItemList ( Object entity ) throws IOException { \nif ( entity instanceof List ) return ( List < HasMetadata > ) entity ; \nelse if ( entity instanceof HasMetadata [ ] ) { \nHasMetadata [ ] array = ( HasMetadata [ ] ) entity ; \nreturn Arrays . asList ( array ) ; \n} \nelse if ( entity instanceof KubernetesList ) { \nKubernetesList config = ( KubernetesList ) entity ; \nreturn config . getItems ( ) ; \n} \nelse if ( entity instanceof Template ) { \nTemplate objects = ( Template ) entity ; \nreturn objects . getObjects ( ) ; \n} \nelse { \nList < HasMetadata > answer = new ArrayList < > ( ) ; \nif ( entity instanceof HasMetadata ) answer . add ( ( HasMetadata ) entity ) ; \nreturn answer ; \n} \n} \n} \n"}
{"3492": "public class KubernetesHelper { \npublic static String getResourceVersion ( HasMetadata entity ) { \nif ( entity != null ) { \nObjectMeta metadata = entity . getMetadata ( ) ; \nif ( metadata != null ) { \nString resourceVersion = metadata . getResourceVersion ( ) ; \nif ( StringUtils . isNotBlank ( resourceVersion ) ) return resourceVersion ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3493": "public class KubernetesHelper { \npublic static boolean isPodReady ( Pod pod ) { \nif ( ! isPodRunning ( pod ) ) return false ; \nPodStatus podStatus = pod . getStatus ( ) ; \nif ( podStatus == null ) return true ; \nList < PodCondition > conditions = podStatus . getConditions ( ) ; \nif ( conditions == null || conditions . isEmpty ( ) ) return true ; \nfor ( PodCondition condition : conditions ) { \nif ( \"ready\" . equalsIgnoreCase ( condition . getType ( ) ) ) return Boolean . parseBoolean ( condition . getStatus ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"3494": "public class KubernetesHelper { \nprivate static Context getCurrentContext ( Config config ) { \nString contextName = config . getCurrentContext ( ) ; \nif ( contextName != null ) { \nList < NamedContext > contexts = config . getContexts ( ) ; \nif ( contexts != null ) for ( NamedContext context : contexts ) { \nif ( Objects . equals ( contextName , context . getName ( ) ) ) return context . getContext ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3495": "public class RouteEnricher { \nprivate boolean hasRoute ( final KubernetesListBuilder listBuilder , final String name ) { \nfinal AtomicBoolean answer = new AtomicBoolean ( false ) ; \nlistBuilder . accept ( new TypedVisitor < RouteBuilder > ( ) { \n@ Override public void visit ( RouteBuilder builder ) { \nObjectMeta metadata = builder . getMetadata ( ) ; \nif ( metadata != null && name . equals ( metadata . getName ( ) ) ) answer . set ( true ) ; \n} \n} \n) ; \nreturn answer . get ( ) ; \n} \n} \n"}
{"3496": "public class MavenUtil { \npublic static boolean hasResource ( MavenProject project , String ... paths ) { \nURLClassLoader compileClassLoader = getCompileClassLoader ( project ) ; \nfor ( String path : paths ) { \ntry { \nif ( compileClassLoader . getResource ( path ) != null ) return true ; \n} \ncatch ( Throwable e ) { \n} \n} \nreturn false ; \n} \n} \n"}
{"3497": "public class KubernetesResourceUtil { \nprivate static Map < String , Object > readAndEnrichFragment ( PlatformMode platformMode , ResourceVersioning apiVersions , File file , String appName ) throws IOException { \nPattern pattern = Pattern . compile ( FILENAME_PATTERN , Pattern . CASE_INSENSITIVE ) ; \nMatcher matcher = pattern . matcher ( file . getName ( ) ) ; \nif ( ! matcher . matches ( ) ) throw new IllegalArgumentException ( String . format ( \"Resource file name '%s' does not match pattern <name>-<type>.(yaml|yml|json)\" , file . getName ( ) ) ) ; \nString name = matcher . group ( \"name\" ) ; \nString type = matcher . group ( \"type\" ) ; \nString ext = matcher . group ( \"ext\" ) . toLowerCase ( ) ; \nString kind ; \nMap < String , Object > fragment = readFragment ( file , ext ) ; \nif ( type != null ) kind = getAndValidateKindFromType ( file , type ) ; \nelse { \nkind = FILENAME_TO_KIND_MAPPER . get ( name . toLowerCase ( ) ) ; \nif ( kind != null ) name = null ; \n} \naddKind ( fragment , kind , file . getName ( ) ) ; \nString apiVersion = apiVersions . getCoreVersion ( ) ; \nif ( Objects . equals ( kind , \"Ingress\" ) ) apiVersion = apiVersions . getExtensionsVersion ( ) ; \nelse if ( Objects . equals ( kind , \"StatefulSet\" ) || Objects . equals ( kind , \"Deployment\" ) ) apiVersion = apiVersions . getAppsVersion ( ) ; \nelse if ( Objects . equals ( kind , \"Job\" ) ) apiVersion = apiVersions . getJobVersion ( ) ; \nelse if ( Objects . equals ( kind , \"DeploymentConfig\" ) && platformMode == PlatformMode . openshift ) apiVersion = apiVersions . getOpenshiftV1version ( ) ; \naddIfNotExistent ( fragment , \"apiVersion\" , apiVersion ) ; \nMap < String , Object > metaMap = getMetadata ( fragment ) ; \naddIfNotExistent ( metaMap , \"name\" , StringUtils . isNotBlank ( name ) ? name : appName ) ; \nreturn fragment ; \n} \n} \n"}
{"3499": "public class KubernetesResourceUtil { \npublic static HasMetadata mergeResources ( HasMetadata item1 , HasMetadata item2 , Logger log , boolean switchOnLocalCustomisation ) { \nif ( item1 instanceof Deployment && item2 instanceof Deployment ) return mergeDeployments ( ( Deployment ) item1 , ( Deployment ) item2 , log , switchOnLocalCustomisation ) ; \nif ( item1 instanceof ConfigMap && item2 instanceof ConfigMap ) { \nConfigMap cm1 = ( ConfigMap ) item1 ; \nConfigMap cm2 = ( ConfigMap ) item2 ; \nreturn mergeConfigMaps ( cm1 , cm2 , log , switchOnLocalCustomisation ) ; \n} \nmergeMetadata ( item1 , item2 ) ; \nreturn item1 ; \n} \n} \n"}
{"3501": "public class KubernetesResourceUtil { \nprivate static boolean isLocalCustomisation ( PodSpec podSpec ) { \nList < Container > containers = podSpec . getContainers ( ) != null ? podSpec . getContainers ( ) : Collections . < Container > emptyList ( ) ; \nfor ( Container container : containers ) { \nif ( StringUtils . isNotBlank ( container . getImage ( ) ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3502": "public class AbstractPortsExtractor { \nprivate Map < String , String > readConfig ( File f ) throws IOException { \nMap < String , String > map ; \nif ( f . getName ( ) . endsWith ( JSON_EXTENSION ) ) map = flatten ( JSON_MAPPER . readValue ( f , Map . class ) ) ; \nelse if ( f . getName ( ) . endsWith ( YAML_EXTENSION ) || f . getName ( ) . endsWith ( YML_EXTENSION ) ) map = flatten ( YAML_MAPPER . readValue ( f , Map . class ) ) ; \nelse if ( f . getName ( ) . endsWith ( PROPERTIES_EXTENSION ) ) { \nProperties properties = new Properties ( ) ; \nproperties . load ( new FileInputStream ( f ) ) ; \nmap = propertiesToMap ( properties ) ; \n} \nelse throw new IllegalArgumentException ( \"Can't read configuration from: [\" + f . getName ( ) + \"]. Unknown file extension.\" ) ; \nreturn map ; \n} \n} \n"}
{"3503": "public class AbstractPortsExtractor { \nprivate void addPortIfValid ( Map < String , Integer > map , String key , String port ) { \nif ( StringUtils . isNotBlank ( port ) ) { \nString t = port . trim ( ) ; \nif ( t . matches ( NUMBER_REGEX ) ) map . put ( key , Integer . parseInt ( t ) ) ; \n} \n} \n} \n"}
{"3504": "public class MavenEnricherContext { \npublic String getDockerJsonConfigString ( final Settings settings , final String serverId ) { \nServer server = getServer ( settings , serverId ) ; \nif ( server == null ) return \"\" ; \nJsonObject auth = new JsonObject ( ) ; \nauth . add ( \"username\" , new JsonPrimitive ( server . getUsername ( ) ) ) ; \nauth . add ( \"password\" , new JsonPrimitive ( server . getPassword ( ) ) ) ; \nString mail = getConfigurationValue ( server , \"email\" ) ; \nif ( ! StringUtils . isBlank ( mail ) ) auth . add ( \"email\" , new JsonPrimitive ( mail ) ) ; \nJsonObject json = new JsonObject ( ) ; \njson . add ( serverId , auth ) ; \nreturn json . toString ( ) ; \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nint diff ; \nint length = Math . min ( components1 . length , components2 . length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( i1 != null && i2 != null ) diff = i1 . compareTo ( i2 ) ; \nelse diff = s1 . compareTo ( s2 ) ; \nif ( diff != 0 ) return diff ; \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) return 0 ; \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3512": "public class ProfileUtil { \npublic static List < Profile > readAllFromClasspath ( String name , String ext ) throws IOException { \nList < Profile > ret = new ArrayList < > ( ) ; \nfor ( String location : getMetaInfProfilePaths ( ext ) ) { \nfor ( String url : ClassUtil . getResources ( location ) ) { \nfor ( Profile profile : fromYaml ( new URL ( url ) . openStream ( ) ) ) { \nif ( name . equals ( profile . getName ( ) ) ) ret . add ( profile ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"3513": "public class ProfileUtil { \nprivate static File findProfileYaml ( File directory ) { \nfor ( String profileFile : PROFILE_FILENAMES ) { \nFile ret = new File ( directory , String . format ( profileFile , \"\" ) ) ; \nif ( ret . exists ( ) ) return ret ; \n} \nreturn null ; \n} \n} \n"}
{"3516": "public class DefaultControllerEnricher { \nprivate String getImagePullPolicy ( ResourceConfig resourceConfig , String defaultValue ) { \nif ( resourceConfig != null ) return resourceConfig . getImagePullPolicy ( ) != null ? resourceConfig . getImagePullPolicy ( ) : defaultValue ; \nreturn defaultValue ; \n} \n} \n"}
{"3517": "public class BaseEnricher { \nprotected boolean isOpenShiftMode ( ) { \nProperties properties = getContext ( ) . getConfiguration ( ) . getProperties ( ) ; \nif ( properties != null ) return RuntimeMode . isOpenShiftMode ( properties ) ; \nreturn false ; \n} \n} \n"}
{"3518": "public class BaseEnricher { \nprotected int getReplicaCount ( KubernetesListBuilder builder , ResourceConfig xmlResourceConfig , int defaultValue ) { \nif ( xmlResourceConfig != null ) { \nList < HasMetadata > items = builder . buildItems ( ) ; \nfor ( HasMetadata item : items ) { \nif ( item instanceof Deployment ) if ( ( ( Deployment ) item ) . getSpec ( ) . getReplicas ( ) != null ) return ( ( Deployment ) item ) . getSpec ( ) . getReplicas ( ) ; \nif ( item instanceof DeploymentConfig ) if ( ( ( DeploymentConfig ) item ) . getSpec ( ) . getReplicas ( ) != null ) return ( ( DeploymentConfig ) item ) . getSpec ( ) . getReplicas ( ) ; \n} \nreturn xmlResourceConfig . getReplicas ( ) > 0 ? xmlResourceConfig . getReplicas ( ) : defaultValue ; \n} \nreturn defaultValue ; \n} \n} \n"}
{"3519": "public class XmlUtils { \npublic static Element firstChild ( Element element , String name ) { \nNodeList nodes = element . getChildNodes ( ) ; \nif ( nodes != null ) for ( int i = 0 , size = nodes . getLength ( ) ; \ni < size ; \ni ++ ) { \nNode item = nodes . item ( i ) ; \nif ( item instanceof Element ) { \nElement childElement = ( Element ) item ; \nif ( name . equals ( childElement . getTagName ( ) ) ) return childElement ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3520": "public class ApplyService { \npublic void installTemplate ( Template entity , String sourceName ) { \nOpenShiftClient openShiftClient = getOpenShiftClient ( ) ; \nif ( openShiftClient == null ) return ; \nif ( ! isProcessTemplatesLocally ( ) ) { \nString namespace = getNamespace ( ) ; \nString id = getName ( entity ) ; \nObjects . requireNonNull ( id , \"No name for \" + entity + \" \" + sourceName ) ; \nTemplate old = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; \nif ( isRunning ( old ) ) if ( UserConfigurationCompare . configEqual ( entity , old ) ) log . info ( \"Template has not changed so not doing anything\" ) ; \nelse { \nboolean recreateMode = isRecreateMode ( ) ; \nrecreateMode = true ; \nif ( recreateMode ) { \nopenShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . delete ( ) ; \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \nelse { \nlog . info ( \"Updating a Template from \" + sourceName ) ; \ntry { \nObject answer = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . replace ( entity ) ; \nlog . info ( \"Updated Template: \" + answer ) ; \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to update Template from \" + sourceName + \". \" + e + \". \" + entity , e ) ; \n} \n} \n} \nelse if ( ! isAllowCreate ( ) ) log . warn ( \"Creation disabled so not creating a Template from \" + sourceName + \" namespace \" + namespace + \" name \" + getName ( entity ) ) ; \nelse doCreateTemplate ( entity , namespace , sourceName ) ; \n} \n} \n} \n"}
{"3521": "public class ApplyService { \nprivate int removeTagByName ( List < TagReference > tags , String tagName ) { \nList < TagReference > removeTags = new ArrayList < > ( ) ; \nfor ( TagReference tag : tags ) { \nif ( Objects . equals ( tagName , tag . getName ( ) ) ) removeTags . add ( tag ) ; \n} \ntags . removeAll ( removeTags ) ; \nreturn removeTags . size ( ) ; \n} \n} \n"}
{"3522": "public class ApplyService { \npublic boolean applyNamespace ( Namespace entity ) { \nString namespace = getOrCreateMetadata ( entity ) . getName ( ) ; \nlog . info ( \"Using namespace: \" + namespace ) ; \nString name = getName ( entity ) ; \nObjects . requireNonNull ( name , \"No name for \" + entity ) ; \nNamespace old = kubernetesClient . namespaces ( ) . withName ( name ) . get ( ) ; \nif ( ! isRunning ( old ) ) try { \nObject answer = kubernetesClient . namespaces ( ) . create ( entity ) ; \nlogGeneratedEntity ( \"Created namespace: \" , namespace , entity , answer ) ; \nreturn true ; \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to create namespace: \" + name + \" due \" + e . getMessage ( ) , e ) ; \n} \nreturn false ; \n} \n} \n"}
{"3524": "public class ApplyService { \npublic boolean applyProjectRequest ( ProjectRequest entity ) { \nString namespace = getOrCreateMetadata ( entity ) . getName ( ) ; \nlog . info ( \"Using project: \" + namespace ) ; \nString name = getName ( entity ) ; \nObjects . requireNonNull ( name , \"No name for \" + entity ) ; \nOpenShiftClient openshiftClient = getOpenShiftClient ( ) ; \nif ( openshiftClient == null ) { \nlog . warn ( \"Cannot check for Project \" + namespace + \" as not running against OpenShift!\" ) ; \nreturn false ; \n} \nboolean exists = checkNamespace ( name ) ; \nif ( ! exists ) try { \nObject answer = openshiftClient . projectrequests ( ) . create ( entity ) ; \nlogGeneratedEntity ( \"Created ProjectRequest: \" , namespace , entity , answer ) ; \nreturn true ; \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to create ProjectRequest: \" + name + \" due \" + e . getMessage ( ) , e ) ; \n} \nreturn false ; \n} \n} \n"}
{"3525": "public class ApplyService { \nprotected String getNamespace ( HasMetadata entity ) { \nString answer = KubernetesHelper . getNamespace ( entity ) ; \nif ( StringUtils . isBlank ( answer ) ) answer = getNamespace ( ) ; \napplyNamespace ( answer ) ; \nreturn answer ; \n} \n} \n"}
{"3527": "public class DefaultNamespaceEnricher { \n@ Override public void create ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nfinal String name = config . getNamespace ( ) ; \nif ( name == null || name . isEmpty ( ) ) return ; \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { \nString type = getConfig ( Config . type ) ; \nif ( \"project\" . equalsIgnoreCase ( type ) || \"namespace\" . equalsIgnoreCase ( type ) ) if ( platformMode == PlatformMode . kubernetes ) { \nlog . info ( \"Adding a default Namespace:\" + config . getNamespace ( ) ) ; \nNamespace namespace = handlerHub . getNamespaceHandler ( ) . getNamespace ( config . getNamespace ( ) ) ; \nbuilder . addToNamespaceItems ( namespace ) ; \n} \nelse { \nlog . info ( \"Adding a default Project\" + config . getNamespace ( ) ) ; \nProject project = handlerHub . getProjectHandler ( ) . getProject ( config . getNamespace ( ) ) ; \nbuilder . addToProjectItems ( project ) ; \n} \n} \n} \n} \n"}
{"3528": "public class DefaultNamespaceEnricher { \n@ Override public void enrich ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nbuilder . accept ( new TypedVisitor < ObjectMetaBuilder > ( ) { \nprivate String getNamespaceName ( ) { \nString name = null ; \nif ( config . getNamespace ( ) != null && ! config . getNamespace ( ) . isEmpty ( ) ) name = config . getNamespace ( ) ; \nname = builder . getItems ( ) . stream ( ) . filter ( item -> Arrays . asList ( NAMESPACE_KINDS ) . contains ( item . getKind ( ) ) ) . findFirst ( ) . get ( ) . getMetadata ( ) . getName ( ) ; \nreturn name ; \n} \n@ Override public void visit ( ObjectMetaBuilder metaBuilder ) { \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) return ; \nString name = getNamespaceName ( ) ; \nif ( name == null || name . isEmpty ( ) ) return ; \nmetaBuilder . withNamespace ( name ) . build ( ) ; \n} \n} \n) ; \nbuilder . accept ( new TypedVisitor < NamespaceBuilder > ( ) { \n@ Override public void visit ( NamespaceBuilder builder ) { \nbuilder . withNewStatus ( \"active\" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; \n} \n} \n) ; \nbuilder . accept ( new TypedVisitor < ProjectBuilder > ( ) { \n@ Override public void visit ( ProjectBuilder builder ) { \nbuilder . withNewStatus ( \"active\" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"3529": "public class JavaExecGenerator { \nprotected Map < String , String > getEnv ( boolean prePackagePhase ) throws MojoExecutionException { \nMap < String , String > ret = new HashMap < > ( ) ; \nif ( ! isFatJar ( ) ) { \nString mainClass = getConfig ( Config . mainClass ) ; \nif ( mainClass == null ) { \nmainClass = mainClassDetector . getMainClass ( ) ; \nif ( mainClass == null ) if ( ! prePackagePhase ) throw new MojoExecutionException ( \"Cannot extract main class to startup\" ) ; \n} \nif ( mainClass != null ) { \nlog . verbose ( \"Detected main class %s\" , mainClass ) ; \nret . put ( JAVA_MAIN_CLASS_ENV_VAR , mainClass ) ; \n} \n} \nList < String > javaOptions = getExtraJavaOptions ( ) ; \nif ( javaOptions . size ( ) > 0 ) ret . put ( JAVA_OPTIONS , StringUtils . join ( javaOptions . iterator ( ) , \" \" ) ) ; \nreturn ret ; \n} \n} \n"}
{"3530": "public class GoTimeUtil { \npublic static Integer durationSeconds ( String duration ) { \nBigDecimal ns = durationNs ( duration ) ; \nif ( ns == null ) return null ; \nBigDecimal sec = ns . divide ( new BigDecimal ( 1_000_000_000 ) ) ; \nif ( sec . compareTo ( new BigDecimal ( Integer . MAX_VALUE ) ) > 0 ) throw new IllegalArgumentException ( \"Integer Overflow\" ) ; \nreturn sec . intValue ( ) ; \n} \n} \n"}
{"3531": "public class GoTimeUtil { \npublic static BigDecimal durationNs ( String durationP ) { \nif ( durationP == null ) return null ; \nString duration = durationP . trim ( ) ; \nif ( duration . length ( ) == 0 ) return null ; \nint unitPos = 1 ; \nwhile ( unitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) unitPos ++ ; \nif ( unitPos >= duration . length ( ) ) throw new IllegalArgumentException ( \"Time unit not found in string: \" + duration ) ; \nString tail = duration . substring ( unitPos ) ; \nLong multiplier = null ; \nInteger unitEnd = null ; \nfor ( int i = 0 ; \ni < TIME_UNITS . length ; \ni ++ ) if ( tail . startsWith ( TIME_UNITS [ i ] ) ) { \nmultiplier = UNIT_MULTIPLIERS [ i ] ; \nunitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; \nbreak ; \n} \nif ( multiplier == null ) throw new IllegalArgumentException ( \"Unknown time unit in string: \" + duration ) ; \nBigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; \nvalue = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; \nString remaining = duration . substring ( unitEnd ) ; \nBigDecimal remainingValue = durationNs ( remaining ) ; \nif ( remainingValue != null ) value = value . add ( remainingValue ) ; \nreturn value ; \n} \n} \n"}
{"3532": "public class AbstractAppServerHandler { \nprotected String [ ] scanFiles ( String ... patterns ) { \nString buildOutputDir = project . getBuild ( ) . getDirectory ( ) ; \nif ( buildOutputDir != null && new File ( buildOutputDir ) . exists ( ) ) { \nDirectoryScanner directoryScanner = new DirectoryScanner ( ) ; \ndirectoryScanner . setBasedir ( buildOutputDir ) ; \ndirectoryScanner . setIncludes ( patterns ) ; \ndirectoryScanner . scan ( ) ; \nreturn directoryScanner . getIncludedFiles ( ) ; \n} \nelse return new String [ 0 ] ; \n} \n} \n"}
{"3534": "public class ApplyMojo { \nprivate boolean serviceHasIngressRule ( List < Ingress > ingresses , Service service ) { \nString serviceName = KubernetesHelper . getName ( service ) ; \nfor ( Ingress ingress : ingresses ) { \nIngressSpec spec = ingress . getSpec ( ) ; \nif ( spec == null ) break ; \nList < IngressRule > rules = spec . getRules ( ) ; \nif ( rules == null ) break ; \nfor ( IngressRule rule : rules ) { \nHTTPIngressRuleValue http = rule . getHttp ( ) ; \nif ( http == null ) break ; \nList < HTTPIngressPath > paths = http . getPaths ( ) ; \nif ( paths == null ) break ; \nfor ( HTTPIngressPath path : paths ) { \nIngressBackend backend = path . getBackend ( ) ; \nif ( backend == null ) break ; \nif ( Objects . equals ( serviceName , backend . getServiceName ( ) ) ) return true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3540": "public class IconEnricher { \nprivate String getDefaultIconRef ( ) { \nProjectClassLoaders cls = getContext ( ) . getProjectClassLoaders ( ) ; \nif ( cls . isClassInCompileClasspath ( false , \"io.fabric8.funktion.runtime.Main\" ) || getContext ( ) . hasDependency ( \"io.fabric8.funktion\" , null ) ) return \"funktion\" ; \nif ( cls . isClassInCompileClasspath ( false , \"org.apache.camel.CamelContext\" ) ) return \"camel\" ; \nif ( getContext ( ) . hasPlugin ( null , SpringBootConfigurationHelper . SPRING_BOOT_MAVEN_PLUGIN_ARTIFACT_ID ) || cls . isClassInCompileClasspath ( false , \"org.springframework.boot.SpringApplication\" ) ) return \"spring-boot\" ; \nif ( cls . isClassInCompileClasspath ( false , \"org.springframework.core.Constants\" ) ) return \"spring\" ; \nif ( cls . isClassInCompileClasspath ( false , \"org.vertx.java.core.Handler\" , \"io.vertx.core.Handler\" ) ) return \"vertx\" ; \nif ( getContext ( ) . hasPlugin ( \"org.wildfly.swarm\" , \"wildfly-swarm-plugin\" ) || getContext ( ) . hasDependency ( \"org.wildfly.swarm\" , null ) ) return \"wildfly-swarm\" ; \nif ( getContext ( ) . hasPlugin ( \"io.thorntail\" , \"thorntail-maven-plugin\" ) || getContext ( ) . hasDependency ( \"io.thorntail\" , null ) ) return \"wildfly-swarm\" ; \nreturn null ; \n} \n} \n"}
{"3541": "public class IconEnricher { \nprivate void copyAppConfigFiles ( File appBuildDir , File appConfigDir ) throws IOException { \nFile [ ] files = appConfigDir . listFiles ( ) ; \nif ( files != null ) { \nappBuildDir . mkdirs ( ) ; \nfor ( File file : files ) { \nFile outFile = new File ( appBuildDir , file . getName ( ) ) ; \nif ( file . isDirectory ( ) ) copyAppConfigFiles ( outFile , file ) ; \nelse Files . copy ( file , outFile ) ; \n} \n} \n} \n} \n"}
{"3542": "public class SpringBootUtil { \nprotected static Properties getPropertiesResource ( URL resource ) { \nProperties answer = new Properties ( ) ; \nif ( resource != null ) try ( InputStream stream = resource . openStream ( ) ) { \nanswer . load ( stream ) ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( \"Error while reading resource from URL \" + resource , e ) ; \n} \nreturn answer ; \n} \n} \n"}
{"3549": "public class ResourceMojo { \nprotected static Template getSingletonTemplate ( KubernetesList resources ) { \nif ( resources != null ) { \nList < HasMetadata > items = resources . getItems ( ) ; \nif ( items != null && items . size ( ) == 1 ) { \nHasMetadata singleEntity = items . get ( 0 ) ; \nif ( singleEntity instanceof Template ) return ( Template ) singleEntity ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3550": "public class ResourceMojo { \nprivate Date getBuildReferenceDate ( ) throws MojoExecutionException { \nFile tsFile = new File ( project . getBuild ( ) . getDirectory ( ) , AbstractDockerMojo . DOCKER_BUILD_TIMESTAMP ) ; \nif ( ! tsFile . exists ( ) ) return new Date ( ) ; \ntry { \nreturn EnvUtil . loadTimestamp ( tsFile ) ; \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Cannot read timestamp from \" + tsFile , e ) ; \n} \n} \n} \n"}
{"3554": "public class BaseGenerator { \nprotected void addFrom ( BuildImageConfiguration . Builder builder ) { \nString fromMode = getConfigWithFallback ( Config . fromMode , \"fabric8.generator.fromMode\" , getFromModeDefault ( context . getRuntimeMode ( ) ) ) ; \nString from = getConfigWithFallback ( Config . from , \"fabric8.generator.from\" , null ) ; \nif ( \"docker\" . equalsIgnoreCase ( fromMode ) ) { \nString fromImage = from ; \nif ( fromImage == null ) fromImage = fromSelector != null ? fromSelector . getFrom ( ) : null ; \nbuilder . from ( fromImage ) ; \nlog . info ( \"Using Docker image %s as base / builder\" , fromImage ) ; \n} \nelse if ( \"istag\" . equalsIgnoreCase ( fromMode ) ) { \nMap < String , String > fromExt = new HashMap < > ( ) ; \nif ( from != null ) { \nImageName iName = new ImageName ( from ) ; \nString tag = iName . getTag ( ) ; \nif ( StringUtils . isBlank ( tag ) ) tag = \"latest\" ; \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) , iName . getSimpleName ( ) + \":\" + tag ) ; \nif ( iName . getUser ( ) != null ) fromExt . put ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) , iName . getUser ( ) ) ; \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . kind . key ( ) , \"ImageStreamTag\" ) ; \n} \nelse fromExt = fromSelector != null ? fromSelector . getImageStreamTagFromExt ( ) : null ; \nif ( fromExt != null ) { \nString namespace = fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) ) ; \nif ( namespace != null ) log . info ( \"Using ImageStreamTag '%s' from namespace '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) , namespace ) ; \nelse log . info ( \"Using ImageStreamTag '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) ) ; \nbuilder . fromExt ( fromExt ) ; \n} \n} \nelse throw new IllegalArgumentException ( String . format ( \"Invalid 'fromMode' in generator configuration for '%s'\" , getName ( ) ) ) ; \n} \n} \n"}
{"3555": "public class BaseGenerator { \nprivate String getFromModeDefault ( RuntimeMode mode ) { \nif ( mode == RuntimeMode . openshift && fromSelector != null && fromSelector . isRedHat ( ) ) return \"istag\" ; \nelse return \"docker\" ; \n} \n} \n"}
{"3556": "public class BaseGenerator { \nprotected String getImageName ( ) { \nif ( RuntimeMode . isOpenShiftMode ( getProject ( ) . getProperties ( ) ) ) return getConfigWithFallback ( Config . name , \"fabric8.generator.name\" , \"%a:%l\" ) ; \nelse return getConfigWithFallback ( Config . name , \"fabric8.generator.name\" , \"%g/%a:%l\" ) ; \n} \n} \n"}
{"3557": "public class BaseGenerator { \nprotected String getRegistry ( ) { \nif ( ! RuntimeMode . isOpenShiftMode ( getProject ( ) . getProperties ( ) ) ) return getConfigWithFallback ( Config . registry , \"fabric8.generator.registry\" , null ) ; \nreturn null ; \n} \n} \n"}
{"3558": "public class AbstractLiveEnricher { \nboolean isOnline ( ) { \nString isOnline = getConfig ( Config . online ) ; \nif ( isOnline != null ) return Configs . asBoolean ( isOnline ) ; \nBoolean ret = asBooleanFromGlobalProp ( \"fabric8.online\" ) ; \nreturn ret != null ? ret : getDefaultOnline ( ) ; \n} \n} \n"}
{"3559": "public class AbstractLiveEnricher { \nprotected String getExternalServiceURL ( String serviceName , String protocol ) { \nif ( ! isOnline ( ) ) { \ngetLog ( ) . info ( \"Not looking for service \" + serviceName + \" as we are in offline mode\" ) ; \nreturn null ; \n} \nelse try { \nKubernetesClient kubernetes = getKubernetes ( ) ; \nString ns = kubernetes . getNamespace ( ) ; \nif ( StringUtils . isBlank ( ns ) ) ns = getNamespace ( ) ; \nService service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; \nreturn service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; \n} \ncatch ( Throwable e ) { \nThrowable cause = e ; \nboolean notFound = false ; \nboolean connectError = false ; \nStack < Throwable > stack = unfoldExceptions ( e ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nThrowable t = stack . pop ( ) ; \nif ( t instanceof ConnectException || \"No route to host\" . equals ( t . getMessage ( ) ) ) { \ngetLog ( ) . warn ( \"Cannot connect to Kubernetes to find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse if ( t instanceof IllegalArgumentException || t . getMessage ( ) != null && t . getMessage ( ) . matches ( \"^No.*found.*$\" ) ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \n; \n} \ngetLog ( ) . warn ( \"Cannot find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \n} \n"}
{"3560": "public class AbstractLiveEnricher { \nprotected Boolean asBooleanFromGlobalProp ( String prop ) { \nString value = getContext ( ) . getConfiguration ( ) . getProperty ( prop ) ; \nif ( value == null ) value = System . getProperty ( prop ) ; \nreturn value != null ? Boolean . valueOf ( value ) : null ; \n} \n} \n"}
{"3561": "public class ElasticsearchJestAutoConfiguration { \nprivate JestClient createJestClient ( String uri ) { \nHttpClientConfig . Builder builder = new HttpClientConfig . Builder ( uri ) . maxTotalConnection ( properties . getMaxTotalConnection ( ) ) . defaultMaxTotalConnectionPerRoute ( properties . getDefaultMaxTotalConnectionPerRoute ( ) ) . maxConnectionIdleTime ( properties . getMaxConnectionIdleTime ( ) , TimeUnit . MILLISECONDS ) . readTimeout ( properties . getReadTimeout ( ) ) . multiThreaded ( properties . getMultiThreaded ( ) ) ; \nif ( StringUtils . hasText ( this . properties . getUsername ( ) ) ) builder . defaultCredentials ( this . properties . getUsername ( ) , this . properties . getPassword ( ) ) ; \nString proxyHost = this . properties . getProxy ( ) . getHost ( ) ; \nif ( StringUtils . hasText ( proxyHost ) ) { \nInteger proxyPort = this . properties . getProxy ( ) . getPort ( ) ; \nAssert . notNull ( proxyPort , \"Proxy port must not be null\" ) ; \nbuilder . proxy ( new HttpHost ( proxyHost , proxyPort ) ) ; \n} \nList < HttpClientConfigBuilderCustomizer > configBuilderCustomizers = builderCustomizers != null ? builderCustomizers . getIfAvailable ( ) : new ArrayList < > ( ) ; \nif ( ! CollectionUtils . isEmpty ( configBuilderCustomizers ) ) { \nlogger . info ( \"Custom HttpClientConfigBuilderCustomizers detected. Applying these to the HttpClientConfig builder.\" ) ; \nconfigBuilderCustomizers . stream ( ) . forEach ( customizer -> customizer . customize ( builder ) ) ; \nlogger . info ( \"Custom HttpClientConfigBuilderCustomizers applied.\" ) ; \n} \nJestClientFactory factory = jestClientFactory != null ? jestClientFactory : new JestClientFactory ( ) ; \nfactory . setHttpClientConfig ( builder . build ( ) ) ; \nreturn factory . getObject ( ) ; \n} \n} \n"}
{"3562": "public class ElasticsearchJestAutoConfiguration { \nprivate int createInternalNode ( ) throws NodeValidationException { \nif ( logger . isInfoEnabled ( ) ) logger . info ( \"Create test ES node\" ) ; \nint port = SocketUtils . findAvailableTcpPort ( ) ; \nString clusterName = INTERNAL_TEST_CLUSTER_NAME + UUID . randomUUID ( ) ; \nSettings . Builder settingsBuilder = Settings . builder ( ) . put ( \"cluster.name\" , clusterName ) . put ( \"http.type\" , \"netty4\" ) . put ( \"http.port\" , String . valueOf ( port ) ) ; \nif ( this . esNodeproperties != null ) this . esNodeproperties . getProperties ( ) . forEach ( settingsBuilder :: put ) ; \nCollection < Class < ? extends Plugin > > plugins = scanPlugins ( ) ; \nplugins . add ( Netty4Plugin . class ) ; \nthis . node = new InternalNode ( settingsBuilder . build ( ) , plugins ) . start ( ) ; \nreturn Integer . parseInt ( settingsBuilder . get ( \"http.port\" ) ) ; \n} \n} \n"}
{"3566": "public class PayPalPaymentResource { \npublic static PayPalPaymentResource fromJson ( String jsonString ) throws JSONException { \nJSONObject json = new JSONObject ( jsonString ) ; \nPayPalPaymentResource payPalPaymentResource = new PayPalPaymentResource ( ) ; \nJSONObject redirectJson = json . optJSONObject ( PAYMENT_RESOURCE_KEY ) ; \nif ( redirectJson != null ) payPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , REDIRECT_URL_KEY , \"\" ) ) ; \nelse { \nredirectJson = json . optJSONObject ( AGREEMENT_SETUP_KEY ) ; \npayPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , APPROVAL_URL_KEY , \"\" ) ) ; \n} \nreturn payPalPaymentResource ; \n} \n} \n"}
{"3567": "public class BraintreeHttpClient { \n@ Override public void get ( String path , HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nUri uri ; \nif ( path . startsWith ( \"http\" ) ) uri = Uri . parse ( path ) ; \nelse uri = Uri . parse ( mBaseUrl + path ) ; \nif ( mAuthorization instanceof ClientToken ) uri = uri . buildUpon ( ) . appendQueryParameter ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . build ( ) ; \nsuper . get ( uri . toString ( ) , callback ) ; \n} \n} \n"}
{"3568": "public class BraintreeHttpClient { \n@ Override public void post ( String path , String data , HttpResponseCallback callback ) { \ntry { \nif ( mAuthorization instanceof ClientToken ) data = new JSONObject ( data ) . put ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . toString ( ) ; \nsuper . post ( path , data , callback ) ; \n} \ncatch ( JSONException e ) { \npostCallbackOnMainThread ( callback , e ) ; \n} \n} \n} \n"}
{"3569": "public class VenmoConfiguration { \nstatic VenmoConfiguration fromJson ( JSONObject json ) { \nif ( json == null ) json = new JSONObject ( ) ; \nVenmoConfiguration venmoConfiguration = new VenmoConfiguration ( ) ; \nvenmoConfiguration . mAccessToken = Json . optString ( json , ACCESS_TOKEN_KEY , \"\" ) ; \nvenmoConfiguration . mEnvironment = Json . optString ( json , ENVIRONMENT_KEY , \"\" ) ; \nvenmoConfiguration . mMerchantId = Json . optString ( json , MERCHANT_ID_KEY , \"\" ) ; \nreturn venmoConfiguration ; \n} \n} \n"}
{"3571": "public class DataCollector { \npublic static void collectDeviceData ( final BraintreeFragment fragment , final String merchantId , final BraintreeResponseListener < String > listener ) { \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nfinal JSONObject deviceData = new JSONObject ( ) ; \ntry { \nString clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; \nif ( ! TextUtils . isEmpty ( clientMetadataId ) ) deviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; \n} \ncatch ( JSONException ignored ) { \n} \nif ( configuration . getKount ( ) . isEnabled ( ) ) { \nfinal String id ; \nif ( merchantId != null ) id = merchantId ; \nelse id = configuration . getKount ( ) . getKountMerchantId ( ) ; \ntry { \nfinal String deviceSessionId = UUIDHelper . getFormattedUUID ( ) ; \nstartDeviceCollector ( fragment , id , deviceSessionId , new BraintreeResponseListener < String > ( ) { \n@ Override public void onResponse ( String sessionId ) { \ntry { \ndeviceData . put ( DEVICE_SESSION_ID_KEY , deviceSessionId ) ; \ndeviceData . put ( FRAUD_MERCHANT_ID_KEY , id ) ; \n} \ncatch ( JSONException ignored ) { \n} \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \n) ; \n} \ncatch ( ClassNotFoundException | NoClassDefFoundError | NumberFormatException ignored ) { \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \nelse listener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"3572": "public class DataCollector { \npublic static void collectPayPalDeviceData ( final BraintreeFragment fragment , final BraintreeResponseListener < String > listener ) { \nfinal JSONObject deviceData = new JSONObject ( ) ; \ntry { \nString clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; \nif ( ! TextUtils . isEmpty ( clientMetadataId ) ) deviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; \n} \ncatch ( JSONException ignored ) { \n} \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \n"}
{"3574": "public class SignatureVerification { \n@ SuppressLint ( \"PackageManagerGetSignatures\" ) public static boolean isSignatureValid ( Context context , String packageName , String certificateSubject , String certificateIssuer , int publicKeyHashCode ) { \nif ( ! sEnableSignatureVerification ) return true ; \nPackageManager packageManager = context . getPackageManager ( ) ; \nSignature [ ] signatures ; \ntry { \nsignatures = packageManager . getPackageInfo ( packageName , PackageManager . GET_SIGNATURES ) . signatures ; \n} \ncatch ( NameNotFoundException e ) { \nreturn false ; \n} \nInputStream certStream = null ; \nboolean validated = ( signatures . length != 0 ) ; \nfor ( Signature signature : signatures ) { \ntry { \ncertStream = new ByteArrayInputStream ( signature . toByteArray ( ) ) ; \nX509Certificate x509Cert = ( X509Certificate ) CertificateFactory . getInstance ( \"X509\" ) . generateCertificate ( certStream ) ; \nString subject = x509Cert . getSubjectX500Principal ( ) . getName ( ) ; \nString issuer = x509Cert . getIssuerX500Principal ( ) . getName ( ) ; \nint actualPublicKeyHashCode = x509Cert . getPublicKey ( ) . hashCode ( ) ; \nvalidated &= ( certificateSubject . equals ( subject ) && certificateIssuer . equals ( issuer ) && publicKeyHashCode == actualPublicKeyHashCode ) ; \nif ( ! validated ) return false ; \n} \ncatch ( CertificateException e ) { \nreturn false ; \n} \nfinally { \ntry { \nif ( certStream != null ) certStream . close ( ) ; \n} \ncatch ( IOException ignored ) { \n} \n} \n} \nreturn validated ; \n} \n} \n"}
{"3575": "public class Json { \npublic static String optString ( JSONObject json , String name , String fallback ) { \nif ( json . isNull ( name ) ) return fallback ; \nelse return json . optString ( name , fallback ) ; \n} \n} \n"}
{"3576": "public class PaymentMethodNonce { \npublic static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { \nJSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; \nif ( paymentMethods == null ) return Collections . emptyList ( ) ; \nList < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; \nJSONObject json ; \nPaymentMethodNonce paymentMethodNonce ; \nfor ( int i = 0 ; \ni < paymentMethods . length ( ) ; \ni ++ ) { \njson = paymentMethods . getJSONObject ( i ) ; \npaymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; \nif ( paymentMethodNonce != null ) paymentMethodsNonces . add ( paymentMethodNonce ) ; \n} \nreturn paymentMethodsNonces ; \n} \n} \n"}
{"3577": "public class OtcConfiguration { \npublic CheckoutRecipe getBrowserCheckoutConfig ( ) { \nfor ( CheckoutRecipe recipe : mCheckoutRecipesInDecreasingPriorityOrder ) { \nif ( recipe . getTarget ( ) == RequestTarget . browser ) return recipe ; \n} \nreturn null ; \n} \n} \n"}
{"3578": "public class OtcConfiguration { \npublic BillingAgreementRecipe getBrowserBillingAgreementConfig ( ) { \nfor ( BillingAgreementRecipe recipe : mBillingAgreementRecipesInDecreasingPriorityOrder ) { \nif ( recipe . getTarget ( ) == RequestTarget . browser ) return recipe ; \n} \nreturn null ; \n} \n} \n"}
{"3579": "public class HttpClient { \npublic void get ( final String path , final HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nfinal String url ; \nif ( path . startsWith ( \"http\" ) ) url = path ; \nelse url = mBaseUrl + path ; \nmThreadPool . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \nHttpURLConnection connection = null ; \ntry { \nconnection = init ( url ) ; \nconnection . setRequestMethod ( METHOD_GET ) ; \npostCallbackOnMainThread ( callback , parseResponse ( connection ) ) ; \n} \ncatch ( Exception e ) { \npostCallbackOnMainThread ( callback , e ) ; \n} \nfinally { \nif ( connection != null ) connection . disconnect ( ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3581": "public class HttpClient { \npublic String post ( String path , String data ) throws Exception { \nHttpURLConnection connection = null ; \ntry { \nif ( path . startsWith ( \"http\" ) ) connection = init ( path ) ; \nelse connection = init ( mBaseUrl + path ) ; \nconnection . setRequestProperty ( \"Content-Type\" , \"application/json\" ) ; \nconnection . setRequestMethod ( METHOD_POST ) ; \nconnection . setDoOutput ( true ) ; \nwriteOutputStream ( connection . getOutputStream ( ) , data ) ; \nreturn parseResponse ( connection ) ; \n} \nfinally { \nif ( connection != null ) connection . disconnect ( ) ; \n} \n} \n} \n"}
{"3584": "public class BraintreeFragment { \npublic < T extends BraintreeListener > void addListener ( T listener ) { \nif ( listener instanceof ConfigurationListener ) mConfigurationListener = ( ConfigurationListener ) listener ; \nif ( listener instanceof BraintreeCancelListener ) mCancelListener = ( BraintreeCancelListener ) listener ; \nif ( listener instanceof PaymentMethodNoncesUpdatedListener ) mPaymentMethodNoncesUpdatedListener = ( PaymentMethodNoncesUpdatedListener ) listener ; \nif ( listener instanceof PaymentMethodNonceCreatedListener ) mPaymentMethodNonceCreatedListener = ( PaymentMethodNonceCreatedListener ) listener ; \nif ( listener instanceof PaymentMethodNonceDeletedListener ) mPaymentMethodNonceDeletedListener = ( PaymentMethodNonceDeletedListener ) listener ; \nif ( listener instanceof BraintreePaymentResultListener ) mBraintreePaymentResultListener = ( BraintreePaymentResultListener ) listener ; \nif ( listener instanceof BraintreeErrorListener ) mErrorListener = ( BraintreeErrorListener ) listener ; \nif ( listener instanceof UnionPayListener ) mUnionPayListener = ( UnionPayListener ) listener ; \nif ( listener instanceof AmericanExpressListener ) mAmericanExpressListener = ( AmericanExpressListener ) listener ; \nflushCallbacks ( ) ; \n} \n} \n"}
{"3585": "public class BraintreeFragment { \npublic < T extends BraintreeListener > void removeListener ( T listener ) { \nif ( listener instanceof ConfigurationListener ) mConfigurationListener = null ; \nif ( listener instanceof BraintreeCancelListener ) mCancelListener = null ; \nif ( listener instanceof PaymentMethodNoncesUpdatedListener ) mPaymentMethodNoncesUpdatedListener = null ; \nif ( listener instanceof PaymentMethodNonceCreatedListener ) mPaymentMethodNonceCreatedListener = null ; \nif ( listener instanceof PaymentMethodNonceDeletedListener ) mPaymentMethodNonceDeletedListener = null ; \nif ( listener instanceof BraintreePaymentResultListener ) mBraintreePaymentResultListener = null ; \nif ( listener instanceof BraintreeErrorListener ) mErrorListener = null ; \nif ( listener instanceof UnionPayListener ) mUnionPayListener = null ; \nif ( listener instanceof AmericanExpressListener ) mAmericanExpressListener = null ; \n} \n} \n"}
{"3586": "public class PayPal { \npublic static void requestBillingAgreement ( BraintreeFragment fragment , PayPalRequest request , PayPalApprovalHandler handler ) { \nif ( request . getAmount ( ) == null ) { \nfragment . sendAnalyticsEvent ( \"paypal.billing-agreement.selected\" ) ; \nif ( request . shouldOfferCredit ( ) ) fragment . sendAnalyticsEvent ( \"paypal.billing-agreement.credit.offered\" ) ; \nrequestOneTimePayment ( fragment , request , true , handler ) ; \n} \nelse fragment . postCallback ( new BraintreeException ( \"There must be no amount specified for the Billing Agreement flow\" ) ) ; \n} \n} \n"}
{"3587": "public class PayPal { \nprotected static void onActivityResult ( final BraintreeFragment fragment , int resultCode , Intent data ) { \nRequest request = getPersistedRequest ( fragment . getApplicationContext ( ) ) ; \nString paymentType = paymentTypeForRequest ( request ) ; \nString switchType = switchTypeForIntent ( data ) ; \nString eventPrefix = paymentType + \".\" + switchType ; \nif ( resultCode == AppCompatActivity . RESULT_OK && data != null && request != null ) { \nResult result = PayPalOneTouchCore . parseResponse ( fragment . getApplicationContext ( ) , request , data ) ; \nswitch ( result . getResultType ( ) ) { \ncase Error : fragment . postCallback ( new BrowserSwitchException ( result . getError ( ) . getMessage ( ) ) ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".failed\" ) ; \nbreak ; \ncase Cancel : fragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".canceled\" ) ; \nbreak ; \ncase Success : onSuccess ( fragment , data , request , result ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".succeeded\" ) ; \nbreak ; \n} \n} \nelse { \nfragment . sendAnalyticsEvent ( eventPrefix + \".canceled\" ) ; \nif ( resultCode != AppCompatActivity . RESULT_CANCELED ) fragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; \n} \n} \n} \n"}
{"3588": "public class PayPal { \nprivate static PayPalAccountBuilder parseResponse ( PayPalRequest paypalRequest , Request request , Result result , Intent intent ) { \nPayPalAccountBuilder paypalAccountBuilder = new PayPalAccountBuilder ( ) . clientMetadataId ( request . getClientMetadataId ( ) ) ; \nif ( paypalRequest != null && paypalRequest . getMerchantAccountId ( ) != null ) paypalAccountBuilder . merchantAccountId ( paypalRequest . getMerchantAccountId ( ) ) ; \nif ( request instanceof CheckoutRequest && paypalRequest != null ) paypalAccountBuilder . intent ( paypalRequest . getIntent ( ) ) ; \nif ( isAppSwitch ( intent ) ) paypalAccountBuilder . source ( \"paypal-app\" ) ; \nelse paypalAccountBuilder . source ( \"paypal-browser\" ) ; \npaypalAccountBuilder . oneTouchCoreData ( result . getResponse ( ) ) ; \nreturn paypalAccountBuilder ; \n} \n} \n"}
{"3591": "public class OpenKoreanTextProcessorJava { \npublic static List < String > tokensToJavaStringList ( Seq < KoreanToken > tokens , boolean keepSpace ) { \nIterator < KoreanToken > tokenized = tokens . iterator ( ) ; \nList < String > output = new LinkedList < > ( ) ; \nwhile ( tokenized . hasNext ( ) ) { \nfinal KoreanToken token = tokenized . next ( ) ; \nif ( keepSpace || token . pos ( ) != KoreanPos . Space ( ) ) output . add ( token . text ( ) ) ; \n} \nreturn output ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) sum += taps [ i ] ; \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) if ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) return State . DONE ; \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse return State . MORE_DATA ; \n} \n} \n"}
{"3601": "public class ImageSequenceDemuxer { \npublic int getMaxAvailableFrame ( ) { \nif ( maxAvailableFrame == - 1 ) { \nint firstPoint = 0 ; \nfor ( int i = MAX_MAX ; \ni > 0 ; \ni /= 2 ) if ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { \nfirstPoint = i ; \nbreak ; \n} \nint pos = firstPoint ; \nfor ( int interv = firstPoint / 2 ; \ninterv > 1 ; \ninterv /= 2 ) if ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) pos += interv ; \nmaxAvailableFrame = pos ; \nLogger . info ( \"Max frame found: \" + maxAvailableFrame ) ; \n} \nreturn Math . min ( maxAvailableFrame , maxFrames ) ; \n} \n} \n"}
{"3608": "public class QTTimeUtil { \npublic static long editedToMedia ( TrakBox trak , long editedTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) return editedTv ; \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( accum + duration > editedTv ) return edit . getMediaTime ( ) + editedTv - accum ; \naccum += duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3621": "public class AACDecoderConfig { \npublic static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { \nfinal IBitStream _in = BitStream . createBitStream ( data ) ; \nfinal AACDecoderConfig config = new AACDecoderConfig ( ) ; \ntry { \nconfig . profile = readProfile ( _in ) ; \nint sf = _in . readBits ( 4 ) ; \nif ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; \nelse config . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; \nProfile cp = config . profile ; \nif ( AAC_SBR == cp ) { \nconfig . extProfile = cp ; \nconfig . sbrPresent = true ; \nsf = _in . readBits ( 4 ) ; \nconfig . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . profile = readProfile ( _in ) ; \n} \nelse if ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { \nconfig . frameLengthFlag = _in . readBool ( ) ; \nif ( config . frameLengthFlag ) throw new AACException ( \"config uses 960-sample frames, not yet supported\" ) ; \nconfig . dependsOnCoreCoder = _in . readBool ( ) ; \nif ( config . dependsOnCoreCoder ) config . coreCoderDelay = _in . readBits ( 14 ) ; \nelse config . coreCoderDelay = 0 ; \nconfig . extensionFlag = _in . readBool ( ) ; \nif ( config . extensionFlag ) { \nif ( cp . isErrorResilientProfile ( ) ) { \nconfig . sectionDataResilience = _in . readBool ( ) ; \nconfig . scalefactorResilience = _in . readBool ( ) ; \nconfig . spectralDataResilience = _in . readBool ( ) ; \n} \n_in . skipBit ( ) ; \n} \nif ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { \n_in . skipBits ( 3 ) ; \nPCE pce = new PCE ( ) ; \npce . decode ( _in ) ; \nconfig . profile = pce . getProfile ( ) ; \nconfig . sampleFrequency = pce . getSampleFrequency ( ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; \n} \nif ( _in . getBitsLeft ( ) > 10 ) readSyncExtension ( _in , config ) ; \n} \nelse throw new AACException ( \"profile not supported: \" + cp . getIndex ( ) ) ; \nreturn config ; \n} \nfinally { \n_in . destroy ( ) ; \n} \n} \n} \n"}
{"3628": "public class SequenceEncoder { \npublic void encodeNativeFrame ( Picture pic ) throws IOException { \nif ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( \"The input images is expected in RGB color.\" ) ; \nColorSpace sinkColor = sink . getInputColor ( ) ; \nLoanerPicture toEncode ; \nif ( sinkColor != null ) { \ntoEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; \ntransform . transform ( pic , toEncode . getPicture ( ) ) ; \n} \nelse toEncode = new LoanerPicture ( pic , 0 ) ; \nPacket pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; \nsink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; \nif ( sinkColor != null ) pixelStore . putBack ( toEncode ) ; \ntimestamp += fps . getDen ( ) ; \nframeNo ++ ; \n} \n} \n"}
{"3629": "public class EbmlUtil { \npublic static byte [ ] ebmlEncodeLen ( long value , int length ) { \nbyte [ ] b = new byte [ length ] ; \nfor ( int idx = 0 ; \nidx < length ; \nidx ++ ) b [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; \nb [ 0 ] |= 0x80 >>> ( length - 1 ) ; \nreturn b ; \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \n-- nBitsPending ; \nif ( nBitsPending <= 0 ) readOneByte ( ) ; \nint tmp = code - ( range << 8 ) ; \nif ( tmp < 0 ) return 0 ; \nelse { \ncode = tmp ; \nreturn 1 ; \n} \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \nfor ( int i = 0 ; \ni < ID_GAIN ; \ni ++ ) if ( lngain == LN_GAIN [ i ] ) return i ; \nreturn 0 ; \n} \n} \n"}
{"3649": "public class AudioUtil { \npublic static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( format . isBigEndian ( ) ) if ( format . getSampleSizeInBits ( ) == 16 ) toFloat16BE ( buf , floatBuf ) ; \nelse toFloat24BE ( buf , floatBuf ) ; \nelse if ( format . getSampleSizeInBits ( ) == 16 ) toFloat16LE ( buf , floatBuf ) ; \nelse toFloat24LE ( buf , floatBuf ) ; \n} \n} \n"}
{"3650": "public class AudioUtil { \npublic static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( format . isBigEndian ( ) ) if ( format . getSampleSizeInBits ( ) == 16 ) fromFloat16BE ( buf , floatBuf ) ; \nelse fromFloat24BE ( buf , floatBuf ) ; \nelse if ( format . getSampleSizeInBits ( ) == 16 ) fromFloat16LE ( buf , floatBuf ) ; \nelse fromFloat24LE ( buf , floatBuf ) ; \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \nfor ( int i = 0 ; \ni < ins . length ; \ni ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; \nfor ( int frames = 0 ; \nframes < max && outb . remaining ( ) >= bytesPerFrame ; \nframes ++ ) for ( int j = 0 ; \nj < ins . length ; \nj ++ ) if ( ins [ j ] . remaining ( ) < bytesPerSample ) for ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) outb . put ( ( byte ) 0 ) ; \nelse for ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) outb . put ( ins [ j ] . get ( ) ) ; \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * outs . length ; \nwhile ( inb . remaining ( ) >= bytesPerFrame ) for ( int j = 0 ; \nj < outs . length ; \nj ++ ) for ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) outs [ j ] . put ( inb . get ( ) ) ; \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \ni < picSizeInMbs ; \ni ++ ) groups [ i ] = 1 ; \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nk < numberOfMbsInBox ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) groups [ mbAddr ] = 0 ; \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3655": "public class SliceGroupMapBuilder { \npublic static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nint k = 0 ; \nfor ( int j = 0 ; \nj < picWidthInMbs ; \nj ++ ) for ( int i = 0 ; \ni < picHeightInMbs ; \ni ++ ) { \nint mbAddr = i * picWidthInMbs + j ; \nif ( k ++ < sizeOfUpperLeftGroup ) groups [ mbAddr ] = changeDirectionInt ; \nelse groups [ mbAddr ] = 1 - changeDirectionInt ; \n} \nreturn groups ; \n} \n} \n"}
{"3656": "public class MXFMetadata { \nprotected static UL [ ] readULBatch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nUL [ ] result = new UL [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) result [ i ] = UL . read ( _bb ) ; \nreturn result ; \n} \n} \n"}
{"3657": "public class MXFMetadata { \nprotected static int [ ] readInt32Batch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nint [ ] result = new int [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) result [ i ] = _bb . getInt ( ) ; \nreturn result ; \n} \n} \n"}
{"3659": "public class H264Encoder { \npublic EncodedFrame encodeFrame ( Picture pic , ByteBuffer _out ) { \nif ( pic . getColor ( ) != ColorSpace . YUV420J ) throw new IllegalArgumentException ( \"Input picture color is not supported: \" + pic . getColor ( ) ) ; \nif ( frameNumber >= keyInterval ) frameNumber = 0 ; \nSliceType sliceType = frameNumber == 0 ? SliceType . I : SliceType . P ; \nboolean idr = frameNumber == 0 ; \nByteBuffer data = doEncodeFrame ( pic , _out , idr , frameNumber ++ , sliceType ) ; \nreturn new EncodedFrame ( data , idr ) ; \n} \n} \n"}
{"3665": "public class JNIMemoryManager { \nvoid gcInternal ( ) { \nJNIReference ref = null ; \nwhile ( ( ref = ( JNIReference ) mRefQueue . poll ( ) ) != null ) ref . delete ( ) ; \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) return false ; \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) out . write ( buffer , 0 , bytesRead ) ; \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) deleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) throw new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) if ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) image = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) image = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) stream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \nelse { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nint numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \nfor ( int i = 0 ; \ni < numSettings ; \ni ++ ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = ( value & flagMask ) > 0 ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \n} \n} \n"}
{"3681": "public class HumbleIO { \nstatic public String generateUniqueName ( Object src , String extension ) { \nStringBuilder builder = new StringBuilder ( ) ; \nbuilder . append ( UUID . randomUUID ( ) . toString ( ) ) ; \nif ( src != null ) { \nbuilder . append ( \"-\" ) ; \nbuilder . append ( src . getClass ( ) . getName ( ) ) ; \nbuilder . append ( \"-\" ) ; \nbuilder . append ( Integer . toHexString ( src . hashCode ( ) ) ) ; \n} \nif ( extension != null ) builder . append ( extension ) ; \nreturn builder . toString ( ) ; \n} \n} \n"}
{"3702": "public class JNIEnv { \npublic static CPUArch getCPUArch ( String javaCPU ) { \nfinal CPUArch javaArch ; \nfinal String javaCPUArch = javaCPU != null ? javaCPU . toLowerCase ( ) : \"\" ; \nif ( javaCPUArch . startsWith ( \"x86_64\" ) || javaCPUArch . startsWith ( \"amd64\" ) || javaCPUArch . startsWith ( \"ia64\" ) ) javaArch = CPUArch . X86_64 ; \nelse if ( javaCPUArch . startsWith ( \"ppc64\" ) || javaCPUArch . startsWith ( \"powerpc64\" ) ) javaArch = CPUArch . PPC64 ; \nelse if ( javaCPUArch . startsWith ( \"ppc\" ) || javaCPUArch . startsWith ( \"powerpc\" ) ) javaArch = CPUArch . PPC ; \nelse if ( javaCPUArch . contains ( \"86\" ) ) javaArch = CPUArch . X86 ; \nelse javaArch = CPUArch . UNKNOWN ; \nreturn javaArch ; \n} \n} \n"}
{"3704": "public class JNIEnv { \npublic static OSFamily getOSFamily ( String osName ) { \nfinal OSFamily retval ; \nif ( osName != null && osName . length ( ) > 0 ) if ( osName . startsWith ( \"Windows\" ) ) retval = OSFamily . WINDOWS ; \nelse if ( osName . startsWith ( \"Mac\" ) ) retval = OSFamily . MAC ; \nelse if ( osName . startsWith ( \"Linux\" ) ) retval = OSFamily . LINUX ; \nelse retval = OSFamily . UNKNOWN ; \nelse retval = OSFamily . UNKNOWN ; \nreturn retval ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) if ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3711": "public class JNILibraryLoader { \nboolean alreadyLoadedLibrary ( String aLibraryName , Long aMajorVersion ) { \nboolean retval = false ; \nSet < Long > foundVersions = mLoadedLibraries . get ( aLibraryName ) ; \nif ( foundVersions != null ) if ( aMajorVersion == null || foundVersions . contains ( aMajorVersion ) ) retval = true ; \nelse log . warn ( \"Attempting load of {}, version {}, but already loaded verions: {}.\" + \"  We will attempt to load the specified version but behavior is undefined\" , new Object [ ] { \naLibraryName , aMajorVersion , foundVersions . toArray ( ) } \n) ; \nreturn retval ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) codec = Codec . findEncodingCodecByName ( codecname ) ; \nelse codec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( int i = 0 ; \ni < duration / framerate . getDouble ( ) ; \ni ++ ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3713": "public class JNIReference { \npublic void delete ( ) { \nfinal long swigPtr = mSwigCPtr . getAndSet ( 0 ) ; \nif ( swigPtr != 0 ) { \nif ( mJavaRefCount . decrementAndGet ( ) == 0 ) FerryJNI . RefCounted_release ( swigPtr , null ) ; \nmMemAllocator = null ; \n} \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) input = input . substring ( 7 ) ; \nif ( input . length ( ) == 0 ) return new byte [ 0 ] ; \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \nfor ( int i = 0 ; \ni < input . length ( ) ; \n++ i ) { \nchar c = input . charAt ( i ) ; \nint digit = c < 128 ? INDEXES [ c ] : - 1 ; \nif ( digit < 0 ) throw new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \ninput58 [ i ] = ( byte ) digit ; \n} \nint zeros = 0 ; \nwhile ( zeros < input58 . length && input58 [ zeros ] == 0 ) ++ zeros ; \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nint outputStart = decoded . length ; \nfor ( int inputStart = zeros ; \ninputStart < input58 . length ; \n) { \ndecoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) ++ inputStart ; \n} \nwhile ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) ++ outputStart ; \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3721": "public class Node { \npublic List < Transaction > getAddressTransactions ( String address , int limit , String after ) throws IOException { \nString requestUrl = String . format ( \"/transactions/address/%s/limit/%d\" , address , limit ) ; \nif ( after != null ) requestUrl += String . format ( \"?after=%s\" , after ) ; \nreturn wavesJsonMapper . < List < List < Transaction > > > convertValue ( send ( requestUrl ) , new TypeReference < List < List < Transaction > > > ( ) { \n} \n) . get ( 0 ) ; \n} \n} \n"}
{"3726": "public class Node { \npublic String compileScript ( String script ) throws IOException { \nif ( script == null || script . isEmpty ( ) ) return null ; \nHttpPost request = new HttpPost ( uri . resolve ( \"/utils/script/compile\" ) ) ; \nrequest . setEntity ( new StringEntity ( script ) ) ; \nreturn parse ( exec ( request ) , \"script\" ) . asText ( ) ; \n} \n} \n"}
{"3727": "public class FSTBytezEncoder { \npublic void writePrimitiveArray ( Object array , int off , int len ) throws IOException { \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \nif ( componentType == byte . class ) writeRawBytes ( ( byte [ ] ) array , off , len ) ; \nelse if ( componentType == char . class ) writeFCharArr ( ( char [ ] ) array , off , len ) ; \nelse if ( componentType == short . class ) writeFShortArr ( ( short [ ] ) array , off , len ) ; \nelse if ( componentType == int . class ) writeFIntArr ( ( int [ ] ) array , off , len ) ; \nelse if ( componentType == double . class ) writeFDoubleArr ( ( double [ ] ) array , off , len ) ; \nelse if ( componentType == float . class ) writeFFloatArr ( ( float [ ] ) array , off , len ) ; \nelse if ( componentType == long . class ) writeFLongArr ( ( long [ ] ) array , off , len ) ; \nelse if ( componentType == boolean . class ) writeFBooleanArr ( ( boolean [ ] ) array , off , len ) ; \nelse throw new RuntimeException ( \"expected primitive array\" ) ; \n} \n} \n"}
{"3731": "public class DefaultCoder { \npublic int toByteArray ( Object obj , byte result [ ] , int resultOffset , int avaiableSize ) { \noutput . resetForReUse ( ) ; \ntry { \noutput . writeObject ( obj ) ; \n} \ncatch ( IOException e ) { \nFSTUtil . < RuntimeException > rethrow ( e ) ; \n} \nint written = output . getWritten ( ) ; \nif ( written > avaiableSize ) throw FSTBufferTooSmallException . Instance ; \nSystem . arraycopy ( output . getBuffer ( ) , 0 , result , resultOffset , written ) ; \nreturn written ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( required <= memory . length ( ) ) return ; \nmutationCount ++ ; \nSystem . out . println ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \ni < max + 2 ; \ni ++ ) f . write ( toWrite ) ; \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . println ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3736": "public class FSTStreamEncoder { \nvoid writeStringAsc ( String name ) throws IOException { \nint len = name . length ( ) ; \nif ( len >= 127 ) throw new RuntimeException ( \"Ascii String too long\" ) ; \nwriteFByte ( ( byte ) len ) ; \nbuffout . ensureFree ( len ) ; \nif ( ascStringCache == null || ascStringCache . length < len ) ascStringCache = new byte [ len ] ; \nname . getBytes ( 0 , len , ascStringCache , 0 ) ; \nwriteRawBytes ( ascStringCache , 0 , len ) ; \n} \n} \n"}
{"3738": "public class FSTConfiguration { \npublic static FSTConfiguration createJsonConfiguration ( boolean prettyPrint , boolean shareReferences ) { \nif ( shareReferences && prettyPrint ) throw new RuntimeException ( \"unsupported flag combination\" ) ; \nreturn createJsonConfiguration ( prettyPrint , shareReferences , null ) ; \n} \n} \n"}
{"3747": "public class FSTConfiguration { \npublic String getCPNameForClass ( Class cl ) { \nString res = minbinNamesReverse . get ( cl . getName ( ) ) ; \nif ( res == null ) { \nif ( cl . isAnonymousClass ( ) ) return getCPNameForClass ( cl . getSuperclass ( ) ) ; \nreturn cl . getName ( ) ; \n} \nreturn res ; \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse if ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse if ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) writeRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) writeRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) writeRawInt ( type , charArr [ i ] ) ; \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) writeRawInt ( type , arr [ i ] ) ; \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) writeRawInt ( type , arr [ i ] ) ; \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \ni < start + len ; \ni ++ ) if ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \n} \n"}
{"3752": "public class MBOut { \npublic void writeRaw ( byte [ ] bufferedName , int i , int length ) { \nif ( pos + length >= bytez . length - 1 ) resize ( ) ; \nSystem . arraycopy ( bufferedName , i , bytez , pos , length ) ; \npos += length ; \n} \n} \n"}
{"3753": "public class FSTObjectOutput { \nprotected FSTClazzInfo . FSTFieldInfo getCachedFI ( Class ... possibles ) { \nif ( refs == null ) refs = refsLocal . get ( ) ; \nif ( curDepth >= refs . length ) return new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; \nelse { \nFSTClazzInfo . FSTFieldInfo inf = refs [ curDepth ] ; \nif ( inf == null ) { \ninf = new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; \nrefs [ curDepth ] = inf ; \nreturn inf ; \n} \ninf . setPossibleClasses ( possibles ) ; \nreturn inf ; \n} \n} \n} \n"}
{"3754": "public class FSTObjectOutput { \nprotected void objectWillBeWritten ( Object obj , int streamPosition ) { \nif ( listener != null ) listener . objectWillBeWritten ( obj , streamPosition ) ; \n} \n} \n"}
{"3755": "public class FSTObjectOutput { \nprotected void objectHasBeenWritten ( Object obj , int oldStreamPosition , int streamPosition ) { \nif ( listener != null ) listener . objectHasBeenWritten ( obj , oldStreamPosition , streamPosition ) ; \n} \n} \n"}
{"3756": "public class FSTObjectOutput { \nprotected FSTClazzInfo getFstClazzInfo ( FSTClazzInfo . FSTFieldInfo referencee , Class clazz ) { \nFSTClazzInfo serializationInfo = null ; \nFSTClazzInfo lastInfo = referencee . lastInfo ; \nif ( lastInfo != null && lastInfo . getClazz ( ) == clazz && lastInfo . conf == conf ) serializationInfo = lastInfo ; \nelse { \nserializationInfo = getClassInfoRegistry ( ) . getCLInfo ( clazz , conf ) ; \nreferencee . lastInfo = serializationInfo ; \n} \nreturn serializationInfo ; \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) if ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) getCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse writeObjectWithContext ( referencee , toWrite , null ) ; \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) if ( subArr == null ) needsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \nelse needsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \n} \n} \n"}
{"3758": "public class StructString { \npublic void setString ( String s ) { \nif ( s == null ) { \nsetLen ( 0 ) ; \nreturn ; \n} \nif ( s . length ( ) > charsLen ( ) ) throw new RuntimeException ( \"String length exceeds buffer size. String len \" + s . length ( ) + \" charsLen:\" + charsLen ( ) ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) chars ( i , s . charAt ( i ) ) ; \nlen = s . length ( ) ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nint sumLen = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni ++ ) sumLen += changeLength [ i ] ; \nsnapshot = new byte [ sumLen ] ; \nint targetIdx = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni ++ ) { \nint changeOffset = changeOffsets [ i ] ; \nint len = changeLength [ i ] ; \nfor ( int ii = 0 ; \nii < len ; \nii ++ ) snapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; \n} \nrebase ( originBase ) ; \n} \n} \n"}
{"3762": "public class FSTObjectRegistry { \npublic int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { \nif ( disabled ) return Integer . MIN_VALUE ; \nif ( clzInfo == null ) { \n} \nelse if ( clzInfo . isFlat ( ) ) return Integer . MIN_VALUE ; \nint handle = objects . putOrGet ( o , streamPosition ) ; \nif ( handle >= 0 ) { \nreUseType [ 0 ] = 0 ; \nreturn handle ; \n} \nreturn Integer . MIN_VALUE ; \n} \n} \n"}
{"3765": "public class BinaryQueue { \npublic byte [ ] readByteArray ( int len ) { \nif ( available ( ) < len ) throw new RuntimeException ( \"not enough data available, check available() > len before calling\" ) ; \nbyte b [ ] = new byte [ len ] ; \nint count = 0 ; \nwhile ( pollIndex != addIndex && count < len ) { \nb [ count ++ ] = storage . get ( pollIndex ++ ) ; \nif ( pollIndex >= storage . length ( ) ) pollIndex = 0 ; \n} \nreturn b ; \n} \n} \n"}
{"3766": "public class BinaryQueue { \npublic int readInt ( ) { \nif ( available ( ) < 4 ) throw new RuntimeException ( \"not enough data available, check available() > 4 before calling\" ) ; \nint ch1 = poll ( ) ; \nint ch2 = poll ( ) ; \nint ch3 = poll ( ) ; \nint ch4 = poll ( ) ; \nreturn ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; \n} \n} \n"}
{"3768": "public class HproseTcpServer { \npublic void setThreadPoolEnabled ( boolean value ) { \nif ( value && ( threadPool == null ) ) threadPool = Executors . newCachedThreadPool ( ) ; \nthreadPoolEnabled = value ; \n} \n} \n"}
{"3769": "public class EmbeddedCassandraServerHelper { \npublic static void startEmbeddedCassandra ( File file , String tmpDir , long timeout ) throws IOException , ConfigurationException { \nif ( cassandraDaemon != null ) return ; \ncheckConfigNameForRestart ( file . getAbsolutePath ( ) ) ; \nlog . debug ( \"Starting cassandra...\" ) ; \nlog . debug ( \"Initialization needed\" ) ; \nSystem . setProperty ( \"cassandra.config\" , \"file:\" + file . getAbsolutePath ( ) ) ; \nSystem . setProperty ( \"cassandra-foreground\" , \"true\" ) ; \nSystem . setProperty ( \"cassandra.native.epoll.enabled\" , \"false\" ) ; \nSystem . setProperty ( \"cassandra.unsafesystem\" , \"true\" ) ; \nif ( System . getProperty ( \"log4j.configuration\" ) == null ) { \ncopy ( DEFAULT_LOG4J_CONFIG_FILE , tmpDir ) ; \nSystem . setProperty ( \"log4j.configuration\" , \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE ) ; \n} \nDatabaseDescriptor . daemonInitialization ( ) ; \ncleanupAndLeaveDirs ( ) ; \nfinal CountDownLatch startupLatch = new CountDownLatch ( 1 ) ; \nExecutorService executor = Executors . newSingleThreadExecutor ( ) ; \nexecutor . execute ( ( ) -> { \ncassandraDaemon = new CassandraDaemon ( ) ; \ncassandraDaemon . activate ( ) ; \nstartupLatch . countDown ( ) ; \n} \n) ; \ntry { \nif ( ! startupLatch . await ( timeout , MILLISECONDS ) ) { \nlog . error ( \"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\" ) ; \nthrow new AssertionError ( \"Cassandra daemon did not start within timeout\" ) ; \n} \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ( ) -> { \nif ( session != null ) session . close ( ) ; \nif ( cluster != null ) cluster . close ( ) ; \n} \n) ) ; \n} \ncatch ( InterruptedException e ) { \nlog . error ( \"Interrupted waiting for Cassandra daemon to start:\" , e ) ; \nthrow new AssertionError ( e ) ; \n} \nfinally { \nexecutor . shutdown ( ) ; \n} \n} \n} \n"}
{"3770": "public class EmbeddedCassandraServerHelper { \npublic static void cleanDataEmbeddedCassandra ( String keyspace , String ... excludedTables ) { \nif ( session != null ) cleanDataWithNativeDriver ( keyspace , excludedTables ) ; \n} \n} \n"}
{"3772": "public class ReflectionUtils { \npublic static void printThreadInfo ( PrintWriter stream , String title ) { \nfinal int STACK_DEPTH = 20 ; \nboolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; \nlong [ ] threadIds = threadBean . getAllThreadIds ( ) ; \nstream . println ( \"Process Thread Dump: \" + title ) ; \nstream . println ( threadIds . length + \" active threads\" ) ; \nfor ( long tid : threadIds ) { \nThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; \nif ( info == null ) { \nstream . println ( \"  Inactive\" ) ; \ncontinue ; \n} \nstream . println ( \"Thread \" + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + \":\" ) ; \nThread . State state = info . getThreadState ( ) ; \nstream . println ( \"  State: \" + state ) ; \nstream . println ( \"  Blocked count: \" + info . getBlockedCount ( ) ) ; \nstream . println ( \"  Waited count: \" + info . getWaitedCount ( ) ) ; \nif ( contention ) { \nstream . println ( \"  Blocked time: \" + info . getBlockedTime ( ) ) ; \nstream . println ( \"  Waited time: \" + info . getWaitedTime ( ) ) ; \n} \nif ( state == Thread . State . WAITING ) stream . println ( \"  Waiting on \" + info . getLockName ( ) ) ; \nelse if ( state == Thread . State . BLOCKED ) { \nstream . println ( \"  Blocked on \" + info . getLockName ( ) ) ; \nstream . println ( \"  Blocked by \" + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; \n} \nstream . println ( \"  Stack:\" ) ; \nfor ( StackTraceElement frame : info . getStackTrace ( ) ) { \nstream . println ( \"    \" + frame . toString ( ) ) ; \n} \n} \nstream . flush ( ) ; \n} \n} \n"}
{"3773": "public class CheckSocket { \npublic static boolean remotePortTaken ( String node , int port , int timeout ) { \nSocket s = null ; \ntry { \ns = new Socket ( ) ; \ns . setReuseAddress ( true ) ; \nSocketAddress sa = new InetSocketAddress ( node , port ) ; \ns . connect ( sa , timeout * 1000 ) ; \n} \ncatch ( IOException e ) { \nif ( e . getMessage ( ) . equals ( \"Connection refused\" ) ) return false ; \nif ( e instanceof SocketTimeoutException || e instanceof UnknownHostException ) throw e ; \n} \nfinally { \nif ( s != null ) { \nif ( s . isConnected ( ) ) return true ; \nelse { \n} \ntry { \ns . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nreturn false ; \n} \n} \n} \n"}
{"3777": "public class BooleanIndexing { \npublic static boolean or ( IComplexNDArray n , Condition cond ) { \nboolean ret = false ; \nIComplexNDArray linear = n . linearView ( ) ; \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) ret = ret || cond . apply ( linear . getComplex ( i ) ) ; \nreturn ret ; \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) if ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; \nelse result [ i ] = false ; \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni ++ ) if ( arr . getDouble ( i ) > 0 ) result [ i ] = true ; \nelse result [ i ] = false ; \nreturn result ; \n} \n} \n"}
{"3781": "public class BooleanIndexing { \npublic static void applyWhere ( final INDArray to , final Condition condition , final Number number ) { \nif ( condition instanceof BaseCondition ) Nd4j . getExecutioner ( ) . exec ( new CompareAndSet ( to , number . doubleValue ( ) , condition ) ) ; \nelse { \nfinal double value = number . doubleValue ( ) ; \nfinal Function < Number , Number > dynamic = new Function < Number , Number > ( ) { \n@ Override public Number apply ( Number number ) { \nreturn value ; \n} \n} \n; \nShape . iterate ( to , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( condition . apply ( to . getDouble ( coord [ 0 ] ) ) ) to . putScalar ( coord [ 0 ] , dynamic . apply ( to . getDouble ( coord [ 0 ] ) ) . doubleValue ( ) ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) for ( int i = 1 ; \ni < arrs . length ; \ni ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \nelse { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \n} \n} \n"}
{"3801": "public class BaseNDArrayFactory { \n@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { \nassert curr . shape ( ) . length == 3 ; \nif ( in . columns ( ) != 1 ) throw new AssertionError ( \"Expected a column vector\" ) ; \nif ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) throw new AssertionError ( \"Number of rows in the input does not match number of columns in tensor\" ) ; \nif ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) throw new AssertionError ( \"Can only perform this operation on a SimpleTensor with square slices\" ) ; \nINDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; \nINDArray inT = in . transpose ( ) ; \nfor ( int i = 0 ; \ni < curr . slices ( ) ; \ni ++ ) { \nINDArray slice = curr . slice ( i ) ; \nINDArray inTTimesSlice = inT . mmul ( slice ) ; \nret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3817": "public class StringUtils { \npublic static String simpleHostname ( String fullHostname ) { \nif ( InetAddresses . isInetAddress ( fullHostname ) ) return fullHostname ; \nint offset = fullHostname . indexOf ( '.' ) ; \nif ( offset != - 1 ) return fullHostname . substring ( 0 , offset ) ; \nreturn fullHostname ; \n} \n} \n"}
{"3818": "public class StringUtils { \npublic static String arrayToString ( String [ ] strs ) { \nif ( strs . length == 0 ) return \"\" ; \nStringBuilder sbuf = new StringBuilder ( ) ; \nsbuf . append ( strs [ 0 ] ) ; \nfor ( int idx = 1 ; \nidx < strs . length ; \nidx ++ ) { \nsbuf . append ( \",\" ) ; \nsbuf . append ( strs [ idx ] ) ; \n} \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"3819": "public class StringUtils { \npublic static String byteToHexString ( byte [ ] bytes , int start , int end ) { \nif ( bytes == null ) throw new IllegalArgumentException ( \"bytes == null\" ) ; \nStringBuilder s = new StringBuilder ( ) ; \nfor ( int i = start ; \ni < end ; \ni ++ ) s . append ( format ( \"%02x\" , bytes [ i ] ) ) ; \nreturn s . toString ( ) ; \n} \n} \n"}
{"3820": "public class StringUtils { \npublic static String [ ] getStrings ( String str , String delim ) { \nCollection < String > values = getStringCollection ( str , delim ) ; \nif ( values . size ( ) == 0 ) return null ; \nreturn values . toArray ( new String [ values . size ( ) ] ) ; \n} \n} \n"}
{"3821": "public class StringUtils { \npublic static String [ ] split ( String str , char escapeChar , char separator ) { \nif ( str == null ) return null ; \nArrayList < String > strList = new ArrayList < String > ( ) ; \nStringBuilder split = new StringBuilder ( ) ; \nint index = 0 ; \nwhile ( ( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ) { \n++ index ; \nstrList . add ( split . toString ( ) ) ; \nsplit . setLength ( 0 ) ; \n} \nstrList . add ( split . toString ( ) ) ; \nint last = strList . size ( ) ; \nwhile ( -- last >= 0 && \"\" . equals ( strList . get ( last ) ) ) strList . remove ( last ) ; \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3822": "public class StringUtils { \npublic static String [ ] split ( String str , char separator ) { \nif ( str . isEmpty ( ) ) return new String [ ] { \n\"\" } \n; \nArrayList < String > strList = new ArrayList < String > ( ) ; \nint startIndex = 0 ; \nint nextIndex = 0 ; \nwhile ( ( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ) { \nstrList . add ( str . substring ( startIndex , nextIndex ) ) ; \nstartIndex = nextIndex + 1 ; \n} \nstrList . add ( str . substring ( startIndex ) ) ; \nint last = strList . size ( ) ; \nwhile ( -- last >= 0 && \"\" . equals ( strList . get ( last ) ) ) strList . remove ( last ) ; \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3823": "public class StringUtils { \npublic static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { \nint numPreEscapes = 0 ; \nfor ( int i = start ; \ni < str . length ( ) ; \ni ++ ) { \nchar curChar = str . charAt ( i ) ; \nif ( numPreEscapes == 0 && curChar == separator ) return i ; \nelse { \nsplit . append ( curChar ) ; \nnumPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3824": "public class StringUtils { \npublic static String escapeHTML ( String string ) { \nif ( string == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nboolean lastCharacterWasSpace = false ; \nchar [ ] chars = string . toCharArray ( ) ; \nfor ( char c : chars ) { \nif ( c == ' ' ) if ( lastCharacterWasSpace ) { \nlastCharacterWasSpace = false ; \nsb . append ( \"&nbsp;\" ) ; \n} \nelse { \nlastCharacterWasSpace = true ; \nsb . append ( \" \" ) ; \n} \nelse { \nlastCharacterWasSpace = false ; \nswitch ( c ) { \ncase '<' : sb . append ( \"&lt;\" ) ; \nbreak ; \ncase '>' : sb . append ( \"&gt;\" ) ; \nbreak ; \ncase '&' : sb . append ( \"&amp;\" ) ; \nbreak ; \ncase '\"' : sb . append ( \"&quot;\" ) ; \nbreak ; \ndefault : sb . append ( c ) ; \nbreak ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3825": "public class StringUtils { \npublic static String join ( CharSequence separator , Iterable < ? > strings ) { \nIterator < ? > i = strings . iterator ( ) ; \nif ( ! i . hasNext ( ) ) return \"\" ; \nStringBuilder sb = new StringBuilder ( i . next ( ) . toString ( ) ) ; \nwhile ( i . hasNext ( ) ) { \nsb . append ( separator ) ; \nsb . append ( i . next ( ) . toString ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3827": "public class StringUtils { \npublic static String replaceTokens ( String template , Pattern pattern , Map < String , String > replacements ) { \nStringBuffer sb = new StringBuffer ( ) ; \nMatcher matcher = pattern . matcher ( template ) ; \nwhile ( matcher . find ( ) ) { \nString replacement = replacements . get ( matcher . group ( 1 ) ) ; \nif ( replacement == null ) replacement = \"\" ; \nmatcher . appendReplacement ( sb , Matcher . quoteReplacement ( replacement ) ) ; \n} \nmatcher . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3829": "public class InvertMatrix { \npublic static INDArray invert ( INDArray arr , boolean inPlace ) { \nif ( ! arr . isSquare ( ) ) throw new IllegalArgumentException ( \"invalid array: must be square matrix\" ) ; \nRealMatrix rm = CheckUtil . convertToApacheMatrix ( arr ) ; \nRealMatrix rmInverse = new LUDecomposition ( rm ) . getSolver ( ) . getInverse ( ) ; \nINDArray inverse = CheckUtil . convertFromApacheMatrix ( rmInverse ) ; \nif ( inPlace ) arr . assign ( inverse ) ; \nreturn inverse ; \n} \n} \n"}
{"3840": "public class BaseDataBuffer { \n@ Override public DataBuffer reallocate ( long length ) { \nPointer oldPointer = pointer ; \nif ( isAttached ( ) ) { \nlong capacity = length * getElementSize ( ) ; \nswitch ( dataType ( ) ) { \ncase DOUBLE : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . DOUBLE , false ) . asDoublePointer ( ) ; \nindexer = DoubleIndexer . create ( ( DoublePointer ) pointer ) ; \nbreak ; \ncase FLOAT : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . FLOAT , false ) . asFloatPointer ( ) ; \nindexer = FloatIndexer . create ( ( FloatPointer ) pointer ) ; \nbreak ; \ncase INT : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . INT , false ) . asIntPointer ( ) ; \nindexer = IntIndexer . create ( ( IntPointer ) pointer ) ; \nbreak ; \n} \nworkspaceGenerationId = getParentWorkspace ( ) . getGenerationId ( ) ; \n} \nelse switch ( dataType ( ) ) { \ncase INT : pointer = new IntPointer ( length ) ; \nindexer = IntIndexer . create ( ( IntPointer ) pointer ) ; \nbreak ; \ncase DOUBLE : pointer = new DoublePointer ( length ) ; \nindexer = DoubleIndexer . create ( ( DoublePointer ) pointer ) ; \nbreak ; \ncase FLOAT : pointer = new FloatPointer ( length ) ; \nindexer = FloatIndexer . create ( ( FloatPointer ) pointer ) ; \nbreak ; \n} \nPointer . memcpy ( pointer , oldPointer , this . length ( ) * getElementSize ( ) ) ; \nreturn this ; \n} \n} \n"}
{"3841": "public class NioUtil { \npublic static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { \nByteBuffer fromView = from ; \nByteBuffer toView = to ; \nfromView . order ( ByteOrder . nativeOrder ( ) ) ; \ntoView . order ( ByteOrder . nativeOrder ( ) ) ; \nswitch ( bufferType ) { \ncase INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; \nIntBuffer toInt = toView . asIntBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nint put = fromInt . get ( fromOffset + i * fromStride ) ; \ntoInt . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; \nFloatBuffer toFloat = toView . asFloatBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nfloat put = fromFloat . get ( fromOffset + i * fromStride ) ; \ntoFloat . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; \nDoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) toDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Only floats and double supported\" ) ; \n} \n} \n} \n"}
{"3847": "public class Transforms { \npublic static INDArray max ( INDArray first , INDArray second , boolean dup ) { \nif ( dup ) first = first . dup ( ) ; \nreturn exec ( new OldMax ( second , first , first , first . length ( ) ) ) ; \n} \n} \n"}
{"3849": "public class Transforms { \npublic static INDArray min ( INDArray first , INDArray second , boolean dup ) { \nif ( dup ) first = first . dup ( ) ; \nreturn exec ( new OldMin ( second , first , first , first . length ( ) ) ) ; \n} \n} \n"}
{"3854": "public class TwoPointApproximation { \npublic static INDArray [ ] adjustSchemeToBounds ( INDArray x , INDArray h , int numSteps , INDArray lowerBound , INDArray upperBound ) { \nINDArray oneSided = Nd4j . onesLike ( h ) ; \nif ( and ( lowerBound . eq ( Double . NEGATIVE_INFINITY ) , upperBound . eq ( Double . POSITIVE_INFINITY ) ) . sumNumber ( ) . doubleValue ( ) > 0 ) return new INDArray [ ] { \nh , oneSided } \n; \nINDArray hTotal = h . mul ( numSteps ) ; \nINDArray hAdjusted = h . dup ( ) ; \nINDArray lowerDist = x . sub ( lowerBound ) ; \nINDArray upperBound2 = upperBound . sub ( x ) ; \nINDArray central = and ( greaterThanOrEqual ( lowerDist , hTotal ) , greaterThanOrEqual ( upperBound2 , hTotal ) ) ; \nINDArray forward = and ( greaterThanOrEqual ( upperBound , lowerDist ) , not ( central ) ) ; \nhAdjusted . put ( forward , min ( h . get ( forward ) , upperBound2 . get ( forward ) . mul ( 0.5 ) . divi ( numSteps ) ) ) ; \noneSided . put ( forward , Nd4j . scalar ( 1.0 ) ) ; \nINDArray backward = and ( upperBound2 . lt ( lowerBound ) , not ( central ) ) ; \nhAdjusted . put ( backward , min ( h . get ( backward ) , lowerDist . get ( backward ) . mul ( 0.5 ) . divi ( numSteps ) ) ) ; \noneSided . put ( backward , Nd4j . scalar ( 1.0 ) ) ; \nINDArray minDist = min ( upperBound2 , lowerDist ) . divi ( numSteps ) ; \nINDArray adjustedCentral = and ( not ( central ) , lessThanOrEqual ( abs ( hAdjusted ) , minDist ) ) ; \nhAdjusted . put ( adjustedCentral , minDist . get ( adjustedCentral ) ) ; \noneSided . put ( adjustedCentral , Nd4j . scalar ( 0.0 ) ) ; \nreturn new INDArray [ ] { \nhAdjusted , oneSided } \n; \n} \n} \n"}
{"3856": "public class CpuLapack { \n@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { \nINDArray tau = Nd4j . create ( N ) ; \nint status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) throw new BlasException ( \"Failed to execute sgeqrf\" , status ) ; \nif ( R != null ) { \nR . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; \nINDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; \nfor ( int i = 1 ; \ni < Math . min ( A . rows ( ) , A . columns ( ) ) ; \ni ++ ) { \nix [ 0 ] = NDArrayIndex . point ( i ) ; \nix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; \nR . put ( ix , 0 ) ; \n} \n} \nstatus = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) throw new BlasException ( \"Failed to execute sorgqr\" , status ) ; \n} \n} \n"}
{"3861": "public class JCublasNDArrayFactory { \n@ Override public INDArray createFromNpyPointer ( Pointer pointer ) { \nPointer dataPointer = nativeOps . dataPointForNumpy ( pointer ) ; \nint dataBufferElementSize = nativeOps . elementSizeForNpyArray ( pointer ) ; \nDataBuffer data = null ; \nPointer shapeBufferPointer = nativeOps . shapeBufferForNumpy ( pointer ) ; \nint length = nativeOps . lengthForShapeBufferPointer ( shapeBufferPointer ) ; \nshapeBufferPointer . capacity ( 4 * length ) ; \nshapeBufferPointer . limit ( 4 * length ) ; \nshapeBufferPointer . position ( 0 ) ; \nval intPointer = new LongPointer ( shapeBufferPointer ) ; \nDataBuffer shapeBuffer = Nd4j . createBuffer ( shapeBufferPointer , DataBuffer . Type . LONG , length , LongRawIndexer . create ( intPointer ) ) ; \ndataPointer . position ( 0 ) ; \ndataPointer . limit ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \ndataPointer . capacity ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \nif ( dataBufferElementSize == ( Float . SIZE / 8 ) ) data = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . FLOAT , Shape . length ( shapeBuffer ) , FloatIndexer . create ( new FloatPointer ( dataPointer ) ) ) ; \nelse if ( dataBufferElementSize == ( Double . SIZE / 8 ) ) data = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . DOUBLE , Shape . length ( shapeBuffer ) , DoubleIndexer . create ( new DoublePointer ( dataPointer ) ) ) ; \nINDArray ret = Nd4j . create ( data , Shape . shape ( shapeBuffer ) , Shape . strideArr ( shapeBuffer ) , Shape . offset ( shapeBuffer ) , Shape . order ( shapeBuffer ) ) ; \nreturn ret ; \n} \n} \n"}
{"3866": "public class CudaGridExecutioner { \n@ Override public Op exec ( Op op ) { \ncheckForCompression ( op ) ; \ninvokeWatchdog ( op ) ; \nif ( op instanceof Accumulation ) exec ( ( Accumulation ) op , new int [ ] { \nInteger . MAX_VALUE } \n) ; \nelse if ( op instanceof IndexAccumulation ) exec ( ( IndexAccumulation ) op , new int [ ] { \nInteger . MAX_VALUE } \n) ; \nelse if ( op instanceof ScalarOp || op instanceof TransformOp ) processAsGridOp ( op ) ; \nelse if ( op instanceof BroadcastOp ) invoke ( ( BroadcastOp ) op ) ; \nelse pushToGrid ( new OpDescriptor ( op ) ) ; \nreturn op ; \n} \n} \n"}
{"3868": "public class JarResource { \npublic InputStream getInputStream ( ) throws FileNotFoundException { \nURL url = this . getUrl ( ) ; \nif ( isJarURL ( url ) ) try { \nurl = extractActualUrl ( url ) ; \nZipFile zipFile = new ZipFile ( url . getFile ( ) ) ; \nZipEntry entry = zipFile . getEntry ( this . resourceName ) ; \nInputStream stream = zipFile . getInputStream ( entry ) ; \nreturn stream ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nelse { \nFile srcFile = this . getFile ( ) ; \nreturn new FileInputStream ( srcFile ) ; \n} \n} \n} \n"}
{"3871": "public class CudaAffinityManager { \nprotected Integer getNextDevice ( long threadId ) { \nInteger device = null ; \nif ( ! CudaEnvironment . getInstance ( ) . getConfiguration ( ) . isForcedSingleGPU ( ) && getNumberOfDevices ( ) > 0 ) synchronized ( this ) { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( devPtr . getAndIncrement ( ) ) ; \nif ( devPtr . get ( ) >= CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) devPtr . set ( 0 ) ; \nlogger . debug ( \"Mapping thread [{}] to device [{}], out of [{}] devices...\" , threadId , device , CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) ; \n} \nelse { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( 0 ) ; \nlogger . debug ( \"Single device is forced, mapping to device [{}]\" , device ) ; \n} \nreturn device ; \n} \n} \n"}
{"3873": "public class LibUtils { \npublic static ARCHType calculateArch ( ) { \nString osArch = System . getProperty ( \"os.arch\" ) ; \nosArch = osArch . toLowerCase ( Locale . ENGLISH ) ; \nif ( osArch . equals ( \"i386\" ) || osArch . equals ( \"x86\" ) || osArch . equals ( \"i686\" ) ) return ARCHType . X86 ; \nif ( osArch . startsWith ( \"amd64\" ) || osArch . startsWith ( \"x86_64\" ) ) return ARCHType . X86_64 ; \nif ( osArch . equals ( \"ppc\" ) || osArch . equals ( \"powerpc\" ) ) return ARCHType . PPC ; \nif ( osArch . startsWith ( \"ppc\" ) ) return ARCHType . PPC_64 ; \nif ( osArch . startsWith ( \"sparc\" ) ) return ARCHType . SPARC ; \nif ( osArch . startsWith ( \"arm\" ) ) return ARCHType . ARM ; \nif ( osArch . startsWith ( \"mips\" ) ) return ARCHType . MIPS ; \nif ( osArch . contains ( \"risc\" ) ) return ARCHType . RISC ; \nreturn ARCHType . UNKNOWN ; \n} \n} \n"}
{"3879": "public class DistributedAssignMessage { \n@ Override public void processMessage ( ) { \nif ( payload != null ) if ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) storage . getArray ( key ) . assign ( payload ) ; \nelse storage . setArray ( key , payload ) ; \nelse if ( index >= 0 ) { \nif ( storage . getArray ( key ) == null ) throw new RuntimeException ( \"Init wasn't called before for key [\" + key + \"]\" ) ; \nstorage . getArray ( key ) . getRow ( index ) . assign ( value ) ; \n} \nelse storage . getArray ( key ) . assign ( value ) ; \n} \n} \n"}
{"3883": "public class OpProfiler { \nprotected String getOpClass ( Op op ) { \nif ( op instanceof ScalarOp ) return \"ScalarOp\" ; \nelse if ( op instanceof MetaOp ) return \"MetaOp\" ; \nelse if ( op instanceof GridOp ) return \"GridOp\" ; \nelse if ( op instanceof BroadcastOp ) return \"BroadcastOp\" ; \nelse if ( op instanceof RandomOp ) return \"RandomOp\" ; \nelse if ( op instanceof Accumulation ) return \"AccumulationOp\" ; \nelse if ( op instanceof TransformOp ) if ( op . y ( ) == null ) return \"TransformOp\" ; \nelse return \"PairWiseTransformOp\" ; \nelse if ( op instanceof IndexAccumulation ) return \"IndexAccumulationOp\" ; \nelse if ( op instanceof CustomOp ) return \"CustomOp\" ; \nelse return \"Unknown Op calls\" ; \n} \n} \n"}
{"3884": "public class SDVariable { \npublic INDArray storeAndAllocateNewArray ( ) { \nval shape = sameDiff . getShapeForVarName ( getVarName ( ) ) ; \nif ( getArr ( ) != null && Arrays . equals ( getArr ( ) . shape ( ) , shape ) ) return getArr ( ) ; \nif ( varName == null ) throw new ND4JIllegalStateException ( \"Unable to store array for null variable name!\" ) ; \nif ( shape == null ) throw new ND4JIllegalStateException ( \"Unable to allocate new array. No shape found for variable \" + varName ) ; \nval arr = getWeightInitScheme ( ) . create ( shape ) ; \nsameDiff . putArrayForVarName ( getVarName ( ) , arr ) ; \nreturn arr ; \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; \nfor ( int i = 0 ; \ni < shape . length ; \ni ++ ) if ( shape [ i ] < 1 ) shape [ i ] = 1 ; \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( shapeMatrix . length ( ) > 1 ) return arr . get ( indexes ) ; \nelse { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nint start = ( int ) startIndex . getDouble ( 0 ) ; \nint end = ( int ) endIndex . getDouble ( 0 ) ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni ++ ) ret . putScalar ( count ++ , arr . getComplex ( i ) ) ; \nreturn ret ; \n} \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( int i = 0 ; \ni < numDevices ; \ni ++ ) if ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) set ( i , array ) ; \nelse set ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \n} \n"}
{"3895": "public class BigDecimalMath { \nstatic public BigDecimal gamma ( MathContext mc ) { \nif ( mc . getPrecision ( ) < GAMMA . precision ( ) ) return GAMMA . round ( mc ) ; \nelse { \ndouble eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; \nMathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; \nBigDecimal resul = BigDecimal . ONE ; \nresul = resul . add ( log ( 2 , mcloc ) ) ; \nresul = resul . subtract ( log ( 3 , mcloc ) ) ; \nint kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; \nmcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; \nfor ( int n = 1 ; \n; \nn ++ ) { \nBigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; \nBigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; \nfourn = fourn . shiftLeft ( 2 * n ) ; \nc = divideRound ( c , fourn ) ; \nresul = resul . subtract ( c ) ; \nif ( c . doubleValue ( ) < 0.1 * eps ) break ; \n} \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3896": "public class BigDecimalMath { \nstatic public BigDecimal sqrt ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) throw new ArithmeticException ( \"negative argument \" + x . toString ( ) + \" of square root\" ) ; \nreturn root ( 2 , x ) ; \n} \n} \n"}
{"3897": "public class BigDecimalMath { \nstatic public BigDecimal cbrt ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return root ( 3 , x . negate ( ) ) . negate ( ) ; \nelse return root ( 3 , x ) ; \n} \n} \n"}
{"3898": "public class BigDecimalMath { \nstatic public BigDecimal root ( final int n , final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) throw new ArithmeticException ( \"negative argument \" + x . toString ( ) + \" of root\" ) ; \nif ( n <= 0 ) throw new ArithmeticException ( \"negative power \" + n + \" of root\" ) ; \nif ( n == 1 ) return x ; \nBigDecimal s = new BigDecimal ( Math . pow ( x . doubleValue ( ) , 1.0 / n ) ) ; \nfinal BigDecimal nth = new BigDecimal ( n ) ; \nfinal BigDecimal xhighpr = scalePrec ( x , 2 ) ; \nMathContext mc = new MathContext ( 2 + x . precision ( ) ) ; \nfinal double eps = x . ulp ( ) . doubleValue ( ) / ( 2 * n * x . doubleValue ( ) ) ; \nfor ( ; \n; \n) { \nBigDecimal c = xhighpr . divide ( s . pow ( n - 1 ) , mc ) ; \nc = s . subtract ( c ) ; \nMathContext locmc = new MathContext ( c . precision ( ) ) ; \nc = c . divide ( nth , locmc ) ; \ns = s . subtract ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) / s . doubleValue ( ) ) < eps ) break ; \n} \nreturn s . round ( new MathContext ( err2prec ( eps ) ) ) ; \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) break ; \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub -- > 0 ) pex *= 10 ; \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3900": "public class BigDecimalMath { \nstatic public BigDecimal exp ( final MathContext mc ) { \nif ( mc . getPrecision ( ) < E . precision ( ) ) return E . round ( mc ) ; \nelse { \nBigDecimal uni = scalePrec ( BigDecimal . ONE , mc . getPrecision ( ) ) ; \nreturn exp ( uni ) ; \n} \n} \n} \n"}
{"3901": "public class BigDecimalMath { \nstatic public BigDecimal pow ( final BigDecimal x , final BigDecimal y ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) throw new ArithmeticException ( \"Cannot power negative \" + x . toString ( ) ) ; \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; \nelse { \nBigDecimal logx = log ( x ) ; \nBigDecimal ylogx = y . multiply ( logx ) ; \nBigDecimal resul = exp ( ylogx ) ; \ndouble errR = Math . abs ( logx . doubleValue ( ) * y . ulp ( ) . doubleValue ( ) / 2. ) + Math . abs ( y . doubleValue ( ) * x . ulp ( ) . doubleValue ( ) / 2. / x . doubleValue ( ) ) ; \nMathContext mcR = new MathContext ( err2prec ( 1.0 , errR ) ) ; \nreturn resul . round ( mcR ) ; \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return sin ( x . negate ( ) ) . negate ( ) ; \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( res . compareTo ( p ) > 0 ) return sin ( subtractRound ( res , p ) ) . negate ( ) ; \nelse if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) return sin ( subtractRound ( p , res ) ) ; \nelse if ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) return cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) break ; \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; \nelse if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return tan ( x . negate ( ) ) . negate ( ) ; \nelse { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( xDbl > 0.8 ) { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \nelse { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \nfor ( int i = 2 ; \n; \ni ++ ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) break ; \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return cos ( x . negate ( ) ) ; \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ONE ; \nelse if ( x . doubleValue ( ) > 1.5 ) return hypot ( 1 , sinh ( x ) ) ; \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) break ; \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return sinh ( x . negate ( ) ) . negate ( ) ; \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; \nelse if ( x . doubleValue ( ) > 2.4 ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) break ; \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3907": "public class BigDecimalMath { \nstatic public BigDecimal tanh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return tanh ( x . negate ( ) ) . negate ( ) ; \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal exp2x = exp ( xhighpr . multiply ( new BigDecimal ( - 2 ) ) ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . pow ( Math . cosh ( x . doubleValue ( ) ) , 2.0 ) ; \nMathContext mc = new MathContext ( err2prec ( Math . tanh ( x . doubleValue ( ) ) , eps ) ) ; \nreturn BigDecimal . ONE . subtract ( exp2x ) . divide ( BigDecimal . ONE . add ( exp2x ) , mc ) ; \n} \n} \n} \n"}
{"3908": "public class BigDecimalMath { \nstatic public BigDecimal asinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal logx = log ( hypot ( 1 , xhighpr ) . add ( xhighpr ) ) ; \ndouble xDbl = x . doubleValue ( ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . hypot ( 1. , xDbl ) ; \nMathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; \nreturn logx . round ( mc ) ; \n} \n} \n} \n"}
{"3909": "public class BigDecimalMath { \nstatic public BigDecimal acosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ONE ) < 0 ) throw new ArithmeticException ( \"Out of range argument cosh \" + x . toString ( ) ) ; \nelse if ( x . compareTo ( BigDecimal . ONE ) == 0 ) return BigDecimal . ZERO ; \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal logx = log ( sqrt ( xhighpr . pow ( 2 ) . subtract ( BigDecimal . ONE ) ) . add ( xhighpr ) ) ; \ndouble xDbl = x . doubleValue ( ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . sqrt ( xDbl * xDbl - 1. ) ; \nMathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; \nreturn logx . round ( mc ) ; \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \nelse if ( x . doubleValue ( ) > 1.5 ) { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( int n = 2 ; \n; \nn ++ ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( eps / 100. / c . doubleValue ( ) < 0.01 ) m = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \nelse m = new MathContext ( 2 ) ; \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) resul = resul . add ( c ) ; \nelse resul = resul . subtract ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) break ; \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( int n = 1 ; \nn < 5 ; \nn ++ ) psi += zdbl / n / ( n + zdbl ) ; \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n"}
{"3911": "public class BigDecimalMath { \nstatic protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { \ndouble x = 0.0 ; \nfor ( int k = 1 ; \nk < 10 ; \nk ++ ) x += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; \ndouble eps = prec2err ( x , mc . getPrecision ( ) ) ; \nint kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; \neps /= kmax ; \nBigDecimal res = BigDecimal . ZERO ; \nfor ( int c = 0 ; \n; \nc ++ ) { \nRational r = new Rational ( ) ; \nfor ( int k = 0 ; \nk < 8 ; \nk ++ ) { \nRational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; \nint pk1h = p * ( 2 + 8 * c + k ) / 2 ; \ntmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; \nr = r . add ( tmp ) ; \n} \nif ( Math . abs ( r . doubleValue ( ) ) < eps ) break ; \nMathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; \nres = res . add ( r . BigDecimalValue ( mcloc ) ) ; \n} \nreturn res . round ( mc ) ; \n} \n} \n"}
{"3913": "public class BigDecimalMath { \nstatic public BigDecimal scalePrec ( final BigDecimal x , final MathContext mc ) { \nfinal int diffPr = mc . getPrecision ( ) - x . precision ( ) ; \nif ( diffPr > 0 ) return scalePrec ( x , diffPr ) ; \nelse return x ; \n} \n} \n"}
{"3915": "public class SameDiff { \npublic void putFunctionForId ( String id , DifferentialFunction function ) { \nif ( functionInstancesById . containsKey ( id ) ) throw new ND4JIllegalStateException ( \"Function by id already exists!\" ) ; \nelse if ( function instanceof SDVariable ) throw new ND4JIllegalStateException ( \"Function must not be a variable!\" ) ; \nfunctionInstancesById . put ( id , function ) ; \n} \n} \n"}
{"3917": "public class SameDiff { \npublic void updateArrayForVarName ( String varName , INDArray arr ) { \nif ( ! variableNameToArr . containsKey ( varName ) ) throw new ND4JIllegalStateException ( \"Array for \" + varName + \" does not exist. Please use putArrayForVertexId instead.\" ) ; \nvariableNameToArr . put ( varName , arr ) ; \nreverseArrayLookup . put ( arr , getVariable ( varName ) ) ; \n} \n} \n"}
{"3918": "public class SameDiff { \npublic void putShapeForVarName ( String varName , long [ ] shape ) { \nif ( shape == null ) throw new ND4JIllegalStateException ( \"Shape must not be null!\" ) ; \nif ( variableNameToShape . containsKey ( varName ) ) throw new ND4JIllegalStateException ( \"Shape for \" + varName + \" already exists!\" ) ; \nfor ( int i = 0 ; \ni < shape . length ; \ni ++ ) if ( shape [ i ] < 1 ) { \naddAsPlaceHolder ( varName ) ; \nplaceHolderOriginalShapes . put ( varName , shape ) ; \nreturn ; \n} \nvariableNameToShape . put ( varName , shape ) ; \n} \n} \n"}
{"3919": "public class SameDiff { \npublic void associateArrayWithVariable ( INDArray arr , SDVariable variable ) { \nif ( variable == null ) throw new ND4JIllegalArgumentException ( \"Variable must not be null!\" ) ; \nif ( arr == null ) throw new ND4JIllegalArgumentException ( \"Array must not be null\" ) ; \nreverseArrayLookup . put ( arr , variable ) ; \nvariableNameToArr . put ( variable . getVarName ( ) , arr ) ; \nif ( ! shapeAlreadyExistsForVarName ( variable . getVarName ( ) ) ) putShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \nelse updateShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \n} \n} \n"}
{"3920": "public class SameDiff { \npublic < T > T getPropertyForFunction ( DifferentialFunction functionInstance , String propertyName ) { \nif ( ! propertiesForFunction . containsKey ( functionInstance . getOwnName ( ) ) ) return null ; \nelse { \nval map = propertiesForFunction . get ( functionInstance . getOwnName ( ) ) ; \nreturn ( T ) map . get ( propertyName ) ; \n} \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) throw new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \nif ( varNames == null ) throw new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \nfor ( int i = 0 ; \ni < varNames . length ; \ni ++ ) if ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3923": "public class SameDiff { \npublic void addArgsFor ( String [ ] variables , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nfor ( val varName : variables ) { \nif ( isPlaceHolder ( varName ) ) placeHolderFunctions . add ( function . getOwnName ( ) ) ; \n} \nincomingArgs . put ( variables , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , variables ) ; \nfor ( val variableName : variables ) { \nList < DifferentialFunction > funcs = functionsArgsFor . get ( variableName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionsArgsFor . put ( variableName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3929": "public class SameDiff { \npublic void removeArgFromFunction ( String varName , DifferentialFunction function ) { \nval args = function . args ( ) ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) if ( args [ i ] . getVarName ( ) . equals ( varName ) ) { \nval reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nincomingArgs . remove ( reverseArgs ) ; \nincomingArgsReverse . remove ( function . getOwnName ( ) ) ; \nval newArgs = new ArrayList < String > ( args . length - 1 ) ; \nfor ( int arg = 0 ; \narg < args . length ; \narg ++ ) if ( ! reverseArgs [ arg ] . equals ( varName ) ) newArgs . add ( reverseArgs [ arg ] ) ; \nval newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; \nincomingArgs . put ( newArgsArr , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; \nbreak ; \n} \n} \n} \n"}
{"3930": "public class SameDiff { \npublic void setGradientForVariableName ( String variableName , SDVariable variable ) { \nif ( variable == null ) throw new ND4JIllegalStateException ( \"Unable to set null gradient for variable name \" + variableName ) ; \ngradients . put ( variableName , variable ) ; \n} \n} \n"}
{"3935": "public class SameDiff { \npublic Pair < Map < SDVariable , DifferentialFunction > , List < DifferentialFunction > > exec ( String functionName ) { \nif ( debugMode ) return sameDiffFunctionInstances . get ( functionName ) . enableDebugMode ( ) . exec ( ) ; \nelse return sameDiffFunctionInstances . get ( functionName ) . exec ( ) ; \n} \n} \n"}
{"3937": "public class SameDiff { \npublic INDArray execBackwardAndEndResult ( ) { \nList < DifferentialFunction > backwards = execBackwards ( ) . getRight ( ) ; \nDifferentialFunction df = backwards . get ( backwards . size ( ) - 1 ) ; \nif ( df instanceof Op ) return ( ( Op ) df ) . z ( ) ; \nelse if ( df instanceof DynamicCustomOp ) return ( ( DynamicCustomOp ) df ) . getOutputArgument ( 0 ) ; \nelse return null ; \n} \n} \n"}
{"3938": "public class SameDiff { \npublic void addAsPlaceHolder ( String varName ) { \nplaceHolderVarNames . add ( varName ) ; \nif ( getVariable ( varName ) != null && getVariable ( varName ) . getShape ( ) != null ) placeHolderOriginalShapes . put ( varName , getVariable ( varName ) . getShape ( ) ) ; \n} \n} \n"}
{"3950": "public class TFGraphMapper { \npublic String getNodeName ( String name ) { \nString ret = name ; \nif ( ret . startsWith ( \"^\" ) ) ret = ret . substring ( 1 ) ; \nif ( ret . endsWith ( \"/read\" ) ) ret = ret . replace ( \"/read\" , \"\" ) ; \nreturn ret ; \n} \n} \n"}
{"3951": "public class NativeOpExecutioner { \nprivate void invoke ( ScalarOp op , int [ ] dimension ) { \ndimension = Shape . normalizeAxis ( op . x ( ) . rank ( ) , dimension ) ; \nPair < DataBuffer , DataBuffer > tadBuffers = tadManager . getTADOnlyShapeInfo ( op . x ( ) , dimension ) ; \nPointer hostTadShapeInfo = tadBuffers . getFirst ( ) . addressPointer ( ) ; \nPointer hostTadOffsets = tadBuffers . getSecond ( ) . addressPointer ( ) ; \nPointer devTadShapeInfoZ = null ; \nPointer devTadOffsetsZ = null ; \nPair < DataBuffer , DataBuffer > tadBuffersZ = tadManager . getTADOnlyShapeInfo ( op . z ( ) , dimension ) ; \ndevTadShapeInfoZ = tadBuffersZ . getFirst ( ) . addressPointer ( ) ; \ndevTadOffsetsZ = tadBuffersZ . getSecond ( ) . addressPointer ( ) ; \nif ( extraz . get ( ) == null ) extraz . set ( new PointerPointer ( 32 ) ) ; \nPointerPointer dummy = extraz . get ( ) . put ( hostTadShapeInfo , hostTadOffsets , devTadShapeInfoZ , devTadOffsetsZ ) ; \nif ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) loop . execScalarFloat ( dummy , op . opNum ( ) , ( FloatPointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( FloatPointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \nelse if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) loop . execScalarDouble ( dummy , op . opNum ( ) , ( DoublePointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( DoublePointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \n} \n"}
{"3952": "public class WorkspaceUtils { \npublic static void assertNoWorkspacesOpen ( String msg ) throws ND4JWorkspaceException { \nif ( Nd4j . getWorkspaceManager ( ) . anyWorkspaceActiveForCurrentThread ( ) ) { \nList < MemoryWorkspace > l = Nd4j . getWorkspaceManager ( ) . getAllWorkspacesForCurrentThread ( ) ; \nList < String > workspaces = new ArrayList < > ( l . size ( ) ) ; \nfor ( MemoryWorkspace ws : l ) { \nif ( ws . isScopeActive ( ) ) workspaces . add ( ws . getId ( ) ) ; \n} \nthrow new ND4JWorkspaceException ( msg + \" - Open/active workspaces: \" + workspaces ) ; \n} \n} \n} \n"}
{"3956": "public class AtomicState { \npublic void releaseToe ( ) { \nif ( getCurrentState ( ) == AccessState . TOE ) if ( 1 > 0 ) if ( toeRequests . decrementAndGet ( ) == 0 ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \ncurrentState . set ( AccessState . TACK . ordinal ( ) ) ; \n} \nelse throw new IllegalStateException ( \"releaseToe() is called from different thread.\" ) ; \nelse throw new IllegalStateException ( \"Object is NOT in Toe state!\" ) ; \n} \n} \n"}
{"3957": "public class AtomicState { \npublic AccessState getCurrentState ( ) { \nif ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) return AccessState . TOE ; \nelse if ( tickRequests . get ( ) <= tackRequests . get ( ) ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \nreturn AccessState . TACK ; \n} \nelse return AccessState . TICK ; \n} \n} \n"}
{"3963": "public class AtomicAllocator { \n@ Override public void synchronizeHostData ( DataBuffer buffer ) { \nif ( buffer . isConstant ( ) ) return ; \nif ( memoryHandler . isDeviceDependant ( ) ) { \nAllocationPoint point = getAllocationPoint ( buffer . getTrackingPoint ( ) ) ; \nif ( point == null ) throw new RuntimeException ( \"AllocationPoint is NULL\" ) ; \nmemoryHandler . synchronizeThreadDevice ( Thread . currentThread ( ) . getId ( ) , memoryHandler . getDeviceId ( ) , point ) ; \n} \n} \n} \n"}
{"3965": "public class GridFlowController { \n@ Override public void synchronizeToHost ( AllocationPoint point ) { \nif ( ! point . isConstant ( ) && point . isEnqueued ( ) ) waitTillFinished ( point ) ; \nsuper . synchronizeToHost ( point ) ; \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( int i = 0 ; \ni < index . rows ( ) ; \ni ++ ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( int j = 0 ; \nj < row . columns ( ) ; \nj ++ ) nums [ j ] = ( int ) row . getFloat ( j ) ; \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nelse if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3969": "public class DifferentialFunction { \npublic List < SDVariable > diff ( List < SDVariable > i_v1 ) { \nList < SDVariable > vals = doDiff ( i_v1 ) ; \nif ( vals == null ) throw new IllegalStateException ( \"Error executing diff operation: doDiff returned null for op: \" + this . opName ( ) ) ; \nval outputVars = args ( ) ; \nfor ( int i = 0 ; \ni < vals . size ( ) ; \ni ++ ) { \nSDVariable var = outputVars [ i ] ; \nSDVariable grad = var . getGradient ( ) ; \nif ( grad != null ) { \nSDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; \ntry { \nvals . set ( i , gradVar ) ; \n} \ncatch ( UnsupportedOperationException e ) { \nthrow new UnsupportedOperationException ( \"Use a mutable list when returning values from \" + this . getClass ( ) . getSimpleName ( ) + \".doDiff (e.g. Arrays.asList instead of Collections.singletonList)\" , e ) ; \n} \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \n} \nelse { \nSDVariable gradVar = vals . get ( i ) ; \nsameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + \"-grad\" ) ; \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \nsameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; \n} \n} \nreturn vals ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) arr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) arr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \n} \n"}
{"3978": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { \nif ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; \nIComplexNDArray linear = linearView ( ) ; \nIComplexNDArray otherLinear = arr . linearView ( ) ; \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) linear . putScalar ( i , otherLinear . getComplex ( i ) ) ; \nreturn this ; \n} \n} \n"}
{"3979": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray getRows ( int [ ] rindices ) { \nINDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; \nfor ( int i = 0 ; \ni < rindices . length ; \ni ++ ) rows . putRow ( i , getRow ( rindices [ i ] ) ) ; \nreturn ( IComplexNDArray ) rows ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( toPut instanceof IComplexNDArray ) { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni ++ ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \n} \n} \nelse for ( int i = 0 ; \ni < r . length ( ) ; \ni ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \nreturn this ; \n} \n} \n"}
{"3984": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray subi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( other . isScalar ( ) ) return subi ( cOther . getComplex ( 0 ) , result ) ; \nif ( result == this ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \nelse if ( result == other ) if ( data . dataType ( ) == ( DataBuffer . Type . DOUBLE ) ) { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asDouble ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asFloat ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nNd4j . getBlasWrapper ( ) . copy ( this , result ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \n} \nreturn cResult ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) return cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \nif ( isScalar ( ) ) return cOther . addi ( getComplex ( 0 ) , result ) ; \nif ( result == this ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \nelse if ( result == other ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \nelse { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < resultLinear . length ( ) ; \ni ++ ) resultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3987": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray ravel ( ) { \nif ( length ( ) >= Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"length() can not be >= Integer.MAX_VALUE\" ) ; \nIComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; \nIComplexNDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < length ( ) ; \ni ++ ) ret . putScalar ( i , linear . getComplex ( i ) ) ; \nreturn ret ; \n} \n} \n"}
{"3995": "public class LossFunctions { \nprivate static LossInfo doReduce ( SameDiff sd , String outputName , boolean isMean , LossInfo . Builder b , Reduction reduction , SDVariable preReduceLoss , SDVariable label , SDVariable weights , int [ ] dimensions ) { \nswitch ( reduction ) { \ncase NONE : b . loss ( preReduceLoss ) ; \nbreak ; \ncase SPECIFIED_DIMS : if ( isMean ) b . loss ( sd . mean ( outputName , preReduceLoss , dimensions ) ) ; \nelse b . loss ( sd . sum ( outputName , preReduceLoss , dimensions ) ) ; \ncase SUM : if ( isMean ) { \nSDVariable m = sd . mean ( preReduceLoss , dimensions ) ; \nb . loss ( sd . sum ( outputName , m ) ) ; \n} \nelse b . loss ( sd . sum ( outputName , preReduceLoss ) ) ; \nbreak ; \ncase MEAN_BY_WEIGHT : SDVariable weightSum = sd . sum ( weights ) ; \nif ( isMean ) { \nSDVariable m2 = sd . mean ( preReduceLoss ) ; \nb . loss ( m2 . div ( outputName , weightSum ) ) ; \n} \nelse { \nSDVariable sum = sd . sum ( preReduceLoss , dimensions ) ; \nb . loss ( sum . div ( outputName , weightSum ) ) ; \n} \nbreak ; \ncase MEAN_BY_COUNT : SDVariable nonZeroWeights = nonZeroCount ( weights , label ) ; \nSDVariable r ; \nif ( isMean ) r = sd . sum ( preReduceLoss ) ; \nelse { \nSDVariable sum = sd . sum ( preReduceLoss , dimensions ) ; \nr = sd . mean ( sum ) ; \n} \nb . loss ( r . div ( outputName , nonZeroWeights ) ) ; \nbreak ; \ndefault : throw new RuntimeException ( \"Unknown reduction: \" + reduction ) ; \n} \nreturn b . build ( ) ; \n} \n} \n"}
{"4012": "public class HybridQueryResults { \nprivate < T > Iterator < Iterator < T > > safePartition ( final Iterator < T > input , int chunkSize ) { \nif ( chunkSize > 1000 ) chunkSize = 1000 ; \nreturn Iterators . transform ( Iterators . partition ( input , chunkSize ) , IterateFunction . instance ( ) ) ; \n} \n} \n"}
{"4020": "public class GenericTypeReflector { \nstatic boolean isMissingTypeParameters ( Type type ) { \nif ( type instanceof Class ) { \nfor ( Class < ? > clazz = ( Class < ? > ) type ; \nclazz != null ; \nclazz = clazz . getEnclosingClass ( ) ) if ( clazz . getTypeParameters ( ) . length != 0 ) return true ; \nreturn false ; \n} \nelse if ( type instanceof ParameterizedType ) return false ; \nelse throw new AssertionError ( \"Unexpected type \" + type . getClass ( ) ) ; \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) return false ; \nelse if ( superType instanceof Class < ? > ) return true ; \nelse if ( mappedSubType instanceof Class < ? > ) return true ; \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \ni < superTypeArgs . length ; \ni ++ ) if ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) return false ; \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) return true ; \n} \nreturn false ; \n} \nelse if ( superType instanceof GenericArrayType ) return isArraySupertype ( superType , subType ) ; \nelse throw new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( type instanceof ParameterizedType || type instanceof Class ) { \nClass < ? > clazz ; \nif ( type instanceof ParameterizedType ) clazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \nelse { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) return new Type [ ] { \nObject . class } \n; \nType [ ] result ; \nint resultIndex ; \nif ( superClass == null ) { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nelse { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \nelse if ( type instanceof TypeVariable ) { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse if ( type instanceof WildcardType ) return ( ( WildcardType ) type ) . getUpperBounds ( ) ; \nelse if ( type instanceof CaptureType ) return ( ( CaptureType ) type ) . getUpperBounds ( ) ; \nelse if ( type instanceof GenericArrayType ) return getArrayExactDirectSuperTypes ( type ) ; \nelse if ( type == null ) throw new NullPointerException ( ) ; \nelse throw new RuntimeException ( \"not implemented type: \" + type ) ; \n} \n} \n"}
{"4023": "public class GenericTypeReflector { \npublic static Type capture ( Type type ) { \nif ( type instanceof ParameterizedType ) return capture ( ( ParameterizedType ) type ) ; \nelse return type ; \n} \n} \n"}
{"4025": "public class CreateContext { \n@ SuppressWarnings ( \"unchecked\" ) public < P > Populator < P > getPopulator ( final Class < P > clazz , final Path path ) { \nif ( clazz == null || clazz . equals ( Object . class ) ) return ( Populator < P > ) NullPopulator . INSTANCE ; \nelse { \nfinal ClassTranslator < P > classTranslator = ( ClassTranslator < P > ) this . < P , FullEntity < ? > > getTranslator ( new TypeKey < > ( clazz ) , this , path ) ; \nreturn classTranslator . getPopulator ( ) ; \n} \n} \n} \n"}
{"4032": "public class Round { \nprivate Result < Map < com . google . cloud . datastore . Key , Entity > > fetchPending ( ) { \nfinal Map < com . google . cloud . datastore . Key , Entity > combined = new HashMap < > ( ) ; \nSet < com . google . cloud . datastore . Key > fetch = new HashSet < > ( ) ; \nfor ( com . google . cloud . datastore . Key key : pending ) { \nEntity ent = stuffed . get ( key ) ; \nif ( ent == null ) fetch . add ( key ) ; \nelse combined . put ( key , ent ) ; \n} \nif ( fetch . isEmpty ( ) ) return new ResultNow < > ( combined ) ; \nelse { \nfinal Result < Map < com . google . cloud . datastore . Key , Entity > > fetched = loadEngine . fetch ( fetch ) ; \nreturn ( ) -> { \ncombined . putAll ( fetched . now ( ) ) ; \nreturn combined ; \n} \n; \n} \n} \n} \n"}
{"4039": "public class Path { \npublic String toPathString ( ) { \nif ( this == ROOT ) return \"\" ; \nelse { \nStringBuilder builder = new StringBuilder ( ) ; \ntoPathString ( builder ) ; \nreturn builder . toString ( ) ; \n} \n} \n} \n"}
{"4047": "public class KeyMetadata { \n@ SuppressWarnings ( \"unchecked\" ) public < K extends IncompleteKey > void setKey ( final FullEntity . Builder < K > container , final P pojo ) { \nfinal IncompleteKey rawKey = getIncompleteKey ( pojo ) ; \nif ( ! ( rawKey instanceof com . google . cloud . datastore . Key ) ) Preconditions . checkState ( isIdNumeric ( ) , \"Cannot save an entity with a null String @Id: %s\" , pojo ) ; \ncontainer . setKey ( ( K ) rawKey ) ; \n} \n} \n"}
{"4051": "public class TypeFactory { \nprivate static boolean couldHaveCommonSubtype ( Type type1 , Type type2 ) { \nClass < ? > erased1 = GenericTypeReflector . erase ( type1 ) ; \nClass < ? > erased2 = GenericTypeReflector . erase ( type2 ) ; \nif ( ! erased1 . isInterface ( ) && ! erased2 . isInterface ( ) ) if ( ! erased1 . isAssignableFrom ( erased2 ) && ! erased2 . isAssignableFrom ( erased1 ) ) return false ; \nreturn true ; \n} \n} \n"}
{"4052": "public class TypeFactory { \nprivate static Type transformOwner ( Type givenOwner , Class < ? > clazz ) { \nif ( givenOwner == null ) return clazz . getDeclaringClass ( ) ; \nelse { \nType transformedOwner = GenericTypeReflector . getExactSuperType ( givenOwner , clazz . getDeclaringClass ( ) ) ; \nif ( transformedOwner == null ) throw new IllegalArgumentException ( \"Given owner type [\" + givenOwner + \"] is not appropriate for [\" + clazz + \"]: it should be a subtype of \" + clazz . getDeclaringClass ( ) ) ; \nif ( Modifier . isStatic ( clazz . getModifiers ( ) ) ) return GenericTypeReflector . erase ( transformedOwner ) ; \nelse return transformedOwner ; \n} \n} \n} \n"}
{"4053": "public class TypeKey { \npublic < A extends Annotation > A getAnnotationAnywhere ( Class < A > annotationType ) { \nA anno = getAnnotation ( annotationType ) ; \nif ( anno == null ) { \nClass < ? > clazz = ( Class < ? > ) GenericTypeReflector . erase ( type ) ; \nreturn clazz . getAnnotation ( annotationType ) ; \n} \nelse return anno ; \n} \n} \n"}
{"4055": "public class LoadEngine { \npublic < T > Result < T > load ( final Key < T > key ) { \nif ( key == null ) throw new NullPointerException ( \"You tried to load a null key!\" ) ; \nfinal Result < T > result = round . get ( key ) ; \nif ( ofy . getTransaction ( ) != null ) ( ( PrivateAsyncTransaction ) ofy . getTransaction ( ) ) . enlist ( result ) ; \nif ( key . getParent ( ) != null ) { \nfinal KeyMetadata < ? > meta = ofy . factory ( ) . keys ( ) . getMetadata ( key ) ; \nif ( meta != null ) if ( meta . shouldLoadParent ( loadArrangement ) ) load ( key . getParent ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4062": "public class Keys { \n@ SuppressWarnings ( \"unchecked\" ) public static < S > Value < S > getIdValue ( final IncompleteKey key ) { \nif ( key instanceof com . google . cloud . datastore . Key ) { \nfinal com . google . cloud . datastore . Key completeKey = ( com . google . cloud . datastore . Key ) key ; \nif ( completeKey . hasId ( ) ) return ( Value < S > ) LongValue . of ( completeKey . getId ( ) ) ; \nelse return ( Value < S > ) StringValue . of ( completeKey . getName ( ) ) ; \n} \nelse return null ; \n} \n} \n"}
{"4063": "public class Keys { \n@ SneakyThrows public static com . google . cloud . datastore . Key fromUrlSafe ( final String urlSafeKey ) { \nif ( urlSafeKey . startsWith ( \"a\" ) ) return KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey ) ; \nelse return com . google . cloud . datastore . Key . fromUrlSafe ( urlSafeKey ) ; \n} \n} \n"}
{"4066": "public class TransactorNo { \nprivate < R > R transactOnce ( final ObjectifyImpl parent , final Work < R > work ) { \nfinal ObjectifyImpl txnOfy = factory . open ( parent . getOptions ( ) , next -> new TransactorYes ( next , this ) ) ; \nboolean committedSuccessfully = false ; \ntry { \nfinal R result = work . run ( ) ; \ntxnOfy . flush ( ) ; \ntxnOfy . getTransaction ( ) . commit ( ) ; \ncommittedSuccessfully = true ; \nreturn result ; \n} \nfinally { \nif ( txnOfy . getTransaction ( ) . isActive ( ) ) try { \ntxnOfy . getTransaction ( ) . rollback ( ) ; \n} \ncatch ( RuntimeException ex ) { \nlog . error ( \"Rollback failed, suppressing error\" , ex ) ; \n} \ntxnOfy . close ( ) ; \nif ( committedSuccessfully ) ( ( PrivateAsyncTransaction ) txnOfy . getTransaction ( ) ) . runCommitListeners ( ) ; \n} \n} \n} \n"}
{"4092": "public class AbstractOpenRtbJsonWriter { \n@ SuppressWarnings ( \"unchecked\" ) protected final < EM extends ExtendableMessage < EM > > void writeExtensions ( EM msg , JsonGenerator gen ) throws IOException { \nboolean openExt = false ; \nfor ( Map . Entry < FieldDescriptor , Object > field : msg . getAllFields ( ) . entrySet ( ) ) { \nFieldDescriptor fd = field . getKey ( ) ; \nif ( fd . isExtension ( ) ) if ( fd . isRepeated ( ) ) { \nList < Object > extValue = ( List < Object > ) field . getValue ( ) ; \nif ( ! extValue . isEmpty ( ) ) { \nOpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . get ( 0 ) . getClass ( ) , fd . getName ( ) ) ; \nif ( extWriter != null ) { \nopenExt = openExt ( gen , openExt ) ; \nextWriter . writeRepeated ( extValue , gen ) ; \n} \n} \n} \nelse { \nObject extValue = field . getValue ( ) ; \nOpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . getClass ( ) , fd . getName ( ) ) ; \nif ( extWriter != null ) { \nopenExt = openExt ( gen , openExt ) ; \nextWriter . writeSingle ( extValue , gen ) ; \n} \n} \n} \nif ( openExt ) gen . writeEndObject ( ) ; \n} \n} \n"}
{"4093": "public class AbstractOpenRtbJsonWriter { \nprotected final boolean writeContentCategory ( String cat , JsonGenerator gen ) throws IOException { \nif ( ! factory . isStrict ( ) || OpenRtbUtils . categoryFromName ( cat ) != null ) { \ngen . writeString ( cat ) ; \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"4097": "public class OpenRtbUtils { \n@ Nullable public static Bid . Builder bidWithId ( BidResponse . Builder response , String id ) { \ncheckNotNull ( id ) ; \nfor ( SeatBid . Builder seatbid : response . getSeatbidBuilderList ( ) ) { \nfor ( Bid . Builder bid : seatbid . getBidBuilderList ( ) ) { \nif ( id . equals ( bid . getId ( ) ) ) return bid ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) return imps ; \nelse if ( impFilter == IMP_NONE ) return ImmutableList . of ( ) ; \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \nfor ( i = 1 ; \ni < size ; \n++ i ) if ( impFilter . test ( imps . get ( i ) ) != included ) break ; \nif ( i == size ) return included ? imps : ImmutableList . < Imp > of ( ) ; \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) return imp ; \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4101": "public class AbstractOpenRtbJsonReader { \nprotected final < EB extends ExtendableBuilder < ? , EB > > void readExtensions ( EB msg , JsonParser par ) throws IOException { \n@ SuppressWarnings ( \"unchecked\" ) Set < OpenRtbJsonExtReader < EB > > extReaders = factory . getReaders ( ( Class < EB > ) msg . getClass ( ) ) ; \nif ( extReaders . isEmpty ( ) ) { \npar . skipChildren ( ) ; \nreturn ; \n} \nstartObject ( par ) ; \nJsonToken tokLast = par . getCurrentToken ( ) ; \nJsonLocation locLast = par . getCurrentLocation ( ) ; \nwhile ( true ) { \nboolean extRead = false ; \nfor ( OpenRtbJsonExtReader < EB > extReader : extReaders ) { \nif ( extReader . filter ( par ) ) { \nextReader . read ( msg , par ) ; \nJsonToken tokNew = par . getCurrentToken ( ) ; \nJsonLocation locNew = par . getCurrentLocation ( ) ; \nboolean advanced = tokNew != tokLast || ! locNew . equals ( locLast ) ; \nextRead |= advanced ; \nif ( ! endObject ( par ) ) return ; \nelse if ( advanced && par . getCurrentToken ( ) != JsonToken . FIELD_NAME ) { \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \nelse { \ntokLast = tokNew ; \nlocLast = locNew ; \n} \n} \n} \nif ( ! endObject ( par ) ) return ; \nif ( ! extRead ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Extension field not consumed by any reader, skipping: {} @{}:{}\" , par . getCurrentName ( ) , locLast . getLineNr ( ) , locLast . getCharOffset ( ) ) ; \npar . nextToken ( ) ; \npar . skipChildren ( ) ; \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \n} \n} \n} \n"}
{"4102": "public class AbstractOpenRtbJsonReader { \nprotected final boolean emptyToNull ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null ) token = par . nextToken ( ) ; \nreturn ! factory ( ) . isStrict ( ) && token == null ; \n} \n} \n"}
{"4104": "public class OpenRtbJsonFactory { \npublic final < T > OpenRtbJsonFactory register ( OpenRtbJsonExtWriter < T > extWriter , Class < T > extKlass , Class < ? extends Message > msgKlass , String fieldName ) { \nMap < String , Map < String , OpenRtbJsonExtWriter < ? > > > mapMsg = extWriters . get ( msgKlass . getName ( ) ) ; \nif ( mapMsg == null ) extWriters . put ( msgKlass . getName ( ) , mapMsg = new LinkedHashMap < > ( ) ) ; \nMap < String , OpenRtbJsonExtWriter < ? > > mapKlass = mapMsg . get ( extKlass . getName ( ) ) ; \nif ( mapKlass == null ) mapMsg . put ( extKlass . getName ( ) , mapKlass = new LinkedHashMap < > ( ) ) ; \nmapKlass . put ( fieldName == null ? FIELDNAME_ALL : fieldName , extWriter ) ; \nreturn this ; \n} \n} \n"}
{"4106": "public class OpenRtbSnippetProcessor { \nprotected void processFields ( SnippetProcessorContext bidCtx ) { \nBid . Builder bid = bidCtx . getBid ( ) ; \nif ( extendedFields ) { \nif ( bid . hasAdid ( ) ) bid . setAdid ( process ( bidCtx , bid . getAdid ( ) ) ) ; \nbid . setId ( process ( bidCtx , bid . getId ( ) ) ) ; \n} \nif ( bid . hasAdm ( ) ) bid . setAdm ( process ( bidCtx , bid . getAdm ( ) ) ) ; \nif ( extendedFields ) { \nif ( bid . hasBurl ( ) ) bid . setBurl ( process ( bidCtx , bid . getBurl ( ) ) ) ; \nif ( bid . hasCid ( ) ) bid . setCid ( process ( bidCtx , bid . getCid ( ) ) ) ; \nif ( bid . hasCrid ( ) ) bid . setCrid ( process ( bidCtx , bid . getCrid ( ) ) ) ; \nif ( bid . hasDealid ( ) ) bid . setDealid ( process ( bidCtx , bid . getDealid ( ) ) ) ; \nbid . setImpid ( process ( bidCtx , bid . getImpid ( ) ) ) ; \nif ( bid . hasIurl ( ) ) bid . setIurl ( process ( bidCtx , bid . getIurl ( ) ) ) ; \nif ( bid . hasLurl ( ) ) bid . setIurl ( process ( bidCtx , bid . getLurl ( ) ) ) ; \nif ( bid . hasNurl ( ) ) bid . setNurl ( process ( bidCtx , bid . getNurl ( ) ) ) ; \n} \n} \n} \n"}
{"4108": "public class ProtoUtils { \npublic static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { \ncheckNotNull ( filter ) ; \nfor ( int i = 0 ; \ni < objs . size ( ) ; \n++ i ) if ( ! filter . test ( objs . get ( i ) ) ) return filterFrom ( objs , filter , i ) ; \nreturn objs ; \n} \n} \n"}
{"4110": "public class OpenRtbJsonUtils { \npublic static void startObject ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) token = par . nextToken ( ) ; \nif ( token == JsonToken . START_OBJECT ) par . nextToken ( ) ; \nelse throw new JsonParseException ( par , \"Expected start of object\" ) ; \n} \n} \n"}
{"4111": "public class OpenRtbJsonUtils { \npublic static void startArray ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) token = par . nextToken ( ) ; \nif ( token == JsonToken . START_ARRAY ) par . nextToken ( ) ; \nelse throw new JsonParseException ( par , \"Expected start of array\" ) ; \n} \n} \n"}
{"4112": "public class OpenRtbJsonUtils { \npublic static JsonToken peekToken ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) token = par . nextToken ( ) ; \nreturn token ; \n} \n} \n"}
{"4118": "public class URLUtil { \npublic static URL resolveURL ( URL base , String target ) throws MalformedURLException { \ntarget = target . trim ( ) ; \nif ( target . startsWith ( \"?\" ) ) return fixPureQueryTargets ( base , target ) ; \nreturn new URL ( base , target ) ; \n} \n} \n"}
{"4119": "public class URLUtil { \nstatic URL fixPureQueryTargets ( URL base , String target ) throws MalformedURLException { \nif ( ! target . startsWith ( \"?\" ) ) return new URL ( base , target ) ; \nString basePath = base . getPath ( ) ; \nString baseRightMost = \"\" ; \nint baseRightMostIdx = basePath . lastIndexOf ( \"/\" ) ; \nif ( baseRightMostIdx != - 1 ) baseRightMost = basePath . substring ( baseRightMostIdx + 1 ) ; \nif ( target . startsWith ( \"?\" ) ) target = baseRightMost + target ; \nreturn new URL ( base , target ) ; \n} \n} \n"}
{"4123": "public class ConfUtils { \npublic static List < String > loadListFromConf ( String paramKey , Map stormConf ) { \nObject obj = stormConf . get ( paramKey ) ; \nList < String > list = new LinkedList < > ( ) ; \nif ( obj == null ) return list ; \nif ( obj instanceof PersistentVector ) list . addAll ( ( PersistentVector ) obj ) ; \nelse list . add ( obj . toString ( ) ) ; \nreturn list ; \n} \n} \n"}
{"4124": "public class ConfUtils { \npublic static Map extractConfigElement ( Map conf ) { \nif ( conf . size ( ) == 1 ) { \nObject confNode = conf . get ( \"config\" ) ; \nif ( confNode != null && confNode instanceof Map ) conf = ( Map ) confNode ; \n} \nreturn conf ; \n} \n} \n"}
{"4127": "public class RefreshTag { \npublic static String extractRefreshURL ( String value ) { \nif ( StringUtils . isBlank ( value ) ) return null ; \ntry { \nif ( matcher . reset ( value ) . matches ( ) ) return matcher . group ( 1 ) ; \n} \ncatch ( Exception e ) { \n} \nreturn null ; \n} \n} \n"}
{"4128": "public class MetadataTransfer { \npublic Metadata getMetaForOutlink ( String targetURL , String sourceURL , Metadata parentMD ) { \nMetadata md = _filter ( parentMD , mdToTransfer ) ; \nif ( trackPath ) md . addValue ( urlPathKeyName , sourceURL ) ; \nif ( trackDepth ) { \nString existingDepth = md . getFirstValue ( depthKeyName ) ; \nint depth ; \ntry { \ndepth = Integer . parseInt ( existingDepth ) ; \n} \ncatch ( Exception e ) { \ndepth = 0 ; \n} \nmd . setValue ( depthKeyName , Integer . toString ( ++ depth ) ) ; \n} \nreturn md ; \n} \n} \n"}
{"4132": "public class CharsetIdentification { \nprivate static String getCharsetFromBOM ( final byte [ ] byteData ) { \nBOMInputStream bomIn = new BOMInputStream ( new ByteArrayInputStream ( byteData ) ) ; \ntry { \nByteOrderMark bom = bomIn . getBOM ( ) ; \nif ( bom != null ) return bom . getCharsetName ( ) ; \n} \ncatch ( IOException e ) { \nreturn null ; \n} \nreturn null ; \n} \n} \n"}
{"4133": "public class CharsetIdentification { \nprivate static String getCharsetFromText ( byte [ ] content , String declaredCharset , int maxLengthCharsetDetection ) { \nString charset = null ; \nCharsetDetector charsetDetector = new CharsetDetector ( ) ; \ncharsetDetector . enableInputFilter ( true ) ; \nif ( declaredCharset != null ) charsetDetector . setDeclaredEncoding ( declaredCharset ) ; \nbyte [ ] subContent = content ; \nif ( maxLengthCharsetDetection != - 1 && content . length > maxLengthCharsetDetection ) subContent = Arrays . copyOfRange ( content , 0 , maxLengthCharsetDetection ) ; \ncharsetDetector . setText ( subContent ) ; \ntry { \nCharsetMatch charsetMatch = charsetDetector . detect ( ) ; \ncharset = validateCharset ( charsetMatch . getName ( ) ) ; \n} \ncatch ( Exception e ) { \ncharset = null ; \n} \nreturn charset ; \n} \n} \n"}
{"4134": "public class CharsetIdentification { \nprivate static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { \nint len = buffer . length ; \nif ( maxlength > 0 && maxlength < len ) len = maxlength ; \nString html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; \nDocument doc = Parser . htmlParser ( ) . parseInput ( html , \"dummy\" ) ; \nElements metaElements = doc . select ( \"meta[http-equiv=content-type], meta[charset]\" ) ; \nString foundCharset = null ; \nfor ( Element meta : metaElements ) { \nif ( meta . hasAttr ( \"http-equiv\" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( \"content\" ) ) ; \nif ( foundCharset == null && meta . hasAttr ( \"charset\" ) ) foundCharset = meta . attr ( \"charset\" ) ; \nif ( foundCharset != null ) return foundCharset ; \n} \nreturn foundCharset ; \n} \n} \n"}
{"4135": "public class SiteMapParserBolt { \nprivate final boolean sniff ( byte [ ] content ) { \nbyte [ ] beginning = content ; \nif ( content . length > maxOffsetGuess && maxOffsetGuess > 0 ) beginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; \nint position = Bytes . indexOf ( beginning , clue ) ; \nif ( position != - 1 ) return true ; \nreturn false ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nint equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \nfor ( int i = 1 ; \ni < tokens . length ; \ni ++ ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) secure = true ; \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) path = ti . substring ( 5 ) ; \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) domain = ti . substring ( 7 ) ; \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) expires = ti . substring ( 8 ) ; \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) continue ; \n} \nif ( expires != null ) try { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) continue ; \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4139": "public class CookieConverter { \npublic static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { \ntry { \nif ( cookieDomain . startsWith ( \".\" ) ) cookieDomain = cookieDomain . substring ( 1 ) ; \nString [ ] domainTokens = cookieDomain . split ( \"\\\\.\" ) ; \nString [ ] hostTokens = urlHostName . split ( \"\\\\.\" ) ; \nint tokenDif = hostTokens . length - domainTokens . length ; \nif ( tokenDif < 0 ) return false ; \nfor ( int i = domainTokens . length - 1 ; \ni >= 0 ; \ni -- ) if ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) return false ; \nreturn true ; \n} \ncatch ( Exception e ) { \nreturn true ; \n} \n} \n} \n"}
{"4140": "public class HttpRobotRulesParser { \nprotected static String getCacheKey ( URL url ) { \nString protocol = url . getProtocol ( ) . toLowerCase ( Locale . ROOT ) ; \nString host = url . getHost ( ) . toLowerCase ( Locale . ROOT ) ; \nint port = url . getPort ( ) ; \nif ( port == - 1 ) port = url . getDefaultPort ( ) ; \nreturn protocol + \":\" + host + \":\" + port ; \n} \n} \n"}
{"4141": "public class HttpRobotRulesParser { \npublic BaseRobotRules getRobotRulesSetFromCache ( URL url ) { \nString cacheKey = getCacheKey ( url ) ; \nBaseRobotRules robotRules = CACHE . getIfPresent ( cacheKey ) ; \nif ( robotRules != null ) return robotRules ; \nreturn EMPTY_RULES ; \n} \n} \n"}
{"4143": "public class AbstractStatusUpdaterBolt { \nprotected final void ack ( Tuple t , String url ) { \nif ( useCache ) cache . put ( url , \"\" ) ; \n_collector . ack ( t ) ; \n} \n} \n"}
{"4144": "public class Rules { \npublic boolean filter ( String url , Metadata metadata ) throws MalformedURLException { \nURL u = new URL ( url ) ; \nString hostname = u . getHost ( ) ; \nif ( checkScope ( hostNameRules . get ( hostname ) , u ) ) return true ; \nString [ ] domainParts = hostname . split ( \"\\\\.\" ) ; \nString domain = null ; \nfor ( int i = domainParts . length - 1 ; \ni >= 0 ; \ni -- ) { \ndomain = domainParts [ i ] + ( domain == null ? \"\" : \".\" + domain ) ; \nif ( checkScope ( domainRules . get ( domain ) , u ) ) return true ; \n} \nfor ( MDScope scope : metadataRules ) { \nString [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; \nif ( vals == null ) continue ; \nfor ( String v : vals ) { \nif ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { \nFastURLFilter . LOG . debug ( \"Filtering {} matching metadata {}:{}\" , url , scope . getKey ( ) , scope . getValue ( ) ) ; \nif ( checkScope ( scope , u ) ) return true ; \n} \n} \n} \nif ( checkScope ( globalRules , u ) ) return true ; \nreturn false ; \n} \n} \n"}
{"4145": "public class RegexURLNormalizer { \n@ Override public String filter ( URL sourceUrl , Metadata sourceMetadata , String urlString ) { \nIterator < Rule > i = rules . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nRule r = i . next ( ) ; \nMatcher matcher = r . pattern . matcher ( urlString ) ; \nurlString = matcher . replaceAll ( r . substitution ) ; \n} \nif ( urlString . equals ( \"\" ) ) urlString = null ; \nreturn urlString ; \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nint semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( query == null ) query = params ; \nelse query += \"&\" + params ; \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) newPath . append ( \"/\" ) . append ( p ) ; \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) return urlToFilter ; \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nwhile ( pairsIterator . hasNext ( ) ) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( queryElementsToRemove . contains ( param . getName ( ) ) ) pairsIterator . remove ( ) ; \nelse if ( removeHashes && param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) pairsIterator . remove ( ) ; \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) newFile . append ( path ) ; \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) newFile . append ( '#' ) . append ( url . getRef ( ) ) ; \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4148": "public class NavigationFilters { \n@ SuppressWarnings ( \"rawtypes\" ) public static NavigationFilters fromConf ( Map stormConf ) { \nString configfile = ConfUtils . getString ( stormConf , \"navigationfilters.config.file\" ) ; \nif ( StringUtils . isNotBlank ( configfile ) ) try { \nreturn new NavigationFilters ( stormConf , configfile ) ; \n} \ncatch ( IOException e ) { \nString message = \"Exception caught while loading the NavigationFilters from \" + configfile ; \nLOG . error ( message ) ; \nthrow new RuntimeException ( message , e ) ; \n} \nreturn NavigationFilters . emptyNavigationFilters ; \n} \n} \n"}
{"4149": "public class GzipHdfsBolt { \npublic GzipHdfsBolt addRecordFormat ( RecordFormat format , int position ) { \nMultipleRecordFormat formats ; \nif ( this . format == null ) { \nformats = new MultipleRecordFormat ( format ) ; \nthis . format = formats ; \n} \nelse { \nif ( this . format instanceof MultipleRecordFormat ) formats = ( MultipleRecordFormat ) this . format ; \nelse { \nformats = new MultipleRecordFormat ( this . format ) ; \nthis . format = formats ; \n} \nformats . addFormat ( new GzippedRecordFormat ( format ) , position ) ; \n} \nreturn this ; \n} \n} \n"}
{"4150": "public class AbstractQueryingSpout { \nprivate long throttleQueries ( ) { \nif ( timeLastQuerySent != 0 ) { \nlong difference = System . currentTimeMillis ( ) - timeLastQuerySent ; \nif ( difference < minDelayBetweenQueries ) return minDelayBetweenQueries - difference ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4151": "public class AbstractQueryingSpout { \nprivate boolean triggerQueries ( ) { \nif ( timeLastQueryReceived != 0 && maxDelayBetweenQueries > 0 ) { \nlong difference = System . currentTimeMillis ( ) - timeLastQueryReceived ; \nif ( difference > maxDelayBetweenQueries ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"4152": "public class ParseFilters { \n@ SuppressWarnings ( \"rawtypes\" ) public static ParseFilters fromConf ( Map stormConf ) { \nString parseconfigfile = ConfUtils . getString ( stormConf , \"parsefilters.config.file\" ) ; \nif ( StringUtils . isNotBlank ( parseconfigfile ) ) try { \nreturn new ParseFilters ( stormConf , parseconfigfile ) ; \n} \ncatch ( IOException e ) { \nString message = \"Exception caught while loading the ParseFilters from \" + parseconfigfile ; \nLOG . error ( message ) ; \nthrow new RuntimeException ( message , e ) ; \n} \nreturn ParseFilters . emptyParseFilter ; \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( null != currentNode ) currentNode . appendChild ( newNode ) ; \nelse if ( null != m_docFrag ) m_docFrag . appendChild ( newNode ) ; \nelse { \nboolean ok = true ; \nshort type = newNode . getNodeType ( ) ; \nif ( type == Node . TEXT_NODE ) { \nString data = newNode . getNodeValue ( ) ; \nif ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) throw new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \nok = false ; \n} \nelse if ( type == Node . ELEMENT_NODE ) if ( m_doc . getDocumentElement ( ) != null ) throw new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \nif ( ok ) m_doc . appendChild ( newNode ) ; \n} \n} \n} \n"}
{"4154": "public class DOMBuilder { \n@ Override public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { \nif ( isOutsideDocElem ( ) ) return ; \nString s = new String ( ch , start , length ) ; \nappend ( m_doc . createTextNode ( s ) ) ; \n} \n} \n"}
{"4156": "public class DOMBuilder { \n@ Override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { \nif ( ch == null || start < 0 || length >= ( ch . length - start ) || length < 0 ) return ; \nappend ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; \n} \n} \n"}
{"4157": "public class DOMBuilder { \npublic void cdata ( char ch [ ] , int start , int length ) { \nif ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; \nString s = new String ( ch , start , length ) ; \nNode n = m_currentNode . getLastChild ( ) ; \nif ( n instanceof CDATASection ) ( ( CDATASection ) n ) . appendData ( s ) ; \nelse if ( n instanceof Comment ) ( ( Comment ) n ) . appendData ( s ) ; \n} \n} \n"}
{"4160": "public class AbstractIndexerBolt { \nprotected String valueForURL ( Tuple tuple ) { \nString url = tuple . getStringByField ( \"url\" ) ; \nMetadata metadata = ( Metadata ) tuple . getValueByField ( \"metadata\" ) ; \nif ( StringUtils . isBlank ( canonicalMetadataParamName ) ) return url ; \nString canonicalValue = metadata . getFirstValue ( canonicalMetadataName ) ; \nif ( StringUtils . isBlank ( canonicalValue ) ) return url ; \ntry { \nURL sURL = new URL ( url ) ; \nURL canonical = URLUtil . resolveURL ( sURL , canonicalValue ) ; \nString sDomain = PaidLevelDomain . getPLD ( sURL . getHost ( ) ) ; \nString canonicalDomain = PaidLevelDomain . getPLD ( canonical . getHost ( ) ) ; \nif ( sDomain . equalsIgnoreCase ( canonicalDomain ) ) return canonical . toExternalForm ( ) ; \nelse LOG . info ( \"Canonical URL references a different domain, ignoring in {} \" , url ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . error ( \"Malformed canonical URL {} was found in {} \" , canonicalValue , url ) ; \n} \nreturn url ; \n} \n} \n"}
{"4162": "public class DefaultScheduler { \nprotected final Optional < Integer > checkCustomInterval ( Metadata metadata , Status s ) { \nif ( customIntervals == null ) return Optional . empty ( ) ; \nfor ( CustomInterval customInterval : customIntervals ) { \nString [ ] values = metadata . getValues ( customInterval . key ) ; \nif ( values == null ) continue ; \nfor ( String v : values ) { \nif ( v . equals ( customInterval . value ) ) return customInterval . getDurationForStatus ( s ) ; \n} \n} \nreturn Optional . empty ( ) ; \n} \n} \n"}
{"4163": "public class URLFilters { \npublic static URLFilters fromConf ( Map stormConf ) { \nString configFile = ConfUtils . getString ( stormConf , \"urlfilters.config.file\" ) ; \nif ( StringUtils . isNotBlank ( configFile ) ) try { \nreturn new URLFilters ( stormConf , configFile ) ; \n} \ncatch ( IOException e ) { \nString message = \"Exception caught while loading the URLFilters from \" + configFile ; \nLOG . error ( message ) ; \nthrow new RuntimeException ( message , e ) ; \n} \nreturn URLFilters . emptyURLFilters ; \n} \n} \n"}
{"4164": "public class WheelView { \npublic void setWheelItemCount ( int count ) { \nmItemCount = count ; \nmItemAngle = calculateItemAngle ( count ) ; \nif ( mWheelBounds != null ) invalidate ( ) ; \n} \n} \n"}
{"4165": "public class WheelView { \npublic static int resolveSizeAndState ( int size , int measureSpec ) { \nint result = size ; \nint specMode = MeasureSpec . getMode ( measureSpec ) ; \nint specSize = MeasureSpec . getSize ( measureSpec ) ; \nswitch ( specMode ) { \ncase MeasureSpec . UNSPECIFIED : result = size ; \nbreak ; \ncase MeasureSpec . AT_MOST : if ( specSize < size ) result = specSize ; \nelse result = size ; \nbreak ; \ncase MeasureSpec . EXACTLY : result = specSize ; \nbreak ; \n} \nreturn result ; \n} \n} \n"}
{"4166": "public class WheelView { \npublic void setEmptyItemDrawable ( Drawable drawable ) { \nmEmptyItemDrawable = drawable ; \nEMPTY_CACHE_ITEM . mDrawable = drawable ; \nif ( mWheelBounds != null ) invalidate ( ) ; \n} \n} \n"}
{"4167": "public class WheelView { \npublic void setAngle ( float angle ) { \nmAngle = angle ; \nupdateSelectedPosition ( ) ; \nif ( mOnAngleChangeListener != null ) mOnAngleChangeListener . onWheelAngleChange ( mAngle ) ; \ninvalidate ( ) ; \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( vel > 0f ) { \nmAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity < 0f ) mAngularVelocity = 0f ; \n} \nelse if ( vel < 0f ) { \nmAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity > 0f ) mAngularVelocity = 0f ; \n} \nif ( mAngularVelocity != 0f ) addAngle ( mAngularVelocity * deltaTime ) ; \nelse mRequiresUpdate = false ; \n} \n} \n"}
{"4173": "public class Circle { \nstatic int clamp ( int value , int upperLimit ) { \nif ( value < 0 ) return value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; \nelse return value % upperLimit ; \n} \n} \n"}
{"4177": "public class ArrayChar { \npublic ArrayObject make1DStringArray ( ) { \nint nelems = ( getRank ( ) == 0 ) ? 1 : ( int ) getSize ( ) / indexCalc . getShape ( getRank ( ) - 1 ) ; \nArray sarr = Array . factory ( DataType . STRING , new int [ ] { \nnelems } \n) ; \nIndexIterator newsiter = sarr . getIndexIterator ( ) ; \nArrayChar . StringIterator siter = getStringIterator ( ) ; \nwhile ( siter . hasNext ( ) ) newsiter . setObjectNext ( siter . next ( ) ) ; \nreturn ( ArrayObject ) sarr ; \n} \n} \n"}
{"4181": "public class CfsrLocalTables { \n@ Override public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { \nGrib2Pds pds = gr . getPDS ( ) ; \nif ( ! pds . isTimeInterval ( ) ) return null ; \nint statType = pds . getOctet ( 47 ) ; \nint n = pds . getInt4StartingAtOctet ( 50 ) ; \nint p2 = pds . getInt4StartingAtOctet ( 55 ) ; \nint p2mp1 = pds . getInt4StartingAtOctet ( 62 ) ; \nint p1 = p2 - p2mp1 ; \nint start , end ; \nswitch ( statType ) { \ncase 193 : start = p1 ; \nend = p1 + n * p2 ; \nbreak ; \ncase 194 : start = 0 ; \nend = n * p2 ; \nbreak ; \ncase 195 : case 204 : case 205 : start = p1 ; \nend = p2 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"unknown statType \" + statType ) ; \n} \nreturn new int [ ] { \nstart , end } \n; \n} \n} \n"}
{"4188": "public class UnitName { \nprotected String makePlural ( final String name ) { \nString plural ; \nfinal int length = name . length ( ) ; \nfinal char lastChar = name . charAt ( length - 1 ) ; \nif ( lastChar != 'y' ) plural = name + ( lastChar == 's' || lastChar == 'x' || lastChar == 'z' || name . endsWith ( \"ch\" ) ? \"es\" : \"s\" ) ; \nelse if ( length == 1 ) plural = name + \"s\" ; \nelse { \nfinal char penultimateChar = name . charAt ( length - 2 ) ; \nplural = ( penultimateChar == 'a' || penultimateChar == 'e' || penultimateChar == 'i' || penultimateChar == 'o' || penultimateChar == 'u' ) ? name + \"s\" : name . substring ( 0 , length - 1 ) + \"ies\" ; \n} \nreturn plural ; \n} \n} \n"}
{"4196": "public class DateRange { \nprivate void recalcDuration ( ) { \nlong min = getStart ( ) . getDate ( ) . getTime ( ) ; \nlong max = getEnd ( ) . getDate ( ) . getTime ( ) ; \ndouble secs = .001 * ( max - min ) ; \nif ( secs < 0 ) secs = 0 ; \nif ( duration == null ) try { \nduration = new TimeDuration ( chooseResolution ( secs ) ) ; \n} \ncatch ( ParseException e ) { \nthrow new RuntimeException ( e ) ; \n} \nif ( resolution == null ) duration . setValueInSeconds ( secs ) ; \nelse { \ndouble resSecs = resolution . getValueInSeconds ( ) ; \ndouble closest = Math . round ( secs / resSecs ) ; \nsecs = closest * resSecs ; \nduration . setValueInSeconds ( secs ) ; \n} \nhashCode = 0 ; \n} \n} \n"}
{"4197": "public class GridUI { \npublic void addMapBean ( MapBean mb ) { \nmapBeanMenu . addAction ( mb . getActionDesc ( ) , mb . getIcon ( ) , mb . getAction ( ) ) ; \nif ( mapBeanCount == 0 ) setMapRenderer ( mb . getRenderer ( ) ) ; \nmapBeanCount ++ ; \nmb . addPropertyChangeListener ( new PropertyChangeListener ( ) { \npublic void propertyChange ( java . beans . PropertyChangeEvent e ) { \nif ( e . getPropertyName ( ) . equals ( \"Renderer\" ) ) setMapRenderer ( ( Renderer ) e . getNewValue ( ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"4205": "public class CatalogWatcher { \npublic void register ( Path dir ) throws IOException { \nif ( ! enable ) return ; \nWatchKey key = dir . register ( watcher , ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY ) ; \nif ( trace ) { \nPath prev = keys . get ( key ) ; \nif ( prev == null ) System . out . format ( \"CatalogWatcher register: %s%n\" , dir ) ; \nelse if ( ! dir . equals ( prev ) ) System . out . format ( \"update: %s -> %s%n\" , prev , dir ) ; \n} \nkeys . put ( key , dir ) ; \n} \n} \n"}
{"4206": "public class CatalogWatcher { \npublic void processEvents ( ) { \nif ( ! enable ) return ; \nfor ( ; \n; \n) { \nWatchKey key ; \ntry { \nkey = watcher . take ( ) ; \n} \ncatch ( InterruptedException x ) { \nreturn ; \n} \nPath dir = keys . get ( key ) ; \nif ( dir == null ) { \nSystem . err . println ( \"WatchKey not recognized!!\" ) ; \ncontinue ; \n} \nfor ( WatchEvent < ? > event : key . pollEvents ( ) ) { \nWatchEvent . Kind kind = event . kind ( ) ; \nif ( kind == OVERFLOW ) continue ; \nWatchEvent < Path > ev = cast ( event ) ; \nPath name = ev . context ( ) ; \nPath child = dir . resolve ( name ) ; \nSystem . out . format ( \"%s: %s%n\" , event . kind ( ) . name ( ) , child ) ; \nif ( recursive && ( kind == ENTRY_CREATE ) ) try { \nif ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) registerAll ( child ) ; \n} \ncatch ( IOException x ) { \n} \n} \nboolean valid = key . reset ( ) ; \nif ( ! valid ) { \nkeys . remove ( key ) ; \nif ( keys . isEmpty ( ) ) break ; \n} \n} \n} \n} \n"}
{"4208": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset open ( FeatureType wantFeatureType , String location , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( location . startsWith ( DataFactory . SCHEME ) ) { \nDataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( wantFeatureType , location , task ) ; \nerrlog . format ( \"%s\" , result . errLog ) ; \nif ( ! featureTypeOk ( wantFeatureType , result . featureType ) ) { \nerrlog . format ( \"wanted %s but dataset is of type %s%n\" , wantFeatureType , result . featureType ) ; \nresult . close ( ) ; \nreturn null ; \n} \nreturn result . featureDataset ; \n} \nelse if ( location . startsWith ( CdmrFeatureDataset . SCHEME ) ) { \nOptional < FeatureDataset > opt = CdmrFeatureDataset . factory ( wantFeatureType , location ) ; \nif ( opt . isPresent ( ) ) return opt . get ( ) ; \nerrlog . format ( \"%s\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \nelse if ( location . startsWith ( ucar . nc2 . ft . point . collection . CompositeDatasetFactory . SCHEME ) ) { \nString spec = location . substring ( CompositeDatasetFactory . SCHEME . length ( ) ) ; \nMFileCollectionManager dcm = MFileCollectionManager . open ( spec , spec , null , errlog ) ; \nreturn CompositeDatasetFactory . factory ( location , wantFeatureType , dcm , errlog ) ; \n} \nDatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; \nif ( durl . serviceType == null ) { \nOptional < FeatureDatasetCoverage > opt = CoverageDatasetFactory . openGrib ( location ) ; \nif ( opt . isPresent ( ) ) return opt . get ( ) ; \nelse if ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NOT_GRIB_FILE ) && ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NO_GRIB_CLASS ) ) { \nerrlog . format ( \"%s%n\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \n} \nNetcdfDataset ncd = NetcdfDataset . acquireDataset ( durl , true , task ) ; \nFeatureDataset fd = wrap ( wantFeatureType , ncd , task , errlog ) ; \nif ( fd == null ) ncd . close ( ) ; \nreturn fd ; \n} \n} \n"}
{"4209": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset wrap ( FeatureType wantFeatureType , NetcdfDataset ncd , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( debug ) System . out . println ( \"wrap \" + ncd . getLocation ( ) + \" want = \" + wantFeatureType ) ; \nif ( ( wantFeatureType == null ) || ( wantFeatureType == FeatureType . ANY ) ) return wrapUnknown ( ncd , task , errlog ) ; \nObject analysis = null ; \nFeatureDatasetFactory useFactory = null ; \nfor ( Factory fac : factoryList ) { \nif ( ! featureTypeOk ( wantFeatureType , fac . featureType ) ) continue ; \nif ( debug ) System . out . println ( \" wrap try factory \" + fac . factory . getClass ( ) . getName ( ) ) ; \nanalysis = fac . factory . isMine ( wantFeatureType , ncd , errlog ) ; \nif ( analysis != null ) { \nuseFactory = fac . factory ; \nbreak ; \n} \n} \nif ( null == useFactory ) { \nerrlog . format ( \"**Failed to find FeatureDatasetFactory for= %s datatype=%s%n\" , ncd . getLocation ( ) , wantFeatureType ) ; \nreturn null ; \n} \nreturn useFactory . open ( wantFeatureType , ncd , analysis , task , errlog ) ; \n} \n} \n"}
{"4210": "public class FeatureDatasetFactoryManager { \nstatic public boolean featureTypeOk ( FeatureType want , FeatureType facType ) { \nif ( want == null ) return true ; \nif ( want == facType ) return true ; \nif ( want == FeatureType . ANY_POINT ) return facType . isPointFeatureType ( ) ; \nif ( facType == FeatureType . ANY_POINT ) return want . isPointFeatureType ( ) ; \nif ( want == FeatureType . COVERAGE ) return facType . isCoverageFeatureType ( ) ; \nif ( want == FeatureType . GRID ) return facType . isCoverageFeatureType ( ) ; \nif ( want == FeatureType . SIMPLE_GEOMETRY ) return facType . isCoverageFeatureType ( ) ; \nif ( want == FeatureType . UGRID ) return facType . isUnstructuredGridFeatureType ( ) ; \nreturn false ; \n} \n} \n"}
{"4211": "public class FeatureDatasetFactoryManager { \nstatic public FeatureType findFeatureType ( NetcdfFile ncd ) { \nString cdm_datatype = ncd . findAttValueIgnoreCase ( null , CF . FEATURE_TYPE , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_data_type\" , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_datatype\" , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"thredds_data_type\" , null ) ; \nif ( cdm_datatype != null ) for ( FeatureType ft : FeatureType . values ( ) ) if ( cdm_datatype . equalsIgnoreCase ( ft . name ( ) ) ) { \nif ( debug ) System . out . println ( \" wrapUnknown found cdm_datatype \" + cdm_datatype ) ; \nreturn ft ; \n} \nCF . FeatureType cff = CF . FeatureType . getFeatureTypeFromGlobalAttribute ( ncd ) ; \nif ( cff != null ) return CF . FeatureType . convert ( cff ) ; \nreturn null ; \n} \n} \n"}
{"4216": "public class CatalogManager { \nprivate Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { \nboolean isLatest = path . endsWith ( \"/latest.xml\" ) ; \nint pos = path . lastIndexOf ( \"/\" ) ; \nString workPath = ( pos >= 0 ) ? path . substring ( 0 , pos ) : path ; \nString filename = ( pos > 0 ) ? path . substring ( pos + 1 ) : path ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; \nif ( match == null ) return null ; \nif ( match . dataRoot . getFeatureCollection ( ) != null ) { \nInvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; \nif ( isLatest ) return fc . makeLatest ( match . remaining , path , baseURI ) ; \nelse return fc . makeCatalog ( match . remaining , path , baseURI ) ; \n} \nDatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; \nif ( dscan != null ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat ; \nif ( isLatest ) cat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; \nelse cat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nCatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; \nif ( catScan != null ) { \nif ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) return catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nlog . warn ( \"makeDynamicCatalog() failed for =\" + workPath + \" request path= \" + path ) ; \nreturn null ; \n} \n} \n"}
{"4222": "public class InvDatasetFcGrib { \n@ Override public CatalogBuilder makeCatalog ( String match , String reqPath , URI catURI ) throws IOException { \nStateGrib localState = ( StateGrib ) checkState ( ) ; \nif ( localState == null ) return null ; \nif ( localState . gribCollection == null ) return null ; \ntry { \nif ( ( match == null ) || ( match . length ( ) == 0 ) ) return makeCatalogTop ( catURI , localState ) ; \nif ( localState . gribCollection instanceof PartitionCollectionImmutable ) { \nString [ ] paths = match . split ( \"/\" ) ; \nPartitionCollectionImmutable pc = ( PartitionCollectionImmutable ) localState . gribCollection ; \nreturn makeCatalogFromPartition ( pc , paths , 0 , catURI ) ; \n} \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nlogger . error ( \"Error making catalog for \" + configPath , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"4228": "public class NOWRadheader { \nint readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) return 0 ; \nif ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) return 0 ; \nString pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; \nif ( pidd . contains ( \"NOWRA\" ) || pidd . contains ( \"USRAD\" ) || pidd . contains ( \"NEX\" ) ) return 1 ; \nelse return 0 ; \n} \n} \n"}
{"4230": "public class NOWRadheader { \npublic static int bytesToInt ( byte [ ] bytes , boolean swapBytes ) { \nbyte a = bytes [ 0 ] ; \nbyte b = bytes [ 1 ] ; \nbyte c = bytes [ 2 ] ; \nbyte d = bytes [ 3 ] ; \nif ( swapBytes ) return ( ( a & 0xff ) ) + ( ( b & 0xff ) << 8 ) + ( ( c & 0xff ) << 16 ) + ( ( d & 0xff ) << 24 ) ; \nelse return ( ( a & 0xff ) << 24 ) + ( ( b & 0xff ) << 16 ) + ( ( c & 0xff ) << 8 ) + ( ( d & 0xff ) ) ; \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) if ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \nbreak ; \n} \nfor ( int pos = 1 ; \npos < sb . length ( ) ; \n++ pos ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) if ( cp < ' ' || cp > 0x7E || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( cp <= 0x7f && Character . isWhitespace ( cp ) ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; \nelse break ; \n} \nif ( sb . length ( ) == 0 ) throw new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4240": "public class GradsTimeDimension { \npublic static boolean hasTimeTemplate ( String template ) { \nfor ( int i = 0 ; \ni < timeTemplates . length ; \ni ++ ) if ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) return true ; \nreturn false ; \n} \n} \n"}
{"4241": "public class FunctionLibrary { \npublic void add ( ServerSideFunction function ) { \nif ( function instanceof BoolFunction ) boolFunctions . put ( function . getName ( ) , function ) ; \nif ( function instanceof BTFunction ) btFunctions . put ( function . getName ( ) , function ) ; \n} \n} \n"}
{"4242": "public class FunctionLibrary { \npublic BoolFunction getBoolFunction ( String name ) throws NoSuchFunctionException { \nif ( ! boolFunctions . containsKey ( name ) ) loadNewFunction ( name ) ; \nreturn ( BoolFunction ) boolFunctions . get ( name ) ; \n} \n} \n"}
{"4243": "public class FunctionLibrary { \npublic BTFunction getBTFunction ( String name ) throws NoSuchFunctionException { \nif ( ! btFunctions . containsKey ( name ) ) loadNewFunction ( name ) ; \nreturn ( BTFunction ) btFunctions . get ( name ) ; \n} \n} \n"}
{"4245": "public class McIDASLookup { \npublic final String getLevelName ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) return result ; \n} \nString levelUnit = getLevelUnit ( gr ) ; \nif ( levelUnit != null ) { \nint level1 = ( int ) gr . getLevel1 ( ) ; \nint level2 = ( int ) gr . getLevel2 ( ) ; \nif ( levelUnit . equalsIgnoreCase ( \"hPa\" ) ) return \"pressure\" ; \nelse if ( level1 == 1013 ) return \"mean sea level\" ; \nelse if ( level1 == 0 ) return \"tropopause\" ; \nelse if ( level1 == 1001 ) return \"surface\" ; \nelse if ( level2 != 0 ) return \"layer\" ; \n} \nreturn \"\" ; \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) return cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \nint type = gr . getLevelType1 ( ) ; \nif ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { \nif ( type == 20 ) return true ; \nif ( type == 100 ) return true ; \nif ( type == 101 ) return true ; \nif ( ( type >= 103 ) && ( type <= 128 ) ) return true ; \nif ( type == 141 ) return true ; \nif ( type == 160 ) return true ; \n} \nelse if ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) return true ; \nreturn false ; \n} \n} \n"}
{"4250": "public class McIDASLookup { \npublic boolean isLayer ( GridRecord gr ) { \nif ( cust != null ) return cust . isLayer ( gr . getLevelType1 ( ) ) ; \nif ( gr . getLevel2 ( ) == 0 ) return false ; \nreturn true ; \n} \n} \n"}
{"4251": "public class CoordTransBuilder { \nstatic public CoordinateTransform makeCoordinateTransform ( NetcdfDataset ds , AttributeContainer ctv , Formatter parseInfo , Formatter errInfo ) { \nString transform_name = ctv . findAttValueIgnoreCase ( \"transform_name\" , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( \"Projection_Name\" , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . GRID_MAPPING_NAME , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . STANDARD_NAME , null ) ; \nif ( null == transform_name ) { \nparseInfo . format ( \"**Failed to find Coordinate Transform name from Variable= %s%n\" , ctv ) ; \nreturn null ; \n} \ntransform_name = transform_name . trim ( ) ; \nClass builderClass = null ; \nfor ( Transform transform : transformList ) { \nif ( transform . transName . equals ( transform_name ) ) { \nbuilderClass = transform . transClass ; \nbreak ; \n} \n} \nif ( null == builderClass ) { \nparseInfo . format ( \"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\" , transform_name , ctv ) ; \nreturn null ; \n} \nObject builderObject ; \ntry { \nbuilderObject = builderClass . newInstance ( ) ; \n} \ncatch ( InstantiationException | IllegalAccessException e ) { \nlog . error ( \"Cant create new instance \" + builderClass . getName ( ) , e ) ; \nreturn null ; \n} \nif ( null == builderObject ) { \nparseInfo . format ( \"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\" , builderClass . getName ( ) , ctv ) ; \nreturn null ; \n} \nCoordinateTransform ct ; \nif ( builderObject instanceof VertTransformBuilderIF ) { \nVertTransformBuilderIF vertBuilder = ( VertTransformBuilderIF ) builderObject ; \nvertBuilder . setErrorBuffer ( errInfo ) ; \nct = vertBuilder . makeCoordinateTransform ( ds , ctv ) ; \n} \nelse if ( builderObject instanceof HorizTransformBuilderIF ) { \nHorizTransformBuilderIF horizBuilder = ( HorizTransformBuilderIF ) builderObject ; \nhorizBuilder . setErrorBuffer ( errInfo ) ; \nString units = AbstractTransformBuilder . getGeoCoordinateUnits ( ds , ctv ) ; \nct = horizBuilder . makeCoordinateTransform ( ctv , units ) ; \n} \nelse { \nlog . error ( \"Illegals class \" + builderClass . getName ( ) ) ; \nreturn null ; \n} \nif ( ct != null ) parseInfo . format ( \" Made Coordinate transform %s from variable %s: %s%n\" , transform_name , ctv . getName ( ) , builderObject . getClass ( ) . getName ( ) ) ; \nreturn ct ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) if ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4257": "public class SerialWriter { \npublic void writeCount ( long count ) throws IOException { \ncountbuffer . clear ( ) ; \ncountbuffer . putLong ( count ) ; \nbyte [ ] countbuf = countbuffer . array ( ) ; \nint len = countbuffer . position ( ) ; \nwriteBytes ( countbuf , len ) ; \nif ( DEBUG ) System . err . printf ( \"count: %d%n\" , count ) ; \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) System . err . printf ( \"%02x\" , bytes [ i ] ) ; \nSystem . err . println ( ) ; \n} \n} \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) System . err . printf ( \" %02x\" , bytes [ i ] ) ; \nSystem . err . println ( \"\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \n} \n} \n"}
{"4267": "public class McIDASGridReader { \npublic float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { \nfloat [ ] data ; \nint te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; \nint rows = gr . getRows ( ) ; \nint cols = gr . getColumns ( ) ; \nrf . seek ( te ) ; \nfloat scale = ( float ) gr . getParamScale ( ) ; \ndata = new float [ rows * cols ] ; \nrf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; \nfor ( int nc = 0 ; \nnc < cols ; \nnc ++ ) for ( int nr = 0 ; \nnr < rows ; \nnr ++ ) { \nint temp = rf . readInt ( ) ; \ndata [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn data ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) file = args [ 0 ] ; \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . println ( \"found \" + grids . size ( ) + \" grids\" ) ; \nint num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) System . out . println ( grids . get ( i ) ) ; \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nint irow = 1 ; \nif ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nint iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nint ilenhd = part . klnhdr ; \nint ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nint istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) return - 15 ; \nint length = DM_RINT ( istart ) ; \nint isword = istart + 1 ; \nif ( length <= ilenhd ) { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nelse if ( Math . abs ( length ) > 10000000 ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword += ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4275": "public class GempakGridReader { \npublic GempakGridRecord findGrid ( String parm ) { \nList < GridRecord > gridList = gridIndex . getGridRecords ( ) ; \nif ( gridList == null ) return null ; \nfor ( GridRecord grid : gridList ) { \nGempakGridRecord gh = ( GempakGridRecord ) grid ; \nif ( gh . param . trim ( ) . equals ( parm ) ) return gh ; \n} \nreturn null ; \n} \n} \n"}
{"4276": "public class GempakGridReader { \npublic float [ ] DM_RPKG ( int isword , int nword , int decimalScale ) throws IOException { \nfloat [ ] data ; \nint ipktyp = DM_RINT ( isword ) ; \nint iiword = isword + 1 ; \nint lendat = nword - 1 ; \nif ( ipktyp == MDGNON ) { \ndata = new float [ lendat ] ; \nDM_RFLT ( iiword , data ) ; \nreturn data ; \n} \nint iiw ; \nint irw ; \nif ( ipktyp == MDGDIF ) { \niiw = 4 ; \nirw = 3 ; \n} \nelse if ( ipktyp == MDGRB2 ) { \niiw = 4 ; \nirw = 1 ; \n} \nelse { \niiw = 3 ; \nirw = 2 ; \n} \nint [ ] iarray = new int [ iiw ] ; \nfloat [ ] rarray = new float [ irw ] ; \nDM_RINT ( iiword , iarray ) ; \niiword = iiword + iiw ; \nlendat = lendat - iiw ; \nDM_RFLT ( iiword , rarray ) ; \niiword = iiword + irw ; \nlendat = lendat - irw ; \nif ( ipktyp == MDGRB2 ) { \ndata = unpackGrib2Data ( iiword , lendat , iarray , rarray ) ; \nreturn data ; \n} \nint nbits = iarray [ 0 ] ; \nint misflg = iarray [ 1 ] ; \nboolean miss = misflg != 0 ; \nint kxky = iarray [ 2 ] ; \nint kx = 0 ; \nif ( iiw == 4 ) kx = iarray [ 3 ] ; \nfloat ref = rarray [ 0 ] ; \nfloat scale = rarray [ 1 ] ; \nfloat difmin = 0 ; \nif ( irw == 3 ) difmin = rarray [ 2 ] ; \ndata = unpackData ( iiword , lendat , ipktyp , kxky , nbits , ref , scale , miss , difmin , kx , decimalScale ) ; \nreturn data ; \n} \n} \n"}
{"4277": "public class GempakGridReader { \nprivate synchronized float [ ] unpackData ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalScale ) throws IOException { \nif ( ipktyp == MDGGRB ) if ( ! useDP ) return unpackGrib1Data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalScale ) ; \nelse { \nif ( nword * 32 < kxky * nbits ) nword ++ ; \nint [ ] ksgrid = new int [ nword ] ; \nDM_RINT ( iiword , ksgrid ) ; \nreturn DP_UGRB ( ksgrid , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \nelse if ( ipktyp == MDGNMC ) return null ; \nelse if ( ipktyp == MDGDIF ) return null ; \nreturn null ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( nbits <= 1 ) || ( nbits > 31 ) ) return grid ; \nif ( scale == 0. ) return grid ; \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \nfor ( int i = 0 ; \ni < kxky ; \ni ++ ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft -= 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) grid [ i ] = RMISSD ; \nelse grid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \nibit += nbits ; \nif ( ibit > 32 ) { \nibit -= 32 ; \niword ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4279": "public class GempakGridReader { \nprivate float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { \nfloat [ ] values = new float [ kxky ] ; \nbitPos = 0 ; \nbitBuf = 0 ; \nnext = 0 ; \nch1 = 0 ; \nch2 = 0 ; \nch3 = 0 ; \nch4 = 0 ; \nrf . seek ( getOffset ( iiword ) ) ; \nint idat ; \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfor ( int i = 0 ; \ni < values . length ; \ni ++ ) { \nidat = bits2UInt ( nbits ) ; \nif ( miss && ( idat == IMISSD ) ) values [ i ] = IMISSD ; \nelse values [ i ] = ( ref + scale * idat ) * scaleFactor ; \n} \nreturn values ; \n} \n} \n"}
{"4280": "public class GempakGridReader { \nprivate float [ ] unpackGrib2Data ( int iiword , int lendat , int [ ] iarray , float [ ] rarray ) throws IOException { \nlong start = getOffset ( iiword ) ; \nrf . seek ( start ) ; \nGrib2Record gr = makeGribRecord ( rf , start ) ; \nfloat [ ] data = gr . readData ( rf ) ; \nif ( ( ( iarray [ 3 ] >> 6 ) & 1 ) == 0 ) data = gb2_ornt ( iarray [ 1 ] , iarray [ 2 ] , iarray [ 3 ] , data ) ; \nreturn data ; \n} \n} \n"}
{"4282": "public class GempakGridReader { \nprivate void getNextByte ( ) throws IOException { \nif ( ! needToSwap ) bitBuf = rf . read ( ) ; \nelse { \nif ( next == 3 ) bitBuf = ch3 ; \nelse if ( next == 2 ) bitBuf = ch2 ; \nelse if ( next == 1 ) bitBuf = ch1 ; \nelse { \nch1 = rf . read ( ) ; \nch2 = rf . read ( ) ; \nch3 = rf . read ( ) ; \nch4 = rf . read ( ) ; \nbitBuf = ch4 ; \nnext = 4 ; \n} \nnext -- ; \n} \n} \n} \n"}
{"4293": "public class CDMUtil { \nstatic public NetcdfFile unwrapfile ( NetcdfFile file ) { \nfor ( ; \n; \n) if ( file instanceof NetcdfDataset ) { \nNetcdfDataset ds = ( NetcdfDataset ) file ; \nfile = ds . getReferencedFile ( ) ; \nif ( file == null ) break ; \n} \nelse break ; \nreturn file ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; \nint effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \nfor ( int i = 0 ; \ni < effectiverank ; \ni ++ ) shape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \nreturn shape ; \n} \n} \n"}
{"4301": "public class ScaledUnit { \npublic double toDerivedUnit ( final double amount ) throws ConversionException { \nif ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( this , getDerivedUnit ( ) ) ; \nreturn ( ( DerivableUnit ) _unit ) . toDerivedUnit ( amount * getScale ( ) ) ; \n} \n} \n"}
{"4302": "public class ScaledUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfinal float scale = ( float ) getScale ( ) ; \nfor ( int i = input . length ; \n-- i >= 0 ; \n) output [ i ] = input [ i ] * scale ; \nif ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( this , getDerivedUnit ( ) ) ; \nreturn ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"4303": "public class ScaledUnit { \npublic double fromDerivedUnit ( final double amount ) throws ConversionException { \nif ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( getDerivedUnit ( ) , this ) ; \nreturn ( ( DerivableUnit ) getUnit ( ) ) . fromDerivedUnit ( amount ) / getScale ( ) ; \n} \n} \n"}
{"4324": "public class SigmetIOServiceProvider { \npublic Array readData1 ( ucar . nc2 . Variable v2 , Section section ) throws IOException , InvalidRangeException { \nint [ ] sh = section . getShape ( ) ; \nArray temp = Array . factory ( v2 . getDataType ( ) , sh ) ; \nlong pos0 = 0 ; \nLayoutRegular index = new LayoutRegular ( pos0 , v2 . getElementSize ( ) , v2 . getShape ( ) , section ) ; \nif ( v2 . getShortName ( ) . startsWith ( \"time\" ) | v2 . getShortName ( ) . startsWith ( \"numGates\" ) ) temp = readIntData ( index , v2 ) ; \nelse temp = readFloatData ( index , v2 ) ; \nreturn temp ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nint i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nwhile ( iter . hasNext ( ) ) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni ++ ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nint count = channel . write ( buffer ) ; \nSystem . out . println ( \"COUNT=\" + count ) ; \nif ( buffer . hasRemaining ( ) ) buffer . compact ( ) ; \nelse buffer . clear ( ) ; \nreturn ( long ) count ; \n} \n} \n"}
{"4329": "public class SigmetIOServiceProvider { \nstatic float calcAz ( short az0 , short az1 ) { \nfloat azim0 = calcAngle ( az0 ) ; \nfloat azim1 = calcAngle ( az1 ) ; \nfloat d = 0.0f ; \nd = Math . abs ( azim0 - azim1 ) ; \nif ( ( az0 < 0 ) & ( az1 > 0 ) ) d = Math . abs ( 360.0f - azim0 ) + Math . abs ( azim1 ) ; \ndouble temp = azim0 + d * 0.5 ; \nif ( temp > 360.0 ) temp -= 360.0 ; \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4330": "public class SigmetIOServiceProvider { \nstatic float calcData ( Map < String , Number > recHdr , short dty , byte data ) { \nshort [ ] coef = { \n1 , 2 , 3 , 4 } \n; \nshort multiprf = recHdr . get ( \"multiprf\" ) . shortValue ( ) ; \nfloat vNyq = recHdr . get ( \"vNyq\" ) . floatValue ( ) ; \ndouble temp = - 999.99 ; \nswitch ( dty ) { \ndefault : if ( data != 0 ) temp = ( ( ( int ) data & 0xFF ) - 64 ) * 0.5 ; \nbreak ; \ncase 3 : if ( data != 0 ) temp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; \nbreak ; \ncase 4 : if ( data != 0 ) { \ndouble v = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; \ntemp = ( ( ( int ) data & 0xFF ) / 256.0 ) * v ; \n} \nbreak ; \ncase 5 : if ( data != 0 ) temp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 16.0 ) ; \nbreak ; \n} \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4335": "public class GridServiceProvider { \nprivate void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nGridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; \nint nx = hsys . getNx ( ) ; \nGridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; \nif ( record == null ) { \nAttribute att = v2 . findAttribute ( \"missing_value\" ) ; \nfloat missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; \nint xyCount = yRange . length ( ) * xRange . length ( ) ; \nfor ( int j = 0 ; \nj < xyCount ; \nj ++ ) ii . setFloatNext ( missing_value ) ; \nreturn ; \n} \nfloat [ ] data = _readData ( record ) ; \nif ( data == null ) { \n_readData ( record ) ; \nreturn ; \n} \nfor ( int y : yRange ) { \nfor ( int x : xRange ) { \nint index = y * nx + x ; \nii . setFloatNext ( data [ index ] ) ; \n} \n} \n} \n} \n"}
{"4336": "public class GridServiceProvider { \npublic boolean isMissingXY ( Variable v2 , int timeIdx , int ensIdx , int levIdx ) throws InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nif ( ( timeIdx < 0 ) || ( timeIdx >= pv . getNTimes ( ) ) ) throw new InvalidRangeException ( \"timeIdx=\" + timeIdx ) ; \nif ( ( levIdx < 0 ) || ( levIdx >= pv . getVertNlevels ( ) ) ) throw new InvalidRangeException ( \"levIdx=\" + levIdx ) ; \nif ( ( ensIdx < 0 ) || ( ensIdx >= pv . getNEnsembles ( ) ) ) throw new InvalidRangeException ( \"ensIdx=\" + ensIdx ) ; \nreturn ( null == pv . findRecord ( ensIdx , timeIdx , levIdx ) ) ; \n} \n} \n"}
{"4337": "public class DtCoverageCS { \npublic LatLonRect getLatLonBoundingBox ( ) { \nif ( llbb == null ) { \nif ( ( getXHorizAxis ( ) instanceof CoordinateAxis2D ) && ( getYHorizAxis ( ) instanceof CoordinateAxis2D ) ) return null ; \nCoordinateAxis horizXaxis = getXHorizAxis ( ) ; \nCoordinateAxis horizYaxis = getYHorizAxis ( ) ; \nif ( isLatLon ( ) ) { \ndouble startLat = horizYaxis . getMinValue ( ) ; \ndouble startLon = horizXaxis . getMinValue ( ) ; \ndouble deltaLat = horizYaxis . getMaxValue ( ) - startLat ; \ndouble deltaLon = horizXaxis . getMaxValue ( ) - startLon ; \nLatLonPoint llpt = new LatLonPointImpl ( startLat , startLon ) ; \nllbb = new LatLonRect ( llpt , deltaLat , deltaLon ) ; \n} \nelse { \nProjectionImpl dataProjection = getProjection ( ) ; \nProjectionRect bb = getBoundingBox ( ) ; \nif ( bb != null ) llbb = dataProjection . projToLatLonBB ( bb ) ; \n} \n} \nreturn llbb ; \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( tabStop > len ) { \nsbuff . setLength ( tabStop ) ; \nfor ( int i = len ; \ni < tabStop ; \ni ++ ) sbuff . setCharAt ( i , ' ' ) ; \n} \nelse if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \n} \n} \n"}
{"4340": "public class Format { \npublic static String pad ( String s , int width , boolean rightJustify ) { \nif ( s . length ( ) >= width ) return s ; \nStringBuilder sbuff = new StringBuilder ( width ) ; \nint need = width - s . length ( ) ; \nsbuff . setLength ( need ) ; \nfor ( int i = 0 ; \ni < need ; \ni ++ ) sbuff . setCharAt ( i , ' ' ) ; \nif ( rightJustify ) sbuff . append ( s ) ; \nelse sbuff . insert ( 0 , s ) ; \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4343": "public class Format { \npublic static String formatByteSize ( double size ) { \nString unit = null ; \nif ( size > 1.0e15 ) { \nunit = \"Pbytes\" ; \nsize *= 1.0e-15 ; \n} \nelse if ( size > 1.0e12 ) { \nunit = \"Tbytes\" ; \nsize *= 1.0e-12 ; \n} \nelse if ( size > 1.0e9 ) { \nunit = \"Gbytes\" ; \nsize *= 1.0e-9 ; \n} \nelse if ( size > 1.0e6 ) { \nunit = \"Mbytes\" ; \nsize *= 1.0e-6 ; \n} \nelse if ( size > 1.0e3 ) { \nunit = \"Kbytes\" ; \nsize *= 1.0e-3 ; \n} \nelse unit = \"bytes\" ; \nreturn Format . d ( size , 4 ) + \" \" + unit ; \n} \n} \n"}
{"4348": "public class Slice { \npublic String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nif ( ( this . stop - this . first ) == 0 ) return String . format ( \"[0]\" ) ; \nelse if ( this . stride == 1 ) if ( ( this . stop - this . first ) == 1 ) return String . format ( \"[%d]\" , this . first ) ; \nelse return String . format ( \"[%d:%d]\" , this . first , this . stop - 1 ) ; \nelse return String . format ( \"[%d:%d:%d]\" , this . first , this . stride , this . stop - 1 ) ; \n} \n} \n"}
{"4354": "public class EarthEllipsoid { \npublic static EarthEllipsoid getType ( int epsgId ) { \nCollection < EarthEllipsoid > all = getAll ( ) ; \nfor ( EarthEllipsoid ellipsoid : all ) { \nif ( ellipsoid . epsgId == epsgId ) return ellipsoid ; \n} \nreturn null ; \n} \n} \n"}
{"4355": "public class NcStreamDataCol { \npublic Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nArray [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; \nint count = 0 ; \nfor ( int len : dproto . getVlensList ( ) ) { \nArray primdata = Array . factory ( dataType , new int [ ] { \nlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) prim . setObjectNext ( all . getObjectNext ( ) ) ; \ndata [ count ++ ] = primdata ; \n} \nreturn Array . makeVlenArray ( section . getShape ( ) , data ) ; \n} \n} \n"}
{"4356": "public class NcStreamDataCol { \nprivate Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nint psize = ( int ) parentSection . computeSize ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nSection vsection = section . removeFirst ( parentSection ) ; \nint vsectionSize = ( int ) vsection . computeSize ( ) ; \nint countInner = 0 ; \nArray [ ] pdata = new Array [ psize ] ; \nfor ( int pCount = 0 ; \npCount < psize ; \npCount ++ ) { \nArray [ ] vdata = new Array [ vsectionSize ] ; \nfor ( int vCount = 0 ; \nvCount < vsectionSize ; \nvCount ++ ) { \nint vlen = dproto . getVlens ( countInner ++ ) ; \nArray primdata = Array . factory ( dataType , new int [ ] { \nvlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( int i = 0 ; \ni < vlen ; \ni ++ ) prim . setObjectNext ( all . getObjectNext ( ) ) ; \nvdata [ vCount ] = primdata ; \n} \npdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; \n} \nreturn Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; \n} \n} \n"}
{"4373": "public class GridHorizCoordSys { \nprivate double getGridSpacingInKm ( String type ) { \ndouble value = gds . getDouble ( type ) ; \nif ( Double . isNaN ( value ) ) return value ; \nString gridUnit = gds . getParam ( GridDefRecord . GRID_UNITS ) ; \nSimpleUnit unit ; \nif ( gridUnit == null || gridUnit . length ( ) == 0 ) unit = SimpleUnit . meterUnit ; \nelse unit = SimpleUnit . factory ( gridUnit ) ; \nif ( unit != null && SimpleUnit . isCompatible ( unit . getUnitString ( ) , \"km\" ) ) value = unit . convertTo ( value , SimpleUnit . kmUnit ) ; \nreturn value ; \n} \n} \n"}
{"4375": "public class GridHorizCoordSys { \nprivate double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . setDimensions ( name ) ; \ndouble [ ] data = new double [ n ] ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) data [ i ] = start + incr * i ; \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nn } \n, data ) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( \"units\" , units ) ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , desc ) ) ; \nv . addAttribute ( new Attribute ( \"standard_name\" , standard_name ) ) ; \nv . addAttribute ( new Attribute ( \"grid_spacing\" , incr + \" \" + units ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; \nncfile . addVariable ( g , v ) ; \nreturn data ; \n} \n} \n"}
{"4377": "public class GridHorizCoordSys { \nprivate void addGDSparams ( Variable v ) { \nList < String > keyList = new ArrayList < > ( gds . getKeys ( ) ) ; \nCollections . sort ( keyList ) ; \nString pre = getGDSprefix ( ) ; \nfor ( String key : keyList ) { \nString name = pre + \"_param_\" + key ; \nString vals = gds . getParam ( key ) ; \ntry { \nint vali = Integer . parseInt ( vals ) ; \nif ( key . equals ( GridDefRecord . VECTOR_COMPONENT_FLAG ) ) { \nString cf = GridCF . VectorComponentFlag . of ( vali ) ; \nv . addAttribute ( new Attribute ( name , cf ) ) ; \n} \nelse v . addAttribute ( new Attribute ( name , vali ) ) ; \n} \ncatch ( Exception e ) { \ntry { \ndouble vald = Double . parseDouble ( vals ) ; \nv . addAttribute ( new Attribute ( name , vald ) ) ; \n} \ncatch ( Exception e2 ) { \nv . addAttribute ( new Attribute ( name , vals ) ) ; \n} \n} \n} \n} \n} \n"}
{"4379": "public class GridHorizCoordSys { \nprivate void makeLC ( ) { \nproj = new LambertConformal ( gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LOV ) , gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) ) ; \nLatLonPointImpl startLL = new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nif ( GridServiceProvider . debugProj ) { \nSystem . out . println ( \"GridHorizCoordSys.makeLC start at latlon \" + startLL ) ; \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeLC end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + getNx ( ) * getDxInKm ( ) ; \ndouble endy = starty + getNy ( ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"lambert_conformal_conic\" ) ) ; \nif ( gds . getDouble ( GridDefRecord . LATIN1 ) == gds . getDouble ( GridDefRecord . LATIN2 ) ) attributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \nelse { \ndouble [ ] data = new double [ ] { \ngds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) } \n; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Array . factory ( DataType . DOUBLE , new int [ ] { \n2 } \n, data ) ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_CENTRAL_MERIDIAN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \n} \n"}
{"4380": "public class GridHorizCoordSys { \nprivate void makePS ( ) { \nString nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; \ndouble latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( \"true\" ) ) ? 90.0 : - 90.0 ; \ndouble scale ; \ndouble lad = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( lad ) ) scale = .933 ; \nelse scale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; \nproj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nif ( GridServiceProvider . debugProj ) { \nSystem . out . printf ( \"starting proj coord %s lat/lon %s%n\" , start , proj . projToLatLon ( start ) ) ; \nSystem . out . println ( \"   should be LA1=\" + gds . getDouble ( GridDefRecord . LA1 ) + \" l)1=\" + gds . getDouble ( GridDefRecord . LO1 ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"polar_stereographic\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo2 < Lo1 ) Lo2 += 360 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMercator: end at latlon= \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   start at proj coord \" + new ProjectionPointImpl ( startx , starty ) ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4383": "public class GridHorizCoordSys { \nprivate void setDxDy ( double startx , double starty , ProjectionImpl proj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nif ( Double . isNaN ( Lo2 ) || Double . isNaN ( La2 ) ) return ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nProjectionPointImpl end = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \ndouble dx = Math . abs ( end . getX ( ) - startx ) / ( gds . getInt ( GridDefRecord . NX ) - 1 ) ; \ndouble dy = Math . abs ( end . getY ( ) - starty ) / ( gds . getInt ( GridDefRecord . NY ) - 1 ) ; \ngds . addParam ( GridDefRecord . DX , String . valueOf ( dx ) ) ; \ngds . addParam ( GridDefRecord . DY , String . valueOf ( dy ) ) ; \ngds . addParam ( GridDefRecord . GRID_UNITS , \"km\" ) ; \n} \n} \n"}
{"4385": "public class InvCatalogFactory10 { \nprotected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nInvDatasetScan datasetScan ; \nif ( dsElem . getAttributeValue ( \"dirLocation\" ) == null ) if ( dsElem . getAttributeValue ( \"location\" ) == null ) { \nlogger . error ( \"readDatasetScan(): datasetScan has neither a \\\"location\\\" nor a \\\"dirLocation\\\" attribute.\" ) ; \ndatasetScan = null ; \n} \nelse return readDatasetScanNew ( catalog , parent , dsElem , base ) ; \nelse { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nfactory . appendWarning ( \"**Warning: Dataset \" + name + \" using old form of DatasetScan (dirLocation instead of location)\\n\" ) ; \nString path = dsElem . getAttributeValue ( \"path\" ) ; \nString scanDir = expandAliasForPath ( dsElem . getAttributeValue ( \"dirLocation\" ) ) ; \nString filter = dsElem . getAttributeValue ( \"filter\" ) ; \nString addDatasetSizeString = dsElem . getAttributeValue ( \"addDatasetSize\" ) ; \nString addLatest = dsElem . getAttributeValue ( \"addLatest\" ) ; \nString sortOrderIncreasingString = dsElem . getAttributeValue ( \"sortOrderIncreasing\" ) ; \nboolean sortOrderIncreasing = false ; \nif ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( \"true\" ) ) sortOrderIncreasing = true ; \nboolean addDatasetSize = true ; \nif ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( \"false\" ) ) addDatasetSize = false ; \nif ( path != null ) { \nif ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nint last = path . length ( ) - 1 ; \nif ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; \n} \nif ( scanDir != null ) { \nint last = scanDir . length ( ) - 1 ; \nif ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; \n} \nElement atcElem = dsElem . getChild ( \"addTimeCoverage\" , defNS ) ; \nString dsNameMatchPattern = null ; \nString startTimeSubstitutionPattern = null ; \nString duration = null ; \nif ( atcElem != null ) { \ndsNameMatchPattern = atcElem . getAttributeValue ( \"datasetNameMatchPattern\" ) ; \nstartTimeSubstitutionPattern = atcElem . getAttributeValue ( \"startTimeSubstitutionPattern\" ) ; \nduration = atcElem . getAttributeValue ( \"duration\" ) ; \n} \ntry { \ndatasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; \nreadDatasetInfo ( catalog , datasetScan , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) System . out . println ( \" Dataset added: \" + datasetScan . dump ( ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Reading DatasetScan\" , e ) ; \ndatasetScan = null ; \n} \n} \nreturn datasetScan ; \n} \n} \n"}
{"4387": "public class McIDASGridRecord { \npublic int getLevelType1 ( ) { \nint gribLevel = getDirBlock ( ) [ 51 ] ; \nint levelType = 0 ; \nif ( ! ( ( gribLevel == McIDASUtil . MCMISSING ) || ( gribLevel == 0 ) ) ) levelType = gribLevel ; \nelse levelType = 1 ; \nreturn levelType ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nint len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( len > 1 ) name = name + Integer . toString ( len ) ; \nelse name = name + values . get ( 0 ) ; \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) if ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) parseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \nreturn dim ; \n} \n} \nString orgName = name ; \nint count = 1 ; \nwhile ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { \nname = orgName + \"-\" + count ; \ncount ++ ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) return ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) d [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \n} \n} \n"}
{"4416": "public class ThreddsMetadata { \npublic void add ( ThreddsMetadata tmd , boolean includeInherited ) { \ncreators . addAll ( tmd . getCreators ( ) ) ; \ncontributors . addAll ( tmd . getContributors ( ) ) ; \ndates . addAll ( tmd . getDates ( ) ) ; \ndocs . addAll ( tmd . getDocumentation ( ) ) ; \nkeywords . addAll ( tmd . getKeywords ( ) ) ; \nprojects . addAll ( tmd . getProjects ( ) ) ; \nproperties . addAll ( tmd . getProperties ( ) ) ; \npublishers . addAll ( tmd . getPublishers ( ) ) ; \nvariables . addAll ( tmd . getVariables ( ) ) ; \nif ( includeInherited ) metadata . addAll ( tmd . getMetadata ( ) ) ; \nelse for ( InvMetadata mdata : tmd . getMetadata ( ) ) { \nif ( ! mdata . isInherited ( ) ) metadata . add ( mdata ) ; \n} \nif ( gc == null ) gc = tmd . getGeospatialCoverage ( ) ; \nif ( timeCoverage == null ) timeCoverage = tmd . getTimeCoverage ( ) ; \nif ( serviceName == null ) serviceName = tmd . getServiceName ( ) ; \nif ( dataType == null ) dataType = tmd . getDataType ( ) ; \nif ( dataSize == 0.0 ) dataSize = tmd . getDataSize ( ) ; \nif ( dataFormat == null ) dataFormat = tmd . getDataFormatType ( ) ; \nif ( authorityName == null ) authorityName = tmd . getAuthority ( ) ; \nif ( variableMapLink == null ) variableMapLink = tmd . getVariableMap ( ) ; \n} \n} \n"}
{"4427": "public class CoordSysBuilder { \nprotected void makeCoordinateSystems ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . isCoordinateSystem ) vp . makeCoordinateSystem ( ) ; \n} \n} \n} \n"}
{"4428": "public class CoordSysBuilder { \nprotected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { \nboolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; \nfor ( VarProcess vp : varList ) { \nVariableEnhanced ve = ( VariableEnhanced ) vp . v ; \nif ( vp . hasCoordinateSystem ( ) || ! vp . isData ( ) ) continue ; \nList < CoordinateAxis > axisList = new ArrayList < > ( ) ; \nList < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; \nfor ( CoordinateAxis axis : axes ) { \nif ( isCoordinateAxisForVariable ( axis , ve ) ) axisList . add ( axis ) ; \n} \nif ( axisList . size ( ) < 2 ) continue ; \nString csName = CoordinateSystem . makeName ( axisList ) ; \nCoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; \nboolean okToBuild = false ; \nif ( requireCompleteCoordSys ) if ( cs != null ) okToBuild = cs . isComplete ( ve ) ; \nelse okToBuild = true ; \nif ( cs != null && okToBuild ) { \nve . addCoordinateSystem ( cs ) ; \nparseInfo . format ( \" assigned maximal CoordSystem '%s' for var= %s%n\" , cs . getName ( ) , ve . getFullName ( ) ) ; \n} \nelse { \nCoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; \nif ( requireCompleteCoordSys ) okToBuild = csnew . isComplete ( ve ) ; \nif ( okToBuild ) { \ncsnew . setImplicit ( true ) ; \nve . addCoordinateSystem ( csnew ) ; \nncDataset . addCoordinateSystem ( csnew ) ; \nparseInfo . format ( \" created maximal CoordSystem '%s' for var= %s%n\" , csnew . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nint checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; \nfor ( int i = 0 ; \ni < checkDims ; \ni ++ ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"4436": "public class Counters { \npublic boolean count ( String name , Comparable value ) { \nCounter counter = map . get ( name ) ; \nif ( counter == null ) counter = add ( name ) ; \nreturn counter . count ( value ) ; \n} \n} \n"}
{"4447": "public class DSPRegistry { \nsynchronized public void unregister ( Class < ? extends DSP > klass ) { \nfor ( int i = 0 ; \ni < registry . size ( ) ; \ni ++ ) if ( registry . get ( i ) . dspclass == klass ) { \nregistry . remove ( i ) ; \nbreak ; \n} \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nint timeUnitOrg = pds . getTimeUnit ( ) ; \nint range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) continue ; \nif ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange += ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; \ndouble fac ; \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) fac = 30.0 * 24.0 ; \nelse if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) fac = 365.0 * 24.0 ; \nelse fac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \nreturn fac * range ; \n} \n} \n"}
{"4453": "public class DapDataset { \npublic void sort ( ) { \nList < DapNode > sorted = new ArrayList < DapNode > ( ) ; \nsortR ( this , sorted ) ; \nfor ( int i = 0 ; \ni < sorted . size ( ) ; \ni ++ ) sorted . get ( i ) . setIndex ( i ) ; \nthis . nodelist = sorted ; \n} \n} \n"}
{"4475": "public class PictureCache { \npublic static synchronized void reportCache ( ) { \nTools . log ( \"   PictureCache.reportCache: cache contains: \" + Integer . toString ( pictureCache . size ( ) ) + \" max: \" + Integer . toString ( maxCache ) ) ; \nEnumeration e = pictureCache . keys ( ) ; \nwhile ( e . hasMoreElements ( ) ) Tools . log ( \"   Cache contains: \" + ( ( String ) e . nextElement ( ) ) ) ; \nTools . log ( \"  End of cache contents\" ) ; \n} \n} \n"}
{"4476": "public class PictureCache { \npublic static void stopBackgroundLoading ( ) { \nEnumeration e = cacheLoadsInProgress . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) ( ( SourcePicture ) e . nextElement ( ) ) . stopLoading ( ) ; \n} \n} \n"}
{"4479": "public class HTTPFactory { \nstatic protected HTTPMethod makemethod ( HTTPSession . Methods m , HTTPSession session , String url ) throws HTTPException { \nHTTPMethod meth = null ; \nif ( MOCKMETHODCLASS == null ) meth = new HTTPMethod ( m , session , url ) ; \nelse { \njava . lang . Class methodcl = MOCKMETHODCLASS ; \nConstructor < HTTPMethod > cons = null ; \ntry { \ncons = methodcl . getConstructor ( HTTPSession . Methods . class , HTTPSession . class , String . class ) ; \n} \ncatch ( Exception e ) { \nthrow new HTTPException ( \"HTTPFactory: no proper HTTPMethod constructor available\" , e ) ; \n} \ntry { \nmeth = cons . newInstance ( m , session , url ) ; \n} \ncatch ( Exception e ) { \nthrow new HTTPException ( \"HTTPFactory: HTTPMethod constructor failed\" , e ) ; \n} \n} \nreturn meth ; \n} \n} \n"}
{"4482": "public class DapNetcdfFile { \n@ Override protected Array readData ( Variable cdmvar , Section section ) throws IOException , InvalidRangeException { \nassert this . dsp != null ; \nArray result = arraymap . get ( cdmvar ) ; \nif ( result == null ) throw new IOException ( \"No data for variable: \" + cdmvar . getFullName ( ) ) ; \nif ( section != null ) { \nif ( cdmvar . getRank ( ) != section . getRank ( ) ) throw new InvalidRangeException ( String . format ( \"Section rank != %s rank\" , cdmvar . getFullName ( ) ) ) ; \nList < Range > ranges = section . getRanges ( ) ; \nif ( CDMUtil . hasVLEN ( ranges ) ) ranges = ranges . subList ( 0 , ranges . size ( ) - 1 ) ; \nif ( ranges . size ( ) > 0 && ! CDMUtil . isWhole ( ranges , cdmvar ) ) result = result . sectionNoReduce ( ranges ) ; \n} \nreturn result ; \n} \n} \n"}
{"4483": "public class RadarServerConfig { \nprivate static FileSystemProvider getProvider ( URI uri ) throws IOException { \nif ( fsproviders . containsKey ( uri . getScheme ( ) ) ) return fsproviders . get ( uri . getScheme ( ) ) ; \nelse { \nFileSystem fs ; \ntry { \nfs = FileSystems . newFileSystem ( uri , new HashMap < String , Object > ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; \n} \ncatch ( FileSystemAlreadyExistsException e ) { \nfs = FileSystems . getFileSystem ( uri ) ; \n} \nfsproviders . put ( uri . getScheme ( ) , fs . provider ( ) ) ; \nreturn fs . provider ( ) ; \n} \n} \n} \n"}
{"4487": "public class MetarParseReport { \nprivate String cloud_hgt2_meters ( String height ) { \nif ( height . equals ( \"999\" ) ) return \"30000\" ; \nelse return Integer . toString ( 30 * Integer . parseInt ( height ) ) ; \n} \n} \n"}
{"4495": "public class SmartArrayInt { \npublic int findIdx ( int want ) { \nif ( isConstant ) return ( want == start ) ? 0 : - 1 ; \nif ( isSequential ) return want - start ; \nif ( isSorted ) return Arrays . binarySearch ( raw , want ) ; \nfor ( int i = 0 ; \ni < raw . length ; \ni ++ ) if ( raw [ i ] == want ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"4501": "public class CatGenConfigMetadataFactory { \nprivate DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { \nString name = dsSourceElement . getAttributeValue ( \"name\" ) ; \nString type = dsSourceElement . getAttributeValue ( \"type\" ) ; \nString structure = dsSourceElement . getAttributeValue ( \"structure\" ) ; \nString accessPoint = dsSourceElement . getAttributeValue ( \"accessPoint\" ) ; \nString createCatalogRefs = dsSourceElement . getAttributeValue ( \"createCatalogRefs\" ) ; \nElement resultServiceElement = dsSourceElement . getChild ( \"resultService\" , dsSourceElement . getNamespace ( ) ) ; \nResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; \nDatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; \nif ( createCatalogRefs != null ) dsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; \njava . util . List list = dsSourceElement . getChildren ( \"datasetNamer\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nElement dsNamerElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; \n} \nlist = dsSourceElement . getChildren ( \"datasetFilter\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nElement dsFilterElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; \n} \nreturn ( dsSource ) ; \n} \n} \n"}
{"4505": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createCatGenConfigElement ( CatalogGenConfig cgc ) { \nElement cgcElem = new Element ( \"catalogGenConfig\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( cgc != null ) { \nif ( cgc . getType ( ) != null ) cgcElem . setAttribute ( \"type\" , cgc . getType ( ) . toString ( ) ) ; \nDatasetSource dsSource = cgc . getDatasetSource ( ) ; \ncgcElem . addContent ( createDatasetSourceElement ( dsSource ) ) ; \n} \nreturn ( cgcElem ) ; \n} \n} \n"}
{"4506": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { \nElement dssElem = new Element ( \"datasetSource\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsSource != null ) { \nif ( dsSource . getName ( ) != null ) dssElem . setAttribute ( \"name\" , dsSource . getName ( ) ) ; \nif ( dsSource . getType ( ) != null ) dssElem . setAttribute ( \"type\" , dsSource . getType ( ) . toString ( ) ) ; \nif ( dsSource . getStructure ( ) != null ) dssElem . setAttribute ( \"structure\" , dsSource . getStructure ( ) . toString ( ) ) ; \nif ( dsSource . getAccessPoint ( ) != null ) dssElem . setAttribute ( \"accessPoint\" , dsSource . getAccessPoint ( ) ) ; \ndssElem . setAttribute ( \"createCatalogRefs\" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; \nResultService rs = dsSource . getResultService ( ) ; \ndssElem . addContent ( createResultServiceElement ( rs ) ) ; \njava . util . List list = dsSource . getDatasetNamerList ( ) ; \nfor ( int j = 0 ; \nj < list . size ( ) ; \nj ++ ) { \nDatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; \ndssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; \n} \nlist = dsSource . getDatasetFilterList ( ) ; \nfor ( int j = 0 ; \nj < list . size ( ) ; \nj ++ ) { \nDatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; \ndssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; \n} \n} \nreturn ( dssElem ) ; \n} \n} \n"}
{"4507": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetNamerElement ( DatasetNamer dsNamer ) { \nElement dsnElem = new Element ( \"datasetNamer\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsNamer != null ) { \nif ( dsNamer . getName ( ) != null ) dsnElem . setAttribute ( \"name\" , dsNamer . getName ( ) ) ; \ndsnElem . setAttribute ( \"addLevel\" , Boolean . toString ( dsNamer . getAddLevel ( ) ) ) ; \nif ( dsNamer . getType ( ) != null ) dsnElem . setAttribute ( \"type\" , dsNamer . getType ( ) . toString ( ) ) ; \nif ( dsNamer . getMatchPattern ( ) != null ) dsnElem . setAttribute ( \"matchPattern\" , dsNamer . getMatchPattern ( ) ) ; \nif ( dsNamer . getSubstitutePattern ( ) != null ) dsnElem . setAttribute ( \"substitutePattern\" , dsNamer . getSubstitutePattern ( ) ) ; \nif ( dsNamer . getAttribContainer ( ) != null ) dsnElem . setAttribute ( \"attribContainer\" , dsNamer . getAttribContainer ( ) ) ; \nif ( dsNamer . getAttribName ( ) != null ) dsnElem . setAttribute ( \"attribName\" , dsNamer . getAttribName ( ) ) ; \n} \nreturn ( dsnElem ) ; \n} \n} \n"}
{"4508": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetFilterElement ( DatasetFilter dsFilter ) { \nElement dsfElem = new Element ( \"datasetFilter\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsFilter != null ) { \nif ( dsFilter . getName ( ) != null ) dsfElem . setAttribute ( \"name\" , dsFilter . getName ( ) ) ; \nif ( dsFilter . getType ( ) != null ) dsfElem . setAttribute ( \"type\" , dsFilter . getType ( ) . toString ( ) ) ; \nif ( dsFilter . getMatchPattern ( ) != null ) dsfElem . setAttribute ( \"matchPattern\" , dsFilter . getMatchPattern ( ) ) ; \nif ( dsFilter . getMatchPatternTarget ( ) != null ) dsfElem . setAttribute ( \"matchPatternTarget\" , dsFilter . getMatchPatternTarget ( ) ) ; \ndsfElem . setAttribute ( \"applyToCollectionDatasets\" , String . valueOf ( dsFilter . isApplyToCollectionDatasets ( ) ) ) ; \ndsfElem . setAttribute ( \"applyToAtomicDatasets\" , String . valueOf ( dsFilter . isApplyToAtomicDatasets ( ) ) ) ; \ndsfElem . setAttribute ( \"rejectMatchingDatasets\" , String . valueOf ( dsFilter . isRejectMatchingDatasets ( ) ) ) ; \n} \nreturn ( dsfElem ) ; \n} \n} \n"}
{"4509": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createResultServiceElement ( ResultService resultService ) { \nElement rsElem = new Element ( \"resultService\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( resultService != null ) { \nif ( resultService . getName ( ) != null ) rsElem . setAttribute ( \"name\" , resultService . getName ( ) ) ; \nif ( resultService . getServiceType ( ) != null ) rsElem . setAttribute ( \"serviceType\" , resultService . getServiceType ( ) . toString ( ) ) ; \nif ( resultService . getBase ( ) != null ) rsElem . setAttribute ( \"base\" , resultService . getBase ( ) ) ; \nif ( resultService . getSuffix ( ) != null ) rsElem . setAttribute ( \"suffix\" , resultService . getSuffix ( ) ) ; \nif ( resultService . getAccessPointHeader ( ) != null ) rsElem . setAttribute ( \"accessPointHeader\" , resultService . getAccessPointHeader ( ) ) ; \n} \nreturn ( rsElem ) ; \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) return false ; \nNamePart np = partit ( flagName ) ; \nif ( debug ) try { \nif ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) System . out . println ( \"Debug.isSet create node = \" + flagName + \" \" + np ) ; \nelse if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . println ( \"Debug.isSet create flag = \" + flagName + \" \" + np ) ; \n} \ncatch ( BackingStoreException e ) { \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) throw new IOException ( \"Unable to open \" + tbl ) ; \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) continue ; \nif ( tline . startsWith ( \"!\" ) ) continue ; \nString [ ] words = new String [ indices . length ] ; \nfor ( int idx = 0 ; \nidx < indices . length ; \nidx ++ ) { \nif ( indices [ idx ] >= tline . length ( ) ) continue ; \nif ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) words [ idx ] = line . substring ( indices [ idx ] ) ; \nelse words [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \nwords [ idx ] = words [ idx ] . trim ( ) ; \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) if ( p . getName ( ) . contains ( \"(\" ) ) templateParamMap . put ( p . getName ( ) , p ) ; \nelse paramMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nint num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) num = ( int ) Double . parseDouble ( words [ 0 ] ) ; \nif ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( \"\" ) ) return null ; \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nint first = name . indexOf ( \"-\" ) ; \nint last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \nfor ( int i = first ; \ni <= last ; \ni ++ ) buf . append ( \"\\\\d\" ) ; \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) description = words [ 3 ] ; \nelse description = words [ 1 ] ; \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) unit = \"\" ; \n} \nint decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4515": "public class GempakParameterTable { \npublic GempakParameter getParameter ( String name ) { \nGempakParameter param = paramMap . get ( name ) ; \nif ( param == null ) { \nSet < String > keys = templateParamMap . keySet ( ) ; \nif ( ! keys . isEmpty ( ) ) for ( String key : keys ) { \nPattern p = Pattern . compile ( key ) ; \nMatcher m = p . matcher ( name ) ; \nif ( m . matches ( ) ) { \nString value = m . group ( 1 ) ; \nGempakParameter match = templateParamMap . get ( key ) ; \nparam = new GempakParameter ( match . getNumber ( ) , name , match . getDescription ( ) + \" (\" + value + \" hour)\" , match . getUnit ( ) , match . getDecimalScale ( ) ) ; \nparamMap . put ( name , param ) ; \nbreak ; \n} \n} \n} \nreturn param ; \n} \n} \n"}
{"4517": "public class GempakParameterTable { \nprivate byte [ ] readBytes ( InputStream is ) throws IOException { \nint totalRead = 0 ; \nbyte [ ] content = new byte [ 1000000 ] ; \nwhile ( true ) { \nint howMany = is . read ( content , totalRead , content . length - totalRead ) ; \nif ( howMany < 0 ) break ; \nif ( howMany == 0 ) continue ; \ntotalRead += howMany ; \nif ( totalRead >= content . length ) { \nbyte [ ] tmp = content ; \nint newLength = ( ( content . length < 25000000 ) ? content . length * 2 : content . length + 5000000 ) ; \ncontent = new byte [ newLength ] ; \nSystem . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; \n} \n} \nis . close ( ) ; \nbyte [ ] results = new byte [ totalRead ] ; \nSystem . arraycopy ( content , 0 , results , 0 , totalRead ) ; \nreturn results ; \n} \n} \n"}
{"4522": "public class Grib2SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( bitMapIndicator == 255 ) return null ; \nif ( bitMapIndicator == 254 ) logger . debug ( \"HEY bitMapIndicator=254 previously defined bitmap\" ) ; \nif ( bitMapIndicator != 0 ) throw new UnsupportedOperationException ( \"Grib2 Bit map section pre-defined (provided by center) = \" + bitMapIndicator ) ; \nraf . seek ( startingPosition ) ; \nint length = GribNumbers . int4 ( raf ) ; \nraf . skipBytes ( 2 ) ; \nbyte [ ] data = new byte [ length - 6 ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( slashpos < 0 && dotpos < 0 ) pieces . name = name ; \nelse if ( slashpos >= 0 && dotpos < 0 ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos < 0 && dotpos >= 0 ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4529": "public class DODSNetcdfFile { \nList < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { \nif ( group == null ) group = rootGroup ; \nList < Dimension > dims = new ArrayList < Dimension > ( ) ; \nEnumeration enumerate = dodsArray . getDimensions ( ) ; \nwhile ( enumerate . hasMoreElements ( ) ) { \nopendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; \nString name = dad . getEncodedName ( ) ; \nif ( name != null ) name = StringUtil2 . unescape ( name ) ; \nDimension myd ; \nif ( name == null ) myd = new Dimension ( null , dad . getSize ( ) , false ) ; \nelse { \nif ( RC . getUseGroups ( ) ) if ( name . indexOf ( '/' ) >= 0 ) { \ngroup = group . makeRelativeGroup ( this , name , true ) ; \nname = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; \n} \nmyd = group . findDimension ( name ) ; \nif ( myd == null ) { \nmyd = new Dimension ( name , dad . getSize ( ) ) ; \ngroup . addDimension ( myd ) ; \n} \nelse if ( myd . getLength ( ) != dad . getSize ( ) ) myd = new Dimension ( name , dad . getSize ( ) , false ) ; \n} \ndims . add ( myd ) ; \n} \nreturn dims ; \n} \n} \n"}
{"4538": "public class IospHelper { \nstatic public Object makePrimitiveArray ( int size , DataType dataType ) { \nObject arr = null ; \nif ( ( dataType . getPrimitiveClassType ( ) == byte . class ) || ( dataType == DataType . CHAR ) || ( dataType == DataType . OPAQUE ) || ( dataType == DataType . STRUCTURE ) ) arr = new byte [ size ] ; \nelse if ( dataType . getPrimitiveClassType ( ) == short . class ) arr = new short [ size ] ; \nelse if ( dataType . getPrimitiveClassType ( ) == int . class ) arr = new int [ size ] ; \nelse if ( dataType . getPrimitiveClassType ( ) == long . class ) arr = new long [ size ] ; \nelse if ( dataType == DataType . FLOAT ) arr = new float [ size ] ; \nelse if ( dataType == DataType . DOUBLE ) arr = new double [ size ] ; \nelse if ( dataType == DataType . STRING ) arr = new String [ size ] ; \nreturn arr ; \n} \n} \n"}
{"4549": "public class CrawlableDatasetFactory { \npublic static CrawlableDataset createCrawlableDataset ( String path , String className , Object configObj ) throws IOException , ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException , IllegalArgumentException , NullPointerException { \nif ( path == null ) throw new NullPointerException ( \"Given path must not be null.\" ) ; \nString tmpClassName = ( className == null ? defaultClassName : className ) ; \nClass crDsClass = Class . forName ( tmpClassName ) ; \nif ( ! CrawlableDataset . class . isAssignableFrom ( crDsClass ) ) throw new IllegalArgumentException ( \"Requested class <\" + className + \"> not an implementation of thredds.crawlabledataset.CrawlableDataset.\" ) ; \nClass [ ] argTypes = { \nString . class , Object . class } \n; \nObject [ ] args = { \npath , configObj } \n; \nConstructor constructor = crDsClass . getDeclaredConstructor ( argTypes ) ; \ntry { \nreturn ( CrawlableDataset ) constructor . newInstance ( args ) ; \n} \ncatch ( InvocationTargetException e ) { \nif ( IOException . class . isAssignableFrom ( e . getCause ( ) . getClass ( ) ) ) throw ( IOException ) e . getCause ( ) ; \nelse throw e ; \n} \n} \n} \n"}
{"4554": "public class Aggregation { \nprotected void makeDatasets ( CancelTask cancelTask ) throws IOException { \ndatasets = new ArrayList < > ( ) ; \nfor ( MFile cd : datasetManager . getFilesSorted ( ) ) { \ndatasets . add ( makeDataset ( cd ) ) ; \n} \nCollections . sort ( datasets ) ; \nfor ( Aggregation . Dataset dataset : explicitDatasets ) { \ndatasets . add ( dataset ) ; \n} \nfor ( Iterator < Dataset > datasetsIter = datasets . iterator ( ) ; \ndatasetsIter . hasNext ( ) ; \n) { \nDataset dataset = datasetsIter . next ( ) ; \nPath datasetPath ; \nif ( dataset . getMFile ( ) instanceof MFileOS ) datasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; \nelse if ( dataset . getMFile ( ) instanceof MFileOS7 ) datasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; \nelse continue ; \nif ( ! Files . isReadable ( datasetPath ) ) { \nlogger . warn ( \"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath ) ; \ndatasetsIter . remove ( ) ; \n} \n} \nSet < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; \nfor ( Aggregation . Dataset dataset : datasets ) { \nif ( dset . contains ( dataset . cacheLocation ) ) logger . warn ( \"Duplicate dataset in aggregation = \" + dataset . cacheLocation ) ; \ndset . add ( dataset . cacheLocation ) ; \n} \nif ( datasets . size ( ) == 0 ) throw new IllegalStateException ( \"There are no datasets in the aggregation \" + datasetManager ) ; \n} \n} \n"}
{"4558": "public class CFLine { \npublic void addPoint ( double x , double y ) { \nPoint ptPrev = null ; \nif ( points . size ( ) > 0 ) ptPrev = points . get ( points . size ( ) - 1 ) ; \nthis . points . add ( new CFPoint ( x , y , ptPrev , null , null ) ) ; \n} \n} \n"}
{"4559": "public class CFLine { \npublic double [ ] getBBUpper ( ) { \ndouble [ ] bbUpper = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) return null ; \nbbUpper [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbUpper [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( bbUpper [ 0 ] < pt . getX ( ) ) bbUpper [ 0 ] = pt . getX ( ) ; \nif ( bbUpper [ 1 ] < pt . getY ( ) ) bbUpper [ 1 ] = pt . getY ( ) ; \n} \nbbUpper [ 0 ] += 10 ; \nbbUpper [ 1 ] += 10 ; \nreturn bbUpper ; \n} \n} \n"}
{"4560": "public class CFLine { \npublic double [ ] getBBLower ( ) { \ndouble [ ] bbLower = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) return null ; \nbbLower [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbLower [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( bbLower [ 0 ] > pt . getX ( ) ) bbLower [ 0 ] = pt . getX ( ) ; \nif ( bbLower [ 1 ] > pt . getY ( ) ) bbLower [ 1 ] = pt . getY ( ) ; \n} \nbbLower [ 0 ] -= 10 ; \nbbLower [ 1 ] -= 10 ; \nreturn bbLower ; \n} \n} \n"}
{"4561": "public class DatasetFilter { \nboolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( this . log . length ( ) > 0 ) out . append ( this . log ) ; \nif ( this . getName ( ) == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (4): null value for name is not valid.\" ) ; \n} \nif ( this . getType ( ) == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (5): null value for type is not valid (set with bad string?).\" ) ; \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION && this . matchPattern == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (6): null value for matchPattern not valid when type is 'RegExp'.\" ) ; \n} \nif ( this . type != DatasetFilter . Type . REGULAR_EXPRESSION && this . type != null && this . matchPattern != null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (7): matchPattern value (\" + this . matchPattern + \") must be null if type is not 'RegExp'.\" ) ; \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"4562": "public class DatasetFilter { \nprivate boolean match ( InvDataset dataset ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) && ! this . applyToCollectionDatasets ) return ( false ) ; \nif ( ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) && ! this . applyToAtomicDatasets ) return ( false ) ; \nif ( this . matchPatternTarget == null ) if ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) this . setMatchPatternTarget ( \"name\" ) ; \nelse this . setMatchPatternTarget ( \"urlPath\" ) ; \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { \nboolean isMatch ; \nif ( this . getMatchPatternTarget ( ) . equals ( \"name\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse if ( this . getMatchPatternTarget ( ) . equals ( \"urlPath\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse isMatch = false ; \nreturn ( isMatch ) ; \n} \nelse { \nSystem . err . println ( \"WARNING -- DatasetFilter.accept(): unsupported type\" + \" <\" + this . type . toString ( ) + \">.\" ) ; \nreturn ( false ) ; \n} \n} \n} \n"}
{"4565": "public class CEEvaluator { \npublic boolean evalClauses ( Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nboolean result = true ; \nEnumeration ec = getClauses ( ) ; \nwhile ( ec . hasMoreElements ( ) && result == true ) { \nObject o = ec . nextElement ( ) ; \nif ( _Debug ) System . out . println ( \"Evaluating clause: \" + ec . nextElement ( ) ) ; \nresult = ( ( TopLevelClause ) o ) . evaluate ( ) ; \n} \nreturn ( result ) ; \n} \n} \n"}
{"4567": "public class HdfEos { \nstatic public boolean amendFromODL ( NetcdfFile ncfile , Group eosGroup ) throws IOException { \nString smeta = getStructMetadata ( eosGroup ) ; \nif ( smeta == null ) return false ; \nHdfEos fixer = new HdfEos ( ) ; \nfixer . fixAttributes ( ncfile . getRootGroup ( ) ) ; \nfixer . amendFromODL ( ncfile , smeta ) ; \nreturn true ; \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) return ; \nIterator < Element > iter = values . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) iter . remove ( ) ; \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) dim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) log . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \n} \n"}
{"4569": "public class HdfEos { \nprivate Dimension checkUnknownDims ( String wantDim , List < Dimension > unknownDims , Dimension oldDim , String location ) { \nfor ( Dimension dim : unknownDims ) { \nif ( dim . getShortName ( ) . equals ( wantDim ) ) { \nint len = oldDim . getLength ( ) ; \nif ( len == 0 ) dim . setUnlimited ( true ) ; \ndim . setLength ( len ) ; \nGroup parent = dim . getGroup ( ) ; \nparent . addDimensionIfNotExists ( dim ) ; \nunknownDims . remove ( dim ) ; \nlog . warn ( \"unknownDim {} length set to {}{}\" , wantDim , oldDim . getLength ( ) , location ) ; \nreturn dim ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4570": "public class HdfEos { \nprivate Group findGroupNested ( Group parent , String name ) { \nfor ( Group g : parent . getGroups ( ) ) { \nif ( g . getShortName ( ) . equals ( name ) ) return g ; \n} \nfor ( Group g : parent . getGroups ( ) ) { \nGroup result = findGroupNested ( g , name ) ; \nif ( result != null ) return result ; \n} \nreturn null ; \n} \n} \n"}
{"4580": "public class RadialCoordSys { \npublic double getMaximumRadial ( ) { \nif ( maxRadial == 0.0 ) try { \nArray radialData = getRadialAxisDataCached ( ) ; \nmaxRadial = MAMath . getMaximum ( radialData ) ; \nString units = getRadialAxis ( ) . getUnitsString ( ) ; \nSimpleUnit radialUnit = SimpleUnit . factory ( units ) ; \nmaxRadial = radialUnit . convertTo ( maxRadial , SimpleUnit . kmUnit ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \nreturn maxRadial ; \n} \n} \n"}
{"4582": "public class GEOSTransform { \npublic double [ ] earthToSat ( double geographic_lon , double geographic_lat ) { \ngeographic_lat = geographic_lat * DEG_TO_RAD ; \ngeographic_lon = geographic_lon * DEG_TO_RAD ; \ndouble geocentric_lat = Math . atan ( ( ( r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . tan ( geographic_lat ) ) ; \ndouble r_earth = r_pol / Math . sqrt ( 1.0 - ( ( r_eq * r_eq - r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . cos ( geocentric_lat ) * Math . cos ( geocentric_lat ) ) ; \ndouble r_1 = h - r_earth * Math . cos ( geocentric_lat ) * Math . cos ( geographic_lon - sub_lon ) ; \ndouble r_2 = - r_earth * Math . cos ( geocentric_lat ) * Math . sin ( geographic_lon - sub_lon ) ; \ndouble r_3 = r_earth * Math . sin ( geocentric_lat ) ; \nif ( r_1 > h ) return new double [ ] { \nDouble . NaN , Double . NaN } \n; \ndouble lamda_sat = Double . NaN ; \ndouble theta_sat = Double . NaN ; \nif ( scan_geom . equals ( GEOS ) ) { \nlamda_sat = Math . atan ( - r_2 / r_1 ) ; \ntheta_sat = Math . asin ( r_3 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \n} \nelse if ( scan_geom . equals ( GOES ) ) { \nlamda_sat = Math . asin ( - r_2 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \ntheta_sat = Math . atan ( r_3 / r_1 ) ; \n} \nreturn new double [ ] { \nlamda_sat , theta_sat } \n; \n} \n} \n"}
{"4583": "public class GEOSTransform { \npublic double [ ] satToEarth ( double x , double y ) { \nif ( scan_geom . equals ( GOES ) ) { \ndouble [ ] lambda_theta_geos = GOES_to_GEOS ( x , y ) ; \nx = lambda_theta_geos [ 0 ] ; \ny = lambda_theta_geos [ 1 ] ; \n} \ndouble c1 = ( h * Math . cos ( x ) * Math . cos ( y ) ) * ( h * Math . cos ( x ) * Math . cos ( y ) ) ; \ndouble c2 = ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) * d ; \nif ( c1 < c2 ) return new double [ ] { \nDouble . NaN , Double . NaN } \n; \ndouble s_d = Math . sqrt ( c1 - c2 ) ; \ndouble s_n = ( h * Math . cos ( x ) * Math . cos ( y ) - s_d ) / ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) ; \ndouble s_1 = h - s_n * Math . cos ( x ) * Math . cos ( y ) ; \ndouble s_2 = s_n * Math . sin ( x ) * Math . cos ( y ) ; \ndouble s_3 = - s_n * Math . sin ( y ) ; \ndouble s_xy = Math . sqrt ( s_1 * s_1 + s_2 * s_2 ) ; \ndouble geographic_lon = Math . atan ( s_2 / s_1 ) + sub_lon ; \ndouble geographic_lat = Math . atan ( - fp * ( s_3 / s_xy ) ) ; \ndouble lonDegrees = RAD_TO_DEG * geographic_lon ; \ndouble latDegrees = RAD_TO_DEG * geographic_lat ; \nif ( lonDegrees < - 180.0 ) lonDegrees += 360.0 ; \nif ( lonDegrees > 180.0 ) lonDegrees -= 360.0 ; \nreturn new double [ ] { \nlonDegrees , latDegrees } \n; \n} \n} \n"}
{"4585": "public class GEOSTransform { \npublic static String scanGeomToSweepAngleAxis ( String scanGeometry ) { \nString sweepAngleAxis = \"y\" ; \nif ( scanGeometry . equals ( GOES ) ) sweepAngleAxis = \"x\" ; \nreturn sweepAngleAxis ; \n} \n} \n"}
{"4586": "public class GEOSTransform { \npublic static String sweepAngleAxisToScanGeom ( String sweepAngleAxis ) { \nString scanGeom = GOES ; \nif ( sweepAngleAxis . equals ( \"y\" ) ) scanGeom = GEOS ; \nreturn scanGeom ; \n} \n} \n"}
{"4601": "public class WRFEta { \nprivate ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { \nint [ ] shape = array . getShape ( ) ; \nint [ ] newShape = new int [ 3 ] ; \nSystem . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; \nnewShape [ dimIndex ] ++ ; \nint ni = newShape [ 0 ] ; \nint nj = newShape [ 1 ] ; \nint nk = newShape [ 2 ] ; \nArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; \nint n = shape [ dimIndex ] ; \ndouble [ ] d = new double [ n ] ; \nint [ ] eshape = new int [ 3 ] ; \nint [ ] neweshape = new int [ 3 ] ; \nfor ( int i = 0 ; \ni < 3 ; \ni ++ ) { \neshape [ i ] = ( i == dimIndex ) ? n : 1 ; \nneweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; \n} \nint [ ] origin = new int [ 3 ] ; \ntry { \nfor ( int i = 0 ; \ni < ( ( dimIndex == 0 ) ? 1 : ni ) ; \ni ++ ) for ( int j = 0 ; \nj < ( ( dimIndex == 1 ) ? 1 : nj ) ; \nj ++ ) for ( int k = 0 ; \nk < ( ( dimIndex == 2 ) ? 1 : nk ) ; \nk ++ ) { \norigin [ 0 ] = i ; \norigin [ 1 ] = j ; \norigin [ 2 ] = k ; \nIndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; \nfor ( int l = 0 ; \nl < n ; \nl ++ ) d [ l ] = it . getDoubleNext ( ) ; \ndouble [ ] d2 = extrapinterpolate ( d ) ; \nIndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; \nfor ( int l = 0 ; \nl < n + 1 ; \nl ++ ) newit . setDoubleNext ( d2 [ l ] ) ; \n} \n} \ncatch ( InvalidRangeException e ) { \nreturn null ; \n} \nreturn newArray ; \n} \n} \n"}
{"4602": "public class WRFEta { \nprivate double [ ] extrapinterpolate ( double [ ] array ) { \nint n = array . length ; \ndouble [ ] d = new double [ n + 1 ] ; \nd [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; \nd [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; \nfor ( int i = 1 ; \ni < n ; \ni ++ ) d [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; \nreturn d ; \n} \n} \n"}
{"4605": "public class GempakStationFileIOSP { \nprotected Structure makeStructure ( String partName , List < Dimension > dimensions , boolean includeMissing ) { \nList < GempakParameter > params = gemreader . getParameters ( partName ) ; \nif ( params == null ) return null ; \nStructure sVar = new Structure ( ncfile , null , null , partName ) ; \nsVar . setDimensions ( dimensions ) ; \nfor ( GempakParameter param : params ) { \nsVar . addMemberVariable ( makeParamVariable ( param , null ) ) ; \n} \nif ( includeMissing ) sVar . addMemberVariable ( makeMissingVariable ( ) ) ; \nreturn sVar ; \n} \n} \n"}
{"4607": "public class GempakStationFileIOSP { \nprotected Variable makeParamVariable ( GempakParameter param , List < Dimension > dims ) { \nVariable var = new Variable ( ncfile , null , null , param . getName ( ) ) ; \nvar . setDataType ( DataType . FLOAT ) ; \nvar . setDimensions ( dims ) ; \nvar . addAttribute ( new Attribute ( CDM . LONG_NAME , param . getDescription ( ) ) ) ; \nString units = param . getUnit ( ) ; \nif ( ( units != null ) && ! units . equals ( \"\" ) ) var . addAttribute ( new Attribute ( CDM . UNITS , units ) ) ; \nvar . addAttribute ( new Attribute ( CDM . MISSING_VALUE , RMISS ) ) ; \nreturn var ; \n} \n} \n"}
{"4609": "public class GempakStationFileIOSP { \nprotected int getStnVarSize ( String name ) { \nint size = - 1 ; \nfor ( int i = 0 ; \ni < stnVarNames . length ; \ni ++ ) if ( name . equals ( stnVarNames [ i ] ) ) { \nsize = stnVarSizes [ i ] ; \nbreak ; \n} \nreturn size ; \n} \n} \n"}
{"4610": "public class GempakStationFileIOSP { \nprivate Array get1DArray ( DataType type , int len ) { \nArray varArray = null ; \nif ( type . equals ( DataType . FLOAT ) ) varArray = new ArrayFloat . D1 ( len ) ; \nelse if ( type . equals ( DataType . DOUBLE ) ) varArray = new ArrayDouble . D1 ( len ) ; \nelse if ( type . equals ( DataType . INT ) ) varArray = new ArrayInt . D1 ( len , false ) ; \nreturn varArray ; \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) if ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nint yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nint yyxbegin = yyn < 0 ? - yyn : 0 ; \nint yychecklim = yylast_ - yyn + 1 ; \nint yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; \nint count = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; \nif ( count < 5 ) { \ncount = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count ++ == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n} \n} \nreturn res . toString ( ) ; \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to read DMR twice\" ) ; \nbyte [ ] dmr8 = null ; \nif ( requestmode == RequestMode . DMR ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nint c ; \nwhile ( ( c = input . read ( ) ) >= 0 ) baos . write ( c ) ; \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nelse if ( requestmode == RequestMode . DAP ) { \nif ( ! readHeader ( input ) ) throw new DapException ( \"Malformed chunk count\" ) ; \ndmr8 = new byte [ this . chunksize ] ; \nint red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( red < this . chunksize ) throw new DapException ( \"Short chunk\" ) ; \n} \nelse assert false : \"Internal error\" ; \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( dmr . endsWith ( \"\\r\\n\" ) ) { \n} \nelse if ( dmr . endsWith ( \"\\n\" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \nelse dmr = dmr + \"\\r\\n\" ; \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; \nelse if ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; \nelse state = State . DATA ; \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; \nif ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nint count = len ; \nint pos = off ; \nwhile ( count > 0 ) if ( avail <= 0 ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nint actual = ( this . avail < count ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) throw new IOException ( \"Unexpected EOF\" ) ; \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \nreturn len ; \n} \n} \n"}
{"4619": "public class TableParser { \nstatic public List < Record > readTable ( String urlString , String format , int maxLines ) throws IOException , NumberFormatException { \nInputStream ios ; \nif ( urlString . startsWith ( \"http:\" ) ) { \nURL url = new URL ( urlString ) ; \nios = url . openStream ( ) ; \n} \nelse ios = new FileInputStream ( urlString ) ; \nreturn readTable ( ios , format , maxLines ) ; \n} \n} \n"}
{"4620": "public class DatasetConstructor { \nstatic private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { \nboolean unlimitedOK = true ; \ntransferGroupAttributes ( src , targetGroup ) ; \nfor ( Dimension d : src . getDimensions ( ) ) { \nif ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { \nDimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; \ntargetGroup . addDimension ( newd ) ; \n} \n} \nfor ( Variable v : src . getVariables ( ) ) { \nVariable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; \nVariableEnhanced targetVe = ( VariableEnhanced ) targetV ; \nboolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; \nif ( replace || ( null == targetV ) ) { \nif ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) v = new StructureDS ( targetGroup , ( Structure ) v ) ; \nelse if ( ! ( v instanceof VariableDS ) ) v = new VariableDS ( targetGroup , v , false ) ; \nif ( null != targetV ) targetGroup . remove ( targetV ) ; \ntargetGroup . addVariable ( v ) ; \nv . resetDimensions ( ) ; \n} \nelse if ( ! targetV . hasCachedData ( ) && ( targetVe . getOriginalVariable ( ) == null ) ) targetVe . setOriginalVariable ( v ) ; \n} \nfor ( Group srcNested : src . getGroups ( ) ) { \nGroup nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; \nif ( null == nested ) { \nnested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; \ntargetGroup . addGroup ( nested ) ; \n} \ntransferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; \n} \n} \n} \n"}
{"4622": "public class IgraPor { \n@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { \nsuper . open ( raff , ncfile , cancelTask ) ; \nint pos = location . lastIndexOf ( \".\" ) ; \nString ext = location . substring ( pos ) ; \nFile file = new File ( location ) ; \nFile stnFile = getStnFile ( location ) ; \nif ( stnFile == null ) throw new FileNotFoundException ( \"Station File does not exist=\" + location ) ; \nif ( ext . equals ( IDX_EXT ) ) stnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \nelse if ( ext . equals ( DAT_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \ndataRaf = raff ; \nString name = file . getName ( ) ; \nstationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; \n} \nelse { \nstnRaf = raff ; \ndataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; \n} \nNcmlConstructor ncmlc = new NcmlConstructor ( ) ; \nif ( ! ncmlc . populateFromResource ( \"resources/nj22/iosp/igra-por.ncml\" , ncfile ) ) throw new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; \nncfile . finish ( ) ; \nstnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , \"station\" ) ; \nseriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , \"station.time_series\" ) ; \nprofileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , \"station.time_series.levels\" ) ; \nStructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; \nStructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; \nstn_fldno = f . fldno ; \n} \n} \n"}
{"4623": "public class SimpleGeometryIndexFinder { \npublic int getBeginning ( int index ) { \nif ( index == ( pastIndex + 1 ) ) return previousEnd + 1 ; \nint newBeginning = 0 ; \nfor ( int i = 0 ; \ni < index ; \ni ++ ) newBeginning += getNodeCount ( i ) ; \npastIndex = index ; \npreviousBegin = newBeginning ; \nreturn newBeginning ; \n} \n} \n"}
{"4624": "public class SimpleGeometryIndexFinder { \npublic int getEnd ( int index ) { \nif ( index == ( pastIndex - 1 ) ) return previousBegin - 1 ; \nint new_end = 0 ; \nfor ( int i = 0 ; \ni < index + 1 ; \ni ++ ) new_end += getNodeCount ( i ) ; \npastIndex = index ; \npreviousEnd = new_end ; \nreturn new_end - 1 ; \n} \n} \n"}
{"4628": "public class Cosmic1Convention { \npublic static double [ ] ECFtoLLA ( double x , double y , double z , double a , double b ) { \ndouble longitude = Math . atan2 ( y , x ) ; \ndouble ePrimeSquared = ( a * a - b * b ) / ( b * b ) ; \ndouble p = Math . sqrt ( x * x + y * y ) ; \ndouble theta = Math . atan ( ( z * a ) / ( p * b ) ) ; \ndouble sineTheta = Math . sin ( theta ) ; \ndouble cosTheta = Math . cos ( theta ) ; \ndouble f = 1 / 298.257223563 ; \ndouble e2 = 2 * f - f * f ; \ndouble top = z + ePrimeSquared * b * sineTheta * sineTheta * sineTheta ; \ndouble bottom = p - e2 * a * cosTheta * cosTheta * cosTheta ; \ndouble geodeticLat = Math . atan ( top / bottom ) ; \ndouble sineLat = Math . sin ( geodeticLat ) ; \ndouble N = a / Math . sqrt ( 1 - e2 * sineLat * sineLat ) ; \ndouble altitude = ( p / Math . cos ( geodeticLat ) ) - N ; \nif ( longitude > Math . PI ) longitude -= 2 * Math . PI ; \nelse if ( longitude < - Math . PI ) longitude += 2 * Math . PI ; \nreturn new double [ ] { \ngeodeticLat , longitude , altitude } \n; \n} \n} \n"}
{"4629": "public class Util { \npublic static String cleanUnit ( String unit ) { \nif ( unit == null ) return null ; \nif ( unit . equalsIgnoreCase ( \"Proportion\" ) || unit . equalsIgnoreCase ( \"Numeric\" ) ) unit = \"\" ; \nelse if ( unit . equalsIgnoreCase ( \"-\" ) ) unit = \"\" ; \nelse if ( unit . startsWith ( \"degree\" ) && unit . endsWith ( \"true\" ) ) unit = unit . replace ( ' ' , '_' ) ; \nelse if ( ! unit . contains ( \" table \" ) ) { \nif ( unit . startsWith ( \"/\" ) ) unit = \"1\" + unit ; \nunit = unit . trim ( ) ; \nunit = StringUtil2 . remove ( unit , \"**\" ) ; \nStringBuilder sb = new StringBuilder ( unit ) ; \nStringUtil2 . remove ( sb , \"^[]\" ) ; \nStringUtil2 . replace ( sb , ' ' , \".\" ) ; \nStringUtil2 . replace ( sb , '*' , \".\" ) ; \nunit = sb . toString ( ) ; \n} \nreturn unit ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) addAttributeTable ( this , attTable , tableName , true ) ; \nelse if ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) continue ; \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) addAttributeTable ( dodsV , attTable , tableName , true ) ; \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) addAttributeTable ( dodsV , attTable , tableName , true ) ; \nelse { \nif ( debugAttributes ) System . out . println ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4642": "public class Variable { \npublic Section getShapeAsSection ( ) { \nif ( shapeAsSection == null ) try { \nList < Range > list = new ArrayList < > ( ) ; \nfor ( Dimension d : dimensions ) { \nint len = d . getLength ( ) ; \nif ( len > 0 ) list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; \nelse if ( len == 0 ) list . add ( Range . EMPTY ) ; \nelse { \nassert d . isVariableLength ( ) ; \nlist . add ( Range . VLEN ) ; \n} \n} \nshapeAsSection = new Section ( list ) . makeImmutable ( ) ; \n} \ncatch ( InvalidRangeException e ) { \nlog . error ( \"Bad shape in variable \" + getFullName ( ) , e ) ; \nthrow new IllegalStateException ( e . getMessage ( ) ) ; \n} \nreturn shapeAsSection ; \n} \n} \n"}
{"4643": "public class Variable { \npublic Variable slice ( int dim , int value ) throws InvalidRangeException { \nif ( ( dim < 0 ) || ( dim >= shape . length ) ) throw new InvalidRangeException ( \"Slice dim invalid= \" + dim ) ; \nboolean recordSliceOk = false ; \nif ( ( dim == 0 ) && ( value == 0 ) ) { \nDimension d = getDimension ( 0 ) ; \nrecordSliceOk = d . isUnlimited ( ) ; \n} \nif ( ! recordSliceOk ) if ( ( value < 0 ) || ( value >= shape [ dim ] ) ) throw new InvalidRangeException ( \"Slice value invalid= \" + value + \" for dimension \" + dim ) ; \nVariable sliceV = copy ( ) ; \nSection slice = new Section ( getShapeAsSection ( ) ) ; \nslice . replaceRange ( dim , new Range ( value , value ) ) . makeImmutable ( ) ; \nsliceV . setProxyReader ( new SliceReader ( this , dim , slice ) ) ; \nsliceV . createNewCache ( ) ; \nsliceV . setCaching ( false ) ; \nsliceV . dimensions . remove ( dim ) ; \nsliceV . resetShape ( ) ; \nreturn sliceV ; \n} \n} \n"}
{"4647": "public class Variable { \nprotected Array _read ( ) throws IOException { \nif ( cache . data != null ) { \nif ( debugCaching ) System . out . println ( \"got data from cache \" + getFullName ( ) ) ; \nreturn cache . data . copy ( ) ; \n} \nArray data = proxyReader . reallyRead ( this , null ) ; \nif ( isCaching ( ) ) { \nsetCachedData ( data ) ; \nif ( debugCaching ) System . out . println ( \"cache \" + getFullName ( ) ) ; \nreturn cache . data . copy ( ) ; \n} \nelse return data ; \n} \n} \n"}
{"4653": "public class Variable { \npublic void resetShape ( ) { \nthis . shape = new int [ dimensions . size ( ) ] ; \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension dim = dimensions . get ( i ) ; \nshape [ i ] = dim . getLength ( ) ; \nif ( dim . isVariableLength ( ) ) isVariableLength = true ; \n} \nthis . shapeAsSection = null ; \n} \n} \n"}
{"4655": "public class Variable { \npublic void resetDimensions ( ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nArrayList < Dimension > newDimensions = new ArrayList < > ( ) ; \nfor ( Dimension dim : dimensions ) { \nif ( dim . isShared ( ) ) { \nDimension newD = getParentGroup ( ) . findDimension ( dim . getShortName ( ) ) ; \nif ( newD == null ) throw new IllegalArgumentException ( \"Variable \" + getFullName ( ) + \" resetDimensions  FAILED, dim doesnt exist in parent group=\" + dim ) ; \nnewDimensions . add ( newD ) ; \n} \nelse newDimensions . add ( dim ) ; \n} \nthis . dimensions = newDimensions ; \nresetShape ( ) ; \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) buildseqtype ( cdmvar ) ; \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \n} \n} \n"}
{"4666": "public class CDMDSP { \nprotected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { \nif ( cdmdims == null || cdmdims . size ( ) == 0 ) return ; \nfor ( Dimension cdmdim : cdmdims ) { \nDapDimension dapdim = null ; \nif ( cdmdim . isShared ( ) ) { \nDimension declareddim = finddimdecl ( cdmdim ) ; \nif ( declareddim == null ) throw new DapException ( \"Unprocessed cdm dimension: \" + cdmdim ) ; \ndapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; \nassert dapdim != null ; \n} \nelse if ( cdmdim . isVariableLength ( ) ) continue ; \nelse dapdim = builddim ( cdmdim ) ; \nassert ( dapdim != null ) : \"Internal error\" ; \ndapvar . addDimension ( dapdim ) ; \n} \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < dimset . size ( ) ; \ni ++ ) if ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount ++ ; \n} \nelse core . add ( dimset . get ( i ) ) ; \nif ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4671": "public class CdmValidatorController { \npublic void doPost ( HttpServletRequest req , HttpServletResponse res ) throws ServletException , IOException { \nlog . info ( \"doPost(): \" + UsageLog . setupRequestContext ( req ) ) ; \nboolean isMultipart = ServletFileUpload . isMultipartContent ( req ) ; \nif ( ! isMultipart ) { \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nServletFileUpload upload = new ServletFileUpload ( this . cdmValidatorContext . getFileuploadFileItemFactory ( ) ) ; \nupload . setSizeMax ( this . cdmValidatorContext . getMaxFileUploadSize ( ) ) ; \nList < FileItem > fileItems ; \ntry { \nfileItems = ( List < FileItem > ) upload . parseRequest ( req ) ; \n} \ncatch ( FileUploadException e ) { \nlog . info ( \"doPost(): Validator FileUploadException\" , e ) ; \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nif ( ! res . isCommitted ( ) ) res . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nString username = null ; \nboolean wantXml = false ; \nfor ( FileItem item : fileItems ) { \nif ( item . isFormField ( ) ) { \nif ( \"username\" . equals ( item . getFieldName ( ) ) ) username = item . getString ( ) ; \nif ( \"xml\" . equals ( item . getFieldName ( ) ) ) wantXml = item . getString ( ) . equals ( \"true\" ) ; \n} \n} \nfor ( FileItem item : fileItems ) { \nif ( ! item . isFormField ( ) ) try { \nprocessUploadedFile ( req , res , ( DiskFileItem ) item , username , wantXml ) ; \nreturn ; \n} \ncatch ( Exception e ) { \nlog . info ( \"doPost(): Validator processUploadedFile\" , e ) ; \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST , e . getMessage ( ) ) ; \n} \n} \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( int i = 0 ; \ni < m . groupCount ( ) ; \ni ++ ) System . out . println ( \" \" + i + \" \" + m . group ( i ) ) ; \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4695": "public class GempakLookup { \npublic final boolean isPositiveUp ( GridRecord gr ) { \nint type = gr . getLevelType1 ( ) ; \nif ( ( type == 1 ) || ( type == 5 ) ) return false ; \nreturn true ; \n} \n} \n"}
{"4697": "public class UnitImpl { \npublic String makeLabel ( final String quantityID ) { \nfinal StringBuilder buf = new StringBuilder ( quantityID ) ; \nif ( quantityID . contains ( \" \" ) ) buf . insert ( 0 , '(' ) . append ( ')' ) ; \nbuf . append ( '/' ) ; \nfinal int start = buf . length ( ) ; \nbuf . append ( toString ( ) ) ; \nif ( buf . substring ( start ) . indexOf ( ' ' ) != - 1 ) buf . insert ( start , '(' ) . append ( ')' ) ; \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) throw new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) throw new InvalidCredentialsException ( method . getStatusText ( ) ) ; \nif ( statusCode != HttpStatus . SC_OK ) throw new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse if ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4702": "public class DConnect2 { \npublic DAS getDAS ( ) throws IOException , DAP2Exception { \nDASCommand command = new DASCommand ( ) ; \nif ( filePath != null ) { \nFile daspath = new File ( filePath + \".das\" ) ; \nif ( daspath . canRead ( ) ) try ( FileInputStream is = new FileInputStream ( daspath ) ) { \ncommand . process ( is ) ; \n} \n} \nelse if ( stream != null ) command . process ( stream ) ; \nelse try { \nopenConnection ( urlString + \".das\" + getCompleteCE ( projString , selString ) , command ) ; \n} \ncatch ( DAP2Exception de ) { \n} \nreturn command . das ; \n} \n} \n"}
{"4703": "public class DConnect2 { \npublic DDS getDDS ( String CE ) throws IOException , ParseException , DAP2Exception { \nDDSCommand command = new DDSCommand ( ) ; \ncommand . setURL ( CE == null || CE . length ( ) == 0 ? urlString : urlString + \"?\" + CE ) ; \nif ( filePath != null ) try ( FileInputStream is = new FileInputStream ( filePath + \".dds\" ) ) { \ncommand . process ( is ) ; \n} \nelse if ( stream != null ) command . process ( stream ) ; \nelse openConnection ( urlString + \".dds\" + ( getCompleteCE ( CE ) ) , command ) ; \nreturn command . dds ; \n} \n} \n"}
{"4705": "public class Sinusoidal { \n@ Override public LatLonPoint projToLatLon ( ProjectionPoint world , LatLonPointImpl result ) { \ndouble fromX = world . getX ( ) - falseEasting ; \ndouble fromY = world . getY ( ) - falseNorthing ; \ndouble toLat_r = fromY / earthRadius ; \ndouble toLon_r ; \nif ( Misc . nearlyEquals ( Math . abs ( toLat_r ) , PI_OVER_2 , 1e-10 ) ) { \ntoLat_r = toLat_r < 0 ? - PI_OVER_2 : + PI_OVER_2 ; \ntoLon_r = Math . toRadians ( centMeridian ) ; \n} \nelse if ( Math . abs ( toLat_r ) < PI_OVER_2 ) toLon_r = Math . toRadians ( centMeridian ) + fromX / ( earthRadius * Math . cos ( toLat_r ) ) ; \nelse return INVALID ; \nif ( Misc . nearlyEquals ( Math . abs ( toLon_r ) , PI , 1e-10 ) ) toLon_r = toLon_r < 0 ? - PI : + PI ; \nelse if ( Math . abs ( toLon_r ) > PI ) return INVALID ; \nresult . setLatitude ( Math . toDegrees ( toLat_r ) ) ; \nresult . setLongitude ( Math . toDegrees ( toLon_r ) ) ; \nreturn result ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \ni < utf8 . length ; \n) { \nbyte b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) out [ index8 ++ ] = blank ; \nelse if ( b == escape8 ) if ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4716": "public class Escape { \npublic static String backslashDecode ( String s ) { \nStringBuilder buf = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( i < buf . length ( ) ) { \nif ( buf . charAt ( i ) == '\\\\' ) buf . deleteCharAt ( i ) ; \ni ++ ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4720": "public class Swap { \nstatic public int swapInt ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy += 8 , i ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; \nreturn accum ; \n} \n} \n"}
{"4724": "public class Swap { \nstatic public byte [ ] shortToBytes ( short v ) { \nbyte [ ] b = new byte [ 2 ] ; \nint allbits = 255 ; \nfor ( int i = 0 ; \ni < 2 ; \ni ++ ) b [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \nreturn b ; \n} \n} \n"}
{"4725": "public class Swap { \nstatic public byte [ ] intToBytes ( int v ) { \nbyte [ ] b = new byte [ 4 ] ; \nint allbits = 255 ; \nfor ( int i = 0 ; \ni < 4 ; \ni ++ ) b [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \nreturn b ; \n} \n} \n"}
{"4726": "public class Swap { \nstatic public byte [ ] longToBytes ( long v ) { \nbyte [ ] b = new byte [ 8 ] ; \nlong allbits = 255 ; \nfor ( int i = 0 ; \ni < 8 ; \ni ++ ) b [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \nreturn b ; \n} \n} \n"}
{"4732": "public class GridCoordSys { \nvoid addLevels ( List < GridRecord > records ) { \nfor ( GridRecord record : records ) { \nDouble d = new Double ( record . getLevel1 ( ) ) ; \nif ( ! levels . contains ( d ) ) levels . add ( d ) ; \nif ( dontUseVertical && ( levels . size ( ) > 1 ) ) if ( GridServiceProvider . debugVert ) System . out . println ( \"GribCoordSys: unused level coordinate has > 1 levels = \" + verticalName + \" \" + record . getLevelType1 ( ) + \" \" + levels . size ( ) ) ; \n} \nCollections . sort ( levels ) ; \nif ( positive . equals ( \"down\" ) ) Collections . reverse ( levels ) ; \n} \n} \n"}
{"4733": "public class GridCoordSys { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) return ; \nint nlevs = levels . size ( ) ; \nncfile . addDimension ( g , new Dimension ( verticalName , nlevs , true ) ) ; \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) return ; \nif ( g == null ) g = ncfile . getRootGroup ( ) ; \nString dims = \"time\" ; \nif ( ! dontUseVertical ) dims = dims + \" \" + verticalName ; \nif ( hcs . isLatLon ( ) ) dims = dims + \" lat lon\" ; \nelse dims = dims + \" y x\" ; \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) v . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) axisType = AxisType . Pressure ; \nelse if ( SimpleUnit . isCompatible ( \"m\" , units ) ) axisType = AxisType . Height ; \nelse axisType = AxisType . GeoZ ; \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) v . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) findCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n"}
{"4735": "public class GridCoordSys { \nvoid findCoordinateTransform ( Group g , String nameStartsWith , int levelType ) { \nList < Variable > vars = g . getVariables ( ) ; \nfor ( Variable v : vars ) { \nif ( v . getShortName ( ) . equals ( nameStartsWith ) ) { \nAttribute att = v . findAttribute ( \"grid_level_type\" ) ; \nif ( ( att == null ) || ( att . getNumericValue ( ) . intValue ( ) != levelType ) ) continue ; \nv . addAttribute ( new Attribute ( _Coordinate . TransformType , \"Vertical\" ) ) ; \nv . addAttribute ( new Attribute ( \"transform_name\" , \"Existing3DField\" ) ) ; \n} \n} \n} \n} \n"}
{"4738": "public class DiskCache2 { \npublic File getFile ( String fileLocation ) { \nif ( ! alwaysUseCache ) { \nFile f = new File ( fileLocation ) ; \nif ( f . exists ( ) ) return f ; \nif ( canWrite ( f ) ) return f ; \n} \nif ( neverUseCache ) throw new IllegalStateException ( \"neverUseCache=true, but file does not exist and directory is not writeable =\" + fileLocation ) ; \nFile f = new File ( makeCachePath ( fileLocation ) ) ; \nif ( cachePathPolicy == CachePathPolicy . NestedDirectory ) { \nFile dir = f . getParentFile ( ) ; \nif ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) cacheLog . warn ( \"Cant create directories for file \" + dir . getPath ( ) ) ; \n} \nreturn f ; \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) throw new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \nif ( ! isRoot && ( files . length == 0 ) ) { \nlong duration = now - dir . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \nreturn ; \n} \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) cleanCache ( file , sbuff , false ) ; \nelse { \nlong duration = now - file . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"4748": "public class SourcePicture { \npublic void loadPictureInThread ( URL imageUrl , int priority , double rotation ) { \nif ( pictureStatusCode == LOADING ) stopLoadingExcept ( imageUrl ) ; \nthis . imageUrl = imageUrl ; \nthis . rotation = rotation ; \nLoadThread t = new LoadThread ( this ) ; \nt . setPriority ( priority ) ; \nt . start ( ) ; \n} \n} \n"}
{"4749": "public class SourcePicture { \npublic void loadPicture ( URL imageUrl , double rotation ) { \nif ( pictureStatusCode == LOADING ) stopLoadingExcept ( imageUrl ) ; \nthis . imageUrl = imageUrl ; \nthis . rotation = rotation ; \nloadPicture ( ) ; \n} \n} \n"}
{"4750": "public class SourcePicture { \npublic void loadPicture ( ) { \nTools . log ( \"SourcePicture.loadPicture: \" + imageUrl . toString ( ) + \" loaded into SourcePicture object: \" + Integer . toString ( this . hashCode ( ) ) ) ; \nsetStatus ( LOADING , \"Loading: \" + imageUrl . toString ( ) ) ; \nabortFlag = false ; \ntry { \nImageInputStream iis = ImageIO . createImageInputStream ( imageUrl . openStream ( ) ) ; \nIterator i = ImageIO . getImageReaders ( iis ) ; \nif ( ! i . hasNext ( ) ) throw new IOException ( \"No Readers Available!\" ) ; \nreader = ( ImageReader ) i . next ( ) ; \nreader . addIIOReadProgressListener ( imageProgressListener ) ; \nreader . setInput ( iis ) ; \nsourcePictureBufferedImage = null ; \nsourcePictureBufferedImage = reader . read ( 0 ) ; \niis . close ( ) ; \nreader . removeIIOReadProgressListener ( imageProgressListener ) ; \nreader . dispose ( ) ; \nif ( ! abortFlag ) { \nif ( rotation != 0 ) { \nsetStatus ( ROTATING , \"Rotating: \" + imageUrl . toString ( ) ) ; \nint xRot = sourcePictureBufferedImage . getWidth ( ) / 2 ; \nint yRot = sourcePictureBufferedImage . getHeight ( ) / 2 ; \nAffineTransform rotateAf = AffineTransform . getRotateInstance ( Math . toRadians ( rotation ) , xRot , yRot ) ; \nAffineTransformOp op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nRectangle2D newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \ndouble minX = newBounds . getMinX ( ) ; \ndouble minY = newBounds . getMinY ( ) ; \nAffineTransform translateAf = AffineTransform . getTranslateInstance ( minX * ( - 1 ) , minY * ( - 1 ) ) ; \nrotateAf . preConcatenate ( translateAf ) ; \nop = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nnewBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \nBufferedImage targetImage = new BufferedImage ( ( int ) newBounds . getWidth ( ) , ( int ) newBounds . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nsourcePictureBufferedImage = op . filter ( sourcePictureBufferedImage , targetImage ) ; \n} \nsetStatus ( READY , \"Loaded: \" + imageUrl . toString ( ) ) ; \nPictureCache . add ( imageUrl , ( SourcePicture ) this . clone ( ) ) ; \n} \nelse { \nsetStatus ( ERROR , \"Aborted: \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \n} \ncatch ( IOException e ) { \nsetStatus ( ERROR , \"Error while reading \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nfor ( int i = 0 ; \ni < nrecords ; \ni ++ ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) for ( int j = 0 ; \nj < nfields ; \nj ++ ) data [ j ] . readRowN ( ds , i ) ; \nelse { \nnrecords -- ; \ni -- ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4762": "public class DbaseFile { \npublic DbaseData getField ( String Name ) { \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) if ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; \nreturn null ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) return null ; \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \nfor ( int i = 0 ; \ni < s . length ; \ni ++ ) dd [ i ] = Double . valueOf ( s [ i ] ) ; \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \nfor ( int i = 0 ; \ni < b . length ; \ni ++ ) if ( b [ i ] ) dd [ i ] = 1 ; \nelse dd [ i ] = 0 ; \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4766": "public class DbaseFile { \npublic String getFieldName ( int i ) { \nif ( i >= nfields || i < 0 ) return null ; \nreturn ( FieldDesc [ i ] . Name ) ; \n} \n} \n"}
{"4767": "public class DbaseFile { \npublic String [ ] getFieldNames ( ) { \nString [ ] s = new String [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) s [ i ] = getFieldName ( i ) ; \nreturn s ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) for ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nelse System . out . println ( ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4772": "public class DapNode { \npublic DapGroup getGroup ( ) { \nif ( this . sort == DapSort . DATASET ) return null ; \nDapNode group = parent ; \nwhile ( group != null ) switch ( group . getSort ( ) ) { \ncase DATASET : case GROUP : return ( DapGroup ) group ; \ndefault : group = group . getParent ( ) ; \nbreak ; \n} \nreturn ( DapGroup ) group ; \n} \n} \n"}
{"4790": "public class NcMLWriter { \npublic Element makeDimensionElement ( Dimension dim ) throws IllegalArgumentException { \nif ( ! dim . isShared ( ) ) throw new IllegalArgumentException ( \"Cannot create private dimension: \" + \"in NcML, <dimension> elements are always shared.\" ) ; \nElement dimElem = new Element ( \"dimension\" , namespace ) ; \ndimElem . setAttribute ( \"name\" , dim . getShortName ( ) ) ; \ndimElem . setAttribute ( \"length\" , Integer . toString ( dim . getLength ( ) ) ) ; \nif ( dim . isUnlimited ( ) ) dimElem . setAttribute ( \"isUnlimited\" , \"true\" ) ; \nreturn dimElem ; \n} \n} \n"}
{"4791": "public class McIDASAreaTransformBuilder { \npublic ProjectionCT makeCoordinateTransform ( AttributeContainer ctv , String units ) { \nint [ ] area = getIntArray ( ctv , McIDASAreaProjection . ATTR_AREADIR ) ; \nint [ ] nav = getIntArray ( ctv , McIDASAreaProjection . ATTR_NAVBLOCK ) ; \nint [ ] aux = null ; \nif ( ctv . findAttributeIgnoreCase ( McIDASAreaProjection . ATTR_AUXBLOCK ) != null ) aux = getIntArray ( ctv , McIDASAreaProjection . ATTR_AUXBLOCK ) ; \nMcIDASAreaProjection proj = new McIDASAreaProjection ( area , nav , aux ) ; \nreturn new ProjectionCT ( ctv . getName ( ) , \"FGDC\" , proj ) ; \n} \n} \n"}
{"4792": "public class McIDASAreaTransformBuilder { \nprivate int [ ] getIntArray ( AttributeContainer ctv , String attName ) { \nAttribute att = ctv . findAttribute ( attName ) ; \nif ( att == null ) throw new IllegalArgumentException ( \"McIDASArea coordTransformVariable \" + ctv . getName ( ) + \" must have \" + attName + \" attribute\" ) ; \nArray arr = att . getValues ( ) ; \nreturn ( int [ ] ) arr . get1DJavaArray ( int . class ) ; \n} \n} \n"}
{"4797": "public class SI { \npublic static synchronized SI instance ( ) throws UnitSystemException { \nif ( si == null ) try { \nsi = new SI ( ) ; \n} \ncatch ( final UnitException e ) { \nthrow new UnitSystemException ( \"Couldn't initialize class SI\" , e ) ; \n} \nreturn si ; \n} \n} \n"}
{"4803": "public class DataFactory { \npublic static void annotate ( Dataset ds , NetcdfDataset ncDataset ) { \nncDataset . setTitle ( ds . getName ( ) ) ; \nncDataset . setId ( ds . getId ( ) ) ; \nfor ( Property p : ds . getProperties ( ) ) { \nString name = p . getName ( ) ; \nif ( null == ncDataset . findGlobalAttribute ( name ) ) ncDataset . addAttribute ( null , new Attribute ( name , p . getValue ( ) ) ) ; \n} \nncDataset . finish ( ) ; \n} \n} \n"}
{"4813": "public class DMRPrinter { \nvoid printXMLAttributes ( DapNode node , CEConstraint ce , int flags ) throws IOException { \nif ( ( flags & PERLINE ) != 0 ) printer . indent ( 2 ) ; \nString name = node . getShortName ( ) ; \nif ( name != null && ( flags & NONAME ) == 0 ) { \nname = node . getShortName ( ) ; \nprintXMLAttribute ( \"name\" , name , flags ) ; \n} \nswitch ( node . getSort ( ) ) { \ncase DATASET : DapDataset dataset = ( DapDataset ) node ; \nprintXMLAttribute ( \"dapVersion\" , dataset . getDapVersion ( ) , flags ) ; \nprintXMLAttribute ( \"dmrVersion\" , dataset . getDMRVersion ( ) , flags ) ; \nprintXMLAttribute ( \"xmlns\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nprintXMLAttribute ( \"xmlns:dap\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nbreak ; \ncase DIMENSION : DapDimension orig = ( DapDimension ) node ; \nif ( orig . isShared ( ) ) { \nDapDimension actual = this . ce . getRedefDim ( orig ) ; \nif ( actual == null ) actual = orig ; \nlong size = actual . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , flags ) ; \n} \nbreak ; \ncase ENUMERATION : printXMLAttribute ( \"basetype\" , ( ( DapEnumeration ) node ) . getBaseType ( ) . getTypeName ( ) , flags ) ; \nbreak ; \ncase VARIABLE : DapVariable var = ( DapVariable ) node ; \nDapType basetype = var . getBaseType ( ) ; \nif ( basetype . isEnumType ( ) ) printXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \nbreak ; \ncase ATTRIBUTE : DapAttribute attr = ( DapAttribute ) node ; \nbasetype = attr . getBaseType ( ) ; \nprintXMLAttribute ( \"type\" , basetype . getTypeName ( ) , flags ) ; \nif ( attr . getBaseType ( ) . isEnumType ( ) ) printXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \nbreak ; \ndefault : break ; \n} \nif ( ! this . testing ) printReserved ( node ) ; \nif ( ( flags & PERLINE ) != 0 ) printer . outdent ( 2 ) ; \n} \n} \n"}
{"4815": "public class DMRPrinter { \nstatic boolean isSpecial ( DapAttribute attr ) { \nif ( attr . getParent ( ) . getSort ( ) == DapSort . DATASET ) for ( String s : GROUPSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) return true ; \n} \nelse if ( attr . getParent ( ) . getSort ( ) == DapSort . VARIABLE ) for ( String s : VARSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( ( dirBlock == null ) || ( ad == null ) ) return ; \nfor ( int i = 1 ; \ni < 14 ; \ni ++ ) { \nif ( i == 7 ) continue ; \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \n} \n} \n} \n"}
{"4819": "public class AreaReader { \nprivate void setNavBlockAttributes ( Variable v ) { \nif ( ( navBlock == null ) || ( ad == null ) ) return ; \nv . addAttribute ( new Attribute ( \"navigation_type\" , McIDASUtil . intBitsToString ( navBlock [ 0 ] ) ) ) ; \n} \n} \n"}
{"4820": "public class AreaReader { \nprivate int getCalType ( String calName ) { \nint calTypeOut = Calibrator . CAL_NONE ; \nif ( calName . trim ( ) . equals ( \"ALB\" ) ) calTypeOut = Calibrator . CAL_ALB ; \nelse if ( calName . trim ( ) . equals ( \"BRIT\" ) ) calTypeOut = Calibrator . CAL_BRIT ; \nelse if ( calName . trim ( ) . equals ( \"RAD\" ) ) calTypeOut = Calibrator . CAL_RAD ; \nelse if ( calName . trim ( ) . equals ( \"RAW\" ) ) calTypeOut = Calibrator . CAL_RAW ; \nelse if ( calName . trim ( ) . equals ( \"TEMP\" ) ) calTypeOut = Calibrator . CAL_TEMP ; \nreturn calTypeOut ; \n} \n} \n"}
{"4821": "public class AreaReader { \nprivate void setCalTypeAttributes ( Variable image , int calType ) { \nString longName = \"image values\" ; \nswitch ( calType ) { \ncase Calibrator . CAL_ALB : longName = \"albedo\" ; \nbreak ; \ncase Calibrator . CAL_BRIT : longName = \"brightness values\" ; \nbreak ; \ncase Calibrator . CAL_TEMP : longName = \"temperature\" ; \nbreak ; \ncase Calibrator . CAL_RAD : longName = \"pixel radiance values\" ; \nbreak ; \ncase Calibrator . CAL_RAW : longName = \"raw image values\" ; \nbreak ; \ndefault : break ; \n} \nimage . addAttribute ( new Attribute ( \"long_name\" , longName ) ) ; \nif ( calUnit != null ) image . addAttribute ( new Attribute ( CDM . UNITS , calUnit ) ) ; \nif ( calScale != 1.f ) image . addAttribute ( new Attribute ( \"scale_factor\" , calScale ) ) ; \n} \n} \n"}
{"4828": "public class CoordsSet { \nprivate CoverageCoordAxis1D findDependent ( CoverageCoordAxis independentAxis , AxisType axisType ) { \nfor ( CoverageCoordAxis axis : axes ) { \nif ( axis . getDependenceType ( ) == CoverageCoordAxis . DependenceType . dependent ) for ( String axisName : axis . dependsOn ) { \nif ( axisName . equalsIgnoreCase ( independentAxis . getName ( ) ) && axis . getAxisType ( ) == axisType ) return ( CoverageCoordAxis1D ) axis ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4830": "public class DSequence { \nprivate void oldDeserialize ( DataInputStream source , ServerVersion sv , StatusUI statusUI ) throws IOException , DataReadException { \ntry { \nfor ( ; \n; \n) deserializeSingle ( source , sv , statusUI ) ; \n} \ncatch ( EOFException e ) { \n} \n} \n} \n"}
{"4844": "public class UnitDBImpl { \npublic void addUnit ( final Unit unit ) throws UnitExistsException , NameException { \nif ( unit . getName ( ) == null ) throw new NameException ( \"Unit name can't be null\" ) ; \naddByName ( unit . getName ( ) , unit ) ; \naddByName ( unit . getPlural ( ) , unit ) ; \naddBySymbol ( unit . getSymbol ( ) , unit ) ; \nunitSet . add ( unit ) ; \n} \n} \n"}
{"4846": "public class UnitDBImpl { \npublic Unit get ( final String id ) { \nUnit unit = getBySymbol ( id ) ; \nif ( unit == null ) unit = getByName ( id ) ; \nreturn unit ; \n} \n} \n"}
{"4847": "public class UnitDBImpl { \nprivate final void addByName ( final String name , final Unit newUnit ) throws UnitExistsException { \nif ( name != null ) addUnique ( nameMap , canonicalize ( name ) , newUnit ) ; \n} \n} \n"}
{"4848": "public class UnitDBImpl { \nprivate final void addBySymbol ( final String symbol , final Unit newUnit ) throws UnitExistsException { \nif ( symbol != null ) addUnique ( symbolMap , symbol , newUnit ) ; \n} \n} \n"}
{"4849": "public class UnitDBImpl { \nprivate static final void addUnique ( final Map < String , Unit > map , final String key , final Unit newUnit ) throws UnitExistsException { \nfinal Unit oldUnit = map . put ( key , newUnit ) ; \nif ( oldUnit != null && ! oldUnit . equals ( newUnit ) ) throw new UnitExistsException ( oldUnit , newUnit ) ; \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( \"parameter name mismatch\" ) ; \nbyte [ ] paramData = rdat . getRawData ( ) ; \nint nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( workingArray != null && workingArray . length == nCells ) values = workingArray ; \nelse values = new float [ nCells ] ; \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) throw new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \nfor ( int cell = 0 ; \ncell < nCells ; \ncell ++ ) switch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \nreturn values ; \n} \n} \n"}
{"4859": "public class ThreddsDataFactory { \npublic static void annotate ( InvDataset ds , NetcdfDataset ncDataset ) { \nncDataset . setTitle ( ds . getName ( ) ) ; \nncDataset . setId ( ds . getID ( ) ) ; \nfor ( InvProperty p : ds . getProperties ( ) ) { \nString name = p . getName ( ) ; \nif ( null == ncDataset . findGlobalAttribute ( name ) ) ncDataset . addAttribute ( null , new Attribute ( name , p . getValue ( ) ) ) ; \n} \nncDataset . finish ( ) ; \n} \n} \n"}
{"4866": "public class H4iosp { \nprivate ucar . ma2 . ArrayStructure readStructureData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException , InvalidRangeException { \nH4header . Vinfo vinfo = ( H4header . Vinfo ) s . getSPobject ( ) ; \nvinfo . setLayoutInfo ( ) ; \nint recsize = vinfo . elemSize ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nH4header . Minfo minfo = ( H4header . Minfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( minfo . offset ) ; \n} \nmembers . setStructureSize ( recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , section . getShape ( ) ) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nif ( ! vinfo . isLinked && ! vinfo . isCompressed ) { \nLayout layout = new LayoutRegular ( vinfo . start , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( raf , layout , DataType . STRUCTURE , result , - 1 , true ) ; \n} \nelse if ( vinfo . isLinked && ! vinfo . isCompressed ) { \nInputStream is = new LinkedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse if ( ! vinfo . isLinked && vinfo . isCompressed ) { \nInputStream is = getCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse if ( vinfo . isLinked && vinfo . isCompressed ) { \nInputStream is = getLinkedCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse throw new IllegalStateException ( ) ; \nreturn structureArray ; \n} \n} \n"}
{"4869": "public class PicturePane { \npublic void zoomToFit ( ) { \nsclPic . setScaleSize ( getSize ( ) ) ; \nif ( sclPic . getStatusCode ( ) == sclPic . LOADED || sclPic . getStatusCode ( ) == sclPic . READY ) sclPic . createScaledPictureInThread ( Thread . MAX_PRIORITY ) ; \n} \n} \n"}
{"4870": "public class PicturePane { \npublic void paintComponent ( Graphics g ) { \nint WindowWidth = getSize ( ) . width ; \nint WindowHeight = getSize ( ) . height ; \nTools . log ( \"paintComponent called\" ) ; \nif ( Dragging == false ) setCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; \nif ( sclPic . getScaledPicture ( ) != null ) { \nGraphics2D g2d = ( Graphics2D ) g ; \nint X_Offset = ( int ) ( ( double ) ( WindowWidth / 2 ) - ( focusPoint . x * sclPic . getScaleFactor ( ) ) ) ; \nint Y_Offset = ( int ) ( ( double ) ( WindowHeight / 2 ) - ( focusPoint . y * sclPic . getScaleFactor ( ) ) ) ; \nRectangle clipBounds = g2d . getClipBounds ( ) ; \ng2d . setColor ( Color . black ) ; \ng2d . fillRect ( clipBounds . x , clipBounds . y , clipBounds . width , clipBounds . height ) ; \ng2d . drawRenderedImage ( sclPic . getScaledPicture ( ) , AffineTransform . getTranslateInstance ( X_Offset , Y_Offset ) ) ; \nif ( showInfo ) { \ng2d . setColor ( Color . white ) ; \ng2d . drawString ( legend , infoPoint . x , infoPoint . y ) ; \ng2d . drawString ( \"Size: \" + Integer . toString ( sclPic . getOriginalWidth ( ) ) + \" x \" + Integer . toString ( sclPic . getOriginalHeight ( ) ) + \" Offset: \" + X_Offset + \" x \" + Y_Offset + \" Mid: \" + Integer . toString ( focusPoint . x ) + \" x \" + Integer . toString ( focusPoint . y ) + \" Scale: \" + twoDecimalFormatter . format ( sclPic . getScaleFactor ( ) ) , infoPoint . x , infoPoint . y + lineSpacing ) ; \n} \n} \nelse { \ng . setClip ( 0 , 0 , WindowWidth , WindowHeight ) ; \ng . setColor ( Color . black ) ; \ng . fillRect ( 0 , 0 , WindowWidth , WindowHeight ) ; \n} \nif ( Dragging == false ) setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; \n} \n} \n"}
{"4872": "public class GempakUtil { \npublic static String TG_ITOC ( int [ ] intdtf ) { \nString gdattim = \"\" ; \nif ( ( intdtf [ 0 ] == 0 ) && ( intdtf [ 1 ] == 0 ) && ( intdtf [ 2 ] == 0 ) ) return gdattim ; \ngdattim = TI_CDTM ( intdtf [ 0 ] , intdtf [ 1 ] ) ; \nif ( intdtf [ 2 ] != 0 ) { \nString [ ] timeType = TG_CFTM ( intdtf [ 2 ] ) ; \nString ftype = timeType [ 0 ] ; \nString ftime = timeType [ 1 ] ; \ngdattim = gdattim . substring ( 0 , 11 ) + ftype + ftime ; \n} \nreturn gdattim ; \n} \n} \n"}
{"4874": "public class GempakUtil { \npublic static int TI_DAYM ( int iyear , int imon ) { \nint iday = 0 ; \nif ( ( imon > 0 ) && ( imon < 13 ) ) { \niday = month [ imon - 1 ] ; \nif ( ( imon == 2 ) && LEAP ( iyear ) ) iday = iday + 1 ; \n} \nreturn iday ; \n} \n} \n"}
{"4875": "public class GempakUtil { \npublic static String LV_CCRD ( int ivcord ) { \nString vcoord = \"\" ; \nif ( ( ivcord >= 0 ) && ( ivcord < vertCoords . length ) ) vcoord = vertCoords [ ivcord ] ; \nelse if ( ivcord > 100 ) vcoord = ST_ITOC ( ivcord ) ; \nreturn vcoord ; \n} \n} \n"}
{"4876": "public class GempakUtil { \npublic static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { \nfor ( int i = startIndex ; \ni < startIndex + number ; \ni ++ ) values [ i ] = Integer . reverseBytes ( values [ i ] ) ; \nreturn values ; \n} \n} \n"}
{"4880": "public class DataDDS { \npublic final void externalize ( OutputStream os , boolean compress , boolean headers ) throws IOException { \nif ( headers ) { \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os , Util . UTF8 ) ) ; \npw . println ( \"HTTP/1.0 200 OK\" ) ; \npw . println ( \"XDAP: \" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"XDODS-Server: DODS/\" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"Content-type: application/octet-stream\" ) ; \npw . println ( \"Content-Description: dods-data\" ) ; \nif ( compress ) pw . println ( \"Content-Encoding: deflate\" ) ; \npw . println ( ) ; \npw . flush ( ) ; \n} \nOutputStream bufferedOS ; \nif ( compress ) bufferedOS = new BufferedOutputStream ( new DeflaterOutputStream ( os ) ) ; \nelse bufferedOS = new BufferedOutputStream ( os ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bufferedOS , Util . UTF8 ) ) ; \nprint ( pw ) ; \npw . flush ( ) ; \nbufferedOS . write ( \"\\nData:\\n\" . getBytes ( CDM . utf8Charset ) ) ; \nbufferedOS . flush ( ) ; \nDataOutputStream dataOS = new DataOutputStream ( bufferedOS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . externalize ( dataOS ) ; \n} \ndataOS . close ( ) ; \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) throw new NullPointerException ( \"null array\" ) ; \nif ( arr . length == 0 ) throw new IllegalArgumentException ( \"Zero-length array\" ) ; \nint sum = 0 ; \nfor ( int i = 0 ; \ni < arr . length ; \ni ++ ) { \nif ( arr [ i ] <= 0 ) throw new IllegalArgumentException ( \"All array values must be > 0\" ) ; \nsum += arr [ i ] ; \n} \nreturn sum ; \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) for ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nint indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) for ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; \n} \nreturn null ; \n} \n} \n"}
{"4893": "public class BaseUnit { \npublic static synchronized BaseUnit getOrCreate ( final UnitName id , final BaseQuantity baseQuantity ) throws NameException , UnitExistsException { \nBaseUnit baseUnit ; \nfinal BaseUnit nameUnit = nameMap . get ( id ) ; \nfinal BaseUnit quantityUnit = quantityMap . get ( baseQuantity ) ; \nif ( nameUnit != null || quantityUnit != null ) { \nbaseUnit = nameUnit != null ? nameUnit : quantityUnit ; \nif ( ( nameUnit != null && ! baseQuantity . equals ( nameUnit . getBaseQuantity ( ) ) ) || ( quantityUnit != null && ! id . equals ( quantityUnit . getUnitName ( ) ) ) ) throw new UnitExistsException ( \"Attempt to incompatibly redefine base unit \\\"\" + baseUnit + '\"' ) ; \n} \nelse { \nbaseUnit = new BaseUnit ( id , baseQuantity ) ; \nquantityMap . put ( baseQuantity , baseUnit ) ; \nnameMap . put ( id , baseUnit ) ; \n} \nreturn baseUnit ; \n} \n} \n"}
{"4894": "public class DatasetUrl { \nstatic private ServiceType searchFragment ( String fragment ) { \nif ( fragment . length ( ) == 0 ) return null ; \nMap < String , String > map = parseFragment ( fragment ) ; \nif ( map == null ) return null ; \nString protocol = map . get ( \"protocol\" ) ; \nif ( protocol == null ) for ( String p : FRAGPROTOCOLS ) { \nif ( map . get ( p ) != null ) { \nprotocol = p ; \nbreak ; \n} \n} \nif ( protocol != null ) { \nif ( protocol . equalsIgnoreCase ( \"dap\" ) || protocol . equalsIgnoreCase ( \"dods\" ) ) return ServiceType . OPENDAP ; \nif ( protocol . equalsIgnoreCase ( \"dap4\" ) ) return ServiceType . DAP4 ; \nif ( protocol . equalsIgnoreCase ( \"cdmremote\" ) ) return ServiceType . CdmRemote ; \nif ( protocol . equalsIgnoreCase ( \"thredds\" ) ) return ServiceType . THREDDS ; \nif ( protocol . equalsIgnoreCase ( \"ncml\" ) ) return ServiceType . NCML ; \n} \nreturn null ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null || url . length ( ) == 0 ) return null ; \nurl = url . toLowerCase ( ) ; \nfor ( int i = 0 ; \ni < FRAGPROTOCOLS . length ; \ni ++ ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) >= 0 ) return FRAGPROTOSVCTYPE [ i ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4902": "public class DapUtil { \nstatic public String locateFile ( String filename , String abspath , boolean wantdir ) { \nDeque < String > q = new ArrayDeque < String > ( ) ; \nfilename = filename . trim ( ) . replace ( '\\\\' , '/' ) ; \nabspath = abspath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( filename . charAt ( 0 ) == '/' ) filename = filename . substring ( 1 ) ; \nif ( filename . endsWith ( \"/\" ) ) filename = filename . substring ( 0 , filename . length ( ) - 1 ) ; \nif ( abspath . endsWith ( \"/\" ) ) abspath = abspath . substring ( 0 , abspath . length ( ) - 1 ) ; \nq . addFirst ( abspath ) ; \nfor ( ; \n; \n) { \nString currentpath = q . poll ( ) ; \nif ( currentpath == null ) break ; \nFile current = new File ( currentpath ) ; \nFile [ ] contents = current . listFiles ( ) ; \nif ( contents != null ) { \nfor ( File subfile : contents ) { \nif ( ! subfile . getName ( ) . equals ( filename ) ) continue ; \nif ( ( wantdir && subfile . isDirectory ( ) ) || ( ! wantdir && subfile . isFile ( ) ) ) return DapUtil . canonicalpath ( subfile . getAbsolutePath ( ) ) ; \n} \nfor ( File subfile : contents ) { \nif ( subfile . isDirectory ( ) ) q . addFirst ( currentpath + \"/\" + subfile . getName ( ) ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4908": "public class DapUtil { \nstatic public boolean hasDriveLetter ( String path ) { \nboolean hasdr = false ; \nif ( path != null && path . length ( ) >= 2 ) hasdr = ( DRIVELETTERS . indexOf ( path . charAt ( 0 ) ) >= 0 && path . charAt ( 1 ) == ':' ) ; \nreturn hasdr ; \n} \n} \n"}
{"4918": "public class FeatureCollectionConfigBuilder { \npublic FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { \nString catFilename ; \nString fcName = null ; \nint pos = catalogAndPath . indexOf ( \"#\" ) ; \nif ( pos > 0 ) { \ncatFilename = catalogAndPath . substring ( 0 , pos ) ; \nfcName = catalogAndPath . substring ( pos + 1 ) ; \n} \nelse catFilename = catalogAndPath ; \nFile cat = new File ( catFilename ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \ndoc = builder . build ( cat ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \ntry { \nList < Element > fcElems = new ArrayList < > ( ) ; \nfindFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; \nif ( fcElems . size ( ) > 0 ) return readConfig ( fcElems . get ( 0 ) ) ; \n} \ncatch ( IllegalStateException e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4919": "public class DapGroup { \npublic void addDecl ( DapNode newdecl ) throws DapException { \nDapSort newsort = newdecl . getSort ( ) ; \nString newname = newdecl . getShortName ( ) ; \nboolean suppress = false ; \nif ( newsort != DapSort . DIMENSION || newname != null ) for ( DapNode decl : decls ) { \nif ( newsort == decl . getSort ( ) && newname . equals ( decl . getShortName ( ) ) ) throw new DapException ( \"DapGroup: attempt to add duplicate decl: \" + newname ) ; \n} \nelse { \nDapDimension anon = ( DapDimension ) newdecl ; \nassert ( newsort == DapSort . DIMENSION && newname == null ) ; \nboolean found = false ; \nfor ( DapDimension dim : dimensions ) { \nif ( ! dim . isShared ( ) && dim . getSize ( ) == anon . getSize ( ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found && ! isTopLevel ( ) ) getDataset ( ) . addDecl ( anon ) ; \nsuppress = found || ! isTopLevel ( ) ; \n} \nif ( ! suppress ) { \ndecls . add ( newdecl ) ; \nnewdecl . setParent ( this ) ; \n} \nswitch ( newdecl . getSort ( ) ) { \ncase ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : super . addAttribute ( ( DapAttribute ) newdecl ) ; \nbreak ; \ncase DIMENSION : if ( ! suppress ) dimensions . add ( ( DapDimension ) newdecl ) ; \nbreak ; \ncase ENUMERATION : enums . add ( ( DapEnumeration ) newdecl ) ; \nbreak ; \ncase ATOMICTYPE : break ; \ncase STRUCTURE : case SEQUENCE : compounds . add ( ( DapStructure ) newdecl ) ; \nbreak ; \ncase VARIABLE : variables . add ( ( DapVariable ) newdecl ) ; \nbreak ; \ncase GROUP : case DATASET : if ( this != ( DapGroup ) newdecl ) groups . add ( ( DapGroup ) newdecl ) ; \nbreak ; \ndefault : throw new ClassCastException ( newdecl . getShortName ( ) ) ; \n} \n} \n} \n"}
{"4922": "public class COARDSConvention { \nprotected AxisType getAxisType ( NetcdfDataset ncDataset , VariableEnhanced v ) { \nString unit = v . getUnitsString ( ) ; \nif ( unit == null ) return null ; \nunit = unit . trim ( ) ; \nif ( unit . equalsIgnoreCase ( \"degrees_east\" ) || unit . equalsIgnoreCase ( \"degrees_E\" ) || unit . equalsIgnoreCase ( \"degreesE\" ) || unit . equalsIgnoreCase ( \"degree_east\" ) || unit . equalsIgnoreCase ( \"degree_E\" ) || unit . equalsIgnoreCase ( \"degreeE\" ) ) return AxisType . Lon ; \nif ( unit . equalsIgnoreCase ( \"degrees_north\" ) || unit . equalsIgnoreCase ( \"degrees_N\" ) || unit . equalsIgnoreCase ( \"degreesN\" ) || unit . equalsIgnoreCase ( \"degree_north\" ) || unit . equalsIgnoreCase ( \"degree_N\" ) || unit . equalsIgnoreCase ( \"degreeN\" ) ) return AxisType . Lat ; \nif ( SimpleUnit . isDateUnit ( unit ) ) return AxisType . Time ; \nif ( SimpleUnit . isCompatible ( \"mbar\" , unit ) ) return AxisType . Pressure ; \nif ( unit . equalsIgnoreCase ( \"level\" ) || unit . equalsIgnoreCase ( \"layer\" ) || unit . equalsIgnoreCase ( \"sigma_level\" ) ) return AxisType . GeoZ ; \nString positive = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . POSITIVE , null ) ; \nif ( positive != null ) if ( SimpleUnit . isCompatible ( \"m\" , unit ) ) return AxisType . Height ; \nelse return AxisType . GeoZ ; \nreturn null ; \n} \n} \n"}
{"4926": "public class HTTPSession { \nstatic synchronized protected void setDefaults ( Map < Prop , Object > props ) { \nif ( false ) props . put ( Prop . HANDLE_AUTHENTICATION , Boolean . TRUE ) ; \nprops . put ( Prop . HANDLE_REDIRECTS , Boolean . TRUE ) ; \nprops . put ( Prop . ALLOW_CIRCULAR_REDIRECTS , Boolean . TRUE ) ; \nprops . put ( Prop . MAX_REDIRECTS , ( Integer ) DFALTREDIRECTS ) ; \nprops . put ( Prop . SO_TIMEOUT , ( Integer ) DFALTSOTIMEOUT ) ; \nprops . put ( Prop . CONN_TIMEOUT , ( Integer ) DFALTCONNTIMEOUT ) ; \nprops . put ( Prop . CONN_REQ_TIMEOUT , ( Integer ) DFALTCONNREQTIMEOUT ) ; \nprops . put ( Prop . USER_AGENT , DFALTUSERAGENT ) ; \n} \n} \n"}
{"4931": "public class HTTPSession { \nsynchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { \ncb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; \nAuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; \nCredentialsProvider cp = null ; \nif ( bestMatch != null ) cp = localcreds . get ( bestMatch ) ; \nelse { \nbestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; \nif ( bestMatch != null ) { \nHTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; \ncp = factory . getProvider ( bestMatch ) ; \n} \n} \nCredentials proxycreds = null ; \nAuthScope proxyscope = null ; \nString user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; \nString pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; \nHttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; \nHttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; \nif ( user != null && ( httpproxy != null || httpsproxy != null ) ) { \nif ( httpproxy != null ) proxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; \nelse proxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; \nproxycreds = new UsernamePasswordCredentials ( user , pwd ) ; \n} \nif ( cp == null && proxycreds != null && proxyscope != null ) { \ncp = new BasicCredentialsProvider ( ) ; \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nelse if ( cp != null && proxycreds != null && proxyscope != null ) cp . setCredentials ( proxyscope , proxycreds ) ; \nif ( cp != null ) this . sessioncontext . setCredentialsProvider ( cp ) ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse newindex . offset += stride [ ii ] * r . first ( ) ; \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nif ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nint count = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) if ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount ++ ; \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4949": "public class AbstractGempakStationFileReader { \nprotected List < String > makeDateList ( boolean unique ) { \nKey date = dateTimeKeys . get ( 0 ) ; \nKey time = dateTimeKeys . get ( 1 ) ; \nList < int [ ] > toCheck ; \nif ( date . type . equals ( ROW ) ) toCheck = headers . rowHeaders ; \nelse toCheck = headers . colHeaders ; \nList < String > fileDates = new ArrayList < > ( ) ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nint idate = header [ date . loc + 1 ] ; \nint itime = header [ time . loc + 1 ] ; \nString dateTime = GempakUtil . TI_CDTM ( idate , itime ) ; \nfileDates . add ( dateTime ) ; \n} \n} \nif ( unique && ! fileDates . isEmpty ( ) ) { \nSortedSet < String > uniqueTimes = Collections . synchronizedSortedSet ( new TreeSet < String > ( ) ) ; \nuniqueTimes . addAll ( fileDates ) ; \nfileDates . clear ( ) ; \nfileDates . addAll ( uniqueTimes ) ; \n} \nreturn fileDates ; \n} \n} \n"}
{"4950": "public class AbstractGempakStationFileReader { \nprivate List < GempakParameter > makeParams ( DMPart part ) { \nList < GempakParameter > gemparms = new ArrayList < > ( part . kparms ) ; \nfor ( DMParam param : part . params ) { \nString name = param . kprmnm ; \nGempakParameter parm = GempakParameters . getParameter ( name ) ; \nif ( parm == null ) parm = new GempakParameter ( 1 , name , name , \"\" , 0 ) ; \ngemparms . add ( parm ) ; \n} \nreturn gemparms ; \n} \n} \n"}
{"4951": "public class AbstractGempakStationFileReader { \nprivate List < GempakStation > getStationList ( ) { \nKey slat = findKey ( GempakStation . SLAT ) ; \nif ( slat == null ) return null ; \nList < int [ ] > toCheck ; \nif ( slat . type . equals ( ROW ) ) toCheck = headers . rowHeaders ; \nelse toCheck = headers . colHeaders ; \nList < GempakStation > fileStations = new ArrayList < > ( ) ; \nint i = 0 ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nGempakStation station = makeStation ( header ) ; \nif ( station != null ) { \nstation . setIndex ( i + 1 ) ; \nfileStations . add ( station ) ; \n} \n} \ni ++ ; \n} \nreturn fileStations ; \n} \n} \n"}
{"4952": "public class AbstractGempakStationFileReader { \nprivate GempakStation makeStation ( int [ ] header ) { \nif ( ( stationKeys == null ) || stationKeys . isEmpty ( ) ) return null ; \nGempakStation newStation = new GempakStation ( ) ; \nfor ( Key key : stationKeys ) { \nint loc = key . loc + 1 ; \nswitch ( key . name ) { \ncase GempakStation . STID : newStation . setSTID ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . STNM : newStation . setSTNM ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SLAT : newStation . setSLAT ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SLON : newStation . setSLON ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SELV : newStation . setSELV ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SPRI : newStation . setSPRI ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . STAT : newStation . setSTAT ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . COUN : newStation . setCOUN ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . SWFO : newStation . setSWFO ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . WFO2 : newStation . setWFO2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . STD2 : newStation . setSTD2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \n} \n} \nreturn newStation ; \n} \n} \n"}
{"4953": "public class AbstractGempakStationFileReader { \npublic List < String > getStationKeyNames ( ) { \nList < String > keys = new ArrayList < > ( ) ; \nif ( ( stationKeys != null ) && ! stationKeys . isEmpty ( ) ) for ( Key key : stationKeys ) { \nkeys . add ( key . name ) ; \n} \nreturn keys ; \n} \n} \n"}
{"4955": "public class AbstractGempakStationFileReader { \npublic int findStationIndex ( String id ) { \nfor ( GempakStation station : getStations ( ) ) { \nif ( station . getSTID ( ) . equals ( id ) ) return station . getIndex ( ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4956": "public class AbstractGempakStationFileReader { \npublic String getFileType ( ) { \nString type = \"Unknown\" ; \nswitch ( dmLabel . kftype ) { \ncase MFSN : type = \"Sounding\" ; \nbreak ; \ncase MFSF : type = \"Surface\" ; \nbreak ; \ndefault : } \nif ( ! subType . equals ( \"\" ) ) type = type + \" (\" + subType + \")\" ; \nreturn type ; \n} \n} \n"}
{"4959": "public class GribIndex { \npublic static GribIndex readOrCreateIndexFromSingleFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType force , org . slf4j . Logger logger ) throws IOException { \nGribIndex index = isGrib1 ? new Grib1Index ( ) : new Grib2Index ( ) ; \nif ( ! index . readIndex ( mfile . getPath ( ) , mfile . getLastModified ( ) , force ) ) { \nindex . makeIndex ( mfile . getPath ( ) , null ) ; \nlogger . debug ( \"  Index written: {} == {} records\" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; \n} \nelse if ( debug ) logger . debug ( \"  Index read: {} == {} records\" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; \nreturn index ; \n} \n} \n"}
{"4960": "public class MFileCollectionManager { \npublic void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { \nCompositeMFileFilter filters = new CompositeMFileFilter ( ) ; \nif ( null != regexpPatternString ) filters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; \nelse if ( suffix != null ) filters . addIncludeFilter ( new WildcardMatchOnPath ( \"*\" + suffix + \"$\" ) ) ; \nif ( olderS != null ) try { \nTimeDuration tu = new TimeDuration ( olderS ) ; \nfilters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( collectionName + \": Invalid time unit for olderThan = {}\" , olderS ) ; \n} \nboolean wantSubdirs = true ; \nif ( ( subdirsS != null ) && subdirsS . equalsIgnoreCase ( \"false\" ) ) wantSubdirs = false ; \nCollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; \nStringBuilder sb = new StringBuilder ( dirName ) ; \nif ( wantSubdirs ) sb . append ( \"**/\" ) ; \nif ( null != regexpPatternString ) sb . append ( regexpPatternString ) ; \nelse if ( suffix != null ) sb . append ( suffix ) ; \nelse sb . append ( \"noFilter\" ) ; \ncollectionName = sb . toString ( ) ; \nscanList . add ( mc ) ; \n} \n} \n"}
{"4964": "public class FileWriter2 { \npublic Variable addVariable ( Variable oldVar ) { \nList < Dimension > newDims = getNewDimensions ( oldVar ) ; \nVariable newVar ; \nif ( ( oldVar . getDataType ( ) . equals ( DataType . STRING ) ) && ( ! version . isExtendedModel ( ) ) ) newVar = writer . addStringVariable ( null , oldVar , newDims ) ; \nelse newVar = writer . addVariable ( null , oldVar . getShortName ( ) , oldVar . getDataType ( ) , newDims ) ; \nvarMap . put ( oldVar , newVar ) ; \nvarList . add ( oldVar ) ; \nfor ( Attribute orgAtt : oldVar . getAttributes ( ) ) writer . addVariableAttribute ( newVar , convertAttribute ( orgAtt ) ) ; \nreturn newVar ; \n} \n} \n"}
{"4966": "public class MarshallingUtil { \npublic static void validate ( XmlObject doc , boolean strict ) throws XmlException { \nSet < XmlError > validationErrors = new HashSet < > ( ) ; \nXmlOptions validationOptions = new XmlOptions ( ) ; \nvalidationOptions . setErrorListener ( validationErrors ) ; \nfinal boolean isValid = doc . validate ( validationOptions ) ; \nif ( ! isValid && ! strict ) validationErrors = filterToOnlySerious ( validationErrors ) ; \nif ( ! validationErrors . isEmpty ( ) ) throw new XmlException ( createErrorMessage ( validationErrors ) ) ; \n} \n} \n"}
{"4967": "public class MultiSlice { \n@ Override public String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( \"[\" ) ; \nboolean first = true ; \nfor ( Slice sub : this . subslices ) { \nif ( ! first ) buf . append ( \",\" ) ; \nfirst = false ; \nif ( ( sub . stop - sub . first ) == 0 ) buf . append ( \"0\" ) ; \nelse if ( sub . stride == 1 ) if ( ( sub . stop - sub . first ) == 1 ) buf . append ( sub . first ) ; \nelse buf . append ( String . format ( \"%d:%d\" , sub . first , sub . stop - 1 ) ) ; \nelse buf . append ( String . format ( \"%d:%d:%d\" , sub . first , sub . stride , sub . stop - 1 ) ) ; \n} \nbuf . append ( \"]\" ) ; \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4969": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , CancelTask cancelTask ) throws IOException { \nArray result ; \nif ( hasCachedData ( ) ) result = super . reallyRead ( client , cancelTask ) ; \nelse if ( orgVar != null ) result = orgVar . read ( ) ; \nelse throw new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \nreturn convert ( result , null ) ; \n} \n} \n"}
{"4970": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nif ( section . computeSize ( ) == getSize ( ) ) return _read ( ) ; \nArray result ; \nif ( hasCachedData ( ) ) result = super . reallyRead ( client , section , cancelTask ) ; \nelse if ( orgVar != null ) result = orgVar . read ( section ) ; \nelse throw new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \nreturn convert ( result , section ) ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) if ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \ni < seqArray . getSize ( ) ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) try { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4973": "public class StructureDS { \nprivate void convertMemberInfo ( StructureMembers wrapperSm ) { \nfor ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { \nVariable v = findVariable ( m . getName ( ) ) ; \nif ( ( v == null ) && ( orgVar != null ) ) v = ( Variable ) findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v != null ) m . setVariableInfo ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) ) ; \nif ( v instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v ; \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \n} \n} \n"}
{"4977": "public class DatasetManager { \npublic boolean resourceControlOk ( HttpServletRequest req , HttpServletResponse res , String reqPath ) { \nif ( null == reqPath ) reqPath = TdsPathUtils . extractPath ( req , null ) ; \nString rc = null ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( reqPath ) ; \nif ( match != null ) rc = match . dataRoot . getRestrict ( ) ; \nif ( rc == null ) rc = datasetTracker . findResourceControl ( reqPath ) ; \nreturn resourceAuthorized ( req , res , rc ) ; \n} \n} \n"}
{"4979": "public class GempakSoundingIOSP { \nprivate ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { \nif ( values == null ) return makeEmptySequence ( seq ) ; \nint numLevels = values . length / params . size ( ) ; \nStructureMembers members = seq . makeStructureMembers ( ) ; \nint offset = ArrayStructureBB . setOffsets ( members ) ; \nint size = offset * numLevels ; \nbyte [ ] bytes = new byte [ size ] ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) ; \nArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { \nnumLevels } \n, buf , 0 ) ; \nint var = 0 ; \nfor ( int i = 0 ; \ni < numLevels ; \ni ++ ) for ( GempakParameter param : params ) { \nif ( members . findMember ( param . getName ( ) ) != null ) buf . putFloat ( values [ var ] ) ; \nvar ++ ; \n} \nreturn new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; \n} \n} \n"}
{"4980": "public class GempakSoundingIOSP { \nprotected Sequence makeSequence ( Structure parent , String partName , boolean includeMissing ) { \nList < GempakParameter > params = gemreader . getParameters ( partName ) ; \nif ( params == null ) return null ; \nSequence sVar = new Sequence ( ncfile , null , parent , partName ) ; \nsVar . setDimensions ( \"\" ) ; \nfor ( GempakParameter param : params ) { \nVariable v = makeParamVariable ( param , null ) ; \naddVerticalCoordAttribute ( v ) ; \nsVar . addMemberVariable ( v ) ; \n} \nif ( includeMissing ) sVar . addMemberVariable ( makeMissingVariable ( ) ) ; \nreturn sVar ; \n} \n} \n"}
{"4981": "public class GempakSoundingIOSP { \nprivate void addVerticalCoordAttribute ( Variable v ) { \nGempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; \nint vertType = gsfr . getVerticalCoordinate ( ) ; \nString pName = v . getFullName ( ) ; \nif ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) if ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( \"PRES\" ) ) v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \nelse if ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( \"HGHT\" ) || pName . equals ( \"MHGT\" ) || pName . equals ( \"DHGT\" ) ) ) v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; \nelse if ( pName . equals ( \"PRES\" ) ) v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \n} \n"}
{"4988": "public class DerivedUnitImpl { \n@ Override protected Unit myMultiplyBy ( final Unit that ) throws MultiplyException { \nUnit result ; \nif ( dimension . getRank ( ) == 0 ) result = that ; \nelse if ( ! ( that instanceof DerivedUnit ) ) result = that . multiplyBy ( this ) ; \nelse { \nfinal UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; \nresult = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . multiplyBy ( thatDimension ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4989": "public class DerivedUnitImpl { \n@ Override protected Unit myDivideBy ( final Unit that ) throws OperationException { \nUnit result ; \nif ( dimension . getRank ( ) == 0 ) result = that . raiseTo ( - 1 ) ; \nelse if ( ! ( that instanceof DerivedUnit ) ) result = that . divideInto ( this ) ; \nelse { \nfinal UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; \nresult = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . divideBy ( thatDimension ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4990": "public class DerivedUnitImpl { \npublic final float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) { \nif ( input != output ) System . arraycopy ( input , 0 , output , 0 , input . length ) ; \nreturn output ; \n} \n} \n"}
{"4998": "public class DOM4Parser { \nprotected void parseresponse ( Node root ) throws ParseException { \nString elemname = root . getNodeName ( ) ; \nif ( elemname . equalsIgnoreCase ( \"Error\" ) ) parseerror ( root ) ; \nelse if ( elemname . equalsIgnoreCase ( \"Dataset\" ) ) parsedataset ( root ) ; \nelse throw new ParseException ( \"Unexpected response root: \" + elemname ) ; \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) return null ; \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) subStr += id ; \nelse if ( beginInd < 0 || endInd < 0 ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \nif ( i < dimList . size ( ) - 1 ) subStr += \",\" ; \n} \nreturn subStr ; \n} \n} \n"}
{"5001": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { \nif ( from instanceof ArrayStructureMA ) return ( ArrayStructureMA ) from ; \nif ( from . getSize ( ) > 0 ) { \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nto . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; \n} \nreturn to ; \n} \nint numRecords = - 1 ; \nMap < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nArray array = from . extractMemberArray ( m ) ; \nassert array . getSize ( ) > 0 : \"array's size should have been computed in extractMemberArray().\" ; \nint firstDimLen = array . getShape ( ) [ 0 ] ; \nif ( numRecords == - 1 ) numRecords = firstDimLen ; \nelse assert numRecords == firstDimLen : String . format ( \"Expected all structure members to have the same first\" + \"dimension length, but %d != %d.\" , numRecords , firstDimLen ) ; \nmemberArrayMap . put ( m . getName ( ) , array ) ; \n} \nint [ ] shape ; \nif ( numRecords == - 1 ) shape = new int [ ] { \n0 } \n; \nelse shape = new int [ ] { \nnumRecords } \n; \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; \nfor ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { \nto . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn to ; \n} \n} \n"}
{"5003": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( Structure from , int [ ] shape ) throws IOException { \nStructureMembers sm = from . makeStructureMembers ( ) ; \nfor ( Variable v : from . getVariables ( ) ) { \nArray data ; \nif ( v instanceof Sequence ) data = Array . factory ( DataType . SEQUENCE , shape ) ; \nelse if ( v instanceof Structure ) data = ArrayStructureMA . factoryMA ( ( Structure ) v , combine ( shape , v . getShape ( ) ) ) ; \nelse data = Array . factory ( v . getDataType ( ) , combine ( shape , v . getShape ( ) ) ) ; \nStructureMembers . Member m = sm . findMember ( v . getShortName ( ) ) ; \nm . setDataArray ( data ) ; \n} \nreturn new ArrayStructureMA ( sm , shape ) ; \n} \n} \n"}
{"5007": "public class CECompiler { \npublic void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { \nif ( expr == null ) return ; \nif ( expr . sort == CEAST . Sort . SEGMENT ) { \nif ( expr . subnodes != null ) throw new DapException ( \"compilefilter: Non-simple segment:\" + expr . name ) ; \nDapVariable field = seq . findByName ( expr . name ) ; \nif ( field == null ) throw new DapException ( \"compilefilter: Unknown filter variable:\" + expr . name ) ; \nexpr . field = field ; \n} \nelse if ( expr . sort == CEAST . Sort . EXPR ) { \nif ( expr . lhs != null ) compilefilter ( var , seq , expr . lhs ) ; \nif ( expr . rhs != null ) compilefilter ( var , seq , expr . rhs ) ; \nif ( expr . lhs != null && expr . rhs != null ) { \nboolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; \nboolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; \nif ( rightvar && ! leftvar ) { \nCEAST tmp = expr . lhs ; \nexpr . lhs = expr . rhs ; \nexpr . rhs = tmp ; \nswitch ( expr . op ) { \ncase LT : expr . op = CEAST . Operator . GT ; \nbreak ; \ncase LE : expr . op = CEAST . Operator . GE ; \nbreak ; \ncase GT : expr . op = CEAST . Operator . LT ; \nbreak ; \ncase GE : expr . op = CEAST . Operator . LE ; \nbreak ; \ndefault : break ; \n} \n} \n} \n} \nelse if ( expr . sort == CEAST . Sort . CONSTANT ) return ; \nelse throw new DapException ( \"compilefilter: Unexpected node type:\" + expr . sort ) ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) upperRight . setLatitude ( lat ) ; \nif ( lat < lowerLeft . getLatitude ( ) ) lowerLeft . setLatitude ( lat ) ; \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) if ( d1 > d2 ) lowerLeft . setLongitude ( lon ) ; \nelse upperRight . setLongitude ( lon ) ; \n} \nelse if ( lon > upperRight . getLongitude ( ) ) if ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse upperRight . setLongitude ( lon ) ; \nelse if ( lon < lowerLeft . getLongitude ( ) ) if ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse lowerLeft . setLongitude ( lon ) ; \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5012": "public class LatLonRect { \npublic void extend ( LatLonRect r ) { \nPreconditions . checkNotNull ( r ) ; \ndouble latMin = r . getLatMin ( ) ; \ndouble latMax = r . getLatMax ( ) ; \nif ( latMax > upperRight . getLatitude ( ) ) upperRight . setLatitude ( latMax ) ; \nif ( latMin < lowerLeft . getLatitude ( ) ) lowerLeft . setLatitude ( latMin ) ; \nif ( allLongitude ) return ; \ndouble lonMin = getLonMin ( ) ; \ndouble lonMax = getLonMax ( ) ; \ndouble nlonMin = LatLonPointImpl . lonNormal ( r . getLonMin ( ) , lonMin ) ; \ndouble nlonMax = nlonMin + r . getWidth ( ) ; \nlonMin = Math . min ( lonMin , nlonMin ) ; \nlonMax = Math . max ( lonMax , nlonMax ) ; \nwidth = lonMax - lonMin ; \nallLongitude = width >= 360.0 ; \nif ( allLongitude ) { \nwidth = 360.0 ; \nlonMin = - 180.0 ; \n} \nelse lonMin = LatLonPointImpl . lonNormal ( lonMin ) ; \nlowerLeft . setLongitude ( lonMin ) ; \nupperRight . setLongitude ( lonMin + width ) ; \nlon0 = lonMin + width / 2 ; \ncrossDateline = lowerLeft . getLongitude ( ) > upperRight . getLongitude ( ) ; \n} \n} \n"}
{"5014": "public class MAMath { \npublic static Array add ( Array a , Array b ) throws IllegalArgumentException { \nArray result = Array . factory ( a . getDataType ( ) , a . getShape ( ) ) ; \nif ( a . getElementType ( ) == double . class ) addDouble ( result , a , b ) ; \nelse throw new UnsupportedOperationException ( ) ; \nreturn result ; \n} \n} \n"}
{"5018": "public class MAMath { \npublic static void copy ( Array result , Array a ) throws IllegalArgumentException { \nClass classType = a . getElementType ( ) ; \nif ( classType == double . class ) copyDouble ( result , a ) ; \nelse if ( classType == float . class ) copyFloat ( result , a ) ; \nelse if ( classType == long . class ) copyLong ( result , a ) ; \nelse if ( classType == int . class ) copyInt ( result , a ) ; \nelse if ( classType == short . class ) copyShort ( result , a ) ; \nelse if ( classType == char . class ) copyChar ( result , a ) ; \nelse if ( classType == byte . class ) copyByte ( result , a ) ; \nelse if ( classType == boolean . class ) copyBoolean ( result , a ) ; \nelse copyObject ( result , a ) ; \n} \n} \n"}
{"5020": "public class MAMath { \npublic static void copyObject ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) throw new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nwhile ( iterA . hasNext ( ) ) iterR . setObjectNext ( iterA . getObjectNext ( ) ) ; \n} \n} \n"}
{"5022": "public class MAMath { \npublic static void setDouble ( Array result , double val ) { \nIndexIterator iter = result . getIndexIterator ( ) ; \nwhile ( iter . hasNext ( ) ) iter . setDoubleNext ( val ) ; \n} \n} \n"}
{"5024": "public class ProjectionAdapter { \nstatic public ProjectionImpl factory ( Projection proj ) { \nif ( proj instanceof ProjectionImpl ) return ( ProjectionImpl ) proj ; \nreturn new ProjectionAdapter ( proj ) ; \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) return null ; \nelse if ( reservedChars == null ) return x ; \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) continue ; \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5029": "public class EscapeStrings { \nstatic public String backslashUnescape ( String x ) { \nif ( ! x . contains ( \"\\\\\" ) ) return x ; \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( c == '\\\\' ) c = x . charAt ( ++ pos ) ; \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) && c == '\\\\' ) c = bs . charAt ( ++ i ) ; \nif ( _allowableInDAP . indexOf ( c ) < 0 ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \nelse buf . append ( c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5034": "public class Nc4Cursor { \nstatic List < Nc4Cursor > getCursorPath ( Nc4Cursor cursor ) { \nList < Nc4Cursor > path = new ArrayList < > ( ) ; \nfor ( ; \n; \n) { \nif ( ! cursor . getScheme ( ) . isCompoundArray ( ) ) path . add ( 0 , cursor ) ; \nif ( cursor . getScheme ( ) == Scheme . SEQUENCE ) break ; \nNc4Cursor next = ( Nc4Cursor ) cursor . getContainer ( ) ; \nif ( next == null ) { \nassert cursor . getTemplate ( ) . isTopLevel ( ) ; \nbreak ; \n} \nassert next . getTemplate ( ) . getSort ( ) == DapSort . VARIABLE ; \ncursor = next ; \n} \nreturn path ; \n} \n} \n"}
{"5035": "public class SwingUtils { \npublic static Object getUIDefaultOfClass ( Class clazz , String property ) { \nObject retVal = null ; \nUIDefaults defaults = getUIDefaultsOfClass ( clazz ) ; \nList < Object > listKeys = Collections . list ( defaults . keys ( ) ) ; \nfor ( Object key : listKeys ) { \nif ( key . equals ( property ) ) return defaults . get ( key ) ; \nif ( key . toString ( ) . equalsIgnoreCase ( property ) ) retVal = defaults . get ( key ) ; \n} \nreturn retVal ; \n} \n} \n"}
{"5036": "public class SwingUtils { \npublic static < T extends JComponent > Class getJClass ( T component ) { \nClass < ? > clazz = component . getClass ( ) ; \nwhile ( ! clazz . getName ( ) . matches ( \"javax.swing.J[^.]*$\" ) ) clazz = clazz . getSuperclass ( ) ; \nreturn clazz ; \n} \n} \n"}
{"5059": "public class DoradeRADD { \npublic float getCellSpacing ( ) throws DescriptorException { \nfloat [ ] cellRanges = myCELV . getCellRanges ( ) ; \nfloat cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; \nfor ( int i = 2 ; \ni < cellRanges . length ; \ni ++ ) { \nfloat space = cellRanges [ i ] - cellRanges [ i - 1 ] ; \nif ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) ) throw new DescriptorException ( \"variable cell spacing\" ) ; \n} \nreturn cellSpacing ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( comp < 0 ) { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \nelse if ( comp == 0 ) { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) newFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5062": "public class Dimension { \nprotected Factor [ ] pow ( final int power ) { \nFactor [ ] factors ; \nif ( power == 0 ) factors = new Factor [ 0 ] ; \nelse { \nfactors = getFactors ( ) ; \nif ( power != 1 ) for ( int i = factors . length ; \n-- i >= 0 ; \n) factors [ i ] = factors [ i ] . pow ( power ) ; \n} \nreturn factors ; \n} \n} \n"}
{"5063": "public class Dimension { \npublic final boolean isReciprocalOf ( final Dimension that ) { \nfinal Factor [ ] theseFactors = _factors ; \nfinal Factor [ ] thoseFactors = that . _factors ; \nboolean isReciprocalOf ; \nif ( theseFactors . length != thoseFactors . length ) isReciprocalOf = false ; \nelse { \nint i ; \nfor ( i = theseFactors . length ; \n-- i >= 0 ; \n) if ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) break ; \nisReciprocalOf = i < 0 ; \n} \nreturn isReciprocalOf ; \n} \n} \n"}
{"5064": "public class Dimension { \npublic final boolean isDimensionless ( ) { \nfor ( int i = _factors . length ; \n-- i >= 0 ; \n) if ( ! _factors [ i ] . isDimensionless ( ) ) return false ; \nreturn true ; \n} \n} \n"}
{"5069": "public class LogarithmicUnit { \n@ Override protected Unit myRaiseTo ( final int power ) throws RaiseException { \nif ( power == 0 ) return DerivedUnitImpl . DIMENSIONLESS ; \nif ( power == 1 ) return this ; \nthrow new RaiseException ( this ) ; \n} \n} \n"}
{"5070": "public class LogarithmicUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfor ( int i = input . length ; \n-- i >= 0 ; \n) output [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; \nreturn reference . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"5072": "public class Vis5DIosp { \nprivate Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { \nString vert_unit = null ; \nString vert_type ; \nArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; \nAxisType axisType = null ; \nswitch ( vert_sys ) { \ncase ( 0 ) : vert_unit = null ; \nvert_type = \"height\" ; \nbreak ; \ncase ( 1 ) : case ( 2 ) : vert_unit = \"km\" ; \nvert_type = \"altitude\" ; \naxisType = AxisType . Height ; \nbreak ; \ncase ( 3 ) : vert_unit = \"mbar\" ; \nvert_type = \"pressure\" ; \naxisType = AxisType . Pressure ; \nbreak ; \ndefault : throw new IOException ( \"vert_sys unknown\" ) ; \n} \nVariable vertVar = new Variable ( ncfile , null , null , vert_type ) ; \nvertVar . setDimensions ( LEVEL ) ; \nvertVar . setDataType ( DataType . FLOAT ) ; \nif ( vert_unit != null ) vertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; \nif ( axisType != null ) vertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nswitch ( vert_sys ) { \ncase ( 0 ) : case ( 1 ) : for ( int i = 0 ; \ni < n_levels ; \ni ++ ) data . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; \nbreak ; \ncase ( 2 ) : for ( int i = 0 ; \ni < n_levels ; \ni ++ ) data . set ( i , vert_args [ i ] ) ; \nbreak ; \ncase ( 3 ) : try { \nVis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; \nfloat [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; \nSystem . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; \nfor ( int i = 0 ; \ni < n_levels ; \ni ++ ) pressures [ 0 ] [ i ] *= 1000 ; \npressures = vert_cs . fromReference ( pressures ) ; \nfor ( int i = 0 ; \ni < n_levels ; \ni ++ ) data . set ( i , pressures [ 0 ] [ i ] ) ; \n} \ncatch ( VisADException ve ) { \nthrow new IOException ( \"unable to make vertical system\" ) ; \n} \nbreak ; \n} \nvertVar . setCachedData ( data , false ) ; \nreturn vertVar ; \n} \n} \n"}
{"5076": "public class DoradeDescriptor { \nprotected float grabFloat ( byte [ ] bytes , int offset ) throws DescriptorException { \ntry { \nbyte [ ] src ; \nif ( littleEndianData ) { \nsrc = new byte [ 4 ] ; \nsrc [ 0 ] = bytes [ offset + 3 ] ; \nsrc [ 1 ] = bytes [ offset + 2 ] ; \nsrc [ 2 ] = bytes [ offset + 1 ] ; \nsrc [ 3 ] = bytes [ offset ] ; \noffset = 0 ; \n} \nelse src = bytes ; \nDataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 4 ) ) ; \nreturn stream . readFloat ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new DescriptorException ( ex ) ; \n} \n} \n} \n"}
{"5077": "public class DoradeDescriptor { \nprotected double grabDouble ( byte [ ] bytes , int offset ) throws DescriptorException { \ntry { \nbyte [ ] src ; \nif ( littleEndianData ) { \nsrc = new byte [ 8 ] ; \nsrc [ 0 ] = bytes [ offset + 7 ] ; \nsrc [ 1 ] = bytes [ offset + 6 ] ; \nsrc [ 2 ] = bytes [ offset + 5 ] ; \nsrc [ 3 ] = bytes [ offset + 4 ] ; \nsrc [ 4 ] = bytes [ offset + 3 ] ; \nsrc [ 5 ] = bytes [ offset + 2 ] ; \nsrc [ 6 ] = bytes [ offset + 1 ] ; \nsrc [ 7 ] = bytes [ offset ] ; \noffset = 0 ; \n} \nelse src = bytes ; \nDataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 8 ) ) ; \nreturn stream . readDouble ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new DescriptorException ( ex ) ; \n} \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) return shapeList . iterator ( ) ; \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) System . out . println ( \"projection/LatLonShift GisFeatureRenderer.getShapes called\" ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( dataProject == null ) shape = feature . getShape ( ) ; \nelse if ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; \nelse if ( dataProject == displayProject ) shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( dataProject , displayProject ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead ++ ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) lookingFor = 1 ; \nelse lookingFor = 0 ; \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( len <= 0 ) return 0 ; \nint c = read ( ) ; \nif ( c == - 1 ) return - 1 ; \nb [ off ] = ( byte ) c ; \nint i = 1 ; \ntry { \nfor ( ; \ni < len ; \ni ++ ) { \nc = read ( ) ; \nif ( c == - 1 ) break ; \nb [ off + i ] = ( byte ) c ; \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val > val2 ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) return i ; \nelse if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5095": "public class NOWRadiosp { \npublic byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { \nint run ; \nbyte [ ] bdata = new byte [ xt ] ; \nint nbin = 0 ; \nint total = 0 ; \nfor ( run = 0 ; \nrun < rLen ; \nrun ++ ) { \nint drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; \nbyte dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; \nfor ( int i = 0 ; \ni < drun ; \ni ++ ) { \nbdata [ nbin ++ ] = dcode1 ; \ntotal ++ ; \n} \n} \nif ( total < xt ) for ( run = total ; \nrun < xt ; \nrun ++ ) bdata [ run ] = 0 ; \nreturn bdata ; \n} \n} \n"}
{"5097": "public class NcDDS { \nprivate BaseType createVariable ( NetcdfFile ncfile , Variable v ) { \nBaseType bt ; \nif ( v . getRank ( ) == 0 ) bt = createScalarVariable ( ncfile , v ) ; \nelse if ( v . getDataType ( ) == DataType . CHAR ) if ( v . getRank ( ) > 1 ) bt = new NcSDCharArray ( v ) ; \nelse bt = new NcSDString ( v ) ; \nelse if ( v . getDataType ( ) == DataType . STRING ) if ( v . getRank ( ) == 0 ) bt = new NcSDString ( v ) ; \nelse bt = new NcSDArray ( v , new NcSDString ( v ) ) ; \nelse bt = createArray ( ncfile , v ) ; \nreturn bt ; \n} \n} \n"}
{"5102": "public class NavigatedPanel { \npublic void setProjectionImpl ( ProjectionImpl p ) { \nif ( geoSelection != null ) { \nLatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; \nsetGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; \n} \nproject = p ; \nnavigate . setMapArea ( project . getDefaultMapArea ( ) ) ; \nif ( Debug . isSet ( \"projection/set\" ) || debugNewProjection ) System . out . println ( \"projection/set NP=\" + project ) ; \nif ( hasReference ) refWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; \n} \n} \n"}
{"5104": "public class NavigatedPanel { \nprivate void redrawLater ( int delay ) { \nboolean already = ( redrawTimer != null ) && ( redrawTimer . isRunning ( ) ) ; \nif ( debugThread ) System . out . println ( \"redrawLater isRunning= \" + already ) ; \nif ( already ) return ; \nif ( redrawTimer == null ) redrawTimer = new javax . swing . Timer ( 0 , new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent e ) { \ndrawG ( ) ; \nredrawTimer . stop ( ) ; \n} \n} \n) ; \nredrawTimer . setDelay ( delay ) ; \nredrawTimer . start ( ) ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) System . out . println ( \"NavigatedPanel newScreenSize old= \" + myBounds ) ; \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) System . out . println ( \"  newBounds = \" + b ) ; \nif ( ( b . width > 0 ) && ( b . height > 0 ) ) bImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \nelse bImage = null ; \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) return ; \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nwhile ( vp . isMemberOfStructure ( ) ) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nwhile ( gp . getParentGroup ( ) != null ) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \nfor ( int i = 1 ; \ni < gchain . size ( ) ; \ni ++ ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) return ; \npathList . add ( vnode ) ; \nfor ( int i = 1 ; \ni < vchain . size ( ) ; \ni ++ ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) return ; \npathList . add ( vnode ) ; \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \n} \n} \n"}
{"5114": "public class GradsDataDescriptorFile { \nprivate void swapByteOrder ( ) { \nString arch = System . getProperty ( \"os.arch\" ) ; \nif ( arch . equals ( \"x86\" ) || arch . equals ( \"arm\" ) || arch . equals ( \"x86_64\" ) || arch . equals ( \"amd64\" ) || arch . equals ( \"alpha\" ) ) bigEndian = true ; \nelse bigEndian = false ; \n} \n} \n"}
{"5115": "public class GradsDataDescriptorFile { \npublic int [ ] getTimeStepsPerFile ( String filename ) { \nif ( chsubs != null ) for ( Chsub ch : chsubs ) { \nif ( filename . contains ( ch . subString ) ) return new int [ ] { \nch . numTimes , ch . startTimeIndex } \n; \n} \nreturn new int [ ] { \ntimeStepsPerFile , 0 } \n; \n} \n} \n"}
{"5116": "public class GradsDataDescriptorFile { \npublic String getFileName ( int eIndex , int tIndex ) { \nString dataFilePath = dataFile ; \nif ( ( getTemplateType ( ) == ENS_TEMPLATE ) || ( getTemplateType ( ) == ENS_TIME_TEMPLATE ) ) dataFilePath = getEnsembleDimension ( ) . replaceFileTemplate ( dataFilePath , eIndex ) ; \ndataFilePath = getTimeDimension ( ) . replaceFileTemplate ( dataFilePath , tIndex ) ; \nif ( ( chsubs != null ) && ( dataFilePath . contains ( CHSUB_TEMPLATE_ID ) ) ) for ( Chsub ch : chsubs ) { \nif ( ( tIndex >= ch . startTimeIndex ) && ( tIndex <= ch . endTimeIndex ) ) { \ndataFilePath = dataFilePath . replace ( CHSUB_TEMPLATE_ID , ch . subString ) ; \nbreak ; \n} \n} \nreturn getFullPath ( dataFilePath ) ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) fileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) templateType = ENS_TIME_TEMPLATE ; \nelse templateType = TIME_TEMPLATE ; \nelse if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) templateType = ENS_TEMPLATE ; \nelse templateType = TIME_TEMPLATE ; \nif ( templateType == ENS_TEMPLATE ) for ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) fileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) for ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) fileSet . add ( file ) ; \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5118": "public class GradsDataDescriptorFile { \nprivate String getDDFPath ( ) { \nif ( pathToDDF == null ) { \nint lastSlash = ddFile . lastIndexOf ( \"/\" ) ; \nif ( lastSlash < 0 ) lastSlash = ddFile . lastIndexOf ( File . separator ) ; \npathToDDF = ( lastSlash < 0 ) ? \"\" : ddFile . substring ( 0 , lastSlash + 1 ) ; \n} \nreturn pathToDDF ; \n} \n} \n"}
{"5119": "public class GradsDataDescriptorFile { \nprivate String getFullPath ( String filename ) { \nString file ; \nString ddfPath = getDDFPath ( ) ; \nif ( filename . startsWith ( \"^\" ) ) { \nfile = filename . replace ( \"^\" , \"\" ) ; \nfile = ddfPath + file ; \n} \nelse { \nFile f = new File ( filename ) ; \nif ( ! f . isAbsolute ( ) ) file = ddfPath + filename ; \nelse file = filename ; \n} \nreturn file ; \n} \n} \n"}
{"5120": "public class GradsDataDescriptorFile { \nprivate void addChsub ( Chsub sub ) { \nif ( chsubs == null ) chsubs = new ArrayList < > ( ) ; \nchsubs . add ( sub ) ; \n} \n} \n"}
{"5121": "public class TimeCoordIntvDateValue { \npublic TimeCoordIntvValue convertReferenceDate ( CalendarDate refDate , CalendarPeriod timeUnit ) { \nif ( timeUnit == null ) throw new IllegalArgumentException ( \"null time unit\" ) ; \nint startOffset = timeUnit . getOffset ( refDate , start ) ; \nint endOffset = timeUnit . getOffset ( refDate , end ) ; \nreturn new TimeCoordIntvValue ( startOffset , endOffset ) ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) return 0 ; \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { \nnoHeader = true ; \nreturn 1 ; \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \nreturn 1 ; \n} \nelse if ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \nreturn 1 ; \n} \nelse return 0 ; \n} \n} \n"}
{"5124": "public class Nidsheader { \nint pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { \nint vlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) vlen = vlen + dlen [ i ] ; \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"graphicSymbolSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"special graphic symbol for code \" + code ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . FLOAT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . FLOAT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5126": "public class Nidsheader { \nint checkMsgHeader ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint rc ; \nlong actualSize ; \nint readLen ; \nactualSize = raf . length ( ) ; \nint pos = 0 ; \nraf . seek ( pos ) ; \nreadLen = ( int ) actualSize ; \nbyte [ ] b = new byte [ readLen ] ; \nrc = raf . read ( b ) ; \nif ( rc != readLen ) log . warn ( \" error reading nids product header \" + raf . getLocation ( ) ) ; \nByteBuffer bos = ByteBuffer . wrap ( b ) ; \nreturn read_msghead ( bos , 0 ) ; \n} \n} \n"}
{"5129": "public class Nidsheader { \nint pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nVariable v ; \nint vlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) vlen = vlen + dlen [ i ] ; \nDimension sDim = new Dimension ( \"unlinkedVectorSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"unlinkedVectorStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Unlinked Vector Packet\" ) ) ; \nv = new Variable ( ncfile , null , null , \"iValue\" ) ; \nv . setDataType ( DataType . SHORT ) ; \nv . setDimensions ( ( String ) null ) ; \ndist . addMemberVariable ( v ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"x_end\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nVariable jj1 = new Variable ( ncfile , null , dist , \"y_end\" ) ; \njj1 . setDimensions ( ( String ) null ) ; \njj1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj1 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nint ival ; \nint isign ; \nfor ( int i = 0 ; \ni < nlevel ; \ni ++ ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ( ival & 0x00008000 ) == 0 ) { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \nelse levels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \nreturn levels ; \n} \n} \n"}
{"5131": "public class Nidsheader { \npublic int [ ] getDualpolLevels ( short [ ] th ) { \nint inc = th . length ; \nint [ ] levels = new int [ inc ] ; \nfor ( int i = 0 ; \ni < inc ; \ni ++ ) levels [ i ] = th [ i ] ; \nreturn levels ; \n} \n} \n"}
{"5135": "public class Nidsheader { \nint getUInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni ++ ) bv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \nfor ( i = num - 1 ; \ni >= 0 ; \ni -- ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5136": "public class Nidsheader { \nint getInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni ++ ) bv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \nif ( bv [ 0 ] > 127 ) { \nbv [ 0 ] -= 128 ; \nbase = - 1 ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni -- ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5137": "public class Nidsheader { \nprotected Object convert ( byte [ ] barray , DataType dataType , int nelems , int byteOrder ) { \nif ( dataType == DataType . BYTE ) return barray ; \nif ( dataType == DataType . CHAR ) return IospHelper . convertByteToChar ( barray ) ; \nByteBuffer bbuff = ByteBuffer . wrap ( barray ) ; \nif ( byteOrder >= 0 ) bbuff . order ( byteOrder == ucar . unidata . io . RandomAccessFile . LITTLE_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; \nif ( dataType == DataType . SHORT ) { \nShortBuffer tbuff = bbuff . asShortBuffer ( ) ; \nshort [ ] pa = new short [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . INT ) { \nIntBuffer tbuff = bbuff . asIntBuffer ( ) ; \nint [ ] pa = new int [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . FLOAT ) { \nFloatBuffer tbuff = bbuff . asFloatBuffer ( ) ; \nfloat [ ] pa = new float [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . DOUBLE ) { \nDoubleBuffer tbuff = bbuff . asDoubleBuffer ( ) ; \ndouble [ ] pa = new double [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nthrow new IllegalStateException ( ) ; \n} \n} \n"}
{"5140": "public class DapController { \nprotected void senderror ( DapRequest drq , int httpcode , Throwable t ) throws IOException { \nif ( httpcode == 0 ) httpcode = HttpServletResponse . SC_BAD_REQUEST ; \nErrorResponse err = new ErrorResponse ( ) ; \nerr . setCode ( httpcode ) ; \nif ( t == null ) err . setMessage ( \"Servlet error: \" + drq . getURL ( ) ) ; \nelse { \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter p = new PrintWriter ( sw ) ; \nt . printStackTrace ( p ) ; \np . close ( ) ; \nsw . close ( ) ; \nerr . setMessage ( sw . toString ( ) ) ; \n} \nerr . setContext ( drq . getURL ( ) ) ; \nString errormsg = err . buildXML ( ) ; \ndrq . getResponse ( ) . sendError ( httpcode , errormsg ) ; \n} \n} \n"}
{"5142": "public class Rubberband { \npublic void stretch ( Point p ) { \nlastPt . x = stretchedPt . x ; \nlastPt . y = stretchedPt . y ; \nstretchedPt . x = p . x ; \nstretchedPt . y = p . y ; \nGraphics2D g = ( Graphics2D ) component . getGraphics ( ) ; \nif ( g != null ) try { \ng . setXORMode ( component . getBackground ( ) ) ; \nif ( firstStretch == true ) firstStretch = false ; \nelse drawLast ( g ) ; \ndrawNext ( g ) ; \n} \nfinally { \ng . dispose ( ) ; \n} \n} \n} \n"}
{"5154": "public class GribNumbers { \npublic static float float4 ( int a , int b , int c , int d ) { \nint sgn , mant , exp ; \nmant = b << 16 | c << 8 | d ; \nif ( mant == 0 ) return 0.0f ; \nsgn = - ( ( ( a & 128 ) >> 6 ) - 1 ) ; \nexp = ( a & 127 ) - 64 ; \nreturn ( float ) ( sgn * Math . pow ( 16.0 , exp - 6 ) * mant ) ; \n} \n} \n"}
{"5164": "public class DGrid { \npublic int projectedComponents ( boolean constrained ) { \nint comp ; \nif ( constrained ) { \ncomp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; \nEnumeration e = mapVars . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) if ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp ++ ; \n} \nelse comp = 1 + mapVars . size ( ) ; \nreturn comp ; \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; \nif ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) exceedLimit = true ; \nString id = ds . getID ( ) ; \nif ( id != null ) if ( idMap . contains ( id ) ) logCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \nelse idMap . add ( id ) ; \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) href = href . substring ( 2 ) ; \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) path = href . substring ( contextPathPlus . length ( ) ) ; \nelse if ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse path = dirPath + href ; \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse processDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \n} \n"}
{"5186": "public class BaseQuantity { \npublic int compareTo ( final BaseQuantity that ) { \nint comp ; \nif ( this == that ) comp = 0 ; \nelse { \ncomp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; \nif ( comp == 0 && getSymbol ( ) != null ) comp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; \n} \nreturn comp ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse if ( ( b & 0xE0 ) != 0xE0 ) buffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \n} \n} \n"}
{"5202": "public class Grib1SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( startingPosition <= 0 ) throw new IllegalStateException ( \"Grib1 Bit map has bad starting position\" ) ; \nraf . seek ( startingPosition ) ; \nint length = GribNumbers . uint3 ( raf ) ; \nraf . read ( ) ; \nint bm = raf . readShort ( ) ; \nif ( bm != 0 ) { \nlogger . warn ( \"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\" , bm ) ; \nreturn null ; \n} \nif ( length <= 6 || length > 10e6 ) return null ; \nint n = length - 6 ; \nbyte [ ] data = new byte [ n ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"5226": "public class GridVariable { \nvoid addProduct ( GridRecord record ) { \nrecords . add ( record ) ; \nif ( firstRecord == null ) firstRecord = record ; \n} \n} \n"}
{"5228": "public class GridVariable { \npublic int showMissingSummary ( Formatter f ) { \nint count = 0 ; \nint total = recordTracker . length ; \nfor ( int i = 0 ; \ni < total ; \ni ++ ) if ( recordTracker [ i ] == null ) count ++ ; \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn count ; \n} \n} \n"}
{"5229": "public class GridVariable { \npublic GridRecord findRecord ( int ens , int time , int level ) { \nif ( hasEnsemble ( ) ) return recordTracker [ ens * ( ntimes * nlevels ) + ( time * nlevels ) + level ] ; \nelse return recordTracker [ time * nlevels + level ] ; \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) return true ; \nif ( b1 == null || b2 == null ) return false ; \nif ( b1 . length < len || b2 . length < len ) return false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) if ( b1 [ i ] != b2 [ i ] ) return false ; \nreturn true ; \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < nlats ; \ni ++ ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( int i = 0 ; \ni < nyRaw ; \ni ++ ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) useIndex ++ ; \nelse useIndex -- ; \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( pos1 < 0 ) varNameEsc = selector ; \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) System . out . println ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" ) ; \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse section = v . getShapeAsSection ( ) ; \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5241": "public class HTTPMethod { \npublic synchronized void close ( ) { \nif ( closed ) return ; \nclosed = true ; \nif ( methodstream != null ) { \ntry { \nthis . methodstream . close ( ) ; \n} \ncatch ( IOException ioe ) { \n} \nthis . methodstream = null ; \n} \nif ( this . lastresponse != null ) { \nif ( false ) try { \ntry { \nEntityUtils . consume ( this . lastresponse . getEntity ( ) ) ; \n} \nfinally { \nHttpClientUtils . closeQuietly ( this . lastresponse ) ; \n} \n} \ncatch ( IOException ignore ) { \n} \nelse HttpClientUtils . closeQuietly ( this . lastresponse ) ; \nthis . lastresponse = null ; \n} \nif ( session != null ) { \nsession . removeMethod ( this ) ; \nif ( localsession ) { \nsession . close ( ) ; \nsession = null ; \n} \n} \nthis . lastrequest = null ; \n} \n} \n"}
{"5246": "public class CBZip2InputStream { \npublic int read ( ) { \nif ( streamEnd ) return - 1 ; \nelse { \nint retChar = currentChar ; \nswitch ( currentState ) { \ncase START_BLOCK_STATE : break ; \ncase RAND_PART_A_STATE : break ; \ncase RAND_PART_B_STATE : setupRandPartB ( ) ; \nbreak ; \ncase RAND_PART_C_STATE : setupRandPartC ( ) ; \nbreak ; \ncase NO_RAND_PART_A_STATE : break ; \ncase NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; \nbreak ; \ncase NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; \nbreak ; \ndefault : break ; \n} \nreturn retChar ; \n} \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( pm . isCanceled ( ) ) task . cancel ( ) ; \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5255": "public class GribCollectionMutable { \nvoid setIndexRaf ( RandomAccessFile indexRaf ) { \nthis . indexRaf = indexRaf ; \nif ( indexRaf != null ) this . indexFilename = indexRaf . getLocation ( ) ; \n} \n} \n"}
{"5267": "public class GempakSurfaceFileReader { \nprotected void makeFileSubType ( ) { \nKey key = findKey ( GempakStation . SLAT ) ; \nif ( key == null ) throw new IllegalStateException ( \"File does not have key=\" + GempakStation . SLAT ) ; \nString latType = key . type ; \nKey dateKey = findKey ( DATE ) ; \nif ( dateKey != null && ! dateKey . type . equals ( latType ) ) if ( latType . equals ( ROW ) ) subType = CLIMATE ; \nelse subType = STANDARD ; \nelse subType = SHIP ; \n} \n} \n"}
{"5273": "public class ChunkWriter { \nvoid sendDXR ( byte [ ] dxr8 ) throws IOException { \nif ( dxr8 == null || dxr8 . length == 0 ) return ; \nif ( mode == RequestMode . DMR || mode == RequestMode . DSR ) state = State . END ; \nelse { \nint flags = DapUtil . CHUNK_DATA ; \nif ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; \nchunkheader ( dxr8 . length , flags , this . header ) ; \noutput . write ( DapUtil . extract ( this . header ) ) ; \nstate = State . DATA ; \n} \noutput . write ( dxr8 ) ; \noutput . flush ( ) ; \n} \n} \n"}
{"5274": "public class ChunkWriter { \npublic void writeError ( int httpcode , String msg , String cxt , String other ) throws IOException { \ndmr8 = null ; \nErrorResponse response = new ErrorResponse ( httpcode , msg , cxt , other ) ; \nString errorbody = response . buildXML ( ) ; \nbyte [ ] errbody8 = DapUtil . extract ( DapUtil . UTF8 . encode ( errorbody ) ) ; \nif ( mode == RequestMode . DMR ) sendDXR ( errbody8 ) ; \nelse { \nchunk . clear ( ) ; \nint flags = DapUtil . CHUNK_ERROR | DapUtil . CHUNK_END ; \nchunkheader ( errbody8 . length , flags , header ) ; \noutput . write ( DapUtil . extract ( header ) ) ; \noutput . write ( errbody8 ) ; \noutput . flush ( ) ; \n} \nstate = State . ERROR ; \n} \n} \n"}
{"5275": "public class ChunkWriter { \npublic void close ( ) throws IOException { \nif ( closed ) return ; \nclosed = true ; \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \nif ( mode == RequestMode . DMR ) return ; \nif ( chunk == null || chunk . position ( ) == 0 ) return ; \nverifystate ( ) ; \nstate = State . DATA ; \nint flags = DapUtil . CHUNK_END ; \nwriteChunk ( flags ) ; \nstate = State . END ; \nthis . output . flush ( ) ; \nif ( this . saveoutput != null ) this . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; \n} \n} \n"}
{"5282": "public class N3raf { \nprotected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { \nlong count = 0 ; \nif ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) while ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; \n} \nelse if ( dataType . getPrimitiveClassType ( ) == short . class ) while ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; \n} \nelse if ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) while ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; \n} \nelse if ( ( dataType == DataType . DOUBLE ) || dataType . getPrimitiveClassType ( ) == long . class ) while ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \nreturn count ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \nfor ( long tnum = trackerNumber - 1 ; \ntnum > 0 ; \ntnum -- ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) break ; \nif ( oldDatabaseFile . delete ( ) ) catalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \nelse catalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \n} \n} \n"}
{"5288": "public class McIDASAreaProjection { \nprivate double [ ] makeDoubleArray ( int [ ] ints ) { \ndouble [ ] newArray = new double [ ints . length ] ; \nfor ( int i = 0 ; \ni < ints . length ; \ni ++ ) newArray [ i ] = ints [ i ] ; \nreturn newArray ; \n} \n} \n"}
{"5292": "public class Dap4Controller { \n@ Override public String getResourcePath ( DapRequest drq , String location ) throws DapException { \nString realpath ; \nif ( TdsRequestedDataset . getDatasetManager ( ) != null ) realpath = TdsRequestedDataset . getLocationFromRequestPath ( location ) ; \nelse { \nassert TdsRequestedDataset . getDatasetManager ( ) == null ; \nString prefix = drq . getResourceRoot ( ) ; \nassert ( prefix != null ) ; \nrealpath = DapUtil . canonjoin ( prefix , location ) ; \n} \nif ( ! TESTING ) if ( ! TdsRequestedDataset . resourceControlOk ( drq . getRequest ( ) , drq . getResponse ( ) , realpath ) ) throw new DapException ( \"Not authorized: \" + location ) . setCode ( DapCodes . SC_FORBIDDEN ) ; \nFile f = new File ( realpath ) ; \nif ( ! f . exists ( ) || ! f . canRead ( ) ) throw new DapException ( \"Not found: \" + location ) . setCode ( DapCodes . SC_NOT_FOUND ) ; \nreturn realpath ; \n} \n} \n"}
{"5293": "public class GridIndexToNC { \nprivate void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { \nGridVertCoord gvcs0 = null ; \nint maxLevels = 0 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs . getNLevels ( ) > maxLevels ) { \ngvcs0 = gvcs ; \nmaxLevels = gvcs . getNLevels ( ) ; \n} \n} \nint seqno = 1 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs != gvcs0 ) gvcs . setSequence ( seqno ++ ) ; \ngvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; \n} \n} \n} \n"}
{"5294": "public class FysatHeader { \nboolean readPIB ( RandomAccessFile raf ) throws IOException { \nthis . firstHeader = new AwxFileFirstHeader ( ) ; \nint pos = 0 ; \nraf . seek ( pos ) ; \nbyte [ ] buf = new byte [ FY_AWX_PIB_LEN ] ; \nint count = raf . read ( buf ) ; \nEndianByteBuffer byteBuffer ; \nif ( count == FY_AWX_PIB_LEN ) { \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nthis . firstHeader . fillHeader ( byteBuffer ) ; \n} \nelse return false ; \nif ( ! ( ( this . firstHeader . fileName . endsWith ( \".AWX\" ) || this . firstHeader . fileName . endsWith ( \".awx\" ) ) && this . firstHeader . firstHeaderLength == FY_AWX_PIB_LEN ) ) return false ; \nbuf = new byte [ this . firstHeader . secondHeaderLength ] ; \nraf . readFully ( buf ) ; \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nswitch ( this . firstHeader . typeOfProduct ) { \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_UNDEFINED : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GEOSAT_IMAGE : secondHeader = new AwxFileGeoSatelliteSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_POLARSAT_IMAGE : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRID : secondHeader = new AwxFileGridProductSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_DISCREET : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRAPH_ANALIYSIS : throw new UnsupportedDatasetException ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"5295": "public class InvDatasetImpl { \npublic boolean finish ( ) { \nboolean ok = true ; \njava . util . Iterator iter ; \nlogger . debug ( \"Now finish \" + getName ( ) + \" id= \" + getID ( ) ) ; \nauthorityName = null ; \ndataType = null ; \ndataFormatType = null ; \ndefaultService = null ; \ngc = null ; \ntc = null ; \ndocs = new ArrayList < > ( ) ; \nmetadata = new ArrayList < > ( ) ; \nproperties = new ArrayList < > ( ) ; \ncreators = new ArrayList < > ( ) ; \ncontributors = new ArrayList < > ( ) ; \ndates = new ArrayList < > ( ) ; \nkeywords = new ArrayList < > ( ) ; \nprojects = new ArrayList < > ( ) ; \npublishers = new ArrayList < > ( ) ; \nvariables = new ArrayList < > ( ) ; \ncanonicalize ( ) ; \ntransfer2PublicMetadata ( tm , true ) ; \ntransfer2PublicMetadata ( tmi , true ) ; \ntransferInheritable2PublicMetadata ( ( InvDatasetImpl ) getParent ( ) ) ; \naccess = new ArrayList < > ( ) ; \nif ( ( urlPath != null ) && ( getServiceDefault ( ) != null ) ) { \nInvAccessImpl a = new InvAccessImpl ( this , urlPath , getServiceDefault ( ) ) ; \na . setSize ( size ) ; \na . finish ( ) ; \naddExpandedAccess ( a ) ; \n} \niter = accessLocal . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvAccessImpl a = ( InvAccessImpl ) iter . next ( ) ; \na . finish ( ) ; \naddExpandedAccess ( a ) ; \n} \nif ( ! ( this instanceof InvCatalogRef ) ) for ( InvDataset invDataset : this . getDatasets ( ) ) { \nInvDatasetImpl curDs = ( InvDatasetImpl ) invDataset ; \nok &= curDs . finish ( ) ; \n} \nreturn ok ; \n} \n} \n"}
{"5306": "public class InvDatasetImpl { \npublic boolean removeLocalMetadata ( InvMetadata metadata ) { \nInvDatasetImpl parentDataset = ( ( InvDatasetImpl ) metadata . getParentDataset ( ) ) ; \nList localMdata = parentDataset . getLocalMetadata ( ) . getMetadata ( ) ; \nif ( localMdata . contains ( metadata ) ) if ( localMdata . remove ( metadata ) ) { \nhashCode = 0 ; \nreturn ( true ) ; \n} \nreturn ( false ) ; \n} \n} \n"}
{"5308": "public class DatasetNamer { \nboolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( this . msgLog . length ( ) > 0 ) out . append ( this . msgLog ) ; \nif ( this . getName ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (1): null value for name is not valid.\" ) ; \n} \nif ( this . getType ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (3): null value for type is not valid (set with bad string?).\" ) ; \n} \nif ( this . getType ( ) == DatasetNamerType . REGULAR_EXPRESSION && ( this . getMatchPattern ( ) == null || this . getSubstitutePattern ( ) == null ) ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (4): invalid datasetNamer <\" + this . getName ( ) + \">;\" + \" type is \" + this . getType ( ) . toString ( ) + \": matchPattern(\" + this . getMatchPattern ( ) + \") and substitutionPattern(\" + this . getSubstitutePattern ( ) + \") \" + \"must not be null.\" ) ; \n} \nif ( this . getType ( ) == DatasetNamerType . DODS_ATTRIBUTE && ( this . getAttribContainer ( ) == null || this . getAttribName ( ) == null ) ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (5): invalid datasetNamer <\" + this . getName ( ) + \">;\" + \" type is \" + this . getType ( ) . toString ( ) + \": attriuteContainer(\" + this . getAttribContainer ( ) + \") and attributeName(\" + this . getAttribName ( ) + \") must not be null.\" ) ; \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"5312": "public class WFSController { \nprivate WFSExceptionWriter getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName , String fullFtName ) { \nList < SimpleGeometry > geometryList = new ArrayList < SimpleGeometry > ( ) ; \nGeometryType geoT = sgcs . getGeometryType ( ftName ) ; \nif ( geoT == null ) return new WFSExceptionWriter ( \"Feature Type of \" + fullFtName + \" not found.\" , \"GetFeature\" , \"OperationProcessingFailed\" ) ; \ntry { \nswitch ( geoT ) { \ncase POINT : Point pt = sgcs . getPoint ( ftName , 0 ) ; \nint j = 0 ; \nwhile ( pt != null ) { \ngeometryList . add ( pt ) ; \nj ++ ; \npt = sgcs . getPoint ( ftName , j ) ; \n} \nbreak ; \ncase LINE : Line line = sgcs . getLine ( ftName , 0 ) ; \nint k = 0 ; \nwhile ( line != null ) { \ngeometryList . add ( line ) ; \nk ++ ; \nline = sgcs . getLine ( ftName , k ) ; \n} \nbreak ; \ncase POLYGON : Polygon poly = sgcs . getPolygon ( ftName , 0 ) ; \nint i = 0 ; \nwhile ( poly != null ) { \ngeometryList . add ( poly ) ; \ni ++ ; \npoly = sgcs . getPolygon ( ftName , i ) ; \n} \nbreak ; \n} \n} \ncatch ( ArrayIndexOutOfBoundsException aout ) { \n} \nWFSGetFeatureWriter gfdw = new WFSGetFeatureWriter ( out , WFSController . constructServerPath ( hsreq ) , WFSController . getXMLNamespaceXMLNSValue ( hsreq ) , geometryList , ftName ) ; \ngfdw . startXML ( ) ; \ngfdw . writeMembers ( ) ; \ngfdw . finishXML ( ) ; \nreturn null ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) if ( ! service . equalsIgnoreCase ( \"WFS\" ) ) return new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \nelse return new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( int ind = 0 ; \nind < versionParts . length ; \nind ++ ) try { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \nif ( ! validVersion ) return new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \nelse return new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \nif ( typeName == null ) return new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nelse return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \nreturn null ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nwhile ( paramNamesE . hasMoreElements ( ) ) paramNames . add ( paramNamesE . nextElement ( ) ) ; \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( hsreq . getServletPath ( ) . length ( ) > 4 ) datasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( actualPath != null ) dataset = NetcdfDataset . openDataset ( actualPath ) ; \nelse return ; \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) request = hsreq . getParameter ( paramName ) ; \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) version = hsreq . getParameter ( paramName ) ; \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) service = hsreq . getParameter ( paramName ) ; \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) || paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) actualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( paramError == null ) { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nelse { \nparamError . write ( hsres ) ; \nreturn ; \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \n} \n} \n"}
{"5316": "public class CrawlableDatasetAmazonS3 { \n@ Override public long length ( ) { \nS3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; \nif ( objectSummary != null ) return objectSummary . getSize ( ) ; \nObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; \nif ( metadata != null ) return metadata . getContentLength ( ) ; \nelse return 0 ; \n} \n} \n"}
{"5317": "public class CrawlableDatasetAmazonS3 { \n@ Override public Date lastModified ( ) { \nS3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; \nif ( objectSummary != null ) return objectSummary . getLastModified ( ) ; \nObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; \nif ( metadata != null ) return metadata . getLastModified ( ) ; \nelse return null ; \n} \n} \n"}
{"5332": "public class FeatureDatasetCapabilitiesWriter { \npublic Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nif ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) throw new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + \" not a StationTimeSeriesFeatureCollection\" ) ; \nStationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; \nElement rootElem = new Element ( \"stationCollection\" ) ; \nDocument doc = new Document ( rootElem ) ; \nList < StationFeature > stations ; \nif ( bb != null ) stations = sobs . getStationFeatures ( bb ) ; \nelse if ( names != null ) stations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; \nelse stations = sobs . getStationFeatures ( ) ; \nfor ( Station s : stations ) { \nElement sElem = new Element ( \"station\" ) ; \nsElem . setAttribute ( \"name\" , s . getName ( ) ) ; \nif ( s . getWmoId ( ) != null ) sElem . setAttribute ( \"wmo_id\" , s . getWmoId ( ) ) ; \nif ( ( s . getDescription ( ) != null ) && ( s . getDescription ( ) . length ( ) > 0 ) ) sElem . addContent ( new Element ( \"description\" ) . addContent ( s . getDescription ( ) ) ) ; \nsElem . addContent ( new Element ( \"longitude\" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; \nsElem . addContent ( new Element ( \"latitide\" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; \nif ( ! Double . isNaN ( s . getAltitude ( ) ) ) sElem . addContent ( new Element ( \"altitude\" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; \nrootElem . addContent ( sElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) return ; \nfor ( int i = 0 ; \ni < getItemCount ( ) ; \ni ++ ) if ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( int i = lastpos - 1 ; \ni >= firstpos ; \ni -- ) if ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \nelse { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5342": "public class OptSwitch { \npublic void SetHasValue ( int type ) { \nthis . type = type ; \nif ( debug ) System . out . println ( \"sw = \" + ( char ) sw + \"; type = \" + type + \"; set = \" + set + \"; val = \" + val ) ; \n} \n} \n"}
{"5343": "public class Grib1GdsPredefined { \npublic static Grib1Gds factory ( int center , int gridNumber ) { \nif ( center == 7 ) return factoryNCEP ( gridNumber ) ; \nelse throw new IllegalArgumentException ( \"Dont have predefined GDS \" + gridNumber + \" from \" + center ) ; \n} \n} \n"}
{"5350": "public class IO { \nstatic public void copyDirTree ( String fromDirName , String toDirName ) throws IOException { \nFile fromDir = new File ( fromDirName ) ; \nFile toDir = new File ( toDirName ) ; \nif ( ! fromDir . exists ( ) ) return ; \nif ( ! toDir . exists ( ) ) if ( ! toDir . mkdirs ( ) ) throw new IOException ( \"Could not create directory: \" + toDir ) ; \nFile [ ] files = fromDir . listFiles ( ) ; \nif ( files != null ) for ( File f : files ) { \nif ( f . isDirectory ( ) ) copyDirTree ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \nelse copyFile ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \n} \n} \n} \n"}
{"5358": "public class DTSServlet { \npublic void badURL ( HttpServletRequest request , HttpServletResponse response ) throws Exception { \nif ( Debug . isSet ( \"showResponse\" ) ) log . debug ( \"Sending Bad URL Page.\" ) ; \nresponse . setContentType ( \"text/html\" ) ; \nresponse . setHeader ( \"XDODS-Server\" , getServerVersion ( ) ) ; \nresponse . setHeader ( \"Content-Description\" , \"dods-error\" ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( response . getOutputStream ( ) , Util . UTF8 ) ) ; \nprintBadURLPage ( pw ) ; \nprintHelpPage ( pw ) ; \npw . flush ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_OK ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) continue ; \nsb . setCharAt ( pos , replaceChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5369": "public class StringUtil2 { \nstatic public String filter ( String x , String okChars ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) sb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) return null ; \nchar [ ] bo = new char [ s . length ( ) ] ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\\n' ) || ( c == '\\t' ) ) ) bo [ count ++ ] = c ; \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5372": "public class StringUtil2 { \nstatic public int match ( String s1 , String s2 ) { \nint i = 0 ; \nwhile ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { \nif ( s1 . charAt ( i ) != s2 . charAt ( i ) ) break ; \ni ++ ; \n} \nreturn i ; \n} \n} \n"}
{"5373": "public class StringUtil2 { \npublic static String padLeft ( String s , int desiredLength , String padString ) { \nwhile ( s . length ( ) < desiredLength ) s = padString + s ; \nreturn s ; \n} \n} \n"}
{"5374": "public class StringUtil2 { \npublic static String padRight ( String s , int desiredLength , String padString ) { \nStringBuilder ret = new StringBuilder ( s ) ; \nwhile ( ret . length ( ) < desiredLength ) ret . append ( padString ) ; \nreturn ret . toString ( ) ; \n} \n} \n"}
{"5375": "public class StringUtil2 { \nstatic public String remove ( String s , String sub ) { \nint len = sub . length ( ) ; \nint pos ; \nwhile ( 0 <= ( pos = s . indexOf ( sub ) ) ) s = s . substring ( 0 , pos ) + s . substring ( pos + len ) ; \nreturn s ; \n} \n} \n"}
{"5376": "public class StringUtil2 { \nstatic public String remove ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) return s ; \nStringBuilder buff = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( i < buff . length ( ) ) if ( buff . charAt ( i ) == c ) buff . deleteCharAt ( i ) ; \nelse i ++ ; \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nint len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! Character . isWhitespace ( c ) ) b . append ( c ) ; \nelse { \nb . append ( ' ' ) ; \nwhile ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) i ++ ; \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5379": "public class StringUtil2 { \nstatic public String replace ( String s , char out , String in ) { \nif ( s . indexOf ( out ) < 0 ) return s ; \nStringBuilder sb = new StringBuilder ( s ) ; \nreplace ( sb , out , in ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5380": "public class StringUtil2 { \nstatic public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { \nboolean ok = true ; \nfor ( char aReplaceChar : replaceChar ) { \nint pos = x . indexOf ( aReplaceChar ) ; \nok = ( pos < 0 ) ; \nif ( ! ok ) break ; \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int i = 0 ; \ni < replaceChar . length ; \ni ++ ) { \nint pos = x . indexOf ( replaceChar [ i ] ) ; \nif ( pos >= 0 ) replace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5383": "public class StringUtil2 { \nstatic public String substitute ( String original , String [ ] match , String [ ] subst ) { \nboolean ok = true ; \nfor ( String aMatch : match ) { \nif ( original . contains ( aMatch ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return original ; \nStringBuilder sb = new StringBuilder ( original ) ; \nfor ( int i = 0 ; \ni < match . length ; \ni ++ ) substitute ( sb , match [ i ] , subst [ i ] ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nwhile ( i < sb . length ( ) ) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) if ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \nif ( ok ) i ++ ; \n} \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \nfor ( int i = 0 ; \ni < sb . length ( ) ; \ni ++ ) { \nint c = sb . charAt ( i ) ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) if ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; \n} \n} \n} \n"}
{"5388": "public class StringUtil2 { \nstatic public String trim ( String s , int bad ) { \nint len = s . length ( ) ; \nint st = 0 ; \nwhile ( ( st < len ) && ( s . charAt ( st ) == bad ) ) st ++ ; \nwhile ( ( st < len ) && ( s . charAt ( len - 1 ) == bad ) ) len -- ; \nreturn ( ( st > 0 ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; \n} \n} \n"}
{"5402": "public class TableAnalyzer { \nstatic public TableAnalyzer factory ( TableConfigurer tc , FeatureType wantFeatureType , NetcdfDataset ds ) throws IOException { \nTableAnalyzer analyzer = new TableAnalyzer ( ds , tc ) ; \nif ( tc != null ) { \nif ( tc . getConvName ( ) == null ) analyzer . userAdvice . format ( \" No 'Conventions' global attribute.%n\" ) ; \nelse analyzer . userAdvice . format ( \" Conventions global attribute = %s %n\" , tc . getConvName ( ) ) ; \nif ( tc . getConvUsed ( ) != null ) { \nanalyzer . setConventionUsed ( tc . getConvUsed ( ) ) ; \nif ( ! tc . getConvUsed ( ) . equals ( tc . getConvName ( ) ) ) analyzer . userAdvice . format ( \" TableConfigurer used = \" + tc . getConvUsed ( ) + \".%n\" ) ; \n} \n} \nelse analyzer . userAdvice . format ( \" No TableConfigurer found, using default analysis.%n\" ) ; \nanalyzer . analyze ( wantFeatureType ) ; \nreturn analyzer ; \n} \n} \n"}
{"5405": "public class McIDASGridServiceProvider { \npublic boolean sync ( ) { \ntry { \nif ( ! mcGridReader . init ( ) ) return false ; \nGridIndex index = mcGridReader . getGridIndex ( ) ; \nncfile . empty ( ) ; \nopen ( index , null ) ; \nreturn true ; \n} \ncatch ( IOException ioe ) { \nreturn false ; \n} \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart -- ; \nif ( type . equalsIgnoreCase ( GAUST62 ) ) baseArray = gltst62 ; \nelse if ( type . equalsIgnoreCase ( GAUSR15 ) ) baseArray = glts15 ; \nelse if ( type . equalsIgnoreCase ( GAUSR20 ) ) baseArray = glts20 ; \nelse if ( type . equalsIgnoreCase ( GAUSR30 ) ) baseArray = glts30 ; \nelse if ( type . equalsIgnoreCase ( GAUSR40 ) ) baseArray = glats ; \nelse throw new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \nif ( start + num > baseArray . length ) throw new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \ndouble [ ] retVals = new double [ num ] ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) retVals [ i ] = baseArray [ start + i ] ; \nreturn retVals ; \n} \n} \n"}
{"5410": "public class CSMConvention { \nprotected void findCoordinateAxes ( NetcdfDataset ds ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordAxes == null ) { \nString coordsString = ds . findAttValueIgnoreCase ( vp . v , CF . COORDINATES , null ) ; \nif ( coordsString != null ) vp . coordinates = coordsString ; \n} \n} \nsuper . findCoordinateAxes ( ds ) ; \n} \n} \n"}
{"5415": "public class Group { \npublic void addDimension ( Dimension dim ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( ! dim . isShared ( ) ) throw new IllegalArgumentException ( \"Dimensions added to a group must be shared.\" ) ; \nif ( findDimensionLocal ( dim . getShortName ( ) ) != null ) throw new IllegalArgumentException ( \"Dimension name (\" + dim . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \ndimensions . add ( dim ) ; \ndim . setGroup ( this ) ; \n} \n} \n"}
{"5416": "public class Group { \npublic boolean addDimensionIfNotExists ( Dimension dim ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( ! dim . isShared ( ) ) throw new IllegalArgumentException ( \"Dimensions added to a group must be shared.\" ) ; \nif ( findDimensionLocal ( dim . getShortName ( ) ) != null ) return false ; \ndimensions . add ( dim ) ; \ndim . setGroup ( this ) ; \nreturn true ; \n} \n} \n"}
{"5419": "public class Group { \npublic void addVariable ( Variable v ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( v == null ) return ; \nif ( findVariable ( v . getShortName ( ) ) != null ) throw new IllegalArgumentException ( \"Variable name (\" + v . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \nvariables . add ( v ) ; \nv . setParentGroup ( this ) ; \n} \n} \n"}
{"5422": "public class DDS { \nprivate String convertDDSAliasFieldsToDASAliasFields ( String attribute ) throws MalformedAliasException { \nString prefix = \"\" ; \nVector aNames = tokenizeAliasField ( attribute ) ; \nString topName = ( String ) aNames . get ( 1 ) ; \nboolean foundIt = false ; \nEnumeration e = getVariables ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nBaseType bt = ( BaseType ) e . nextElement ( ) ; \nString normName = normalize ( bt . getEncodedName ( ) ) ; \nif ( topName . equals ( normName ) ) foundIt = true ; \n} \nif ( ! foundIt ) prefix = \".\" + getLooseEndsTableName ( ) ; \nreturn ( prefix + attribute ) ; \n} \n} \n"}
{"5425": "public class GeotiffWriter { \npublic void writeGrid ( GridDataset dataset , GridDatatype grid , Array data , boolean greyScale ) throws IOException { \nGridCoordSystem gcs = grid . getCoordinateSystem ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + grid . getFullName ( ) ) ; \nCoordinateAxis1D xaxis = ( CoordinateAxis1D ) gcs . getXHorizAxis ( ) ; \nCoordinateAxis1D yaxis = ( CoordinateAxis1D ) gcs . getYHorizAxis ( ) ; \ndouble scaler = ( xaxis . getUnitsString ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge ( 0 ) * scaler ; \ndouble xInc = xaxis . getIncrement ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getIncrement ( ) ) * scaler ; \nif ( yaxis . getCoordValue ( 0 ) < yaxis . getCoordValue ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdge ( ( int ) yaxis . getSize ( ) ) * scaler ; \n} \nif ( ! xaxis . isRegular ( ) || ! yaxis . isRegular ( ) ) throw new IllegalArgumentException ( \"Must be evenly spaced grid = \" + grid . getFullName ( ) ) ; \nif ( pageNumber > 1 ) geotiff . initTags ( ) ; \nwriteGrid ( grid , data , greyScale , xStart , yStart , xInc , yInc , pageNumber ) ; \npageNumber ++ ; \n} \n} \n"}
{"5426": "public class GeotiffWriter { \nprivate ArrayFloat replaceMissingValues ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { \nfloat minValue = ( float ) ( dataMinMax . min - 1.0 ) ; \nArrayFloat floatArray = ( ArrayFloat ) Array . factory ( DataType . FLOAT , data . getShape ( ) ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nIndexIterator floatIter = floatArray . getIndexIterator ( ) ; \nwhile ( dataIter . hasNext ( ) ) { \nfloat v = dataIter . getFloatNext ( ) ; \nif ( grid . isMissing ( ( double ) v ) ) v = minValue ; \nfloatIter . setFloatNext ( v ) ; \n} \nreturn floatArray ; \n} \n} \n"}
{"5427": "public class GeotiffWriter { \nprivate ArrayByte replaceMissingValuesAndScale ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { \ndouble scale = 254.0 / ( dataMinMax . max - dataMinMax . min ) ; \nArrayByte byteArray = ( ArrayByte ) Array . factory ( DataType . BYTE , data . getShape ( ) ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nIndexIterator resultIter = byteArray . getIndexIterator ( ) ; \nbyte bv ; \nwhile ( dataIter . hasNext ( ) ) { \ndouble v = dataIter . getDoubleNext ( ) ; \nif ( grid . isMissing ( v ) ) bv = 0 ; \nelse { \nint iv = ( int ) ( ( v - dataMinMax . min ) * scale + 1 ) ; \nbv = ( byte ) ( iv & 0xff ) ; \n} \nresultIter . setByteNext ( bv ) ; \n} \nreturn byteArray ; \n} \n} \n"}
{"5428": "public class GeotiffWriter { \nprivate double geoShiftGetXstart ( Array lon , double inc ) { \nIndex ilon = lon . getIndex ( ) ; \nint [ ] lonShape = lon . getShape ( ) ; \nIndexIterator lonIter = lon . getIndexIterator ( ) ; \ndouble xlon = 0.0 ; \nLatLonPoint p0 = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( 0 ) ) ) ; \nLatLonPoint pN = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( lonShape [ 0 ] - 1 ) ) ) ; \nxlon = p0 . getLongitude ( ) ; \nwhile ( lonIter . hasNext ( ) ) { \nfloat l = lonIter . getFloatNext ( ) ; \nLatLonPoint pn = new LatLonPointImpl ( 0 , l ) ; \nif ( pn . getLongitude ( ) < xlon ) xlon = pn . getLongitude ( ) ; \n} \nif ( p0 . getLongitude ( ) == pN . getLongitude ( ) ) xlon = xlon - inc ; \nreturn xlon ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( pageNumber > 1 ) geotiff . initTags ( ) ; \nint nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( greyScale ) { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nint height = data . getShape ( ) [ 0 ] ; \nint width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber ++ ; \n} \n} \n"}
{"5434": "public class GribCdmIndex { \npublic static boolean updateGribCollection ( FeatureCollectionConfig config , CollectionUpdateType updateType , Logger logger ) throws IOException { \nif ( logger == null ) logger = classLogger ; \nlong start = System . currentTimeMillis ( ) ; \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \nPath rootPath = Paths . get ( specp . getRootDir ( ) ) ; \nboolean isGrib1 = config . type == FeatureCollectionType . GRIB1 ; \nboolean changed ; \nif ( config . ptype == FeatureCollectionConfig . PartitionType . none || config . ptype == FeatureCollectionConfig . PartitionType . all ) try ( CollectionAbstract dcm = new CollectionPathMatcher ( config , specp , logger ) ) { \nchanged = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . none , logger , errlog ) ; \n} \nelse if ( config . ptype == FeatureCollectionConfig . PartitionType . timePeriod ) try ( TimePartition tp = new TimePartition ( config , specp , logger ) ) { \nchanged = updateTimePartition ( isGrib1 , tp , updateType , logger ) ; \n} \nelse if ( specp . wantSubdirs ( ) ) try ( DirectoryPartition dpart = new DirectoryPartition ( config , rootPath , true , new GribCdmIndex ( logger ) , NCX_SUFFIX , logger ) ) { \ndpart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nchanged = updateDirectoryCollectionRecurse ( isGrib1 , dpart , config , updateType , logger ) ; \n} \nelse changed = updateLeafCollection ( isGrib1 , config , updateType , true , logger , rootPath ) ; \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . info ( \"updateGribCollection {} changed {} took {} msecs\" , config . collectionName , changed , took ) ; \nreturn changed ; \n} \n} \n"}
{"5435": "public class GribCdmIndex { \nprivate static boolean updateLeafCollection ( boolean isGrib1 , FeatureCollectionConfig config , CollectionUpdateType updateType , boolean isTop , Logger logger , Path dirPath ) throws IOException { \nif ( config . ptype == FeatureCollectionConfig . PartitionType . file ) return updateFilePartition ( isGrib1 , config , updateType , isTop , logger , dirPath ) ; \nelse { \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \ntry ( DirectoryCollection dcm = new DirectoryCollection ( config . collectionName , dirPath , isTop , config . olderThan , logger ) ) { \ndcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nif ( specp . getFilter ( ) != null ) dcm . setStreamFilter ( new StreamFilter ( specp . getFilter ( ) , specp . getFilterOnName ( ) ) ) ; \nboolean changed = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . directory , logger , errlog ) ; \nlogger . debug ( \"  GribCdmIndex.updateDirectoryPartition was updated=%s on %s%n\" , changed , dirPath ) ; \nreturn changed ; \n} \n} \n} \n} \n"}
{"5436": "public class GribCdmIndex { \npublic static GribCollectionImmutable openGribCollectionFromRaf ( RandomAccessFile raf , FeatureCollectionConfig config , CollectionUpdateType updateType , org . slf4j . Logger logger ) throws IOException { \nGribCollectionImmutable result ; \nboolean isGrib1 = false ; \nboolean isGrib2 = Grib2RecordScanner . isValidFile ( raf ) ; \nif ( ! isGrib2 ) isGrib1 = Grib1RecordScanner . isValidFile ( raf ) ; \nif ( isGrib1 || isGrib2 ) { \nresult = openGribCollectionFromDataFile ( isGrib1 , raf , config , updateType , null , logger ) ; \nraf . close ( ) ; \n} \nelse result = openGribCollectionFromIndexFile ( raf , config , logger ) ; \nreturn result ; \n} \n} \n"}
{"5442": "public class RC { \nstatic void setWellKnown ( ) { \nif ( dfaltRC . triplestore . size ( ) == 0 ) return ; \nfor ( String key : dfaltRC . keySet ( ) ) { \nTriple triple = dfaltRC . lookup ( key ) ; \nif ( triple . url == null ) RC . set ( key , triple . value ) ; \n} \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) return false ; \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) System . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) System . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) fs . setProjection ( displayProject ) ; \nelse if ( fs . newProjection && displayProject . isLatLon ( ) ) fs . setProjection ( displayProject ) ; \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) System . out . println ( \"GisFeature/MapDraw: makeShapes with \" + displayProject ) ; \nwhile ( featList . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; \nelse if ( dataProject == displayProject ) shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( dataProject , displayProject ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5453": "public class EnsCoord { \nstatic public void normalize ( EnsCoord result , List < EnsCoord > ecList ) { \nList < EnsCoord > extra = new ArrayList < > ( ) ; \nfor ( EnsCoord ec : ecList ) { \nif ( ! result . equalsData ( ec ) ) extra . add ( ec ) ; \n} \nif ( extra . size ( ) == 0 ) return ; \nfor ( EnsCoord ec : extra ) { \nif ( ec . getNEnsembles ( ) < result . getNEnsembles ( ) ) continue ; \nresult = ec ; \n} \n} \n} \n"}
{"5457": "public class ArrayStructure { \npublic Object getScalarObject ( int recno , StructureMembers . Member m ) { \nDataType dataType = m . getDataType ( ) ; \nif ( dataType == DataType . DOUBLE ) return getScalarDouble ( recno , m ) ; \nelse if ( dataType == DataType . FLOAT ) return getScalarFloat ( recno , m ) ; \nelse if ( dataType . getPrimitiveClassType ( ) == byte . class ) return getScalarByte ( recno , m ) ; \nelse if ( dataType . getPrimitiveClassType ( ) == short . class ) return getScalarShort ( recno , m ) ; \nelse if ( dataType . getPrimitiveClassType ( ) == int . class ) return getScalarInt ( recno , m ) ; \nelse if ( dataType . getPrimitiveClassType ( ) == long . class ) return getScalarLong ( recno , m ) ; \nelse if ( dataType == DataType . CHAR ) return getScalarString ( recno , m ) ; \nelse if ( dataType == DataType . STRING ) return getScalarString ( recno , m ) ; \nelse if ( dataType == DataType . STRUCTURE ) return getScalarStructure ( recno , m ) ; \nelse if ( dataType == DataType . OPAQUE ) { \nArrayObject data = ( ArrayObject ) m . getDataArray ( ) ; \nreturn data . getObject ( recno * m . getSize ( ) ) ; \n} \nthrow new RuntimeException ( \"Dont have implementation for \" + dataType ) ; \n} \n} \n"}
{"5476": "public class CEConstraint { \nstatic public CEConstraint compile ( String sce , DapDataset dmr ) throws DapException { \nif ( sce == null || sce . length ( ) == 0 ) return CEConstraint . getUniversal ( dmr ) ; \nCEParserImpl ceparser = new CEParserImpl ( dmr ) ; \nif ( PARSEDEBUG ) ceparser . setDebugLevel ( 1 ) ; \nif ( DEBUG ) System . err . println ( \"Dap4Servlet: parsing constraint: |\" + sce + \"|\" ) ; \nboolean ok ; \ntry { \nok = ceparser . parse ( sce ) ; \n} \ncatch ( ParseException pe ) { \nok = false ; \n} \nif ( ! ok ) throw new DapException ( \"Constraint parse failed: \" + sce ) ; \nCEAST root = ceparser . getCEAST ( ) ; \nCECompiler compiler = new CECompiler ( ) ; \nCEConstraint ce = compiler . compile ( dmr , root ) ; \nce . expand ( ) ; \nce . finish ( ) ; \nreturn ce ; \n} \n} \n"}
{"5477": "public class Grib2Iosp { \n@ Override public boolean isValidFile ( RandomAccessFile raf ) throws IOException { \nif ( raf instanceof HTTPRandomAccessFile ) if ( raf . length ( ) > raf . getBufferSize ( ) ) return false ; \nelse { \nGribCdmIndex . GribCollectionType type = GribCdmIndex . getType ( raf ) ; \nif ( type == GribCdmIndex . GribCollectionType . GRIB2 ) return true ; \nif ( type == GribCdmIndex . GribCollectionType . Partition2 ) return true ; \n} \nreturn Grib2RecordScanner . isValidFile ( raf ) ; \n} \n} \n"}
{"5479": "public class GempakFileReader { \npublic int getByteOrder ( int kmachn ) { \nif ( ( kmachn == MTVAX ) || ( kmachn == MTULTX ) || ( kmachn == MTALPH ) || ( kmachn == MTLNUX ) || ( kmachn == MTIGPH ) ) return RandomAccessFile . LITTLE_ENDIAN ; \nreturn RandomAccessFile . BIG_ENDIAN ; \n} \n} \n"}
{"5480": "public class GempakFileReader { \nvoid setByteOrder ( ) { \nString arch = System . getProperty ( \"os.arch\" ) ; \nif ( arch . equals ( \"x86\" ) || arch . equals ( \"arm\" ) || arch . equals ( \"x86_64\" ) || arch . equals ( \"amd64\" ) || arch . equals ( \"alpha\" ) ) MTMACH = RandomAccessFile . LITTLE_ENDIAN ; \nelse MTMACH = RandomAccessFile . BIG_ENDIAN ; \n} \n} \n"}
{"5481": "public class GempakFileReader { \npublic Key findKey ( String name ) { \nif ( keys == null ) return null ; \nfor ( Key key : keys . kkrow ) { \nif ( key . name . equals ( name ) ) return key ; \n} \nfor ( Key key : keys . kkcol ) { \nif ( key . name . equals ( name ) ) return key ; \n} \nreturn null ; \n} \n} \n"}
{"5482": "public class GempakFileReader { \npublic DMFileHeaderInfo findFileHeader ( String name ) { \nif ( ( fileHeaderInfo == null ) || fileHeaderInfo . isEmpty ( ) ) return null ; \nfor ( DMFileHeaderInfo fhi : fileHeaderInfo ) { \nif ( name . equals ( fhi . kfhnam ) ) return fhi ; \n} \nreturn null ; \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) return null ; \nint knt = fileHeaderInfo . indexOf ( fh ) ; \nint iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \nfor ( int i = 0 ; \ni < knt ; \ni ++ ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \n} \nint nword = DM_RINT ( iread ) ; \nif ( nword <= 0 ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread ++ ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( name . equals ( \"NAVB\" ) && needToSwap ) { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread ++ ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread ++ ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nelse DM_RFLT ( iread , rheader ) ; \nreturn rheader ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) return ; \nfor ( int i = 0 ; \ni < parts . size ( ) ; \ni ++ ) { \nSystem . out . println ( \"\\nParts[\" + i + \"]:\" ) ; \nSystem . out . println ( parts . get ( i ) ) ; \n} \n} \n} \n"}
{"5486": "public class GempakFileReader { \npublic float DM_RFLT ( int word ) throws IOException { \nif ( rf == null ) throw new IOException ( \"DM_RFLT: no file to read from\" ) ; \nif ( dmLabel == null ) throw new IOException ( \"DM_RFLT: reader not initialized\" ) ; \nrf . seek ( getOffset ( word ) ) ; \nif ( needToSwap ) rf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; \nelse rf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nfloat rdata = rf . readFloat ( ) ; \nif ( RMISSD != dmLabel . smissd ) if ( Math . abs ( rdata - dmLabel . smissd ) < RDIFFD ) rdata = RMISSD ; \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn rdata ; \n} \n} \n"}
{"5487": "public class GempakFileReader { \npublic String DM_RSTR ( int isword , int nchar ) throws IOException { \nif ( rf == null ) throw new IOException ( \"DM_RSTR: no file to read from\" ) ; \nrf . seek ( getOffset ( isword ) ) ; \nreturn rf . readString ( nchar ) ; \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nint nparms = part . kparms ; \nint nwordp = part . kwordp ; \nint npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) return null ; \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nint ir = 0 ; \nint ii = 0 ; \nfor ( int pack = 0 ; \npack < npack ; \npack ++ ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \nfor ( int idata = 0 ; \nidata < nparms ; \nidata ++ ) { \nint jbit = pkinf . nbitsc [ idata ] ; \nint jsbit = pkinf . isbitc [ idata ] ; \nint jshift = 1 - jsbit ; \nint jsword = pkinf . iswrdc [ idata ] ; \nint jword = jdata [ jsword ] ; \nint mask = mskpat >>> ( 32 - jbit ) ; \nint ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( ( jsbit + jbit - 1 ) > 32 ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nint iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ifield == pkinf . imissc [ idata ] ) data [ ir + idata ] = RMISSD ; \nelse data [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \nir += nparms ; \nii += nwordp ; \n} \nreturn data ; \n} \n} \n"}
{"5489": "public class GempakFileReader { \nprotected static String getBits ( int b ) { \nFormatter s = new Formatter ( ) ; \nfor ( int i = 31 ; \ni >= 0 ; \ni -- ) { \nif ( ( b & ( 1 << i ) ) != 0 ) s . format ( \"1\" ) ; \nelse s . format ( \"0\" ) ; \nif ( i % 8 == 0 ) s . format ( \"|\" ) ; \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse if ( type . equals ( \"Alias\" ) ) { \n} \nelse if ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) System . out . println ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) System . out . println ( \"Parsing new BaseType element. Parse level: \" + parseLevel ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) parseGrid ( e , indent ) ; \nelse for ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse if ( bt instanceof DArray ) { \nif ( _Debug ) System . out . println ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \nparseLevel -- ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel ++ ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) System . out . println ( indent + \"Parsing Aliases: \" ) ; \nif ( _Debug ) System . out . println ( subIndent + \"currentBT: \" + currentBT . getTypeName ( ) + \" \" + currentBT . getClearName ( ) ) ; \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) System . out . println ( subIndent + \"The name '\" + name + \"' is aliased to dds attribute: '\" + attributeName + \"'\" ) ; \nif ( currentAT == null ) currentBT . addAttributeAlias ( name , attributeName ) ; \nelse currentAT . addAlias ( name , attributeName ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5494": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > decode ( List < Short > keyDesc , BufrTableLookup lookup ) { \nif ( keyDesc == null ) return null ; \nList < DataDescriptor > keys = new ArrayList < DataDescriptor > ( ) ; \nfor ( short id : keyDesc ) { \nDataDescriptor dd = new DataDescriptor ( id , lookup ) ; \nkeys . add ( dd ) ; \nif ( dd . f == 3 ) { \nTableD . Descriptor tdd = lookup . getDescriptorTableD ( dd . fxy ) ; \nif ( tdd == null || tdd . getSequence ( ) == null ) dd . bad = true ; \nelse { \ndd . name = tdd . getName ( ) ; \ndd . subKeys = decode ( tdd . getSequence ( ) , lookup ) ; \n} \n} \n} \nreturn keys ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) dk . subKeys . add ( dkIter . next ( ) ) ; \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) dk . subKeys = replicate ( dk . subKeys ) ; \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5497": "public class GempakSurfaceIOSP { \npublic String getCFFeatureType ( ) { \nif ( gemreader . getFileSubType ( ) . equals ( GempakSurfaceFileReader . SHIP ) ) return CF . FeatureType . point . toString ( ) ; \nreturn CF . FeatureType . timeSeries . toString ( ) ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni ++ ) System . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \nSystem . out . println ( \"Methods:\" ) ; \nfor ( int i = 0 ; \ni < m . length ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( int j = 0 ; \nj < excepts . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . println ( \"\" ) ; \n} \nSystem . out . println ( \"******************\" ) ; \n} \n} \n"}
{"5503": "public class CoordinateTimeAbstract { \npublic CoordinateTimeAbstract makeBestFromComplete ( ) { \nint [ ] best = new int [ time2runtime . length ] ; \nint last = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < time2runtime . length ; \ni ++ ) { \nint time = time2runtime [ i ] ; \nif ( time >= last ) { \nlast = time ; \nbest [ i ] = time ; \ncount ++ ; \n} \nelse best [ i ] = - 1 ; \n} \nreturn makeBestFromComplete ( best , count ) ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) number = DataType . widenNumber ( number ) ; \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) f . format ( \"U\" ) ; \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) f . format ( \"S\" ) ; \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) f . format ( \"B\" ) ; \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) f . format ( \"L\" ) ; \n} \n} \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse throw new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5515": "public class MessageWriter { \nvoid scheduleWrite ( Message m ) { \nq . add ( m ) ; \nif ( ! isScheduled . getAndSet ( true ) ) executor . submit ( this ) ; \n} \n} \n"}
{"5517": "public class ToolsUI { \nprivate void jumptoThreddsDatatype ( thredds . client . catalog . Access invAccess ) { \nif ( invAccess == null ) return ; \nthredds . client . catalog . Service s = invAccess . getService ( ) ; \nif ( s . getType ( ) == ServiceType . HTTPServer ) { \ndownloadFile ( invAccess . getStandardUrlName ( ) ) ; \nreturn ; \n} \nif ( s . getType ( ) == ServiceType . WMS ) { \nopenWMSDataset ( invAccess . getStandardUrlName ( ) ) ; \nreturn ; \n} \nif ( s . getType ( ) == ServiceType . CdmrFeature ) { \nopenCoverageDataset ( invAccess . getWrappedUrlName ( ) ) ; \nreturn ; \n} \nthredds . client . catalog . Dataset ds = invAccess . getDataset ( ) ; \nif ( ds . getFeatureType ( ) == null ) { \ntry { \nopenNetcdfFile ( threddsDataFactory . openDataset ( invAccess , true , null , null ) ) ; \n} \ncatch ( IOException ioe ) { \nJOptionPane . showMessageDialog ( null , \"Error on setThreddsDatatype = \" + ioe . getMessage ( ) ) ; \n} \nreturn ; \n} \nDataFactory . Result threddsData = null ; \ntry { \nthreddsData = threddsDataFactory . openFeatureDataset ( invAccess , null ) ; \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( null , \"Failed to open err=\" + threddsData . errLog ) ; \nreturn ; \n} \njumptoThreddsDatatype ( threddsData ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nJOptionPane . showMessageDialog ( null , \"Error on setThreddsDatatype = \" + ioe . getMessage ( ) ) ; \nif ( threddsData != null ) try { \nthreddsData . close ( ) ; \n} \ncatch ( IOException ioe2 ) { \n} \n} \n} \n} \n"}
{"5518": "public class ToolsUI { \nprivate void jumptoThreddsDatatype ( DataFactory . Result threddsData ) { \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( this , \"Cant open dataset=\" + threddsData . errLog ) ; \ntry { \nthreddsData . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \nif ( threddsData . featureType . isCoverageFeatureType ( ) ) if ( threddsData . featureDataset instanceof FeatureDatasetCoverage ) { \nmakeComponent ( ftTabPane , \"Coverages\" ) ; \ncoveragePanel . setDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( coveragePanel ) ; \n} \nelse if ( threddsData . featureDataset instanceof GridDataset ) { \nmakeComponent ( ftTabPane , \"Grids\" ) ; \ngridPanel . setDataset ( ( GridDataset ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( gridPanel ) ; \n} \nelse if ( threddsData . featureType == FeatureType . IMAGE ) { \nmakeComponent ( ftTabPane , \"Images\" ) ; \nimagePanel . setImageLocation ( threddsData . imageURL ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( imagePanel ) ; \n} \nelse if ( threddsData . featureType == FeatureType . RADIAL ) { \nmakeComponent ( ftTabPane , \"Radial\" ) ; \nradialPanel . setDataset ( ( RadialDatasetSweep ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( radialPanel ) ; \n} \nelse if ( threddsData . featureType . isPointFeatureType ( ) ) { \nmakeComponent ( ftTabPane , \"PointFeature\" ) ; \npointFeaturePanel . setPointFeatureDataset ( ( PointDatasetImpl ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( pointFeaturePanel ) ; \n} \nelse if ( threddsData . featureType == FeatureType . STATION_RADIAL ) { \nmakeComponent ( ftTabPane , \"StationRadial\" ) ; \nstationRadialPanel . setStationRadialDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( stationRadialPanel ) ; \n} \n} \n} \n"}
{"5520": "public class ToolsUI { \nprivate static void prepareGui ( ) { \nfinal String osName = System . getProperty ( \"os.name\" ) . toLowerCase ( ) ; \nfinal boolean isMacOs = osName . startsWith ( \"mac os x\" ) ; \nif ( isMacOs ) { \nSystem . setProperty ( \"apple.laf.useScreenMenuBar\" , \"true\" ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { \n@ Override public void run ( ) { \ndoSavePrefsAndUI ( ) ; \n} \n} \n) ; \n} \nelse try { \nfor ( UIManager . LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { \nif ( \"Nimbus\" . equals ( info . getName ( ) ) ) { \nUIManager . setLookAndFeel ( info . getClassName ( ) ) ; \nbreak ; \n} \n} \n} \ncatch ( Exception exc ) { \nlog . warn ( \"Unable to apply Nimbus look-and-feel due to {}\" , exc . toString ( ) ) ; \nif ( log . isTraceEnabled ( ) ) exc . printStackTrace ( ) ; \n} \nBAMutil . setResourcePath ( \"/resources/nj22/ui/icons/\" ) ; \nSwingUtilities . invokeLater ( ( ) -> { \nfinal Toolkit tk = Toolkit . getDefaultToolkit ( ) ; \nfinal Font f = new Font ( \"SansSerif\" , Font . PLAIN , 12 ) ; \n@ SuppressWarnings ( \"deprecation\" ) final FontMetrics fm = tk . getFontMetrics ( f ) ; \n} \n) ; \n} \n} \n"}
{"5521": "public class ToolsUI { \nprivate static void createToolsFrame ( ) { \nframe = new JFrame ( \"NetCDF (\" + DIALOG_VERSION + \") Tools\" ) ; \nui = new ToolsUI ( prefs , frame ) ; \nframe . setIconImage ( BAMutil . getImage ( \"netcdfUI\" ) ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \n@ Override public void windowActivated ( final WindowEvent e ) { \nToolsSplashScreen . getSharedInstance ( ) . setVisible ( false ) ; \n} \n@ Override public void windowClosing ( final WindowEvent e ) { \nif ( ! done ) exit ( ) ; \n} \n} \n) ; \nframe . getContentPane ( ) . add ( ui ) ; \nfinal Rectangle have = frame . getGraphicsConfiguration ( ) . getBounds ( ) ; \nfinal Rectangle def = new Rectangle ( 50 , 50 , 800 , 800 ) ; \nRectangle want = ( Rectangle ) prefs . getBean ( FRAME_SIZE , def ) ; \nif ( want . getX ( ) > have . getWidth ( ) - 25 ) want = def ; \nframe . setBounds ( want ) ; \nframe . pack ( ) ; \nframe . setBounds ( want ) ; \nif ( wantDataset != null ) setDataset ( ) ; \n} \n} \n"}
{"5539": "public class BeanTable { \nprotected void restoreState ( ) { \nif ( store == null ) return ; \nArrayList propColObjs = ( ArrayList ) store . getBean ( \"propertyCol\" , new ArrayList ( ) ) ; \nHidableTableColumnModel tableColumnModel = ( HidableTableColumnModel ) jtable . getColumnModel ( ) ; \nint newViewIndex = 0 ; \nfor ( Object propColObj : propColObjs ) { \nPropertyCol propCol = ( PropertyCol ) propColObj ; \ntry { \nint currentViewIndex = tableColumnModel . getColumnIndex ( propCol . getName ( ) ) ; \nTableColumn column = tableColumnModel . getColumn ( currentViewIndex ) ; \ncolumn . setPreferredWidth ( propCol . getWidth ( ) ) ; \ntableColumnModel . moveColumn ( currentViewIndex , newViewIndex ) ; \nassert tableColumnModel . getColumn ( newViewIndex ) == column : \"tableColumn wasn't successfully moved.\" ; \ntableColumnModel . setColumnVisible ( column , propCol . isVisible ( ) ) ; \nif ( propCol . isVisible ( ) ) ++ newViewIndex ; \n} \ncatch ( IllegalArgumentException e ) { \nlogger . debug ( String . format ( \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\" , propCol . getName ( ) ) , e ) ; \n} \n} \n} \n} \n"}
{"5544": "public class NestedTable { \nprivate CoordVarExtractor findCoordinateAxis ( Table . CoordName coordName , Table t , int nestingLevel ) { \nif ( t == null ) return null ; \nString axisName = t . findCoordinateVariableName ( coordName ) ; \nif ( axisName != null ) { \nVariableDS v = t . findVariable ( axisName ) ; \nif ( v != null ) return new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; \nif ( t . extraJoins != null ) for ( Join j : t . extraJoins ) { \nv = j . findVariable ( axisName ) ; \nif ( v != null ) return new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; \n} \nif ( t instanceof Table . TableSingleton ) { \nTable . TableSingleton ts = ( Table . TableSingleton ) t ; \nreturn new CoordVarStructureData ( axisName , ts . sdata ) ; \n} \nif ( t instanceof Table . TableTop ) { \nv = ( VariableDS ) ds . findVariable ( axisName ) ; \nif ( v != null ) return new CoordVarTop ( v ) ; \nelse return new CoordVarConstant ( coordName . toString ( ) , \"\" , axisName ) ; \n} \nerrlog . format ( \"NestedTable: cant find variable '%s' for coordinate type %s %n\" , axisName , coordName ) ; \n} \nreturn findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; \n} \n} \n"}
{"5560": "public class ClauseFactory { \npublic TopLevelClause newBoolFunctionClause ( String functionName , List children ) throws DAP2ServerSideException , NoSuchFunctionException { \nBoolFunction function = functionLibrary . getBoolFunction ( functionName ) ; \nif ( function == null ) if ( functionLibrary . getBTFunction ( functionName ) != null ) throw new NoSuchFunctionException ( \"The function \" + functionName + \"() does not return a \" + \"boolean value, and must be used in a comparison or \" + \"as an argument to another function.\" ) ; \nelse throw new NoSuchFunctionException ( \"This server does not support a \" + functionName + \"() function\" ) ; \nreturn new BoolFunctionClause ( function , children ) ; \n} \n} \n"}
{"5561": "public class ClauseFactory { \npublic SubClause newBTFunctionClause ( String functionName , List children ) throws DAP2ServerSideException , NoSuchFunctionException { \nBTFunction function = functionLibrary . getBTFunction ( functionName ) ; \nif ( function == null ) if ( functionLibrary . getBoolFunction ( functionName ) != null ) throw new NoSuchFunctionException ( \"The function \" + functionName + \"() cannot be used as a \" + \"sub-expression in a constraint clause\" ) ; \nelse throw new NoSuchFunctionException ( \"This server does not support a \" + functionName + \"() function\" ) ; \nreturn new BTFunctionClause ( function , children ) ; \n} \n} \n"}
{"5564": "public class CatalogCrawler { \npublic void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nboolean isDataScan = ds . findProperty ( \"DatasetScan\" ) != null ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nif ( ! isCatRef || isDataScan ) listen . getDataset ( ds , context ) ; \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( ! isDataScan ) listen . getDataset ( catref . getProxyDataset ( ) , context ) ; \n} \nfor ( InvDataset dds : dlist ) { \ncrawlDataset ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( isCatRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) if ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) listen . getDataset ( chooseRandom ( leaves ) , context ) ; \nelse if ( type == Type . random_direct_middle ) listen . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \nelse for ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) if ( cacheState > 0 ) if ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \nelse return ; \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) System . out . println ( \"  close \" + location ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) file . setLength ( minLength ) ; \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5573": "public class RandomAccessFile { \npublic int read ( ) throws IOException { \nif ( filePosition < dataEnd ) { \nint pos = ( int ) ( filePosition - bufferStart ) ; \nfilePosition ++ ; \nreturn ( buffer [ pos ] & 0xff ) ; \n} \nelse if ( endOfFile ) return - 1 ; \nelse { \nseek ( filePosition ) ; \nreturn read ( ) ; \n} \n} \n} \n"}
{"5574": "public class RandomAccessFile { \npublic final void readShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) pa [ start + i ] = readShort ( ) ; \n} \n} \n"}
{"5575": "public class RandomAccessFile { \npublic final int readIntUnbuffered ( long pos ) throws IOException { \nbyte [ ] bb = new byte [ 4 ] ; \nread_ ( pos , bb , 0 , 4 ) ; \nint ch1 = bb [ 0 ] & 0xff ; \nint ch2 = bb [ 1 ] & 0xff ; \nint ch3 = bb [ 2 ] & 0xff ; \nint ch4 = bb [ 3 ] & 0xff ; \nif ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) throw new EOFException ( ) ; \nif ( bigEndian ) return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; \nelse return ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; \n} \n} \n"}
{"5576": "public class RandomAccessFile { \npublic final void readInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) pa [ start + i ] = readInt ( ) ; \n} \n} \n"}
{"5577": "public class RandomAccessFile { \npublic final void readLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) pa [ start + i ] = readLong ( ) ; \n} \n} \n"}
{"5578": "public class RandomAccessFile { \npublic final void readFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) pa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; \n} \n} \n"}
{"5579": "public class RandomAccessFile { \npublic final void readDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) pa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; \n} \n} \n"}
{"5582": "public class RandomAccessFile { \npublic final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeBoolean ( pa [ start + i ] ) ; \n} \n} \n"}
{"5583": "public class RandomAccessFile { \npublic final void writeShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeShort ( pa [ start + i ] ) ; \n} \n} \n"}
{"5584": "public class RandomAccessFile { \npublic final void writeChar ( char [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeChar ( pa [ start + i ] ) ; \n} \n} \n"}
{"5585": "public class RandomAccessFile { \npublic final void writeInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeInt ( pa [ start + i ] ) ; \n} \n} \n"}
{"5586": "public class RandomAccessFile { \npublic final void writeLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeLong ( pa [ start + i ] ) ; \n} \n} \n"}
{"5587": "public class RandomAccessFile { \npublic final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeFloat ( pa [ start + i ] ) ; \n} \n} \n"}
{"5588": "public class RandomAccessFile { \npublic final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) writeDouble ( pa [ start + i ] ) ; \n} \n} \n"}
{"5589": "public class RandomAccessFile { \npublic final void writeBytes ( String s ) throws IOException { \nint len = s . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) write ( ( byte ) s . charAt ( i ) ) ; \n} \n} \n"}
{"5590": "public class RandomAccessFile { \npublic final void writeBytes ( char b [ ] , int off , int len ) throws IOException { \nfor ( int i = off ; \ni < len ; \ni ++ ) write ( ( byte ) b [ i ] ) ; \n} \n} \n"}
{"5593": "public class DirectoryBuilder { \nstatic public MCollection factory ( FeatureCollectionConfig config , Path topDir , boolean isTop , IndexReader indexReader , String suffix , org . slf4j . Logger logger ) throws IOException { \nDirectoryBuilder builder = new DirectoryBuilder ( config . collectionName , topDir . toString ( ) , suffix ) ; \nDirectoryPartition dpart = new DirectoryPartition ( config , topDir , isTop , indexReader , suffix , logger ) ; \nif ( ! builder . isLeaf ( indexReader ) ) return dpart ; \nboolean hasIndex = builder . findIndex ( ) ; \nif ( hasIndex ) return dpart . makeChildCollection ( builder ) ; \nelse { \nDirectoryCollection result = new DirectoryCollection ( config . collectionName , topDir , isTop , config . olderThan , logger ) ; \nreturn result ; \n} \n} \n} \n"}
{"5596": "public class DirectoryBuilder { \npublic List < DirectoryBuilder > constructChildren ( IndexReader indexReader , CollectionUpdateType forceCollection ) throws IOException { \nif ( childrenConstructed ) return children ; \nif ( index != null && forceCollection == CollectionUpdateType . nocheck ) constructChildrenFromIndex ( indexReader , false ) ; \nelse scanForChildren ( ) ; \npartitionStatus = ( children . size ( ) > 0 ) ? PartitionStatus . isDirectoryPartition : PartitionStatus . isLeaf ; \nchildrenConstructed = true ; \nreturn children ; \n} \n} \n"}
{"5603": "public class FileCache { \n@ Override public boolean release ( FileCacheable ncfile ) throws IOException { \nif ( ncfile == null ) return false ; \nif ( disabled . get ( ) ) { \nncfile . setFileCache ( null ) ; \nncfile . close ( ) ; \nreturn false ; \n} \nCacheElement . CacheFile file = files . get ( ncfile ) ; \nif ( file != null ) { \nif ( ! file . isLocked . get ( ) ) cacheLog . warn ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \" not locked; hash= \" + ncfile . hashCode ( ) ) ; \nfile . lastAccessed = System . currentTimeMillis ( ) ; \nfile . countAccessed ++ ; \nfile . isLocked . set ( false ) ; \nfile . ncfile . release ( ) ; \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \"; hash= \" + ncfile . hashCode ( ) ) ; \nif ( debugPrint ) System . out . printf ( \"  FileCache %s release %s lock=%s count=%d%n\" , name , ncfile . getLocation ( ) , file . isLocked . get ( ) , countLocked ( ) ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"5607": "public class GridCoordSys { \nvoid makeVerticalTransform ( GridDataset gds , Formatter parseInfo ) { \nif ( vt != null ) return ; \nif ( vCT == null ) return ; \nvt = vCT . makeVerticalTransform ( gds . getNetcdfDataset ( ) , timeDim ) ; \nif ( vt == null ) if ( parseInfo != null ) parseInfo . format ( \"  - ERR can't make VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \nelse if ( parseInfo != null ) parseInfo . format ( \"  - VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \n} \n"}
{"5609": "public class GridCoordSys { \n@ Override public boolean isZPositive ( ) { \nif ( vertZaxis == null ) return false ; \nif ( vertZaxis . getPositive ( ) != null ) return vertZaxis . getPositive ( ) . equalsIgnoreCase ( ucar . nc2 . constants . CF . POSITIVE_UP ) ; \nif ( vertZaxis . getAxisType ( ) == AxisType . Height ) return true ; \nreturn vertZaxis . getAxisType ( ) != AxisType . Pressure ; \n} \n} \n"}
{"5617": "public class TdsDownloader { \npublic void getRemoteFiles ( final CancelTask _cancel ) { \nthis . cancel = _cancel ; \nString urls = config . getServerPrefix ( ) + \"/thredds/admin/log/\" + type + \"/\" ; \nta . append ( String . format ( \"Download URL = %s%n\" , urls ) ) ; \nString contents = null ; \ntry ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { \nint statusCode = method . execute ( ) ; \nif ( statusCode == 200 ) contents = method . getResponseAsString ( ) ; \nif ( ( contents == null ) || ( contents . length ( ) == 0 ) ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s%n%n\" , urls ) ) ; \nreturn ; \n} \nelse ta . append ( String . format ( \"Logs at URL = %s%n%s%n\" , urls , contents ) ) ; \n} \ncatch ( Throwable t ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s error = %s%n%n\" , urls , t . getMessage ( ) ) ) ; \nt . printStackTrace ( ) ; \nreturn ; \n} \nfinal String list = contents ; \nSwingWorker worker = new SwingWorker < String , Void > ( ) { \n@ Override protected String doInBackground ( ) throws Exception { \ntry { \nta . append ( String . format ( \"Local log files stored in = %s%n%n\" , localDir ) ) ; \nString [ ] lines = list . split ( \"\\n\" ) ; \nfor ( String line : lines ) { \nnew RemoteLog ( line . trim ( ) ) ; \nif ( cancel . isCancel ( ) ) break ; \n} \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \n} \nreturn null ; \n} \npublic void done ( ) { \nif ( cancel . isCancel ( ) ) ta . append ( String . format ( \"Download was cancelled for %s%n\" , type ) ) ; \nelse ta . append ( String . format ( \"Download complete for %s%n\" , type ) ) ; \n} \n} \n; \nworker . execute ( ) ; \n} \n} \n"}
{"5623": "public class CalendarPeriod { \npublic double getConvertFactor ( CalendarPeriod from ) { \nif ( field == CalendarPeriod . Field . Month || field == CalendarPeriod . Field . Year ) log . warn ( \" CalendarDate.convert on Month or Year\" ) ; \nreturn ( double ) from . millisecs ( ) / millisecs ( ) ; \n} \n} \n"}
{"5633": "public class CoordinateSharerBest { \npublic List < Integer > reindex ( List < Coordinate > coords ) { \nList < Integer > result = new ArrayList < > ( ) ; \nfor ( Coordinate coord : coords ) { \nCoordinate sub = swap . get ( coord ) ; \nCoordinate use = ( sub == null ) ? coord : sub ; \nInteger idx = indexMap . get ( use ) ; \nif ( idx == null ) throw new IllegalStateException ( ) ; \nresult . add ( idx ) ; \n} \nreturn result ; \n} \n} \n"}
{"5644": "public class OffsetUnit { \npublic double toDerivedUnit ( final double amount ) throws ConversionException { \nif ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( this , getDerivedUnit ( ) ) ; \nreturn ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( amount + getOffset ( ) ) ; \n} \n} \n"}
{"5645": "public class OffsetUnit { \npublic double fromDerivedUnit ( final double amount ) throws ConversionException { \nif ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( getDerivedUnit ( ) , this ) ; \nreturn ( ( DerivableUnit ) getUnit ( ) ) . fromDerivedUnit ( amount ) - getOffset ( ) ; \n} \n} \n"}
{"5647": "public class ConvertD2N { \npublic Array convertTopVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV ) throws IOException , DAP2Exception { \nArray data = convert ( dataV ) ; \nif ( ( dataV . darray != null ) && ( dataV . bt instanceof DString ) ) if ( v . getDataType ( ) == DataType . STRING ) return convertStringArray ( data , v ) ; \nelse if ( v . getDataType ( ) == DataType . CHAR ) return convertStringArrayToChar ( dataV . darray , v , section ) ; \nelse { \nString mess = \"DODSVariable convertArray String invalid dataType= \" + v . getDataType ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalArgumentException ( mess ) ; \n} \nif ( ( dataV . bt instanceof DString ) && ( v . getDataType ( ) == DataType . CHAR ) ) return convertStringToChar ( data , v ) ; \nreturn data ; \n} \n} \n"}
{"5648": "public class ConvertD2N { \npublic Array convert ( DodsV dataV ) throws IOException , DAP2Exception { \nif ( dataV . darray == null ) if ( dataV . bt instanceof DStructure ) { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataStructure ( ( DStructure ) dataV . bt , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse if ( dataV . bt instanceof DGrid ) throw new IllegalStateException ( \"DGrid without a darray\" ) ; \nelse if ( dataV . bt instanceof DSequence ) { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataSequenceArray ( ( DSequence ) dataV . bt , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse { \nDataType dtype = dataV . getDataType ( ) ; \nArray scalarData = Array . factory ( dtype , new int [ 0 ] ) ; \nIndexIterator scalarIndex = scalarData . getIndexIterator ( ) ; \niconvertDataPrimitiveScalar ( dataV . bt , scalarIndex ) ; \nreturn scalarData ; \n} \nif ( dataV . darray != null ) if ( dataV . bt instanceof DStructure ) { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataStructureArray ( dataV . darray , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse if ( dataV . bt instanceof DString ) return convertStringArray ( dataV . darray ) ; \nelse { \nopendap . dap . PrimitiveVector pv = dataV . darray . getPrimitiveVector ( ) ; \nObject storage = pv . getInternalStorage ( ) ; \nDataType dtype = dataV . getDataType ( ) ; \nreturn Array . factory ( dtype , makeShape ( dataV . darray ) , storage ) ; \n} \nString mess = \"Unknown baseType \" + dataV . bt . getClass ( ) . getName ( ) + \" name=\" + dataV . getEncodedName ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalStateException ( mess ) ; \n} \n} \n"}
{"5649": "public class MetadataManager { \nstatic synchronized public void closeAll ( ) { \nList < MetadataManager > closeDatabases = new ArrayList < > ( openDatabases ) ; \nfor ( MetadataManager mm : closeDatabases ) { \nif ( debug ) System . out . println ( \"  close database \" + mm . collectionName ) ; \nmm . close ( ) ; \n} \nopenDatabases = new ArrayList < > ( ) ; \nif ( myEnv != null ) try { \nmyEnv . close ( ) ; \nmyEnv = null ; \nlogger . info ( \"closed bdb caching\" ) ; \n} \ncatch ( DatabaseException dbe ) { \nlogger . error ( \"Error closing bdb: \" , dbe ) ; \n} \n} \n} \n"}
{"5663": "public class EcmwfLocalConcepts { \nprivate void storeConcept ( String tableVersion , String parameterNumber , String key , String value ) { \nHashMap < String , HashMap < String , String > > tmpTable ; \nif ( localConcepts . containsKey ( tableVersion ) ) { \ntmpTable = localConcepts . get ( tableVersion ) ; \nif ( tmpTable . containsKey ( parameterNumber ) ) { \nHashMap < String , String > tmpParam = tmpTable . get ( parameterNumber ) ; \nif ( ! tmpParam . containsKey ( key ) ) tmpParam . put ( key , value ) ; \nelse System . out . println ( \"already has key value pair: \" + key + \":\" + value ) ; \n} \nelse { \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \n} \nelse { \ntmpTable = new HashMap < > ( ) ; \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \nlocalConcepts . put ( tableVersion , tmpTable ) ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) addLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) addLevelDs . addDataset ( curDs ) ; \nelse namedDs . addDataset ( curDs ) ; \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) if ( addLevelDs . hasNestedDatasets ( ) ) namedDs . addDataset ( addLevelDs ) ; \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( int i = 0 ; \ni < namedDs . getDatasets ( ) . size ( ) ; \ni ++ ) dataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5677": "public class ScalablePicture { \npublic void sourceLoadProgressNotification ( int statusCode , int percentage ) { \nEnumeration e = scalablePictureStatusListeners . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) ( ( ScalablePictureListener ) e . nextElement ( ) ) . sourceLoadProgressNotification ( statusCode , percentage ) ; \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nwhile ( ! done ) { \nfor ( int group = 0 ; \ngroup < belowGroups . length ; \ngroup ++ ) { \nif ( above ) partToCheck = aboveGroups [ group ] ; \nelse partToCheck = belowGroups [ group ] ; \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) types . add ( partToCheck ) ; \n} \nif ( ! above ) above = true ; \nelse done = true ; \n} \nreturn types ; \n} \n} \n"}
{"5684": "public class GempakSoundingFileReader { \nprivate boolean checkForValidGroup ( String partToCheck , String [ ] params ) { \nDMPart part = getPart ( partToCheck ) ; \nif ( part == null ) return false ; \nint i = 0 ; \nfor ( DMParam parm : part . params ) { \nif ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5687": "public class DiskCache { \nstatic public File getCacheFile ( String fileLocation ) { \nFile f = new File ( makeCachePath ( fileLocation ) ) ; \nif ( f . exists ( ) ) if ( ! f . setLastModified ( System . currentTimeMillis ( ) ) ) logger . warn ( \"Failed to setLastModified on \" + f . getPath ( ) ) ; \nif ( ! checkExist ) { \nFile dir = f . getParentFile ( ) ; \nif ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) logger . warn ( \"Failed to mkdirs on \" + dir . getPath ( ) ) ; \ncheckExist = true ; \n} \nreturn f ; \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( file . length ( ) + total > maxBytes ) { \ntotal_delete += file . length ( ) ; \nif ( sbuff != null ) sbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \nif ( ! file . delete ( ) && sbuff != null ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \nelse total += file . length ( ) ; \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"5691": "public class CoordinateAxis { \nstatic public CoordinateAxis factory ( NetcdfDataset ncd , VariableDS vds ) { \nif ( ( vds . getRank ( ) == 0 ) || ( vds . getRank ( ) == 1 ) || ( vds . getRank ( ) == 2 && vds . getDataType ( ) == DataType . CHAR ) ) return new CoordinateAxis1D ( ncd , vds ) ; \nelse if ( vds . getRank ( ) == 2 ) return new CoordinateAxis2D ( ncd , vds ) ; \nelse return new CoordinateAxis ( ncd , vds ) ; \n} \n} \n"}
{"5694": "public class CoordinateAxis { \npublic void getInfo ( Formatter buf ) { \nbuf . format ( \"%-30s\" , getNameAndDimensions ( ) ) ; \nbuf . format ( \"%-20s\" , getUnitsString ( ) ) ; \nif ( axisType != null ) buf . format ( \"%-10s\" , axisType . toString ( ) ) ; \nbuf . format ( \"%s\" , getDescription ( ) ) ; \n} \n} \n"}
{"5695": "public class CoordinateAxis { \npublic ucar . nc2 . time . Calendar getCalendarFromAttribute ( ) { \nAttribute cal = findAttribute ( CF . CALENDAR ) ; \nString s = ( cal == null ) ? null : cal . getStringValue ( ) ; \nif ( s == null ) { \nAttribute convention = ( ncd == null ) ? null : ncd . getRootGroup ( ) . findAttribute ( CDM . CONVENTIONS ) ; \nif ( convention != null ) { \nString hasName = convention . getStringValue ( ) ; \nint version = CF1Convention . getVersion ( hasName ) ; \nif ( version >= 0 ) return Calendar . gregorian ; \nif ( COARDSConvention . isMine ( hasName ) ) return Calendar . gregorian ; \n} \n} \nreturn ucar . nc2 . time . Calendar . get ( s ) ; \n} \n} \n"}
{"5707": "public class XMLStore { \nstatic public XMLStore createFromResource ( String resourceName , XMLStore storedDefaults ) throws java . io . IOException { \nClass c = XMLStore . class ; \nInputStream primIS = c . getResourceAsStream ( resourceName ) ; \nInputStream objIS = c . getResourceAsStream ( resourceName ) ; \nif ( primIS == null ) throw new java . io . IOException ( \"XMLStore.createFromResource cant find <\" + resourceName + \">\" ) ; \nif ( debugWhichStore ) System . out . println ( \"XMLStore read from resource \" + resourceName ) ; \nreturn new XMLStore ( primIS , objIS , storedDefaults ) ; \n} \n} \n"}
{"5709": "public class XMLStore { \npublic void save ( ) throws java . io . IOException { \nif ( prefsFile == null ) throw new UnsupportedOperationException ( \"XMLStore is read-only\" ) ; \nFile prefTemp ; \nString parentFilename = prefsFile . getParent ( ) ; \nif ( parentFilename == null ) prefTemp = File . createTempFile ( \"pref\" , \".xml\" ) ; \nelse { \nFile parentFile = new File ( parentFilename ) ; \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" , parentFile ) ; \n} \nprefTemp . deleteOnExit ( ) ; \nFileOutputStream fos = new FileOutputStream ( prefTemp , false ) ; \nsave ( fos ) ; \nfos . close ( ) ; \nPath xmlBackup = Paths . get ( prefsFile . getAbsolutePath ( ) + \".bak\" ) ; \nPath prefsPath = prefsFile . toPath ( ) ; \nif ( Files . exists ( prefsPath ) ) Files . move ( prefsPath , xmlBackup , StandardCopyOption . REPLACE_EXISTING ) ; \nFiles . move ( prefTemp . toPath ( ) , prefsFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni ++ ) writeSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n"}
{"5717": "public class GempakStation { \npublic String getWmoId ( ) { \nString wmoID = \"\" ; \nif ( ! ( stnm == GempakConstants . IMISSD ) ) wmoID = String . valueOf ( ( int ) ( stnm / 10 ) ) ; \nreturn wmoID ; \n} \n} \n"}
{"5718": "public class DbaseData { \nint readRowN ( DataInputStream ds , int n ) { \nif ( n > nrec ) return - 1 ; \ntry { \nds . readFully ( field , 0 , desc . FieldLength ) ; \n} \ncatch ( java . io . IOException e ) { \nreturn - 1 ; \n} \nswitch ( desc . Type ) { \ncase 'C' : case 'D' : character [ n ] = new String ( field , CDM . utf8Charset ) ; \nbreak ; \ncase 'N' : numeric [ n ] = Double . valueOf ( new String ( field , CDM . utf8Charset ) ) ; \nbreak ; \ncase 'F' : if ( desc . FieldLength == 4 ) numeric [ n ] = ( double ) Swap . swapFloat ( field , 0 ) ; \nelse numeric [ n ] = Swap . swapDouble ( field , 0 ) ; \nbreak ; \ncase 'L' : switch ( field [ 0 ] ) { \ncase 't' : case 'T' : case 'Y' : case 'y' : logical [ n ] = true ; \nbreak ; \ndefault : logical [ n ] = false ; \nbreak ; \n} \ndefault : return - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"5720": "public class Grib2DataReader { \nprivate float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nBitReader reader = new BitReader ( raf , startPos + 5 ) ; \nif ( bitmap == null ) for ( int i = 0 ; \ni < totalNPoints ; \ni ++ ) data [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \nelse for ( int i = 0 ; \ni < totalNPoints ; \ni ++ ) if ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) data [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \nelse data [ i ] = staticMissingValue ; \nreturn data ; \n} \n} \n"}
{"5721": "public class Grib2DataReader { \nprivate float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nif ( nb == 0 ) { \nArrays . fill ( data , R ) ; \nreturn data ; \n} \nbyte [ ] buf = new byte [ dataLength - 5 ] ; \nraf . readFully ( buf ) ; \nInputStream in = new ByteArrayInputStream ( buf ) ; \nBufferedImage image = ImageIO . read ( in ) ; \nif ( nb != image . getColorModel ( ) . getPixelSize ( ) ) logger . debug ( \"PNG pixel size disagrees with grib number of bits: \" , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; \nDataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; \nif ( bitmap == null ) for ( int i = 0 ; \ni < dataNPoints ; \ni ++ ) data [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; \nelse for ( int bitPt = 0 , dataPt = 0 ; \nbitPt < totalNPoints ; \nbitPt ++ ) if ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) data [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; \nelse data [ bitPt ] = staticMissingValue ; \nreturn data ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \nfor ( int i = 0 ; \nodom . hasNext ( ) ; \ni ++ ) instances [ i ] = readStructure ( odom . next ( ) ) ; \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5727": "public class StationRenderer { \npublic void setSelectedStation ( String name ) { \nStationUI sui = ( StationUI ) stationHash . get ( name ) ; \nif ( sui != null ) setSelectedStation ( sui ) ; \n} \n} \n"}
{"5741": "public class Grib1ParamTableReader { \npublic Grib1Parameter getParameter ( int id ) { \nif ( parameters == null ) parameters = readParameterTable ( ) ; \nreturn parameters . get ( id ) ; \n} \n} \n"}
{"5742": "public class Grib1ParamTableReader { \npublic Grib1Parameter getLocalParameter ( int id ) { \nif ( parameters == null ) parameters = readParameterTable ( ) ; \nreturn parameters . get ( id ) ; \n} \n} \n"}
{"5745": "public class PrefixDBImpl { \nprivate static Prefix getPrefix ( final String string , final Set < Prefix > set ) { \nfor ( final Iterator < Prefix > iter = set . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nfinal Prefix prefix = iter . next ( ) ; \nfinal int comp = prefix . compareTo ( string ) ; \nif ( comp == 0 ) return prefix ; \nif ( comp > 0 ) break ; \n} \nreturn null ; \n} \n} \n"}
{"5747": "public class WKTParser { \npublic double getParameter ( String name ) { \nDouble val = ( Double ) parameters . get ( name . toLowerCase ( ) ) ; \nif ( val == null ) throw new IllegalArgumentException ( \"no parameter called \" + name ) ; \nreturn val . doubleValue ( ) ; \n} \n} \n"}
{"5753": "public class CFPolygon { \npublic void setNext ( Polygon next ) { \nif ( next instanceof CFPolygon ) setNext ( ( CFPolygon ) next ) ; \nelse this . next = next ; \n} \n} \n"}
{"5754": "public class CFPolygon { \npublic void setPrev ( Polygon prev ) { \nif ( prev instanceof CFPolygon ) setPrev ( ( CFPolygon ) prev ) ; \nelse this . prev = prev ; \n} \n} \n"}
{"5783": "public class NetcdfFile { \nprotected Boolean makeRecordStructure ( ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nBoolean didit = false ; \nif ( ( spi != null ) && ( spi instanceof N3iosp ) && hasUnlimitedDimension ( ) ) didit = ( Boolean ) spi . sendIospMessage ( IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \nreturn didit ; \n} \n} \n"}
{"5785": "public class NetcdfFile { \npublic Array readSection ( String variableSection ) throws IOException , InvalidRangeException { \nParsedSectionSpec cer = ParsedSectionSpec . parseVariableSection ( this , variableSection ) ; \nif ( cer . child == null ) return cer . v . read ( cer . section ) ; \nif ( spi == null ) return IospHelper . readSection ( cer ) ; \nelse return spi . readSection ( cer ) ; \n} \n} \n"}
{"5797": "public class Attribute { \nprivate static final boolean checkByte ( String s ) throws AttributeBadValueException { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) log . debug ( \"Attribute.checkByte() - string: '\" + s + \"'   value: \" + val ) ; \nif ( val > 0xFF || val < 0 ) return false ; \nelse return true ; \n} \ncatch ( NumberFormatException e ) { \nthrow new AttributeBadValueException ( \"`\" + s + \"' is not a Byte value.\" ) ; \n} \n} \n} \n"}
{"5798": "public class Attribute { \nprivate static final boolean checkShort ( String s ) { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) DAPNode . log . debug ( \"Attribute.checkShort() - string: '\" + s + \"'   value: \" + val ) ; \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5799": "public class Attribute { \nprivate static final boolean checkInt ( String s ) { \ntry { \nint val = Integer . parseInt ( s ) ; \nif ( DebugValueChecking ) DAPNode . log . debug ( \"Attribute.checkInt() - string: '\" + s + \"'   value: \" + val ) ; \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5800": "public class Attribute { \nprivate static final boolean checkUInt ( String s ) { \ntry { \nlong val = Long . parseLong ( s ) ; \nif ( DebugValueChecking ) DAPNode . log . debug ( \"Attribute.checkUInt() - string: '\" + s + \"'   value: \" + val ) ; \nif ( val > 0xFFFFFFFFL ) return false ; \nelse return true ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5801": "public class Attribute { \nprivate static final boolean checkFloat ( String s ) { \ntry { \nfloat val = Float . parseFloat ( s ) ; \nif ( DebugValueChecking ) DAPNode . log . debug ( \"Attribute.checkFloat() - string: '\" + s + \"'   value: \" + val ) ; \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) || s . equalsIgnoreCase ( \"inf\" ) ) return true ; \nreturn false ; \n} \n} \n} \n"}
{"5802": "public class Attribute { \nprivate static final boolean checkDouble ( String s ) { \ntry { \ndouble val = Double . parseDouble ( s ) ; \nif ( DebugValueChecking ) DAPNode . log . debug ( \"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val ) ; \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) || s . equalsIgnoreCase ( \"inf\" ) ) return true ; \nreturn false ; \n} \n} \n} \n"}
{"5803": "public class EnhanceScaleMissingUnsignedImpl { \nprivate DataType getAttributeDataType ( Attribute attribute ) { \nDataType dataType = attribute . getDataType ( ) ; \nif ( signedness == Signedness . UNSIGNED ) dataType = dataType . withSignedness ( signedness ) ; \nreturn dataType ; \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) continue ; \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) return false ; \ni -- ; \n} \nelse i ++ ; \n} \nreturn true ; \n} \n} \n"}
{"5810": "public class GridDefRecord { \npublic final String getParam ( String key ) { \nString value = paramStr . get ( key ) ; \nif ( value == null ) { \nDouble result = paramDbl . get ( key ) ; \nif ( result != null ) value = result . toString ( ) ; \nelse { \nInteger intResult = paramInt . get ( key ) ; \nif ( intResult != null ) value = intResult . toString ( ) ; \n} \nif ( value != null ) paramStr . put ( key , value ) ; \n} \nif ( debug && value == null ) System . out . println ( key + \" value not found\" ) ; \nreturn value ; \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) return false ; \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) continue ; \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) return false ; \n} \nelse if ( val . matches ( \"^[0-9]+\" ) ) if ( ! val . equals ( oval ) ) return false ; \nelse if ( ! val . equals ( oval ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) if ( start == 0 ) return b . have - 3 ; \nelse return start ; \nif ( matchPos + 6 >= b . have ) return start ; \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5815": "public class Ceparse { \nvoid markStackedVariables ( Stack s ) { \nStack bts = new Stack ( ) ; \nwhile ( ! s . empty ( ) ) bts . push ( s . pop ( ) ) ; \nwhile ( bts . size ( ) > 1 ) { \nServerMethods ct = ( ServerMethods ) bts . pop ( ) ; \nct . setProject ( true , false ) ; \n} \nServerMethods bt = ( ServerMethods ) bts . pop ( ) ; \nbt . setProject ( true , true ) ; \n} \n} \n"}
{"5816": "public class NcmlEditor { \nboolean writeNcml ( String location ) { \nboolean err = false ; \ncloseOpenFiles ( ) ; \ntry { \nfinal String result ; \nds = openDataset ( location , addCoords , null ) ; \nif ( ds == null ) editor . setText ( \"Failed to open <\" + location + \">\" ) ; \nelse { \nfinal NcMLWriter ncmlWriter = new NcMLWriter ( ) ; \nfinal Element netcdfElem = ncmlWriter . makeNetcdfElement ( ds , null ) ; \nresult = ncmlWriter . writeToString ( netcdfElem ) ; \neditor . setText ( result ) ; \neditor . setCaretPosition ( 0 ) ; \n} \n} \ncatch ( Exception e ) { \nfinal StringWriter sw = new StringWriter ( 10000 ) ; \ne . printStackTrace ( ) ; \ne . printStackTrace ( new PrintWriter ( sw ) ) ; \neditor . setText ( sw . toString ( ) ) ; \nerr = true ; \n} \nreturn ! err ; \n} \n} \n"}
{"5819": "public class StationCollectionStream { \n@ Override protected StationHelper createStationHelper ( ) throws IOException { \nStationHelper stationHelper = new StationHelper ( ) ; \ntry ( InputStream in = CdmRemote . sendQuery ( null , uri , \"req=stations\" ) ) { \nPointStream . MessageType mtype = PointStream . readMagic ( in ) ; \nif ( mtype != PointStream . MessageType . StationList ) throw new RuntimeException ( \"Station Request: bad response\" ) ; \nint len = NcStream . readVInt ( in ) ; \nbyte [ ] b = new byte [ len ] ; \nNcStream . readFully ( in , b ) ; \nPointStreamProto . StationList stationsp = PointStreamProto . StationList . parseFrom ( b ) ; \nfor ( ucar . nc2 . ft . point . remote . PointStreamProto . Station sp : stationsp . getStationsList ( ) ) { \nstationHelper . addStation ( new StationFeatureStream ( null , null ) ) ; \n} \nreturn stationHelper ; \n} \n} \n} \n"}
{"5820": "public class ResultService { \nprotected boolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( this . log . length ( ) > 0 ) out . append ( this . log ) ; \nif ( this . getAccessPointHeader ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** ResultService (1): a null 'accessPointHeader' is invalid.\" ) ; \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"5826": "public class DoradeSWIB { \npublic float [ ] getAzimuths ( ) { \nif ( azimuths == null ) { \nazimuths = new float [ nRays ] ; \nfor ( int r = 0 ; \nr < nRays ; \nr ++ ) azimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; \n} \nreturn azimuths ; \n} \n} \n"}
{"5827": "public class DoradeSWIB { \npublic float [ ] getElevations ( ) { \nif ( elevations == null ) { \nelevations = new float [ nRays ] ; \nfor ( int r = 0 ; \nr < nRays ; \nr ++ ) elevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; \n} \nreturn elevations ; \n} \n} \n"}
{"5832": "public class Structure { \n@ Override public void setParentGroup ( Group group ) { \nif ( isImmutable ( ) ) throw new IllegalStateException ( \"Cant modify\" ) ; \nsuper . setParentGroup ( group ) ; \nif ( members != null ) for ( Variable v : members ) { \nv . setParentGroup ( group ) ; \n} \n} \n} \n"}
{"5834": "public class Structure { \npublic StructureData readStructure ( int index ) throws IOException , ucar . ma2 . InvalidRangeException { \nSection section = null ; \nif ( getRank ( ) == 1 ) section = new Section ( ) . appendRange ( index , index ) ; \nelse if ( getRank ( ) > 1 ) { \nIndex ii = Index . factory ( shape ) ; \nii . setCurrentCounter ( index ) ; \nint [ ] origin = ii . getCurrentCounter ( ) ; \nsection = new Section ( ) ; \nfor ( int anOrigin : origin ) section . appendRange ( anOrigin , anOrigin ) ; \n} \nArray dataArray = read ( section ) ; \nArrayStructure data = ( ArrayStructure ) dataArray ; \nreturn data . getStructureData ( 0 ) ; \n} \n} \n"}
{"5838": "public class ProjectionImpl { \npublic String getClassName ( ) { \nString className = getClass ( ) . getName ( ) ; \nint index = className . lastIndexOf ( \".\" ) ; \nif ( index >= 0 ) className = className . substring ( index + 1 ) ; \nreturn className ; \n} \n} \n"}
{"5849": "public class TableAligner { \npublic static void installInAllColumns ( JTable table , int alignment ) { \nfor ( int colViewIndex = 0 ; \ncolViewIndex < table . getColumnCount ( ) ; \n++ colViewIndex ) installInOneColumn ( table , colViewIndex , alignment ) ; \n} \n} \n"}
{"5855": "public class CoreSocketFactory { \nprivate static List < String > listIpTypes ( String cloudSqlIpTypes ) { \nString [ ] rawTypes = cloudSqlIpTypes . split ( \",\" ) ; \nArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; \nfor ( int i = 0 ; \ni < rawTypes . length ; \ni ++ ) if ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( \"PUBLIC\" ) ) result . add ( i , \"PRIMARY\" ) ; \nelse result . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; \nreturn result ; \n} \n} \n"}
{"5857": "public class FluentLoggerFactory { \nprotected synchronized void purgeLogger ( FluentLogger logger ) { \nIterator < Entry < FluentLogger , String > > it = loggers . entrySet ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) if ( it . next ( ) . getKey ( ) == logger ) { \nit . remove ( ) ; \nreturn ; \n} \n} \n} \n"}
{"5858": "public class InMemoryJavaCompiler { \npublic Map < String , Class < ? > > compileAll ( ) throws Exception { \nif ( sourceCodes . size ( ) == 0 ) throw new CompilationException ( \"No source code to compile\" ) ; \nCollection < SourceCode > compilationUnits = sourceCodes . values ( ) ; \nCompiledCode [ ] code ; \ncode = new CompiledCode [ compilationUnits . size ( ) ] ; \nIterator < SourceCode > iter = compilationUnits . iterator ( ) ; \nfor ( int i = 0 ; \ni < code . length ; \ni ++ ) code [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; \nDiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; \nExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; \nJavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; \nboolean result = task . call ( ) ; \nif ( ! result || collector . getDiagnostics ( ) . size ( ) > 0 ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings || hasErrors ) throw new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \nMap < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; \nfor ( String className : sourceCodes . keySet ( ) ) { \nclasses . put ( className , classLoader . loadClass ( className ) ) ; \n} \nreturn classes ; \n} \n} \n"}
{"5861": "public class GifHeaderParser { \nprivate void readGraphicControlExt ( ) { \nread ( ) ; \nint packed = read ( ) ; \nheader . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; \nif ( header . currentFrame . dispose == 0 ) header . currentFrame . dispose = 1 ; \nheader . currentFrame . transparency = ( packed & 1 ) != 0 ; \nint delayInHundredthsOfASecond = readShort ( ) ; \nif ( delayInHundredthsOfASecond < MIN_FRAME_DELAY ) delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; \nheader . currentFrame . delay = delayInHundredthsOfASecond * 10 ; \nheader . currentFrame . transIndex = read ( ) ; \nread ( ) ; \n} \n} \n"}
{"5862": "public class GifDecoder { \nsynchronized Bitmap getNextFrame ( ) { \nif ( header . frameCount <= 0 || framePointer < 0 ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) Log . d ( TAG , \"unable to decode frame, frameCount=\" + header . frameCount + \" framePointer=\" + framePointer ) ; \nstatus = STATUS_FORMAT_ERROR ; \n} \nif ( status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) Log . d ( TAG , \"Unable to decode frame, status=\" + status ) ; \nreturn null ; \n} \nstatus = STATUS_OK ; \nGifFrame currentFrame = header . frames . get ( framePointer ) ; \nGifFrame previousFrame = null ; \nint previousIndex = framePointer - 1 ; \nif ( previousIndex >= 0 ) previousFrame = header . frames . get ( previousIndex ) ; \nact = currentFrame . lct != null ? currentFrame . lct : header . gct ; \nif ( act == null ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) Log . d ( TAG , \"No Valid Color Table for frame #\" + framePointer ) ; \nstatus = STATUS_FORMAT_ERROR ; \nreturn null ; \n} \nif ( currentFrame . transparency ) { \nSystem . arraycopy ( act , 0 , pct , 0 , act . length ) ; \nact = pct ; \nact [ currentFrame . transIndex ] = 0 ; \n} \nreturn setPixels ( currentFrame , previousFrame ) ; \n} \n} \n"}
{"5863": "public class PersonLoginViewModel { \npublic SelectableStringList selectablePersonsProperty ( ) { \nif ( selectablePersons == null ) selectablePersons = new SelectableItemList < > ( FXCollections . observableArrayList ( repository . getPersons ( ) ) , person -> person . getFirstName ( ) + \" \" + person . getLastName ( ) ) ; \nreturn selectablePersons ; \n} \n} \n"}
{"5864": "public class ListTransformation { \nprivate void initListEvents ( ) { \nthis . listChangeListener = new ListChangeListener < SourceType > ( ) { \n@ Override public void onChanged ( Change < ? extends SourceType > listEvent ) { \nList < TargetType > deleteStaging = new ArrayList < > ( ) ; \nwhile ( listEvent . next ( ) ) if ( listEvent . wasUpdated ( ) ) processUpdateEvent ( listEvent ) ; \nelse if ( listEvent . wasReplaced ( ) ) processReplaceEvent ( listEvent , deleteStaging ) ; \nelse if ( listEvent . wasAdded ( ) ) processAddEvent ( listEvent ) ; \nelse if ( listEvent . wasRemoved ( ) ) processRemoveEvent ( listEvent , deleteStaging ) ; \nprocessStagingLists ( deleteStaging ) ; \n} \n} \n; \nmodelListProperty ( ) . addListener ( new WeakListChangeListener < > ( listChangeListener ) ) ; \n} \n} \n"}
{"5865": "public class Repository { \npublic Person getPersonById ( final int id ) { \nfor ( Person person : persons ) { \nif ( id == person . getId ( ) ) return person ; \n} \nreturn null ; \n} \n} \n"}
{"5866": "public class CompositeValidationStatus { \nvoid addMessage ( Validator validator , List < ? extends ValidationMessage > messages ) { \nif ( messages . isEmpty ( ) ) return ; \nfinal int validatorHash = System . identityHashCode ( validator ) ; \nif ( ! validatorToMessagesMap . containsKey ( validatorHash ) ) validatorToMessagesMap . put ( validatorHash , new ArrayList < > ( ) ) ; \nfinal List < Integer > messageHashesOfThisValidator = validatorToMessagesMap . get ( validatorHash ) ; \nmessages . stream ( ) . map ( System :: identityHashCode ) . forEach ( messageHashesOfThisValidator :: add ) ; \ngetMessagesInternal ( ) . addAll ( messages ) ; \n} \n} \n"}
{"5868": "public class ViewLoaderReflectionUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < V extends View < ? extends VM > , VM extends ViewModel > void createAndInjectViewModel ( final V view , Consumer < ViewModel > newVmConsumer ) { \nfinal Class < ? > viewModelType = TypeResolver . resolveRawArgument ( View . class , view . getClass ( ) ) ; \nif ( viewModelType == ViewModel . class ) { \nfinal List < Field > viewModelFields = ViewLoaderReflectionUtils . getViewModelFields ( view . getClass ( ) ) ; \nif ( ! viewModelFields . isEmpty ( ) ) throw new RuntimeException ( \"The given view of type <\" + view . getClass ( ) + \"> has no generic viewModel type declared but tries to inject a viewModel.\" ) ; \nreturn ; \n} \nif ( viewModelType == TypeResolver . Unknown . class ) return ; \nfinal Optional < Field > fieldOptional = getViewModelField ( view . getClass ( ) , viewModelType ) ; \nif ( fieldOptional . isPresent ( ) ) { \nField field = fieldOptional . get ( ) ; \nReflectionUtils . accessMember ( field , ( ) -> { \nObject existingViewModel = field . get ( view ) ; \nif ( existingViewModel == null ) { \nfinal Object newViewModel = DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; \nfield . set ( view , newViewModel ) ; \nnewVmConsumer . accept ( ( ViewModel ) newViewModel ) ; \n} \n} \n, \"Can't inject ViewModel of type <\" + viewModelType + \"> into the view <\" + view + \">\" ) ; \n} \n} \n} \n"}
{"5869": "public class ViewLoaderReflectionUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewModelType createViewModel ( ViewType view ) { \nfinal Class < ? > viewModelType = TypeResolver . resolveRawArgument ( View . class , view . getClass ( ) ) ; \nif ( viewModelType == ViewModel . class ) return null ; \nif ( TypeResolver . Unknown . class == viewModelType ) return null ; \nreturn ( ViewModelType ) DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; \n} \n} \n"}
{"5870": "public class DataFxCountrySelector { \nvoid loadCountries ( ) { \nInputStream iso3166Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_LOCATION ) ; \nif ( iso3166Resource == null ) throw new IllegalStateException ( \"Can't find the list of countries! Expected location was:\" + ISO_3166_LOCATION ) ; \nXmlConverter < Country > countryConverter = new XmlConverter < > ( \"iso_3166_entry\" , Country . class ) ; \ntry { \nDataReader < Country > dataSource = new InputStreamSource < > ( iso3166Resource , countryConverter ) ; \nListDataProvider < Country > listDataProvider = new ListDataProvider < > ( dataSource ) ; \nlistDataProvider . setResultObservableList ( countries ) ; \nWorker < ObservableList < Country > > worker = listDataProvider . retrieve ( ) ; \nworker . stateProperty ( ) . addListener ( obs -> { \nif ( worker . getState ( ) == Worker . State . SUCCEEDED ) loadSubdivisions ( ) ; \n} \n) ; \n} \ncatch ( IOException e ) { \nLOG . error ( \"A problem was detected while loading the XML file with the available countries.\" , e ) ; \n} \n} \n} \n"}
{"5871": "public class DataFxCountrySelector { \nvoid loadSubdivisions ( ) { \nInputStream iso3166_2Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_2_LOCATION ) ; \nif ( iso3166_2Resource == null ) throw new IllegalStateException ( \"Can't find the list of subdivisions! Expected location was:\" + ISO_3166_2_LOCATION ) ; \nXmlConverter < ISO3166_2_CountryEntity > converter = new XmlConverter < > ( \"iso_3166_country\" , ISO3166_2_CountryEntity . class ) ; \nObservableList < ISO3166_2_CountryEntity > subdivisionsEntities = FXCollections . observableArrayList ( ) ; \ntry { \nDataReader < ISO3166_2_CountryEntity > dataSource = new InputStreamSource < > ( iso3166_2Resource , converter ) ; \nListDataProvider < ISO3166_2_CountryEntity > listDataProvider = new ListDataProvider < > ( dataSource ) ; \nlistDataProvider . setResultObservableList ( subdivisionsEntities ) ; \nWorker < ObservableList < ISO3166_2_CountryEntity > > worker = listDataProvider . retrieve ( ) ; \nworker . stateProperty ( ) . addListener ( obs -> { \nif ( worker . getState ( ) == Worker . State . SUCCEEDED ) { \nsubdivisionsEntities . forEach ( entity -> { \nif ( entity . subsets != null && ! entity . subsets . isEmpty ( ) ) { \nCountry country = findCountryByCode ( entity . code ) ; \nif ( ! countryCodeSubdivisionMap . containsKey ( country ) ) countryCodeSubdivisionMap . put ( country , new ArrayList < > ( ) ) ; \nList < Subdivision > subdivisionList = countryCodeSubdivisionMap . get ( country ) ; \nentity . subsets . forEach ( subset -> { \nsubset . entryList . forEach ( entry -> { \nsubdivisionList . add ( new Subdivision ( entry . name , entry . code , country ) ) ; \n} \n) ; \n} \n) ; \nString subdivisionName = entity . subsets . stream ( ) . map ( subset -> subset . subdivisionType ) . collect ( Collectors . joining ( \"/\" ) ) ; \ncountryCodeSubdivisionNameMap . put ( country , subdivisionName ) ; \n} \n} \n) ; \ninProgress . set ( false ) ; \n} \n} \n) ; \n} \ncatch ( IOException e ) { \nLOG . error ( \"A problem was detected while loading the XML file with the available subdivisions.\" , e ) ; \n} \n} \n} \n"}
{"5877": "public class SelectableItemList { \nprivate void createIndexEvents ( ) { \nselectionModel . selectedIndexProperty ( ) . addListener ( ( bean , oldVal , newVal ) -> { \nint index = newVal . intValue ( ) ; \nListType item = index == - 1 ? null : modelListProperty ( ) . get ( index ) ; \nselectedItem . set ( item ) ; \n} \n) ; \nselectedItem . addListener ( ( observable , oldVal , newVal ) -> { \nif ( newVal == null ) { \nselectionModel . select ( - 1 ) ; \nselectedItem . set ( null ) ; \n} \nelse { \nint index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; \nif ( index != - 1 ) selectionModel . select ( index ) ; \nelse selectedItem . set ( oldVal ) ; \n} \n} \n) ; \n} \n} \n"}
{"5878": "public class ReflectionUtils { \npublic static < T > T accessMember ( final AccessibleObject member , final Callable < T > callable , String errorMessage ) { \nif ( callable == null ) return null ; \nreturn AccessController . doPrivileged ( ( PrivilegedAction < T > ) ( ) -> { \nboolean wasAccessible = member . isAccessible ( ) ; \ntry { \nmember . setAccessible ( true ) ; \nreturn callable . call ( ) ; \n} \ncatch ( Exception exception ) { \nthrow new IllegalStateException ( errorMessage , exception ) ; \n} \nfinally { \nmember . setAccessible ( wasAccessible ) ; \n} \n} \n) ; \n} \n} \n"}
{"5880": "public class FxmlViewLoader { \nprivate String createFxmlPath ( Class < ? > viewType ) { \nfinal StringBuilder pathBuilder = new StringBuilder ( ) ; \nfinal FxmlPath pathAnnotation = viewType . getDeclaredAnnotation ( FxmlPath . class ) ; \nfinal String fxmlPath = Optional . ofNullable ( pathAnnotation ) . map ( FxmlPath :: value ) . map ( String :: trim ) . orElse ( \"\" ) ; \nif ( fxmlPath . isEmpty ( ) ) { \npathBuilder . append ( \"/\" ) ; \nif ( viewType . getPackage ( ) != null ) { \npathBuilder . append ( viewType . getPackage ( ) . getName ( ) . replaceAll ( \"\\\\.\" , \"/\" ) ) ; \npathBuilder . append ( \"/\" ) ; \n} \npathBuilder . append ( viewType . getSimpleName ( ) ) ; \npathBuilder . append ( \".fxml\" ) ; \n} \nelse pathBuilder . append ( fxmlPath ) ; \nreturn pathBuilder . toString ( ) ; \n} \n} \n"}
{"5881": "public class StyleDao { \npublic StyleRow queryForRow ( StyleMappingRow styleMappingRow ) { \nStyleRow styleRow = null ; \nAttributesRow attributesRow = queryForIdRow ( styleMappingRow . getRelatedId ( ) ) ; \nif ( attributesRow != null ) styleRow = getRow ( attributesRow ) ; \nreturn styleRow ; \n} \n} \n"}
{"5884": "public class CoverageDataPng { \npublic static void validateImageType ( PngReader reader ) { \nif ( reader == null ) throw new GeoPackageException ( \"The image is null\" ) ; \nif ( reader . imgInfo . channels != 1 || reader . imgInfo . bitDepth != 16 ) throw new GeoPackageException ( \"The coverage data tile is expected to be a single channel 16 bit unsigned short, channels: \" + reader . imgInfo . channels + \", bits: \" + reader . imgInfo . bitDepth ) ; \n} \n} \n"}
{"5890": "public class UserConnection { \npublic TResult query ( UserQuery query ) { \nCursor cursor = null ; \nString [ ] selectionArgs = query . getSelectionArgs ( ) ; \nString sql = query . getSql ( ) ; \nif ( sql != null ) cursor = database . rawQuery ( sql , selectionArgs ) ; \nelse { \nString table = query . getTable ( ) ; \nString [ ] columns = query . getColumns ( ) ; \nString selection = query . getSelection ( ) ; \nString groupBy = query . getGroupBy ( ) ; \nString having = query . getHaving ( ) ; \nString orderBy = query . getOrderBy ( ) ; \nString [ ] columnsAs = query . getColumnsAs ( ) ; \nString limit = query . getLimit ( ) ; \nif ( columnsAs != null && limit != null ) cursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy , limit ) ; \nelse if ( columnsAs != null ) cursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy ) ; \nelse if ( limit != null ) cursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; \nelse cursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; \n} \nTResult result = handleCursor ( cursor , query ) ; \nreturn result ; \n} \n} \n"}
{"5891": "public class UserConnection { \nprivate TResult handleCursor ( Cursor cursor , UserQuery query ) { \nTResult result = convertCursor ( cursor ) ; \nresult . setQuery ( query ) ; \nif ( table != null ) result . setTable ( table ) ; \nreturn result ; \n} \n} \n"}
{"5892": "public class FeatureTableIndex { \npublic FeatureRow getFeatureRow ( GeometryIndex geometryIndex ) { \nlong geomId = geometryIndex . getGeomId ( ) ; \nFeatureRow row = featureRowSync . getRowOrLock ( geomId ) ; \nif ( row == null ) try { \nrow = featureDao . queryForIdRow ( geomId ) ; \n} \nfinally { \nfeatureRowSync . setRow ( geomId , row ) ; \n} \nreturn row ; \n} \n} \n"}
{"5895": "public class CoverageData { \npublic static CoverageData < ? > getCoverageData ( GeoPackage geoPackage , TileDao tileDao , Integer width , Integer height , Projection requestProjection ) { \nTileMatrixSet tileMatrixSet = tileDao . getTileMatrixSet ( ) ; \nGriddedCoverageDao griddedCoverageDao = geoPackage . getGriddedCoverageDao ( ) ; \nGriddedCoverage griddedCoverage = null ; \ntry { \nif ( griddedCoverageDao . isTableExists ( ) ) griddedCoverage = griddedCoverageDao . query ( tileMatrixSet ) ; \n} \ncatch ( SQLException e ) { \nthrow new GeoPackageException ( \"Failed to get Gridded Coverage for table name: \" + tileMatrixSet . getTableName ( ) , e ) ; \n} \nCoverageData < ? > coverageData = null ; \nGriddedCoverageDataType dataType = griddedCoverage . getDataType ( ) ; \nswitch ( dataType ) { \ncase INTEGER : coverageData = new CoverageDataPng ( geoPackage , tileDao , width , height , requestProjection ) ; \nbreak ; \ncase FLOAT : coverageData = new CoverageDataTiff ( geoPackage , tileDao , width , height , requestProjection ) ; \nbreak ; \ndefault : throw new GeoPackageException ( \"Unsupported Gridded Coverage Data Type: \" + dataType ) ; \n} \nreturn coverageData ; \n} \n} \n"}
{"5898": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResults ( CoverageDataRequest request , BoundingBox requestProjectedBoundingBox , int overlappingPixels ) { \nTileMatrix tileMatrix = getTileMatrix ( request ) ; \nCoverageDataTileMatrixResults results = null ; \nif ( tileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \nif ( results == null ) results = getResultsZoom ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \n} \nreturn results ; \n} \n} \n"}
{"5899": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoom ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nif ( zoomIn && zoomInBeforeOut ) results = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \nif ( results == null && zoomOut ) results = getResultsZoomOut ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \nif ( results == null && zoomIn && ! zoomInBeforeOut ) results = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \nreturn results ; \n} \n} \n"}
{"5900": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nfor ( long zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; \nzoomLevel <= tileDao . getMaxZoom ( ) ; \nzoomLevel ++ ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) break ; \n} \n} \nreturn results ; \n} \n} \n"}
{"5901": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nfor ( long zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; \nzoomLevel >= tileDao . getMinZoom ( ) ; \nzoomLevel -- ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) break ; \n} \n} \nreturn results ; \n} \n} \n"}
{"5902": "public class CoverageData { \nprivate TileMatrix getTileMatrix ( CoverageDataRequest request ) { \nTileMatrix tileMatrix = null ; \nif ( request . overlap ( coverageBoundingBox ) != null ) { \nBoundingBox projectedBoundingBox = request . getProjectedBoundingBox ( ) ; \ndouble distanceWidth = projectedBoundingBox . getMaxLongitude ( ) - projectedBoundingBox . getMinLongitude ( ) ; \ndouble distanceHeight = projectedBoundingBox . getMaxLatitude ( ) - projectedBoundingBox . getMinLatitude ( ) ; \nLong zoomLevel = tileDao . getClosestZoomLevel ( distanceWidth , distanceHeight ) ; \nif ( zoomLevel != null ) tileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \n} \nreturn tileMatrix ; \n} \n} \n"}
{"5904": "public class Icons { \npublic void setIcon ( IconRow iconRow , GeometryType geometryType ) { \nif ( geometryType != null ) if ( iconRow != null ) icons . put ( geometryType , iconRow ) ; \nelse icons . remove ( geometryType ) ; \nelse defaultIcon = iconRow ; \n} \n} \n"}
{"5905": "public class Icons { \npublic IconRow getIcon ( GeometryType geometryType ) { \nIconRow iconRow = null ; \nif ( geometryType != null && ! icons . isEmpty ( ) ) { \nList < GeometryType > geometryTypes = GeometryUtils . parentHierarchy ( geometryType ) ; \ngeometryTypes . add ( 0 , geometryType ) ; \nfor ( GeometryType type : geometryTypes ) { \niconRow = icons . get ( type ) ; \nif ( iconRow != null ) break ; \n} \n} \nif ( iconRow == null ) iconRow = defaultIcon ; \nif ( iconRow == null && geometryType == null && icons . size ( ) == 1 ) iconRow = icons . values ( ) . iterator ( ) . next ( ) ; \nreturn iconRow ; \n} \n} \n"}
{"5906": "public class GeoPackageDatabase { \npublic org . sqlite . database . sqlite . SQLiteDatabase openOrGetBindingsDb ( ) { \nif ( bindingsDb == null ) synchronized ( db ) { \nif ( bindingsDb == null ) { \nSystem . loadLibrary ( \"sqliteX\" ) ; \nbindingsDb = org . sqlite . database . sqlite . SQLiteDatabase . openDatabase ( db . getPath ( ) , null , org . sqlite . database . sqlite . SQLiteDatabase . OPEN_READWRITE ) ; \n} \n} \nreturn bindingsDb ; \n} \n} \n"}
{"5909": "public class TableMetadataDataSource { \npublic void create ( TableMetadata metadata ) { \nContentValues values = new ContentValues ( ) ; \nvalues . put ( TableMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; \nvalues . put ( TableMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; \nvalues . put ( TableMetadata . COLUMN_LAST_INDEXED , metadata . getLastIndexed ( ) ) ; \nlong insertId = db . insert ( TableMetadata . TABLE_NAME , null , values ) ; \nif ( insertId == - 1 ) throw new GeoPackageException ( \"Failed to insert table metadata. GeoPackage Id: \" + metadata . getGeoPackageId ( ) + \", Table Name: \" + metadata . getTableName ( ) + \", Last Indexed: \" + metadata . getLastIndexed ( ) ) ; \n} \n} \n"}
{"5912": "public class TableMetadataDataSource { \npublic long getGeoPackageId ( String geoPackage ) { \nlong id = - 1 ; \nGeoPackageMetadataDataSource ds = new GeoPackageMetadataDataSource ( db ) ; \nGeoPackageMetadata metadata = ds . get ( geoPackage ) ; \nif ( metadata != null ) id = metadata . getId ( ) ; \nreturn id ; \n} \n} \n"}
{"5913": "public class TableMetadataDataSource { \nprivate TableMetadata createTableMetadata ( Cursor cursor ) { \nTableMetadata metadata = new TableMetadata ( ) ; \nmetadata . setGeoPackageId ( cursor . getLong ( 0 ) ) ; \nmetadata . setTableName ( cursor . getString ( 1 ) ) ; \nif ( ! cursor . isNull ( 2 ) ) metadata . setLastIndexed ( cursor . getLong ( 2 ) ) ; \nreturn metadata ; \n} \n} \n"}
{"5914": "public class RTreeIndexTableDao { \npublic Extensions create ( ) { \nExtensions extension = null ; \nif ( ! has ( ) ) { \nextension = rTree . create ( featureDao . getTable ( ) ) ; \nif ( progress != null ) progress . addProgress ( count ( ) ) ; \n} \nreturn extension ; \n} \n} \n"}
{"5925": "public class ManualFeatureQuery { \npublic ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { \nList < Long > featureIds = new ArrayList < > ( ) ; \nlong offset = 0 ; \nboolean hasResults = true ; \nminX -= tolerance ; \nmaxX += tolerance ; \nminY -= tolerance ; \nmaxY += tolerance ; \nwhile ( hasResults ) { \nhasResults = false ; \nFeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; \ntry { \nwhile ( featureCursor . moveToNext ( ) ) { \nhasResults = true ; \nFeatureRow featureRow = featureCursor . getRow ( ) ; \nGeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; \nif ( envelope != null ) { \ndouble minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; \ndouble maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; \ndouble minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; \ndouble maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; \nif ( minXMax <= maxXMin && minYMax <= maxYMin ) featureIds . add ( featureRow . getId ( ) ) ; \n} \n} \n} \nfinally { \nfeatureCursor . close ( ) ; \n} \noffset += chunkLimit ; \n} \nManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; \nreturn results ; \n} \n} \n"}
{"5929": "public class TileGenerator { \npublic void setBitmapCompressionConfig ( Config config ) { \nif ( options == null ) options = new Options ( ) ; \noptions . inPreferredConfig = config ; \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) transformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \nfor ( int zoom = minZoom ; \nzoom <= maxZoom ; \nzoom ++ ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( degrees ) tileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \nelse tileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \ncount += tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"5931": "public class TileGenerator { \nprivate void adjustBounds ( BoundingBox boundingBox , int zoom ) { \nif ( googleTiles ) adjustGoogleBounds ( ) ; \nelse if ( projection . isUnit ( Units . DEGREES ) ) adjustGeoPackageBoundsWGS84 ( boundingBox , zoom ) ; \nelse adjustGeoPackageBounds ( boundingBox , zoom ) ; \n} \n} \n"}
{"5936": "public class TileDao { \npublic TileGrid getTileGrid ( long zoomLevel ) { \nTileGrid tileGrid = null ; \nTileMatrix tileMatrix = getTileMatrix ( zoomLevel ) ; \nif ( tileMatrix != null ) tileGrid = new TileGrid ( 0 , 0 , tileMatrix . getMatrixWidth ( ) - 1 , tileMatrix . getMatrixHeight ( ) - 1 ) ; \nreturn tileGrid ; \n} \n} \n"}
{"5937": "public class TileDao { \npublic TileRow queryForTile ( long column , long row , long zoomLevel ) { \nMap < String , Object > fieldValues = new HashMap < String , Object > ( ) ; \nfieldValues . put ( TileTable . COLUMN_TILE_COLUMN , column ) ; \nfieldValues . put ( TileTable . COLUMN_TILE_ROW , row ) ; \nfieldValues . put ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; \nTileCursor cursor = queryForFieldValues ( fieldValues ) ; \nTileRow tileRow = null ; \ntry { \nif ( cursor . moveToNext ( ) ) tileRow = cursor . getRow ( ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn tileRow ; \n} \n} \n"}
{"5941": "public class TileDao { \npublic TileGrid queryForTileGrid ( long zoomLevel ) { \nString where = buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; \nString [ ] whereArgs = buildWhereArgs ( new Object [ ] { \nzoomLevel } \n) ; \nInteger minX = min ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; \nInteger maxX = max ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; \nInteger minY = min ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; \nInteger maxY = max ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; \nTileGrid tileGrid = null ; \nif ( minX != null && maxX != null && minY != null && maxY != null ) tileGrid = new TileGrid ( minX , minY , maxX , maxY ) ; \nreturn tileGrid ; \n} \n} \n"}
{"5946": "public class CoverageDataTiff { \npublic float [ ] getPixelValues ( byte [ ] imageBytes ) { \nTIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; \nFileDirectory directory = tiffImage . getFileDirectory ( ) ; \nvalidateImageType ( directory ) ; \nRasters rasters = directory . readRasters ( ) ; \nfloat [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; \nfor ( int y = 0 ; \ny < rasters . getHeight ( ) ; \ny ++ ) for ( int x = 0 ; \nx < rasters . getWidth ( ) ; \nx ++ ) { \nint index = rasters . getSampleIndex ( x , y ) ; \npixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; \n} \nreturn pixels ; \n} \n} \n"}
{"5947": "public class CoverageDataTiff { \npublic static void validateImageType ( FileDirectory directory ) { \nif ( directory == null ) throw new GeoPackageException ( \"The image is null\" ) ; \nint samplesPerPixel = directory . getSamplesPerPixel ( ) ; \nInteger bitsPerSample = null ; \nif ( directory . getBitsPerSample ( ) != null && ! directory . getBitsPerSample ( ) . isEmpty ( ) ) bitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; \nInteger sampleFormat = null ; \nif ( directory . getSampleFormat ( ) != null && ! directory . getSampleFormat ( ) . isEmpty ( ) ) sampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; \nif ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null || sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) throw new GeoPackageException ( \"The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: \" + samplesPerPixel + \", Bits Per Sample: \" + bitsPerSample + \", Sample Format: \" + sampleFormat ) ; \n} \n} \n"}
{"5950": "public class GeoPackageCache { \nprivate GeoPackage getOrOpen ( String name , boolean writable , boolean cache ) { \nGeoPackage geoPackage = get ( name ) ; \nif ( geoPackage == null ) { \ngeoPackage = manager . open ( name , writable ) ; \nif ( cache ) add ( geoPackage ) ; \n} \nreturn geoPackage ; \n} \n} \n"}
{"5951": "public class UserCursor { \nprivate TRow getCurrentRow ( ) { \nTRow row = null ; \nif ( table != null ) { \nint [ ] columnTypes = new int [ table . columnCount ( ) ] ; \nObject [ ] values = new Object [ table . columnCount ( ) ] ; \nboolean valid = true ; \nfor ( TColumn column : table . getColumns ( ) ) { \nint index = column . getIndex ( ) ; \nint columnType = getType ( index ) ; \nif ( column . isPrimaryKey ( ) && columnType == FIELD_TYPE_NULL ) valid = false ; \ncolumnTypes [ index ] = columnType ; \nvalues [ index ] = getValue ( column ) ; \n} \nrow = getRow ( columnTypes , values ) ; \nif ( ! valid ) { \ninvalidPositions . add ( getPosition ( ) ) ; \nrow . setValid ( false ) ; \n} \n} \nreturn row ; \n} \n} \n"}
{"5952": "public class UserCursor { \nprivate boolean moveToNextInvalid ( ) { \nboolean hasNext = false ; \nif ( invalidCursor == null && dao != null && hasInvalidPositions ( ) ) { \nsuper . close ( ) ; \nList < TColumn > blobColumns = dao . getTable ( ) . columnsOfType ( GeoPackageDataType . BLOB ) ; \nString [ ] columnsAs = dao . buildColumnsAsNull ( blobColumns ) ; \nquery . set ( UserQueryParamType . COLUMNS_AS , columnsAs ) ; \nUserCursor < TColumn , TTable , TRow > requeryCursor = dao . query ( query ) ; \ninvalidCursor = createInvalidCursor ( dao , requeryCursor , getInvalidPositions ( ) , blobColumns ) ; \n} \nif ( invalidCursor != null ) hasNext = invalidCursor . moveToNext ( ) ; \nreturn hasNext ; \n} \n} \n"}
{"5953": "public class StyleMappingDao { \npublic List < StyleMappingRow > queryByBaseFeatureId ( long id ) { \nList < StyleMappingRow > rows = new ArrayList < > ( ) ; \nUserCustomCursor cursor = queryByBaseId ( id ) ; \ntry { \nwhile ( cursor . moveToNext ( ) ) rows . add ( getRow ( cursor ) ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn rows ; \n} \n} \n"}
{"5954": "public class StyleMappingDao { \npublic int deleteByBaseId ( long id , GeometryType geometryType ) { \nString geometryTypeName = null ; \nif ( geometryType != null ) geometryTypeName = geometryType . getName ( ) ; \nStringBuilder where = new StringBuilder ( ) ; \nwhere . append ( buildWhere ( StyleMappingTable . COLUMN_BASE_ID , id ) ) ; \nwhere . append ( \" AND \" ) ; \nwhere . append ( buildWhere ( StyleMappingTable . COLUMN_GEOMETRY_TYPE_NAME , geometryTypeName ) ) ; \nList < Object > whereArguments = new ArrayList < > ( ) ; \nwhereArguments . add ( id ) ; \nif ( geometryTypeName != null ) whereArguments . add ( geometryTypeName ) ; \nString [ ] whereArgs = buildWhereArgs ( whereArguments ) ; \nint deleted = delete ( where . toString ( ) , whereArgs ) ; \nreturn deleted ; \n} \n} \n"}
{"5957": "public class GeoPackageManagerImpl { \nprivate List < String > deleteMissingDatabases ( List < String > databases ) { \nList < String > filesExist = new ArrayList < > ( ) ; \nfor ( String database : databases ) { \nif ( exists ( database ) ) filesExist . add ( database ) ; \n} \nreturn filesExist ; \n} \n} \n"}
{"5962": "public class GeoPackageManagerImpl { \nprivate void validateDatabase ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity , boolean close , boolean closeOnError ) { \ntry { \nif ( validateHeader ) validateDatabaseHeader ( sqliteDatabase ) ; \nif ( validateIntegrity ) validateDatabaseIntegrity ( sqliteDatabase ) ; \n} \ncatch ( Exception e ) { \nif ( closeOnError ) sqliteDatabase . close ( ) ; \nthrow e ; \n} \nif ( close ) sqliteDatabase . close ( ) ; \n} \n} \n"}
{"5963": "public class GeoPackageManagerImpl { \nprivate void validateDatabaseHeader ( SQLiteDatabase sqliteDatabase ) { \nboolean validHeader = isDatabaseHeaderValid ( sqliteDatabase ) ; \nif ( ! validHeader ) throw new GeoPackageException ( \"GeoPackage SQLite header is not valid: \" + sqliteDatabase . getPath ( ) ) ; \n} \n} \n"}
{"5964": "public class GeoPackageManagerImpl { \nprivate boolean isDatabaseHeaderValid ( SQLiteDatabase sqliteDatabase ) { \nboolean validHeader = false ; \nFileInputStream fis = null ; \ntry { \nfis = new FileInputStream ( sqliteDatabase . getPath ( ) ) ; \nbyte [ ] headerBytes = new byte [ 16 ] ; \nif ( fis . read ( headerBytes ) == 16 ) { \nByteReader byteReader = new ByteReader ( headerBytes ) ; \nString header = byteReader . readString ( headerBytes . length ) ; \nString headerPrefix = header . substring ( 0 , GeoPackageConstants . SQLITE_HEADER_PREFIX . length ( ) ) ; \nvalidHeader = headerPrefix . equalsIgnoreCase ( GeoPackageConstants . SQLITE_HEADER_PREFIX ) ; \n} \n} \ncatch ( Exception e ) { \nLog . e ( GeoPackageManagerImpl . class . getSimpleName ( ) , \"Failed to retrieve database header\" , e ) ; \n} \nfinally { \nif ( fis != null ) try { \nfis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nreturn validHeader ; \n} \n} \n"}
{"5965": "public class GeoPackageManagerImpl { \nprivate void addInternalDatabases ( Collection < String > databases ) { \nString [ ] databaseArray = context . databaseList ( ) ; \nfor ( String database : databaseArray ) { \nif ( ! isTemporary ( database ) && ! database . equalsIgnoreCase ( GeoPackageMetadataDb . DATABASE_NAME ) ) databases . add ( database ) ; \n} \n} \n} \n"}
{"5966": "public class GeoPackageManagerImpl { \nprivate void addExternalDatabases ( Collection < String > databases ) { \nList < GeoPackageMetadata > externalGeoPackages = getExternalGeoPackages ( ) ; \nfor ( GeoPackageMetadata external : externalGeoPackages ) { \nif ( new File ( external . getExternalPath ( ) ) . exists ( ) ) databases . add ( external . getName ( ) ) ; \nelse delete ( external . getName ( ) ) ; \n} \n} \n} \n"}
{"5967": "public class GeoPackageManagerImpl { \nprivate boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { \ntry { \nif ( exists ( database ) ) if ( override ) if ( ! delete ( database ) ) throw new GeoPackageException ( \"Failed to delete existing database: \" + database ) ; \nelse throw new GeoPackageException ( \"GeoPackage database already exists: \" + database ) ; \nFile newDbFile = context . getDatabasePath ( database ) ; \ntry { \nSQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; \ndb . close ( ) ; \nGeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; \n} \ncatch ( IOException e ) { \nthrow new GeoPackageException ( \"Failed to import GeoPackage database: \" + database , e ) ; \n} \n} \nfinally { \nGeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; \n} \nif ( progress == null || progress . isActive ( ) ) { \ntry { \nSQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { \n@ Override public void onCorruption ( SQLiteDatabase dbObj ) { \n} \n} \n) ; \nvalidateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; \nGeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; \nmetadataDb . open ( ) ; \ntry { \nGeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; \nGeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; \nmetadata . setName ( database ) ; \ndataSource . create ( metadata ) ; \n} \nfinally { \nmetadataDb . close ( ) ; \n} \n} \ncatch ( Exception e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file\" , e ) ; \n} \nGeoPackage geoPackage = open ( database , false ) ; \nif ( geoPackage != null ) try { \nif ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \n} \ncatch ( SQLException e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Could not verify existence of required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \nfinally { \ngeoPackage . close ( ) ; \n} \nelse { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Unable to open GeoPackage database. Database: \" + database ) ; \n} \n} \nreturn exists ( database ) ; \n} \n} \n"}
{"5970": "public class GeometryMetadataDataSource { \npublic long create ( GeometryMetadata metadata ) { \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeometryMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_ID , metadata . getId ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; \nlong insertId = db . insert ( GeometryMetadata . TABLE_NAME , null , values ) ; \nif ( insertId == - 1 ) throw new GeoPackageException ( \"Failed to insert geometry metadata. GeoPackage Id: \" + metadata . getGeoPackageId ( ) + \", Table Name: \" + metadata . getTableName ( ) + \", Geometry Id: \" + metadata . getId ( ) ) ; \nmetadata . setId ( insertId ) ; \nreturn insertId ; \n} \n} \n"}
{"5973": "public class GeometryMetadataDataSource { \npublic boolean createOrUpdate ( GeometryMetadata metadata ) { \nboolean success = false ; \nif ( exists ( metadata ) ) success = update ( metadata ) ; \nelse { \ncreate ( metadata ) ; \nsuccess = true ; \n} \nreturn success ; \n} \n} \n"}
{"5976": "public class GeometryMetadataDataSource { \npublic static GeometryMetadata createGeometryMetadata ( Cursor cursor ) { \nGeometryMetadata metadata = new GeometryMetadata ( ) ; \nmetadata . setGeoPackageId ( cursor . getLong ( 0 ) ) ; \nmetadata . setTableName ( cursor . getString ( 1 ) ) ; \nmetadata . setId ( cursor . getLong ( 2 ) ) ; \nmetadata . setMinX ( cursor . getDouble ( 3 ) ) ; \nmetadata . setMaxX ( cursor . getDouble ( 4 ) ) ; \nmetadata . setMinY ( cursor . getDouble ( 5 ) ) ; \nmetadata . setMaxY ( cursor . getDouble ( 6 ) ) ; \nif ( ! cursor . isNull ( 7 ) ) metadata . setMinZ ( cursor . getDouble ( 7 ) ) ; \nif ( ! cursor . isNull ( 8 ) ) metadata . setMaxZ ( cursor . getDouble ( 8 ) ) ; \nif ( ! cursor . isNull ( 9 ) ) metadata . setMinM ( cursor . getDouble ( 9 ) ) ; \nif ( ! cursor . isNull ( 10 ) ) metadata . setMaxM ( cursor . getDouble ( 10 ) ) ; \nreturn metadata ; \n} \n} \n"}
{"5978": "public class NumberFeaturesTile { \nprivate Bitmap drawTile ( int tileWidth , int tileHeight , String text ) { \nBitmap bitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; \nCanvas canvas = new Canvas ( bitmap ) ; \nif ( tileFillPaint != null ) canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileFillPaint ) ; \nif ( tileBorderPaint != null ) canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileBorderPaint ) ; \nRect textBounds = new Rect ( ) ; \ntextPaint . getTextBounds ( text , 0 , text . length ( ) , textBounds ) ; \nint centerX = ( int ) ( bitmap . getWidth ( ) / 2.0f ) ; \nint centerY = ( int ) ( bitmap . getHeight ( ) / 2.0f ) ; \nif ( circlePaint != null || circleFillPaint != null ) { \nint diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; \nfloat radius = diameter / 2.0f ; \nradius = radius + ( diameter * circlePaddingPercentage ) ; \nif ( circleFillPaint != null ) canvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; \nif ( circlePaint != null ) canvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; \n} \ncanvas . drawText ( text , centerX - textBounds . exactCenterX ( ) , centerY - textBounds . exactCenterY ( ) , textPaint ) ; \nreturn bitmap ; \n} \n} \n"}
{"5979": "public class SimpleAttributesDao { \npublic List < SimpleAttributesRow > getRows ( List < Long > ids ) { \nList < SimpleAttributesRow > simpleAttributesRows = new ArrayList < > ( ) ; \nfor ( long id : ids ) { \nUserCustomRow userCustomRow = queryForIdRow ( id ) ; \nif ( userCustomRow != null ) simpleAttributesRows . add ( getRow ( userCustomRow ) ) ; \n} \nreturn simpleAttributesRows ; \n} \n} \n"}
{"5989": "public class TileCreator { \npublic GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { \nGeoPackageTile tile = null ; \nProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; \nBoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nList < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; \nfor ( int i = 0 ; \ntile == null && i < tileMatrices . size ( ) ; \ni ++ ) { \nTileMatrix tileMatrix = tileMatrices . get ( i ) ; \nTileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; \nif ( tileResults != null ) try { \nif ( tileResults . getCount ( ) > 0 ) { \nBoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nint requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; \nint requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; \nint tileWidth = requestedTileWidth ; \nint tileHeight = requestedTileHeight ; \nif ( ! sameProjection ) { \ntileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; \ntileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; \n} \nBitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; \nif ( tileBitmap != null ) { \nif ( ! sameProjection ) { \nBitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; \ntileBitmap . recycle ( ) ; \ntileBitmap = reprojectTile ; \n} \ntry { \nbyte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; \ntileBitmap . recycle ( ) ; \ntile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; \n} \ncatch ( IOException e ) { \nLog . e ( TileCreator . class . getSimpleName ( ) , \"Failed to create tile. min lat: \" + requestBoundingBox . getMinLatitude ( ) + \", max lat: \" + requestBoundingBox . getMaxLatitude ( ) + \", min lon: \" + requestBoundingBox . getMinLongitude ( ) + \", max lon: \" + requestBoundingBox . getMaxLongitude ( ) , e ) ; \n} \n} \n} \n} \nfinally { \ntileResults . close ( ) ; \n} \n} \nreturn tile ; \n} \n} \n"}
{"5991": "public class TileCreator { \nprivate Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { \nfinal double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; \nfinal double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; \nfinal double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; \nfinal double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; \nfinal int width = tile . getWidth ( ) ; \nfinal int height = tile . getHeight ( ) ; \nint [ ] pixels = new int [ width * height ] ; \ntile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; \nint [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; \nfor ( int y = 0 ; \ny < requestedTileHeight ; \ny ++ ) for ( int x = 0 ; \nx < requestedTileWidth ; \nx ++ ) { \ndouble longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; \ndouble latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; \nProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; \nProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; \ndouble projectedLongitude = toCoord . x ; \ndouble projectedLatitude = toCoord . y ; \nint xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; \nint yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; \nxPixel = Math . max ( 0 , xPixel ) ; \nxPixel = Math . min ( width - 1 , xPixel ) ; \nyPixel = Math . max ( 0 , yPixel ) ; \nyPixel = Math . min ( height - 1 , yPixel ) ; \nint color = pixels [ ( yPixel * width ) + xPixel ] ; \nprojectedPixels [ ( y * requestedTileWidth ) + x ] = color ; \n} \nBitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; \nprojectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; \nreturn projectedTileBitmap ; \n} \n} \n"}
{"5993": "public class FeatureTiles { \npublic void calculateDrawOverlap ( ) { \nif ( pointIcon != null ) { \nheightOverlap = this . density * pointIcon . getHeight ( ) ; \nwidthOverlap = this . density * pointIcon . getWidth ( ) ; \n} \nelse { \nheightOverlap = this . density * pointRadius ; \nwidthOverlap = this . density * pointRadius ; \n} \nfloat linePaintHalfStroke = this . density * lineStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , linePaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , linePaintHalfStroke ) ; \nfloat polygonPaintHalfStroke = this . density * polygonStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , polygonPaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , polygonPaintHalfStroke ) ; \nif ( featureTableStyles != null && featureTableStyles . has ( ) ) { \nSet < Long > styleRowIds = new HashSet < > ( ) ; \nList < Long > tableStyleIds = featureTableStyles . getAllTableStyleIds ( ) ; \nif ( tableStyleIds != null ) styleRowIds . addAll ( tableStyleIds ) ; \nList < Long > styleIds = featureTableStyles . getAllStyleIds ( ) ; \nif ( styleIds != null ) styleRowIds . addAll ( styleIds ) ; \nStyleDao styleDao = featureTableStyles . getStyleDao ( ) ; \nfor ( long styleRowId : styleRowIds ) { \nStyleRow styleRow = styleDao . getRow ( styleDao . queryForIdRow ( styleRowId ) ) ; \nfloat styleHalfWidth = this . density * ( float ) ( styleRow . getWidthOrDefault ( ) / 2.0f ) ; \nwidthOverlap = Math . max ( widthOverlap , styleHalfWidth ) ; \nheightOverlap = Math . max ( heightOverlap , styleHalfWidth ) ; \n} \nSet < Long > iconRowIds = new HashSet < > ( ) ; \nList < Long > tableIconIds = featureTableStyles . getAllTableIconIds ( ) ; \nif ( tableIconIds != null ) iconRowIds . addAll ( tableIconIds ) ; \nList < Long > iconIds = featureTableStyles . getAllIconIds ( ) ; \nif ( iconIds != null ) iconRowIds . addAll ( iconIds ) ; \nIconDao iconDao = featureTableStyles . getIconDao ( ) ; \nfor ( long iconRowId : iconRowIds ) { \nIconRow iconRow = iconDao . getRow ( iconDao . queryForIdRow ( iconRowId ) ) ; \ndouble [ ] iconDimensions = iconRow . getDerivedDimensions ( ) ; \nfloat iconWidth = this . density * ( float ) Math . ceil ( iconDimensions [ 0 ] ) ; \nfloat iconHeight = this . density * ( float ) Math . ceil ( iconDimensions [ 1 ] ) ; \nwidthOverlap = Math . max ( widthOverlap , iconWidth ) ; \nheightOverlap = Math . max ( heightOverlap , iconHeight ) ; \n} \n} \n} \n} \n"}
{"5995": "public class FeatureTiles { \npublic void setLinePaint ( Paint linePaint ) { \nif ( linePaint == null ) throw new AssertionError ( \"Line Paint can not be null\" ) ; \nthis . linePaint = linePaint ; \nsetLineStrokeWidth ( linePaint . getStrokeWidth ( ) ) ; \n} \n} \n"}
{"5996": "public class FeatureTiles { \npublic void setPolygonPaint ( Paint polygonPaint ) { \nif ( polygonPaint == null ) throw new AssertionError ( \"Polygon Paint can not be null\" ) ; \nthis . polygonPaint = polygonPaint ; \nsetPolygonStrokeWidth ( polygonPaint . getStrokeWidth ( ) ) ; \n} \n} \n"}
{"5997": "public class FeatureTiles { \npublic byte [ ] drawTileBytes ( int x , int y , int zoom ) { \nBitmap bitmap = drawTile ( x , y , zoom ) ; \nbyte [ ] tileData = null ; \nif ( bitmap != null ) try { \ntileData = BitmapConverter . toBytes ( bitmap , compressFormat ) ; \n} \ncatch ( IOException e ) { \nLog . e ( FeatureTiles . class . getSimpleName ( ) , \"Failed to create tile. x: \" + x + \", y: \" + y + \", zoom: \" + zoom , e ) ; \n} \nfinally { \nbitmap . recycle ( ) ; \n} \nreturn tileData ; \n} \n} \n"}
{"5998": "public class FeatureTiles { \npublic Bitmap drawTile ( int x , int y , int zoom ) { \nBitmap bitmap ; \nif ( isIndexQuery ( ) ) bitmap = drawTileQueryIndex ( x , y , zoom ) ; \nelse bitmap = drawTileQueryAll ( x , y , zoom ) ; \nreturn bitmap ; \n} \n} \n"}
{"5999": "public class FeatureTiles { \npublic Bitmap drawTileQueryIndex ( int x , int y , int zoom ) { \nBoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; \ntry { \nlong tileCount = results . count ( ) ; \nif ( tileCount > 0 ) if ( maxFeaturesPerTile == null || tileCount <= maxFeaturesPerTile . longValue ( ) ) bitmap = drawTile ( zoom , webMercatorBoundingBox , results ) ; \nelse if ( maxFeaturesTileDraw != null ) bitmap = maxFeaturesTileDraw . drawTile ( tileWidth , tileHeight , tileCount , results ) ; \n} \nfinally { \nresults . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6004": "public class FeatureTiles { \npublic Bitmap drawTileQueryAll ( int x , int y , int zoom ) { \nBoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureCursor cursor = featureDao . queryForAll ( ) ; \ntry { \nint totalCount = cursor . getCount ( ) ; \nif ( totalCount > 0 ) if ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) bitmap = drawTile ( zoom , boundingBox , cursor ) ; \nelse if ( maxFeaturesTileDraw != null ) bitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6005": "public class FeatureTiles { \nprotected List < Point > simplifyPoints ( double simplifyTolerance , List < Point > points ) { \nList < Point > simplifiedPoints = null ; \nif ( simplifyGeometries ) { \nif ( projection != null && ! projection . isUnit ( Units . METRES ) ) { \nProjectionTransform toWebMercator = projection . getTransformation ( WEB_MERCATOR_PROJECTION ) ; \npoints = toWebMercator . transform ( points ) ; \n} \nsimplifiedPoints = GeometryUtils . simplifyPoints ( points , simplifyTolerance ) ; \nif ( projection != null && ! projection . isUnit ( Units . METRES ) ) { \nProjectionTransform fromWebMercator = WEB_MERCATOR_PROJECTION . getTransformation ( projection ) ; \nsimplifiedPoints = fromWebMercator . transform ( simplifiedPoints ) ; \n} \n} \nelse simplifiedPoints = points ; \nreturn simplifiedPoints ; \n} \n} \n"}
{"6006": "public class FeatureTiles { \nprotected Paint getPointPaint ( FeatureStyle featureStyle ) { \nPaint paint = getFeatureStylePaint ( featureStyle , FeatureDrawType . CIRCLE ) ; \nif ( paint == null ) paint = pointPaint ; \nreturn paint ; \n} \n} \n"}
{"6007": "public class FeatureTiles { \nprotected Paint getLinePaint ( FeatureStyle featureStyle ) { \nPaint paint = getFeatureStylePaint ( featureStyle , FeatureDrawType . STROKE ) ; \nif ( paint == null ) paint = linePaint ; \nreturn paint ; \n} \n} \n"}
{"6008": "public class FeatureTiles { \nprotected Paint getPolygonPaint ( FeatureStyle featureStyle ) { \nPaint paint = getFeatureStylePaint ( featureStyle , FeatureDrawType . STROKE ) ; \nif ( paint == null ) paint = polygonPaint ; \nreturn paint ; \n} \n} \n"}
{"6009": "public class FeatureTiles { \nprotected Paint getPolygonFillPaint ( FeatureStyle featureStyle ) { \nPaint paint = null ; \nboolean hasStyleColor = false ; \nif ( featureStyle != null ) { \nStyleRow style = featureStyle . getStyle ( ) ; \nif ( style != null ) if ( style . hasFillColor ( ) ) paint = getStylePaint ( style , FeatureDrawType . FILL ) ; \nelse hasStyleColor = style . hasColor ( ) ; \n} \nif ( paint == null && ! hasStyleColor && fillPolygon ) paint = polygonFillPaint ; \nreturn paint ; \n} \n} \n"}
{"6010": "public class FeatureTiles { \nprivate Paint getFeatureStylePaint ( FeatureStyle featureStyle , FeatureDrawType drawType ) { \nPaint paint = null ; \nif ( featureStyle != null ) { \nStyleRow style = featureStyle . getStyle ( ) ; \nif ( style != null && style . hasColor ( ) ) paint = getStylePaint ( style , drawType ) ; \n} \nreturn paint ; \n} \n} \n"}
{"6011": "public class FeatureTiles { \nprivate Paint getStylePaint ( StyleRow style , FeatureDrawType drawType ) { \nPaint paint = featurePaintCache . getPaint ( style , drawType ) ; \nif ( paint == null ) { \nColor color = null ; \nStyle paintStyle = null ; \nFloat strokeWidth = null ; \nswitch ( drawType ) { \ncase CIRCLE : color = style . getColorOrDefault ( ) ; \npaintStyle = Style . FILL ; \nbreak ; \ncase STROKE : color = style . getColorOrDefault ( ) ; \npaintStyle = Style . STROKE ; \nstrokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; \nbreak ; \ncase FILL : color = style . getFillColor ( ) ; \npaintStyle = Style . FILL ; \nstrokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; \nbreak ; \ndefault : throw new GeoPackageException ( \"Unsupported Draw Type: \" + drawType ) ; \n} \nPaint stylePaint = new Paint ( ) ; \nstylePaint . setAntiAlias ( true ) ; \nstylePaint . setStyle ( paintStyle ) ; \nstylePaint . setColor ( color . getColorWithAlpha ( ) ) ; \nif ( strokeWidth != null ) stylePaint . setStrokeWidth ( strokeWidth ) ; \nsynchronized ( featurePaintCache ) { \npaint = featurePaintCache . getPaint ( style , drawType ) ; \nif ( paint == null ) { \nfeaturePaintCache . setPaint ( style , drawType , stylePaint ) ; \npaint = stylePaint ; \n} \n} \n} \nreturn paint ; \n} \n} \n"}
{"6013": "public class FeaturePaintCache { \npublic Paint getPaint ( long styleId , FeatureDrawType type ) { \nPaint paint = null ; \nFeaturePaint featurePaint = getFeaturePaint ( styleId ) ; \nif ( featurePaint != null ) paint = featurePaint . getPaint ( type ) ; \nreturn paint ; \n} \n} \n"}
{"6015": "public class IconCache { \npublic static Bitmap createIcon ( IconRow icon , float density , IconCache iconCache ) { \nBitmap iconImage = null ; \nif ( icon != null ) { \nif ( iconCache != null ) iconImage = iconCache . get ( icon . getId ( ) ) ; \nif ( iconImage == null ) { \nBitmapFactory . Options options = icon . getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \ndouble styleWidth = dataWidth ; \ndouble styleHeight = dataHeight ; \ndouble widthDensity = DisplayMetrics . DENSITY_DEFAULT ; \ndouble heightDensity = DisplayMetrics . DENSITY_DEFAULT ; \nif ( icon . getWidth ( ) != null ) { \nstyleWidth = icon . getWidth ( ) ; \ndouble widthRatio = dataWidth / styleWidth ; \nwidthDensity *= widthRatio ; \nif ( icon . getHeight ( ) == null ) heightDensity = widthDensity ; \n} \nif ( icon . getHeight ( ) != null ) { \nstyleHeight = icon . getHeight ( ) ; \ndouble heightRatio = dataHeight / styleHeight ; \nheightDensity *= heightRatio ; \nif ( icon . getWidth ( ) == null ) widthDensity = heightDensity ; \n} \noptions = new BitmapFactory . Options ( ) ; \noptions . inDensity = ( int ) ( Math . min ( widthDensity , heightDensity ) + 0.5f ) ; \noptions . inTargetDensity = ( int ) ( DisplayMetrics . DENSITY_DEFAULT * density + 0.5f ) ; \niconImage = icon . getDataBitmap ( options ) ; \nif ( widthDensity != heightDensity ) { \nint width = ( int ) ( styleWidth * density + 0.5f ) ; \nint height = ( int ) ( styleHeight * density + 0.5f ) ; \nif ( width != iconImage . getWidth ( ) || height != iconImage . getHeight ( ) ) { \nBitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; \niconImage . recycle ( ) ; \niconImage = scaledBitmap ; \n} \n} \nif ( iconCache != null ) iconCache . put ( icon . getId ( ) , iconImage ) ; \n} \n} \nreturn iconImage ; \n} \n} \n"}
{"6022": "public class FeatureStyleExtension { \nprivate StyleMappingDao getMappingDao ( String tablePrefix , String featureTable ) { \nString tableName = tablePrefix + featureTable ; \nStyleMappingDao dao = null ; \nif ( geoPackage . isTable ( tableName ) ) dao = new StyleMappingDao ( relatedTables . getUserDao ( tableName ) ) ; \nreturn dao ; \n} \n} \n"}
{"6025": "public class FeatureStyleExtension { \npublic FeatureStyles getTableFeatureStyles ( String featureTable ) { \nFeatureStyles featureStyles = null ; \nLong id = contentsId . getId ( featureTable ) ; \nif ( id != null ) { \nStyles styles = getTableStyles ( featureTable , id ) ; \nIcons icons = getTableIcons ( featureTable , id ) ; \nif ( styles != null || icons != null ) featureStyles = new FeatureStyles ( styles , icons ) ; \n} \nreturn featureStyles ; \n} \n} \n"}
{"6026": "public class FeatureStyleExtension { \npublic Styles getTableStyles ( String featureTable ) { \nStyles styles = null ; \nLong id = contentsId . getId ( featureTable ) ; \nif ( id != null ) styles = getTableStyles ( featureTable , id ) ; \nreturn styles ; \n} \n} \n"}
{"6027": "public class FeatureStyleExtension { \npublic StyleRow getTableStyle ( String featureTable , GeometryType geometryType ) { \nStyleRow styleRow = null ; \nStyles tableStyles = getTableStyles ( featureTable ) ; \nif ( tableStyles != null ) styleRow = tableStyles . getStyle ( geometryType ) ; \nreturn styleRow ; \n} \n} \n"}
{"6028": "public class FeatureStyleExtension { \npublic Icons getTableIcons ( String featureTable ) { \nIcons icons = null ; \nLong id = contentsId . getId ( featureTable ) ; \nif ( id != null ) icons = getTableIcons ( featureTable , id ) ; \nreturn icons ; \n} \n} \n"}
{"6029": "public class FeatureStyleExtension { \npublic IconRow getTableIcon ( String featureTable , GeometryType geometryType ) { \nIconRow iconRow = null ; \nIcons tableIcons = getTableIcons ( featureTable ) ; \nif ( tableIcons != null ) iconRow = tableIcons . getIcon ( geometryType ) ; \nreturn iconRow ; \n} \n} \n"}
{"6031": "public class FeatureStyleExtension { \npublic FeatureStyles getFeatureStyles ( String featureTable , long featureId ) { \nStyles styles = getStyles ( featureTable , featureId ) ; \nIcons icons = getIcons ( featureTable , featureId ) ; \nFeatureStyles featureStyles = null ; \nif ( styles != null || icons != null ) featureStyles = new FeatureStyles ( styles , icons ) ; \nreturn featureStyles ; \n} \n} \n"}
{"6034": "public class FeatureStyleExtension { \nprivate Styles getStyles ( long featureId , StyleMappingDao mappingDao ) { \nStyles styles = null ; \nif ( mappingDao != null ) { \nStyleDao styleDao = getStyleDao ( ) ; \nif ( styleDao != null ) { \nList < StyleMappingRow > styleMappingRows = mappingDao . queryByBaseFeatureId ( featureId ) ; \nif ( ! styleMappingRows . isEmpty ( ) ) for ( StyleMappingRow styleMappingRow : styleMappingRows ) { \nStyleRow styleRow = styleDao . queryForRow ( styleMappingRow ) ; \nif ( styleRow != null ) { \nif ( styles == null ) styles = new Styles ( ) ; \nstyles . setStyle ( styleRow , styleMappingRow . getGeometryType ( ) ) ; \n} \n} \n} \n} \nreturn styles ; \n} \n} \n"}
{"6035": "public class FeatureStyleExtension { \nprivate Icons getIcons ( long featureId , StyleMappingDao mappingDao ) { \nIcons icons = null ; \nif ( mappingDao != null ) { \nIconDao iconDao = getIconDao ( ) ; \nif ( iconDao != null ) { \nList < StyleMappingRow > styleMappingRows = mappingDao . queryByBaseFeatureId ( featureId ) ; \nif ( ! styleMappingRows . isEmpty ( ) ) for ( StyleMappingRow styleMappingRow : styleMappingRows ) { \nIconRow iconRow = iconDao . queryForRow ( styleMappingRow ) ; \nif ( iconRow != null ) { \nif ( icons == null ) icons = new Icons ( ) ; \nicons . setIcon ( iconRow , styleMappingRow . getGeometryType ( ) ) ; \n} \n} \n} \n} \nreturn icons ; \n} \n} \n"}
{"6036": "public class FeatureStyleExtension { \npublic void setTableFeatureStyles ( String featureTable , FeatureStyles featureStyles ) { \nif ( featureStyles != null ) { \nsetTableStyles ( featureTable , featureStyles . getStyles ( ) ) ; \nsetTableIcons ( featureTable , featureStyles . getIcons ( ) ) ; \n} \nelse deleteTableFeatureStyles ( featureTable ) ; \n} \n} \n"}
{"6037": "public class FeatureStyleExtension { \npublic void setTableStyles ( String featureTable , Styles styles ) { \ndeleteTableStyles ( featureTable ) ; \nif ( styles != null ) { \nif ( styles . getDefault ( ) != null ) setTableStyleDefault ( featureTable , styles . getDefault ( ) ) ; \nfor ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { \nsetTableStyle ( featureTable , style . getKey ( ) , style . getValue ( ) ) ; \n} \n} \n} \n} \n"}
{"6038": "public class FeatureStyleExtension { \npublic void setTableIcons ( String featureTable , Icons icons ) { \ndeleteTableIcons ( featureTable ) ; \nif ( icons != null ) { \nif ( icons . getDefault ( ) != null ) setTableIconDefault ( featureTable , icons . getDefault ( ) ) ; \nfor ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { \nsetTableIcon ( featureTable , icon . getKey ( ) , icon . getValue ( ) ) ; \n} \n} \n} \n} \n"}
{"6042": "public class FeatureStyleExtension { \npublic void setStyles ( String featureTable , long featureId , Styles styles ) { \ndeleteStyles ( featureTable , featureId ) ; \nif ( styles != null ) { \nif ( styles . getDefault ( ) != null ) setStyleDefault ( featureTable , featureId , styles . getDefault ( ) ) ; \nfor ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { \nsetStyle ( featureTable , featureId , style . getKey ( ) , style . getValue ( ) ) ; \n} \n} \n} \n} \n"}
{"6047": "public class FeatureStyleExtension { \npublic void setIcons ( String featureTable , long featureId , Icons icons ) { \ndeleteIcons ( featureTable , featureId ) ; \nif ( icons != null ) { \nif ( icons . getDefault ( ) != null ) setIconDefault ( featureTable , featureId , icons . getDefault ( ) ) ; \nfor ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { \nsetIcon ( featureTable , featureId , icon . getKey ( ) , icon . getValue ( ) ) ; \n} \n} \n} \n} \n"}
{"6051": "public class FeatureStyleExtension { \nprivate long getOrInsertStyle ( StyleRow style ) { \nlong styleId ; \nif ( style . hasId ( ) ) styleId = style . getId ( ) ; \nelse { \nStyleDao styleDao = getStyleDao ( ) ; \nstyleId = styleDao . create ( style ) ; \n} \nreturn styleId ; \n} \n} \n"}
{"6052": "public class FeatureStyleExtension { \nprivate long getOrInsertIcon ( IconRow icon ) { \nlong iconId ; \nif ( icon . hasId ( ) ) iconId = icon . getId ( ) ; \nelse { \nIconDao iconDao = getIconDao ( ) ; \niconId = iconDao . create ( icon ) ; \n} \nreturn iconId ; \n} \n} \n"}
{"6056": "public class FeatureStyleExtension { \nprivate void deleteTableMappings ( StyleMappingDao mappingDao , String featureTable ) { \nif ( mappingDao != null ) { \nLong featureContentsId = contentsId . getId ( featureTable ) ; \nif ( featureContentsId != null ) mappingDao . deleteByBaseId ( featureContentsId ) ; \n} \n} \n} \n"}
{"6057": "public class FeatureStyleExtension { \nprivate void deleteTableMapping ( StyleMappingDao mappingDao , String featureTable , GeometryType geometryType ) { \nif ( mappingDao != null ) { \nLong featureContentsId = contentsId . getId ( featureTable ) ; \nif ( featureContentsId != null ) mappingDao . deleteByBaseId ( featureContentsId , geometryType ) ; \n} \n} \n} \n"}
{"6058": "public class FeatureStyleExtension { \nprivate void deleteMapping ( StyleMappingDao mappingDao , long featureId , GeometryType geometryType ) { \nif ( mappingDao != null ) mappingDao . deleteByBaseId ( featureId , geometryType ) ; \n} \n} \n"}
{"6059": "public class FeatureStyleExtension { \npublic List < Long > getAllTableStyleIds ( String featureTable ) { \nList < Long > styleIds = null ; \nStyleMappingDao mappingDao = getTableStyleMappingDao ( featureTable ) ; \nif ( mappingDao != null ) styleIds = mappingDao . uniqueRelatedIds ( ) ; \nreturn styleIds ; \n} \n} \n"}
{"6060": "public class FeatureStyleExtension { \npublic List < Long > getAllTableIconIds ( String featureTable ) { \nList < Long > iconIds = null ; \nStyleMappingDao mappingDao = getTableIconMappingDao ( featureTable ) ; \nif ( mappingDao != null ) iconIds = mappingDao . uniqueRelatedIds ( ) ; \nreturn iconIds ; \n} \n} \n"}
{"6061": "public class FeatureStyleExtension { \npublic List < Long > getAllStyleIds ( String featureTable ) { \nList < Long > styleIds = null ; \nStyleMappingDao mappingDao = getStyleMappingDao ( featureTable ) ; \nif ( mappingDao != null ) styleIds = mappingDao . uniqueRelatedIds ( ) ; \nreturn styleIds ; \n} \n} \n"}
{"6062": "public class FeatureStyleExtension { \npublic List < Long > getAllIconIds ( String featureTable ) { \nList < Long > iconIds = null ; \nStyleMappingDao mappingDao = getIconMappingDao ( featureTable ) ; \nif ( mappingDao != null ) iconIds = mappingDao . uniqueRelatedIds ( ) ; \nreturn iconIds ; \n} \n} \n"}
{"6063": "public class CoverageDataPngImage { \npublic byte [ ] getImageBytes ( ) { \nbyte [ ] bytes = null ; \nif ( imageBytes != null ) bytes = imageBytes ; \nelse if ( outputStream != null ) bytes = outputStream . toByteArray ( ) ; \nreturn bytes ; \n} \n} \n"}
{"6064": "public class CoverageDataPngImage { \npublic void flushStream ( ) { \nif ( outputStream != null ) { \nif ( imageBytes == null ) imageBytes = outputStream . toByteArray ( ) ; \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \nLog . w ( CoverageDataPngImage . class . getSimpleName ( ) , \"Failed to close output stream\" , e ) ; \n} \n} \n} \n} \n"}
{"6065": "public class CoverageDataPngImage { \npublic int getPixel ( int x , int y ) { \nint pixel = - 1 ; \nif ( pixels == null ) readPixels ( ) ; \nif ( pixels != null ) pixel = pixels [ y ] [ x ] ; \nelse throw new GeoPackageException ( \"Could not retrieve pixel value\" ) ; \nreturn pixel ; \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( points . size ( ) >= 2 ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( i == 0 ) path . moveTo ( x , y ) ; \nelse path . lineTo ( x , y ) ; \n} \n} \n} \n} \n"}
{"6071": "public class DefaultFeatureTiles { \nprivate void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { \nList < LineString > rings = polygon . getRings ( ) ; \nif ( ! rings . isEmpty ( ) ) { \nLineString polygonLineString = rings . get ( 0 ) ; \nList < Point > polygonPoints = polygonLineString . getPoints ( ) ; \nif ( polygonPoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; \nfor ( int i = 1 ; \ni < rings . size ( ) ; \ni ++ ) { \nLineString holeLineString = rings . get ( i ) ; \nList < Point > holePoints = holeLineString . getPoints ( ) ; \nif ( holePoints . size ( ) >= 2 ) addRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; \n} \n} \n} \n} \n} \n"}
{"6075": "public class FeatureTableStyles { \npublic Styles getCachedTableStyles ( ) { \nStyles styles = cachedTableFeatureStyles . getStyles ( ) ; \nif ( styles == null ) synchronized ( cachedTableFeatureStyles ) { \nstyles = cachedTableFeatureStyles . getStyles ( ) ; \nif ( styles == null ) { \nstyles = getTableStyles ( ) ; \nif ( styles == null ) styles = new Styles ( ) ; \ncachedTableFeatureStyles . setStyles ( styles ) ; \n} \n} \nif ( styles . isEmpty ( ) ) styles = null ; \nreturn styles ; \n} \n} \n"}
{"6076": "public class FeatureTableStyles { \npublic Icons getCachedTableIcons ( ) { \nIcons icons = cachedTableFeatureStyles . getIcons ( ) ; \nif ( icons == null ) synchronized ( cachedTableFeatureStyles ) { \nicons = cachedTableFeatureStyles . getIcons ( ) ; \nif ( icons == null ) { \nicons = getTableIcons ( ) ; \nif ( icons == null ) icons = new Icons ( ) ; \ncachedTableFeatureStyles . setIcons ( icons ) ; \n} \n} \nif ( icons . isEmpty ( ) ) icons = null ; \nreturn icons ; \n} \n} \n"}
{"6078": "public class IconRow { \npublic void setWidth ( Double width ) { \nif ( width != null && width < 0.0 ) throw new GeoPackageException ( \"Width must be greater than or equal to 0.0, invalid value: \" + width ) ; \nsetValue ( getWidthColumnIndex ( ) , width ) ; \n} \n} \n"}
{"6079": "public class IconRow { \npublic void setHeight ( Double height ) { \nif ( height != null && height < 0.0 ) throw new GeoPackageException ( \"Height must be greater than or equal to 0.0, invalid value: \" + height ) ; \nsetValue ( getHeightColumnIndex ( ) , height ) ; \n} \n} \n"}
{"6080": "public class IconRow { \npublic double [ ] getDerivedDimensions ( ) { \nDouble width = getWidth ( ) ; \nDouble height = getHeight ( ) ; \nif ( width == null || height == null ) { \nBitmapFactory . Options options = getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \nif ( width == null ) { \nwidth = ( double ) dataWidth ; \nif ( height != null ) width *= ( height / dataHeight ) ; \n} \nif ( height == null ) { \nheight = ( double ) dataHeight ; \nif ( width != null ) height *= ( width / dataWidth ) ; \n} \n} \nreturn new double [ ] { \nwidth , height } \n; \n} \n} \n"}
{"6082": "public class UserInvalidCursor { \nprivate void readBlobValue ( UserRow row , UserColumn column ) { \nByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; \ntry { \nbyte [ ] blobChunk = new byte [ ] { \n0 } \n; \nfor ( int i = 1 ; \nblobChunk . length > 0 ; \ni += CHUNK_SIZE ) { \nif ( i > 1 ) byteStream . write ( blobChunk ) ; \nblobChunk = new byte [ ] { \n} \n; \nString query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; \nCursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; \ntry { \nif ( blobCursor . moveToNext ( ) ) blobChunk = blobCursor . getBlob ( 0 ) ; \n} \nfinally { \nblobCursor . close ( ) ; \n} \n} \nbyte [ ] blob = byteStream . toByteArray ( ) ; \nrow . setValue ( column . getIndex ( ) , blob ) ; \n} \ncatch ( IOException e ) { \nLog . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( byteStream ) ; \n} \n} \n} \n"}
{"6084": "public class StyleRow { \npublic Color getColorOrDefault ( ) { \nColor color = getColor ( ) ; \nif ( color == null ) color = new Color ( ) ; \nreturn color ; \n} \n} \n"}
{"6085": "public class StyleRow { \nprivate String validateColor ( String color ) { \nString validated = color ; \nif ( color != null ) { \nif ( ! color . startsWith ( \"#\" ) ) validated = \"#\" + color ; \nif ( ! colorPattern . matcher ( validated ) . matches ( ) ) throw new GeoPackageException ( \"Color must be in hex format #RRGGBB or #RGB, invalid value: \" + color ) ; \nvalidated = validated . toUpperCase ( ) ; \n} \nreturn validated ; \n} \n} \n"}
{"6086": "public class StyleRow { \nprivate Color createColor ( String hexColor , Double opacity ) { \nColor color = null ; \nif ( hexColor != null || opacity != null ) { \ncolor = new Color ( ) ; \nif ( hexColor != null ) color . setColor ( hexColor ) ; \nif ( opacity != null ) color . setOpacity ( opacity . floatValue ( ) ) ; \n} \nreturn color ; \n} \n} \n"}
{"6090": "public class FeatureIndexManager { \npublic boolean index ( FeatureRow row , List < FeatureIndexType > types ) { \nboolean indexed = false ; \nfor ( FeatureIndexType type : types ) { \nif ( index ( type , row ) ) indexed = true ; \n} \nreturn indexed ; \n} \n} \n"}
{"6091": "public class FeatureIndexManager { \npublic boolean deleteIndex ( Collection < FeatureIndexType > types ) { \nboolean deleted = false ; \nfor ( FeatureIndexType type : types ) { \nif ( deleteIndex ( type ) ) deleted = true ; \n} \nreturn deleted ; \n} \n} \n"}
{"6092": "public class FeatureIndexManager { \npublic boolean deleteIndex ( FeatureRow row , List < FeatureIndexType > types ) { \nboolean deleted = false ; \nfor ( FeatureIndexType type : types ) { \nif ( deleteIndex ( type , row ) ) deleted = true ; \n} \nreturn deleted ; \n} \n} \n"}
{"6093": "public class FeatureIndexManager { \npublic boolean deleteIndex ( long geomId , List < FeatureIndexType > types ) { \nboolean deleted = false ; \nfor ( FeatureIndexType type : types ) { \nif ( deleteIndex ( type , geomId ) ) deleted = true ; \n} \nreturn deleted ; \n} \n} \n"}
{"6094": "public class FeatureIndexManager { \npublic boolean deleteIndex ( FeatureIndexType type , long geomId ) { \nif ( type == null ) throw new GeoPackageException ( \"FeatureIndexType is required to delete index\" ) ; \nboolean deleted = false ; \nswitch ( type ) { \ncase GEOPACKAGE : deleted = featureTableIndex . deleteIndex ( geomId ) > 0 ; \nbreak ; \ncase METADATA : deleted = featureIndexer . deleteIndex ( geomId ) ; \nbreak ; \ncase RTREE : deleted = true ; \nbreak ; \ndefault : throw new GeoPackageException ( \"Unsupported FeatureIndexType: \" + type ) ; \n} \nreturn deleted ; \n} \n} \n"}
{"6095": "public class FeatureIndexManager { \npublic boolean isIndexed ( ) { \nboolean indexed = false ; \nfor ( FeatureIndexType type : indexLocationQueryOrder ) { \nindexed = isIndexed ( type ) ; \nif ( indexed ) break ; \n} \nreturn indexed ; \n} \n} \n"}
{"6096": "public class FeatureIndexManager { \npublic List < FeatureIndexType > getIndexedTypes ( ) { \nList < FeatureIndexType > indexed = new ArrayList < > ( ) ; \nfor ( FeatureIndexType type : indexLocationQueryOrder ) { \nif ( isIndexed ( type ) ) indexed . add ( type ) ; \n} \nreturn indexed ; \n} \n} \n"}
{"6102": "public class ContextIOUtils { \npublic static File getInternalFile ( Context context , String filePath ) { \nFile internalFile = null ; \nif ( filePath != null ) internalFile = new File ( context . getFilesDir ( ) , filePath ) ; \nelse internalFile = context . getFilesDir ( ) ; \nreturn internalFile ; \n} \n} \n"}
{"6104": "public class StyleMappingRow { \npublic GeometryType getGeometryType ( ) { \nGeometryType geometryType = null ; \nString geometryTypeName = getGeometryTypeName ( ) ; \nif ( geometryTypeName != null ) geometryType = GeometryType . fromName ( geometryTypeName ) ; \nreturn geometryType ; \n} \n} \n"}
{"6105": "public class StyleMappingRow { \npublic void setGeometryType ( GeometryType geometryType ) { \nString geometryTypeName = null ; \nif ( geometryType != null ) geometryTypeName = geometryType . getName ( ) ; \nsetValue ( getGeometryTypeNameColumnIndex ( ) , geometryTypeName ) ; \n} \n} \n"}
{"6111": "public class FeatureCursor { \npublic GeoPackageGeometryData getGeometry ( ) { \nGeoPackageGeometryData geometry = null ; \nint columnIndex = getTable ( ) . getGeometryColumnIndex ( ) ; \nint type = getType ( columnIndex ) ; \nif ( type != FIELD_TYPE_NULL ) { \nbyte [ ] geometryBytes = getBlob ( columnIndex ) ; \nif ( geometryBytes != null ) geometry = new GeoPackageGeometryData ( geometryBytes ) ; \n} \nreturn geometry ; \n} \n} \n"}
{"6112": "public class FeatureIndexer { \nprivate boolean index ( long geoPackageId , FeatureRow row , boolean possibleUpdate ) { \nboolean indexed = false ; \nGeoPackageGeometryData geomData = row . getGeometry ( ) ; \nif ( geomData != null ) { \nGeometryEnvelope envelope = geomData . getEnvelope ( ) ; \nif ( envelope == null ) { \nGeometry geometry = geomData . getGeometry ( ) ; \nif ( geometry != null ) envelope = GeometryEnvelopeBuilder . buildEnvelope ( geometry ) ; \n} \nif ( envelope != null ) { \nGeometryMetadata metadata = geometryMetadataDataSource . populate ( geoPackageId , featureDao . getTableName ( ) , row . getId ( ) , envelope ) ; \nif ( possibleUpdate ) geometryMetadataDataSource . createOrUpdate ( metadata ) ; \nelse geometryMetadataDataSource . create ( metadata ) ; \nindexed = true ; \n} \n} \nreturn indexed ; \n} \n} \n"}
{"6113": "public class FeatureIndexer { \nprivate void updateLastIndexed ( GeoPackageMetadataDb db , long geoPackageId ) { \nlong indexedTime = ( new Date ( ) ) . getTime ( ) ; \nTableMetadataDataSource ds = new TableMetadataDataSource ( db ) ; \nif ( ! ds . updateLastIndexed ( geoPackageId , featureDao . getTableName ( ) , indexedTime ) ) throw new GeoPackageException ( \"Failed to update last indexed time. Table: GeoPackage Id: \" + geoPackageId + \", Table: \" + featureDao . getTableName ( ) + \", Last Indexed: \" + indexedTime ) ; \n} \n} \n"}
{"6127": "public class FeatureIndexer { \npublic FeatureRow getFeatureRow ( GeometryMetadata geometryMetadata ) { \nlong geomId = geometryMetadata . getId ( ) ; \nFeatureRow row = featureRowSync . getRowOrLock ( geomId ) ; \nif ( row == null ) try { \nrow = featureDao . queryForIdRow ( geomId ) ; \n} \nfinally { \nfeatureRowSync . setRow ( geomId , row ) ; \n} \nreturn row ; \n} \n} \n"}
{"6130": "public class FeatureTileGenerator { \nprivate static BoundingBox getBoundingBox ( GeoPackage geoPackage , FeatureTiles featureTiles , BoundingBox boundingBox , Projection projection ) { \nString tableName = featureTiles . getFeatureDao ( ) . getTableName ( ) ; \nboolean manualQuery = boundingBox == null ; \nBoundingBox featureBoundingBox = geoPackage . getBoundingBox ( projection , tableName , manualQuery ) ; \nif ( featureBoundingBox != null ) if ( boundingBox == null ) boundingBox = featureBoundingBox ; \nelse boundingBox = boundingBox . overlap ( featureBoundingBox ) ; \nif ( boundingBox != null ) boundingBox = featureTiles . expandBoundingBox ( boundingBox , projection ) ; \nreturn boundingBox ; \n} \n} \n"}
{"6138": "public class GeoPackageMetadataDataSource { \npublic void create ( GeoPackageMetadata metadata ) { \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeoPackageMetadata . COLUMN_NAME , metadata . getName ( ) ) ; \nvalues . put ( GeoPackageMetadata . COLUMN_EXTERNAL_PATH , metadata . getExternalPath ( ) ) ; \nlong insertId = db . insert ( GeoPackageMetadata . TABLE_NAME , null , values ) ; \nif ( insertId == - 1 ) throw new GeoPackageException ( \"Failed to insert GeoPackage metadata. Name: \" + metadata . getName ( ) + \", External Path: \" + metadata . getExternalPath ( ) ) ; \nmetadata . setId ( insertId ) ; \n} \n} \n"}
{"6140": "public class GeoPackageMetadataDataSource { \npublic boolean rename ( GeoPackageMetadata metadata , String newName ) { \nboolean renamed = rename ( metadata . getName ( ) , newName ) ; \nif ( renamed ) metadata . setName ( newName ) ; \nreturn renamed ; \n} \n} \n"}
{"6143": "public class GeoPackageMetadataDataSource { \npublic GeoPackageMetadata get ( String database ) { \nGeoPackageMetadata metadata = null ; \nString selection = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; \nString [ ] selectionArgs = new String [ ] { \ndatabase } \n; \nCursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; \ntry { \nif ( cursor . moveToNext ( ) ) metadata = createGeoPackageMetadata ( cursor ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn metadata ; \n} \n} \n"}
{"6144": "public class GeoPackageMetadataDataSource { \npublic GeoPackageMetadata get ( long id ) { \nGeoPackageMetadata metadata = null ; \nString selection = GeoPackageMetadata . COLUMN_ID + \" = ?\" ; \nString [ ] selectionArgs = new String [ ] { \nString . valueOf ( id ) } \n; \nCursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; \ntry { \nif ( cursor . moveToNext ( ) ) metadata = createGeoPackageMetadata ( cursor ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn metadata ; \n} \n} \n"}
{"6147": "public class GeoPackageMetadataDataSource { \npublic GeoPackageMetadata getExternalAtPath ( String path ) { \nGeoPackageMetadata metadata = null ; \nString selection = GeoPackageMetadata . COLUMN_EXTERNAL_PATH + \" = ?\" ; \nString [ ] selectionArgs = new String [ ] { \npath } \n; \nCursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; \ntry { \nif ( cursor . moveToNext ( ) ) metadata = createGeoPackageMetadata ( cursor ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn metadata ; \n} \n} \n"}
{"6150": "public class GeoPackageMetadataDataSource { \nprivate List < String > getMetadataWhereNameLike ( String like , String sortColumn , boolean notLike ) { \nList < String > names = new ArrayList < > ( ) ; \nStringBuilder where = new StringBuilder ( GeoPackageMetadata . COLUMN_NAME ) ; \nif ( notLike ) where . append ( \" not\" ) ; \nwhere . append ( \" like ?\" ) ; \nString [ ] whereArgs = new String [ ] { \nlike } \n; \nCursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , new String [ ] { \nGeoPackageMetadata . COLUMN_NAME } \n, where . toString ( ) , whereArgs , null , null , sortColumn ) ; \ntry { \nwhile ( cursor . moveToNext ( ) ) names . add ( cursor . getString ( 0 ) ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn names ; \n} \n} \n"}
{"6152": "public class ParallaxFactory { \npublic View onViewCreated ( View view , Context context , AttributeSet attrs ) { \nif ( view == null ) return null ; \nview = onViewCreatedInternal ( view , context , attrs ) ; \nfor ( OnViewCreatedListener listener : otherListeners ) { \nif ( listener != null ) view = listener . onViewCreated ( view , context , attrs ) ; \n} \nreturn view ; \n} \n} \n"}
{"6153": "public class ParallaxContainer { \nprivate void addParallaxView ( View view , int pageIndex ) { \nif ( view instanceof ViewGroup ) { \nViewGroup viewGroup = ( ViewGroup ) view ; \nfor ( int i = 0 , childCount = viewGroup . getChildCount ( ) ; \ni < childCount ; \ni ++ ) addParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; \n} \nParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; \nif ( tag != null ) { \ntag . index = pageIndex ; \nparallaxViews . add ( view ) ; \n} \n} \n} \n"}
{"6154": "public class ParallaxLayoutInflater { \n@ Override protected View onCreateView ( String name , AttributeSet attrs ) throws ClassNotFoundException { \nView view = null ; \nfor ( String prefix : sClassPrefixList ) { \ntry { \nview = createView ( name , prefix , attrs ) ; \n} \ncatch ( ClassNotFoundException ignored ) { \n} \n} \nif ( view == null ) view = super . onCreateView ( name , attrs ) ; \nreturn mParallaxFactory . onViewCreated ( view , view . getContext ( ) , attrs ) ; \n} \n} \n"}
{"6155": "public class ParallaxLayoutInflater { \nprivate View createCustomViewInternal ( View parent , View view , String name , Context context , AttributeSet attrs ) { \nif ( view == null && name . indexOf ( '.' ) > - 1 ) { \nif ( mConstructorArgs == null ) mConstructorArgs = ReflectionUtils . getField ( LayoutInflater . class , \"mConstructorArgs\" ) ; \nfinal Object [ ] mConstructorArgsArr = ( Object [ ] ) ReflectionUtils . getValue ( mConstructorArgs , this ) ; \nfinal Object lastContext = mConstructorArgsArr [ 0 ] ; \nmConstructorArgsArr [ 0 ] = parent != null ? parent . getContext ( ) : context ; \nReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; \ntry { \nview = createView ( name , null , attrs ) ; \n} \ncatch ( ClassNotFoundException ignored ) { \n} \nfinally { \nmConstructorArgsArr [ 0 ] = lastContext ; \nReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; \n} \n} \nreturn view ; \n} \n} \n"}
{"6156": "public class SMTPAppender { \nprotected void subAppend ( CyclicBuffer < ILoggingEvent > cb , ILoggingEvent event ) { \nif ( includeCallerData ) event . getCallerData ( ) ; \nevent . prepareForDeferredProcessing ( ) ; \ncb . add ( event ) ; \n} \n} \n"}
{"6157": "public class ContextInitializer { \nprivate URL findConfigFileFromSystemProperties ( boolean updateStatus ) { \nString logbackConfigFile = OptionHelper . getSystemProperty ( CONFIG_FILE_PROPERTY ) ; \nif ( logbackConfigFile != null ) { \nURL result = null ; \ntry { \nFile file = new File ( logbackConfigFile ) ; \nif ( file . exists ( ) && file . isFile ( ) ) { \nif ( updateStatus ) statusOnResourceSearch ( logbackConfigFile , this . classLoader , logbackConfigFile ) ; \nresult = file . toURI ( ) . toURL ( ) ; \n} \nelse result = new URL ( logbackConfigFile ) ; \nreturn result ; \n} \ncatch ( MalformedURLException e ) { \nresult = Loader . getResource ( logbackConfigFile , this . classLoader ) ; \nif ( result != null ) return result ; \n} \nfinally { \nif ( updateStatus ) statusOnResourceSearch ( logbackConfigFile , this . classLoader , result != null ? result . toString ( ) : null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6158": "public class ContextInitializer { \nprivate URL getResource ( String filename , ClassLoader myClassLoader , boolean updateStatus ) { \nURL url = myClassLoader . getResource ( filename ) ; \nif ( updateStatus ) { \nString resourcePath = null ; \nif ( url != null ) resourcePath = filename ; \nstatusOnResourceSearch ( filename , myClassLoader , resourcePath ) ; \n} \nreturn url ; \n} \n} \n"}
{"6160": "public class ContextInitializer { \nprivate void statusOnResourceSearch ( String resourceName , ClassLoader classLoader , String path ) { \nStatusManager sm = loggerContext . getStatusManager ( ) ; \nif ( path == null ) sm . add ( new InfoStatus ( \"Could NOT find resource [\" + resourceName + \"]\" , loggerContext ) ) ; \nelse sm . add ( new InfoStatus ( \"Found resource [\" + resourceName + \"] at [\" + path + \"]\" , loggerContext ) ) ; \n} \n} \n"}
{"6161": "public class ServerSocketListener { \nprivate String socketAddressToString ( SocketAddress address ) { \nString addr = address . toString ( ) ; \nint i = addr . indexOf ( \"/\" ) ; \nif ( i >= 0 ) addr = addr . substring ( i + 1 ) ; \nreturn addr ; \n} \n} \n"}
{"6164": "public class RollingFileAppender { \n@ Override protected void subAppend ( E event ) { \nsynchronized ( triggeringPolicy ) { \nif ( triggeringPolicy . isTriggeringEvent ( currentlyActiveFile , event ) ) rollover ( ) ; \n} \nsuper . subAppend ( event ) ; \n} \n} \n"}
{"6165": "public class InterpretationContext { \npublic void addSubstitutionProperty ( String key , String value ) { \nif ( key == null || value == null ) return ; \nvalue = value . trim ( ) ; \npropertiesMap . put ( key , value ) ; \n} \n} \n"}
{"6166": "public class InterpretationContext { \npublic String getProperty ( String key ) { \nString v = propertiesMap . get ( key ) ; \nif ( v != null ) return v ; \nelse return context . getProperty ( key ) ; \n} \n} \n"}
{"6168": "public class Parser { \nNode E ( ) throws ScanException { \nNode t = T ( ) ; \nif ( t == null ) return null ; \nNode eOpt = Eopt ( ) ; \nif ( eOpt != null ) t . setNext ( eOpt ) ; \nreturn t ; \n} \n} \n"}
{"6169": "public class Parser { \nNode T ( ) throws ScanException { \nToken t = getCurentToken ( ) ; \nexpectNotNull ( t , \"a LITERAL or '%'\" ) ; \nswitch ( t . getType ( ) ) { \ncase Token . LITERAL : advanceTokenPointer ( ) ; \nreturn new Node ( Node . LITERAL , t . getValue ( ) ) ; \ncase Token . PERCENT : advanceTokenPointer ( ) ; \nFormatInfo fi ; \nToken u = getCurentToken ( ) ; \nFormattingNode c ; \nexpectNotNull ( u , \"a FORMAT_MODIFIER, SIMPLE_KEYWORD or COMPOUND_KEYWORD\" ) ; \nif ( u . getType ( ) == Token . FORMAT_MODIFIER ) { \nfi = FormatInfo . valueOf ( ( String ) u . getValue ( ) ) ; \nadvanceTokenPointer ( ) ; \nc = C ( ) ; \nc . setFormatInfo ( fi ) ; \n} \nelse c = C ( ) ; \nreturn c ; \ndefault : return null ; \n} \n} \n} \n"}
{"6171": "public class FileNamePattern { \npublic String toRegexForFixedDate ( Date date ) { \nStringBuilder buf = new StringBuilder ( ) ; \nConverter < Object > p = headTokenConverter ; \nwhile ( p != null ) { \nif ( p instanceof LiteralConverter ) buf . append ( p . convert ( null ) ) ; \nelse if ( p instanceof IntegerTokenConverter ) buf . append ( FileFinder . regexEscapePath ( \"(\\\\d+)\" ) ) ; \nelse if ( p instanceof DateTokenConverter ) { \nDateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; \nif ( dtc . isPrimary ( ) ) buf . append ( p . convert ( date ) ) ; \nelse buf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; \n} \np = p . getNext ( ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6173": "public class AbstractEventEvaluatorAction { \n@ SuppressWarnings ( \"unchecked\" ) public void end ( InterpretationContext ec , String e ) { \nif ( inError ) return ; \nif ( evaluator instanceof LifeCycle ) { \n( ( LifeCycle ) evaluator ) . start ( ) ; \naddInfo ( \"Starting evaluator named [\" + evaluator . getName ( ) + \"]\" ) ; \n} \nObject o = ec . peekObject ( ) ; \nif ( o != evaluator ) addWarn ( \"The object on the top the of the stack is not the evaluator pushed earlier.\" ) ; \nelse { \nec . popObject ( ) ; \ntry { \nMap < String , EventEvaluator < ? > > evaluatorMap = ( Map < String , EventEvaluator < ? > > ) context . getObject ( CoreConstants . EVALUATOR_MAP ) ; \nif ( evaluatorMap == null ) addError ( \"Could not find EvaluatorMap\" ) ; \nelse evaluatorMap . put ( evaluator . getName ( ) , evaluator ) ; \n} \ncatch ( Exception ex ) { \naddError ( \"Could not set evaluator named [\" + evaluator + \"].\" , ex ) ; \n} \n} \n} \n} \n"}
{"6174": "public class ContextSelectorStaticBinder { \npublic void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { \nif ( this . key == null ) this . key = key ; \nelse if ( this . key != key ) throw new IllegalAccessException ( \"Only certain classes can access this method.\" ) ; \nString contextSelectorStr = OptionHelper . getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; \nif ( contextSelectorStr == null ) contextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; \nelse if ( contextSelectorStr . equals ( \"JNDI\" ) ) throw new RuntimeException ( \"JNDI not supported\" ) ; \nelse contextSelector = dynamicalContextSelector ( defaultLoggerContext , contextSelectorStr ) ; \n} \n} \n"}
{"6176": "public class AndroidContextUtil { \npublic void setupProperties ( LoggerContext context ) { \nProperties props = new Properties ( ) ; \nprops . setProperty ( CoreConstants . DATA_DIR_KEY , getFilesDirectoryPath ( ) ) ; \nfinal String extDir = getMountedExternalStorageDirectoryPath ( ) ; \nif ( extDir != null ) props . setProperty ( CoreConstants . EXT_DIR_KEY , extDir ) ; \nprops . setProperty ( CoreConstants . PACKAGE_NAME_KEY , getPackageName ( ) ) ; \nprops . setProperty ( CoreConstants . VERSION_CODE_KEY , getVersionCode ( ) ) ; \nprops . setProperty ( CoreConstants . VERSION_NAME_KEY , getVersionName ( ) ) ; \ncontext . putProperties ( props ) ; \n} \n} \n"}
{"6177": "public class AndroidContextUtil { \npublic String getMountedExternalStorageDirectoryPath ( ) { \nString path = null ; \nString state = Environment . getExternalStorageState ( ) ; \nif ( state . equals ( Environment . MEDIA_MOUNTED ) || state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) path = absPath ( Environment . getExternalStorageDirectory ( ) ) ; \nreturn path ; \n} \n} \n"}
{"6181": "public class MDCBasedDiscriminator { \npublic String getDiscriminatingValue ( ILoggingEvent event ) { \nMap < String , String > mdcMap = event . getMDCPropertyMap ( ) ; \nif ( mdcMap == null ) return defaultValue ; \nString mdcValue = mdcMap . get ( key ) ; \nif ( mdcValue == null ) return defaultValue ; \nelse return mdcValue ; \n} \n} \n"}
{"6182": "public class ReconfigureOnChangeFilter { \nprivate void updateMaskIfNecessary ( long now ) { \nfinal long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; \nlastMaskCheck = now ; \nif ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) mask = ( mask << 1 ) | 1 ; \nelse if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) mask = mask >>> 2 ; \n} \n} \n"}
{"6183": "public class FilterAttachableImpl { \npublic FilterReply getFilterChainDecision ( E event ) { \nfinal Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; \nfinal int len = filterArrray . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nfinal FilterReply r = filterArrray [ i ] . decide ( event ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) return r ; \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6187": "public class SSLContextFactoryBean { \nprivate String locationFromSystemProperty ( String name ) { \nString location = System . getProperty ( name ) ; \nif ( location != null && ! location . startsWith ( \"file:\" ) ) location = \"file:\" + location ; \nreturn location ; \n} \n} \n"}
{"6188": "public class LocationUtil { \npublic static URL urlForResource ( String location ) throws MalformedURLException , FileNotFoundException { \nif ( location == null ) throw new NullPointerException ( \"location is required\" ) ; \nURL url = null ; \nif ( ! location . matches ( SCHEME_PATTERN ) ) url = Loader . getResourceBySelfClassLoader ( location ) ; \nelse if ( location . startsWith ( CLASSPATH_SCHEME ) ) { \nString path = location . substring ( CLASSPATH_SCHEME . length ( ) ) ; \nif ( path . startsWith ( \"/\" ) ) path = path . substring ( 1 ) ; \nif ( path . length ( ) == 0 ) throw new MalformedURLException ( \"path is required\" ) ; \nurl = Loader . getResourceBySelfClassLoader ( path ) ; \n} \nelse url = new URL ( location ) ; \nif ( url == null ) throw new FileNotFoundException ( location ) ; \nreturn url ; \n} \n} \n"}
{"6189": "public class EnsureExceptionHandling { \npublic boolean chainHandlesThrowable ( Converter < ILoggingEvent > head ) { \nConverter < ILoggingEvent > c = head ; \nwhile ( c != null ) { \nif ( c instanceof ThrowableHandlingConverter ) return true ; \nc = c . getNext ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"6191": "public class StatusPrinter { \npublic static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { \nif ( context == null ) throw new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) ps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) print ( sm , threshold ) ; \n} \n} \n} \n"}
{"6192": "public class StatusPrinter { \npublic static void printIfErrorsOccured ( Context context ) { \nif ( context == null ) throw new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) ps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) print ( sm ) ; \n} \n} \n} \n"}
{"6193": "public class StatusPrinter { \npublic static void print ( Context context , long threshold ) { \nif ( context == null ) throw new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) ps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \nelse print ( sm , threshold ) ; \n} \n} \n"}
{"6194": "public class SyslogAppender { \nprivate void handleThrowableFirstLine ( OutputStream sw , IThrowableProxy tp , String stackTracePrefix , boolean isRootException ) throws IOException { \nStringBuilder sb = new StringBuilder ( ) . append ( stackTracePrefix ) ; \nif ( ! isRootException ) sb . append ( CoreConstants . CAUSED_BY ) ; \nsb . append ( tp . getClassName ( ) ) . append ( \": \" ) . append ( tp . getMessage ( ) ) ; \nsw . write ( sb . toString ( ) . getBytes ( ) ) ; \nsw . flush ( ) ; \n} \n} \n"}
{"6195": "public class AbstractComponentTracker { \nprivate Entry < C > getFromEitherMap ( String key ) { \nEntry < C > entry = liveMap . get ( key ) ; \nif ( entry != null ) return entry ; \nelse return lingerersMap . get ( key ) ; \n} \n} \n"}
{"6197": "public class FormatInfo { \npublic static FormatInfo valueOf ( String str ) throws IllegalArgumentException { \nif ( str == null ) throw new NullPointerException ( \"Argument cannot be null\" ) ; \nFormatInfo fi = new FormatInfo ( ) ; \nint indexOfDot = str . indexOf ( '.' ) ; \nString minPart = null ; \nString maxPart = null ; \nif ( indexOfDot != - 1 ) { \nminPart = str . substring ( 0 , indexOfDot ) ; \nif ( indexOfDot + 1 == str . length ( ) ) throw new IllegalArgumentException ( \"Formatting string [\" + str + \"] should not end with '.'\" ) ; \nelse maxPart = str . substring ( indexOfDot + 1 ) ; \n} \nelse minPart = str ; \nif ( minPart != null && minPart . length ( ) > 0 ) { \nint min = Integer . parseInt ( minPart ) ; \nif ( min >= 0 ) fi . min = min ; \nelse { \nfi . min = - min ; \nfi . leftPad = false ; \n} \n} \nif ( maxPart != null && maxPart . length ( ) > 0 ) { \nint max = Integer . parseInt ( maxPart ) ; \nif ( max >= 0 ) fi . max = max ; \nelse { \nfi . max = - max ; \nfi . leftTruncate = false ; \n} \n} \nreturn fi ; \n} \n} \n"}
{"6198": "public class RenameUtil { \npublic void rename ( String src , String target ) throws RolloverFailure { \nif ( src . equals ( target ) ) { \naddWarn ( \"Source and target files are the same [\" + src + \"]. Skipping.\" ) ; \nreturn ; \n} \nFile srcFile = new File ( src ) ; \nif ( srcFile . exists ( ) ) { \nFile targetFile = new File ( target ) ; \ncreateMissingTargetDirsIfNecessary ( targetFile ) ; \naddInfo ( \"Renaming file [\" + srcFile + \"] to [\" + targetFile + \"]\" ) ; \nboolean result = srcFile . renameTo ( targetFile ) ; \nif ( ! result ) { \naddWarn ( \"Failed to rename file [\" + srcFile + \"] as [\" + targetFile + \"].\" ) ; \nBoolean areOnDifferentVolumes = areOnDifferentVolumes ( srcFile , targetFile ) ; \nif ( Boolean . TRUE . equals ( areOnDifferentVolumes ) ) { \naddWarn ( \"Detected different file systems for source [\" + src + \"] and target [\" + target + \"]. Attempting rename by copying.\" ) ; \nrenameByCopying ( src , target ) ; \nreturn ; \n} \nelse { \naddWarn ( \"Please consider leaving the [file] option of \" + RollingFileAppender . class . getSimpleName ( ) + \" empty.\" ) ; \naddWarn ( \"See also \" + RENAMING_ERROR_URL ) ; \n} \n} \n} \nelse throw new RolloverFailure ( \"File [\" + src + \"] does not exist.\" ) ; \n} \n} \n"}
{"6199": "public class RenameUtil { \nBoolean areOnDifferentVolumes ( File srcFile , File targetFile ) throws RolloverFailure { \nif ( ! EnvUtil . isJDK7OrHigher ( ) ) return false ; \nFile parentOfTarget = targetFile . getAbsoluteFile ( ) . getParentFile ( ) ; \nif ( parentOfTarget == null ) { \naddWarn ( \"Parent of target file [\" + targetFile + \"] is null\" ) ; \nreturn null ; \n} \nif ( ! parentOfTarget . exists ( ) ) { \naddWarn ( \"Parent of target file [\" + targetFile + \"] does not exist\" ) ; \nreturn null ; \n} \ntry { \nboolean onSameFileStore = FileStoreUtil . areOnSameFileStore ( srcFile , parentOfTarget ) ; \nreturn ! onSameFileStore ; \n} \ncatch ( RolloverFailure rf ) { \naddWarn ( \"Error while checking file store equality\" , rf ) ; \nreturn null ; \n} \n} \n} \n"}
{"6202": "public class LoggingEvent { \npublic void setMDCPropertyMap ( Map < String , String > map ) { \nif ( mdcPropertyMap != null ) throw new IllegalStateException ( \"The MDCPropertyMap has been already set for this event.\" ) ; \nthis . mdcPropertyMap = map ; \n} \n} \n"}
{"6203": "public class MDCConverter { \nprivate String outputMDCForAllKeys ( Map < String , String > mdcPropertyMap ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( Map . Entry < String , String > entry : mdcPropertyMap . entrySet ( ) ) { \nif ( first ) first = false ; \nelse buf . append ( \", \" ) ; \nbuf . append ( entry . getKey ( ) ) . append ( '=' ) . append ( entry . getValue ( ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) return null ; \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nint found = LINE_NA ; \nfor ( int i = 0 ; \ni < steArray . length ; \ni ++ ) if ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) found = i + 1 ; \nelse if ( found != LINE_NA ) break ; \nif ( found == LINE_NA ) return EMPTY_CALLER_DATA_ARRAY ; \nint availableDepth = steArray . length - found ; \nint desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \nfor ( int i = 0 ; \ni < desiredDepth ; \ni ++ ) callerDataArray [ i ] = steArray [ found + i ] ; \nreturn callerDataArray ; \n} \n} \n"}
{"6206": "public class BasicStatusManager { \npublic void add ( Status newStatus ) { \nfireStatusAddEvent ( newStatus ) ; \ncount ++ ; \nif ( newStatus . getLevel ( ) > level ) level = newStatus . getLevel ( ) ; \nsynchronized ( statusListLock ) { \nif ( statusList . size ( ) < MAX_HEADER_COUNT ) statusList . add ( newStatus ) ; \nelse tailBuffer . add ( newStatus ) ; \n} \n} \n} \n"}
{"6207": "public class BasicStatusManager { \npublic boolean add ( StatusListener listener ) { \nsynchronized ( statusListenerListLock ) { \nif ( listener instanceof OnConsoleStatusListener ) { \nboolean alreadyPresent = checkForPresence ( statusListenerList , listener . getClass ( ) ) ; \nif ( alreadyPresent ) return false ; \n} \nstatusListenerList . add ( listener ) ; \n} \nreturn true ; \n} \n} \n"}
{"6209": "public class Interpreter { \nList < Action > getApplicableActionList ( ElementPath elementPath , Attributes attributes ) { \nList < Action > applicableActionList = ruleStore . matchActions ( elementPath ) ; \nif ( applicableActionList == null ) applicableActionList = lookupImplicitAction ( elementPath , attributes , interpretationContext ) ; \nreturn applicableActionList ; \n} \n} \n"}
{"6211": "public class SystemPropertiesProxy { \npublic String get ( String key , String def ) throws IllegalArgumentException { \nif ( SystemProperties == null || getString == null ) return null ; \nString ret = null ; \ntry { \nret = ( String ) getString . invoke ( SystemProperties , new Object [ ] { \nkey , def } \n) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \n} \nif ( ret == null || ret . length ( ) == 0 ) ret = def ; \nreturn ret ; \n} \n} \n"}
{"6213": "public class Introspector { \nstatic public String decapitalize ( String name ) { \nif ( name == null || name . length ( ) == 0 ) return name ; \nelse { \nString nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; \nif ( name . length ( ) > 1 ) nm += name . substring ( 1 ) ; \nreturn nm ; \n} \n} \n} \n"}
{"6215": "public class Introspector { \nstatic public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { \nfinal String SETTER_PREFIX = \"set\" ; \nfinal String GETTER_PREFIX = \"get\" ; \nfinal int LEN_PREFIX = SETTER_PREFIX . length ( ) ; \nMap < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; \nfor ( Method m : clazz . getMethods ( ) ) { \nPropertyDescriptor pd = null ; \nString mName = m . getName ( ) ; \nboolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nboolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nif ( isGet || isSet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( isSet ) if ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \nelse if ( isGet ) if ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) pd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \nreturn map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \n} \n"}
{"6216": "public class OutputStreamAppender { \npublic void start ( ) { \nint errors = 0 ; \nif ( this . encoder == null ) { \naddStatus ( new ErrorStatus ( \"No encoder set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors ++ ; \n} \nif ( this . outputStream == null ) { \naddStatus ( new ErrorStatus ( \"No output stream set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors ++ ; \n} \nif ( errors == 0 ) super . start ( ) ; \n} \n} \n"}
{"6217": "public class StatusListenerConfigHelper { \nstatic public void addOnConsoleListenerInstance ( Context context , OnConsoleStatusListener onConsoleStatusListener ) { \nonConsoleStatusListener . setContext ( context ) ; \nboolean effectivelyAdded = context . getStatusManager ( ) . add ( onConsoleStatusListener ) ; \nif ( effectivelyAdded ) onConsoleStatusListener . start ( ) ; \n} \n} \n"}
{"6218": "public class DefinePropertyAction { \npublic void end ( InterpretationContext ec , String name ) { \nif ( inError ) return ; \nObject o = ec . peekObject ( ) ; \nif ( o != definer ) addWarn ( \"The object at the of the stack is not the property definer for property named [\" + propertyName + \"] pushed earlier.\" ) ; \nelse { \naddInfo ( \"Popping property definer for property named [\" + propertyName + \"] from the object stack\" ) ; \nec . popObject ( ) ; \nString propertyValue = definer . getPropertyValue ( ) ; \nif ( propertyValue != null ) ActionUtil . setProperty ( ec , propertyName , propertyValue , scope ) ; \n} \n} \n} \n"}
{"6219": "public class ContextBasedDiscriminator { \npublic String getDiscriminatingValue ( ILoggingEvent event ) { \nString contextName = event . getLoggerContextVO ( ) . getName ( ) ; \nif ( contextName == null ) return defaultValue ; \nelse return contextName ; \n} \n} \n"}
{"6222": "public class ShutdownHookAction { \n@ Override public void end ( InterpretationContext ic , String name ) throws ActionException { \nif ( inError ) return ; \nObject o = ic . peekObject ( ) ; \nif ( o != hook ) addWarn ( \"The object at the of the stack is not the hook pushed earlier.\" ) ; \nelse { \nic . popObject ( ) ; \nThread hookThread = new Thread ( hook , \"Logback shutdown hook [\" + context . getName ( ) + \"]\" ) ; \naddInfo ( \"Registering shutdown hook with JVM runtime\" ) ; \ncontext . putObject ( CoreConstants . SHUTDOWN_HOOK_THREAD , hookThread ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( hookThread ) ; \n} \n} \n} \n"}
{"6223": "public class SSLParametersConfiguration { \nprivate String [ ] enabledProtocols ( String [ ] supportedProtocols , String [ ] defaultProtocols ) { \nif ( enabledProtocols == null ) { \nif ( OptionHelper . isEmpty ( getIncludedProtocols ( ) ) && OptionHelper . isEmpty ( getExcludedProtocols ( ) ) ) enabledProtocols = Arrays . copyOf ( defaultProtocols , defaultProtocols . length ) ; \nelse enabledProtocols = includedStrings ( supportedProtocols , getIncludedProtocols ( ) , getExcludedProtocols ( ) ) ; \nfor ( String protocol : enabledProtocols ) { \naddInfo ( \"enabled protocol: \" + protocol ) ; \n} \n} \nreturn enabledProtocols ; \n} \n} \n"}
{"6224": "public class SSLParametersConfiguration { \nprivate String [ ] enabledCipherSuites ( String [ ] supportedCipherSuites , String [ ] defaultCipherSuites ) { \nif ( enabledCipherSuites == null ) { \nif ( OptionHelper . isEmpty ( getIncludedCipherSuites ( ) ) && OptionHelper . isEmpty ( getExcludedCipherSuites ( ) ) ) enabledCipherSuites = Arrays . copyOf ( defaultCipherSuites , defaultCipherSuites . length ) ; \nelse enabledCipherSuites = includedStrings ( supportedCipherSuites , getIncludedCipherSuites ( ) , getExcludedCipherSuites ( ) ) ; \nfor ( String cipherSuite : enabledCipherSuites ) { \naddInfo ( \"enabled cipher suite: \" + cipherSuite ) ; \n} \n} \nreturn enabledCipherSuites ; \n} \n} \n"}
{"6225": "public class SSLParametersConfiguration { \nprivate String [ ] includedStrings ( String [ ] defaults , String included , String excluded ) { \nList < String > values = new ArrayList < String > ( defaults . length ) ; \nvalues . addAll ( Arrays . asList ( defaults ) ) ; \nif ( included != null ) StringCollectionUtil . retainMatching ( values , stringToArray ( included ) ) ; \nif ( excluded != null ) StringCollectionUtil . removeMatching ( values , stringToArray ( excluded ) ) ; \nreturn values . toArray ( new String [ values . size ( ) ] ) ; \n} \n} \n"}
{"6228": "public class AppenderAttachableImpl { \npublic void addAppender ( Appender < E > newAppender ) { \nif ( newAppender == null ) throw new IllegalArgumentException ( \"Null argument disallowed\" ) ; \nappenderList . addIfAbsent ( newAppender ) ; \n} \n} \n"}
{"6229": "public class AppenderAttachableImpl { \npublic boolean detachAppender ( Appender < E > appender ) { \nif ( appender == null ) return false ; \nboolean result ; \nresult = appenderList . remove ( appender ) ; \nreturn result ; \n} \n} \n"}
{"6230": "public class AppenderAttachableImpl { \npublic boolean detachAppender ( String name ) { \nif ( name == null ) return false ; \nboolean removed = false ; \nfor ( Appender < E > a : appenderList ) { \nif ( name . equals ( ( a ) . getName ( ) ) ) { \nremoved = appenderList . remove ( a ) ; \nbreak ; \n} \n} \nreturn removed ; \n} \n} \n"}
{"6232": "public class Logger { \npublic void callAppenders ( ILoggingEvent event ) { \nint writes = 0 ; \nfor ( Logger l = this ; \nl != null ; \nl = l . parent ) { \nwrites += l . appendLoopOnAppenders ( event ) ; \nif ( ! l . additive ) break ; \n} \nif ( writes == 0 ) loggerContext . noAppenderDefinedWarning ( this ) ; \n} \n} \n"}
{"6233": "public class Logger { \npublic boolean detachAppender ( Appender < ILoggingEvent > appender ) { \nif ( aai == null ) return false ; \nreturn aai . detachAppender ( appender ) ; \n} \n} \n"}
{"6234": "public class Logger { \nLogger createChildByLastNamePart ( final String lastPart ) { \nint i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; \nif ( i_index != - 1 ) throw new IllegalArgumentException ( \"Child name [\" + lastPart + \" passed as parameter, may not include [\" + CoreConstants . DOT + \"]\" ) ; \nif ( childrenList == null ) childrenList = new CopyOnWriteArrayList < Logger > ( ) ; \nLogger childLogger ; \nif ( this . isRootLogger ( ) ) childLogger = new Logger ( lastPart , this , this . loggerContext ) ; \nelse childLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , this . loggerContext ) ; \nchildrenList . add ( childLogger ) ; \nchildLogger . effectiveLevelInt = this . effectiveLevelInt ; \nreturn childLogger ; \n} \n} \n"}
{"6238": "public class FileUtil { \nstatic public boolean createMissingParentDirectories ( File file ) { \nFile parent = file . getParentFile ( ) ; \nif ( parent == null ) return true ; \nparent . mkdirs ( ) ; \nreturn parent . exists ( ) ; \n} \n} \n"}
{"6243": "public class Loader { \npublic static ClassLoader getClassLoaderOfObject ( Object o ) { \nif ( o == null ) throw new NullPointerException ( \"Argument cannot be null\" ) ; \nreturn getClassLoaderOfClass ( o . getClass ( ) ) ; \n} \n} \n"}
{"6245": "public class Loader { \npublic static ClassLoader getClassLoaderOfClass ( final Class < ? > clazz ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nif ( cl == null ) return ClassLoader . getSystemClassLoader ( ) ; \nelse return cl ; \n} \n} \n"}
{"6247": "public class LogcatAppender { \nprotected String getTag ( ILoggingEvent event ) { \nString tag = ( this . tagEncoder != null ) ? this . tagEncoder . getLayout ( ) . doLayout ( event ) : event . getLoggerName ( ) ; \nif ( checkLoggable && ( tag . length ( ) > MAX_TAG_LENGTH ) ) tag = tag . substring ( 0 , MAX_TAG_LENGTH - 1 ) + \"*\" ; \nreturn tag ; \n} \n} \n"}
{"6248": "public class PropertyAction { \npublic void begin ( InterpretationContext ec , String localName , Attributes attributes ) { \nif ( \"substitutionProperty\" . equals ( localName ) ) addWarn ( \"[substitutionProperty] element has been deprecated. Please use the [property] element instead.\" ) ; \nString name = attributes . getValue ( NAME_ATTRIBUTE ) ; \nString value = attributes . getValue ( VALUE_ATTRIBUTE ) ; \nString scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; \nScope scope = ActionUtil . stringToScope ( scopeStr ) ; \nif ( checkFileAttributeSanity ( attributes ) ) { \nString file = attributes . getValue ( FILE_ATTRIBUTE ) ; \nfile = ec . subst ( file ) ; \ntry { \nFileInputStream istream = new FileInputStream ( file ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( FileNotFoundException e ) { \naddError ( \"Could not find properties file [\" + file + \"].\" ) ; \n} \ncatch ( IOException e1 ) { \naddError ( \"Could not read properties file [\" + file + \"].\" , e1 ) ; \n} \n} \nelse if ( checkResourceAttributeSanity ( attributes ) ) { \nString resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; \nresource = ec . subst ( resource ) ; \nURL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; \nif ( resourceURL == null ) addError ( \"Could not find resource [\" + resource + \"].\" ) ; \nelse try { \nInputStream istream = resourceURL . openStream ( ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( IOException e ) { \naddError ( \"Could not read resource file [\" + resource + \"].\" , e ) ; \n} \n} \nelse if ( checkValueNameAttributesSanity ( attributes ) ) { \nvalue = RegularEscapeUtil . basicEscape ( value ) ; \nvalue = value . trim ( ) ; \nvalue = ec . subst ( value ) ; \nActionUtil . setProperty ( ec , name , value , scope ) ; \n} \nelse addError ( INVALID_ATTRIBUTES ) ; \n} \n} \n"}
{"6250": "public class OnMarkerEvaluator { \npublic boolean evaluate ( ILoggingEvent event ) throws NullPointerException , EvaluationException { \nMarker eventsMarker = event . getMarker ( ) ; \nif ( eventsMarker == null ) return false ; \nfor ( String markerStr : markerList ) { \nif ( eventsMarker . contains ( markerStr ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6252": "public class FileStoreUtil { \nstatic public boolean areOnSameFileStore ( File a , File b ) throws RolloverFailure { \nif ( ! a . exists ( ) ) throw new IllegalArgumentException ( \"File [\" + a + \"] does not exist.\" ) ; \nif ( ! b . exists ( ) ) throw new IllegalArgumentException ( \"File [\" + b + \"] does not exist.\" ) ; \ntry { \nClass < ? > pathClass = Class . forName ( PATH_CLASS_STR ) ; \nClass < ? > filesClass = Class . forName ( FILES_CLASS_STR ) ; \nMethod toPath = File . class . getMethod ( \"toPath\" ) ; \nMethod getFileStoreMethod = filesClass . getMethod ( \"getFileStore\" , pathClass ) ; \nObject pathA = toPath . invoke ( a ) ; \nObject pathB = toPath . invoke ( b ) ; \nObject fileStoreA = getFileStoreMethod . invoke ( null , pathA ) ; \nObject fileStoreB = getFileStoreMethod . invoke ( null , pathB ) ; \nreturn fileStoreA . equals ( fileStoreB ) ; \n} \ncatch ( Exception e ) { \nthrow new RolloverFailure ( \"Failed to check file store equality for [\" + a + \"] and [\" + b + \"]\" , e ) ; \n} \n} \n} \n"}
{"6253": "public class SMTPAppenderBase { \npublic void start ( ) { \nif ( cbTracker == null ) cbTracker = new CyclicBufferTracker < E > ( ) ; \nsession = buildSessionFromProperties ( ) ; \nif ( session == null ) { \naddError ( \"Failed to obtain javax.mail.Session. Cannot start.\" ) ; \nreturn ; \n} \nsubjectLayout = makeSubjectLayout ( subjectStr ) ; \nstarted = true ; \n} \n} \n"}
{"6254": "public class SMTPAppenderBase { \nprotected void append ( E eventObject ) { \nif ( ! checkEntryConditions ( ) ) return ; \nString key = discriminator . getDiscriminatingValue ( eventObject ) ; \nlong now = System . currentTimeMillis ( ) ; \nfinal CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; \nsubAppend ( cb , eventObject ) ; \ntry { \nif ( eventEvaluator . evaluate ( eventObject ) ) { \nCyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; \ncb . clear ( ) ; \nif ( asynchronousSending ) { \nSenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; \ncontext . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; \n} \nelse sendBuffer ( cbClone , eventObject ) ; \n} \n} \ncatch ( EvaluationException ex ) { \nerrorCount ++ ; \nif ( errorCount < CoreConstants . MAX_ERROR_COUNT ) addError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; \n} \nif ( eventMarksEndOfLife ( eventObject ) ) cbTracker . endOfLife ( key ) ; \ncbTracker . removeStaleComponents ( now ) ; \nif ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { \naddInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; \nlastTrackerStatusPrint = now ; \nif ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) delayBetweenStatusMessages *= 4 ; \n} \n} \n} \n"}
{"6255": "public class SMTPAppenderBase { \nprotected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { \ntry { \nMimeBodyPart part = new MimeBodyPart ( ) ; \nStringBuffer sbuf = new StringBuffer ( ) ; \nString header = layout . getFileHeader ( ) ; \nif ( header != null ) sbuf . append ( header ) ; \nString presentationHeader = layout . getPresentationHeader ( ) ; \nif ( presentationHeader != null ) sbuf . append ( presentationHeader ) ; \nfillBuffer ( cb , sbuf ) ; \nString presentationFooter = layout . getPresentationFooter ( ) ; \nif ( presentationFooter != null ) sbuf . append ( presentationFooter ) ; \nString footer = layout . getFileFooter ( ) ; \nif ( footer != null ) sbuf . append ( footer ) ; \nString subjectStr = \"Undefined subject\" ; \nif ( subjectLayout != null ) { \nsubjectStr = subjectLayout . doLayout ( lastEventObject ) ; \nint newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\\n' ) : - 1 ; \nif ( newLinePos > - 1 ) subjectStr = subjectStr . substring ( 0 , newLinePos ) ; \n} \nMimeMessage mimeMsg = new MimeMessage ( session ) ; \nif ( from != null ) mimeMsg . setFrom ( getAddress ( from ) ) ; \nelse mimeMsg . setFrom ( ) ; \nmimeMsg . setSubject ( subjectStr , charsetEncoding ) ; \nList < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; \nif ( destinationAddresses . isEmpty ( ) ) { \naddInfo ( \"Empty destination address. Aborting email transmission\" ) ; \nreturn ; \n} \nInternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; \nmimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; \nString contentType = layout . getContentType ( ) ; \nif ( ContentTypeUtil . isTextual ( contentType ) ) part . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; \nelse part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; \nMultipart mp = new MimeMultipart ( ) ; \nmp . addBodyPart ( part ) ; \nmimeMsg . setContent ( mp ) ; \nupdateMimeMsg ( mimeMsg , cb , lastEventObject ) ; \nmimeMsg . setSentDate ( new Date ( ) ) ; \naddInfo ( \"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays . toString ( toAddressArray ) ) ; \nTransport . send ( mimeMsg ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Error occurred while sending e-mail notification.\" , e ) ; \n} \n} \n} \n"}
{"6256": "public class DynamicThresholdFilter { \npublic void addMDCValueLevelPair ( MDCValueLevelPair mdcValueLevelPair ) { \nif ( valueLevelMap . containsKey ( mdcValueLevelPair . getValue ( ) ) ) addError ( mdcValueLevelPair . getValue ( ) + \" has been already set\" ) ; \nelse valueLevelMap . put ( mdcValueLevelPair . getValue ( ) , mdcValueLevelPair . getLevel ( ) ) ; \n} \n} \n"}
{"6257": "public class Compiler { \n@ SuppressWarnings ( \"unchecked\" ) DynamicConverter < E > createConverter ( SimpleKeywordNode kn ) { \nString keyword = ( String ) kn . getValue ( ) ; \nString converterClassStr = ( String ) converterMap . get ( keyword ) ; \nif ( converterClassStr != null ) try { \nreturn ( DynamicConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , DynamicConverter . class , context ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Failed to instantiate converter class [\" + converterClassStr + \"] for keyword [\" + keyword + \"]\" , e ) ; \nreturn null ; \n} \nelse { \naddError ( \"There is no conversion class registered for conversion word [\" + keyword + \"]\" ) ; \nreturn null ; \n} \n} \n} \n"}
{"6258": "public class Compiler { \n@ SuppressWarnings ( \"unchecked\" ) CompositeConverter < E > createCompositeConverter ( CompositeNode cn ) { \nString keyword = ( String ) cn . getValue ( ) ; \nString converterClassStr = ( String ) converterMap . get ( keyword ) ; \nif ( converterClassStr != null ) try { \nreturn ( CompositeConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , CompositeConverter . class , context ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Failed to instantiate converter class [\" + converterClassStr + \"] as a composite converter for keyword [\" + keyword + \"]\" , e ) ; \nreturn null ; \n} \nelse { \naddError ( \"There is no conversion class registered for composite conversion word [\" + keyword + \"]\" ) ; \nreturn null ; \n} \n} \n} \n"}
{"6267": "public class ContextBase { \npublic void setName ( String name ) throws IllegalStateException { \nif ( name != null && name . equals ( this . name ) ) return ; \nif ( this . name == null || CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) this . name = name ; \nelse throw new IllegalStateException ( \"Context has been already given a name\" ) ; \n} \n} \n"}
{"6269": "public class StatusUtil { \npublic long timeOfLastReset ( ) { \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nif ( statusList == null ) return - 1 ; \nint len = statusList . size ( ) ; \nfor ( int i = len - 1 ; \ni >= 0 ; \ni -- ) { \nStatus s = statusList . get ( i ) ; \nif ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) return s . getDate ( ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"6270": "public class HTMLLayoutBase { \n@ Override public void start ( ) { \nint errorCount = 0 ; \ntry { \nParser < E > p = new Parser < E > ( pattern ) ; \np . setContext ( getContext ( ) ) ; \nNode t = p . parse ( ) ; \nthis . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; \nConverterUtil . startConverters ( this . head ) ; \n} \ncatch ( ScanException ex ) { \naddError ( \"Incorrect pattern found\" , ex ) ; \nerrorCount ++ ; \n} \nif ( errorCount == 0 ) super . started = true ; \n} \n} \n"}
{"6271": "public class HTMLLayoutBase { \npublic Map < String , String > getEffectiveConverterMap ( ) { \nMap < String , String > effectiveMap = new HashMap < String , String > ( ) ; \nMap < String , String > defaultMap = getDefaultConverterMap ( ) ; \nif ( defaultMap != null ) effectiveMap . putAll ( defaultMap ) ; \nContext context = getContext ( ) ; \nif ( context != null ) { \n@ SuppressWarnings ( \"unchecked\" ) Map < String , String > contextMap = ( Map < String , String > ) context . getObject ( CoreConstants . PATTERN_RULE_REGISTRY ) ; \nif ( contextMap != null ) effectiveMap . putAll ( contextMap ) ; \n} \nreturn effectiveMap ; \n} \n} \n"}
{"6274": "public class AppenderAction { \n@ SuppressWarnings ( \"unchecked\" ) public void begin ( InterpretationContext ec , String localName , Attributes attributes ) throws ActionException { \nappender = null ; \ninError = false ; \nString className = attributes . getValue ( CLASS_ATTRIBUTE ) ; \nif ( OptionHelper . isEmpty ( className ) ) { \naddError ( \"Missing class name for appender. Near [\" + localName + \"] line \" + getLineNumber ( ec ) ) ; \ninError = true ; \nreturn ; \n} \ntry { \naddInfo ( \"About to instantiate appender of type [\" + className + \"]\" ) ; \nwarnDeprecated ( className ) ; \nappender = ( Appender < E > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . Appender . class , context ) ; \nappender . setContext ( context ) ; \nString appenderName = ec . subst ( attributes . getValue ( NAME_ATTRIBUTE ) ) ; \nif ( OptionHelper . isEmpty ( appenderName ) ) addWarn ( \"No appender name given for appender of type \" + className + \"].\" ) ; \nelse { \nappender . setName ( appenderName ) ; \naddInfo ( \"Naming appender as [\" + appenderName + \"]\" ) ; \n} \nHashMap < String , Appender < E > > appenderBag = ( HashMap < String , Appender < E > > ) ec . getObjectMap ( ) . get ( ActionConst . APPENDER_BAG ) ; \nappenderBag . put ( appenderName , appender ) ; \nec . pushObject ( appender ) ; \n} \ncatch ( Exception oops ) { \ninError = true ; \naddError ( \"Could not create an Appender of type [\" + className + \"].\" , oops ) ; \nthrow new ActionException ( oops ) ; \n} \n} \n} \n"}
{"6275": "public class AppenderAction { \npublic void end ( InterpretationContext ec , String name ) { \nif ( inError ) return ; \nif ( appender instanceof LifeCycle ) ( ( LifeCycle ) appender ) . start ( ) ; \nObject o = ec . peekObject ( ) ; \nif ( o != appender ) addWarn ( \"The object at the of the stack is not the appender named [\" + appender . getName ( ) + \"] pushed earlier.\" ) ; \nelse ec . popObject ( ) ; \n} \n} \n"}
{"6279": "public class LogbackMDCAdapter { \npublic Map < String , String > getCopyOfContextMap ( ) { \nMap < String , String > hashMap = copyOnThreadLocal . get ( ) ; \nif ( hashMap == null ) return null ; \nelse return new HashMap < String , String > ( hashMap ) ; \n} \n} \n"}
{"6281": "public class TurboFilterList { \npublic FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { \nfinal int size = size ( ) ; \nif ( size == 1 ) try { \nTurboFilter tf = get ( 0 ) ; \nreturn tf . decide ( marker , logger , level , format , params , t ) ; \n} \ncatch ( IndexOutOfBoundsException iobe ) { \nreturn FilterReply . NEUTRAL ; \n} \nObject [ ] tfa = toArray ( ) ; \nfinal int len = tfa . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nfinal TurboFilter tf = ( TurboFilter ) tfa [ i ] ; \nfinal FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) return r ; \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6283": "public class StaticLoggerBinder { \nvoid init ( ) { \ntry { \ntry { \nnew ContextInitializer ( defaultLoggerContext ) . autoConfig ( ) ; \n} \ncatch ( JoranException je ) { \nUtil . report ( \"Failed to auto configure default logger context\" , je ) ; \n} \nif ( ! StatusUtil . contextHasStatusListener ( defaultLoggerContext ) ) StatusPrinter . printInCaseOfErrorsOrWarnings ( defaultLoggerContext ) ; \ncontextSelectorBinder . init ( defaultLoggerContext , KEY ) ; \ninitialized = true ; \n} \ncatch ( Exception t ) { \nUtil . report ( \"Failed to instantiate [\" + LoggerContext . class . getName ( ) + \"]\" , t ) ; \n} \n} \n} \n"}
{"6284": "public class FileFilterUtil { \npublic static File [ ] filesInFolderMatchingStemRegex ( File file , final String stemRegex ) { \nif ( file == null ) return new File [ 0 ] ; \nif ( ! file . exists ( ) || ! file . isDirectory ( ) ) return new File [ 0 ] ; \nreturn file . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . matches ( stemRegex ) ; \n} \n} \n) ; \n} \n} \n"}
{"6285": "public class OnPrintStreamStatusListenerBase { \nprivate void retrospectivePrint ( ) { \nif ( context == null ) return ; \nlong now = System . currentTimeMillis ( ) ; \nStatusManager sm = context . getStatusManager ( ) ; \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nfor ( Status status : statusList ) { \nlong timestampOfStatusMesage = status . getDate ( ) ; \nif ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) print ( status ) ; \n} \n} \n} \n"}
{"6286": "public class SyslogAppenderBase { \nstatic public int facilityStringToint ( String facilityStr ) { \nif ( \"KERN\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_KERN ; \nelse if ( \"USER\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_USER ; \nelse if ( \"MAIL\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_MAIL ; \nelse if ( \"DAEMON\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_DAEMON ; \nelse if ( \"AUTH\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_AUTH ; \nelse if ( \"SYSLOG\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_SYSLOG ; \nelse if ( \"LPR\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LPR ; \nelse if ( \"NEWS\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_NEWS ; \nelse if ( \"UUCP\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_UUCP ; \nelse if ( \"CRON\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_CRON ; \nelse if ( \"AUTHPRIV\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_AUTHPRIV ; \nelse if ( \"FTP\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_FTP ; \nelse if ( \"NTP\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_NTP ; \nelse if ( \"AUDIT\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_AUDIT ; \nelse if ( \"ALERT\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_ALERT ; \nelse if ( \"CLOCK\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_CLOCK ; \nelse if ( \"LOCAL0\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL0 ; \nelse if ( \"LOCAL1\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL1 ; \nelse if ( \"LOCAL2\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL2 ; \nelse if ( \"LOCAL3\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL3 ; \nelse if ( \"LOCAL4\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL4 ; \nelse if ( \"LOCAL5\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL5 ; \nelse if ( \"LOCAL6\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL6 ; \nelse if ( \"LOCAL7\" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL7 ; \nelse throw new IllegalArgumentException ( facilityStr + \" is not a valid syslog facility string\" ) ; \n} \n} \n"}
{"6287": "public class SQLiteAppender { \npublic File getDatabaseFile ( String filename ) { \nFile dbFile = null ; \nif ( filename != null && filename . trim ( ) . length ( ) > 0 ) dbFile = new File ( filename ) ; \nif ( dbFile == null || dbFile . isDirectory ( ) ) dbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( \"logback.db\" ) ) ; \nreturn dbFile ; \n} \n} \n"}
{"6291": "public class SQLiteAppender { \nprivate void secondarySubAppend ( ILoggingEvent event , long eventId ) throws SQLException { \nMap < String , String > mergedMap = mergePropertyMaps ( event ) ; \ninsertProperties ( mergedMap , eventId ) ; \nif ( event . getThrowableProxy ( ) != null ) insertThrowable ( event . getThrowableProxy ( ) , eventId ) ; \n} \n} \n"}
{"6293": "public class SQLiteAppender { \nprivate String asStringTruncatedTo254 ( Object o ) { \nString s = null ; \nif ( o != null ) s = o . toString ( ) ; \nif ( s != null && s . length ( ) > 254 ) s = s . substring ( 0 , 254 ) ; \nreturn s == null ? \"\" : s ; \n} \n} \n"}
{"6294": "public class SQLiteAppender { \nprivate static short computeReferenceMask ( ILoggingEvent event ) { \nshort mask = 0 ; \nint mdcPropSize = 0 ; \nif ( event . getMDCPropertyMap ( ) != null ) mdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; \nint contextPropSize = 0 ; \nif ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) contextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; \nif ( mdcPropSize > 0 || contextPropSize > 0 ) mask = PROPERTIES_EXIST ; \nif ( event . getThrowableProxy ( ) != null ) mask |= EXCEPTION_EXISTS ; \nreturn mask ; \n} \n} \n"}
{"6295": "public class SQLiteAppender { \nprivate Map < String , String > mergePropertyMaps ( ILoggingEvent event ) { \nMap < String , String > mergedMap = new HashMap < String , String > ( ) ; \nMap < String , String > loggerContextMap = event . getLoggerContextVO ( ) . getPropertyMap ( ) ; \nif ( loggerContextMap != null ) mergedMap . putAll ( loggerContextMap ) ; \nMap < String , String > mdcMap = event . getMDCPropertyMap ( ) ; \nif ( mdcMap != null ) mergedMap . putAll ( mdcMap ) ; \nreturn mergedMap ; \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) return 0 ; \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) return 0 ; \nint minLen = ( lSize <= rSize ) ? lSize : rSize ; \nint match = 0 ; \nfor ( int i = 0 ; \ni < minLen ; \ni ++ ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) match ++ ; \nelse break ; \n} \nreturn match ; \n} \n} \n"}
{"6298": "public class StatusBase { \npublic synchronized int getEffectiveLevel ( ) { \nint result = level ; \nint effLevel ; \nIterator it = iterator ( ) ; \nStatus s ; \nwhile ( it . hasNext ( ) ) { \ns = ( Status ) it . next ( ) ; \neffLevel = s . getEffectiveLevel ( ) ; \nif ( effLevel > result ) result = effLevel ; \n} \nreturn result ; \n} \n} \n"}
{"6299": "public class PropertySetter { \npublic void setProperty ( String name , String value ) { \nif ( value == null ) return ; \nname = Introspector . decapitalize ( name ) ; \nPropertyDescriptor prop = getPropertyDescriptor ( name ) ; \nif ( prop == null ) addWarn ( \"No such property [\" + name + \"] in \" + objClass . getName ( ) + \".\" ) ; \nelse try { \nsetProperty ( prop , name , value ) ; \n} \ncatch ( PropertySetterException ex ) { \naddWarn ( \"Failed to set property [\" + name + \"] to value \\\"\" + value + \"\\\". \" , ex ) ; \n} \n} \n} \n"}
{"6300": "public class PropertySetter { \nprivate boolean isUnequivocallyInstantiable ( Class < ? > clazz ) { \nif ( clazz . isInterface ( ) ) return false ; \nObject o ; \ntry { \no = clazz . getDeclaredConstructor ( ) . newInstance ( ) ; \nif ( o != null ) return true ; \nelse return false ; \n} \ncatch ( InstantiationException e ) { \nreturn false ; \n} \ncatch ( IllegalAccessException e ) { \nreturn false ; \n} \ncatch ( NoSuchMethodException e ) { \nreturn false ; \n} \ncatch ( InvocationTargetException e ) { \nreturn false ; \n} \n} \n} \n"}
{"6301": "public class CopyOnInheritThreadLocal { \n@ Override protected HashMap < String , String > childValue ( HashMap < String , String > parentValue ) { \nif ( parentValue == null ) return null ; \nelse return new HashMap < String , String > ( parentValue ) ; \n} \n} \n"}
{"6304": "public class IncludeAction { \nprivate void trimHeadAndTail ( SaxEventRecorder recorder ) { \nList < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; \nif ( saxEventList . size ( ) == 0 ) return ; \nboolean includedTagFound = false ; \nboolean configTagFound = false ; \nSaxEvent first = saxEventList . get ( 0 ) ; \nif ( first != null ) { \nString elemName = getEventName ( first ) ; \nincludedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; \nconfigTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; \n} \nif ( includedTagFound || configTagFound ) { \nsaxEventList . remove ( 0 ) ; \nfinal int listSize = saxEventList . size ( ) ; \nif ( listSize == 0 ) return ; \nfinal int lastIndex = listSize - 1 ; \nSaxEvent last = saxEventList . get ( lastIndex ) ; \nif ( last != null ) { \nString elemName = getEventName ( last ) ; \nif ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) saxEventList . remove ( lastIndex ) ; \n} \n} \n} \n} \n"}
{"6306": "public class AlgoliaException { \npublic boolean isTransient ( ) { \nThrowable cause = getCause ( ) ; \nif ( cause == null ) return isServerError ( statusCode ) ; \nelse if ( cause instanceof AlgoliaException ) return ( ( AlgoliaException ) cause ) . isTransient ( ) ; \nelse if ( cause instanceof IOException ) return true ; \nelse return false ; \n} \n} \n"}
{"6308": "public class MirroredIndex { \nprivate synchronized void ensureLocalIndex ( ) { \nif ( localIndex == null ) localIndex = new LocalIndex ( getClient ( ) . getRootDataDir ( ) . getAbsolutePath ( ) , getClient ( ) . getApplicationID ( ) , getRawIndexName ( ) ) ; \n} \n} \n"}
{"6309": "public class MirroredIndex { \npublic void sync ( ) { \nif ( getDataSelectionQueries ( ) . length == 0 ) throw new IllegalStateException ( \"Cannot sync with empty data selection queries\" ) ; \nsynchronized ( this ) { \nif ( syncing ) return ; \nsyncing = true ; \n} \ngetClient ( ) . localBuildExecutorService . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \n_sync ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"6310": "public class MirroredIndex { \npublic void syncIfNeeded ( ) { \nlong currentDate = System . currentTimeMillis ( ) ; \nif ( currentDate - mirrorSettings . getLastSyncDate ( ) . getTime ( ) > delayBetweenSyncs || mirrorSettings . getQueriesModificationDate ( ) . compareTo ( mirrorSettings . getLastSyncDate ( ) ) > 0 ) sync ( ) ; \n} \n} \n"}
{"6311": "public class Index { \npublic JSONObject waitTask ( String taskID , long timeToWait ) throws AlgoliaException { \ntry { \nwhile ( true ) { \nJSONObject obj = client . getRequest ( \"/1/indexes/\" + encodedIndexName + \"/task/\" + URLEncoder . encode ( taskID , \"UTF-8\" ) , null , false , null ) ; \nif ( obj . getString ( \"status\" ) . equals ( \"published\" ) ) return obj ; \ntry { \nThread . sleep ( timeToWait >= MAX_TIME_MS_TO_WAIT ? MAX_TIME_MS_TO_WAIT : timeToWait ) ; \n} \ncatch ( InterruptedException e ) { \ncontinue ; \n} \nfinal long newTimeout = timeToWait * 2 ; \ntimeToWait = ( newTimeout <= 0 || newTimeout >= MAX_TIME_MS_TO_WAIT ) ? MAX_TIME_MS_TO_WAIT : newTimeout ; \n} \n} \ncatch ( JSONException e ) { \nthrow new AlgoliaException ( e . getMessage ( ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"6312": "public class OfflineClient { \nprivate JSONObject listIndexesOfflineSync ( ) throws AlgoliaException { \ntry { \nfinal String rootDataPath = getRootDataDir ( ) . getAbsolutePath ( ) ; \nfinal File appDir = getAppDir ( ) ; \nfinal File [ ] directories = appDir . listFiles ( new FileFilter ( ) { \n@ Override public boolean accept ( File pathname ) { \nreturn pathname . isDirectory ( ) ; \n} \n} \n) ; \nJSONObject response = new JSONObject ( ) ; \nJSONArray items = new JSONArray ( ) ; \nif ( directories != null ) for ( File directory : directories ) { \nfinal String name = directory . getName ( ) ; \nif ( hasOfflineData ( name ) ) items . put ( new JSONObject ( ) . put ( \"name\" , name ) ) ; \n} \nresponse . put ( \"items\" , items ) ; \nreturn response ; \n} \ncatch ( JSONException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"6314": "public class AbstractClient { \nprivate static byte [ ] _toByteArray ( InputStream stream ) throws AlgoliaException { \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nint read ; \nbyte [ ] buffer = new byte [ 1024 ] ; \ntry { \nwhile ( ( read = stream . read ( buffer , 0 , buffer . length ) ) != - 1 ) out . write ( buffer , 0 , read ) ; \nout . flush ( ) ; \nreturn out . toByteArray ( ) ; \n} \ncatch ( IOException e ) { \nthrow new AlgoliaException ( \"Error while reading stream: \" + e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"6315": "public class AbstractClient { \nprivate static void consumeQuietly ( final HttpURLConnection connection ) { \ntry { \nint read = 0 ; \nwhile ( read != - 1 ) read = connection . getInputStream ( ) . read ( ) ; \nconnection . getInputStream ( ) . close ( ) ; \nread = 0 ; \nwhile ( read != - 1 ) read = connection . getErrorStream ( ) . read ( ) ; \nconnection . getErrorStream ( ) . close ( ) ; \nconnection . disconnect ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n"}
{"6316": "public class AbstractClient { \nprivate List < String > hostsThatAreUp ( List < String > hosts ) { \nList < String > upHosts = new ArrayList < > ( ) ; \nfor ( String host : hosts ) { \nif ( isUpOrCouldBeRetried ( host ) ) upHosts . add ( host ) ; \n} \nreturn upHosts . isEmpty ( ) ? hosts : upHosts ; \n} \n} \n"}
{"6317": "public class PlacesQuery { \npublic @ NonNull PlacesQuery setType ( Type type ) { \nif ( type == null ) set ( KEY_TYPE , null ) ; \nelse switch ( type ) { \ncase CITY : set ( KEY_TYPE , \"city\" ) ; \nbreak ; \ncase COUNTRY : set ( KEY_TYPE , \"country\" ) ; \nbreak ; \ncase ADDRESS : set ( KEY_TYPE , \"address\" ) ; \nbreak ; \ncase BUS_STOP : set ( KEY_TYPE , \"busStop\" ) ; \nbreak ; \ncase TRAIN_STATION : set ( KEY_TYPE , \"trainStation\" ) ; \nbreak ; \ncase TOWN_HALL : set ( KEY_TYPE , \"townhall\" ) ; \nbreak ; \ncase AIRPORT : set ( KEY_TYPE , \"airport\" ) ; \nbreak ; \n} \nreturn this ; \n} \n} \n"}
{"6318": "public class BrowseIterator { \npublic void start ( ) { \nif ( started ) throw new IllegalStateException ( ) ; \nstarted = true ; \nrequest = index . browseAsync ( query , requestOptions , completionHandler ) ; \n} \n} \n"}
{"6319": "public class ExpiringCache { \npublic V put ( K key , V value ) { \nV previous = null ; \nsynchronized ( this ) { \nlong timeout = System . currentTimeMillis ( ) + TimeUnit . MILLISECONDS . convert ( expirationTimeout , expirationTimeUnit ) ; \nfinal Pair < V , Long > previousPair = lruCache . put ( key , new Pair < > ( value , timeout ) ) ; \nif ( previousPair != null ) previous = previousPair . first ; \n} \nreturn previous ; \n} \n} \n"}
{"6320": "public class ExpiringCache { \nsynchronized public V get ( K key ) { \nfinal Pair < V , Long > cachePair = lruCache . get ( key ) ; \nif ( cachePair != null && cachePair . first != null ) if ( cachePair . second > System . currentTimeMillis ( ) ) return cachePair . first ; \nelse lruCache . remove ( key ) ; \nreturn null ; \n} \n} \n"}
{"6321": "public class ThreadSpawner { \npublic void awaitCompletion ( ) { \nfor ( Thread thread : threads ) { \ntry { \nthread . join ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow rethrow ( e ) ; \n} \n} \nif ( caughtException != null ) throw rethrow ( caughtException ) ; \n} \n} \n"}
{"6322": "public class VersionUtils { \npublic static int versionCompare ( String firstVersionString , String secondVersionString ) { \nString [ ] firstVersion = parseVersionString ( firstVersionString ) ; \nString [ ] secondVersion = parseVersionString ( secondVersionString ) ; \nint i = 0 ; \nwhile ( i < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) i ++ ; \nif ( i < firstVersion . length && i < secondVersion . length ) { \nint diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; \nreturn Integer . signum ( diff ) ; \n} \nelse return Integer . signum ( firstVersion . length - secondVersion . length ) ; \n} \n} \n"}
{"6323": "public class ExceptionReporter { \npublic static void report ( String testId , Throwable cause ) { \nif ( cause == null ) { \nLOGGER . fatal ( \"Can't call report with a null exception\" ) ; \nreturn ; \n} \nlong exceptionCount = FAILURE_ID . incrementAndGet ( ) ; \nif ( exceptionCount > MAX_EXCEPTION_COUNT ) { \nLOGGER . warn ( \"Exception #\" + exceptionCount + \" detected. The maximum number of exceptions has been exceeded, so it\" + \" won't be reported to the Agent.\" , cause ) ; \nreturn ; \n} \nLOGGER . warn ( \"Exception #\" + exceptionCount + \" detected\" , cause ) ; \nString targetFileName = exceptionCount + \".exception\" ; \nFile dir = getUserDir ( ) ; \nFile tmpFile = new File ( dir , targetFileName + \".tmp\" ) ; \ntry { \nif ( ! tmpFile . createNewFile ( ) ) throw new IOException ( \"Could not create tmp file: \" + tmpFile . getAbsolutePath ( ) ) ; \n} \ncatch ( IOException e ) { \nLOGGER . fatal ( \"Could not report exception; this means that this exception is not visible to the coordinator\" , e ) ; \nreturn ; \n} \nwriteText ( testId + NEW_LINE + throwableToString ( cause ) , tmpFile ) ; \nFile file = new File ( dir , targetFileName ) ; \nLOGGER . info ( file . getAbsolutePath ( ) ) ; \nrename ( tmpFile , file ) ; \n} \n} \n"}
{"6324": "public class FileUtils { \npublic static void copyDirectory ( File src , File target ) { \ncheckNotNull ( src , \"src can't be null\" ) ; \ncheckNotNull ( target , \"target can't be null\" ) ; \nFile [ ] files = src . listFiles ( ) ; \nif ( files == null ) return ; \nfor ( File srcFile : files ) { \nif ( srcFile . isDirectory ( ) ) { \nFile targetChild = new File ( target , srcFile . getName ( ) ) ; \nensureExistingDirectory ( targetChild ) ; \ncopyDirectory ( srcFile , targetChild ) ; \n} \nelse copyFileToDirectory ( srcFile , target ) ; \n} \n} \n} \n"}
{"6326": "public class ReflectionUtils { \npublic static < E > E getStaticFieldValue ( Class clazz , String fieldName , Class fieldType ) { \nField field = getField ( clazz , fieldName , fieldType ) ; \nif ( field == null ) throw new ReflectionException ( format ( \"Field %s.%s is not found\" , clazz . getName ( ) , fieldName ) ) ; \nfield . setAccessible ( true ) ; \nreturn getFieldValue0 ( null , field , clazz . getName ( ) , fieldName ) ; \n} \n} \n"}
{"6327": "public class ReflectionUtils { \npublic static Method getMethodByName ( Class clazz , String methodName ) { \nfor ( Method method : clazz . getDeclaredMethods ( ) ) { \nif ( method . getName ( ) . equals ( methodName ) ) return method ; \n} \nreturn null ; \n} \n} \n"}
{"6331": "public class JsonProtocol { \nprotected void readJsonSyntaxChar ( byte [ ] b ) throws IOException { \nbyte ch = reader . read ( ) ; \nif ( ch != b [ 0 ] ) throw new ProtocolException ( \"Unexpected character:\" + ( char ) ch ) ; \n} \n} \n"}
{"6332": "public class JsonProtocol { \nprivate static byte hexVal ( byte ch ) throws IOException { \nif ( ( ch >= '0' ) && ( ch <= '9' ) ) return ( byte ) ( ( char ) ch - '0' ) ; \nelse if ( ( ch >= 'a' ) && ( ch <= 'f' ) ) return ( byte ) ( ( char ) ch - 'a' + 10 ) ; \nelse throw new ProtocolException ( \"Expected hex character\" ) ; \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) if ( ( b [ i ] & 0x00FF ) >= 0x30 ) if ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse transport . write ( b , i , 1 ) ; \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) transport . write ( b , i , 1 ) ; \nelse if ( tmpbuf [ 0 ] > 1 ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6334": "public class JsonProtocol { \nprivate void writeJsonInteger ( long num ) throws IOException { \ncontext . write ( ) ; \nString str = Long . toString ( num ) ; \nboolean escapeNum = context . escapeNum ( ) ; \nif ( escapeNum ) transport . write ( QUOTE ) ; \ntry { \nbyte [ ] buf = str . getBytes ( \"UTF-8\" ) ; \ntransport . write ( buf ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \nif ( escapeNum ) transport . write ( QUOTE ) ; \n} \n} \n"}
{"6335": "public class JsonProtocol { \nprivate void writeJsonDouble ( double num ) throws IOException { \ncontext . write ( ) ; \nString str = Double . toString ( num ) ; \nboolean special = false ; \nswitch ( str . charAt ( 0 ) ) { \ncase 'N' : case 'I' : special = true ; \nbreak ; \ncase '-' : if ( str . charAt ( 1 ) == 'I' ) special = true ; \nbreak ; \ndefault : break ; \n} \nboolean escapeNum = special || context . escapeNum ( ) ; \nif ( escapeNum ) transport . write ( QUOTE ) ; \ntry { \nbyte [ ] b = str . getBytes ( \"UTF-8\" ) ; \ntransport . write ( b , 0 , b . length ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \nif ( escapeNum ) transport . write ( QUOTE ) ; \n} \n} \n"}
{"6336": "public class JsonProtocol { \nprivate ByteString readJsonString ( boolean skipContext ) throws IOException { \nBuffer buffer = new Buffer ( ) ; \nArrayList < Character > codeunits = new ArrayList < > ( ) ; \nif ( ! skipContext ) context . read ( ) ; \nreadJsonSyntaxChar ( QUOTE ) ; \nwhile ( true ) { \nbyte ch = reader . read ( ) ; \nif ( ch == QUOTE [ 0 ] ) break ; \nif ( ch == ESCSEQ [ 0 ] ) { \nch = reader . read ( ) ; \nif ( ch == ESCSEQ [ 1 ] ) { \ntransport . read ( tmpbuf , 0 , 4 ) ; \nshort cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; \ntry { \nif ( Character . isHighSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) > 0 ) throw new ProtocolException ( \"Expected low surrogate char\" ) ; \ncodeunits . add ( ( char ) cu ) ; \n} \nelse if ( Character . isLowSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) == 0 ) throw new ProtocolException ( \"Expected high surrogate char\" ) ; \ncodeunits . add ( ( char ) cu ) ; \nbuffer . write ( new String ( new int [ ] { \ncodeunits . get ( 0 ) , codeunits . get ( 1 ) } \n, 0 , 2 ) . getBytes ( \"UTF-8\" ) ) ; \ncodeunits . clear ( ) ; \n} \nelse buffer . write ( new String ( new int [ ] { \ncu } \n, 0 , 1 ) . getBytes ( \"UTF-8\" ) ) ; \ncontinue ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( IOException ex ) { \nthrow new ProtocolException ( \"Invalid unicode sequence\" ) ; \n} \n} \nelse { \nint off = ESCAPE_CHARS . indexOf ( ch ) ; \nif ( off == - 1 ) throw new ProtocolException ( \"Expected control char\" ) ; \nch = ESCAPE_CHAR_VALS [ off ] ; \n} \n} \nbuffer . write ( new byte [ ] { \nch } \n) ; \n} \nreturn buffer . readByteString ( ) ; \n} \n} \n"}
{"6337": "public class JsonProtocol { \nprivate String readJsonNumericChars ( ) throws IOException { \nStringBuilder strbld = new StringBuilder ( ) ; \nwhile ( true ) { \nbyte ch = reader . peek ( ) ; \nif ( ! isJsonNumeric ( ch ) ) break ; \nstrbld . append ( ( char ) reader . read ( ) ) ; \n} \nreturn strbld . toString ( ) ; \n} \n} \n"}
{"6338": "public class JsonProtocol { \nprivate long readJsonInteger ( ) throws IOException { \ncontext . read ( ) ; \nif ( context . escapeNum ( ) ) readJsonSyntaxChar ( QUOTE ) ; \nString str = readJsonNumericChars ( ) ; \nif ( context . escapeNum ( ) ) readJsonSyntaxChar ( QUOTE ) ; \ntry { \nreturn Long . valueOf ( str ) ; \n} \ncatch ( NumberFormatException ex ) { \nthrow new ProtocolException ( \"Bad data encountered in numeric data\" ) ; \n} \n} \n} \n"}
{"6339": "public class JsonProtocol { \nprivate double readJsonDouble ( ) throws IOException { \ncontext . read ( ) ; \nif ( reader . peek ( ) == QUOTE [ 0 ] ) { \nByteString str = readJsonString ( true ) ; \ndouble dub = Double . valueOf ( str . utf8 ( ) ) ; \nif ( ! context . escapeNum ( ) && ! Double . isNaN ( dub ) && ! Double . isInfinite ( dub ) ) throw new ProtocolException ( \"Numeric data unexpectedly quoted\" ) ; \nreturn dub ; \n} \nelse { \nif ( context . escapeNum ( ) ) readJsonSyntaxChar ( QUOTE ) ; \ntry { \nreturn Double . valueOf ( readJsonNumericChars ( ) ) ; \n} \ncatch ( NumberFormatException ex ) { \nthrow new ProtocolException ( \"Bad data encountered in numeric data\" ) ; \n} \n} \n} \n} \n"}
{"6341": "public class ClientBase { \nprotected final Object execute ( MethodCall < ? > methodCall ) throws Exception { \nif ( ! running . get ( ) ) throw new IllegalStateException ( \"Cannot write to a closed service client\" ) ; \ntry { \nreturn invokeRequest ( methodCall ) ; \n} \ncatch ( ServerException e ) { \nthrow e . thriftException ; \n} \n} \n} \n"}
{"6342": "public class ClientBase { \nfinal Object invokeRequest ( MethodCall < ? > call ) throws Exception { \nboolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; \nint sid = seqId . incrementAndGet ( ) ; \nprotocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; \ncall . send ( protocol ) ; \nprotocol . writeMessageEnd ( ) ; \nprotocol . flush ( ) ; \nif ( isOneWay ) return null ; \nMessageMetadata metadata = protocol . readMessageBegin ( ) ; \nif ( metadata . seqId != sid ) throw new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Unrecognized sequence ID\" ) ; \nif ( metadata . type == TMessageType . EXCEPTION ) { \nThriftException e = ThriftException . read ( protocol ) ; \nprotocol . readMessageEnd ( ) ; \nthrow new ServerException ( e ) ; \n} \nelse if ( metadata . type != TMessageType . REPLY ) throw new ThriftException ( ThriftException . Kind . INVALID_MESSAGE_TYPE , \"Invalid message type: \" + metadata . type ) ; \nif ( metadata . seqId != seqId . get ( ) ) throw new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Out-of-order response\" ) ; \nif ( ! metadata . name . equals ( call . name ) ) throw new ThriftException ( ThriftException . Kind . WRONG_METHOD_NAME , \"Unexpected method name in reply; expected \" + call . name + \" but received \" + metadata . name ) ; \ntry { \nObject result = call . receive ( protocol , metadata ) ; \nprotocol . readMessageEnd ( ) ; \nreturn result ; \n} \ncatch ( Exception e ) { \nif ( e instanceof Struct ) protocol . readMessageEnd ( ) ; \nthrow e ; \n} \n} \n} \n"}
{"6343": "public class AsyncClientBase { \nprotected void enqueue ( MethodCall < ? > methodCall ) { \nif ( ! running . get ( ) ) throw new IllegalStateException ( \"Cannot write to a closed service client\" ) ; \nif ( ! pendingCalls . offer ( methodCall ) ) throw new IllegalStateException ( \"Call queue is full\" ) ; \n} \n} \n"}
{"6346": "public class PlatformUtils { \npublic static void refreshRepositoryView ( ) { \nIWorkbenchWindow activeWindow = Activator . getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; \nif ( activeWindow == null ) return ; \nIWorkbenchPage page = activeWindow . getActivePage ( ) ; \nif ( page == null ) return ; \nRepositoryView view = ( RepositoryView ) page . findView ( IGuvnorConstants . REPVIEW_ID ) ; \nif ( view != null ) view . refresh ( ) ; \n} \n} \n"}
{"6347": "public class PlatformUtils { \npublic static ResourceHistoryView getResourceHistoryView ( ) throws Exception { \nIWorkbenchWindow activeWindow = Activator . getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; \nif ( activeWindow == null ) return null ; \nIWorkbenchPage page = activeWindow . getActivePage ( ) ; \nif ( page == null ) return null ; \nreturn ( ResourceHistoryView ) page . showView ( IGuvnorConstants . RESHISTORYVIEW_ID ) ; \n} \n} \n"}
{"6348": "public class PlatformUtils { \npublic static void openEditor ( String contents , String name ) { \nIWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; \nIStorage storage = new StringStorage ( contents , name ) ; \nIStorageEditorInput input = new StringInput ( storage ) ; \nIWorkbenchPage page = window . getActivePage ( ) ; \nIEditorDescriptor desc = PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . getDefaultEditor ( name ) ; \nString editorId = desc != null ? desc . getId ( ) : \"org.eclipse.ui.DefaultTextEditor\" ; \ntry { \nif ( page != null ) page . openEditor ( input , editorId ) ; \n} \ncatch ( Exception e ) { \nActivator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; \n} \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) return ; \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal int SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nint size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) treeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n) ; \n} \n} \n"}
{"6353": "public class PropertyBehavior { \npublic void setIsKeepAllAlive ( boolean isKeepAllAlive ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyKeepAllAlive = false ; \nif ( isDAVElement ( child , \"keepalive\" ) ) isAlreadyKeepAllAlive = \"*\" . equals ( getFirstText ( child ) ) ; \nif ( isKeepAllAlive ) if ( ! isAlreadyKeepAllAlive ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"keepalive\" , \"*\" ) ; \n} \nelse if ( isAlreadyKeepAllAlive ) root . removeChild ( child ) ; \n} \n} \n"}
{"6354": "public class PropertyBehavior { \npublic void setIsOmit ( boolean isOmit ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyOmit = isDAVElement ( child , \"omit\" ) ; \nif ( isOmit ) if ( ! isAlreadyOmit ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"omit\" ) ; \n} \nelse if ( isAlreadyOmit ) root . removeChild ( child ) ; \n} \n} \n"}
{"6358": "public class ConditionTerm { \npublic boolean matches ( ConditionTerm conditionTerm ) { \nint numberOfItemsToMatch = 0 ; \nboolean match = true ; \nEnumeration factors = getConditionFactors ( ) ; \nwhile ( match && factors . hasMoreElements ( ) ) { \nConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; \nif ( factor . not ( ) ) match = ! conditionTerm . contains ( factor ) ; \nelse { \nmatch = conditionTerm . contains ( factor ) ; \nnumberOfItemsToMatch ++ ; \n} \n} \nmatch = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; \nreturn match ; \n} \n} \n"}
{"6359": "public class DSLAdapter { \npublic static Reader getDSLContent ( String ruleSource , IResource input ) throws CoreException { \nString dslFileName = findDSLConfigName ( ruleSource , input ) ; \nif ( dslFileName == null ) return null ; \nIResource res = findDSLResource ( input , dslFileName ) ; \nif ( res instanceof IFile ) { \nIFile dslConf = ( IFile ) res ; \nif ( dslConf . exists ( ) ) return new InputStreamReader ( dslConf . getContents ( ) ) ; \n} \nreturn null ; \n} \n} \n"}
{"6370": "public class DebugUtil { \npublic static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { \nIStatusHandler handler = getStackFrameProvider ( ) ; \nif ( handler != null ) { \nIJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; \nif ( stackFrame != null ) return stackFrame ; \n} \nIDebugTarget target = value . getDebugTarget ( ) ; \nIJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; \nif ( javaTarget != null ) { \nIThread [ ] threads = javaTarget . getThreads ( ) ; \nfor ( int i = 0 ; \ni < threads . length ; \ni ++ ) { \nIThread thread = threads [ i ] ; \nif ( thread . isSuspended ( ) ) return ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6371": "public class RuleCompletionProcessor { \nprivate boolean isSubtypeOf ( String class1 , String class2 ) { \nif ( class1 == null || class2 == null ) return false ; \nclass1 = convertToNonPrimitiveClass ( class1 ) ; \nclass2 = convertToNonPrimitiveClass ( class2 ) ; \nClassTypeResolver resolver = new ClassTypeResolver ( getUniqueImports ( ) , ProjectClassLoader . getProjectClassLoader ( getEditor ( ) ) ) ; \ntry { \nClass < ? > clazz1 = resolver . resolveType ( class1 ) ; \nClass < ? > clazz2 = resolver . resolveType ( class2 ) ; \nif ( clazz1 == null || clazz2 == null ) return false ; \nreturn clazz2 . isAssignableFrom ( clazz1 ) ; \n} \ncatch ( ClassNotFoundException exc ) { \nreturn false ; \n} \n} \n} \n"}
{"6372": "public class RuleCompletionProcessor { \npublic static boolean containsProposal ( final Collection < ICompletionProposal > proposals , String newProposal ) { \nfor ( ICompletionProposal prop : proposals ) { \nString displayString = prop . getDisplayString ( ) ; \nString [ ] existings = displayString . split ( \" \" ) ; \nif ( existings . length == 0 ) continue ; \nString [ ] newProposals = newProposal . split ( \" \" ) ; \nif ( newProposals . length == 0 ) continue ; \nif ( existings [ 0 ] . equals ( newProposals [ 0 ] ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6374": "public class RequestInputStream { \npublic void reset ( ) throws IOException { \nif ( file == null ) ( ( ByteArrayInputStream ) is ) . reset ( ) ; \nelse { \nif ( fos != null ) { \nwhile ( skip ( 4096 ) > 0 ) ; \nfos . close ( ) ; \nfos = null ; \nif ( length == - 1 ) length = totalBytesRead ; \n} \nis . close ( ) ; \nis = new FileInputStream ( file ) ; \n} \ntotalBytesRead = 0 ; \n} \n} \n"}
{"6376": "public class GraphicalVertex { \npublic void addConnection ( Connection conn ) { \nif ( conn == null || conn . getSource ( ) == conn . getTarget ( ) ) throw new IllegalArgumentException ( ) ; \nif ( conn . getSource ( ) == this ) { \nsourceConnections . add ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse if ( conn . getTarget ( ) == this ) { \ntargetConnections . add ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n"}
{"6377": "public class GraphicalVertex { \npublic Object getPropertyValue ( Object propertyId ) { \nif ( XPOS_PROP . equals ( propertyId ) ) return Integer . toString ( location . x ) ; \nif ( YPOS_PROP . equals ( propertyId ) ) return Integer . toString ( location . y ) ; \nif ( HEIGHT_PROP . equals ( propertyId ) ) return Integer . toString ( size . height ) ; \nif ( WIDTH_PROP . equals ( propertyId ) ) return Integer . toString ( size . width ) ; \nreturn null ; \n} \n} \n"}
{"6378": "public class GraphicalVertex { \npublic void removeConnection ( Connection conn ) { \nif ( conn == null ) throw new IllegalArgumentException ( ) ; \nif ( conn . getSource ( ) == this ) { \nsourceConnections . remove ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse if ( conn . getTarget ( ) == this ) { \ntargetConnections . remove ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n"}
{"6379": "public class GraphicalVertex { \npublic void setLocation ( Point newLocation ) { \nif ( newLocation == null ) throw new IllegalArgumentException ( ) ; \nlocation . setLocation ( newLocation ) ; \nfirePropertyChange ( LOCATION_PROP , null , location ) ; \n} \n} \n"}
{"6382": "public class GraphicalVertex { \npublic static String dumpConstraints ( final Constraint [ ] constraints ) { \nif ( constraints == null ) return null ; \nfinal StringBuffer buffer = new StringBuffer ( ) ; \nfor ( int i = 0 , length = constraints . length ; \ni < length ; \ni ++ ) buffer . append ( constraints [ i ] . toString ( ) + \"<br>\" ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"6386": "public class DroolsEclipsePlugin { \npublic void start ( BundleContext context ) throws Exception { \nsuper . start ( context ) ; \nIPreferenceStore preferenceStore = getPreferenceStore ( ) ; \nuseCachePreference = preferenceStore . getBoolean ( IDroolsConstants . CACHE_PARSED_RULES ) ; \npreferenceStore . addPropertyChangeListener ( new IPropertyChangeListener ( ) { \npublic void propertyChange ( PropertyChangeEvent event ) { \nif ( IDroolsConstants . CACHE_PARSED_RULES . equals ( event . getProperty ( ) ) ) { \nuseCachePreference = ( ( Boolean ) event . getNewValue ( ) ) . booleanValue ( ) ; \nif ( ! useCachePreference ) clearCache ( ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \nfor ( int i = 0 ; \ni < patterns . length ; \ni ++ ) if ( setDateTime ( date , patterns [ i ] ) ) break ; \n} \n} \n"}
{"6395": "public class FieldEditorPropertyPage { \nprotected void addField ( FieldEditor editor ) { \nif ( fields == null ) fields = new ArrayList < FieldEditor > ( ) ; \nString name = editor . getPreferenceName ( ) ; \neditor . setPreferenceName ( getPreferenceName ( name ) ) ; \nfields . add ( editor ) ; \n} \n} \n"}
{"6396": "public class FieldEditorPropertyPage { \nprotected void adjustGridLayout ( ) { \nint numColumns = calcNumberOfColumns ( ) ; \n( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; \nif ( fields != null ) for ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nFieldEditor fieldEditor = fields . get ( i ) ; \nfieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; \n} \n} \n} \n"}
{"6397": "public class FieldEditorPropertyPage { \nprotected void applyFont ( ) { \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nwhile ( e . hasNext ( ) ) FieldEditor pe = e . next ( ) ; \n} \n} \n} \n"}
{"6403": "public class CompletionContext { \nprivate void determineDialect ( String backText ) { \ndialect = null ; \nboolean mvel = MVEL_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nboolean java = JAVA_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nif ( mvel ) dialect = MVEL_DIALECT ; \nelse if ( java ) dialect = JAVA_DIALECT ; \n} \n} \n"}
{"6411": "public class Node { \npublic Node addChild ( Node n ) { \nif ( ! this . children . containsKey ( n . getToken ( ) ) ) { \nthis . children . put ( n . getToken ( ) , n ) ; \nn . setParent ( this ) ; \nreturn n ; \n} \nelse return ( Node ) this . children . get ( n . getToken ( ) ) ; \n} \n} \n"}
{"6413": "public class Precondition { \npublic void addCondition ( Condition condition ) throws WebDAVException { \nEnumeration conditions = getConditions ( ) ; \nif ( condition . getResourceURI ( ) != null ) while ( conditions . hasMoreElements ( ) ) { \nCondition existingCondition = ( Condition ) conditions . nextElement ( ) ; \nif ( existingCondition . getResourceURI ( ) != null && existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMultipleSpecification\" , condition . getResourceURI ( ) ) ) ; \n} \nthis . conditions . addElement ( condition ) ; \n} \n} \n"}
{"6419": "public class DSLRuleCompletionProcessor { \npublic String getLastLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) if ( line . length ( ) > 0 ) last = line ; \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( last . indexOf ( \"(\" ) > - 1 ) last = last . substring ( last . lastIndexOf ( \"(\" ) + 1 ) ; \nif ( last . indexOf ( \",\" ) > - 1 ) last = last . substring ( last . lastIndexOf ( \",\" ) + 1 ) ; \nif ( last . endsWith ( \")\" ) ) last = \"\" ; \nreturn last ; \n} \n} \n"}
{"6420": "public class DSLRuleCompletionProcessor { \npublic String getLastNonDashLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) { \nline = line . trim ( ) ; \nif ( line . length ( ) > 0 && ! line . startsWith ( \"-\" ) ) last = line ; \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( last . indexOf ( \"(\" ) > - 1 && ! last . endsWith ( \")\" ) ) last = last . substring ( 0 , last . indexOf ( \"(\" ) ) ; \nelse if ( last . indexOf ( \"(\" ) > - 1 && last . endsWith ( \")\" ) ) last = \"\" ; \nreturn last ; \n} \n} \n"}
{"6424": "public class NewJBPMProjectWizard { \nprivate void createProcess ( IJavaProject project , IProgressMonitor monitor , String exampleType ) throws CoreException , IOException { \nString fileName = \"org/jbpm/eclipse/wizard/project/\" + exampleType + \".bpmn.template\" ; \nIFolder folder = null ; \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/com/sample\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \nIFile file = folder . getFile ( \"sample.bpmn\" ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \nif ( ! file . exists ( ) ) file . create ( inputstream , true , monitor ) ; \nelse file . setContents ( inputstream , true , false , monitor ) ; \nfileName = \"org/jbpm/eclipse/wizard/project/ProcessMain-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) fileName += \".v5.template\" ; \nelse fileName += \".template\" ; \nfolder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \npackageFragment . createCompilationUnit ( \"ProcessMain.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) if ( \"advanced\" . equals ( exampleType ) ) { \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/META-INF\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( \"org/jbpm/eclipse/wizard/project/ProcessLauncher-advanced-persistence.xml.template\" ) ; \nfile = folder . getFile ( \"persistence.xml\" ) ; \nif ( ! file . exists ( ) ) file . create ( inputstream , true , monitor ) ; \nelse file . setContents ( inputstream , true , false , monitor ) ; \n} \n} \n} \n"}
{"6425": "public class NewJBPMProjectWizard { \nprivate void createProcessSampleJUnit ( IJavaProject project , String exampleType , IProgressMonitor monitor ) throws JavaModelException , IOException { \nString s = \"org/jbpm/eclipse/wizard/project/ProcessJUnit-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) s += \".v5.template\" ; \nelse s += \".template\" ; \nIFolder folder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( s ) ; \npackageFragment . createCompilationUnit ( \"ProcessTest.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \n} \n} \n"}
{"6438": "public class KieServiceDelegate { \nprotected String httpDelete ( String request ) throws IOException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . println ( \"[DELETE] \" + url . toString ( ) ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setRequestMethod ( \"DELETE\" ) ; \nconn . setRequestProperty ( \"Content\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . println ( \"[DELETE] response: \" + response ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) throw new IOException ( \"HTTP DELETE failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null && ! status . isEmpty ( ) ) if ( ! \"APPROVED\" . equals ( status ) ) throw new IOException ( \"HTTP DELETE failed : Request status code : \" + status ) ; \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null && ! jobId . isEmpty ( ) ) return jobId ; \nreturn response ; \n} \n} \n"}
{"6439": "public class KieServiceDelegate { \nprotected String httpPost ( String request , JsonObject body ) throws IOException , RuntimeException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . println ( \"[POST] \" + url . toString ( ) + \" body: \" + body ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setDoOutput ( body != null ) ; \nconn . setRequestMethod ( \"POST\" ) ; \nconn . setRequestProperty ( \"Content-Type\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nif ( body != null ) { \njava . io . OutputStream os = conn . getOutputStream ( ) ; \nWriter writer = new OutputStreamWriter ( os , \"UTF-8\" ) ; \nbody . writeTo ( writer ) ; \nwriter . close ( ) ; \nos . flush ( ) ; \n} \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . println ( \"[POST] response: \" + response ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) throw new IOException ( \"HTTP POST failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null && ! status . isEmpty ( ) ) if ( ! \"APPROVED\" . equals ( status ) ) throw new IOException ( \"HTTP POST failed : Request status code : \" + status ) ; \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null && ! jobId . isEmpty ( ) ) return jobId ; \nreturn response ; \n} \n} \n"}
{"6440": "public class KieServiceDelegate { \npublic String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { \nfinal AtomicReference < String > ar = new AtomicReference < String > ( ) ; \nIWorkbench wb = PlatformUI . getWorkbench ( ) ; \nIProgressService ps = wb . getProgressService ( ) ; \ntry { \nps . busyCursorWhile ( new IRunnableWithProgress ( ) { \npublic void run ( IProgressMonitor pm ) throws InterruptedException { \npm . beginTask ( \"Waiting for Job \" + jobId + \":\\n\\n\" + title , STATUS_REQUEST_TIMEOUT ) ; \npm . subTask ( title ) ; \nlong startTime = System . currentTimeMillis ( ) ; \nlong stopTime = startTime ; \ndo { \ntry { \nThread . sleep ( STATUS_REQUEST_DELAY ) ; \nString response = httpGet ( \"jobs/\" + jobId ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nString result = jo . get ( \"result\" ) . asString ( ) ; \nif ( \"null\" . equals ( result ) ) if ( ! \"SUCCESS\" . equals ( status ) ) result = null ; \nif ( status != null && result != null ) ar . set ( status + \":\" + result ) ; \nstopTime = System . currentTimeMillis ( ) ; \npm . worked ( STATUS_REQUEST_DELAY ) ; \nActivator . println ( \"status=\" + status ) ; \nActivator . println ( \"result=\" + result ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nif ( pm . isCanceled ( ) ) throw new InterruptedException ( \"Operation canceled\" ) ; \n} \nwhile ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; \npm . done ( ) ; \nActivator . println ( \"\\n----------------------------------\\n\" + \"Job \" + jobId + \"\\n\" + title + \"\\ncompleted in \" + ( stopTime - startTime ) / 1000.0 + \" sec\\n\" + \"Status: \" + ar . get ( ) + \"\\n----------------------------------\\n\" ) ; \n} \n} \n) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \nreturn ar . get ( ) ; \n} \n} \n"}
{"6445": "public class AbstractCompletionProcessor { \nprotected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { \nif ( prefix != null && prefix . trim ( ) . length ( ) > 0 ) { \nIterator < ICompletionProposal > iterator = props . iterator ( ) ; \nString prefixLc = prefix . toLowerCase ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nICompletionProposal item = iterator . next ( ) ; \nString content = item . getDisplayString ( ) . toLowerCase ( ) ; \nif ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) iterator . remove ( ) ; \n} \n} \n} \n} \n"}
{"6449": "public class VertexEditPartFactory { \nprivate EditPart getPartForElement ( Object modelElement ) { \nif ( modelElement instanceof ReteGraph ) return new DiagramEditPart ( ) ; \nif ( modelElement instanceof BaseVertex ) return new VertexEditPart ( ) ; \nif ( modelElement instanceof Connection ) return new ConnectionEditPart ( ) ; \nDroolsEclipsePlugin . log ( new Exception ( \"Can't create part for model element: \" + ( ( modelElement != null ) ? modelElement . getClass ( ) . getName ( ) : \"null\" ) ) ) ; \nreturn null ; \n} \n} \n"}
{"6452": "public class RowList { \npublic void add ( final int depth , final BaseVertex vertex ) { \nif ( this . rows . size ( ) < ( depth + 1 ) ) { \nfinal int addRows = depth - this . rows . size ( ) + 1 ; \nfor ( int i = 0 ; \ni < addRows ; \n++ i ) this . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; \n} \n( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; \n} \n} \n"}
{"6453": "public class RowList { \npublic int getRow ( final BaseVertex vertex ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \n++ i ) if ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"6454": "public class RowList { \npublic int getWidth ( ) { \nint width = 0 ; \nfor ( final Iterator < Row > rowIter = this . rows . iterator ( ) ; \nrowIter . hasNext ( ) ; \n) { \nfinal Row row = rowIter . next ( ) ; \nfinal int rowWidth = row . getWidth ( ) ; \nif ( rowWidth > width ) width = rowWidth ; \n} \nreturn width ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \n++ i ) System . err . println ( i + \": \" + get ( i ) . getVertices ( ) ) ; \n} \n} \n"}
{"6456": "public class RowList { \npublic void optimize ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \n++ i ) get ( i ) . optimize ( ) ; \n} \n} \n"}
{"6457": "public class ReteViewer { \npublic ReteGraph loadReteModel ( IProgressMonitor monitor , String contents ) throws Throwable { \nif ( relayoutRequired == false ) return diagram ; \nReteGraph newDiagram = new ReteGraph ( ) ; \ntry { \nmonitor . beginTask ( \"Loading RETE Tree\" , 100 ) ; \nmonitor . subTask ( \"Loading Rule Base\" ) ; \nInternalKnowledgeBase ruleBase = null ; \ntry { \nIResource resource = drlEditor . getResource ( ) ; \nClassLoader newLoader = DroolsBuilder . class . getClassLoader ( ) ; \nif ( resource . getProject ( ) . getNature ( \"org.eclipse.jdt.core.javanature\" ) != null ) { \nIJavaProject project = JavaCore . create ( resource . getProject ( ) ) ; \nnewLoader = ProjectClassLoader . getProjectClassLoader ( project ) ; \n} \nDRLInfo drlInfo = DroolsEclipsePlugin . getDefault ( ) . parseResource ( drlEditor , true , true ) ; \nif ( drlInfo == null ) throw new Exception ( \"Could not find DRL info\" ) ; \nif ( drlInfo . getBuilderErrors ( ) . length > 0 ) throw new Exception ( drlInfo . getBuilderErrors ( ) . length + \" build errors\" ) ; \nif ( drlInfo . getParserErrors ( ) . size ( ) > 0 ) throw new Exception ( drlInfo . getParserErrors ( ) . size ( ) + \" parser errors\" ) ; \nInternalKnowledgePackage pkg = drlInfo . getPackage ( ) ; \nRuleBaseConfiguration config = new RuleBaseConfiguration ( ) ; \nconfig . setClassLoader ( newLoader ) ; \nruleBase = KnowledgeBaseFactory . newKnowledgeBase ( config ) ; \nif ( pkg != null ) ruleBase . addPackage ( pkg ) ; \n} \ncatch ( Throwable t ) { \nDroolsEclipsePlugin . log ( t ) ; \nthrow new Exception ( MSG_PARSE_ERROR + \" \" + t . getMessage ( ) ) ; \n} \nmonitor . worked ( 50 ) ; \nif ( monitor . isCanceled ( ) ) throw new InterruptedException ( ) ; \nmonitor . subTask ( \"Building RETE Tree\" ) ; \nfinal ReteooVisitor visitor = new ReteooVisitor ( newDiagram ) ; \nvisitor . visitInternalKnowledgeBase ( ruleBase ) ; \nmonitor . worked ( 30 ) ; \nif ( monitor . isCanceled ( ) ) throw new InterruptedException ( ) ; \nmonitor . subTask ( \"Calculating RETE Tree Layout\" ) ; \nBaseVertex rootVertex = visitor . getRootVertex ( ) ; \nRowList rowList = ReteooLayoutFactory . calculateReteRows ( rootVertex ) ; \nReteooLayoutFactory . layoutRowList ( newDiagram , rowList ) ; \nzeroBaseDiagram ( newDiagram ) ; \nmonitor . worked ( 20 ) ; \nif ( monitor . isCanceled ( ) ) throw new InterruptedException ( ) ; \nmonitor . done ( ) ; \n} \ncatch ( Throwable t ) { \nif ( ! ( t instanceof InterruptedException ) ) DroolsEclipsePlugin . log ( t ) ; \nthrow t ; \n} \nrelayoutRequired = false ; \nreturn newDiagram ; \n} \n} \n"}
{"6459": "public class ReteViewer { \npublic void drawGraph ( ReteGraph newGraph ) { \nLayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; \nif ( getGraphicalViewer ( ) . getContents ( ) == null ) getGraphicalViewer ( ) . setContents ( getModel ( ) ) ; \nfinal boolean isNewDiagram = newGraph != null && newGraph != diagram ; \nif ( isNewDiagram ) diagram . removeAll ( ) ; \nConnectionRouter router ; \nif ( ( isNewDiagram && newGraph . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) || ( ! isNewDiagram && getModel ( ) . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) ) router = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; \nelse router = ConnectionRouter . NULL ; \nconnLayer . setConnectionRouter ( router ) ; \nif ( newGraph != null && newGraph != diagram ) diagram . addAll ( newGraph . getChildren ( ) ) ; \n} \n} \n"}
{"6460": "public class DroolsDebugTarget { \npublic DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { \nif ( source == null ) return null ; \nIterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nIJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; \nif ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( \"mvel\" ) ) { \nDroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; \ntry { \nint matchLine = l . getLineNumber ( ) ; \nString matchSource = l . getRuleName ( ) ; \nif ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) return l ; \n} \ncatch ( CoreException e ) { \nlogError ( e ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6471": "public class AbstractResourceHandle { \npublic void move ( ILocator destination , boolean overwrite , Enumeration names ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( names == null ) propertyBehavior . setIsKeepAllAlive ( true ) ; \nelse while ( names . hasMoreElements ( ) ) { \nObject obj = names . nextElement ( ) ; \nAssert . isTrue ( obj instanceof QualifiedName , Policy . bind ( \"assert.propNameMustBeEnumOverQual\" ) ) ; \npropertyBehavior . addProperty ( ( ( QualifiedName ) obj ) . getLocalName ( ) ) ; \n} \nIResponse response = null ; \ntry { \nresponse = davClient . move ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6485": "public class Request { \npublic void write ( OutputStream os ) throws IOException { \nif ( requestBodyWriter == null ) { \nif ( inputRead ) { \nis . reset ( ) ; \ninputRead = false ; \n} \nsuper . write ( os ) ; \n} \nelse requestBodyWriter . writeRequestBody ( os ) ; \n} \n} \n"}
{"6488": "public class PropFind { \npublic void setIsAllProp ( boolean isAllProp ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyAllProp = isDAVElement ( child , \"allprop\" ) ; \nif ( isAllProp ) if ( ! isAlreadyAllProp ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"allprop\" ) ; \n} \nelse if ( isAlreadyAllProp ) root . removeChild ( child ) ; \n} \n} \n"}
{"6489": "public class PropFind { \npublic void setIsPropName ( boolean isPropName ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyPropName = isDAVElement ( child , \"propname\" ) ; \nif ( isPropName ) if ( ! isAlreadyPropName ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"propname\" ) ; \n} \nelse if ( isAlreadyPropName ) root . removeChild ( child ) ; \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) return prefix ; \nif ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) return \"\" ; \nelse { \nchar [ ] c = prefix . toCharArray ( ) ; \nint start = 0 ; \nfor ( int i = c . length - 1 ; \ni >= 0 ; \ni -- ) if ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nint bytesRead = 0 ; \nint totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nwhile ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { \nif ( contentLength == - 1 ) bytesRead = is . read ( buffer ) ; \nelse bytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \nif ( bytesRead == - 1 ) if ( contentLength >= 0 ) throw new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \nelse { \ntotalBytesRead += bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \n} \n} \n"}
{"6494": "public class DroolsThread { \npublic synchronized void stepOver ( ) throws DebugException { \nif ( ! ( getTopStackFrame ( ) instanceof MVELStackFrame ) ) { \nsuper . stepOver ( ) ; \nreturn ; \n} \nMVELStackFrame mvelStack = ( MVELStackFrame ) getTopStackFrame ( ) ; \nif ( ! canStepOver ( ) || ! mvelStack . canStepOver ( ) ) return ; \nif ( ! setRemoteOnBreakReturn ( Debugger . STEP ) ) return ; \nsetRunning ( true ) ; \npreserveStackFrames ( ) ; \nfireEvent ( new DebugEvent ( this , DebugEvent . RESUME , DebugEvent . STEP_OVER ) ) ; \ntry { \ngetUnderlyingThread ( ) . resume ( ) ; \n} \ncatch ( RuntimeException e ) { \ntargetRequestFailed ( MessageFormat . format ( JDIDebugModelMessages . JDIThread_exception_stepping , e . toString ( ) ) , e ) ; \n} \n} \n} \n"}
{"6495": "public class DroolsBuilder { \nprotected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { \nfor ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nObject error = iter . next ( ) ; \nif ( error instanceof ParserError ) { \nParserError err = ( ParserError ) error ; \nmarkers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; \n} \nelse if ( error instanceof KnowledgeBuilderResult ) { \nKnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; \nint [ ] errorLines = res . getLines ( ) ; \nmarkers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; \n} \nelse if ( error instanceof ExpanderException ) { \nExpanderException exc = ( ExpanderException ) error ; \nmarkers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; \n} \nelse markers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; \n} \n} \n} \n"}
{"6497": "public class GuvnorMetadataUtils { \npublic static boolean addResourceToGuvnor ( String repLoc , String targetLoc , IFile selectedFile ) { \nboolean res = false ; \ntry { \nString fullPath = targetLoc + selectedFile . getName ( ) ; \nIWebDavClient client = WebDavServerCache . getWebDavClient ( repLoc ) ; \nif ( client == null ) { \nclient = WebDavClientFactory . createClient ( new URL ( repLoc ) ) ; \nWebDavServerCache . cacheWebDavClient ( repLoc , client ) ; \n} \ntry { \nres = client . createResource ( fullPath , new ByteArrayInputStream ( new byte [ 0 ] ) , false ) ; \nif ( res ) client . putResource ( fullPath , selectedFile . getContents ( ) ) ; \n} \ncatch ( WebDavException wde ) { \nif ( wde . getErrorCode ( ) != IResponse . SC_UNAUTHORIZED ) throw wde ; \nboolean retry = PlatformUtils . getInstance ( ) . authenticateForServer ( repLoc , client ) ; \nif ( retry ) { \nres = client . createResource ( fullPath , new ByteArrayInputStream ( new byte [ 0 ] ) , false ) ; \nif ( res ) client . putResource ( fullPath , selectedFile . getContents ( ) ) ; \n} \n} \nif ( res ) { \nGuvnorMetadataUtils . markCurrentGuvnorResource ( selectedFile ) ; \nResourceProperties resProps = client . queryProperties ( fullPath ) ; \nGuvnorMetadataProps mdProps = new GuvnorMetadataProps ( selectedFile . getName ( ) , repLoc , fullPath , resProps . getLastModifiedDate ( ) , resProps . getRevision ( ) ) ; \nGuvnorMetadataUtils . setGuvnorMetadataProps ( selectedFile . getFullPath ( ) , mdProps ) ; \n} \n} \ncatch ( Exception e ) { \nActivator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; \n} \nreturn res ; \n} \n} \n"}
{"6498": "public class GuvnorMetadataUtils { \npublic static void commitFileChanges ( IFile selectedFile ) { \ntry { \nGuvnorMetadataProps props = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; \nIWebDavClient client = WebDavServerCache . getWebDavClient ( props . getRepository ( ) ) ; \nif ( client == null ) { \nclient = WebDavClientFactory . createClient ( new URL ( props . getRepository ( ) ) ) ; \nWebDavServerCache . cacheWebDavClient ( props . getRepository ( ) , client ) ; \n} \nResourceProperties remoteProps = null ; \ntry { \nremoteProps = client . queryProperties ( props . getFullpath ( ) ) ; \n} \ncatch ( WebDavException wde ) { \nif ( wde . getErrorCode ( ) != IResponse . SC_UNAUTHORIZED ) throw wde ; \nboolean retry = PlatformUtils . getInstance ( ) . authenticateForServer ( props . getRepository ( ) , client ) ; \nif ( retry ) remoteProps = client . queryProperties ( props . getFullpath ( ) ) ; \n} \nif ( remoteProps == null ) throw new Exception ( \"Could not retrieve server version of \" + props . getFullpath ( ) ) ; \nboolean proceed = true ; \nif ( ! props . getRevision ( ) . equals ( remoteProps . getRevision ( ) ) ) { \nString msg = MessageFormat . format ( Messages . getString ( \"overwrite.confirmation\" ) , new Object [ ] { \nselectedFile . getName ( ) , remoteProps . getRevision ( ) , props . getRevision ( ) } \n) ; \nDisplay display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; \nproceed = MessageDialog . openQuestion ( display . getActiveShell ( ) , Messages . getString ( \"overwrite.confirmation.caption\" ) , msg ) ; \n} \nif ( proceed ) { \nclient . putResource ( props . getFullpath ( ) , selectedFile . getContents ( ) ) ; \nGuvnorMetadataUtils . markCurrentGuvnorResource ( selectedFile ) ; \nResourceProperties resProps = client . queryProperties ( props . getFullpath ( ) ) ; \nGuvnorMetadataProps mdProps = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; \nmdProps . setVersion ( resProps . getLastModifiedDate ( ) ) ; \nmdProps . setRevision ( resProps . getRevision ( ) ) ; \nGuvnorMetadataUtils . setGuvnorMetadataProps ( selectedFile . getFullPath ( ) , mdProps ) ; \n} \n} \ncatch ( Exception e ) { \nActivator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; \n} \n} \n} \n"}
{"6509": "public class DSLTree { \nprotected String getObjMetadata ( String text ) { \nif ( text . startsWith ( \"[\" ) ) return text . substring ( 1 , text . lastIndexOf ( \"]\" ) ) ; \nelse return \"\" ; \n} \n} \n"}
{"6510": "public class DSLTree { \nprotected String stripObjMetadata ( String text ) { \nif ( text . startsWith ( \"[\" ) ) return text . substring ( text . lastIndexOf ( \"]\" ) + 1 ) ; \nelse return text ; \n} \n} \n"}
{"6512": "public class DSLTree { \npublic Node [ ] getConditionChildren ( String text ) { \nNode thenode = this . rootCond ; \nif ( text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) thenode = ch ; \nelse break ; \n} \nif ( thenode != this . rootCond ) this . current = thenode ; \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6513": "public class DSLTree { \npublic Node [ ] getChildren ( String obj , String text ) { \nNode thenode = this . rootCond . getChild ( obj ) ; \nif ( thenode == null ) for ( Node child : this . rootCond . getChildren ( ) ) { \nString tokenText = child . getToken ( ) ; \nif ( tokenText != null ) { \nint index = tokenText . indexOf ( \"{\" ) ; \nif ( index != - 1 ) { \nString substring = tokenText . substring ( 0 , index ) ; \nif ( obj != null && obj . startsWith ( substring ) ) thenode = child ; \n} \n} \n} \nif ( thenode != null && text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) thenode = ch ; \nelse break ; \n} \nif ( thenode != this . rootCond ) this . current = thenode ; \n} \nif ( thenode == null ) return null ; \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6514": "public class DSLTree { \npublic void addChildToList ( Node n , String prefix , ArrayList < String > list ) { \nif ( n . getChildren ( ) . size ( ) > 0 ) for ( Node child : n . getChildren ( ) ) { \nif ( prefix != null && \"-\" . equals ( child . getToken ( ) ) ) { \nif ( ! list . contains ( prefix ) ) list . add ( prefix ) ; \nreturn ; \n} \nString text = ( prefix == null ? \"\" : prefix + \" \" ) + child . getToken ( ) ; \naddChildToList ( child , text , list ) ; \n} \nelse if ( ! list . contains ( prefix ) ) list . add ( prefix ) ; \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \nfor ( int idx = 0 ; \nidx < count ; \nidx ++ ) System . out . print ( tab ) ; \n} \n} \n"}
{"6520": "public class HttpClient { \npublic Response invoke ( Request request ) throws IOException { \nAssert . isNotNull ( request ) ; \ntry { \nopen ( ) ; \nURL resourceUrl = request . getResourceUrl ( ) ; \nURL originServerUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , \"/\" ) ; \nURL proxyServerUrl = getProxyServerUrl ( originServerUrl ) ; \nif ( proxyServerUrl == null && ! matchesProxyServerException ( originServerUrl ) ) proxyServerUrl = getDefaultProxyServerUrl ( ) ; \nIContext context = webDAVFactory . newContext ( request . getContext ( ) ) ; \nIContext defaultContext = getContext ( originServerUrl ) ; \nif ( defaultContext == null ) defaultContext = getDefaultContext ( ) ; \nif ( defaultContext != null ) { \nEnumeration e = defaultContext . keys ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nString key = ( String ) e . nextElement ( ) ; \ncontext . put ( key , defaultContext . get ( key ) ) ; \n} \n} \nif ( authority != null ) { \nauthority . authorize ( request , null , context , proxyServerUrl , true ) ; \nauthority . authorize ( request , null , context , proxyServerUrl , false ) ; \n} \nreturn invoke1 ( request , context , proxyServerUrl , originServerUrl , 0 , 0 ) ; \n} \nfinally { \nrequest . close ( ) ; \n} \n} \n} \n"}
{"6522": "public class NewDroolsProjectWizard { \nprivate void createRuleSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) createProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template\" , \"DroolsTest.java\" ) ; \nelse if ( version . getMajor ( ) == 5 ) createProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template\" , \"DroolsTest.java\" ) ; \nelse if ( version . getMajor ( ) >= 6 ) createProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template\" , \"DroolsTest.java\" ) ; \n} \n} \n"}
{"6523": "public class NewDroolsProjectWizard { \nprivate void createRule ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nif ( startPage . getRuntime ( ) . getVersion ( ) . getMajor ( ) >= 6 ) { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/rules\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/resources/com/sample/rules\" , \"Sample.drl\" ) ; \n} \nelse createProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/rules\" , \"Sample.drl\" ) ; \n} \n} \n"}
{"6524": "public class NewDroolsProjectWizard { \nprivate void createRuleFlow ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rfm.template\" , \"src/main/rules\" , \"ruleflow.rfm\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.drl.template\" , \"src/main/rules\" , \"ruleflow.drl\" ) ; \n} \nelse if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) createProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \nelse if ( version . getMajor ( ) == 5 ) createProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/rules\" , \"sample.bpmn\" ) ; \nelse { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/process\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/resources/com/sample/process\" , \"sample.bpmn\" ) ; \n} \n} \n} \n"}
{"6525": "public class NewDroolsProjectWizard { \nprivate void createRuleFlowSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nString s ; \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) s = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample_4.java.template\" ; \nelse if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) s = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample.java.template\" ; \nelse if ( version . getMajor ( ) == 5 ) s = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_5.java.template\" ; \nelse s = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_6.java.template\" ; \ncreateProjectJavaFile ( project , s , \"ProcessTest.java\" ) ; \n} \n} \n"}
{"6527": "public class GenericModelEditor { \npublic void createImage ( OutputStream stream , int format ) { \nSWTGraphics g = null ; \nGC gc = null ; \nImage image = null ; \nLayerManager layerManager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nIFigure figure = layerManager . getLayer ( LayerConstants . PRINTABLE_LAYERS ) ; \nRectangle r = figure . getBounds ( ) ; \ntry { \nimage = new Image ( Display . getDefault ( ) , r . width , r . height ) ; \ngc = new GC ( image ) ; \ng = new SWTGraphics ( gc ) ; \ng . translate ( r . x * - 1 , r . y * - 1 ) ; \nfigure . paint ( g ) ; \nImageLoader imageLoader = new ImageLoader ( ) ; \nimageLoader . data = new ImageData [ ] { \nimage . getImageData ( ) } \n; \nimageLoader . save ( stream , format ) ; \n} \ncatch ( Throwable t ) { \nDroolsEclipsePlugin . log ( t ) ; \n} \nfinally { \nif ( g != null ) g . dispose ( ) ; \nif ( gc != null ) gc . dispose ( ) ; \nif ( image != null ) image . dispose ( ) ; \n} \n} \n} \n"}
{"6528": "public class AlphaNodeVertex { \npublic String getFieldName ( ) { \nAlphaNodeFieldConstraint constraint = this . node . getConstraint ( ) ; \nif ( constraint instanceof MvelConstraint ) { \nMvelConstraint mvelConstraint = ( MvelConstraint ) constraint ; \nInternalReadAccessor accessor = mvelConstraint . getFieldExtractor ( ) ; \nif ( accessor instanceof ClassFieldReader ) return ( ( ClassFieldReader ) accessor ) . getFieldName ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"6531": "public class WebDavClient { \nprivate void addGuvnorResourceProperties ( ResourceProperties props , String filename , String resource ) throws Exception { \nif ( props == null ) return ; \nIResponse response = null ; \ntry { \nString path = resource . substring ( 0 , resource . lastIndexOf ( '/' ) ) ; \nString apiVer = changeToAPICall ( path ) ; \nProperties guvProps = new Properties ( ) ; \nresponse = getResourceInputStream ( apiVer ) ; \nguvProps . load ( response . getInputStream ( ) ) ; \nString val = guvProps . getProperty ( filename ) ; \nif ( val != null ) { \nStringTokenizer tokens = new StringTokenizer ( val , \",\" ) ; \nif ( tokens . hasMoreElements ( ) ) props . setLastModifiedDate ( tokens . nextToken ( ) ) ; \nif ( tokens . hasMoreElements ( ) ) props . setRevision ( tokens . nextToken ( ) ) ; \n} \nelse { \nException nfe = new Exception ( \"Failed to get Guvnor properties for \" + filename ) ; \nActivator . getDefault ( ) . writeLog ( IStatus . WARNING , nfe . getMessage ( ) , nfe ) ; \n} \n} \nfinally { \nif ( response != null ) response . close ( ) ; \n} \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nint v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nint v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v1OutDegree < v2OutDegree ) return 1 ; \nif ( v1OutDegree > v2OutDegree ) return - 1 ; \nreturn 0 ; \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \nfor ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nvertexIter . hasNext ( ) ; \n) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( front ) optimized . addFirst ( vertex ) ; \nelse optimized . addLast ( vertex ) ; \nfront = ! front ; \n} \nthis . vertices = optimized ; \n} \n} \n"}
{"6536": "public class ExportImageDialog { \nprivate void initializeControls ( ) { \nif ( originalFile != null ) { \nresourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; \nString fileName = originalFile . getName ( ) ; \nint index = fileName . lastIndexOf ( \".\" ) ; \nif ( index != - 1 ) fileName = fileName . substring ( 0 , index ) ; \nfileName += \"-image.png\" ; \nresourceGroup . setResource ( fileName ) ; \n} \nelse if ( originalName != null ) resourceGroup . setResource ( originalName ) ; \nsetDialogComplete ( validatePage ( ) ) ; \n} \n} \n"}
{"6537": "public class ExportImageDialog { \nprivate boolean validatePage ( ) { \nif ( ! resourceGroup . areAllValuesValid ( ) ) { \nif ( ! resourceGroup . getResource ( ) . equals ( \"\" ) ) setErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; \nelse setErrorMessage ( null ) ; \nreturn false ; \n} \nString resourceName = resourceGroup . getResource ( ) ; \nIWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; \nIPath fullPath = resourceGroup . getContainerFullPath ( ) ; \nif ( fullPath != null ) { \nString projectName = fullPath . segment ( 0 ) ; \nIStatus isValidProjectName = workspace . validateName ( projectName , IResource . PROJECT ) ; \nif ( isValidProjectName . isOK ( ) ) { \nIProject project = workspace . getRoot ( ) . getProject ( projectName ) ; \nif ( ! project . isOpen ( ) ) { \nsetErrorMessage ( IDEWorkbenchMessages . SaveAsDialog_closedProjectMessage ) ; \nreturn false ; \n} \n} \n} \nIStatus result = workspace . validateName ( resourceName , IResource . FILE ) ; \nif ( ! result . isOK ( ) ) { \nsetErrorMessage ( result . getMessage ( ) ) ; \nreturn false ; \n} \nsetErrorMessage ( null ) ; \nreturn true ; \n} \n} \n"}
{"6539": "public class Connection { \npublic BaseVertex getOpposite ( BaseVertex vertex ) { \nif ( vertex == null || ( ! vertex . equals ( getSource ( ) ) && ! vertex . equals ( getTarget ( ) ) ) ) return null ; \nif ( vertex . equals ( getSource ( ) ) ) return getTarget ( ) ; \nreturn getSource ( ) ; \n} \n} \n"}
{"6540": "public class YubikeyLoginModule { \nprivate boolean validate_otps ( List < String > otps , NameCallback nameCb ) throws LoginException { \nboolean validated = false ; \nfor ( String otp : otps ) { \nlog . trace ( \"Checking OTP {}\" , otp ) ; \nVerificationResponse ykr ; \ntry { \nykr = this . yc . verify ( otp ) ; \n} \ncatch ( YubicoVerificationException e ) { \nlog . warn ( \"Errors during validation: \" , e ) ; \nthrow new LoginException ( \"Errors during validation: \" + e . getMessage ( ) ) ; \n} \ncatch ( YubicoValidationFailure e ) { \nlog . warn ( \"Something went very wrong during authentication: \" , e ) ; \nthrow new LoginException ( \"Something went very wrong during authentication: \" + e . getMessage ( ) ) ; \n} \nif ( ykr != null ) { \nlog . trace ( \"OTP {} verify result : {}\" , otp , ykr . getStatus ( ) . toString ( ) ) ; \nif ( ykr . getStatus ( ) == ResponseStatus . OK ) { \nString publicId = YubicoClient . getPublicId ( otp ) ; \nlog . info ( \"OTP verified successfully (YubiKey id {})\" , publicId ) ; \nif ( is_right_user ( nameCb . getName ( ) , publicId ) ) { \nthis . principals . add ( new YubikeyPrincipal ( publicId , this . idRealm ) ) ; \nvalidated = true ; \n} \n} \nelse log . debug ( \"OTP validation returned {}\" , ykr . getStatus ( ) . toString ( ) ) ; \n} \n} \nreturn validated ; \n} \n} \n"}
{"6542": "public class YubikeyToUserMapImpl { \nprivate String get_username_for_id ( String publicId , String filename ) throws FileNotFoundException { \nScanner sc = null ; \nFile file = new File ( filename ) ; \ntry { \nsc = new Scanner ( file ) ; \nwhile ( sc . hasNextLine ( ) ) { \nString line = sc . nextLine ( ) ; \nif ( line . startsWith ( \"yk.\" + publicId + \".user\" ) ) { \nString ykuser = line . split ( \"=\" ) [ 1 ] . trim ( ) ; \nreturn ykuser ; \n} \n} \n} \nfinally { \nif ( sc != null ) sc . close ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"6544": "public class HttpOathOtpLoginModule { \nboolean verify_otp ( String userName , String otp ) { \ntry { \nString authString = userName + \":\" + otp ; \nString authStringEnc = Base64 . encodeBase64URLSafeString ( authString . getBytes ( ) ) ; \nBufferedReader in = attemptAuthentication ( authStringEnc ) ; \nString inputLine ; \nwhile ( ( inputLine = in . readLine ( ) ) != null ) if ( inputLine . contains ( expectedOutput ) ) return true ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Failed verifying OATH OTP :\" , ex ) ; \n} \nreturn false ; \n} \n} \n"}
{"6545": "public class MultiValuePasswordCallback { \npublic void clearPassword ( ) { \nfor ( char pw [ ] : this . secrets ) { \nfor ( int i = 0 ; \ni < pw . length ; \ni ++ ) pw [ i ] = 0 ; \n} \nthis . secrets = new ArrayList < char [ ] > ( ) ; \n} \n} \n"}
{"6546": "public class YubicoClient { \npublic static String getPublicId ( String otp ) { \nif ( ( otp == null ) || ( otp . length ( ) < OTP_MIN_LEN ) ) throw new IllegalArgumentException ( \"The OTP is too short to be valid\" ) ; \nInteger len = otp . length ( ) ; \nreturn otp . substring ( 0 , len - 32 ) . toLowerCase ( ) ; \n} \n} \n"}
{"6547": "public class YubicoClient { \npublic static boolean isValidOTPFormat ( String otp ) { \nif ( otp == null ) return false ; \nint len = otp . length ( ) ; \nfor ( char c : otp . toCharArray ( ) ) { \nif ( c < 0x20 || c > 0x7E ) return false ; \n} \nreturn OTP_MIN_LEN <= len && len <= OTP_MAX_LEN ; \n} \n} \n"}
{"6554": "public class OgnlRuntime { \npublic static String getUniqueDescriptor ( Object object , boolean fullyQualified ) { \nStringBuffer result = new StringBuffer ( ) ; \nif ( object != null ) { \nif ( object instanceof Proxy ) { \nClass interfaceClass = object . getClass ( ) . getInterfaces ( ) [ 0 ] ; \nresult . append ( getClassName ( interfaceClass , fullyQualified ) ) ; \nresult . append ( '^' ) ; \nobject = Proxy . getInvocationHandler ( object ) ; \n} \nresult . append ( getClassName ( object , fullyQualified ) ) ; \nresult . append ( '@' ) ; \nresult . append ( getPointerString ( object ) ) ; \n} \nelse result . append ( NULL_OBJECT_STRING ) ; \nreturn new String ( result ) ; \n} \n} \n"}
{"6557": "public class OgnlRuntime { \npublic static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { \nMethod result = null ; \nif ( methods != null ) { \nClass typeClass = target != null ? target . getClass ( ) : null ; \nif ( typeClass == null && source != null && Class . class . isInstance ( source ) ) typeClass = ( Class ) source ; \nClass [ ] argClasses = getArgClasses ( args ) ; \nMatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; \nif ( mm != null ) { \nresult = mm . mMethod ; \nClass [ ] mParameterTypes = mm . mParameterTypes ; \nSystem . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; \nfor ( int j = 0 ; \nj < mParameterTypes . length ; \nj ++ ) { \nClass type = mParameterTypes [ j ] ; \nif ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) actualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \n} \n} \nif ( result == null ) result = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; \nreturn result ; \n} \n} \n"}
{"6558": "public class OgnlRuntime { \npublic static final Object getMethodValue ( OgnlContext context , Object target , String propertyName , boolean checkAccessAndExistence ) throws OgnlException , IllegalAccessException , NoSuchMethodException , IntrospectionException { \nObject result = null ; \nMethod m = getGetMethod ( context , ( target == null ) ? null : target . getClass ( ) , propertyName ) ; \nif ( m == null ) m = getReadMethod ( ( target == null ) ? null : target . getClass ( ) , propertyName , null ) ; \nif ( checkAccessAndExistence ) if ( ( m == null ) || ! context . getMemberAccess ( ) . isAccessible ( context , target , m , propertyName ) ) result = NotFound ; \nif ( result == null ) if ( m != null ) try { \nresult = invokeMethod ( target , m , NoArguments ) ; \n} \ncatch ( InvocationTargetException ex ) { \nthrow new OgnlException ( propertyName , ex . getTargetException ( ) ) ; \n} \nelse throw new NoSuchMethodException ( propertyName ) ; \nreturn result ; \n} \n} \n"}
{"6559": "public class OgnlRuntime { \npublic static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { \nMap result ; \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) synchronized ( _propertyDescriptorCache ) { \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nPropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; \nresult = new HashMap ( 101 ) ; \nfor ( int i = 0 , icount = pda . length ; \ni < icount ; \ni ++ ) { \nif ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) pda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; \nif ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) pda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; \nresult . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; \n} \nfindObjectIndexedPropertyDescriptors ( targetClass , result ) ; \n_propertyDescriptorCache . put ( targetClass , result ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6560": "public class OgnlRuntime { \npublic static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { \nPropertyDescriptor result = null ; \nPropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; \nfor ( int i = 0 , icount = pda . length ; \n( result == null ) && ( i < icount ) ; \ni ++ ) if ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) result = pda [ i ] ; \nreturn result ; \n} \n} \n"}
{"6563": "public class OgnlParser { \nfinal public void projection ( ) throws ParseException { \nASTProject jjtn000 = new ASTProject ( JJTPROJECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse jjtree . popNode ( ) ; \nif ( jjte000 instanceof RuntimeException ) { \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \nif ( jjte000 instanceof ParseException ) { \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) jjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \n} \n"}
{"6564": "public class OgnlParser { \nfinal public void selectAll ( ) throws ParseException { \nASTSelect jjtn000 = new ASTSelect ( JJTSELECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \njj_consume_token ( 3 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse jjtree . popNode ( ) ; \nif ( jjte000 instanceof RuntimeException ) { \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \nif ( jjte000 instanceof ParseException ) { \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) jjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \n} \n"}
{"6569": "public class OgnlOps { \npublic static String stringValue ( Object value , boolean trim ) { \nString result ; \nif ( value == null ) result = OgnlRuntime . NULL_STRING ; \nelse { \nresult = value . toString ( ) ; \nif ( trim ) result = result . trim ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"6572": "public class OgnlOps { \npublic static int getIntValue ( Object value ) { \ntry { \nif ( value == null ) return - 1 ; \nif ( Number . class . isInstance ( value ) ) return ( ( Number ) value ) . intValue ( ) ; \nString str = String . class . isInstance ( value ) ? ( String ) value : value . toString ( ) ; \nreturn Integer . parseInt ( str ) ; \n} \ncatch ( Throwable t ) { \nthrow new RuntimeException ( \"Error converting \" + value + \" to integer:\" , t ) ; \n} \n} \n} \n"}
{"6575": "public class OgnlOps { \npublic static Number newInteger ( int type , long value ) { \nswitch ( type ) { \ncase BOOL : case CHAR : case INT : return new Integer ( ( int ) value ) ; \ncase FLOAT : if ( ( long ) ( float ) value == value ) return new Float ( ( float ) value ) ; \ncase DOUBLE : if ( ( long ) ( double ) value == value ) return new Double ( ( double ) value ) ; \ncase LONG : return new Long ( value ) ; \ncase BYTE : return new Byte ( ( byte ) value ) ; \ncase SHORT : return new Short ( ( short ) value ) ; \ndefault : return BigInteger . valueOf ( value ) ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse ++ newSize ; \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) for ( int k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \n++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; \nelse newChildren [ j ++ ] = c ; \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6587": "public class FileWatchServices { \npublic static String getDefaultWatchServiceId ( ) { \nString result = \"polling\" ; \nString osName = System . getProperty ( \"os.name\" ) ; \nif ( osName != null ) { \nosName = osName . toLowerCase ( Locale . ENGLISH ) ; \nif ( osName . contains ( \"windows\" ) || osName . contains ( \"linux\" ) ) result = isAtLeastJava7 ( ) ? \"jdk7\" : \"jnotify\" ; \nelse if ( osName . contains ( \"mac\" ) ) result = \"jnotify\" ; \n} \nreturn result ; \n} \n} \n"}
{"6588": "public class AbstractPlay2StartServerMojo { \nprotected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { \nlong endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; \nboolean started = false ; \nURL connectUrl = new URL ( rootUrl ) ; \nint verifyWaitDelay = 1000 ; \nwhile ( ! started ) { \nif ( startTimeout > 0 && endTimeMillis - System . currentTimeMillis ( ) < 0L ) { \nif ( spawned ) { \nInternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; \ninternalStop . project = project ; \ntry { \ninternalStop . execute ( ) ; \n} \ncatch ( MojoExecutionException e ) { \n} \ncatch ( MojoFailureException e ) { \n} \n} \nthrow new MojoExecutionException ( String . format ( \"Failed to start Play! server in %d ms\" , Integer . valueOf ( startTimeout ) ) ) ; \n} \nBuildException runnerException = runner . getException ( ) ; \nif ( runnerException != null ) throw new MojoExecutionException ( \"Play! server start exception\" , runnerException ) ; \ntry { \nURLConnection conn = connectUrl . openConnection ( ) ; \nif ( startTimeout > 0 ) { \nint connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; \nif ( connectTimeOut > 0 ) conn . setConnectTimeout ( connectTimeOut ) ; \n} \nconnectUrl . openConnection ( ) . getContent ( ) ; \nstarted = true ; \n} \ncatch ( Exception e ) { \n} \nif ( ! started ) { \nlong sleepTime = verifyWaitDelay ; \nif ( startTimeout > 0 ) sleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; \nif ( sleepTime > 0 ) try { \nThread . sleep ( sleepTime ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new MojoExecutionException ( \"?\" , e ) ; \n} \n} \n} \n} \n} \n"}
{"6592": "public class AbstractArchivingMojo { \nprotected void checkArchiverForProblems ( Archiver archiver ) { \nfor ( ResourceIterator iter = archiver . getResources ( ) ; \niter . hasNext ( ) ; \n) iter . next ( ) ; \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) debug ( \"Could not change folder: dir was null\" ) ; \nelse if ( ! dir . isDirectory ( ) ) debug ( \"Could not change folder: dir is no directory\" ) ; \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) numDirectories ++ ; \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( int i = 0 , counter = 0 ; \ni < numDirectories ; \ncounter ++ ) if ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse debug ( \"Could not change folder: contents of dir were null\" ) ; \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6600": "public class DirectoryChooserFragment { \nprivate FileObserver createFileObserver ( final String path ) { \nreturn new FileObserver ( path , FileObserver . CREATE | FileObserver . DELETE | FileObserver . MOVED_FROM | FileObserver . MOVED_TO ) { \n@ Override public void onEvent ( final int event , final String path ) { \ndebug ( \"FileObserver received event %d\" , event ) ; \nfinal Activity activity = getActivity ( ) ; \nif ( activity != null ) activity . runOnUiThread ( new Runnable ( ) { \n@ Override public void run ( ) { \nrefreshDirectory ( ) ; \n} \n} \n) ; \n} \n} \n; \n} \n} \n"}
{"6601": "public class DirectoryChooserFragment { \nprivate void returnSelectedFolder ( ) { \nif ( mSelectedDir != null ) { \ndebug ( \"Returning %s as result\" , mSelectedDir . getAbsolutePath ( ) ) ; \nmListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { \n@ Override public void apply ( final OnFragmentInteractionListener f ) { \nf . onSelectDirectory ( mSelectedDir . getAbsolutePath ( ) ) ; \n} \n} \n) ; \n} \nelse mListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { \n@ Override public void apply ( final OnFragmentInteractionListener f ) { \nf . onCancelChooser ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"6602": "public class DirectoryChooserFragment { \nprivate int createFolder ( ) { \nif ( mNewDirectoryName != null && mSelectedDir != null && mSelectedDir . canWrite ( ) ) { \nfinal File newDir = new File ( mSelectedDir , mNewDirectoryName ) ; \nif ( newDir . exists ( ) ) return R . string . create_folder_error_already_exists ; \nelse { \nfinal boolean result = newDir . mkdir ( ) ; \nif ( result ) return R . string . create_folder_success ; \nelse return R . string . create_folder_error ; \n} \n} \nelse if ( mSelectedDir != null && ! mSelectedDir . canWrite ( ) ) return R . string . create_folder_error_no_write_access ; \nelse return R . string . create_folder_error ; \n} \n} \n"}
{"6606": "public class ConverterHtmlToSpanned { \nprivate void endList ( boolean orderedList ) { \nif ( ! mParagraphStyles . isEmpty ( ) ) { \nAccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; \nParagraphType type = style . getType ( ) ; \nif ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { \nint indent = style . getRelativeIndent ( ) ; \nif ( indent > 1 ) { \nstyle . setRelativeIndent ( indent - 1 ) ; \nstyle . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; \n} \nelse mParagraphStyles . pop ( ) ; \n} \nelse { \nmParagraphStyles . pop ( ) ; \nendList ( orderedList ) ; \n} \n} \n} \n} \n"}
{"6607": "public class HighlightView { \nvoid handleMotion ( int edge , float dx , float dy ) { \nRect r = computeLayout ( ) ; \nif ( edge == GROW_NONE ) return ; \nelse if ( edge == MOVE ) moveBy ( dx * ( mCropRect . width ( ) / r . width ( ) ) , dy * ( mCropRect . height ( ) / r . height ( ) ) ) ; \nelse { \nif ( ( ( GROW_LEFT_EDGE | GROW_RIGHT_EDGE ) & edge ) == 0 ) dx = 0 ; \nif ( ( ( GROW_TOP_EDGE | GROW_BOTTOM_EDGE ) & edge ) == 0 ) dy = 0 ; \nfloat xDelta = dx * ( mCropRect . width ( ) / r . width ( ) ) ; \nfloat yDelta = dy * ( mCropRect . height ( ) / r . height ( ) ) ; \ngrowBy ( ( ( ( edge & GROW_LEFT_EDGE ) != 0 ) ? - 1 : 1 ) * xDelta , ( ( ( edge & GROW_TOP_EDGE ) != 0 ) ? - 1 : 1 ) * yDelta ) ; \n} \n} \n} \n"}
{"6611": "public class RTEditText { \nprivate void addSpanWatcher ( ) { \nSpannable spannable = getText ( ) ; \nif ( spannable . getSpans ( 0 , spannable . length ( ) , getClass ( ) ) != null ) spannable . setSpan ( this , 0 , spannable . length ( ) , Spanned . SPAN_INCLUSIVE_INCLUSIVE ) ; \n} \n} \n"}
{"6617": "public class MediaUtils { \npublic static String determineOriginalFile ( Context context , Uri uri ) throws IllegalArgumentException { \nString originalFile = null ; \nif ( uri != null ) { \nif ( uri . getScheme ( ) . startsWith ( \"content\" ) ) originalFile = getPathFromUri ( context , uri ) ; \nif ( uri . toString ( ) . matches ( \"https?://\\\\w+\\\\.googleusercontent\\\\.com/.+\" ) ) originalFile = uri . toString ( ) ; \nif ( uri . getScheme ( ) . startsWith ( \"file\" ) ) originalFile = uri . toString ( ) . substring ( 7 ) ; \nif ( isNullOrEmpty ( originalFile ) ) throw new IllegalArgumentException ( \"File path was null\" ) ; \n} \nelse throw new IllegalArgumentException ( \"Image Uri was null!\" ) ; \nreturn originalFile ; \n} \n} \n"}
{"6618": "public class ElementType { \npublic String namespace ( String name , boolean attribute ) { \nint colon = name . indexOf ( ':' ) ; \nif ( colon == - 1 ) return attribute ? \"\" : theSchema . getURI ( ) ; \nString prefix = name . substring ( 0 , colon ) ; \nif ( prefix . equals ( \"xml\" ) ) return \"http://www.w3.org/XML/1998/namespace\" ; \nelse return ( \"urn:x-prefix:\" + prefix ) . intern ( ) ; \n} \n} \n"}
{"6619": "public class ElementType { \npublic String localName ( String name ) { \nint colon = name . indexOf ( ':' ) ; \nif ( colon == - 1 ) return name ; \nelse return name . substring ( colon + 1 ) . intern ( ) ; \n} \n} \n"}
{"6620": "public class ElementType { \npublic void setAttribute ( AttributesImpl atts , String name , String type , String value ) { \nif ( name . equals ( \"xmlns\" ) || name . startsWith ( \"xmlns:\" ) ) return ; \n; \nString namespace = namespace ( name , true ) ; \nString localName = localName ( name ) ; \nint i = atts . getIndex ( name ) ; \nif ( i == - 1 ) { \nname = name . intern ( ) ; \nif ( type == null ) type = \"CDATA\" ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . addAttribute ( namespace , localName , name , type , value ) ; \n} \nelse { \nif ( type == null ) type = atts . getType ( i ) ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . setAttribute ( i , namespace , localName , name , type , value ) ; \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) throw new IndexOutOfBoundsException ( ) ; \nelse if ( len == 0 ) return ; \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nwhile ( remaining > 0 ) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6628": "public class ByteArrayOutputStream { \npublic synchronized void writeTo ( OutputStream out ) throws IOException { \nint remaining = count ; \nfor ( byte [ ] buf : buffers ) { \nint c = Math . min ( buf . length , remaining ) ; \nout . write ( buf , 0 , c ) ; \nremaining -= c ; \nif ( remaining == 0 ) break ; \n} \n} \n} \n"}
{"6629": "public class ByteArrayOutputStream { \npublic synchronized byte [ ] toByteArray ( ) { \nint remaining = count ; \nif ( remaining == 0 ) return EMPTY_BYTE_ARRAY ; \nbyte newbuf [ ] = new byte [ remaining ] ; \nint pos = 0 ; \nfor ( byte [ ] buf : buffers ) { \nint c = Math . min ( buf . length , remaining ) ; \nSystem . arraycopy ( buf , 0 , newbuf , pos , c ) ; \npos += c ; \nremaining -= c ; \nif ( remaining == 0 ) break ; \n} \nreturn newbuf ; \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) if ( size <= 0 ) { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \nelse { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \nfor ( int pos = 0 ; \npos < mFontSizeAdapter . getCount ( ) ; \npos ++ ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \n} \n} \n} \n} \n"}
{"6631": "public class FilenameUtils { \npublic static String separatorsToUnix ( String path ) { \nif ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == - 1 ) return path ; \nreturn path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; \n} \n} \n"}
{"6633": "public class CropImageView { \nprivate void ensureVisible ( HighlightView hv ) { \nRect r = hv . mDrawRect ; \nint panDeltaX1 = Math . max ( 0 , mLeft - r . left ) ; \nint panDeltaX2 = Math . min ( 0 , mRight - r . right ) ; \nint panDeltaY1 = Math . max ( 0 , mTop - r . top ) ; \nint panDeltaY2 = Math . min ( 0 , mBottom - r . bottom ) ; \nint panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2 ; \nint panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2 ; \nif ( panDeltaX != 0 || panDeltaY != 0 ) panBy ( panDeltaX , panDeltaY ) ; \n} \n} \n"}
{"6636": "public class RegexValidator { \npublic String validate ( String value ) { \nif ( value == null ) return null ; \nfor ( int i = 0 ; \ni < patterns . length ; \ni ++ ) { \nMatcher matcher = patterns [ i ] . matcher ( value ) ; \nif ( matcher . matches ( ) ) { \nint count = matcher . groupCount ( ) ; \nif ( count == 1 ) return matcher . group ( 1 ) ; \nStringBuffer buffer = new StringBuffer ( ) ; \nfor ( int j = 0 ; \nj < count ; \nj ++ ) { \nString component = matcher . group ( j + 1 ) ; \nif ( component != null ) buffer . append ( component ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6638": "public class Schema { \npublic void attribute ( String elemName , String attrName , String type , String value ) { \nElementType e = getElementType ( elemName ) ; \nif ( e == null ) throw new Error ( \"Attribute \" + attrName + \" specified for unknown element type \" + elemName ) ; \ne . setAttribute ( attrName , type , value ) ; \n} \n} \n"}
{"6639": "public class Schema { \npublic void parent ( String name , String parentName ) { \nElementType child = getElementType ( name ) ; \nElementType parent = getElementType ( parentName ) ; \nif ( child == null ) throw new Error ( \"No child \" + name + \" for parent \" + parentName ) ; \nif ( parent == null ) throw new Error ( \"No parent \" + parentName + \" for child \" + name ) ; \nchild . setParent ( parent ) ; \n} \n} \n"}
{"6643": "public class CharacterEffect { \npublic void applyToSelection ( RTEditText editor , V value ) { \nSelection selection = getSelection ( editor ) ; \nint flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nSpannable str = editor . getText ( ) ; \nfor ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { \nboolean sameSpan = span . getValue ( ) . equals ( value ) ; \nint spanStart = str . getSpanStart ( span ) ; \nif ( spanStart < selection . start ( ) ) if ( sameSpan ) { \nflags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nselection . offset ( selection . start ( ) - spanStart , 0 ) ; \n} \nelse str . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; \nint spanEnd = str . getSpanEnd ( span ) ; \nif ( spanEnd > selection . end ( ) ) if ( sameSpan ) selection . offset ( 0 , spanEnd - selection . end ( ) ) ; \nelse str . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; \nstr . removeSpan ( span ) ; \n} \nif ( value != null ) { \nRTSpan < V > newSpan = newSpan ( value ) ; \nif ( newSpan != null ) str . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; \n} \n} \n} \n"}
{"6647": "public class ConverterTextToHtml { \nprivate static String replaceAll ( String source , String search , String replace ) { \nif ( USE_REPLACE_ALL ) return source . replaceAll ( search , replace ) ; \nelse { \nPattern p = Pattern . compile ( search ) ; \nMatcher m = p . matcher ( source ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nboolean atLeastOneFound = false ; \nwhile ( m . find ( ) ) { \nm . appendReplacement ( sb , replace ) ; \natLeastOneFound = true ; \n} \nif ( atLeastOneFound ) { \nm . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \nelse return source ; \n} \n} \n} \n"}
{"6650": "public class BitmapManager { \npublic synchronized boolean canThreadDecoding ( Thread t ) { \nThreadStatus status = mThreadStatus . get ( t ) ; \nif ( status == null ) return true ; \nreturn ( status . mState != State . CANCEL ) ; \n} \n} \n"}
{"6651": "public class BitmapManager { \npublic Bitmap decodeFileDescriptor ( FileDescriptor fd , BitmapFactory . Options options ) { \nif ( options . mCancel ) return null ; \nThread thread = Thread . currentThread ( ) ; \nif ( ! canThreadDecoding ( thread ) ) return null ; \nsetDecodingOptions ( thread , options ) ; \nBitmap b = BitmapFactory . decodeFileDescriptor ( fd , null , options ) ; \nremoveDecodingOptions ( thread ) ; \nreturn b ; \n} \n} \n"}
{"6652": "public class FontManager { \npublic static SortedSet < RTTypeface > getFonts ( Context context ) { \nMap < String , String > assetFonts = getAssetFonts ( context ) ; \nAssetManager assets = context . getResources ( ) . getAssets ( ) ; \nfor ( String fontName : assetFonts . keySet ( ) ) { \nString filePath = assetFonts . get ( fontName ) ; \nif ( ! ALL_FONTS . contains ( fontName ) ) try { \nTypeface typeface = Typeface . createFromAsset ( assets , filePath ) ; \nALL_FONTS . add ( new RTTypeface ( fontName , typeface ) ) ; \n} \ncatch ( Exception e ) { \n} \n} \nMap < String , String > systemFonts = getSystemFonts ( ) ; \nfor ( String fontName : systemFonts . keySet ( ) ) { \nString filePath = systemFonts . get ( fontName ) ; \nif ( ! ALL_FONTS . contains ( fontName ) ) try { \nTypeface typeface = Typeface . createFromFile ( filePath ) ; \nALL_FONTS . add ( new RTTypeface ( fontName , typeface ) ) ; \n} \ncatch ( Exception e ) { \n} \n} \nreturn ALL_FONTS ; \n} \n} \n"}
{"6653": "public class FontManager { \nprivate static Map < String , String > getAssetFonts ( Context context ) { \nsynchronized ( ASSET_FONTS_BY_NAME ) { \nif ( ASSET_FONTS_BY_NAME . isEmpty ( ) ) { \nAssetManager assets = context . getResources ( ) . getAssets ( ) ; \nCollection < String > fontFiles = AssetIndex . getAssetIndex ( context ) ; \nif ( fontFiles == null || fontFiles . isEmpty ( ) ) fontFiles = listFontFiles ( context . getResources ( ) ) ; \nfor ( String filePath : fontFiles ) { \nif ( filePath . toLowerCase ( Locale . getDefault ( ) ) . endsWith ( \"ttf\" ) ) { \nString fontName = TTFAnalyzer . getFontName ( assets , filePath ) ; \nif ( fontName == null ) fontName = getFileName ( filePath ) ; \nASSET_FONTS_BY_NAME . put ( fontName , filePath ) ; \n} \n} \n} \nreturn ASSET_FONTS_BY_NAME ; \n} \n} \n} \n"}
{"6654": "public class FontManager { \nprivate static Map < String , String > getSystemFonts ( ) { \nsynchronized ( SYSTEM_FONTS_BY_NAME ) { \nfor ( String fontDir : FONT_DIRS ) { \nFile dir = new File ( fontDir ) ; \nif ( ! dir . exists ( ) ) continue ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) continue ; \nfor ( File file : files ) { \nString filePath = file . getAbsolutePath ( ) ; \nif ( ! SYSTEM_FONTS_BY_PATH . containsKey ( filePath ) ) { \nString fontName = TTFAnalyzer . getFontName ( file . getAbsolutePath ( ) ) ; \nif ( fontName == null ) fontName = getFileName ( filePath ) ; \nSYSTEM_FONTS_BY_PATH . put ( filePath , fontName ) ; \nSYSTEM_FONTS_BY_NAME . put ( fontName , filePath ) ; \n} \n} \n} \nreturn SYSTEM_FONTS_BY_NAME ; \n} \n} \n} \n"}
{"6655": "public class Parser { \nprivate void setup ( ) { \nif ( theSchema == null ) theSchema = new HTMLSchema ( ) ; \nif ( theScanner == null ) theScanner = new HTMLScanner ( ) ; \nif ( theAutoDetector == null ) theAutoDetector = new AutoDetector ( ) { \npublic Reader autoDetectingReader ( InputStream i ) { \nreturn new InputStreamReader ( i ) ; \n} \n} \n; \ntheStack = new Element ( theSchema . getElementType ( \"<root>\" ) , defaultAttributes ) ; \nthePCDATA = new Element ( theSchema . getElementType ( \"<pcdata>\" ) , defaultAttributes ) ; \ntheNewElement = null ; \ntheAttributeName = null ; \nthePITarget = null ; \ntheSaved = null ; \ntheEntity = 0 ; \nvirginStack = true ; \ntheDoctypeName = theDoctypePublicId = theDoctypeSystemId = null ; \n} \n} \n"}
{"6656": "public class Parser { \nprivate Reader getReader ( InputSource s ) throws SAXException , IOException { \nReader r = s . getCharacterStream ( ) ; \nInputStream i = s . getByteStream ( ) ; \nString encoding = s . getEncoding ( ) ; \nString publicid = s . getPublicId ( ) ; \nString systemid = s . getSystemId ( ) ; \nif ( r == null ) { \nif ( i == null ) i = getInputStream ( publicid , systemid ) ; \nif ( encoding == null ) r = theAutoDetector . autoDetectingReader ( i ) ; \nelse try { \nr = new InputStreamReader ( i , encoding ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nr = new InputStreamReader ( i ) ; \n} \n} \nreturn r ; \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ch == '&' && refStart == - 1 ) refStart = dstlen ; \nelse if ( refStart == - 1 ) { \n} \nelse if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse if ( ch == ';' ) { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ent > 0xFFFF ) { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nrefStart = - 1 ; \n} \nelse refStart = - 1 ; \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6660": "public class Parser { \nprivate int lookupEntity ( char [ ] buff , int offset , int length ) { \nint result = 0 ; \nif ( length < 1 ) return result ; \nif ( buff [ offset ] == '#' ) { \nif ( length > 1 && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) try { \nreturn Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \nreturn theSchema . getEntity ( new String ( buff , offset , length ) ) ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) return ; \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) namespace = localName = \"\" ; \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) theContentHandler . endPrefixMapping ( prefix ) ; \nAttributes atts = theStack . atts ( ) ; \nfor ( int i = atts . getLength ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) theContentHandler . endPrefixMapping ( attPrefix ) ; \n} \ntheStack = theStack . next ( ) ; \n} \n} \n"}
{"6666": "public class Parser { \nprivate static String trimquotes ( String in ) { \nif ( in == null ) return in ; \nint length = in . length ( ) ; \nif ( length == 0 ) return in ; \nchar s = in . charAt ( 0 ) ; \nchar e = in . charAt ( length - 1 ) ; \nif ( s == e && ( s == '\\'' || s == '\"' ) ) in = in . substring ( 1 , in . length ( ) - 1 ) ; \nreturn in ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) return new String [ 0 ] ; \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && ! dq ) if ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse if ( s < 0 && c != ' ' ) s = e ; \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6668": "public class Parser { \nprivate void rectify ( Element e ) throws SAXException { \nElement sp ; \nwhile ( true ) { \nfor ( sp = theStack ; \nsp != null ; \nsp = sp . next ( ) ) if ( sp . canContain ( e ) ) break ; \nif ( sp != null ) break ; \nElementType parentType = e . parent ( ) ; \nif ( parentType == null ) break ; \nElement parent = new Element ( parentType , defaultAttributes ) ; \nparent . setNext ( e ) ; \ne = parent ; \n} \nif ( sp == null ) return ; \nwhile ( theStack != sp ) { \nif ( theStack == null || theStack . next ( ) == null || theStack . next ( ) . next ( ) == null ) break ; \nrestartablyPop ( ) ; \n} \nwhile ( e != null ) { \nElement nexte = e . next ( ) ; \nif ( ! e . name ( ) . equals ( \"<pcdata>\" ) ) push ( e ) ; \ne = nexte ; \nrestart ( e ) ; \n} \ntheNewElement = null ; \n} \n} \n"}
{"6670": "public class RTManager { \npublic void onSaveInstanceState ( Bundle outState ) { \noutState . putString ( \"mToolbarVisibility\" , mToolbarVisibility . name ( ) ) ; \noutState . putBoolean ( \"mToolbarIsVisible\" , mToolbarIsVisible ) ; \noutState . putInt ( \"mActiveEditor\" , mActiveEditor ) ; \nif ( mLinkSelection != null ) outState . putSerializable ( \"mLinkSelection\" , mLinkSelection ) ; \n} \n} \n"}
{"6675": "public class ImageViewTouchBase { \nprotected float maxZoom ( ) { \nif ( mBitmapDisplayed . getBitmap ( ) == null ) return 1F ; \nfloat fw = ( float ) mBitmapDisplayed . getWidth ( ) / ( float ) mThisWidth ; \nfloat fh = ( float ) mBitmapDisplayed . getHeight ( ) / ( float ) mThisHeight ; \nfloat max = Math . max ( fw , fh ) * 4 ; \nreturn max ; \n} \n} \n"}
{"6678": "public class Helper { \npublic static String encodeUrl ( String url ) { \nUri uri = Uri . parse ( url ) ; \ntry { \nMap < String , List < String > > splitQuery = splitQuery ( uri ) ; \nStringBuilder encodedQuery = new StringBuilder ( ) ; \nfor ( String key : splitQuery . keySet ( ) ) { \nfor ( String value : splitQuery . get ( key ) ) { \nif ( encodedQuery . length ( ) > 0 ) encodedQuery . append ( \"&\" ) ; \nencodedQuery . append ( key + \"=\" + URLEncoder . encode ( value , \"UTF-8\" ) ) ; \n} \n} \nString queryString = encodedQuery != null && encodedQuery . length ( ) > 0 ? \"?\" + encodedQuery : \"\" ; \nURI baseUri = new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , uri . getPath ( ) , null , uri . getFragment ( ) ) ; \nreturn baseUri + queryString ; \n} \ncatch ( UnsupportedEncodingException ignore ) { \n} \ncatch ( URISyntaxException ignore ) { \n} \nreturn uri . toString ( ) ; \n} \n} \n"}
{"6682": "public class HTMLWriter { \npublic void setOutput ( Writer writer ) { \nif ( writer == null ) output = new OutputStreamWriter ( System . out ) ; \nelse output = writer ; \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nint i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \nif ( ! name . equals ( value ) ) return false ; \nfor ( int j = 0 ; \nj < booleans . length ; \nj ++ ) if ( name . equals ( booleans [ j ] ) ) return true ; \nreturn false ; \n} \n} \n"}
{"6687": "public class HTMLWriter { \n@ SuppressWarnings ( \"unchecked\" ) private void writeNSDecls ( ) throws SAXException { \nEnumeration < String > prefixes = ( Enumeration < String > ) nsSupport . getDeclaredPrefixes ( ) ; \nwhile ( prefixes . hasMoreElements ( ) ) { \nString prefix = ( String ) prefixes . nextElement ( ) ; \nString uri = nsSupport . getURI ( prefix ) ; \nif ( uri == null ) uri = \"\" ; \nwrite ( ' ' ) ; \nif ( \"\" . equals ( prefix ) ) write ( \"xmlns=\\\"\" ) ; \nelse { \nwrite ( \"xmlns:\" ) ; \nwrite ( prefix ) ; \nwrite ( \"=\\\"\" ) ; \n} \nwriteEscUTF16 ( uri , 0 , uri . length ( ) , true ) ; \nwrite ( '\\\"' ) ; \n} \n} \n} \n"}
{"6688": "public class HTMLWriter { \nprivate void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { \nString prefix = doPrefix ( uri , qName , isElement ) ; \nif ( prefix != null && ! \"\" . equals ( prefix ) ) { \nwrite ( prefix ) ; \nwrite ( ':' ) ; \n} \nif ( localName != null && ! \"\" . equals ( localName ) ) write ( localName ) ; \nelse { \nint i = qName . indexOf ( ':' ) ; \nwrite ( qName . substring ( i + 1 , qName . length ( ) ) ) ; \n} \n} \n} \n"}
{"6690": "public class AwsKinesisUtils { \nprivate static void waitStreamActivation ( AmazonKinesis consumer , String streamName , long streamCreationTimeoutMillis ) { \nDescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; \nDescribeStreamResult describeStreamResult = null ; \nString streamStatus = null ; \nlong endTime = System . currentTimeMillis ( ) + streamCreationTimeoutMillis ; \ndo { \ntry { \ndescribeStreamResult = consumer . describeStream ( describeStreamRequest ) ; \nstreamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; \nif ( ACTIVE_STREAM_STATUS . equals ( streamStatus ) ) break ; \nThread . sleep ( 100 ) ; \n} \ncatch ( ResourceNotFoundException | LimitExceededException ignored ) { \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new AwsKinesisException ( \"Thread interrupted while waiting for stream activation\" , args -> args . add ( \"streamName\" , streamName ) , e ) ; \n} \n} \nwhile ( System . currentTimeMillis ( ) < endTime ) ; \nif ( describeStreamResult == null || streamStatus == null || ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) throw new AwsKinesisException ( \"Stream never went active\" , args -> args . add ( \"streamName\" , streamName ) . add ( \"streamCreationTimeoutMillis\" , streamCreationTimeoutMillis ) ) ; \n} \n} \n"}
{"6691": "public class IronMigration { \nprivate static void completeStoreSnapshotWithMissingInstanceSnapshots ( Path targetStoresPath ) { \nString transactionIdRegexAlone = \"\\\"transactionId\\\"\\\\s*:\\\\s*\\\\d+\\\\s*,\" ; \nString transactionIdRegexReplace = \"(.*\\\"transactionId\\\"\\\\s*:\\\\s*)\\\\d+(\\\\s*,.*)\" ; \nPattern transactionIdPattern = compile ( transactionIdRegexAlone ) ; \nSet < File > previousSnapshots = new HashSet < > ( ) ; \nArrays . stream ( targetStoresPath . resolve ( SNAPSHOT_DIRECTORY_NAME ) . toFile ( ) . listFiles ( ) ) . sorted ( ) . forEach ( snapshot -> { \nSet < String > snapshotNames = Arrays . stream ( snapshot . listFiles ( ) ) . map ( File :: getName ) . collect ( toSet ( ) ) ; \npreviousSnapshots . stream ( ) . filter ( previousSnapshot -> ! snapshotNames . contains ( previousSnapshot . getName ( ) ) ) . forEach ( previousSnapshot -> { \ntry { \nPath targetPath = snapshot . toPath ( ) . resolve ( previousSnapshot . getName ( ) ) ; \nPath sourcePath = previousSnapshot . toPath ( ) ; \nlong count = countTransactionId ( transactionIdPattern , sourcePath ) ; \nif ( count != 1L ) throw new StoreException ( \"transactionId not found once\" , args -> args . add ( \"found count\" , count ) ) ; \nBigInteger newTransactionId = new BigInteger ( snapshot . getName ( ) ) ; \nreplaceTransactionIdValue ( transactionIdRegexReplace , sourcePath , targetPath , newTransactionId . toString ( ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UncheckedIOException ( e ) ; \n} \n} \n) ; \npreviousSnapshots . clear ( ) ; \npreviousSnapshots . addAll ( Arrays . stream ( snapshot . listFiles ( ) ) . collect ( toSet ( ) ) ) ; \n} \n) ; \n} \n} \n"}
{"6692": "public class AwsKinesisTransactionStore { \nprivate boolean waitTheMinimalDurationToExecuteTheNextProvisioningRequest ( ) { \nif ( m_lastGetShardIteratorRequestTime != null ) { \nlong delay = m_durationBetweenRequests . get ( ) - ( System . currentTimeMillis ( ) - m_lastGetShardIteratorRequestTime ) ; \nif ( delay > 0 ) try { \nThread . sleep ( delay ) ; \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nreturn false ; \n} \n} \nm_lastGetShardIteratorRequestTime = System . currentTimeMillis ( ) ; \nreturn true ; \n} \n} \n"}
{"6697": "public class StorePersistence { \nOptional < BigInteger > loadStores ( Function < String , EntityStores > entityStoresByStoreName , BiFunction < SerializableSnapshot , String , SerializableSnapshot > snapshotPostProcessor ) { \nOptional < BigInteger > latestSnapshotTxId ; \ntry { \nlatestSnapshotTxId = m_snapshotStore . listSnapshots ( ) . stream ( ) . max ( BigInteger :: compareTo ) ; \n} \ncatch ( IOException e ) { \nthrow new UnrecoverableStoreException ( \"Error occurred when recovering from latest snapshot\" , e ) ; \n} \nlatestSnapshotTxId . ifPresent ( lastTx -> { \nLOG . info ( \"Recovering store from snapshot\" , args -> args . add ( \"transactionId\" , lastTx ) ) ; \nvar postProcess = new SnapshotPostProcessor ( snapshotPostProcessor ) ; \ntry { \nFlowable . fromPublisher ( m_snapshotStore . createSnapshotReader ( lastTx ) ) . blockingForEach ( reader -> { \nString storeName = reader . storeName ( ) ; \nEntityStores entityStores = entityStoresByStoreName . apply ( storeName ) ; \nSerializableSnapshot serializableSnapshot ; \ntry ( InputStream is = reader . inputStream ( ) ) { \nserializableSnapshot = m_snapshotSerializer . deserializeSnapshot ( storeName , is ) ; \n} \nif ( serializableSnapshot . getSnapshotModelVersion ( ) != SNAPSHOT_MODEL_VERSION ) throw new UnrecoverableStoreException ( \"Snapshot serializable model version is not supported\" , args -> args . add ( \"version\" , serializableSnapshot . getSnapshotModelVersion ( ) ) . add ( \"expectedVersion\" , SNAPSHOT_MODEL_VERSION ) ) ; \nif ( ! lastTx . equals ( serializableSnapshot . getTransactionId ( ) ) ) throw new UnrecoverableStoreException ( \"Snapshot transaction id  mismatch with request transaction id\" , args -> args . add ( \"snapshotTransactionId\" , serializableSnapshot . getTransactionId ( ) ) . add ( \"requestTransactionId\" , lastTx ) ) ; \nSerializableSnapshot finalSnapshot = postProcess . apply ( storeName , serializableSnapshot ) ; \nfinalSnapshot . getEntities ( ) . forEach ( serializableEntityInstances -> { \nString entityName = serializableEntityInstances . getEntityName ( ) ; \nEntityStore < ? > entityStore = entityStores . getEntityStore ( entityName ) ; \ncheckArgument ( entityStore != null , \"Entity has not be registered in the store\" , args -> args . add ( \"entityName\" , entityName ) ) ; \nentityStore . recover ( serializableEntityInstances ) ; \n} \n) ; \n} \n) ; \n} \ncatch ( Exception e ) { \nthrow new UnrecoverableStoreException ( \"Error occurred when recovering from latest snapshot\" , e ) ; \n} \nm_applicationModelVersion = postProcess . getConsistentApplicationModelVersion ( ) ; \n} \n) ; \nif ( ! latestSnapshotTxId . isPresent ( ) ) LOG . info ( \"Store has no snapshot, store is empty, creating it's first snapshot\" ) ; \nreturn latestSnapshotTxId ; \n} \n} \n"}
{"6698": "public class DefaultWildcardStreamLocator { \nvoid triggerWildcardExpander ( final Collection < File > allFiles , final WildcardContext wildcardContext ) throws IOException { \nLOG . debug ( \"wildcard resources: {}\" , allFiles ) ; \nif ( allFiles . isEmpty ( ) ) { \nfinal String message = String . format ( \"No resource found for wildcard: %s\" , wildcardContext . getWildcard ( ) ) ; \nLOG . warn ( message ) ; \nthrow new IOException ( message ) ; \n} \nif ( wildcardExpanderHandler != null ) try { \nwildcardExpanderHandler . apply ( allFiles ) ; \n} \ncatch ( final IOException e ) { \nthrow e ; \n} \ncatch ( final Exception e ) { \nLOG . debug ( \"wildcard expanding error. Reporting original exception\" , e ) ; \nthrow new IOException ( \"Exception during expanding wildcard: \" + e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"6699": "public class StringUtils { \nprivate static String replace ( final String inString , final String oldPattern , final String newPattern ) { \nif ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) return inString ; \nfinal StringBuffer sbuf = new StringBuffer ( ) ; \nint pos = 0 ; \nint index = inString . indexOf ( oldPattern ) ; \nfinal int patLen = oldPattern . length ( ) ; \nwhile ( index >= 0 ) { \nsbuf . append ( inString . substring ( pos , index ) ) ; \nsbuf . append ( newPattern ) ; \npos = index + patLen ; \nindex = inString . indexOf ( oldPattern , pos ) ; \n} \nsbuf . append ( inString . substring ( pos ) ) ; \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"6700": "public class StringUtils { \nprivate static String deleteAny ( final String inString , final String charsToDelete ) { \nif ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) return inString ; \nfinal StringBuffer out = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < inString . length ( ) ; \ni ++ ) { \nfinal char c = inString . charAt ( i ) ; \nif ( charsToDelete . indexOf ( c ) == - 1 ) out . append ( c ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"6702": "public class ConfigurableWroManagerFactory { \nprivate void updatePropertiesWithConfiguration ( final Properties props , final String key ) { \nfinal FilterConfig filterConfig = Context . get ( ) . getFilterConfig ( ) ; \nfinal String valuesAsString = filterConfig . getInitParameter ( key ) ; \nif ( valuesAsString != null ) props . setProperty ( key , valuesAsString ) ; \nelse { \nfinal String value = getConfigProperties ( ) . getProperty ( key ) ; \nif ( value != null ) props . setProperty ( key , value ) ; \n} \n} \n} \n"}
{"6703": "public class ConfigurableWroManagerFactory { \nprivate Properties getConfigProperties ( ) { \nif ( configProperties == null ) { \nconfigProperties = newConfigProperties ( ) ; \nif ( additionalConfigProperties != null ) configProperties . putAll ( additionalConfigProperties ) ; \n} \nreturn configProperties ; \n} \n} \n"}
{"6704": "public class SmartWroModelFactory { \nprivate InputStream createAutoDetectedStream ( final String defaultFileName ) throws IOException { \ntry { \nValidate . notNull ( wroFile , \"Cannot call this method if wroFile is null!\" ) ; \nif ( autoDetectWroFile ) { \nfinal File file = new File ( wroFile . getParentFile ( ) , defaultFileName ) ; \nLOG . debug ( \"\\tloading autodetected wro file: \" + file ) ; \nreturn new FileInputStream ( file ) ; \n} \nLOG . debug ( \"loading wroFile: \" + wroFile ) ; \nreturn new FileInputStream ( wroFile ) ; \n} \ncatch ( final FileNotFoundException e ) { \nif ( autoDetectWroFile ) throw e ; \nthrow new WroRuntimeException ( \"The wroFile doesn't exist. Skip trying with other wro model factories\" , e ) ; \n} \n} \n} \n"}
{"6714": "public class WildcardExpanderModelTransformer { \npublic Function < Collection < File > , Void > createExpanderHandler ( final Group group , final Resource resource , final String baseNameFolder ) { \nLOG . debug ( \"createExpanderHandler using baseNameFolder: {}\\n for resource {}\" , baseNameFolder , resource ) ; \nreturn new Function < Collection < File > , Void > ( ) { \npublic Void apply ( final Collection < File > files ) { \nif ( baseNameFolder == null ) { \nLOG . warn ( \"The resource {} is probably invalid, removing it from the group.\" , resource ) ; \ngroup . replace ( resource , new ArrayList < Resource > ( ) ) ; \n} \nelse { \nfinal List < Resource > expandedResources = new ArrayList < Resource > ( ) ; \nLOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; \nfor ( final File file : files ) { \nfinal String resourcePath = getFullPathNoEndSeparator ( resource ) ; \nLOG . debug ( \"\\tresourcePath: {}\" , resourcePath ) ; \nLOG . debug ( \"\\tfile path: {}\" , file . getPath ( ) ) ; \nfinal String computedResourceUri = resourcePath + StringUtils . removeStart ( file . getPath ( ) , baseNameFolder ) . replace ( '\\\\' , '/' ) ; \nfinal Resource expandedResource = Resource . create ( computedResourceUri , resource . getType ( ) ) ; \nLOG . debug ( \"\\texpanded resource: {}\" , expandedResource ) ; \nexpandedResources . add ( expandedResource ) ; \n} \nLOG . debug ( \"\\treplace resource {}\" , resource ) ; \ngroup . replace ( resource , expandedResources ) ; \n} \nreturn null ; \n} \nprivate String getFullPathNoEndSeparator ( final Resource resource1 ) { \nfinal String result = FilenameUtils . getFullPathNoEndSeparator ( resource1 . getUri ( ) ) ; \nif ( result != null && 1 == result . length ( ) && 0 == FilenameUtils . indexOfLastSeparator ( result ) ) return \"\" ; \nreturn result ; \n} \n} \n; \n} \n} \n"}
{"6715": "public class AbstractUriLocatorFactory { \npublic final InputStream locate ( final String uri ) throws IOException { \nfinal UriLocator uriLocator = getInstance ( uri ) ; \nif ( uriLocator == null ) throw new WroRuntimeException ( \"No locator is capable of handling uri: \" + uri ) ; \nLOG . debug ( \"[OK] locating {} using locator: {}\" , uri , uriLocator . getClass ( ) . getSimpleName ( ) ) ; \nreturn new AutoCloseInputStream ( uriLocator . locate ( uri ) ) ; \n} \n} \n"}
{"6716": "public class WroFilter { \nprivate WroConfiguration createConfiguration ( ) { \nfinal WroConfiguration configAttribute = ServletContextAttributeHelper . create ( filterConfig ) . getWroConfiguration ( ) ; \nif ( configAttribute != null ) setConfiguration ( configAttribute ) ; \nreturn getWroConfigurationFactory ( ) . create ( ) ; \n} \n} \n"}
{"6720": "public class WroModel { \nprivate void identifyDuplicateGroupNames ( final Collection < Group > groups ) { \nLOG . debug ( \"identifyDuplicateGroupNames\" ) ; \nfinal List < String > groupNames = new ArrayList < String > ( ) ; \nfor ( final Group group : groups ) { \nif ( groupNames . contains ( group . getName ( ) ) ) throw new WroRuntimeException ( \"Duplicate group name detected: \" + group . getName ( ) ) ; \ngroupNames . add ( group . getName ( ) ) ; \n} \n} \n} \n"}
{"6721": "public class WroModel { \npublic void merge ( final WroModel importedModel ) { \nValidate . notNull ( importedModel , \"imported model cannot be null!\" ) ; \nLOG . debug ( \"merging importedModel: {}\" , importedModel ) ; \nfor ( final String groupName : new WroModelInspector ( importedModel ) . getGroupNames ( ) ) { \nif ( new WroModelInspector ( this ) . getGroupNames ( ) . contains ( groupName ) ) throw new WroRuntimeException ( \"Duplicate group name detected: \" + groupName ) ; \nfinal Group importedGroup = new WroModelInspector ( importedModel ) . getGroupByName ( groupName ) ; \naddGroup ( importedGroup ) ; \n} \n} \n} \n"}
{"6722": "public class InjectableUriLocatorFactoryDecorator { \npublic InputStream locate ( final String uri ) throws IOException { \nfinal UriLocator locator = getInstance ( uri ) ; \nif ( locator == null ) return getDecoratedObject ( ) . locate ( uri ) ; \nreturn locator . locate ( uri ) ; \n} \n} \n"}
{"6723": "public class GroupsProcessor { \nprivate String applyPostProcessors ( final CacheKey cacheKey , final String content ) throws IOException { \nfinal Collection < ResourcePostProcessor > processors = processorsFactory . getPostProcessors ( ) ; \nLOG . debug ( \"appying post processors: {}\" , processors ) ; \nif ( processors . isEmpty ( ) ) return content ; \nfinal Resource resource = Resource . create ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; \nReader reader = new StringReader ( content . toString ( ) ) ; \nWriter writer = null ; \nfor ( final ResourcePostProcessor processor : processors ) { \nfinal ResourcePreProcessor decoratedProcessor = decorateProcessor ( processor , cacheKey . isMinimize ( ) ) ; \nwriter = new StringWriter ( ) ; \ndecoratedProcessor . process ( resource , reader , writer ) ; \nreader = new StringReader ( writer . toString ( ) ) ; \n} \nreturn writer . toString ( ) ; \n} \n} \n"}
{"6725": "public class AbstractProcessorsFilter { \nprivate void doProcess ( final String requestUri , final Reader reader , final Writer writer ) throws IOException { \nReader input = reader ; \nWriter output = null ; \nLOG . debug ( \"processing resource: {}\" , requestUri ) ; \ntry { \nfinal StopWatch stopWatch = new StopWatch ( ) ; \nfinal Injector injector = InjectorBuilder . create ( new BaseWroManagerFactory ( ) ) . build ( ) ; \nfinal List < ResourcePreProcessor > processors = getProcessorsList ( ) ; \nif ( processors == null || processors . isEmpty ( ) ) IOUtils . copy ( reader , writer ) ; \nelse { \nfor ( final ResourcePreProcessor processor : processors ) { \nstopWatch . start ( \"Using \" + processor . getClass ( ) . getSimpleName ( ) ) ; \ninjector . inject ( processor ) ; \noutput = new StringWriter ( ) ; \nLOG . debug ( \"Using {} processor\" , processor ) ; \nprocessor . process ( createResource ( requestUri ) , input , output ) ; \ninput = new StringReader ( output . toString ( ) ) ; \nstopWatch . stop ( ) ; \n} \nLOG . debug ( stopWatch . prettyPrint ( ) ) ; \nif ( output != null ) writer . write ( output . toString ( ) ) ; \n} \n} \nfinally { \nreader . close ( ) ; \nwriter . close ( ) ; \n} \n} \n} \n"}
{"6730": "public class AbstractWro4jMojo { \nprivate void persistResourceFingerprints ( final List < String > groupNames ) { \nfinal WroModelInspector modelInspector = new WroModelInspector ( getModel ( ) ) ; \nfor ( final String groupName : groupNames ) { \nfinal Group group = modelInspector . getGroupByName ( groupName ) ; \nif ( group != null ) for ( final Resource resource : group . getResources ( ) ) { \ngetResourceChangeHandler ( ) . remember ( resource ) ; \n} \n} \n} \n} \n"}
{"6733": "public class AbstractWroModelFactory { \nprotected InputStream getModelResourceAsStream ( ) throws IOException { \nfinal ServletContext servletContext = context . getServletContext ( ) ; \nif ( servletContext == null ) throw new WroRuntimeException ( \"No servletContext is available. Probably you are running this code outside of the request cycle!\" ) ; \nfinal String resourceLocation = \"/WEB-INF/\" + getDefaultModelFilename ( ) ; \nfinal InputStream stream = servletContext . getResourceAsStream ( resourceLocation ) ; \nif ( stream == null ) throw new IOException ( \"Invalid resource requested: \" + resourceLocation ) ; \nreturn stream ; \n} \n} \n"}
{"6734": "public class DefaultWroManagerFactory { \nprivate WroManagerFactory initFactory ( final Properties properties ) { \nWroManagerFactory factory = null ; \nfinal String wroManagerClassName = properties . getProperty ( ConfigConstants . managerFactoryClassName . name ( ) ) ; \nif ( StringUtils . isEmpty ( wroManagerClassName ) ) factory = newManagerFactory ( ) ; \nelse { \nClass < ? > factoryClass = null ; \ntry { \nfactoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( wroManagerClassName ) ; \nfactory = ( WroManagerFactory ) factoryClass . newInstance ( ) ; \n} \ncatch ( final Exception e ) { \nthrow new WroRuntimeException ( \"Exception while loading WroManagerFactory class:\" + wroManagerClassName , e ) ; \n} \n} \nif ( factory instanceof ConfigurableWroManagerFactory ) ( ( ConfigurableWroManagerFactory ) factory ) . addConfigProperties ( properties ) ; \nreturn factory ; \n} \n} \n"}
{"6738": "public class PreProcessorExecutor { \npublic String processAndMerge ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { \nnotNull ( criteria ) ; \nLOG . debug ( \"criteria: {}\" , criteria ) ; \ncallbackRegistry . onBeforeMerge ( ) ; \ntry { \nnotNull ( resources ) ; \nLOG . debug ( \"process and merge resources: {}\" , resources ) ; \nfinal StringBuffer result = new StringBuffer ( ) ; \nif ( shouldRunInParallel ( resources ) ) result . append ( runInParallel ( resources , criteria ) ) ; \nelse for ( final Resource resource : resources ) { \nLOG . debug ( \"\\tmerging resource: {}\" , resource ) ; \nresult . append ( applyPreProcessors ( resource , criteria ) ) ; \n} \nreturn result . toString ( ) ; \n} \nfinally { \ncallbackRegistry . onAfterMerge ( ) ; \n} \n} \n} \n"}
{"6739": "public class PreProcessorExecutor { \nprivate String runInParallel ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { \nLOG . debug ( \"Running preProcessing in Parallel\" ) ; \nfinal StringBuffer result = new StringBuffer ( ) ; \nfinal List < Callable < String > > callables = new ArrayList < Callable < String > > ( ) ; \nfor ( final Resource resource : resources ) { \ncallables . add ( new Callable < String > ( ) { \npublic String call ( ) throws Exception { \nLOG . debug ( \"Callable started for resource: {} ...\" , resource ) ; \nreturn applyPreProcessors ( resource , criteria ) ; \n} \n} \n) ; \n} \nfinal ExecutorService exec = getExecutorService ( ) ; \nfinal List < Future < String > > futures = new ArrayList < Future < String > > ( ) ; \nfor ( final Callable < String > callable : callables ) { \nfinal Callable < String > decoratedCallable = new ContextPropagatingCallable < String > ( callable ) ; \nfutures . add ( exec . submit ( decoratedCallable ) ) ; \n} \nfor ( final Future < String > future : futures ) { \ntry { \nresult . append ( future . get ( ) ) ; \n} \ncatch ( final Exception e ) { \nfinal Throwable cause = e . getCause ( ) ; \nif ( cause instanceof WroRuntimeException ) throw ( WroRuntimeException ) cause ; \nelse if ( cause instanceof IOException ) throw ( IOException ) cause ; \nelse throw new WroRuntimeException ( \"Problem during parallel pre processing\" , e ) ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"6740": "public class PreProcessorExecutor { \nprivate String applyPreProcessors ( final Resource resource , final ProcessingCriteria criteria ) throws IOException { \nfinal Collection < ResourcePreProcessor > processors = processorsFactory . getPreProcessors ( ) ; \nLOG . debug ( \"applying preProcessors: {}\" , processors ) ; \nString resourceContent = null ; \ntry { \nresourceContent = getResourceContent ( resource ) ; \n} \ncatch ( final IOException e ) { \nLOG . debug ( \"Invalid resource found: {}\" , resource ) ; \nif ( Context . get ( ) . getConfig ( ) . isIgnoreMissingResources ( ) ) return StringUtils . EMPTY ; \nelse { \nLOG . error ( \"Cannot ignore missing resource:  {}\" , resource ) ; \nthrow e ; \n} \n} \nif ( ! processors . isEmpty ( ) ) { \nWriter writer = null ; \nfor ( final ResourcePreProcessor processor : processors ) { \nfinal ResourcePreProcessor decoratedProcessor = decoratePreProcessor ( processor , criteria ) ; \nwriter = new StringWriter ( ) ; \nfinal Reader reader = new StringReader ( resourceContent ) ; \ndecoratedProcessor . process ( resource , reader , writer ) ; \nresourceContent = writer . toString ( ) ; \n} \n} \nreturn String . format ( \"%s%n\" , resourceContent ) ; \n} \n} \n"}
{"6744": "public class ImageUrlRewriter { \npublic String rewrite ( final String cssUri , final String imageUrl ) { \nnotNull ( cssUri ) ; \nnotNull ( imageUrl ) ; \nif ( StringUtils . isEmpty ( imageUrl ) ) return imageUrl ; \nif ( ServletContextUriLocator . isValid ( cssUri ) ) { \nif ( ServletContextUriLocator . isValid ( imageUrl ) ) return prependContextPath ( imageUrl ) ; \nif ( ServletContextUriLocator . isProtectedResource ( cssUri ) ) return context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; \nfinal String aggregatedPathPrefix = computeAggregationPathPrefix ( context . aggregatedFolderPath ) ; \nLOG . debug ( \"computed aggregatedPathPrefix {}\" , aggregatedPathPrefix ) ; \nString newImageLocation = computeNewImageLocation ( aggregatedPathPrefix + cssUri , imageUrl ) ; \nif ( newImageLocation . startsWith ( ServletContextUriLocator . PREFIX ) ) newImageLocation = prependContextPath ( newImageLocation ) ; \nLOG . debug ( \"newImageLocation: {}\" , newImageLocation ) ; \nreturn newImageLocation ; \n} \nif ( ClasspathUriLocator . isValid ( cssUri ) ) { \nfinal String proxyUrl = context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; \nfinal String contextRelativeUrl = prependContextPath ( imageUrl ) ; \nreturn ( ServletContextUriLocator . isValid ( imageUrl ) ? contextRelativeUrl : proxyUrl ) ; \n} \nif ( UrlUriLocator . isValid ( cssUri ) ) { \nfinal String computedCssUri = ServletContextUriLocator . isValid ( imageUrl ) ? computeCssUriForExternalServer ( cssUri ) : cssUri ; \nreturn computeNewImageLocation ( computedCssUri , imageUrl ) ; \n} \nthrow new WroRuntimeException ( \"Could not replace imageUrl: \" + imageUrl + \", contained at location: \" + cssUri ) ; \n} \n} \n"}
{"6745": "public class ImageUrlRewriter { \nprivate String computeNewImageLocation ( final String cssUri , final String imageUrl ) { \nLOG . debug ( \"cssUri: {}, imageUrl {}\" , cssUri , imageUrl ) ; \nfinal String cleanImageUrl = cleanImageUrl ( imageUrl ) ; \nint idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; \nif ( idxLastSeparator == - 1 ) { \nif ( ClasspathUriLocator . isValid ( cssUri ) ) { \nidxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; \nif ( idxLastSeparator >= 0 ) idxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; \n} \nif ( idxLastSeparator < 0 ) throw new IllegalStateException ( \"Invalid cssUri: \" + cssUri + \". Should contain at least one '/' character!\" ) ; \n} \nfinal String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; \nfinal String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; \nfinal String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; \nLOG . debug ( \"computedImageLocation: {}\" , computedImageLocation ) ; \nreturn computedImageLocation ; \n} \n} \n"}
{"6746": "public class BaseWroManagerFactory { \npublic BaseWroManagerFactory addModelTransformer ( final Transformer < WroModel > modelTransformer ) { \nif ( modelTransformers == null ) modelTransformers = new ArrayList < Transformer < WroModel > > ( ) ; \nthis . modelTransformers . add ( modelTransformer ) ; \nreturn this ; \n} \n} \n"}
{"6747": "public class ResourceBundleProcessor { \npublic void serveProcessedBundle ( ) throws IOException { \nfinal WroConfiguration configuration = context . getConfig ( ) ; \nfinal HttpServletRequest request = context . getRequest ( ) ; \nfinal HttpServletResponse response = context . getResponse ( ) ; \nOutputStream os = null ; \ntry { \nfinal CacheKey cacheKey = getSafeCacheKey ( request ) ; \ninitAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; \nfinal CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; \nfinal String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; \nfinal String etagValue = String . format ( \"\\\"%s\\\"\" , cacheValue . getHash ( ) ) ; \nif ( etagValue != null && etagValue . equals ( ifNoneMatch ) ) { \nLOG . debug ( \"ETag hash detected: {}. Sending {} status code\" , etagValue , HttpServletResponse . SC_NOT_MODIFIED ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \nreturn ; \n} \nresponse . setContentType ( cacheKey . getType ( ) . getContentType ( ) + \"; charset=\" + configuration . getEncoding ( ) ) ; \nresponse . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; \nos = response . getOutputStream ( ) ; \nif ( cacheValue . getRawContent ( ) != null ) if ( isGzipAllowed ( ) ) { \nresponse . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nresponse . setHeader ( \"Vary\" , \"Accept-Encoding\" ) ; \nIOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; \n} \nelse { \nresponse . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; \nIOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; \n} \n} \nfinally { \nif ( os != null ) IOUtils . closeQuietly ( os ) ; \n} \n} \n} \n"}
{"6749": "public class CssVariablesProcessor { \nprivate Map < String , String > extractVariables ( final String variablesBody ) { \nfinal Map < String , String > map = new HashMap < String , String > ( ) ; \nfinal Matcher m = PATTERN_VARIABLES_BODY . matcher ( variablesBody ) ; \nLOG . debug ( \"parsing variables body\" ) ; \nwhile ( m . find ( ) ) { \nfinal String key = m . group ( 1 ) ; \nfinal String value = m . group ( 2 ) ; \nif ( map . containsKey ( key ) ) LOG . warn ( \"A duplicate variable name found with name: {} and value: {}.\" , key , value ) ; \nmap . put ( key , value ) ; \n} \nreturn map ; \n} \n} \n"}
{"6751": "public class CssVariablesProcessor { \nprivate String replaceVariables ( final String css , final Map < String , String > variables ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfinal Matcher m = PATTERN_VARIABLE_HOLDER . matcher ( css ) ; \nwhile ( m . find ( ) ) { \nfinal String oldMatch = m . group ( ) ; \nfinal String variableName = m . group ( 1 ) ; \nfinal String variableValue = variables . get ( variableName ) ; \nif ( variableValue != null ) { \nfinal String newReplacement = oldMatch . replace ( oldMatch , variableValue ) ; \nm . appendReplacement ( sb , newReplacement . trim ( ) ) ; \n} \nelse LOG . warn ( \"No variable with name \" + variableName + \" was found!\" ) ; \n} \nm . appendTail ( sb ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6754": "public class GzipFilter { \nprivate void doGzipResponse ( final HttpServletRequest req , final HttpServletResponse response , final FilterChain chain ) throws IOException , ServletException { \nLOG . debug ( \"Applying gzip on resource: \" + req . getRequestURI ( ) ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nfinal CountingOutputStream countingStream = new CountingOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( baos ) ) ) ; \nfinal HttpServletResponseWrapper wrappedResponse = new RedirectedStreamServletResponseWrapper ( countingStream , response ) ; \nchain . doFilter ( req , wrappedResponse ) ; \ncountingStream . close ( ) ; \nresponse . setContentLength ( countingStream . getCount ( ) ) ; \nif ( countingStream . getCount ( ) > 0 ) IOUtils . write ( baos . toByteArray ( ) , response . getOutputStream ( ) ) ; \n} \n} \n"}
{"6758": "public class ResourceChangeHandler { \npublic void remember ( final Resource resource ) { \nfinal WroManager manager = getManagerFactory ( ) . create ( ) ; \nfinal HashStrategy hashStrategy = manager . getHashStrategy ( ) ; \nfinal UriLocatorFactory locatorFactory = manager . getUriLocatorFactory ( ) ; \nif ( rememberedSet . contains ( resource . getUri ( ) ) ) getLog ( ) . debug ( \"Resource with uri '\" + resource . getUri ( ) + \"' has already been updated in this run.\" ) ; \nelse try { \nfinal String fingerprint = hashStrategy . getHash ( locatorFactory . locate ( resource . getUri ( ) ) ) ; \ngetBuildContextHolder ( ) . setValue ( resource . getUri ( ) , fingerprint ) ; \nrememberedSet . add ( resource . getUri ( ) ) ; \ngetLog ( ) . debug ( \"Persist fingerprint for resource '\" + resource . getUri ( ) + \"' : \" + fingerprint ) ; \nif ( resource . getType ( ) == ResourceType . CSS ) { \nfinal Reader reader = new InputStreamReader ( locatorFactory . locate ( resource . getUri ( ) ) ) ; \ngetLog ( ) . debug ( \"Check @import directive from \" + resource ) ; \npersistFingerprintsForCssImports ( resource , reader ) ; \n} \n} \ncatch ( final IOException e ) { \ngetLog ( ) . debug ( \"could not check fingerprint of resource: \" + resource ) ; \n} \n} \n} \n"}
{"6760": "public class ResourceLintReport { \nprivate List < T > filter ( final Collection < T > collection ) { \nfinal List < T > nullFreeList = new ArrayList < T > ( ) ; \nif ( collection != null ) for ( final T item : collection ) { \nif ( item != null ) nullFreeList . add ( item ) ; \n} \nreturn nullFreeList ; \n} \n} \n"}
{"6762": "public class AbstractCssImportPreProcessor { \nprivate List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) throws IOException { \nfinal List < Resource > imports = new ArrayList < Resource > ( ) ; \nfinal String css = cssContent ; \nfinal List < String > foundImports = findImports ( css ) ; \nfor ( final String importUrl : foundImports ) { \nfinal Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; \nif ( imports . contains ( importedResource ) ) LOG . debug ( \"[WARN] Duplicate imported resource: {}\" , importedResource ) ; \nelse { \nimports . add ( importedResource ) ; \nonImportDetected ( importedResource . getUri ( ) ) ; \n} \n} \nreturn imports ; \n} \n} \n"}
{"6764": "public class AbstractConfigurableMultipleStrategy { \npublic static String createItemsAsString ( final String ... items ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < items . length ; \ni ++ ) { \nsb . append ( items [ i ] ) ; \nif ( i < items . length - 1 ) sb . append ( TOKEN_DELIMITER ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6768": "public class RhinoScriptBuilder { \npublic Object evaluate ( final String script , final String sourceName ) { \nnotNull ( script ) ; \ntry { \nreturn getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; \n} \ncatch ( final RhinoException e ) { \nfinal String message = RhinoUtils . createExceptionMessage ( e ) ; \nLOG . error ( \"JavaScriptException occured: {}\" , message ) ; \nthrow new WroRuntimeException ( message ) ; \n} \nfinally { \nif ( Context . getCurrentContext ( ) != null ) Context . exit ( ) ; \n} \n} \n} \n"}
{"6773": "public class Wro4jMojo { \nprivate File computeDestinationFolder ( final ResourceType resourceType ) throws MojoExecutionException { \nFile folder = destinationFolder ; \nif ( resourceType == ResourceType . JS ) if ( jsDestinationFolder != null ) folder = jsDestinationFolder ; \nif ( resourceType == ResourceType . CSS ) if ( cssDestinationFolder != null ) folder = cssDestinationFolder ; \ngetLog ( ) . info ( \"folder: \" + folder ) ; \nif ( folder == null ) throw new MojoExecutionException ( \"Couldn't compute destination folder for resourceType: \" + resourceType + \". That means that you didn't define one of the following parameters: \" + \"destinationFolder, cssDestinationFolder, jsDestinationFolder\" ) ; \nif ( ! folder . exists ( ) ) folder . mkdirs ( ) ; \nreturn folder ; \n} \n} \n"}
{"6774": "public class Wro4jMojo { \nprivate void processGroup ( final String group , final File parentFoder ) throws Exception { \nByteArrayOutputStream resultOutputStream = null ; \nInputStream resultInputStream = null ; \ntry { \ngetLog ( ) . info ( \"processing group: \" + group ) ; \nfinal HttpServletRequest request = Mockito . mock ( HttpServletRequest . class ) ; \nMockito . when ( request . getContextPath ( ) ) . thenReturn ( normalizeContextPath ( contextPath ) ) ; \nMockito . when ( request . getRequestURI ( ) ) . thenReturn ( group ) ; \nfinal HttpServletResponse response = Mockito . mock ( HttpServletResponse . class ) ; \nresultOutputStream = new ByteArrayOutputStream ( ) ; \nMockito . when ( response . getOutputStream ( ) ) . thenReturn ( new DelegatingServletOutputStream ( resultOutputStream ) ) ; \nfinal WroConfiguration config = Context . get ( ) . getConfig ( ) ; \nconfig . setIgnoreEmptyGroup ( true ) ; \nContext . set ( Context . webContext ( request , response , Mockito . mock ( FilterConfig . class ) ) , config ) ; \nContext . get ( ) . setAggregatedFolderPath ( getAggregatedPathResolver ( ) . resolve ( ) ) ; \ngetManagerFactory ( ) . create ( ) . process ( ) ; \nresultInputStream = new UnclosableBufferedInputStream ( resultOutputStream . toByteArray ( ) ) ; \nfinal File destinationFile = new File ( parentFoder , rename ( group , resultInputStream ) ) ; \nfinal File parentFolder = destinationFile . getParentFile ( ) ; \nif ( ! parentFolder . exists ( ) ) parentFolder . mkdirs ( ) ; \ndestinationFile . createNewFile ( ) ; \nresultInputStream . reset ( ) ; \ngetLog ( ) . debug ( \"Created file: \" + destinationFile . getName ( ) ) ; \nfinal OutputStream fos = new FileOutputStream ( destinationFile ) ; \nIOUtils . copy ( resultInputStream , fos ) ; \nfos . close ( ) ; \nif ( destinationFile . length ( ) == 0 ) { \ngetLog ( ) . debug ( \"No content found for group: \" + group ) ; \ndestinationFile . delete ( ) ; \n} \nelse { \ngetLog ( ) . info ( \"file size: \" + destinationFile . getName ( ) + \" -> \" + destinationFile . length ( ) + \" bytes\" ) ; \ngetLog ( ) . info ( destinationFile . getAbsolutePath ( ) + \" (\" + destinationFile . length ( ) + \" bytes\" + \")\" ) ; \n} \n} \nfinally { \nif ( getBuildContext ( ) != null ) getBuildContext ( ) . refresh ( parentFoder ) ; \nif ( resultOutputStream != null ) resultOutputStream . close ( ) ; \nif ( resultInputStream != null ) resultInputStream . close ( ) ; \n} \n} \n} \n"}
{"6778": "public class JarWildcardStreamLocator { \n@ Override public InputStream locateStream ( final String uri , final File folder ) throws IOException { \nnotNull ( folder ) ; \nfinal File jarPath = getJarFile ( folder ) ; \nif ( isSupported ( jarPath ) ) return locateStreamFromJar ( uri , jarPath ) ; \nreturn super . locateStream ( uri , folder ) ; \n} \n} \n"}
{"6784": "public class RubySassEngine { \npublic void addRequire ( final String require ) { \nif ( require != null && require . trim ( ) . length ( ) > 0 ) requires . add ( require . trim ( ) ) ; \n} \n} \n"}
{"6785": "public class RubySassEngine { \npublic String process ( final String content ) { \nif ( isEmpty ( content ) ) return StringUtils . EMPTY ; \ntry { \nsynchronized ( this ) { \nreturn engineInitializer . get ( ) . eval ( buildUpdateScript ( content ) ) . toString ( ) ; \n} \n} \ncatch ( final ScriptException e ) { \nthrow new WroRuntimeException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"6790": "public class Selector { \nprivate Property [ ] parseProperties ( final String contents ) { \nfinal String [ ] parts = contents . split ( \";\" ) ; \nfinal List < Property > resultsAsList = new ArrayList < Property > ( ) ; \nfor ( String part : parts ) { \ntry { \nif ( ! StringUtils . isEmpty ( part . trim ( ) ) ) resultsAsList . add ( new Property ( part ) ) ; \n} \ncatch ( final Exception e ) { \nLOG . warn ( e . getMessage ( ) , e ) ; \n} \n} \nreturn resultsAsList . toArray ( new Property [ resultsAsList . size ( ) ] ) ; \n} \n} \n"}
{"6791": "public class StopWatch { \npublic TaskInfo [ ] getTaskInfo ( ) { \nif ( ! this . keepTaskList ) throw new UnsupportedOperationException ( \"Task info is not being kept!\" ) ; \nreturn ( TaskInfo [ ] ) this . taskList . toArray ( new TaskInfo [ this . taskList . size ( ) ] ) ; \n} \n} \n"}
{"6795": "public class WroUtil { \npublic static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { \nif ( StringUtils . isEmpty ( location ) ) throw new IllegalArgumentException ( \"Location cannot be empty string!\" ) ; \nfinal String contextPath = request . getContextPath ( ) ; \nif ( contextPath != null ) if ( startsWithIgnoreCase ( location , contextPath ) ) return location . substring ( contextPath . length ( ) ) ; \nelse return location ; \nfinal String noSlash = location . substring ( 1 ) ; \nfinal int nextSlash = noSlash . indexOf ( '/' ) ; \nif ( nextSlash == - 1 ) return \"\" ; \nreturn noSlash . substring ( nextSlash ) ; \n} \n} \n"}
{"6806": "public class Context { \npublic static void unset ( ) { \nfinal String correlationId = CORRELATION_ID . get ( ) ; \nif ( correlationId != null ) CONTEXT_MAP . remove ( correlationId ) ; \nCORRELATION_ID . remove ( ) ; \n} \n} \n"}
{"6811": "public class Group { \npublic final boolean hasResourcesOfType ( final ResourceType resourceType ) { \nnotNull ( resourceType , \"ResourceType cannot be null!\" ) ; \nfor ( final Resource resource : resources ) { \nif ( resourceType . equals ( resource . getType ( ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6815": "public class XmlModelFactory { \nprivate Collection < Resource > parseGroup ( final Element element ) { \nfinal String name = element . getAttribute ( ATTR_GROUP_NAME ) ; \nfinal String isAbstractAsString = element . getAttribute ( ATTR_GROUP_ABSTRACT ) ; \nfinal boolean isAbstractGroup = StringUtils . isNotEmpty ( isAbstractAsString ) && Boolean . valueOf ( isAbstractAsString ) ; \nif ( groupsInProcess . contains ( name ) ) throw new RecursiveGroupDefinitionException ( \"Infinite Recursion detected for the group: \" + name + \". Recursion path: \" + groupsInProcess ) ; \nLOG . debug ( \"\\tadding group: {}\" , name ) ; \ngroupsInProcess . add ( name ) ; \nfinal Group parsedGroup = new WroModelInspector ( model ) . getGroupByName ( name ) ; \nif ( parsedGroup != null ) { \ngroupsInProcess . remove ( name ) ; \nreturn parsedGroup . getResources ( ) ; \n} \nfinal Group group = createGroup ( element ) ; \ngroupsInProcess . remove ( name ) ; \nif ( ! isAbstractGroup ) model . addGroup ( group ) ; \nreturn group . getResources ( ) ; \n} \n} \n"}
{"6817": "public class XmlModelFactory { \nprivate void parseResource ( final Element resourceElement , final Collection < Resource > resources ) { \nfinal String tagName = resourceElement . getTagName ( ) ; \nfinal String uri = resourceElement . getTextContent ( ) ; \nif ( TAG_GROUP_REF . equals ( tagName ) ) resources . addAll ( getResourcesForGroup ( uri ) ) ; \nif ( getResourceType ( resourceElement ) != null ) { \nfinal Resource resource = createResource ( resourceElement ) ; \nLOG . debug ( \"\\t\\tadding resource: {}\" , resource ) ; \nresources . add ( resource ) ; \n} \n} \n} \n"}
{"6818": "public class XmlModelFactory { \nprivate Collection < Resource > getResourcesForGroup ( final String groupName ) { \nfinal WroModelInspector modelInspector = new WroModelInspector ( model ) ; \nfinal Group foundGroup = modelInspector . getGroupByName ( groupName ) ; \nif ( foundGroup == null ) { \nfinal Element groupElement = allGroupElements . get ( groupName ) ; \nif ( groupElement == null ) throw new WroRuntimeException ( \"Invalid group-ref: \" + groupName ) ; \nreturn parseGroup ( groupElement ) ; \n} \nreturn foundGroup . getResources ( ) ; \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( threadId != 0 ) timerLabel = name + \" (thread \" + threadId + \")\" ; \nelse if ( threadCount > 1 ) timerLabel = name + \" (over \" + threadCount + \" threads)\" ; \nelse timerLabel = name ; \nif ( todoFlags == RECORD_NONE ) LoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \nelse { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"CPU\" ; \nvalues += totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nelse separator = \"\" ; \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += separator + \"Wall\" ; \nvalues += separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU avg\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall avg\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( threadCount > 1 ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU per thread\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall per thread\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nif ( isRunning ) logger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \n} \n"}
{"6820": "public class ElkTimer { \npublic static long stopNamedTimer ( String timerName , int todoFlags , long threadId ) { \nElkTimer key = new ElkTimer ( timerName , todoFlags , threadId ) ; \nif ( registeredTimers . containsKey ( key ) ) return registeredTimers . get ( key ) . stop ( ) ; \nelse return - 1 ; \n} \n} \n"}
{"6822": "public class ElkTimer { \npublic static ElkTimer getNamedTimer ( String timerName , int todoFlags , long threadId ) { \nElkTimer key = new ElkTimer ( timerName , todoFlags , threadId ) ; \nElkTimer previous = registeredTimers . putIfAbsent ( key , key ) ; \nif ( previous != null ) return previous ; \nreturn key ; \n} \n} \n"}
{"6824": "public class ClassExpressionSaturationFactory { \nprivate void wakeUpWorkers ( ) { \nif ( ! workersWaiting_ ) return ; \nstopWorkersLock_ . lock ( ) ; \ntry { \nworkersWaiting_ = false ; \nthereAreContextsToProcess_ . signalAll ( ) ; \n} \nfinally { \nstopWorkersLock_ . unlock ( ) ; \n} \n} \n} \n"}
{"6825": "public class ClassExpressionSaturationFactory { \nprivate void updateProcessedCounters ( int snapshotFinishedWorkers ) { \nif ( isInterrupted ( ) ) { \nwakeUpWorkers ( ) ; \nreturn ; \n} \nif ( countStartedWorkers_ . get ( ) > snapshotFinishedWorkers ) return ; \nint snapshotCountJobsSubmitted = countJobsSubmittedUpper_ . get ( ) ; \nint snapshotCountContextNonSaturated = saturationState_ . getContextMarkNonSaturatedCount ( ) ; \nint snapshotCountStartedWorkers = countStartedWorkers_ . get ( ) ; \nif ( snapshotCountStartedWorkers > snapshotFinishedWorkers ) return ; \nif ( updateIfSmaller ( countContextsSaturatedLower_ , snapshotCountContextNonSaturated ) ) wakeUpWorkers ( ) ; \nupdateIfSmaller ( countJobsProcessedLower_ , snapshotCountJobsSubmitted ) ; \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nint snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nfor ( ; \n; \n) { \nint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) return ; \nint updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) break ; \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \nfor ( ; \n; \n) { \nint snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsFinished >= snapshotJobsProcessed ) break ; \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) continue ; \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) LOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo ++ ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \n} \n} \n"}
{"6828": "public class DummyRuleVisitor { \nprotected < P > O defaultVisit ( Rule < P > rule , P premise , ContextPremises premises , ClassInferenceProducer producer ) { \nif ( LOGGER_ . isTraceEnabled ( ) ) LOGGER_ . trace ( \"ignore {} by {} in {}\" , premise , rule , premises ) ; \nreturn null ; \n} \n} \n"}
{"6829": "public class ObjectPropertyTaxonomyComputationFactory { \nprivate void instertIntoTaxonomy ( final IndexedObjectProperty property ) { \nfinal Map < IndexedObjectProperty , ElkObjectProperty > equivalent = collectEquivalent ( property ) ; \nif ( equivalent == null ) return ; \nfinal Map < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > subEquivalent = new ArrayHashMap < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > ( ) ; \nfinal Set < IndexedObjectProperty > indirect = new ArrayHashSet < IndexedObjectProperty > ( ) ; \nfor ( final IndexedObjectProperty subProperty : property . getSaturated ( ) . getSubProperties ( ) ) { \nif ( equivalent . containsKey ( subProperty ) ) continue ; \nfinal Map < IndexedObjectProperty , ElkObjectProperty > subEq = collectEquivalent ( subProperty ) ; \nsubEquivalent . put ( subProperty , subEq . values ( ) ) ; \nfor ( final IndexedObjectProperty subSubProperty : subProperty . getSaturated ( ) . getSubProperties ( ) ) { \nif ( ! subEq . containsKey ( subSubProperty ) ) indirect . add ( subSubProperty ) ; \n} \n} \nif ( subEquivalent . isEmpty ( ) && ( indexedBottomProperty_ == null || ! equivalent . containsKey ( indexedBottomProperty_ ) ) ) { \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , defaultDirectSubproperties_ ) ) ; \nreturn ; \n} \nfinal Collection < Collection < ? extends ElkObjectProperty > > direct = Operations . map ( subEquivalent . entrySet ( ) , new Operations . Transformation < Map . Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > , Collection < ? extends ElkObjectProperty > > ( ) { \n@ Override public Collection < ? extends ElkObjectProperty > transform ( final Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > element ) { \nif ( indirect . contains ( element . getKey ( ) ) ) return null ; \nelse return element . getValue ( ) ; \n} \n} \n) ; \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , direct ) ) ; \n} \n} \n"}
{"6830": "public class AbstractReasonerState { \npublic synchronized void ensureLoading ( ) throws ElkException { \nif ( ! isLoadingFinished ( ) ) { \nif ( isIncrementalMode ( ) ) if ( ! stageManager . incrementalAdditionStage . isCompleted ( ) ) complete ( stageManager . incrementalAdditionStage ) ; \nelse if ( ! stageManager . contextInitializationStage . isCompleted ( ) ) complete ( stageManager . contextInitializationStage ) ; \nLOGGER_ . trace ( \"Reset axiom loading\" ) ; \nstageManager . inputLoadingStage . invalidateRecursive ( ) ; \nstageManager . contextInitializationStage . invalidateRecursive ( ) ; \nstageManager . incrementalCompletionStage . invalidateRecursive ( ) ; \n} \ncomplete ( stageManager . inputLoadingStage ) ; \n} \n} \n"}
{"6831": "public class AbstractReasonerState { \nprivate void restoreSaturation ( ) throws ElkException { \nensureLoading ( ) ; \nfinal boolean changed ; \nif ( isIncrementalMode ( ) ) { \nchanged = ! stageManager . incrementalTaxonomyCleaningStage . isCompleted ( ) ; \ncomplete ( stageManager . incrementalTaxonomyCleaningStage ) ; \n} \nelse { \nchanged = ! stageManager . contextInitializationStage . isCompleted ( ) ; \ncomplete ( stageManager . contextInitializationStage ) ; \n} \nif ( changed ) stageManager . consistencyCheckingStage . invalidateRecursive ( ) ; \n} \n} \n"}
{"6832": "public class AbstractReasonerState { \npublic synchronized boolean isInconsistent ( ) throws ElkException { \nrestoreConsistencyCheck ( ) ; \nif ( ! consistencyCheckingState . isInconsistent ( ) ) incompleteness_ . log ( incompleteness_ . getIncompletenessMonitorForClassification ( ) ) ; \nreturn consistencyCheckingState . isInconsistent ( ) ; \n} \n} \n"}
{"6833": "public class AbstractReasonerState { \nprotected Taxonomy < ElkClass > restoreTaxonomy ( ) throws ElkInconsistentOntologyException , ElkException { \nruleAndConclusionStats . reset ( ) ; \nrestoreConsistencyCheck ( ) ; \nif ( consistencyCheckingState . isInconsistent ( ) ) throw new ElkInconsistentOntologyException ( ) ; \ncomplete ( stageManager . classTaxonomyComputationStage ) ; \nreturn classTaxonomyState . getTaxonomy ( ) ; \n} \n} \n"}
{"6834": "public class AbstractReasonerState { \nprotected InstanceTaxonomy < ElkClass , ElkNamedIndividual > restoreInstanceTaxonomy ( ) throws ElkInconsistentOntologyException , ElkException { \nruleAndConclusionStats . reset ( ) ; \nrestoreConsistencyCheck ( ) ; \nif ( consistencyCheckingState . isInconsistent ( ) ) throw new ElkInconsistentOntologyException ( ) ; \ncomplete ( stageManager . instanceTaxonomyComputationStage ) ; \nreturn instanceTaxonomyState . getTaxonomy ( ) ; \n} \n} \n"}
{"6835": "public class ConsistencyCheckingState { \npublic Proof < ? extends EntailmentInference > getEvidence ( final boolean atMostOne ) { \nreturn new Proof < EntailmentInference > ( ) { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public Collection < OntologyInconsistencyEntailmentInference > getInferences ( final Object conclusion ) { \nif ( ! OntologyInconsistencyImpl . INSTANCE . equals ( conclusion ) ) return Collections . emptyList ( ) ; \nfinal Collection < ? extends IndexedIndividual > inconsistentIndividuals = getInconsistentIndividuals ( ) ; \nIterable < OntologyInconsistencyEntailmentInference > result = Operations . map ( inconsistentIndividuals , INDIVIDUAL_TO_ENTAILMENT_INFERENCE ) ; \nint size = inconsistentIndividuals . size ( ) ; \nif ( isTopObjectPropertyInBottom_ ) { \nresult = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new TopObjectPropertyInBottomEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getSubPropertyChain ( topProperty_ , bottomProperty_ ) ) ) , result ) ; \nsize ++ ; \n} \nif ( isOwlThingInconsistent_ ) { \nresult = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new OwlThingInconsistencyEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getContradiction ( owlThing_ ) ) ) , result ) ; \nsize ++ ; \n} \nif ( atMostOne ) { \nfinal Iterator < OntologyInconsistencyEntailmentInference > iter = result . iterator ( ) ; \nif ( ! iter . hasNext ( ) ) return Collections . emptyList ( ) ; \nreturn Collections . singleton ( iter . next ( ) ) ; \n} \nreturn Operations . getCollection ( result , size ) ; \n} \n} \n; \n} \n} \n"}
{"6837": "public class AbstractReasonerStage { \npublic void invalidateRecursive ( ) { \nQueue < AbstractReasonerStage > toInvalidate_ = new LinkedList < AbstractReasonerStage > ( ) ; \ntoInvalidate_ . add ( this ) ; \nAbstractReasonerStage next ; \nwhile ( ( next = toInvalidate_ . poll ( ) ) != null ) if ( next . invalidate ( ) ) for ( AbstractReasonerStage postStage : next . postStages_ ) { \ntoInvalidate_ . add ( postStage ) ; \n} \n} \n} \n"}
{"6838": "public class InstanceTaxonomyState { \nCollection < IndexedIndividual > getToAdd ( ) { \nif ( taxonomy_ == null ) return toAdd_ ; \nfinal int size = pruneToAdd ( ) ; \nreturn Operations . getCollection ( toAdd_ , size ) ; \n} \n} \n"}
{"6854": "public class OreTaxonomyPrinter { \nprotected static void printDeclarations ( Taxonomy < ElkClass > classTaxonomy , ElkObject . Factory objectFactory , Appendable writer ) throws IOException { \nList < ElkClass > classes = new ArrayList < ElkClass > ( classTaxonomy . getNodes ( ) . size ( ) * 2 ) ; \nfor ( TaxonomyNode < ElkClass > classNode : classTaxonomy . getNodes ( ) ) { \nfor ( ElkClass clazz : classNode ) { \nif ( ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_THING ) && ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_NOTHING ) ) classes . add ( clazz ) ; \n} \n} \nCollections . sort ( classes , CLASS_COMPARATOR ) ; \nfor ( ElkClass clazz : classes ) { \nElkDeclarationAxiom decl = objectFactory . getDeclarationAxiom ( clazz ) ; \nOwlFunctionalStylePrinter . append ( writer , decl , true ) ; \nwriter . append ( '\\n' ) ; \n} \n} \n} \n"}
{"6857": "public class HashGenerator { \npublic static int combineMultisetHash ( boolean finalize , int ... hashes ) { \nint hash = 0 ; \nfor ( int h : hashes ) { \nhash = hash + h ; \n} \nif ( finalize ) hash = combineListHash ( hash ) ; \nreturn hash ; \n} \n} \n"}
{"6860": "public class IncompletenessManager { \npublic IncompletenessMonitor getReasonerIncompletenessMonitor ( final IncompletenessMonitor ... additionalMonitors ) { \nfinal List < IncompletenessMonitor > monitors = new ArrayList < IncompletenessMonitor > ( additionalMonitors . length + 1 ) ; \nmonitors . add ( getIncompletenessDueToStatedAxiomsMonitor ( ) ) ; \nmonitors . addAll ( Arrays . asList ( additionalMonitors ) ) ; \nreturn new DelegatingIncompletenessMonitor ( monitors ) { \n@ Override public boolean logNewIncompletenessReasons ( final Logger logger ) { \nfinal boolean result = super . logNewIncompletenessReasons ( logger ) ; \nif ( result ) LoggerWrap . log ( logger , LogLevel . WARN , MARKER_ , \"Reasoning may be incomplete! See log level INFO for more details.\" ) ; \nreturn result ; \n} \n} \n; \n} \n} \n"}
{"6861": "public class TaxonomyPrinter { \nprotected static < T extends ElkEntity > void processTaxomomy ( final Taxonomy < T > taxonomy , final Appendable writer ) throws IOException { \nfinal ElkObject . Factory factory = new ElkObjectEntityRecyclingFactory ( ) ; \nfinal List < T > members = new ArrayList < T > ( taxonomy . getNodes ( ) . size ( ) * 2 ) ; \nfor ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { \nfor ( final T member : node ) { \nif ( ! member . getIri ( ) . equals ( taxonomy . getTopNode ( ) . getCanonicalMember ( ) . getIri ( ) ) && ! member . getIri ( ) . equals ( taxonomy . getBottomNode ( ) . getCanonicalMember ( ) . getIri ( ) ) ) members . add ( member ) ; \n} \n} \nCollections . sort ( members , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nprintDeclarations ( members , factory , writer ) ; \nfinal TreeSet < T > canonicalMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfor ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { \ncanonicalMembers . add ( node . getCanonicalMember ( ) ) ; \n} \nfor ( final T canonicalMember : canonicalMembers ) { \nfinal TaxonomyNode < T > node = taxonomy . getNode ( canonicalMember ) ; \nfinal ArrayList < T > orderedEquivalentMembers = new ArrayList < T > ( node . size ( ) ) ; \nfor ( final T member : node ) { \norderedEquivalentMembers . add ( member ) ; \n} \nCollections . sort ( orderedEquivalentMembers , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfinal TreeSet < T > orderedSuperMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfor ( final TaxonomyNode < T > superNode : node . getDirectSuperNodes ( ) ) { \norderedSuperMembers . add ( superNode . getCanonicalMember ( ) ) ; \n} \nprintMemberAxioms ( canonicalMember , orderedEquivalentMembers , orderedSuperMembers , taxonomy , factory , writer ) ; \n} \n} \n} \n"}
{"6864": "public class ClassExpressionQueryState { \nprivate QueryState markNotComputed ( final IndexedClassExpression queryClass ) { \nfinal QueryState state = indexed_ . get ( queryClass ) ; \nif ( state == null || ! state . isComputed ) return null ; \nstate . isComputed = false ; \nif ( state . node != null ) { \nremoveAllRelated ( queryClass , state . node ) ; \nstate . node = null ; \n} \nreturn state ; \n} \n} \n"}
{"6866": "public class AbstractMatch { \nprotected static void checkChainMatch ( final ElkSubObjectPropertyExpression fullChain , final int startPos ) { \nfullChain . accept ( new ElkSubObjectPropertyExpressionVisitor < Void > ( ) { \nvoid fail ( ) { \nthrow new IllegalArgumentException ( fullChain + \", \" + startPos ) ; \n} \nVoid defaultVisit ( ElkObjectPropertyExpression expression ) { \nif ( startPos != 0 ) fail ( ) ; \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectPropertyChain expression ) { \nif ( startPos < 0 || startPos >= expression . getObjectPropertyExpressions ( ) . size ( ) ) fail ( ) ; \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectInverseOf expression ) { \nreturn defaultVisit ( expression ) ; \n} \n@ Override public Void visit ( ElkObjectProperty expression ) { \nreturn defaultVisit ( expression ) ; \n} \n} \n) ; \n} \n} \n"}
{"6874": "public class Reasoner { \npublic synchronized boolean shutdown ( long timeout , TimeUnit unit ) throws InterruptedException { \nboolean success = true ; \nif ( success ) LOGGER_ . info ( \"ELK reasoner has shut down\" ) ; \nelse LOGGER_ . error ( \"ELK reasoner failed to shut down!\" ) ; \nreturn success ; \n} \n} \n"}
{"6877": "public class StatisticsPrinter { \nstatic String getString ( char c , int n ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) sb . append ( c ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6879": "public class XhtmlResourceMessageConverter { \nprivate void writeResource ( XhtmlWriter writer , Object object ) { \nif ( object == null ) return ; \ntry { \nif ( object instanceof Resource ) { \nResource < ? > resource = ( Resource < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriteResource ( writer , resource . getContent ( ) ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse if ( object instanceof Resources ) { \nResources < ? > resources = ( Resources < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriter . beginUnorderedList ( ) ; \nCollection < ? > content = resources . getContent ( ) ; \nwriteResource ( writer , content ) ; \nwriter . endUnorderedList ( ) ; \nwriter . writeLinks ( resources . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse if ( object instanceof ResourceSupport ) { \nResourceSupport resource = ( ResourceSupport ) object ; \nwriter . beginListItem ( ) ; \nwriteObject ( writer , resource ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse if ( object instanceof Collection ) { \nCollection < ? > collection = ( Collection < ? > ) object ; \nfor ( Object item : collection ) { \nwriteResource ( writer , item ) ; \n} \n} \nelse writeObject ( writer , object ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( \"failed to transform object \" + object , ex ) ; \n} \n} \n} \n"}
{"6880": "public class SpringActionDescriptor { \n@ Override public ActionInputParameter getActionInputParameter ( String name ) { \nActionInputParameter ret = requestParams . get ( name ) ; \nif ( ret == null ) ret = pathVariables . get ( name ) ; \nif ( ret == null ) for ( ActionInputParameter annotatedParameter : getInputParameters ( ) ) { \nPropertyDescriptor pd = getPropertyDescriptorForPropertyPath ( name , annotatedParameter . getParameterType ( ) ) ; \nif ( pd != null ) { \nif ( pd . getWriteMethod ( ) != null ) { \nObject callValue = annotatedParameter . getValue ( ) ; \nObject propertyValue = null ; \nif ( callValue != null ) { \nBeanWrapper beanWrapper = PropertyAccessorFactory . forBeanPropertyAccess ( callValue ) ; \npropertyValue = beanWrapper . getPropertyValue ( name ) ; \n} \nret = new SpringActionInputParameter ( new MethodParameter ( pd . getWriteMethod ( ) , 0 ) , propertyValue ) ; \n} \nbreak ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"6881": "public class SpringActionDescriptor { \nPropertyDescriptor getPropertyDescriptorForPropertyPath ( String propertyPath , Class < ? > propertyType ) { \nint pos = PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath ) ; \nif ( pos > - 1 ) { \nString nestedProperty = propertyPath . substring ( 0 , pos ) ; \nString nestedPath = propertyPath . substring ( pos + 1 ) ; \nPropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( propertyType , nestedProperty ) ; \nreturn getPropertyDescriptorForPropertyPath ( nestedPath , propertyDescriptor . getPropertyType ( ) ) ; \n} \nelse return BeanUtils . getPropertyDescriptor ( propertyType , propertyPath ) ; \n} \n} \n"}
{"6882": "public class SpringActionDescriptor { \n@ Override public Map < String , ActionInputParameter > getRequiredParameters ( ) { \nMap < String , ActionInputParameter > ret = new HashMap < String , ActionInputParameter > ( ) ; \nfor ( Map . Entry < String , ActionInputParameter > entry : requestParams . entrySet ( ) ) { \nActionInputParameter annotatedParameter = entry . getValue ( ) ; \nif ( annotatedParameter . isRequired ( ) ) ret . put ( entry . getKey ( ) , annotatedParameter ) ; \n} \nfor ( Map . Entry < String , ActionInputParameter > entry : pathVariables . entrySet ( ) ) { \nActionInputParameter annotatedParameter = entry . getValue ( ) ; \nret . put ( entry . getKey ( ) , annotatedParameter ) ; \n} \nreturn ret ; \n} \n} \n"}
{"6883": "public class DataType { \npublic static boolean isSingleValueType ( Class < ? > clazz ) { \nboolean ret ; \nif ( isNumber ( clazz ) || isBoolean ( clazz ) || isString ( clazz ) || isEnum ( clazz ) || isDate ( clazz ) || isCalendar ( clazz ) || isCurrency ( clazz ) ) ret = true ; \nelse ret = false ; \nreturn ret ; \n} \n} \n"}
{"6892": "public class Affordance { \n@ JsonIgnore public boolean hasUnsatisfiedRequiredVariables ( ) { \nfor ( ActionDescriptor actionDescriptor : actionDescriptors ) { \nMap < String , ActionInputParameter > requiredParameters = actionDescriptor . getRequiredParameters ( ) ; \nfor ( ActionInputParameter annotatedParameter : requiredParameters . values ( ) ) { \nif ( ! annotatedParameter . hasValue ( ) ) return true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6893": "public class SpringActionInputParameter { \npublic String getValueFormatted ( ) { \nString ret ; \nif ( value == null ) ret = null ; \nelse ret = ( String ) conversionService . convert ( value , typeDescriptor , TypeDescriptor . valueOf ( String . class ) ) ; \nreturn ret ; \n} \n} \n"}
{"6897": "public class SpringActionInputParameter { \npublic boolean isRequired ( ) { \nboolean ret ; \nif ( isRequestBody ( ) ) ret = requestBody . required ( ) ; \nelse if ( isRequestParam ( ) ) ret = ! ( isDefined ( requestParam . defaultValue ( ) ) || ! requestParam . required ( ) ) ; \nelse if ( isRequestHeader ( ) ) ret = ! ( isDefined ( requestHeader . defaultValue ( ) ) || ! requestHeader . required ( ) ) ; \nelse ret = true ; \nreturn ret ; \n} \n} \n"}
{"6898": "public class SpringActionInputParameter { \npublic String getDefaultValue ( ) { \nString ret ; \nif ( isRequestParam ( ) ) ret = isDefined ( requestParam . defaultValue ( ) ) ? requestParam . defaultValue ( ) : null ; \nelse if ( isRequestHeader ( ) ) ret = ! ( ValueConstants . DEFAULT_NONE . equals ( requestHeader . defaultValue ( ) ) ) ? requestHeader . defaultValue ( ) : null ; \nelse ret = null ; \nreturn ret ; \n} \n} \n"}
{"6899": "public class SpringActionInputParameter { \n@ Override public String getParameterName ( ) { \nString ret = null ; \nif ( requestParam != null ) { \nString requestParamName = requestParam . value ( ) ; \nif ( ! requestParamName . isEmpty ( ) ) ret = requestParamName ; \n} \nif ( pathVariable != null ) { \nString pathVariableName = pathVariable . value ( ) ; \nif ( ! pathVariableName . isEmpty ( ) ) ret = pathVariableName ; \n} \nif ( ret == null ) { \nString parameterName = methodParameter . getParameterName ( ) ; \nif ( parameterName == null ) { \nmethodParameter . initParameterNameDiscovery ( new LocalVariableTableParameterNameDiscoverer ( ) ) ; \nret = methodParameter . getParameterName ( ) ; \n} \nelse ret = parameterName ; \n} \nreturn ret ; \n} \n} \n"}
{"6900": "public class LinkListSerializer { \nprivate String getExposedPropertyOrParamName ( ActionInputParameter inputParameter ) { \nfinal Expose expose = inputParameter . getAnnotation ( Expose . class ) ; \nString property ; \nif ( expose != null ) property = expose . value ( ) ; \nelse property = inputParameter . getParameterName ( ) ; \nreturn property ; \n} \n} \n"}
{"6901": "public class LdContextFactory { \npublic String getVocab ( MixinSource mixinSource , Object bean , Class < ? > mixInClass ) { \nif ( proxyUnwrapper != null ) bean = proxyUnwrapper . unwrapProxy ( bean ) ; \nString classVocab = bean == null ? null : vocabFromClassOrPackage ( bean . getClass ( ) ) ; \nfinal Vocab mixinVocab = findAnnotation ( mixInClass , Vocab . class ) ; \nObject nestedContextProviderFromMixin = getNestedContextProviderFromMixin ( mixinSource , bean , mixInClass ) ; \nString contextProviderVocab = null ; \nif ( nestedContextProviderFromMixin != null ) contextProviderVocab = getVocab ( mixinSource , nestedContextProviderFromMixin , null ) ; \nString vocab ; \nif ( mixinVocab != null ) vocab = mixinVocab . value ( ) ; \nelse if ( classVocab != null ) vocab = classVocab ; \nelse if ( contextProviderVocab != null ) vocab = contextProviderVocab ; \nelse vocab = HTTP_SCHEMA_ORG ; \nreturn vocab ; \n} \n} \n"}
{"6902": "public class PartialUriTemplateComponents { \npublic String getQuery ( ) { \nStringBuilder query = new StringBuilder ( ) ; \nif ( queryTail . length ( ) > 0 ) if ( queryHead . length ( ) == 0 ) query . append ( \"{?\" ) . append ( queryTail ) . append ( \"}\" ) ; \nelse if ( queryHead . length ( ) > 0 ) query . append ( queryHead ) . append ( \"{&\" ) . append ( queryTail ) . append ( \"}\" ) ; \nelse query . append ( queryHead ) ; \nreturn query . toString ( ) ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( possibleValues . length > 0 ) if ( actionInputParameter . isArrayOrCollection ( ) ) appendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \nelse appendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \nelse if ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \nfor ( int i = 0 ; \ni < items ; \ni ++ ) { \nObject value ; \nif ( i < callValues . length ) value = callValues [ i ] ; \nelse value = null ; \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6905": "public class XhtmlWriter { \nprivate void appendInputOrSelect ( ActionInputParameter parentInputParameter , String paramName , ActionInputParameter childInputParameter , Object [ ] possibleValues ) throws IOException { \nif ( possibleValues . length > 0 ) if ( childInputParameter . isArrayOrCollection ( ) ) appendSelectMulti ( paramName , possibleValues , childInputParameter ) ; \nelse appendSelectOne ( paramName , possibleValues , childInputParameter ) ; \nelse appendInput ( paramName , childInputParameter , childInputParameter . getValue ( ) , parentInputParameter . isReadOnly ( paramName ) ) ; \n} \n} \n"}
{"6910": "public class AbstractUberNode { \npublic UberNode getFirstByRel ( String rel ) { \nfor ( UberNode node : data ) { \nList < String > myRels = node . getRel ( ) ; \nif ( myRels != null ) for ( String myRel : myRels ) { \nif ( rel . equals ( myRel ) ) return node ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6911": "public class AbstractUberNode { \n@ Override public Iterator < UberNode > iterator ( ) { \nreturn new Iterator < UberNode > ( ) { \nint index = 0 ; \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( \"removing from uber node is not supported\" ) ; \n} \n@ Override public UberNode next ( ) { \nindex = findNextChildWithData ( ) ; \nreturn data . get ( index ++ ) ; \n} \n@ Override public boolean hasNext ( ) { \nreturn findNextChildWithData ( ) != - 1 ; \n} \nprivate int findNextChildWithData ( ) { \nfor ( int i = index ; \ni < data . size ( ) ; \ni ++ ) if ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) return i ; \nreturn - 1 ; \n} \n} \n; \n} \n} \n"}
{"6912": "public class PersistentHashMap { \n@ SuppressWarnings ( \"WeakerAccess\" ) public static < K , V > PersistentHashMap < K , V > ofEq ( Equator < K > eq , Iterable < Map . Entry < K , V > > es ) { \nif ( es == null ) return empty ( eq ) ; \nMutableHashMap < K , V > map = emptyMutable ( eq ) ; \nfor ( Map . Entry < K , V > entry : es ) { \nif ( entry != null ) map . assoc ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn map . immutable ( ) ; \n} \n} \n"}
{"6913": "public class PersistentTreeMap { \npublic static < K extends Comparable < K > , V > PersistentTreeMap < K , V > of ( Iterable < Map . Entry < K , V > > es ) { \nif ( es == null ) return empty ( ) ; \nPersistentTreeMap < K , V > map = new PersistentTreeMap < > ( Equator . defaultComparator ( ) , null , 0 ) ; \nfor ( Map . Entry < K , V > entry : es ) { \nif ( entry != null ) map = map . assoc ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn map ; \n} \n} \n"}
{"6916": "public class PersistentTreeMap { \n@ Override public K lastKey ( ) { \nUnEntry < K , V > max = last ( ) ; \nif ( max == null ) throw new NoSuchElementException ( \"this map is empty\" ) ; \nreturn max . getKey ( ) ; \n} \n} \n"}
{"6917": "public class Xform { \npublic static < T > Xform < T > of ( Iterable < ? extends T > list ) { \nif ( list == null ) return empty ( ) ; \nreturn new SourceProviderIterableDesc < > ( list ) ; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( int j = opIdx ; \nj < ops . length ; \nj ++ ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) continue sourceLoop ; \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) return ( H ) ret ; \n} \nelse if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6919": "public class Xform { \n@ Override public Xform < A > dropWhile ( Fn1 < ? super A , Boolean > predicate ) { \nif ( predicate == null ) throw new IllegalArgumentException ( \"Can't dropWhile without a function.\" ) ; \nreturn new DropWhileDesc < > ( this , predicate ) ; \n} \n} \n"}
{"6920": "public class Xform { \n@ Override public < B > B fold ( B ident , Fn2 < ? super B , ? super A , B > reducer ) { \nif ( reducer == null ) throw new IllegalArgumentException ( \"Can't fold with a null reduction function.\" ) ; \nRunList runList = toRunList ( ) ; \nreturn _fold ( runList , runList . opArray ( ) , 0 , ident , reducer ) ; \n} \n} \n"}
{"6921": "public class Tuple2 { \npublic static < K , V > Tuple2 < K , V > of ( Map . Entry < K , V > entry ) { \nif ( entry instanceof Tuple2 ) return ( Tuple2 < K , V > ) entry ; \nreturn new Tuple2 < > ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \n"}
{"6922": "public class OneOf3 { \n@ SuppressWarnings ( \"unchecked\" ) public < R > R match ( Fn1 < A , R > fa , Fn1 < B , R > fb , Fn1 < C , R > fc ) { \nif ( sel == 0 ) return fa . apply ( ( A ) item ) ; \nelse if ( sel == 1 ) return fb . apply ( ( B ) item ) ; \nelse return fc . apply ( ( C ) item ) ; \n} \n} \n"}
{"6923": "public class RuntimeTypes { \npublic static ImList < Class > registerClasses ( Class ... cs ) { \nif ( cs == null ) throw new IllegalArgumentException ( \"Can't register a null type array\" ) ; \nif ( cs . length == 0 ) throw new IllegalArgumentException ( \"Can't register a zero-length type array\" ) ; \nfor ( Class c : cs ) { \nif ( c == null ) throw new IllegalArgumentException ( \"There shouldn't be any null types in this array!\" ) ; \n} \nArrayHolder < Class > ah = new ArrayHolder < > ( cs ) ; \nImList < Class > registeredTypes ; \nsynchronized ( Lock . INSTANCE ) { \nregisteredTypes = typeMap . get ( ah ) ; \nif ( registeredTypes == null ) { \nImList < Class > vecCs = vec ( cs ) ; \ntypeMap . put ( ah , vecCs ) ; \nregisteredTypes = vecCs ; \n} \n} \nreturn registeredTypes ; \n} \n} \n"}
{"6925": "public class PersistentVector { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public PersistentVector < E > append ( E val ) { \nif ( size - tailoff ( ) < MAX_NODE_LENGTH ) { \nE [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; \nSystem . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; \nnewTail [ tail . length ] = val ; \nreturn new PersistentVector < > ( size + 1 , shift , root , newTail ) ; \n} \nNode newroot ; \nNode tailnode = new Node ( root . edit , tail ) ; \nint newshift = shift ; \nif ( ( size >>> NODE_LENGTH_POW_2 ) > ( 1 << shift ) ) { \nnewroot = new Node ( root . edit ) ; \nnewroot . array [ 0 ] = root ; \nnewroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; \nnewshift += NODE_LENGTH_POW_2 ; \n} \nelse newroot = pushTail ( shift , root , tailnode ) ; \nreturn new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { \nval } \n) ; \n} \n} \n"}
{"6927": "public class StaticImports { \n@ SafeVarargs public static < T > MutableSet < T > mutableSet ( T ... items ) { \nMutableSet < T > ret = PersistentHashSet . emptyMutable ( ) ; \nif ( items == null ) return ret ; \nfor ( T t : items ) { \nret . put ( t ) ; \n} \nreturn ret ; \n} \n} \n"}
{"6928": "public class StaticImports { \n@ SafeVarargs public static < T > MutableList < T > mutableVec ( T ... items ) { \nMutableList < T > ret = PersistentVector . emptyMutable ( ) ; \nif ( items == null ) return ret ; \nfor ( T t : items ) { \nret . append ( t ) ; \n} \nreturn ret ; \n} \n} \n"}
{"6929": "public class StaticImports { \n@ SafeVarargs public static < T > ImSet < T > set ( T ... items ) { \nif ( ( items == null ) || ( items . length < 1 ) ) return PersistentHashSet . empty ( ) ; \nreturn PersistentHashSet . of ( Arrays . asList ( items ) ) ; \n} \n} \n"}
{"6930": "public class StaticImports { \n@ SafeVarargs static public < T > ImList < T > vec ( T ... items ) { \nif ( ( items == null ) || ( items . length < 1 ) ) return PersistentVector . empty ( ) ; \nreturn mutableVec ( items ) . immutable ( ) ; \n} \n} \n"}
{"6932": "public class IndentUtils { \npublic static StringBuilder indentSpace ( int len ) { \nStringBuilder sB = new StringBuilder ( ) ; \nif ( len < 1 ) return sB ; \nwhile ( len > SPACES_LENGTH_MINUS_ONE ) { \nsB . append ( SPACES [ SPACES_LENGTH_MINUS_ONE ] ) ; \nlen = len - SPACES_LENGTH_MINUS_ONE ; \n} \nreturn sB . append ( SPACES [ len ] ) ; \n} \n} \n"}
{"6933": "public class IndentUtils { \npublic static < T > String arrayString ( T [ ] items ) { \nStringBuilder sB = new StringBuilder ( \"A[\" ) ; \nboolean isFirst = true ; \nfor ( T item : items ) { \nif ( isFirst ) isFirst = false ; \nelse sB . append ( \" \" ) ; \nif ( item instanceof String ) sB . append ( \"\\\"\" ) . append ( item ) . append ( \"\\\"\" ) ; \nelse sB . append ( item ) ; \n} \nreturn sB . append ( \"]\" ) . toString ( ) ; \n} \n} \n"}
{"6934": "public class LazyRef { \npublic static < T > LazyRef < T > of ( Fn0 < T > producer ) { \nif ( producer == null ) throw new IllegalArgumentException ( \"The producer function cannot be null (the value it returns can)\" ) ; \nreturn new LazyRef < > ( producer ) ; \n} \n} \n"}
{"6936": "public class Cowry { \npublic static < T > T [ ] insertIntoArrayAt ( T item , T [ ] items , int idx , Class < T > tClass ) { \n@ SuppressWarnings ( \"unchecked\" ) T [ ] newItems = ( T [ ] ) ( ( tClass == null ) ? new Object [ items . length + 1 ] : Array . newInstance ( tClass , items . length + 1 ) ) ; \nif ( idx > 0 ) System . arraycopy ( items , 0 , newItems , 0 , idx ) ; \nnewItems [ idx ] = item ; \nif ( idx < items . length ) System . arraycopy ( items , idx , newItems , idx + 1 , items . length - idx ) ; \nreturn newItems ; \n} \n} \n"}
{"6937": "public class Cowry { \npublic static < T > T [ ] arrayCopy ( T [ ] items , int length , Class < T > tClass ) { \n@ SuppressWarnings ( \"unchecked\" ) T [ ] newItems = ( T [ ] ) ( ( tClass == null ) ? new Object [ length ] : Array . newInstance ( tClass , length ) ) ; \nif ( length > 0 ) System . arraycopy ( items , 0 , newItems , 0 , items . length < length ? items . length : length ) ; \nreturn newItems ; \n} \n} \n"}
{"6938": "public class SleeTransactionImpl { \nprivate void suspendIfAssoaciatedWithThread ( ) throws SystemException { \nfinal SleeTransaction currentThreadTransaction = transactionManager . getSleeTransaction ( ) ; \nif ( currentThreadTransaction != null && currentThreadTransaction . equals ( this ) ) transactionManager . getRealTransactionManager ( ) . suspend ( ) ; \n} \n} \n"}
{"6939": "public class SleeTransactionImpl { \nprivate void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { \ntry { \nint status = transaction . getStatus ( ) ; \nif ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) ) throw new IllegalStateException ( \"There is no active tx, tx is in state: \" + status ) ; \nsuspendIfAssoaciatedWithThread ( ) ; \n} \ncatch ( SystemException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"6940": "public class DeployableUnitServiceComponentBuilder { \npublic List < ServiceComponentImpl > buildComponents ( String serviceDescriptorFileName , JarFile deployableUnitJar ) throws DeploymentException { \nJarEntry componentDescriptor = deployableUnitJar . getJarEntry ( serviceDescriptorFileName ) ; \nInputStream componentDescriptorInputStream = null ; \nList < ServiceComponentImpl > result = new ArrayList < ServiceComponentImpl > ( ) ; \ntry { \ncomponentDescriptorInputStream = deployableUnitJar . getInputStream ( componentDescriptor ) ; \nServiceDescriptorFactoryImpl descriptorFactory = componentManagement . getComponentDescriptorFactory ( ) . getServiceDescriptorFactory ( ) ; \nfor ( ServiceDescriptorImpl descriptor : descriptorFactory . parse ( componentDescriptorInputStream ) ) { \nresult . add ( new ServiceComponentImpl ( descriptor ) ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new DeploymentException ( \"failed to parse service descriptor from \" + componentDescriptor . getName ( ) , e ) ; \n} \nfinally { \nif ( componentDescriptorInputStream != null ) try { \ncomponentDescriptorInputStream . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close inputstream of descriptor for jar \" + componentDescriptor . getName ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6941": "public class ConcreteClassGeneratorUtils { \nstatic private void validateDirectory ( File aDirectory ) throws FileNotFoundException { \nif ( aDirectory == null ) throw new IllegalArgumentException ( \"Directory should not be null.\" ) ; \nif ( ! aDirectory . exists ( ) ) throw new FileNotFoundException ( \"Directory does not exist: \" + aDirectory ) ; \nif ( ! aDirectory . isDirectory ( ) ) throw new IllegalArgumentException ( \"Is not a directory: \" + aDirectory ) ; \nif ( ! aDirectory . canRead ( ) ) throw new IllegalArgumentException ( \"Directory cannot be read: \" + aDirectory ) ; \n} \n} \n"}
{"6944": "public class ConcreteClassGeneratorUtils { \npublic static void copyMethods ( CtMethod [ ] methods , CtClass destination , CtClass [ ] exceptions ) { \nCtMethod methodCopy = null ; \nfor ( CtMethod method : methods ) { \ntry { \nmethodCopy = new CtMethod ( method , destination , null ) ; \nif ( exceptions != null ) try { \nmethodCopy . setExceptionTypes ( exceptions ) ; \n} \ncatch ( NotFoundException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \ndestination . addMethod ( methodCopy ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"6945": "public class LogStructureTreePanel { \nprivate TreeItem doTree ( FQDNNode localRoot ) { \nTreeItem localLeaf = new TreeItem ( ) ; \nLogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; \nlocalLeaf . setWidget ( logTreeNode ) ; \nif ( localRoot . getChildren ( ) . size ( ) > 0 ) { \nTree t = new Tree ( ) ; \nArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; \nCollections . sort ( names ) ; \nIterator it = names . iterator ( ) ; \nwhile ( it . hasNext ( ) ) t . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; \nlocalLeaf . addItem ( t ) ; \n} \nreturn localLeaf ; \n} \n} \n"}
{"6947": "public class UsageNotificationManagerMBeanImpl { \npublic boolean getNotificationsEnabled ( String paramName ) { \nBoolean areNotificationsEnabled = paramNames . get ( paramName ) ; \nif ( ! isSlee11 ) if ( areNotificationsEnabled == null || areNotificationsEnabled . booleanValue ( ) ) return true ; \nelse return false ; \nelse if ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) return true ; \nelse return false ; \n} \n} \n"}
{"6948": "public class ServiceManagementImpl { \npublic Set < String > getReferencedRAEntityLinksWhichNotExists ( ServiceComponent serviceComponent ) { \nSet < String > result = new HashSet < String > ( ) ; \nSet < String > raLinkNames = sleeContainer . getResourceManagement ( ) . getLinkNamesSet ( ) ; \nfor ( String raLink : serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) ) { \nif ( ! raLinkNames . contains ( raLink ) ) result . add ( raLink ) ; \n} \nreturn result ; \n} \n} \n"}
{"6949": "public class ServiceManagementImpl { \npublic void installService ( final ServiceComponent serviceComponent ) throws Exception { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Installing Service \" + serviceComponent ) ; \nfinal ServiceUsageMBean serviceUsageMBean = sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nserviceUsageMBean . remove ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \naction = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nNotificationSourceWrapperImpl sbbMNotificationSource = new NotificationSourceWrapperImpl ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nserviceComponent . getAlarmNotificationSources ( ) . putIfAbsent ( sbbID , sbbMNotificationSource ) ; \n} \nsleeContainer . getSbbManagement ( ) . serviceInstall ( serviceComponent ) ; \n} \n} \n"}
{"6950": "public class ServiceManagementImpl { \npublic void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isStopping ( ) ) for ( int i = 0 ; \ni < 15 ; \ni ++ ) try { \nThread . sleep ( 1000 ) ; \nlogger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isInactive ( ) ) break ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) throw new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; \nServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; \nif ( serviceUsageMBean != null ) { \nserviceUsageMBean . remove ( ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nsleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nsleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; \n} \n} \n"}
{"6951": "public class ServiceManagementImpl { \npublic boolean isRAEntityLinkNameReferenced ( String raLinkName ) { \nif ( raLinkName == null ) throw new NullPointerException ( \"null ra link name\" ) ; \nboolean b = false ; \ntry { \nb = transactionManager . requireTransaction ( ) ; \nfor ( ServiceID serviceID : componentRepositoryImpl . getServiceIDs ( ) ) { \nServiceComponent serviceComponent = componentRepositoryImpl . getComponentByID ( serviceID ) ; \nif ( serviceComponent . getServiceState ( ) != ServiceState . INACTIVE && serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) . contains ( raLinkName ) ) return true ; \n} \nreturn false ; \n} \nfinally { \ntry { \ntransactionManager . requireTransactionEnd ( b , false ) ; \n} \ncatch ( Throwable ex ) { \nthrow new SLEEException ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \n} \n"}
{"6952": "public class ServiceUsageMBeanImpl { \npublic synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) throws NullPointerException , UnrecognizedSbbException , InvalidArgumentException , ManagementException { \nif ( sbbId == null ) throw new NullPointerException ( \"Sbb ID is null!\" ) ; \nSbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbId ) ; \nif ( sbbComponent == null ) throw new UnrecognizedSbbException ( sbbId . toString ( ) ) ; \nelse if ( sbbComponent . getUsageParametersInterface ( ) == null ) throw new InvalidArgumentException ( \"no usage parameter interface for \" + sbbId ) ; \nServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; \nif ( ! serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) throw new UnrecognizedSbbException ( sbbId . toString ( ) + \" is not part of \" + getService ( ) ) ; \nSet < String > resultSet = new HashSet < String > ( ) ; \nfor ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { \nif ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) . getSbb ( ) . equals ( sbbId ) ) { \nString name = usageMBeanImpl . getUsageParameterSet ( ) ; \nif ( name != null ) resultSet . add ( name ) ; \n} \n} \nreturn resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; \n} \n} \n"}
{"6954": "public class ProfileFacilityImpl { \npublic Collection < ProfileID > getProfiles ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , TransactionRolledbackLocalException , FacilityException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"getProfiles( profileTableName = \" + profileTableName + \" )\" ) ; \nprofileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; \ntry { \nreturn profileManagement . getProfileTable ( profileTableName ) . getProfiles ( ) ; \n} \ncatch ( NullPointerException e ) { \nthrow e ; \n} \ncatch ( UnrecognizedProfileTableNameException e ) { \nthrow e ; \n} \ncatch ( Throwable e ) { \nthrow new FacilityException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"6955": "public class ProfileFacilityImpl { \npublic ProfileTableActivity getProfileTableActivity ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , TransactionRolledbackLocalException , FacilityException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"getProfileTableActivity( profileTableName = \" + profileTableName + \" )\" ) ; \nfinal SleeTransactionManager sleeTransactionManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; \nboolean terminateTx = sleeTransactionManager . requireTransaction ( ) ; \ntry { \nreturn profileManagement . getProfileTable ( profileTableName ) . getActivity ( ) ; \n} \ncatch ( NullPointerException e ) { \nthrow e ; \n} \ncatch ( UnrecognizedProfileTableNameException e ) { \nthrow e ; \n} \ncatch ( Throwable e ) { \nthrow new FacilityException ( \"Failed to obtain profile table.\" , e ) ; \n} \nfinally { \ntry { \nsleeTransactionManager . requireTransactionEnd ( terminateTx , false ) ; \n} \ncatch ( Throwable e ) { \nthrow new FacilityException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"6956": "public class ProfileFacilityImpl { \npublic ProfileID getProfileByIndexedAttribute ( java . lang . String profileTableName , java . lang . String attributeName , java . lang . Object attributeValue ) throws NullPointerException , UnrecognizedProfileTableNameException , UnrecognizedAttributeException , AttributeNotIndexedException , AttributeTypeMismatchException , TransactionRolledbackLocalException , FacilityException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"getProfileByIndexedAttribute( profileTableName = \" + profileTableName + \" , attributeName = \" + attributeName + \" , attributeValue = \" + attributeValue + \" )\" ) ; \nprofileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; \ntry { \nProfileTableImpl profileTable = profileManagement . getProfileTable ( profileTableName ) ; \nif ( profileTable . getProfileSpecificationComponent ( ) . isSlee11 ( ) ) throw new FacilityException ( \"JAIN SLEE 1.1 Specs forbidden the usage of this method on SLEE 1.1 Profile Tables\" ) ; \nCollection < ProfileID > profileIDs = profileTable . getProfilesByAttribute ( attributeName , attributeValue , false ) ; \nif ( profileIDs . isEmpty ( ) ) return null ; \nelse return profileIDs . iterator ( ) . next ( ) ; \n} \ncatch ( NullPointerException e ) { \nthrow e ; \n} \ncatch ( UnrecognizedProfileTableNameException e ) { \nthrow e ; \n} \ncatch ( UnrecognizedAttributeException e ) { \nthrow e ; \n} \ncatch ( AttributeNotIndexedException e ) { \nthrow e ; \n} \ncatch ( AttributeTypeMismatchException e ) { \nthrow e ; \n} \ncatch ( Throwable e ) { \nthrow new FacilityException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"6958": "public class AbstractOperation { \nprotected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { \nStringBuffer sb = new StringBuffer ( \"[\" ) ; \nfor ( int index = 0 ; \nindex < array . length ; \nindex ++ ) { \nif ( editor != null ) { \neditor . setValue ( array [ index ] ) ; \nsb . append ( editor . getAsText ( ) ) ; \n} \nelse sb . append ( array [ index ] . toString ( ) ) ; \nif ( index < array . length - 1 ) sb . append ( CID_SEPARATOR ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6959": "public class SleeEndpointFireEventNotTransactedExecutor { \nvoid execute ( final ActivityHandle realHandle , final ActivityHandle refHandle , final FireableEventType eventType , final Object event , final Address address , final ReceivableService receivableService , final int eventFlags ) throws ActivityIsEndingException , FireEventException , SLEEException , UnrecognizedActivityHandleException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \ntry { \nsleeEndpoint . _fireEvent ( realHandle , refHandle , eventType , event , address , receivableService , eventFlags , tx ) ; \n} \nfinally { \nif ( tx != null ) super . resumeTransaction ( tx ) ; \n} \n} \n} \n"}
{"6960": "public class ActivityContextNamingFacilityCacheData { \npublic void bindName ( Object ach , String name ) throws NameAlreadyBoundException { \nfinal Node node = getNode ( ) ; \nif ( node . hasChild ( name ) ) throw new NameAlreadyBoundException ( \"name already bound\" ) ; \nelse node . addChild ( Fqn . fromElements ( name ) ) . put ( CACHE_NODE_MAP_KEY , ach ) ; \n} \n} \n"}
{"6961": "public class ActivityContextNamingFacilityCacheData { \npublic Object unbindName ( String name ) throws NameNotBoundException { \nfinal Node node = getNode ( ) ; \nfinal Node childNode = node . getChild ( name ) ; \nif ( childNode == null ) throw new NameNotBoundException ( \"name not bound\" ) ; \nelse { \nfinal Object ach = childNode . get ( CACHE_NODE_MAP_KEY ) ; \nnode . removeChild ( name ) ; \nreturn ach ; \n} \n} \n} \n"}
{"6962": "public class ActivityContextNamingFacilityCacheData { \npublic Object lookupName ( String name ) { \nfinal Node childNode = getNode ( ) . getChild ( name ) ; \nif ( childNode == null ) return null ; \nelse return childNode . get ( CACHE_NODE_MAP_KEY ) ; \n} \n} \n"}
{"6964": "public class NextSbbEntityFinder { \npublic Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { \nSbbEntityID sbbEntityId = null ; \nSbbEntity sbbEntity = null ; \nEventEntryDescriptor mEventEntry = null ; \nfor ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nsbbEntityId = iter . next ( ) ; \nsbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; \nif ( sbbEntity == null ) continue ; \nif ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) continue ; \nif ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) if ( ! sleeEvent . isActivityEndEvent ( ) ) continue ; \nelse return new Result ( sbbEntity , false ) ; \nmEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; \nif ( mEventEntry != null && mEventEntry . isReceived ( ) ) return new Result ( sbbEntity , true ) ; \nelse if ( ! sleeEvent . isActivityEndEvent ( ) ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Event is not received by sbb descriptor of entity \" + sbbEntityId + \", will not deliver event to sbb entity ...\" ) ; \ncontinue ; \n} \nelse return new Result ( sbbEntity , false ) ; \n} \nreturn null ; \n} \n} \n"}
{"6966": "public class DeployableUnitJarComponentBuilder { \nprivate void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { \nJarInputStream jarIs = null ; \ntry { \njarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; \nfor ( JarEntry entry = jarIs . getNextJarEntry ( ) ; \njarIs . available ( ) > 0 && entry != null ; \nentry = jarIs . getNextJarEntry ( ) ) { \nlogger . trace ( \"jar entry = \" + entry . getName ( ) ) ; \nif ( entry . isDirectory ( ) ) { \nFile dir = new File ( dstDir , entry . getName ( ) ) ; \nif ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \nelse { \nFile file = new File ( dstDir , entry . getName ( ) ) ; \nFile dir = file . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \npipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; \n} \nfinally { \nif ( jarIs != null ) try { \njarIs . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close jar input stream\" , e ) ; \n} \n} \n} \n} \n"}
{"6969": "public class ActivityContextCacheData { \npublic boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { \nfinal Node node = getAttachedSbbsNode ( true ) ; \nif ( ! node . hasChild ( sbbEntityId ) ) { \nnode . addChild ( Fqn . fromElements ( sbbEntityId ) ) ; \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"6973": "public class ActivityContextCacheData { \npublic boolean attachTimer ( TimerID timerID ) { \nfinal Node node = getAttachedTimersNode ( true ) ; \nif ( ! node . hasChild ( timerID ) ) { \nnode . addChild ( Fqn . fromElements ( timerID ) ) ; \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"6977": "public class ActivityContextCacheData { \npublic void nameBound ( String name ) { \nfinal Node node = getNamesBoundNode ( true ) ; \nif ( ! node . hasChild ( name ) ) node . addChild ( Fqn . fromElements ( name ) ) ; \n} \n} \n"}
{"6981": "public class ActivityContextCacheData { \n@ SuppressWarnings ( \"unchecked\" ) public void setCmpAttribute ( String attrName , Object attrValue ) { \nfinal Node node = getCmpAttributesNode ( true ) ; \nNode cmpNode = node . getChild ( attrName ) ; \nif ( cmpNode == null ) cmpNode = node . addChild ( Fqn . fromElements ( attrName ) ) ; \ncmpNode . put ( CMP_ATTRIBUTES_NODE_MAP_KEY , attrValue ) ; \n} \n} \n"}
{"6982": "public class ActivityContextCacheData { \n@ SuppressWarnings ( \"unchecked\" ) public Object getCmpAttribute ( String attrName ) { \nfinal Node node = getCmpAttributesNode ( false ) ; \nif ( node == null ) return null ; \nelse { \nfinal Node cmpNode = node . getChild ( attrName ) ; \nif ( cmpNode != null ) return cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ; \nelse return null ; \n} \n} \n} \n"}
{"6983": "public class ActivityContextCacheData { \n@ SuppressWarnings ( \"unchecked\" ) public Map getCmpAttributesCopy ( ) { \nfinal Node node = getCmpAttributesNode ( false ) ; \nif ( node == null ) return Collections . emptyMap ( ) ; \nelse { \nMap result = new HashMap ( ) ; \nNode cmpNode = null ; \nfor ( Object obj : node . getChildren ( ) ) { \ncmpNode = ( Node ) obj ; \nresult . put ( cmpNode . getFqn ( ) . getLastElement ( ) , cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ) ; \n} \nreturn result ; \n} \n} \n} \n"}
{"6985": "public class UsageMBeanImpl { \npublic void sendUsageNotification ( long value , long seqno , String usageParameterSetName , String usageParameterName , boolean isCounter ) { \nUsageNotificationManagerMBeanImpl notificationManager = parent . getUsageNotificationManagerMBean ( notificationSource ) ; \nif ( notificationManager == null || notificationManager . getNotificationsEnabled ( usageParameterName ) ) { \nUsageNotification notification = createUsageNotification ( value , seqno , usageParameterSetName , usageParameterName , isCounter ) ; \nfor ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { \nif ( triplet . notificationFilter == null || triplet . notificationFilter . isNotificationEnabled ( notification ) ) triplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; \n} \n} \n} \n} \n"}
{"6986": "public class DeploymentManagerMBeanImpl { \nprivate File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { \nInputStream in = null ; \nOutputStream out = null ; \ntry { \nString filename = new File ( duURL . getPath ( ) ) . getName ( ) ; \nFile tempFile = new File ( deploymentRoot , filename ) ; \nout = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; \nURLConnection conn = duURL . openConnection ( ) ; \nin = conn . getInputStream ( ) ; \nbyte [ ] buffer = new byte [ 1024 ] ; \nint numRead ; \nwhile ( ( numRead = in . read ( buffer ) ) != - 1 ) out . write ( buffer , 0 , numRead ) ; \nreturn tempFile ; \n} \nfinally { \ntry { \nif ( in != null ) { \nin . close ( ) ; \nin = null ; \n} \nif ( out != null ) { \nout . close ( ) ; \nout = null ; \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n} \n"}
{"6989": "public class DeploymentManager { \npublic void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( ! du . isInstalled ( ) ) if ( waitingForInstallDUs . remove ( du ) ) logger . info ( du . getDeploymentInfoShortName ( ) + \" wasn't deployed. Removing from waiting list.\" ) ; \nelse if ( ! du . areComponentsStillPresent ( ) ) { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" components already removed. Removing DU info.\" ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse if ( du . isReadyToUninstall ( ) ) { \nsciAction ( du . getUninstallActions ( ) , du ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse { \nif ( ! waitingForUninstallDUs . contains ( du ) ) { \nwaitingForUninstallDUs . add ( du ) ; \nlogger . warn ( \"Unable to UNINSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependents to be removed.\" ) ; \n} \nthrow new DependencyException ( \"Unable to undeploy \" + du . getDeploymentInfoShortName ( ) ) ; \n} \n} \n} \n"}
{"6992": "public class MobicentsLogFilter { \npublic boolean isLoggable ( LogRecord record ) { \nLogger logger = getLogger ( record ) ; \nif ( record . getThrown ( ) != null ) logWithThrowable ( logger , record ) ; \nelse logWithoutThrowable ( logger , record ) ; \nreturn false ; \n} \n} \n"}
{"6994": "public class ComponentRepositoryImpl { \npublic Set < SleeComponent > getReferringComponents ( SleeComponent component ) { \nSet < SleeComponent > result = new HashSet < SleeComponent > ( ) ; \nfor ( EventTypeComponent otherComponent : eventTypeComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nfor ( LibraryComponent otherComponent : libraryComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nfor ( ProfileSpecificationComponent otherComponent : profileSpecificationComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nfor ( ResourceAdaptorComponent otherComponent : resourceAdaptorComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nfor ( ResourceAdaptorTypeComponent otherComponent : resourceAdaptorTypeComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nfor ( SbbComponent otherComponent : sbbComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nfor ( ServiceComponent otherComponent : serviceComponents . values ( ) ) { \nif ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; \n} \nreturn result ; \n} \n} \n"}
{"6995": "public class SbbEntityFactoryCacheData { \npublic Set < SbbEntityID > getSbbEntities ( ) { \nfinal Node node = getNode ( ) ; \nif ( node == null ) return Collections . emptySet ( ) ; \nHashSet < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; \nServiceID serviceID = null ; \nfor ( Object obj : node . getChildrenNames ( ) ) { \nserviceID = ( ServiceID ) obj ; \nfor ( SbbEntityID sbbEntityID : getRootSbbEntityIDs ( serviceID ) ) { \nresult . add ( sbbEntityID ) ; \ncollectSbbEntities ( sbbEntityID , result ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6998": "public class ProfileTableImpl { \npublic boolean profileExists ( String profileName ) { \nboolean result = component . getProfileEntityFramework ( ) . findProfile ( this . getProfileTableName ( ) , profileName ) != null ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Profile named \" + profileName + ( result ? \"\" : \" does not\" ) + \" exists on table named \" + this . getProfileTableName ( ) ) ; \nreturn result ; \n} \n} \n"}
{"6999": "public class ProfileTableImpl { \npublic void remove ( boolean isUninstall ) throws SLEEException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"removeProfileTable: removing profileTable=\" + profileTableName ) ; \nfor ( ProfileID profileID : getProfiles ( ) ) { \nthis . removeProfile ( profileID . getProfileName ( ) , false , isUninstall ) ; \n} \nif ( getDefaultProfileEntity ( ) != null ) this . removeProfile ( null , false , false ) ; \nTransactionalAction commitAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \ntraceMBeanImpl . deregisterNotificationSource ( new ProfileTableNotification ( profileTableName ) ) ; \ncloseUncommittedProfileMBeans ( ) ; \n} \n} \n; \nsleeContainer . getTransactionManager ( ) . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( commitAction ) ; \nif ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) endActivity ( ) ; \nunregisterUsageMBean ( ) ; \nprofileManagement . getObjectPoolManagement ( ) . removeObjectPool ( this , sleeContainer . getTransactionManager ( ) ) ; \n} \n} \n"}
{"7000": "public class ResourceAdaptorEntityImpl { \npublic void updateConfigurationProperties ( ConfigProperties properties ) throws InvalidConfigurationException , InvalidStateException { \nif ( ! component . getDescriptor ( ) . getSupportsActiveReconfiguration ( ) && ( sleeContainer . getSleeState ( ) != SleeState . STOPPED ) && ( state == ResourceAdaptorEntityState . ACTIVE || state == ResourceAdaptorEntityState . STOPPING ) ) throw new InvalidStateException ( \"the value of the supports-active-reconfiguration attribute of the resource-adaptor-class element in the deployment descriptor of the Resource Adaptor of the resource adaptor entity is False and the resource adaptor entity is in the Active or Stopping state and the SLEE is in the Starting, Running, or Stopping state\" ) ; \nelse object . raConfigurationUpdate ( properties ) ; \n} \n} \n"}
{"7001": "public class ResourceAdaptorEntityImpl { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public void sleeRunning ( ) throws InvalidStateException { \nif ( this . state . isActive ( ) ) { \nif ( setFTContext ) { \nsetFTContext = false ; \nif ( object . isFaultTolerant ( ) ) try { \nthis . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; \nobject . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity \" + name , t ) ; \n} \n} \ntry { \nobject . raActive ( ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking raActive() for entity \" + name , t ) ; \n} \n} \n} \n} \n"}
{"7003": "public class ResourceAdaptorEntityImpl { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public void activate ( ) throws InvalidStateException { \nif ( ! this . state . isInactive ( ) ) throw new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \nthis . state = ResourceAdaptorEntityState . ACTIVE ; \nif ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { \nif ( setFTContext ) { \nsetFTContext = false ; \nif ( object . isFaultTolerant ( ) ) try { \nthis . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; \nobject . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity \" + name , t ) ; \n} \n} \ntry { \nobject . raActive ( ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking raActive() for entity \" + name , t ) ; \n} \n} \n} \n} \n"}
{"7004": "public class ResourceAdaptorEntityImpl { \npublic void deactivate ( ) throws InvalidStateException , TransactionRequiredLocalException { \nif ( ! this . state . isActive ( ) ) throw new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \nthis . state = ResourceAdaptorEntityState . STOPPING ; \nif ( object . getState ( ) == ResourceAdaptorObjectState . ACTIVE ) object . raStopping ( ) ; \nTimerTask t = new TimerTask ( ) { \n@ Override public void run ( ) { \ntry { \ncancel ( ) ; \nif ( state == ResourceAdaptorEntityState . STOPPING ) if ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) scheduleAllActivitiesEnd ( ) ; \nelse allActivitiesEnded ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \nresourceAdaptorContext . getTimer ( ) . schedule ( t , 500 ) ; \n} \n} \n"}
{"7005": "public class ResourceAdaptorEntityImpl { \nprivate void scheduleAllActivitiesEnd ( ) throws TransactionRequiredLocalException { \nboolean skipActivityEnding = ! sleeContainer . getCluster ( ) . isSingleMember ( ) ; \nif ( ! skipActivityEnding && hasActivities ( ) ) { \nlogger . info ( \"RA entity \" + name + \" activities end scheduled.\" ) ; \ntimerTask = new EndAllActivitiesRAEntityTimerTask ( this , sleeContainer ) ; \n} \nelse allActivitiesEnded ( ) ; \n} \n} \n"}
{"7006": "public class ResourceAdaptorEntityImpl { \npublic void remove ( ) throws InvalidStateException { \nif ( ! this . state . isInactive ( ) ) throw new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \nobject . raUnconfigure ( ) ; \nif ( object . isFaultTolerant ( ) ) { \nobject . unsetFaultTolerantResourceAdaptorContext ( ) ; \nftResourceAdaptorContext . shutdown ( ) ; \n} \nobject . unsetResourceAdaptorContext ( ) ; \nthis . sleeContainer . getTraceManagement ( ) . deregisterNotificationSource ( this . getNotificationSource ( ) ) ; \nstate = null ; \n} \n} \n"}
{"7008": "public class ResourceAdaptorEntityImpl { \npublic void serviceActive ( ServiceID serviceID ) { \ntry { \nReceivableService receivableService = resourceAdaptorContext . getServiceLookupFacility ( ) . getReceivableService ( serviceID ) ; \nif ( receivableService . getReceivableEvents ( ) . length > 0 ) object . serviceActive ( receivableService ) ; \n} \ncatch ( Throwable e ) { \nlogger . warn ( \"invocation resulted in unchecked exception\" , e ) ; \n} \n} \n} \n"}
{"7009": "public class ResourceAdaptorEntityImpl { \nActivityHandle derreferActivityHandle ( ActivityHandle handle ) { \nActivityHandle ah = null ; \nif ( resourceManagement . getHandleReferenceFactory ( ) != null && handle . getClass ( ) == ActivityHandleReference . class ) { \nActivityHandleReference ahReference = ( ActivityHandleReference ) handle ; \nah = resourceManagement . getHandleReferenceFactory ( ) . getActivityHandle ( ahReference ) ; \n} \nelse ah = handle ; \nreturn ah ; \n} \n} \n"}
{"7010": "public class ResourceAdaptorEntityImpl { \npublic void activityEnded ( final ActivityHandle handle , int activityFlags ) { \nlogger . trace ( \"activityEnded( handle = \" + handle + \" )\" ) ; \nActivityHandle ah = null ; \nif ( handle instanceof ActivityHandleReference ) ah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; \nelse ah = handle ; \nif ( ah != null && ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) object . activityEnded ( ah ) ; \nif ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) synchronized ( this ) { \nif ( ! hasActivities ( ) ) { \nif ( timerTask != null ) timerTask . cancel ( ) ; \nallActivitiesEnded ( ) ; \n} \n} \n} \n} \n"}
{"7011": "public class ResourceAdaptorObjectImpl { \npublic void raConfigurationUpdate ( ConfigProperties properties ) throws InvalidConfigurationException { \nif ( doTraceLogs ) logger . trace ( \"raConfigurationUpdate( properties = \" + properties + \" )\" ) ; \nverifyConfigProperties ( properties ) ; \nobject . raConfigurationUpdate ( configProperties ) ; \n} \n} \n"}
{"7012": "public class ResourceAdaptorObjectImpl { \nprivate void verifyConfigProperties ( ConfigProperties newProperties ) throws InvalidConfigurationException { \nif ( doTraceLogs ) logger . trace ( \"verifyConfigProperties( newProperties = \" + newProperties + \" )\" ) ; \nfor ( ConfigProperties . Property configProperty : configProperties . getProperties ( ) ) { \nif ( newProperties . getProperty ( configProperty . getName ( ) ) == null ) newProperties . addProperty ( configProperty ) ; \n} \nfor ( ConfigProperties . Property entityProperty : newProperties . getProperties ( ) ) { \nif ( entityProperty . getValue ( ) == null ) throw new InvalidConfigurationException ( \"the property \" + entityProperty . getName ( ) + \" has null value\" ) ; \n} \nobject . raVerifyConfiguration ( newProperties ) ; \nconfigProperties = newProperties ; \n} \n} \n"}
{"7013": "public class ResourceAdaptorObjectImpl { \npublic void raStopping ( ) throws InvalidStateException { \nif ( doTraceLogs ) logger . trace ( \"raStopping()\" ) ; \nif ( state == ResourceAdaptorObjectState . ACTIVE ) { \nstate = ResourceAdaptorObjectState . STOPPING ; \nobject . raStopping ( ) ; \n} \nelse throw new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \n} \n"}
{"7014": "public class ResourceAdaptorObjectImpl { \npublic void raInactive ( ) throws InvalidStateException { \nif ( doTraceLogs ) logger . trace ( \"raInactive()\" ) ; \nif ( state == ResourceAdaptorObjectState . STOPPING ) { \nstate = ResourceAdaptorObjectState . INACTIVE ; \nobject . raInactive ( ) ; \n} \nelse throw new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \n} \n"}
{"7015": "public class ResourceAdaptorObjectImpl { \npublic void raUnconfigure ( ) throws InvalidStateException { \nif ( doTraceLogs ) logger . trace ( \"raUnconfigure()\" ) ; \nif ( state == ResourceAdaptorObjectState . INACTIVE ) { \nstate = ResourceAdaptorObjectState . UNCONFIGURED ; \nobject . raUnconfigure ( ) ; \n} \nelse throw new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \n} \n"}
{"7016": "public class ResourceAdaptorObjectImpl { \npublic void unsetResourceAdaptorContext ( ) throws InvalidStateException { \nif ( doTraceLogs ) logger . trace ( \"unsetResourceAdaptorContext()\" ) ; \nif ( state == ResourceAdaptorObjectState . UNCONFIGURED ) { \nobject . unsetResourceAdaptorContext ( ) ; \nstate = null ; \n} \nelse throw new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \n} \n"}
{"7017": "public class ResourceAdaptorObjectImpl { \n@ SuppressWarnings ( \"unchecked\" ) public void unsetFaultTolerantResourceAdaptorContext ( ) throws IllegalArgumentException { \nif ( doTraceLogs ) logger . trace ( \"unsetFaultTolerantResourceAdaptorContext()\" ) ; \nif ( isFaultTolerant ( ) ) ( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) . unsetFaultTolerantResourceAdaptorContext ( ) ; \nelse throw new IllegalArgumentException ( \"RA Object is not fault tolerant!\" ) ; \n} \n} \n"}
{"7018": "public class ProfileSpecificationComponentImpl { \nprivate void buildProfileAttributeMap ( ) throws DeploymentException { \nHashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; \nClass < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; \nString attributeGetterMethodPrefix = \"get\" ; \nfor ( Method method : cmpInterface . getMethods ( ) ) { \nif ( ! method . getDeclaringClass ( ) . equals ( Object . class ) && method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { \nString attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; \nswitch ( attributeName . length ( ) ) { \ncase 0 : throw new DeploymentException ( \"the profile cmp interface class has an invalid attribute getter method name > \" + method . getName ( ) ) ; \ncase 1 : attributeName = attributeName . toLowerCase ( ) ; \nbreak ; \ndefault : attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; \nbreak ; \n} \nProfileAttributeImpl profileAttribute = null ; \ntry { \nprofileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; \n} \ncatch ( Throwable e ) { \nthrow new DeploymentException ( \"Invalid profile cmp interface attribute getter method definition ( name = \" + attributeName + \" , type = \" + method . getReturnType ( ) + \" )\" , e ) ; \n} \nif ( isSlee11 ( ) ) for ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { \nif ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) profileAttribute . setUnique ( cmpField . isUnique ( ) ) ; \n} \nelse for ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { \nif ( profileIndex . getName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setIndex ( true ) ; \nprofileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; \n} \n} \nmap . put ( attributeName , profileAttribute ) ; \n} \n} \nprofileAttributeMap = Collections . unmodifiableMap ( map ) ; \n} \n} \n"}
{"7019": "public class EventContextSuspensionHandler { \nprivate void resume ( ) { \nRunnable runnable = new Runnable ( ) { \npublic void run ( ) { \nif ( scheduledFuture == null ) return ; \nscheduledFuture . cancel ( false ) ; \nscheduledFuture = null ; \nfor ( EventContext ec : barriedEvents ) { \nec . getLocalActivityContext ( ) . getExecutorService ( ) . routeEvent ( ec ) ; \n} \nbarriedEvents = null ; \nevent . getLocalActivityContext ( ) . getEventQueueManager ( ) . removeBarrier ( transaction ) ; \nsuspended = false ; \nevent . getLocalActivityContext ( ) . getCurrentEventRoutingTask ( ) . run ( ) ; \n} \n} \n; \nevent . getLocalActivityContext ( ) . getExecutorService ( ) . execute ( runnable ) ; \n} \n} \n"}
{"7021": "public class AbstractUsageMBeanImplParent { \npublic void remove ( ) { \nLogger logger = getLogger ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Closing \" + toString ( ) ) ; \nfinal MBeanServer mbeanServer = sleeContainer . getMBeanServer ( ) ; \ntry { \nmbeanServer . unregisterMBean ( getObjectName ( ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"failed to remove \" + toString ( ) , e ) ; \n} \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Removing all named usage parameters of \" + toString ( ) ) ; \nfor ( String name : usageMBeans . keySet ( ) ) { \ntry { \n_removeUsageParameterSet ( name , false ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \ntry { \nremoveUsageParameterSet ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"7023": "public class ProfileAbstractClassDecorator { \npublic boolean decorateAbstractClass ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nProfileAbstractClassDescriptor abstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; \nif ( abstractClass == null ) return false ; \nString abstractClassName = abstractClass . getProfileAbstractClassName ( ) ; \ntry { \nctClass = pool . get ( abstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Class: \" + abstractClassName , nfe ) ; \n} \ndecorateClassJNDIAddToEnvironmentCalls ( ) ; \nif ( isAbstractClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nctClass . writeFile ( deployDir ) ; \nctClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Modified Abstract Class \" + ctClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nctClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"7025": "public class SbbAbstractMethodHandler { \npublic static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address , ServiceID serviceID ) { \nif ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) throw new SLEEException ( \"congestion control refused event\" ) ; \nif ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null || sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( \"SbbObject not assigned!\" ) ; \nif ( eventObject == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The event ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \nif ( aci == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The activity ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \nfinal SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; \ntxManager . mandateTransaction ( ) ; \nActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) . getActivityContext ( ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"invoke(): firing event on \" + ac ) ; \nif ( ac . isEnding ( ) ) throw new IllegalStateException ( \"activity context \" + ac . getActivityContextHandle ( ) + \" is ending\" ) ; \nfinal EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; \nif ( transactionData != null ) { \nfinal EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; \nif ( eventBeingDelivered != null && eventBeingDelivered . getEvent ( ) == eventObject ) { \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; \nreturn ; \n} \n} \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; \n} \n} \n"}
{"7026": "public class SbbAbstractMethodHandler { \npublic static Object getProfileCMPMethod ( SbbEntity sbbEntity , String getProfileCMPMethodName , ProfileID profileID ) throws UnrecognizedProfileTableNameException , UnrecognizedProfileNameException { \nGetProfileCMPMethodDescriptor mGetProfileCMPMethod = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getGetProfileCMPMethods ( ) . get ( getProfileCMPMethodName ) ; \nif ( mGetProfileCMPMethod == null ) throw new AbstractMethodError ( \"Profile CMP Method not found\" ) ; \nif ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( \"Could not invoke getProfileCMP Method, Sbb Object is not in the READY state!\" ) ; \nProfileManagement sleeProfileManager = sleeContainer . getSleeProfileTableManager ( ) ; \nProfileTable profileTable = sleeProfileManager . getProfileTable ( profileID . getProfileTableName ( ) ) ; \nif ( ! profileTable . profileExists ( profileID . getProfileName ( ) ) ) throw new UnrecognizedProfileNameException ( profileID . toString ( ) ) ; \nreturn profileTable . getProfile ( profileID . getProfileName ( ) ) . getProfileCmpSlee10Wrapper ( ) ; \n} \n} \n"}
{"7027": "public class SbbAbstractMethodHandler { \npublic static Object getSbbUsageParameterSet ( SbbEntity sbbEntity , String name ) throws UnrecognizedUsageParameterSetNameException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"getSbbUsageParameterSet(): serviceId = \" + sbbEntity . getSbbEntityId ( ) . getServiceID ( ) + \" , sbbID = \" + sbbEntity . getSbbId ( ) + \" , name = \" + name ) ; \nreturn getServiceUsageMBeanImpl ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) . getInstalledUsageParameterSet ( sbbEntity . getSbbId ( ) , name ) ; \n} \n} \n"}
{"7028": "public class ClassUtils { \npublic static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { \nHashMap abstractMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) if ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) abstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; \nreturn abstractMethods ; \n} \n} \n"}
{"7029": "public class ClassUtils { \npublic static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { \nHashMap interfaceMethods = new HashMap ( ) ; \nCtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) if ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { \nConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; \ninterfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \nMap temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; \nfor ( Iterator i = temp . keySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nString key = ( String ) i . next ( ) ; \nif ( ! exceptMethods . containsKey ( key ) ) interfaceMethods . put ( key , temp . get ( key ) ) ; \n} \nreturn interfaceMethods ; \n} \n} \n"}
{"7030": "public class ProfileObjectPoolManagement { \npublic void createObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Creating Pool for \" + profileTable ) ; \ncreateObjectPool ( profileTable ) ; \nif ( sleeTransactionManager != null ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Due to tx rollback, removing pool for \" + profileTable ) ; \ntry { \nremoveObjectPool ( profileTable ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to remove table's \" + profileTable + \" object pool\" , e ) ; \n} \n} \n} \n; \nsleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \n} \n"}
{"7031": "public class ProfileObjectPoolManagement { \npublic void removeObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Removing Pool for \" + profileTable ) ; \nremoveObjectPool ( profileTable ) ; \n} \n} \n; \nif ( sleeTransactionManager != null ) sleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action ) ; \nelse action . execute ( ) ; \n} \n} \n"}
{"7033": "public class AlarmMBeanImpl { \npublic String raiseAlarm ( NotificationSourceWrapper notificationSource , String alarmType , String instanceID , AlarmLevel level , String message , Throwable cause ) { \nsynchronized ( notificationSource ) { \nif ( isAlarmAlive ( notificationSource , alarmType , instanceID ) ) { \nAlarm a = null ; \ntry { \nAlarmPlaceHolder localAPH = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID ) ; \nfor ( Map . Entry < String , AlarmPlaceHolder > e : this . alarmIdToAlarm . entrySet ( ) ) { \nif ( e . getValue ( ) . equals ( localAPH ) ) { \na = e . getValue ( ) . getAlarm ( ) ; \nbreak ; \n} \n} \n} \ncatch ( Exception e ) { \n} \nif ( a != null ) return a . getAlarmID ( ) ; \nelse return this . raiseAlarm ( notificationSource , alarmType , instanceID , level , message , cause ) ; \n} \nelse { \nAlarm a = new Alarm ( UUID . randomUUID ( ) . toString ( ) , notificationSource . getNotificationSource ( ) , alarmType , instanceID , level , message , cause , System . currentTimeMillis ( ) ) ; \nAlarmPlaceHolder aph = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID , a ) ; \nthis . alarmIdToAlarm . put ( a . getAlarmID ( ) , aph ) ; \nthis . placeHolderToNotificationSource . put ( aph , aph . getNotificationSource ( ) . getNotificationSource ( ) ) ; \ngenerateNotification ( aph , false ) ; \nreturn a . getAlarmID ( ) ; \n} \n} \n} \n} \n"}
{"7034": "public class ProfileManagementHandler { \npublic static Object getUsageParameterSet ( ProfileObjectImpl profileObject , String name ) throws UnrecognizedUsageParameterSetNameException { \nif ( logger . isDebugEnabled ( ) ) logger . info ( \"[getUsageParameterSet(\" + name + \")] @ \" + profileObject ) ; \nif ( name == null ) throw new NullPointerException ( \"UsageParameterSet name must not be null.\" ) ; \nProfileTableImpl profileTable = profileObject . getProfileTable ( ) ; \nObject result = profileTable . getProfileTableUsageMBean ( ) . getInstalledUsageParameterSet ( name ) ; \nif ( result == null ) throw new UnrecognizedUsageParameterSetNameException ( ) ; \nelse return result ; \n} \n} \n"}
{"7035": "public class EventTypeComponentImpl { \npublic javax . slee . management . EventTypeDescriptor getSpecsDescriptor ( ) { \nif ( specsDescriptor == null ) specsDescriptor = new javax . slee . management . EventTypeDescriptor ( getEventTypeID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , descriptor . getLibraryRefs ( ) . toArray ( new LibraryID [ descriptor . getLibraryRefs ( ) . size ( ) ] ) , getDescriptor ( ) . getEventClassName ( ) ) ; \nreturn specsDescriptor ; \n} \n} \n"}
{"7036": "public class SLEESubDeployer { \npublic boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nURL url = du . getUrl ( ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Method accepts called for \" + url + \" [DU: \" + deployableUnitName + \"]\" ) ; \ntry { \nString fullPath = url . getFile ( ) ; \nString fileName = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 , fullPath . length ( ) ) ; \nif ( toAccept . containsKey ( fileName ) ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \nreturn true ; \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nif ( du . getEntry ( \"META-INF/deployable-unit.xml\" ) != null ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \nreturn true ; \n} \n} \nfinally { \nif ( duJarFile != null ) try { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \ncatch ( Exception ignore ) { \n} \nreturn false ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) try { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7038": "public class SLEESubDeployer { \npublic void start ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Method start called for \" + du . getUrl ( ) + \" [DU: \" + deployableUnitName + \"]\" ) ; \ntry { \nDeployableUnit realDU = deployableUnits . get ( du . getFileName ( ) ) ; \nif ( realDU != null ) { \nwhile ( isInUndeployList ( du . getFileName ( ) ) ) Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \nsleeContainerDeployer . getDeploymentManager ( ) . installDeployableUnit ( realDU ) ; \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"\" , e ) ; \n} \n} \n} \n"}
{"7039": "public class SLEESubDeployer { \npublic void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"stop( deployableUnitURL = : \" + deployableUnitURL + \" )\" ) ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nDeployableUnit realDU = null ; \nString fileName = du . getFileName ( ) ; \nif ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Got DU: \" + realDU . getDeploymentInfoShortName ( ) ) ; \nif ( ! isInUndeployList ( fileName ) ) addToUndeployList ( fileName ) ; \ntry { \nsleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; \ndeployableUnits . remove ( fileName ) ; \nremoveFromUndeployList ( fileName ) ; \n} \ncatch ( DependencyException e ) { \n} \ncatch ( Exception e ) { \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof InvalidStateException ) logger . warn ( cause . getLocalizedMessage ( ) + \"... WAITING ...\" ) ; \nelse if ( e instanceof DeploymentException ) throw new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; \nelse logger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"7041": "public class TransactionContextImpl { \nprotected void executeAfterCommitActions ( ) { \nif ( afterCommitActions != null ) { \nif ( trace ) logger . trace ( \"Executing after commit actions\" ) ; \nexecuteActions ( afterCommitActions , trace ) ; \nafterCommitActions = null ; \n} \n} \n} \n"}
{"7042": "public class TransactionContextImpl { \nprotected void executeAfterCommitPriorityActions ( ) { \nif ( afterCommitPriorityActions != null ) { \nif ( trace ) logger . trace ( \"Executing after commit priority actions\" ) ; \nexecuteActions ( afterCommitPriorityActions , trace ) ; \nafterCommitPriorityActions = null ; \n} \n} \n} \n"}
{"7043": "public class TransactionContextImpl { \nprotected void executeAfterRollbackActions ( ) { \nif ( afterRollbackActions != null ) { \nif ( trace ) logger . trace ( \"Executing rollback actions\" ) ; \nexecuteActions ( afterRollbackActions , trace ) ; \nafterRollbackActions = null ; \n} \n} \n} \n"}
{"7044": "public class TransactionContextImpl { \nprotected void executeBeforeCommitActions ( ) { \nif ( beforeCommitActions != null ) { \nif ( trace ) logger . trace ( \"Executing before commit actions\" ) ; \nexecuteActions ( beforeCommitActions , trace ) ; \nbeforeCommitActions = null ; \n} \n} \n} \n"}
{"7045": "public class TransactionContextImpl { \nprotected void executeBeforeCommitPriorityActions ( ) { \nif ( beforeCommitPriorityActions != null ) { \nif ( trace ) logger . trace ( \"Executing before commit priority actions\" ) ; \nexecuteActions ( beforeCommitPriorityActions , trace ) ; \nbeforeCommitPriorityActions = null ; \n} \n} \n} \n"}
{"7047": "public class TracerStorage { \npublic Tracer createTracer ( String tracerName , boolean requestedBySource ) { \nTracerImpl tparent = null ; \nTracerImpl t = tracers . get ( tracerName ) ; \nif ( t == null ) { \nString [ ] split = tracerName . split ( \"\\\\.\" ) ; \nString currentName = \"\" ; \nfor ( String s : split ) { \nif ( tparent == null ) { \ntparent = rootTracer ; \ncurrentName = s ; \n} \nelse currentName = currentName + \".\" + s ; \nt = tracers . get ( currentName ) ; \nif ( t == null ) { \nt = new TracerImpl ( currentName , tparent , this . notificationSource , this . traceFacility ) ; \nfinal TracerImpl u = tracers . putIfAbsent ( t . getTracerName ( ) , t ) ; \nif ( u != null ) t = u ; \n} \ntparent = t ; \n} \n} \nif ( requestedBySource ) t . setRequestedBySource ( requestedBySource ) ; \nreturn t ; \n} \n} \n"}
{"7050": "public class SleeComponentWithUsageParametersClassCodeGenerator { \npublic void process ( SleeComponentWithUsageParametersInterface component ) throws DeploymentException { \nClassPool classPool = component . getClassPool ( ) ; \nString deploymentDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nClass < ? > usageParametersInterface = component . getUsageParametersInterface ( ) ; \nif ( usageParametersInterface != null ) try { \ncomponent . setUsageParametersConcreteClass ( new ConcreteUsageParameterClassGenerator ( usageParametersInterface . getName ( ) , deploymentDir , classPool ) . generateConcreteUsageParameterClass ( ) ) ; \nif ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( \"Generated usage parameter impl class for \" + component ) ; \nnew ConcreteUsageParameterMBeanGenerator ( component ) . generateConcreteUsageParameterMBean ( ) ; \nif ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( \"Generated usage mbean (interface and impl) for \" + component ) ; \n} \ncatch ( DeploymentException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nthrow new DeploymentException ( \"Failed to generate \" + component + \" usage parameter class\" , ex ) ; \n} \n} \n} \n"}
{"7052": "public class SbbObjectPoolManagementImpl { \npublic void createObjectPool ( final ServiceID serviceID , final SbbComponent sbbComponent , final SleeTransactionManager sleeTransactionManager ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Creating Pool for  \" + serviceID + \" and \" + sbbComponent ) ; \ncreateObjectPool ( serviceID , sbbComponent ) ; \nif ( sleeTransactionManager != null && sleeTransactionManager . getTransactionContext ( ) != null ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Due to tx rollback, removing pool for \" + serviceID + \" and \" + sbbComponent ) ; \ntry { \nremoveObjectPool ( serviceID , sbbComponent . getSbbID ( ) ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to remove \" + serviceID + \" and \" + sbbComponent + \" object pool\" , e ) ; \n} \n} \n} \n; \nsleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \n} \n"}
{"7053": "public class SleeEndpointEndActivityNotTransactedExecutor { \nvoid execute ( final ActivityHandle handle ) throws UnrecognizedActivityHandleException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \ntry { \nsleeEndpoint . _endActivity ( handle , tx ) ; \n} \nfinally { \nif ( tx != null ) super . resumeTransaction ( tx ) ; \n} \n} \n} \n"}
{"7054": "public class SleeEndpointImpl { \nActivityContextHandle _startActivity ( ActivityHandle handle , int activityFlags , final SleeTransaction barrierTx ) { \nActivityContext ac = null ; \nif ( raEntity . getHandleReferenceFactory ( ) != null && ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) { \nfinal ActivityHandleReference reference = raEntity . getHandleReferenceFactory ( ) . createActivityHandleReference ( handle ) ; \ntry { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , reference ) , activityFlags ) ; \n} \ncatch ( ActivityAlreadyExistsException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nraEntity . getHandleReferenceFactory ( ) . removeActivityHandleReference ( reference ) ; \nthrow e ; \n} \n} \nelse ac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) , activityFlags ) ; \nif ( barrierTx != null && ac != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nreturn ac . getActivityContextHandle ( ) ; \n} \n} \n"}
{"7055": "public class SleeEndpointImpl { \nvoid _endActivity ( ActivityHandle handle , final SleeTransaction barrierTx ) throws UnrecognizedActivityHandleException { \nfinal ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; \nfinal ActivityContext ac = acFactory . getActivityContext ( ach ) ; \nif ( ac != null ) { \nif ( barrierTx != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nac . endActivity ( ) ; \n} \nelse throw new UnrecognizedActivityHandleException ( handle . toString ( ) ) ; \n} \n} \n"}
{"7056": "public class SleeEndpointImpl { \nprivate void checkFireEventPreconditions ( ActivityHandle handle , FireableEventType eventType , Object event ) throws NullPointerException , IllegalEventException , IllegalStateException { \nif ( event == null ) throw new NullPointerException ( \"event is null\" ) ; \nif ( handle == null ) throw new NullPointerException ( \"handle is null\" ) ; \nif ( eventType == null ) throw new NullPointerException ( \"eventType is null\" ) ; \nfinal EventTypeComponent eventTypeComponent = componentRepository . getComponentByID ( eventType . getEventType ( ) ) ; \nif ( eventTypeComponent == null ) throw new IllegalEventException ( \"event type not installed (more on SLEE 1.1 specs 15.14.8)\" ) ; \nif ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) throw new IllegalEventException ( \"the class of the event object fired is not assignable to the event class of the event type (more on SLEE 1.1 specs 15.14.8) \" ) ; \nif ( eventType . getClass ( ) != FireableEventTypeImpl . class ) throw new IllegalEventException ( \"unknown implementation of FireableEventType\" ) ; \nif ( raEntity . getAllowedEventTypes ( ) != null && ! raEntity . getAllowedEventTypes ( ) . contains ( eventType . getEventType ( ) ) ) throw new IllegalEventException ( \"Resource Adaptor configured to not ignore ra type event checking and the event \" + eventType . getEventType ( ) + \" does not belongs to any of the ra types implemented by the resource adaptor\" ) ; \n} \n} \n"}
{"7057": "public class SleeEndpointImpl { \nvoid _fireEvent ( ActivityHandle realHandle , ActivityHandle refHandle , FireableEventType eventType , Object event , Address address , ReceivableService receivableService , int eventFlags , final SleeTransaction barrierTx ) throws ActivityIsEndingException , SLEEException { \nfinal ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , refHandle ) ; \nfinal ActivityContext ac = acFactory . getActivityContext ( ach ) ; \nif ( ac == null ) throw new UnrecognizedActivityHandleException ( \"Unable to fire \" + eventType . getEventType ( ) + \" on activity handle \" + realHandle + \" , the handle is not mapped to an activity context\" ) ; \nelse { \nif ( barrierTx != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal EventProcessingCallbacks callbacks = new EventProcessingCallbacks ( realHandle , eventType , event , address , receivableService , eventFlags , raEntity ) ; \nfinal EventProcessingSucceedCallback succeedCallback = EventFlags . hasRequestProcessingSuccessfulCallback ( eventFlags ) ? callbacks : null ; \nfinal EventProcessingFailedCallback failedCallback = EventFlags . hasRequestProcessingFailedCallback ( eventFlags ) ? callbacks : null ; \nfinal EventUnreferencedCallback unreferencedCallback = EventFlags . hasRequestEventReferenceReleasedCallback ( eventFlags ) ? callbacks : null ; \nac . fireEvent ( eventType . getEventType ( ) , event , address , receivableService == null ? null : receivableService . getService ( ) , succeedCallback , failedCallback , unreferencedCallback ) ; \n} \n} \n} \n"}
{"7058": "public class ConcreteSbbLocalObjectGenerator { \npublic Class generateSbbLocalObjectConcreteClass ( ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"generateSbbLocalObjectConcreteClass: sbbLocalObjectInterface = \" + sbbLocalObjectName + \" deployPath = \" + deployPath ) ; \ntry { \nconcreteSbbLocalObject = pool . makeClass ( ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_PREFIX + sbbLocalObjectName + ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_SUFFIX ) ; \ntry { \nsleeSbbLocalObject = pool . get ( SbbLocalObjectImpl . class . getName ( ) ) ; \nsbbLocalObjectInterface = pool . get ( sbbLocalObjectName ) ; \n} \ncatch ( NotFoundException nfe ) { \nnfe . printStackTrace ( ) ; \nString s = \"Problem with pool \" ; \nlogger . error ( s , nfe ) ; \nthrow new RuntimeException ( s , nfe ) ; \n} \nCtClass concreteClassInterface ; \ntry { \nconcreteClassInterface = pool . get ( SbbLocalObjectConcrete . class . getName ( ) ) ; \n} \ncatch ( NotFoundException nfe ) { \nnfe . printStackTrace ( ) ; \nString s = \"Problem with the pool! \" ; \nlogger . error ( s , nfe ) ; \nthrow new RuntimeException ( s , nfe ) ; \n} \nConcreteClassGeneratorUtils . createInterfaceLinks ( concreteSbbLocalObject , new CtClass [ ] { \nsbbLocalObjectInterface , concreteClassInterface } \n) ; \nConcreteClassGeneratorUtils . createInheritanceLink ( concreteSbbLocalObject , sleeSbbLocalObject ) ; \nMap interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( sbbLocalObjectInterface ) ; \ngenerateConcreteMethods ( interfaceMethods , sbbAbstractClassName ) ; \ntry { \nconcreteSbbLocalObject . writeFile ( deployPath ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Concrete Class \" + concreteSbbLocalObject . getName ( ) + \" generated in the following path \" + deployPath ) ; \n} \ncatch ( CannotCompileException e ) { \nString s = \" Unexpected exception ! \" ; \nlogger . fatal ( s , e ) ; \nthrow new RuntimeException ( s , e ) ; \n} \ncatch ( IOException e ) { \nString s = \"IO Exception!\" ; \nlogger . error ( s , e ) ; \nreturn null ; \n} \ntry { \nreturn Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteSbbLocalObject . getName ( ) ) ; \n} \ncatch ( ClassNotFoundException e ) { \nlogger . error ( \"unable to load sbb local object impl class\" , e ) ; \nreturn null ; \n} \n} \nfinally { \nif ( this . concreteSbbLocalObject != null ) this . concreteSbbLocalObject . defrost ( ) ; \n} \n} \n} \n"}
{"7059": "public class AccessorOperation { \nprotected void makeGetter ( ) { \nif ( fieldClass . equals ( boolean . class ) || fieldClass . equals ( Boolean . class ) ) super . operationName = \"is\" + this . beanFieldName ; \nelse super . operationName = \"get\" + this . beanFieldName ; \n} \n} \n"}
{"7060": "public class AccessorOperation { \nprotected Object convert ( String optArg ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException , CommandException { \nif ( fieldClass . isPrimitive ( ) ) { \nif ( fieldClass . equals ( int . class ) ) return new Integer ( optArg ) ; \nelse if ( fieldClass . equals ( long . class ) ) return new Long ( optArg ) ; \nelse if ( fieldClass . equals ( int . class ) ) return new Integer ( optArg ) ; \nelse if ( fieldClass . equals ( byte . class ) ) return new Byte ( optArg ) ; \nelse if ( fieldClass . equals ( short . class ) ) return new Short ( optArg ) ; \nelse if ( fieldClass . equals ( float . class ) ) return new Float ( optArg ) ; \nelse if ( fieldClass . equals ( double . class ) ) return new Double ( optArg ) ; \nelse if ( fieldClass . equals ( boolean . class ) ) return new Boolean ( optArg ) ; \nelse if ( fieldClass . equals ( char . class ) ) return new Character ( optArg . charAt ( 0 ) ) ; \nthrow new CommandException ( \"Unpredicted place. Please report.\" ) ; \n} \nelse if ( isClassNumber ( ) ) { \nConstructor < ? > con = fieldClass . getConstructor ( String . class ) ; \nreturn con . newInstance ( optArg ) ; \n} \nreturn optArg ; \n} \n} \n"}
{"7062": "public class DeployableUnitInstallPanel { \nprivate String extractMessage ( String result ) { \nString startPreTag = \"<pre>\" ; \nString endPreTag = \"</pre>\" ; \nresult = result . trim ( ) ; \nif ( result . startsWith ( startPreTag ) && result . endsWith ( endPreTag ) ) result = result . substring ( startPreTag . length ( ) , result . length ( ) - endPreTag . length ( ) ) ; \nreturn result ; \n} \n} \n"}
{"7063": "public class ChildRelationImpl { \npublic boolean contains ( Object object ) { \nif ( ! ( object instanceof SbbLocalObject ) ) return false ; \nfinal SbbLocalObjectImpl sbblocal = ( SbbLocalObjectImpl ) object ; \nfinal SbbEntityID sbbEntityId = sbblocal . getSbbEntityId ( ) ; \nif ( ! idBelongsToChildRelation ( sbbEntityId ) ) return false ; \nreturn new SbbEntityCacheData ( sbbEntityId , sleeContainer . getCluster ( ) . getMobicentsCache ( ) ) . exists ( ) ; \n} \n} \n"}
{"7064": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean containsAll ( Collection c ) { \nif ( c == null ) throw new NullPointerException ( \"null collection!\" ) ; \nfor ( Iterator it = c . iterator ( ) ; \nit . hasNext ( ) ; \n) if ( ! contains ( it . next ( ) ) ) return false ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"containsAll : collection = \" + c + \" > all in child relation\" ) ; \nreturn true ; \n} \n} \n"}
{"7065": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean removeAll ( Collection c ) { \nboolean flag = true ; \nif ( c == null ) throw new NullPointerException ( \" null collection ! \" ) ; \nfor ( Iterator it = c . iterator ( ) ; \nit . hasNext ( ) ; \n) flag &= this . remove ( it . next ( ) ) ; \nreturn flag ; \n} \n} \n"}
{"7068": "public class ClassPool { \npublic void clean ( ) { \nfor ( ClassPath classPath : classPaths ) { \nclassPool . removeClassPath ( classPath ) ; \n} \nfor ( String classMade : classesMade ) { \ntry { \nclassPool . get ( classMade ) . detach ( ) ; \n} \ncatch ( NotFoundException e ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Failed to detach class \" + classMade + \" from class pool\" , e ) ; \n} \n} \n} \n} \n"}
{"7069": "public class ProfileCallRecorderTransactionData { \n@ SuppressWarnings ( \"unchecked\" ) public static void addProfileCall ( ProfileObjectImpl po ) throws SLEEException { \nSleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; \ntry { \nif ( sleeTransactionManager . getTransaction ( ) == null ) return ; \n} \ncatch ( SystemException se ) { \nthrow new SLEEException ( \"Unable to verify SLEE Transaction.\" , se ) ; \n} \nString key = makeKey ( po ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Recording call to profile. Key[\" + key + \"]\" ) ; \nfinal TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; \nProfileCallRecorderTransactionData data = ( ProfileCallRecorderTransactionData ) txContext . getData ( ) . get ( TRANSACTION_CONTEXT_KEY ) ; \nif ( data == null ) { \ndata = new ProfileCallRecorderTransactionData ( ) ; \ntxContext . getData ( ) . put ( TRANSACTION_CONTEXT_KEY , data ) ; \n} \nif ( ! po . isProfileReentrant ( ) ) { \nif ( data . invokedProfiles . contains ( key ) && data . invokedProfiles . getLast ( ) . compareTo ( key ) != 0 ) throw new SLEEException ( \"Detected loopback call. Call sequence: \" + data . invokedProfiles ) ; \ndata . invokedProfiles . add ( key ) ; \ndata . invokedProfileTablesNames . add ( po . getProfileTable ( ) . getProfileTableName ( ) ) ; \n} \n} \n} \n"}
{"7071": "public class ProfileTableTransactionView { \npublic static void passivateProfileObjectOnTxEnd ( SleeTransactionManager txManager , final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { \nTransactionalAction afterRollbackAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nprofileObject . invalidateObject ( ) ; \npool . returnObject ( profileObject ) ; \n} \n} \n; \nTransactionalAction beforeCommitAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( profileObject . getState ( ) == ProfileObjectState . READY ) { \nif ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) { \nprofileObject . fireAddOrUpdatedEventIfNeeded ( ) ; \nprofileObject . profilePassivate ( ) ; \n} \nelse profileObject . profileRemove ( true , false ) ; \npool . returnObject ( profileObject ) ; \n} \n} \n} \n; \nfinal TransactionContext txContext = txManager . getTransactionContext ( ) ; \ntxContext . getAfterRollbackActions ( ) . add ( afterRollbackAction ) ; \ntxContext . getBeforeCommitActions ( ) . add ( beforeCommitAction ) ; \n} \n} \n"}
{"7072": "public class ComponentIDArrayPropertyEditor { \npublic void setAsText ( String text ) { \nif ( text == null || text . equals ( \"\" ) ) super . setValue ( new ComponentID [ 0 ] ) ; \nelse { \njava . util . ArrayList results = new java . util . ArrayList ( ) ; \njava . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; \nComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; \nwhile ( st . hasMoreTokens ( ) ) { \ncidPropEditor . setAsText ( st . nextToken ( ) ) ; \nif ( st . hasMoreTokens ( ) ) st . nextToken ( ) ; \nresults . add ( cidPropEditor . getValue ( ) ) ; \n} \nComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; \nresults . toArray ( cid ) ; \nthis . setValue ( cid ) ; \n} \n} \n} \n"}
{"7073": "public class ConcreteActivityContextInterfaceGenerator { \npublic Class generateActivityContextInterfaceConcreteClass ( ) throws DeploymentException { \nString tmpClassName = ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_PREFIX + activityContextInterfaceName + ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_SUFFIX ; \nconcreteActivityContextInterface = pool . makeClass ( tmpClassName ) ; \nCtClass sbbActivityContextInterface = null ; \ntry { \nactivityContextInterface = pool . get ( activityContextInterfaceName ) ; \nsbbActivityContextInterface = pool . get ( SbbActivityContextInterfaceImpl . class . getName ( ) ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find aci \" + activityContextInterfaceName , nfe ) ; \n} \nConcreteClassGeneratorUtils . createInheritanceLink ( concreteActivityContextInterface , sbbActivityContextInterface ) ; \nConcreteClassGeneratorUtils . createInterfaceLinks ( concreteActivityContextInterface , new CtClass [ ] { \nactivityContextInterface } \n) ; \nMap interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( activityContextInterface ) ; \ngenerateConcreteMethods ( interfaceMethods ) ; \nString sbbDeploymentPathStr = deployDir ; \ntry { \nconcreteActivityContextInterface . writeFile ( sbbDeploymentPathStr ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Concrete Class \" + tmpClassName + \" generated in the following path \" + sbbDeploymentPathStr ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"problem generating concrete class\" , e ) ; \nthrow new DeploymentException ( \"problem generating concrete class! \" , e ) ; \n} \nClass clazz = null ; \ntry { \nclazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( tmpClassName ) ; \n} \ncatch ( Exception e1 ) { \nlogger . error ( \"problem loading generated class\" , e1 ) ; \nthrow new DeploymentException ( \"problem loading the generated class! \" , e1 ) ; \n} \nthis . concreteActivityContextInterface . defrost ( ) ; \nreturn clazz ; \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) return ; \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) concreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \nelse if ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) concreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \nelse throw new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \n} \n} \n"}
{"7075": "public class ActivityContextImpl { \npublic void setDataAttribute ( String key , Object newValue ) { \ncacheData . setCmpAttribute ( key , newValue ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Activity context with handle \" + getActivityContextHandle ( ) + \" set cmp attribute named \" + key + \" to value \" + newValue ) ; \n} \n} \n"}
{"7076": "public class ActivityContextImpl { \npublic void addNameBinding ( String aciName ) { \ncacheData . nameBound ( aciName ) ; \nif ( acReferencesHandler != null ) acReferencesHandler . nameReferenceCreated ( ) ; \n} \n} \n"}
{"7078": "public class ActivityContextImpl { \npublic boolean removeNameBinding ( String aciName ) { \nboolean removed = cacheData . nameUnbound ( aciName ) ; \nif ( removed && acReferencesHandler != null ) acReferencesHandler . nameReferenceRemoved ( ) ; \nreturn removed ; \n} \n} \n"}
{"7079": "public class ActivityContextImpl { \npublic boolean attachTimer ( TimerID timerID ) { \nif ( cacheData . attachTimer ( timerID ) ) { \nif ( acReferencesHandler != null ) acReferencesHandler . timerReferenceCreated ( ) ; \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"7081": "public class ActivityContextImpl { \npublic boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { \nboolean attached = cacheData . attachSbbEntity ( sbbEntityId ) ; \nif ( attached ) if ( acReferencesHandler != null ) acReferencesHandler . sbbeReferenceCreated ( false ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Attachement from sbb entity \" + sbbEntityId + \" to AC \" + getActivityContextHandle ( ) + \" result: \" + attached ) ; \nreturn attached ; \n} \n} \n"}
{"7082": "public class ActivityContextImpl { \npublic void detachSbbEntity ( SbbEntityID sbbEntityId ) throws javax . slee . TransactionRequiredLocalException { \nboolean detached = cacheData . detachSbbEntity ( sbbEntityId ) ; \nif ( detached && acReferencesHandler != null && ! isEnding ( ) ) { \nacReferencesHandler . sbbeReferenceRemoved ( ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Detached sbb entity \" + sbbEntityId + \" from AC with handle \" + getActivityContextHandle ( ) ) ; \n} \n} \n} \n"}
{"7083": "public class ActivityContextImpl { \npublic Set < SbbEntityID > getSortedSbbAttachmentSet ( Set < SbbEntityID > excludeSet ) { \nfinal Set < SbbEntityID > sbbAttachementSet = cacheData . getSbbEntitiesAttached ( ) ; \nSet < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; \nfor ( SbbEntityID sbbEntityId : sbbAttachementSet ) { \nif ( ! excludeSet . contains ( sbbEntityId ) ) result . add ( sbbEntityId ) ; \n} \nif ( result . size ( ) > 1 ) result = sleeContainer . getSbbEntityFactory ( ) . sortByPriority ( result ) ; \nreturn result ; \n} \n} \n"}
{"7084": "public class ActivityContextImpl { \npublic void endActivity ( ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Ending activity context with handle \" + getActivityContextHandle ( ) ) ; \nif ( cacheData . setEnding ( true ) ) fireEvent ( sleeContainer . getEventContextFactory ( ) . createActivityEndEventContext ( this , new ActivityEndEventUnreferencedCallback ( getActivityContextHandle ( ) , factory ) ) , sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ) ; \n} \n} \n"}
{"7085": "public class DeployableUnit { \npublic void addComponent ( DeployableComponent dc ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Adding Component \" + dc . getComponentKey ( ) ) ; \ncomponents . add ( dc ) ; \ncomponentIDs . add ( dc . getComponentKey ( ) ) ; \ndependencies . addAll ( dc . getDependencies ( ) ) ; \ninstallActions . addAll ( dc . getInstallActions ( ) ) ; \nCollection < ManagementAction > postInstallActionsStrings = postInstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( postInstallActionsStrings != null && ! postInstallActionsStrings . isEmpty ( ) ) installActions . addAll ( postInstallActionsStrings ) ; \nCollection < ManagementAction > preUninstallActionsStrings = preUninstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( preUninstallActionsStrings != null ) uninstallActions . addAll ( preUninstallActionsStrings ) ; \nuninstallActions . addAll ( dc . getUninstallActions ( ) ) ; \n} \n} \n"}
{"7088": "public class DeployableUnit { \npublic boolean hasDuplicates ( ) { \nArrayList < String > duplicates = new ArrayList < String > ( ) ; \nfor ( String componentId : componentIDs ) { \nif ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) . contains ( componentId ) ) duplicates . add ( componentId ) ; \n} \nif ( ! duplicates . isEmpty ( ) ) { \nlogger . warn ( \"The deployable unit '\" + this . diShortName + \"' contains components that are already deployed. The following are already installed:\" ) ; \nfor ( String dupComponent : duplicates ) { \nlogger . warn ( \" - \" + dupComponent ) ; \n} \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7089": "public class DeployableUnit { \npublic Collection < ManagementAction > getInstallActions ( ) { \nArrayList < ManagementAction > iActions = new ArrayList < ManagementAction > ( ) ; \nif ( ! postInstallActions . values ( ) . isEmpty ( ) ) for ( String componentId : postInstallActions . keySet ( ) ) { \niActions . addAll ( postInstallActions . get ( componentId ) ) ; \n} \niActions . addAll ( installActions ) ; \nreturn iActions ; \n} \n} \n"}
{"7090": "public class DeployableUnit { \npublic Collection < ManagementAction > getUninstallActions ( ) { \nCollection < ManagementAction > uActions = new ArrayList < ManagementAction > ( uninstallActions ) ; \nuActions . add ( new UninstallDeployableUnitAction ( diURL . toString ( ) , sleeContainerDeployer . getDeploymentMBean ( ) ) ) ; \nif ( ! preUninstallActions . values ( ) . isEmpty ( ) ) for ( String componentId : preUninstallActions . keySet ( ) ) { \nuActions . addAll ( preUninstallActions . get ( componentId ) ) ; \n} \nreturn uActions ; \n} \n} \n"}
{"7091": "public class DeployableUnit { \nprivate boolean hasReferringDU ( ) throws Exception { \nSleeContainer sC = SleeContainer . lookupFromJndi ( ) ; \nfor ( String componentIdString : this . getComponents ( ) ) { \nComponentIDPropertyEditor cidpe = new ComponentIDPropertyEditor ( ) ; \ncidpe . setAsText ( componentIdString ) ; \nComponentID componentId = ( ComponentID ) cidpe . getValue ( ) ; \nfor ( ComponentID referringComponentId : sC . getComponentRepository ( ) . getReferringComponents ( componentId ) ) { \nComponentIDPropertyEditor rcidpe = new ComponentIDPropertyEditor ( ) ; \nrcidpe . setValue ( referringComponentId ) ; \nString referringComponentIdString = rcidpe . getAsText ( ) ; \nif ( ! this . getComponents ( ) . contains ( referringComponentIdString ) ) return true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"7094": "public class AbstractProfileMBeanImpl { \nprivate void writeMode ( ) throws SLEEException , ManagementException { \nif ( ! isProfileWriteable ( ) ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Changing state to read-write, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \nProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; \nprofileObject . getProfileEntity ( ) . setReadOnly ( false ) ; \nstate = State . write ; \n} \nelse if ( logger . isDebugEnabled ( ) ) logger . debug ( \"Already in write state, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \n} \n"}
{"7095": "public class AbstractProfileMBeanImpl { \nprotected void beforeSetCmpField ( ) throws ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"beforeSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \nif ( isProfileWriteable ( ) ) try { \nsleeContainer . getTransactionManager ( ) . resume ( transaction ) ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \nelse throw new InvalidStateException ( ) ; \n} \n} \n"}
{"7096": "public class AbstractProfileMBeanImpl { \nprotected void afterSetCmpField ( ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"afterSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \ntry { \nsleeContainer . getTransactionManager ( ) . suspend ( ) ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"7097": "public class AbstractProfileMBeanImpl { \nprotected boolean beforeGetCmpField ( ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"beforeGetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \nreturn beforeNonSetCmpField ( ) ; \n} \n} \n"}
{"7098": "public class AbstractProfileMBeanImpl { \nprotected void afterGetCmpField ( boolean activatedTransaction ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"afterGetCmpField( activatedTransaction = \" + activatedTransaction + \" ) on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \nafterNonSetCmpField ( activatedTransaction ) ; \n} \n} \n"}
{"7099": "public class AbstractProfileMBeanImpl { \nprotected boolean beforeManagementMethodInvocation ( ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"beforeManagementMethodInvocation() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \njndiManagement = sleeContainer . getJndiManagement ( ) ; \njndiManagement . pushJndiContext ( profileTable . getProfileSpecificationComponent ( ) ) ; \nreturn beforeNonSetCmpField ( ) ; \n} \n} \n"}
{"7100": "public class AbstractProfileMBeanImpl { \nprotected void afterManagementMethodInvocation ( boolean activatedTransaction ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"afterManagementMethodInvocation( activatedTransaction = \" + activatedTransaction + \" ) on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \nafterNonSetCmpField ( activatedTransaction ) ; \njndiManagement . popJndiContext ( ) ; \n} \n} \n"}
{"7101": "public class DeployableUnitImpl { \nprivate void deletePath ( File path ) { \nif ( path . isDirectory ( ) ) { \nFile [ ] files = path . listFiles ( ) ; \nif ( files != null ) for ( File file : files ) { \ndeletePath ( file ) ; \n} \n} \npath . delete ( ) ; \n} \n} \n"}
{"7103": "public class ConcreteSbbGenerator { \nprivate void createDefaultUsageParameterGetter ( CtClass sbbConcrete ) throws DeploymentException { \nString methodName = \"getDefaultSbbUsageParameterSet\" ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \nif ( method != null ) try { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{ return ($r)\" + SbbAbstractMethodHandler . class . getName ( ) + \".getDefaultSbbUsageParameterSet(sbbEntity); }\" ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( CannotCompileException cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , cce ) ; \n} \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \nif ( method != null ) try { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( int i = 0 ; \ni < method . getParameterTypes ( ) . length ; \ni ++ ) concreteMethodBody += \",$\" + ( i + 1 ) ; \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n"}
{"7106": "public class ConcreteSbbGenerator { \nprotected void createGetSbbActivityContextInterfaceMethod ( CtClass activityContextInterface , Class < ? > concreteActivityContextInterfaceClass ) throws DeploymentException { \nString methodToAdd = \"public \" + activityContextInterface . getName ( ) + \" asSbbActivityContextInterface(javax.slee.ActivityContextInterface aci) {\" + \"if(aci==null)\" + \"     throw new \" + IllegalStateException . class . getName ( ) + \"(\\\"Passed argument can not be of null value.\\\");\" + \" if(sbbEntity == null || sbbEntity.getSbbObject().getState() != \" + SbbObjectState . class . getName ( ) + \".READY) { throw new \" + IllegalStateException . class . getName ( ) + \"(\\\"Cannot call asSbbActivityContextInterface\\\"); } \" + \"else if ( aci instanceof \" + concreteActivityContextInterfaceClass . getName ( ) + \") return aci;\" + \"else return  new \" + concreteActivityContextInterfaceClass . getName ( ) + \" ( (\" + ActivityContextInterface . class . getName ( ) + \") $1, \" + \"sbbEntity.getSbbComponent());\" + \"}\" ; \nCtMethod methodTest ; \ntry { \nmethodTest = CtNewMethod . make ( methodToAdd , sbbConcreteClass ) ; \nsbbConcreteClass . addMethod ( methodTest ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Method \" + methodToAdd + \" added\" ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new DeploymentException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"7107": "public class CompositeQueryExpression { \nprotected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { \nif ( expr == null ) throw new NullPointerException ( \"expr is null\" ) ; \nif ( expr instanceof CompositeQueryExpression ) ( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; \nelse if ( expr instanceof Not ) ( ( Not ) expr ) . checkForCycles ( this ) ; \nexprs . add ( expr ) ; \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) concreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"7114": "public class SbbActivityContextInterfaceImpl { \npublic Object getFieldValue ( String fieldName , Class < ? > returnType ) { \nString realFieldName = getRealFieldName ( fieldName ) ; \nObject value = aciImpl . getActivityContext ( ) . getDataAttribute ( realFieldName ) ; \nif ( value == null ) if ( returnType . isPrimitive ( ) ) if ( returnType . equals ( Integer . TYPE ) ) return Integer . valueOf ( 0 ) ; \nelse if ( returnType . equals ( Boolean . TYPE ) ) return Boolean . FALSE ; \nelse if ( returnType . equals ( Long . TYPE ) ) return Long . valueOf ( 0 ) ; \nelse if ( returnType . equals ( Double . TYPE ) ) return Double . valueOf ( 0 ) ; \nelse if ( returnType . equals ( Float . TYPE ) ) return Float . valueOf ( 0 ) ; \nreturn value ; \n} \n} \n"}
{"7115": "public class ProfileObjectImpl { \npublic void setProfileContext ( ProfileContextImpl profileContext ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"[setProfileContext] \" + this ) ; \nif ( profileContext == null ) throw new NullPointerException ( \"Passed context must not be null.\" ) ; \nif ( state != ProfileObjectState . DOES_NOT_EXIST ) throw new IllegalStateException ( \"Wrong state: \" + this . state + \",on profile set context operation, for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ) ; \nthis . profileContext = profileContext ; \nthis . profileContext . setProfileObject ( this ) ; \nif ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \nelse Thread . currentThread ( ) . setContextClassLoader ( cl ) ; \ntry { \nif ( isSlee11 ) try { \nprofileConcrete . setProfileContext ( profileContext ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \ncatch ( Exception e ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Exception encountered while setting profile context for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) , e ) ; \n} \n} \nfinally { \nif ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \nelse Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \n} \nstate = ProfileObjectState . POOLED ; \n} \n} \n"}
{"7116": "public class ProfileObjectImpl { \nprivate void profileInitialize ( String profileName ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"[profileInitialize] \" + this + \" , profileName = \" + profileName ) ; \nif ( this . state != ProfileObjectState . POOLED ) throw new SLEEException ( this . toString ( ) ) ; \nif ( profileName == null ) { \nprofileEntity = profileEntityFramework . getProfileEntityFactory ( ) . newInstance ( profileTable . getProfileTableName ( ) , null ) ; \nthis . state = ProfileObjectState . PROFILE_INITIALIZATION ; \nif ( profileConcreteClassInfo . isInvokeProfileInitialize ( ) ) try { \nprofileConcrete . profileInitialize ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \nelse { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Copying state from default profile on object \" + this ) ; \nprofileEntity = cloneEntity ( profileTable . getDefaultProfileEntity ( ) ) ; \nprofileEntity . setProfileName ( profileName ) ; \n} \nprofileEntity . create ( ) ; \nprofileEntity . setDirty ( true ) ; \n} \n} \n"}
{"7117": "public class ProfileObjectImpl { \npublic void unsetProfileContext ( ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"[unsetProfileContext] \" + this ) ; \nif ( state == ProfileObjectState . POOLED && profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \nelse Thread . currentThread ( ) . setContextClassLoader ( cl ) ; \nif ( isSlee11 ) try { \nprofileConcrete . unsetProfileContext ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \nprofileContext . setProfileObject ( null ) ; \nstate = ProfileObjectState . DOES_NOT_EXIST ; \n} \nfinally { \nif ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \nelse Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \n} \n} \n} \n"}
{"7118": "public class ProfileObjectImpl { \npublic ProfileLocalObject getProfileLocalObject ( ) { \nfinal Class < ? > profileLocalObjectConcreteClass = profileTable . getProfileSpecificationComponent ( ) . getProfileLocalObjectConcreteClass ( ) ; \nProfileLocalObject profileLocalObject = null ; \nif ( profileLocalObjectConcreteClass == null ) profileLocalObject = new ProfileLocalObjectImpl ( this ) ; \nelse try { \nprofileLocalObject = ( ProfileLocalObject ) profileLocalObjectConcreteClass . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nreturn profileLocalObject ; \n} \n} \n"}
{"7119": "public class ProfileObjectImpl { \npublic void fireAddOrUpdatedEventIfNeeded ( ) { \nif ( state == ProfileObjectState . READY ) if ( profileEntity . isDirty ( ) ) if ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { \nActivityContext ac = profileTable . getActivityContext ( ) ; \nAbstractProfileEvent event = null ; \nif ( profileEntity . isCreate ( ) ) if ( persisted ) { \nevent = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; \npersisted = false ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"firing profile added event for profile named \" + profileEntity ) ; \n} \nelse return ; \nelse { \nevent = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"firing profile updated event for profile named \" + profileEntity ) ; \n} \nac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; \n} \n} \n} \n"}
{"7120": "public class ProfileObjectImpl { \npublic AbstractProfileCmpSlee10Wrapper getProfileCmpSlee10Wrapper ( ) { \nif ( profileCmpSlee10Wrapper == null ) try { \nprofileCmpSlee10Wrapper = ( AbstractProfileCmpSlee10Wrapper ) profileTable . getProfileSpecificationComponent ( ) . getProfileCmpSlee10WrapperClass ( ) . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nreturn profileCmpSlee10Wrapper ; \n} \n} \n"}
{"7121": "public class ClassGeneratorUtils { \npublic static CtClass createClass ( String className , String [ ] interfaces ) throws Exception { \nif ( className == null ) throw new NullPointerException ( \"Class name cannot be null\" ) ; \nCtClass clazz = classPool . makeClass ( className ) ; \nif ( interfaces != null && interfaces . length > 0 ) clazz . setInterfaces ( classPool . get ( interfaces ) ) ; \nreturn clazz ; \n} \n} \n"}
{"7122": "public class ClassGeneratorUtils { \npublic static void createInheritanceLink ( CtClass concreteClass , String superClassName ) { \nif ( superClassName != null && superClassName . length ( ) >= 0 ) try { \nconcreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; \n} \ncatch ( CannotCompileException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( NotFoundException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"7123": "public class ClassGeneratorUtils { \npublic static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) { \nif ( toAnnotate instanceof CtClass ) { \nCtClass classToAnnotate = ( CtClass ) toAnnotate ; \nClassFile cf = classToAnnotate . getClassFile ( ) ; \nConstPool cp = cf . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) addMemberValuesToAnnotation ( a , cp , memberValues ) ; \nattr . addAnnotation ( a ) ; \ncf . addAttribute ( attr ) ; \n} \nelse if ( toAnnotate instanceof CtMethod ) { \nCtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; \nMethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; \nConstPool cp = mi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) addMemberValuesToAnnotation ( a , cp , memberValues ) ; \nattr . addAnnotation ( a ) ; \nmi . addAttribute ( attr ) ; \n} \nelse if ( toAnnotate instanceof CtField ) { \nCtField fieldToAnnotate = ( CtField ) toAnnotate ; \nFieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; \nConstPool cp = fi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) addMemberValuesToAnnotation ( a , cp , memberValues ) ; \nattr . addAnnotation ( a ) ; \nfi . addAttribute ( attr ) ; \n} \nelse throw new UnsupportedOperationException ( \"Unknown object type: \" + toAnnotate . getClass ( ) ) ; \n} \n} \n"}
{"7125": "public class AbstractActivityContextInterfaceFactory { \nprotected ActivityContextInterface getACI ( Object activity ) throws NullPointerException , UnrecognizedActivityException , FactoryException { \nif ( activity == null ) throw new NullPointerException ( \"null activity object\" ) ; \nActivityHandle handle = null ; \nfor ( ResourceAdaptorEntity raEntity : sleeContainer . getResourceManagement ( ) . getResourceAdaptorEntitiesPerType ( resourceAdaptorTypeID ) ) { \nhandle = raEntity . getResourceAdaptorObject ( ) . getActivityHandle ( activity ) ; \nif ( handle != null ) { \nActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; \nActivityContext ac = sleeContainer . getActivityContextFactory ( ) . getActivityContext ( ach ) ; \nif ( ac != null ) return ac . getActivityContextInterface ( ) ; \nbreak ; \n} \n} \nthrow new UnrecognizedActivityException ( activity . toString ( ) ) ; \n} \n} \n"}
{"7126": "public class AbstractSleeComponent { \npublic ClassPool getClassPool ( ) { \nif ( classPool == null ) { \nif ( classLoader == null ) throw new IllegalStateException ( \"can't init javassit classpool, there is no class loader set for the component\" ) ; \nclassPool = new ClassPool ( ) ; \nclassPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain ) ) ; \nfor ( ClassLoader domainDependencies : classLoaderDomain . getAllDependencies ( ) ) { \nclassPool . appendClassPath ( new LoaderClassPath ( domainDependencies ) ) ; \n} \nclassPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain . getParent ( ) ) ) ; \n} \nreturn classPool ; \n} \n} \n"}
{"7127": "public class AbstractSleeComponent { \npublic void setDeployableUnit ( DeployableUnit deployableUnit ) throws AlreadyDeployedException { \nif ( this . deployableUnit != null ) throw new IllegalStateException ( \"deployable unit already set. du = \" + this . deployableUnit ) ; \nthis . deployableUnit = deployableUnit ; \nif ( ! addToDeployableUnit ( ) ) throw new AlreadyDeployedException ( \"unable to install du having multiple components with id \" + getComponentID ( ) ) ; \n} \n} \n"}
{"7129": "public class SleeEndpointStartActivityNotTransactedExecutor { \nvoid execute ( final ActivityHandle handle , final int activityFlags , boolean suspendActivity ) throws SLEEException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \nActivityContextHandle ach = null ; \ntry { \nach = sleeEndpoint . _startActivity ( handle , activityFlags , suspendActivity ? tx : null ) ; \n} \nfinally { \nif ( tx != null ) { \nsuper . resumeTransaction ( tx ) ; \nif ( ach != null && ActivityFlags . hasRequestSleeActivityGCCallback ( activityFlags ) ) acFactory . getActivityContext ( ach ) ; \n} \n} \n} \n} \n"}
{"7130": "public class ClassUtils { \npublic static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { \nClass returnValue = null ; \nif ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) return classOrInterfaceWithInterfaces ; \nfor ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { \nif ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) returnValue = iface ; \nelse returnValue = checkInterfaces ( iface , interfaceSearched ) ; \nif ( returnValue != null ) break ; \n} \nif ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { \nClass superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; \nif ( superClass != null ) returnValue = checkInterfaces ( superClass , interfaceSearched ) ; \n} \nreturn returnValue ; \n} \n} \n"}
{"7131": "public class ClassUtils { \npublic static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { \nHashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; \nMethod [ ] methods = null ; \nClass [ ] superInterfaces ; \nsuperInterfaces = xInterfaceClass . getInterfaces ( ) ; \nfor ( Class superInterface : superInterfaces ) { \nif ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; \n} \nmethods = xInterfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) abstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \nreturn abstractMethods ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) return ; \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) lastToken = token ; \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n"}
{"7135": "public class DeployableUnitBuilderImpl { \nprivate void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { \nfor ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { \nif ( componentID instanceof EventTypeID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \nelse if ( componentID instanceof LibraryID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \nelse if ( componentID instanceof ProfileSpecificationID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \nelse if ( componentID instanceof ResourceAdaptorID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \nelse if ( componentID instanceof ResourceAdaptorTypeID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \nelse if ( componentID instanceof SbbID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \nelse if ( componentID instanceof ServiceID ) throw new SLEEException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on a service component \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \n} \n"}
{"7136": "public class DeployableUnitBuilderImpl { \nprivate File createTempDUDeploymentDir ( File deploymentRoot , DeployableUnitID deployableUnitID ) { \ntry { \nFile tempFile = File . createTempFile ( \"restcomm-slee-du-\" , \"\" , deploymentRoot ) ; \nFile tempDUDeploymentDir = new File ( tempFile . getAbsolutePath ( ) + \"-contents\" ) ; \nif ( ! tempDUDeploymentDir . exists ( ) ) tempDUDeploymentDir . mkdirs ( ) ; \nelse throw new SLEEException ( \"Dir \" + tempDUDeploymentDir + \" already exists, unable to create deployment dir for DU \" + deployableUnitID ) ; \ntempFile . delete ( ) ; \nreturn tempDUDeploymentDir ; \n} \ncatch ( IOException e ) { \nthrow new SLEEException ( \"Failed to create deployment dir for DU \" + deployableUnitID , e ) ; \n} \n} \n} \n"}
{"7137": "public class JPAProfileEntityFramework { \n@ SuppressWarnings ( \"unchecked\" ) private EntityManager getEntityManager ( ) { \nif ( txDataKey == null ) txDataKey = new StringBuilder ( \"jpapef.em.\" ) . append ( component . getProfileSpecificationID ( ) ) . toString ( ) ; \nfinal TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; \nMap transactionContextData = txContext . getData ( ) ; \nEntityManager result = ( EntityManager ) transactionContextData . get ( txDataKey ) ; \nif ( result == null ) { \nresult = entityManagerFactory . createEntityManager ( ) ; \ntransactionContextData . put ( txDataKey , result ) ; \n} \nreturn result ; \n} \n} \n"}
{"7138": "public class SleeManagementMBeanImpl { \npublic void start ( ) throws InvalidStateException , ManagementException { \ntry { \nfinal SleeStateChangeRequest startingRequest = new SleeStateChangeRequest ( ) { \n@ Override public void stateChanged ( SleeState oldState ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( generateMessageWithLogo ( \"starting\" ) ) ; \nnotifyStateChange ( oldState , getNewState ( ) ) ; \n} \n@ Override public void requestCompleted ( ) { \nfinal SleeStateChangeRequest runningRequest = new SleeStateChangeRequest ( ) { \nprivate SleeState oldState ; \n@ Override public void stateChanged ( SleeState oldState ) { \nlogger . info ( generateMessageWithLogo ( \"started\" ) ) ; \nthis . oldState = oldState ; \n} \n@ Override public void requestCompleted ( ) { \nnotifyStateChange ( oldState , getNewState ( ) ) ; \n} \n@ Override public boolean isBlockingRequest ( ) { \nreturn true ; \n} \n@ Override public SleeState getNewState ( ) { \nreturn SleeState . RUNNING ; \n} \n} \n; \ntry { \nsleeContainer . setSleeState ( runningRequest ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to set container in RUNNING state\" , e ) ; \ntry { \nstop ( false ) ; \n} \ncatch ( Throwable f ) { \nlogger . error ( \"Failed to set container in STOPPED state, after failure to set in RUNNING state\" , e ) ; \n} \n} \n} \n@ Override public boolean isBlockingRequest ( ) { \nreturn true ; \n} \n@ Override public SleeState getNewState ( ) { \nreturn SleeState . STARTING ; \n} \n} \n; \nsleeContainer . setSleeState ( startingRequest ) ; \n} \ncatch ( InvalidStateException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nthrow new ManagementException ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"7139": "public class Utility { \npublic static ClassLoader switchSafelyClassLoader ( final ClassLoader cl , final ProfileObject po ) { \nClassLoader _cl = null ; \nif ( System . getSecurityManager ( ) != null ) _cl = ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { \npublic Object run ( ) { \nreturn _switchSafelyClassLoader ( cl , po ) ; \n} \n} \n) ; \nelse _cl = _switchSafelyClassLoader ( cl , po ) ; \nreturn _cl ; \n} \n} \n"}
{"7141": "public class ProfileLocalObjectImpl { \nprotected void checkTransaction ( ) throws IllegalStateException { \ntry { \nif ( ! sleeContainer . getTransactionManager ( ) . getTransaction ( ) . equals ( this . transaction ) ) throw new IllegalStateException ( ) ; \n} \ncatch ( SystemException e ) { \nthrow new IllegalStateException ( ) ; \n} \n} \n} \n"}
{"7144": "public class AbstractProfileEvent { \nProfileObjectImpl getProfileObjectValidInCurrentTransaction ( ProfileEntity profileEntity ) throws TransactionRequiredLocalException { \nfinal SleeTransactionManager txManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; \ntxManager . mandateTransaction ( ) ; \nif ( txData == null ) txData = new HashMap < ProfileEntity , ProfileObjectImpl > ( ) ; \nProfileObjectImpl profileObject = ( ProfileObjectImpl ) txData . get ( profileEntity ) ; \nif ( profileObject == null ) { \nprofileEntity . setReadOnly ( true ) ; \nprofileEntity . setDirty ( false ) ; \nProfileObjectPool pool = profileManagement . getObjectPoolManagement ( ) . getObjectPool ( profileEntity . getTableName ( ) ) ; \nprofileObject = pool . borrowObject ( ) ; \nprofileObject . profileActivate ( profileEntity ) ; \nProfileTableTransactionView . passivateProfileObjectOnTxEnd ( txManager , profileObject , pool ) ; \ntxData . put ( profileEntity , profileObject ) ; \n} \nreturn profileObject ; \n} \n} \n"}
{"7151": "public class TracerImpl { \nprivate String tracerNameToLog4JLoggerName ( String tracerName , NotificationSource notificationSource ) { \nfinal StringBuilder sb = new StringBuilder ( \"javax.slee.\" ) . append ( notificationSource . toString ( ) ) ; \nif ( ! tracerName . equals ( ROOT_TRACER_NAME ) ) sb . append ( '.' ) . append ( tracerName ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"7152": "public class TracerImpl { \nvoid syncLevelWithLog4j ( ) { \nLevel log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; \nif ( level == null ) assignLog4JLevel ( log4jLevel ) ; \nelse if ( tracerToLog4JLevel ( level ) != log4jLevel ) assignLog4JLevel ( log4jLevel ) ; \nif ( parent == null && level == null ) { \nlogger . setLevel ( Level . INFO ) ; \nlevel = TraceLevel . INFO ; \n} \nresetCacheFlags ( false ) ; \n} \n} \n"}
{"7153": "public class TracerImpl { \nprivate void assignLog4JLevel ( Level log4jLevel ) { \nif ( log4jLevel == null ) return ; \nif ( log4jLevel == Level . DEBUG ) level = TraceLevel . FINE ; \nelse if ( log4jLevel == Level . INFO ) level = TraceLevel . INFO ; \nelse if ( log4jLevel == Level . WARN ) level = TraceLevel . WARNING ; \nelse if ( log4jLevel == Level . ERROR ) level = TraceLevel . SEVERE ; \nelse if ( log4jLevel == Level . TRACE ) level = TraceLevel . FINEST ; \nelse if ( log4jLevel == Level . OFF ) level = TraceLevel . OFF ; \n} \n} \n"}
{"7154": "public class TracerImpl { \nvoid resetCacheFlags ( boolean resetChilds ) { \nif ( isTraceable ( TraceLevel . FINEST ) ) { \nfinestEnabled = true ; \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfinestEnabled = false ; \nif ( isTraceable ( TraceLevel . FINER ) ) { \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfinerEnabled = false ; \nif ( isTraceable ( TraceLevel . FINE ) ) { \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfineEnabled = false ; \nif ( isTraceable ( TraceLevel . CONFIG ) ) { \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse if ( isTraceable ( TraceLevel . INFO ) ) { \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \ninfoEnabled = false ; \nif ( isTraceable ( TraceLevel . WARNING ) ) { \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nwarningEnabled = false ; \nif ( isTraceable ( TraceLevel . SEVERE ) ) severeEnabled = true ; \nelse severeEnabled = false ; \n} \n} \n} \n} \n} \nif ( resetChilds ) for ( TracerImpl child : childs ) { \nif ( child . level == null ) child . resetCacheFlags ( true ) ; \n} \n} \n} \n"}
{"7155": "public class TracerImpl { \nvoid sendNotification ( javax . slee . facilities . TraceLevel level , String message , Throwable t ) { \nif ( ! isTraceable ( level ) ) return ; \ntraceMBean . sendNotification ( new TraceNotification ( notificationSource . getNotificationSource ( ) . getTraceNotificationType ( ) , traceMBean , notificationSource . getNotificationSource ( ) , getTracerName ( ) , level , message , t , notificationSource . getNextSequence ( ) , System . currentTimeMillis ( ) ) ) ; \n} \n} \n"}
{"7156": "public class TracerImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { \nif ( tracerName . equals ( \"\" ) ) return ; \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) lastToken = token ; \nif ( lastToken . equals ( token ) && token . equals ( \".\" ) ) throw new InvalidArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \nlastToken = token ; \n} \nif ( lastToken . equals ( \".\" ) ) throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n"}
{"7161": "public class URLClassLoaderDomainImpl { \nprotected Class < ? > findClassLocally ( String name ) throws ClassNotFoundException { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + \" findClassLocally: \" + name ) ; \nfinal boolean acquiredLock = acquireGlobalLock ( ) ; \ntry { \nreturn findClassLocallyLocked ( name ) ; \n} \nfinally { \nif ( acquiredLock ) releaseGlobalLock ( ) ; \n} \n} \n} \n"}
{"7164": "public class ProfileProvisioningMBeanImpl { \nprivate AbstractProfileMBeanImpl createAndRegisterProfileMBean ( String profileName , ProfileTableImpl profileTable ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"createAndRegisterProfileMBean( profileTable = \" + profileTable + \" , profileName = \" + profileName + \" )\" ) ; \ntry { \nProfileSpecificationComponent component = profileTable . getProfileSpecificationComponent ( ) ; \nConstructor < ? > constructor = component . getProfileMBeanConcreteImplClass ( ) . getConstructor ( Class . class , String . class , ProfileTableImpl . class ) ; \nfinal AbstractProfileMBeanImpl profileMBean = ( AbstractProfileMBeanImpl ) constructor . newInstance ( component . getProfileMBeanConcreteInterfaceClass ( ) , profileName , profileTable ) ; \nprofileMBean . register ( ) ; \nTransactionalAction rollbackAction = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nprofileMBean . unregister ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \nsleeTransactionManagement . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( rollbackAction ) ; \nreturn profileMBean ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"7165": "public class SleeEndpointOperationNotTransactedExecutor { \nvoid resumeTransaction ( SleeTransaction transaction ) throws SLEEException { \nif ( transaction != null ) try { \ntxManager . resume ( transaction ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"7168": "public class SleeContainer { \npublic void initSlee ( ) throws InvalidStateException { \nif ( sleeState != null ) throw new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; \nbeforeModulesInitialization ( ) ; \nfor ( Iterator < SleeContainerModule > i = modules . iterator ( ) ; \ni . hasNext ( ) ; \n) i . next ( ) . sleeInitialization ( ) ; \nafterModulesInitialization ( ) ; \nsleeState = SleeState . STOPPED ; \n} \n} \n"}
{"7169": "public class SleeContainer { \npublic void shutdownSlee ( ) throws InvalidStateException { \nif ( sleeState != SleeState . STOPPED ) throw new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; \nbeforeModulesShutdown ( ) ; \nfor ( Iterator < SleeContainerModule > i = modules . descendingIterator ( ) ; \ni . hasNext ( ) ; \n) i . next ( ) . sleeShutdown ( ) ; \nafterModulesShutdown ( ) ; \nsleeState = null ; \n} \n} \n"}
{"7170": "public class SleeContainer { \nprivate void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { \nif ( oldState == SleeState . STOPPED ) if ( newState == SleeState . STARTING ) return ; \nelse if ( oldState == SleeState . STARTING ) if ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) return ; \nelse if ( oldState == SleeState . RUNNING ) if ( newState == SleeState . STOPPING ) return ; \nelse if ( oldState == SleeState . STOPPING ) if ( newState == SleeState . STOPPED ) return ; \nthrow new InvalidStateException ( \"illegal slee state transition: \" + oldState + \" -> \" + newState ) ; \n} \n} \n"}
{"7171": "public class ConcreteProfileGenerator { \nprivate void generateNamedUsageParameterGetter ( CtClass profileConcreteClass ) { \nString methodName = \"getUsageParameterSet\" ; \nfor ( CtMethod ctMethod : profileConcreteClass . getMethods ( ) ) { \nif ( ctMethod . getName ( ) . equals ( methodName ) ) try { \nCtMethod ctMethodCopy = CtNewMethod . copy ( ctMethod , profileConcreteClass , null ) ; \nString methodBody = \"{ return ($r)\" + ClassGeneratorUtils . MANAGEMENT_HANDLER + \".getUsageParameterSet(profileObject,$1); }\" ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Implemented method \" + methodName + \" , body = \" + methodBody ) ; \nctMethodCopy . setBody ( methodBody ) ; \nprofileConcreteClass . addMethod ( ctMethodCopy ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"7173": "public class PolyJDBCBuilder { \npublic PolyJDBC build ( ) { \nTransactionManager manager ; \nif ( dataSource != null ) manager = new DataSourceTransactionManager ( dataSource ) ; \nelse manager = new ExternalTransactionManager ( connectionProvider ) ; \nreturn new DefaultPolyJDBC ( dialect , schemaName , new ColumnTypeMapper ( customMappings ) , manager ) ; \n} \n} \n"}
{"7176": "public class RegionRequest { \n@ JsonCreator public static RegionRequest fromString ( String str ) throws ResolvingException { \nif ( str . equals ( \"full\" ) ) return new RegionRequest ( ) ; \nif ( str . equals ( \"square\" ) ) return new RegionRequest ( true ) ; \nMatcher matcher = PARSE_PAT . matcher ( str ) ; \nif ( ! matcher . matches ( ) ) throw new ResolvingException ( \"Bad format: \" + str ) ; \nif ( matcher . group ( 1 ) == null ) return new RegionRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , Integer . valueOf ( matcher . group ( 4 ) ) , Integer . valueOf ( matcher . group ( 5 ) ) ) ; \nelse return new RegionRequest ( new BigDecimal ( matcher . group ( 2 ) ) , new BigDecimal ( matcher . group ( 3 ) ) , new BigDecimal ( matcher . group ( 4 ) ) , new BigDecimal ( matcher . group ( 5 ) ) ) ; \n} \n} \n"}
{"7177": "public class RegionRequest { \npublic Rectangle2D getRegion ( ) { \nif ( isRelative ( ) ) return new Rectangle2D . Double ( relativeBox . x . doubleValue ( ) , relativeBox . y . doubleValue ( ) , relativeBox . w . doubleValue ( ) , relativeBox . h . doubleValue ( ) ) ; \nelse return absoluteBox ; \n} \n} \n"}
{"7178": "public class RegionRequest { \npublic Rectangle resolve ( Dimension imageDims ) throws ResolvingException { \nif ( square ) if ( imageDims . width > imageDims . height ) return new Rectangle ( ( imageDims . width - imageDims . height ) / 2 , 0 , imageDims . height , imageDims . height ) ; \nelse if ( imageDims . height > imageDims . width ) return new Rectangle ( 0 , ( imageDims . height - imageDims . width ) / 2 , imageDims . width , imageDims . width ) ; \nif ( absoluteBox == null && relativeBox == null ) return new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; \nRectangle rect ; \nif ( isRelative ( ) ) rect = new Rectangle ( ( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , ( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; \nelse rect = absoluteBox ; \nif ( rect . x >= imageDims . width || rect . y >= imageDims . height ) throw new ResolvingException ( \"X and Y must be smaller than the native width/height\" ) ; \nif ( rect . x + rect . width > imageDims . width ) rect . width = imageDims . width - rect . x ; \nif ( rect . y + rect . height > imageDims . height ) rect . height = imageDims . height - rect . y ; \nreturn rect ; \n} \n} \n"}
{"7179": "public class ResourceDeserializer { \nprivate String getOnType ( DeserializationContext ctxt ) { \nObject curVal = ctxt . getParser ( ) . getCurrentValue ( ) ; \nboolean isPaintingAnno = ( curVal != null && curVal instanceof Annotation && ( ( Annotation ) curVal ) . getMotivation ( ) != null && ( ( Annotation ) curVal ) . getMotivation ( ) . equals ( Motivation . PAINTING ) ) ; \nif ( isPaintingAnno ) return \"sc:Canvas\" ; \nJsonStreamContext parent = ctxt . getParser ( ) . getParsingContext ( ) . getParent ( ) ; \nwhile ( parent != null && ( parent . getCurrentValue ( ) == null || ! ( parent . getCurrentValue ( ) instanceof Resource ) ) ) parent = parent . getParent ( ) ; \nif ( parent != null ) { \nResource parentObj = ( Resource ) parent . getCurrentValue ( ) ; \nreturn parentObj . getType ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"7180": "public class Resource { \npublic void setViewingHints ( List < ViewingHint > viewingHints ) throws IllegalArgumentException { \nfor ( ViewingHint hint : viewingHints ) { \nboolean supportsHint = ( hint . getType ( ) == ViewingHint . Type . OTHER || this . getSupportedViewingHintTypes ( ) . contains ( hint . getType ( ) ) ) ; \nif ( ! supportsHint ) throw new IllegalArgumentException ( String . format ( \"Resources of type '%s' do not support the '%s' viewing hint.\" , this . getType ( ) , hint . toString ( ) ) ) ; \n} \nthis . viewingHints = viewingHints ; \n} \n} \n"}
{"7181": "public class Resource { \npublic Resource addViewingHint ( ViewingHint first , ViewingHint ... rest ) throws IllegalArgumentException { \nList < ViewingHint > hints = this . viewingHints ; \nif ( hints == null ) hints = new ArrayList < > ( ) ; \nhints . addAll ( Lists . asList ( first , rest ) ) ; \nthis . setViewingHints ( hints ) ; \nreturn this ; \n} \n} \n"}
{"7183": "public class Resource { \npublic Resource addRendering ( OtherContent first , OtherContent ... rest ) { \nif ( renderings == null ) this . renderings = new ArrayList < > ( ) ; \nList < OtherContent > renderingsToAdd = Lists . asList ( first , rest ) ; \nrenderingsToAdd . forEach ( this :: verifyRendering ) ; \nthis . renderings . addAll ( renderingsToAdd ) ; \nreturn this ; \n} \n} \n"}
{"7185": "public class ImageApiProfile { \npublic ImageApiProfile merge ( ImageApiProfile other ) { \nImageApiProfile merged = new ImageApiProfile ( ) ; \nstreamNotNull ( this . features ) . forEach ( merged :: addFeature ) ; \nstreamNotNull ( other . features ) . forEach ( merged :: addFeature ) ; \nstreamNotNull ( this . formats ) . forEach ( merged :: addFormat ) ; \nstreamNotNull ( other . formats ) . forEach ( merged :: addFormat ) ; \nstreamNotNull ( this . qualities ) . forEach ( merged :: addQuality ) ; \nstreamNotNull ( other . qualities ) . forEach ( merged :: addQuality ) ; \nif ( this . maxWidth != null && other . maxWidth == null ) merged . maxWidth = this . maxWidth ; \nelse if ( this . maxWidth == null && other . maxWidth != null ) merged . maxWidth = other . maxWidth ; \nelse if ( this . maxWidth != null ) merged . maxWidth = Math . min ( this . maxWidth , other . maxWidth ) ; \nif ( this . maxHeight != null && other . maxHeight == null ) merged . maxHeight = this . maxHeight ; \nelse if ( this . maxHeight == null && other . maxHeight != null ) merged . maxHeight = other . maxHeight ; \nelse if ( this . maxHeight != null ) merged . maxHeight = Math . min ( this . maxHeight , other . maxHeight ) ; \nif ( this . maxArea != null && other . maxArea == null ) merged . maxArea = this . maxArea ; \nelse if ( this . maxArea == null && other . maxArea != null ) merged . maxArea = other . maxArea ; \nelse if ( this . maxArea != null ) merged . maxArea = Math . min ( this . maxArea , other . maxArea ) ; \nreturn merged ; \n} \n} \n"}
{"7186": "public class RotationRequest { \n@ JsonCreator public static RotationRequest fromString ( String str ) throws ResolvingException { \nMatcher matcher = PATTERN . matcher ( str ) ; \nif ( ! matcher . matches ( ) ) throw new ResolvingException ( \"Bad format: \" + str ) ; \nreturn new RotationRequest ( new BigDecimal ( matcher . group ( 2 ) ) , ! ( matcher . group ( 1 ) == null ) ) ; \n} \n} \n"}
{"7187": "public class SizeRequest { \n@ JsonCreator public static SizeRequest fromString ( String str ) throws ResolvingException { \nif ( str . equals ( \"full\" ) ) return new SizeRequest ( ) ; \nif ( str . equals ( \"max\" ) ) return new SizeRequest ( true ) ; \nMatcher matcher = PARSE_PAT . matcher ( str ) ; \nif ( ! matcher . matches ( ) ) throw new ResolvingException ( \"Bad format: \" + str ) ; \nif ( matcher . group ( 1 ) != null ) if ( matcher . group ( 1 ) . equals ( \"!\" ) ) return new SizeRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , true ) ; \nelse if ( matcher . group ( 1 ) . equals ( \"pct:\" ) ) return new SizeRequest ( new BigDecimal ( matcher . group ( 4 ) ) ) ; \nInteger width = null ; \nInteger height = null ; \nif ( matcher . group ( 2 ) != null ) width = Integer . parseInt ( matcher . group ( 2 ) ) ; \nif ( matcher . group ( 3 ) != null ) height = Integer . parseInt ( matcher . group ( 3 ) ) ; \nreturn new SizeRequest ( width , height ) ; \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) bridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nwhile ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) try { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \nfor ( int i = 0 ; \ni < devices . length ; \ni ++ ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \n} \n} \n"}
{"7189": "public class AbstractDevice { \npublic String getDump ( ) { \npushAutomator2Device ( ) ; \nruntest ( ) ; \nString path = pullDump2PC ( ) ; \nString xml = \"\" ; \ntry { \nFileInputStream fileInputStream = new FileInputStream ( path ) ; \n@ SuppressWarnings ( \"resource\" ) BufferedReader in = new BufferedReader ( new InputStreamReader ( fileInputStream ) ) ; \nStringBuffer buffer = new StringBuffer ( ) ; \nString line = \"\" ; \nwhile ( ( line = in . readLine ( ) ) != null ) buffer . append ( line ) ; \nxml = buffer . toString ( ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn xml ; \n} \n} \n"}
{"7190": "public class AbstractDevice { \npublic boolean handlePopBox ( String deviceBrand ) { \npushHandleGps2Device ( ) ; \nCommandLine exeCommand = null ; \nif ( deviceBrand . contains ( \"HTC\" ) ) exeCommand = adbCommand ( \"shell\" , \"uiautomator\" , \"runtest\" , \"/data/local/tmp/handlePopBox.jar\" , \"-c\" , \"com.test.device.gps.HTCGPSTest\" ) ; \nelse if ( deviceBrand . contains ( \"Meizu\" ) ) exeCommand = adbCommand ( \"shell\" , \"uiautomator\" , \"runtest\" , \"/data/local/tmp/handlePopBox.jar\" , \"-c\" , \"com.test.device.gps.MeizuGPSTest\" ) ; \nString output = executeCommandQuietly ( exeCommand ) ; \nlog . debug ( \"run test {}\" , output ) ; \ntry { \nThread . sleep ( 1000 ) ; \n} \ncatch ( InterruptedException ie ) { \nthrow new RuntimeException ( ie ) ; \n} \nreturn output . contains ( \"OK\" ) ; \n} \n} \n"}
{"7194": "public class AbstractDevice { \npublic String getCrashLog ( ) { \nString crashLogFileName = null ; \nFile crashLogFile = new File ( getExternalStoragePath ( ) , crashLogFileName ) ; \nCommandLine directoryListCommand = adbCommand ( \"shell\" , \"ls\" , crashLogFile . getParentFile ( ) . getAbsolutePath ( ) ) ; \nString directoryList = executeCommandQuietly ( directoryListCommand ) ; \nif ( directoryList . contains ( crashLogFileName ) ) return executeCommandQuietly ( adbCommand ( \"shell\" , \"cat\" , crashLogFile . getAbsolutePath ( ) ) ) ; \nreturn \"\" ; \n} \n} \n"}
{"7196": "public class TextEditor { \npublic TextEditor indent ( int spaces ) { \nStringBuilder sb = new StringBuilder ( spaces ) ; \nfor ( int i = 0 ; \ni < spaces ; \ni ++ ) sb . append ( ' ' ) ; \nreturn replaceAll ( \"^\" , sb . toString ( ) ) ; \n} \n} \n"}
{"7197": "public class TextEditor { \npublic Collection < HTMLToken > tokenizeHTML ( ) { \nList < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; \nString nestedTags = nestedTagsRegex ( 6 ) ; \nPattern p = Pattern . compile ( \"\" + \"(?s:<!(--.*?--\\\\s*)+>)\" + \"|\" + \"(?s:<\\\\?.*?\\\\?>)\" + \"|\" + nestedTags + \"\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( text ) ; \nint lastPos = 0 ; \nwhile ( m . find ( ) ) { \nif ( lastPos < m . start ( ) ) tokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; \ntokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; \nlastPos = m . end ( ) ; \n} \nif ( lastPos < text . length ( ) ) tokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; \nreturn tokens ; \n} \n} \n"}
{"7198": "public class MarkdownProcessor { \npublic String markdown ( String txt ) { \nif ( txt == null ) txt = \"\" ; \nTextEditor text = new TextEditor ( txt ) ; \ntext . replaceAll ( \"\\\\r\\\\n\" , \"\\n\" ) ; \ntext . replaceAll ( \"\\\\r\" , \"\\n\" ) ; \ntext . replaceAll ( \"^[ \\\\t]+$\" , \"\" ) ; \ntext . append ( \"\\n\\n\" ) ; \ntext . detabify ( ) ; \ntext . deleteAll ( \"^[ ]+$\" ) ; \nhashHTMLBlocks ( text ) ; \nstripLinkDefinitions ( text ) ; \ntext = runBlockGamut ( text ) ; \nunEscapeSpecialChars ( text ) ; \ntext . append ( \"\\n\" ) ; \nreturn text . toString ( ) ; \n} \n} \n"}
{"7200": "public class ExceptionCollector { \nfinal void addException ( SQLException exception ) { \nif ( ! ( exception instanceof SQLTimeoutException ) && ! ( exception instanceof SQLTransactionRollbackException ) ) getOrInit ( ) . offer ( exception ) ; \n} \n} \n"}
{"7201": "public class ClhmStatementCache { \n@ Override public void close ( ) { \nif ( closed . getAndSet ( true ) ) return ; \nfor ( Map . Entry < StatementMethod , StatementHolder > entry : statementCache . entrySet ( ) ) { \nStatementHolder value = entry . getValue ( ) ; \nstatementCache . remove ( entry . getKey ( ) , value ) ; \nquietClose ( value . rawStatement ( ) ) ; \n} \n} \n} \n"}
{"7202": "public class BarberProcessor { \nprivate String findParentFqcn ( TypeElement typeElement , Set < String > parents ) { \nTypeMirror type ; \nwhile ( true ) { \ntype = typeElement . getSuperclass ( ) ; \nif ( type . getKind ( ) == TypeKind . NONE ) return null ; \ntypeElement = ( TypeElement ) ( ( DeclaredType ) type ) . asElement ( ) ; \nif ( parents . contains ( typeElement . toString ( ) ) ) { \nString packageName = getPackageName ( typeElement ) ; \nreturn packageName + \".\" + getClassName ( typeElement , packageName ) ; \n} \n} \n} \n} \n"}
{"7203": "public class Barbershop { \nvoid writeToFiler ( Filer filer ) throws IOException { \nClassName targetClassName = ClassName . get ( classPackage , targetClass ) ; \nTypeSpec . Builder barberShop = TypeSpec . classBuilder ( className ) . addModifiers ( Modifier . PUBLIC ) . addTypeVariable ( TypeVariableName . get ( \"T\" , targetClassName ) ) . addMethod ( generateStyleMethod ( ) ) . addMethod ( generateCheckParentMethod ( ) ) ; \nif ( parentBarbershop == null ) { \nbarberShop . addSuperinterface ( ParameterizedTypeName . get ( ClassName . get ( Barber . IBarbershop . class ) , TypeVariableName . get ( \"T\" ) ) ) ; \nbarberShop . addField ( FieldSpec . builder ( WeakHashSet . class , \"lastStyledTargets\" , Modifier . PROTECTED ) . initializer ( \"new $T()\" , WeakHashSet . class ) . build ( ) ) ; \n} \nelse barberShop . superclass ( ParameterizedTypeName . get ( ClassName . bestGuess ( parentBarbershop ) , TypeVariableName . get ( \"T\" ) ) ) ; \nJavaFile javaFile = JavaFile . builder ( classPackage , barberShop . build ( ) ) . build ( ) ; \njavaFile . writeTo ( filer ) ; \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \nelse { \nint numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) url += \"?\" ; \nfor ( int i = 1 ; \ni <= numberOfPages ; \ni ++ ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \n} \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7209": "public class ExtentCucumberFormatter { \nprivate static synchronized void setKlovReport ( ) { \nif ( extentReports == null ) return ; \nExtentProperties extentProperties = ExtentProperties . INSTANCE ; \nif ( klovReporter != null ) return ; \nif ( extentProperties . getKlovServerUrl ( ) != null ) { \nString hostname = extentProperties . getMongodbHost ( ) ; \nint port = extentProperties . getMongodbPort ( ) ; \nString database = extentProperties . getMongodbDatabase ( ) ; \nString username = extentProperties . getMongodbUsername ( ) ; \nString password = extentProperties . getMongodbPassword ( ) ; \ntry { \nklovReporter = new KlovReporter ( ) ; \nif ( username != null && password != null ) { \nMongoClientURI uri = new MongoClientURI ( \"mongodb://\" + username + \":\" + password + \"@\" + hostname + \":\" + port + \"/?authSource=\" + database ) ; \nklovReporter . initMongoDbConnection ( uri ) ; \n} \nelse klovReporter . initMongoDbConnection ( hostname , port ) ; \nklovReporter . setProjectName ( extentProperties . getKlovProjectName ( ) ) ; \nklovReporter . setReportName ( extentProperties . getKlovReportName ( ) ) ; \nklovReporter . setKlovUrl ( extentProperties . getKlovServerUrl ( ) ) ; \nextentReports . attachReporter ( klovReporter ) ; \n} \ncatch ( Exception ex ) { \nklovReporter = null ; \nthrow new IllegalArgumentException ( \"Error setting up Klov Reporter\" , ex ) ; \n} \n} \n} \n} \n"}
{"7211": "public class Reporter { \npublic static void setSystemInfo ( String key , String value ) { \nif ( systemInfoKeyMap . isEmpty ( ) || ! systemInfoKeyMap . containsKey ( key ) ) systemInfoKeyMap . put ( key , false ) ; \nif ( systemInfoKeyMap . get ( key ) ) return ; \ngetExtentReport ( ) . setSystemInfo ( key , value ) ; \nsystemInfoKeyMap . put ( key , true ) ; \n} \n} \n"}
{"7213": "public class Selector { \npublic static Selector selectAs ( final String propName , final String alias , final Function transform ) { \nreturn new Selector ( propName , alias ) { \n@ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { \nif ( ! path && fields != null ) row . put ( this . name , transform . apply ( fields . get ( this . name ) . getValue ( item ) ) ) ; \nelse row . put ( alias , transform . apply ( BeanUtils . atIndex ( item , propName ) ) ) ; \n} \n@ Override public void handleStart ( Collection < ? > results ) { \n} \n@ Override public void handleComplete ( List < Map < String , Object > > rows ) { \n} \n} \n; \n} \n} \n"}
{"7214": "public class Annotations { \npublic static List < AnnotationData > extractValidationAnnotationData ( Annotation [ ] annotations , Set < String > allowedPackages ) { \nList < AnnotationData > annotationsList = new ArrayList < > ( ) ; \nfor ( Annotation annotation : annotations ) { \nAnnotationData annotationData = new AnnotationData ( annotation , allowedPackages ) ; \nif ( annotationData . isAllowed ( ) ) annotationsList . add ( annotationData ) ; \n} \nreturn annotationsList ; \n} \n} \n"}
{"7215": "public class Annotations { \nprivate static Annotation [ ] extractAllAnnotationsForProperty ( Class < ? > clazz , String propertyName , boolean useRead ) { \ntry { \nAnnotation [ ] annotations = findPropertyAnnotations ( clazz , propertyName , useRead ) ; \nif ( annotations . length == 0 ) annotations = findPropertyAnnotations ( clazz . getSuperclass ( ) , propertyName , useRead ) ; \nreturn annotations ; \n} \ncatch ( Exception ex ) { \nreturn Exceptions . handle ( Annotation [ ] . class , sputs ( \"Unable to extract annotation for property\" , propertyName , \" of class \" , clazz , \"  useRead \" , useRead ) , ex ) ; \n} \n} \n} \n"}
{"7216": "public class Annotations { \nprivate static Annotation [ ] findPropertyAnnotations ( Class < ? > clazz , String propertyName , boolean useRead ) throws IntrospectionException { \nPropertyDescriptor propertyDescriptor = getPropertyDescriptor ( clazz , propertyName ) ; \nif ( propertyDescriptor == null ) return new Annotation [ ] { \n} \n; \nMethod accessMethod = null ; \nif ( useRead ) accessMethod = propertyDescriptor . getReadMethod ( ) ; \nelse accessMethod = propertyDescriptor . getWriteMethod ( ) ; \nif ( accessMethod != null ) { \nAnnotation [ ] annotations = accessMethod . getAnnotations ( ) ; \nreturn annotations ; \n} \nelse return new Annotation [ ] { \n} \n; \n} \n} \n"}
{"7217": "public class Annotations { \nprivate static PropertyDescriptor doGetPropertyDescriptor ( final Class < ? > type , final String propertyName ) { \ntry { \nBeanInfo beanInfo = Introspector . getBeanInfo ( type ) ; \nPropertyDescriptor [ ] propertyDescriptors = beanInfo . getPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor pd : propertyDescriptors ) { \nif ( pd . getName ( ) . equals ( propertyName ) ) return pd ; \n} \nClass < ? > superclass = type . getSuperclass ( ) ; \nif ( superclass != null ) return doGetPropertyDescriptor ( superclass , propertyName ) ; \nreturn null ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( \"Unable to get property \" + propertyName + \" for class \" + type , ex ) ; \n} \n} \n} \n"}
{"7218": "public class BoonExpressionContext { \nprivate Object doLookup ( String objectExpression , Object defaultValue , boolean searchChildren ) { \nif ( Str . isEmpty ( objectExpression ) ) return defaultValue ; \nchar firstChar = Str . idx ( objectExpression , 0 ) ; \nchar secondChar = Str . idx ( objectExpression , 1 ) ; \nchar lastChar = Str . idx ( objectExpression , - 1 ) ; \nboolean escape = false ; \nswitch ( firstChar ) { \ncase '$' : if ( lastChar == '}' ) objectExpression = slc ( objectExpression , 2 , - 1 ) ; \nelse objectExpression = slc ( objectExpression , 1 ) ; \nbreak ; \ncase '{' : if ( secondChar == '{' && lastChar == '}' ) { \nchar thirdChar = Str . idx ( objectExpression , 2 ) ; \nif ( thirdChar == '{' ) { \nescape = true ; \nobjectExpression = slc ( objectExpression , 3 , - 3 ) ; \n} \nelse objectExpression = slc ( objectExpression , 2 , - 2 ) ; \n} \nelse if ( lastChar == '}' ) return jsonParser . parse ( objectExpression ) ; \nelse { \nescape = true ; \nobjectExpression = slc ( objectExpression , 1 ) ; \n} \nbreak ; \ncase '[' : return jsonParser . parse ( objectExpression ) ; \ncase '.' : if ( secondChar == '.' ) { \nString newExp = slc ( objectExpression , 2 ) ; \nreturn parent . doLookup ( newExp , newExp , false ) ; \n} \n} \nObject value ; \nlastChar = Str . idx ( objectExpression , - 1 ) ; \nif ( lastChar == ')' ) value = handleFunction ( objectExpression , searchChildren ) ; \nelse { \nvalue = findProperty ( objectExpression , searchChildren ) ; \nvalue = value == null ? defaultValue : value ; \n} \nif ( ! escape ) return value ; \nelse return StandardFunctions . escapeXml ( value ) ; \n} \n} \n"}
{"7224": "public class AnnotationData { \nMap < String , Object > doGetValues ( Annotation annotation ) { \nMap < String , Object > values = new HashMap < String , Object > ( ) ; \nMethod [ ] methods = annotation . annotationType ( ) . getDeclaredMethods ( ) ; \nfinal Object [ ] noargs = ( Object [ ] ) null ; \nfor ( Method method : methods ) { \nif ( method . getParameterTypes ( ) . length == 0 ) try { \nObject value = method . invoke ( annotation , noargs ) ; \nif ( value instanceof Enum ) { \nEnum enumVal = ( Enum ) value ; \nvalue = enumVal . name ( ) ; \n} \nvalues . put ( method . getName ( ) , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"7229": "public class RecursiveDescentPropertyValidator { \nprivate void ifPropertyBlankRemove ( Map < String , Object > properties , String property ) { \nObject object = properties . get ( property ) ; \nif ( object == null ) properties . remove ( property ) ; \nelse if ( object instanceof String ) { \nString string = ( String ) object ; \nif ( \"\" . equals ( string . trim ( ) ) ) properties . remove ( property ) ; \n} \n} \n} \n"}
{"7235": "public class LevelDBKeyValueStore { \n@ Override public void putAll ( Map < byte [ ] , byte [ ] > values ) { \nWriteBatch batch = database . createWriteBatch ( ) ; \ntry { \nfor ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { \nbatch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nif ( putAllWriteCount . addAndGet ( values . size ( ) ) > 10_000 ) { \nputAllWriteCount . set ( 0 ) ; \ndatabase . write ( batch , flush ) ; \n} \nelse database . write ( batch , writeOptions ) ; \n} \nfinally { \ncloseBatch ( batch ) ; \n} \n} \n} \n"}
{"7238": "public class LevelDBKeyValueStore { \n@ Override public Map < byte [ ] , byte [ ] > loadAllByKeys ( Collection < byte [ ] > keys ) { \nif ( keys == null || keys . size ( ) == 0 ) return Collections . EMPTY_MAP ; \nMap < byte [ ] , byte [ ] > results = new LinkedHashMap < > ( keys . size ( ) ) ; \nDBIterator iterator = null ; \ntry { \niterator = database . iterator ( ) ; \niterator . seek ( keys . iterator ( ) . next ( ) ) ; \nwhile ( iterator . hasNext ( ) ) { \nfinal Map . Entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; \nresults . put ( next . getKey ( ) , next . getValue ( ) ) ; \n} \n} \nfinally { \ntry { \nif ( iterator != null ) iterator . close ( ) ; \n} \ncatch ( IOException e ) { \nExceptions . handle ( e ) ; \n} \n} \nreturn results ; \n} \n} \n"}
{"7240": "public class Dbl { \npublic static < T > double reduceBy ( final double [ ] array , T object ) { \nif ( object . getClass ( ) . isAnonymousClass ( ) ) return reduceByR ( array , object ) ; \ntry { \nConstantCallSite callSite = Invoker . invokeReducerLongIntReturnLongMethodHandle ( object ) ; \nMethodHandle methodHandle = callSite . dynamicInvoker ( ) ; \ntry { \ndouble sum = 0 ; \nfor ( double v : array ) { \nsum = ( double ) methodHandle . invokeExact ( sum , v ) ; \n} \nreturn sum ; \n} \ncatch ( Throwable throwable ) { \nreturn handle ( Long . class , throwable , \"Unable to perform reduceBy\" ) ; \n} \n} \ncatch ( Exception ex ) { \nreturn reduceByR ( array , object ) ; \n} \n} \n} \n"}
{"7248": "public class ObjectFilter { \npublic static Criterion notIn ( final Object name , final Object ... values ) { \nreturn new Criterion < Object > ( name . toString ( ) , Operator . NOT_IN , values ) { \n@ Override public boolean resolve ( Object owner ) { \nObject fieldValue = fieldValue ( ) ; \nif ( value == null ) return false ; \nreturn ! valueSet ( ) . contains ( fieldValue ) ; \n} \n} \n; \n} \n} \n"}
{"7249": "public class ObjectFilter { \npublic static Criteria criteriaFromList ( List < ? > list ) { \nList < Object > args = new ArrayList ( list ) ; \nObject o = atIndex ( args , - 1 ) ; \nif ( ! ( o instanceof List ) ) atIndex ( args , - 1 , Collections . singletonList ( o ) ) ; \nreturn ( Criteria ) Invoker . invokeFromList ( ObjectFilter . class , \"createCriteriaFromClass\" , args ) ; \n} \n} \n"}
{"7251": "public class DoubleList { \npublic boolean addArray ( double ... integers ) { \nif ( end + integers . length >= values . length ) values = grow ( values , ( values . length + integers . length ) * 2 ) ; \nSystem . arraycopy ( integers , 0 , values , end , integers . length ) ; \nend += integers . length ; \nreturn true ; \n} \n} \n"}
{"7252": "public class Ordering { \npublic static < T > T max ( T [ ] array ) { \nif ( array . length > 1 ) { \nSorting . sortDesc ( array ) ; \nreturn array [ 0 ] ; \n} \nelse return null ; \n} \n} \n"}
{"7253": "public class Ordering { \npublic static < T > List < T > firstOf ( List < T > list , int count , Sort ... sorts ) { \nif ( list . size ( ) > 1 ) { \nSorting . sort ( list , sorts ) ; \nreturn Lists . sliceOf ( list , 0 , count ) ; \n} \nelse return null ; \n} \n} \n"}
{"7254": "public class Ordering { \npublic static < T > T lastOf ( List < T > list , Sort ... sorts ) { \nif ( list . size ( ) > 1 ) { \nSorting . sort ( list , sorts ) ; \nreturn list . get ( list . size ( ) - 1 ) ; \n} \nelse return null ; \n} \n} \n"}
{"7255": "public class Ordering { \npublic static < T > List < T > lastOf ( List < T > list , int count , Sort ... sorts ) { \nif ( list . size ( ) > 1 ) { \nSorting . sort ( list , sorts ) ; \nreturn Lists . endSliceOf ( list , count * - 1 ) ; \n} \nelse return null ; \n} \n} \n"}
{"7256": "public class Ordering { \npublic static < T > List < T > least ( List < T > list , int count ) { \nif ( list . size ( ) > 1 ) { \nSorting . sort ( list ) ; \nreturn Lists . sliceOf ( list , 0 , count ) ; \n} \nelse return null ; \n} \n} \n"}
{"7257": "public class Ordering { \npublic static < T > T min ( List < T > list ) { \nif ( list . size ( ) > 1 ) { \nSorting . sort ( list ) ; \nreturn list . get ( 0 ) ; \n} \nelse return null ; \n} \n} \n"}
{"7258": "public class Ordering { \npublic static < T > T min ( T [ ] array , String sortBy ) { \nif ( array . length > 1 ) { \nSorting . sort ( array , sortBy ) ; \nreturn array [ 0 ] ; \n} \nelse return null ; \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( int index = 0 ; \nindex < chars . length ; \nindex ++ ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) continue ; \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) continue ; \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) continue ; \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) continue ; \nbuffer . append ( cchar ) ; \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) return ; \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 && ! lastCharWasNumber ) buffer . append ( ' ' ) ; \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse lastCharWasNumber = false ; \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 && ! lastCharWasUpperCase ) buffer . append ( ' ' ) ; \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse lastCharWasUpperCase = false ; \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7266": "public class BaseDataStore { \nprivate void processReadQueue ( ) throws InterruptedException { \nReadStatus readStatus = new ReadStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( request != null ) { \nreadStatus . tracker . addCall ( request , outputDataQueue ) ; \nreadOperationsBatch . add ( request ) ; \nif ( readOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) break ; \nrequest = readOperationsQueue . poll ( ) ; \n} \nif ( readOperationsBatch . size ( ) > 0 ) try { \nrecievedReadBatch ( new ArrayList < > ( readOperationsBatch ) ) ; \n} \nfinally { \nreadOperationsBatch . clear ( ) ; \n} \nelse flushReadsIfNeeded ( ) ; \nif ( readStatus . readBatchSize . size ( ) > 1_000 ) { \nStatCount count ; \nfinal long now = Timer . timer ( ) . time ( ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME USER  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME CPU  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.max\" , readStatus . readBatchSize . max ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.min\" , readStatus . readBatchSize . min ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.median\" , readStatus . readBatchSize . median ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.mean\" , readStatus . readBatchSize . mean ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.standardDeviation\" , readStatus . readBatchSize . standardDeviation ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.variance\" , readStatus . readBatchSize . variance ( ) ) ; \noutputDataQueue . put ( count ) ; \nreadStatus . readBatchSize . clear ( ) ; \n} \n} \n} \n} \n"}
{"7267": "public class BaseDataStore { \nprivate void processWriteQueue ( ) throws InterruptedException { \nWriteStatus status = new WriteStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( operation != null ) { \nstatus . tracker . addCall ( operation , outputDataQueue ) ; \nwriteOperationsBatch . add ( operation ) ; \nif ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) break ; \noperation = writeOperationsQueue . poll ( ) ; \n} \nif ( writeOperationsBatch . size ( ) > 0 ) try { \nstatus . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; \nrecievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; \n} \nfinally { \nwriteOperationsBatch . clear ( ) ; \n} \nelse flushWritesIfNeeded ( ) ; \nif ( status . writeBatchSize . size ( ) > 1000 ) status . sendBatchSize ( source , outputDataQueue ) ; \n} \n} \n} \n"}
{"7268": "public class BaseDataStore { \npublic void start ( ) { \nscheduledExecutorService = Executors . newScheduledThreadPool ( 2 , new ThreadFactory ( ) { \n@ Override public Thread newThread ( Runnable runnable ) { \nThread thread = new Thread ( runnable ) ; \nthread . setName ( \" DataQueue Process \" + source ) ; \nreturn thread ; \n} \n} \n) ; \nfuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nif ( stop . get ( ) ) return ; \ntry { \nprocessWriteQueue ( ) ; \n} \ncatch ( InterruptedException ex ) { \n} \ncatch ( Exception ex ) { \nlogger . fatal ( ex ) ; \n} \n} \n} \n, 0 , dataStoreConfig . threadErrorResumeTimeMS ( ) , TimeUnit . MILLISECONDS ) ; \nfuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nif ( stop . get ( ) ) return ; \ntry { \nprocessReadQueue ( ) ; \n} \ncatch ( InterruptedException ex ) { \n} \ncatch ( Exception ex ) { \nlogger . fatal ( ex , \"Problem with base data store running scheduled job\" ) ; \n} \n} \n} \n, 0 , dataStoreConfig . threadErrorResumeTimeMS ( ) , TimeUnit . MILLISECONDS ) ; \n} \n} \n"}
{"7273": "public class Str { \npublic static String addObjects ( Object ... objects ) { \nint length = 0 ; \nfor ( Object obj : objects ) { \nif ( obj == null ) continue ; \nlength += obj . toString ( ) . length ( ) ; \n} \nCharBuf builder = CharBuf . createExact ( length ) ; \nfor ( Object str : objects ) { \nif ( str == null ) continue ; \nbuilder . add ( str . toString ( ) ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) return \"\" ; \nif ( count instanceof Double || count instanceof BigDecimal ) { \nString s = count . toString ( ) ; \nif ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \nelse return s ; \n} \nelse if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) buf . add ( ',' ) ; \n} \nif ( buf . lastChar ( ) == ',' ) buf . removeLastChar ( ) ; \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7283": "public class Sort { \npublic static Sort sorts ( Sort ... sorts ) { \nif ( sorts == null || sorts . length == 0 ) return null ; \nSort main = sorts [ 0 ] ; \nfor ( int index = 1 ; \nindex < sorts . length ; \nindex ++ ) main . then ( sorts [ index ] ) ; \nreturn main ; \n} \n} \n"}
{"7285": "public class Sort { \npublic Comparator comparator ( Map < String , FieldAccess > fields ) { \nif ( comparator == null ) comparator = universalComparator ( this . getName ( ) , fields , this . getType ( ) , this . childComparators ( fields ) ) ; \nreturn comparator ; \n} \n} \n"}
{"7288": "public class Int { \npublic static boolean equalsOrDie ( int expected , int got ) { \nif ( expected != got ) return die ( Boolean . class , \"Expected was\" , expected , \"but we got \" , got ) ; \nreturn true ; \n} \n} \n"}
{"7289": "public class Int { \npublic static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { \nif ( expected . length != got . length ) die ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; \nfor ( int index = 0 ; \nindex < expected . length ; \nindex ++ ) if ( expected [ index ] != got [ index ] ) die ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; \nreturn true ; \n} \n} \n"}
{"7290": "public class Int { \npublic static int sum ( int [ ] values , int start , int length ) { \nlong sum = 0 ; \nfor ( int index = start ; \nindex < length ; \nindex ++ ) sum += values [ index ] ; \nif ( sum < Integer . MIN_VALUE ) die ( \"overflow the sum is too small\" , sum ) ; \nif ( sum > Integer . MAX_VALUE ) die ( \"overflow the sum is too big\" , sum ) ; \nreturn ( int ) sum ; \n} \n} \n"}
{"7293": "public class SortingInternal { \npublic static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending , boolean nullsFirst ) { \ntry { \nif ( list == null || list . size ( ) == 0 ) return ; \nObject o = list . get ( 0 ) ; \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) Collections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \ncatch ( Exception ex ) { \nExceptions . handle ( ex , \"list\" , list , \"\\nsortBy\" , sortBy , \"fields\" , fields , \"ascending\" , ascending , \"nullFirst\" , nullsFirst ) ; \n} \n} \n} \n"}
{"7294": "public class MapperComplex { \nprivate void setFieldValueFromMap ( final Object parentObject , final FieldAccess field , final Map mapInner ) { \nClass < ? > fieldClassType = field . type ( ) ; \nObject value = null ; \nif ( ! Typ . isMap ( fieldClassType ) ) if ( ! fieldClassType . isInterface ( ) && ! Typ . isAbstract ( fieldClassType ) ) value = fromMap ( mapInner , field . type ( ) ) ; \nelse { \nObject oClassName = mapInner . get ( \"class\" ) ; \nif ( oClassName != null ) value = fromMap ( mapInner , Reflection . loadClass ( oClassName . toString ( ) ) ) ; \nelse value = null ; \n} \nelse if ( Typ . isMap ( fieldClassType ) ) { \nClass keyType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 0 ] ; \nClass valueType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 1 ] ; \nSet < Map . Entry > set = mapInner . entrySet ( ) ; \nMap newMap = new LinkedHashMap ( ) ; \nfor ( Map . Entry entry : set ) { \nObject evalue = entry . getValue ( ) ; \nObject key = entry . getKey ( ) ; \nif ( evalue instanceof ValueContainer ) evalue = ( ( ValueContainer ) evalue ) . toValue ( ) ; \nkey = Conversions . coerce ( keyType , key ) ; \nevalue = Conversions . coerce ( valueType , evalue ) ; \nnewMap . put ( key , evalue ) ; \n} \nvalue = newMap ; \n} \nfield . setValue ( parentObject , value ) ; \n} \n} \n"}
{"7295": "public class MapperComplex { \n@ Override public List < ? > toList ( Object object ) { \nTypeType instanceType = TypeType . getInstanceType ( object ) ; \nswitch ( instanceType ) { \ncase NULL : return Lists . list ( ( Object ) null ) ; \ncase ARRAY : case ARRAY_INT : case ARRAY_BYTE : case ARRAY_SHORT : case ARRAY_FLOAT : case ARRAY_DOUBLE : case ARRAY_LONG : case ARRAY_STRING : case ARRAY_OBJECT : return Conversions . toList ( object ) ; \ncase INSTANCE : if ( Reflection . respondsTo ( object , \"toList\" ) ) return ( List < ? > ) Reflection . invoke ( object , \"toList\" ) ; \nbreak ; \n} \nreturn Lists . list ( object ) ; \n} \n} \n"}
{"7297": "public class Lists { \n@ Universal public static < V > List < V > deepCopy ( List < V > list ) { \nif ( list instanceof LinkedList ) return deepCopyToList ( list , new LinkedList < V > ( ) ) ; \nelse if ( list instanceof CopyOnWriteArrayList ) return deepCopyToList ( list , new CopyOnWriteArrayList < V > ( ) ) ; \nelse return deepCopy ( ( Collection ) list ) ; \n} \n} \n"}
{"7299": "public class Fields { \npublic static boolean classHasStringField ( Class < ? > clz , String name ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getType ( ) . equals ( Typ . string ) && field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"7300": "public class Fields { \npublic static boolean classHasField ( Class < ? > clz , String name ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"7301": "public class Fields { \npublic static String getFirstComparableOrPrimitiveFromClass ( Class < ? > clz ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( ( field . getType ( ) . isPrimitive ( ) || Typ . isComparable ( field . getType ( ) ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) ) return field . getName ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"7302": "public class Fields { \npublic static String getSortableField ( Object value1 ) { \nif ( value1 instanceof Map ) return getSortableFieldFromMap ( ( Map < String , ? > ) value1 ) ; \nelse return getSortableFieldFromClass ( value1 . getClass ( ) ) ; \n} \n} \n"}
{"7304": "public class CacheEntry { \nprivate final int compareTime ( CacheEntry other ) { \nif ( time > other . time ) return 1 ; \nelse if ( time < other . time ) return - 1 ; \nelse if ( time == other . time ) return 0 ; \ndie ( ) ; \nreturn 0 ; \n} \n} \n"}
{"7306": "public class Sorting { \npublic static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( list == null || list . size ( ) == 0 ) return ; \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nIterator iterator = list . iterator ( ) ; \nObject object = iterator . next ( ) ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) fields = BeanUtils . getFieldsFromObject ( object ) ; \nelse while ( iterator . hasNext ( ) ) { \nobject = iterator . next ( ) ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) Collections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) return ; \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) fields = BeanUtils . getFieldsFromObject ( object ) ; \nelse for ( int index = 1 ; \nindex < array . length ; \nindex ++ ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) Arrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n"}
{"7313": "public class FastConcurrentReadLruLfuFifoCache { \npublic VALUE get ( KEY key ) { \nCacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; \nif ( cacheEntry != null ) { \ncacheEntry . readCount . incrementAndGet ( ) ; \nreturn cacheEntry . value ; \n} \nelse return null ; \n} \n} \n"}
{"7314": "public class FastConcurrentReadLruLfuFifoCache { \npublic VALUE getSilent ( KEY key ) { \nCacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; \nif ( cacheEntry != null ) return cacheEntry . value ; \nelse return null ; \n} \n} \n"}
{"7315": "public class FastConcurrentReadLruLfuFifoCache { \nprivate final int order ( ) { \nint order = count . incrementAndGet ( ) ; \nif ( order > Integer . MAX_VALUE - 100 ) count . set ( 0 ) ; \nreturn order ; \n} \n} \n"}
{"7317": "public class LongRangeValidator { \nprivate void dynamicallyInitIfNeeded ( Object value ) { \nif ( ! isInitialized ( ) ) if ( value instanceof Integer ) init ( new Integer ( min . intValue ( ) ) , new Integer ( max . intValue ( ) ) ) ; \nelse if ( value instanceof Byte ) init ( new Byte ( min . byteValue ( ) ) , new Byte ( max . byteValue ( ) ) ) ; \nelse if ( value instanceof Short ) init ( new Short ( min . shortValue ( ) ) , new Short ( max . shortValue ( ) ) ) ; \nelse init ( min , max ) ; \n} \n} \n"}
{"7318": "public class CollectorManager { \npublic final ByteBuffer allocateBuffer ( int size ) { \nif ( RECYCLE_BUFFER ) { \nByteBuffer spentBuffer = recycleChannel . poll ( ) ; \nif ( spentBuffer == null ) spentBuffer = ByteBuffer . allocateDirect ( size ) ; \nspentBuffer . clear ( ) ; \nreturn spentBuffer ; \n} \nelse return ByteBuffer . allocateDirect ( size ) ; \n} \n} \n"}
{"7319": "public class CollectorManager { \nprivate boolean determineIfWeShouldExit ( ) { \nboolean shouldStop = stop . get ( ) ; \nif ( ! shouldStop ) Thread . interrupted ( ) ; \nelse { \nSystem . out . println ( \"Exiting processing loop as requested\" ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7320": "public class CollectorManager { \nprivate void manageInputWriterChannel ( ) throws InterruptedException { \ntry { \nByteBuffer dataToWriteToFile ; \ndataToWriteToFile = inputChannel . poll ( ) ; \nif ( dataToWriteToFile == null ) { \nqueueEmptyMaybeFlush ( ) ; \ndataToWriteToFile = inputChannel . poll ( ) ; \n} \nif ( dataToWriteToFile == null ) dataToWriteToFile = waitForNextDataToWrite ( ) ; \nif ( dataToWriteToFile != null ) { \nwriter . nextBufferToWrite ( dataToWriteToFile ) ; \nif ( RECYCLE_BUFFER ) recycleChannel . offer ( dataToWriteToFile ) ; \n} \n} \ncatch ( InterruptedException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nex . printStackTrace ( ) ; \nex . printStackTrace ( System . err ) ; \n} \n} \n} \n"}
{"7321": "public class CollectorManager { \nprivate void queueEmptyMaybeFlush ( ) { \nif ( PERIODIC_FORCE_FLUSH ) { \nlong currentTime = time . get ( ) ; \nif ( ( currentTime - lastFlushTime ) > FORCE_FLUSH_AFTER_THIS_MANY_MILI_SECONDS ) { \nif ( writer . syncToDisk ( ) ) this . numberOfFlushesTotal . incrementAndGet ( ) ; \nlastFlushTime = time . get ( ) ; \n} \n} \n} \n} \n"}
{"7323": "public class CollectorManager { \npublic void start ( final TimeAware receiver ) { \nwriterFuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nprocessWrites ( ) ; \n} \n} \n, 0 , 500 , TimeUnit . MILLISECONDS ) ; \nstartMonitor ( ) ; \ntickTock = this . scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nlong time = System . nanoTime ( ) / 1_000_000 ; \nif ( receiver != null ) receiver . tick ( time ) ; \ntick ( time ) ; \n} \n} \n, 0 , 20 , TimeUnit . MILLISECONDS ) ; \n} \n} \n"}
{"7324": "public class LazyValueMap { \n@ Override public final Object get ( Object key ) { \nObject object = null ; \nif ( map == null ) buildMap ( ) ; \nobject = map . get ( key ) ; \nlazyChopIfNeeded ( object ) ; \nreturn object ; \n} \n} \n"}
{"7325": "public class FilterDefault { \nprivate ResultSet mainQueryPlan ( Criteria [ ] expressions ) { \nResultSetInternal results = new ResultSetImpl ( this . fields ) ; \nif ( expressions == null || expressions . length == 0 ) results . addResults ( searchableCollection . all ( ) ) ; \nGroup group = expressions . length == 1 && expressions [ 0 ] instanceof Group ? ( Group ) expressions [ 0 ] : ObjectFilter . and ( expressions ) ; \ndoFilterGroup ( group , results ) ; \nreturn results ; \n} \n} \n"}
{"7326": "public class FilterDefault { \nprivate void doFilterGroup ( Group group , ResultSetInternal results ) { \nif ( group . getGrouping ( ) == Grouping . OR ) or ( group . getExpressions ( ) , fields , results ) ; \nelse { \nResultSetInternal resultsForAnd = new ResultSetImpl ( fields ) ; \nand ( group . getExpressions ( ) , fields , resultsForAnd ) ; \nresults . addResults ( resultsForAnd . asList ( ) ) ; \n} \n} \n} \n"}
{"7327": "public class BatchFileWriter { \npublic void tick ( long time ) { \nthis . time . set ( time ) ; \nlong startTime = fileStartTime . get ( ) ; \nlong duration = time - startTime ; \nif ( duration > FILE_TIMEOUT_MILISECONDS ) fileTimeOut . set ( true ) ; \n} \n} \n"}
{"7328": "public class BatchFileWriter { \npublic boolean syncToDisk ( ) { \nif ( outputStream != null && dirty ) try { \nif ( outputStream instanceof FileChannel ) { \nFileChannel channel = ( FileChannel ) outputStream ; \nchannel . force ( true ) ; \n} \ndirty = false ; \nreturn true ; \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \nreturn false ; \n} \nelse return false ; \n} \n} \n"}
{"7329": "public class BatchFileWriter { \nprivate void cleanupOutputStream ( ) { \nif ( outputStream != null ) try { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal int size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred += size ; \nbytesTransferred += size ; \nbytesSinceLastFlush += size ; \nbuffersSent ++ ; \n} \nif ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) try { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n"}
{"7331": "public class BatchFileWriter { \nprivate void write ( final ByteBuffer bufferOut ) throws InterruptedException { \ninitOutputStream ( ) ; \ntry { \nif ( outputStream != null ) outputStream . write ( bufferOut ) ; \nelse error . set ( true ) ; \nif ( bytesSinceLastFlush > FLUSH_EVERY_N_BYTES ) { \nsyncToDisk ( ) ; \nbytesSinceLastFlush = 0 ; \n} \n} \ncatch ( ClosedByInterruptException cbie ) { \nthrow new InterruptedException ( \"File closed by interruption\" ) ; \n} \ncatch ( Exception e ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \ne . printStackTrace ( System . err ) ; \ndiagnose ( ) ; \nExceptions . handle ( e ) ; \n} \n} \n} \n"}
{"7332": "public class BatchFileWriter { \nprivate void initOutputStream ( ) { \nlong time = this . time . get ( ) ; \nif ( error . get ( ) || this . totalBytesTransferred == 0 ) { \ncleanupOutputStream ( ) ; \nerror . set ( false ) ; \ntime = System . nanoTime ( ) / 1_000_000 ; \n} \nif ( outputStream != null ) return ; \nfileName = LogFilesConfig . getLogFileName ( FORMAT_PATTERN , outputDirPath ( ) , numFiles , time , SERVER_NAME ) ; \ntry { \nfileTimeOut . set ( false ) ; \noutputStream = streamCreator ( ) ; \nfileStartTime . set ( time ) ; \nbytesTransferred = 0 ; \nbytesSinceLastFlush = 0 ; \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \nExceptions . handle ( ex ) ; \n} \nfinally { \nnumFiles ++ ; \n} \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \nfor ( int index = 0 ; \nindex < path . length ; \nindex ++ ) { \nString propName = path [ index ] ; \nif ( o == null ) return null ; \nelse if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse o = getProp ( o , propName ) ; \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7350": "public class BeanUtils { \npublic static Map < String , FieldAccess > getFieldsFromObject ( Object object ) { \ntry { \nMap < String , FieldAccess > fields ; \nif ( object instanceof Map ) fields = getFieldsFromMap ( ( Map < String , Object > ) object ) ; \nelse fields = getPropertyFieldAccessMap ( object . getClass ( ) ) ; \nreturn fields ; \n} \ncatch ( Exception ex ) { \nrequireNonNull ( object , \"Item cannot be null\" ) ; \nreturn handle ( Map . class , ex , \"Unable to get fields from object\" , className ( object ) ) ; \n} \n} \n} \n"}
{"7354": "public class BeanUtils { \nprivate static Object getCollectionProp ( Object o , String propName , int index , String [ ] path ) { \no = _getFieldValuesFromCollectionOrArray ( o , propName ) ; \nif ( index + 1 == path . length ) return o ; \nelse { \nindex ++ ; \nreturn getCollectionProp ( o , path [ index ] , index , path ) ; \n} \n} \n} \n"}
{"7355": "public class BeanUtils { \npublic static Object getProp ( Object object , final String property ) { \nif ( object == null ) return null ; \nif ( isDigits ( property ) ) object = idx ( object , StringScanner . parseInt ( property ) ) ; \nClass < ? > cls = object . getClass ( ) ; \nMap < String , FieldAccess > fields = Reflection . getPropertyFieldAccessors ( cls ) ; \nif ( ! fields . containsKey ( property ) ) fields = Reflection . getAllAccessorFields ( cls ) ; \nif ( ! fields . containsKey ( property ) ) return null ; \nelse return fields . get ( property ) . getValue ( object ) ; \n} \n} \n"}
{"7356": "public class BeanUtils { \npublic static int getPropertyInt ( final Object root , final String ... properties ) { \nfinal String lastProperty = properties [ properties . length - 1 ] ; \nif ( isDigits ( lastProperty ) ) return Conversions . toInt ( getPropertyValue ( root , properties ) ) ; \nObject object = baseForGetProperty ( root , properties ) ; \nMap < String , FieldAccess > fields = getFieldsFromObject ( object ) ; \nFieldAccess field = fields . get ( lastProperty ) ; \nif ( field . type ( ) == Typ . intgr ) return field . getInt ( object ) ; \nelse return Conversions . toInt ( field . getValue ( object ) ) ; \n} \n} \n"}
{"7358": "public class MessageSpecification { \npublic String createMessage ( String key , List < String > argKeys , Object ... args ) { \nString message = getMessage ( key ) ; \nObject [ ] actualArgs ; \nif ( args . length > 0 ) actualArgs = args ; \nelse if ( argKeys != null ) actualArgs = keysToValues ( argKeys ) ; \nelse actualArgs = new Object [ ] { \n} \n; \nreturn doCreateMessage ( message , actualArgs ) ; \n} \n} \n"}
{"7362": "public class JsonSlurper { \npublic Object parseText ( String text ) { \nif ( text == null || text . length ( ) == 0 ) throw new IllegalArgumentException ( \"The JSON input text should neither be null nor empty.\" ) ; \nreturn JsonFactory . create ( ) . fromJson ( text ) ; \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! request . getMethod ( ) . equals ( \"GET\" ) ) httpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \nelse httpClientRequest . end ( ) ; \n} \n} \n; \nif ( closed . get ( ) ) this . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nint retry = 0 ; \nwhile ( closed . get ( ) ) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) break ; \nretry ++ ; \nif ( retry > 10 ) break ; \nif ( retry % 3 == 0 ) connect ( ) ; \n} \nif ( ! closed . get ( ) ) runnable . run ( ) ; \nelse responseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \nelse runnable . run ( ) ; \n} \n} \n"}
{"7367": "public class CouchDbUtil { \npublic static List < String > listResources ( String path ) { \ntry { \nClass < CouchDbUtil > clazz = CouchDbUtil . class ; \nURL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"file\" ) ) return Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"jar\" ) ) { \nString jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( \"!\" ) ) ; \nJarFile jar = new JarFile ( URLDecoder . decode ( jarPath , \"UTF-8\" ) ) ; \nEnumeration < JarEntry > entries = jar . entries ( ) ; \nSet < String > result = new HashSet < String > ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nString name = entries . nextElement ( ) . getName ( ) ; \nif ( name . startsWith ( SPRING_BOOT_DIR ) ) name = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; \nif ( name . startsWith ( path ) ) { \nString entry = name . substring ( path . length ( ) ) ; \nint checkSubdir = entry . indexOf ( \"/\" ) ; \nif ( checkSubdir >= 0 ) entry = entry . substring ( 0 , checkSubdir ) ; \nif ( entry . length ( ) > 0 ) result . add ( entry ) ; \n} \n} \nclose ( jar ) ; \nreturn new ArrayList < String > ( result ) ; \n} \nreturn null ; \n} \ncatch ( Exception e ) { \nthrow new CouchDbException ( e ) ; \n} \n} \n} \n"}
{"7368": "public class Replication { \npublic ReplicationResult trigger ( ) { \nassertNotEmpty ( source , \"Source\" ) ; \nassertNotEmpty ( target , \"Target\" ) ; \nHttpResponse response = null ; \ntry { \nJsonObject json = createJson ( ) ; \nif ( log . isDebugEnabled ( ) ) log . debug ( json ) ; \nfinal URI uri = buildUri ( dbc . getBaseUri ( ) ) . path ( \"_replicate\" ) . build ( ) ; \nresponse = dbc . post ( uri , json . toString ( ) ) ; \nfinal InputStreamReader reader = new InputStreamReader ( getStream ( response ) , Charsets . UTF_8 ) ; \nreturn dbc . getGson ( ) . fromJson ( reader , ReplicationResult . class ) ; \n} \nfinally { \nclose ( response ) ; \n} \n} \n} \n"}
{"7369": "public class View { \nprivate < V > V queryValue ( Class < V > classOfV ) { \nInputStream instream = null ; \ntry { \nReader reader = new InputStreamReader ( instream = queryForStream ( ) , Charsets . UTF_8 ) ; \nJsonArray array = new JsonParser ( ) . parse ( reader ) . getAsJsonObject ( ) . get ( \"rows\" ) . getAsJsonArray ( ) ; \nif ( array . size ( ) != 1 ) throw new NoDocumentException ( \"Expecting a single result but was: \" + array . size ( ) ) ; \nreturn JsonToObject ( gson , array . get ( 0 ) , \"value\" , classOfV ) ; \n} \nfinally { \nclose ( instream ) ; \n} \n} \n} \n"}
{"7374": "public class CouchDbDesign { \npublic DesignDocument getFromDesk ( String id ) { \nassertNotEmpty ( id , \"id\" ) ; \nfinal DesignDocument dd = new DesignDocument ( ) ; \nfinal String rootPath = format ( \"%s/%s/\" , DESIGN_DOCS_DIR , id ) ; \nfinal List < String > elements = listResources ( rootPath ) ; \nif ( elements == null ) throw new IllegalArgumentException ( \"Design docs directory cannot be empty.\" ) ; \nMap < String , MapReduce > views = null ; \nif ( elements . contains ( VIEWS ) ) { \nviews = new HashMap < String , MapReduce > ( ) ; \nfinal String viewsPath = format ( \"%s%s/\" , rootPath , VIEWS ) ; \nfor ( String viewDirName : listResources ( viewsPath ) ) { \nfinal MapReduce mr = new MapReduce ( ) ; \nfinal String viewPath = format ( \"%s%s/\" , viewsPath , viewDirName ) ; \nfinal List < String > dirList = listResources ( viewPath ) ; \nfor ( String fileName : dirList ) { \nfinal String def = readFile ( format ( \"/%s%s\" , viewPath , fileName ) ) ; \nif ( MAP_JS . equals ( fileName ) ) mr . setMap ( def ) ; \nelse if ( REDUCE_JS . equals ( fileName ) ) mr . setReduce ( def ) ; \n} \nviews . put ( viewDirName , mr ) ; \n} \n} \ndd . setId ( DESIGN_PREFIX + id ) ; \ndd . setLanguage ( JAVASCRIPT ) ; \ndd . setViews ( views ) ; \ndd . setFilters ( populateMap ( rootPath , elements , FILTERS ) ) ; \ndd . setShows ( populateMap ( rootPath , elements , SHOWS ) ) ; \ndd . setLists ( populateMap ( rootPath , elements , LISTS ) ) ; \ndd . setUpdates ( populateMap ( rootPath , elements , UPDATES ) ) ; \ndd . setValidateDocUpdate ( readContent ( elements , rootPath , VALIDATE_DOC ) ) ; \ndd . setRewrites ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , REWRITES ) , JsonArray . class ) ) ; \ndd . setFulltext ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , FULLTEXT ) , JsonObject . class ) ) ; \ndd . setIndexes ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , INDEXES ) , JsonObject . class ) ) ; \nreturn dd ; \n} \n} \n"}
{"7387": "public class CouchDbClientBase { \nvoid validate ( HttpResponse response ) throws IOException { \nfinal int code = response . getStatusLine ( ) . getStatusCode ( ) ; \nif ( code == 200 || code == 201 || code == 202 ) return ; \nString reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; \nswitch ( code ) { \ncase HttpStatus . SC_NOT_FOUND : { \nthrow new NoDocumentException ( reason ) ; \n} \ncase HttpStatus . SC_CONFLICT : { \nthrow new DocumentConflictException ( reason ) ; \n} \ndefault : { \nthrow new CouchDbException ( reason += EntityUtils . toString ( response . getEntity ( ) ) ) ; \n} \n} \n} \n} \n"}
{"7392": "public class MoneyToStr { \npublic String convert ( Double theMoney ) { \nif ( theMoney == null ) throw new IllegalArgumentException ( \"theMoney is null\" ) ; \nLong intPart = theMoney . longValue ( ) ; \nLong fractPart = Math . round ( ( theMoney - intPart ) * NUM100 ) ; \nif ( currency == Currency . PER1000 ) fractPart = Math . round ( ( theMoney - intPart ) * NUM1000 ) ; \nreturn convert ( intPart , fractPart ) ; \n} \n} \n"}
{"7393": "public class LockManager { \npublic void shutdown ( ) { \ntry { \nlocksExecutor . shutdown ( ) ; \nlocksExecutor . awaitTermination ( 5 , TimeUnit . SECONDS ) ; \nCountDownLatch latch = new CountDownLatch ( 1 ) ; \nactiveLocksLock . writeLock ( ) . lock ( ) ; \nObservable . from ( activeLocks . entrySet ( ) ) . map ( Map . Entry :: getValue ) . flatMap ( lock -> releaseLock ( lock . getName ( ) , lock . getValue ( ) ) . map ( released -> new Lock ( lock . getName ( ) , lock . getValue ( ) , lock . getExpiration ( ) , lock . getRenewalRate ( ) , ! released ) ) ) . subscribe ( lock -> { \nif ( lock . isLocked ( ) ) logger . infof ( \"Failed to release lock %s\" , lock . getName ( ) ) ; \n} \n, t -> { \nlogger . info ( \"There was an error while releasing locks\" , t ) ; \nlatch . countDown ( ) ; \n} \n, latch :: countDown ) ; \nlatch . await ( ) ; \nlogger . info ( \"Shutdown complete\" ) ; \n} \ncatch ( InterruptedException e ) { \nlogger . debug ( \"Shutdown was interrupted. Some locks may not have been released but they will still expire.\" ) ; \n} \n} \n} \n"}
{"7398": "public class TokenAuthenticator { \nprivate boolean isQuery ( HttpServerExchange serverExchange ) { \nif ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"GET\" ) || serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"HEAD\" ) ) return true ; \nelse if ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"POST\" ) ) if ( postQuery != null && postQuery . matcher ( serverExchange . getRelativePath ( ) ) . find ( ) ) return true ; \nelse return false ; \nelse return false ; \n} \n} \n"}
{"7399": "public class TokenAuthenticator { \nprivate void sendAuthenticationRequest ( HttpServerExchange serverExchange , PooledConnection connection ) { \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nString verb = getVerb ( serverExchange ) ; \nString resource ; \nif ( ! isQuery ( serverExchange ) ) if ( USER_WRITE_ACCESS . equalsIgnoreCase ( \"true\" ) ) resource = RESOURCE ; \nelse resource = resourceName ; \nelse resource = RESOURCE ; \ncontext . subjectAccessReview = generateSubjectAccessReview ( context . tenant , verb , resource ) ; \nClientRequest request = buildClientRequest ( context ) ; \ncontext . clientRequestStarting ( ) ; \nconnection . sendRequest ( request , new RequestReadyCallback ( serverExchange , connection ) ) ; \n} \n} \n"}
{"7400": "public class TokenAuthenticator { \nprivate String getVerb ( HttpServerExchange serverExchange ) { \nif ( isQuery ( serverExchange ) ) return VERBS . get ( GET ) ; \nelse { \nString verb = VERBS . get ( serverExchange . getRequestMethod ( ) ) ; \nif ( verb == null ) { \nlog . debugf ( \"Unhandled http method '%s'. Checking for read access.\" , serverExchange . getRequestMethod ( ) ) ; \nverb = VERBS_DEFAULT ; \n} \nreturn verb ; \n} \n} \n} \n"}
{"7402": "public class TokenAuthenticator { \nprivate void onRequestResult ( HttpServerExchange serverExchange , PooledConnection connection , boolean allowed ) { \nconnectionPools . get ( serverExchange . getIoThread ( ) ) . release ( connection ) ; \nAuthContext context = serverExchange . removeAttachment ( AUTH_CONTEXT_KEY ) ; \napiLatency . update ( context . getClientResponseTime ( ) , NANOSECONDS ) ; \nauthLatency . update ( context . getLatency ( ) , NANOSECONDS ) ; \nif ( allowed ) serverExchange . dispatch ( containerHandler ) ; \nelse endExchange ( serverExchange , FORBIDDEN ) ; \n} \n} \n"}
{"7403": "public class TokenAuthenticator { \nprivate void onRequestFailure ( HttpServerExchange serverExchange , PooledConnection connection , IOException e , boolean retry ) { \nlog . debug ( \"Client request failure\" , e ) ; \nIoUtils . safeClose ( connection ) ; \nConnectionPool connectionPool = connectionPools . get ( serverExchange . getIoThread ( ) ) ; \nconnectionPool . release ( connection ) ; \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nif ( context . retries < MAX_RETRY && retry ) { \ncontext . retries ++ ; \nPooledConnectionWaiter waiter = createWaiter ( serverExchange ) ; \nif ( ! connectionPool . offer ( waiter ) ) endExchange ( serverExchange , INTERNAL_SERVER_ERROR , TOO_MANY_PENDING_REQUESTS ) ; \n} \nelse endExchange ( serverExchange , INTERNAL_SERVER_ERROR , CLIENT_REQUEST_FAILURE ) ; \n} \n} \n"}
{"7405": "public class JobsService { \npublic Observable < JobDetails > findScheduledJobs ( Date timeSlice , rx . Scheduler scheduler ) { \nreturn session . executeAndFetch ( findAllScheduled . bind ( ) , scheduler ) . filter ( filterNullJobs ) . filter ( row -> row . getTimestamp ( 0 ) . compareTo ( timeSlice ) <= 0 ) . map ( row -> createJobDetails ( row . getUUID ( 1 ) , row . getString ( 2 ) , row . getString ( 3 ) , row . getMap ( 4 , String . class , String . class ) , getTrigger ( row . getUDTValue ( 5 ) ) , JobStatus . fromCode ( row . getByte ( 6 ) ) , timeSlice ) ) . collect ( HashMap :: new , ( Map < UUID , SortedSet < JobDetails > > map , JobDetails details ) -> { \nSortedSet < JobDetails > set = map . get ( details . getJobId ( ) ) ; \nif ( set == null ) set = new TreeSet < > ( ( JobDetails d1 , JobDetails d2 ) -> Long . compare ( d1 . getTrigger ( ) . getTriggerTime ( ) , d2 . getTrigger ( ) . getTriggerTime ( ) ) ) ; \nset . add ( details ) ; \nmap . put ( details . getJobId ( ) , set ) ; \n} \n) . flatMap ( map -> Observable . from ( map . entrySet ( ) ) ) . map ( entry -> entry . getValue ( ) . first ( ) ) ; \n} \n} \n"}
{"7407": "public class Utils { \npublic static void endExchange ( HttpServerExchange exchange , int statusCode , String reasonPhrase ) { \nexchange . setStatusCode ( statusCode ) ; \nif ( reasonPhrase != null ) exchange . setReasonPhrase ( reasonPhrase ) ; \nexchange . endExchange ( ) ; \n} \n} \n"}
{"7408": "public class DataAccessImpl { \n@ Override public Observable < Observable < Row > > findAllDataFromBucket ( long timestamp , int pageSize , int maxConcurrency ) { \nPreparedStatement ts = getTempStatement ( MetricType . UNDEFINED , TempStatement . SCAN_WITH_TOKEN_RANGES , timestamp ) ; \nif ( ts == null || prepMap . floorKey ( timestamp ) == 0L ) return Observable . empty ( ) ; \nreturn Observable . from ( getTokenRanges ( ) ) . map ( tr -> rxSession . executeAndFetch ( ts . bind ( ) . setToken ( 0 , tr . getStart ( ) ) . setToken ( 1 , tr . getEnd ( ) ) . setFetchSize ( pageSize ) ) ) ; \n} \n} \n"}
{"7409": "public class Buckets { \npublic static Buckets fromStep ( long start , long end , long step ) { \ncheckTimeRange ( start , end ) ; \ncheckArgument ( step > 0 , \"step is not positive: %s\" , step ) ; \nif ( step > ( end - start ) ) return new Buckets ( start , step , 1 ) ; \nlong quotient = ( end - start ) / step ; \nlong remainder = ( end - start ) % step ; \nlong count ; \nif ( remainder == 0 ) count = quotient ; \nelse count = quotient + 1 ; \ncheckArgument ( count <= Integer . MAX_VALUE , \"Computed number of buckets is too big: %s\" , count ) ; \nreturn new Buckets ( start , step , ( int ) count ) ; \n} \n} \n"}
{"7413": "public class MockJedis { \n@ Override public ScanResult < String > scan ( String cursor , ScanParams params ) { \nCollection < byte [ ] > rawParams = params . getParams ( ) ; \nboolean isKey = true ; \nString match = null ; \nboolean foundMatchKey = false ; \nfor ( byte [ ] raw : rawParams ) { \nif ( isKey ) { \nString key = new String ( raw ) ; \nif ( key . equals ( new String ( MATCH . raw ) ) ) foundMatchKey = true ; \n} \nelse if ( foundMatchKey ) { \nmatch = new String ( raw ) ; \nbreak ; \n} \nisKey = ! isKey ; \n} \nreturn new ScanResult < String > ( \"0\" , new ArrayList < String > ( keys ( match ) ) ) ; \n} \n} \n"}
{"7417": "public class ZipBuilder { \npublic File build ( ) throws IOException { \nif ( entries . isEmpty ( ) ) throw new EmptyZipException ( ) ; \nString fileName = \"import_configuration\" + System . currentTimeMillis ( ) + \".zip\" ; \nFile result = new File ( TEMP_DIR . toFile ( ) , fileName ) ; \ntry ( ZipOutputStream zip = new ZipOutputStream ( Files . newOutputStream ( result . toPath ( ) , StandardOpenOption . CREATE_NEW ) ) ) { \ncustomization . init ( entries . values ( ) , this :: streamFor ) ; \nfor ( Entry < Object , String > entry : entries . entrySet ( ) ) { \ntry ( InputStream input = toInputStream ( entry . getKey ( ) ) ) { \naddEntry ( ExtraZipEntry . of ( entry . getValue ( ) , customization . customize ( entry . getValue ( ) , input ) ) , zip ) ; \n} \n} \ncustomization . extraEntries ( ) . forEach ( entry -> addEntry ( entry , zip ) ) ; \nzip . closeEntry ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"7423": "public class UniqueDirectory { \npublic static File in ( File parentDir ) { \nFile result = new File ( parentDir , UUID . randomUUID ( ) . toString ( ) ) ; \nif ( ! result . mkdirs ( ) ) throw new RuntimeIoException ( new IOException ( \"Could not create directory: \" + result ) ) ; \nreturn result ; \n} \n} \n"}
{"7428": "public class BatchSipAssembler { \npublic synchronized void add ( D domainObject ) throws IOException { \nif ( shouldStartNewSip ( domainObject ) ) startSip ( ) ; \nassembler . add ( domainObject ) ; \n} \n} \n"}
{"7432": "public class IOStreams { \npublic static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { \nbyte [ ] buffer = new byte [ bufferSize ] ; \nint numRead = Objects . requireNonNull ( in , \"Missing input\" ) . read ( buffer ) ; \nif ( numRead == 0 ) throw new IllegalArgumentException ( \"Missing content\" ) ; \nObjects . requireNonNull ( out , \"Missing output\" ) ; \nwhile ( numRead > 0 ) { \nout . write ( buffer , 0 , numRead ) ; \nhashAssembler . add ( buffer , numRead ) ; \nnumRead = in . read ( buffer ) ; \n} \n} \n} \n"}
{"7433": "public class XmlUtil { \npublic static Document parse ( File file ) { \nif ( ! file . isFile ( ) ) throw new IllegalArgumentException ( \"Missing file: \" + file . getAbsolutePath ( ) ) ; \ntry { \ntry ( InputStream stream = Files . newInputStream ( file . toPath ( ) , StandardOpenOption . READ ) ) { \nreturn parse ( stream ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalArgumentException ( \"Failed to parse \" + file . getAbsolutePath ( ) , e ) ; \n} \n} \n} \n"}
{"7440": "public class FileArchiver { \npublic static void main ( String [ ] args ) { \ntry { \nArguments arguments = new Arguments ( args ) ; \nFile root = new File ( arguments . next ( \"content\" ) ) ; \nif ( ! root . isDirectory ( ) ) root = new File ( \".\" ) ; \nString rootPath = root . getCanonicalPath ( ) ; \nString sip = arguments . next ( \"build/files.zip\" ) ; \nnew FileArchiver ( ) . run ( rootPath , sip ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( System . out ) ; \nSystem . exit ( 1 ) ; \n} \n} \n} \n"}
{"7444": "public class QSStringUtil { \npublic static String asciiCharactersEncoding ( String str ) throws QSException { \nif ( QSStringUtil . isEmpty ( str ) ) return \"\" ; \ntry { \nString encoded = URLEncoder . encode ( str , QSConstant . ENCODING_UTF8 ) ; \nencoded = encoded . replace ( \"%2F\" , \"/\" ) ; \nencoded = encoded . replace ( \"%3D\" , \"=\" ) ; \nencoded = encoded . replace ( \"+\" , \"%20\" ) ; \nencoded = encoded . replace ( \"%3A\" , \":\" ) ; \nreturn encoded ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new QSException ( \"UnsupportedEncodingException:\" , e ) ; \n} \n} \n} \n"}
{"7446": "public class Base64 { \nprivate static int removeWhiteSpace ( char [ ] data ) { \nif ( data == null ) return 0 ; \nint newSize = 0 ; \nint len = data . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) if ( ! isWhiteSpace ( data [ i ] ) ) data [ newSize ++ ] = data [ i ] ; \nreturn newSize ; \n} \n} \n"}
{"7449": "public class UploadManager { \nprivate void completeMultiUpload ( String objectKey , String fileName , String eTag , String uploadID , long length ) throws QSException { \nCompleteMultipartUploadInput completeMultipartUploadInput = new CompleteMultipartUploadInput ( uploadID , partCounts , 0 ) ; \ncompleteMultipartUploadInput . setContentLength ( length ) ; \nif ( ! QSStringUtil . isEmpty ( fileName ) ) try { \nString keyName = QSStringUtil . percentEncode ( fileName , \"UTF-8\" ) ; \ncompleteMultipartUploadInput . setContentDisposition ( String . format ( \"attachment; filename=\\\"%s\\\"; filename*=utf-8''%s\" , keyName , keyName ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \nif ( ! QSStringUtil . isEmpty ( eTag ) ) completeMultipartUploadInput . setETag ( eTag ) ; \nRequestHandler requestHandler = bucket . completeMultipartUploadRequest ( objectKey , completeMultipartUploadInput ) ; \nsign ( requestHandler ) ; \nBucket . CompleteMultipartUploadOutput send = ( Bucket . CompleteMultipartUploadOutput ) requestHandler . send ( ) ; \nif ( send . getStatueCode ( ) == 200 || send . getStatueCode ( ) == 201 ) { \nuploadModel . setUploadComplete ( true ) ; \nsetData ( objectKey , recorder ) ; \n} \nif ( callBack != null ) callBack . onAPIResponse ( objectKey , send ) ; \n} \n} \n"}
{"7450": "public class FavoriteAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nfinal String notificationId = entry . getId ( ) ; \nfinal Set < String > favoriteNotices = this . getFavoriteNotices ( req ) ; \nif ( favoriteNotices . contains ( notificationId ) ) favoriteNotices . remove ( notificationId ) ; \nelse favoriteNotices . add ( notificationId ) ; \nsetFavoriteNotices ( req , favoriteNotices ) ; \n} \n} \n"}
{"7451": "public class JpaNotificationService { \npublic void addEntryState ( PortletRequest req , String entryId , NotificationState state ) { \nif ( usernameFinder . isAuthenticated ( req ) ) { \nfinal String username = usernameFinder . findUsername ( req ) ; \nString idStr = entryId . replaceAll ( ID_PREFIX , \"\" ) ; \nJpaEntry jpaEntry = notificationDao . getEntry ( Long . parseLong ( idStr ) ) ; \nif ( jpaEntry != null ) { \nJpaEvent event = new JpaEvent ( ) ; \nevent . setEntry ( jpaEntry ) ; \nevent . setState ( state ) ; \nevent . setTimestamp ( new Timestamp ( new Date ( ) . getTime ( ) ) ) ; \nevent . setUsername ( username ) ; \nnotificationDao . createOrUpdateEvent ( event ) ; \n} \nelse throw new IllegalArgumentException ( \"JpaEntry not found\" ) ; \n} \n} \n} \n"}
{"7452": "public class SSPToken { \npublic boolean hasExpired ( ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( created + ( expiresIn * 1000 ) + TIMEOUT_BUFFER > now ) return false ; \nreturn true ; \n} \n} \n"}
{"7460": "public class SSPApi { \nprivate synchronized SSPToken getAuthenticationToken ( boolean forceUpdate ) throws MalformedURLException , RestClientException { \nif ( authenticationToken != null && ! authenticationToken . hasExpired ( ) && ! forceUpdate ) return authenticationToken ; \nString authString = getClientId ( ) + \":\" + getClientSecret ( ) ; \nString authentication = new Base64 ( ) . encodeToString ( authString . getBytes ( ) ) ; \nHttpHeaders headers = new HttpHeaders ( ) ; \nheaders . add ( AUTHORIZATION , BASIC + \" \" + authentication ) ; \nMultiValueMap < String , String > form = new LinkedMultiValueMap < > ( ) ; \nform . add ( GRANT_TYPE , CLIENT_CREDENTIALS ) ; \nHttpEntity < MultiValueMap < String , String > > request = new HttpEntity < > ( form , headers ) ; \nURL authURL = getAuthenticationURL ( ) ; \nauthenticationToken = restTemplate . postForObject ( authURL . toExternalForm ( ) , request , SSPToken . class ) ; \nreturn authenticationToken ; \n} \n} \n"}
{"7462": "public class NotificationResponse { \nprivate void addCategories ( List < NotificationCategory > newCategories ) { \nif ( newCategories == null ) return ; \nnewCategories = newCategories . parallelStream ( ) . map ( NotificationCategory :: cloneNoExceptions ) . collect ( Collectors . toList ( ) ) ; \nMap < String , NotificationCategory > catsByName = this . categories . parallelStream ( ) . collect ( toMap ( c -> c . getTitle ( ) . toLowerCase ( ) , c -> c ) ) ; \nMap < Boolean , List < NotificationCategory > > matchingNewCats = newCategories . stream ( ) . collect ( partitioningBy ( c -> catsByName . containsKey ( c . getTitle ( ) . toLowerCase ( ) ) ) ) ; \nmatchingNewCats . get ( Boolean . TRUE ) . stream ( ) . forEachOrdered ( c -> catsByName . get ( c . getTitle ( ) . toLowerCase ( ) ) . addEntries ( c . getEntries ( ) ) ) ; \nthis . categories . addAll ( matchingNewCats . get ( Boolean . FALSE ) ) ; \n} \n} \n"}
{"7463": "public class SSPTaskNotificationService { \n@ Override public NotificationResponse fetch ( PortletRequest req ) { \nPortletPreferences preferences = req . getPreferences ( ) ; \nString enabled = preferences . getValue ( SSP_NOTIFICATIONS_ENABLED , \"false\" ) ; \nif ( ! \"true\" . equalsIgnoreCase ( enabled ) ) return new NotificationResponse ( ) ; \nString personId = getPersonId ( req ) ; \nif ( personId == null ) return new NotificationResponse ( ) ; \nString urlFragment = getActiveTaskUrl ( ) ; \nSSPApiRequest < String > request = new SSPApiRequest < > ( urlFragment , String . class ) . addUriParameter ( \"personId\" , personId ) ; \nResponseEntity < String > response ; \ntry { \nresponse = sspApi . doRequest ( request ) ; \n} \ncatch ( Exception e ) { \nlog . error ( \"Error reading SSP Notifications: \" + e . getMessage ( ) ) ; \nreturn notificationError ( e . getMessage ( ) ) ; \n} \nif ( response . getStatusCode ( ) . series ( ) != HttpStatus . Series . SUCCESSFUL ) { \nlog . error ( \"Error reading SSP Notifications: \" + response ) ; \nreturn notificationError ( response . getBody ( ) ) ; \n} \nNotificationResponse notification = mapToNotificationResponse ( req , response ) ; \nreturn notification ; \n} \n} \n"}
{"7465": "public class SSPTaskNotificationService { \nprivate NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) { \nString error = readContext . read ( MESSAGE_QUERY ) ; \nreturn notificationError ( error ) ; \n} \nObject rows = readContext . read ( ROWS_QUERY ) ; \nif ( ! ( rows instanceof JSONArray ) ) throw new RuntimeException ( \"Expected 'rows' to be an array of tasks\" ) ; \nString source = getNotificationSource ( request ) ; \nList < NotificationEntry > list = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < ( ( JSONArray ) rows ) . size ( ) ; \ni ++ ) { \nNotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; \nif ( entry != null ) { \nattachActions ( request , entry ) ; \nlist . add ( entry ) ; \n} \n} \nNotificationResponse notification = new NotificationResponse ( ) ; \nif ( ! list . isEmpty ( ) ) { \nNotificationCategory category = getNotificationCategory ( request ) ; \ncategory . addEntries ( list ) ; \nnotification . setCategories ( Arrays . asList ( category ) ) ; \n} \nreturn notification ; \n} \n} \n"}
{"7466": "public class SSPTaskNotificationService { \nprivate NotificationEntry mapNotificationEntry ( ReadContext readContext , int index , String source ) { \nboolean completed = readContext . read ( format ( ROW_COMPLETED_QUERY_FMT , index ) , Boolean . class ) ; \nif ( completed ) return null ; \nNotificationEntry entry = new NotificationEntry ( ) ; \nentry . setSource ( source ) ; \nString id = readContext . read ( format ( ROW_ID_QUERY_FMT , index ) ) ; \nentry . setId ( id ) ; \nString title = readContext . read ( format ( ROW_NAME_QUERY_FMT , index ) ) ; \nentry . setTitle ( title ) ; \nString desc = readContext . read ( format ( ROW_DESCRIPTION_QUERY_FMT , index ) ) ; \nentry . setBody ( desc ) ; \nString link = readContext . read ( format ( ROW_LINK_QUERY_FMT , index ) ) ; \nURL fixedLink = normalizeLink ( link ) ; \nif ( fixedLink != null ) entry . setUrl ( fixedLink . toExternalForm ( ) ) ; \nDate createDate = readContext . read ( format ( \"$.rows[%d].createdDate\" , index ) , Date . class ) ; \nMap < NotificationState , Date > states = new HashMap < > ( ) ; \nstates . put ( NotificationState . ISSUED , createDate ) ; \ntry { \nString dateStr = readContext . read ( format ( ROW_DUE_DATE_QUERY_FMT , index ) ) ; \nif ( ! StringUtils . isBlank ( dateStr ) ) synchronized ( dateFormat ) { \nDate dueDate = dateFormat . parse ( dateStr ) ; \nentry . setDueDate ( dueDate ) ; \n} \n} \ncatch ( Exception e ) { \nlog . warn ( \"Error parsing due date.  Ignoring\" , e ) ; \n} \nreturn entry ; \n} \n} \n"}
{"7468": "public class SSPTaskNotificationService { \nprivate URL normalizeLink ( String link ) { \ntry { \nif ( StringUtils . isEmpty ( link ) ) return null ; \nif ( link . startsWith ( \"/\" ) ) return sspApi . getSSPUrl ( link , true ) ; \nif ( link . startsWith ( \"http://\" ) || link . startsWith ( \"https://\" ) ) return new URL ( link ) ; \nreturn new URL ( \"http://\" + link ) ; \n} \ncatch ( MalformedURLException e ) { \nlog . warn ( \"Bad URL from SSP Entry: \" + link , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"7471": "public class ReadAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nfinal String notificationId = entry . getId ( ) ; \nfinal Set < String > readNotices = this . getReadNotices ( req ) ; \nif ( readNotices . contains ( notificationId ) ) readNotices . remove ( notificationId ) ; \nelse readNotices . add ( notificationId ) ; \nsetReadNotices ( req , readNotices ) ; \n} \n} \n"}
{"7472": "public class ClassLoaderResourceNotificationService { \nprivate NotificationResponse readFromFile ( String filename ) { \nNotificationResponse rslt ; \nlogger . debug ( \"Preparing to read from file:  {}\" , filename ) ; \nURL location = getClass ( ) . getClassLoader ( ) . getResource ( filename ) ; \nif ( location != null ) try { \nFile f = new File ( location . toURI ( ) ) ; \nrslt = mapper . readValue ( f , NotificationResponse . class ) ; \n} \ncatch ( Exception e ) { \nString msg = \"Failed to read the data file:  \" + location ; \nlogger . error ( msg , e ) ; \nrslt = prepareErrorResponse ( getName ( ) , msg ) ; \n} \nelse { \nString msg = \"Data file not found:  \" + filename ; \nrslt = prepareErrorResponse ( getName ( ) , msg ) ; \n} \nreturn rslt ; \n} \n} \n"}
{"7473": "public class SSPSchoolIdPersonLookup { \nprivate String getSchoolId ( PortletRequest request ) { \nPortletPreferences prefs = request . getPreferences ( ) ; \nString schoolIdAttributeName = prefs . getValue ( \"SSPTaskNotificationService.schoolIdAttribute\" , \"schoolId\" ) ; \nMap < String , String > userInfo = ( Map < String , String > ) request . getAttribute ( PortletRequest . USER_INFO ) ; \nString studentId = userInfo . get ( schoolIdAttributeName ) ; \nif ( ! StringUtils . isEmpty ( studentId ) ) return studentId ; \nstudentId = userInfo . get ( USERNAME_ATTRIBUTE ) ; \nreturn studentId ; \n} \n} \n"}
{"7474": "public class SSPSchoolIdPersonLookup { \nprivate String extractUserId ( String studentId , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) return null ; \nint count = readContext . read ( RESULTS_QUERY , Integer . class ) ; \nif ( count != 1 ) { \nlog . warn ( \"Expected a single unique result for \" + studentId + \".  Found \" + count ) ; \nreturn null ; \n} \nString id = readContext . read ( STUDENT_ID_QUERY ) ; \nreturn id ; \n} \n} \n"}
{"7475": "public class HideAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nif ( ! isEntrySnoozed ( entry , req ) ) hide ( entry , req ) ; \nelse unhide ( entry , req ) ; \n} \n} \n"}
{"7479": "public class DistancePointTriangle3D_F64 { \npublic void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { \nGeometryMath_F64 . sub ( B , P , D ) ; \na = E0 . dot ( E0 ) ; \nb = E0 . dot ( E1 ) ; \nc = E1 . dot ( E1 ) ; \nd = E0 . dot ( D ) ; \ne = E1 . dot ( D ) ; \ndouble det = a * c - b * b ; \ns = b * e - c * d ; \nt = b * d - a * e ; \nif ( s + t <= det ) if ( s < 0 ) if ( t < 0 ) region4 ( ) ; \nelse region3 ( ) ; \nelse if ( t < 0 ) region5 ( ) ; \nelse region0 ( det ) ; \nelse if ( s < 0 ) region2 ( ) ; \nelse if ( t < 0 ) region6 ( ) ; \nelse region1 ( ) ; \nclosestPt . x = B . x + s * E0 . x + t * E1 . x ; \nclosestPt . y = B . y + s * E0 . y + t * E1 . y ; \nclosestPt . z = B . z + s * E0 . z + t * E1 . z ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( int i = 0 ; \ni < polygon . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( p . x < rectangle . p0 . x ) rectangle . p0 . x = p . x ; \nelse if ( p . x > rectangle . p1 . x ) rectangle . p1 . x = p . x ; \nif ( p . y < rectangle . p0 . y ) rectangle . p0 . y = p . y ; \nelse if ( p . y > rectangle . p1 . y ) rectangle . p1 . y = p . y ; \n} \n} \n} \n"}
{"7489": "public class UtilPolygons2D_F64 { \npublic static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { \nPoint2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) array [ i ] = points . get ( i ) ; \nAndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; \nandrew . process ( array , array . length , hull ) ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( int i = 0 ; \ni < polygon . vertexes . size ( ) ; \n) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( angle <= tol ) { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) i = polygon . vertexes . size ( ) - 1 ; \n} \nelse i ++ ; \n} \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \nfor ( int i = 0 ; \ni < target . size ( ) ; \ni ++ ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength += b0 . distance ( b1 ) ; \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nint cornerB = 0 ; \nfor ( int k = 0 ; \nk < numberOfSamples ; \nk ++ ) { \ndouble location = totalLength * k / numberOfSamples ; \nwhile ( location > cornerLocationsB [ cornerB + 1 ] ) cornerB ++ ; \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < model . size ( ) + 1 ; \ni ++ ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( d < best ) best = d ; \n} \nerror += best ; \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7496": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , Point2D_F64 ret ) { \ndouble a0 = l_0 . b . x - l_0 . a . x ; \ndouble b0 = l_0 . b . y - l_0 . a . y ; \ndouble a1 = l_1 . b . x - l_1 . a . x ; \ndouble b1 = l_1 . b . y - l_1 . a . y ; \ndouble top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; \ndouble bottom = a0 * b1 - b0 * a1 ; \nif ( bottom == 0 ) return null ; \ndouble t_1 = top / bottom ; \nif ( t_1 < 0 || t_1 > 1 ) return null ; \ntop = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; \nbottom = a1 * b0 - b1 * a0 ; \ndouble t_0 = top / bottom ; \nif ( t_0 < 0 || t_0 > 1 ) return null ; \nif ( ret == null ) ret = new Point2D_F64 ( ) ; \nret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; \nreturn ret ; \n} \n} \n"}
{"7502": "public class ConvertRotation3D_F64 { \nprivate static double get ( DMatrixRMaj M , int index ) { \nif ( index < 0 ) return - M . data [ - index - 1 ] ; \nelse return M . data [ index - 1 ] ; \n} \n} \n"}
{"7518": "public class Polygon2D_F64 { \npublic boolean isInside ( Point2D_F64 p ) { \nif ( isConvex ( ) ) return Intersection2D_F64 . containConvex ( this , p ) ; \nelse return Intersection2D_F64 . containConcave ( this , p ) ; \n} \n} \n"}
{"7531": "public class InterpolateLinearSe2_F64 { \npublic static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { \ndouble w0 = 1.0 - where ; \noutput . T . x = a . T . x * w0 + b . T . x * where ; \noutput . T . y = a . T . y * w0 + b . T . y * where ; \ndouble yaw0 = a . getYaw ( ) ; \ndouble yaw1 = b . getYaw ( ) ; \ndouble cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; \ndouble ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; \ndouble yaw ; \nif ( cw > ccw ) yaw = yaw0 + ccw * where ; \nelse yaw = yaw0 - cw * where ; \noutput . setYaw ( yaw ) ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) hull . get ( i ) . set ( input [ i ] ) ; \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) work . removeTail ( ) ; \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nint minSize = work . size + 2 ; \nfor ( int i = length - 1 ; \ni >= 0 ; \ni -- ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) work . removeTail ( ) ; \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \nfor ( int i = 0 ; \ni < work . size ( ) ; \ni ++ ) hull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \n} \n} \n"}
{"7537": "public class SpecialEuclideanOps_F64 { \npublic static Se3_F64 axisXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , Se3_F64 se ) { \nif ( se == null ) se = new Se3_F64 ( ) ; \ndouble theta = Math . sqrt ( rotX * rotX + rotY + rotY + rotZ * rotZ ) ; \nif ( theta == 0 ) CommonOps_DDRM . setIdentity ( se . R ) ; \nelse ConvertRotation3D_F64 . rodriguesToMatrix ( rotX / theta , rotY / theta , rotZ / theta , theta , se . getR ( ) ) ; \nVector3D_F64 T = se . getT ( ) ; \nT . x = dx ; \nT . y = dy ; \nT . z = dz ; \nreturn se ; \n} \n} \n"}
{"7542": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 , Point3D_F64 ret ) { \nif ( ret == null ) ret = new Point3D_F64 ( ) ; \nret . x = l0 . p . x - l1 . p . x ; \nret . y = l0 . p . y - l1 . p . y ; \nret . z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( ret , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble t0 = dv01v1 * dv1v0 - MiscOps . dot ( ret , l0 . slope ) * dv1v1 ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \nif ( bottom == 0 ) return null ; \nt0 /= bottom ; \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \nret . x = ( double ) 0.5 * ( ( l0 . p . x + t0 * l0 . slope . x ) + ( l1 . p . x + t1 * l1 . slope . x ) ) ; \nret . y = ( double ) 0.5 * ( ( l0 . p . y + t0 * l0 . slope . y ) + ( l1 . p . y + t1 * l1 . slope . y ) ) ; \nret . z = ( double ) 0.5 * ( ( l0 . p . z + t0 * l0 . slope . z ) + ( l1 . p . z + t1 * l1 . slope . z ) ) ; \nreturn ret ; \n} \n} \n"}
{"7543": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineParametric3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { \nif ( ret == null ) ret = new Point3D_F64 ( ) ; \ndouble dx = pt . x - line . p . x ; \ndouble dy = pt . y - line . p . y ; \ndouble dz = pt . z - line . p . z ; \ndouble n2 = line . slope . normSq ( ) ; \ndouble d = ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) ; \nret . x = line . p . x + d * line . slope . x / n2 ; \nret . y = line . p . y + d * line . slope . y / n2 ; \nret . z = line . p . z + d * line . slope . z / n2 ; \nreturn ret ; \n} \n} \n"}
{"7545": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { \nif ( ret == null ) ret = new Point3D_F64 ( ) ; \ndouble dx = pt . x - line . a . x ; \ndouble dy = pt . y - line . a . y ; \ndouble dz = pt . z - line . a . z ; \ndouble slope_x = line . b . x - line . a . x ; \ndouble slope_y = line . b . y - line . a . y ; \ndouble slope_z = line . b . z - line . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( d <= 0 ) ret . set ( line . a ) ; \nelse if ( d >= n ) ret . set ( line . b ) ; \nelse { \nret . x = line . a . x + d * slope_x / n ; \nret . y = line . a . y + d * slope_y / n ; \nret . z = line . a . z + d * slope_z / n ; \n} \nreturn ret ; \n} \n} \n"}
{"7546": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( Point3D_F64 vertexA , Point3D_F64 vertexB , Point3D_F64 vertexC , Point3D_F64 point , Point3D_F64 ret ) { \nif ( ret == null ) ret = new Point3D_F64 ( ) ; \nDistancePointTriangle3D_F64 alg = new DistancePointTriangle3D_F64 ( ) ; \nalg . setTriangle ( vertexA , vertexB , vertexC ) ; \nalg . closestPoint ( point , ret ) ; \nreturn ret ; \n} \n} \n"}
{"7547": "public class SePointOps_F64 { \npublic static Point2D_F64 transform ( Se2_F64 se , Point2D_F64 orig , Point2D_F64 result ) { \nif ( result == null ) result = new Point2D_F64 ( ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \ndouble x = orig . x ; \ndouble y = orig . y ; \nresult . x = se . getX ( ) + x * c - y * s ; \nresult . y = se . getY ( ) + x * s + y * c ; \nreturn result ; \n} \n} \n"}
{"7558": "public class UtilLine2D_F64 { \npublic static LineGeneral2D_F64 convert ( LineParametric2D_F64 src , LineGeneral2D_F64 ret ) { \nif ( ret == null ) ret = new LineGeneral2D_F64 ( ) ; \nret . A = - src . slope . y ; \nret . B = src . slope . x ; \nret . C = - ret . A * src . p . x - ret . B * src . p . y ; \nreturn ret ; \n} \n} \n"}
{"7559": "public class UtilLine2D_F64 { \npublic static LineParametric2D_F64 convert ( LineGeneral2D_F64 src , LineParametric2D_F64 ret ) { \nif ( ret == null ) ret = new LineParametric2D_F64 ( ) ; \nret . slope . x = src . B ; \nret . slope . y = - src . A ; \nif ( Math . abs ( src . B ) > Math . abs ( src . A ) ) { \nret . p . y = - src . C / src . B ; \nret . p . x = 0 ; \n} \nelse { \nret . p . x = - src . C / src . A ; \nret . p . y = 0 ; \n} \nreturn ret ; \n} \n} \n"}
{"7566": "public class GeoTuple_F64 { \n@ Override public T copy ( ) { \nT ret = createNewInstance ( ) ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) ret . setIdx ( i , getIdx ( i ) ) ; \nreturn ret ; \n} \n} \n"}
{"7568": "public class UtilLine3D_F64 { \npublic static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { \ndouble dx = pointOnLine . x - line . p . x ; \ndouble dy = pointOnLine . y - line . p . y ; \ndouble dz = pointOnLine . z - line . p . z ; \ndouble adx = Math . abs ( dx ) ; \ndouble ady = Math . abs ( dy ) ; \ndouble adz = Math . abs ( dz ) ; \ndouble t ; \nif ( adx > ady ) if ( adx > adz ) t = dx / line . slope . x ; \nelse t = dz / line . slope . z ; \nelse if ( ady > adz ) t = dy / line . slope . y ; \nelse t = dz / line . slope . z ; \nreturn t ; \n} \n} \n"}
{"7577": "public class UtilVector2D_F64 { \npublic static boolean identicalSign ( double xa , double ya , double xb , double yb , double tol ) { \ndouble dx0 = xb - xa ; \ndouble dy0 = yb - ya ; \ndouble dx1 = xb + xa ; \ndouble dy1 = yb + ya ; \ndouble error0 = dx0 * dx0 + dy0 * dy0 ; \ndouble error1 = dx1 * dx1 + dy1 * dy1 ; \nif ( error0 < error1 ) return error0 <= tol * tol ; \nelse return error1 <= tol * tol ; \n} \n} \n"}
{"7584": "public class BoxLength3D_F64 { \npublic Point3D_F64 getCorner ( int index , Point3D_F64 corner ) { \nif ( corner == null ) corner = new Point3D_F64 ( ) ; \ncorner . set ( p ) ; \nif ( ( index & 0x01 ) != 0 ) corner . x += lengthX ; \nif ( ( index & 0x02 ) != 0 ) corner . y += lengthY ; \nif ( ( index & 0x04 ) != 0 ) corner . z += lengthZ ; \nreturn corner ; \n} \n} \n"}
{"7585": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { \ndouble x = l0 . p . x - l1 . p . x ; \ndouble y = l0 . p . y - l1 . p . y ; \ndouble z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \ndouble t0 ; \nif ( bottom == 0 ) t0 = 0 ; \nelse t0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \ndouble dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; \ndouble dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; \ndouble dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; \ndouble distanceSq = dx * dx + dy * dy + dz * dz ; \nif ( distanceSq < 0 ) return 0 ; \nelse return Math . sqrt ( distanceSq ) ; \n} \n} \n"}
{"7586": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l , Point3D_F64 p ) { \ndouble x = l . p . x - p . x ; \ndouble y = l . p . y - p . y ; \ndouble z = l . p . z - p . z ; \ndouble cc = x * x + y * y + z * z ; \ndouble b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; \ndouble distanceSq = cc - b * b ; \nif ( distanceSq < 0 ) return 0 ; \nelse return Math . sqrt ( distanceSq ) ; \n} \n} \n"}
{"7587": "public class Distance3D_F64 { \npublic static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { \ndouble dx = p . x - l . a . x ; \ndouble dy = p . y - l . a . y ; \ndouble dz = p . z - l . a . z ; \ndouble cc = dx * dx + dy * dy + dz * dz ; \ndouble slope_x = l . b . x - l . a . x ; \ndouble slope_y = l . b . y - l . a . y ; \ndouble slope_z = l . b . z - l . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( d <= 0 ) return p . distance ( l . a ) ; \nelse if ( d >= n ) return p . distance ( l . b ) ; \ndouble distanceSq = cc - d * d ; \nif ( distanceSq < 0 ) return 0 ; \nelse return Math . sqrt ( distanceSq ) ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \nfor ( int i = offset , idxA = 0 ; \ni < end ; \ni += 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( int j = 0 ; \nj < numCoefs ; \nj ++ ) { \nA . data [ idxA ++ ] = pow ; \npow *= x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) return false ; \nsolver . solve ( b , x ) ; \nfor ( int i = 0 ; \ni < numCoefs ; \ni ++ ) output . set ( i , x . data [ i ] ) ; \nreturn true ; \n} \n} \n"}
{"7604": "public class UtilVector3D_F64 { \npublic static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { \nif ( output == null ) output = new Vector3D_F64 ( ) ; \ndouble scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; \nif ( scale == 0 ) output . set ( 0 , 0 , 0 ) ; \nelse { \ndouble x = A . x / scale ; \ndouble y = A . y / scale ; \ndouble z = A . z / scale ; \nif ( Math . abs ( x ) > Math . abs ( y ) ) output . set ( z , 0 , - x ) ; \nelse output . set ( 0 , z , - y ) ; \n} \nreturn output ; \n} \n} \n"}
{"7607": "public class UtilVector3D_F64 { \npublic static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { \nif ( R == null ) R = new DMatrixRMaj ( 3 , v . length ) ; \nfor ( int i = 0 ; \ni < v . length ; \ni ++ ) { \nR . set ( 0 , i , v [ i ] . x ) ; \nR . set ( 1 , i , v [ i ] . y ) ; \nR . set ( 2 , i , v [ i ] . z ) ; \n} \nreturn R ; \n} \n} \n"}
{"7613": "public class Area2D_F64 { \npublic static double quadrilateral ( Quadrilateral_F64 quad ) { \ndouble bx = quad . b . x - quad . a . x ; \ndouble by = quad . b . y - quad . a . y ; \ndouble cx = quad . c . x - quad . a . x ; \ndouble cy = quad . c . y - quad . a . y ; \ndouble dx = quad . d . x - quad . a . x ; \ndouble dy = quad . d . y - quad . a . y ; \nif ( ( bx * cy - by * cx >= 0 ) == ( cx * dy - cy * dx >= 0 ) ) return triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; \nelse return triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; \n} \n} \n"}
{"7616": "public class UtilPoint2D_F64 { \npublic static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { \nPoint2D_F64 center = mean ( points , null ) ; \ndouble angles [ ] = new double [ points . size ( ) ] ; \nfor ( int i = 0 ; \ni < angles . length ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - center . x ; \ndouble dy = p . y - center . y ; \nangles [ i ] = Math . atan2 ( dy , dx ) ; \n} \nint order [ ] = new int [ points . size ( ) ] ; \nQuickSort_F64 sorter = new QuickSort_F64 ( ) ; \nsorter . sort ( angles , 0 , points . size ( ) , order ) ; \nList < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) out . add ( points . get ( order [ i ] ) ) ; \nreturn out ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) if ( covariance instanceof ReshapeMatrix ) ( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \nelse throw new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7630": "public class InstallFeatureUtil { \n@ SafeVarargs public static Set < String > combineToSet ( Collection < String > ... collections ) { \nSet < String > result = new HashSet < String > ( ) ; \nSet < String > lowercaseSet = new HashSet < String > ( ) ; \nfor ( Collection < String > collection : collections ) { \nif ( collection != null ) for ( String value : collection ) { \nif ( ! lowercaseSet . contains ( value . toLowerCase ( ) ) ) { \nlowercaseSet . add ( value . toLowerCase ( ) ) ; \nresult . add ( value ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7632": "public class InstallFeatureUtil { \nprivate Set < String > getConfigDropinsFeatures ( Set < String > origResult , File serverDirectory , String folderName ) { \nSet < String > result = origResult ; \nFile configDropinsFolder ; \ntry { \nconfigDropinsFolder = new File ( new File ( serverDirectory , \"configDropins\" ) , folderName ) . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The \" + serverDirectory + \"/configDropins/\" + folderName + \" directory cannot be accessed. Skipping its server features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nFile [ ] configDropinsXmls = configDropinsFolder . listFiles ( new FilenameFilter ( ) { \n@ Override public boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".xml\" ) ; \n} \n} \n) ; \nif ( configDropinsXmls == null || configDropinsXmls . length == 0 ) return result ; \nComparator < File > comparator = new Comparator < File > ( ) { \n@ Override public int compare ( File left , File right ) { \nreturn left . getAbsolutePath ( ) . toLowerCase ( ) . compareTo ( right . getAbsolutePath ( ) . toLowerCase ( ) ) ; \n} \n} \n; \nCollections . sort ( Arrays . asList ( configDropinsXmls ) , comparator ) ; \nfor ( File xml : configDropinsXmls ) { \nSet < String > features = getServerXmlFeatures ( result , xml , null ) ; \nif ( features != null ) result = features ; \n} \nreturn result ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) try { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nodes . getLength ( ) ; \ni ++ ) if ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) { \nif ( result == null ) result = new HashSet < String > ( ) ; \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \nelse if ( \"include\" . equals ( child . getNodeName ( ) ) ) result = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nreturn result ; \n} \n} \n"}
{"7634": "public class InstallFeatureUtil { \nprivate Set < String > parseIncludeNode ( Set < String > origResult , File serverFile , Element node , List < File > updatedParsedXmls ) { \nSet < String > result = origResult ; \nString includeFileName = node . getAttribute ( \"location\" ) ; \nif ( includeFileName == null || includeFileName . trim ( ) . isEmpty ( ) ) return result ; \nFile includeFile = null ; \nif ( isURL ( includeFileName ) ) try { \nFile tempFile = File . createTempFile ( \"serverFromURL\" , \".xml\" ) ; \nFileUtils . copyURLToFile ( new URL ( includeFileName ) , tempFile , COPY_FILE_TIMEOUT_MILLIS , COPY_FILE_TIMEOUT_MILLIS ) ; \nincludeFile = tempFile ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" includes a URL \" + includeFileName + \" that cannot be accessed. Skipping the included features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nelse includeFile = new File ( includeFileName ) ; \ntry { \nif ( ! includeFile . isAbsolute ( ) ) includeFile = new File ( serverFile . getParentFile ( ) . getAbsolutePath ( ) , includeFileName ) . getCanonicalFile ( ) ; \nelse includeFile = includeFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" includes a file \" + includeFileName + \" that cannot be accessed. Skipping the included features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nif ( ! updatedParsedXmls . contains ( includeFile ) ) { \nString onConflict = node . getAttribute ( \"onConflict\" ) ; \nSet < String > features = getServerXmlFeatures ( null , includeFile , updatedParsedXmls ) ; \nresult = handleOnConflict ( result , onConflict , features ) ; \n} \nreturn result ; \n} \n} \n"}
{"7635": "public class InstallFeatureUtil { \nprivate static Set < String > parseFeatureManagerNode ( Element node ) { \nSet < String > result = new HashSet < String > ( ) ; \nNodeList features = node . getElementsByTagName ( \"feature\" ) ; \nif ( features != null ) for ( int j = 0 ; \nj < features . getLength ( ) ; \nj ++ ) { \nString content = features . item ( j ) . getTextContent ( ) ; \nif ( content != null ) if ( content . contains ( \":\" ) ) { \nString [ ] split = content . split ( \":\" , 2 ) ; \nresult . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; \n} \nelse result . add ( content . trim ( ) . toLowerCase ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"7637": "public class InstallFeatureUtil { \npublic static Set < String > getOpenLibertyFeatureSet ( Set < File > jsons ) throws PluginExecutionException { \nSet < String > libertyFeatures = new HashSet < String > ( ) ; \nfor ( File file : jsons ) { \nScanner s = null ; \ntry { \ns = new Scanner ( file ) ; \nwhile ( s . findWithinHorizon ( OPEN_LIBERTY_GROUP_ID + \":([^:]*):\" , 0 ) != null ) { \nMatchResult match = s . match ( ) ; \nif ( match . groupCount ( ) >= 1 ) libertyFeatures . add ( match . group ( 1 ) ) ; \n} \n} \ncatch ( FileNotFoundException e ) { \nthrow new PluginExecutionException ( \"The JSON file is not found at \" + file . getAbsolutePath ( ) , e ) ; \n} \nfinally { \nif ( s != null ) s . close ( ) ; \n} \n} \nreturn libertyFeatures ; \n} \n} \n"}
{"7640": "public class InstallFeatureUtil { \npublic static String getNextProductVersion ( String version ) throws PluginExecutionException { \nString result = null ; \nint versionSplittingIndex = version . lastIndexOf ( \".\" ) + 1 ; \nif ( versionSplittingIndex == 0 ) throw new PluginExecutionException ( \"Product version \" + version + \" is not in the expected format. It must have period separated version segments.\" ) ; \nString quarterVersion = version . substring ( versionSplittingIndex ) ; \nint nextQuarterSpecifier ; \ntry { \nnextQuarterSpecifier = Integer . parseInt ( quarterVersion ) + 1 ; \n} \ncatch ( NumberFormatException e ) { \nthrow new PluginExecutionException ( \"Product version \" + version + \" is not in the expected format. Its last segment is expected to be an integer.\" , e ) ; \n} \nresult = version . substring ( 0 , versionSplittingIndex ) + nextQuarterSpecifier ; \nreturn result ; \n} \n} \n"}
{"7641": "public class InstallFeatureUtil { \npublic static String extractSymbolicName ( File jar ) throws PluginExecutionException { \nJarFile jarFile = null ; \ntry { \njarFile = new JarFile ( jar ) ; \nreturn jarFile . getManifest ( ) . getMainAttributes ( ) . getValue ( \"Bundle-SymbolicName\" ) ; \n} \ncatch ( IOException e ) { \nthrow new PluginExecutionException ( \"Could not load the jar \" + jar . getAbsolutePath ( ) , e ) ; \n} \nfinally { \nif ( jarFile != null ) try { \njarFile . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n"}
{"7642": "public class InstallFeatureUtil { \npublic static File getMapBasedInstallKernelJar ( File dir ) { \nFile [ ] installMapJars = dir . listFiles ( new FilenameFilter ( ) { \n@ Override public boolean accept ( File dir , String name ) { \nreturn name . startsWith ( INSTALL_MAP_PREFIX ) && name . endsWith ( INSTALL_MAP_SUFFIX ) ; \n} \n} \n) ; \nFile result = null ; \nif ( installMapJars != null ) for ( File jar : installMapJars ) { \nif ( isReplacementJar ( result , jar ) ) result = jar ; \n} \nreturn result ; \n} \n} \n"}
{"7643": "public class InstallFeatureUtil { \nprivate static boolean isReplacementJar ( File file1 , File file2 ) { \nif ( file1 == null ) return true ; \nelse if ( file2 == null ) return false ; \nelse { \nString version1 = extractVersion ( file1 . getName ( ) ) ; \nString version2 = extractVersion ( file2 . getName ( ) ) ; \nreturn compare ( version1 , version2 ) < 0 ; \n} \n} \n} \n"}
{"7644": "public class InstallFeatureUtil { \nprivate static String extractVersion ( String fileName ) { \nint startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; \nint endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; \nif ( startIndex < endIndex ) return fileName . substring ( startIndex , endIndex ) ; \nelse return null ; \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) return 0 ; \nelse if ( version1 == null && version2 != null ) return - 1 ; \nelse if ( version1 != null && version2 == null ) return 1 ; \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ni < components1 . length && i < components2 . length ; \ni ++ ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) return comparison ; \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7646": "public class InstallFeatureUtil { \npublic static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { \nProcess pr = null ; \nInputStream is = null ; \nScanner s = null ; \nWorker worker = null ; \ntry { \nString command ; \nif ( OSUtil . isWindows ( ) ) command = installDirectory + \"\\\\bin\\\\productInfo.bat \" + action ; \nelse command = installDirectory + \"/bin/productInfo \" + action ; \npr = Runtime . getRuntime ( ) . exec ( command ) ; \nworker = new Worker ( pr ) ; \nworker . start ( ) ; \nworker . join ( 300000 ) ; \nif ( worker . exit == null ) throw new PluginExecutionException ( \"productInfo command timed out\" ) ; \nint exitValue = pr . exitValue ( ) ; \nif ( exitValue != 0 ) throw new PluginExecutionException ( \"productInfo exited with return code \" + exitValue ) ; \nis = pr . getInputStream ( ) ; \ns = new Scanner ( is ) ; \ns . useDelimiter ( \"\\\\A\" ) ; \nif ( s . hasNext ( ) ) return s . next ( ) ; \nreturn null ; \n} \ncatch ( IOException ex ) { \nthrow new PluginExecutionException ( \"productInfo error: \" + ex ) ; \n} \ncatch ( InterruptedException ex ) { \nworker . interrupt ( ) ; \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new PluginExecutionException ( \"productInfo error: \" + ex ) ; \n} \nfinally { \nif ( s != null ) s . close ( ) ; \nif ( is != null ) try { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( pr != null ) pr . destroy ( ) ; \n} \n} \n} \n"}
{"7647": "public class SpringBootUtil { \npublic static boolean isSpringBootUberJar ( File artifact ) { \nif ( artifact == null || ! artifact . exists ( ) || ! artifact . isFile ( ) ) return false ; \ntry ( JarFile jarFile = new JarFile ( artifact ) ) { \nManifest manifest = jarFile . getManifest ( ) ; \nif ( manifest != null ) { \nAttributes attributes = manifest . getMainAttributes ( ) ; \nif ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null && attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) return true ; \nelse { \nEnumeration < JarEntry > entries = jarFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nJarEntry entry = entries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( ! entryName . startsWith ( \"org\" ) && ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) ) return true ; \n} \n} \n} \n} \ncatch ( IOException e ) { \n} \nreturn false ; \n} \n} \n"}
{"7648": "public class LibertyProperty { \nprivate static LibertyPropertyI getArquillianProperty ( String key , Class < ? > cls ) throws ArquillianConfigurationException { \ntry { \nif ( cls == LibertyManagedObject . LibertyManagedProperty . class ) return LibertyManagedObject . LibertyManagedProperty . valueOf ( key ) ; \nelse if ( cls == LibertyRemoteObject . LibertyRemoteProperty . class ) return LibertyRemoteObject . LibertyRemoteProperty . valueOf ( key ) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new ArquillianConfigurationException ( \"Property \\\"\" + key + \"\\\" in arquillianProperties does not exist. You probably have a typo.\" ) ; \n} \nthrow new ArquillianConfigurationException ( \"This should never happen.\" ) ; \n} \n} \n"}
{"7656": "public class Puzzle { \npublic int getDistanceToGoal ( ) { \nint distance = 0 ; \nfor ( int i = 0 ; \ni < cells . length ; \ni ++ ) distance += getDistance ( i , cells [ i ] ) ; \nreturn distance ; \n} \n} \n"}
{"7660": "public class MySystem { \npublic synchronized static void variable ( String name , Object value ) { \nif ( ! variable ) return ; \nSystem . out . println ( timeStamp ( ) + \"*=> \" + name + \" = '\" + ( value == null ? null : value . toString ( ) ) + \"'\" ) ; \n} \n} \n"}
{"7668": "public class FileAssetServlet { \nprivate String fixPath ( String path ) { \nif ( ! path . isEmpty ( ) ) if ( ! path . endsWith ( \"/\" ) ) return path + '/' ; \nelse return path ; \nelse return path ; \n} \n} \n"}
{"7669": "public class HqlUtil { \npublic static String joinToString ( CriteriaJoin criteriaJoin ) { \nStringBuilder builder = new StringBuilder ( \"LEFT OUTER JOIN \" ) . append ( criteriaJoin . getEntityClass ( ) . getName ( ) ) . append ( \" \" ) . append ( criteriaJoin . getAlias ( ) ) . append ( \" \" ) . append ( \" ON \" ) ; \nif ( criteriaJoin . getJoinRelations ( ) . size ( ) == 0 ) throw new RuntimeException ( \"Not found any Join Relations in \" + criteriaJoin . getAlias ( ) + \" Join Criteria ! \" ) ; \nStringJoiner joiner = new StringJoiner ( \" AND \" ) ; \nList < JoinRelation > relationList = criteriaJoin . getJoinRelations ( ) ; \nfor ( JoinRelation joinRelation : relationList ) { \nStringBuilder relationBuilder = new StringBuilder ( \"\\n\" ) . append ( joinRelation . getRelationCriteria ( ) . getAlias ( ) ) . append ( \".\" ) . append ( joinRelation . getRelationField ( ) ) . append ( \"=\" ) . append ( joinRelation . getJoinedCriteria ( ) . getAlias ( ) ) . append ( \".\" ) . append ( joinRelation . getJoinedField ( ) ) ; \njoiner . add ( relationBuilder . toString ( ) ) ; \n} \nif ( joiner . length ( ) > 0 ) builder . append ( joiner . toString ( ) ) ; \nreturn builder . toString ( ) ; \n} \n} \n"}
{"7671": "public class TokenBasedAuthResponseFilter { \n@ Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { \nString authToken = extractAuthTokenFromCookieList ( requestContext . getHeaders ( ) . getFirst ( \"Cookie\" ) ) ; \nif ( authToken != null && authToken . length ( ) != 0 ) try { \nBasicToken token = new BasicToken ( authToken ) ; \nif ( token . isExpired ( ) ) { \nLOGGER . debug ( \"ExpireDate : \" + token . getExpirationDate ( ) . toString ( ) ) ; \nLOGGER . debug ( \"Now: \" + DateTime . now ( ) . toDate ( ) . toString ( ) ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , getTokenSentence ( null ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \nresponseContext . setEntity ( \"Token expired. Please login again.\" ) ; \nLOGGER . info ( \"Token expired. Please login again.\" ) ; \n} \nelse { \ntoken . setExpiration ( token . getMaxAge ( ) ) ; \nif ( ! logoutPath . equals ( requestContext . getUriInfo ( ) . getPath ( ) ) ) { \nString cookie = getTokenSentence ( token ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , cookie ) ; \n} \n} \n} \ncatch ( Exception e ) { \nLOGGER . error ( \"Token re-creation failed\" , e . getMessage ( ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \n} \n} \n} \n"}
{"7672": "public class TokenBasedAuthResponseFilter { \nprivate String extractAuthTokenFromCookieList ( String cookieList ) { \nif ( cookieList == null || cookieList . length ( ) == 0 ) return null ; \nString [ ] cookies = cookieList . split ( \";\" ) ; \nfor ( String cookie : cookies ) { \nif ( cookie . trim ( ) . startsWith ( tokenKey ) ) return cookie . trim ( ) . substring ( tokenKey . length ( ) + 1 ) ; \n} \nreturn null ; \n} \n} \n"}
{"7673": "public class JerseyUtil { \npublic static void registerGuiceBound ( Injector injector , final JerseyEnvironment environment ) { \nwhile ( injector != null ) { \nfor ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { \nType type = key . getTypeLiteral ( ) . getType ( ) ; \nif ( type instanceof Class ) { \nClass < ? > c = ( Class ) type ; \nif ( isProviderClass ( c ) ) { \nlogger . info ( \"Registering {} as a provider class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse if ( isRootResourceClass ( c ) ) if ( Resource . isAcceptable ( c ) ) { \nlogger . info ( \"Registering {} as a root resource class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse logger . warn ( \"Class {} was not registered as a resource. Bind a concrete implementation instead.\" , c . getName ( ) ) ; \n} \n} \ninjector = injector . getParent ( ) ; \n} \n} \n} \n"}
{"7685": "public class RobeExceptionMapper { \n@ Override public Response toResponse ( Exception e ) { \nString id = System . nanoTime ( ) + \"\" ; \nLOGGER . error ( id , e ) ; \nif ( e instanceof RobeRuntimeException ) return ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; \nelse if ( e instanceof ConstraintViolationException ) { \nConstraintViolationException exception = ( ConstraintViolationException ) e ; \nRobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; \nint i = 0 ; \nfor ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { \nerrors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; \n} \nreturn Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse if ( e instanceof WebApplicationException ) { \nWebApplicationException we = ( WebApplicationException ) e ; \nRobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; \nreturn Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nif ( e . getClass ( ) . getName ( ) . equals ( \"org.hibernate.exception.ConstraintViolationException\" ) ) if ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( \"for\" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \n} \n"}
{"7686": "public class BasicToken { \npublic static void configure ( TokenBasedAuthConfiguration configuration ) { \nencryptor . setPoolSize ( configuration . getPoolSize ( ) ) ; \nif ( configuration . getServerPassword ( ) . equals ( \"auto\" ) ) encryptor . setPassword ( UUID . randomUUID ( ) . toString ( ) ) ; \nelse encryptor . setPassword ( configuration . getServerPassword ( ) ) ; \nencryptor . setAlgorithm ( configuration . getAlgorithm ( ) ) ; \nencryptor . initialize ( ) ; \nBasicToken . defaultMaxAge = configuration . getMaxage ( ) ; \ncache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( defaultMaxAge , TimeUnit . SECONDS ) . expireAfterWrite ( defaultMaxAge , TimeUnit . SECONDS ) . build ( ) ; \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) item . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \nfor ( int i = 0 ; \ni < item . getReceivers ( ) . size ( ) ; \ni ++ ) to [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) for ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) entry . setValue ( value ) ; \n} \n} \n} \n"}
{"7691": "public class AbstractAuthResource { \npublic void changePassword ( T user , String currentPassword , String newPassword , String newPassword2 ) throws AuthenticationException { \nverifyPassword ( user , currentPassword ) ; \nif ( ! newPassword . equals ( newPassword2 ) ) throw new AuthenticationException ( user . getUsername ( ) + \": New password and re-type password must be same\" ) ; \nelse if ( newPassword . equals ( currentPassword ) ) throw new AuthenticationException ( user . getUsername ( ) + \": New password and old password must be different\" ) ; \nverifyPasswordStrength ( currentPassword , newPassword , user ) ; \nOptional < ? extends UserEntry > optional = userStore . changePassword ( user . getUsername ( ) , newPassword ) ; \nif ( ! optional . isPresent ( ) ) throw new AuthenticationException ( user . getUsername ( ) + \": Can't update UserEntry Password\" ) ; \n} \n} \n"}
{"7692": "public class AbstractAuthResource { \npublic T getUser ( String accountName ) { \nOptional < T > optional = ( Optional < T > ) userStore . findByUsername ( accountName ) ; \nif ( optional . isPresent ( ) ) return optional . get ( ) ; \nelse return null ; \n} \n} \n"}
{"7694": "public class AbstractAuthResource { \npublic void verifyAccountNameStrength ( String accountName ) throws AuthenticationException { \nMatcher matcher = PATTERN . matcher ( accountName ) ; \nif ( ! matcher . matches ( ) ) throw new AuthenticationException ( accountName + \" is not a valid email\" ) ; \n} \n} \n"}
{"7696": "public class SearchFactory { \n@ Override public SearchModel provide ( ) { \nSearchModel searchModel = new SearchModel ( ) ; \nsearchModel . setResponse ( response ) ; \nString method = getMethod ( ) ; \nif ( \"GET\" . equals ( method ) ) { \nMultivaluedMap < String , String > queryParameters = getUriInfo ( ) . getQueryParameters ( ) ; \nfor ( Map . Entry < String , List < String > > param : queryParameters . entrySet ( ) ) { \nif ( param . getValue ( ) . get ( 0 ) == null ) continue ; \nif ( \"_q\" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setQ ( param . getValue ( ) . get ( 0 ) ) ; \nelse if ( \"_limit\" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setLimit ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \nelse if ( \"_offset\" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setOffset ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \nelse if ( \"_fields\" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setFields ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \nelse if ( \"_sort\" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setSort ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \nelse if ( \"_filter\" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setFilterExpression ( param . getValue ( ) . get ( 0 ) ) ; \n} \n} \nreturn searchModel ; \n} \n} \n"}
{"7697": "public class Transaction { \nprivate void success ( ) { \norg . hibernate . Transaction txn = session . getTransaction ( ) ; \nif ( txn != null && txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) txn . commit ( ) ; \n} \n} \n"}
{"7698": "public class Transaction { \nprivate void error ( ) { \norg . hibernate . Transaction txn = session . getTransaction ( ) ; \nif ( txn != null && txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) txn . rollback ( ) ; \n} \n} \n"}
{"7699": "public class Transaction { \nprivate void start ( ) { \ntry { \nbefore ( ) ; \ntransactionWrapper . wrap ( ) ; \nsuccess ( ) ; \n} \ncatch ( Exception e ) { \nerror ( ) ; \nif ( exceptionHandler != null ) exceptionHandler . onException ( e ) ; \nelse throw e ; \n} \nfinally { \nfinish ( ) ; \n} \n} \n} \n"}
{"7700": "public class Query { \npublic static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { \nif ( Validations . isEmptyOrNull ( name ) ) return null ; \nString [ ] names = name . split ( \"\\\\.\" ) ; \nString currentName ; \nint step = 0 ; \nCriteriaParent < E > currentCriteria = criteria ; \nFieldMeta currentFieldMeta ; \nStringJoiner aliasJoiner = new StringJoiner ( \"$\" ) ; \ndo { \ncurrentName = names [ step ] ; \nif ( Validations . isEmptyOrNull ( currentName ) ) throw new RuntimeException ( currentName + \" defined name is wrong ! \" ) ; \ncurrentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; \nstep ++ ; \naliasJoiner . add ( currentCriteria . getAlias ( ) ) ; \nif ( step >= names . length ) break ; \nif ( currentFieldMeta . getReference ( ) == null ) throw new RuntimeException ( \"\" + currentName + \" join field of \" + name + \"'s reference target information must defined ! \" ) ; \nCriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; \nif ( criteriaJoin == null ) currentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; \ncurrentCriteria = criteriaJoin ; \n} \nwhile ( step >= names . length ) ; \nHolder < E > holder = new Holder < > ( ) ; \nholder . currentFieldName = currentName ; \nholder . currentCriteria = currentCriteria ; \nholder . currentFieldMeta = currentFieldMeta ; \nreturn holder ; \n} \n} \n"}
{"7702": "public class ParseDate { \n@ Override public Date parse ( Object o , Field field ) { \nif ( ! isValid ( o ) ) return null ; \nJsonFormat formatAnn = field . getAnnotation ( JsonFormat . class ) ; \nif ( formatAnn == null ) throw new RuntimeException ( \"JsonFormat with pattern needed for: \" + field . getName ( ) ) ; \ntry { \nreturn new SimpleDateFormat ( formatAnn . pattern ( ) , Locale . getDefault ( ) ) . parse ( o . toString ( ) ) ; \n} \ncatch ( ParseException e ) { \nthrow new RuntimeException ( \"JsonFormat with pattern is wrong for: \" + field . getName ( ) + \" pattern: \" + formatAnn . pattern ( ) ) ; \n} \n} \n} \n"}
{"7712": "public class NamespaceManager { \npublic NamespaceManager withNamespace ( String namespace , String href ) { \nif ( namespaces . containsKey ( namespace ) ) throw new RepresentationException ( format ( \"Duplicate namespace '%s' found for representation factory\" , namespace ) ) ; \nif ( ! href . contains ( \"{rel}\" ) ) throw new RepresentationException ( format ( \"Namespace '%s' does not include {rel} URI template argument.\" , namespace ) ) ; \nreturn new NamespaceManager ( namespaces . put ( namespace , href ) ) ; \n} \n} \n"}
{"7714": "public class ResourceRepresentation { \npublic ResourceRepresentation < V > withRel ( Rel rel ) { \nif ( rels . containsKey ( rel . rel ( ) ) ) throw new IllegalStateException ( String . format ( \"Rel %s is already declared.\" , rel . rel ( ) ) ) ; \nfinal TreeMap < String , Rel > updatedRels = rels . put ( rel . rel ( ) , rel ) ; \nreturn new ResourceRepresentation < > ( content , links , updatedRels , namespaceManager , value , resources ) ; \n} \n} \n"}
{"7716": "public class ResourceRepresentation { \npublic ResourceRepresentation < V > withNamespace ( String namespace , String href ) { \nif ( ! rels . containsKey ( \"curies\" ) ) rels = rels . put ( \"curies\" , Rels . collection ( \"curies\" ) ) ; \nfinal NamespaceManager updatedNamespaceManager = namespaceManager . withNamespace ( namespace , href ) ; \nreturn new ResourceRepresentation < > ( content , links , rels , updatedNamespaceManager , value , resources ) ; \n} \n} \n"}
{"7719": "public class CharStreams { \npublic static boolean equal ( Reader in1 , Reader in2 ) throws IOException { \nif ( in1 == in2 ) return true ; \nif ( in1 == null || in2 == null ) return false ; \nin1 = buffer ( in1 ) ; \nin2 = buffer ( in2 ) ; \nint c1 = in1 . read ( ) ; \nint c2 = in2 . read ( ) ; \nwhile ( c1 != - 1 && c2 != - 1 && c1 == c2 ) { \nc1 = in1 . read ( ) ; \nc2 = in2 . read ( ) ; \n} \nreturn in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; \n} \n} \n"}
{"7721": "public class XFiles { \npublic static void touch ( File ... files ) throws IOException { \nlong now = System . currentTimeMillis ( ) ; \nfor ( File f : files ) { \nif ( ! f . createNewFile ( ) && ! f . setLastModified ( now ) ) throw new IOException ( \"Failed to touch \" + f ) ; \n} \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nint len = BLOCK_LENGTH - bufferLen ; \nif ( len < 9 ) len += BLOCK_LENGTH ; \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \nfor ( int i = 1 ; \ni < len - 8 ; \ni ++ ) buf [ i ] = ( byte ) 0x00 ; \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \n} \n} \n"}
{"7724": "public class Classes { \npublic static String getShortName ( Class < ? > c ) { \nString qname = getQualifiedName ( c ) ; \nint start = qname . lastIndexOf ( '$' ) ; \nif ( start == - 1 ) start = qname . lastIndexOf ( '.' ) ; \nreturn qname . substring ( start + 1 ) ; \n} \n} \n"}
{"7726": "public class Passwords { \npublic static boolean verify ( String password , byte [ ] hash ) { \nbyte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; \nint n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; \nint r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; \nint p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; \nif ( n > N || n < N_MIN || r > R || r < R_MIN || p > P || p < P_MIN ) { \nn = N ; \nr = R ; \np = P ; \n} \nbyte [ ] salt = new byte [ SALT_LENGTH ] ; \nSystem . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; \nbyte [ ] expected = hash ( password , salt , r , n , p ) ; \nint result = 0 ; \nfor ( int i = 0 ; \ni < h . length ; \ni ++ ) result |= h [ i ] ^ expected [ i ] ; \nreturn result == 0 ; \n} \n} \n"}
{"7734": "public class Fraction { \npublic Fraction dividedBy ( Fraction f ) { \nif ( ZERO . equals ( f ) ) throw new ArithmeticException ( \"Division by zero\" ) ; \nreturn new Fraction ( n . multiply ( f . d ) , d . multiply ( f . n ) ) . reduced ( ) ; \n} \n} \n"}
{"7735": "public class Numbers { \npublic static long max ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong max = values [ 0 ] ; \nfor ( int i = 1 ; \ni < values . length ; \ni ++ ) max = Math . max ( max , values [ i ] ) ; \nreturn max ; \n} \n} \n"}
{"7736": "public class Numbers { \npublic static long min ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong min = values [ 0 ] ; \nfor ( int i = 1 ; \ni < values . length ; \ni ++ ) min = Math . min ( min , values [ i ] ) ; \nreturn min ; \n} \n} \n"}
{"7737": "public class Parameters { \npublic static void checkCondition ( boolean condition , String msg , Object ... args ) { \nif ( ! condition ) throw new IllegalArgumentException ( format ( msg , args ) ) ; \n} \n} \n"}
{"7742": "public class LocationForecastHelper { \npublic Optional < MeteoExtrasForecast > findNearestForecast ( ZonedDateTime dateTime ) { \nZonedDateTime dt = toZeroMSN ( dateTime . withZoneSameInstant ( METZONE ) ) ; \nPointForecast chosenForecast = null ; \nfor ( Forecast forecast : getLocationForecast ( ) . getForecasts ( ) ) { \nif ( forecast instanceof PointForecast ) { \nPointForecast pointForecast = ( PointForecast ) forecast ; \nif ( isDateMatch ( dt , cloneZonedDateTime ( pointForecast . getFrom ( ) ) ) ) { \nchosenForecast = pointForecast ; \nbreak ; \n} \nelse if ( chosenForecast == null ) chosenForecast = pointForecast ; \nelse if ( isNearerDate ( pointForecast . getFrom ( ) , dt , chosenForecast . getFrom ( ) ) ) chosenForecast = pointForecast ; \n} \n} \nif ( chosenForecast == null ) return Optional . empty ( ) ; \nreturn Optional . of ( new MeteoExtrasForecast ( chosenForecast , getIndexer ( ) . getWidestFitPeriodForecast ( chosenForecast . getFrom ( ) ) . orElse ( null ) ) ) ; \n} \n} \n"}
{"7744": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = getNow ( ) ; \nfor ( int i = 0 ; \ni <= 6 ; \ni ++ ) { \nZonedDateTime dti = dt . plusDays ( i ) ; \nif ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { \nMeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; \nif ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) forecastDays . add ( mefd ) ; \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7745": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createLongTermForecast ( ) { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; \nfor ( int i = 0 ; \ni < series . getSeries ( ) . size ( ) ; \ni ++ ) createLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7746": "public class Location { \npublic static Location fromCoordinates ( String coordinates ) { \nif ( coordinates == null ) throw new IllegalArgumentException ( \"Cannot create Location from null input.\" ) ; \nMatcher m = P . matcher ( coordinates ) ; \nif ( ! m . matches ( ) ) throw new IllegalArgumentException ( coordinates + \" must be on the pattern (longitude,latitude,altitude) : \" + P . pattern ( ) ) ; \ntry { \nDouble longitude = Double . valueOf ( m . group ( 1 ) ) ; \nDouble latitude = Double . valueOf ( m . group ( 2 ) ) ; \nInteger altitude = 0 ; \nif ( m . group ( 3 ) != null ) altitude = Integer . valueOf ( m . group ( 3 ) . substring ( 1 ) ) ; \nreturn new Location ( longitude , latitude , altitude , \"\" ) ; \n} \ncatch ( NumberFormatException e ) { \nthrow new IllegalArgumentException ( coordinates + \" must be on the pattern (longitude,latitude,altitude) : \" + P . pattern ( ) ) ; \n} \n} \n} \n"}
{"7748": "public class WindSymbolHelper { \npublic static Optional < String > createWindSymbolName ( PointForecast pointForecast ) { \nif ( pointForecast == null || pointForecast . getWindDirection ( ) == null || pointForecast . getWindSpeed ( ) == null ) return Optional . empty ( ) ; \nreturn Optional . of ( pointForecast . getWindDirection ( ) . getName ( ) . toLowerCase ( ) + idFormat . format ( pointForecast . getWindSpeed ( ) . getBeaufort ( ) ) ) ; \n} \n} \n"}
{"7749": "public class WindSymbolHelper { \npublic static Optional < BeaufortLevel > findBeaufortLevel ( PointForecast pointForecast ) { \nif ( pointForecast == null || pointForecast . getWindSpeed ( ) == null ) return Optional . empty ( ) ; \nreturn Optional . ofNullable ( findUnitById ( pointForecast . getWindSpeed ( ) . getBeaufort ( ) ) ) ; \n} \n} \n"}
{"7750": "public class MeteoNetUtils { \npublic static URI createUri ( String uri ) throws MeteoException { \nif ( uri == null ) throw new MeteoException ( \"URI is null\" ) ; \ntry { \nreturn new URI ( uri ) ; \n} \ncatch ( URISyntaxException e ) { \nthrow new MeteoException ( e ) ; \n} \n} \n} \n"}
{"7751": "public class SunriseDate { \npublic boolean isSun ( ZonedDateTime currentDate ) { \nif ( getSun ( ) . getNeverRise ( ) ) return false ; \nelse if ( getSun ( ) . getNeverSet ( ) ) return true ; \nreturn timeWithinPeriod ( currentDate ) ; \n} \n} \n"}
{"7752": "public class MeteoForecastIndexer { \nOptional < PointForecast > getPointForecast ( ZonedDateTime dateTime ) { \nfor ( Forecast forecast : forecasts ) { \nif ( forecast instanceof PointForecast ) { \nPointForecast pointForecast = ( PointForecast ) forecast ; \nif ( createHourIndexKey ( dateTime ) . equals ( createHourIndexKey ( cloneZonedDateTime ( pointForecast . getFrom ( ) ) ) ) ) return Optional . of ( pointForecast ) ; \n} \n} \nreturn Optional . empty ( ) ; \n} \n} \n"}
{"7753": "public class MeteoForecastIndexer { \nOptional < PeriodForecast > getBestFitPeriodForecast ( ZonedDateTime from , ZonedDateTime to ) { \nif ( from == null || to == null ) return Optional . empty ( ) ; \nZonedDateTime requestFrom = toZeroMSN ( from ) ; \nZonedDateTime requestTo = toZeroMSN ( to ) ; \nList < PeriodForecast > forecastsList = dayIndex . get ( new DayIndexKey ( requestFrom ) ) ; \nif ( forecastsList == null ) return Optional . empty ( ) ; \nPeriodForecast chosenForecast = null ; \nlong score = 0 ; \nlong tmpScore = 0 ; \nfor ( PeriodForecast forecast : forecastsList ) { \nZonedDateTime actualFrom = cloneZonedDateTime ( forecast . getFrom ( ) ) ; \nZonedDateTime actualTo = cloneZonedDateTime ( forecast . getTo ( ) ) ; \nif ( requestFrom . equals ( actualFrom ) && requestTo . equals ( actualTo ) ) return Optional . of ( forecast ) ; \nelse if ( ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualFrom ) ) || ( requestFrom . isAfter ( actualTo ) && requestTo . isAfter ( actualTo ) ) || actualTo . isEqual ( actualFrom ) ) continue ; \nelse if ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualTo ) ) tmpScore = hoursBetween ( requestTo , actualFrom ) ; \nelse if ( ( actualFrom . isBefore ( requestFrom ) || actualFrom . isEqual ( requestFrom ) ) && actualTo . isBefore ( requestTo ) ) tmpScore = hoursBetween ( actualTo , requestFrom ) ; \nelse if ( actualFrom . isAfter ( requestFrom ) && ( actualTo . isBefore ( requestTo ) || actualTo . isEqual ( requestTo ) ) ) tmpScore = hoursBetween ( actualTo , actualFrom ) ; \nelse if ( actualFrom . isBefore ( requestFrom ) && actualTo . isAfter ( requestTo ) ) tmpScore = hoursBetween ( requestTo , requestFrom ) ; \nelse { \nDateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"yyyy-MM-dd:HH:mm\" ) ; \nlog . warn ( \"Unhandled forecast Requested period:\" + requestFrom . format ( formatter ) + \"--\" + requestTo . format ( formatter ) + \", Actual period: \" + actualFrom . format ( formatter ) + \"--\" + actualTo . format ( formatter ) ) ; \n} \ntmpScore = Math . abs ( tmpScore ) ; \nif ( ( score == 0 && tmpScore > 0 ) || tmpScore > score ) { \nscore = tmpScore ; \nchosenForecast = forecast ; \n} \n} \nreturn Optional . ofNullable ( chosenForecast ) ; \n} \n} \n"}
{"7756": "public class Application { \nprivate void updateDB ( ) throws SQLException , LiquibaseException { \nSystem . out . println ( \"About to perform DB update.\" ) ; \ntry ( BasicDataSource dataSource = new BasicDataSource ( ) ) { \ndataSource . setUrl ( fullConnectionString ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \ntry ( java . sql . Connection c = dataSource . getConnection ( ) ) { \nDatabase database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; \nLiquibase liquibase = null ; \nClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; \ntry { \nif ( accessor . getResourcesAsStream ( \"changelog-master.xml\" ) != null ) liquibase = new Liquibase ( \"changelog-master.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \nelse if ( accessor . getResourcesAsStream ( \"changelog.xml\" ) != null ) liquibase = new Liquibase ( \"changelog.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \nelse { \nString errorMessage = \"No liquibase changelog-master.xml or changelog.xml could be located\" ; \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; \nthrow new RuntimeException ( errorMessage ) ; \n} \n} \ncatch ( final IOException ioe ) { \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; \n} \nliquibase . getLog ( ) . setLogLevel ( logLevel ) ; \nliquibase . update ( new Contexts ( ) ) ; \nSystem . out . println ( \"DB update finished.\" ) ; \n} \n} \n} \n} \n"}
{"7758": "public class ReferencedObject { \npublic synchronized T acquire ( final DataSource source ) throws DataSourceException { \nif ( object == null ) if ( getReference ( ) == null ) throw new IllegalStateException ( \"No reference or object present\" ) ; \nelse object = source . getObject ( getReference ( ) , objectClass ) ; \nreturn object ; \n} \n} \n"}
{"7761": "public class CafConfigurationSource { \nprivate < T > T getConfig ( final Class < T > configClass ) throws ConfigurationException { \nIterator < Name > it = getServicePath ( ) . descendingPathIterator ( ) ; \nwhile ( it . hasNext ( ) ) try ( InputStream in = getConfigurationStream ( configClass , it . next ( ) ) ) { \nreturn decoder . deserialise ( in , configClass ) ; \n} \ncatch ( final ConfigurationException e ) { \nLOG . trace ( \"No configuration at this path level\" , e ) ; \n} \ncatch ( final CodecException | IOException e ) { \nincrementErrors ( ) ; \nthrow new ConfigurationException ( \"Failed to get configuration for \" + configClass . getSimpleName ( ) , e ) ; \n} \nincrementErrors ( ) ; \nthrow new ConfigurationException ( \"No configuration found for \" + configClass . getSimpleName ( ) ) ; \n} \n} \n"}
{"7762": "public class CafConfigurationSource { \nprivate static boolean getIsSubstitutorEnabled ( final BootstrapConfiguration bootstrapConfig ) { \nfinal String ENABLE_SUBSTITUTOR_CONFIG_KEY = \"CAF_CONFIG_ENABLE_SUBSTITUTOR\" ; \nfinal boolean ENABLE_SUBSTITUTOR_CONFIG_DEFAULT = true ; \nif ( ! bootstrapConfig . isConfigurationPresent ( ENABLE_SUBSTITUTOR_CONFIG_KEY ) ) return ENABLE_SUBSTITUTOR_CONFIG_DEFAULT ; \ntry { \nreturn bootstrapConfig . getConfigurationBoolean ( ENABLE_SUBSTITUTOR_CONFIG_KEY ) ; \n} \ncatch ( final ConfigurationException ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"7764": "public class CafConfigurationDecoderProvider { \n@ Override public Decoder getDecoder ( final BootstrapConfiguration bootstrap , final Decoder defaultDecoder ) { \nfinal String DECODER_CONFIG_KEY = \"CAF_CONFIG_DECODER\" ; \nfinal String decoder ; \ntry { \nif ( ! bootstrap . isConfigurationPresent ( DECODER_CONFIG_KEY ) ) return defaultDecoder ; \ndecoder = bootstrap . getConfiguration ( DECODER_CONFIG_KEY ) ; \n} \ncatch ( final ConfigurationException ex ) { \nthrow new RuntimeException ( ex ) ; \n} \ntry { \nreturn ModuleProvider . getInstance ( ) . getModule ( Decoder . class , decoder ) ; \n} \ncatch ( final NullPointerException ex ) { \nthrow new RuntimeException ( \"Unable to get Decoder using \" + DECODER_CONFIG_KEY + \" value: \" + decoder , ex ) ; \n} \n} \n} \n"}
{"7767": "public class ReferencedData { \npublic synchronized InputStream acquire ( final DataSource source ) throws DataSourceException { \nInputStream ret ; \nif ( data == null ) if ( getReference ( ) == null ) throw new IllegalStateException ( \"No data or reference present\" ) ; \nelse ret = source . getStream ( getReference ( ) ) ; \nelse ret = new ByteArrayInputStream ( data ) ; \nreturn ret ; \n} \n} \n"}
{"7768": "public class ReferencedData { \npublic synchronized long size ( final DataSource source ) throws DataSourceException { \nif ( data == null ) if ( getReference ( ) == null ) throw new IllegalStateException ( \"No data or reference present\" ) ; \nelse return source . getDataSize ( getReference ( ) ) ; \nelse return data . length ; \n} \n} \n"}
{"7770": "public class Name { \npublic String getIndex ( final int index ) { \nif ( index < 0 || index >= components . size ( ) ) throw new IllegalArgumentException ( \"Index out of bounds\" ) ; \nreturn components . get ( index ) ; \n} \n} \n"}
{"7771": "public class Name { \npublic Name getPrefix ( final int upperIndex ) { \nif ( upperIndex < 0 || upperIndex > components . size ( ) ) throw new IllegalArgumentException ( \"Index out of bounds\" ) ; \nreturn new Name ( components . subList ( 0 , upperIndex ) ) ; \n} \n} \n"}
{"7773": "public class Runtime { \nboolean exec ( HsrePattern re , CharSequence data , EnumSet < ExecFlags > execFlags ) throws RegexException { \nif ( 0 != ( re . guts . info & Flags . REG_UIMPOSSIBLE ) ) throw new RegexException ( \"Regex marked impossible\" ) ; \neflags = 0 ; \nfor ( ExecFlags ef : execFlags ) { \nswitch ( ef ) { \ncase NOTBOL : eflags |= Flags . REG_NOTBOL ; \nbreak ; \ncase NOTEOL : eflags |= Flags . REG_NOTEOL ; \nbreak ; \ncase LOOKING_AT : eflags |= Flags . REG_LOOKING_AT ; \nbreak ; \ndefault : throw new RuntimeException ( \"impossible exec flag\" ) ; \n} \n} \nthis . re = re ; \nthis . g = re . guts ; \nthis . data = data ; \nthis . dataLength = this . data . length ( ) ; \nif ( this . match != null ) this . match . clear ( ) ; \nelse this . match = Lists . newArrayList ( ) ; \nmatch . add ( null ) ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) while ( match . size ( ) < g . nsub + 1 ) match . add ( null ) ; \nif ( mem != null && mem . length >= g . ntree ) Arrays . fill ( mem , 0 ) ; \nelse mem = new int [ g . ntree ] ; \nassert g . tree != null ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) return cfind ( g . tree . machine ) ; \nelse return find ( g . tree . machine ) ; \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) break ; \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nbegin <= close ; \nbegin ++ ) { \nif ( begin > 0 && lookingAt ) return false ; \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( shorter ) end = d . shortest ( begin , estart , estop , null , hitend ) ; \nelse end = d . longest ( begin , estop , hitend ) ; \nif ( hitend [ 0 ] && cold == - 1 ) cold = begin ; \nif ( end == - 1 ) break ; \nfor ( int x = 0 ; \nx < match . size ( ) ; \nx ++ ) match . set ( x , null ) ; \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( shorter ) estart = end + 1 ; \nelse estop = end - 1 ; \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7775": "public class Runtime { \nprivate void subset ( RuntimeSubexpression sub , int begin , int end ) { \nint n = sub . number ; \nassert n > 0 ; \nwhile ( match . size ( ) < ( n + 1 ) ) match . add ( null ) ; \nmatch . set ( n , new RegMatch ( begin , end ) ) ; \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nint mid ; \nassert t . op == '.' ; \nassert t . left != null && t . left . machine . states . length > 0 ; \nassert t . right != null && t . right . machine . states . length > 0 ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( mem [ t . retry ] == 0 ) { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) return false ; \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nelse mid = begin + ( mem [ t . retry ] - 1 ) ; \nfor ( ; \n; \n) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) break ; \nif ( mid == end ) return false ; \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) return false ; \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \nreturn true ; \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nint i ; \nint n = t . number ; \nint len ; \nint paren ; \nint p ; \nint stop ; \nint min = t . min ; \nint max = t . max ; \nassert t . op == 'b' ; \nassert n >= 0 ; \nif ( match . get ( n ) == null ) return false ; \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) return false ; \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) return begin == end ; \nassert end >= begin ; \nif ( ( end - begin ) < len ) return false ; \nstop = end - len ; \ni = 0 ; \nfor ( p = begin ; \np <= stop && ( i < max || max == Compiler . INFINITY ) ; \np += len ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) break ; \ni ++ ; \n} \nif ( p != end ) return false ; \nreturn min <= i && ( i <= max || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7778": "public class Compiler { \nprivate void cloneouts ( Nfa nfa , State old , State from , State to , int type ) { \nArc a ; \nassert old != from ; \nfor ( a = old . outs ; \na != null ; \na = a . outchain ) nfa . newarc ( type , a . co , from , to ) ; \n} \n} \n"}
{"7779": "public class Compiler { \nprivate void optst ( Subre t ) { \nif ( t == null ) return ; \nif ( t . left != null ) optst ( t . left ) ; \nif ( t . right != null ) optst ( t . right ) ; \n} \n} \n"}
{"7780": "public class Compiler { \nprivate void markst ( Subre t ) { \nassert t != null ; \nt . flags |= Subre . INUSE ; \nif ( t . left != null ) markst ( t . left ) ; \nif ( t . right != null ) markst ( t . right ) ; \n} \n} \n"}
{"7781": "public class Compiler { \nprivate long nfanode ( Subre t ) throws RegexException { \nlong ret ; \nassert t . begin != null ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) LOG . debug ( String . format ( \"========= TREE NODE %s ==========\" , t . shortId ( ) ) ) ; \nNfa newNfa = new Nfa ( nfa ) ; \nnewNfa . dupnfa ( t . begin , t . end , newNfa . init , newNfa . finalState ) ; \nnewNfa . specialcolors ( ) ; \nret = newNfa . optimize ( ) ; \nt . cnfa = newNfa . compact ( ) ; \nreturn ret ; \n} \n} \n"}
{"7782": "public class Compiler { \nprivate Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { \nState left ; \nState right ; \nSubre branches ; \nSubre branch ; \nSubre t ; \nint firstbranch ; \nassert stopper == ')' || stopper == EOS ; \nbranches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branches ; \nfirstbranch = 1 ; \ndo { \nif ( 0 == firstbranch ) { \nbranch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branch . right ; \n} \nfirstbranch = 0 ; \nleft = nfa . newstate ( ) ; \nright = nfa . newstate ( ) ; \nnfa . emptyarc ( initState , left ) ; \nnfa . emptyarc ( right , finalState ) ; \nbranch . left = parsebranch ( stopper , type , left , right , false ) ; \nbranch . flags |= up ( branch . flags | branch . left . flags ) ; \nif ( ( branch . flags & ~ branches . flags ) != 0 ) for ( t = branches ; \nt != branch ; \nt = t . right ) t . flags |= branch . flags ; \n} \nwhile ( eat ( '|' ) ) ; \nassert see ( stopper ) || see ( EOS ) ; \nif ( ! see ( stopper ) ) { \nassert stopper == ')' && see ( EOS ) ; \nthrow new RegexException ( \"Unbalanced parentheses.\" ) ; \n} \nif ( branch == branches ) { \nassert branch . right == null ; \nt = branch . left ; \nbranch . left = null ; \nbranches = t ; \n} \nelse if ( ! messy ( branches . flags ) ) { \nbranches . left = null ; \nbranches . right = null ; \nbranches . op = '=' ; \n} \nreturn branches ; \n} \n} \n"}
{"7783": "public class Compiler { \nprivate void deltraverse ( Nfa nfa , State leftend , State s ) { \nArc a ; \nState to ; \nif ( s . nouts == 0 ) return ; \nif ( s . tmp != null ) return ; \ns . tmp = s ; \nwhile ( ( a = s . outs ) != null ) { \nto = a . to ; \ndeltraverse ( nfa , leftend , to ) ; \nassert to . nouts == 0 || to . tmp != null ; \nnfa . freearc ( a ) ; \nif ( to . nins == 0 && to . tmp == null ) { \nassert to . nouts == 0 ; \nnfa . freestate ( to ) ; \n} \n} \nassert s . no != State . FREESTATE ; \nassert s == leftend || s . nins != 0 ; \nassert s . nouts == 0 ; \ns . tmp = null ; \n} \n} \n"}
{"7786": "public class Compiler { \nprivate int scannum ( ) throws RegexException { \nint n = 0 ; \nwhile ( see ( DIGIT ) && n < DUPMAX ) { \nn = n * 10 + nextvalue ; \nlex . next ( ) ; \n} \nif ( see ( DIGIT ) || n > DUPMAX ) throw new RegexException ( \"Unvalid reference number.\" ) ; \nreturn n ; \n} \n} \n"}
{"7787": "public class Compiler { \nprivate void bracket ( State lp , State rp ) throws RegexException { \nassert see ( '[' ) ; \nlex . next ( ) ; \nwhile ( ! see ( ']' ) && ! see ( EOS ) ) brackpart ( lp , rp ) ; \nassert see ( ']' ) ; \ncm . okcolors ( nfa ) ; \n} \n} \n"}
{"7789": "public class Compiler { \nprivate int newlacon ( State begin , State end , int pos ) { \nif ( lacons . size ( ) == 0 ) lacons . add ( null ) ; \nSubre sub = new Subre ( ( char ) 0 , 0 , begin , end ) ; \nsub . subno = pos ; \nlacons . add ( sub ) ; \nreturn lacons . size ( ) - 1 ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nint rangeCount = set . getRangeCount ( ) ; \nfor ( int rx = 0 ; \nrx < rangeCount ; \nrx ++ ) { \nint rangeStart = set . getRangeStart ( rx ) ; \nint rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) LOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \nif ( rangeStart == rangeEnd ) nfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \n} \n} \n} \n"}
{"7794": "public class ColorMap { \nvoid subrange ( int from , int to , State lp , State rp ) throws RegexException { \nMap < Range < Integer > , Short > curColors = map . subRangeMap ( Range . closed ( from , to ) ) . asMapOfRanges ( ) ; \nList < Range < Integer > > ranges = Lists . newArrayList ( curColors . keySet ( ) ) ; \nfor ( Range < Integer > rangeToProcess : ranges ) { \nint start = rangeToProcess . lowerEndpoint ( ) ; \nif ( rangeToProcess . lowerBoundType ( ) == BoundType . OPEN ) start ++ ; \nint end = rangeToProcess . upperEndpoint ( ) ; \nif ( rangeToProcess . upperBoundType ( ) == BoundType . CLOSED ) end ++ ; \nshort color = subcolor ( start , end - start ) ; \ncompiler . getNfa ( ) . newarc ( Compiler . PLAIN , color , lp , rp ) ; \n} \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) continue ; \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \n} \n} \n"}
{"7797": "public class ColorMap { \nvoid uncolorchain ( Arc a ) { \nColorDesc cd = colorDescs . get ( a . co ) ; \nArc aa ; \naa = cd . arcs ; \nif ( aa == a ) cd . arcs = a . colorchain ; \nelse { \nfor ( ; \naa != null && aa . colorchain != a ; \naa = aa . colorchain ) { \n} \nassert aa != null ; \naa . colorchain = a . colorchain ; \n} \na . colorchain = null ; \n} \n} \n"}
{"7798": "public class ColorMap { \nvoid dumpcolors ( ) { \nfor ( int co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \nColorDesc cd = colorDescs . get ( co ) ; \nif ( cd != null ) dumpcolor ( co , cd ) ; \n} \n} \n} \n"}
{"7800": "public class Lex { \nvoid prefixes ( ) throws RegexException { \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) return ; \nif ( have ( 4 ) && next3 ( '*' , '*' , '*' ) ) switch ( charAtNowPlus ( 3 ) ) { \ncase '?' : throw new RegexException ( \"REG_BADPAT\" ) ; \ncase '=' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \nv . now += 4 ; \nreturn ; \ncase ':' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_ADVANCED ; \nv . now += 4 ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADRPT\" ) ; \n} \nif ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) return ; \nif ( have ( 3 ) && next2 ( '(' , '?' ) && iscalpha ( charAtNowPlus ( 2 ) ) ) { \nv . note ( Flags . REG_UNONPOSIX ) ; \nv . now += 2 ; \nfor ( ; \n! ateos ( ) && iscalpha ( charAtNow ( ) ) ; \nv . now ++ ) switch ( charAtNow ( ) ) { \ncase 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'c' : v . cflags &= ~ Flags . REG_ICASE ; \nbreak ; \ncase 'e' : v . cflags |= Flags . REG_EXTENDED ; \nv . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'i' : v . cflags |= Flags . REG_ICASE ; \nbreak ; \ncase 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; \nbreak ; \ncase 'p' : v . cflags |= Flags . REG_NLSTOP ; \nv . cflags &= ~ Flags . REG_NLANCH ; \nbreak ; \ncase 'q' : v . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ Flags . REG_ADVANCED ; \nbreak ; \ncase 's' : v . cflags &= ~ Flags . REG_NEWLINE ; \nbreak ; \ncase 't' : v . cflags &= ~ Flags . REG_EXPANDED ; \nbreak ; \ncase 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; \nv . cflags |= Flags . REG_NLANCH ; \nbreak ; \ncase 'x' : v . cflags |= Flags . REG_EXPANDED ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADOPT\" ) ; \n} \nif ( ! next1 ( ')' ) ) throw new RegexException ( \"REG_BADOPT\" ) ; \nv . now ++ ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) v . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \n} \n} \n} \n"}
{"7804": "public class Dfa { \nint lastcold ( ) { \nint nopr = 0 ; \nfor ( StateSet ss : stateSets . values ( ) ) { \nif ( ss . noprogress && nopr < ss . getLastSeen ( ) ) nopr = ss . getLastSeen ( ) ; \n} \nreturn nopr ; \n} \n} \n"}
{"7805": "public class Locale { \nstatic UnicodeSet eclass ( char c , boolean cases ) { \nif ( cases ) return allcases ( c ) ; \nelse { \nUnicodeSet set = new UnicodeSet ( ) ; \nset . add ( c ) ; \nreturn set ; \n} \n} \n} \n"}
{"7806": "public class Locale { \npublic static UnicodeSet cclass ( String cclassName , boolean casefold ) throws RegexException { \ntry { \nif ( casefold ) return KNOWN_SETS_CI . get ( cclassName ) ; \nelse return KNOWN_SETS_CS . get ( cclassName ) ; \n} \ncatch ( ExecutionException e ) { \nThrowables . propagateIfInstanceOf ( e . getCause ( ) , RegexException . class ) ; \nthrow new RegexRuntimeException ( e . getCause ( ) ) ; \n} \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nint p ; \nint q ; \nlong tmp ; \nif ( last - first <= 1 ) return ; \nfor ( p = first ; \np <= last ; \np ++ ) for ( q = p ; \nq <= last ; \nq ++ ) { \nshort pco = Cnfa . carcColor ( arcs [ p ] ) ; \nshort qco = Cnfa . carcColor ( arcs [ q ] ) ; \nint pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nint qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( pco > qco || ( pco == qco && pto > qto ) ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \n} \n} \n} \n"}
{"7808": "public class Subre { \nString dumpst ( boolean nfapresent ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"%s. `%c'\" , shortId ( ) , op ) ) ; \nif ( 0 != ( flags & LONGER ) ) sb . append ( \" longest\" ) ; \nif ( 0 != ( flags & SHORTER ) ) sb . append ( \" shortest\" ) ; \nif ( 0 != ( flags & MIXED ) ) sb . append ( \" hasmixed\" ) ; \nif ( 0 != ( flags & CAP ) ) sb . append ( \" hascapture\" ) ; \nif ( 0 != ( flags & BACKR ) ) sb . append ( \" hasbackref\" ) ; \nif ( 0 == ( flags & INUSE ) ) sb . append ( \" UNUSED\" ) ; \nif ( subno != 0 ) sb . append ( String . format ( \" (#%d)\" , subno ) ) ; \nif ( min != 1 || max != 1 ) { \nsb . append ( String . format ( \" {%d,\" , min ) ) ; \nif ( max != Compiler . INFINITY ) sb . append ( String . format ( \"%d\" , max ) ) ; \nsb . append ( \"}\" ) ; \n} \nif ( nfapresent ) sb . append ( String . format ( \" %d-%d\" , begin . no , end . no ) ) ; \nif ( left != null ) sb . append ( String . format ( \" L:%s\" , left . toString ( ) ) ) ; \nif ( right != null ) sb . append ( String . format ( \" R:%s\" , right . toString ( ) ) ) ; \nsb . append ( \"\\n\" ) ; \nif ( left != null ) left . dumpst ( nfapresent ) ; \nif ( right != null ) right . dumpst ( nfapresent ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"7809": "public class Nfa { \nState newstate ( int flag ) { \nState newState = new State ( ) ; \nnewState . no = nstates ++ ; \nif ( states == null ) states = newState ; \nif ( slast != null ) { \nassert slast . next == null ; \nslast . next = newState ; \n} \nnewState . prev = slast ; \nslast = newState ; \nnewState . flag = flag ; \nreturn newState ; \n} \n} \n"}
{"7812": "public class Nfa { \nvoid copyins ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nfor ( a = old . ins ; \na != null ; \na = a . inchain ) cparc ( a , a . from , newState ) ; \n} \n} \n"}
{"7813": "public class Nfa { \nvoid copyouts ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nfor ( a = old . outs ; \na != null ; \na = a . outchain ) cparc ( a , newState , a . to ) ; \n} \n} \n"}
{"7814": "public class Nfa { \nvoid dropstate ( State s ) { \nArc a ; \nwhile ( ( a = s . ins ) != null ) freearc ( a ) ; \nwhile ( ( a = s . outs ) != null ) freearc ( a ) ; \nfreestate ( s ) ; \n} \n} \n"}
{"7815": "public class Nfa { \nvoid freestate ( State s ) { \nassert s != null ; \nassert s . nins == 0 ; \nassert s . nouts == 0 ; \nif ( s . next != null ) s . next . prev = s . prev ; \nelse { \nassert s == slast ; \nslast = s . prev ; \n} \nif ( s . prev != null ) s . prev . next = s . next ; \nelse { \nassert s == states ; \nstates = s . next ; \n} \n} \n} \n"}
{"7817": "public class Nfa { \nvoid duptraverse ( State s , State stmp ) { \nArc a ; \nif ( s . tmp != null ) return ; \ns . tmp = ( stmp == null ) ? newstate ( ) : stmp ; \nif ( s . tmp == null ) return ; \nfor ( a = s . outs ; \na != null ; \na = a . outchain ) { \nduptraverse ( a . to , null ) ; \nassert a . to . tmp != null ; \ncparc ( a , s . tmp , a . to . tmp ) ; \n} \n} \n} \n"}
{"7819": "public class Nfa { \nvoid dumpnfa ( ) { \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) return ; \nLOG . debug ( \"dump nfa\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"pre %d, post %d init %d final %d\" , pre . no , post . no , init . no , finalState . no ) ) ; \nif ( bos [ 0 ] != Constants . COLORLESS ) sb . append ( String . format ( \", bos [%d]\" , bos [ 0 ] ) ) ; \nif ( bos [ 1 ] != Constants . COLORLESS ) sb . append ( String . format ( \", bol [%d]\" , bos [ 1 ] ) ) ; \nif ( eos [ 0 ] != Constants . COLORLESS ) sb . append ( String . format ( \", eos [%d]\" , eos [ 0 ] ) ) ; \nif ( eos [ 1 ] != Constants . COLORLESS ) sb . append ( String . format ( \", eol [%d]\" , eos [ 1 ] ) ) ; \nLOG . debug ( sb . toString ( ) ) ; \nfor ( State s = states ; \ns != null ; \ns = s . next ) dumpstate ( s ) ; \nif ( parent == null ) cm . dumpcolors ( ) ; \n} \n} \n"}
{"7820": "public class Nfa { \nvoid dumpstate ( State s ) { \nArc a ; \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) return ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"State %d%s%c\" , s . no , ( s . tmp != null ) ? \"T\" : \"\" , ( s . flag != 0 ) ? ( char ) s . flag : '.' ) ) ; \nif ( s . prev != null && s . prev . next != s ) sb . append ( String . format ( \"\\tstate chain bad\" ) ) ; \nif ( s . nouts == 0 ) sb . append ( \"\\tno out arcs\" ) ; \nelse dumparcs ( s , sb ) ; \nLOG . debug ( sb . toString ( ) ) ; \nfor ( a = s . ins ; \na != null ; \na = a . inchain ) if ( a . to != s ) LOG . debug ( String . format ( \"\\tlink from %d to %d on %d's in-chain\" , a . from . no , a . to . no , s . no ) ) ; \n} \n} \n"}
{"7822": "public class Nfa { \nint dumprarcs ( Arc a , State s , int pos , StringBuilder sb ) { \nif ( a . outchain != null ) pos = dumprarcs ( a . outchain , s , pos , sb ) ; \ndumparc ( a , s , sb ) ; \nif ( pos == 5 ) { \nsb . append ( \"\\n\" ) ; \npos = 1 ; \n} \nelse pos ++ ; \nreturn pos ; \n} \n} \n"}
{"7823": "public class Nfa { \nvoid dumparc ( Arc a , State s , StringBuilder sb ) { \nsb . append ( \"\\t\" ) ; \nswitch ( a . type ) { \ncase Compiler . PLAIN : sb . append ( String . format ( \"[%d]\" , a . co ) ) ; \nbreak ; \ncase Compiler . AHEAD : sb . append ( String . format ( \">%d>\" , a . co ) ) ; \nbreak ; \ncase Compiler . BEHIND : sb . append ( String . format ( \"<%d<\" , a . co ) ) ; \nbreak ; \ncase Compiler . LACON : sb . append ( String . format ( \":%d:\" , a . co ) ) ; \nbreak ; \ncase '^' : case '$' : sb . append ( String . format ( \"%c%d\" , ( char ) a . type , a . co ) ) ; \nbreak ; \ncase Compiler . EMPTY : break ; \ndefault : sb . append ( String . format ( \"0x%x/0%d\" , a . type , a . co ) ) ; \nbreak ; \n} \nif ( a . from != s ) sb . append ( String . format ( \"?%d?\" , a . from . no ) ) ; \nsb . append ( \"->\" ) ; \nif ( a . to == null ) { \nsb . append ( \"null\" ) ; \nArc aa ; \nfor ( aa = a . to . ins ; \naa != null ; \naa = aa . inchain ) if ( aa == a ) break ; \nif ( aa == null ) LOG . debug ( \"?!?\" ) ; \n} \nelse sb . append ( String . format ( \"%d\" , a . to . no ) ) ; \n} \n} \n"}
{"7825": "public class Nfa { \nlong analyze ( ) { \nArc a ; \nArc aa ; \nif ( pre . outs == null ) return Flags . REG_UIMPOSSIBLE ; \nfor ( a = pre . outs ; \na != null ; \na = a . outchain ) for ( aa = a . to . outs ; \naa != null ; \naa = aa . outchain ) if ( aa . to == post ) return Flags . REG_UEMPTYMATCH ; \nreturn 0 ; \n} \n} \n"}
{"7826": "public class Nfa { \nint combine ( Arc con , Arc a ) throws RegexException { \nswitch ( ( con . type << 8 ) | a . type ) { \ncase '^' << 8 | Compiler . PLAIN : case '$' << 8 | Compiler . PLAIN : return INCOMPATIBLE ; \ncase Compiler . AHEAD << 8 | Compiler . PLAIN : case Compiler . BEHIND << 8 | Compiler . PLAIN : if ( con . co == a . co ) return SATISFIED ; \nreturn INCOMPATIBLE ; \ncase '^' << 8 | '^' : case '$' << 8 | '$' : case Compiler . AHEAD << 8 | Compiler . AHEAD : case Compiler . BEHIND << 8 | Compiler . BEHIND : if ( con . co == a . co ) return SATISFIED ; \nreturn INCOMPATIBLE ; \ncase '^' << 8 | Compiler . BEHIND : case Compiler . BEHIND << 8 | '^' : case '$' << 8 | Compiler . AHEAD : case Compiler . AHEAD << 8 | '$' : return INCOMPATIBLE ; \ncase '^' << 8 | Compiler . AHEAD : case Compiler . BEHIND << 8 | '$' : case Compiler . BEHIND << 8 | Compiler . AHEAD : case '$' << 8 | '^' : case '$' << 8 | Compiler . BEHIND : case Compiler . AHEAD << 8 | '^' : case Compiler . AHEAD << 8 | Compiler . BEHIND : case '^' << 8 | Compiler . LACON : case Compiler . BEHIND << 8 | Compiler . LACON : case '$' << 8 | Compiler . LACON : case Compiler . AHEAD << 8 | Compiler . LACON : return COMPATIBLE ; \ndefault : throw new RuntimeException ( \"Impossible arc\" ) ; \n} \n} \n} \n"}
{"7827": "public class Nfa { \nvoid cleanup ( ) { \nState s ; \nState nexts ; \nint n ; \nmarkreachable ( pre , null , pre ) ; \nmarkcanreach ( post , pre , post ) ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nif ( s . tmp != post && 0 == s . flag ) dropstate ( s ) ; \n} \nassert post . nins == 0 || post . tmp == post ; \ncleartraverse ( pre ) ; \nassert post . nins == 0 || post . tmp == null ; \nn = 0 ; \nfor ( s = states ; \ns != null ; \ns = s . next ) s . no = n ++ ; \nnstates = n ; \n} \n} \n"}
{"7828": "public class Nfa { \nvoid markreachable ( State s , State okay , State mark ) { \nArc a ; \nif ( s . tmp != okay ) return ; \ns . tmp = mark ; \nfor ( a = s . outs ; \na != null ; \na = a . outchain ) markreachable ( a . to , okay , mark ) ; \n} \n} \n"}
{"7829": "public class Nfa { \nvoid markcanreach ( State s , State okay , State mark ) { \nArc a ; \nif ( s . tmp != okay ) return ; \ns . tmp = mark ; \nfor ( a = s . ins ; \na != null ; \na = a . inchain ) markcanreach ( a . from , okay , mark ) ; \n} \n} \n"}
{"7830": "public class Nfa { \nvoid fixempties ( ) { \nState s ; \nState nexts ; \nArc a ; \nArc nexta ; \nboolean progress ; \ndo { \nprogress = false ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nfor ( a = s . outs ; \na != null ; \na = nexta ) { \nnexta = a . outchain ; \nif ( a . type == Compiler . EMPTY && unempty ( a ) ) progress = true ; \nassert nexta == null || s . no != State . FREESTATE ; \n} \n} \nif ( progress ) dumpnfa ( ) ; \n} \nwhile ( progress ) ; \n} \n} \n"}
{"7831": "public class Nfa { \nboolean unempty ( Arc a ) { \nState from = a . from ; \nState to = a . to ; \nboolean usefrom ; \nassert a . type == Compiler . EMPTY ; \nassert from != pre && to != post ; \nif ( from == to ) { \nfreearc ( a ) ; \nreturn true ; \n} \nusefrom = true ; \nif ( from . nouts > to . nins ) usefrom = false ; \nelse if ( from . nouts == to . nins ) if ( from . nins > to . nouts ) usefrom = false ; \nfreearc ( a ) ; \nif ( usefrom ) if ( from . nouts == 0 ) { \nmoveins ( from , to ) ; \nfreestate ( from ) ; \n} \nelse copyins ( from , to ) ; \nelse if ( to . nins == 0 ) { \nmoveouts ( to , from ) ; \nfreestate ( to ) ; \n} \nelse copyouts ( to , from ) ; \nreturn true ; \n} \n} \n"}
{"7832": "public class AnalyzeTask { \nprivate Map < String , String > getRuleParameters ( ) throws CliExecutionException { \nMap < String , String > ruleParameters ; \nif ( ruleParametersFile == null ) ruleParameters = Collections . emptyMap ( ) ; \nelse { \nProperties properties = new Properties ( ) ; \ntry { \nproperties . load ( new FileInputStream ( ruleParametersFile ) ) ; \n} \ncatch ( IOException e ) { \nthrow new CliExecutionException ( \"Cannot read rule parameters file '\" + ruleParametersFile . getPath ( ) + \"'.\" ) ; \n} \nruleParameters = new TreeMap < > ( ) ; \nfor ( String name : properties . stringPropertyNames ( ) ) { \nruleParameters . put ( name , properties . getProperty ( name ) ) ; \n} \n} \nreturn ruleParameters ; \n} \n} \n"}
{"7841": "public class Main { \nprivate void interpretCommandLine ( CommandLine commandLine , Options options , TaskFactory taskFactory ) throws CliExecutionException { \nif ( commandLine . hasOption ( OPTION_HELP ) ) { \nprintUsage ( options , null ) ; \nSystem . exit ( 1 ) ; \n} \nList < String > taskNames = commandLine . getArgList ( ) ; \nif ( taskNames . isEmpty ( ) ) { \nprintUsage ( options , \"A task must be specified, i.e. one  of \" + gatherTaskNames ( taskFactory ) ) ; \nSystem . exit ( 1 ) ; \n} \nList < Task > tasks = new ArrayList < > ( ) ; \nfor ( String taskName : taskNames ) { \nTask task = taskFactory . fromName ( taskName ) ; \nif ( task == null ) printUsage ( options , \"Unknown task \" + taskName ) ; \ntasks . add ( task ) ; \n} \nMap < String , Object > properties = readProperties ( commandLine ) ; \nPluginRepository pluginRepository = getPluginRepository ( ) ; \ntry { \nexecuteTasks ( tasks , options , commandLine , pluginRepository , properties ) ; \n} \ncatch ( PluginRepositoryException e ) { \nthrow new CliExecutionException ( \"Unexpected plugin repository problem while executing tasks.\" , e ) ; \n} \n} \n} \n"}
{"7844": "public class Main { \nprivate Map < String , Object > readProperties ( CommandLine commandLine ) throws CliConfigurationException { \nfinal Properties properties = new Properties ( ) ; \nInputStream propertiesStream ; \nif ( commandLine . hasOption ( \"p\" ) ) { \nFile propertyFile = new File ( commandLine . getOptionValue ( \"p\" ) ) ; \nif ( ! propertyFile . exists ( ) ) throw new CliConfigurationException ( \"Property file given by command line does not exist: \" + propertyFile . getAbsolutePath ( ) ) ; \ntry { \npropertiesStream = new FileInputStream ( propertyFile ) ; \n} \ncatch ( FileNotFoundException e ) { \nthrow new CliConfigurationException ( \"Cannot open property file.\" , e ) ; \n} \n} \nelse propertiesStream = Main . class . getResourceAsStream ( \"/jqassistant.properties\" ) ; \nMap < String , Object > result = new HashMap < > ( ) ; \nif ( propertiesStream != null ) { \ntry { \nproperties . load ( propertiesStream ) ; \n} \ncatch ( IOException e ) { \nthrow new CliConfigurationException ( \"Cannot load properties from file.\" , e ) ; \n} \nfor ( String name : properties . stringPropertyNames ( ) ) { \nresult . put ( name , properties . getProperty ( name ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7845": "public class Main { \nprivate void printUsage ( final Options options , final String errorMessage ) { \nif ( errorMessage != null ) System . out . println ( \"Error: \" + errorMessage ) ; \nfinal HelpFormatter formatter = new HelpFormatter ( ) ; \nformatter . printHelp ( Main . class . getCanonicalName ( ) + \" <task> [options]\" , options ) ; \nSystem . out . println ( \"Tasks are: \" + gatherTaskNames ( taskFactory ) ) ; \nSystem . out . println ( \"Example: \" + Main . class . getCanonicalName ( ) + \" scan -f java:classpath::target/classes java:classpath::target/test-classes\" ) ; \n} \n} \n"}
{"7847": "public class Main { \nprivate ClassLoader createPluginClassLoader ( ) throws CliExecutionException { \nClassLoader parentClassLoader = Task . class . getClassLoader ( ) ; \nFile homeDirectory = getHomeDirectory ( ) ; \nif ( homeDirectory != null ) { \nFile pluginDirectory = new File ( homeDirectory , DIRECTORY_PLUGINS ) ; \nif ( pluginDirectory . exists ( ) ) { \nfinal List < URL > urls = new ArrayList < > ( ) ; \nfinal Path pluginDirectoryPath = pluginDirectory . toPath ( ) ; \nSimpleFileVisitor < Path > visitor = new SimpleFileVisitor < Path > ( ) { \n@ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { \nif ( file . toFile ( ) . getName ( ) . endsWith ( \".jar\" ) ) urls . add ( file . toFile ( ) . toURI ( ) . toURL ( ) ) ; \nreturn FileVisitResult . CONTINUE ; \n} \n} \n; \ntry { \nFiles . walkFileTree ( pluginDirectoryPath , visitor ) ; \n} \ncatch ( IOException e ) { \nthrow new CliExecutionException ( \"Cannot read plugin directory.\" , e ) ; \n} \nLOGGER . debug ( \"Using plugin URLs: \" + urls ) ; \nreturn new com . buschmais . jqassistant . commandline . PluginClassLoader ( urls , parentClassLoader ) ; \n} \n} \nreturn parentClassLoader ; \n} \n} \n"}
{"7848": "public class CountryBoundaries { \npublic Set < String > getContainingIds ( double minLongitude , double minLatitude , double maxLongitude , double maxLatitude ) { \nSet < String > ids = new HashSet < > ( ) ; \nforCellsIn ( minLongitude , minLatitude , maxLongitude , maxLatitude , cell -> { \nif ( ids . isEmpty ( ) ) ids . addAll ( cell . getContainingIds ( ) ) ; \nelse ids . retainAll ( cell . getContainingIds ( ) ) ; \n} \n) ; \nreturn ids ; \n} \n} \n"}
{"7850": "public class Router { \npublic String uri ( HttpMethod method , T target , Object ... params ) { \nMethodlessRouter < T > router = ( method == null ) ? anyMethodRouter : routers . get ( method ) ; \nif ( router == null ) router = anyMethodRouter ; \nString ret = router . uri ( target , params ) ; \nif ( ret != null ) return ret ; \nreturn ( router != anyMethodRouter ) ? anyMethodRouter . uri ( target , params ) : null ; \n} \n} \n"}
{"7851": "public class OrderlessRouter { \npublic OrderlessRouter < T > addRoute ( String pathPattern , T target ) { \nPathPattern p = new PathPattern ( pathPattern ) ; \nif ( routes . containsKey ( p ) ) return this ; \nroutes . put ( p , target ) ; \naddReverseRoute ( target , p ) ; \nreturn this ; \n} \n} \n"}
{"7857": "public class HibernateBookmarkStore { \nprivate Criterion smartEqual ( String property , Object value ) { \nif ( value == null ) return Restrictions . isNull ( property ) ; \nelse return Restrictions . eq ( property , value ) ; \n} \n} \n"}
{"7859": "public class DefaultBookmarksComparator { \nprotected int compareFolders ( final Entry e1 , final Entry e2 ) { \nfinal boolean f1 = e1 instanceof Folder ; \nfinal boolean f2 = e2 instanceof Folder ; \nif ( f1 && ! f2 ) return - 1 ; \nelse if ( ! f1 && f2 ) return 1 ; \nelse return 0 ; \n} \n} \n"}
{"7861": "public class DefaultBookmarksComparator { \nprotected int compareBookmarks ( final Entry e1 , final Entry e2 ) { \nif ( e1 instanceof Bookmark && e2 instanceof Bookmark ) { \nfinal Bookmark b1 = ( Bookmark ) e1 ; \nfinal Bookmark b2 = ( Bookmark ) e2 ; \nreturn new CompareToBuilder ( ) . append ( b1 . getUrl ( ) , b2 . getUrl ( ) ) . append ( b1 . isNewWindow ( ) , b2 . isNewWindow ( ) ) . toComparison ( ) ; \n} \nelse return 0 ; \n} \n} \n"}
{"7862": "public class JspServletWrapper { \npublic void setServletClassLastModifiedTime ( long lastModified ) { \nif ( this . servletClassLastModifiedTime < lastModified ) synchronized ( this ) { \nif ( this . servletClassLastModifiedTime < lastModified ) { \nthis . servletClassLastModifiedTime = lastModified ; \nreload = true ; \n} \n} \n} \n} \n"}
{"7863": "public class JspServletWrapper { \npublic java . util . List < String > getDependants ( ) { \ntry { \nObject target ; \nif ( isTagFile ) { \nif ( reload ) tagHandlerClass = ctxt . load ( ) ; \ntarget = tagHandlerClass . newInstance ( ) ; \n} \nelse target = getServlet ( ) ; \nif ( target != null && target instanceof JspSourceDependent ) return ( ( JspSourceDependent ) target ) . getDependants ( ) ; \n} \ncatch ( Throwable ex ) { \n} \nreturn null ; \n} \n} \n"}
{"7864": "public class JasperLoader { \npublic Class findClass ( String className ) throws ClassNotFoundException { \nbyte [ ] cdata = this . bytecodes . get ( className ) ; \nString path = className . replace ( '.' , '/' ) + \".class\" ; \nif ( cdata == null ) { \ncdata = loadClassDataFromFile ( path ) ; \nif ( cdata == null ) throw new ClassNotFoundException ( className ) ; \n} \nClass clazz = null ; \nif ( securityManager != null ) { \nProtectionDomain pd = new ProtectionDomain ( codeSource , permissionCollection ) ; \nclazz = defineClass ( className , cdata , 0 , cdata . length , pd ) ; \n} \nelse clazz = defineClass ( className , cdata , 0 , cdata . length ) ; \nreturn clazz ; \n} \n} \n"}
{"7865": "public class BasicAuthentication { \npublic static String [ ] parseAuthorization ( final HttpServletRequest request ) { \nfinal String auth = request . getHeader ( \"Authorization\" ) ; \nlogger . debug ( \"Auth header: {}\" , auth ) ; \nif ( auth == null || auth . isEmpty ( ) ) return null ; \nfinal String [ ] toks = auth . split ( \"\\\\s\" ) ; \nif ( toks . length < 2 ) return null ; \nif ( ! \"Basic\" . equalsIgnoreCase ( toks [ 0 ] ) ) return null ; \nfinal byte [ ] authData = Base64 . getDecoder ( ) . decode ( toks [ 1 ] ) ; \nfinal String authStr = StandardCharsets . ISO_8859_1 . decode ( ByteBuffer . wrap ( authData ) ) . toString ( ) ; \nlogger . debug ( \"Auth String: {}\" , authStr ) ; \nfinal String [ ] authToks = authStr . split ( \":\" , 2 ) ; \nlogger . debug ( \"Auth tokens: {}\" , new Object [ ] { \nauthToks } \n) ; \nif ( authToks . length != 2 ) return null ; \nreturn authToks ; \n} \n} \n"}
{"7866": "public class ProtectedFunctionMapper { \npublic static ProtectedFunctionMapper getInstance ( ) { \nProtectedFunctionMapper funcMapper ; \nif ( SecurityUtil . isPackageProtectionEnabled ( ) ) funcMapper = AccessController . doPrivileged ( new PrivilegedAction < ProtectedFunctionMapper > ( ) { \npublic ProtectedFunctionMapper run ( ) { \nreturn new ProtectedFunctionMapper ( ) ; \n} \n} \n) ; \nelse funcMapper = new ProtectedFunctionMapper ( ) ; \nfuncMapper . fnmap = new java . util . HashMap < String , Method > ( ) ; \nreturn funcMapper ; \n} \n} \n"}
{"7867": "public class ProtectedFunctionMapper { \npublic void mapFunction ( String fnQName , final Class < ? > c , final String methodName , final Class < ? > [ ] args ) { \njava . lang . reflect . Method method ; \nif ( SecurityUtil . isPackageProtectionEnabled ( ) ) try { \nmethod = AccessController . doPrivileged ( new PrivilegedExceptionAction < Method > ( ) { \npublic Method run ( ) throws Exception { \nreturn c . getDeclaredMethod ( methodName , args ) ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException ex ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + ex . getException ( ) . getMessage ( ) ) ; \n} \nelse try { \nmethod = c . getDeclaredMethod ( methodName , args ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + e . getMessage ( ) ) ; \n} \nthis . fnmap . put ( fnQName , method ) ; \n} \n} \n"}
{"7869": "public class ProtectedFunctionMapper { \npublic Method resolveFunction ( String prefix , String localName ) { \nif ( this . fnmap != null ) return this . fnmap . get ( prefix + \":\" + localName ) ; \nreturn theMethod ; \n} \n} \n"}
{"7875": "public class ParserController { \nprivate Node . Nodes doParse ( String inFileName , Node parent , URL jarFileUrl ) throws FileNotFoundException , JasperException , IOException { \nNode . Nodes parsedPage = null ; \nisEncodingSpecifiedInProlog = false ; \nisDefaultPageEncoding = false ; \nhasBom = false ; \nJarFile jarFile = getJarFile ( jarFileUrl ) ; \nString absFileName = resolveFileName ( inFileName ) ; \nString jspConfigPageEnc = getJspConfigPageEncoding ( absFileName ) ; \ndetermineSyntaxAndEncoding ( absFileName , jarFile , jspConfigPageEnc ) ; \nif ( parent != null ) compiler . getPageInfo ( ) . addDependant ( absFileName ) ; \ncomparePageEncodings ( jspConfigPageEnc ) ; \nif ( isXml ) parsedPage = JspDocumentParser . parse ( this , absFileName , jarFile , parent , isTagFile , directiveOnly , sourceEnc , jspConfigPageEnc , isEncodingSpecifiedInProlog ) ; \nelse { \nInputStreamReader inStreamReader = null ; \ntry { \ninStreamReader = JspUtil . getReader ( absFileName , sourceEnc , jarFile , ctxt , err ) ; \nJspReader jspReader = new JspReader ( ctxt , absFileName , sourceEnc , inStreamReader , err ) ; \nparsedPage = Parser . parse ( this , absFileName , jspReader , parent , isTagFile , directiveOnly , jarFileUrl , sourceEnc , jspConfigPageEnc , isDefaultPageEncoding , hasBom ) ; \n} \nfinally { \nif ( inStreamReader != null ) try { \ninStreamReader . close ( ) ; \n} \ncatch ( Exception any ) { \n} \n} \n} \nif ( jarFile != null ) try { \njarFile . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \nbaseDirStack . pop ( ) ; \nreturn parsedPage ; \n} \n} \n"}
{"7876": "public class JspCompilationContext { \npublic Compiler createCompiler ( boolean jspcMode ) throws JasperException { \nif ( jspCompiler != null ) return jspCompiler ; \njspCompiler = new Compiler ( this , jsw , jspcMode ) ; \nreturn jspCompiler ; \n} \n} \n"}
{"7878": "public class OsgiSitemapGenerator { \nprivate Optional < Instant > calcLastMod ( ) { \nInstant globalLastMod = null ; \nfor ( final ChannelInformation ci : this . channelService . list ( ) ) { \nfinal Optional < Instant > lastMod = ofNullable ( ci . getState ( ) . getModificationTimestamp ( ) ) ; \nif ( globalLastMod == null || lastMod . get ( ) . isAfter ( globalLastMod ) ) globalLastMod = lastMod . get ( ) ; \n} \nreturn Optional . ofNullable ( globalLastMod ) ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \nfor ( int i = 1 ; \ni < stack . length ; \ni ++ ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { \nif ( checkClassLoader ( tmp ) ) if ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) break ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7883": "public class Pagination { \npublic static < T > PaginationResult < T > paginate ( final Integer startPage , final int pageSize , final List < T > fullDataSet ) { \nreturn paginate ( startPage , pageSize , ( start , length ) -> { \nfinal int len = fullDataSet . size ( ) ; \nif ( start > len ) return Collections . emptyList ( ) ; \nreturn fullDataSet . subList ( start , Math . min ( start + length , len ) ) ; \n} \n) ; \n} \n} \n"}
{"7884": "public class MetaKey { \npublic static MetaKey fromString ( final String string ) { \nfinal int idx = string . indexOf ( ':' ) ; \nif ( idx < 1 ) return null ; \nif ( idx + 1 >= string . length ( ) ) return null ; \nreturn new MetaKey ( string . substring ( 0 , idx ) , string . substring ( idx + 1 ) , true ) ; \n} \n} \n"}
{"7885": "public class RpmBuilder { \nprivate void fillRequirements ( ) throws IOException { \nthis . requirements . add ( new Dependency ( \"rpmlib(CompressedFileNames)\" , \"3.0.4-1\" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; \nif ( ! this . options . getFileDigestAlgorithm ( ) . equals ( DigestAlgorithm . MD5 ) ) this . requirements . add ( new Dependency ( \"rpmlib(FileDigests)\" , \"4.6.0-1\" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; \nthis . requirements . add ( new Dependency ( \"rpmlib(PayloadFilesHavePrefix)\" , \"4.0-1\" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; \nthis . options . getPayloadCoding ( ) . createProvider ( ) . fillRequirements ( this . requirements :: add ) ; \n} \n} \n"}
{"7886": "public class ImplicitTagLibraryInfo { \npublic TagFileInfo getTagFile ( String shortName ) { \nTagFileInfo tagFile = super . getTagFile ( shortName ) ; \nif ( tagFile == null ) { \nString path = tagFileMap . get ( shortName ) ; \nif ( path == null ) return null ; \nTagInfo tagInfo = null ; \ntry { \ntagInfo = TagFileProcessor . parseTagFileDirectives ( pc , shortName , path , this ) ; \n} \ncatch ( JasperException je ) { \nthrow new RuntimeException ( je . toString ( ) ) ; \n} \ntagFile = new TagFileInfo ( shortName , path , tagInfo ) ; \nvec . add ( tagFile ) ; \nthis . tagFiles = vec . toArray ( new TagFileInfo [ vec . size ( ) ] ) ; \n} \nreturn tagFile ; \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) return ; \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) try { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nwhile ( list . hasNext ( ) ) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) this . tlibversion = element . getBody ( ) ; \nelse if ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) this . jspversion = element . getBody ( ) ; \nelse if ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) err . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) err . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \n} \n"}
{"7888": "public class OutputSpooler { \npublic String getChecksum ( final String fileName , final String algorithm ) { \nif ( ! this . digests . contains ( algorithm ) ) return null ; \nfinal String result = this . checksums . get ( fileName + \":\" + algorithm ) ; \nif ( result == null ) throw new IllegalStateException ( String . format ( \"Stream '%s' not closed.\" , fileName ) ) ; \nreturn result ; \n} \n} \n"}
{"7889": "public class OutputSpooler { \npublic long getSize ( final String fileName ) { \nfinal Long result = this . sizes . get ( fileName ) ; \nif ( result == null ) throw new IllegalStateException ( String . format ( \"Stream '%s' not closed or was not added\" , fileName ) ) ; \nreturn result ; \n} \n} \n"}
{"7890": "public class ChannelController { \nprivate static void validateChannelName ( final String name , final ValidationContext ctx ) { \nif ( name == null || name . isEmpty ( ) ) return ; \nfinal Matcher m = ChannelService . NAME_PATTERN . matcher ( name ) ; \nif ( ! m . matches ( ) ) ctx . error ( \"names\" , String . format ( \"The channel name '%s' must match the pattern '%s'\" , name , ChannelService . NAME_PATTERN . pattern ( ) ) ) ; \n} \n} \n"}
{"7893": "public class UnzipServlet { \nprotected static List < MavenVersionedArtifact > getMavenArtifacts ( final String channelId , final Supplier < Collection < ArtifactInformation > > artifactsSupplier , final String groupId , final String artifactId , final boolean snapshot , final Predicate < ComparableVersion > versionFilter ) { \nfinal List < MavenVersionedArtifact > arts = new ArrayList < > ( ) ; \nfor ( final ArtifactInformation ai : artifactsSupplier . get ( ) ) { \nif ( ! isZip ( ai ) ) continue ; \nfinal String mvnGroupId = ai . getMetaData ( ) . get ( MK_GROUP_ID ) ; \nfinal String mvnArtifactId = ai . getMetaData ( ) . get ( MK_ARTIFACT_ID ) ; \nfinal String classifier = ai . getMetaData ( ) . get ( MK_CLASSIFIER ) ; \nfinal String mvnVersion = ai . getMetaData ( ) . get ( MK_VERSION ) ; \nfinal String mvnSnapshotVersion = ai . getMetaData ( ) . get ( MK_SNAPSHOT_VERSION ) ; \nif ( mvnGroupId == null || mvnArtifactId == null || mvnVersion == null ) continue ; \nif ( classifier != null && ! classifier . isEmpty ( ) ) continue ; \nif ( ! mvnGroupId . equals ( groupId ) || ! mvnArtifactId . equals ( artifactId ) ) continue ; \nif ( ! snapshot && ( mvnSnapshotVersion != null || mvnVersion . endsWith ( \"-SNAPSHOT\" ) ) ) continue ; \nfinal ComparableVersion v = parseVersion ( mvnVersion ) ; \nfinal ComparableVersion sv = parseVersion ( mvnSnapshotVersion ) ; \nif ( v == null ) continue ; \nif ( versionFilter == null ) arts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \nelse if ( versionFilter . test ( v ) ) arts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \nelse if ( sv != null && versionFilter . test ( sv ) ) arts . add ( new MavenVersionedArtifact ( sv , channelId , ai ) ) ; \n} \nreturn arts ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \n-- optPrev ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nelse opts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse opts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; \nelse opts [ optCur ] . state . updateLiteral ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nint back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nif ( back < REPS ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \nfor ( rep = 1 ; \nrep <= back ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \nfor ( ; \nrep < REPS ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \n} \n} \n"}
{"7901": "public class TldScanner { \nprivate TldInfo scanTld ( String resourcePath , String entryName , InputStream stream ) throws JasperException { \ntry { \nTreeNode tld = new ParserUtils ( ) . parseXMLDocument ( resourcePath , stream , isValidationEnabled ) ; \nString uri = null ; \nTreeNode uriNode = tld . findChild ( \"uri\" ) ; \nif ( uriNode != null ) uri = uriNode . getBody ( ) ; \nArrayList < String > listeners = new ArrayList < String > ( ) ; \nIterator < TreeNode > listenerNodes = tld . findChildren ( \"listener\" ) ; \nwhile ( listenerNodes . hasNext ( ) ) { \nTreeNode listener = listenerNodes . next ( ) ; \nTreeNode listenerClass = listener . findChild ( \"listener-class\" ) ; \nif ( listenerClass != null ) { \nString listenerClassName = listenerClass . getBody ( ) ; \nif ( listenerClassName != null ) listeners . add ( listenerClassName ) ; \n} \n} \nreturn new TldInfo ( uri , entryName , listeners . toArray ( new String [ listeners . size ( ) ] ) ) ; \n} \nfinally { \nif ( stream != null ) try { \nstream . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \n} \n"}
{"7903": "public class JspRuntimeContext { \npublic ClassLoader getParentClassLoader ( ) { \nClassLoader parentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( parentClassLoader == null ) parentClassLoader = this . getClass ( ) . getClassLoader ( ) ; \nreturn parentClassLoader ; \n} \n} \n"}
{"7906": "public class JspRuntimeContext { \npublic void saveBytecode ( String className , String classFileName ) { \nbyte [ ] bytecode = getBytecode ( className ) ; \nif ( bytecode != null ) try { \nFileOutputStream fos = new FileOutputStream ( classFileName ) ; \nfos . write ( bytecode ) ; \nfos . close ( ) ; \n} \ncatch ( IOException ex ) { \ncontext . log ( \"Error in saving bytecode for \" + className + \" to \" + classFileName , ex ) ; \n} \n} \n} \n"}
{"7907": "public class JspRuntimeContext { \nprivate void checkCompile ( ) { \nfor ( JspServletWrapper jsw : jsps . values ( ) ) { \nif ( jsw . isTagFile ( ) ) continue ; \nJspCompilationContext ctxt = jsw . getJspEngineContext ( ) ; \nsynchronized ( jsw ) { \ntry { \nctxt . compile ( ) ; \n} \ncatch ( FileNotFoundException ex ) { \nctxt . incrementRemoved ( ) ; \n} \ncatch ( Throwable t ) { \njsw . getServletContext ( ) . log ( Localizer . getMessage ( \"jsp.error.background.compile\" ) , t ) ; \n} \n} \n} \n} \n} \n"}
{"7908": "public class JspRuntimeContext { \nprivate void initClassPath ( ) { \nStringBuilder cpath = new StringBuilder ( ) ; \nString sep = System . getProperty ( \"path.separator\" ) ; \ncpath . append ( options . getScratchDir ( ) + sep ) ; \nString cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; \nif ( cp == null || cp . equals ( \"\" ) ) cp = options . getClassPath ( ) ; \nif ( cp != null ) classpath = cpath . toString ( ) + cp ; \nif ( classpath != null ) try { \nclasspath = URLDecoder . decode ( classpath , \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nif ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , \"Exception decoding classpath : \" + classpath , e ) ; \n} \n} \n} \n"}
{"7909": "public class JspRuntimeContext { \nprotected void threadStart ( ) { \nif ( thread != null ) return ; \nthreadDone = false ; \nthread = new Thread ( this , threadName ) ; \nthread . setDaemon ( true ) ; \nthread . start ( ) ; \n} \n} \n"}
{"7910": "public class JspRuntimeContext { \nprotected void threadStop ( ) { \nif ( thread == null ) return ; \nthreadDone = true ; \nthread . interrupt ( ) ; \ntry { \nthread . join ( ) ; \n} \ncatch ( InterruptedException e ) { \n; \n} \nthread = null ; \n} \n} \n"}
{"7912": "public class ChannelServiceImpl { \nprivate Optional < ChannelInstance > findByName ( final String name ) { \nif ( name == null ) return empty ( ) ; \nfinal String id = this . manager . accessCall ( KEY_STORAGE , ChannelServiceAccess . class , channels -> { \nreturn channels . mapToId ( name ) ; \n} \n) ; \nreturn findById ( id ) ; \n} \n} \n"}
{"7913": "public class ChannelServiceImpl { \nprivate ChannelInstance findChannel ( final By by ) { \nfinal Optional < ChannelInstance > channel ; \ntry ( Locked l = lock ( this . readLock ) ) { \nchannel = find ( by ) ; \n} \nif ( ! channel . isPresent ( ) ) throw new ChannelNotFoundException ( by . toString ( ) ) ; \nreturn channel . get ( ) ; \n} \n} \n"}
{"7917": "public class Parser { \npublic static Node . Nodes parse ( ParserController pc , String path , JspReader reader , Node parent , boolean isTagFile , boolean directivesOnly , URL jarFileUrl , String pageEnc , String jspConfigPageEnc , boolean isDefaultPageEncoding , boolean hasBom ) throws JasperException { \nParser parser = new Parser ( pc , reader , isTagFile , directivesOnly , jarFileUrl , hasBom ) ; \nNode . Root root = new Node . Root ( reader . mark ( ) , parent , false ) ; \nroot . setPageEncoding ( pageEnc ) ; \nroot . setJspConfigPageEncoding ( jspConfigPageEnc ) ; \nroot . setIsDefaultPageEncoding ( isDefaultPageEncoding ) ; \nroot . setHasBom ( hasBom ) ; \nif ( hasBom ) { \nchar bomChar = ( char ) reader . nextChar ( ) ; \nif ( bomChar != 0xFEFF ) parser . err . jspError ( reader . mark ( ) , \"jsp.error.invalidBom\" , Integer . toHexString ( bomChar ) . toUpperCase ( ) ) ; \n} \nif ( directivesOnly ) { \nparser . parseTagFileDirectives ( root ) ; \nreturn new Node . Nodes ( root ) ; \n} \nPageInfo pageInfo = pc . getCompiler ( ) . getPageInfo ( ) ; \nif ( parent == null ) parser . addInclude ( root , pageInfo . getIncludePrelude ( ) ) ; \nwhile ( reader . hasMoreInput ( ) ) parser . parseElements ( root ) ; \nif ( parent == null ) { \nparser . addInclude ( root , pageInfo . getIncludeCoda ( ) ) ; \nparser . pageInfo . setRootPath ( path ) ; \n} \nNode . Nodes page = new Node . Nodes ( root ) ; \nreturn page ; \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nwhile ( i < size ) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) if ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \nelse if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \nelse if ( ch == '\\\\' && i + 1 < size ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni += 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7921": "public class Parser { \nprivate boolean parseJspAttributeAndBody ( Node parent , String tag , String bodyType ) throws JasperException { \nboolean result = false ; \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:attribute\" ) ) { \nparseNamedAttributes ( parent ) ; \nresult = true ; \n} \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:body\" ) ) { \nparseJspBody ( parent , bodyType ) ; \nreader . skipSpaces ( ) ; \nif ( ! reader . matchesETag ( tag ) ) err . jspError ( reader . mark ( ) , \"jsp.error.unterminated\" , \"&lt;\" + tag ) ; \nresult = true ; \n} \nelse if ( result && ! reader . matchesETag ( tag ) ) err . jspError ( reader . mark ( ) , \"jsp.error.jspbody.required\" , \"&lt;\" + tag ) ; \nreturn result ; \n} \n} \n"}
{"7927": "public class MavenCoordinates { \npublic MavenCoordinates toBase ( ) { \nif ( this . classifier == null && this . extension == null ) return this ; \nreturn new MavenCoordinates ( this . groupId , this . artifactId , this . version ) ; \n} \n} \n"}
{"7928": "public class JspContextWrapper { \nprivate String findAlias ( String varName ) { \nif ( aliases == null ) return varName ; \nString alias = aliases . get ( varName ) ; \nif ( alias == null ) return varName ; \nreturn alias ; \n} \n} \n"}
{"7930": "public class SystemLogHandler { \npublic static String unsetThread ( ) { \nByteArrayOutputStream baos = ( ByteArrayOutputStream ) data . get ( ) ; \nif ( baos == null ) return null ; \nstreams . set ( null ) ; \ndata . set ( null ) ; \nreturn baos . toString ( ) ; \n} \n} \n"}
{"7931": "public class SystemLogHandler { \nprotected PrintStream findStream ( ) { \nPrintStream ps = ( PrintStream ) streams . get ( ) ; \nif ( ps == null ) ps = wrapped ; \nreturn ps ; \n} \n} \n"}
{"7932": "public class RepoBuilder { \nprotected static void writeOptional ( final StringWriter writer , final String fieldName , final String value ) { \nif ( value != null ) write ( writer , fieldName , value ) ; \n} \n} \n"}
{"7936": "public class BodyContentImpl { \npublic void writeOut ( Writer out ) throws IOException { \nif ( writer == null ) out . write ( cb , 0 , nextChar ) ; \n} \n} \n"}
{"7937": "public class BodyContentImpl { \nvoid setWriter ( Writer writer ) { \nthis . writer = writer ; \nif ( writer != null ) if ( bufferSize != 0 ) { \nbufferSizeSave = bufferSize ; \nbufferSize = 0 ; \n} \nelse { \nbufferSize = bufferSizeSave ; \nclearBody ( ) ; \n} \n} \n} \n"}
{"7938": "public class BodyContentImpl { \nprivate void reAllocBuff ( int len ) { \nif ( bufferSize + len <= cb . length ) { \nbufferSize = cb . length ; \nreturn ; \n} \nif ( len < cb . length ) len = cb . length ; \nbufferSize = cb . length + len ; \nchar [ ] tmp = new char [ bufferSize ] ; \nSystem . arraycopy ( cb , 0 , tmp , 0 , cb . length ) ; \ncb = tmp ; \ntmp = null ; \n} \n} \n"}
{"7940": "public class StorageManager { \nprivate static State getSameParent ( final State parent , final MetaKey key ) { \nState current = parent ; \nwhile ( current != null ) { \nif ( current . key . equals ( key ) ) return current ; \ncurrent = current . parent ; \n} \nreturn null ; \n} \n} \n"}
{"7941": "public class StorageManager { \npublic StorageRegistration registerModel ( final long lockPriority , final MetaKey key , final StorageModelProvider < ? , ? > storageProvider ) throws ModelInitializationException { \nthis . modelLock . writeLock ( ) . lock ( ) ; \ntry { \ntestClosed ( ) ; \nif ( this . modelKeyMap . containsKey ( key ) ) throw new IllegalArgumentException ( String . format ( \"A provider for '%s' is already registered\" , key ) ) ; \ntry { \nstorageProvider . start ( this . context ) ; \n} \ncatch ( final Exception e ) { \nthrow new ModelInitializationException ( \"Failed to start model provider: \" + key , e ) ; \n} \nfinal long id = this . counter ++ ; \nfinal Entry entry = new Entry ( id , lockPriority , key , storageProvider ) ; \nthis . modelIdMap . put ( id , entry ) ; \nthis . modelKeyMap . put ( key , entry ) ; \nreturn new StorageRegistration ( ) { \n@ Override public void unregister ( ) { \nunregisterModel ( id ) ; \n} \n} \n; \n} \nfinally { \nthis . modelLock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"7943": "public class JobController { \n@ RequestMapping ( \"/{id}/monitor\" ) public ModelAndView monitor ( @ PathVariable ( \"id\" ) final String id ) { \nfinal JobHandle job = this . manager . getJob ( id ) ; \nif ( job != null ) logger . debug ( \"Job: {} - {}\" , job . getId ( ) , job . getState ( ) ) ; \nelse logger . debug ( \"No job: {}\" , id ) ; \nfinal Map < String , Object > model = new HashMap < > ( 1 ) ; \nmodel . put ( \"job\" , job ) ; \nreturn new ModelAndView ( \"monitor\" , model ) ; \n} \n} \n"}
{"7944": "public class AbstractChannelServiceServlet { \nprotected boolean isAuthenticated ( final By by , final HttpServletRequest request ) { \nfinal String [ ] authToks = parseAuthorization ( request ) ; \nif ( authToks == null ) return false ; \nfinal String deployKey = authToks [ 1 ] ; \nlogger . debug ( \"Deploy key: '{}'\" , deployKey ) ; \nfinal ChannelService service = getService ( request ) ; \nif ( service == null ) { \nlogger . info ( \"Called 'isAuthenticated' without service\" ) ; \nreturn false ; \n} \nreturn service . getChannelDeployKeyStrings ( by ) . orElse ( Collections . emptySet ( ) ) . contains ( deployKey ) ; \n} \n} \n"}
{"7946": "public class ChannelData { \npublic static Gson makeGson ( final boolean pretty ) { \nfinal GsonBuilder gb = new GsonBuilder ( ) ; \nif ( pretty ) gb . setPrettyPrinting ( ) ; \ngb . registerTypeAdapter ( Node . class , new NodeAdapter ( ) ) ; \ngb . registerTypeAdapter ( byte [ ] . class , new ByteArrayAdapter ( ) ) ; \nreturn gb . create ( ) ; \n} \n} \n"}
{"7948": "public class MetaKeys { \npublic static Map < MetaKey , String > union ( final Map < MetaKey , String > providedMetaData , final Map < MetaKey , String > extractedMetaData ) { \nfinal int size1 = providedMetaData != null ? providedMetaData . size ( ) : 0 ; \nfinal int size2 = extractedMetaData != null ? extractedMetaData . size ( ) : 0 ; \nif ( size1 + size2 == 0 ) return Collections . emptyMap ( ) ; \nfinal Map < MetaKey , String > result = new HashMap < > ( size1 + size2 ) ; \nif ( extractedMetaData != null ) result . putAll ( extractedMetaData ) ; \nif ( providedMetaData != null ) result . putAll ( providedMetaData ) ; \nreturn Collections . unmodifiableMap ( result ) ; \n} \n} \n"}
{"7949": "public class JspRuntimeLibrary { \npublic static Throwable getThrowable ( ServletRequest request ) { \nThrowable error = ( Throwable ) request . getAttribute ( SERVLET_EXCEPTION ) ; \nif ( error == null ) { \nerror = ( Throwable ) request . getAttribute ( JSP_EXCEPTION ) ; \nif ( error != null ) request . setAttribute ( SERVLET_EXCEPTION , error ) ; \n} \nreturn error ; \n} \n} \n"}
{"7950": "public class Uploader { \nprivate String isCheckSum ( final Coordinates c ) { \nfinal String cext = c . getExtension ( ) ; \nif ( cext == null ) return null ; \nfor ( final String ext : this . options . getChecksumExtensions ( ) ) { \nif ( cext . endsWith ( \".\" + ext ) ) return ext ; \n} \nreturn null ; \n} \n} \n"}
{"7952": "public class PageContextImpl { \npublic Exception getException ( ) { \nThrowable t = JspRuntimeLibrary . getThrowable ( request ) ; \nif ( ( t != null ) && ( ! ( t instanceof Exception ) ) ) t = new JspException ( t ) ; \nreturn ( Exception ) t ; \n} \n} \n"}
{"7953": "public class PageContextImpl { \npublic static Object evaluateExpression ( final String expression , final Class expectedType , final PageContext pageContext , final ProtectedFunctionMapper functionMap ) throws ELException { \nObject retValue ; \nif ( SecurityUtil . isPackageProtectionEnabled ( ) ) try { \nretValue = AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { \npublic Object run ( ) throws Exception { \nELContextImpl elContext = ( ELContextImpl ) pageContext . getELContext ( ) ; \nelContext . setFunctionMapper ( functionMap ) ; \nExpressionFactory expFactory = getExpressionFactory ( pageContext ) ; \nValueExpression expr = expFactory . createValueExpression ( elContext , expression , expectedType ) ; \nreturn expr . getValue ( elContext ) ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException ex ) { \nException realEx = ex . getException ( ) ; \nif ( realEx instanceof ELException ) throw ( ELException ) realEx ; \nelse throw new ELException ( realEx ) ; \n} \nelse { \nELContextImpl elContext = ( ELContextImpl ) pageContext . getELContext ( ) ; \nelContext . setFunctionMapper ( functionMap ) ; \nExpressionFactory expFactory = getExpressionFactory ( pageContext ) ; \nValueExpression expr = expFactory . createValueExpression ( elContext , expression , expectedType ) ; \nretValue = expr . getValue ( elContext ) ; \n} \nreturn retValue ; \n} \n} \n"}
{"7954": "public class SystemServiceImpl { \nprotected String makePrefixFromOsgiProperties ( ) { \nfinal String port = System . getProperty ( \"org.osgi.service.http.port\" ) ; \nif ( port == null ) return null ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"http://\" ) . append ( discoverHostname ( ) ) ; \nif ( ! \"80\" . equals ( port ) ) sb . append ( ':' ) . append ( port ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"7957": "public class TagFileProcessor { \nprivate Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { \nJspCompilationContext ctxt = compiler . getCompilationContext ( ) ; \nJspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; \nsynchronized ( rctxt ) { \nJspServletWrapper wrapper = ( JspServletWrapper ) rctxt . getWrapper ( tagFilePath ) ; \nif ( wrapper == null ) { \nwrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \nrctxt . addWrapper ( tagFilePath , wrapper ) ; \nwrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; \nwrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; \n} \nelse wrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; \nClass tagClazz ; \nint tripCount = wrapper . incTripCount ( ) ; \ntry { \nif ( tripCount > 0 ) { \nJspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \ntagClazz = tempWrapper . loadTagFilePrototype ( ) ; \ntempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; \n} \nelse tagClazz = wrapper . loadTagFile ( ) ; \n} \nfinally { \nwrapper . decTripCount ( ) ; \n} \ntry { \nObject tagIns = tagClazz . newInstance ( ) ; \nif ( tagIns instanceof JspSourceDependent ) for ( String dependant : ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) { \nparentPageInfo . addDependant ( dependant ) ; \n} \n} \ncatch ( Exception e ) { \n} \nreturn tagClazz ; \n} \n} \n} \n"}
{"7958": "public class TagFileProcessor { \npublic void removeProtoTypeFiles ( String classFileName ) { \nIterator < Compiler > iter = tempVector . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCompiler c = iter . next ( ) ; \nif ( classFileName == null ) c . removeGeneratedClassFiles ( ) ; \nelse if ( classFileName . equals ( c . getCompilationContext ( ) . getClassFileName ( ) ) ) { \nc . removeGeneratedClassFiles ( ) ; \ntempVector . remove ( c ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"7959": "public class JspC { \npublic static void main ( String arg [ ] ) { \nif ( arg . length == 0 ) System . out . println ( Localizer . getMessage ( \"jspc.usage\" ) ) ; \nelse { \nJspC jspc = new JspC ( ) ; \ntry { \njspc . setArgs ( arg ) ; \nif ( jspc . helpNeeded ) System . out . println ( Localizer . getMessage ( \"jspc.usage\" ) ) ; \nelse jspc . execute ( ) ; \n} \ncatch ( JasperException je ) { \nSystem . err . println ( je ) ; \nif ( jspc . getDieLevel ( ) != NO_DIE_LEVEL ) System . exit ( jspc . getDieLevel ( ) ) ; \n} \n} \n} \n} \n"}
{"7960": "public class JspC { \npublic void setUriroot ( String s ) { \nuriRoot = s ; \nif ( s != null ) try { \nuriRoot = new File ( s ) . getCanonicalPath ( ) ; \n} \ncatch ( Exception ex ) { \nuriRoot = s ; \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && i < files . length ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) dirs . push ( f2 . getPath ( ) ) ; \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) pages . add ( path ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7962": "public class JspC { \nprivate void locateUriRoot ( File f ) { \nString tUriBase = uriBase ; \nif ( tUriBase == null ) tUriBase = \"/\" ; \ntry { \nif ( f . exists ( ) ) { \nf = new File ( f . getCanonicalPath ( ) ) ; \nwhile ( f != null ) { \nFile g = new File ( f , \"WEB-INF\" ) ; \nif ( g . exists ( ) && g . isDirectory ( ) ) { \nuriRoot = f . getCanonicalPath ( ) ; \nuriBase = tUriBase ; \nif ( log . isLoggable ( Level . INFO ) ) log . info ( Localizer . getMessage ( \"jspc.implicit.uriRoot\" , uriRoot ) ) ; \nbreak ; \n} \nif ( f . exists ( ) && f . isDirectory ( ) ) tUriBase = \"/\" + f . getName ( ) + \"/\" + tUriBase ; \nString fParent = f . getParent ( ) ; \nif ( fParent == null ) break ; \nelse f = new File ( fParent ) ; \n} \nif ( uriRoot != null ) { \nFile froot = new File ( uriRoot ) ; \nuriRoot = froot . getCanonicalPath ( ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n"}
{"7963": "public class JspC { \nprivate ClassLoader initSystemClassLoader ( ) throws IOException { \nString sysClassPath = getSystemClassPath ( ) ; \nif ( sysClassPath == null ) return null ; \nArrayList < URL > urls = new ArrayList < URL > ( ) ; \nStringTokenizer tokenizer = new StringTokenizer ( sysClassPath , File . pathSeparator ) ; \nwhile ( tokenizer . hasMoreTokens ( ) ) urls . add ( new File ( tokenizer . nextToken ( ) ) . toURL ( ) ) ; \nif ( urls . size ( ) == 0 ) return null ; \nURL urlsArray [ ] = new URL [ urls . size ( ) ] ; \nurls . toArray ( urlsArray ) ; \nreturn new URLClassLoader ( urlsArray , this . getClass ( ) . getClassLoader ( ) ) ; \n} \n} \n"}
{"7966": "public class JspReader { \nboolean matchesOptionalSpacesFollowedBy ( String s ) throws JasperException { \nMark mark = mark ( ) ; \nskipSpaces ( ) ; \nboolean result = matches ( s ) ; \nif ( ! result ) reset ( mark ) ; \nreturn result ; \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , ch = nextChar ( ) ) if ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) if ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse { \nreset ( restart ) ; \ncontinue skip ; \n} \nreturn ret ; \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) if ( ch == '\\\\' && prev == '\\\\' ) ch = 0 ; \nelse if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) if ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse continue skip ; \nreturn ret ; \n} \nreturn null ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) return \"\" ; \nint ch = peekChar ( ) ; \nif ( quoted ) if ( ch == '\"' || ch == '\\'' ) { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \nfor ( ch = nextChar ( ) ; \nch != - 1 && ch != endQuote ; \nch = nextChar ( ) ) { \nif ( ch == '\\\\' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \n} \nif ( ch == - 1 ) err . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \nelse err . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \nelse if ( ! isDelimiter ( ) ) do { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) if ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"7971": "public class JspReader { \nprivate boolean popFile ( ) throws JasperException { \nif ( current == null || currFileId < 0 ) return false ; \nString fName = getFile ( currFileId ) ; \ncurrFileId = unregisterSourceFile ( fName ) ; \nif ( currFileId < - 1 ) err . jspError ( \"jsp.error.file.not.registered\" , fName ) ; \nMark previous = current . popStream ( ) ; \nif ( previous != null ) { \nmaster = current . baseDir ; \ncurrent = previous ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7972": "public class Coordinates { \npublic Coordinates makeUnclassified ( ) { \nif ( this . classifier == null ) return this ; \nreturn new Coordinates ( this . groupId , this . artifactId , this . version , this . qualifiedVersion , null , this . extension ) ; \n} \n} \n"}
{"7973": "public class AspectInformation { \npublic static List < AspectInformation > filterIds ( final List < AspectInformation > list , final Predicate < String > predicate ) { \nif ( list == null ) return null ; \nreturn list . stream ( ) . filter ( ( i ) -> predicate . test ( i . getFactoryId ( ) ) ) . collect ( Collectors . toList ( ) ) ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nelse { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \ni < CACHED_SCHEMA_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) CACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nelse { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \ni < CACHED_DTD_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) CACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n"}
{"7977": "public class ParserUtils { \nprivate static String uencode ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nStringTokenizer tokens = new StringTokenizer ( prefix , \"/\\\\:\" , true ) ; \nStringBuilder stringBuilder = new StringBuilder ( ) ; \nwhile ( tokens . hasMoreElements ( ) ) { \nString token = tokens . nextToken ( ) ; \nif ( \"/\" . equals ( token ) || \"\\\\\" . equals ( token ) || \":\" . equals ( token ) ) stringBuilder . append ( token ) ; \nelse try { \nstringBuilder . append ( URLEncoder . encode ( token , \"UTF-8\" ) ) ; \n} \ncatch ( java . io . UnsupportedEncodingException ex ) { \n} \n} \nreturn stringBuilder . toString ( ) ; \n} \nelse return prefix ; \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) continue ; \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; \n} \n} \nelse TreeNode treeChild = convert ( treeNode , child ) ; \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7979": "public class BindingManager { \nprivate static void mergeErrors ( final BindingResult bindingResult , final BindingResult result ) { \nif ( bindingResult == null ) return ; \nresult . addErrors ( bindingResult . getLocalErrors ( ) ) ; \nfor ( final Map . Entry < String , BindingResult > child : bindingResult . getChildren ( ) . entrySet ( ) ) { \nmergeErrors ( child . getValue ( ) , result . getChildOrAdd ( child . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"7980": "public class BindingManager { \nprivate void initializeBinder ( final Binder binder ) { \nfor ( final Method m : binder . getClass ( ) . getMethods ( ) ) { \nif ( ! m . isAnnotationPresent ( Binder . Initializer . class ) ) continue ; \nfinal Call call = bind ( m , binder ) ; \ntry { \ncall . invoke ( ) ; \n} \ncatch ( final Exception e ) { \nthrow new RuntimeException ( String . format ( \"Failed to initialze binder: %s # %s\" , binder , m ) , e ) ; \n} \n} \n} \n} \n"}
{"7981": "public class ChannelAspectProcessor { \npublic static Map < String , ChannelAspectInformation > scanAspectInformations ( final BundleContext context ) { \nCollection < ServiceReference < ChannelAspectFactory > > refs ; \ntry { \nrefs = context . getServiceReferences ( ChannelAspectFactory . class , null ) ; \n} \ncatch ( final InvalidSyntaxException e ) { \nreturn Collections . emptyMap ( ) ; \n} \nif ( refs == null ) return Collections . emptyMap ( ) ; \nfinal Map < String , ChannelAspectInformation > result = new HashMap < > ( refs . size ( ) ) ; \nfor ( final ServiceReference < ChannelAspectFactory > ref : refs ) { \nfinal ChannelAspectInformation info = makeInformation ( ref ) ; \nresult . put ( info . getFactoryId ( ) , info ) ; \n} \nreturn result ; \n} \n} \n"}
{"7983": "public class TagPluginManager { \nprivate void invokePlugin ( Node . CustomTag n ) { \nTagPlugin tagPlugin = tagPlugins . get ( n . getTagHandlerClass ( ) . getName ( ) ) ; \nif ( tagPlugin == null ) return ; \nTagPluginContext tagPluginContext = new TagPluginContextImpl ( n , pageInfo ) ; \nn . setTagPluginContext ( tagPluginContext ) ; \ntagPlugin . doTag ( tagPluginContext ) ; \n} \n} \n"}
{"7986": "public class AetherImporter { \npublic static AetherResult asResult ( final Collection < ArtifactResult > results , final ImportConfiguration cfg , final Optional < DependencyResult > dependencyResult ) { \nfinal AetherResult result = new AetherResult ( ) ; \nfinal Set < String > requested = new HashSet < > ( cfg . getCoordinates ( ) . size ( ) ) ; \nfor ( final MavenCoordinates mc : cfg . getCoordinates ( ) ) { \nrequested . add ( mc . toString ( ) ) ; \n} \nfinal Map < String , Boolean > optionalDeps = new HashMap < > ( ) ; \nfillOptionalDependenciesMap ( dependencyResult , optionalDeps ) ; \nfor ( final ArtifactResult ar : results ) { \nfinal AetherResult . Entry entry = new AetherResult . Entry ( ) ; \nfinal MavenCoordinates coordinates = MavenCoordinates . fromResult ( ar ) ; \nfinal String key = coordinates . toBase ( ) . toString ( ) ; \nentry . setCoordinates ( coordinates ) ; \nentry . setResolved ( ar . isResolved ( ) ) ; \nentry . setRequested ( requested . contains ( key ) ) ; \nentry . setOptional ( optionalDeps . getOrDefault ( key , Boolean . FALSE ) ) ; \nif ( ar . getExceptions ( ) != null && ! ar . getExceptions ( ) . isEmpty ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ar . getExceptions ( ) . get ( 0 ) . getMessage ( ) ) ; \nif ( ar . getExceptions ( ) . size ( ) > 1 ) sb . append ( \" ...\" ) ; \nentry . setError ( sb . toString ( ) ) ; \n} \nresult . getArtifacts ( ) . add ( entry ) ; \n} \nCollections . sort ( result . getArtifacts ( ) , Comparator . comparing ( AetherResult . Entry :: getCoordinates ) ) ; \nresult . setRepositoryUrl ( cfg . getRepositoryUrl ( ) ) ; \nreturn result ; \n} \n} \n"}
{"7987": "public class TagLibraryInfoImpl { \nprivate InputStream getResourceAsStream ( String uri ) throws JasperException { \ntry { \nString real = ctxt . getRealPath ( uri ) ; \nif ( real == null ) return ctxt . getResourceAsStream ( uri ) ; \nelse return new FileInputStream ( real ) ; \n} \ncatch ( FileNotFoundException ex ) { \nreturn ctxt . getResourceAsStream ( uri ) ; \n} \n} \n} \n"}
{"7988": "public class TagLibraryInfoImpl { \npublic ValidationMessage [ ] validate ( PageData thePage ) { \nTagLibraryValidator tlv = getTagLibraryValidator ( ) ; \nif ( tlv == null ) return null ; \nString uri = getURI ( ) ; \nif ( uri . startsWith ( \"/\" ) ) uri = URN_JSPTLD + uri ; \nValidationMessage [ ] messages = tlv . validate ( getPrefixString ( ) , uri , thePage ) ; \ntlv . release ( ) ; \nreturn messages ; \n} \n} \n"}
{"7991": "public class XMLEncodingDetector { \nprivate void scanXMLDecl ( ) throws IOException , JasperException { \nif ( skipString ( \"<?xml\" ) ) { \nfMarkupDepth ++ ; \nif ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . clear ( ) ; \nfStringBuffer . append ( \"xml\" ) ; \nwhile ( XMLChar . isName ( peekChar ( ) ) ) fStringBuffer . append ( ( char ) scanChar ( ) ) ; \nString target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; \nscanPIData ( target , fString ) ; \n} \nelse scanXMLDeclOrTextDecl ( false ) ; \n} \n} \n} \n"}
{"7994": "public class JspCServletContext { \npublic URL getResource ( String path ) throws MalformedURLException { \nif ( ! path . startsWith ( \"/\" ) ) throw new MalformedURLException ( \"Path '\" + path + \"' does not start with '/'\" ) ; \nURL url = new URL ( myResourceBaseURL , path . substring ( 1 ) ) ; \nInputStream is = null ; \ntry { \nis = url . openStream ( ) ; \n} \ncatch ( Throwable t ) { \nurl = null ; \n} \nfinally { \nif ( is != null ) try { \nis . close ( ) ; \n} \ncatch ( Throwable t2 ) { \n} \n} \nreturn url ; \n} \n} \n"}
{"8008": "public class LZEncoder { \nint movePos ( int requiredForFlushing , int requiredForFinishing ) { \nassert requiredForFlushing >= requiredForFinishing ; \n++ readPos ; \nint avail = writePos - readPos ; \nif ( avail < requiredForFlushing ) if ( avail < requiredForFinishing || ! finishing ) { \n++ pendingSize ; \navail = 0 ; \n} \nreturn avail ; \n} \n} \n"}
{"8012": "public class JspWriterImpl { \npublic void flush ( ) throws IOException { \nflushBuffer ( ) ; \nif ( out != null ) out . flush ( ) ; \nelse { \nresponse . setCharacterEncoding ( response . getCharacterEncoding ( ) ) ; \nresponse . flushBuffer ( ) ; \n} \n} \n} \n"}
{"8015": "public class JspWriterImpl { \nprivate void allocateCharBuffer ( ) { \nif ( bufferSize == 0 ) return ; \nif ( bufferSize > MAX_BUFFER_SIZE ) buf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; \nelse buf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; \n} \n} \n"}
{"8017": "public class Aggregator { \npublic List < String > makeKey ( final Map < MetaKey , String > metaData , final boolean requireAll ) { \nfinal List < String > result = new ArrayList < > ( this . fields . size ( ) ) ; \nfor ( final MetaKey field : this . fields ) { \nfinal String value = metaData . get ( field ) ; \nif ( requireAll && value == null ) return null ; \nresult . add ( value ) ; \n} \nreturn result ; \n} \n} \n"}
{"8018": "public class Compiler { \nprivate void generateClass ( ) throws FileNotFoundException , JasperException , Exception { \nlong t1 = 0 ; \nif ( log . isLoggable ( Level . FINE ) ) t1 = System . currentTimeMillis ( ) ; \nString javaFileName = ctxt . getServletJavaFileName ( ) ; \nsetJavaCompilerOptions ( ) ; \nJavacErrorDetail [ ] javacErrors = javaCompiler . compile ( ctxt . getFullClassName ( ) , pageNodes ) ; \nif ( javacErrors != null ) { \njavaCompiler . doJavaFile ( true ) ; \nlog . severe ( \"Error compiling file: \" + javaFileName ) ; \nerrDispatcher . javacError ( javacErrors ) ; \n} \nif ( log . isLoggable ( Level . FINE ) ) { \nlong t2 = System . currentTimeMillis ( ) ; \nlog . fine ( \"Compiled \" + javaFileName + \" \" + ( t2 - t1 ) + \"ms\" ) ; \n} \njavaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \nif ( ! ctxt . isPrototypeMode ( ) && ! options . isSmapSuppressed ( ) ) smapUtil . installSmap ( ) ; \nif ( jsw != null && jsw . getServletClassLastModifiedTime ( ) <= 0 ) jsw . setServletClassLastModifiedTime ( javaCompiler . getClassLastModified ( ) ) ; \nif ( options . getSaveBytecode ( ) ) javaCompiler . saveClassFile ( ctxt . getFullClassName ( ) , ctxt . getClassFileName ( ) ) ; \nctxt . getRuntimeContext ( ) . adjustBytecodeTime ( ctxt . getFullClassName ( ) , jspModTime ) ; \n} \n} \n"}
{"8019": "public class Compiler { \npublic void compile ( boolean compileClass ) throws FileNotFoundException , JasperException , Exception { \ntry { \nctxt . makeOutputDir ( ctxt . getOutputDir ( ) ) ; \nif ( errDispatcher == null ) errDispatcher = new ErrorDispatcher ( jspcMode ) ; \ngenerateJava ( ) ; \nif ( compileClass ) generateClass ( ) ; \nelse javaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \n} \nfinally { \nif ( tfp != null ) tfp . removeProtoTypeFiles ( null ) ; \njavaCompiler . release ( ) ; \ntfp = null ; \nerrDispatcher = null ; \nif ( ! jspcMode ) pageInfo = null ; \npageNodes = null ; \nif ( ctxt . getWriter ( ) != null ) { \nctxt . getWriter ( ) . close ( ) ; \nctxt . setWriter ( null ) ; \n} \n} \n} \n} \n"}
{"8021": "public class Compiler { \nprivate void initJavaCompiler ( ) throws JasperException { \nboolean disablejsr199 = Boolean . TRUE . toString ( ) . equals ( System . getProperty ( \"org.apache.jasper.compiler.disablejsr199\" ) ) ; \nDouble version = Double . valueOf ( System . getProperty ( \"java.specification.version\" ) ) ; \nif ( ! disablejsr199 && ( version >= 1.6 || getClassFor ( \"javax.tools.Tool\" ) != null ) ) javaCompiler = new Jsr199JavaCompiler ( ) ; \nelse { \nClass c = getClassFor ( \"org.eclipse.jdt.internal.compiler.Compiler\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.JDTJavaCompiler\" ) ; \nif ( c != null ) try { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \nif ( javaCompiler == null ) { \nClass c = getClassFor ( \"org.apache.tools.ant.taskdefs.Javac\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.AntJavaCompiler\" ) ; \nif ( c != null ) try { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \nif ( javaCompiler == null ) errDispatcher . jspError ( \"jsp.error.nojavac\" ) ; \njavaCompiler . init ( ctxt , errDispatcher , jspcMode ) ; \n} \n} \n"}
{"8022": "public class Compiler { \nprivate boolean systemJarInWebinf ( String path ) { \nif ( path . indexOf ( \"/WEB-INF/\" ) < 0 ) return false ; \nBoolean useMyFaces = ( Boolean ) ctxt . getServletContext ( ) . getAttribute ( \"com.sun.faces.useMyFaces\" ) ; \nif ( useMyFaces == null || ! useMyFaces ) for ( String jar : systemJsfJars ) { \nif ( path . indexOf ( jar ) > 0 ) return true ; \n} \nfor ( String jar : systemJars ) { \nif ( path . indexOf ( jar ) > 0 ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"8024": "public class Generator { \nprivate void generateDeclarations ( Node . Nodes page ) throws JasperException { \nclass DeclarationVisitor extends Node . Visitor { \nprivate boolean getServletInfoGenerated = false ; \npublic void visit ( Node . PageDirective n ) throws JasperException { \nif ( getServletInfoGenerated ) return ; \nString info = n . getAttributeValue ( \"info\" ) ; \nif ( info == null ) return ; \ngetServletInfoGenerated = true ; \nout . printil ( \"public String getServletInfo() {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return \" ) ; \nout . print ( quote ( info ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \npublic void visit ( Node . Declaration n ) throws JasperException { \nn . setBeginJavaLine ( out . getJavaLine ( ) ) ; \nout . printMultiLn ( n . getText ( ) ) ; \nout . println ( ) ; \nn . setEndJavaLine ( out . getJavaLine ( ) ) ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( n . useTagPlugin ( ) ) { \nif ( n . getAtSTag ( ) != null ) n . getAtSTag ( ) . visit ( this ) ; \nvisitBody ( n ) ; \nif ( n . getAtETag ( ) != null ) n . getAtETag ( ) . visit ( this ) ; \n} \nelse visitBody ( n ) ; \n} \n} \nout . println ( ) ; \npage . visit ( new DeclarationVisitor ( ) ) ; \n} \n} \n"}
{"8025": "public class Generator { \nprivate void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { \nclass TagHandlerPoolVisitor extends Node . Visitor { \nprivate Set < String > names = new HashSet < String > ( ) ; \nTagHandlerPoolVisitor ( Set < String > v ) { \nnames = v ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! n . implementsSimpleTag ( ) ) { \nString name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; \nn . setTagHandlerPoolName ( name ) ; \nif ( ! names . contains ( name ) ) names . add ( name ) ; \n} \nvisitBody ( n ) ; \n} \nprivate String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { \nString poolName = null ; \npoolName = \"_jspx_tagPool_\" + prefix + \"_\" + shortName ; \nif ( attrs != null ) { \nString [ ] attrNames = new String [ attrs . getLength ( ) ] ; \nfor ( int i = 0 ; \ni < attrNames . length ; \ni ++ ) attrNames [ i ] = attrs . getQName ( i ) ; \nArrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; \nfor ( int i = 0 ; \ni < attrNames . length ; \ni ++ ) poolName = poolName + \"_\" + attrNames [ i ] ; \n} \nif ( hasEmptyBody ) poolName = poolName + \"_nobody\" ; \nreturn JspUtil . makeXmlJavaIdentifier ( poolName ) ; \n} \n} \npage . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; \n} \n} \n"}
{"8026": "public class Generator { \nprivate void generateXmlProlog ( Node . Nodes page ) { \nString omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; \nif ( ( omitXmlDecl != null && ! JspUtil . booleanValue ( omitXmlDecl ) ) || ( omitXmlDecl == null && page . getRoot ( ) . isXmlSyntax ( ) && ! pageInfo . hasJspRoot ( ) && ! ctxt . isTagFile ( ) ) ) { \nString cType = pageInfo . getContentType ( ) ; \nString charSet = cType . substring ( cType . indexOf ( \"charset=\" ) + 8 ) ; \nout . printil ( \"out.write(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"\" + charSet + \"\\\\\\\"?>\\\\n\\\");\" ) ; \n} \nString doctypeName = pageInfo . getDoctypeName ( ) ; \nif ( doctypeName != null ) { \nString doctypePublic = pageInfo . getDoctypePublic ( ) ; \nString doctypeSystem = pageInfo . getDoctypeSystem ( ) ; \nout . printin ( \"out.write(\\\"<!DOCTYPE \" ) ; \nout . print ( doctypeName ) ; \nif ( doctypePublic == null ) out . print ( \" SYSTEM \\\\\\\"\" ) ; \nelse { \nout . print ( \" PUBLIC \\\\\\\"\" ) ; \nout . print ( doctypePublic ) ; \nout . print ( \"\\\\\\\" \\\\\\\"\" ) ; \n} \nout . print ( doctypeSystem ) ; \nout . println ( \"\\\\\\\">\\\\n\\\");\" ) ; \n} \n} \n} \n"}
{"8027": "public class Generator { \nprivate void genCommonPostamble ( ) { \nfor ( int i = 0 ; \ni < methodsBuffered . size ( ) ; \ni ++ ) { \nGenBuffer methodBuffer = methodsBuffered . get ( i ) ; \nmethodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( methodBuffer . toString ( ) ) ; \n} \nif ( fragmentHelperClass . isUsed ( ) ) { \nfragmentHelperClass . generatePostamble ( ) ; \nfragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( fragmentHelperClass . toString ( ) ) ; \n} \nif ( arrayBuffer != null ) out . printMultiLn ( arrayBuffer . toString ( ) ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \n} \n} \n"}
{"8029": "public class Generator { \npublic static void generate ( ServletWriter out , Compiler compiler , Node . Nodes page ) throws JasperException { \nGenerator gen = new Generator ( out , compiler ) ; \nif ( gen . isPoolingEnabled ) gen . compileTagHandlerPoolList ( page ) ; \nif ( gen . ctxt . isTagFile ( ) ) { \nJasperTagInfo tagInfo = ( JasperTagInfo ) gen . ctxt . getTagInfo ( ) ; \ngen . generateTagHandlerPreamble ( tagInfo , page ) ; \nif ( gen . ctxt . isPrototypeMode ( ) ) return ; \ngen . generateXmlProlog ( page ) ; \ngen . fragmentHelperClass . generatePreamble ( ) ; \npage . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; \ngen . generateTagHandlerPostamble ( tagInfo ) ; \n} \nelse { \ngen . generatePreamble ( page ) ; \ngen . generateXmlProlog ( page ) ; \ngen . fragmentHelperClass . generatePreamble ( ) ; \npage . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; \ngen . generatePostamble ( page ) ; \n} \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) out . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) out . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \n} \nout . println ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) out . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) out . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \n} \n} \n"}
{"8031": "public class TransferServiceImpl { \nprivate Map < MetaKey , String > readProperties ( final InputStream stream ) throws IOException { \ntry { \nfinal Document doc = this . xmlToolsFactory . newDocumentBuilder ( ) . parse ( new FilterInputStream ( stream ) { \n@ Override public void close ( ) { \n} \n} \n) ; \nfinal Element root = doc . getDocumentElement ( ) ; \nif ( ! \"properties\" . equals ( root . getNodeName ( ) ) ) throw new IllegalStateException ( String . format ( \"Root element must be of type '%s'\" , \"properties\" ) ) ; \nfinal Map < MetaKey , String > result = new HashMap < > ( ) ; \nfor ( final Element ele : XmlHelper . iterElement ( root , \"property\" ) ) { \nfinal String namespace = ele . getAttribute ( \"namespace\" ) ; \nfinal String key = ele . getAttribute ( \"key\" ) ; \nfinal String value = ele . getTextContent ( ) ; \nif ( namespace . isEmpty ( ) || key . isEmpty ( ) ) continue ; \nresult . put ( new MetaKey ( namespace , key ) , value ) ; \n} \nreturn result ; \n} \ncatch ( final Exception e ) { \nthrow new IOException ( \"Failed to read properties\" , e ) ; \n} \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) errMsg = new StringBuilder ( ) ; \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( int i = 0 ; \ni < errors . length ; \ni ++ ) if ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \nif ( errMsg != null ) errDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n"}
{"8034": "public class TagHandlerPool { \npublic < T extends JspTag > JspTag get ( Class < T > handlerClass ) throws JspException { \nsynchronized ( this ) { \nif ( current >= 0 ) return handlers [ current -- ] ; \n} \nJspTag tagHandler = null ; \ntry { \nif ( resourceInjector != null ) tagHandler = resourceInjector . createTagHandlerInstance ( handlerClass ) ; \nelse tagHandler = handlerClass . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new JspException ( e . getMessage ( ) , e ) ; \n} \nreturn tagHandler ; \n} \n} \n"}
{"8035": "public class ELParser { \npublic static ELNode . Nodes parse ( String expression ) { \nELParser parser = new ELParser ( expression ) ; \nwhile ( parser . hasNextChar ( ) ) { \nString text = parser . skipUntilEL ( ) ; \nif ( text . length ( ) > 0 ) parser . expr . add ( new ELNode . Text ( text ) ) ; \nELNode . Nodes elexpr = parser . parseEL ( ) ; \nif ( ! elexpr . isEmpty ( ) ) parser . expr . add ( new ELNode . Root ( elexpr , parser . isDollarExpr ) ) ; \n} \nreturn parser . expr ; \n} \n} \n"}
{"8036": "public class JspConfig { \nprivate JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { \nif ( prev == null ) return curr ; \nif ( prev . getExtension ( ) == null ) return prev ; \nif ( curr . getExtension ( ) == null ) return curr ; \nString prevPath = prev . getPath ( ) ; \nString currPath = curr . getPath ( ) ; \nif ( prevPath == null && currPath == null ) return prev ; \nif ( prevPath == null && currPath != null ) return curr ; \nif ( prevPath != null && currPath == null ) return prev ; \nif ( prevPath . length ( ) >= currPath . length ( ) ) return prev ; \nreturn curr ; \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) return false ; \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) uriPath = uri . substring ( 0 , index + 1 ) ; \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) uriExtension = uri . substring ( index + 1 ) ; \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) if ( uri . equals ( path ) ) return true ; \nelse if ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"8042": "public class JspUtil { \npublic static String getExprInXml ( String expression ) { \nString returnString ; \nint length = expression . length ( ) ; \nif ( expression . startsWith ( OPEN_EXPR ) && expression . endsWith ( CLOSE_EXPR ) ) returnString = expression . substring ( 1 , length - 1 ) ; \nelse returnString = expression ; \nreturn escapeXml ( returnString ) ; \n} \n} \n"}
{"8043": "public class JspUtil { \npublic static void checkScope ( String scope , Node n , ErrorDispatcher err ) throws JasperException { \nif ( scope != null && ! scope . equals ( \"page\" ) && ! scope . equals ( \"request\" ) && ! scope . equals ( \"session\" ) && ! scope . equals ( \"application\" ) ) err . jspError ( n , \"jsp.error.invalid.scope\" , scope ) ; \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) sb . append ( \"&lt;\" ) ; \nelse if ( c == '>' ) sb . append ( \"&gt;\" ) ; \nelse if ( c == '\\'' ) sb . append ( \"&apos;\" ) ; \nelse if ( c == '&' ) sb . append ( \"&amp;\" ) ; \nelse if ( c == '\"' ) sb . append ( \"&quot;\" ) ; \nelse sb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8046": "public class JspUtil { \npublic static String getTagHandlerClassName ( String path , ErrorDispatcher err ) throws JasperException { \nString className = null ; \nint begin = 0 ; \nint index ; \nindex = path . lastIndexOf ( \".tag\" ) ; \nif ( index == - 1 ) err . jspError ( \"jsp.error.tagfile.badSuffix\" , path ) ; \nindex = path . indexOf ( WEB_INF_TAGS ) ; \nif ( index != - 1 ) { \nclassName = \"org.apache.jsp.tag.web.\" ; \nbegin = index + WEB_INF_TAGS . length ( ) ; \n} \nelse { \nindex = path . indexOf ( META_INF_TAGS ) ; \nif ( index != - 1 ) { \nclassName = \"org.apache.jsp.tag.meta.\" ; \nbegin = index + META_INF_TAGS . length ( ) ; \n} \nelse err . jspError ( \"jsp.error.tagfile.illegalPath\" , path ) ; \n} \nclassName += makeJavaPackage ( path . substring ( begin ) ) ; \nreturn className ; \n} \n} \n"}
{"8047": "public class JspUtil { \npublic static final String makeJavaPackage ( String path ) { \nString classNameComponents [ ] = split ( path , \"/\" ) ; \nStringBuilder legalClassNames = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < classNameComponents . length ; \ni ++ ) { \nlegalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; \nif ( i < classNameComponents . length - 1 ) legalClassNames . append ( '.' ) ; \n} \nreturn legalClassNames . toString ( ) ; \n} \n} \n"}
{"8048": "public class JspUtil { \nprivate static final String [ ] split ( String path , String pat ) { \nArrayList < String > comps = new ArrayList < String > ( ) ; \nint pos = path . indexOf ( pat ) ; \nint start = 0 ; \nwhile ( pos >= 0 ) { \nif ( pos > start ) { \nString comp = path . substring ( start , pos ) ; \ncomps . add ( comp ) ; \n} \nstart = pos + pat . length ( ) ; \npos = path . indexOf ( pat , start ) ; \n} \nif ( start < path . length ( ) ) comps . add ( path . substring ( start ) ) ; \nString [ ] result = new String [ comps . size ( ) ] ; \nfor ( int i = 0 ; \ni < comps . size ( ) ; \ni ++ ) result [ i ] = comps . get ( i ) ; \nreturn result ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) modifiedIdentifier . append ( '_' ) ; \nfor ( int i = 0 ; \ni < identifier . length ( ) ; \ni ++ ) { \nchar ch = identifier . charAt ( i ) ; \nif ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) modifiedIdentifier . append ( ch ) ; \nelse if ( ch == '.' ) modifiedIdentifier . append ( '_' ) ; \nelse modifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) modifiedIdentifier . append ( '_' ) ; \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8051": "public class JspUtil { \npublic static boolean isJavaKeyword ( String key ) { \nint i = 0 ; \nint j = javaKeywords . length ; \nwhile ( i < j ) { \nint k = ( i + j ) / 2 ; \nint result = javaKeywords [ k ] . compareTo ( key ) ; \nif ( result == 0 ) return true ; \nif ( result < 0 ) i = k + 1 ; \nelse j = k ; \n} \nreturn false ; \n} \n} \n"}
{"8052": "public class InstallableUnit { \nprivate static void addProperty ( final Map < String , String > props , final String key , final String value ) { \nif ( value == null ) return ; \nprops . put ( key , value ) ; \n} \n} \n"}
{"8053": "public class Functions { \npublic static String modifier ( final String prefix , final Modifier modifier ) { \nif ( modifier == null ) return \"\" ; \nString value = null ; \nswitch ( modifier ) { \ncase DEFAULT : value = \"default\" ; \nbreak ; \ncase PRIMARY : value = \"primary\" ; \nbreak ; \ncase SUCCESS : value = \"success\" ; \nbreak ; \ncase INFO : value = \"info\" ; \nbreak ; \ncase WARNING : value = \"warning\" ; \nbreak ; \ncase DANGER : value = \"danger\" ; \nbreak ; \ncase LINK : value = \"link\" ; \nbreak ; \n} \nif ( value != null && prefix != null ) return prefix + value ; \nelse return value != null ? value : \"\" ; \n} \n} \n"}
{"8054": "public class Functions { \npublic static SortedSet < String > metadata ( final Map < MetaKey , String > metadata , String namespace , String key ) { \nfinal SortedSet < String > result = new TreeSet < > ( ) ; \nif ( namespace . isEmpty ( ) ) namespace = null ; \nif ( key . isEmpty ( ) ) key = null ; \nfor ( final Map . Entry < MetaKey , String > entry : metadata . entrySet ( ) ) { \nif ( namespace != null && ! namespace . equals ( entry . getKey ( ) . getNamespace ( ) ) ) continue ; \nif ( key != null && ! key . equals ( entry . getKey ( ) . getKey ( ) ) ) continue ; \nresult . add ( entry . getValue ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"8055": "public class DatabaseUserService { \n@ Override public void run ( ) throws Exception { \nthis . storageManager . modifyRun ( MODEL_KEY , UserWriteModel . class , users -> { \nfinal Date timeout = new Date ( System . currentTimeMillis ( ) - getTimeout ( ) ) ; \nfinal Collection < UserEntity > updates = new LinkedList < > ( ) ; \nfinal Collection < String > removals = new LinkedList < > ( ) ; \nfor ( final UserEntity user : users . asCollection ( ) ) { \nif ( user . getEmailTokenDate ( ) == null || user . getEmailTokenDate ( ) . after ( timeout ) ) continue ; \nif ( user . isEmailVerified ( ) ) { \nuser . setEmailToken ( null ) ; \nuser . setEmailTokenDate ( null ) ; \nuser . setEmailTokenSalt ( null ) ; \nupdates . add ( user ) ; \n} \nelse removals . add ( user . getId ( ) ) ; \n} \nupdates . forEach ( users :: putUser ) ; \nremovals . forEach ( users :: removeUser ) ; \n} \n) ; \n} \n} \n"}
{"8056": "public class FileNames { \npublic static String getBasename ( final String name ) { \nif ( name == null ) return null ; \nfinal String [ ] toks = name . split ( \"/\" ) ; \nif ( toks . length < 1 ) return name ; \nreturn toks [ toks . length - 1 ] ; \n} \n} \n"}
{"8057": "public class MetadataCache { \npublic boolean put ( Locator locator , String key , String value ) throws CacheException { \nif ( value == null ) return false ; \nTimer . Context cachePutTimerContext = MetadataCache . cachePutTimer . time ( ) ; \nboolean dbWrite = false ; \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nString oldValue = cache . getIfPresent ( cacheKey ) ; \ncache . put ( cacheKey , value ) ; \nif ( oldValue == null || ! oldValue . equals ( value ) ) dbWrite = true ; \nif ( dbWrite ) { \nupdatedMetricMeter . mark ( ) ; \nif ( ! batchedWrites ) databasePut ( locator , key , value ) ; \nelse databaseLazyWrite ( locator , key ) ; \n} \nreturn dbWrite ; \n} \nfinally { \ncachePutTimerContext . stop ( ) ; \n} \n} \n} \n"}
{"8060": "public class PreaggregateConversions { \npublic static Number resolveNumber ( Number n ) { \nif ( n instanceof LazilyParsedNumber ) try { \nreturn n . longValue ( ) ; \n} \ncatch ( NumberFormatException ex ) { \nreturn n . doubleValue ( ) ; \n} \nelse return n ; \n} \n} \n"}
{"8070": "public class ScheduleContext { \nvoid scheduleEligibleSlots ( long maxAgeMillis , long rollupDelayForMetricsWithShortDelay , long rollupWaitForMetricsWithLongDelay ) { \nlong now = scheduleTime ; \nArrayList < Integer > shardKeys = new ArrayList < Integer > ( shardStateManager . getManagedShards ( ) ) ; \nCollections . shuffle ( shardKeys ) ; \nfor ( int shard : shardKeys ) { \nfor ( Granularity g : Granularity . rollupGranularities ( ) ) { \nsynchronized ( scheduledSlots ) { \nsynchronized ( runningSlots ) { \nList < Integer > slotsToWorkOn = shardStateManager . getSlotStateManager ( shard , g ) . getSlotsEligibleForRollup ( now , maxAgeMillis , rollupDelayForMetricsWithShortDelay , rollupWaitForMetricsWithLongDelay ) ; \nif ( slotsToWorkOn . size ( ) == 0 ) continue ; \nif ( ! canWorkOnShard ( shard ) ) continue ; \nfor ( Integer slot : slotsToWorkOn ) { \nSlotKey slotKey = SlotKey . of ( g , slot , shard ) ; \nif ( areChildKeysOrSelfKeyScheduledOrRunning ( slotKey ) ) continue ; \nSlotKey key = SlotKey . of ( g , slot , shard ) ; \nscheduledSlots . add ( key ) ; \norderedScheduledSlots . add ( key ) ; \nrecentlyScheduledShards . put ( shard , scheduleTime ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"8072": "public class Emitter { \npublic Emitter on ( String event , Listener fn ) { \nConcurrentLinkedQueue < Listener > callbacks = this . callbacks . get ( event ) ; \nif ( callbacks == null ) { \ncallbacks = new ConcurrentLinkedQueue < Listener > ( ) ; \nConcurrentLinkedQueue < Listener > _callbacks = this . callbacks . putIfAbsent ( event , callbacks ) ; \nif ( _callbacks != null ) callbacks = _callbacks ; \n} \ncallbacks . add ( fn ) ; \nreturn this ; \n} \n} \n"}
{"8074": "public class Emitter { \npublic Emitter off ( String event ) { \nConcurrentLinkedQueue < Listener > callbacks = this . callbacks . remove ( event ) ; \nif ( callbacks != null ) for ( Listener fn : callbacks ) { \nthis . onceCallbacks . remove ( fn ) ; \n} \nreturn this ; \n} \n} \n"}
{"8087": "public class ZKShardLockManager { \nprivate void registerMetrics ( final ObjectName nameObj , MetricRegistry reg ) { \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Lock Disinterested Time Millis\" ) , new JmxAttributeGauge ( nameObj , \"LockDisinterestedTimeMillis\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Min Lock Hold Time Millis\" ) , new JmxAttributeGauge ( nameObj , \"MinLockHoldTimeMillis\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Seconds Since Last Scavenge\" ) , new JmxAttributeGauge ( nameObj , \"SecondsSinceLastScavenge\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Zk Connection Status\" ) , new JmxAttributeGauge ( nameObj , \"ZkConnectionStatus\" ) { \n@ Override public Object getValue ( ) { \nObject val = super . getValue ( ) ; \nif ( val . equals ( \"connected\" ) ) return 1 ; \nreturn 0 ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Held Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getHeldShards ( ) . size ( ) ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Unheld Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getUnheldShards ( ) . size ( ) ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Error Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getErrorShards ( ) . size ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"8088": "public class ThreadPoolBuilder { \npublic ThreadPoolBuilder withName ( String name ) { \nif ( ! name . contains ( \"%d\" ) ) name = name + \"-%d\" ; \nnameMap . putIfAbsent ( name , new AtomicInteger ( 0 ) ) ; \nint id = nameMap . get ( name ) . incrementAndGet ( ) ; \nthis . poolName = String . format ( name , id ) ; \nif ( id > 1 ) this . threadNameFormat = name . replace ( \"%d\" , id + \"-%d\" ) ; \nelse this . threadNameFormat = name ; \nreturn this ; \n} \n} \n"}
{"8089": "public class MetricIndexData { \npublic void add ( String metricIndex , long docCount ) { \nfinal String [ ] tokens = metricIndex . split ( METRIC_TOKEN_SEPARATOR_REGEX ) ; \nswitch ( tokens . length - baseLevel ) { \ncase 1 : if ( baseLevel > 0 ) metricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) ) ; \nelse metricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . indexOf ( \".\" ) ) ) ; \naddChildrenDocCount ( metricNameBaseLevelMap , metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) , docCount ) ; \nbreak ; \ncase 0 : setActualDocCount ( metricNameBaseLevelMap , metricIndex , docCount ) ; \nbreak ; \ndefault : break ; \n} \n} \n} \n"}
{"8090": "public class MetricIndexData { \nprivate Set < String > getCompleteMetricNames ( Map < String , MetricIndexDocCount > metricIndexMap ) { \nSet < String > completeMetricNames = new HashSet < String > ( ) ; \nfor ( Map . Entry < String , MetricIndexDocCount > entry : metricIndexMap . entrySet ( ) ) { \nMetricIndexDocCount metricIndexDocCount = entry . getValue ( ) ; \nif ( metricIndexDocCount != null ) if ( metricIndexDocCount . actualDocCount > 0 && metricIndexDocCount . actualDocCount > metricIndexDocCount . childrenTotalDocCount ) completeMetricNames . add ( entry . getKey ( ) ) ; \n} \nreturn Collections . unmodifiableSet ( completeMetricNames ) ; \n} \n} \n"}
{"8093": "public class Granularity { \npublic static Granularity granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , long assumedIntervalMillis , Clock ttlComparisonClock ) { \nif ( from >= to ) throw new RuntimeException ( \"Invalid interval specified for fromPointsInInterval\" ) ; \ndouble requestedDuration = to - from ; \nif ( algorithm . startsWith ( \"GEOMETRIC\" ) ) return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \nelse if ( algorithm . startsWith ( \"LINEAR\" ) ) return granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \nelse if ( algorithm . startsWith ( \"LESSTHANEQUAL\" ) ) return granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; \nreturn granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \n} \n} \n"}
{"8094": "public class Granularity { \nprivate static Granularity granularityFromPointsLessThanEqual ( double requestedDuration , int points , long assumedIntervalMillis ) { \nGranularity gran = granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \nif ( requestedDuration / gran . milliseconds ( ) > points ) try { \ngran = gran . coarser ( ) ; \n} \ncatch ( GranularityException e ) { \n} \nreturn gran ; \n} \n} \n"}
{"8101": "public class LocatorFetchRunnable { \nprotected Set < Locator > getLocators ( RollupExecutionContext executionContext , boolean isReroll , Granularity delayedMetricsRerollGranularity , Granularity delayedMetricsStorageGranularity ) { \nSet < Locator > locators = new HashSet < Locator > ( ) ; \nif ( RECORD_DELAYED_METRICS && isReroll && ! getGranularity ( ) . isCoarser ( delayedMetricsRerollGranularity ) ) if ( getGranularity ( ) . isCoarser ( delayedMetricsStorageGranularity ) ) for ( SlotKey slotKey : parentSlotKey . getChildrenKeys ( delayedMetricsStorageGranularity ) ) { \nlocators . addAll ( getDelayedLocators ( executionContext , slotKey ) ) ; \n} \nelse locators = getDelayedLocators ( executionContext , parentSlotKey . extrapolate ( delayedMetricsStorageGranularity ) ) ; \nelse locators = getLocators ( executionContext ) ; \nreturn locators ; \n} \n} \n"}
{"8103": "public class AbstractElasticIO { \nprotected String regexToGrabCurrentAndNextLevel ( final String query ) { \nif ( StringUtils . isEmpty ( query ) ) throw new IllegalArgumentException ( \"Query(glob) string cannot be null/empty\" ) ; \nString queryRegex = getRegex ( query ) ; \nint totalQueryTokens = getTotalTokens ( query ) ; \nif ( totalQueryTokens == 1 ) { \nString baseRegex = convertRegexToCaptureUptoNextToken ( queryRegex ) ; \nreturn baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN ; \n} \nelse { \nString [ ] queryRegexParts = queryRegex . split ( \"\\\\\\\\.\" ) ; \nString queryRegexUptoPrevLevel = StringUtils . join ( queryRegexParts , METRIC_TOKEN_SEPARATOR_REGEX , 0 , totalQueryTokens - 1 ) ; \nString baseRegex = convertRegexToCaptureUptoNextToken ( queryRegexUptoPrevLevel ) ; \nString queryRegexLastLevel = queryRegexParts [ totalQueryTokens - 1 ] ; \nString lastTokenRegex = convertRegexToCaptureUptoNextToken ( queryRegexLastLevel ) ; \nreturn baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + lastTokenRegex + \"(\" + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN + \")\" + \"{0,1}\" ; \n} \n} \n} \n"}
{"8104": "public class StorageManager { \npublic synchronized void start ( ) { \nif ( uploaderThread != null ) throw new RuntimeException ( \"StorageManager is already started\" ) ; \nfileUploader = new DoneFileUploader ( ) ; \nuploaderThread = new Thread ( fileUploader , \"StorageManager uploader\" ) ; \nuploaderThread . start ( ) ; \n} \n} \n"}
{"8105": "public class StorageManager { \npublic synchronized void stop ( ) throws IOException { \nif ( uploaderThread == null ) throw new RuntimeException ( \"Not running\" ) ; \nuploaderThread . interrupt ( ) ; \nuploaderThread = null ; \nfileUploader . shutdown ( ) ; \n} \n} \n"}
{"8112": "public class Range { \npublic static Iterable < Range > rangesForInterval ( Granularity g , final long from , final long to ) { \nif ( g == Granularity . FULL ) return Arrays . asList ( new Range ( from , to ) ) ; \nfinal long snappedStartMillis = g . snapMillis ( from ) ; \nfinal long snappedStopMillis = g . snapMillis ( to + g . milliseconds ( ) ) ; \nreturn new IntervalRangeIterator ( g , snappedStartMillis , snappedStopMillis ) ; \n} \n} \n"}
{"8113": "public class AstyanaxWriter { \npublic void insertFull ( Collection < ? extends IMetric > metrics , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { \nTimer . Context ctx = Instrumentation . getWriteTimerContext ( CassandraModel . CF_METRICS_FULL_NAME ) ; \ntry { \nMutationBatch mutationBatch = keyspace . prepareMutationBatch ( ) ; \nfor ( IMetric metric : metrics ) { \nfinal Locator locator = metric . getLocator ( ) ; \nif ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { \nif ( mutationBatch != null ) insertLocator ( locator , mutationBatch ) ; \nLocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; \n} \nif ( isRecordingDelayedMetrics ) if ( mutationBatch != null ) insertLocatorIfDelayed ( metric , mutationBatch , clock ) ; \ninsertMetric ( metric , mutationBatch ) ; \nInstrumentation . markFullResMetricWritten ( ) ; \n} \ntry { \nmutationBatch . execute ( ) ; \n} \ncatch ( ConnectionException e ) { \nInstrumentation . markWriteError ( e ) ; \nlog . error ( \"Connection exception during insertFull\" , e ) ; \nthrow e ; \n} \n} \nfinally { \nctx . stop ( ) ; \n} \n} \n} \n"}
{"8114": "public class AstyanaxWriter { \npublic void insertMetrics ( Collection < IMetric > metrics , ColumnFamily cf , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { \nTimer . Context ctx = Instrumentation . getWriteTimerContext ( cf . getName ( ) ) ; \nMultimap < Locator , IMetric > map = asMultimap ( metrics ) ; \nMutationBatch batch = keyspace . prepareMutationBatch ( ) ; \ntry { \nfor ( Locator locator : map . keySet ( ) ) { \nColumnListMutation < Long > mutation = batch . withRow ( cf , locator ) ; \nfor ( IMetric metric : map . get ( locator ) ) { \nmutation . putColumn ( metric . getCollectionTime ( ) , metric . getMetricValue ( ) , ( AbstractSerializer ) ( Serializers . serializerFor ( metric . getMetricValue ( ) . getClass ( ) ) ) , metric . getTtlInSeconds ( ) ) ; \nif ( cf . getName ( ) . equals ( CassandraModel . CF_METRICS_PREAGGREGATED_FULL_NAME ) ) Instrumentation . markFullResPreaggregatedMetricWritten ( ) ; \nif ( isRecordingDelayedMetrics ) insertLocatorIfDelayed ( metric , batch , clock ) ; \n} \nif ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { \ninsertLocator ( locator , batch ) ; \nLocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; \n} \n} \ntry { \nbatch . execute ( ) ; \n} \ncatch ( ConnectionException e ) { \nInstrumentation . markWriteError ( e ) ; \nlog . error ( \"Connection exception persisting data\" , e ) ; \nthrow e ; \n} \n} \nfinally { \nctx . stop ( ) ; \n} \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) return ; \nif ( fileManager == null ) return ; \nif ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nwhile ( downloadDir . listFiles ( ) . length != 0 ) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( downloadLock . tryLock ( ) ) try { \nif ( fileManager . hasNewFiles ( ) ) fileManager . downloadNewFiles ( downloadDir ) ; \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors += 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) try { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \nelse log . debug ( \"Download in progress\" ) ; \n} \n} \n"}
{"8124": "public class ExtractorFactory { \npublic Extractor getNewInstance ( ) { \nExtractor extractor = new BasicExtractor ( config ) ; \nif ( config . shouldCachedDownload ( ) ) extractor = new CachedExtractor ( extractor , config ) ; \nreturn extractor ; \n} \n} \n"}
{"8126": "public class EmbeddedRabbitMq { \npublic void start ( ) throws ErlangVersionException , DownloadException , ExtractionException , StartupException { \nif ( rabbitMqProcess != null ) throw new IllegalStateException ( \"Start shouldn't be called more than once unless stop() has been called before.\" ) ; \ncheck ( ) ; \ndownload ( ) ; \nextract ( ) ; \nrun ( ) ; \n} \n} \n"}
{"8127": "public class EmbeddedRabbitMq { \npublic void stop ( ) throws ShutDownException { \nif ( rabbitMqProcess == null ) throw new IllegalStateException ( \"Stop shouldn't be called unless 'start()' was successful.\" ) ; \nnew ShutdownHelper ( config , rabbitMqProcess ) . run ( ) ; \nrabbitMqProcess = null ; \n} \n} \n"}
{"8129": "public class PnSignalingParams { \npublic void addIceServers ( List < PeerConnection . IceServer > iceServers ) { \nif ( this . iceServers != null ) iceServers . addAll ( this . iceServers ) ; \nthis . iceServers = iceServers ; \n} \n} \n"}
{"8130": "public class PnSignalingParams { \npublic void addIceServers ( PeerConnection . IceServer iceServers ) { \nif ( this . iceServers == null ) this . iceServers = new ArrayList < PeerConnection . IceServer > ( ) ; \nthis . iceServers . add ( 0 , iceServers ) ; \n} \n} \n"}
{"8133": "public class Immobilie { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < WeitereAdresse > getWeitereAdresse ( ) { \nif ( weitereAdresse == null ) weitereAdresse = new ArrayList < WeitereAdresse > ( ) ; \nreturn this . weitereAdresse ; \n} \n} \n"}
{"8134": "public class Immobilie { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < UserDefinedSimplefield > getUserDefinedSimplefield ( ) { \nif ( userDefinedSimplefield == null ) userDefinedSimplefield = new ArrayList < UserDefinedSimplefield > ( ) ; \nreturn this . userDefinedSimplefield ; \n} \n} \n"}
{"8135": "public class Immobilie { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < UserDefinedAnyfield > getUserDefinedAnyfield ( ) { \nif ( userDefinedAnyfield == null ) userDefinedAnyfield = new ArrayList < UserDefinedAnyfield > ( ) ; \nreturn this . userDefinedAnyfield ; \n} \n} \n"}
{"8137": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < MultimediaAnhangTyp > getMultimediaAnhang ( ) { \nif ( multimediaAnhang == null ) multimediaAnhang = new ArrayList < MultimediaAnhangTyp > ( ) ; \nreturn this . multimediaAnhang ; \n} \n} \n"}
{"8138": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StatusTyp getStatusVBM ( ) { \nif ( statusVBM == null ) return StatusTyp . AKTIV ; \nelse return statusVBM ; \n} \n} \n"}
{"8139": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StatusTyp getStatusIS24 ( ) { \nif ( statusIS24 == null ) return StatusTyp . AKTIV ; \nelse return statusIS24 ; \n} \n} \n"}
{"8140": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StatusTyp getStatusHP ( ) { \nif ( statusHP == null ) return StatusTyp . AKTIV ; \nelse return statusHP ; \n} \n} \n"}
{"8141": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public AktionsTyp getImportmodus ( ) { \nif ( importmodus == null ) return AktionsTyp . IMPORTIEREN ; \nelse return importmodus ; \n} \n} \n"}
{"8142": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getAdressdruck ( ) { \nif ( adressdruck == null ) return false ; \nelse return adressdruck ; \n} \n} \n"}
{"8143": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public WaehrungTyp getWaehrung ( ) { \nif ( waehrung == null ) return WaehrungTyp . EUR ; \nelse return waehrung ; \n} \n} \n"}
{"8144": "public class SonstigeGewerbeTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public BodenbelagTyp getBodenbelag ( ) { \nif ( bodenbelag == null ) return BodenbelagTyp . KEINE_ANGABE ; \nelse return bodenbelag ; \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) return false ; \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) start ++ ; \nboolean fraction = false ; \nfor ( int i = start ; \ni < value . length ( ) ; \ni ++ ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \ncontinue ; \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) continue ; \nif ( ! Character . isDigit ( c ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"8167": "public class Root { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T01:43:04+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < PropertyType > getProperty ( ) { \nif ( property == null ) property = new ArrayList < PropertyType > ( ) ; \nreturn this . property ; \n} \n} \n"}
{"8169": "public class Kontaktperson { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < UserDefinedExtend > getUserDefinedExtend ( ) { \nif ( userDefinedExtend == null ) userDefinedExtend = new ArrayList < UserDefinedExtend > ( ) ; \nreturn this . userDefinedExtend ; \n} \n} \n"}
{"8171": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Zimmer > getZimmer ( ) { \nif ( zimmer == null ) zimmer = new ArrayList < Zimmer > ( ) ; \nreturn this . zimmer ; \n} \n} \n"}
{"8172": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Haus > getHaus ( ) { \nif ( haus == null ) haus = new ArrayList < Haus > ( ) ; \nreturn this . haus ; \n} \n} \n"}
{"8173": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < BueroPraxen > getBueroPraxen ( ) { \nif ( bueroPraxen == null ) bueroPraxen = new ArrayList < BueroPraxen > ( ) ; \nreturn this . bueroPraxen ; \n} \n} \n"}
{"8174": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Gastgewerbe > getGastgewerbe ( ) { \nif ( gastgewerbe == null ) gastgewerbe = new ArrayList < Gastgewerbe > ( ) ; \nreturn this . gastgewerbe ; \n} \n} \n"}
{"8175": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < LandUndForstwirtschaft > getLandUndForstwirtschaft ( ) { \nif ( landUndForstwirtschaft == null ) landUndForstwirtschaft = new ArrayList < LandUndForstwirtschaft > ( ) ; \nreturn this . landUndForstwirtschaft ; \n} \n} \n"}
{"8176": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Sonstige > getSonstige ( ) { \nif ( sonstige == null ) sonstige = new ArrayList < Sonstige > ( ) ; \nreturn this . sonstige ; \n} \n} \n"}
{"8177": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < ZinshausRenditeobjekt > getZinshausRenditeobjekt ( ) { \nif ( zinshausRenditeobjekt == null ) zinshausRenditeobjekt = new ArrayList < ZinshausRenditeobjekt > ( ) ; \nreturn this . zinshausRenditeobjekt ; \n} \n} \n"}
{"8178": "public class Terrains { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < TerrainType > getTerrain ( ) { \nif ( terrain == null ) terrain = new ArrayList < TerrainType > ( ) ; \nreturn this . terrain ; \n} \n} \n"}
{"8182": "public class LocaleUtils { \npublic static String getCountryISO2FromISO3 ( String iso3Code ) { \niso3Code = StringUtils . trimToNull ( iso3Code ) ; \nif ( iso3Code == null ) return null ; \nif ( iso3Code . length ( ) == 3 ) for ( String iso2Code : Locale . getISOCountries ( ) ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nString countryISO3 = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; \nif ( countryISO3 != null && countryISO3 . equalsIgnoreCase ( iso3Code ) ) return iso2Code ; \n} \nreturn null ; \n} \n} \n"}
{"8187": "public class Immoxml { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Anbieter > getAnbieter ( ) { \nif ( anbieter == null ) anbieter = new ArrayList < Anbieter > ( ) ; \nreturn this . anbieter ; \n} \n} \n"}
{"8189": "public class PdfsType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < URI > getPdf ( ) { \nif ( pdf == null ) pdf = new ArrayList < URI > ( ) ; \nreturn this . pdf ; \n} \n} \n"}
{"8195": "public class UserDefinedAnyfield { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Object > getContent ( ) { \nif ( content == null ) content = new ArrayList < Object > ( ) ; \nreturn this . content ; \n} \n} \n"}
{"8200": "public class WazTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public StellplatzKategorieTyp getParkplatz ( ) { \nif ( parkplatz == null ) return StellplatzKategorieTyp . KEINE_ANGABE ; \nelse return parkplatz ; \n} \n} \n"}
{"8203": "public class Bewertung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Bewertung . Feld > getFeld ( ) { \nif ( feld == null ) feld = new ArrayList < Bewertung . Feld > ( ) ; \nreturn this . feld ; \n} \n} \n"}
{"8207": "public class CsvRecord { \nprotected Iterable < String > print ( ) { \nfinal int length = this . getRecordLenth ( ) ; \nList < String > row = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) row . add ( this . get ( i ) ) ; \nreturn row ; \n} \n} \n"}
{"8211": "public class ZustandAngaben { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Energiepass > getEnergiepass ( ) { \nif ( energiepass == null ) energiepass = new ArrayList < Energiepass > ( ) ; \nreturn this . energiepass ; \n} \n} \n"}
{"8216": "public class VersteigerungsterminTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getWiederholungstermin ( ) { \nif ( wiederholungstermin == null ) return false ; \nelse return wiederholungstermin ; \n} \n} \n"}
{"8217": "public class VersteigerungsterminTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getTeilungsversteigerung ( ) { \nif ( teilungsversteigerung == null ) return false ; \nelse return teilungsversteigerung ; \n} \n} \n"}
{"8219": "public class Interessent { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Interessent . Bevorzugt > getBevorzugt ( ) { \nif ( bevorzugt == null ) bevorzugt = new ArrayList < Interessent . Bevorzugt > ( ) ; \nreturn this . bevorzugt ; \n} \n} \n"}
{"8220": "public class Interessent { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Interessent . Wunsch > getWunsch ( ) { \nif ( wunsch == null ) wunsch = new ArrayList < Interessent . Wunsch > ( ) ; \nreturn this . wunsch ; \n} \n} \n"}
{"8223": "public class WeitereAdresse { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < EmailSonstige > getEmailSonstige ( ) { \nif ( emailSonstige == null ) emailSonstige = new ArrayList < EmailSonstige > ( ) ; \nreturn this . emailSonstige ; \n} \n} \n"}
{"8224": "public class WeitereAdresse { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < TelSonstige > getTelSonstige ( ) { \nif ( telSonstige == null ) telSonstige = new ArrayList < TelSonstige > ( ) ; \nreturn this . telSonstige ; \n} \n} \n"}
{"8230": "public class ResultSetType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:42:33+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < ResultSetType . ROW > getROW ( ) { \nif ( row == null ) row = new ArrayList < ResultSetType . ROW > ( ) ; \nreturn this . row ; \n} \n} \n"}
{"8232": "public class Anhaenge { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Anhang > getAnhang ( ) { \nif ( anhang == null ) anhang = new ArrayList < Anhang > ( ) ; \nreturn this . anhang ; \n} \n} \n"}
{"8233": "public class GarageTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public GaragenKategorieTyp getObjektKategorie2 ( ) { \nif ( objektKategorie2 == null ) return GaragenKategorieTyp . KEINE_ANGABE ; \nelse return objektKategorie2 ; \n} \n} \n"}
{"8234": "public class GarageTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public ObjektZustandTyp getObjektzustand ( ) { \nif ( objektzustand == null ) return ObjektZustandTyp . KEINE_ANGABE ; \nelse return objektzustand ; \n} \n} \n"}
{"8235": "public class HausTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public HausKategorienTyp getHausKategorie ( ) { \nif ( hausKategorie == null ) return HausKategorienTyp . KEINE_ANGABE ; \nelse return hausKategorie ; \n} \n} \n"}
{"8236": "public class HausTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public AusstattungsqualitaetsTyp getAusstattungsqualitaet ( ) { \nif ( ausstattungsqualitaet == null ) return AusstattungsqualitaetsTyp . KEINE_ANGABE ; \nelse return ausstattungsqualitaet ; \n} \n} \n"}
{"8237": "public class Objekt { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < String > getVermarktungsart ( ) { \nif ( vermarktungsart == null ) vermarktungsart = new ArrayList < String > ( ) ; \nreturn this . vermarktungsart ; \n} \n} \n"}
{"8238": "public class Objekt { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Interessent > getInteressent ( ) { \nif ( interessent == null ) interessent = new ArrayList < Interessent > ( ) ; \nreturn this . interessent ; \n} \n} \n"}
{"8267": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Wohnung > getWohnung ( ) { \nif ( wohnung == null ) wohnung = new ArrayList < Wohnung > ( ) ; \nreturn this . wohnung ; \n} \n} \n"}
{"8268": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Grundstueck > getGrundstueck ( ) { \nif ( grundstueck == null ) grundstueck = new ArrayList < Grundstueck > ( ) ; \nreturn this . grundstueck ; \n} \n} \n"}
{"8269": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Einzelhandel > getEinzelhandel ( ) { \nif ( einzelhandel == null ) einzelhandel = new ArrayList < Einzelhandel > ( ) ; \nreturn this . einzelhandel ; \n} \n} \n"}
{"8270": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < HallenLagerProd > getHallenLagerProd ( ) { \nif ( hallenLagerProd == null ) hallenLagerProd = new ArrayList < HallenLagerProd > ( ) ; \nreturn this . hallenLagerProd ; \n} \n} \n"}
{"8271": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Parken > getParken ( ) { \nif ( parken == null ) parken = new ArrayList < Parken > ( ) ; \nreturn this . parken ; \n} \n} \n"}
{"8272": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < FreizeitimmobilieGewerblich > getFreizeitimmobilieGewerblich ( ) { \nif ( freizeitimmobilieGewerblich == null ) freizeitimmobilieGewerblich = new ArrayList < FreizeitimmobilieGewerblich > ( ) ; \nreturn this . freizeitimmobilieGewerblich ; \n} \n} \n"}
{"8273": "public class Objektart { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < String > getObjektartZusatz ( ) { \nif ( objektartZusatz == null ) objektartZusatz = new ArrayList < String > ( ) ; \nreturn this . objektartZusatz ; \n} \n} \n"}
{"8274": "public class Ausstattung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Stellplatzart > getStellplatzart ( ) { \nif ( stellplatzart == null ) stellplatzart = new ArrayList < Stellplatzart > ( ) ; \nreturn this . stellplatzart ; \n} \n} \n"}
{"8276": "public class FeaturesType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < String > getFeature ( ) { \nif ( feature == null ) feature = new ArrayList < String > ( ) ; \nreturn this . feature ; \n} \n} \n"}
{"8278": "public class OpenImmo_1_2_5 { \n@ Override @ SuppressWarnings ( \"Duplicates\" ) public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_5 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) try { \nthis . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8291": "public class WohnungTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public WohnungKategorienTyp getWohnungKategorie ( ) { \nif ( wohnungKategorie == null ) return WohnungKategorienTyp . KEINE_ANGABE ; \nelse return wohnungKategorie ; \n} \n} \n"}
{"8294": "public class Feedindex { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Feedindex . Feed > getFeed ( ) { \nif ( feed == null ) feed = new ArrayList < Feedindex . Feed > ( ) ; \nreturn this . feed ; \n} \n} \n"}
{"8296": "public class Ausstattung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Serviceleistungen > getServiceleistungen ( ) { \nif ( serviceleistungen == null ) serviceleistungen = new ArrayList < Serviceleistungen > ( ) ; \nreturn this . serviceleistungen ; \n} \n} \n"}
{"8301": "public class OpenImmo_1_2_1 { \n@ Override @ SuppressWarnings ( \"Duplicates\" ) public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_1 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) try { \nthis . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeXmlNamespace ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade the XML namespace!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8303": "public class MetaDataType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:42:33+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < MetaDataType . FIELD > getFIELD ( ) { \nif ( field == null ) field = new ArrayList < MetaDataType . FIELD > ( ) ; \nreturn this . field ; \n} \n} \n"}
{"8304": "public class OpenImmo_1_2_0 { \n@ Override public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_0 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) try { \nthis . upgradeMieteinnahmenElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <mieteinnahmen_ist> and <mieteinnahmen_soll> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8305": "public class Trovit { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:55:25+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < AdType > getAd ( ) { \nif ( ad == null ) ad = new ArrayList < AdType > ( ) ; \nreturn this . ad ; \n} \n} \n"}
{"8308": "public class BueroPraxisTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public DatenVerkabelungsTyp getDatenVerkabelung ( ) { \nif ( datenVerkabelung == null ) return DatenVerkabelungsTyp . KEINE_ANGABE ; \nelse return datenVerkabelung ; \n} \n} \n"}
{"8309": "public class BueroPraxisTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public JaNeinVereinbarungTyp getKlimaanlage ( ) { \nif ( klimaanlage == null ) return JaNeinVereinbarungTyp . KEINE_ANGABE ; \nelse return klimaanlage ; \n} \n} \n"}
{"8310": "public class ImagesType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T01:43:04+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < ImagesType . Image > getImage ( ) { \nif ( image == null ) image = new ArrayList < ImagesType . Image > ( ) ; \nreturn this . image ; \n} \n} \n"}
{"8329": "public class Fehlerliste { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Fehlerliste . Fehler > getFehler ( ) { \nif ( fehler == null ) fehler = new ArrayList < Fehlerliste . Fehler > ( ) ; \nreturn this . fehler ; \n} \n} \n"}
{"8331": "public class Preise { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < StpSonstige > getStpSonstige ( ) { \nif ( stpSonstige == null ) stpSonstige = new ArrayList < StpSonstige > ( ) ; \nreturn this . stpSonstige ; \n} \n} \n"}
{"8332": "public class ValueListsType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:42:33+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < ValueListsType . VALUELIST > getVALUELIST ( ) { \nif ( valuelist == null ) valuelist = new ArrayList < ValueListsType . VALUELIST > ( ) ; \nreturn this . valuelist ; \n} \n} \n"}
{"8335": "public class PhotosType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < URI > getPhoto ( ) { \nif ( photo == null ) photo = new ArrayList < URI > ( ) ; \nreturn this . photo ; \n} \n} \n"}
{"8341": "public class Anbieter { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Immobilie > getImmobilie ( ) { \nif ( immobilie == null ) immobilie = new ArrayList < Immobilie > ( ) ; \nreturn this . immobilie ; \n} \n} \n"}
{"8342": "public class OpenimmoFeedback { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Objekt > getObjekt ( ) { \nif ( objekt == null ) objekt = new ArrayList < Objekt > ( ) ; \nreturn this . objekt ; \n} \n} \n"}
{"8343": "public class OpenimmoFeedback { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Fehlerliste > getFehlerliste ( ) { \nif ( fehlerliste == null ) fehlerliste = new ArrayList < Fehlerliste > ( ) ; \nreturn this . fehlerliste ; \n} \n} \n"}
{"8344": "public class OpenimmoFeedback { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Status > getStatus ( ) { \nif ( status == null ) status = new ArrayList < Status > ( ) ; \nreturn this . status ; \n} \n} \n"}
{"8347": "public class Infrastruktur { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < Distanzen > getDistanzen ( ) { \nif ( distanzen == null ) distanzen = new ArrayList < Distanzen > ( ) ; \nreturn this . distanzen ; \n} \n} \n"}
{"8348": "public class Infrastruktur { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public List < DistanzenSport > getDistanzenSport ( ) { \nif ( distanzenSport == null ) distanzenSport = new ArrayList < DistanzenSport > ( ) ; \nreturn this . distanzenSport ; \n} \n} \n"}
{"8349": "public class ObjectUtils { \npublic static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { \nif ( ! isCheckedException ( ex ) ) return true ; \nif ( declaredExceptions != null ) { \nint i = 0 ; \nwhile ( i < declaredExceptions . length ) { \nif ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) return true ; \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8351": "public class SimpleNamespaceContext { \npublic void bindNamespaceUri ( String prefix , String namespaceUri ) { \nAssert . notNull ( prefix , \"No prefix given\" ) ; \nAssert . notNull ( namespaceUri , \"No namespaceUri given\" ) ; \nif ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) defaultNamespaceUri = namespaceUri ; \nelse { \nprefixToNamespaceUri . put ( prefix , namespaceUri ) ; \ngetPrefixesInternal ( namespaceUri ) . add ( prefix ) ; \n} \n} \n} \n"}
{"8352": "public class SimpleNamespaceContext { \npublic void removeBinding ( String prefix ) { \nif ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) defaultNamespaceUri = \"\" ; \nelse { \nString namespaceUri = prefixToNamespaceUri . remove ( prefix ) ; \nList < String > prefixes = getPrefixesInternal ( namespaceUri ) ; \nprefixes . remove ( prefix ) ; \n} \n} \n} \n"}
{"8353": "public class XmlValidationModeDetector { \nprivate boolean hasOpeningTag ( String content ) { \nif ( this . inComment ) return false ; \nint openTagIndex = content . indexOf ( '<' ) ; \nreturn ( openTagIndex > - 1 && content . length ( ) > openTagIndex && Character . isLetter ( content . charAt ( openTagIndex + 1 ) ) ) ; \n} \n} \n"}
{"8354": "public class XmlValidationModeDetector { \nprivate String consumeCommentTokens ( String line ) { \nif ( line . indexOf ( START_COMMENT ) == - 1 && line . indexOf ( END_COMMENT ) == - 1 ) return line ; \nwhile ( ( line = consume ( line ) ) != null ) if ( ! this . inComment && ! line . trim ( ) . startsWith ( START_COMMENT ) ) return line ; \nreturn line ; \n} \n} \n"}
{"8356": "public class XmlValidationModeDetector { \nprivate int commentToken ( String line , String token , boolean inCommentIfPresent ) { \nint index = line . indexOf ( token ) ; \nif ( index > - 1 ) this . inComment = inCommentIfPresent ; \nreturn ( index == - 1 ? index : index + token . length ( ) ) ; \n} \n} \n"}
{"8357": "public class Log4jConfigurer { \npublic static void initLogging ( String location ) throws FileNotFoundException { \nString resolvedLocation = SystemPropertyUtils . resolvePlaceholders ( location ) ; \nURL url = ResourceUtils . getURL ( resolvedLocation ) ; \nif ( resolvedLocation . toLowerCase ( ) . endsWith ( XML_FILE_EXTENSION ) ) DOMConfigurator . configure ( url ) ; \nelse PropertyConfigurator . configure ( url ) ; \n} \n} \n"}
{"8359": "public class CompositeIterator { \npublic void add ( Iterator < E > iterator ) { \nAssert . state ( ! inUse , \"You can no longer add iterator to a composite iterator that's already in use\" ) ; \nif ( iterators . contains ( iterator ) ) throw new IllegalArgumentException ( \"You cannot add the same iterator twice\" ) ; \niterators . add ( iterator ) ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) throw new UnknownOptionException ( curArg ) ; \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) valueArg = argv [ position ] ; \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse value = opt . getValue ( null , locale ) ; \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) otherArgs . addElement ( argv [ position ] ) ; \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8367": "public class SingletonLoader { \npublic Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { \nObject ret = null ; \nMethod [ ] methods = c . getDeclaredMethods ( ) ; \nMethod m ; \nint modifiers ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nm = methods [ i ] ; \nmodifiers = m . getModifiers ( ) ; \nif ( ( modifiers & Modifier . STATIC ) != 0 ) if ( ( modifiers & Modifier . PUBLIC ) != 0 ) if ( m . getParameterTypes ( ) . length == 0 ) if ( m . getReturnType ( ) == c ) if ( m . getName ( ) . toLowerCase ( ) . indexOf ( \"instance\" ) != - 1 ) try { \nret = m . invoke ( null , dummyParameters ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalAccessException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \n} \n} \nif ( ret == null ) { \nConstructor [ ] constructors = c . getConstructors ( ) ; \nConstructor con = null ; \nfor ( int i = 0 ; \ni < constructors . length ; \ni ++ ) { \ncon = constructors [ i ] ; \nif ( con . getParameterTypes ( ) . length == 0 ) { \nmodifiers = con . getModifiers ( ) ; \ntry { \nif ( ( modifiers & Modifier . PUBLIC ) == 0 ) con . setAccessible ( true ) ; \nret = c . newInstance ( ) ; \n} \ncatch ( SecurityException se ) { \n} \n} \n} \n} \nif ( ret == null ) System . err . println ( \"Unable to instantiate: \" + c . getName ( ) + \": no singleton method, no public default constructor.\" ) ; \nreturn ret ; \n} \n} \n"}
{"8368": "public class ConcurrencyThrottleSupport { \nprotected void afterAccess ( ) { \nif ( this . concurrencyLimit >= 0 ) synchronized ( this . monitor ) { \nthis . concurrencyCount -- ; \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Returning from throttle at concurrency count \" + this . concurrencyCount ) ; \nthis . monitor . notify ( ) ; \n} \n} \n} \n"}
{"8369": "public class MethodInvoker { \npublic void setTargetObject ( Object targetObject ) { \nthis . targetObject = targetObject ; \nif ( targetObject != null ) this . targetClass = targetObject . getClass ( ) ; \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nint lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) throw new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) throw new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \nif ( targetMethod == null ) throw new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \nfor ( int i = 0 ; \ni < arguments . length ; \n++ i ) argTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) throw ex ; \n} \n} \n} \n"}
{"8373": "public class SerializationUtils { \npublic static byte [ ] serialize ( Object object ) { \nif ( object == null ) return null ; \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \ntry { \nObjectOutputStream oos = new ObjectOutputStream ( baos ) ; \noos . writeObject ( object ) ; \noos . flush ( ) ; \n} \ncatch ( IOException ex ) { \nthrow new IllegalArgumentException ( \"Failed to serialize object of type: \" + object . getClass ( ) , ex ) ; \n} \nreturn baos . toByteArray ( ) ; \n} \n} \n"}
{"8374": "public class SerializationUtils { \npublic static Object deserialize ( byte [ ] bytes ) { \nif ( bytes == null ) return null ; \ntry { \nObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; \nreturn ois . readObject ( ) ; \n} \ncatch ( IOException ex ) { \nthrow new IllegalArgumentException ( \"Failed to deserialize object\" , ex ) ; \n} \ncatch ( ClassNotFoundException ex ) { \nthrow new IllegalStateException ( \"Failed to deserialize object type\" , ex ) ; \n} \n} \n} \n"}
{"8375": "public class DomUtils { \npublic static Element getChildElementByTagName ( Element ele , String childEleName ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nAssert . notNull ( childEleName , \"Element name must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nl . getLength ( ) ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) return ( Element ) node ; \n} \nreturn null ; \n} \n} \n"}
{"8377": "public class DomUtils { \npublic static List < Element > getChildElements ( Element ele ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nList < Element > childEles = new ArrayList < Element > ( ) ; \nfor ( int i = 0 ; \ni < nl . getLength ( ) ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element ) childEles . add ( ( Element ) node ) ; \n} \nreturn childEles ; \n} \n} \n"}
{"8380": "public class StringUtil { \npublic static final String setSize ( final String s , final int length ) { \nString result = s ; \nint oldlen = s . length ( ) ; \nif ( oldlen > length ) System . err . println ( \"greenpeace.util.setSize(String s,int length): length (\" + length + \") is smaller than s.length(\" + oldlen + \") : \" + s ) ; \nelse { \nint tofill = length - oldlen ; \nresult = StringUtil . appendSpaces ( s , tofill ) ; \n} \nreturn result ; \n} \n} \n"}
{"8381": "public class WeakReferenceMonitor { \npublic static void monitor ( Object handle , ReleaseListener listener ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Monitoring handle [\" + handle + \"] with release listener [\" + listener + \"]\" ) ; \nWeakReference < Object > weakRef = new WeakReference < Object > ( handle , handleQueue ) ; \naddEntry ( weakRef , listener ) ; \n} \n} \n"}
{"8383": "public class WeakReferenceMonitor { \nprivate static boolean keepMonitoringThreadAlive ( ) { \nsynchronized ( WeakReferenceMonitor . class ) { \nif ( ! trackedEntries . isEmpty ( ) ) return true ; \nelse { \nlogger . debug ( \"No entries left to track - stopping reference monitor thread\" ) ; \nmonitoringThread = null ; \nreturn false ; \n} \n} \n} \n} \n"}
{"8384": "public class PhoneNumberAddress { \npublic static String calcMobileCity ( String mobileNumber ) throws MalformedURLException { \nObjectMapper objectMapper = new ObjectMapper ( ) ; \nString jsonString = null ; \nString urlString = \"http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=\" + mobileNumber ; \nStringBuffer sb = new StringBuffer ( ) ; \nBufferedReader buffer ; \nURL url = new URL ( urlString ) ; \ntry { \nInputStream in = url . openStream ( ) ; \nbuffer = new BufferedReader ( new InputStreamReader ( in , \"gb2312\" ) ) ; \nString line = null ; \nwhile ( ( line = buffer . readLine ( ) ) != null ) sb . append ( line ) ; \nin . close ( ) ; \nbuffer . close ( ) ; \njsonString = sb . toString ( ) ; \nEntityHelper . print ( jsonString ) ; \njsonString = jsonString . replaceAll ( \"^[__]\\\\w{14}+[_ = ]+\" , \"[\" ) ; \nString jsonString2 = jsonString + \"]\" ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8385": "public class AbstractStaxXMLReader { \nprotected void startPrefixMapping ( String prefix , String namespace ) throws SAXException { \nif ( getContentHandler ( ) != null ) { \nif ( prefix == null ) prefix = \"\" ; \nif ( ! StringUtils . hasLength ( namespace ) ) return ; \nif ( ! namespace . equals ( namespaces . get ( prefix ) ) ) { \ngetContentHandler ( ) . startPrefixMapping ( prefix , namespace ) ; \nnamespaces . put ( prefix , namespace ) ; \n} \n} \n} \n} \n"}
{"8386": "public class AbstractStaxXMLReader { \nprotected void endPrefixMapping ( String prefix ) throws SAXException { \nif ( getContentHandler ( ) != null ) if ( namespaces . containsKey ( prefix ) ) { \ngetContentHandler ( ) . endPrefixMapping ( prefix ) ; \nnamespaces . remove ( prefix ) ; \n} \n} \n} \n"}
{"8389": "public class HorizontalPicker { \nprivate int getTextColor ( int item ) { \nint scrollX = getScrollX ( ) ; \nint color = textColor . getDefaultColor ( ) ; \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nif ( scrollX > itemWithPadding * item - itemWithPadding / 2 && scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) { \nint position = scrollX - itemWithPadding / 2 ; \ncolor = getColor ( position , item ) ; \n} \nelse if ( item == pressedItem ) color = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, color ) ; \nreturn color ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( this . values != null ) { \nlayouts = new BoringLayout [ this . values . length ] ; \nfor ( int i = 0 ; \ni < layouts . length ; \ni ++ ) layouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \n} \nelse layouts = new BoringLayout [ 0 ] ; \nif ( getWidth ( ) > 0 ) startMarqueeIfNeeded ( ) ; \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \n} \n} \n"}
{"8391": "public class HorizontalPicker { \nprivate int getColor ( int scrollX , int position ) { \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nfloat proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; \nif ( proportion > .5 ) proportion = ( proportion - .5f ) ; \nelse proportion = .5f - proportion ; \nproportion *= 2 ; \nint defaultColor ; \nint selectedColor ; \nif ( pressedItem == position ) { \ndefaultColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, textColor . getDefaultColor ( ) ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed , android . R . attr . state_selected } \n, defaultColor ) ; \n} \nelse { \ndefaultColor = textColor . getDefaultColor ( ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_selected } \n, defaultColor ) ; \n} \nreturn ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; \n} \n} \n"}
{"8393": "public class HorizontalPicker { \nprivate int getInBoundsX ( int x ) { \nif ( x < 0 ) x = 0 ; \nelse if ( x > ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ) x = ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ; \nreturn x ; \n} \n} \n"}
{"8396": "public class ServerMethods { \npublic String [ ] get_keyword_arguments ( String keyword ) { \nif ( keyword . equalsIgnoreCase ( \"stop_remote_server\" ) ) return new String [ 0 ] ; \ntry { \nString [ ] args = servlet . getLibrary ( ) . getKeywordArguments ( keyword ) ; \nreturn args == null ? new String [ 0 ] : args ; \n} \ncatch ( Throwable e ) { \nlog . warn ( \"\" , e ) ; \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"8397": "public class ServerMethods { \npublic String get_keyword_documentation ( String keyword ) { \nif ( keyword . equalsIgnoreCase ( \"stop_remote_server\" ) ) return \"Stops the remote server.\\n\\nThe server may be configured so that users cannot stop it.\" ; \ntry { \nString doc = servlet . getLibrary ( ) . getKeywordDocumentation ( keyword ) ; \nreturn doc == null ? \"\" : doc ; \n} \ncatch ( Throwable e ) { \nlog . warn ( \"\" , e ) ; \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"8398": "public class RemoteServer { \npublic static void main ( String [ ] args ) throws Exception { \nconfigureLogging ( ) ; \nCommandLineHelper helper = new CommandLineHelper ( args ) ; \nif ( helper . getHelpRequested ( ) ) { \nSystem . out . print ( helper . getUsage ( ) ) ; \nSystem . exit ( 0 ) ; \n} \nRemoteServer remoteServer = new RemoteServer ( ) ; \nString error = helper . getError ( ) ; \nif ( error == null ) try { \nfor ( String path : helper . getLibraryMap ( ) . keySet ( ) ) remoteServer . putLibrary ( path , helper . getLibraryMap ( ) . get ( path ) ) ; \n} \ncatch ( IllegalPathException e ) { \nerror = e . getMessage ( ) ; \n} \nif ( error != null ) { \nSystem . out . println ( \"Error: \" + error ) ; \nSystem . out . println ( ) ; \nSystem . out . println ( helper . getUsage ( ) ) ; \nSystem . exit ( 1 ) ; \n} \nremoteServer . setPort ( helper . getPort ( ) ) ; \nremoteServer . setAllowStop ( helper . getAllowStop ( ) ) ; \nremoteServer . setHost ( helper . getHost ( ) ) ; \nremoteServer . start ( ) ; \n} \n} \n"}
{"8399": "public class RemoteServer { \npublic void stop ( int timeoutMS ) throws Exception { \nlog . info ( \"Robot Framework remote server stopping\" ) ; \nif ( timeoutMS > 0 ) { \nserver . setGracefulShutdown ( timeoutMS ) ; \nThread stopper = new Thread ( ) { \n@ Override public void run ( ) { \ntry { \nserver . stop ( ) ; \n} \ncatch ( Throwable e ) { \nlog . error ( String . format ( \"Failed to stop the server: %s\" , e . getMessage ( ) ) , e ) ; \n} \n} \n} \n; \nstopper . start ( ) ; \n} \nelse server . stop ( ) ; \n} \n} \n"}
{"8404": "public class PropertiesToJsonConverter { \npublic String convertToJson ( Properties properties ) throws ParsePropertiesException { \nfor ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { \nif ( ! ( entry . getKey ( ) instanceof String ) ) throw new ParsePropertiesException ( format ( PROPERTY_KEY_NEEDS_TO_BE_STRING_TYPE , entry . getKey ( ) . getClass ( ) , entry . getKey ( ) == null ? \"null\" : entry . getKey ( ) ) ) ; \n} \nreturn convertFromValuesAsObjectMap ( propertiesToMap ( properties ) ) ; \n} \n} \n"}
{"8413": "public class MdPageGeneratorMojo { \n@ SuppressWarnings ( \"UnusedReturnValue\" ) private boolean preprocessMarkdownFiles ( File inputDirectory ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"Read files from: \" + inputDirectory ) ; \ntry { \nif ( ! inputDirectory . exists ( ) ) { \ngetLog ( ) . info ( \"There is no input folder for the project. Skipping.\" ) ; \nreturn false ; \n} \nint baseDepth = StringUtils . countMatches ( inputDirectory . getAbsolutePath ( ) , File . separator ) ; \nList < File > markdownFiles = getFilesAsArray ( FileUtils . iterateFiles ( inputDirectory , getInputFileExtensions ( ) , recursiveInput ) ) ; \nfor ( File file : markdownFiles ) { \ngetLog ( ) . debug ( \"File getName() \" + file . getName ( ) ) ; \ngetLog ( ) . debug ( \"File getAbsolutePath() \" + file . getAbsolutePath ( ) ) ; \ngetLog ( ) . debug ( \"File getPath() \" + file . getPath ( ) ) ; \nMarkdownDTO dto = new MarkdownDTO ( ) ; \ndto . markdownFile = file ; \ndto . folderDepth = StringUtils . countMatches ( file . getAbsolutePath ( ) , File . separator ) - ( baseDepth + 1 ) ; \nif ( alwaysUseDefaultTitle ) dto . title = defaultTitle ; \nelse { \nList < String > raw = FileUtils . readLines ( file , getInputEncoding ( ) ) ; \ndto . title = getTitle ( raw ) ; \n} \nif ( applyFiltering ) for ( String line : FileUtils . readLines ( file , getInputEncoding ( ) ) ) { \nif ( isVariableLine ( line ) ) { \nString key = line . replaceAll ( \"(^\\\\{)|(=.*)\" , \"\" ) ; \nString value = line . replaceAll ( \"(^\\\\{(.*?)=)|(}$)\" , \"\" ) ; \ngetLog ( ) . debug ( \"Substitute: '\" + key + \"' -> '\" + value + \"'\" ) ; \ndto . substitutes . put ( key , value ) ; \n} \n} \nString inputFileExtension = FilenameUtils . getExtension ( file . getName ( ) ) ; \ndto . htmlFile = new File ( recursiveInput ? outputDirectory + File . separator + file . getParentFile ( ) . getPath ( ) . substring ( inputDirectory . getPath ( ) . length ( ) ) + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) : outputDirectory + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) ) ; \ngetLog ( ) . debug ( \"File htmlFile() \" + dto . htmlFile ) ; \nmarkdownDTOs . add ( dto ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to load file \" + e . getMessage ( ) , e ) ; \n} \nreturn true ; \n} \n} \n"}
{"8414": "public class MdPageGeneratorMojo { \nprivate String substituteVariables ( String template , String patternString , Map < String , String > variables ) { \nPattern pattern = Pattern . compile ( patternString ) ; \nMatcher matcher = pattern . matcher ( template ) ; \nStringBuffer buffer = new StringBuffer ( ) ; \nwhile ( matcher . find ( ) ) if ( variables . containsKey ( matcher . group ( 1 ) ) ) { \nString replacement = variables . get ( matcher . group ( 1 ) ) ; \nmatcher . appendReplacement ( buffer , replacement != null ? Matcher . quoteReplacement ( replacement ) : \"null\" ) ; \n} \nmatcher . appendTail ( buffer ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"8415": "public class MdPageGeneratorMojo { \nprivate String getTitle ( List < String > raw ) { \nif ( raw == null ) return defaultTitle ; \nString previousLine = \"\" ; \nfor ( String line : raw ) { \nline = line . trim ( ) ; \nif ( line . startsWith ( \"#\" ) ) { \nline = line . replace ( \"#\" , \"\" ) ; \nreturn line ; \n} \nif ( ( line . startsWith ( \"=\" ) && StringUtils . countMatches ( line , \"=\" ) == previousLine . length ( ) && line . matches ( \"^=+$\" ) ) || ( line . startsWith ( \"-\" ) && StringUtils . countMatches ( line , \"-\" ) == previousLine . length ( ) && line . matches ( \"^-+$\" ) ) ) return previousLine ; \npreviousLine = line ; \n} \nreturn defaultTitle ; \n} \n} \n"}
{"8416": "public class MdPageGeneratorMojo { \nprivate String addTitleToHtmlFile ( String html , String title ) { \nif ( html == null ) return html ; \nif ( title != null ) { \ngetLog ( ) . debug ( \"Setting the title in the HTML file to: \" + title ) ; \nreturn html . replaceFirst ( \"titleToken\" , title ) ; \n} \nelse { \ngetLog ( ) . debug ( \"Title was null, setting the title in the HTML file to an empty string\" ) ; \nreturn html . replaceFirst ( \"titleToken\" , \"\" ) ; \n} \n} \n} \n"}
{"8417": "public class MdPageGeneratorMojo { \nprivate String replaceVariables ( String initialContent , Map < String , String > variables ) { \nString newContent = initialContent ; \nif ( applyFiltering && newContent != null ) { \nnewContent = newContent . replaceAll ( \"\\\\{\\\\w*=.*}\" , \"\" ) ; \nif ( variables != null ) newContent = substituteVariables ( newContent , \"\\\\$\\\\{(.+?)\\\\}\" , variables ) ; \n} \nreturn newContent ; \n} \n} \n"}
{"8418": "public class MdPageGeneratorMojo { \nprivate String updateRelativePaths ( String html , int folderDepth ) { \nif ( html == null ) return html ; \ngetLog ( ) . debug ( \"Updating relative paths in html includes (css, js).\" ) ; \nreturn html . replaceAll ( \"##SITE_BASE##\" , getSiteBasePrefix ( folderDepth ) ) ; \n} \n} \n"}
{"8419": "public class MdPageGeneratorMojo { \nprivate void copyFiles ( String fromDir , String toDir ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"fromDir=\" + fromDir + \"; toDir=\" + toDir ) ; \ntry { \nFile fromDirFile = new File ( fromDir ) ; \nif ( fromDirFile . exists ( ) ) { \nIterator < File > files = FileUtils . iterateFiles ( new File ( fromDir ) , null , false ) ; \nwhile ( files . hasNext ( ) ) { \nFile file = files . next ( ) ; \nif ( file . exists ( ) ) FileUtils . copyFileToDirectory ( file , new File ( toDir ) ) ; \nelse getLog ( ) . error ( \"File '\" + file . getAbsolutePath ( ) + \"' does not exist. Skipping copy\" ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to copy file \" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8425": "public class CrossfadeDrawerLayout { \nprivate void overlapViews ( int width ) { \nif ( width == mWidth ) return ; \nmWidth = width ; \nfloat percentage = calculatePercentage ( width ) ; \nfloat alpha = percentage / 100 ; \nmSmallView . setAlpha ( 1 ) ; \nmSmallView . setClickable ( false ) ; \nmLargeView . bringToFront ( ) ; \nmLargeView . setAlpha ( alpha ) ; \nmLargeView . setClickable ( true ) ; \nmLargeView . setVisibility ( alpha > 0.01f ? View . VISIBLE : View . GONE ) ; \nif ( mCrossfadeListener != null ) mCrossfadeListener . onCrossfade ( mContainer , calculatePercentage ( width ) , width ) ; \n} \n} \n"}
{"8431": "public class ApiClient { \nprivate Client buildHttpClient ( boolean debugging ) { \nfinal ClientConfig clientConfig = new ClientConfig ( ) ; \nclientConfig . register ( MultiPartFeature . class ) ; \nclientConfig . register ( json ) ; \nclientConfig . register ( JacksonFeature . class ) ; \nif ( debugging ) clientConfig . register ( LoggingFilter . class ) ; \nreturn ClientBuilder . newClient ( clientConfig ) ; \n} \n} \n"}
{"8433": "public class ModelsApi { \npublic DataModelUpdateResponse updateDataModel ( DataModel body , Boolean force , String workspaceId ) throws ApiException { \nObject localVarPostBody = body ; \nif ( body == null ) throw new ApiException ( 400 , \"Missing the required parameter 'body' when calling updateDataModel\" ) ; \nString localVarPath = \"/models/dataModel\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) ; \nList < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; \nMap < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; \nlocalVarQueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"force\" , force ) ) ; \nlocalVarQueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"workspaceId\" , workspaceId ) ) ; \nfinal String [ ] localVarAccepts = { \n\"application/json\" } \n; \nfinal String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; \nfinal String [ ] localVarContentTypes = { \n\"application/json\" } \n; \nfinal String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; \nString [ ] localVarAuthNames = new String [ ] { \n\"token\" } \n; \nGenericType < DataModelUpdateResponse > localVarReturnType = new GenericType < DataModelUpdateResponse > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( localVarPath , \"PUT\" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; \n} \n} \n"}
{"8438": "public class GraphqlApi { \npublic GraphQLResult processGraphQLMultipart ( String graphQLRequest , File file ) throws ApiException { \nObject localVarPostBody = null ; \nif ( graphQLRequest == null ) throw new ApiException ( 400 , \"Missing the required parameter 'graphQLRequest' when calling processGraphQLMultipart\" ) ; \nif ( file == null ) throw new ApiException ( 400 , \"Missing the required parameter 'file' when calling processGraphQLMultipart\" ) ; \nString localVarPath = \"/graphql/upload\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) ; \nList < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; \nMap < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; \nif ( graphQLRequest != null ) localVarFormParams . put ( \"graphQLRequest\" , graphQLRequest ) ; \nif ( file != null ) localVarFormParams . put ( \"file\" , file ) ; \nfinal String [ ] localVarAccepts = { \n\"application/json\" } \n; \nfinal String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; \nfinal String [ ] localVarContentTypes = { \n\"multipart/form-data\" } \n; \nfinal String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; \nString [ ] localVarAuthNames = new String [ ] { \n\"token\" } \n; \nGenericType < GraphQLResult > localVarReturnType = new GenericType < GraphQLResult > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( localVarPath , \"POST\" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; \n} \n} \n"}
{"8439": "public class BookmarksApi { \npublic BookmarkListResponse getBookmarks ( String bookmarkType , String groupKey , String sharingType ) throws ApiException { \nObject localVarPostBody = null ; \nif ( bookmarkType == null ) throw new ApiException ( 400 , \"Missing the required parameter 'bookmarkType' when calling getBookmarks\" ) ; \nString localVarPath = \"/bookmarks\" . replaceAll ( \"\\\\{format\\\\}\" , \"json\" ) ; \nList < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; \nMap < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; \nMap < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; \nlocalVarQueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"bookmarkType\" , bookmarkType ) ) ; \nlocalVarQueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"groupKey\" , groupKey ) ) ; \nlocalVarQueryParams . addAll ( apiClient . parameterToPairs ( \"\" , \"sharingType\" , sharingType ) ) ; \nfinal String [ ] localVarAccepts = { \n\"application/json\" } \n; \nfinal String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; \nfinal String [ ] localVarContentTypes = { \n\"application/json\" } \n; \nfinal String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; \nString [ ] localVarAuthNames = new String [ ] { \n\"token\" } \n; \nGenericType < BookmarkListResponse > localVarReturnType = new GenericType < BookmarkListResponse > ( ) { \n} \n; \nreturn apiClient . invokeAPI ( localVarPath , \"GET\" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; \n} \n} \n"}
{"8442": "public class MarkLogicDatasetGraph { \npublic MarkLogicDatasetGraph withRulesets ( SPARQLRuleset ... rulesets ) { \nif ( this . rulesets == null ) this . rulesets = rulesets ; \nelse { \nCollection < SPARQLRuleset > collection = new ArrayList < SPARQLRuleset > ( ) ; \ncollection . addAll ( Arrays . asList ( this . rulesets ) ) ; \ncollection . addAll ( Arrays . asList ( rulesets ) ) ; \nthis . rulesets = collection . toArray ( new SPARQLRuleset [ ] { \n} \n) ; \n} \nreturn this ; \n} \n} \n"}
{"8443": "public class JenaDatabaseClient { \npublic void close ( ) { \nif ( writeBuffer != null ) writeBuffer . cancel ( ) ; \nif ( timer != null ) timer . cancel ( ) ; \nclient = null ; \n} \n} \n"}
{"8444": "public class JenaDatabaseClient { \npublic synchronized InputStreamHandle executeSelect ( SPARQLQueryDefinition qdef , InputStreamHandle handle , Long offset , Long limit ) { \nif ( limit == null ) this . sparqlQueryManager . clearPageLength ( ) ; \nelse this . sparqlQueryManager . setPageLength ( limit ) ; \nif ( offset != null ) return this . sparqlQueryManager . executeSelect ( qdef , handle , offset , currentTransaction ) ; \nelse return this . sparqlQueryManager . executeSelect ( qdef , handle , currentTransaction ) ; \n} \n} \n"}
{"8448": "public class GMOperation { \npublic GMOperation rotate ( final double degrees , final RotationAnnotation annotation ) { \nif ( annotation == null ) throw new IllegalArgumentException ( \"Rotation annotation must be defined\" ) ; \nfinal List < String > args = getCmdArgs ( ) ; \nargs . add ( \"-rotate\" ) ; \nargs . add ( String . format ( Locale . ENGLISH , \"%.1f%s\" , degrees , annotation . asAnnotation ( ) ) ) ; \nreturn this ; \n} \n} \n"}
{"8449": "public class GMOperation { \npublic GMOperation gravity ( final Gravity value ) { \nif ( value == null ) throw new IllegalArgumentException ( \"Gravity value must be defined\" ) ; \ngravity ( value . toString ( ) ) ; \nreturn this ; \n} \n} \n"}
{"8451": "public class GMOperation { \npublic GMOperation font ( final String style , final int size , final String color ) { \nif ( isBlank ( style ) ) throw new IllegalArgumentException ( \"Text font style must be defined\" ) ; \nif ( isBlank ( color ) ) throw new IllegalArgumentException ( \"Text font color must be defined\" ) ; \nfont ( style ) ; \npointsize ( size ) ; \nfill ( color ) ; \nreturn this ; \n} \n} \n"}
{"8452": "public class GMOperation { \npublic GMOperation source ( final File file , @ CheckForNull final Integer width , @ CheckForNull final Integer height ) throws IOException { \nif ( file != null && ! file . exists ( ) ) throw new IOException ( \"Source file '\" + file + \"' does not exist\" ) ; \nif ( ( width != null ) && ( height != null ) && ( width > 0 ) && ( height > 0 ) ) size ( width , height ) ; \nreturn addImage ( file ) ; \n} \n} \n"}
{"8453": "public class GMOperation { \npublic GMOperation addImage ( final File file ) { \nif ( file == null ) throw new IllegalArgumentException ( \"file must be defined\" ) ; \ngetCmdArgs ( ) . add ( file . getPath ( ) ) ; \nreturn this ; \n} \n} \n"}
{"8454": "public class Args { \npublic static List < String > parse ( Object target , String [ ] args ) { \nList < String > arguments = new ArrayList < String > ( ) ; \narguments . addAll ( Arrays . asList ( args ) ) ; \nClass < ? > clazz ; \nif ( target instanceof Class ) clazz = ( Class ) target ; \nelse { \nclazz = target . getClass ( ) ; \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \nprocessProperty ( target , pd , arguments ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \nfor ( Class < ? > currentClazz = clazz ; \ncurrentClazz != null ; \ncurrentClazz = currentClazz . getSuperclass ( ) ) for ( Field field : currentClazz . getDeclaredFields ( ) ) { \nprocessField ( target , field , arguments ) ; \n} \nfor ( String argument : arguments ) { \nif ( argument . startsWith ( \"-\" ) ) throw new IllegalArgumentException ( \"Invalid argument: \" + argument ) ; \n} \nreturn arguments ; \n} \n} \n"}
{"8455": "public class Args { \npublic static void usage ( PrintStream errStream , Object target ) { \nClass < ? > clazz ; \nif ( target instanceof Class ) clazz = ( Class ) target ; \nelse clazz = target . getClass ( ) ; \nerrStream . println ( \"Usage: \" + clazz . getName ( ) ) ; \nfor ( Class < ? > currentClazz = clazz ; \ncurrentClazz != null ; \ncurrentClazz = currentClazz . getSuperclass ( ) ) for ( Field field : currentClazz . getDeclaredFields ( ) ) { \nfieldUsage ( errStream , target , field ) ; \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \npropertyUsage ( errStream , target , pd ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n} \n"}
{"8456": "public class UnitConverter { \npublic static TimeUnit extractTimeUnitFromString ( String timeString ) { \ntimeString = timeString . toLowerCase ( ) ; \nif ( timeString . contains ( \"minute\" ) ) return TimeUnit . MINUTES ; \nelse if ( timeString . contains ( \"microsecond\" ) ) return TimeUnit . MICROSECONDS ; \nelse if ( timeString . contains ( \"millisecond\" ) ) return TimeUnit . MILLISECONDS ; \nelse if ( timeString . contains ( \"second\" ) ) return TimeUnit . SECONDS ; \nelse if ( timeString . contains ( \"hour\" ) ) return TimeUnit . HOURS ; \nelse if ( timeString . toLowerCase ( ) . contains ( \"day\" ) ) return TimeUnit . DAYS ; \nelse return null ; \n} \n} \n"}
{"8457": "public class PropertiesArgs { \npublic static void parse ( Object target , Properties arguments ) { \nClass clazz ; \nif ( target instanceof Class ) clazz = ( Class ) target ; \nelse clazz = target . getClass ( ) ; \nfor ( Field field : clazz . getDeclaredFields ( ) ) { \nprocessField ( target , field , arguments ) ; \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \nprocessProperty ( target , pd , arguments ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n} \n"}
{"8465": "public class Selector { \npublic Selector overlapVerticallyWith ( final SlideElement element , final float minOverlapRatio ) { \ncheckNotNull ( element ) ; \nfinal Rectangle r1 = element . getBounds ( ) ; \nr1 . x = 0 ; \nr1 . width = 1 ; \nelements = Collections2 . filter ( elements , new Predicate < SlideElement > ( ) { \n@ Override public boolean apply ( SlideElement e ) { \nif ( e == element ) return false ; \nif ( r1 . height == 0 ) return false ; \nRectangle r2 = e . getBounds ( ) ; \nr2 . x = 0 ; \nr2 . width = 1 ; \nRectangle intersection = r1 . intersection ( r2 ) ; \nfloat yOverlapRatio = 1f * intersection . height / r1 . height ; \nreturn yOverlapRatio > minOverlapRatio ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"8466": "public class SqsExecutor { \npublic Object executeOutboundOperation ( final Message < ? > message ) { \ntry { \nString serializedMessage = messageMarshaller . serialize ( message ) ; \nif ( queue == null ) { \nSendMessageRequest request = new SendMessageRequest ( queueUrl , serializedMessage ) ; \nSendMessageResult result = sqsClient . sendMessage ( request ) ; \nlog . debug ( \"Message sent, Id:\" + result . getMessageId ( ) ) ; \n} \nelse queue . add ( serializedMessage ) ; \n} \ncatch ( MessageMarshallerException e ) { \nlog . error ( e . getMessage ( ) , e ) ; \nthrow new MessagingException ( e . getMessage ( ) , e . getCause ( ) ) ; \n} \nreturn message . getPayload ( ) ; \n} \n} \n"}
{"8467": "public class SnsExecutor { \npublic Object executeOutboundOperation ( final Message < ? > message ) { \ntry { \nString serializedMessage = messageMarshaller . serialize ( message ) ; \nif ( snsTestProxy == null ) { \nPublishRequest request = new PublishRequest ( ) ; \nPublishResult result = client . publish ( request . withTopicArn ( topicArn ) . withMessage ( serializedMessage ) ) ; \nlog . debug ( \"Published message to topic: \" + result . getMessageId ( ) ) ; \n} \nelse snsTestProxy . dispatchMessage ( serializedMessage ) ; \n} \ncatch ( MessageMarshallerException e ) { \nlog . error ( e . getMessage ( ) , e ) ; \nthrow new MessagingException ( e . getMessage ( ) , e . getCause ( ) ) ; \n} \nreturn message . getPayload ( ) ; \n} \n} \n"}
{"8468": "public class JNE { \nsynchronized static public File requireFile ( String name , Options options ) throws IOException { \nFile file = findFile ( name , options ) ; \nif ( file == null ) throw new ResourceNotFoundException ( \"Resource file \" + name + \" not found\" ) ; \nreturn file ; \n} \n} \n"}
{"8469": "public class JNE { \nstatic private File getOrCreateTempDirectory ( boolean deleteOnExit ) throws ExtractException { \nif ( ( TEMP_DIRECTORY != null ) && TEMP_DIRECTORY . exists ( ) ) return TEMP_DIRECTORY ; \ntry { \nPath baseDir = Paths . get ( System . getProperty ( \"java.io.tmpdir\" ) ) ; \nPath tempDirectory = baseDir . resolve ( \"jne.\" + UUID . randomUUID ( ) . toString ( ) ) ; \nFiles . createDirectories ( tempDirectory ) ; \nFile tempDirectoryAsFile = tempDirectory . toFile ( ) ; \nif ( deleteOnExit ) tempDirectoryAsFile . deleteOnExit ( ) ; \nTEMP_DIRECTORY = tempDirectoryAsFile ; \nreturn TEMP_DIRECTORY ; \n} \ncatch ( IOException e ) { \nthrow new ExtractException ( \"Unable to create temporary dir\" , e ) ; \n} \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal int contextValuesLength = values == null ? 0 : values . size ( ) ; \nfor ( int i = 0 ; \ni < keys . size ( ) ; \n++ i ) { \nfinal String key = keys . get ( i ) ; \nif ( i >= contextValuesLength ) jsonGenerator . writeObjectField ( key , null ) ; \nelse { \nfinal Object value = values . get ( i ) ; \nif ( isSimpleType ( value ) ) jsonGenerator . writeObjectField ( key , value ) ; \nelse { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \n} \n} \n} \n} \n} \n"}
{"8487": "public class AbstractStenoCallerConverter { \nprotected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { \nfinal StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; \nif ( callerData != null ) for ( int i = 0 ; \ni < callerData . length ; \n++ i ) { \nfinal String callerClassName = callerData [ i ] . getClassName ( ) ; \nif ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) return callerData [ i ] ; \n} \nreturn null ; \n} \n} \n"}
{"8488": "public class SafeSerializationHelper { \npublic static void safeEncodeValue ( final StringBuilder encoder , @ Nullable final Object value ) { \nif ( value == null ) encoder . append ( \"null\" ) ; \nelse if ( value instanceof Map ) safeEncodeMap ( encoder , ( Map < ? , ? > ) value ) ; \nelse if ( value instanceof List ) safeEncodeList ( encoder , ( List < ? > ) value ) ; \nelse if ( value . getClass ( ) . isArray ( ) ) safeEncodeArray ( encoder , value ) ; \nelse if ( value instanceof LogValueMapFactory . LogValueMap ) safeEncodeLogValueMap ( encoder , ( LogValueMapFactory . LogValueMap ) value ) ; \nelse if ( value instanceof Throwable ) safeEncodeThrowable ( encoder , ( Throwable ) value ) ; \nelse if ( StenoSerializationHelper . isSimpleType ( value ) ) if ( value instanceof Boolean ) encoder . append ( BooleanNode . valueOf ( ( Boolean ) value ) . toString ( ) ) ; \nelse if ( value instanceof Double ) encoder . append ( DoubleNode . valueOf ( ( Double ) value ) . toString ( ) ) ; \nelse if ( value instanceof Float ) encoder . append ( FloatNode . valueOf ( ( Float ) value ) . toString ( ) ) ; \nelse if ( value instanceof Long ) encoder . append ( LongNode . valueOf ( ( Long ) value ) . toString ( ) ) ; \nelse if ( value instanceof Integer ) encoder . append ( IntNode . valueOf ( ( Integer ) value ) . toString ( ) ) ; \nelse encoder . append ( new TextNode ( value . toString ( ) ) . toString ( ) ) ; \nelse safeEncodeValue ( encoder , LogReferenceOnly . of ( value ) . toLogValue ( ) ) ; \n} \n} \n"}
{"8490": "public class AbsObjectPool { \nprotected void checkMappings ( int arrayPosition ) { \nfinal int index = positions . indexOfValue ( arrayPosition ) ; \nif ( index >= 0 ) positions . removeAt ( index ) ; \n} \n} \n"}
{"8491": "public class SaveAttrsUtility { \npublic static String parseSaveAttr ( final Cell cell , final Map < String , String > saveCommentsMap ) { \nif ( cell != null ) { \nString key = cell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , cell . getRowIndex ( ) ) ; \nString saveAttr = null ; \nif ( saveCommentsMap != null ) saveAttr = ParserUtility . getStringBetweenBracket ( saveCommentsMap . get ( key ) ) ; \nif ( ( saveAttr == null ) && ( cell . getCellTypeEnum ( ) == CellType . STRING ) ) saveAttr = SaveAttrsUtility . parseSaveAttrString ( cell . getStringCellValue ( ) ) ; \nif ( ( saveAttr != null ) && ( ! saveAttr . isEmpty ( ) ) ) return TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + \"=\" + saveAttr + \",\" ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8493": "public class SaveAttrsUtility { \npublic static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { \nif ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) return ; \nint ipos = fullSaveAttr . indexOf ( '=' ) ; \nif ( ipos > 0 ) { \nString columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; \nString saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; \nCell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; \nif ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) CommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; \n} \n} \n} \n"}
{"8494": "public class SaveAttrsUtility { \npublic static String parseSaveAttrString ( final String strValue ) { \nif ( strValue != null ) { \nint first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; \nint last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; \nint end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; \nif ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) return strValue . substring ( first + 2 , end ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8495": "public class SaveAttrsUtility { \npublic static String getSaveAttrListFromRow ( final Row row ) { \nif ( row != null ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; \nif ( cell != null ) { \nString str = cell . getStringCellValue ( ) ; \nif ( ( str != null ) && ( ! str . isEmpty ( ) ) ) return str ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8496": "public class SaveAttrsUtility { \npublic static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { \nif ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { \nString str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + \"=\" ; \nint istart = saveAttrs . indexOf ( str ) ; \nif ( istart >= 0 ) { \nint iend = saveAttrs . indexOf ( ',' , istart ) ; \nif ( iend > istart ) return saveAttrs . substring ( istart + str . length ( ) , iend ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8498": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { \nfor ( Row row : sheet ) { \nint rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) setSaveAttrsForRow ( row , saveCommentsMap ) ; \n} \n} \n} \n"}
{"8499": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForRow ( final Row row , final Map < String , String > saveCommentsMap ) { \nStringBuilder saveAttr = new StringBuilder ( ) ; \nfor ( Cell cell : row ) { \nString sAttr = parseSaveAttr ( cell , saveCommentsMap ) ; \nif ( ! sAttr . isEmpty ( ) ) saveAttr . append ( sAttr ) ; \n} \nif ( saveAttr . length ( ) > 0 ) SaveAttrsUtility . setSaveObjectsInHiddenColumn ( row , saveAttr . toString ( ) ) ; \n} \n} \n"}
{"8500": "public class SaveAttrsUtility { \npublic static String prepareContextAndAttrsForCell ( Cell poiCell , String fullName , CellHelper cellHelper ) { \nif ( fullName == null ) return null ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( poiCell . getRow ( ) ) ; \nif ( saveAttrList != null ) { \nString saveAttr = SaveAttrsUtility . getSaveAttrFromList ( poiCell . getColumnIndex ( ) , saveAttrList ) ; \nif ( saveAttr != null ) { \ncellHelper . restoreDataContext ( fullName ) ; \nreturn saveAttr ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8501": "public class TieSheetNumberConverter { \nprivate String fmtNumber ( final double d ) { \nif ( Double . compare ( d % 1 , 0 ) == 0 ) return String . format ( \"%d\" , ( int ) d ) ; \nelse return String . format ( \"%.2f\" , d ) ; \n} \n} \n"}
{"8504": "public class TieWebSheetBean { \npublic XSSFEvaluationWorkbook getWbWrapper ( ) { \nif ( ( this . wbWrapper == null ) && ( this . getWb ( ) != null ) ) this . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) this . getWb ( ) ) ; \nreturn wbWrapper ; \n} \n} \n"}
{"8505": "public class TieWebSheetBean { \npublic FormulaEvaluator getFormulaEvaluator ( ) { \nif ( ( this . formulaEvaluator == null ) && ( this . getWb ( ) != null ) ) this . formulaEvaluator = this . getWb ( ) . getCreationHelper ( ) . createFormulaEvaluator ( ) ; \nreturn formulaEvaluator ; \n} \n} \n"}
{"8506": "public class TieWebSheetBean { \npublic void reCalcMaxColCounts ( ) { \nif ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { \nthis . maxColCounts = 0 ; \nreturn ; \n} \nint maxColumns = 0 ; \nfor ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { \nint counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; \nif ( maxColumns < counts ) maxColumns = counts ; \n} \nthis . maxColCounts = maxColumns ; \n} \n} \n"}
{"8514": "public class TieWebSheetBean { \npublic SheetConfiguration getCurrentSheetConfig ( ) { \nString currentTabName = this . getCurrent ( ) . getCurrentTabName ( ) ; \nif ( currentTabName == null ) return null ; \nreturn this . getSheetConfigMap ( ) . get ( currentTabName ) ; \n} \n} \n"}
{"8516": "public class DateTimeCustomConverter { \nprivate Locale getLocale ( final FacesContext context , final UIComponent component ) { \nString localeStr = ( String ) component . getAttributes ( ) . get ( TieConstants . COMPONENT_ATTR_LOCALE ) ; \nif ( localeStr == null ) return context . getViewRoot ( ) . getLocale ( ) ; \nreturn Locale . forLanguageTag ( localeStr ) ; \n} \n} \n"}
{"8518": "public class TieWebSheetBeanHelper { \npublic final CellHelper getCellHelper ( ) { \nif ( ( this . cellHelper == null ) && ( this . parent != null ) ) this . cellHelper = new CellHelper ( parent ) ; \nreturn cellHelper ; \n} \n} \n"}
{"8519": "public class TieWebSheetBeanHelper { \npublic final PicturesHelper getPicHelper ( ) { \nif ( ( this . picHelper == null ) && ( this . parent != null ) ) this . picHelper = new PicturesHelper ( parent ) ; \nreturn picHelper ; \n} \n} \n"}
{"8520": "public class TieWebSheetBeanHelper { \npublic final ValidationHandler getValidationHandler ( ) { \nif ( ( this . validationHandler == null ) && ( this . parent != null ) ) this . validationHandler = new ValidationHandler ( parent ) ; \nreturn validationHandler ; \n} \n} \n"}
{"8521": "public class TieWebSheetBeanHelper { \npublic final ChartHelper getChartHelper ( ) { \nif ( ( this . chartHelper == null ) && ( this . parent != null ) ) this . chartHelper = new ChartHelper ( parent ) ; \nreturn chartHelper ; \n} \n} \n"}
{"8523": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { \nbyte originalOperandClass = - 1 ; \nif ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) originalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; \nint currentRow ; \ncurrentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( ( currentRow >= 0 ) && shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) return convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; \nif ( ( ptg instanceof AttrPtg ) && ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) ) { \nAttrPtg newPtg = ( AttrPtg ) ptg ; \nif ( newPtg . isSum ( ) ) { \nFuncVarPtg fptg = FuncVarPtg . create ( \"sum\" , shiftFormulaRef . getFormulaChanged ( ) ) ; \nreturn singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \nreturn singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \n"}
{"8524": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtgForWatchList ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg , final byte originalOperandClass , final int currentRow ) { \nList < SerialRow > rowlist = getRowsList ( currentRow , shiftFormulaRef . getCurrentRowsMappingList ( ) ) ; \nif ( ( rowlist == null ) || ( rowlist . isEmpty ( ) ) ) return singlePtg ( ptg , originalOperandClass , - 1 ) ; \nshiftFormulaRef . setFormulaChanged ( 1 ) ; \nif ( ( rowlist . size ( ) == 1 ) || ( ( position + 1 ) >= ptgs . length ) || ! ( ptgs [ position + 1 ] instanceof ParenthesisPtg ) ) return singlePtg ( fixupRefRelativeRowOneToOne ( ptg , rowlist . get ( 0 ) . getRow ( ) ) , originalOperandClass , - 1 ) ; \nshiftFormulaRef . setFormulaChanged ( rowlist . size ( ) ) ; \nreturn fixupRefRelativeRowOneToMany ( ptg , originalOperandClass , rowlist , ptgs , position ) ; \n} \n} \n"}
{"8525": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] singlePtg ( final Object ptg , final byte originalOperandClass , final int formulaChanged ) { \nPtg [ ] newPtg = new Ptg [ 1 ] ; \nif ( originalOperandClass != ( - 1 ) ) ( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; \nObject ptgAfter = ptg ; \nif ( ptg instanceof FuncVarPtg ) { \nFuncVarPtg fptg = ( FuncVarPtg ) ptg ; \nif ( ( formulaChanged > 0 ) && ( fptg . getNumberOfOperands ( ) != formulaChanged ) ) ptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , formulaChanged ) ; \n} \nnewPtg [ 0 ] = ( Ptg ) ptgAfter ; \nreturn newPtg ; \n} \n} \n"}
{"8526": "public class ShiftFormulaUtility { \nprivate static List < SerialRow > getRowsList ( final int currentRow , final List < RowsMapping > currentRowsMappingList ) { \nList < SerialRow > all = null ; \nint size = currentRowsMappingList . size ( ) ; \nfor ( RowsMapping rowsmapping : currentRowsMappingList ) { \nList < SerialRow > current = rowsmapping . get ( currentRow ) ; \nif ( current != null ) { \nif ( size == 1 ) return current ; \nall = assembleRowsListFromRowsMapping ( all , current ) ; \n} \n} \nreturn all ; \n} \n} \n"}
{"8527": "public class ShiftFormulaUtility { \nprivate static List < SerialRow > assembleRowsListFromRowsMapping ( final List < SerialRow > all , final List < SerialRow > current ) { \nList < SerialRow > list ; \nif ( all == null ) { \nlist = new ArrayList < > ( ) ; \nlist . addAll ( current ) ; \n} \nelse { \nlist = all ; \nfor ( SerialRow row : current ) { \nif ( ! all . contains ( row ) ) list . add ( row ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8528": "public class ShiftFormulaUtility { \nprotected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { \nif ( ptg instanceof RefPtgBase ) if ( ptg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = ( RefPtgBase ) ptg ; \nreturn new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nelse if ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nint shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; \nnew3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; \nnew3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nint shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; \nreturn new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) unitSize = 2 ; \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nint originFirstRow = areaPtg . getFirstRow ( ) ; \nint originLastRow = areaPtg . getLastRow ( ) ; \nint unitSize = 2 ; \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nint shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nif ( i < ( rowList . size ( ) - 1 ) ) newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n"}
{"8531": "public class ColorUtility { \npublic static XColor getBgColor ( final CTPlotArea ctPlot , final ThemesTable themeTable ) { \nCTSolidColorFillProperties colorFill = null ; \ntry { \ncolorFill = ctPlot . getSpPr ( ) . getSolidFill ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No entry in bgcolor for solidFill\" , ex ) ; \n} \nXColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; \nif ( xcolor != null ) return xcolor ; \nelse return new XColor ( new XSSFColor ( Color . WHITE ) ) ; \n} \n} \n"}
{"8532": "public class ColorUtility { \npublic static XColor geColorFromSpPr ( final int index , final CTShapeProperties ctSpPr , final ThemesTable themeTable , final boolean isLineColor ) { \nCTSolidColorFillProperties colorFill = null ; \ntry { \nif ( isLineColor ) colorFill = ctSpPr . getLn ( ) . getSolidFill ( ) ; \nelse colorFill = ctSpPr . getSolidFill ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"No entry for solidFill\" , ex ) ; \n} \nXColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; \nif ( xcolor != null ) return xcolor ; \nelse return getXColorWithAutomaticFill ( index , themeTable ) ; \n} \n} \n"}
{"8533": "public class ColorUtility { \nprivate static XColor findAutomaticFillColor ( final ThemesTable themeTable , final CTSolidColorFillProperties colorFill ) { \nif ( colorFill == null ) return null ; \nCTSchemeColor ctsColor = colorFill . getSchemeClr ( ) ; \nif ( ctsColor != null ) return getXColorFromSchemeClr ( ctsColor , themeTable ) ; \nelse { \nCTSRgbColor ctrColor = colorFill . getSrgbClr ( ) ; \nif ( ctrColor != null ) return getXColorFromRgbClr ( ctrColor ) ; \n} \nreturn null ; \n} \n} \n"}
{"8534": "public class ColorUtility { \nprivate static XColor getXColorFromSchemeClr ( final CTSchemeColor ctsColor , final ThemesTable themeTable ) { \nif ( ctsColor . getVal ( ) != null ) return getXColorWithSchema ( ctsColor . getVal ( ) . toString ( ) , 0 , ctsColor , themeTable ) ; \nreturn null ; \n} \n} \n"}
{"8536": "public class ColorUtility { \nprivate static XColor getXColorWithAutomaticFill ( final int index , final ThemesTable themeTable ) { \nint reminder = ( index + 1 ) % AUTOCOLORSIZE ; \nif ( reminder == 0 ) reminder = AUTOCOLORSIZE ; \nString schema = AUTOCOLORNAME + reminder ; \ndouble tint = getAutomaticTint ( index ) ; \nreturn getXColorWithSchema ( schema , tint , null , themeTable ) ; \n} \n} \n"}
{"8538": "public class ColorUtility { \npublic static short [ ] getTripletFromXSSFColor ( final XSSFColor xssfColor ) { \nshort [ ] rgbfix = { \nRGB8BITS , RGB8BITS , RGB8BITS } \n; \nif ( xssfColor != null ) { \nbyte [ ] rgb = xssfColor . getRGBWithTint ( ) ; \nif ( rgb == null ) rgb = xssfColor . getRGB ( ) ; \nrgbfix [ 0 ] = ( short ) ( ( rgb [ 0 ] < 0 ) ? ( rgb [ 0 ] + RGB8BITS ) : rgb [ 0 ] ) ; \nrgbfix [ 1 ] = ( short ) ( ( rgb [ 1 ] < 0 ) ? ( rgb [ 1 ] + RGB8BITS ) : rgb [ 1 ] ) ; \nrgbfix [ 2 ] = ( short ) ( ( rgb [ 2 ] < 0 ) ? ( rgb [ 2 ] + RGB8BITS ) : rgb [ 2 ] ) ; \n} \nreturn rgbfix ; \n} \n} \n"}
{"8539": "public class ColorUtility { \nstatic String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { \nString style = \"\" ; \nif ( poiCell instanceof HSSFCell ) { \nint bkColorIndex = cellStyle . getFillForegroundColor ( ) ; \nHSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; \nif ( color != null ) { \nHSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; \nHSSFColor color2 = palette . getColor ( bkColorIndex ) ; \nif ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) color = color2 ; \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( color . getTriplet ( ) , \",\" ) + \");\" ; \n} \n} \nelse if ( poiCell instanceof XSSFCell ) { \nXSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; \nif ( color != null ) style = \"background-color:rgb(\" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , \",\" ) + \");\" ; \n} \nreturn style ; \n} \n} \n"}
{"8540": "public class CellControlsUtility { \nprivate static String findComponentNameFromClass ( final UIComponent component ) { \nString cname = component . getClass ( ) . getSimpleName ( ) ; \nif ( supportComponents . contains ( cname ) ) return cname ; \nreturn null ; \n} \n} \n"}
{"8541": "public class CellControlsUtility { \npublic static void populateAttributes ( final UIComponent component , final FacesCell fcell , final Map < String , Map < String , String > > defaultControlMap ) { \nList < CellFormAttributes > inputAttrs = fcell . getInputAttrs ( ) ; \nString cname = findComponentNameFromClass ( component ) ; \nif ( cname == null ) return ; \nMap < String , String > defaultMap = defaultControlMap . get ( cname ) ; \nif ( defaultMap == null ) { \ndefaultMap = new HashMap < > ( ) ; \ndefaultControlMap . put ( cname , defaultMap ) ; \n} \nfor ( Map . Entry < String , String > entry : defaultMap . entrySet ( ) ) { \nsetObjectProperty ( component , entry . getKey ( ) , entry . getValue ( ) , true ) ; \n} \nfor ( CellFormAttributes attr : inputAttrs ) { \nString propertyName = attr . getType ( ) ; \nString propertyValue = attr . getValue ( ) ; \nif ( ! defaultMap . containsKey ( propertyName ) ) { \nString defaultValue = getObjectPropertyValue ( component , propertyName , true ) ; \ndefaultMap . put ( propertyName , defaultValue ) ; \n} \nsetObjectProperty ( component , propertyName , propertyValue , true ) ; \n} \n} \n} \n"}
{"8543": "public class CellControlsUtility { \npublic static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { \ntry { \nString methodName = \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; \nAttributesType parameterType = matchParaMeterOfMethod ( obj , methodName ) ; \nif ( parameterType != null ) { \nMethod method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { \nparameterType . clazz } \n) ; \nmethod . invoke ( obj , convertToObject ( parameterType , propertyValue ) ) ; \n} \n} \ncatch ( Exception e ) { \nString msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; \nif ( ignoreNonExisting ) LOG . log ( Level . FINE , msg , e ) ; \nelse { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \n} \n} \n} \n"}
{"8544": "public class CellControlsUtility { \npublic static String getObjectPropertyValue ( final Object obj , final String propertyName , final boolean ignoreNonExisting ) { \ntry { \nMethod method = obj . getClass ( ) . getMethod ( \"get\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ) ; \nreturn ( String ) method . invoke ( obj ) ; \n} \ncatch ( Exception e ) { \nString msg = \"failed to get property '\" + propertyName + \"' for object \" + obj ; \nif ( ignoreNonExisting ) LOG . log ( Level . FINE , msg , e ) ; \nelse { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8545": "public class CellControlsUtility { \npublic static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { \nint rowIndex = originRowIndex ; \nif ( rowIndex < 0 ) rowIndex = poiCell . getRowIndex ( ) ; \nString skey = poiCell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; \nMap < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( \"$$\" ) ; \nif ( commentMap != null ) { \nString comment = commentMap . get ( skey ) ; \nif ( comment != null ) CommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; \n} \nString widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; \nif ( widgetType != null ) { \nfcell . setControl ( widgetType . toLowerCase ( ) ) ; \nfcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; \nfcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; \nfcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; \n} \n} \n} \n"}
{"8547": "public class PicturesHelper { \npublic final void setupFacesCellPictureCharts ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { \nif ( parent . getPicturesMap ( ) != null ) setupFacesCellPicture ( sheet1 , fcell , cell , fId ) ; \nif ( parent . getCharsData ( ) . getChartsMap ( ) != null ) setupFacesCellCharts ( sheet1 , fcell , cell , fId ) ; \n} \n} \n"}
{"8550": "public class ChartHelper { \nprivate void initChartsMap ( final Workbook wb ) { \ntry { \nif ( wb instanceof XSSFWorkbook ) initXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"getChartsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8551": "public class ChartHelper { \nprivate String getPieTitle ( final ChartData chartData ) { \nfor ( ChartSeries chartSeries : chartData . getSeriesList ( ) ) { \nif ( chartSeries != null ) return getParsedCellValue ( chartSeries . getSeriesLabel ( ) ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8552": "public class ChartHelper { \npublic final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { \nif ( chart != null && style != null ) { \nBasicStroke stroke = ChartUtility . toStroke ( style ) ; \nPlot plot = chart . getPlot ( ) ; \nif ( plot instanceof CategoryPlot ) { \nCategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; \nCategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; \ntry { \ncir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse if ( plot instanceof XYPlot ) { \nXYPlot xyPlot = chart . getXYPlot ( ) ; \nXYItemRenderer xyir = xyPlot . getRenderer ( ) ; \ntry { \nxyir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse LOG . log ( Level . FINE , \"setSeriesColor() unsupported plot: {}\" , plot . toString ( ) ) ; \n} \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) for ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \n} \n} \n"}
{"8556": "public class ChartHelper { \nprivate String getChartIdFromParent ( final XSSFChart chart , final String sheetName ) { \nif ( chart . getParent ( ) != null ) for ( RelationPart rp : chart . getParent ( ) . getRelationParts ( ) ) { \nif ( rp . getDocumentPart ( ) == chart ) return sheetName + \"!\" + rp . getRelationship ( ) . getId ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8557": "public class ChartHelper { \nprivate void initAnchorsMap ( final Workbook wb , final ChartsData chartsData ) { \ntry { \nif ( wb instanceof XSSFWorkbook ) ChartUtility . initXSSFAnchorsMap ( ( XSSFWorkbook ) wb , chartsData ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Web Form getAnchorsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8559": "public class ConfigurationUtility { \n@ SuppressWarnings ( \"rawtypes\" ) public static Collection transformToCollectionObject ( final ExpressionEngine engine , final String collectionName , final Map < String , Object > context ) { \nObject collectionObject = engine . evaluate ( collectionName , context ) ; \nif ( ! ( collectionObject instanceof Collection ) ) throw new EvaluationException ( collectionName + \" expression is not a collection\" ) ; \nreturn ( Collection ) collectionObject ; \n} \n} \n"}
{"8560": "public class ConfigurationUtility { \npublic static String getFullNameFromRow ( final Row row ) { \nif ( row != null ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; \nif ( cell != null ) return cell . getStringCellValue ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8561": "public class ConfigurationUtility { \npublic static void reBuildUpperLevelFormula ( final ConfigBuildRef configBuildRef , final String actionFullName ) { \nMap < Cell , String > cachedMap = configBuildRef . getCachedCells ( ) ; \nMap < String , List < RowsMapping > > rowsMap = new HashMap < > ( ) ; \nfor ( Map . Entry < Cell , String > entry : cachedMap . entrySet ( ) ) { \nCell cell = entry . getKey ( ) ; \nString originFormula = entry . getValue ( ) ; \nif ( originFormula != null ) setupUpperLevelFormula ( cell , originFormula , actionFullName , rowsMap , configBuildRef ) ; \n} \n} \n} \n"}
{"8562": "public class ConfigurationUtility { \nprivate static void setupUpperLevelFormula ( final Cell cell , final String originFormula , final String actionFullName , final Map < String , List < RowsMapping > > rowsMap , final ConfigBuildRef configBuildRef ) { \nString fullName = getFullNameFromRow ( cell . getRow ( ) ) ; \nif ( actionFullName . startsWith ( fullName + \":\" ) ) { \nList < RowsMapping > currentRowsMappingList = rowsMap . get ( fullName ) ; \nif ( currentRowsMappingList == null ) { \ncurrentRowsMappingList = gatherRowsMappingByFullName ( configBuildRef , fullName ) ; \nrowsMap . put ( fullName , currentRowsMappingList ) ; \n} \nShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef ( configBuildRef . getWatchList ( ) , currentRowsMappingList ) ; \nshiftFormulaRef . setFormulaChanged ( 0 ) ; \nbuildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , originFormula ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; \n} \n} \n} \n"}
{"8563": "public class ConfigurationUtility { \npublic static void buildCellFormulaForShiftedRows ( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final Cell cell , final String originFormula ) { \nif ( ( shiftFormulaRef . getWatchList ( ) != null ) && ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { \nPtg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; \nPtg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) cell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; \n} \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < ( parts . length - 1 ) ; \ni ++ ) { \nif ( i == 0 ) fname . append ( parts [ i ] ) ; \nelse fname . append ( \":\" ) . append ( parts [ i ] ) ; \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \n} \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nfor ( int i = startRowIndex ; \ni <= sheet . getLastRowNum ( ) ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { \nint sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nint sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( sufindex > 0 ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nint increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) changeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \nelse return ; \n} \n} \n} \n"}
{"8569": "public class ConfigurationUtility { \npublic static int getOriginalRowNumInHiddenColumn ( final Row row ) { \nif ( row != null ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nString rowNum = cell . getStringCellValue ( ) ; \ntry { \nif ( ( rowNum != null ) && ( ! rowNum . isEmpty ( ) ) && ( WebSheetUtility . isNumeric ( rowNum ) ) ) return Integer . parseInt ( rowNum ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"getOriginalRowNumInHiddenColumn rowNum = \" + rowNum + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8571": "public class ConfigurationUtility { \npublic static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { \nStringBuilder fullName = new StringBuilder ( ) ; \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nfor ( int i = 1 ; \ni < parts . length - 1 ; \ni ++ ) { \nString part = parts [ i ] ; \nif ( fullName . length ( ) == 0 ) fullName . append ( part ) ; \nelse fullName . append ( \":\" + part ) ; \nif ( fullName . length ( ) > 0 ) { \nConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; \nif ( rangeAttrs != null ) rowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8572": "public class ConfigurationUtility { \npublic static List < RowsMapping > findChildRowsMappingFromShiftMap ( final String fullName , final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nNavigableMap < String , ConfigRangeAttrs > tailmap = shiftMap . tailMap ( fullName , false ) ; \nfor ( Map . Entry < String , ConfigRangeAttrs > entry : tailmap . entrySet ( ) ) { \nString key = entry . getKey ( ) ; \nif ( key . startsWith ( fullName ) ) rowsMappingList . add ( entry . getValue ( ) . getUnitRowsMapping ( ) ) ; \nelse break ; \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8573": "public class ConfigurationUtility { \n@ SuppressWarnings ( \"rawtypes\" ) public static Object findItemInCollection ( final Collection collection , final int index ) { \nif ( index >= 0 ) { \nif ( collection instanceof List ) { \nList list = ( List ) collection ; \nreturn list . get ( index ) ; \n} \nint i = 0 ; \nfor ( Object object : collection ) { \nif ( i == index ) return object ; \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) for ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) for ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nint rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"8577": "public class ConfigurationUtility { \npublic static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { \nint ibegin = 0 ; \nint ifind ; \nint inameEnd ; \nString tempStr ; \nString findStr ; \nString replaceStr ; \nString returnStr = attrValue ; \nwhile ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ) { \ninameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; \nif ( inameEnd > 0 ) findStr = attrValue . substring ( ifind , inameEnd ) ; \nelse findStr = attrValue . substring ( ifind ) ; \nif ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) tempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; \nelse tempStr = findStr ; \nreplaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; \nif ( replaceStr == null ) replaceStr = \"\" ; \nreturnStr = attrValue . replace ( findStr , replaceStr ) ; \nibegin = ifind + 1 ; \n} \nreturn returnStr ; \n} \n} \n"}
{"8578": "public class ConfigurationUtility { \npublic static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nMap < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < numRegions ; \ni ++ ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) cellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; \n} \nreturn cellRangeMap ; \n} \n} \n"}
{"8579": "public class ConfigurationUtility { \npublic static List < String > skippedRegionCells ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nList < String > skipCellList = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < numRegions ; \ni ++ ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) addSkipCellToListInTheRegion ( skipCellList , caddress ) ; \n} \nreturn skipCellList ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \nfor ( int col = caddress . getFirstColumn ( ) ; \ncol <= caddress . getLastColumn ( ) ; \ncol ++ ) for ( int row = caddress . getFirstRow ( ) ; \nrow <= caddress . getLastRow ( ) ; \nrow ++ ) { \nif ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) continue ; \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \n} \n} \n} \n"}
{"8581": "public class ConfigurationUtility { \npublic static void buildSheetCommentFromAlias ( Sheet sheet , List < TieCommandAlias > tieCommandAliasList ) { \nif ( ( tieCommandAliasList == null ) || ( tieCommandAliasList . isEmpty ( ) ) ) return ; \nfor ( Row row : sheet ) { \nfor ( Cell cell : row ) { \nbuildCellCommentFromalias ( tieCommandAliasList , cell ) ; \n} \n} \n} \n} \n"}
{"8582": "public class ConfigurationUtility { \nprivate static void buildCellCommentFromalias ( List < TieCommandAlias > tieCommandAliasList , Cell cell ) { \nString value = CellUtility . getCellValueWithoutFormat ( cell ) ; \nif ( ( value != null ) && ( ! value . isEmpty ( ) ) ) for ( TieCommandAlias alias : tieCommandAliasList ) { \nMatcher matcher = alias . getPattern ( ) . matcher ( value ) ; \nif ( matcher . find ( ) ) { \nCellUtility . createOrInsertComment ( cell , alias . getCommand ( ) ) ; \nif ( alias . isRemove ( ) ) CellUtility . setCellValue ( cell , ParserUtility . removeCharsFromString ( value , matcher . start ( ) , matcher . end ( ) ) ) ; \n} \n} \n} \n} \n"}
{"8583": "public class ConfigurationHandler { \npublic final Map < String , SheetConfiguration > buildConfiguration ( ) { \nMap < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; \nList < String > sheetNames = new ArrayList < > ( ) ; \nString sname ; \nfor ( int i = 0 ; \ni < parent . getWb ( ) . getNumberOfSheets ( ) ; \ni ++ ) { \nsname = parent . getWb ( ) . getSheetName ( i ) ; \nif ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) sheetNames . add ( sname ) ; \n} \nfor ( String sheetName : sheetNames ) { \nSheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; \nConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; \nbuildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; \n} \nreturn sheetConfigMap ; \n} \n} \n"}
{"8584": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( formName ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nint leftCol = sheet . getLeftCol ( ) ; \nint lastRow = sheet . getLastRowNum ( ) ; \nint firstRow = sheet . getFirstRowNum ( ) ; \nint rightCol = 0 ; \nint maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) break ; \nmaxRow = row . getRowNum ( ) ; \nint firstCellNum = row . getFirstCellNum ( ) ; \nif ( firstCellNum >= 0 && firstCellNum < leftCol ) leftCol = firstCellNum ; \nif ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { \nint verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( verifiedcol > rightCol ) rightCol = verifiedcol ; \n} \n} \nif ( maxRow < lastRow ) lastRow = maxRow ; \nString tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0 : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0\" ; \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \ntempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + \" : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; \nsheetConfig . setFormBodyRange ( tempStr ) ; \nsheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; \nsheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; \nsheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; \nint sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; \nif ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) sheetConfig . setHidden ( true ) ; \nreturn sheetConfig ; \n} \n} \n"}
{"8585": "public class ConfigurationHandler { \nprivate FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { \nint firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nint lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; \nCell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nFormCommand fcommand = new FormCommand ( ) ; \nfcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; \nif ( sheetConfig . isHidden ( ) ) fcommand . setHidden ( TieConstants . TRUE_STRING ) ; \nelse fcommand . setHidden ( TieConstants . FALSE_STRING ) ; \nfcommand . setName ( sheetConfig . getFormName ( ) ) ; \nfcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; \nfcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; \nfcommand . setHeaderLength ( \"0\" ) ; \nfcommand . setFooterLength ( \"0\" ) ; \nfcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; \nreturn fcommand ; \n} \n} \n"}
{"8586": "public class ConfigurationHandler { \nprivate int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { \nint lastCol = sheetRightCol ; \nint col ; \nfor ( col = lastCol ; \ncol >= stoppoint ; \ncol -- ) { \nCell cell = row . getCell ( col ) ; \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) break ; \n} \nreturn col ; \n} \n} \n"}
{"8587": "public class ConfigurationHandler { \npublic final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { \nif ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) return ; \ncheckAndRepairLastRow ( sheet ) ; \nint sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; \nList < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; \nboolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; \nList < String > formList = new ArrayList < > ( ) ; \nbuildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; \nmatchParentCommand ( commandList ) ; \nmatchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; \ninitTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; \n} \n} \n"}
{"8588": "public class ConfigurationHandler { \nprivate final void checkAndRepairLastRow ( final Sheet sheet ) { \nRow lastrow = sheet . getRow ( sheet . getLastRowNum ( ) ) ; \nif ( lastrow != null ) { \nfor ( Cell cell : lastrow ) { \nif ( ( cell . getCellTypeEnum ( ) != CellType . _NONE ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) return ; \n} \nsheet . removeRow ( lastrow ) ; \n} \n} \n} \n"}
{"8589": "public class ConfigurationHandler { \nprivate List < ConfigCommand > buildCommandListFromSheetComment ( final XSSFSheet sheet , final int sheetRightCol , final CellAttributesMap cellAttributesMap ) { \nList < ConfigCommand > commandList = new ArrayList < > ( ) ; \nif ( parent . isSkipConfiguration ( ) ) return commandList ; \nMap < CellAddress , ? extends Comment > comments = null ; \ntry { \ncomments = sheet . getCellComments ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"Null exception throwed when no comment exists: \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nif ( comments == null ) return commandList ; \nSortedSet < CellAddress > keys = new TreeSet < > ( comments . keySet ( ) ) ; \nfor ( CellAddress key : keys ) { \nCell cell = sheet . getRow ( key . getRow ( ) ) . getCell ( key . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nbuildCommandList ( sheet , sheetRightCol , cell , commandList , cellAttributesMap ) ; \n} \nreturn commandList ; \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nint matchIndex = - 1 ; \nConfigRange matchRange = null ; \nfor ( int j = 0 ; \nj < commandList . size ( ) ; \nj ++ ) if ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \nif ( matchIndex >= 0 ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \n} \n} \n"}
{"8591": "public class ConfigurationHandler { \nprivate boolean hasEachCommandInTheList ( final List < ConfigCommand > commandList ) { \nif ( commandList != null ) for ( ConfigCommand command : commandList ) { \nif ( command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_EACH ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"8593": "public class ConfigurationHandler { \nprivate void copyTemplateForTieCommands ( final Sheet sheet ) { \nif ( parent . isSkipConfiguration ( ) ) return ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( wb . getSheet ( copyName ) == null ) { \nSheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; \nint sheetIndex = wb . getSheetIndex ( newSheet ) ; \nwb . setSheetName ( sheetIndex , copyName ) ; \nwb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; \n} \n} \n} \n"}
{"8594": "public class ConfigurationHandler { \nprivate List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { \nComment comment = cell . getCellComment ( ) ; \nString text = comment . getString ( ) . getString ( ) ; \nString [ ] commentLines = text . split ( \"\\\\n\" ) ; \nStringBuilder newComment = new StringBuilder ( ) ; \nboolean changed = false ; \nfor ( String commentLine : commentLines ) { \nString line = commentLine . trim ( ) ; \nif ( ParserUtility . isCommandString ( line ) ) { \nprocessCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; \nchanged = true ; \n} \nelse if ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { \nprocessMethodLine ( cell , line , cellAttributesMap ) ; \nchanged = true ; \n} \nelse if ( newComment . length ( ) > 0 ) newComment . append ( \"\\\\n\" + commentLine ) ; \nelse newComment . append ( commentLine ) ; \n} \nif ( ! changed ) moveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \nelse if ( newComment . length ( ) > 0 ) { \nmoveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nRichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; \ncomment . setString ( str ) ; \n} \nelse cell . removeCellComment ( ) ; \nreturn cList ; \n} \n} \n"}
{"8595": "public class ConfigurationHandler { \nprivate void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { \nif ( ParserUtility . isWidgetMethodString ( line ) ) ParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; \nelse if ( ParserUtility . isValidateMethodString ( line ) ) ParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; \nelse moveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; \n} \n} \n"}
{"8596": "public class ConfigurationHandler { \nprivate void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { \nint nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; \nif ( nameEndIndex < 0 ) { \nString errMsg = \"Failed to parse command line [\" + line + \"]. Expected '\" + TieConstants . ATTR_PREFIX + \"' symbol.\" ; \nLOG . severe ( errMsg ) ; \nthrow new IllegalStateException ( errMsg ) ; \n} \nString commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; \nMap < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; \nConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; \nif ( configCommand != null ) cList . add ( configCommand ) ; \n} \n} \n"}
{"8600": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( fcommand . getName ( ) ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nint leftCol = fcommand . getLeftCol ( ) ; \nint lastRow = fcommand . getLastRow ( ) ; \nint rightCol = 0 ; \nint maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) break ; \nmaxRow = row . getRowNum ( ) ; \nif ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { \nint verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( verifiedcol > rightCol ) rightCol = verifiedcol ; \n} \n} \nif ( maxRow < lastRow ) lastRow = maxRow ; \nsetHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nsetBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; \nsetFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nString hidden = fcommand . getHidden ( ) ; \nif ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) sheetConfig . setHidden ( true ) ; \nString fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; \nif ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) sheetConfig . setFixedWidthStyle ( true ) ; \nsheetConfig . setFormCommand ( fcommand ) ; \nreturn sheetConfig ; \n} \n} \n"}
{"8601": "public class ConfigurationHandler { \nprivate void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { \nString tempStr ; \nif ( fcommand . calcFooterLength ( ) == 0 ) tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; \nelse tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + fcommand . calcBodyLength ( ) ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; \nsheetConfig . setFormFooterRange ( tempStr ) ; \nsheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; \n} \n} \n"}
{"8603": "public class ConfigurationHandler { \nprivate void setHeaderOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { \nString tempStr ; \nif ( fcommand . calcHeaderLength ( ) == 0 ) tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; \nelse tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + 1 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \n} \n} \n"}
{"8604": "public class CommandUtility { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) public static int deleteRow ( final ConfigBuildRef configBuildRef , final int rowIndex , final Map < String , Object > dataContext , final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; \nconfigBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; \nCollectionObject collect = configBuildRef . getCellHelper ( ) . getLastCollect ( fullName ) ; \nCollection lastCollection = collect . getLastCollection ( ) ; \nint lastCollectionIndex = collect . getLastCollectionIndex ( ) ; \nEachCommand eachCommand = collect . getEachCommand ( ) ; \nif ( lastCollectionIndex < 0 ) throw new DeleteRowException ( \"No each command found.\" ) ; \nif ( lastCollection . size ( ) <= 1 ) throw new DeleteRowException ( \"Cannot delete the last record in the group.\" ) ; \nCommandUtility . deleteObjectInContext ( lastCollection , eachCommand , lastCollectionIndex , dataContext ) ; \nConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) . get ( fullName ) ; \nif ( currentRangeAttrs == null ) throw new DeleteRowException ( \"Cannot find delete range.\" ) ; \nint startRow = currentRangeAttrs . getFirstRowIndex ( ) ; \nint length = currentRangeAttrs . getFinalLength ( ) ; \nint endRow = startRow + length - 1 ; \nList < String > removeFullNameList = findRemoveFullNameList ( configBuildRef . getSheet ( ) , startRow , endRow ) ; \nremoveRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , removeFullNameList ) ; \nString var = eachCommand . getVar ( ) ; \nCommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , startRow , endRow , configBuildRef . getCachedCells ( ) ) ; \nCommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , endRow ) ; \nMap < String , String > changeMap = new TreeMap < > ( ) ; \nConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , startRow , fullName , changeMap , - 1 ) ; \nConfigurationUtility . changeIndexNumberInShiftMap ( configBuildRef . getShiftMap ( ) , changeMap ) ; \nConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , fullName ) ; \nConfigurationUtility . changeUpperLevelFinalLength ( configBuildRef . getShiftMap ( ) , fullName , - length ) ; \ndataContext . remove ( var ) ; \nreturn length ; \n} \n} \n"}
{"8606": "public class CommandUtility { \nprivate static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { \nList < String > list = new ArrayList < > ( ) ; \nfor ( int rowIndex = startRow ; \nrowIndex <= endRow ; \nrowIndex ++ ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; \nif ( ! list . contains ( fullName ) ) list . add ( fullName ) ; \n} \nreturn list ; \n} \n} \n"}
{"8607": "public class CommandUtility { \npublic static EachCommand getEachCommandFromPartsName ( final Map < String , Command > commandIndexMap , final String [ ] varparts ) { \nif ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) return ( EachCommand ) commandIndexMap . get ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX + varparts [ 1 ] ) ; \nreturn null ; \n} \n} \n"}
{"8608": "public class CommandUtility { \n@ SuppressWarnings ( { \n\"rawtypes\" , \"unchecked\" } \n) private static String insertEmptyObjectInContext ( final String fullName , final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { \nif ( ! ( lastCollection instanceof List ) ) throw new EvaluationException ( \"Collection must be list in order to insert/delete.\" ) ; \nList collectionList = ( List ) lastCollection ; \nObject currentObj = collectionList . get ( lastCollectionIndex ) ; \nObject insertObj ; \ntry { \ninsertObj = currentObj . getClass ( ) . newInstance ( ) ; \ncollectionList . add ( lastCollectionIndex + 1 , insertObj ) ; \ndataContext . put ( eachCommand . getVar ( ) , insertObj ) ; \nreturn fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) + ( lastCollectionIndex + 1 ) ; \n} \ncatch ( InstantiationException | IllegalAccessException e ) { \nthrow new EvaluationException ( e ) ; \n} \n} \n} \n"}
{"8609": "public class CommandUtility { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) private static void deleteObjectInContext ( final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { \nif ( ! ( lastCollection instanceof List ) ) throw new EvaluationException ( eachCommand . getVar ( ) + TieConstants . EACH_COMMAND_INVALID_MSG ) ; \nList collectionList = ( List ) lastCollection ; \ncollectionList . remove ( lastCollectionIndex ) ; \ndataContext . remove ( eachCommand . getVar ( ) ) ; \n} \n} \n"}
{"8611": "public class CommandUtility { \npublic static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) for ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nindexMap . put ( command . getCommandName ( ) , command ) ; \ncommand . getConfigRange ( ) . indexCommandRange ( indexMap ) ; \n} \n} \n} \n"}
{"8612": "public class CommandUtility { \npublic static boolean isRowAllowAdd ( final Row row , final SheetConfiguration sheetConfig ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; \nif ( fullName != null ) { \nConfigRangeAttrs attrs = sheetConfig . getShiftMap ( ) . get ( fullName ) ; \nif ( ( attrs != null ) && ( attrs . isAllowAdd ( ) ) && ( row . getRowNum ( ) == attrs . getFirstRowRef ( ) . getRowIndex ( ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nint srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nint srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) copyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( index > 0 ) CellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \nfor ( int rowIndex = srcStartRow ; \nrowIndex <= srcEndRow ; \nrowIndex ++ ) if ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) unitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \n} \n"}
{"8614": "public class CommandUtility { \npublic static void evaluateNormalCells ( final Cell cell , final String strValue , final Map < String , Object > context , final ExpressionEngine engine ) { \nif ( strValue . contains ( TieConstants . METHOD_PREFIX ) ) { \nObject evaluationResult = evaluate ( strValue , context , engine ) ; \nif ( evaluationResult == null ) evaluationResult = \"\" ; \nCellUtility . setCellValue ( cell , evaluationResult . toString ( ) ) ; \ncreateTieCell ( cell , context , engine ) ; \n} \n} \n} \n"}
{"8615": "public class CommandUtility { \nprivate static void evaluateUserFormula ( final Cell cell , final String strValue ) { \nString formulaStr = strValue . substring ( 2 , strValue . length ( ) - 1 ) ; \nif ( ( formulaStr != null ) && ( ! formulaStr . isEmpty ( ) ) ) cell . setCellFormula ( formulaStr ) ; \n} \n} \n"}
{"8617": "public class CommandUtility { \npublic static void createCellComment ( final Cell cell , final String newComment , final Map < Cell , String > finalCommentMap ) { \nif ( newComment != null ) finalCommentMap . put ( cell , newComment ) ; \n} \n} \n"}
{"8618": "public class CommandUtility { \npublic static boolean evalBoolExpression ( final ExpressionEngine expEngine , final String pscript ) { \nObject result = null ; \nString script = \"( \" + pscript + \" )\" ; \nscript = script . toUpperCase ( ) . replace ( \"AND\" , \"&&\" ) ; \nscript = script . toUpperCase ( ) . replace ( \"OR\" , \"||\" ) ; \ntry { \nresult = expEngine . evaluate ( script ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"WebForm WebFormHelper evalBoolExpression script = \" + script + \"; error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \nif ( result != null ) return ( ( Boolean ) result ) . booleanValue ( ) ; \nelse return false ; \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \nfor ( int irow = rowIndexStart ; \nirow <= rowIndexEnd ; \nirow ++ ) removeCachedCellForRow ( sheet , irow , cachedMap ) ; \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) return ; \nint lastRowNum = sheet . getLastRowNum ( ) ; \nif ( rowIndexEnd < lastRowNum ) sheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \nif ( rowIndexEnd == lastRowNum ) for ( int i = rowIndexEnd ; \ni >= rowIndexStart ; \ni -- ) removeSingleRowInSheet ( sheet , rowIndexStart ) ; \n} \n} \n"}
{"8620": "public class CommandUtility { \nprivate static void removeSingleRowInSheet ( final Sheet sheet , final int rowIndexStart ) { \nRow removingRow = sheet . getRow ( rowIndexStart ) ; \nif ( removingRow != null ) sheet . removeRow ( removingRow ) ; \n} \n} \n"}
{"8621": "public class CommandUtility { \nprivate static void removeCachedCellForRow ( final Sheet sheet , final int rowIndexStart , final Map < Cell , String > cachedMap ) { \nRow removingRow = sheet . getRow ( rowIndexStart ) ; \nif ( removingRow != null ) for ( Cell cell : removingRow ) { \ncachedMap . remove ( cell ) ; \n} \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) return ; \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nfor ( int rowIndex = rowIndexEnd ; \nrowIndex >= rowIndexStart ; \nrowIndex -- ) bodyRows . remove ( rowIndex - top ) ; \nfor ( int irow = rowIndexStart - top ; \nirow < bodyRows . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \n} \n} \n} \n"}
{"8623": "public class CellMap { \nprivate String loadPicture ( final int rowIndex , final int colIndex ) { \nFacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; \nif ( facesCell != null && facesCell . isContainPic ( ) ) { \nFacesContext context = FacesContext . getCurrentInstance ( ) ; \nString pictureId = facesCell . getPictureId ( ) ; \nString pictureViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + pictureId ; \nMap < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; \nif ( sessionMap . get ( pictureViewId ) == null ) sessionMap . put ( pictureViewId , parent . getPicturesMap ( ) . get ( pictureId ) . getPictureData ( ) ) ; \nreturn pictureViewId ; \n} \nelse return null ; \n} \n} \n"}
{"8624": "public class CellMap { \nprivate String loadChart ( final int rowIndex , final int colIndex ) { \nFacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; \nif ( facesCell != null && facesCell . isContainChart ( ) ) { \nFacesContext context = FacesContext . getCurrentInstance ( ) ; \nString chartId = facesCell . getChartId ( ) ; \nString chartViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + chartId ; \nif ( context != null ) { \nMap < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; \nif ( sessionMap . get ( chartViewId ) == null ) sessionMap . put ( chartViewId , parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ) ; \n} \nreturn chartViewId ; \n} \nelse return null ; \n} \n} \n"}
{"8625": "public class CellMap { \nprivate String assembleNewValue ( final Object value , final FacesCell facesCell ) { \nString newValue ; \nif ( value instanceof java . util . Date ) { \nString datePattern = facesCell . getDatePattern ( ) ; \nif ( datePattern == null || datePattern . isEmpty ( ) ) datePattern = parent . getDefaultDatePattern ( ) ; \nFormat formatter = new SimpleDateFormat ( datePattern ) ; \nnewValue = formatter . format ( value ) ; \n} \nelse newValue = ( String ) value ; \nif ( \"textarea\" . equalsIgnoreCase ( facesCell . getInputType ( ) ) && ( newValue != null ) ) newValue = newValue . replace ( \"\\r\\n\" , \"\\n\" ) ; \nreturn newValue ; \n} \n} \n"}
{"8626": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static String getCellValueWithFormat ( final Cell poiCell , final FormulaEvaluator formulaEvaluator , final DataFormatter dataFormatter ) { \nif ( poiCell == null ) return null ; \nString result ; \ntry { \nCellType cellType = poiCell . getCellTypeEnum ( ) ; \nif ( cellType == CellType . FORMULA ) cellType = formulaEvaluator . evaluate ( poiCell ) . getCellTypeEnum ( ) ; \nif ( cellType == CellType . ERROR ) result = \"\" ; \nelse result = dataFormatter . formatCellValue ( poiCell , formulaEvaluator ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Web Form WebFormHelper getCellValue Error row = \" + poiCell . getRowIndex ( ) + \" column = \" + poiCell . getColumnIndex ( ) + \" error = \" + e . getLocalizedMessage ( ) + \"; Change return result to blank\" , e ) ; \nresult = \"\" ; \n} \nreturn result ; \n} \n} \n"}
{"8627": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static String getCellValueWithoutFormat ( final Cell poiCell ) { \nif ( poiCell == null ) return null ; \nif ( poiCell . getCellTypeEnum ( ) == CellType . FORMULA ) return getCellStringValueWithType ( poiCell , poiCell . getCachedFormulaResultTypeEnum ( ) ) ; \nelse return getCellStringValueWithType ( poiCell , poiCell . getCellTypeEnum ( ) ) ; \n} \n} \n"}
{"8629": "public class CellUtility { \nprivate static String getCellStringValueWithNumberType ( final Cell poiCell ) { \nString result ; \nif ( DateUtil . isCellDateFormatted ( poiCell ) ) result = poiCell . getDateCellValue ( ) . toString ( ) ; \nelse { \nresult = BigDecimal . valueOf ( poiCell . getNumericCellValue ( ) ) . toPlainString ( ) ; \nif ( result . endsWith ( \".0\" ) ) result = result . substring ( 0 , result . length ( ) - 2 ) ; \n} \nreturn result ; \n} \n} \n"}
{"8630": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static Cell setCellValue ( final Cell c , final String value ) { \ntry { \nif ( value . length ( ) == 0 ) c . setCellType ( CellType . BLANK ) ; \nelse if ( WebSheetUtility . isNumeric ( value ) ) setCellValueNumber ( c , value ) ; \nelse if ( WebSheetUtility . isDate ( value ) ) setCellValueDate ( c , value ) ; \nelse if ( c . getCellTypeEnum ( ) == CellType . BOOLEAN ) setCellValueBoolean ( c , value ) ; \nelse setCellValueString ( c , value ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \" error in setCellValue of CellUtility = \" + e . getLocalizedMessage ( ) , e ) ; \nsetCellValueString ( c , value ) ; \n} \nreturn c ; \n} \n} \n"}
{"8632": "public class CellUtility { \nprivate static void setCellValueBoolean ( final Cell c , final String value ) { \nif ( \"Y\" . equalsIgnoreCase ( value ) || \"Yes\" . equalsIgnoreCase ( value ) || \"True\" . equalsIgnoreCase ( value ) ) c . setCellValue ( true ) ; \nelse c . setCellValue ( false ) ; \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nint length = srcRowEnd - srcRowStart + 1 ; \nif ( length <= 0 ) return ; \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) copySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \nfor ( int i = 0 ; \ni < srcSheet . getNumMergedRegions ( ) ; \ni ++ ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { \nint targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nint targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \n} \n} \n} \n"}
{"8636": "public class CellUtility { \nprivate static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { \nRow newRow = destSheet . getRow ( destinationRowNum ) ; \nRow sourceRow = srcSheet . getRow ( sourceRowNum ) ; \nif ( newRow == null ) newRow = destSheet . createRow ( destinationRowNum ) ; \nnewRow . setHeight ( sourceRow . getHeight ( ) ) ; \nfor ( int i = 0 ; \ni < sourceRow . getLastCellNum ( ) ; \ni ++ ) copyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; \nif ( setHiddenColumn ) ConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; \nreturn ; \n} \n} \n"}
{"8637": "public class CellUtility { \npublic static Cell copyCell ( final Sheet destSheet , final Row sourceRow , final Row newRow , final int cellIndex , final boolean checkLock ) { \nCell sourceCell = sourceRow . getCell ( cellIndex ) ; \nif ( sourceCell == null ) return null ; \nboolean refreshCell = false ; \nif ( sourceRow . equals ( newRow ) && ( sourceCell . getColumnIndex ( ) == cellIndex ) ) { \nsourceRow . removeCell ( sourceCell ) ; \nrefreshCell = true ; \n} \nCell newCell = newRow . createCell ( cellIndex ) ; \ntry { \nif ( ! refreshCell && ( sourceCell . getCellComment ( ) != null ) ) cloneComment ( sourceCell , newCell ) ; \ncopyCellSetStyle ( destSheet , sourceCell , newCell ) ; \ncopyCellSetValue ( sourceCell , newCell , checkLock ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"copy cell set error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn newCell ; \n} \n} \n"}
{"8639": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static void copyCellSetStyle ( final Sheet destSheet , final Cell sourceCell , final Cell newCell ) { \nCellStyle newCellStyle = getCellStyleFromSourceCell ( destSheet , sourceCell ) ; \nnewCell . setCellStyle ( newCellStyle ) ; \nif ( sourceCell . getHyperlink ( ) != null ) newCell . setHyperlink ( sourceCell . getHyperlink ( ) ) ; \nnewCell . setCellType ( sourceCell . getCellTypeEnum ( ) ) ; \n} \n} \n"}
{"8642": "public class CellUtility { \npublic static void createOrInsertComment ( final Cell cell , final String commentStr ) { \nXSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nComment comment = cell . getCellComment ( ) ; \nString originStr = \"\" ; \nif ( comment == null ) { \nClientAnchor anchor = createCommentAnchor ( cell , factory ) ; \ncomment = drawing . createCellComment ( anchor ) ; \n} \nelse originStr = comment . getString ( ) . getString ( ) + \"\\n\" ; \noriginStr += commentStr ; \nRichTextString str = factory . createRichTextString ( originStr ) ; \ncomment . setString ( str ) ; \ncomment . setAuthor ( \"\" ) ; \ncell . setCellComment ( comment ) ; \ncomment . setColumn ( cell . getColumnIndex ( ) ) ; \ncomment . setRow ( cell . getRowIndex ( ) ) ; \n} \n} \n"}
{"8644": "public class CellUtility { \nprivate static XSSFVMLDrawing getVmlDrawingFromCell ( final Cell cell ) { \nXSSFSheet sourceSheet = ( XSSFSheet ) cell . getSheet ( ) ; \nfor ( POIXMLDocumentPart sourcePart : sourceSheet . getRelations ( ) ) { \nif ( ( sourcePart != null ) && ( sourcePart instanceof XSSFVMLDrawing ) ) return ( XSSFVMLDrawing ) sourcePart ; \n} \nreturn null ; \n} \n} \n"}
{"8649": "public class CellUtility { \npublic static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { \nint initRows = 1 ; \nif ( \"Repeat\" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { \ninitRows = sheetConfig . getBodyInitialRows ( ) ; \nif ( initRows < 1 ) initRows = 1 ; \n} \nreturn initRows ; \n} \n} \n"}
{"8652": "public class CellUtility { \npublic static Cell getPoiCellFromSheet ( final int rowIndex , final int colIndex , final Sheet sheet1 ) { \nif ( ( sheet1 != null ) && ( sheet1 . getRow ( rowIndex ) != null ) ) return sheet1 . getRow ( rowIndex ) . getCell ( colIndex ) ; \nreturn null ; \n} \n} \n"}
{"8655": "public class TieWebSheetBeanCurrent { \npublic final String getCurrentDataContextName ( ) { \nif ( currentDataContextName == null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nList < String > list = this . getCurrentDataContextNameList ( ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) if ( i > 0 ) sb . append ( \":\" + list . get ( i ) ) ; \nelse sb . append ( list . get ( i ) ) ; \nthis . setCurrentDataContextName ( sb . toString ( ) ) ; \n} \nreturn currentDataContextName ; \n} \n} \n"}
{"8660": "public class RowsMapping { \npublic final void mergeMap ( final RowsMapping addMap ) { \nMap < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; \nfor ( Map . Entry < Integer , List < SerialRow > > entry : map . entrySet ( ) ) { \nList < SerialRow > entryRowList = entry . getValue ( ) ; \nif ( ( entryRowList != null ) && ( ! entryRowList . isEmpty ( ) ) ) for ( SerialRow row : entryRowList ) { \nthis . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; \n} \n} \n} \n} \n"}
{"8662": "public class ChartUtility { \npublic static ChartType getChartType ( final CTChart ctChart ) { \nCTPlotArea plotArea = ctChart . getPlotArea ( ) ; \nfor ( ChartType chartType : ChartType . values ( ) ) { \nif ( chartType . isThisType ( plotArea ) ) return chartType ; \n} \nreturn null ; \n} \n} \n"}
{"8663": "public class ChartUtility { \npublic static BasicStroke toStroke ( final String style ) { \nBasicStroke result = null ; \nif ( style != null ) { \nfloat lineWidth = STROKE_DEFAULT_LINE_WIDTH ; \nfloat [ ] dash = { \nSTROKE_DEFAULT_DASH_WIDTH } \n; \nfloat [ ] dot = { \nlineWidth } \n; \nif ( style . equalsIgnoreCase ( STYLE_LINE ) ) result = new BasicStroke ( lineWidth ) ; \nelse if ( style . equalsIgnoreCase ( STYLE_DASH ) ) result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DASH , dash , STROKE_DEFAULT_DASHPHASE ) ; \nelse if ( style . equalsIgnoreCase ( STYLE_DOT ) ) result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DOT , dot , STROKE_DEFAULT_DASHPHASE ) ; \n} \nreturn result ; \n} \n} \n"}
{"8664": "public class ChartUtility { \npublic static ChartData initChartDataFromXSSFChart ( final String chartId , final XSSFChart chart , final XSSFWorkbook wb ) { \nThemesTable themeTable = wb . getStylesSource ( ) . getTheme ( ) ; \nChartData chartData = new ChartData ( ) ; \nXSSFRichTextString chartTitle = chart . getTitle ( ) ; \nif ( chartTitle != null ) chartData . setTitle ( chartTitle . toString ( ) ) ; \nCTChart ctChart = chart . getCTChart ( ) ; \nChartType chartType = ChartUtility . getChartType ( ctChart ) ; \nif ( chartType == null ) throw new IllegalChartException ( \"Unknown chart type\" ) ; \nchartData . setBgColor ( ColorUtility . getBgColor ( ctChart . getPlotArea ( ) , themeTable ) ) ; \nchartData . setId ( chartId ) ; \nchartData . setType ( chartType ) ; \nList < CTCatAx > ctCatAxList = ctChart . getPlotArea ( ) . getCatAxList ( ) ; \nif ( ( ctCatAxList != null ) && ( ! ctCatAxList . isEmpty ( ) ) ) chartData . setCatAx ( new ChartAxis ( ctCatAxList . get ( 0 ) ) ) ; \nList < CTValAx > ctValAxList = ctChart . getPlotArea ( ) . getValAxList ( ) ; \nif ( ( ctValAxList != null ) && ( ! ctValAxList . isEmpty ( ) ) ) chartData . setValAx ( new ChartAxis ( ctValAxList . get ( 0 ) ) ) ; \nChartObject ctObj = chartType . createChartObject ( ) ; \nif ( ctObj == null ) throw new IllegalChartException ( \"Cannot create chart object.\" ) ; \nsetUpChartData ( chartData , ctChart , themeTable , ctObj ) ; \nreturn chartData ; \n} \n} \n"}
{"8665": "public class ChartUtility { \npublic static void setUpChartData ( final ChartData chartData , final CTChart ctChart , final ThemesTable themeTable , final ChartObject ctObj ) { \nObject chartObj = null ; \n@ SuppressWarnings ( \"rawtypes\" ) List plotCharts = ctObj . getChartListFromCtChart ( ctChart ) ; \nif ( plotCharts != null && ( ! plotCharts . isEmpty ( ) ) ) chartObj = plotCharts . get ( 0 ) ; \nif ( chartObj != null ) { \n@ SuppressWarnings ( \"rawtypes\" ) List bsers = ctObj . getSerListFromCtObjChart ( chartObj ) ; \nif ( ! AppUtils . emptyList ( bsers ) ) { \nchartData . buildCategoryList ( ctObj . getCtAxDataSourceFromSerList ( bsers ) ) ; \nchartData . buildSeriesList ( bsers , themeTable , ctObj ) ; \n} \n} \n} \n} \n"}
{"8666": "public class ChartUtility { \npublic static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { \nMap < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; \nMap < String , String > positionMap = charsData . getChartPositionMap ( ) ; \nanchortMap . clear ( ) ; \npositionMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) initXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; \n} \n} \n"}
{"8667": "public class ChartUtility { \nprivate static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nCTDrawing ctDrawing = drawing . getCTDrawing ( ) ; \nif ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) return ; \nList < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; \nfor ( int j = 0 ; \nj < alist . size ( ) ; \nj ++ ) { \nCTTwoCellAnchor ctanchor = alist . get ( j ) ; \nString singleChartId = getAnchorAssociateChartId ( ctanchor ) ; \nif ( singleChartId != null ) { \nString chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; \nint dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; \nint dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; \nint dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; \nint dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; \nint col1 = ctanchor . getFrom ( ) . getCol ( ) ; \nint row1 = ctanchor . getFrom ( ) . getRow ( ) ; \nint col2 = ctanchor . getTo ( ) . getCol ( ) ; \nint row2 = ctanchor . getTo ( ) . getRow ( ) ; \nanchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; \npositionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; \n} \n} \n} \n} \n"}
{"8668": "public class ChartUtility { \nprivate static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { \nif ( ctanchor . getGraphicFrame ( ) == null ) return null ; \nNode parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; \nNodeList childNodes = parentNode . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < childNodes . getLength ( ) ; \ni ++ ) { \nNode childNode = childNodes . item ( i ) ; \nif ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { \nString rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; \nif ( rId != null ) return rId ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8669": "public class ChartUtility { \nprivate static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { \nfor ( int j = 0 ; \nj < attrs . getLength ( ) ; \nj ++ ) { \nAttr attribute = ( Attr ) attrs . item ( j ) ; \nif ( \"r:id\" . equalsIgnoreCase ( attribute . getName ( ) ) ) return attribute . getValue ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8673": "public class CellHelper { \npublic final Cell getPoiCellWithRowColFromTab ( final int rowIndex , final int colIndex , final String tabName ) { \nif ( parent . getWb ( ) != null ) return CellUtility . getPoiCellFromSheet ( rowIndex , colIndex , parent . getWb ( ) . getSheet ( parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ) ) ; \nreturn null ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) return ; \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nint listSize = list . size ( ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ( ! stopSkip ) && ( i < listSize ) ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) skip = true ; \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \n} \nif ( stopSkip ) parent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \nreturn ; \n} \n} \n"}
{"8677": "public class CellHelper { \nprivate boolean isNeedRestore ( final String fullName , final String [ ] parts ) { \nif ( fullName == null ) return false ; \nif ( ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) && ( parent . getCurrent ( ) . getCurrentDataContextName ( ) . toLowerCase ( ) . startsWith ( fullName . toLowerCase ( ) ) ) ) return false ; \nreturn ( ( parts != null ) && ( parts . length > 1 ) ) ; \n} \n} \n"}
{"8679": "public class ConfigRange { \npublic final void shiftRowRef ( final Sheet sheet , final int shiftnum ) { \ntry { \nthis . setFirstRowRef ( sheet . getRow ( attrs . getFirstRowAddr ( ) . getRow ( ) + shiftnum ) . getCell ( attrs . getFirstRowAddr ( ) . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) , false ) ; \nthis . setLastRowPlusRef ( sheet , attrs . getLastRowPlusAddr ( ) . getColumn ( ) , attrs . getLastRowPlusAddr ( ) . getRow ( ) + shiftnum - 1 , false ) ; \nif ( commandList != null ) for ( ConfigCommand command : commandList ) { \ncommand . shiftRowRef ( sheet , shiftnum ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"shiftRowRef error =\" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8680": "public class ConfigRange { \npublic final void setFirstRowRef ( final Cell pFirstRowRef , final boolean alsoCreateAddr ) { \nthis . attrs . setFirstRowRef ( pFirstRowRef ) ; \nif ( alsoCreateAddr ) this . setFirstRowAddr ( new SerialCellAddress ( pFirstRowRef ) ) ; \n} \n} \n"}
{"8681": "public class ConfigRange { \npublic final void setLastRowPlusRef ( final Sheet sheet , final int rightCol , final int lastRow , final boolean alsoSetAddr ) { \nif ( ( lastRow >= 0 ) && ( sheet != null ) && ( rightCol >= 0 ) ) { \nRow row = sheet . getRow ( lastRow + 1 ) ; \nif ( row == null ) row = sheet . createRow ( lastRow + 1 ) ; \nCell cell = row . getCell ( rightCol ) ; \nif ( cell == null ) { \ncell = row . getCell ( rightCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nthis . attrs . setLastCellCreated ( true ) ; \n} \nelse this . attrs . setLastCellCreated ( false ) ; \nthis . attrs . setLastRowPlusRef ( cell ) ; \nif ( alsoSetAddr ) this . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; \n} \nelse { \nthis . attrs . setLastRowPlusRef ( null ) ; \nif ( alsoSetAddr ) this . attrs . setLastRowPlusAddr ( null ) ; \n} \n} \n} \n"}
{"8682": "public class ConfigRange { \nprivate void buildCellsForRow ( final Row row , final String fullName , final Map < String , Object > context , final ConfigBuildRef configBuildRef , ShiftFormulaRef shiftFormulaRef ) { \nif ( ( row == null ) || ! ConfigurationUtility . isStaticRowRef ( this , row ) ) return ; \nfor ( Cell cell : row ) { \nbuildSingleCell ( cell , context , configBuildRef , shiftFormulaRef ) ; \n} \nConfigurationUtility . setFullNameInHiddenColumn ( row , fullName ) ; \n} \n} \n"}
{"8683": "public class ConfigRange { \nprivate void buildSingleCell ( final Cell cell , final Map < String , Object > context , final ConfigBuildRef configBuildRef , final ShiftFormulaRef shiftFormulaRef ) { \ntry { \nCommandUtility . evaluate ( context , cell , configBuildRef . getEngine ( ) ) ; \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nString originFormula = cell . getCellFormula ( ) ; \nshiftFormulaRef . setFormulaChanged ( 0 ) ; \nConfigurationUtility . buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , cell . getCellFormula ( ) ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"build cell ( row = \" + cell . getRowIndex ( ) + \" column = \" + cell . getColumnIndex ( ) + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8685": "public class ChartData { \npublic final void buildCategoryList ( final CTAxDataSource ctAxDs ) { \nList < ParsedCell > cells = new ArrayList < > ( ) ; \ntry { \nString fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow ++ ) for ( int col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol ++ ) cells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; \n} \nthis . setCategoryList ( cells ) ; \n} \n} \n"}
{"8687": "public class ChartData { \nprivate ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { \nChartSeries ctSer = new ChartSeries ( ) ; \nctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; \nctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; \nList < ParsedCell > cells = new ArrayList < > ( ) ; \nString fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow ++ ) for ( int col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol ++ ) cells . add ( new ParsedCell ( sheetName , row , col ) ) ; \nctSer . setValueList ( cells ) ; \nctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; \nreturn ctSer ; \n} \n} \n"}
{"8688": "public class ChartData { \nprivate List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < XColor > colors = new ArrayList < > ( ) ; \nif ( ( dptList != null ) && ( cells != null ) ) for ( int index = 0 ; \nindex < cells . size ( ) ; \nindex ++ ) { \nCTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; \nCTShapeProperties ctSpPr = null ; \nif ( dpt != null ) ctSpPr = dpt . getSpPr ( ) ; \ncolors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; \n} \nreturn colors ; \n} \n} \n"}
{"8689": "public class ChartData { \nprivate CTDPt getDPtFromListWithIndex ( final List < CTDPt > dptList , final int index ) { \nif ( dptList != null ) for ( CTDPt dpt : dptList ) { \nif ( dpt . getIdx ( ) . getVal ( ) == index ) return dpt ; \n} \nreturn null ; \n} \n} \n"}
{"8690": "public class SheetConfiguration { \npublic final void setCommandIndexMap ( final Map < String , Command > pcommandIndexMap ) { \nif ( pcommandIndexMap instanceof HashMap ) this . commandIndexMap = ( HashMap < String , Command > ) pcommandIndexMap ; \nelse { \nthis . commandIndexMap = new HashMap < > ( ) ; \nthis . commandIndexMap . putAll ( pcommandIndexMap ) ; \n} \n} \n} \n"}
{"8691": "public class PicturesUtility { \npublic static void getPictruesMap ( final Workbook wb , final Map < String , Picture > picMap ) { \nif ( wb instanceof XSSFWorkbook ) getXSSFPictruesMap ( ( XSSFWorkbook ) wb , picMap ) ; \nreturn ; \n} \n} \n"}
{"8692": "public class PicturesUtility { \nprivate static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { \npicMap . clear ( ) ; \nList < XSSFPictureData > pictures = wb . getAllPictures ( ) ; \nif ( pictures . isEmpty ( ) ) return ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nfor ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { \ntry { \nindexPictureInMap ( picMap , sheet , dr ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8694": "public class PicturesUtility { \npublic static String generatePictureStyle ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final Picture pic ) { \nClientAnchor anchor = pic . getClientAnchor ( ) ; \nif ( anchor != null ) { \nAnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , anchor ) ; \nif ( anchorSize != null ) return \"MARGIN-LEFT:\" + String . format ( \"%.2f\" , anchorSize . getPercentLeft ( ) ) + \"%;MARGIN-TOP:\" + String . format ( \"%.2f\" , anchorSize . getPercentTop ( ) ) + \"%;width:\" + String . format ( \"%.2f\" , anchorSize . getPercentWidth ( ) ) + \"%;\" ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8695": "public class PicturesUtility { \npublic static String generateChartStyle ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String chartId , final Map < String , ClientAnchor > anchorsMap ) { \nClientAnchor anchor = anchorsMap . get ( chartId ) ; \nif ( anchor != null ) { \nAnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , anchor ) ; \nif ( anchorSize != null ) return \"MARGIN-LEFT:\" + String . format ( \"%.2f\" , anchorSize . getPercentLeft ( ) ) + \"%;MARGIN-TOP:\" + String . format ( \"%.2f\" , anchorSize . getPercentTop ( ) ) + \"%;width:\" + String . format ( \"%.2f\" , anchorSize . getPercentWidth ( ) ) + \"%;height:135%;\" ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) return null ; \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nint left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nint right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ( cell != null ) && ( fcell != null ) ) { \nfor ( int col = cell . getColumnIndex ( ) ; \ncol < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; \ncol ++ ) cellWidth += sheet1 . getColumnWidthInPixels ( col ) ; \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \nfor ( int rowIndex = cell . getRowIndex ( ) ; \nrowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; \nrowIndex ++ ) cellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nelse { \nfor ( short col = anchor . getCol1 ( ) ; \ncol < anchor . getCol2 ( ) ; \ncol ++ ) picWidth += sheet1 . getColumnWidthInPixels ( col ) ; \nfor ( int rowindex = anchor . getRow1 ( ) ; \nrowindex < anchor . getRow2 ( ) ; \nrowindex ++ ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) picHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8697": "public class TieCommandAlias { \npublic Pattern getPattern ( ) { \nif ( ( this . pattern == null ) && ( alias != null ) ) this . pattern = Pattern . compile ( \"\\\\s*\" + ParserUtility . wildcardToRegex ( alias ) ) ; \nreturn pattern ; \n} \n} \n"}
{"8699": "public class SerialCell { \npublic final void recover ( final Sheet sheet ) { \nif ( this . cellAddr != null ) this . setCell ( sheet . getRow ( this . cellAddr . getRow ( ) ) . getCell ( this . cellAddr . getColumn ( ) ) ) ; \n} \n} \n"}
{"8700": "public class CellStyleUtility { \npublic static String getRowStyle ( final Workbook wb , final Cell poiCell , final String inputType , final float rowHeight , final int rowspan ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nif ( ( cellStyle != null ) && ( rowspan == 1 ) ) { \nshort fontIdx = cellStyle . getFontIndex ( ) ; \nFont font = wb . getFontAt ( fontIdx ) ; \nfloat maxHeight = rowHeight ; \nif ( ! inputType . isEmpty ( ) ) maxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , rowHeight ) ; \nreturn \"height:\" + WebSheetUtility . pointsToPixels ( maxHeight ) + \"px;\" ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8701": "public class CellStyleUtility { \npublic static String getCellFontStyle ( final Workbook wb , final Cell poiCell ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nStringBuilder webStyle = new StringBuilder ( ) ; \nif ( cellStyle != null ) { \nshort fontIdx = cellStyle . getFontIndex ( ) ; \nFont font = wb . getFontAt ( fontIdx ) ; \nif ( font . getItalic ( ) ) webStyle . append ( \"font-style: italic;\" ) ; \nif ( font . getBold ( ) ) webStyle . append ( \"font-weight: bold;\" ) ; \nwebStyle . append ( \"font-size: \" + font . getFontHeightInPoints ( ) + \"pt;\" ) ; \nString decoration = getCellFontDecoration ( font ) ; \nif ( decoration . length ( ) > 0 ) webStyle . append ( \"text-decoration:\" + decoration + \";\" ) ; \nwebStyle . append ( getCellFontColor ( font ) ) ; \n} \nreturn webStyle . toString ( ) ; \n} \n} \n"}
{"8702": "public class CellStyleUtility { \nprivate static String getCellFontColor ( final Font font ) { \nshort [ ] rgbfix = { \nTieConstants . RGB_MAX , TieConstants . RGB_MAX , TieConstants . RGB_MAX } \n; \nif ( font instanceof XSSFFont ) { \nXSSFColor color = ( ( XSSFFont ) font ) . getXSSFColor ( ) ; \nif ( color != null ) rgbfix = ColorUtility . getTripletFromXSSFColor ( color ) ; \n} \nif ( rgbfix [ 0 ] != TieConstants . RGB_MAX ) return \"color:rgb(\" + FacesUtility . strJoin ( rgbfix , \",\" ) + \");\" ; \nreturn \"\" ; \n} \n} \n"}
{"8703": "public class CellStyleUtility { \nprivate static String getCellFontDecoration ( final Font font ) { \nStringBuilder decoration = new StringBuilder ( ) ; \nif ( font . getUnderline ( ) != 0 ) decoration . append ( \" underline\" ) ; \nif ( font . getStrikeout ( ) ) decoration . append ( \" line-through\" ) ; \nreturn decoration . toString ( ) ; \n} \n} \n"}
{"8705": "public class CellStyleUtility { \npublic static String getColumnStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { \nString inputType = fcell . getInputType ( ) ; \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nStringBuilder webStyle = new StringBuilder ( ) ; \nif ( cellStyle != null ) { \nif ( fcell . isContainPic ( ) || fcell . isContainChart ( ) ) webStyle . append ( \"vertical-align: top;\" ) ; \nelse { \nwebStyle . append ( getAlignmentFromCell ( poiCell , cellStyle ) ) ; \nwebStyle . append ( getVerticalAlignmentFromCell ( cellStyle ) ) ; \n} \nwebStyle . append ( ColorUtility . getBgColorFromCell ( wb , poiCell , cellStyle ) ) ; \nwebStyle . append ( getRowStyle ( wb , poiCell , inputType , rowHeight , fcell . getRowspan ( ) ) ) ; \n} \nelse webStyle . append ( getAlignmentFromCellType ( poiCell ) ) ; \nreturn webStyle . toString ( ) ; \n} \n} \n"}
{"8708": "public class CellStyleUtility { \npublic static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { \nint totalHeight = additionalHeight ; \nfor ( int i = firstRow ; \ni <= lastRow ; \ni ++ ) totalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; \nreturn totalHeight ; \n} \n} \n"}
{"8709": "public class CellStyleUtility { \npublic static void setupCellStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nif ( ( cellStyle != null ) && ( ! cellStyle . getLocked ( ) ) ) { \nif ( fcell . getInputType ( ) . isEmpty ( ) ) fcell . setInputType ( CellStyleUtility . getInputTypeFromCellType ( poiCell ) ) ; \nif ( fcell . getControl ( ) . isEmpty ( ) && ( ! fcell . getInputType ( ) . isEmpty ( ) ) ) fcell . setControl ( \"text\" ) ; \nsetInputStyleBaseOnInputType ( fcell , poiCell ) ; \n} \nString webStyle = getCellStyle ( wb , poiCell , fcell . getInputType ( ) ) + getCellFontStyle ( wb , poiCell ) + getRowStyle ( wb , poiCell , fcell . getInputType ( ) , rowHeight , fcell . getRowspan ( ) ) ; \nfcell . setStyle ( webStyle ) ; \nfcell . setColumnStyle ( getColumnStyle ( wb , fcell , poiCell , rowHeight ) ) ; \n} \n} \n"}
{"8710": "public class CellStyleUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static String getInputTypeFromCellType ( final Cell cell ) { \nString inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; \nif ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) inputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; \nCellStyle style = cell . getCellStyle ( ) ; \nif ( style != null ) { \nint formatIndex = style . getDataFormat ( ) ; \nString formatString = style . getDataFormatString ( ) ; \nif ( DateUtil . isADateFormat ( formatIndex , formatString ) ) inputType = TieConstants . CELL_INPUT_TYPE_DATE ; \nelse if ( isAPercentageCell ( formatString ) ) inputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; \n} \nreturn inputType ; \n} \n} \n"}
{"8713": "public class FacesUtility { \npublic static String removePrefixPath ( final String prefix , final String resource ) { \nString normalizedResource = resource ; \nif ( normalizedResource . startsWith ( prefix ) ) normalizedResource = normalizedResource . substring ( prefix . length ( ) - 1 ) ; \nreturn normalizedResource ; \n} \n} \n"}
{"8714": "public class FacesUtility { \npublic static boolean evalInputType ( final String input , final String type ) { \nScanner scanner = new Scanner ( input ) ; \nboolean ireturn = false ; \nif ( \"Integer\" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextInt ( ) ; \nelse if ( \"Double\" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextDouble ( ) ; \nelse if ( \"Boolean\" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextBoolean ( ) ; \nelse if ( \"Byte\" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextByte ( ) ; \nelse if ( type . toLowerCase ( ) . startsWith ( \"text\" ) ) ireturn = true ; \nscanner . close ( ) ; \nreturn ireturn ; \n} \n} \n"}
{"8716": "public class FacesUtility { \npublic static String strJoin ( final short [ ] aArr , final String sSep ) { \nStringBuilder sbStr = new StringBuilder ( ) ; \nfor ( int i = 0 , il = aArr . length ; \ni < il ; \ni ++ ) { \nif ( i > 0 ) sbStr . append ( sSep ) ; \nsbStr . append ( aArr [ i ] ) ; \n} \nreturn sbStr . toString ( ) ; \n} \n} \n"}
{"8717": "public class FacesUtility { \npublic static double round ( final double value , final int places ) { \nif ( places < 0 ) throw new IllegalArgumentException ( ) ; \nBigDecimal bd = BigDecimal . valueOf ( value ) ; \nbd = bd . setScale ( places , RoundingMode . HALF_UP ) ; \nreturn bd . doubleValue ( ) ; \n} \n} \n"}
{"8718": "public class TieWebSheetView { \npublic String getTabType ( ) { \nint sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ( sheetId >= 0 ) && ( tabs != null ) ) { \nif ( sheetId >= tabs . size ( ) ) sheetId = 0 ; \ntabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; \n} \nelse tabType = TieConstants . TAB_TYPE_NONE ; \nreturn tabType ; \n} \n} \n"}
{"8719": "public class TieWebSheetView { \npublic String getTabStyle ( ) { \nString tabStyle = TieConstants . TAB_STYLE_VISIBLE ; \nint sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ( sheetId >= 0 ) && ( sheetId < tabs . size ( ) ) ) tabStyle = TieConstants . TAB_STYLE_INVISIBLE ; \nreturn tabStyle ; \n} \n} \n"}
{"8724": "public class FormCommand { \nprivate List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { \nList < Integer > watchList = new ArrayList < > ( ) ; \nConfigRange cRange = this . getConfigRange ( ) ; \nList < ConfigCommand > commandList = cRange . getCommandList ( ) ; \nif ( commandList . isEmpty ( ) ) return watchList ; \nint lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; \nif ( lastStaticRow < 0 ) lastStaticRow = this . getTopRow ( ) ; \nint sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; \nfor ( int i = this . getTopRow ( ) ; \ni <= this . getLastRow ( ) ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nfor ( Cell cell : row ) { \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) buildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; \n} \n} \nreturn watchList ; \n} \n} \n"}
{"8725": "public class FormCommand { \nprivate void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { \nString formula = cell . getCellFormula ( ) ; \nPtg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; \nfor ( int k = 0 ; \nk < ptgs . length ; \nk ++ ) { \nObject ptg = ptgs [ k ] ; \nint areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( areaInt >= 0 ) addToWatchList ( areaInt , lastStaticRow , watchList ) ; \n} \ncell . setCellType ( CellType . STRING ) ; \ncell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; \n} \n} \n"}
{"8726": "public class FormCommand { \nprivate void addToWatchList ( final int addRow , final int lastStaticRow , final List < Integer > watchList ) { \nif ( ( addRow > lastStaticRow ) && ! ( watchList . contains ( addRow ) ) ) watchList . add ( addRow ) ; \n} \n} \n"}
{"8727": "public class ParserUtility { \npublic static boolean isCommandString ( final String str ) { \nif ( str == null ) return false ; \nreturn str . startsWith ( TieConstants . COMMAND_PREFIX ) ; \n} \n} \n"}
{"8728": "public class ParserUtility { \npublic static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) return ; \nint widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; \nint elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; \nif ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) return ; \nString type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) return ; \nString key = getAttributeKeyInMapByCell ( cell ) ; \ncellAttributesMap . getCellInputType ( ) . put ( key , type ) ; \nList < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; \nif ( inputs == null ) { \ninputs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; \n} \nparseInputAttributes ( inputs , values ) ; \nparseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; \n} \n} \n"}
{"8729": "public class ParserUtility { \npublic static String getAttributeKeyInMapByCell ( final Cell cell ) { \nif ( cell == null ) return null ; \nreturn cell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( cell ) ; \n} \n} \n"}
{"8730": "public class ParserUtility { \npublic static void parseValidateAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) return ; \nif ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ) return ; \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) return ; \nString key = getAttributeKeyInMapByCell ( cell ) ; \nList < CellFormAttributes > attrs = cellAttributesMap . getCellValidateAttributes ( ) . get ( key ) ; \nif ( attrs == null ) { \nattrs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellValidateAttributes ( ) . put ( key , attrs ) ; \n} \nparseValidateAttributes ( attrs , values ) ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nint bracketNum = 0 ; \nfor ( int i = startPos ; \ni < str . length ( ) ; \ni ++ ) { \nchar current = str . charAt ( i ) ; \nif ( current == TieConstants . EL_START_BRACKET ) bracketNum ++ ; \nelse if ( current == TieConstants . EL_END ) { \nbracketNum -- ; \nif ( bracketNum <= 0 ) return i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8734": "public class ParserUtility { \npublic static void parseValidateAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { \nif ( controlAttrs == null ) return ; \nString [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; \nCellFormAttributes attr = new CellFormAttributes ( ) ; \nfor ( String cattr : cattrs ) { \nextractValidationAttributes ( attr , cattr ) ; \n} \nif ( ( attr . getValue ( ) != null ) && ( ! attr . getValue ( ) . isEmpty ( ) ) ) clist . add ( attr ) ; \n} \n} \n"}
{"8735": "public class ParserUtility { \nprivate static String [ ] splitByEualSign ( final String attrData ) { \nint attrNameEndIndex = attrData . indexOf ( '=' ) ; \nif ( attrNameEndIndex < 0 ) return new String [ 0 ] ; \nString attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; \nString attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; \nString [ ] rlist = new String [ 2 ] ; \nrlist [ 0 ] = attrName ; \nrlist [ 1 ] = attrValue ; \nreturn rlist ; \n} \n} \n"}
{"8736": "public class ParserUtility { \npublic static void parseSpecialAttributes ( final String key , final String type , final List < CellFormAttributes > inputs , final CellAttributesMap cellAttributesMap ) { \nSpecialAttributes sAttr = new SpecialAttributes ( ) ; \nfor ( CellFormAttributes attr : inputs ) { \ngatherSpecialAttributes ( type , sAttr , attr ) ; \n} \nif ( sAttr . selectLabels != null ) processSelectItemAttributes ( key , cellAttributesMap , sAttr ) ; \nif ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) processCalendarAttributes ( key , cellAttributesMap , sAttr ) ; \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) sAttr . selectValues = sAttr . selectLabels ; \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) smap = new LinkedHashMap < > ( ) ; \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) smap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \nfor ( int i = 0 ; \ni < sAttr . selectLabels . length ; \ni ++ ) smap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \n} \n} \n"}
{"8739": "public class ParserUtility { \nprivate static void gatherSpecialAttributes ( final String type , final SpecialAttributes sAttr , final CellFormAttributes attr ) { \nString attrKey = attr . getType ( ) ; \nif ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_LABELS ) ) sAttr . selectLabels = attr . getValue ( ) . split ( \";\" ) ; \nif ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_VALUES ) ) sAttr . selectValues = attr . getValue ( ) . split ( \";\" ) ; \nif ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_LABEL ) ) sAttr . defaultSelectLabel = attr . getValue ( ) ; \nif ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_VALUE ) ) sAttr . defaultSelectValue = attr . getValue ( ) ; \nif ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) && attrKey . equalsIgnoreCase ( TieConstants . WIDGET_ATTR_PATTERN ) ) sAttr . defaultDatePattern = attr . getValue ( ) ; \n} \n} \n"}
{"8740": "public class ParserUtility { \npublic static void parseCommentToMap ( final String cellKey , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { \nif ( ( newComment != null ) && ( ! newComment . trim ( ) . isEmpty ( ) ) ) { \nString commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; \nif ( ! normalComment ) commentKey = newComment . substring ( 0 , newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; \nMap < String , String > map = sheetCommentMap . get ( commentKey ) ; \nif ( map == null ) map = new HashMap < > ( ) ; \nmap . put ( cellKey , newComment ) ; \nsheetCommentMap . put ( commentKey , map ) ; \n} \n} \n} \n"}
{"8741": "public class ParserUtility { \npublic static int findFirstNonCellNamePosition ( String input , int startPosition ) { \nchar c ; \nfor ( int i = startPosition ; \ni < input . length ( ) ; \ni ++ ) { \nc = input . charAt ( i ) ; \nif ( c != '$' && ! Character . isLetterOrDigit ( c ) ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8745": "public class WebSheetUtility { \npublic static Cell getCellByReference ( final String cellRef , final Sheet sheet ) { \nCell c = null ; \ntry { \nCellReference ref = new CellReference ( cellRef ) ; \nRow r = sheet . getRow ( ref . getRow ( ) ) ; \nif ( r != null ) c = r . getCell ( ref . getCol ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"WebForm WebFormHelper getCellByReference cellRef = \" + cellRef + \"; error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn c ; \n} \n} \n"}
{"8747": "public class WebSheetUtility { \npublic static boolean isDate ( final String s ) { \nPattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; \nString [ ] terms = s . split ( \" \" ) ; \nMatcher matcher ; \nfor ( String term : terms ) { \nmatcher = pattern . matcher ( term ) ; \nif ( matcher . matches ( ) ) return true ; \n} \npattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; \nterms = s . split ( \" \" ) ; \nfor ( String term : terms ) { \nmatcher = pattern . matcher ( term ) ; \nif ( matcher . matches ( ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"8748": "public class WebSheetUtility { \npublic static String parseDate ( final String entry ) { \nPattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; \nString [ ] terms = entry . split ( \" \" ) ; \nMatcher matcher ; \nfor ( String term : terms ) { \nmatcher = pattern . matcher ( term ) ; \nif ( matcher . matches ( ) ) return matcher . group ( ) ; \n} \npattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; \nterms = entry . split ( \" \" ) ; \nfor ( String term : terms ) { \nmatcher = pattern . matcher ( term ) ; \nif ( matcher . matches ( ) ) return matcher . group ( ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) s = s . substring ( 1 ) ; \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \ni < sLen ; \ni ++ ) { \nc = s . charAt ( i ) ; \nif ( c < '0' || c > '9' ) if ( ! shouldContinue ( c , sPara ) ) return false ; \nelse if ( sPara . isCommaHit ( ) ) sPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \nreturn true ; \n} \n} \n"}
{"8750": "public class WebSheetUtility { \nprivate static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { \nif ( c == '.' && ! para . isDecimalHit ( ) ) { \npara . setDecimalHit ( true ) ; \nif ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) return false ; \nreturn true ; \n} \nelse if ( c == ',' && ! para . isDecimalHit ( ) ) { \nif ( para . isCommaHit ( ) ) { \nif ( para . getSinceLastComma ( ) != 3 ) return false ; \npara . setSinceLastComma ( 0 ) ; \n} \npara . setCommaHit ( true ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"8751": "public class WebSheetUtility { \npublic static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { \ntry { \nMethod method = obj . getClass ( ) . getMethod ( \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) , new Class [ ] { \nString . class } \n) ; \nmethod . invoke ( obj , propertyValue ) ; \n} \ncatch ( Exception e ) { \nString msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; \nif ( ignoreNonExisting ) LOG . info ( msg ) ; \nelse { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \n} \n} \n} \n"}
{"8752": "public class WebSheetUtility { \npublic static int cellCompareTo ( final Cell thisCell , final Cell otherCell ) { \nint r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; \nif ( r != 0 ) return r ; \nr = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; \nif ( r != 0 ) return r ; \nreturn 0 ; \n} \n} \n"}
{"8754": "public class WebSheetUtility { \npublic static void clearHiddenColumns ( final Sheet sheet ) { \nfor ( Row row : sheet ) { \nif ( row . getLastCellNum ( ) > TieConstants . MAX_COLUMNS_IN_SHEET ) deleteHiddenColumnsInRow ( row ) ; \n} \n} \n} \n"}
{"8756": "public class WebSheetUtility { \nprivate static void deleteCellFromRow ( final Row row , final int cellNum ) { \nCell cell = row . getCell ( cellNum ) ; \nif ( cell != null ) row . removeCell ( cell ) ; \n} \n} \n"}
{"8758": "public class ValidationHandler { \nprivate void refreshAfterStatusChanged ( final boolean oldStatus , final boolean newStatus , final int formRow , final int formCol , final FacesCell cell , final boolean updateGui ) { \nif ( ! newStatus ) cell . setErrormsg ( \"\" ) ; \ncell . setInvalid ( newStatus ) ; \nif ( updateGui && ( oldStatus != newStatus ) && ( parent . getWebFormClientId ( ) != null ) ) RequestContext . getCurrentInstance ( ) . update ( parent . getWebFormClientId ( ) + \":\" + ( formRow ) + \":group\" + ( formCol ) ) ; \n} \n} \n"}
{"8759": "public class ValidationHandler { \npublic boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { \nboolean submitMode = parent . getSubmitMode ( ) ; \nboolean passEmptyCheck = ! submitMode ; \nint topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nboolean pass = true ; \nFacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; \nif ( fRow == null ) return pass ; \nFacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; \nif ( cell == null ) return pass ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; \nboolean oldStatus = cell . isInvalid ( ) ; \nString value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; \nif ( value == null ) value = \"\" ; \nelse value = value . trim ( ) ; \nif ( passEmptyCheck && value . isEmpty ( ) ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn pass ; \n} \nif ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) return false ; \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nList < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; \nif ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) return false ; \nif ( cellAttributes != null ) pass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; \nif ( pass ) refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn pass ; \n} \n} \n"}
{"8762": "public class ValidationHandler { \nprivate boolean validateAllRulesForSingleCell ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , final List < CellFormAttributes > cellAttributes , boolean updateGui ) { \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; \nfor ( CellFormAttributes attr : cellAttributes ) { \nboolean pass = doValidation ( value , attr , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , sheet1 ) ; \nif ( ! pass ) { \nString errmsg = attr . getMessage ( ) ; \nif ( errmsg == null ) errmsg = TieConstants . DEFALT_MSG_INVALID_INPUT ; \ncell . setErrormsg ( errmsg ) ; \nLOG . log ( Level . INFO , \"Validation failed for sheet {0} row {1} column {2} : {3}\" , new Object [ ] { \npoiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errmsg } \n) ; \nrefreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8763": "public class ValidationHandler { \nprivate boolean doValidation ( final Object value , final CellFormAttributes attr , final int rowIndex , final int colIndex , final Sheet sheet ) { \nboolean pass ; \nString attrValue = attr . getValue ( ) ; \nattrValue = attrValue . replace ( \"$value\" , value . toString ( ) + \"\" ) . replace ( \"$rowIndex\" , rowIndex + \"\" ) . replace ( \"$colIndex\" , colIndex + \"\" ) . replace ( \"$sheetName\" , sheet . getSheetName ( ) ) ; \nattrValue = ConfigurationUtility . replaceExpressionWithCellValue ( attrValue , rowIndex , sheet ) ; \nif ( attrValue . contains ( TieConstants . EL_START ) ) { \nObject returnObj = FacesUtility . evaluateExpression ( attrValue , Object . class ) ; \nattrValue = returnObj . toString ( ) ; \npass = Boolean . parseBoolean ( attrValue ) ; \n} \nelse pass = parent . getCellHelper ( ) . evalBoolExpression ( attrValue ) ; \nreturn pass ; \n} \n} \n"}
{"8765": "public class ValidationHandler { \npublic final boolean validateCurrentPage ( ) { \nboolean allpass = true ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nfor ( int irow = 0 ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow ++ ) if ( ! validateRowInCurrentPage ( irow + top , false ) ) allpass = false ; \nreturn allpass ; \n} \n} \n"}
{"8767": "public class ValidationHandler { \nprivate boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { \nboolean pass = true ; \nif ( sheetConfig == null ) return pass ; \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nList < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; \nfor ( int index = 0 ; \nindex < cellRow . size ( ) ; \nindex ++ ) { \nFacesCell fcell = cellRow . get ( index ) ; \nif ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) pass = false ; \n} \nreturn pass ; \n} \n} \n"}
{"8768": "public class ValidationHandler { \nprivate void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { \nUIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; \nif ( s == null ) return ; \nDataTable webDataTable = ( DataTable ) s ; \nint first = webDataTable . getFirst ( ) ; \nint rowsToRender = webDataTable . getRowsToRender ( ) ; \nint rowCounts = webDataTable . getRowCount ( ) ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nfor ( int i = first ; \ni <= ( first + rowsToRender ) ; \ni ++ ) if ( i < rowCounts ) refreshCachedCellsInRow ( tblName , top , left , i ) ; \n} \n} \n"}
{"8769": "public class ValidationHandler { \nprivate void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { \nFacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; \nint isize = dataRow . getCells ( ) . size ( ) ; \nfor ( int index = 0 ; \nindex < isize ; \nindex ++ ) { \nFacesCell fcell = dataRow . getCells ( ) . get ( index ) ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; \nif ( poiCell != null ) parent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; \n} \n} \n} \n"}
{"8770": "public class ValidationHandler { \npublic void setSubmitModeInView ( final Boolean fullflag ) { \nif ( FacesContext . getCurrentInstance ( ) != null ) { \nMap < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; \nif ( viewMap != null ) { \nBoolean flag = ( Boolean ) viewMap . get ( TieConstants . SUBMITMODE ) ; \nif ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) viewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; \n} \n} \n} \n} \n"}
{"8771": "public class ValidationHandler { \npublic boolean preValidation ( ) { \nString currentTabName = parent . getCurrent ( ) . getCurrentTabName ( ) ; \nString tabName = null ; \nString firstInvalidTabName = null ; \nboolean reload = false ; \nfor ( Map . Entry < String , SheetConfiguration > entry : parent . getSheetConfigMap ( ) . entrySet ( ) ) { \ntabName = entry . getKey ( ) ; \nif ( reload || ( ! tabName . equals ( currentTabName ) ) ) { \nparent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; \nreload = true ; \n} \nif ( ! parent . getValidationHandler ( ) . validateCurrentPage ( ) && ( firstInvalidTabName == null ) ) firstInvalidTabName = tabName ; \n} \nif ( firstInvalidTabName != null ) { \nif ( ! tabName . equals ( firstInvalidTabName ) ) parent . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( firstInvalidTabName ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"8772": "public class CellAttributesMap { \npublic final void clear ( ) { \nif ( this . templateCommentMap != null ) this . templateCommentMap . clear ( ) ; \nif ( this . cellDatePattern != null ) this . cellDatePattern . clear ( ) ; \nif ( this . cellInputAttributes != null ) this . cellInputAttributes . clear ( ) ; \nif ( this . cellInputType != null ) this . cellInputType . clear ( ) ; \nif ( this . cellSelectItemsAttributes != null ) this . cellSelectItemsAttributes . clear ( ) ; \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nint bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nint left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nint totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) parent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( top < 0 ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \nfor ( int i = top ; \ni <= bottom ; \ni ++ ) parent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \nparent . setShowLineNumber ( false ) ; \n} \n} \n} \n"}
{"8774": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { \nint firstCol = rangeBuildRef . getLeft ( ) ; \nint lastCol = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int i = firstCol ; \ni <= lastCol ; \ni ++ ) if ( ! sheet1 . isColumnHidden ( i ) ) { \nString style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8775": "public class WebSheetLoader { \nprivate void fillToMaxColumns ( final List < HeaderCell > headercells ) { \nif ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { \nint fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; \nfor ( int s = 0 ; \ns < fills ; \ns ++ ) headercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; \n} \n} \n} \n"}
{"8776": "public class WebSheetLoader { \nprivate String getHeaderColumnStyle ( final Workbook wb , final Cell cell , final double colWidth , final double totalWidth ) { \nString columnstyle = \"\" ; \nif ( cell != null ) columnstyle += CellStyleUtility . getCellStyle ( wb , cell , \"\" ) + CellStyleUtility . getCellFontStyle ( wb , cell ) ; \ncolumnstyle = columnstyle + getWidthStyle ( colWidth , totalWidth ) ; \nreturn columnstyle ; \n} \n} \n"}
{"8778": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nint left = rangeBuildRef . getLeft ( ) ; \nint right = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nRow row = sheet1 . getRow ( currentRow ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \ncindex <= right ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nint originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nheadercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; \n} \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8779": "public class WebSheetLoader { \nprivate String getColumnWidthStyle ( final Sheet sheet1 , final Map < String , CellRangeAddress > cellRangeMap , final String cellindex , final int cindex , final double totalWidth ) { \nCellRangeAddress caddress = cellRangeMap . get ( cellindex ) ; \ndouble colWidth ; \nif ( caddress != null ) colWidth = CellStyleUtility . calcTotalWidth ( sheet1 , caddress . getFirstColumn ( ) , caddress . getLastColumn ( ) , 0 ) ; \nelse colWidth = sheet1 . getColumnWidth ( cindex ) ; \nreturn getWidthStyle ( colWidth , totalWidth ) ; \n} \n} \n"}
{"8781": "public class WebSheetLoader { \nprivate void initTabs ( ) { \nparent . setTabs ( new ArrayList < TabModel > ( ) ) ; \nif ( parent . getSheetConfigMap ( ) != null ) for ( String key : parent . getSheetConfigMap ( ) . keySet ( ) ) { \nparent . getTabs ( ) . add ( new TabModel ( \"form_\" + key , key , \"form\" ) ) ; \n} \n} \n} \n"}
{"8782": "public class WebSheetLoader { \nprivate void loadData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) return ; \nif ( parent . isAdvancedContext ( ) ) parent . getSerialDataContext ( ) . getDataContext ( ) . put ( \"tiecells\" , new HashMap < String , TieCell > ( ) ) ; \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nList < RowsMapping > currentRowsMappingList = null ; \nConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; \nint length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , currentRowsMappingList ) ; \nsheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; \nsheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; \nsheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; \nsheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; \nsheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; \nsheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; \nsheetConfig . setBodyPopulated ( true ) ; \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8783": "public class WebSheetLoader { \npublic void refreshData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) return ; \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nfor ( int irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; \nirow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ; \nirow ++ ) refreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8784": "public class WebSheetLoader { \nprivate void refreshDataForRow ( Row row ) { \nif ( row == null ) return ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nif ( saveAttrList != null ) { \nString [ ] saveAttrs = saveAttrList . split ( \",\" ) ; \nfor ( String fullSaveAttr : saveAttrs ) { \nrefreshDataForCell ( row , fullSaveAttr ) ; \n} \n} \n} \n} \n"}
{"8785": "public class WebSheetLoader { \nprivate void refreshDataForCell ( Row row , String fullSaveAttr ) { \nif ( fullSaveAttr != null ) try { \nString fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; \nif ( fullName != null ) { \nparent . getCellHelper ( ) . restoreDataContext ( fullName ) ; \nSaveAttrsUtility . refreshSheetRowFromContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , fullSaveAttr , row , parent . getExpEngine ( ) ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"refreshDataForCell with fullAaveAttr =\" + fullSaveAttr + \" error = \" + ex . getMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8786": "public class WebSheetLoader { \npublic final int findTabIndexWithName ( final String tabname ) { \nfor ( int i = 0 ; \ni < parent . getTabs ( ) . size ( ) ; \ni ++ ) if ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"8787": "public class WebSheetLoader { \npublic final void loadWorkSheet ( final String tabName ) { \nprepareWorkShee ( tabName ) ; \nparent . getValidationHandler ( ) . validateCurrentPage ( ) ; \ncreateDynamicColumns ( tabName ) ; \nsetDataTablePage ( 0 ) ; \nparent . getCurrent ( ) . setCurrentDataContextName ( null ) ; \nsaveObjs ( ) ; \nif ( ( RequestContext . getCurrentInstance ( ) != null ) && ( parent . getClientId ( ) != null ) ) RequestContext . getCurrentInstance ( ) . update ( parent . getClientId ( ) + \":websheettab\" ) ; \n} \n} \n"}
{"8788": "public class WebSheetLoader { \npublic final void prepareWorkShee ( final String tabName ) { \nint tabIndex = findTabIndexWithName ( tabName ) ; \nif ( parent . getWebFormTabView ( ) != null ) parent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; \nparent . getCurrent ( ) . setCurrentTabName ( tabName ) ; \nString sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nparent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; \nparent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; \nloadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; \nloadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; \n} \n} \n"}
{"8789": "public class WebSheetLoader { \nprivate void setDataTablePage ( final int first ) { \nif ( parent . getWebFormClientId ( ) != null ) { \nfinal DataTable d = ( DataTable ) FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . findComponent ( parent . getWebFormClientId ( ) ) ; \nif ( d != null ) d . setFirst ( first ) ; \n} \n} \n} \n"}
{"8792": "public class WebSheetLoader { \nprivate void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nclearCache ( ) ; \nfor ( int i = top ; \ni <= bottom ; \ni ++ ) parent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \nsheetConfig . setBodyPopulated ( true ) ; \nparent . getCurrent ( ) . setCurrentTopRow ( top ) ; \nparent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; \n} \n} \n"}
{"8793": "public class WebSheetLoader { \nprivate FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nFacesRow facesRow = new FacesRow ( rowIndex ) ; \nRow row = sheet1 . getRow ( rowIndex ) ; \nsetupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nList < FacesCell > bodycells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \ncindex <= right ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nbodycells . add ( fcell ) ; \naddCache ( cell ) ; \n} \nelse bodycells . add ( null ) ; \n} \nelse bodycells . add ( null ) ; \n} \nfacesRow . setCells ( bodycells ) ; \nreturn facesRow ; \n} \n} \n"}
{"8794": "public class WebSheetLoader { \npublic final void refreshCachedCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) && ( tblName != null ) ) try { \nprocessRefreshCell ( tblName , i , index , cell , fcell ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"refresh Cached Cell error : \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8795": "public class WebSheetLoader { \nprivate void processRefreshCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { \nString newValue = CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) ; \nif ( parent . getCachedCells ( ) . isValueChanged ( cell , newValue ) ) { \nif ( fcell . isHasSaveAttr ( ) ) parent . getCellHelper ( ) . saveDataInContext ( cell , newValue ) ; \nRequestContext . getCurrentInstance ( ) . update ( tblName + \":\" + i + \":cocalc\" + index ) ; \nparent . getCachedCells ( ) . put ( cell , CellType . FORMULA ) ; \n} \n} \n} \n"}
{"8796": "public class WebSheetLoader { \nprivate void createDynamicColumns ( final String tabName ) { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nparent . getColumns ( ) . clear ( ) ; \nfor ( int i = left ; \ni <= right ; \ni ++ ) parent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; \n} \n} \n"}
{"8798": "public class WebSheetLoader { \nprivate void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nfor ( int irow = insertPosition ; \nirow < ( insertPosition + length ) ; \nirow ++ ) parent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \nfor ( int irow = insertPosition + length - top ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; \n} \n} \n} \n"}
{"8800": "public class WebSheetLoader { \npublic final Boolean isUnsavedStatus ( ) { \nMap < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; \nBoolean flag = ( Boolean ) viewMap . get ( TieConstants . UNSAVEDSTATE ) ; \nif ( flag == null ) return false ; \nreturn flag ; \n} \n} \n"}
{"8801": "public class Utils { \npublic static < T > Constructor < T > commonConstructor ( Class < T > type ) throws NoMethodForDependency { \nConstructor < ? > [ ] cs = type . getDeclaredConstructors ( ) ; \nif ( cs . length == 0 ) throw new NoMethodForDependency ( raw ( type ) ) ; \nConstructor < ? > mostParamsConstructor = null ; \nfor ( Constructor < ? > c : cs ) { \nif ( ! arrayContains ( c . getParameterTypes ( ) , type , ( a , b ) -> a == b ) && ( mostParamsConstructor == null || ( moreVisible ( c , mostParamsConstructor ) == c && ( moreVisible ( mostParamsConstructor , c ) == c || c . getParameterCount ( ) > mostParamsConstructor . getParameterCount ( ) ) ) ) ) mostParamsConstructor = c ; \n} \nif ( mostParamsConstructor == null ) throw new NoMethodForDependency ( raw ( type ) ) ; \n@ SuppressWarnings ( \"unchecked\" ) Constructor < T > c = ( Constructor < T > ) mostParamsConstructor ; \nreturn c ; \n} \n} \n"}
{"8804": "public class CacheEntry { \nprotected final void writeString ( final Writer writer , final String line ) throws IOException { \nif ( line != null ) writer . write ( line + '\\n' ) ; \nelse writer . write ( '\\n' ) ; \n} \n} \n"}
{"8805": "public class BaseRequestBuilder { \nprotected void setConvertedTrafficStatsTag ( final String tag ) { \nresult . statsTag = Utils . getTrafficStatsTag ( tag ) ; \nif ( config . isDebugRest ( ) ) Log . d ( TAG , \"TrafficStats tag <\" + tag + \">=\" + Integer . toHexString ( result . statsTag ) ) ; \n} \n} \n"}
{"8808": "public class BaseRequestBuilder { \nprotected Parameter removeParameter ( final String name ) { \nif ( name == null ) throw new IllegalArgumentException ( \"Parameter name cannot be null\" ) ; \nfinal Iterator < Parameter > iter = result . simpleParameters . getChildren ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nfinal Parameter p = iter . next ( ) ; \nif ( name . equals ( p . name ) ) { \niter . remove ( ) ; \nreturn p ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8813": "public class StreamingPlaybackController { \nprotected final void bind ( ) { \nif ( bindRequested ) return ; \nfinal boolean result = context . bindService ( createBindIntent ( ) , serviceConnection , 0 ) ; \nif ( DEBUG ) Log . v ( TAG , \"Bind to streaming service: \" + result ) ; \nbindRequested = result ; \nonBind ( result ) ; \n} \n} \n"}
{"8814": "public class StreamingPlaybackController { \nprotected final void unbind ( ) { \nif ( streamingPlayback != null ) dropListener ( ) ; \ntry { \ncontext . unbindService ( serviceConnection ) ; \n} \ncatch ( final RuntimeException e ) { \nif ( DEBUG ) Log . w ( TAG , \"Cannot unbind radio\" , e ) ; \n} \nbindRequested = false ; \n} \n} \n"}
{"8815": "public class StreamingPlaybackController { \nprotected final void dropListener ( ) { \nif ( DEBUG ) Log . v ( TAG , \"Drop listener\" ) ; \nif ( streamingPlayback != null ) { \ntry { \nstreamingPlayback . removeListener ( ) ; \n} \ncatch ( final RemoteException e ) { \nLog . e ( TAG , \"Cannot remove listener\" , e ) ; \n} \nbindRequested = false ; \n} \n} \n} \n"}
{"8816": "public class ImageRequest { \npublic void storeToDisk ( ) throws IOException { \nif ( manager . isPresentOnDisk ( url ) ) return ; \nif ( ! hasAllowedSize ( ) ) { \nIoUtils . consumeStream ( getRemoteInputStream ( ) , manager . getBuffersPool ( ) ) ; \nreturn ; \n} \nImageResult result = decodeStream ( getRemoteInputStream ( ) , true ) ; \nif ( result . getType ( ) == ImageSourceType . NETWORK && result . getBitmap ( ) != null ) writeBitmapToDisk ( result . getBitmap ( ) ) ; \n} \n} \n"}
{"8819": "public class StringPart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendData(OutputStream)\" ) ; \nout . write ( getContent ( ) ) ; \n} \n} \n"}
{"8820": "public class PoolableBufferedInputStream { \n@ Override public synchronized int available ( ) throws IOException { \nfinal InputStream localIn = in ; \nif ( buf == null || localIn == null ) throw new IOException ( \"Stream is closed\" ) ; \nreturn count - pos + localIn . available ( ) ; \n} \n} \n"}
{"8821": "public class PoolableBufferedInputStream { \n@ Override public void close ( ) throws IOException { \nfinal byte [ ] localBuf = buf ; \nbuf = null ; \nfinal InputStream localIn = in ; \nin = null ; \npool . release ( localBuf ) ; \nif ( localIn != null ) localIn . close ( ) ; \n} \n} \n"}
{"8822": "public class PoolableBufferedInputStream { \n@ Override public synchronized int read ( ) throws IOException { \nbyte [ ] localBuf = buf ; \nfinal InputStream localIn = in ; \nif ( localBuf == null || localIn == null ) throw new IOException ( \"Stream is closed\" ) ; \nif ( pos >= count && fillbuf ( localIn , localBuf ) == - 1 ) return - 1 ; \nif ( localBuf != buf ) { \nlocalBuf = buf ; \nif ( localBuf == null ) throw new IOException ( \"Stream is closed\" ) ; \n} \nfinal int mask = 0xFF ; \nif ( count - pos > 0 ) return localBuf [ pos ++ ] & mask ; \nreturn - 1 ; \n} \n} \n"}
{"8823": "public class PoolableBufferedInputStream { \n@ Override public synchronized void reset ( ) throws IOException { \nif ( buf == null ) throw new IOException ( \"Stream is closed\" ) ; \nif ( - 1 == markpos ) throw new IOException ( \"Mark has been invalidated.\" ) ; \npos = markpos ; \n} \n} \n"}
{"8824": "public class Part { \nprotected void sendStart ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendStart(OutputStream out)\" ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( getPartBoundary ( ) ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8825": "public class Part { \nprotected void sendDispositionHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendDispositionHeader(OutputStream out)\" ) ; \nout . write ( CONTENT_DISPOSITION_BYTES ) ; \nout . write ( QUOTE_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( getName ( ) ) ) ; \nout . write ( QUOTE_BYTES ) ; \n} \n} \n"}
{"8826": "public class Part { \nprotected void sendContentTypeHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendContentTypeHeader(OutputStream out)\" ) ; \nfinal String contentType = getContentType ( ) ; \nif ( contentType != null ) { \nout . write ( CRLF_BYTES ) ; \nout . write ( CONTENT_TYPE_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( contentType ) ) ; \nfinal String charSet = getCharSet ( ) ; \nif ( charSet != null ) { \nout . write ( CHARSET_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( charSet ) ) ; \n} \n} \n} \n} \n"}
{"8827": "public class Part { \nprotected void sendTransferEncodingHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendTransferEncodingHeader(OutputStream out)\" ) ; \nfinal String transferEncoding = getTransferEncoding ( ) ; \nif ( transferEncoding != null ) { \nout . write ( CRLF_BYTES ) ; \nout . write ( CONTENT_TRANSFER_ENCODING_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( transferEncoding ) ) ; \n} \n} \n} \n"}
{"8828": "public class Part { \nprotected void sendEndOfHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendEndOfHeader(OutputStream out)\" ) ; \nout . write ( CRLF_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8829": "public class Part { \nprotected void sendEnd ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendEnd(OutputStream out)\" ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) throw new IllegalArgumentException ( \"Parts may not be null\" ) ; \nif ( partBoundary == null || partBoundary . length == 0 ) throw new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8831": "public class Part { \npublic static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"getLengthOfParts(Parts[])\" ) ; \nif ( parts == null ) throw new IllegalArgumentException ( \"Parts may not be null\" ) ; \nlong total = 0 ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nfinal long l = parts [ i ] . length ( ) ; \nif ( l < 0 ) return - 1 ; \ntotal += l ; \n} \ntotal += EXTRA_BYTES . length ; \ntotal += partBoundary . length ; \ntotal += EXTRA_BYTES . length ; \ntotal += CRLF_BYTES . length ; \nreturn total ; \n} \n} \n"}
{"8837": "public class WebsockifyProxyHandler { \nstatic void closeOnFlush ( Channel ch ) { \nif ( ch . isConnected ( ) ) ch . write ( ChannelBuffers . EMPTY_BUFFER ) . addListener ( ChannelFutureListener . CLOSE ) ; \n} \n} \n"}
{"8838": "public class FilePart { \n@ Override protected void sendDispositionHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( \"FilePart\" , \"enter sendDispositionHeader(OutputStream out)\" ) ; \nsuper . sendDispositionHeader ( out ) ; \nfinal String filename = this . source . getFileName ( ) ; \nif ( filename != null ) { \nout . write ( FILE_NAME_BYTES ) ; \nout . write ( QUOTE_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( filename ) ) ; \nout . write ( QUOTE_BYTES ) ; \n} \n} \n} \n"}
{"8839": "public class FilePart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) Log . v ( TAG , \"enter sendData(OutputStream out)\" ) ; \nif ( lengthOfData ( ) == 0 ) { \nif ( DEBUG ) Log . d ( TAG , \"No data to send.\" ) ; \nreturn ; \n} \nfinal int size = 4096 ; \nfinal byte [ ] tmp = new byte [ size ] ; \nfinal InputStream instream = source . createInputStream ( ) ; \ntry { \nint len ; \nwhile ( ( len = instream . read ( tmp ) ) >= 0 ) out . write ( tmp , 0 , len ) ; \n} \nfinally { \ninstream . close ( ) ; \n} \n} \n} \n"}
{"8840": "public class BaseFileResponseCache { \nprotected void install ( final int version ) throws IOException { \nif ( buffersPool == null ) throw new IllegalStateException ( \"Buffers pool is not resolved\" ) ; \ndiskCache = DiskLruCache . open ( ensureWorkingDirectory ( ) , version , ENTRIES_COUNT , getMaxSize ( ) ) ; \nonCacheInstalled ( ) ; \n} \n} \n"}
{"8841": "public class BaseFileResponseCache { \nprivate synchronized File ensureWorkingDirectory ( ) throws IOException { \nFile directory = getWorkingDirectory ( ) ; \nif ( ! directory . exists ( ) ) if ( ! directory . mkdirs ( ) ) throw new IOException ( \"Working directory \" + directory + \" cannot be created\" ) ; \nelse if ( ! directory . isDirectory ( ) ) { \nif ( ! directory . delete ( ) ) throw new IOException ( directory + \" is not a directory and cannot be deleted\" ) ; \nif ( ! directory . mkdirs ( ) ) throw new IOException ( \"Working directory \" + directory + \" cannot be recreated\" ) ; \n} \nreturn directory ; \n} \n} \n"}
{"8842": "public class BaseFileResponseCache { \nprotected CacheResponse get ( final CacheEntry requestInfo ) { \nif ( ! checkDiskCache ( ) ) return null ; \nfinal CacheEntry entry = newCacheEntry ( ) ; \nfinal DiskLruCache . Snapshot snapshot = readCacheInfo ( requestInfo , entry ) ; \nif ( snapshot == null ) return null ; \nif ( ! entry . matches ( requestInfo ) || ! entry . canBeUsed ( ) ) { \nsnapshot . close ( ) ; \nreturn null ; \n} \nhitCount . incrementAndGet ( ) ; \nfinal InputStream body = newBodyInputStream ( snapshot ) ; \nreturn entry . newCacheResponse ( body ) ; \n} \n} \n"}
{"8844": "public class BufferBitmapDecorator { \nprotected void reset ( final int width , final int height ) { \nBitmap bitmap = this . bitmap ; \nif ( bitmap != null ) bitmap . recycle ( ) ; \nbitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; \nthis . bitmap = bitmap ; \nthis . bitmapCanvas = new Canvas ( bitmap ) ; \n} \n} \n"}
{"8848": "public class LocationBinder { \npublic void stopListening ( ) { \nif ( locationManager == null ) return ; \nif ( DEBUG ) Log . d ( TAG , \"Stop location listening...\" ) ; \nif ( listener != null ) listener . onLocationStop ( ) ; \nmyHandler . removeMessages ( MSG_STOP_FINE_PROVIDER ) ; \nlocationManager . removeUpdates ( coarseListener ) ; \nlocationManager . removeUpdates ( fineListener ) ; \nlocationManager = null ; \n} \n} \n"}
{"8850": "public class RequestMethod { \nprotected void disconnect ( final URLConnection connection ) { \nfinal URLConnection http = UrlConnectionWrapper . unwrap ( connection ) ; \nif ( http instanceof HttpURLConnection ) ( ( HttpURLConnection ) http ) . disconnect ( ) ; \n} \n} \n"}
{"8851": "public class ApplicationServiceSupport { \npublic void bind ( ) { \nif ( serviceObject != null ) return ; \nfinal Context context = contextRef . get ( ) ; \nif ( context == null ) return ; \nfinal Intent intent = new Intent ( context , GoroService . class ) ; \nintent . setAction ( getInterfaceClass ( ) . getName ( ) ) ; \nif ( DEBUG_CALLS ) Log . v ( TAG , \"Attempt to bind to service \" + this + \"/\" + context , new RuntimeException ( ) ) ; \ncontext . startService ( intent ) ; \nfinal boolean bindResult = context . bindService ( intent , this , 0 ) ; \nif ( DEBUG ) Log . v ( TAG , \"Binded to service: \" + bindResult + \", \" + context + \", interface: \" + getInterfaceClass ( ) ) ; \n} \n} \n"}
{"8852": "public class ApplicationServiceSupport { \npublic void unbind ( ) { \nif ( serviceObject == null ) return ; \nserviceObject = null ; \nfinal Context context = contextRef . get ( ) ; \nif ( DEBUG ) Log . v ( TAG , \"Unbind \" + context + \" from \" + getInterfaceClass ( ) ) ; \nif ( context == null ) return ; \ntry { \ncontext . unbindService ( this ) ; \n} \ncatch ( final Exception e ) { \nif ( DEBUG ) Log . e ( TAG , \"Cannot unbind from application service\" , e ) ; \n} \n} \n} \n"}
{"8853": "public class ViewImageConsumer { \npublic void notifyAboutViewChanges ( ) { \nfinal T view = this . view ; \nif ( view != null && view instanceof ImagesLoadListenerProvider ) this . listener = ( ( ImagesLoadListenerProvider ) view ) . getImagesLoadListener ( ) ; \n} \n} \n"}
{"8856": "public class RequestBuilderLoader { \n@ Override protected void onReset ( ) { \nif ( DEBUG ) Log . v ( TAG , \"onReset \" + this ) ; \nsuper . onReset ( ) ; \nonStopLoading ( ) ; \nif ( receivedResponse != null ) { \nonReleaseData ( receivedResponse ) ; \nreceivedResponse = null ; \n} \n} \n} \n"}
{"8858": "public class GUIUtils { \npublic static void setTextOrHide ( final TextView view , final CharSequence text , final int hvisibility ) { \nif ( TextUtils . isEmpty ( text ) ) view . setVisibility ( hvisibility ) ; \nelse { \nview . setText ( text ) ; \nview . setVisibility ( View . VISIBLE ) ; \n} \n} \n} \n"}
{"8865": "public class ImagesManager { \npublic void populateImage ( final View view , final String url ) { \nfinal Object tag = view . getTag ( ) ; \nImageConsumer consumer = null ; \nif ( tag == null ) { \nconsumer = createImageConsumer ( view ) ; \nview . setTag ( consumer ) ; \n} \nelse { \nif ( ! ( tag instanceof ImageConsumer ) ) throw new IllegalStateException ( \"View already has a tag \" + tag + \". Cannot store consumer\" ) ; \nconsumer = ( ImageConsumer ) tag ; \n} \npopulateImage ( consumer , url ) ; \n} \n} \n"}
{"8866": "public class ImagesManager { \npublic void cancelImageLoading ( final View view ) { \ncheckThread ( ) ; \nfinal Object tag = view . getTag ( ) ; \nif ( tag != null && tag instanceof ImageConsumer ) cancelImageLoading ( ( ImageConsumer ) tag ) ; \n} \n} \n"}
{"8867": "public class ImagesManager { \nprotected ImageConsumer createImageConsumer ( final View view ) { \nif ( this . consumerFactory == null ) throw new IllegalStateException ( \"Image consumers factory bean not found in container. Take a look at DefaultBeansManager.edit().images() method in assist package.\" ) ; \nreturn consumerFactory . createConsumer ( view ) ; \n} \n} \n"}
{"8869": "public class ImagesManager { \nprivate void setLoadingImage ( final ImageConsumer consumer ) { \nif ( ! consumer . skipLoadingImage ( ) ) { \nDrawable d = getLoadingDrawable ( consumer ) ; \nif ( ! consumer . hasUndefinedSize ( ) || ( d . getIntrinsicWidth ( ) != 0 && d . getIntrinsicHeight ( ) != 0 ) ) consumer . setLoadingImage ( d ) ; \n} \n} \n} \n"}
{"8870": "public class ImagesManager { \nprivate void startImageLoaderTask ( final ImageConsumer consumer , final ImageRequest request ) { \nfinal String key = request . getKey ( ) ; \nif ( debug ) Log . d ( TAG , \"Key \" + key ) ; \nImageLoader loader = currentLoads . get ( key ) ; \nif ( loader != null ) { \nfinal boolean added = loader . addTarget ( consumer ) ; \nif ( ! added ) loader = null ; \n} \nif ( loader == null ) { \nif ( debug ) Log . d ( TAG , \"Start a new task\" ) ; \nloader = new ImageLoader ( request , this ) ; \nif ( ! loader . addTarget ( consumer ) ) throw new IllegalStateException ( \"Cannot add target to the new loader\" ) ; \ncurrentLoads . put ( key , loader ) ; \nif ( debug ) Log . d ( TAG , \"Current loaders count: \" + currentLoads . size ( ) ) ; \nfinal Executor executor = getImageTaskExecutor ( ) ; \nexecutor . execute ( loader . future ) ; \n} \nelse if ( debug ) Log . d ( TAG , \"Joined to the existing task \" + key ) ; \n} \n} \n"}
{"8871": "public class ImagesManager { \nprotected void memCacheImage ( final String url , final Bitmap bitmap ) { \nif ( debug ) Log . d ( TAG , \"Memcache for \" + url ) ; \nmemCache . putElement ( url , bitmap ) ; \n} \n} \n"}
{"8872": "public class BuffersPool { \npublic void release ( final byte [ ] buffer ) { \nif ( buffer == null ) return ; \nfinal int capacity = buffer . length ; \nif ( capacity == 0 ) return ; \nsynchronized ( lock ) { \nList < Object > bList = buffers . get ( capacity ) ; \nif ( bList == null ) { \nbList = new LinkedList < Object > ( ) ; \nbuffers . put ( capacity , bList ) ; \n} \nbList . add ( buffer ) ; \nusedBuffersCount -- ; \n} \n} \n} \n"}
{"8873": "public class RequestDescription { \nprotected void onURLConnectionPrepared ( final Context context , final URLConnection urlConnection ) { \nif ( contentType != null ) urlConnection . addRequestProperty ( \"Content-Type\" , contentType ) ; \nif ( contentLanguage != null ) urlConnection . addRequestProperty ( \"Accept-Language\" , contentLanguage ) ; \nurlConnection . addRequestProperty ( \"Accept-Encoding\" , IoUtils . ENCODING_GZIP ) ; \nurlConnection . addRequestProperty ( \"User-Agent\" , buildUserAgent ( context ) ) ; \nif ( headers != null ) for ( String name : headers . keySet ( ) ) { \nurlConnection . addRequestProperty ( name , headers . getString ( name ) ) ; \n} \n} \n} \n"}
{"8875": "public class CacheControlUrlConnection { \nprivate void connectWithWorkaround ( ) throws IOException { \nif ( Build . VERSION . SDK_INT > Build . VERSION_CODES . GINGERBREAD_MR1 ) { \nsuper . connect ( ) ; \nreturn ; \n} \nURLConnection coreConnection = UrlConnectionWrapper . unwrap ( getCore ( ) ) ; \nif ( coreConnection instanceof HttpsURLConnection ) try { \nsuper . connect ( ) ; \n} \ncatch ( NullPointerException e ) { \n} \nelse super . connect ( ) ; \n} \n} \n"}
{"8879": "public class JCublas2 { \nprivate static int checkResult ( int result ) { \nif ( exceptionsEnabled && result != cublasStatus . CUBLAS_STATUS_SUCCESS ) throw new CudaException ( cublasStatus . stringFor ( result ) ) ; \nreturn result ; \n} \n} \n"}
{"8880": "public class JCublas { \nprivate static void checkResultBLAS ( ) { \nif ( exceptionsEnabled ) { \nlastResult = cublasGetErrorNative ( ) ; \nif ( lastResult != cublasStatus . CUBLAS_STATUS_SUCCESS ) throw new CudaException ( cublasStatus . stringFor ( lastResult ) ) ; \n} \n} \n} \n"}
{"8889": "public class MetricDataRequest { \npublic List < MetricData > get ( ) throws RequestException , UnauthorizedException { \nHttpResponse < String > response ; \ntry { \nresponse = Unirest . get ( this . appdURL + \"/controller/rest/applications/\" + appName + \"/metric-data\" ) . header ( \"accept\" , \"application/json\" ) . basicAuth ( this . appdUsername , this . appdPassword ) . queryString ( getQueryString ( ) ) . queryString ( \"output\" , \"json\" ) . asString ( ) ; \n} \ncatch ( UnirestException e ) { \nthrow new RequestException ( \"Something was wrong with sending request.\" , e ) ; \n} \nif ( response == null ) throw new RequestException ( \"Response is empty.\" ) ; \nswitch ( response . getStatus ( ) ) { \ncase 200 : { \nreturn process ( new JsonNode ( response . getBody ( ) ) ) ; \n} \ncase 401 : { \nthrow new UnauthorizedException ( \"Authentication failed\" ) ; \n} \ndefault : { \nthrow new RequestException ( \"Unhandled response code \" + response . getStatus ( ) ) ; \n} \n} \n} \n} \n"}
{"8890": "public class MetricDataRequest { \nprotected Map < String , Object > getQueryString ( ) { \nMap < String , Object > qs = new HashMap < > ( ) ; \nif ( timeParams != null ) { \nqs . put ( \"time-range-type\" , timeParams . type ) ; \nif ( timeParams . duration > 0 ) qs . put ( \"duration-in-mins\" , timeParams . duration ) ; \nif ( timeParams . startTime > 0 ) qs . put ( \"start-time\" , timeParams . startTime ) ; \nif ( timeParams . endTime > 0 ) qs . put ( \"end-time\" , timeParams . endTime ) ; \n} \nqs . put ( \"rollup\" , false ) ; \nif ( metricPath != null ) qs . put ( \"metric-path\" , metricPath ) ; \nreturn qs ; \n} \n} \n"}
{"8893": "public class Config { \npublic static ConnectionConfig getConnectionConfig ( ) { \nboolean isValid = true ; \nString appdUsername = getPropertyOrEnv ( \"com.signalfx.appd.username\" , \"APPD_USERNAME\" ) ; \nif ( StringUtils . isEmpty ( appdUsername ) ) { \nlog . error ( \"AppDynamics username not specified.\" ) ; \nisValid = false ; \n} \nString appdPassword = getPropertyOrEnv ( \"com.signalfx.appd.password\" , \"APPD_PASSWORD\" ) ; \nif ( StringUtils . isEmpty ( appdPassword ) ) { \nlog . error ( \"AppDynamics password not specified.\" ) ; \nisValid = false ; \n} \nString appdURL = getPropertyOrEnv ( \"com.signalfx.appd.host\" , \"APPD_HOST\" ) ; \nif ( StringUtils . isEmpty ( appdURL ) ) { \nlog . error ( \"AppDynamics host not specified.\" ) ; \nisValid = false ; \n} \nString fxToken = getPropertyOrEnv ( \"com.signalfx.api.token\" , \"SIGNALFX_TOKEN\" ) ; \nif ( StringUtils . isEmpty ( fxToken ) ) { \nlog . error ( \"SignalFx token not specified.\" ) ; \nisValid = false ; \n} \nif ( isValid ) return new ConnectionConfig ( appdUsername , appdPassword , appdURL , fxToken ) ; \nelse return null ; \n} \n} \n"}
{"8894": "public class ReportAppD { \npublic void perform ( List < AppInfo > apps , MetricDataRequest . TimeParams timeParams ) { \nList < SignalFxProtocolBuffers . DataPoint > dataPoints = new LinkedList < > ( ) ; \nfor ( AppInfo app : apps ) { \ndataRequest . setAppName ( app . name ) ; \nfor ( MetricInfo metricInfo : app . metrics ) { \ndataRequest . setTimeParams ( timeParams ) ; \ndataRequest . setMetricPath ( metricInfo . metricPathQuery ) ; \nList < MetricData > metricDataList ; \ntry { \nmetricDataList = dataRequest . get ( ) ; \n} \ncatch ( RequestException e ) { \nlog . error ( \"Metric query failure for \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \ncounterAppDRequestFailure . inc ( ) ; \ncontinue ; \n} \ncatch ( UnauthorizedException e ) { \nlog . error ( \"AppDynamics authentication failed\" ) ; \nreturn ; \n} \nif ( metricDataList != null && metricDataList . size ( ) > 0 ) for ( MetricData metricData : metricDataList ) { \nMetricTimeSeries mts = metricInfo . getMetricTimeSeries ( metricData . metricPath ) ; \nList < SignalFxProtocolBuffers . DataPoint > mtsDataPoints = processor . process ( mts , metricData . metricValues ) ; \ndataPoints . addAll ( mtsDataPoints ) ; \nif ( ! mtsDataPoints . isEmpty ( ) ) counterMtsReported . inc ( ) ; \nelse counterMtsEmpty . inc ( ) ; \n} \nelse log . warn ( \"No metric found for query \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \n} \n} \nif ( ! dataPoints . isEmpty ( ) ) try { \nreporter . report ( dataPoints ) ; \ncounterDataPointsReported . inc ( dataPoints . size ( ) ) ; \n} \ncatch ( Reporter . ReportException e ) { \nlog . error ( \"There were errors reporting metric\" ) ; \n} \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) return ; \nelse try { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) timeSentMap . put ( instanceName , actualTimeSent ) ; \n} \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \n} \n} \ncatch ( JSONException je ) { \n} \n} \n} \n"}
{"8924": "public class LogPersister { \nstatic public void setContext ( final Context context ) { \nif ( null == LogPersister . context ) { \nLogManager . getLogManager ( ) . getLogger ( \"\" ) . addHandler ( julHandler ) ; \njava . util . logging . Logger . getLogger ( \"\" ) . setLevel ( Level . ALL ) ; \nLogPersister . context = context ; \nif ( fileLoggerInstance == null || fileLoggerInstance instanceof FileLogger ) { \nFileLogger . setContext ( context ) ; \nfileLoggerInstance = FileLogger . getInstance ( ) ; \n} \nSharedPreferences prefs = LogPersister . context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nif ( null != level ) setLevelSync ( level ) ; \nelse setLevelSync ( Logger . LEVEL . fromString ( prefs . getString ( SHARED_PREF_KEY_level , getLevelDefault ( ) . toString ( ) ) ) ) ; \nif ( null != logFileMaxSize ) setMaxLogStoreSize ( logFileMaxSize ) ; \nelse setMaxLogStoreSize ( prefs . getInt ( SHARED_PREF_KEY_logFileMaxSize , DEFAULT_logFileMaxSize ) ) ; \nif ( null != capture ) setCaptureSync ( capture ) ; \nelse setCaptureSync ( prefs . getBoolean ( SHARED_PREF_KEY_logPersistence , DEFAULT_capture ) ) ; \nuncaughtExceptionHandler = new UncaughtExceptionHandler ( ) ; \nThread . setDefaultUncaughtExceptionHandler ( uncaughtExceptionHandler ) ; \n} \n} \n} \n"}
{"8927": "public class LogPersister { \nstatic public void setMaxLogStoreSize ( final int bytes ) { \nif ( bytes >= 10000 ) logFileMaxSize = bytes ; \nif ( null != context ) { \nSharedPreferences prefs = context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nprefs . edit ( ) . putInt ( SHARED_PREF_KEY_logFileMaxSize , logFileMaxSize ) . commit ( ) ; \n} \n} \n} \n"}
{"8928": "public class LogPersister { \nprotected static String prependMetadata ( String message , JSONObject metadata ) { \ntry { \nif ( null != metadata ) { \nString clazz = \"\" ; \nString method = \"\" ; \nString file = \"\" ; \nString line = \"\" ; \nif ( metadata . has ( \"$class\" ) ) { \nclazz = metadata . getString ( \"$class\" ) ; \nclazz = clazz . substring ( clazz . lastIndexOf ( '.' ) + 1 , clazz . length ( ) ) ; \n} \nif ( metadata . has ( \"$method\" ) ) method = metadata . getString ( \"$method\" ) ; \nif ( metadata . has ( \"$file\" ) ) file = metadata . getString ( \"$file\" ) ; \nif ( metadata . has ( \"$line\" ) ) line = metadata . getString ( \"$line\" ) ; \nif ( ! ( clazz + method + file + line ) . equals ( \"\" ) ) message = clazz + \".\" + method + \" in \" + file + \":\" + line + \" :: \" + message ; \n} \n} \ncatch ( Exception e ) { \n} \nreturn message ; \n} \n} \n"}
{"8929": "public class LogPersister { \nprotected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { \nJSONObject jsonMetadata ; \nif ( additionalMetadata != null ) jsonMetadata = additionalMetadata ; \nelse jsonMetadata = new JSONObject ( ) ; \ntry { \nStackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; \nint index = 0 ; \nwhile ( ! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ) index ++ ; \nwhile ( stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ) index ++ ; \njsonMetadata . put ( \"$class\" , stackTraceElements [ index ] . getClassName ( ) ) ; \njsonMetadata . put ( \"$file\" , stackTraceElements [ index ] . getFileName ( ) ) ; \njsonMetadata . put ( \"$method\" , stackTraceElements [ index ] . getMethodName ( ) ) ; \njsonMetadata . put ( \"$line\" , stackTraceElements [ index ] . getLineNumber ( ) ) ; \njsonMetadata . put ( \"$src\" , \"java\" ) ; \n} \ncatch ( Exception e ) { \nLog . e ( LOG_TAG_NAME , \"Could not generate jsonMetadata object.\" , e ) ; \n} \nreturn jsonMetadata ; \n} \n} \n"}
{"8930": "public class LogPersister { \nprivate static JSONObject createJSONObject ( final Logger . LEVEL level , final String pkg , final String message , long timestamp , final JSONObject jsonMetadata , final Throwable t ) { \nJSONObject jsonObject = new JSONObject ( ) ; \ntry { \njsonObject . put ( \"timestamp\" , timestamp ) ; \njsonObject . put ( \"level\" , level . toString ( ) ) ; \njsonObject . put ( \"pkg\" , pkg ) ; \njsonObject . put ( \"msg\" , message ) ; \njsonObject . put ( \"threadid\" , Thread . currentThread ( ) . getId ( ) ) ; \nif ( null != jsonMetadata ) jsonObject . put ( \"metadata\" , jsonMetadata ) ; \nif ( null != t ) jsonObject . put ( \"metadata\" , appendFullStackTrace ( jsonMetadata , t ) ) ; \n} \ncatch ( JSONException e ) { \nLog . e ( LOG_TAG_NAME , \"Error adding JSONObject key/value pairs\" , e ) ; \n} \nreturn jsonObject ; \n} \n} \n"}
{"8932": "public class BMSAnalytics { \nprivate static void setUserIdentity ( final String user , boolean isInitialCtx ) { \nif ( ! isInitialCtx && ! BMSAnalytics . hasUserContext ) { \nlogger . error ( \"Cannot set user identity with anonymous user collection enabled.\" ) ; \nreturn ; \n} \nJSONObject metadata = new JSONObject ( ) ; \nDEFAULT_USER_ID = user ; \nString hashedUserID = UUID . nameUUIDFromBytes ( user . getBytes ( ) ) . toString ( ) ; \ntry { \nif ( isInitialCtx ) metadata . put ( CATEGORY , INITIAL_CTX_CATEGORY ) ; \nelse metadata . put ( CATEGORY , USER_SWITCH_CATEGORY ) ; \nif ( BMSAnalytics . collectLocation ) if ( locationService . getInitLocationRequests ( ) ) { \nmetadata . put ( LONGITUDE_KEY , locationService . getLongitude ( ) ) ; \nmetadata . put ( LATITUDE_KEY , locationService . getLatitude ( ) ) ; \n} \nmetadata . put ( TIMESTAMP_KEY , ( new Date ( ) ) . getTime ( ) ) ; \nmetadata . put ( APP_SESSION_ID_KEY , MFPAnalyticsActivityLifecycleListener . getAppSessionID ( ) ) ; \nmetadata . put ( USER_ID_KEY , hashedUserID ) ; \n} \ncatch ( JSONException e ) { \nlogger . debug ( \"JSONException encountered logging change in user context: \" + e . getMessage ( ) ) ; \n} \nMFPInAppFeedBackListner . setUserIdentity ( user ) ; \nlog ( metadata ) ; \n} \n} \n"}
{"8933": "public class FileLogger { \nprivate byte [ ] getByteArrayFromFile ( final String file ) throws UnsupportedEncodingException { \nString ret = \"\" ; \nFile fl = new File ( context . getFilesDir ( ) , file ) ; \nif ( fl . exists ( ) ) try { \nFileInputStream fin = new FileInputStream ( fl ) ; \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ( int ) fl . length ( ) ) ; \ncopyStream ( fin , baos ) ; \nreturn baos . toByteArray ( ) ; \n} \ncatch ( IOException e ) { \nLog . e ( LogPersister . LOG_TAG_NAME , \"problem reading file \" + fl . toString ( ) , e ) ; \n} \nreturn ret . getBytes ( \"UTF-8\" ) ; \n} \n} \n"}
{"8934": "public class MFPAnalyticsLocationListener { \nprotected void startLocationUpdates ( ) { \nif ( ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_FINE_LOCATION ) != PackageManager . PERMISSION_GRANTED && ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_COARSE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) return ; \nLocationServices . FusedLocationApi . requestLocationUpdates ( mGoogleApiClient , mLocationRequest , this ) ; \n} \n} \n"}
{"8935": "public class ObjectSizing { \npublic void sizeRegion ( Region < ? , ? > region , int numEntries ) { \nif ( region == null ) throw new IllegalArgumentException ( \"Region is null.\" ) ; \nif ( region instanceof PartitionedRegion ) sizePartitionedRegion ( region , numEntries ) ; \nelse sizeReplicatedOrLocalRegion ( region , numEntries ) ; \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nint regionSize = primaryDataSet . size ( ) ; \nif ( numEntries == 0 ) numEntries = primaryDataSet . size ( ) ; \nelse if ( numEntries > regionSize ) numEntries = regionSize ; \nint count = 0 ; \nfor ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) break ; \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nint regionSize = entries . size ( ) ; \nif ( numEntries == 0 ) numEntries = entries . size ( ) ; \nelse if ( numEntries > regionSize ) numEntries = regionSize ; \nint count = 0 ; \nfor ( Iterator < ? > i = entries . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) break ; \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8938": "public class SnapshotRecordReader { \npublic SnapshotRecord readSnapshotRecord ( ) throws IOException , ClassNotFoundException { \nbyte [ ] key = DataSerializer . readByteArray ( dis ) ; \nif ( key == null ) return null ; \nbyte [ ] value = DataSerializer . readByteArray ( dis ) ; \nreturn new SnapshotRecord ( key , value ) ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) if ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse stream . print ( \" \" + timeStamps [ i ] ) ; \nstream . println ( \"]\" ) ; \n} \n} \n"}
{"8940": "public class TimeStampSeries { \ndouble [ ] getTimeValuesSinceIdx ( int idx ) { \nint resultSize = this . count - idx ; \ndouble [ ] result = new double [ resultSize ] ; \nfor ( int i = 0 ; \ni < resultSize ; \ni ++ ) result [ i ] = getMilliTimeStamp ( idx + i ) ; \nreturn result ; \n} \n} \n"}
{"8946": "public class GemFireJmxClient { \npublic static Collection < String > listHosts ( JMX jmx ) { \nSet < ObjectName > objectNames = jmx . searchObjectNames ( \"GemFire:type=Member,member=*\" ) ; \nif ( objectNames == null || objectNames . isEmpty ( ) ) return null ; \nHashSet < String > hostLists = new HashSet < String > ( objectNames . size ( ) ) ; \nMemberMXBean memberMXBean = null ; \nfor ( ObjectName objectName : objectNames ) { \nmemberMXBean = jmx . newBean ( MemberMXBean . class , objectName ) ; \nhostLists . add ( memberMXBean . getHost ( ) ) ; \n} \nreturn hostLists ; \n} \n} \n"}
{"8951": "public class Querier { \n@ SuppressWarnings ( \"unchecked\" ) public static < ReturnType > Collection < ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException { \nSelectResults < ReturnType > selectResults ; \nif ( rfc == null || JvmRegionFunctionContext . class . isAssignableFrom ( rfc . getClass ( ) ) ) { \nif ( params == null || params . length == 0 ) selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( ) ; \nelse selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( params ) ; \nif ( selectResults == null || selectResults . isEmpty ( ) ) return null ; \nArrayList < ReturnType > results = new ArrayList < ReturnType > ( selectResults . size ( ) ) ; \nresults . addAll ( selectResults . asList ( ) ) ; \nreturn results ; \n} \nelse { \nif ( params == null || params . length == 0 ) selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; \nelse selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; \nif ( selectResults == null || selectResults . isEmpty ( ) ) return null ; \nreturn selectResults ; \n} \n} \n} \n"}
{"8956": "public class ReadExportFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \nResultSender < Object > sender = functionContext . getResultSender ( ) ; \nCache cache = CacheFactory . getAnyInstance ( ) ; \nLogger logWriter = LogManager . getLogger ( getClass ( ) ) ; \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null || args . length != 2 ) throw new FunctionException ( \"Required array args: [region,extension]\" ) ; \nString extensionArg = args [ 0 ] ; \nif ( extensionArg == null || extensionArg . length ( ) == 0 ) throw new IllegalArgumentException ( \"File extension required\" ) ; \nExportFileType extension = ExportFileType . valueOf ( extensionArg ) ; \nString regionName = args [ 1 ] ; \nRegion < Object , Object > region = cache . getRegion ( regionName ) ; \nif ( region == null ) { \nsender . lastResult ( null ) ; \nreturn ; \n} \nFile file = new File ( new StringBuilder ( directoryPath ) . append ( \"/\" ) . append ( regionName ) . append ( \".\" ) . append ( extensionArg ) . toString ( ) ) ; \nString serverName = cache . getDistributedSystem ( ) . getDistributedMember ( ) . getName ( ) ; \nswitch ( extension ) { \ncase gfd : new GfdExportFunction ( ) . exportRegion ( region ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Unsupported extension file type:\" + extension ) ; \n} \nSerializable content = readContent ( file , extension , logWriter ) ; \nSerializable [ ] arrayResults = { \nserverName , content , file . getAbsolutePath ( ) } \n; \nsender . lastResult ( arrayResults ) ; \n} \ncatch ( Exception e ) { \nString stackTrace = Debugger . stackTrace ( e ) ; \nlogWriter . error ( stackTrace ) ; \nthrow new FunctionException ( stackTrace ) ; \n} \n} \n} \n"}
{"8957": "public class GemFireInspector { \npublic static Set < String > listHosts ( JMX jmx ) { \nSet < ObjectName > memberObjects = jmx . searchObjectNames ( \"GemFire:type=Member,member=*\" ) ; \nif ( memberObjects == null || memberObjects . isEmpty ( ) ) return null ; \nHashSet < String > hostList = new HashSet < String > ( memberObjects . size ( ) ) ; \nMemberMXBean bean = null ; \nfor ( ObjectName objectName : memberObjects ) { \nbean = jmx . newBean ( MemberMXBean . class , objectName ) ; \ntry { \nhostList . add ( bean . getHost ( ) ) ; \n} \ncatch ( UndeclaredThrowableException e ) { \n} \n} \nreturn hostList ; \n} \n} \n"}
{"8958": "public class LuceneSearchFunction { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) @ Override public void execute ( FunctionContext functionContext ) { \nCache cache = CacheFactory . getAnyInstance ( ) ; \ntry { \nif ( ! ( functionContext instanceof RegionFunctionContext ) ) throw new FunctionException ( \"Execute on a region\" ) ; \nObject args = functionContext . getArguments ( ) ; \nif ( args == null ) throw new FunctionException ( \"arguments is required\" ) ; \nTextPageCriteria criteria = null ; \nif ( args instanceof PdxInstance ) { \nPdxInstance pdxInstance = ( PdxInstance ) args ; \ntry { \ncriteria = ( TextPageCriteria ) ( pdxInstance . getObject ( ) ) ; \n} \ncatch ( PdxSerializationException e ) { \nthrow new FunctionException ( e . getMessage ( ) + \" JSON:\" + JSONFormatter . toJSON ( pdxInstance ) ) ; \n} \n} \nelse criteria = ( TextPageCriteria ) args ; \nRegion < String , Collection < Object > > pagingRegion = cache . getRegion ( criteria . getPageRegionName ( ) ) ; \nRegion < ? , ? > region = cache . getRegion ( criteria . getRegionName ( ) ) ; \nGeodePagination pagination = new GeodePagination ( ) ; \nTextPolicySearchStrategy geodeSearch = new TextPolicySearchStrategy ( cache ) ; \ngeodeSearch . saveSearchResultsWithPageKeys ( criteria , criteria . getQuery ( ) , null , ( Region < String , Collection < Object > > ) pagingRegion ) ; \nCollection < Object > collection = pagination . readResultsByPageValues ( criteria . getId ( ) , criteria . getSortField ( ) , criteria . isSortDescending ( ) , criteria . getBeginIndex ( ) , ( Region < Object , Object > ) region , ( Region ) pagingRegion ) ; \nif ( collection == null ) { \nfunctionContext . getResultSender ( ) . lastResult ( null ) ; \nreturn ; \n} \nPagingCollection < Object > pageCollection = new PagingCollection < Object > ( collection , criteria ) ; \nfunctionContext . getResultSender ( ) . lastResult ( pageCollection ) ; \n} \ncatch ( RuntimeException e ) { \nLogger logger = LogManager . getLogger ( LuceneSearchFunction . class ) ; \nlogger . error ( Debugger . stackTrace ( e ) ) ; \nthrow e ; \n} \n} \n} \n"}
{"8961": "public class GeodeClient { \n@ SuppressWarnings ( \"unchecked\" ) public < K , V > Region < K , V > getRegion ( String regionName ) { \nif ( regionName == null || regionName . length ( ) == 0 ) return null ; \nRegion < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; \nif ( region != null ) return ( Region < K , V > ) region ; \nregion = ( Region < K , V > ) this . createRegion ( regionName ) ; \nif ( cachingProxy ) region . registerInterestRegex ( \".*\" ) ; \nreturn region ; \n} \n} \n"}
{"8963": "public class RegionDiffDirector { \npublic void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) { \nif ( sourceChecksumMap == null ) { \nif ( targetMap != null && ! targetMap . isEmpty ( ) ) this . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; \nreturn ; \n} \nif ( targetMap == null ) { \nthis . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; \nreturn ; \n} \nBigInteger targetBi = null ; \nBigInteger sourceBi = null ; \nfor ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) { \ntargetBi = targetMap . get ( entrySource . getKey ( ) ) ; \nsourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; \nif ( targetBi == null ) keysMissingOnTarget . add ( entrySource . getKey ( ) ) ; \nelse if ( ! targetBi . equals ( sourceBi ) ) keysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; \n} \nSet < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; \nfor ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) { \nif ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) keysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; \n} \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nint typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \nfor ( int i = 0 ; \ni < this . resourceTypeTable . length ; \ni ++ ) if ( this . resourceTypeTable [ i ] != null ) if ( this . resourceTypeTable [ i ] . close ( ) ) this . resourceTypeTable [ i ] = null ; \nelse typeCount ++ ; \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount ++ ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nint instCount = 0 ; \nfor ( int i = 0 ; \ni < this . resourceInstTable . length ; \ni ++ ) if ( this . resourceInstTable [ i ] != null ) if ( this . resourceInstTable [ i ] . close ( ) ) this . resourceInstTable [ i ] = null ; \nelse instCount ++ ; \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount ++ ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \n} \n} \n"}
{"8968": "public class SingletonGemFireJmx { \npublic synchronized static JMX reconnect ( ) { \ntry { \nClientCache cache = null ; \ncache = ClientCacheFactory . getAnyInstance ( ) ; \nif ( cache != null && ! cache . isClosed ( ) ) cache . close ( ) ; \n} \ncatch ( Exception e ) { \nSystem . out . println ( \"Cache was closed\" ) ; \n} \nif ( jmx != null ) { \njmx . dispose ( ) ; \njmx = null ; \n} \nreturn getJmx ( ) ; \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) queryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \nelse queryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) locators . add ( member . getName ( ) ) ; \nelse shutDownMember ( member . getName ( ) ) ; \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8970": "public class GemFireMgmt { \npublic static void shutDownMember ( String name ) { \ntry { \nObjectName serverName = new ObjectName ( \"GemFire:type=Member,member=\" + name ) ; \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nMemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; \nbean . shutDownMember ( ) ; \nSystem . out . println ( \"Waiting for member:\" + name + \"  to shutdown\" ) ; \nwhile ( GemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ) Thread . sleep ( shutDownDelay ) ; \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to shutdown member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \ncatch ( Exception e ) { \nSystem . out . println ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"8976": "public class GemFireNetworking { \npublic static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { \nif ( remoteLocators == null || remoteLocators . length ( ) == 0 ) return false ; \nif ( remoteLocators . equalsIgnoreCase ( locators ) ) return true ; \nString [ ] remoteLocatorsArray = remoteLocators . split ( \",\" ) ; \nif ( locators == null || locators . length ( ) == 0 ) return false ; \nString [ ] locatorsArray = locators . split ( \",\" ) ; \nString remoteLocatorHost , locatorHost ; \nint remoteLocatorPort , locatorPort ; \nfor ( String remoteLocator : remoteLocatorsArray ) { \nif ( remoteLocator == null || remoteLocator . length ( ) == 0 ) continue ; \nfor ( String locator : locatorsArray ) { \nif ( locator == null || locator . length ( ) == 0 ) continue ; \ntry { \nremoteLocatorHost = parseLocatorHost ( remoteLocator ) ; \nlocatorHost = parseLocatorHost ( locator ) ; \nremoteLocatorPort = parseLocatorPort ( remoteLocator ) ; \nlocatorPort = parseLocatorPort ( locator ) ; \nif ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) return true ; \nelse { \n} \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new IllegalArgumentException ( \"remoteLocator:\" + remoteLocator + \" locator:\" + locator + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8978": "public class GetEntriesChecksumFunction { \nHashMap < Serializable , BigInteger > buildCheckSumMap ( Region < Serializable , Object > region ) { \nif ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) region = PartitionRegionHelper . getLocalData ( region ) ; \nSet < Serializable > keySet = region . keySet ( ) ; \nif ( keySet == null || keySet . isEmpty ( ) ) return null ; \nHashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; \nObject object = null ; \nObject tmp = null ; \nfor ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) { \nobject = entry . getValue ( ) ; \nif ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) { \ntmp = ( ( PdxInstance ) object ) . getObject ( ) ; \nif ( Serializable . class . isAssignableFrom ( tmp . getClass ( ) ) ) object = tmp ; \n} \nif ( ! ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) ) regionCheckSumMap . put ( entry . getKey ( ) , MD . checksum ( object ) ) ; \nelse regionCheckSumMap . put ( entry . getKey ( ) , BigInteger . valueOf ( object . hashCode ( ) ) ) ; \n} \nreturn regionCheckSumMap ; \n} \n} \n"}
{"8980": "public class SqliteInteger { \nboolean isTypeOf ( TypeMirror typeMirror ) { \nif ( integerKinds . contains ( typeMirror . getKind ( ) ) ) return true ; \nif ( integerObjects . contains ( typeMirror . toString ( ) ) ) return true ; \nreturn false ; \n} \n} \n"}
{"8983": "public class ShillelaghUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > T createInstance ( Class < T > clazz ) { \nif ( clazz . isInterface ( ) ) { \nif ( clazz == List . class ) return ( T ) new ArrayList ( ) ; \nelse if ( clazz == Map . class ) return ( T ) new HashMap ( ) ; \nthrow new UnsupportedOperationException ( \"Interface types can not be instantiated.\" ) ; \n} \nObjectInstantiator instantiator = OBJENESIS . getInstantiatorOf ( clazz ) ; \nreturn ( T ) instantiator . newInstance ( ) ; \n} \n} \n"}
{"8984": "public class ShillelaghProcessor { \nprivate void checkForTableId ( TableObject tableObject , Element element ) { \nId idAnnotation = element . getAnnotation ( Id . class ) ; \nif ( idAnnotation != null ) { \nif ( element . asType ( ) . getKind ( ) != TypeKind . LONG && ! ( \"java.lang.Long\" . equals ( element . asType ( ) . toString ( ) ) ) ) logger . e ( \"@Id must be on a long\" ) ; \nString columnName = Strings . isBlank ( idAnnotation . name ( ) ) ? element . getSimpleName ( ) . toString ( ) : idAnnotation . name ( ) ; \nfinal TableColumn idColumn = new TableColumn ( columnName , element . getSimpleName ( ) . toString ( ) , element . asType ( ) . toString ( ) , SqliteType . INTEGER ) ; \ntableObject . setIdColumn ( idColumn ) ; \n} \n} \n} \n"}
{"8985": "public class ShillelaghProcessor { \nprivate void checkForFields ( TableObject tableObject , Element columnElement ) { \nColumn columnAnnotation = columnElement . getAnnotation ( Column . class ) ; \nif ( columnAnnotation == null ) return ; \nfinal Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; \nfinal String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; \nTableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; \nif ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { \nString columnType = columnElement . asType ( ) . toString ( ) ; \nlogger . d ( \"Column Element Type: \" + columnType ) ; \nif ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( \"java.lang.Byte[]\" ) && ! columnType . startsWith ( \"java.util.Map\" ) && ! columnType . startsWith ( \"java.util.List\" ) ) logger . e ( String . format ( \"%s in %s is not Serializable and will not be able to be converted to a byte array\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \nelse if ( tableColumn . isOneToMany ( ) ) { \nTypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; \nif ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) logger . e ( \"One to many relationship in class %s where %s is not annotated with @Table\" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; \noneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; \nTypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; \ntableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; \n} \nelse if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { \n@ SuppressWarnings ( \"ConstantConditions\" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; \nif ( annotation == null ) logger . e ( String . format ( \"%s in %s needs to be marked as a blob or should be \" + \"annotated with @Table\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \ntableColumn . setOneToOne ( true ) ; \n} \ntableObject . addColumn ( tableColumn ) ; \n} \n} \n"}
{"8986": "public class ShillelaghProcessor { \nprivate boolean checkForSuperType ( Element element , Class type ) { \nList < ? extends TypeMirror > superTypes = typeUtils . directSupertypes ( element . asType ( ) ) ; \nfor ( TypeMirror superType : superTypes ) { \nif ( superType . toString ( ) . equals ( type . getName ( ) ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"8987": "public class TableObject { \nprivate String getSchema ( ) { \nStringBuilder sb = new StringBuilder ( ) ; \nIterator < TableColumn > iterator = columns . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nTableColumn column = iterator . next ( ) ; \nif ( column . isOneToMany ( ) ) { \nif ( ! iterator . hasNext ( ) ) { \nint length = sb . length ( ) ; \nsb . replace ( length - 2 , length , \"\" ) ; \n} \ncontinue ; \n} \nsb . append ( column ) ; \nif ( iterator . hasNext ( ) ) sb . append ( \", \" ) ; \n} \nString idCol = idColumn == null ? \"id_missing\" : idColumn . getColumnName ( ) ; \nreturn String . format ( CREATE_TABLE_DEFAULT , getTableName ( ) , idCol , sb . toString ( ) ) ; \n} \n} \n"}
{"8990": "public class Builder { \npublic final Observable < T > toObservable ( ) { \nif ( ! HAS_RX_JAVA ) throw new RuntimeException ( \"RxJava not available! Add RxJava to your build to use this feature\" ) ; \nreturn shillelagh . getObservable ( tableObject , new CursorLoader ( ) { \n@ Override public Cursor getCursor ( ) { \nreturn shillelagh . rawQuery ( query . toString ( ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"8993": "public class Strings { \nstatic String capitalize ( String string ) { \nif ( isBlank ( string ) ) return \"\" ; \nchar first = string . charAt ( 0 ) ; \nif ( Character . isUpperCase ( first ) ) return string ; \nelse return Character . toUpperCase ( first ) + string . substring ( 1 ) ; \n} \n} \n"}
{"8994": "public class SqliteReal { \nboolean isTypeOf ( TypeMirror typeMirror ) { \nif ( realKinds . contains ( typeMirror . getKind ( ) ) ) return true ; \nif ( realObjects . contains ( typeMirror . toString ( ) ) ) return true ; \nreturn false ; \n} \n} \n"}
{"8996": "public class OneWireTemperatureSensor { \npublic float readTemperature ( ) throws IOException { \nbyte [ ] encoded = Files . readAllBytes ( new File ( deviceFile , \"w1_slave\" ) . toPath ( ) ) ; \nString tmp = new String ( encoded ) ; \nint tmpIndex = tmp . indexOf ( \"t=\" ) ; \nif ( tmpIndex < 0 ) throw new IOException ( \"Could not read temperature!\" ) ; \nreturn Integer . parseInt ( tmp . substring ( tmpIndex + 2 ) . trim ( ) ) / 1000f ; \n} \n} \n"}
{"9005": "public class ColumnVector { \nprotected void set ( final float values [ ] ) { \nthis . m_nRows = values . length ; \nthis . m_nCols = 1 ; \nthis . m_aValues = new float [ m_nRows ] [ 1 ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) this . m_aValues [ r ] [ 0 ] = values [ r ] ; \n} \n} \n"}
{"9006": "public class BigFunctions { \npublic static BigDecimal intPower ( @ Nonnull final BigDecimal px , final long pexponent , final int scale ) { \nBigDecimal x = px ; \nlong exponent = pexponent ; \nif ( exponent < 0 ) return BigDecimal . ONE . divide ( intPower ( x , - exponent , scale ) , scale , RoundingMode . HALF_EVEN ) ; \nBigDecimal power = BigDecimal . ONE ; \nwhile ( exponent > 0 ) { \nif ( ( exponent & 1 ) == 1 ) power = power . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \nx = x . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \nexponent >>= 1 ; \nThread . yield ( ) ; \n} \nreturn power ; \n} \n} \n"}
{"9007": "public class BigFunctions { \npublic static BigDecimal intRoot ( @ Nonnull final BigDecimal px , final long index , final int scale ) { \nBigDecimal x = px ; \nif ( x . signum ( ) < 0 ) throw new IllegalArgumentException ( \"x < 0: \" + x ) ; \nfinal int sp1 = scale + 1 ; \nfinal BigDecimal n = x ; \nfinal BigDecimal i = BigDecimal . valueOf ( index ) ; \nfinal BigDecimal im1 = BigDecimal . valueOf ( index - 1 ) ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \nBigDecimal xPrev ; \nx = x . divide ( i , scale , RoundingMode . HALF_EVEN ) ; \ndo { \nfinal BigDecimal xToIm1 = intPower ( x , index - 1 , sp1 ) ; \nfinal BigDecimal xToI = x . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nfinal BigDecimal numerator = n . add ( im1 . multiply ( xToI ) ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nfinal BigDecimal denominator = i . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nxPrev = x ; \nx = numerator . divide ( denominator , sp1 , RoundingMode . DOWN ) ; \nThread . yield ( ) ; \n} \nwhile ( x . subtract ( xPrev ) . abs ( ) . compareTo ( tolerance ) > 0 ) ; \nreturn x ; \n} \n} \n"}
{"9009": "public class BigFunctions { \npublic static BigDecimal ln ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( x . signum ( ) <= 0 ) throw new IllegalArgumentException ( \"x <= 0: \" + x ) ; \nfinal int magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; \nif ( magnitude < 3 ) return _lnNewton ( x , scale ) ; \nfinal BigDecimal root = intRoot ( x , magnitude , scale ) ; \nfinal BigDecimal lnRoot = _lnNewton ( root , scale ) ; \nreturn BigDecimal . valueOf ( magnitude ) . multiply ( lnRoot ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \n} \n"}
{"9011": "public class BigFunctions { \npublic static BigDecimal arctan ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( x . abs ( ) . compareTo ( BigDecimal . ONE ) >= 0 ) throw new IllegalArgumentException ( \"|x| >= 1: \" + x ) ; \nif ( x . signum ( ) == - 1 ) return arctan ( x . negate ( ) , scale ) . negate ( ) ; \nreturn _arctanTaylor ( x , scale ) ; \n} \n} \n"}
{"9013": "public class BigFunctions { \npublic static BigDecimal sqrt ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( x . signum ( ) < 0 ) throw new IllegalArgumentException ( \"x < 0: \" + x ) ; \nfinal BigInteger n = x . movePointRight ( scale << 1 ) . toBigInteger ( ) ; \nfinal int bits = ( n . bitLength ( ) + 1 ) >> 1 ; \nBigInteger ix = n . shiftRight ( bits ) ; \nBigInteger ixPrev ; \ndo { \nixPrev = ix ; \nix = ix . add ( n . divide ( ix ) ) . shiftRight ( 1 ) ; \nThread . yield ( ) ; \n} \nwhile ( ix . compareTo ( ixPrev ) != 0 ) ; \nreturn new BigDecimal ( ix , scale ) ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( ++ group == 10 ) { \nSystem . out . println ( ) ; \nif ( ++ line == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) System . out . println ( piString . substring ( index ) ) ; \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) maxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nj < length ; \n++ j ) System . out . print ( \"*\" ) ; \nSystem . out . println ( ) ; \n} \n} \n} \n"}
{"9024": "public class Matrix { \npublic RowVector getRow ( final int r ) throws MatrixException { \nif ( ( r < 0 ) || ( r >= m_nRows ) ) throw new MatrixException ( MatrixException . INVALID_INDEX ) ; \nfinal RowVector rv = new RowVector ( m_nCols ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) rv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; \nreturn rv ; \n} \n} \n"}
{"9025": "public class Matrix { \npublic ColumnVector getColumn ( final int c ) throws MatrixException { \nif ( ( c < 0 ) || ( c >= m_nCols ) ) throw new MatrixException ( MatrixException . INVALID_INDEX ) ; \nfinal ColumnVector cv = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) cv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; \nreturn cv ; \n} \n} \n"}
{"9026": "public class Matrix { \nprotected void set ( final float values [ ] [ ] ) { \nm_nRows = values . length ; \nm_nCols = values [ 0 ] . length ; \nm_aValues = values ; \nfor ( int r = 1 ; \nr < m_nRows ; \n++ r ) m_nCols = Math . min ( m_nCols , values [ r ] . length ) ; \n} \n} \n"}
{"9027": "public class Matrix { \npublic Matrix transpose ( ) { \nfinal float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) for ( int c = 0 ; \nc < m_nCols ; \n++ c ) tv [ c ] [ r ] = m_aValues [ r ] [ c ] ; \nreturn new Matrix ( tv ) ; \n} \n} \n"}
{"9028": "public class Matrix { \npublic Matrix add ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \nfinal float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) for ( int c = 0 ; \nc < m_nCols ; \n++ c ) sv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; \nreturn new Matrix ( sv ) ; \n} \n} \n"}
{"9029": "public class Matrix { \npublic Matrix subtract ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \nfinal float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) for ( int c = 0 ; \nc < m_nCols ; \n++ c ) dv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; \nreturn new Matrix ( dv ) ; \n} \n} \n"}
{"9030": "public class Matrix { \npublic Matrix multiply ( final float k ) { \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) for ( int c = 0 ; \nc < m_nCols ; \n++ c ) pv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9031": "public class Matrix { \npublic Matrix multiply ( final Matrix m ) throws MatrixException { \nif ( m_nCols != m . m_nRows ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) for ( int c = 0 ; \nc < m . m_nCols ; \n++ c ) { \nfloat dot = 0 ; \nfor ( int k = 0 ; \nk < m_nCols ; \n++ k ) dot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; \npv [ r ] [ c ] = dot ; \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) ar . print ( m_aValues [ r ] [ c ] , width ) ; \nar . println ( ) ; \n} \n} \n} \n"}
{"9034": "public class RegressionLine { \nprivate void _validateCoefficients ( ) { \nif ( m_bCoefsValid ) return ; \nif ( m_nDataPoints >= 2 ) { \nfinal float xBar = ( float ) m_dSumX / m_nDataPoints ; \nfinal float yBar = ( float ) m_dSumY / m_nDataPoints ; \nm_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; \nm_fA0 = yBar - m_fA1 * xBar ; \n} \nelse m_fA0 = m_fA1 = Float . NaN ; \nm_bCoefsValid = true ; \n} \n} \n"}
{"9037": "public class InMemorySldServiceImpl { \npublic RawSld toXml ( StyledLayerDescriptorInfo sldi ) throws SldException { \ntry { \nif ( sldi . getVersion ( ) == null ) sldi . setVersion ( \"1.0.0\" ) ; \nreturn parseSldI ( sldi ) ; \n} \ncatch ( JiBXException e ) { \nthrow new SldException ( \"Validation error\" , e ) ; \n} \n} \n} \n"}
{"9046": "public class InvertibleMatrix { \npublic float norm ( ) { \nfloat sum = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) for ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nfinal float v = m_aValues [ r ] [ c ] ; \nsum += v * v ; \n} \nreturn ( float ) Math . sqrt ( sum ) ; \n} \n} \n"}
{"9047": "public class LinearSystem { \npublic ColumnVector solve ( final ColumnVector b , final boolean improve ) throws MatrixException { \nif ( b . m_nRows != m_nRows ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \ndecompose ( ) ; \nfinal ColumnVector y = _forwardSubstitution ( b ) ; \nfinal ColumnVector x = _backSubstitution ( y ) ; \nif ( improve ) _improve ( b , x ) ; \nreturn x ; \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) ar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \nar . println ( ) ; \n} \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \nfor ( int rPivot = 0 ; \nrPivot < m_nRows - 1 ; \n++ rPivot ) { \nfloat largestScaledElmt = 0 ; \nint rLargest = 0 ; \nfor ( int r = rPivot ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( largestScaledElmt < scaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n} \nif ( largestScaledElmt == 0 ) throw new MatrixException ( MatrixException . SINGULAR ) ; \nif ( rLargest != rPivot ) { \nfinal int temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \n++ m_nExchangeCount ; \n} \nfinal int prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \nfor ( int r = rPivot + 1 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) for ( int c = rPivot + 1 ; \nc < m_nCols ; \n++ c ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt -= multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n} \n} \n} \n} \n} \n"}
{"9050": "public class LinearSystem { \nprivate ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { \nfinal ColumnVector y = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = 0 ; \nc < r ; \n++ c ) dot += m_aLU . at ( pr , c ) * y . at ( c ) ; \ny . set ( r , b . at ( pr ) - dot ) ; \n} \nreturn y ; \n} \n} \n"}
{"9051": "public class LinearSystem { \nprivate ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { \nfinal ColumnVector x = new ColumnVector ( m_nRows ) ; \nfor ( int r = m_nRows - 1 ; \nr >= 0 ; \n-- r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = r + 1 ; \nc < m_nRows ; \n++ c ) dot += m_aLU . at ( pr , c ) * x . at ( c ) ; \nx . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; \n} \nreturn x ; \n} \n} \n"}
{"9053": "public class IdentityMatrix { \npublic static void convert ( final SquareMatrix sm ) { \nfor ( int r = 0 ; \nr < sm . m_nRows ; \n++ r ) for ( int c = 0 ; \nc < sm . m_nCols ; \n++ c ) sm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; \n} \n} \n"}
{"9054": "public class RandomExponential { \npublic float nextVonNeumann ( ) { \nint n ; \nint k = 0 ; \nfloat u1 ; \nfor ( ; \n; \n) { \nn = 1 ; \nu1 = GENERATOR . nextFloat ( ) ; \nfloat u = u1 ; \nfloat uPrev = Float . NaN ; \nfor ( ; \n; \n) { \nuPrev = u ; \nu = GENERATOR . nextFloat ( ) ; \nif ( u > uPrev ) { \nif ( ( n & 1 ) == 0 ) return u1 + k ; \n++ k ; \nbreak ; \n} \n++ n ; \n} \n} \n} \n} \n"}
{"9057": "public class RegulaFalsiRootFinder { \n@ Override protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException { \nif ( EqualsHelper . equals ( m_fXFalse , m_fPrevXFalse ) ) throw new AbstractRootFinder . PositionUnchangedException ( ) ; \n} \n} \n"}
{"9058": "public class ImprovedRegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fPrevFFalse = m_fFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nm_bDecreasePos = m_bDecreaseNeg = false ; \nif ( Float . isNaN ( m_fPrevFFalse ) || ( m_fPrevFFalse * m_fFalse > 0 ) ) if ( m_fFalse < 0 ) m_bDecreasePos = true ; \nelse m_bDecreaseNeg = true ; \n} \n} \n"}
{"9062": "public class ModuloArithmetic { \npublic static int raise ( final int pbase , final int pexponent , final int m ) { \nint base = pbase ; \nint exponent = pexponent ; \nint power = 1 ; \nwhile ( exponent > 0 ) { \nif ( ( exponent & 1 ) == 1 ) power = multiply ( power , base , m ) ; \nbase = multiply ( base , base , m ) ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9064": "public class SldEditor { \npublic SldManager getSldManager ( ) { \nif ( sldManager == null ) sldManager = new SldManagerImpl ( getEventBus ( ) , getSldEditorServiceFactory ( ) . createSldGwtServiceAsync ( ) ) ; \nreturn sldManager ; \n} \n} \n"}
{"9068": "public class IEEE754 { \npublic static void validateFloatBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( ( biased < 0 ) || ( biased > IEEE754Constants . FLOAT_EXPONENT_RESERVED ) ) throw new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . FLOAT_EXPONENT_RESERVED + \".\" ) ; \n} \n} \n"}
{"9069": "public class IEEE754 { \npublic static void validateFloatUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( ( unbiased < - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . FLOAT_EXPONENT_BIAS ) ) throw new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . FLOAT_EXPONENT_BIAS + \".\" ) ; \n} \n} \n"}
{"9070": "public class IEEE754 { \npublic static void validateDoubleBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( ( biased < 0 ) || ( biased > IEEE754Constants . DOUBLE_EXPONENT_RESERVED ) ) throw new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . DOUBLE_EXPONENT_RESERVED + \".\" ) ; \n} \n} \n"}
{"9071": "public class IEEE754 { \npublic static void validateDoubleUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( ( unbiased < - IEEE754Constants . DOUBLE_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . DOUBLE_EXPONENT_BIAS ) ) throw new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . DOUBLE_EXPONENT_BIAS + \".\" ) ; \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nint n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \nfor ( int factor = 2 ; \nn > 1 ; \n++ factor ) if ( isPrime [ factor ] && ( n % factor == 0 ) ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn /= factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \nfinal int factors [ ] = new int [ v . size ( ) ] ; \nfor ( int i = 0 ; \ni < v . size ( ) ; \n++ i ) factors [ i ] = v . get ( i ) . intValue ( ) ; \nreturn factors ; \n} \n} \n"}
{"9080": "public class BisectionRootFinder { \n@ Override protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException { \nif ( EqualsHelper . equals ( m_fXMid , m_fPrevXMid ) ) throw new AbstractRootFinder . PositionUnchangedException ( ) ; \n} \n} \n"}
{"9081": "public class JavaFXExtension { \npublic static void setJavaFxApplication ( final CdiApplication javaFxApplication ) { \nfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; \nPlatform . runLater ( ( ) -> { \nJAVA_FX_APPLICATION . set ( javaFxApplication ) ; \nlatch . countDown ( ) ; \n} \n) ; \nif ( ! Platform . isFxApplicationThread ( ) ) try { \nlatch . await ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"9084": "public class CdiFXMLLoaderFactory { \nstatic void initializeFXMLLoader ( final FXMLLoader fxmlLoader , final Class < ? > targetClass , final String location , final String resources , final String charset ) { \ncheckAndSetLocation ( fxmlLoader , targetClass , location ) ; \nif ( charset != null && ! charset . equals ( CHARSET_UNSPECIFIED ) ) fxmlLoader . setCharset ( Charset . forName ( charset ) ) ; \nif ( resources != null && ! resources . equals ( RESOURCES_UNSPECIFIED ) ) fxmlLoader . setResources ( ResourceBundle . getBundle ( resources ) ) ; \n} \n} \n"}
{"9087": "public class AttrbuteFilterExpressionCollectionEvaluator { \nprotected AttributeDefinition getApplicableAttributeDefinition ( final UUID attributeDefinitionUuid , final List < AttributeDefinition > attributeDefinitions ) { \nif ( LOG . isTraceEnabled ( ) ) LOG . entry ( attributeDefinitionUuid , attributeDefinitions ) ; \nAttributeDefinition attributeDefinition = null ; \nfor ( AttributeDefinition anAttributeDefinition : attributeDefinitions ) { \nif ( anAttributeDefinition . getUUID ( ) . equals ( attributeDefinitionUuid ) ) { \nattributeDefinition = anAttributeDefinition ; \nbreak ; \n} \n} \nif ( LOG . isTraceEnabled ( ) ) LOG . exit ( attributeDefinition ) ; \nreturn attributeDefinition ; \n} \n} \n"}
{"9088": "public class AttrbuteFilterExpressionCollectionEvaluator { \nprotected boolean evaluate ( final UUID attributeDefinitionUuid , final AttributeFilterExpression attributeFilter , final Map < UUID , String > eventAttributes , final List < AttributeDefinition > attributeDefinitions ) throws ParseException { \nif ( LOG . isTraceEnabled ( ) ) LOG . entry ( attributeDefinitionUuid , attributeFilter , eventAttributes , attributeDefinitions ) ; \nfinal String attributeValue = eventAttributes . get ( attributeDefinitionUuid ) ; \nif ( attributeValue == null ) { \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . trace ( \"An attributeValue was not specified for this attribute definition.\" ) ; \nLOG . exit ( false ) ; \n} \nreturn false ; \n} \nfinal AttributeDefinition attributeDefinition = getApplicableAttributeDefinition ( attributeDefinitionUuid , attributeDefinitions ) ; \nif ( attributeDefinition == null ) { \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . trace ( \"The attributeDefinition did not exist.\" ) ; \nLOG . exit ( false ) ; \n} \nreturn false ; \n} \nfinal Unit unit = attributeDefinition . getUnits ( ) ; \ntry { \nboolean result = unit . evaluate ( attributeFilter . getOperator ( ) , attributeValue , attributeFilter . getOperand ( ) ) ; \nif ( LOG . isTraceEnabled ( ) ) LOG . exit ( result ) ; \nreturn result ; \n} \ncatch ( ParseException e ) { \nif ( LOG . isTraceEnabled ( ) ) LOG . throwing ( e ) ; \nthrow e ; \n} \n} \n} \n"}
{"9089": "public class Utils { \npublic static String sanitizeTag ( String s ) { \nif ( s . length ( ) > MAX_TAG_LENGTH ) s = s . substring ( s . length ( ) - MAX_TAG_LENGTH ) ; \nreturn s ; \n} \n} \n"}
{"9092": "public class RSRServiceDiscoveryImpl { \npublic Collection < String > queryForNames ( ) throws Exception { \nSet < String > names = new HashSet < String > ( ) ; \nIterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; \nwhile ( services . hasNext ( ) ) { \nService service = services . next ( ) ; \nif ( ! service . getTags ( ) . contains ( typeTag ) ) continue ; \nString name = service . getMetadata ( ) . get ( ServiceTracker . NAME ) ; \nif ( ! names . contains ( name ) ) names . add ( name ) ; \n} \nreturn names ; \n} \n} \n"}
{"9093": "public class RSRServiceDiscoveryImpl { \npublic Collection < ServiceInstance < T > > queryForInstances ( String name ) throws Exception { \nList < ServiceInstance < T > > serviceInstances = new ArrayList < ServiceInstance < T > > ( ) ; \nIterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; \nwhile ( services . hasNext ( ) ) { \nService service = services . next ( ) ; \nif ( service . getTags ( ) . contains ( typeTag ) && service . getMetadata ( ) . get ( ServiceTracker . NAME ) . equals ( name ) ) serviceInstances . add ( convert ( service ) ) ; \n} \nreturn serviceInstances ; \n} \n} \n"}
{"9094": "public class CollaborationClient { \npublic List < Collaboration > getAllToByLoggedIn ( ) { \nCollaborationListing collaborationListing = new CollaborationListing ( ) ; \nif ( this . serviceTicket != null ) collaborationListing . setServiceTicket ( this . serviceTicket ) ; \nreturn new CollaborationListing ( this . postJson ( collaborationListing , WS . Path . Collaboration . Version1 . getAllToByLoggedIn ( ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9095": "public class ABaseFieldClient { \nprotected String getMetaDataForDecimalAs ( String metaDataPrefixParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { \nStringBuffer returnBuffer = new StringBuffer ( ) ; \nif ( metaDataPrefixParam != null && ! metaDataPrefixParam . isEmpty ( ) ) returnBuffer . append ( metaDataPrefixParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . MIN ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( minParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . MAX ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( maxParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . STEP_FACTOR ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( stepFactorParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nString prefix = ( prefixParam == null ) ? \"\" : prefixParam ; \nreturnBuffer . append ( FieldMetaData . Decimal . PREFIX ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( prefix ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturn returnBuffer . toString ( ) ; \n} \n} \n"}
{"9096": "public class UserClient { \npublic User changePasswordForLoggedInUser ( String existingPasswordParam , String newPasswordParam , String confirmNewPasswordParam ) { \nUser toChangePasswordFor = new User ( ) ; \nif ( this . serviceTicket != null ) toChangePasswordFor . setServiceTicket ( this . serviceTicket ) ; \nString existingPassword = existingPasswordParam == null ? UtilGlobal . EMPTY : existingPasswordParam ; \nString newPassword = newPasswordParam == null ? UtilGlobal . EMPTY : newPasswordParam ; \nString confirmNewPassword = confirmNewPasswordParam == null ? UtilGlobal . EMPTY : confirmNewPasswordParam ; \nJSONObject passwordClear = new JSONObject ( ) ; \npasswordClear . put ( \"existing\" , existingPassword ) ; \npasswordClear . put ( \"new\" , newPassword ) ; \npasswordClear . put ( \"confirm_new\" , confirmNewPassword ) ; \ntoChangePasswordFor . setPasswordClear ( passwordClear . toString ( ) ) ; \nreturn new User ( this . postJson ( toChangePasswordFor , WS . Path . User . Version1 . changePassword ( ) ) ) ; \n} \n} \n"}
{"9097": "public class UserClient { \npublic UserListing getAllUsers ( ) { \nUserListing userToGetInfoFor = new UserListing ( ) ; \nif ( this . serviceTicket != null ) userToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; \ntry { \nreturn new UserListing ( this . postJson ( userToGetInfoFor , WS . Path . User . Version1 . getAllUsers ( ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9098": "public class UserClient { \npublic byte [ ] getGravatarForEmail ( String emailAddressParam , int sizeParam ) { \ntry { \nJSONObject gravatarJSONObj = this . getJson ( WS . Path . User . Version1 . getGravatarByEmail ( emailAddressParam , sizeParam ) ) ; \nString base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , \"\" ) ; \nif ( base64Text == null || base64Text . isEmpty ( ) ) return null ; \nreturn UtilGlobal . decodeBase64 ( base64Text ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \ncatch ( UnsupportedEncodingException unsEncExcept ) { \nthrow new FluidClientException ( unsEncExcept . getMessage ( ) , unsEncExcept , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n"}
{"9099": "public class UserClient { \npublic byte [ ] getGravatarForUser ( User userParam , int sizeParam ) { \nif ( userParam == null ) return null ; \ntry { \nJSONObject gravatarJSONObj = this . postJson ( userParam , WS . Path . User . Version1 . getGravatarByUser ( sizeParam ) ) ; \nString base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , \"\" ) ; \nif ( base64Text == null || base64Text . isEmpty ( ) ) return null ; \nreturn UtilGlobal . decodeBase64 ( base64Text ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9101": "public class Field { \n@ XmlTransient public String getElasticSearchFieldType ( ) { \nType fieldType = this . getTypeAsEnum ( ) ; \nif ( fieldType == null ) return null ; \nswitch ( fieldType ) { \ncase ParagraphText : return ElasticSearchType . TEXT ; \ncase Text : String metaData = this . getTypeMetaData ( ) ; \nif ( metaData == null || metaData . isEmpty ( ) ) return ElasticSearchType . TEXT ; \nif ( LATITUDE_AND_LONGITUDE . equals ( metaData ) ) return ElasticSearchType . GEO_POINT ; \nreturn ElasticSearchType . TEXT ; \ncase TrueFalse : return ElasticSearchType . BOOLEAN ; \ncase DateTime : return ElasticSearchType . DATE ; \ncase Decimal : return ElasticSearchType . DOUBLE ; \ncase MultipleChoice : return ElasticSearchType . KEYWORD ; \n} \nreturn null ; \n} \n} \n"}
{"9102": "public class FlowStepClient { \npublic FlowStep createFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . putJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepCreate ( ) ) ) ; \n} \n} \n"}
{"9103": "public class FlowStepClient { \npublic FlowStep updateFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepUpdate ( ) ) ) ; \n} \n} \n"}
{"9104": "public class FlowStepClient { \npublic FlowStep getFlowStepById ( Long flowStepIdParam , String flowStepTypeParam ) { \nFlowStep flowStep = new FlowStep ( flowStepIdParam ) ; \nflowStep . setFlowStepType ( flowStepTypeParam ) ; \nif ( this . serviceTicket != null ) flowStep . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStep , WS . Path . FlowStep . Version1 . getById ( ) ) ) ; \n} \n} \n"}
{"9105": "public class FlowStepClient { \npublic FlowStep getFlowStepByStep ( FlowStep flowStepParam ) { \nif ( this . serviceTicket != null && flowStepParam != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . getByStep ( ) ) ) ; \n} \n} \n"}
{"9106": "public class FlowStepClient { \npublic FlowStepListing getStepsByFlow ( Flow flowParam ) { \nif ( this . serviceTicket != null && flowParam != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepListing ( this . postJson ( flowParam , WS . Path . FlowStep . Version1 . getAllStepsByFlow ( ) ) ) ; \n} \n} \n"}
{"9107": "public class FlowStepClient { \npublic FlowStep deleteFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( ) ) ) ; \n} \n} \n"}
{"9108": "public class FlowStepClient { \npublic FlowStep forceDeleteFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( true ) ) ) ; \n} \n} \n"}
{"9109": "public class ABaseESUtil { \nprotected final List < Form > populateTableFields ( boolean addAllTableRecordsForReturnParam , boolean includeFieldDataParam , List < Field > formFieldsParam ) { \nif ( formFieldsParam == null || formFieldsParam . isEmpty ( ) ) return null ; \nList < Form > allTableRecordsFromAllFields = addAllTableRecordsForReturnParam ? new ArrayList ( ) : null ; \nfor ( Field descendantField : formFieldsParam ) { \nif ( ! ( descendantField . getFieldValue ( ) instanceof TableField ) ) continue ; \nTableField tableField = ( TableField ) descendantField . getFieldValue ( ) ; \nList < Form > tableRecordWithIdOnly = tableField . getTableRecords ( ) ; \nif ( tableRecordWithIdOnly == null || tableRecordWithIdOnly . isEmpty ( ) ) continue ; \nList < Long > formIdsOnly = new ArrayList ( ) ; \nfor ( Form tableRecord : tableRecordWithIdOnly ) { \nformIdsOnly . add ( tableRecord . getId ( ) ) ; \n} \nList < Form > populatedTableRecords = this . getFormsByIds ( Index . TABLE_RECORD , formIdsOnly , includeFieldDataParam , DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS ) ; \nif ( addAllTableRecordsForReturnParam && populatedTableRecords != null ) allTableRecordsFromAllFields . addAll ( populatedTableRecords ) ; \ntableField . setTableRecords ( populatedTableRecords ) ; \ndescendantField . setFieldValue ( tableField ) ; \n} \nreturn allTableRecordsFromAllFields ; \n} \n} \n"}
{"9111": "public class AGenericListMessageHandler { \n@ Override public void handleMessage ( Object objectToProcess ) { \nif ( objectToProcess instanceof Error ) { \nError fluidError = ( ( Error ) objectToProcess ) ; \nthis . errors . add ( fluidError ) ; \nif ( this . messageReceivedCallback != null ) this . messageReceivedCallback . errorMessageReceived ( fluidError ) ; \nif ( this . completableFuture != null ) this . completableFuture . completeExceptionally ( new FluidClientException ( fluidError . getErrorMessage ( ) , fluidError . getErrorCode ( ) ) ) ; \n} \nelse { \nJSONObject jsonObject = ( JSONObject ) objectToProcess ; \nif ( this . compressedResponse ) { \nCompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; \nbyte [ ] compressedJsonList = UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; \nbyte [ ] uncompressedJson = null ; \ntry { \nuncompressedJson = this . uncompress ( compressedJsonList ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidClientException ( \"I/O issue with uncompress. \" + eParam . getMessage ( ) , eParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \njsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; \n} \nT messageForm = this . getNewInstanceBy ( jsonObject ) ; \nthis . returnValue . add ( messageForm ) ; \nif ( this . completableFuture != null ) { \nString echo = messageForm . getEcho ( ) ; \nif ( echo != null && ! echo . trim ( ) . isEmpty ( ) ) this . expectedEchoMessagesBeforeComplete . remove ( echo ) ; \nif ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) this . completableFuture . complete ( this . returnValue ) ; \n} \nif ( this . messageReceivedCallback != null ) this . messageReceivedCallback . messageReceived ( messageForm ) ; \n} \n} \n} \n"}
{"9112": "public class AGenericListMessageHandler { \n@ Override public void connectionClosed ( ) { \nthis . isConnectionClosed = true ; \nif ( this . completableFuture != null ) if ( this . getErrors ( ) . isEmpty ( ) ) this . completableFuture . complete ( this . returnValue ) ; \nelse { \nError firstFluidError = this . getErrors ( ) . get ( 0 ) ; \nthis . completableFuture . completeExceptionally ( new FluidClientException ( firstFluidError . getErrorMessage ( ) , firstFluidError . getErrorCode ( ) ) ) ; \n} \n} \n} \n"}
{"9113": "public class AGenericListMessageHandler { \nprivate List < String > getEchoMessagesFromReturnValue ( ) { \nList < String > returnListing = new ArrayList ( ) ; \nif ( this . returnValue == null ) return returnListing ; \nIterator < T > iterForReturnVal = this . returnValue . iterator ( ) ; \nwhile ( iterForReturnVal . hasNext ( ) ) { \nT returnVal = iterForReturnVal . next ( ) ; \nif ( returnVal . getEcho ( ) == null ) continue ; \nreturnListing . add ( returnVal . getEcho ( ) ) ; \n} \nreturn returnListing ; \n} \n} \n"}
{"9114": "public class PersonalInventoryClient { \npublic List < FluidItem > getPersonalInventoryItems ( ) { \nUser loggedInUser = new User ( ) ; \nif ( this . serviceTicket != null ) loggedInUser . setServiceTicket ( this . serviceTicket ) ; \ntry { \nreturn new FluidItemListing ( this . postJson ( loggedInUser , WS . Path . PersonalInventory . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9115": "public class FormContainerClient { \npublic TableRecord createTableRecord ( TableRecord tableRecordParam ) { \nif ( tableRecordParam != null && this . serviceTicket != null ) tableRecordParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new TableRecord ( this . putJson ( tableRecordParam , WS . Path . FormContainerTableRecord . Version1 . formContainerTableRecordCreate ( ) ) ) ; \n} \n} \n"}
{"9116": "public class FormContainerClient { \npublic Form deleteFormContainer ( Form formContainerParam ) { \nif ( formContainerParam != null && this . serviceTicket != null ) formContainerParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Form ( this . postJson ( formContainerParam , WS . Path . FormContainer . Version1 . formContainerDelete ( ) ) ) ; \n} \n} \n"}
{"9117": "public class FormContainerClient { \npublic List < FormFlowHistoricData > getFormFlowHistoricData ( Form formParam ) { \nif ( formParam != null && this . serviceTicket != null ) formParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FormFlowHistoricDataListing ( this . postJson ( formParam , WS . Path . FlowItemHistory . Version1 . getByFormContainer ( ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9118": "public class FormContainerClient { \npublic List < FormHistoricData > getFormAndFieldHistoricData ( Form formParam , boolean includeCurrentParam ) { \nif ( formParam != null && this . serviceTicket != null ) formParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FormHistoricDataListing ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByFormContainer ( includeCurrentParam ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9119": "public class FormContainerClient { \npublic FormHistoricData getMostRecentFormAndFieldHistoricData ( Form formParam ) { \nif ( formParam != null && this . serviceTicket != null ) formParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FormHistoricData ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByMostRecentByFormContainer ( ) ) ) ; \n} \n} \n"}
{"9122": "public class FormContainerClient { \npublic Form unLockFormContainer ( Form formParam , User userToUnLockAsParam , boolean unlockAsyncParam , boolean removeFromPersonalInventoryParam ) { \nif ( this . serviceTicket != null && formParam != null ) formParam . setServiceTicket ( this . serviceTicket ) ; \nLong unLockAsUserId = ( userToUnLockAsParam == null ) ? null : userToUnLockAsParam . getId ( ) ; \ntry { \nreturn new Form ( this . postJson ( formParam , WS . Path . FormContainer . Version1 . unLockFormContainer ( unLockAsUserId , unlockAsyncParam , removeFromPersonalInventoryParam ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9123": "public class SQLFormUtil { \nprivate Form mapFormContainerTo ( Map < Long , String > definitionAndTitleParam , ResultSet resultSetParam ) throws SQLException { \nLong formId = resultSetParam . getLong ( SQLColumnIndex . _01_FORM_ID ) ; \nString formType = definitionAndTitleParam . get ( resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) ) ; \nString title = resultSetParam . getString ( SQLColumnIndex . _03_TITLE ) ; \nDate created = resultSetParam . getDate ( SQLColumnIndex . _04_CREATED ) ; \nDate lastUpdated = resultSetParam . getDate ( SQLColumnIndex . _05_LAST_UPDATED ) ; \nLong currentUserId = resultSetParam . getLong ( SQLColumnIndex . _06_CURRENT_USER_ID ) ; \nif ( formType == null ) throw new SQLException ( \"No mapping found for Form Type '\" + resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) + \"'.\" ) ; \nForm toAdd = new Form ( formType ) ; \ntoAdd . setId ( formId ) ; \ntoAdd . setTitle ( title ) ; \nif ( created != null ) toAdd . setDateCreated ( new Date ( created . getTime ( ) ) ) ; \nif ( lastUpdated != null ) toAdd . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; \nif ( currentUserId != null && currentUserId . longValue ( ) > 0 ) { \nUser currentUser = new User ( ) ; \ncurrentUser . setId ( currentUserId ) ; \ntoAdd . setCurrentUser ( currentUser ) ; \n} \nreturn toAdd ; \n} \n} \n"}
{"9124": "public class Role { \n@ XmlTransient public static List < Role > convertToObjects ( String roleListingParam ) { \nif ( roleListingParam == null || roleListingParam . trim ( ) . isEmpty ( ) ) return null ; \nString [ ] listOfRoles = roleListingParam . split ( UtilGlobal . REG_EX_COMMA ) ; \nList < Role > returnVal = new ArrayList < > ( ) ; \nfor ( String roleName : listOfRoles ) { \nRole roleToAdd = new Role ( ) ; \nroleToAdd . setName ( roleName . trim ( ) ) ; \nreturnVal . add ( roleToAdd ) ; \n} \nreturn returnVal ; \n} \n} \n"}
{"9125": "public class FormDefinitionClient { \npublic Form createFormDefinition ( Form formDefinitionParam ) { \nif ( formDefinitionParam != null && this . serviceTicket != null ) formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Form ( this . putJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionCreate ( ) ) ) ; \n} \n} \n"}
{"9126": "public class FormDefinitionClient { \npublic Form updateFormDefinition ( Form formDefinitionParam ) { \nif ( formDefinitionParam != null && this . serviceTicket != null ) formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Form ( this . postJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionUpdate ( ) ) ) ; \n} \n} \n"}
{"9127": "public class FormDefinitionClient { \npublic Form getFormDefinitionById ( Long formDefinitionIdParam ) { \nForm form = new Form ( formDefinitionIdParam ) ; \nif ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; \nreturn new Form ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getById ( ) ) ) ; \n} \n} \n"}
{"9128": "public class FormDefinitionClient { \npublic Form getFormDefinitionByName ( String formDefinitionNameParam ) { \nForm form = new Form ( formDefinitionNameParam ) ; \nif ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; \nreturn new Form ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getByName ( ) ) ) ; \n} \n} \n"}
{"9129": "public class FormDefinitionClient { \npublic List < Form > getAllByLoggedInUser ( boolean includeTableRecordTypesParam ) { \nForm form = new Form ( ) ; \nif ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; \nif ( includeTableRecordTypesParam ) return new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUserIncludeTableTypes ( ) ) ) . getListing ( ) ; \nelse return new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9130": "public class FormDefinitionClient { \npublic Form deleteFormDefinition ( Form formDefinitionParam ) { \nif ( formDefinitionParam != null && this . serviceTicket != null ) formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Form ( this . postJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionDelete ( ) ) ) ; \n} \n} \n"}
{"9131": "public class CacheUtil { \nprivate String getStorageKeyFrom ( Long formDefIdParam , Long formContIdParam , Long formFieldIdParam ) { \nStringBuilder stringBuff = new StringBuilder ( ) ; \nif ( formDefIdParam == null ) stringBuff . append ( NULL ) ; \nelse stringBuff . append ( formDefIdParam . toString ( ) ) ; \nstringBuff . append ( DASH ) ; \nif ( formContIdParam == null ) stringBuff . append ( NULL ) ; \nelse stringBuff . append ( formContIdParam . toString ( ) ) ; \nstringBuff . append ( DASH ) ; \nif ( formFieldIdParam == null ) stringBuff . append ( NULL ) ; \nelse stringBuff . append ( formFieldIdParam . toString ( ) ) ; \nreturn stringBuff . toString ( ) ; \n} \n} \n"}
{"9132": "public class CacheUtil { \nprivate MemcachedClient initXMemcachedClient ( ) { \nif ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) return this . memcachedClient ; \ntry { \nthis . memcachedClient = new XMemcachedClient ( this . cacheHost , this . cachePort ) ; \nreturn this . memcachedClient ; \n} \ncatch ( IOException e ) { \nthrow new FluidCacheException ( \"Unable to create MemCache client. \" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"9133": "public class CacheUtil { \npublic void shutdown ( ) { \nif ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) try { \nthis . memcachedClient . shutdown ( ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidCacheException ( \"Unable to create shutdown MemCache client. \" + eParam . getMessage ( ) , eParam ) ; \n} \n} \n} \n"}
{"9134": "public class ABaseUtil { \nprotected long toLongSafe ( String toParseParam ) { \nif ( toParseParam == null || toParseParam . trim ( ) . isEmpty ( ) ) return - 1 ; \ntry { \nreturn Long . parseLong ( toParseParam . trim ( ) ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn - 1 ; \n} \n} \n} \n"}
{"9135": "public class DocumentToPDFConvert { \npublic File convertDocumentToPDF ( File inputDocumentParam ) { \nif ( inputDocumentParam == null || ! inputDocumentParam . exists ( ) ) throw new UtilException ( \"Input document to convert not provided or does not exist.\" , UtilException . ErrorCode . COMMAND ) ; \nif ( ! inputDocumentParam . isFile ( ) ) throw new UtilException ( \"Input document '' is not a file.\" , UtilException . ErrorCode . COMMAND ) ; \nFile parentFolder = inputDocumentParam . getParentFile ( ) ; \nString inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; \nint indexOfDot = - 1 ; \nif ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) inputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; \nFile generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( \".pdf\" ) ) ; \nString completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; \ntry { \nCommandUtil . CommandResult commandResult = this . commandUtil . executeCommand ( CommandUtil . FLUID_CLI , COMMAND_CONVERT_DOC_TO_PDF , \"-i\" , inputDocumentParam . getAbsolutePath ( ) , \"-o\" , completeOutputPath ) ; \nif ( commandResult . getExitCode ( ) != 0 ) throw new UtilException ( \"Unable to convert '\" + inputDocumentParam . getName ( ) + \"' to PDF. \" + commandResult . toString ( ) , UtilException . ErrorCode . COMMAND ) ; \nFile returnVal = new File ( completeOutputPath ) ; \nif ( ! returnVal . exists ( ) ) throw new UtilException ( \"Command executed, but no output file. Expected PDF at '\" + completeOutputPath + \"'.\" , UtilException . ErrorCode . GENERAL ) ; \nreturn returnVal ; \n} \ncatch ( IOException eParam ) { \nthrow new UtilException ( \"Problem executing command. \" + eParam . getMessage ( ) , eParam , UtilException . ErrorCode . GENERAL ) ; \n} \n} \n} \n"}
{"9136": "public class SQLUtilWebSocketRESTWrapper { \nprivate List < Field > getFieldValuesForFormFromCache ( Long formIdParam , List < FormFieldListing > listingReturnFieldValsPopulatedParam , Form [ ] formsToFetchForLocalCacheArrParam ) { \nif ( formIdParam == null || formIdParam . longValue ( ) < 1 ) return null ; \nif ( listingReturnFieldValsPopulatedParam == null || listingReturnFieldValsPopulatedParam . isEmpty ( ) ) return null ; \nif ( formsToFetchForLocalCacheArrParam == null || formsToFetchForLocalCacheArrParam . length == 0 ) return null ; \nfor ( Form formIter : formsToFetchForLocalCacheArrParam ) { \nif ( formIdParam . equals ( formIter . getId ( ) ) ) { \nString echoToUse = formIter . getEcho ( ) ; \nfor ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { \nif ( echoToUse . equals ( fieldListing . getEcho ( ) ) ) return fieldListing . getListing ( ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9137": "public class FlowStepRuleClient { \npublic FlowStepRule createFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleEntryCreate ( ) ) ) ; \n} \n} \n"}
{"9138": "public class FlowStepRuleClient { \npublic FlowStepRule createFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleExitCreate ( ) ) ) ; \n} \n} \n"}
{"9139": "public class FlowStepRuleClient { \npublic FlowStepRule createFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleViewCreate ( ) ) ) ; \n} \n} \n"}
{"9140": "public class FlowStepRuleClient { \npublic FlowStepRule updateFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateEntry ( ) ) ) ; \n} \n} \n"}
{"9141": "public class FlowStepRuleClient { \npublic FlowStepRule updateFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateExit ( ) ) ) ; \n} \n} \n"}
{"9142": "public class FlowStepRuleClient { \npublic FlowStepRule updateFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateView ( ) ) ) ; \n} \n} \n"}
{"9143": "public class FlowStepRuleClient { \npublic FlowStepRule moveFlowStepEntryRuleUp ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryUp ( ) ) ) ; \n} \n} \n"}
{"9144": "public class FlowStepRuleClient { \npublic FlowStepRule moveFlowStepEntryRuleDown ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryDown ( ) ) ) ; \n} \n} \n"}
{"9145": "public class FlowStepRuleClient { \npublic FlowStepRule deleteFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteEntry ( ) ) ) ; \n} \n} \n"}
{"9146": "public class FlowStepRuleClient { \npublic FlowStep deleteFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteExit ( ) ) ) ; \n} \n} \n"}
{"9147": "public class FlowStepRuleClient { \npublic FlowStep deleteFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new FlowStep ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteView ( ) ) ) ; \n} \n} \n"}
{"9148": "public class LoginClient { \nprivate AuthEncryptedData initializeSession ( String passwordParam , AuthResponse authResponseParam ) { \nbyte [ ] ivBytes = UtilGlobal . decodeBase64 ( authResponseParam . getIvBase64 ( ) ) ; \nbyte [ ] seedBytes = UtilGlobal . decodeBase64 ( authResponseParam . getSeedBase64 ( ) ) ; \nbyte [ ] encryptedData = UtilGlobal . decodeBase64 ( authResponseParam . getEncryptedDataBase64 ( ) ) ; \nbyte [ ] hMacFromResponse = UtilGlobal . decodeBase64 ( authResponseParam . getEncryptedDataHmacBase64 ( ) ) ; \nbyte [ ] localGeneratedHMac = AES256Local . generateLocalHMAC ( encryptedData , passwordParam , authResponseParam . getSalt ( ) , seedBytes ) ; \nif ( ! Arrays . equals ( hMacFromResponse , localGeneratedHMac ) ) throw new FluidClientException ( \"Login attempt failure.\" , FluidClientException . ErrorCode . LOGIN_FAILURE ) ; \nbyte [ ] decryptedEncryptedData = AES256Local . decryptInitPacket ( encryptedData , passwordParam , authResponseParam . getSalt ( ) , ivBytes , seedBytes ) ; \ntry { \nJSONObject jsonObj = new JSONObject ( new String ( decryptedEncryptedData ) ) ; \nreturn new AuthEncryptedData ( jsonObj ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9149": "public class UserQueryClient { \npublic UserQueryListing getAllUserQueries ( ) { \nUserQuery userQueryToGetInfoFor = new UserQuery ( ) ; \nif ( this . serviceTicket != null ) userQueryToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; \ntry { \nreturn new UserQueryListing ( this . postJson ( userQueryToGetInfoFor , WS . Path . UserQuery . Version1 . getAllUserQueries ( ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9150": "public class RoleClient { \npublic RoleListing getAllRoles ( ) { \nRoleListing roleToGetInfoFor = new RoleListing ( ) ; \nif ( this . serviceTicket != null ) roleToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; \ntry { \nreturn new RoleListing ( this . postJson ( roleToGetInfoFor , WS . Path . Role . Version1 . getAllRoles ( ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9151": "public class ABaseFluidVO { \npublic String getServiceTicketAsHexUpper ( ) { \nString serviceTicket = this . getServiceTicket ( ) ; \nif ( serviceTicket == null ) return null ; \nif ( serviceTicket . isEmpty ( ) ) return serviceTicket ; \nbyte [ ] base64Bytes = Base64 . getDecoder ( ) . decode ( serviceTicket ) ; \nreturn this . bytesToHex ( base64Bytes ) ; \n} \n} \n"}
{"9152": "public class FormFieldClient { \npublic Field createFieldTextMasked ( Field formFieldParam , String maskValueParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( maskValueParam == null || maskValueParam . trim ( ) . isEmpty ( ) ) maskValueParam = \"\" ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9153": "public class FormFieldClient { \npublic Field createFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( barcodeTypeParam == null || barcodeTypeParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( \"Barcode type cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9154": "public class FormFieldClient { \npublic Field createFieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9155": "public class FormFieldClient { \npublic Field createFieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9156": "public class FormFieldClient { \npublic Field createFieldTable ( Field formFieldParam , Form formDefinitionParam , boolean sumDecimalsParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Table ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForTableField ( formDefinitionParam , sumDecimalsParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9157": "public class FormFieldClient { \npublic Field updateFieldTextMasked ( Field formFieldParam , String maskValueParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( maskValueParam == null || maskValueParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( \"Masked value cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9158": "public class FormFieldClient { \npublic Field updateFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( barcodeTypeParam == null || barcodeTypeParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( \"Barcode type cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9159": "public class FormFieldClient { \npublic Field updateFieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9160": "public class FormFieldClient { \npublic Field updateFieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9161": "public class FormFieldClient { \npublic Field updateFieldTable ( Field formFieldParam , Form formDefinitionParam , boolean sumDecimalsParam ) { \nif ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Table ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForTableField ( formDefinitionParam , sumDecimalsParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9162": "public class FormFieldClient { \npublic Field getFieldByName ( String fieldNameParam ) { \nField field = new Field ( ) ; \nfield . setFieldName ( fieldNameParam ) ; \nif ( this . serviceTicket != null ) field . setServiceTicket ( this . serviceTicket ) ; \nreturn new Field ( this . postJson ( field , WS . Path . FormField . Version1 . getByName ( ) ) ) ; \n} \n} \n"}
{"9163": "public class FormFieldClient { \npublic FormFieldListing getFieldsByFormNameAndLoggedInUser ( String formNameParam , boolean editOnlyFieldsParam ) { \nForm form = new Form ( ) ; \nform . setFormType ( formNameParam ) ; \nif ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; \nreturn new FormFieldListing ( this . postJson ( form , WS . Path . FormField . Version1 . getByFormDefinitionAndLoggedInUser ( editOnlyFieldsParam ) ) ) ; \n} \n} \n"}
{"9164": "public class FormFieldClient { \npublic FormFieldListing getFieldsByFormTypeIdAndLoggedInUser ( Long formTypeIdParam , boolean editOnlyFieldsParam ) { \nForm form = new Form ( ) ; \nform . setFormTypeId ( formTypeIdParam ) ; \nif ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; \nreturn new FormFieldListing ( this . postJson ( form , WS . Path . FormField . Version1 . getByFormDefinitionAndLoggedInUser ( editOnlyFieldsParam ) ) ) ; \n} \n} \n"}
{"9165": "public class FormFieldClient { \npublic Field deleteField ( Field fieldParam ) { \nif ( fieldParam != null && this . serviceTicket != null ) fieldParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( ) ) ) ; \n} \n} \n"}
{"9166": "public class FormFieldClient { \npublic Field forceDeleteField ( Field fieldParam ) { \nif ( fieldParam != null && this . serviceTicket != null ) fieldParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( true ) ) ) ; \n} \n} \n"}
{"9168": "public class UserFieldClient { \npublic Field updateFieldValue ( Field userFieldValueParam ) { \nif ( userFieldValueParam != null && this . serviceTicket != null ) userFieldValueParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Field ( this . postJson ( userFieldValueParam , WS . Path . UserField . Version1 . userFieldUpdateValue ( ) ) ) ; \n} \n} \n"}
{"9169": "public class ESFormFieldMappingUtil { \npublic GetIndexResponse getOrCreateIndex ( String indexParam ) { \nif ( this . doesIndexExist ( indexParam ) ) return this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; \nelse { \nCreateIndexRequestBuilder createIndexRequestBuilder = this . client . admin ( ) . indices ( ) . prepareCreate ( indexParam ) ; \nCreateIndexResponse mappingCreateResponse = createIndexRequestBuilder . execute ( ) . actionGet ( ) ; \nif ( ! mappingCreateResponse . isAcknowledged ( ) ) throw new FluidElasticSearchException ( \"Index Creation for '\" + indexParam + \"' not acknowledged by ElasticSearch.\" ) ; \nreturn this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; \n} \n} \n} \n"}
{"9170": "public class FlowClient { \npublic Flow createFlow ( Flow flowParam ) { \nif ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Flow ( this . putJson ( flowParam , WS . Path . Flow . Version1 . flowCreate ( ) ) ) ; \n} \n} \n"}
{"9171": "public class FlowClient { \npublic Flow updateFlow ( Flow flowParam ) { \nif ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowUpdate ( ) ) ) ; \n} \n} \n"}
{"9172": "public class FlowClient { \npublic Flow getFlowById ( Long flowIdParam ) { \nFlow flow = new Flow ( flowIdParam ) ; \nif ( this . serviceTicket != null ) flow . setServiceTicket ( this . serviceTicket ) ; \nreturn new Flow ( this . postJson ( flow , WS . Path . Flow . Version1 . getById ( ) ) ) ; \n} \n} \n"}
{"9173": "public class FlowClient { \npublic Flow getFlowByName ( String flowNameParam ) { \nFlow flow = new Flow ( ) ; \nflow . setName ( flowNameParam ) ; \nif ( this . serviceTicket != null ) flow . setServiceTicket ( this . serviceTicket ) ; \nreturn new Flow ( this . postJson ( flow , WS . Path . Flow . Version1 . getByName ( ) ) ) ; \n} \n} \n"}
{"9174": "public class FlowClient { \npublic Flow deleteFlow ( Flow flowParam ) { \nif ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( ) ) ) ; \n} \n} \n"}
{"9175": "public class FlowClient { \npublic Flow forceDeleteFlow ( Flow flowParam ) { \nif ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( true ) ) ) ; \n} \n} \n"}
{"9176": "public class GlobalFieldClient { \npublic Field updateFieldValue ( Field globalFieldValueParam ) { \nif ( globalFieldValueParam != null && this . serviceTicket != null ) globalFieldValueParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Field ( this . postJson ( globalFieldValueParam , Version1 . globalFieldUpdateValue ( ) ) ) ; \n} \n} \n"}
{"9177": "public class GlobalFieldClient { \npublic List < Field > getAllGlobalFieldValues ( ) { \nField field = new Field ( ) ; \nfield . setFieldValue ( new MultiChoice ( ) ) ; \nif ( this . serviceTicket != null ) field . setServiceTicket ( this . serviceTicket ) ; \nreturn new GlobalFieldListing ( this . postJson ( field , Version1 . getAllValues ( ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9178": "public class SQLFormDefinitionUtil { \npublic Map < Long , String > getFormDefinitionIdAndTitle ( ) { \nif ( ! LOCAL_MAPPING . isEmpty ( ) ) { \nMap < Long , String > returnVal = new HashMap < > ( LOCAL_MAPPING ) ; \nif ( System . currentTimeMillis ( ) > timeToUpdateAgain ) synchronized ( LOCAL_MAPPING ) { \nLOCAL_MAPPING . clear ( ) ; \n} \nreturn returnVal ; \n} \nsynchronized ( LOCAL_MAPPING ) { \nif ( ! LOCAL_MAPPING . isEmpty ( ) ) return new HashMap < > ( LOCAL_MAPPING ) ; \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nISyntax syntax = SyntaxFactory . getInstance ( ) . getSyntaxFor ( this . getSQLTypeFromConnection ( ) , ISyntax . ProcedureMapping . FormDefinition . GetFormDefinitions ) ; \npreparedStatement = this . getConnection ( ) . prepareStatement ( syntax . getPreparedStatement ( ) ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \nwhile ( resultSet . next ( ) ) { \nLong id = resultSet . getLong ( 1 ) ; \nString title = resultSet . getString ( 2 ) ; \nLOCAL_MAPPING . put ( id , title ) ; \n} \ntimeToUpdateAgain = ( System . currentTimeMillis ( ) + TimeUnit . MINUTES . toMillis ( 10 ) ) ; \n} \ncatch ( SQLException sqlError ) { \nthrow new FluidSQLException ( sqlError ) ; \n} \nfinally { \nthis . closeStatement ( preparedStatement , resultSet ) ; \n} \nreturn new HashMap < > ( LOCAL_MAPPING ) ; \n} \n} \n} \n"}
{"9182": "public class ABaseClientWebSocket { \nprotected String getExceptionMessageVerbose ( String prefixParam , String uniqueReqIdParam , int numberOfSentItemsParam ) { \nStringBuilder formFieldsCombined = new StringBuilder ( ) ; \nint returnValSize = - 1 ; \nRespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; \nif ( respHandler instanceof AGenericListMessageHandler ) { \nList < ? extends ABaseFluidJSONObject > returnValue = ( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; \nif ( returnValue != null ) { \nreturnValSize = returnValue . size ( ) ; \nreturnValue . forEach ( listingItm -> { \nif ( listingItm instanceof ABaseListing ) { \nABaseListing castedToListing = ( ABaseListing ) listingItm ; \nif ( castedToListing != null ) castedToListing . getListing ( ) . forEach ( formItm -> { \nformFieldsCombined . append ( formItm . toString ( ) ) ; \n} \n) ; \n} \nelse formFieldsCombined . append ( listingItm . toString ( ) ) ; \n} \n) ; \n} \n} \nreturn ( prefixParam + \": \" + \"Timeout while waiting for all return data. There were '\" + returnValSize + \"' items after a Timeout of \" + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + \" seconds on req-ref-nr '\" + uniqueReqIdParam + \"'. Expected a total of '\" + numberOfSentItemsParam + \"' forms. Returned-Data '\" + formFieldsCombined . toString ( ) + \"'.\" ) ; \n} \n} \n"}
{"9184": "public class Auth0Client { \npublic AccessToken getAccessToken ( String clientIdParam , String clientSecretParam , String codeParam , String redirectUrlParam ) { \nif ( clientIdParam == null || clientIdParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( \"Client Id must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( clientSecretParam == null || clientSecretParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( \"Client Secret must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( codeParam == null || codeParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( \"Code must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nAccessTokenRequest tokenRequest = new AccessTokenRequest ( ) ; \ntokenRequest . setClientId ( clientIdParam ) ; \ntokenRequest . setClientSecret ( clientSecretParam ) ; \ntokenRequest . setGrantType ( AUTHORIZATION_CODE ) ; \ntokenRequest . setCode ( codeParam ) ; \ntokenRequest . setRedirectUri ( redirectUrlParam ) ; \nreturn new AccessToken ( this . postJson ( false , tokenRequest , WS . Path . Auth0 . Version1 . userToken ( ) ) ) ; \n} \n} \n"}
{"9185": "public class Auth0Client { \npublic NormalizedUserProfile getUserProfileInfo ( AccessToken accessTokenParam ) { \nif ( accessTokenParam == null || ( accessTokenParam . getAccessToken ( ) == null || accessTokenParam . getAccessToken ( ) . trim ( ) . isEmpty ( ) ) ) throw new FluidClientException ( \"Code must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \ntry { \nString accessToken = accessTokenParam . getAccessToken ( ) ; \nList < HeaderNameValue > headerListing = new ArrayList < HeaderNameValue > ( ) ; \nheaderListing . add ( new HeaderNameValue ( NormalizedUserProfile . HeaderMapping . AUTHORIZATION , \"Bearer \" + accessToken ) ) ; \nreturn new NormalizedUserProfile ( this . getJson ( true , WS . Path . Auth0 . Version1 . userInfo ( ) , headerListing ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new FluidClientException ( \"Unable to Encode (Not Supported). \" + e . getMessage ( ) , FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; \n} \n} \n} \n"}
{"9186": "public class ABaseClientWS { \nprotected JSONObject executeJson ( HttpMethod httpMethodParam , List < HeaderNameValue > headerNameValuesParam , boolean checkConnectionValidParam , ABaseFluidJSONObject baseDomainParam , ContentType contentTypeParam , String postfixUrlParam ) { \nif ( baseDomainParam == null ) throw new FluidClientException ( \"No JSON body to post.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nString bodyJsonString = baseDomainParam . toJsonObject ( ) . toString ( ) ; \nreturn this . executeString ( httpMethodParam , headerNameValuesParam , checkConnectionValidParam , bodyJsonString , contentTypeParam , postfixUrlParam ) ; \n} \n} \n"}
{"9187": "public class ABaseClientWS { \nprotected JSONObject executeForm ( HttpMethod httpMethodParam , List < HeaderNameValue > headerNameValuesParam , boolean checkConnectionValidParam , List < FormNameValue > formNameValuesParam , ContentType contentTypeParam , String postfixUrlParam ) { \nif ( formNameValuesParam == null || formNameValuesParam . isEmpty ( ) ) throw new FluidClientException ( \"No 'Name and Value' body to post.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nStringBuilder strBuilder = new StringBuilder ( ) ; \nfor ( FormNameValue nameValue : formNameValuesParam ) { \nif ( nameValue . getName ( ) == null || nameValue . getName ( ) . trim ( ) . isEmpty ( ) ) continue ; \nif ( nameValue . getValue ( ) == null ) continue ; \nstrBuilder . append ( nameValue . getName ( ) ) ; \nstrBuilder . append ( EQUALS ) ; \nstrBuilder . append ( nameValue . getValue ( ) ) ; \nstrBuilder . append ( AMP ) ; \n} \nString bodyJsonString = strBuilder . toString ( ) ; \nbodyJsonString = bodyJsonString . substring ( 0 , bodyJsonString . length ( ) - 1 ) ; \nreturn this . executeString ( httpMethodParam , headerNameValuesParam , checkConnectionValidParam , bodyJsonString , contentTypeParam , postfixUrlParam ) ; \n} \n} \n"}
{"9188": "public class ABaseClientWS { \nprivate ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { \nResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { \npublic String handleResponse ( final HttpResponse responseParam ) throws IOException { \nint status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; \nif ( status == 404 ) throw new FluidClientException ( \"Endpoint for Service not found. URL [\" + urlCalledParam + \"].\" , FluidClientException . ErrorCode . CONNECT_ERROR ) ; \nelse if ( status >= 200 && status < 300 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse if ( status == 400 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; \nthrow new FluidClientException ( \"Unexpected response status: \" + status + \". \" + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + \". \\nResponse Text [\" + responseString + \"]\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n; \nreturn responseHandler ; \n} \n} \n"}
{"9189": "public class ABaseClientWS { \npublic boolean isConnectionValid ( ) { \ntry { \nthis . getJson ( false , WS . Path . Test . Version1 . testConnection ( ) ) ; \n} \ncatch ( FluidClientException flowJobExcept ) { \nif ( flowJobExcept . getErrorCode ( ) == FluidClientException . ErrorCode . CONNECT_ERROR ) return false ; \nthrow flowJobExcept ; \n} \nreturn true ; \n} \n} \n"}
{"9190": "public class ABaseClientWS { \nprivate CloseableHttpClient getClient ( ) { \nif ( this . closeableHttpClient != null ) return this . closeableHttpClient ; \nString pathToFluidTrustStore = this . getPathToFluidSpecificTrustStore ( ) ; \nif ( IS_IN_JUNIT_TEST_MODE || pathToFluidTrustStore != null ) { \nSSLContextBuilder builder = new SSLContextBuilder ( ) ; \ntry { \nif ( pathToFluidTrustStore == null ) builder . loadTrustMaterial ( new SSLTrustAll ( ) ) ; \nelse { \nString password = this . getFluidSpecificTrustStorePassword ( ) ; \nif ( password == null ) password = UtilGlobal . EMPTY ; \nif ( IS_IN_JUNIT_TEST_MODE ) builder . loadTrustMaterial ( new File ( pathToFluidTrustStore ) , password . toCharArray ( ) , new SSLTrustAll ( ) ) ; \nelse builder . loadTrustMaterial ( new File ( pathToFluidTrustStore ) , password . toCharArray ( ) ) ; \n} \nSSLContext sslContext = builder . build ( ) ; \nthis . closeableHttpClient = HttpClients . custom ( ) . setSSLSocketFactory ( new SSLConnectionSocketFactory ( sslContext ) ) . build ( ) ; \n} \ncatch ( NoSuchAlgorithmException e ) { \nthrow new FluidClientException ( \"NoSuchAlgorithm: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( KeyManagementException e ) { \nthrow new FluidClientException ( \"KeyManagement: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( KeyStoreException e ) { \nthrow new FluidClientException ( \"KeyStore: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( CertificateException e ) { \nthrow new FluidClientException ( \"Certificate: Unable to load self signed trust material. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \ncatch ( IOException ioError ) { \nthrow new FluidClientException ( \"IOError: Unable to load self signed trust material. \" + ioError . getMessage ( ) , ioError , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; \n} \n} \nelse this . closeableHttpClient = HttpClients . createDefault ( ) ; \nreturn this . closeableHttpClient ; \n} \n} \n"}
{"9191": "public class ABaseClientWS { \nprivate String getPathToFluidSpecificTrustStore ( ) { \nString fluidSystemTrustStore = System . getProperty ( SYSTEM_PROP_FLUID_TRUST_STORE ) ; \nif ( fluidSystemTrustStore == null || fluidSystemTrustStore . trim ( ) . isEmpty ( ) ) return null ; \nFile certFile = new File ( fluidSystemTrustStore ) ; \nif ( certFile . exists ( ) && certFile . isFile ( ) ) return fluidSystemTrustStore ; \nreturn null ; \n} \n} \n"}
{"9192": "public class ABaseSQLUtil { \npublic void closeConnection ( ) { \nif ( this . connection == null ) return ; \ntry { \nif ( this . connection . isClosed ( ) ) return ; \nthis . connection . close ( ) ; \n} \ncatch ( SQLException sqlExcept ) { \nthrow new FluidSQLException ( sqlExcept ) ; \n} \n} \n} \n"}
{"9193": "public class FlowItemClient { \npublic FluidItemListing getFluidItemsForView ( JobView jobViewParam , int queryLimitParam , int offsetParam , String sortFieldParam , String sortOrderParam ) { \nif ( this . serviceTicket != null && jobViewParam != null ) jobViewParam . setServiceTicket ( this . serviceTicket ) ; \ntry { \nreturn new FluidItemListing ( this . postJson ( jobViewParam , WS . Path . FlowItem . Version1 . getByJobView ( queryLimitParam , offsetParam , sortFieldParam , sortOrderParam ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9194": "public class FlowItemClient { \npublic FluidItem sendFormToFlow ( Form formToSendToFlowParam , String flowParam ) { \nFluidItem itemToSend = new FluidItem ( ) ; \nitemToSend . setForm ( formToSendToFlowParam ) ; \nitemToSend . setFlow ( flowParam ) ; \nif ( this . serviceTicket != null ) itemToSend . setServiceTicket ( this . serviceTicket ) ; \ntry { \nreturn new FluidItem ( this . postJson ( itemToSend , WS . Path . FlowItem . Version1 . sendFlowItemToFlow ( ) ) ) ; \n} \ncatch ( JSONException e ) { \nthrow new FluidClientException ( e . getMessage ( ) , e , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9195": "public class WebSocketClient { \n@ OnClose public void onClose ( Session userSessionParam , CloseReason reasonParam ) { \nthis . userSession = null ; \nif ( this . messageHandlers != null ) this . messageHandlers . values ( ) . forEach ( handle -> { \nhandle . connectionClosed ( ) ; \n} \n) ; \n} \n} \n"}
{"9196": "public class WebSocketClient { \n@ OnMessage public void onMessage ( String messageParam ) { \nboolean handlerFoundForMsg = false ; \nfor ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { \nObject qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; \nif ( qualifyObj instanceof Error ) handler . handleMessage ( qualifyObj ) ; \nelse if ( qualifyObj instanceof JSONObject ) { \nhandler . handleMessage ( qualifyObj ) ; \nhandlerFoundForMsg = true ; \nbreak ; \n} \n} \nif ( ! handlerFoundForMsg ) throw new FluidClientException ( \"No handler found for message;\\n\" + messageParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n"}
{"9197": "public class WebSocketClient { \npublic void sendMessage ( ABaseFluidJSONObject aBaseFluidJSONObjectParam ) { \nif ( aBaseFluidJSONObjectParam == null ) throw new FluidClientException ( \"No JSON Object to send.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \nelse this . sendMessage ( aBaseFluidJSONObjectParam . toJsonObject ( ) . toString ( ) ) ; \n} \n} \n"}
{"9198": "public class WebSocketClient { \npublic void sendMessage ( String messageToSendParam ) { \nif ( this . userSession == null ) throw new FluidClientException ( \"User Session is not set. Check if connection is open.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \nRemoteEndpoint . Async asyncRemote = null ; \nif ( ( asyncRemote = this . userSession . getAsyncRemote ( ) ) == null ) throw new FluidClientException ( \"Remote Session is not set. Check if connection is open.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \nasyncRemote . sendText ( messageToSendParam ) ; \n} \n} \n"}
{"9199": "public class WebSocketClient { \npublic void closeSession ( ) { \nif ( this . userSession == null ) return ; \ntry { \nthis . userSession . close ( ) ; \n} \ncatch ( IOException e ) { \nthrow new FluidClientException ( \"Unable to close session. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n"}
{"9200": "public class SQLUtilWebSocketExecuteNativeSQLClient { \npublic List < SQLResultSet > executeNativeSQLSynchronized ( NativeSQLQuery nativeSQLQueryParam ) { \nif ( nativeSQLQueryParam == null ) return null ; \nif ( nativeSQLQueryParam . getDatasourceName ( ) == null || nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) throw new FluidClientException ( \"No data-source name provided. Not allowed.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( ( nativeSQLQueryParam . getQuery ( ) == null || nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) && ( nativeSQLQueryParam . getStoredProcedure ( ) == null || nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) ) return null ; \nthis . setEchoIfNotSet ( nativeSQLQueryParam ) ; \nString uniqueReqId = this . initNewRequest ( ) ; \nthis . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; \ntry { \nList < SQLResultSet > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( this . getTimeoutInMillis ( ) , TimeUnit . MILLISECONDS ) ; \nif ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) throw new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + \"The connection was closed by the server prior to the response received.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \nreturn returnValue ; \n} \ncatch ( InterruptedException exceptParam ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + exceptParam . getMessage ( ) , exceptParam , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; \n} \ncatch ( ExecutionException executeProblem ) { \nThrowable cause = executeProblem . getCause ( ) ; \nif ( cause instanceof FluidClientException ) throw ( FluidClientException ) cause ; \nelse throw new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + cause . getMessage ( ) , cause , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; \n} \ncatch ( TimeoutException eParam ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: Timeout while waiting for all return data. There were '\" + this . getHandler ( uniqueReqId ) . getReturnValue ( ) . size ( ) + \"' items after a Timeout of \" + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + \" seconds.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nfinally { \nthis . removeHandler ( uniqueReqId ) ; \n} \n} \n} \n"}
{"9201": "public class FluidLicenseClient { \npublic String requestLicense ( LicenseRequest licenseRequestParam ) { \nif ( licenseRequestParam != null && this . serviceTicket != null ) licenseRequestParam . setServiceTicket ( this . serviceTicket ) ; \nreturn this . executeTxtReceiveTxt ( HttpMethod . POST , null , false , ( licenseRequestParam == null ) ? null : licenseRequestParam . toJsonObject ( ) . toString ( ) , ContentType . APPLICATION_JSON , Version1 . licenseRequest ( ) ) ; \n} \n} \n"}
{"9202": "public class FluidLicenseClient { \npublic LicenseRequest applyLicense ( String licenseToApplyParam ) { \nLicenseRequest liceReq = new LicenseRequest ( ) ; \nliceReq . setLicenseCipherText ( licenseToApplyParam ) ; \nif ( this . serviceTicket != null ) liceReq . setServiceTicket ( this . serviceTicket ) ; \nreturn new LicenseRequest ( this . postJson ( liceReq , Version1 . licenseApply ( ) ) ) ; \n} \n} \n"}
{"9203": "public class RouteFieldClient { \npublic Field createFieldTextPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9204": "public class RouteFieldClient { \npublic Field createFieldParagraphTextPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9205": "public class RouteFieldClient { \npublic Field createFieldParagraphTextHTML ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9206": "public class RouteFieldClient { \npublic Field createFieldMultiChoiceSelectMany ( Field routeFieldParam , List < String > multiChoiceValuesParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( multiChoiceValuesParam == null || multiChoiceValuesParam . isEmpty ( ) ) throw new FluidClientException ( \"No Multi-choice values provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . SELECT_MANY ) ; \nrouteFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9207": "public class RouteFieldClient { \npublic Field createFieldDateTimeDate ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9208": "public class RouteFieldClient { \npublic Field updateFieldTextPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9209": "public class RouteFieldClient { \npublic Field updateFieldParagraphTextHTML ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9210": "public class RouteFieldClient { \npublic Field updateFieldDateTimeDateAndTime ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9211": "public class RouteFieldClient { \npublic Field updateFieldDecimalPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9212": "public class RouteFieldClient { \npublic Field updateFieldValue ( Field routeFieldValueParam ) { \nif ( routeFieldValueParam != null && this . serviceTicket != null ) routeFieldValueParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Field ( this . postJson ( routeFieldValueParam , Version1 . routeFieldUpdateValue ( ) ) ) ; \n} \n} \n"}
{"9213": "public class RouteFieldClient { \npublic Field createFieldValue ( Field routeFieldValueToCreateParam , FluidItem fluidItemParam ) { \nif ( routeFieldValueToCreateParam != null && this . serviceTicket != null ) routeFieldValueToCreateParam . setServiceTicket ( this . serviceTicket ) ; \nLong fluidItmId = ( fluidItemParam == null ) ? null : fluidItemParam . getId ( ) ; \nreturn new Field ( this . putJson ( routeFieldValueToCreateParam , Version1 . routeFieldCreateValue ( fluidItmId ) ) ) ; \n} \n} \n"}
{"9214": "public class ConfigurationClient { \npublic Configuration getConfigurationByKey ( String configurationKeyParam ) { \nConfiguration configuration = new Configuration ( ) ; \nconfiguration . setKey ( configurationKeyParam ) ; \nif ( this . serviceTicket != null ) configuration . setServiceTicket ( this . serviceTicket ) ; \nreturn new Configuration ( this . postJson ( configuration , WS . Path . Configuration . Version1 . getByKey ( ) ) ) ; \n} \n} \n"}
{"9215": "public class ConfigurationClient { \npublic ConfigurationListing getAllConfigurations ( ) { \nConfiguration configuration = new Configuration ( ) ; \nif ( this . serviceTicket != null ) configuration . setServiceTicket ( this . serviceTicket ) ; \nreturn new ConfigurationListing ( this . postJson ( configuration , WS . Path . Configuration . Version1 . getAllConfigurations ( ) ) ) ; \n} \n} \n"}
{"9216": "public class AttachmentClient { \npublic Attachment createAttachment ( Attachment attachmentParam ) { \nif ( attachmentParam != null && this . serviceTicket != null ) attachmentParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Attachment ( this . putJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentCreate ( ) ) ) ; \n} \n} \n"}
{"9217": "public class AttachmentClient { \npublic Attachment getAttachmentById ( Long attachmentIdParam , boolean includeAttachmentDataParam ) { \nAttachment attachment = new Attachment ( attachmentIdParam ) ; \nif ( this . serviceTicket != null ) attachment . setServiceTicket ( this . serviceTicket ) ; \nreturn new Attachment ( this . postJson ( attachment , WS . Path . Attachment . Version1 . getById ( includeAttachmentDataParam ) ) ) ; \n} \n} \n"}
{"9218": "public class AttachmentClient { \npublic Attachment deleteAttachment ( Attachment attachmentParam ) { \nif ( attachmentParam != null && this . serviceTicket != null ) attachmentParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Attachment ( this . postJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( ) ) ) ; \n} \n} \n"}
{"9219": "public class AttachmentClient { \npublic Attachment forceDeleteAttachment ( Attachment attachmentParam ) { \nif ( attachmentParam != null && this . serviceTicket != null ) attachmentParam . setServiceTicket ( this . serviceTicket ) ; \nreturn new Attachment ( this . postJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( true ) ) ) ; \n} \n} \n"}
{"9220": "public class XsdParserJar { \nprivate void parseJarFile ( InputStream inputStream ) { \ntry { \nNode schemaNode = getSchemaNode ( inputStream ) ; \nif ( isXsdSchema ( schemaNode ) ) XsdSchema . parse ( this , schemaNode ) ; \nelse throw new ParsingException ( \"The top level element of a XSD file should be the xsd:schema node.\" ) ; \n} \ncatch ( SAXException | IOException | ParserConfigurationException e ) { \nLogger . getAnonymousLogger ( ) . log ( Level . SEVERE , \"Exception while parsing.\" , e ) ; \n} \n} \n} \n"}
{"9221": "public class XsdParserJar { \nprivate void setClassLoader ( String jarPath ) { \nif ( ! jarPath . endsWith ( \".jar\" ) ) throw new ParsingException ( \"The jarPath received doesn't represent a jar file.\" ) ; \nClassLoader originalCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nURL url = originalCl . getResource ( jarPath ) ; \nif ( url == null ) try { \nurl = new URL ( \"file:/\" + jarPath ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new ParsingException ( \"Invalid jar name.\" ) ; \n} \nClassLoader urlCl = URLClassLoader . newInstance ( new URL [ ] { \nurl } \n, originalCl ) ; \nThread . currentThread ( ) . setContextClassLoader ( urlCl ) ; \nclassLoader = urlCl ; \n} \n} \n"}
{"9222": "public class XsdGroup { \nprivate void rule2 ( ) { \nif ( ! ( parent instanceof XsdSchema ) && name != null ) throw new ParsingException ( XSD_TAG + \" element: The \" + NAME_TAG + \" should only be used when the parent of the \" + XSD_TAG + \" is the \" + XsdSchema . XSD_TAG + \" element.\" ) ; \n} \n} \n"}
{"9223": "public class XsdGroup { \nprivate void rule3 ( ) { \nif ( parent instanceof XsdSchema && name == null ) throw new ParsingException ( XSD_TAG + \" element: The \" + NAME_TAG + \" should is required the parent of the \" + XSD_TAG + \" is the \" + XsdSchema . XSD_TAG + \" element.\" ) ; \n} \n} \n"}
{"9224": "public class XsdAttribute { \nprivate void rule3 ( ) { \nif ( attributesMap . containsKey ( REF_TAG ) && ( simpleType != null || form != null || type != null ) ) throw new ParsingException ( XSD_TAG + \" element: If \" + REF_TAG + \" attribute is present, simpleType element, form attribute and type attribute cannot be present at the same time.\" ) ; \n} \n} \n"}
{"9226": "public class XsdElement { \nprivate void rule7 ( ) { \nif ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) throw new ParsingException ( XSD_TAG + \" element: The \" + FORM_TAG + \" attribute can only be present when the parent of the \" + xsdElementIsXsdSchema ) ; \n} \n} \n"}
{"9227": "public class XsdElement { \nprivate void rule3 ( ) { \nif ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) throw new ParsingException ( XSD_TAG + \" element: The \" + REF_TAG + \" attribute cannot be present when the parent of the \" + xsdElementIsXsdSchema ) ; \n} \n} \n"}
{"9228": "public class ConvertTypeOfObject { \n@ Override public T convert ( final Object value ) { \nif ( value == null ) return null ; \nelse if ( isIterable ( ) && Iterable . class . isAssignableFrom ( value . getClass ( ) ) ) return convertIterable ( value ) ; \nelse if ( reflectedKlass . assignableFromObject ( value ) ) return ( T ) value ; \nelse if ( reflectedKlass . canBeUnboxed ( value . getClass ( ) ) ) return ( T ) value ; \nelse if ( reflectedKlass . canBeBoxed ( value . getClass ( ) ) ) return ( T ) value ; \nFluentClass < ? > klassToCreate ; \nif ( reflectedKlass . isPrimitive ( ) ) klassToCreate = reflectedKlass . boxedType ( ) ; \nelse klassToCreate = reflectedKlass ; \nreturn ( T ) convertValueTo ( value , klassToCreate ) ; \n} \n} \n"}
{"9233": "public class DiscoveryApi { \nBuilder urlBuilder ( String path ) { \nBuilder builder = baseUrlBuilder ( ) . addPathSegment ( configuration . getApiPackage ( ) ) . addPathSegment ( configuration . getApiVersion ( ) ) . addPathSegment ( path ) ; \nif ( configuration . getPathModifier ( ) != DiscoveryApiConfiguration . PathModifier . NONE ) builder . addPathSegment ( configuration . getPathModifier ( ) . getModifier ( ) ) ; \nreturn builder ; \n} \n} \n"}
{"9235": "public class Line { \npublic double getValue ( double p ) { \nif ( module == null ) throw new NoModuleException ( ) ; \ndouble x = ( x1 - x0 ) * p + x0 ; \ndouble y = ( y1 - y0 ) * p + y0 ; \ndouble z = ( z1 - z0 ) * p + z0 ; \ndouble value = module . getValue ( x , y , z ) ; \nif ( attenuate ) return p * ( 1.0 - p ) * 4 * value ; \nelse return value ; \n} \n} \n"}
{"9241": "public class Range { \npublic void setBounds ( double currentLower , double currentUpper , double newLower , double newUpper ) { \nif ( currentLower == currentUpper ) throw new IllegalArgumentException ( \"currentLower must not equal currentUpper. Both are \" + currentUpper ) ; \nif ( newLower == newUpper ) throw new IllegalArgumentException ( \"newLowerBound must not equal newUpperBound. Both are \" + newUpper ) ; \ncurrentLowerBound = currentLower ; \ncurrentUpperBound = currentUpper ; \nnewLowerBound = newLower ; \nnewUpperBound = newUpper ; \nrecalculateScaleBias ( ) ; \n} \n} \n"}
{"9249": "public class RestoreContext { \npublic void restore ( ) { \nfor ( String propertyName : propertyNames ) { \nif ( restoreProperties . containsKey ( propertyName ) ) System . setProperty ( propertyName , restoreProperties . get ( propertyName ) ) ; \nelse System . clearProperty ( propertyName ) ; \n} \n} \n} \n"}
{"9255": "public class SoftSet { \nprivate void processQueue ( ) { \nComparableSoftReference cr ; \nwhile ( ( cr = ( ComparableSoftReference ) gcqueue . poll ( ) ) != null ) map . remove ( cr . getKey ( ) ) ; \n} \n} \n"}
{"9259": "public class NestedRuntimeException { \npublic void printStackTrace ( final PrintStream stream ) { \nif ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) super . printStackTrace ( stream ) ; \nNestedThrowable . Util . print ( nested , stream ) ; \n} \n} \n"}
{"9260": "public class NestedRuntimeException { \npublic void printStackTrace ( final PrintWriter writer ) { \nif ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) super . printStackTrace ( writer ) ; \nNestedThrowable . Util . print ( nested , writer ) ; \n} \n} \n"}
{"9262": "public class BasicTaskWrapper { \npublic void run ( ) { \nthis . runThread = Thread . currentThread ( ) ; \nlong runTime = getElapsedTime ( ) ; \nif ( startTimeout > 0l && runTime >= startTimeout ) { \ntaskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; \nreturn ; \n} \nboolean stopped = false ; \nsynchronized ( stateLock ) { \nif ( state == TASK_STOPPED ) stopped = true ; \nelse { \nstate = TASK_STARTED ; \ntaskStarted ( ) ; \nif ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; \n} \n} \nif ( stopped ) { \ntaskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; \nreturn ; \n} \nThrowable throwable = null ; \ntry { \ntask . execute ( ) ; \n} \ncatch ( Throwable t ) { \nthrowable = t ; \n} \ntaskCompleted ( throwable ) ; \nsynchronized ( stateLock ) { \nstate = TASK_COMPLETED ; \nif ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; \n} \n} \n} \n"}
{"9269": "public class WorkerQueue { \nprotected Executable getJobImpl ( ) throws InterruptedException { \nwhile ( m_currentJob == null ) wait ( ) ; \nJobItem item = m_currentJob ; \nm_currentJob = m_currentJob . m_next ; \nreturn item . m_job ; \n} \n} \n"}
{"9270": "public class WorkerQueue { \nprotected void putJobImpl ( Executable job ) { \nJobItem posted = new JobItem ( job ) ; \nif ( m_currentJob == null ) { \nm_currentJob = posted ; \nnotifyAll ( ) ; \n} \nelse { \nJobItem item = m_currentJob ; \nwhile ( item . m_next != null ) item = item . m_next ; \nitem . m_next = posted ; \n} \n} \n} \n"}
{"9271": "public class BlockingMode { \npublic static final BlockingMode toBlockingMode ( String name ) { \nBlockingMode mode = null ; \nif ( name == null ) mode = null ; \nelse if ( name . equalsIgnoreCase ( \"run\" ) ) mode = RUN ; \nelse if ( name . equalsIgnoreCase ( \"wait\" ) ) mode = WAIT ; \nelse if ( name . equalsIgnoreCase ( \"discard\" ) ) mode = DISCARD ; \nelse if ( name . equalsIgnoreCase ( \"discardOldest\" ) ) mode = DISCARD_OLDEST ; \nelse if ( name . equalsIgnoreCase ( \"abort\" ) ) mode = ABORT ; \nreturn mode ; \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \nfor ( int count = 0 ; \ncount < readerMap . size ( ) ; \ncount ++ ) mapArr . add ( null ) ; \nEnumeration enumt = readerMap . keys ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \nfor ( int count = 0 ; \ncount < mapArr . size ( ) ; \ncount ++ ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \n} \n} \n} \n"}
{"9277": "public class Catalog { \npublic void loadSystemCatalogs ( ) throws MalformedURLException , IOException { \nVector catalogs = catalogManager . getCatalogFiles ( ) ; \nif ( catalogs != null ) for ( int count = 0 ; \ncount < catalogs . size ( ) ; \ncount ++ ) catalogFiles . addElement ( catalogs . elementAt ( count ) ) ; \nif ( catalogFiles . size ( ) > 0 ) { \nString catfile = ( String ) catalogFiles . lastElement ( ) ; \ncatalogFiles . removeElement ( catfile ) ; \nparseCatalog ( catfile ) ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) break ; \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) newQueue . addElement ( q . nextElement ( ) ) ; \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) catalogEntries . addElement ( e . nextElement ( ) ) ; \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) try { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \nelse catalogs . addElement ( catfile ) ; \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) newQueue . addElement ( q . nextElement ( ) ) ; \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) catalogEntries . addElement ( e . nextElement ( ) ) ; \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) break ; \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( ! parsed ) if ( notFound ) catalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \nelse catalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \n} \n"}
{"9283": "public class Catalog { \npublic String resolveDoctype ( String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolved = null ; \ncatalogManager . debug . message ( 3 , \"resolveDoctype(\" + entityName + \",\" + publicId + \",\" + systemId + \")\" ) ; \nsystemId = normalizeURI ( systemId ) ; \nif ( publicId != null && publicId . startsWith ( \"urn:publicid:\" ) ) publicId = PublicId . decodeURN ( publicId ) ; \nif ( systemId != null && systemId . startsWith ( \"urn:publicid:\" ) ) { \nsystemId = PublicId . decodeURN ( systemId ) ; \nif ( publicId != null && ! publicId . equals ( systemId ) ) { \ncatalogManager . debug . message ( 1 , \"urn:publicid: system identifier differs from public identifier; using public identifier\" ) ; \nsystemId = null ; \n} \nelse { \npublicId = systemId ; \nsystemId = null ; \n} \n} \nif ( systemId != null ) { \nresolved = resolveLocalSystem ( systemId ) ; \nif ( resolved != null ) return resolved ; \n} \nif ( publicId != null ) { \nresolved = resolveLocalPublic ( DOCTYPE , entityName , publicId , systemId ) ; \nif ( resolved != null ) return resolved ; \n} \nboolean over = default_override ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == OVERRIDE ) { \nover = e . getEntryArg ( 0 ) . equalsIgnoreCase ( \"YES\" ) ; \ncontinue ; \n} \nif ( e . getEntryType ( ) == DOCTYPE && e . getEntryArg ( 0 ) . equals ( entityName ) ) if ( over || systemId == null ) return e . getEntryArg ( 1 ) ; \n} \nreturn resolveSubordinateCatalogs ( DOCTYPE , entityName , publicId , systemId ) ; \n} \n} \n"}
{"9284": "public class Catalog { \npublic String resolveDocument ( ) throws MalformedURLException , IOException { \ncatalogManager . debug . message ( 3 , \"resolveDocument\" ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DOCUMENT ) return e . getEntryArg ( 1 ) ; \n} \nreturn resolveSubordinateCatalogs ( DOCUMENT , null , null , null ) ; \n} \n} \n"}
{"9285": "public class Catalog { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \ncatalogManager . debug . message ( 3 , \"resolveSystem(\" + systemId + \")\" ) ; \nsystemId = normalizeURI ( systemId ) ; \nif ( systemId != null && systemId . startsWith ( \"urn:publicid:\" ) ) { \nsystemId = PublicId . decodeURN ( systemId ) ; \nreturn resolvePublic ( systemId , null ) ; \n} \nif ( systemId != null ) { \nString resolved = resolveLocalSystem ( systemId ) ; \nif ( resolved != null ) return resolved ; \n} \nreturn resolveSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9286": "public class Catalog { \nprotected String resolveLocalURI ( String uri ) throws MalformedURLException , IOException { \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == URI && ( e . getEntryArg ( 0 ) . equals ( uri ) ) ) return e . getEntryArg ( 1 ) ; \n} \nenumt = catalogEntries . elements ( ) ; \nString startString = null ; \nString prefix = null ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == REWRITE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) if ( startString == null || p . length ( ) > startString . length ( ) ) { \nstartString = p ; \nprefix = e . getEntryArg ( 1 ) ; \n} \n} \nif ( prefix != null ) return prefix + uri . substring ( startString . length ( ) ) ; \n} \nenumt = catalogEntries . elements ( ) ; \nVector delCats = new Vector ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) delCats . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \nif ( delCats . size ( ) > 0 ) { \nEnumeration enumCats = delCats . elements ( ) ; \nif ( catalogManager . debug . getDebug ( ) > 1 ) { \ncatalogManager . debug . message ( 2 , \"Switching to delegated catalog(s):\" ) ; \nwhile ( enumCats . hasMoreElements ( ) ) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ncatalogManager . debug . message ( 2 , \"\\t\" + delegatedCatalog ) ; \n} \n} \nCatalog dcat = newCatalog ( ) ; \nenumCats = delCats . elements ( ) ; \nwhile ( enumCats . hasMoreElements ( ) ) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ndcat . parseCatalog ( delegatedCatalog ) ; \n} \nreturn dcat . resolveURI ( uri ) ; \n} \nreturn null ; \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nelse if ( entityType == DOCUMENT ) resolved = c . resolveDocument ( ) ; \nelse if ( entityType == ENTITY ) resolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nelse if ( entityType == NOTATION ) resolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nelse if ( entityType == PUBLIC ) resolved = c . resolvePublic ( publicId , systemId ) ; \nelse if ( entityType == SYSTEM ) resolved = c . resolveSystem ( systemId ) ; \nelse if ( entityType == URI ) resolved = c . resolveURI ( systemId ) ; \nif ( resolved != null ) return resolved ; \n} \nreturn null ; \n} \n} \n"}
{"9288": "public class Catalog { \nprotected String makeAbsolute ( String sysid ) { \nURL local = null ; \nsysid = fixSlashes ( sysid ) ; \ntry { \nlocal = new URL ( base , sysid ) ; \n} \ncatch ( MalformedURLException e ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on system identifier\" , sysid ) ; \n} \nif ( local != null ) return local . toString ( ) ; \nelse return sysid ; \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) return null ; \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \nfor ( int count = 0 ; \ncount < bytes . length ; \ncount ++ ) { \nint ch = bytes [ count ] & 0xFF ; \nif ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) newRef += encodedByte ( ch ) ; \nelse newRef += ( char ) bytes [ count ] ; \n} \nreturn newRef ; \n} \n} \n"}
{"9290": "public class Catalog { \nprotected String encodedByte ( int b ) { \nString hex = Integer . toHexString ( b ) . toUpperCase ( ) ; \nif ( hex . length ( ) < 2 ) return \"%0\" + hex ; \nelse return \"%\" + hex ; \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nint pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nwhile ( local . hasMoreElements ( ) ) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) return ; \nif ( dp . length ( ) > partial . length ( ) ) pos ++ ; \nif ( dp . length ( ) < partial . length ( ) ) break ; \n} \nif ( localDelegate . size ( ) == 0 ) localDelegate . addElement ( entry ) ; \nelse localDelegate . insertElementAt ( entry , pos ) ; \n} \n} \n"}
{"9293": "public class ThrowableHandler { \nprotected static void fireOnThrowable ( int type , Throwable t ) { \nObject [ ] list = listeners . toArray ( ) ; \nfor ( int i = 0 ; \ni < list . length ; \ni ++ ) ( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; \n} \n} \n"}
{"9297": "public class InetAddressEditor { \npublic Object getValue ( ) { \ntry { \nString text = getAsText ( ) ; \nif ( text == null ) return null ; \nif ( text . startsWith ( \"/\" ) ) text = text . substring ( 1 ) ; \nreturn InetAddress . getByName ( StringPropertyReplacer . replaceProperties ( text ) ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new NestedRuntimeException ( e ) ; \n} \n} \n} \n"}
{"9300": "public class CachedList { \nprivate void maintain ( ) { \nSoftObject obj ; \nint count = 0 ; \nwhile ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { \ncount ++ ; \nlist . remove ( obj ) ; \n} \nif ( count != 0 ) System . err . println ( \"vm reclaimed \" + count + \" objects\" ) ; \n} \n} \n"}
{"9302": "public class CatalogEntry { \npublic static int getEntryType ( String name ) throws CatalogException { \nif ( ! entryTypes . containsKey ( name ) ) throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; \nInteger iType = ( Integer ) entryTypes . get ( name ) ; \nif ( iType == null ) throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; \nreturn iType . intValue ( ) ; \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \nfor ( int i = 0 ; \ni < PROTOCOLS . length ; \ni ++ ) try { \nURL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) return handler ; \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nfor ( int p = 0 ; \np < handlerPkgs . length ; \np ++ ) try { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9316": "public class LongCounter { \npublic static LongCounter makeDirectional ( final LongCounter counter , final boolean increasing ) { \nLongCounter temp ; \nif ( increasing ) temp = new Wrapper ( counter ) { \nprivate static final long serialVersionUID = - 8902748795144754375L ; \npublic long decrement ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \npublic void reset ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \nelse temp = new Wrapper ( counter ) { \nprivate static final long serialVersionUID = 2584758778978644599L ; \npublic long increment ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \nreturn temp ; \n} \n} \n"}
{"9317": "public class OASISXMLCatalogReader { \nprotected boolean inExtensionNamespace ( ) { \nboolean inExtension = false ; \nEnumeration elements = namespaceStack . elements ( ) ; \nwhile ( ! inExtension && elements . hasMoreElements ( ) ) { \nString ns = ( String ) elements . nextElement ( ) ; \nif ( ns == null ) inExtension = true ; \nelse inExtension = ( ! ns . equals ( tr9401NamespaceName ) && ! ns . equals ( namespaceName ) ) ; \n} \nreturn inExtension ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( limit > 0 && count > limit ) count = limit ; \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) end = string . length ( ) ; \nif ( end == 0 ) strings [ i ] = EMPTY ; \nelse strings [ i ] = string . substring ( begin , end ) ; \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9323": "public class Strings { \npublic static String join ( final byte array [ ] ) { \nByte bytes [ ] = new Byte [ array . length ] ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni ++ ) bytes [ i ] = new Byte ( array [ i ] ) ; \nreturn join ( bytes , null ) ; \n} \n} \n"}
{"9327": "public class TimedCachePolicy { \npublic Object get ( Object key ) { \nTimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; \nif ( entry == null ) return null ; \nif ( entry . isCurrent ( now ) == false ) if ( entry . refresh ( ) == false ) { \nentry . destroy ( ) ; \nentryMap . remove ( key ) ; \nreturn null ; \n} \nObject value = entry . getValue ( ) ; \nreturn value ; \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) return null ; \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) goodChildren . add ( currentChild ) ; \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9335": "public class XmlHelper { \npublic static Element getUniqueChild ( Element element , String tagName ) throws Exception { \nIterator goodChildren = getChildrenByTagName ( element , tagName ) ; \nif ( goodChildren != null && goodChildren . hasNext ( ) ) { \nElement child = ( Element ) goodChildren . next ( ) ; \nif ( goodChildren . hasNext ( ) ) throw new Exception ( \"expected only one \" + tagName + \" tag\" ) ; \nreturn child ; \n} \nelse throw new Exception ( \"expected one \" + tagName + \" tag\" ) ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) if ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) result += children . item ( i ) . getNodeValue ( ) ; \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9344": "public class Resolver { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolveSystem ( systemId ) ; \nif ( resolved != null ) return resolved ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) return resolved ; \n} \nelse if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { \nString suffix = e . getEntryArg ( 0 ) ; \nString result = e . getEntryArg ( 1 ) ; \nif ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) return result ; \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9345": "public class Resolver { \npublic String resolvePublic ( String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) return resolved ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nif ( systemId != null ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) return resolved ; \n} \nresolved = resolveExternalPublic ( publicId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) return resolved ; \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . PUBLIC , null , publicId , systemId ) ; \n} \n} \n"}
{"9346": "public class Resolver { \nprotected String resolveExternalSystem ( String systemId , String resolver ) throws MalformedURLException , IOException { \nResolver r = queryResolver ( resolver , \"i2l\" , systemId , null ) ; \nif ( r != null ) return r . resolveSystem ( systemId ) ; \nelse return null ; \n} \n} \n"}
{"9347": "public class Resolver { \nprotected String resolveExternalPublic ( String publicId , String resolver ) throws MalformedURLException , IOException { \nResolver r = queryResolver ( resolver , \"fpi2l\" , publicId , null ) ; \nif ( r != null ) return r . resolvePublic ( publicId , null ) ; \nelse return null ; \n} \n} \n"}
{"9348": "public class Resolver { \nprotected Resolver queryResolver ( String resolver , String command , String arg1 , String arg2 ) { \nString RFC2483 = resolver + \"?command=\" + command + \"&format=tr9401&uri=\" + arg1 + \"&uri2=\" + arg2 ; \ntry { \nURL url = new URL ( RFC2483 ) ; \nURLConnection urlCon = url . openConnection ( ) ; \nurlCon . setUseCaches ( false ) ; \nResolver r = ( Resolver ) newCatalog ( ) ; \nString cType = urlCon . getContentType ( ) ; \nif ( cType . indexOf ( \";\" ) > 0 ) cType = cType . substring ( 0 , cType . indexOf ( \";\" ) ) ; \nr . parseCatalog ( cType , urlCon . getInputStream ( ) ) ; \nreturn r ; \n} \ncatch ( CatalogException cex ) { \nif ( cex . getExceptionType ( ) == CatalogException . UNPARSEABLE ) catalogManager . debug . message ( 1 , \"Unparseable catalog: \" + RFC2483 ) ; \nelse if ( cex . getExceptionType ( ) == CatalogException . UNKNOWN_FORMAT ) catalogManager . debug . message ( 1 , \"Unknown catalog format: \" + RFC2483 ) ; \nreturn null ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed resolver URL: \" + RFC2483 ) ; \nreturn null ; \n} \ncatch ( IOException ie ) { \ncatalogManager . debug . message ( 1 , \"I/O Exception opening resolver: \" + RFC2483 ) ; \nreturn null ; \n} \n} \n} \n"}
{"9349": "public class Resolver { \nprivate Vector appendVector ( Vector vec , Vector appvec ) { \nif ( appvec != null ) for ( int count = 0 ; \ncount < appvec . size ( ) ; \ncount ++ ) vec . addElement ( appvec . elementAt ( count ) ) ; \nreturn vec ; \n} \n} \n"}
{"9351": "public class Resolver { \npublic String resolveSystemReverse ( String systemId ) throws MalformedURLException , IOException { \nVector resolved = resolveAllSystemReverse ( systemId ) ; \nif ( resolved != null && resolved . size ( ) > 0 ) return ( String ) resolved . elementAt ( 0 ) ; \nelse return null ; \n} \n} \n"}
{"9352": "public class Resolver { \npublic Vector resolveAllSystem ( String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nif ( systemId != null ) { \nVector localResolutions = resolveAllLocalSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \nVector subResolutions = resolveAllSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; \nresolutions = appendVector ( resolutions , subResolutions ) ; \nif ( resolutions . size ( ) > 0 ) return resolutions ; \nelse return null ; \n} \n} \n"}
{"9353": "public class Resolver { \nprivate Vector resolveAllLocalSystem ( String systemId ) { \nVector map = new Vector ( ) ; \nString osname = System . getProperty ( \"os.name\" ) ; \nboolean windows = ( osname . indexOf ( \"Windows\" ) >= 0 ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == SYSTEM && ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) ) map . addElement ( e . getEntryArg ( 1 ) ) ; \n} \nif ( map . size ( ) == 0 ) return null ; \nelse return map ; \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == SYSTEM ) { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse if ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \n} \nif ( resolutions != null ) return resolutions ; \nelse return null ; \n} \n} \n"}
{"9356": "public class SAXCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nif ( parserFactory == null && parserClass == null ) { \ndebug . message ( 1 , \"Cannot read SAX catalog without a parser\" ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ndebug = catalog . getCatalogManager ( ) . debug ; \nEntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; \nthis . catalog = catalog ; \ntry { \nif ( parserFactory != null ) { \nSAXParser parser = parserFactory . newSAXParser ( ) ; \nSAXParserHandler spHandler = new SAXParserHandler ( ) ; \nspHandler . setContentHandler ( this ) ; \nif ( bResolver != null ) spHandler . setEntityResolver ( bResolver ) ; \nparser . parse ( new InputSource ( is ) , spHandler ) ; \n} \nelse { \nParser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; \nparser . setDocumentHandler ( this ) ; \nif ( bResolver != null ) parser . setEntityResolver ( bResolver ) ; \nparser . parse ( new InputSource ( is ) ) ; \n} \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \ncatch ( SAXException se ) { \nException e = se . getException ( ) ; \nUnknownHostException uhe = new UnknownHostException ( ) ; \nFileNotFoundException fnfe = new FileNotFoundException ( ) ; \nif ( e != null ) if ( e . getClass ( ) == uhe . getClass ( ) ) throw new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \nelse if ( e . getClass ( ) == fnfe . getClass ( ) ) throw new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \nthrow new CatalogException ( se ) ; \n} \n} \n} \n"}
{"9357": "public class FileURLConnection { \npublic void connect ( ) throws IOException { \nif ( connected ) return ; \nif ( ! file . exists ( ) ) throw new FileNotFoundException ( file . getPath ( ) ) ; \nconnected = true ; \n} \n} \n"}
{"9360": "public class Node { \nvoid helpDelete ( Node < K , V > b , Node < K , V > f ) { \nif ( f == next && this == b . next ) if ( f == null || f . value != f ) appendMarker ( f ) ; \nelse b . casNext ( this , f . next ) ; \n} \n} \n"}
{"9365": "public class JBossObject { \npublic static void list ( JBossStringBuilder buffer , Collection objects ) { \nif ( objects == null ) return ; \nbuffer . append ( '[' ) ; \nif ( objects . isEmpty ( ) == false ) for ( Iterator i = objects . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nObject object = i . next ( ) ; \nif ( object instanceof JBossObject ) ( ( JBossObject ) object ) . toShortString ( buffer ) ; \nelse buffer . append ( object . toString ( ) ) ; \nif ( i . hasNext ( ) ) buffer . append ( \", \" ) ; \n} \nbuffer . append ( ']' ) ; \n} \n} \n"}
{"9370": "public class Objects { \npublic static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \nvalueType } \n) ; \n} \ncatch ( Exception ignore ) { \nClass [ ] types = type . getClasses ( ) ; \nfor ( int i = 0 ; \ni < types . length ; \ni ++ ) try { \nreturn type . getConstructor ( new Class [ ] { \ntypes [ i ] } \n) ; \n} \ncatch ( Exception ignore2 ) { \n} \n} \nreturn null ; \n} \n} \n"}
{"9377": "public class PropertyMap { \npublic boolean removePropertyListener ( PropertyListener listener ) { \nif ( listener == null ) throw new NullArgumentException ( \"listener\" ) ; \nboolean removed = false ; \nif ( listener instanceof BoundPropertyListener ) removed = removePropertyListener ( ( BoundPropertyListener ) listener ) ; \nelse removed = unboundListeners . remove ( listener ) ; \nreturn removed ; \n} \n} \n"}
{"9381": "public class PropertyMap { \nprotected void firePropertyChanged ( PropertyEvent event ) { \nif ( boundListeners != null ) { \nList list = ( List ) boundListeners . get ( event . getPropertyName ( ) ) ; \nif ( list != null ) firePropertyChanged ( list , event ) ; \n} \nfirePropertyChanged ( unboundListeners , event ) ; \n} \n} \n"}
{"9387": "public class JBossEntityResolver { \nprotected InputSource resolveSystemID ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveSystemID, systemId=\" + systemId ) ; \nInputSource inputSource = null ; \nString filename = null ; \nif ( localEntities != null ) filename = ( String ) localEntities . get ( systemId ) ; \nif ( filename == null ) filename = ( String ) entities . get ( systemId ) ; \nif ( filename != null ) { \nif ( trace ) log . trace ( \"Found entity systemId=\" + systemId + \" fileName=\" + filename ) ; \nInputStream ins = loadClasspathResource ( filename , trace ) ; \nif ( ins != null ) { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nelse log . warn ( \"Cannot load systemId from resource: \" + filename ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9388": "public class JBossEntityResolver { \nprotected InputSource resolveSystemIDasURL ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveSystemIDasURL, systemId=\" + systemId ) ; \nInputSource inputSource = null ; \ntry { \nif ( trace ) log . trace ( \"Trying to resolve systemId as a URL\" ) ; \nif ( isReplaceSystemProperties ( ) ) systemId = StringPropertyReplacer . replaceProperties ( systemId ) ; \nURL url = new URL ( systemId ) ; \nif ( warnOnNonFileURLs && url . getProtocol ( ) . equalsIgnoreCase ( \"file\" ) == false && url . getProtocol ( ) . equalsIgnoreCase ( \"vfszip\" ) == false ) log . warn ( \"Trying to resolve systemId as a non-file URL: \" + systemId ) ; \nInputStream ins = url . openStream ( ) ; \nif ( ins != null ) { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nelse log . warn ( \"Cannot load systemId as URL: \" + systemId ) ; \nif ( trace ) log . trace ( \"Resolved systemId as a URL\" ) ; \n} \ncatch ( MalformedURLException ignored ) { \nif ( trace ) log . trace ( \"SystemId is not a url: \" + systemId , ignored ) ; \n} \ncatch ( IOException e ) { \nif ( trace ) log . trace ( \"Failed to obtain URL.InputStream from systemId: \" + systemId , e ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9391": "public class PublicId { \npublic static String normalize ( String publicId ) { \nString normal = publicId . replace ( '\\t' , ' ' ) ; \nnormal = normal . replace ( '\\r' , ' ' ) ; \nnormal = normal . replace ( '\\n' , ' ' ) ; \nnormal = normal . trim ( ) ; \nint pos ; \nwhile ( ( pos = normal . indexOf ( \"  \" ) ) >= 0 ) normal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; \nreturn normal ; \n} \n} \n"}
{"9393": "public class PublicId { \npublic static String decodeURN ( String urn ) { \nString publicId = \"\" ; \nif ( urn . startsWith ( \"urn:publicid:\" ) ) publicId = urn . substring ( 13 ) ; \nelse return urn ; \npublicId = PublicId . stringReplace ( publicId , \"%2F\" , \"/\" ) ; \npublicId = PublicId . stringReplace ( publicId , \":\" , \"//\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%3A\" , \":\" ) ; \npublicId = PublicId . stringReplace ( publicId , \";\" , \"::\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"+\" , \" \" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%2B\" , \"+\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%23\" , \"#\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%3F\" , \"?\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%27\" , \"'\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%3B\" , \";\" ) ; \npublicId = PublicId . stringReplace ( publicId , \"%25\" , \"%\" ) ; \nreturn publicId ; \n} \n} \n"}
{"9400": "public class HashCode { \npublic static int generate ( final Object array [ ] , final boolean deep ) { \nint hashcode = 0 ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) if ( deep && ( array [ i ] instanceof Object [ ] ) ) hashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; \nelse hashcode ^= array [ i ] . hashCode ( ) ; \nreturn hashcode ; \n} \n} \n"}
{"9403": "public class TextCatalogReader { \nprotected String nextToken ( ) throws IOException { \nString token = \"\" ; \nint ch , nextch ; \nif ( ! tokenStack . empty ( ) ) return ( String ) tokenStack . pop ( ) ; \nwhile ( true ) { \nch = catfile . read ( ) ; \nwhile ( ch <= ' ' ) { \nch = catfile . read ( ) ; \nif ( ch < 0 ) return null ; \n} \nnextch = catfile . read ( ) ; \nif ( nextch < 0 ) return null ; \nif ( ch == '-' && nextch == '-' ) { \nch = ' ' ; \nnextch = nextChar ( ) ; \nwhile ( ch != '-' || nextch != '-' ) { \nch = nextch ; \nnextch = nextChar ( ) ; \n} \n} \nelse { \nstack [ ++ top ] = nextch ; \nstack [ ++ top ] = ch ; \nbreak ; \n} \n} \nch = nextChar ( ) ; \nif ( ch == '\"' || ch == '\\'' ) { \nint quote = ch ; \nwhile ( ( ch = nextChar ( ) ) != quote ) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \n} \nreturn token ; \n} \nelse { \nwhile ( ch > ' ' ) { \nnextch = nextChar ( ) ; \nif ( ch == '-' && nextch == '-' ) { \nstack [ ++ top ] = ch ; \nstack [ ++ top ] = nextch ; \nreturn token ; \n} \nelse { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \nch = nextch ; \n} \n} \nreturn token ; \n} \n} \n} \n"}
{"9404": "public class DateEditor { \npublic static void initialize ( ) { \nPrivilegedAction action = new PrivilegedAction ( ) { \npublic Object run ( ) { \nString defaultFormat = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.format\" , \"MMM d, yyyy\" ) ; \nString defaultLocale = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.locale\" ) ; \nDateFormat defaultDateFormat ; \nif ( defaultLocale == null || defaultLocale . length ( ) == 0 ) defaultDateFormat = new SimpleDateFormat ( defaultFormat ) ; \nelse defaultDateFormat = new SimpleDateFormat ( defaultFormat , Strings . parseLocaleString ( defaultLocale ) ) ; \nformats = new DateFormat [ ] { \ndefaultDateFormat , new SimpleDateFormat ( \"EEE MMM d HH:mm:ss z yyyy\" ) , new SimpleDateFormat ( \"EEE, d MMM yyyy HH:mm:ss Z\" ) } \n; \nreturn null ; \n} \n} \n; \nAccessController . doPrivileged ( action ) ; \n} \n} \n"}
{"9417": "public class DOMUtils { \npublic static QName resolveQName ( Element el , String qualifiedName ) { \nQName qname ; \nString prefix = \"\" ; \nString namespaceURI = \"\" ; \nString localPart = qualifiedName ; \nint colIndex = qualifiedName . indexOf ( \":\" ) ; \nif ( colIndex > 0 ) { \nprefix = qualifiedName . substring ( 0 , colIndex ) ; \nlocalPart = qualifiedName . substring ( colIndex + 1 ) ; \nif ( \"xmlns\" . equals ( prefix ) ) namespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; \nelse { \nElement nsElement = el ; \nwhile ( namespaceURI . equals ( \"\" ) && nsElement != null ) { \nnamespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; \nif ( namespaceURI . equals ( \"\" ) ) nsElement = getParentElement ( nsElement ) ; \n} \n} \nif ( namespaceURI . equals ( \"\" ) ) throw new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; \n} \nqname = new QName ( namespaceURI , localPart , prefix ) ; \nreturn qname ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attribs . getLength ( ) ; \ni ++ ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( uri == null && qname . startsWith ( \"xmlns\" ) ) log . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \nelse destElement . setAttributeNS ( uri , qname , value ) ; \n} \n} \n} \n"}
{"9425": "public class DOMCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nDocumentBuilderFactory factory = null ; \nDocumentBuilder builder = null ; \nfactory = DocumentBuilderFactory . newInstance ( ) ; \nfactory . setNamespaceAware ( false ) ; \nfactory . setValidating ( false ) ; \ntry { \nbuilder = factory . newDocumentBuilder ( ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nDocument doc = null ; \ntry { \ndoc = builder . parse ( is ) ; \n} \ncatch ( SAXException se ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \nElement root = doc . getDocumentElement ( ) ; \nString namespaceURI = Namespaces . getNamespaceURI ( root ) ; \nString localName = Namespaces . getLocalName ( root ) ; \nString domParserClass = getCatalogParser ( namespaceURI , localName ) ; \nif ( domParserClass == null ) { \nif ( namespaceURI == null ) catalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + localName ) ; \nelse catalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + \"{\" + namespaceURI + \"}\" + localName ) ; \nreturn ; \n} \nDOMCatalogParser domParser = null ; \ntry { \ndomParser = ( DOMCatalogParser ) Class . forName ( domParserClass ) . newInstance ( ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot load XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot instantiate XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot access XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ClassCastException cce ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot cast XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nNode node = root . getFirstChild ( ) ; \nwhile ( node != null ) { \ndomParser . parseCatalogEntry ( catalog , node ) ; \nnode = node . getNextSibling ( ) ; \n} \n} \n} \n"}
{"9428": "public class CatalogLocation { \npublic InputSource resolveEntity ( String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolvedURI = catologResolver . resolveSystem ( systemId ) ; \nif ( resolvedURI == null ) resolvedURI = catologResolver . resolvePublic ( publicId , systemId ) ; \nif ( resolvedURI != null ) { \nfinal InputSource is = new InputSource ( ) ; \nis . setPublicId ( publicId ) ; \nis . setSystemId ( systemId ) ; \nis . setByteStream ( this . loadResource ( resolvedURI ) ) ; \nthis . isLastEntityResolved = true ; \nreturn is ; \n} \nelse { \nthis . isLastEntityResolved = false ; \nreturn null ; \n} \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) return ; \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) method . invoke ( null , ( Object [ ] ) null ) ; \nelse type . newInstance ( ) ; \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9435": "public class Classes { \npublic static Class getPrimitiveWrapper ( final Class type ) { \nif ( ! type . isPrimitive ( ) ) throw new IllegalArgumentException ( \"type is not a primitive class\" ) ; \nfor ( int i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni += 2 ) if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; \nthrow new UnreachableStatementException ( ) ; \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn ++ ) allIfaces . add ( ifaces [ n ] ) ; \nc = c . getSuperclass ( ) ; \n} \n} \n} \n"}
{"9437": "public class Classes { \npublic static Class [ ] getAllUniqueInterfaces ( Class c ) { \nSet uniqueIfaces = new HashSet ( ) ; \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn ++ ) uniqueIfaces . add ( ifaces [ n ] ) ; \nc = c . getSuperclass ( ) ; \n} \nreturn ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; \n} \n} \n"}
{"9438": "public class Classes { \npublic static boolean isPrimitiveWrapper ( final Class type ) { \nfor ( int i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni += 2 ) if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) return true ; \nreturn false ; \n} \n} \n"}
{"9440": "public class Classes { \npublic final static Method getAttributeGetter ( Class cls , String attr ) throws NoSuchMethodException { \nStringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; \nbuf . append ( \"get\" ) ; \nif ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) buf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; \nelse buf . append ( attr ) ; \ntry { \nreturn cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; \n} \ncatch ( NoSuchMethodException e ) { \nbuf . replace ( 0 , 3 , \"is\" ) ; \nreturn cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; \n} \n} \n} \n"}
{"9441": "public class Classes { \npublic final static Method getAttributeSetter ( Class cls , String attr , Class type ) throws NoSuchMethodException { \nStringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; \nbuf . append ( \"set\" ) ; \nif ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) buf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; \nelse buf . append ( attr ) ; \nreturn cls . getMethod ( buf . toString ( ) , new Class [ ] { \ntype } \n) ; \n} \n} \n"}
{"9442": "public class Classes { \nprivate final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { \nint arraySize = 0 ; \nwhile ( name . endsWith ( \"[]\" ) ) { \nname = name . substring ( 0 , name . length ( ) - 2 ) ; \narraySize ++ ; \n} \nClass c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; \nif ( c == null ) try { \nc = cl . loadClass ( name ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; \n} \nif ( arraySize > 0 ) { \nint [ ] dims = new int [ arraySize ] ; \nfor ( int i = 0 ; \ni < arraySize ; \ni ++ ) dims [ i ] = 1 ; \nc = Array . newInstance ( c , dims ) . getClass ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"9444": "public class DefaultPropertyReader { \npublic static String [ ] getFilenames ( final String propertyName ) throws PropertyException { \nString filenames [ ] ; \nObject filename = PropertyManager . getProperty ( propertyName ) ; \nif ( filename != null ) filenames = new String [ ] { \nString . valueOf ( filename ) } \n; \nelse filenames = PropertyManager . getArrayProperty ( propertyName ) ; \nreturn filenames ; \n} \n} \n"}
{"9445": "public class WeakSet { \nprotected final void maintain ( ) { \nWeakObject weak ; \nwhile ( ( weak = ( WeakObject ) queue . poll ( ) ) != null ) set . remove ( weak ) ; \n} \n} \n"}
{"9446": "public class WeakSet { \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nIterator iter = set . iterator ( ) ; \nObject UNKNOWN = new Object ( ) ; \nObject next = UNKNOWN ; \npublic boolean hasNext ( ) { \nif ( next != UNKNOWN ) return true ; \nwhile ( iter . hasNext ( ) ) { \nWeakObject weak = ( WeakObject ) iter . next ( ) ; \nObject obj = null ; \nif ( weak != null && ( obj = weak . get ( ) ) == null ) continue ; \nnext = obj ; \nreturn true ; \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( ( next == UNKNOWN ) && ! hasNext ( ) ) throw new NoSuchElementException ( ) ; \nObject obj = next ; \nnext = UNKNOWN ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n"}
{"9447": "public class URLListerFactory { \npublic URLLister createURLLister ( String protocol ) throws MalformedURLException { \ntry { \nString className = ( String ) classes . get ( protocol ) ; \nif ( className == null ) throw new MalformedURLException ( \"No lister class defined for protocol \" + protocol ) ; \nClass < ? > clazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; \nreturn ( URLLister ) clazz . newInstance ( ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new MalformedURLException ( e . getMessage ( ) ) ; \n} \ncatch ( InstantiationException e ) { \nthrow new MalformedURLException ( e . getMessage ( ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new MalformedURLException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) count ++ ; \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) return true ; \nwhile ( next == null ) if ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \nelse break ; \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9454": "public class PropertyEditors { \npublic static Object convertValue ( String text , String typeName ) throws ClassNotFoundException , IntrospectionException { \nClass < ? > typeClass = Classes . getPrimitiveTypeForName ( typeName ) ; \nif ( typeClass == null ) { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \ntypeClass = loader . loadClass ( typeName ) ; \n} \nPropertyEditor editor = PropertyEditorManager . findEditor ( typeClass ) ; \nif ( editor == null ) throw new IntrospectionException ( \"No property editor for type=\" + typeClass ) ; \neditor . setAsText ( text ) ; \nreturn editor . getValue ( ) ; \n} \n} \n"}
{"9456": "public class ApplicationDeadlockException { \npublic static ApplicationDeadlockException isADE ( Throwable t ) { \nwhile ( t != null ) if ( t instanceof ApplicationDeadlockException ) return ( ApplicationDeadlockException ) t ; \nelse t = t . getCause ( ) ; \nreturn null ; \n} \n} \n"}
{"9464": "public class CatalogManager { \nprivate synchronized void readProperties ( ) { \ntry { \npropertyFileURI = CatalogManager . class . getResource ( \"/\" + propertyFile ) ; \nInputStream in = CatalogManager . class . getResourceAsStream ( \"/\" + propertyFile ) ; \nif ( in == null ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Cannot find \" + propertyFile ) ; \nignoreMissingProperties = true ; \n} \nreturn ; \n} \nresources = new PropertyResourceBundle ( in ) ; \n} \ncatch ( MissingResourceException mre ) { \nif ( ! ignoreMissingProperties ) System . err . println ( \"Cannot read \" + propertyFile ) ; \n} \ncatch ( java . io . IOException e ) { \nif ( ! ignoreMissingProperties ) System . err . println ( \"Failure trying to read \" + propertyFile ) ; \n} \nif ( verbosity == null ) try { \nString verbStr = resources . getString ( \"verbosity\" ) ; \nint verb = Integer . parseInt ( verbStr . trim ( ) ) ; \ndebug . setDebug ( verb ) ; \nverbosity = new Integer ( verb ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n"}
{"9467": "public class CatalogManager { \nprivate String queryCatalogFiles ( ) { \nString catalogList = System . getProperty ( pFiles ) ; \nfromPropertiesFile = false ; \nif ( catalogList == null ) { \nif ( resources == null ) readProperties ( ) ; \nif ( resources != null ) try { \ncatalogList = resources . getString ( \"catalogs\" ) ; \nfromPropertiesFile = true ; \n} \ncatch ( MissingResourceException e ) { \nSystem . err . println ( propertyFile + \": catalogs not found.\" ) ; \ncatalogList = null ; \n} \n} \nif ( catalogList == null ) catalogList = defaultCatalogFiles ; \nreturn catalogList ; \n} \n} \n"}
{"9468": "public class CatalogManager { \npublic Vector getCatalogFiles ( ) { \nif ( catalogFiles == null ) catalogFiles = queryCatalogFiles ( ) ; \nStringTokenizer files = new StringTokenizer ( catalogFiles , \";\" ) ; \nVector catalogs = new Vector ( ) ; \nwhile ( files . hasMoreTokens ( ) ) { \nString catalogFile = files . nextToken ( ) ; \nURL absURI = null ; \nif ( fromPropertiesFile && ! relativeCatalogs ( ) ) try { \nabsURI = new URL ( propertyFileURI , catalogFile ) ; \ncatalogFile = absURI . toString ( ) ; \n} \ncatch ( MalformedURLException mue ) { \nabsURI = null ; \n} \ncatalogs . add ( catalogFile ) ; \n} \nreturn catalogs ; \n} \n} \n"}
{"9469": "public class CatalogManager { \nprivate boolean queryPreferPublic ( ) { \nString prefer = System . getProperty ( pPrefer ) ; \nif ( prefer == null ) { \nif ( resources == null ) readProperties ( ) ; \nif ( resources == null ) return defaultPreferPublic ; \ntry { \nprefer = resources . getString ( \"prefer\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultPreferPublic ; \n} \n} \nif ( prefer == null ) return defaultPreferPublic ; \nreturn ( prefer . equalsIgnoreCase ( \"public\" ) ) ; \n} \n} \n"}
{"9470": "public class CatalogManager { \nprivate boolean queryUseStaticCatalog ( ) { \nString staticCatalog = System . getProperty ( pStatic ) ; \nif ( useStaticCatalog == null ) { \nif ( resources == null ) readProperties ( ) ; \nif ( resources == null ) return defaultUseStaticCatalog ; \ntry { \nstaticCatalog = resources . getString ( \"static-catalog\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultUseStaticCatalog ; \n} \n} \nif ( staticCatalog == null ) return defaultUseStaticCatalog ; \nreturn ( staticCatalog . equalsIgnoreCase ( \"true\" ) || staticCatalog . equalsIgnoreCase ( \"yes\" ) || staticCatalog . equalsIgnoreCase ( \"1\" ) ) ; \n} \n} \n"}
{"9471": "public class BootstrapResolver { \npublic InputSource resolveEntity ( String publicId , String systemId ) { \nString resolved = null ; \nif ( systemId != null && systemMap . containsKey ( systemId ) ) resolved = ( String ) systemMap . get ( systemId ) ; \nelse if ( publicId != null && publicMap . containsKey ( publicId ) ) resolved = ( String ) publicMap . get ( publicId ) ; \nif ( resolved != null ) try { \nInputSource iSource = new InputSource ( resolved ) ; \niSource . setPublicId ( publicId ) ; \nURL url = new URL ( resolved ) ; \nInputStream iStream = url . openStream ( ) ; \niSource . setByteStream ( iStream ) ; \nreturn iSource ; \n} \ncatch ( Exception e ) { \nreturn null ; \n} \nreturn null ; \n} \n} \n"}
{"9472": "public class BootstrapResolver { \npublic Source resolve ( String href , String base ) throws TransformerException { \nString uri = href ; \nint hashPos = href . indexOf ( \"#\" ) ; \nif ( hashPos >= 0 ) uri = href . substring ( 0 , hashPos ) ; \nString result = null ; \nif ( href != null && uriMap . containsKey ( href ) ) result = ( String ) uriMap . get ( href ) ; \nif ( result == null ) try { \nURL url = null ; \nif ( base == null ) { \nurl = new URL ( uri ) ; \nresult = url . toString ( ) ; \n} \nelse { \nURL baseURL = new URL ( base ) ; \nurl = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; \nresult = url . toString ( ) ; \n} \n} \ncatch ( java . net . MalformedURLException mue ) { \nString absBase = makeAbsolute ( base ) ; \nif ( ! absBase . equals ( base ) ) return resolve ( href , absBase ) ; \nelse throw new TransformerException ( \"Malformed URL \" + href + \"(base \" + base + \")\" , mue ) ; \n} \nSAXSource source = new SAXSource ( ) ; \nsource . setInputSource ( new InputSource ( result ) ) ; \nreturn source ; \n} \n} \n"}
{"9473": "public class BootstrapResolver { \nprivate String makeAbsolute ( String uri ) { \nif ( uri == null ) uri = \"\" ; \ntry { \nURL url = new URL ( uri ) ; \nreturn url . toString ( ) ; \n} \ncatch ( MalformedURLException mue ) { \nString dir = System . getProperty ( \"user.dir\" ) ; \nString file = \"\" ; \nif ( dir . endsWith ( \"/\" ) ) file = \"file://\" + dir + uri ; \nelse file = \"file://\" + dir + \"/\" + uri ; \ntry { \nURL fileURL = new URL ( file ) ; \nreturn fileURL . toString ( ) ; \n} \ncatch ( MalformedURLException mue2 ) { \nreturn uri ; \n} \n} \n} \n} \n"}
{"9475": "public class MethodBoundPropertyListener { \nprotected void invokeSetter ( String value ) { \ntry { \nClass < ? > type = descriptor . getPropertyType ( ) ; \nPropertyEditor editor = PropertyEditors . findEditor ( type ) ; \neditor . setAsText ( value ) ; \nObject coerced = editor . getValue ( ) ; \nsetter . invoke ( instance , new Object [ ] { \ncoerced } \n) ; \n} \ncatch ( InvocationTargetException e ) { \nThrowable target = e . getTargetException ( ) ; \nif ( target instanceof PropertyException ) throw ( PropertyException ) target ; \nelse throw new PropertyException ( target ) ; \n} \ncatch ( Exception e ) { \nthrow new PropertyException ( e ) ; \n} \n} \n} \n"}
{"9476": "public class Namespaces { \npublic static String getLocalName ( Element element ) { \nString name = element . getTagName ( ) ; \nif ( name . indexOf ( ':' ) > 0 ) name = name . substring ( name . indexOf ( ':' ) + 1 ) ; \nreturn name ; \n} \n} \n"}
{"9477": "public class Namespaces { \npublic static String getNamespaceURI ( Node node , String prefix ) { \nif ( node == null || node . getNodeType ( ) != Node . ELEMENT_NODE ) return null ; \nif ( prefix . equals ( \"\" ) ) if ( ( ( Element ) node ) . hasAttribute ( \"xmlns\" ) ) return ( ( Element ) node ) . getAttribute ( \"xmlns\" ) ; \nelse { \nString nsattr = \"xmlns:\" + prefix ; \nif ( ( ( Element ) node ) . hasAttribute ( nsattr ) ) return ( ( Element ) node ) . getAttribute ( nsattr ) ; \n} \nreturn getNamespaceURI ( node . getParentNode ( ) , prefix ) ; \n} \n} \n"}
{"9482": "public class FilePropertyReader { \npublic Map readProperties ( ) throws PropertyException , IOException { \nProperties props = new Properties ( ) ; \nfor ( int i = 0 ; \ni < filenames . length ; \ni ++ ) loadProperties ( props , filenames [ i ] ) ; \nreturn props ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) jar ( files [ i ] , prefix , info ) ; \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) jout . write ( buffer , 0 , len ) ; \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n"}
{"9492": "public class CompoundIterator { \npublic boolean hasNext ( ) { \nfor ( ; \nindex < iters . length ; \nindex ++ ) if ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) return true ; \nreturn false ; \n} \n} \n"}
{"9493": "public class TinyMachine { \npublic void fireEvent ( Object event ) { \nif ( event == null ) throw new IllegalArgumentException ( \"Event must not be null.\" ) ; \nmTaskQueue . offer ( Task . obtainTask ( Task . CODE_FIRE_EVENT , event , - 1 ) ) ; \nif ( ! mQueueProcessed ) processTaskQueue ( ) ; \n} \n} \n"}
{"9494": "public class StructsBatchCompiler { \nprivate void internalInstallJvmTypeProvider ( XtextResourceSet resourceSet , File tmpClassDirectory , boolean skipIndexLookup ) { \nIterable < String > classPathEntries = concat ( getClassPathEntries ( ) , getSourcePathDirectories ( ) , asList ( tmpClassDirectory . toString ( ) ) ) ; \nclassPathEntries = filter ( classPathEntries , new Predicate < String > ( ) { \npublic boolean apply ( String input ) { \nreturn ! Strings . isEmpty ( input . trim ( ) ) ; \n} \n} \n) ; \nFunction < String , URL > toUrl = new Function < String , URL > ( ) { \npublic URL apply ( String from ) { \ntry { \nreturn new File ( from ) . toURI ( ) . toURL ( ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n; \nIterable < URL > classPathUrls = Iterables . transform ( classPathEntries , toUrl ) ; \nlog . debug ( \"classpath used for Struct compilation : \" + classPathUrls ) ; \nClassLoader parentClassLoader ; \nif ( useCurrentClassLoaderAsParent ) parentClassLoader = currentClassLoader ; \nelse if ( isEmpty ( bootClassPath ) ) parentClassLoader = ClassLoader . getSystemClassLoader ( ) . getParent ( ) ; \nelse { \nIterable < URL > bootClassPathUrls = Iterables . transform ( getBootClassPathEntries ( ) , toUrl ) ; \nparentClassLoader = new BootClassLoader ( toArray ( bootClassPathUrls , URL . class ) ) ; \n} \nClassLoader urlClassLoader = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , parentClassLoader ) ; \nnew ClasspathTypeProvider ( urlClassLoader , resourceSet , skipIndexLookup ? null : indexedJvmTypeAccess ) ; \nresourceSet . setClasspathURIContext ( urlClassLoader ) ; \nURLClassLoader urlClassLoaderForAnnotationProcessing = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , currentClassLoader ) ; \nresourceSet . eAdapters ( ) . add ( new ProcessorClassloaderAdapter ( urlClassLoaderForAnnotationProcessing ) ) ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) return true ; \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) if ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \nelse if ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \nif ( deleteParentFolder ) if ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9496": "public class Dispatcher { \npublic void dispatchOnFxThread ( Action action ) { \nif ( Platform . isFxApplicationThread ( ) ) actionStream . push ( action ) ; \nelse Platform . runLater ( ( ) -> actionStream . push ( action ) ) ; \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nint n = 1 ; \nif ( args . length < 1 ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( an != null ) { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nelse { \nusage ( ) ; \nreturn ; \n} \nif ( args . length > 1 ) try { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \nFile path = new File ( args [ 0 ] ) ; \nSystem . out . println ( \"analyzer=\" + analyzer . getClass ( ) . getName ( ) ) ; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \nSystem . out . println ( \"Usage:\" ) ; \nSystem . out . println ( \"\\t-Dmode=simple, defalut is complex\" ) ; \nSystem . out . println ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) seg = new SimpleSeg ( dic ) ; \nelse seg = new ComplexSeg ( dic ) ; \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) bw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . println ( \"use \" + time + \"ms\" ) ; \n} \n} \n"}
{"9507": "public class Chunk { \npublic int getSumDegree ( ) { \nif ( sumDegree < 0 ) { \nint sum = 0 ; \nfor ( Word word : words ) { \nif ( word != null && word . getDegree ( ) > - 1 ) sum += word . getDegree ( ) ; \n} \nsumDegree = sum ; \n} \nreturn sumDegree ; \n} \n} \n"}
{"9508": "public class JdbcStemmerOverrideFilterFactory { \nprivate static Map < String , String > superclassArgs ( Map < String , String > args ) { \nMap < String , String > result = new HashMap < > ( ) ; \nif ( ! result . containsKey ( \"dictionary\" ) ) result . put ( \"dictionary\" , JdbcResourceLoader . DATABASE ) ; \nfor ( String arg : ImmutableList . of ( \"dictionary\" , \"ignoreCase\" ) ) { \nString value = args . get ( arg ) ; \nif ( value != null ) result . put ( arg , value ) ; \n} \nreturn result ; \n} \n} \n"}
{"9510": "public class SimpleJdbcReader { \nprotected final void checkDatasource ( ) { \nif ( dataSource != null ) try ( Connection connection = dataSource . getConnection ( ) ) { \n} \ncatch ( SQLException e ) { \ndataSource = null ; \nlogger . error ( \"Failed to connect to database of data source: {}.\" , e . getMessage ( ) ) ; \nif ( ! ignore ) throw new IllegalArgumentException ( \"Failed to connect to the database.\" , e ) ; \n} \n} \n} \n"}
{"9523": "public class JdbcFixture { \npublic String queryInWithSql ( String database , String sql ) { \nJdbcTemplate template = getDatabaseJdbcTemplate ( database ) ; \nif ( sql != null && ! sql . trim ( ) . toUpperCase ( ) . startsWith ( JdbcFixture . SELECT_COMMAND_PREFIX ) ) return Objects . toString ( template . update ( sql ) ) ; \nList < String > results = template . queryForList ( sql , String . class ) ; \nif ( results == null || results . isEmpty ( ) ) return null ; \nreturn results . get ( 0 ) ; \n} \n} \n"}
{"9524": "public class UBValue { \npublic boolean [ ] asBoolArray ( ) { \nboolean [ ] retval ; \nUBArray array = asArray ( ) ; \nswitch ( array . getStrongType ( ) ) { \ncase Int8 : { \nbyte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) retval [ i ] = data [ i ] > 0 ; \nbreak ; \n} \ncase Int16 : { \nshort [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) retval [ i ] = data [ i ] > 0 ; \nbreak ; \n} \ncase Int32 : { \nint [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) retval [ i ] = data [ i ] > 0 ; \nbreak ; \n} \ncase Int64 : { \nlong [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) retval [ i ] = data [ i ] > 0 ; \nbreak ; \n} \ncase Float32 : { \nfloat [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) retval [ i ] = data [ i ] > 0 ; \nbreak ; \n} \ncase Float64 : { \ndouble [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) retval [ i ] = data [ i ] > 0 ; \nbreak ; \n} \ndefault : throw new RuntimeException ( \"not an int32[] type\" ) ; \n} \nreturn retval ; \n} \n} \n"}
{"9525": "public class Query { \npublic Query < T > byExample ( T obj ) { \nif ( obj != null ) return dao . getTableHelper ( ) . buildFilter ( this , obj ) ; \nreturn this ; \n} \n} \n"}
{"9527": "public class TableHelper { \npublic boolean backup ( SQLiteDatabase db , Context ctx , String suffix ) { \ntry { \nnew CsvTableWriter ( this ) . dumpToCsv ( ctx , db , suffix ) ; \n} \ncatch ( SQLException e ) { \nif ( e . getMessage ( ) . contains ( \"no such table\" ) ) Log . w ( TAG , \"Table \" + this . getTableName ( ) + \" doesn't exist. This is expected if the table is new in this db version.\" ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9529": "public class ContactActivity { \npublic void setEmptyText ( CharSequence emptyText ) { \nif ( mListView != null ) { \nView emptyView = mListView . getEmptyView ( ) ; \nif ( emptyText instanceof TextView ) ( ( TextView ) emptyView ) . setText ( emptyText ) ; \n} \n} \n} \n"}
{"9535": "public class StringUtils { \npublic static String join ( final List < String > list ) { \nif ( list == null ) return null ; \nelse if ( list . size ( ) == 0 ) return \"\" ; \nelse if ( list . size ( ) == 1 ) return list . get ( 0 ) ; \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( builder . length ( ) > 0 ) builder . append ( \", \" ) ; \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9536": "public class StringUtils { \npublic static String join ( final String [ ] list ) { \nif ( list == null ) return null ; \nelse if ( list . length == 0 ) return \"\" ; \nelse if ( list . length == 1 ) return list [ 0 ] ; \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( builder . length ( ) > 0 ) builder . append ( \", \" ) ; \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9539": "public class EntityProcessor { \nprivate void inspectId ( ) { \nif ( entityModel . getIdField ( ) == null ) { \nList < FieldModel > fields = entityModel . getFields ( ) ; \nfor ( FieldModel f : fields ) { \nif ( EntityModel . DEFAULT_ID_FIELD . equals ( f . getFieldName ( ) ) ) entityModel . setIdField ( f ) ; \n} \n} \nFieldModel idField = entityModel . getIdField ( ) ; \nif ( idField != null && \"long\" . equals ( idField . getJavaType ( ) ) ) return ; \nelse abort ( \"Entity must contain a field named id or annotated with @Id of type long\" ) ; \n} \n} \n"}
{"9546": "public class QueryBuilder { \npublic Query createQuery ( final EntityManager manager ) { \nif ( manager == null ) throw new NullPointerException ( \"Entity Manager required\" ) ; \nfinal Query query = manager . createQuery ( render ( ) ) ; \nfor ( Parameter < ? > parameter : parameters ) { \nparameter . apply ( query ) ; \n} \nreturn query ; \n} \n} \n"}
{"9547": "public class QueryBuilder { \npublic < T > TypedQuery < T > createQuery ( final EntityManager manager , Class < T > type ) { \nif ( manager == null ) throw new NullPointerException ( \"Entity Manager required\" ) ; \nTypedQuery < T > result = manager . createQuery ( render ( ) , type ) ; \nfor ( Parameter < ? > parameter : parameters ) { \nparameter . apply ( result ) ; \n} \nreturn result ; \n} \n} \n"}
{"9549": "public class SQLiteDao { \npublic int delete ( Long id ) { \nif ( id != null ) return getWritableDb ( ) . delete ( th . getTableName ( ) , th . getIdCol ( ) + \"=?\" , new String [ ] { \nid . toString ( ) } \n) ; \nreturn 0 ; \n} \n} \n"}
{"9550": "public class SQLiteDao { \npublic long save ( T obj ) { \nif ( th . getId ( obj ) == 0 ) return insert ( obj ) ; \nlong updated = update ( obj ) ; \nif ( updated == 1 ) return 0 ; \nreturn - 1 ; \n} \n} \n"}
{"9555": "public class IntentionStacks { \nStack255 getEmptyIntentionStack ( ) { \nif ( ! stacks . isEmpty ( ) && getActiveStack ( ) . isEmpty ( ) ) return getActiveStack ( ) ; \nStack255 stack = new Stack255 ( ( byte ) 8 , ( byte ) 2 ) ; \nstacks . push ( stack ) ; \nreturn stack ; \n} \n} \n"}
{"9556": "public class PlanBindings { \npublic void add ( Plan plan , Set < Belief > planBindings ) { \nif ( plan == null ) return ; \nif ( this . bindings . containsKey ( plan ) ) { \nSet < Belief > oldBindings = this . bindings . remove ( plan ) ; \nif ( oldBindings == null || oldBindings . isEmpty ( ) ) cachedsize -- ; \nelse cachedsize -= oldBindings . size ( ) ; \n} \nthis . bindings . put ( plan , planBindings ) ; \nif ( planBindings == null || planBindings . isEmpty ( ) ) cachedsize ++ ; \nelse cachedsize += planBindings . size ( ) ; \n} \n} \n"}
{"9559": "public class PlanBindings { \nprivate final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { \nif ( agent == null || planInstance == null ) return ; \nBelief belief = getResultAtIndex ( results , choice ) ; \nif ( belief == null ) return ; \nObject [ ] tuple = belief . getTuple ( ) ; \nif ( tuple == null ) return ; \nint index = 0 ; \nHashMap < String , Object > vars = new HashMap < String , Object > ( ) ; \nfor ( Object o : belief . getTuple ( ) ) { \ntry { \nString fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; \nvars . put ( fieldname , o ) ; \n} \ncatch ( BeliefBaseException e ) { \nLog . error ( \"Agent \" + agent . getId ( ) + \" could not retrive belief set field: \" + e . getMessage ( ) ) ; \n} \nindex ++ ; \n} \nplanInstance . setPlanVariables ( vars ) ; \n} \n} \n"}
{"9561": "public class GoalPlanType { \npublic byte [ ] getParents ( ) { \nif ( parents == null ) return null ; \nbyte [ ] arr = new byte [ parents . length ] ; \nSystem . arraycopy ( parents , 0 , arr , 0 , arr . length ) ; \nreturn arr ; \n} \n} \n"}
{"9562": "public class GoalPlanType { \npublic byte [ ] getChildren ( ) { \nif ( children == null ) return null ; \nbyte [ ] arr = new byte [ children . length ] ; \nSystem . arraycopy ( children , 0 , arr , 0 , arr . length ) ; \nreturn arr ; \n} \n} \n"}
{"9563": "public class GoalPlanType { \npublic static byte [ ] grow ( byte [ ] bytes , int increment ) { \nif ( bytes == null ) return new byte [ 1 ] ; \nbyte [ ] temp = new byte [ bytes . length + increment ] ; \nSystem . arraycopy ( bytes , 0 , temp , 0 , bytes . length ) ; \nreturn temp ; \n} \n} \n"}
{"9565": "public class Plan { \npublic void step ( ) { \nif ( body == null || body . length == 0 || index < 0 || index >= body . length ) return ; \nbody [ index ++ ] . step ( ) ; \n} \n} \n"}
{"9569": "public class Program { \nstatic void initIntentionSelectionThreads ( Config config ) { \nint ncores = config . getNumThreads ( ) ; \nMain . intentionSelectors = new IntentionSelector [ ncores ] ; \nfor ( int i = 0 ; \ni < Main . npools ; \ni ++ ) Main . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; \n} \n} \n"}
{"9571": "public class Program { \nstatic void shutdownIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \ni < Main . npools ; \ni ++ ) Main . intentionSelectors [ i ] . shutdown ( ) ; \n} \n} \n"}
{"9572": "public class Program { \npublic static void registerExtension ( JillExtension extension ) { \nif ( extension != null ) { \nGlobalState . eventHandlers . add ( extension ) ; \nMain . logger . info ( \"Registered Jill extension: \" + extension ) ; \n} \nelse Main . logger . warn ( \"Cannot register null extension; will ignore.\" ) ; \n} \n} \n"}
{"9574": "public class ProgramLoader { \npublic static boolean loadAgent ( String className , int num , AObjectCatalog agents ) { \nClass < ? > aclass = loadClass ( className , Agent . class ) ; \nif ( aclass == null ) return false ; \nAgentType atype = new AgentType ( className ) ; \natype . setAgentClass ( aclass ) ; \nGlobalState . agentTypes . push ( atype ) ; \nString [ ] goals = getGoalsFromAgentInfoAnnotation ( aclass ) ; \nif ( goals . length == 0 ) return false ; \nloadGoalPlanNodes ( atype , goals ) ; \ncompleteGoalPlanHierarchy ( ) ; \ncreateAgentsInCatalog ( agents , atype , aclass , num ) ; \nreturn true ; \n} \n} \n"}
{"9575": "public class ProgramLoader { \nprivate static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { \nfor ( int j = 0 ; \nj < plans . length ; \nj ++ ) { \nClass < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; \nif ( pclass == null ) return false ; \nlogger . info ( \"Found Plan \" + pclass . getName ( ) + \" that handles Goal \" + gtype . getName ( ) ) ; \nPlanType ptype = new PlanType ( pclass . getName ( ) ) ; \nptype . setPlanClass ( pclass ) ; \nGlobalState . planTypes . push ( ptype ) ; \nptype . addParent ( ( byte ) gtype . getId ( ) ) ; \ngtype . addChild ( ( byte ) ptype . getId ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) return false ; \nfor ( int i = 0 ; \ni < obj1 . name . length ; \ni ++ ) if ( obj1 . name [ i ] != obj2 . name [ i ] ) return false ; \nreturn true ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && i < args . length ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) abort ( null ) ; \nif ( i + 1 < args . length ) parseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \nif ( config == null ) abort ( \"Configuration file or string was not given\" ) ; \nelse if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) abort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n"}
{"9584": "public class AObjectCatalog { \npublic AObject get ( int index ) { \nif ( index >= 0 && index < objects . length ) return objects [ index ] ; \nreturn null ; \n} \n} \n"}
{"9585": "public class AObjectCatalog { \npublic AObject find ( String name ) { \nfor ( int i = 0 ; \ni < nextid ; \ni ++ ) if ( objects [ i ] . getName ( ) . equals ( name ) ) return objects [ i ] ; \nreturn null ; \n} \n} \n"}
{"9586": "public class AObjectCatalog { \npublic void push ( AObject obj ) { \nif ( obj == null || obj . getId ( ) != GlobalConstant . NULLID ) return ; \nif ( nextid == objects . length ) grow ( ) ; \nobj . setId ( nextid ) ; \nobjects [ nextid ++ ] = obj ; \n} \n} \n"}
{"9587": "public class Stack255 { \npublic Object get ( int idx ) { \nint index = idx & 0xff ; \nif ( isEmpty ( ) ) return null ; \nelse if ( index < 0 || index >= size ) return null ; \nreturn objects [ index ] ; \n} \n} \n"}
{"9588": "public class Stack255 { \npublic boolean push ( Object obj ) { \nif ( isFull ( ) ) return false ; \nif ( size == objects . length ) grow ( ) ; \nobjects [ size ++ ] = obj ; \nreturn true ; \n} \n} \n"}
{"9589": "public class Stack255 { \npublic Object pop ( ) { \nif ( isEmpty ( ) ) return null ; \nsize -- ; \nObject obj = objects [ size ] ; \nobjects [ size ] = null ; \nreturn obj ; \n} \n} \n"}
{"9590": "public class ABeliefStore { \npublic static String getType ( Object obj ) { \nif ( obj == null ) return null ; \nString type = null ; \nif ( obj instanceof String || obj instanceof Integer || obj instanceof Double || obj instanceof Boolean ) type = obj . getClass ( ) . getName ( ) ; \nreturn type ; \n} \n} \n"}
{"9591": "public class ABeliefStore { \nprivate static boolean match ( Belief belief , AQuery query ) { \nassert ( belief != null ) ; \nassert ( query != null ) ; \nif ( belief . getBeliefset ( ) != query . getBeliefset ( ) ) return false ; \nswitch ( query . getOp ( ) ) { \ncase EQ : Object lhs = belief . getTuple ( ) [ query . getField ( ) ] ; \nObject rhs = query . getValue ( ) ; \nreturn \"*\" . equals ( rhs ) || lhs . equals ( rhs ) ; \ncase GT : case LT : default : break ; \n} \nreturn false ; \n} \n} \n"}
{"9592": "public class ABeliefStore { \npublic static void main ( String [ ] args ) throws BeliefBaseException { \nBeliefBase bb = new ABeliefStore ( 100 , 4 ) ; \nbb . eval ( 0 , \"neighbour.age < 31\" ) ; \nConsole console = System . console ( ) ; \nif ( console == null ) { \nSystem . err . println ( \"No console.\" ) ; \nSystem . exit ( 1 ) ; \n} \nwhile ( true ) { \nPattern pattern = Pattern . compile ( console . readLine ( \"%nEnter your regex: \" ) ) ; \nMatcher matcher = pattern . matcher ( console . readLine ( \"Enter input string to search: \" ) ) ; \nboolean found = false ; \nwhile ( matcher . find ( ) ) { \nconsole . format ( \"I found the text\" + \" \\\"%s\\\" starting at \" + \"index %d and ending at index %d.%n\" , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; \nfound = true ; \n} \nif ( ! found ) console . format ( \"No match found.%n\" ) ; \n} \n} \n} \n"}
{"9593": "public class AString { \npublic static byte [ ] toBytes ( String str ) { \nif ( str == null ) return new byte [ 0 ] ; \nbyte [ ] val = null ; \ntry { \nval = str . getBytes ( CHARSET ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \n} \nreturn val ; \n} \n} \n"}
{"9602": "public class BeliefSet { \npublic BeliefSetField getFieldByName ( String name ) { \nBeliefSetField field = null ; \nfor ( int i = 0 ; \ni < fields . length ; \ni ++ ) if ( name . equals ( fields [ i ] . getName ( ) ) ) { \nfield = fields [ i ] ; \nbreak ; \n} \nreturn field ; \n} \n} \n"}
{"9605": "public class IntentionSelector { \npublic void run ( ) { \nSet < Integer > toRemove = new HashSet < Integer > ( ) ; \ndo { \nboolean idle = true ; \nremoveInactiveAgents ( ) ; \naddActiveAgents ( ) ; \nfor ( Integer i : activeAgents ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nStack255 agentExecutionStack = ( Stack255 ) ( agent ) . getExecutionStack ( ) ; \nif ( ! isStackValid ( agent , agentExecutionStack ) ) { \ntoRemove . add ( i ) ; \ncontinue ; \n} \nidle = false ; \nObject node = ( Object ) agentExecutionStack . get ( ( byte ) ( agentExecutionStack . size ( ) - 1 ) ) ; \nif ( node instanceof Plan ) managePlan ( i , agentExecutionStack , ( Plan ) node , toRemove ) ; \nelse if ( node instanceof Goal ) manageGoal ( i , agent , agentExecutionStack , ( Goal ) node ) ; \nagent . nextActiveStack ( ) ; \n} \nremoveFinishedAgents ( toRemove ) ; \nif ( idle ) { \nwaitOnExternalMessage ( ) ; \nif ( shutdown ) break ; \n} \n} \nwhile ( true ) ; \nlogger . debug ( \"Pool {} is exiting\" , poolid ) ; \n} \n} \n"}
{"9606": "public class IntentionSelector { \nprivate boolean isStackValid ( Agent agent , Stack255 agentExecutionStack ) { \nif ( agentExecutionStack == null ) return false ; \nfinal int esSize = agentExecutionStack . size ( ) ; \nlogger . trace ( \"{} execution stack is {}/255 full\" , Log . logPrefix ( agent . getId ( ) ) , esSize ) ; \nif ( esSize == 0 ) return false ; \nif ( esSize >= 255 ) { \nlogger . error ( \"{} execution stack reached size limit of 255. Cannot continue.\" , Log . logPrefix ( agent . getId ( ) ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9610": "public class IntentionSelector { \npublic void setAgentIdle ( int agentId , boolean idle ) { \nif ( ! idle ) synchronized ( extToAdd ) { \nextToAdd . add ( agentId ) ; \n} \nif ( idle ) synchronized ( extToRemove ) { \nextToRemove . add ( agentId ) ; \n} \n} \n} \n"}
{"9612": "public class Main { \npublic static boolean init ( Config config ) { \nif ( config . isDoPauseForUserInput ( ) ) Program . pauseForUserInput ( ) ; \nLog . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; \nlogger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; \nint numAgents = 0 ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nnumAgents += agentType . getCount ( ) ; \n} \nfinal int increment = 10000 ; \nGlobalState . reset ( ) ; \nGlobalState . agents = new AObjectCatalog ( \"agents\" , numAgents , increment ) ; \nGlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; \nlong t0 ; \nt0 = System . currentTimeMillis ( ) ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nif ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) return false ; \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Created \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nProgram . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; \nif ( config . getProgramOutputFile ( ) != null ) try { \nwriter = new PrintStream ( config . getProgramOutputFile ( ) , \"UTF-8\" ) ; \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nlogger . error ( \"Could not open program outout file \" + config . getProgramOutputFile ( ) , e ) ; \n} \nelse writer = System . out ; \nProgram . initIntentionSelectionThreads ( config ) ; \nreturn true ; \n} \n} \n"}
{"9613": "public class Main { \npublic static void waitUntilIdle ( ) { \nlong t0 = System . currentTimeMillis ( ) ; \nsynchronized ( poolsIdle ) { \nwhile ( ! arePoolsIdle ( ) ) try { \npoolsIdle . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nlogger . error ( \"Failed to wait on termination condition: \" + e . getMessage ( ) ) ; \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Finished running \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9614": "public class Main { \npublic static void finish ( ) { \nfor ( JillExtension extension : GlobalState . eventHandlers ) { \nextension . finish ( ) ; \n} \nProgram . shutdownIntentionSelectionThreads ( ) ; \nlong t0 = System . currentTimeMillis ( ) ; \nfor ( int i = 0 ; \ni < GlobalState . agents . size ( ) ; \ni ++ ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nagent . finish ( ) ; \n} \nif ( writer != null ) writer . close ( ) ; \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Terminated \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9615": "public class Main { \npublic static boolean arePoolsIdle ( ) { \nboolean idle = true ; \nfor ( int i = 0 ; \ni < npools ; \ni ++ ) idle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; \nreturn idle ; \n} \n} \n"}
{"9616": "public class Main { \npublic static int poolid ( int agentid ) { \nint poolid = agentid / poolsize ; \nif ( poolid + 1 > npools ) poolid = npools - 1 ; \nreturn poolid ; \n} \n} \n"}
{"9619": "public class JpaUtils { \npublic static Expression < ? > join ( String attribute , From < ? , ? > from ) { \nExpression < ? > path ; \ntry { \nString [ ] properties = attribute . split ( \"\\\\.\" ) ; \nif ( properties . length > 1 ) path = joinRecursively ( properties , findOrCreateJoin ( properties [ 0 ] , from ) , 1 ) . get ( properties [ properties . length - 1 ] ) ; \nelse path = from . get ( properties [ 0 ] ) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow SeedException . wrap ( e , JpaErrorCode . UNABLE_TO_CREATE_JPA_JOIN_FOR_SPECIFICATION ) . put ( \"property\" , attribute ) ; \n} \nreturn path ; \n} \n} \n"}
{"9620": "public class JpaUtils { \nprivate static Join < ? , ? > joinRecursively ( String [ ] properties , Join < ? , ? > join , int index ) { \nif ( index < properties . length - 1 ) return joinRecursively ( properties , findOrCreateJoin ( properties [ index ] , join ) , index + 1 ) ; \nelse return join ; \n} \n} \n"}
{"9621": "public class JpaUtils { \nprivate static Join < ? , ? > findOrCreateJoin ( String property , From < ? , ? > from ) { \nfor ( Join < ? , ? > rootJoin : from . getJoins ( ) ) { \nif ( rootJoin . getAttribute ( ) . getName ( ) . equals ( property ) ) return rootJoin ; \n} \nreturn from . join ( property ) ; \n} \n} \n"}
{"9622": "public class PartialResponse { \npublic boolean isEndReached ( ) { \nif ( to == null || from == null ) return true ; \nif ( length == null ) return false ; \nreturn to == length - 1 ; \n} \n} \n"}
{"9623": "public class MultipartFormArgumentsReader { \nprivate static UploadStream getUploadStream ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException { \nFormIterator form = new FormIteratorImpl ( httpRequest ) ; \nif ( ! form . hasNext ( ) ) throw new IllegalArgumentException ( \"Empty form.\" ) ; \nPart part = form . next ( ) ; \nif ( ! ( part instanceof UploadStream ) ) throw new IllegalArgumentException ( \"Illegal form. Expected uploaded stream but got field |%s|.\" , part . getName ( ) ) ; \nreturn ( UploadStream ) part ; \n} \n} \n"}
{"9624": "public class RestServlet { \n@ Override protected void handleRequest ( RequestContext context ) throws IOException { \nHttpServletRequest httpRequest = context . getRequest ( ) ; \nHttpServletResponse httpResponse = context . getResponse ( ) ; \nArgumentsReader argumentsReader = null ; \nObject value = null ; \nManagedMethodSPI method = null ; \ntry { \nmethod = restMethods . get ( key ( httpRequest . getPathInfo ( ) ) ) ; \nif ( method == null ) throw new NoSuchMethodException ( ) ; \nType [ ] formalParameters = method . getParameterTypes ( ) ; \nargumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; \nObject [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; \nObject instance = container . getInstance ( method . getDeclaringClass ( ) ) ; \nvalue = method . invoke ( instance , arguments ) ; \n} \ncatch ( AuthorizationException e ) { \nsendUnauthorized ( context ) ; \nreturn ; \n} \ncatch ( NoSuchMethodException e ) { \nsendNotFound ( context , e ) ; \nreturn ; \n} \ncatch ( IllegalArgumentException e ) { \nsendBadRequest ( context ) ; \nreturn ; \n} \ncatch ( InvocationException e ) { \nsendError ( context , e ) ; \nreturn ; \n} \nfinally { \nif ( argumentsReader != null ) argumentsReader . clean ( ) ; \n} \nhttpResponse . setCharacterEncoding ( \"UTF-8\" ) ; \nif ( method . isVoid ( ) ) { \nhttpResponse . setStatus ( HttpServletResponse . SC_NO_CONTENT ) ; \nreturn ; \n} \nContentType contentType = valueWriterFactory . getContentTypeForValue ( value ) ; \nhttpResponse . setStatus ( HttpServletResponse . SC_OK ) ; \nhttpResponse . setContentType ( contentType . getValue ( ) ) ; \nValueWriter valueWriter = valueWriterFactory . getValueWriter ( contentType ) ; \nvalueWriter . write ( httpResponse , value ) ; \n} \n} \n"}
{"9627": "public class ContentType { \nprivate static Map < String , String > parseParameters ( String expression ) { \nMap < String , String > parameters = new HashMap < > ( ) ; \nint parametersSeparatorIndex = 0 ; \nfor ( ; \n; \n) { \nint valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; \nif ( valueSeparatorIndex == - 1 ) break ; \nString name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; \n++ valueSeparatorIndex ; \nparametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; \nif ( parametersSeparatorIndex == - 1 ) parametersSeparatorIndex = expression . length ( ) ; \nif ( valueSeparatorIndex == parametersSeparatorIndex ) throw new SyntaxException ( \"Invalid content type parameters |%s|. Value is empty.\" , expression ) ; \nif ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) throw new SyntaxException ( \"Invalid content type parameters |%s|. Name override |%s|.\" , expression , name ) ; \n++ parametersSeparatorIndex ; \n} \nif ( parameters . isEmpty ( ) ) throw new SyntaxException ( \"Invalid content type parameters |%s|. Missing name/value separator.\" , expression ) ; \nreturn parameters ; \n} \n} \n"}
{"9629": "public class AbstractGenerator { \nprotected final GeneratedFile getTargetFile ( final String artifactName , final String filename , final String logInfo ) { \nfinal Folder folder = getGeneratorConfig ( ) . findTargetFolder ( artifactName ) ; \nfinal File dir = folder . getCanonicalDir ( ) ; \nfinal File file = new File ( dir , filename ) ; \nif ( ! dir . exists ( ) ) if ( folder . isCreate ( ) ) dir . mkdirs ( ) ; \nelse throw new IllegalStateException ( \"Directory '\" + dir + \"' does not exist, but configuration does not allow creation: \" + \"<folder name=\\\"\" + folder . getName ( ) + \"\\\" create=\\\"false\\\" ... />\" ) ; \nif ( ! file . getParentFile ( ) . exists ( ) ) file . getParentFile ( ) . mkdirs ( ) ; \nif ( file . exists ( ) && ! folder . overrideAllowed ( file ) ) return new GeneratedFile ( file , logInfo , true ) ; \nreturn new GeneratedFile ( file , logInfo ) ; \n} \n} \n"}
{"9630": "public class AbstractGenerator { \nprotected final void write ( @ NotNull final GeneratedArtifact artifact ) throws GenerateException { \nContract . requireArgNotNull ( \"artifact\" , artifact ) ; \nfinal GeneratedFile genFile = getTargetFile ( artifact . getName ( ) , artifact . getPathAndName ( ) , null ) ; \nif ( genFile . isSkip ( ) ) LOG . debug ( \"Omitted already existing file: {} [{}]\" , genFile , artifact ) ; \nelse { \nLOG . debug ( \"Writing file:  {} [{}]\" , genFile , artifact ) ; \ntry { \nfinal OutputStream out = new BufferedOutputStream ( new FileOutputStream ( genFile . getTmpFile ( ) ) ) ; \ntry { \nout . write ( artifact . getData ( ) ) ; \n} \nfinally { \nout . close ( ) ; \n} \ngenFile . persist ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new GenerateException ( \"Error writing artifact '\" + artifact + \"' to '\" + artifact . getPathAndName ( ) + \"'!\" , ex ) ; \n} \n} \n} \n} \n"}
{"9631": "public class InstanceFieldsInitializationProcessor { \n@ Override public void postProcessInstance ( ManagedClassSPI managedClass , Object instance ) { \nConfig config = managedClass . getConfig ( ) ; \nif ( config == null ) return ; \nList < Config > fields = config . findChildren ( \"instance-field\" ) ; \nif ( ! fields . isEmpty ( ) && ! InstanceType . POJO . equals ( managedClass . getInstanceType ( ) ) ) throw new BugError ( \"Cannot assign instance field on non %s type.\" , InstanceType . POJO ) ; \nfor ( Config field : fields ) { \nClasses . setFieldValue ( instance , field . getAttribute ( \"name\" ) , field . getAttribute ( \"value\" ) ) ; \n} \n} \n} \n"}
{"9632": "public class ManagedClass { \nprivate static Constructor < ? > getDeclaredConstructor ( Class < ? > implementationClass ) { \nif ( implementationClass == null ) return null ; \nConstructor < ? > [ ] declaredConstructors = ( Constructor < ? > [ ] ) implementationClass . getDeclaredConstructors ( ) ; \nif ( declaredConstructors . length == 0 ) throw new BugError ( \"Invalid implementation class |%s|. Missing constructor.\" , implementationClass ) ; \nConstructor < ? > constructor = null ; \nfor ( Constructor < ? > declaredConstructor : declaredConstructors ) { \nif ( declaredConstructor . isSynthetic ( ) ) continue ; \nif ( declaredConstructor . getParameterTypes ( ) . length == 0 ) continue ; \nif ( declaredConstructor . getAnnotation ( Test . class ) != null ) continue ; \nif ( constructor != null ) throw new BugError ( \"Implementation class |%s| has not a single constructor with parameters.\" , implementationClass ) ; \nconstructor = declaredConstructor ; \n} \nif ( constructor == null ) constructor = declaredConstructors [ 0 ] ; \nconstructor . setAccessible ( true ) ; \nreturn constructor ; \n} \n} \n"}
{"9635": "public class FormObject { \nprivate static Class < ? > type ( Field field ) { \nif ( Types . isKindOf ( field . getType ( ) , List . class ) ) return ( Class < ? > ) ( ( ParameterizedType ) field . getGenericType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; \nreturn field . getType ( ) ; \n} \n} \n"}
{"9636": "public class DependencyProcessor { \n@ SuppressWarnings ( \"unchecked\" ) protected static Object getDependencyValue ( ManagedClassSPI hostManagedClass , Class < ? > type ) { \nStack < Class < ? > > stackTrace = dependenciesStack . get ( ) ; \nif ( stackTrace == null ) { \nstackTrace = new Stack < > ( ) ; \ndependenciesStack . set ( stackTrace ) ; \n} \nContainerSPI container = hostManagedClass . getContainer ( ) ; \nif ( stackTrace . contains ( type ) ) try { \nstackTrace . add ( type ) ; \nStringBuilder builder = new StringBuilder ( ) ; \nbuilder . append ( \"Circular dependency. Dependencies trace follows:\\r\\n\" ) ; \nfor ( Class < ? > stackTraceClass : stackTrace ) { \nbuilder . append ( \"\\t- \" ) ; \nbuilder . append ( stackTraceClass . getName ( ) ) ; \nbuilder . append ( \"\\r\\n\" ) ; \n} \nlog . error ( builder . toString ( ) ) ; \nthrow new BugError ( \"Circular dependency for |%s|.\" , type . getName ( ) ) ; \n} \nfinally { \ndependenciesStack . remove ( ) ; \n} \nstackTrace . push ( type ) ; \ntry { \nManagedClassSPI dependencyManagedClass = container . getManagedClass ( type ) ; \nif ( isProxyRequired ( hostManagedClass , dependencyManagedClass ) ) { \nScopeProxyHandler < ? > handler = new ScopeProxyHandler < > ( container , type ) ; \nreturn Proxy . newProxyInstance ( dependencyManagedClass . getImplementationClass ( ) . getClassLoader ( ) , dependencyManagedClass . getInterfaceClasses ( ) , handler ) ; \n} \nObject value = container . getOptionalInstance ( ( Class < ? super Object > ) type ) ; \nif ( value != null ) return value ; \nif ( Types . isKindOf ( type , AppFactory . class ) ) return container ; \nif ( Classes . isInstantiable ( type ) ) return Classes . newInstance ( type ) ; \nthrow new BugError ( \"Dependency |%s| not resolved for |%s|.\" , type . getName ( ) , hostManagedClass ) ; \n} \nfinally { \nstackTrace . pop ( ) ; \n} \n} \n} \n"}
{"9637": "public class GeneratedFile { \npublic final void persist ( ) { \nif ( persisted ) return ; \ntry { \nif ( FileUtils . contentEquals ( tmpFile , file ) ) { \nLOG . debug ( \"Omitted: {} {}\" , getPath ( ) , logInfo ) ; \nif ( ! tmpFile . delete ( ) ) tmpFile . deleteOnExit ( ) ; \n} \nelse { \nif ( file . exists ( ) && ! file . delete ( ) ) throw new IOException ( \"Wasn't able to delete file \" + file ) ; \nif ( ! tmpFile . renameTo ( file ) ) throw new IOException ( \"Wasn't able to rename temporary file \" + tmpFile + \" to \" + file ) ; \nLOG . info ( \"Generated: {} {}\" , getPath ( ) , logInfo ) ; \n} \npersisted = true ; \n} \ncatch ( final IOException ex ) { \nthrow new RuntimeException ( \"Error comparing content: tmp=\" + tmpFile + \", target=\" + file + logInfo , ex ) ; \n} \n} \n} \n"}
{"9638": "public class AbstractEndpoint { \npublic final void setDefaultLink ( String rel , String ... hrefs ) { \nif ( hrefs == null || hrefs . length == 0 ) defaultLinks . remove ( rel ) ; \nelse defaultLinks . put ( rel , stream ( hrefs ) . map ( uri :: resolve ) . collect ( toSet ( ) ) ) ; \n} \n} \n"}
{"9639": "public class AbstractEndpoint { \npublic final void setDefaultLinkTemplate ( String rel , String href ) { \nif ( href == null ) defaultLinkTemplates . remove ( rel ) ; \nelse defaultLinkTemplates . put ( rel , href ) ; \n} \n} \n"}
{"9640": "public class AbstractEndpoint { \n@ SuppressWarnings ( \"LocalVariableHidesMemberVariable\" ) private void handleLinks ( HttpResponse response ) { \nMap < String , Map < URI , String > > links = new HashMap < > ( ) ; \nMap < String , String > linkTemplates = new HashMap < > ( ) ; \nhandleHeaderLinks ( response , links , linkTemplates ) ; \nHttpEntity entity = response . getEntity ( ) ; \nif ( entity != null ) { \nHeader contentType = entity . getContentType ( ) ; \nif ( ( contentType != null ) && contentType . getValue ( ) . startsWith ( \"application/json\" ) ) try { \nhandleBodyLinks ( serializer . readTree ( entity . getContent ( ) ) , links , linkTemplates ) ; \n} \ncatch ( IOException ex ) { \nthrow new RuntimeException ( ) ; \n} \n} \nthis . links = unmodifiableMap ( links ) ; \nthis . linkTemplates = unmodifiableMap ( linkTemplates ) ; \n} \n} \n"}
{"9641": "public class AbstractEndpoint { \nprotected void handleHeaderLinks ( HttpResponse response , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { \ngetLinkHeaders ( response ) . forEach ( header -> { \nif ( header . getRel ( ) == null ) return ; \nif ( header . isTemplated ( ) ) linkTemplates . put ( header . getRel ( ) , header . getHref ( ) ) ; \nelse getOrAdd ( links , header . getRel ( ) ) . put ( uri . resolve ( header . getHref ( ) ) , header . getTitle ( ) ) ; \n} \n) ; \n} \n} \n"}
{"9642": "public class AbstractEndpoint { \nprotected void handleBodyLinks ( JsonNode jsonBody , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { \nif ( jsonBody . getNodeType ( ) != JsonNodeType . OBJECT ) return ; \nJsonNode linksNode = jsonBody . get ( \"_links\" ) ; \nif ( linksNode == null ) linksNode = jsonBody . get ( \"links\" ) ; \nif ( linksNode == null ) return ; \nlinksNode . fields ( ) . forEachRemaining ( x -> { \nString rel = x . getKey ( ) ; \nMap < URI , String > linksForRel = getOrAdd ( links , rel ) ; \nswitch ( x . getValue ( ) . getNodeType ( ) ) { \ncase ARRAY : x . getValue ( ) . forEach ( subobj -> { \nif ( subobj . getNodeType ( ) == JsonNodeType . OBJECT ) parseLinkObject ( rel , ( ObjectNode ) subobj , linksForRel , linkTemplates ) ; \n} \n) ; \nbreak ; \ncase OBJECT : parseLinkObject ( rel , ( ObjectNode ) x . getValue ( ) , linksForRel , linkTemplates ) ; \nbreak ; \n} \n} \n) ; \n} \n} \n"}
{"9643": "public class AbstractEndpoint { \nprivate void parseLinkObject ( String rel , ObjectNode obj , Map < URI , String > linksForRel , Map < String , String > linkTemplates ) { \nJsonNode href = obj . findValue ( \"href\" ) ; \nif ( href == null ) return ; \nJsonNode templated = obj . findValue ( \"templated\" ) ; \nif ( templated != null && templated . isBoolean ( ) && templated . asBoolean ( ) ) linkTemplates . put ( rel , href . asText ( ) ) ; \nelse { \nJsonNode title = obj . findValue ( \"title\" ) ; \nlinksForRel . put ( uri . resolve ( href . asText ( ) ) , ( title != null && title . getNodeType ( ) == JsonNodeType . STRING ) ? title . asText ( ) : null ) ; \n} \n} \n} \n"}
{"9644": "public class AbstractEndpoint { \nprivate static Map < URI , String > getOrAdd ( Map < String , Map < URI , String > > map , String key ) { \nMap < URI , String > value = map . get ( key ) ; \nif ( value == null ) map . put ( key , value = new HashMap < > ( ) ) ; \nreturn value ; \n} \n} \n"}
{"9646": "public class AbstractEndpoint { \nprotected Optional < Boolean > isMethodAllowed ( String method ) { \nif ( allowedMethods . isEmpty ( ) ) return Optional . empty ( ) ; \nreturn Optional . of ( allowedMethods . contains ( method ) ) ; \n} \n} \n"}
{"9648": "public class Container { \nprotected void registerInstanceFactory ( InstanceType instanceType , InstanceFactory instanceFactory ) { \nlog . debug ( \"Register instance factory |%s| to |%s|.\" , instanceFactory . getClass ( ) , instanceType ) ; \nif ( instanceFactories . put ( instanceType , instanceFactory ) != null ) throw new BugError ( \"Attempt to override instance type |%s|.\" , instanceType ) ; \n} \n} \n"}
{"9649": "public class Container { \nprotected void registerInstanceProcessor ( InstanceProcessor instanceProcessor ) { \nfor ( InstanceProcessor existingInstanceProcessoor : instanceProcessors ) { \nif ( existingInstanceProcessoor . getClass ( ) . equals ( instanceProcessor . getClass ( ) ) ) throw new BugError ( \"Attempt to override instance processor |%s|.\" , instanceProcessor . getClass ( ) ) ; \n} \nlog . debug ( \"Register instance processor |%s|.\" , instanceProcessor . getClass ( ) ) ; \ninstanceProcessors . add ( instanceProcessor ) ; \n} \n} \n"}
{"9650": "public class Container { \nprotected void registerClassProcessor ( ClassProcessor classProcessor ) { \nfor ( ClassProcessor existingClassProcessoor : classProcessors ) { \nif ( existingClassProcessoor . getClass ( ) . equals ( classProcessor . getClass ( ) ) ) throw new BugError ( \"Attempt to override class processor |%s|.\" , classProcessor . getClass ( ) ) ; \n} \nlog . debug ( \"Register class processor |%s|.\" , classProcessor . getClass ( ) ) ; \nclassProcessors . add ( classProcessor ) ; \n} \n} \n"}
{"9651": "public class Container { \n@ Override public < T > T getInstance ( Class < ? super T > interfaceClass , Object ... args ) { \nParams . notNull ( interfaceClass , \"Interface class\" ) ; \nManagedClassSPI managedClass = classesPool . get ( interfaceClass ) ; \nif ( managedClass == null ) throw new BugError ( \"No managed class associated with interface class |%s|.\" , interfaceClass ) ; \nInstanceKey instanceKey = new InstanceKey ( managedClass . getKey ( ) ) ; \nreturn getInstance ( managedClass , instanceKey , args ) ; \n} \n} \n"}
{"9652": "public class ParameterizedTemplateModel { \npublic final void addArgument ( @ NotNull final Argument argument ) { \nif ( arguments == null ) arguments = new ArrayList < Argument > ( ) ; \narguments . add ( argument ) ; \n} \n} \n"}
{"9655": "public class ParameterizedTemplateModel { \npublic final void init ( final SrcGen4JContext context , final Map < String , String > vars ) { \nif ( template != null ) template = Utils4J . replaceVars ( template , vars ) ; \nif ( arguments != null ) for ( final Argument argument : arguments ) { \nargument . init ( vars ) ; \n} \nif ( targetFiles != null ) for ( final TargetFile targetFile : targetFiles ) { \ntargetFile . init ( vars ) ; \n} \nif ( tflProducerConfig != null ) tflProducerConfig . init ( context , this , vars ) ; \n} \n} \n"}
{"9666": "public class MultipartMixedArgumentsReader { \n@ Override public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { \ntry { \nObject [ ] arguments = new Object [ formalParameters . length ] ; \nint argumentIndex = 0 ; \nServletFileUpload multipart = new ServletFileUpload ( ) ; \nFileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; \nFileItemStream fileItemStream = null ; \nwhile ( iterator . hasNext ( ) ) { \nfileItemStream = iterator . next ( ) ; \nString contentType = fileItemStream . getContentType ( ) ; \nType parameterType = formalParameters [ argumentIndex ] ; \nArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; \nboolean streamArgument = StreamFactory . isStream ( parameterType ) ; \nArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; \nInputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; \narguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; \n++ argumentIndex ; \nif ( streamArgument ) { \nthreadLocal . set ( inputStream ) ; \nbreak ; \n} \ninputStream . close ( ) ; \n} \nif ( argumentIndex != formalParameters . length ) throw new IllegalArgumentException ( \"Not all parameters processed due to stream argument that is not the last on arguments list.\" ) ; \nreturn arguments ; \n} \ncatch ( FileUploadException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9667": "public class AbstractEMFParser { \nprotected final void parseModel ( ) { \nif ( ( fileExtensions == null ) || ( fileExtensions . size ( ) == 0 ) ) throw new IllegalStateException ( \"No file extensions for EMF model files set!\" ) ; \nresourceSet = new ResourceSetImpl ( ) ; \nerror = false ; \nparseDirs ( ) ; \nparseResources ( ) ; \n} \n} \n"}
{"9668": "public class AbstractEMFParser { \nprotected final void resolveProxies ( ) { \nfinal List < String > unresolved = new ArrayList < String > ( ) ; \nif ( ! resolvedAllProxies ( unresolved , 0 ) ) { \nLOG . warn ( \"Could not resolve the following proxies ({}):\" , unresolved . size ( ) ) ; \nfor ( final String ref : unresolved ) { \nLOG . warn ( \"Not found: {}\" , ref ) ; \n} \nfinal Iterator < Notifier > it = resourceSet . getAllContents ( ) ; \nwhile ( it . hasNext ( ) ) { \nfinal Notifier next = it . next ( ) ; \nif ( next instanceof EObject ) { \nfinal EObject obj = ( EObject ) next ; \nif ( obj . eIsProxy ( ) ) try { \nit . remove ( ) ; \n} \ncatch ( final UnsupportedOperationException ex ) { \nLOG . error ( \"Could not remove proxy: \" + obj , ex ) ; \n} \n} \n} \n} \n} \n} \n"}
{"9670": "public class AbstractEMFParser { \nprivate void parseDir ( final File dir ) { \nLOG . debug ( \"Parse: {}\" , dir ) ; \nfinal File [ ] files = getFiles ( dir ) ; \nif ( ( files == null ) || ( files . length == 0 ) ) LOG . debug ( \"No files found in directory: {}\" , dir ) ; \nelse for ( final File file : files ) { \nif ( file . isFile ( ) ) { \nfinal Resource resource = resourceSet . getResource ( URI . createFileURI ( Utils4J . getCanonicalPath ( file ) ) , true ) ; \nfinal EList < Diagnostic > diagnostics = resource . getErrors ( ) ; \nif ( diagnostics . size ( ) == 0 ) LOG . debug ( \"Parsed {}\" , file ) ; \nelse { \nerror = true ; \nLOG . error ( \"Parsed {} with errors: {}\" , file , diagnostics ) ; \n} \n} \nelse parseDir ( file ) ; \n} \n} \n} \n"}
{"9672": "public class AbstractEMFParser { \nprivate static Set < EObject > findAllEObjects ( final ResourceSet resourceSet ) { \nfinal Set < EObject > list = new HashSet < EObject > ( ) ; \nfor ( final Iterator < Notifier > i = resourceSet . getAllContents ( ) ; \ni . hasNext ( ) ; \n) { \nfinal Notifier next = i . next ( ) ; \nif ( next instanceof EObject ) list . add ( ( EObject ) next ) ; \n} \nreturn list ; \n} \n} \n"}
{"9673": "public class AbstractEMFParser { \nprotected final void setModelDirs ( final File ... modelDirs ) { \nif ( modelDirs == null ) this . modelDirs = null ; \nelse { \nthis . modelDirs = new ArrayList < File > ( ) ; \nthis . modelDirs . addAll ( Arrays . asList ( modelDirs ) ) ; \n} \n} \n} \n"}
{"9674": "public class AbstractEMFParser { \nprotected final void setFileExtensions ( final String ... fileExtensions ) { \nif ( fileExtensions == null ) this . fileExtensions = null ; \nelse { \nthis . fileExtensions = new ArrayList < String > ( ) ; \nthis . fileExtensions . addAll ( Arrays . asList ( fileExtensions ) ) ; \n} \n} \n} \n"}
{"9675": "public class AbstractEMFParser { \nprotected final void setModelResources ( final URI ... modelResources ) { \nif ( modelResources == null ) this . modelResources = null ; \nelse { \nthis . modelResources = new ArrayList < URI > ( ) ; \nthis . modelResources . addAll ( Arrays . asList ( modelResources ) ) ; \n} \n} \n} \n"}
{"9677": "public class StatementImpl { \npublic void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { \nint arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; \nAssertUtils . assertTrue ( values . length <= arrayLen ) ; \nfor ( int i = 0 ; \ni < arrayLen ; \ni ++ ) setString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; \n} \n} \n"}
{"9678": "public class StatementImpl { \npublic void setBoolean2 ( String parameterName , Boolean value ) throws java . sql . SQLException { \nif ( value == null ) setNull ( parameterName , Types . BIT ) ; \nelse setBoolean ( parameterName , value ) ; \n} \n} \n"}
{"9681": "public class VelocityGenerator { \nprotected final void merge ( final VelocityContext context , final String artifactName , final String templateName , final String filename ) throws GenerateException { \nfinal GeneratedFile genFile = getTargetFile ( artifactName , filename , templateName ) ; \nif ( genFile . isSkip ( ) ) LOG . debug ( \"Omitted already existing file: {} [{}]\" , genFile , templateName ) ; \nelse { \nLOG . debug ( \"Start merging velocity template: {} [{}]\" , genFile , templateName ) ; \ntry { \nfinal Writer writer = new FileWriter ( genFile . getTmpFile ( ) ) ; \ntry { \nfinal Template template = ve . getTemplate ( templateName ) ; \ntemplate . merge ( context , writer ) ; \n} \nfinally { \nwriter . close ( ) ; \n} \ngenFile . persist ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new GenerateException ( \"Error merging template '\" + templateName + \"' to '\" + filename + \"'!\" , ex ) ; \n} \n} \n} \n} \n"}
{"9682": "public class ParameterizedTemplateParserConfig { \npublic final File getModelDir ( ) { \nif ( ( modelDir == null ) && ( modelPath != null ) ) modelDir = Utils4J . getCanonicalFile ( new File ( modelPath ) ) ; \nreturn modelDir ; \n} \n} \n"}
{"9683": "public class ParameterizedTemplateParserConfig { \npublic final File getTemplateDir ( ) { \nif ( ( templateDir == null ) && ( templatePath != null ) ) try { \ntemplateDir = new File ( templatePath ) . getCanonicalFile ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new RuntimeException ( \"Couldn't determine canonical template file: \" + templatePath , ex ) ; \n} \nreturn templateDir ; \n} \n} \n"}
{"9686": "public class WebViewFactory { \nprivate void configureWindow ( WebWindow web ) { \nif ( m_fullscreen ) { \nm_width = web . width ( ) ; \nm_height = web . height ( ) ; \nweb . showFullScreen ( ) ; \n} \nelse { \nweb . showNormal ( ) ; \nif ( ! m_resizable ) web . setFixedSize ( new QSize ( m_width , m_height ) ) ; \nelse web . setBaseSize ( new QSize ( m_width , m_height ) ) ; \nweb . resize ( m_width , m_height ) ; \n} \nif ( ! m_bar ) web . menuBar ( ) . setVisible ( false ) ; \nelse { \nweb . menuBar ( ) . setVisible ( true ) ; \nif ( m_icon != null ) { \nQIcon icon = new QIcon ( m_icon ) ; \nweb . setWindowIcon ( icon ) ; \n} \nweb . setWindowTitle ( m_appName ) ; \n} \nif ( ! m_contextMenu ) web . setContextMenuPolicy ( ContextMenuPolicy . PreventContextMenu ) ; \nelse web . setContextMenuPolicy ( ContextMenuPolicy . DefaultContextMenu ) ; \n} \n} \n"}
{"9687": "public class WebViewFactory { \npublic void print ( QWebView view ) { \nif ( m_print ) { \nQPrinter printer = new QPrinter ( ) ; \nQPrintDialog printDialog = new QPrintDialog ( printer , view ) ; \nif ( printDialog . exec ( ) == QDialog . DialogCode . Accepted . value ( ) ) view . print ( printer ) ; \n} \nelse m_logger . warn ( \"Print disabled\" ) ; \n} \n} \n"}
{"9688": "public class WebViewFactory { \npublic static void write ( InputStream in , OutputStream out ) throws IOException { \nbyte [ ] b = new byte [ 4096 ] ; \nfor ( int n ; \n( n = in . read ( b ) ) != - 1 ; \n) out . write ( b , 0 , n ) ; \nin . close ( ) ; \nout . close ( ) ; \n} \n} \n"}
{"9690": "public class RequestContext { \npublic void attach ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) { \nif ( requestURL == null ) requestURL = httpRequest . getRequestURI ( ) ; \nif ( locale == null ) locale = httpRequest . getLocale ( ) ; \nif ( requestPath == null ) requestPath = httpRequest . getRequestURI ( ) . substring ( httpRequest . getContextPath ( ) . length ( ) ) ; \nthis . httpRequest = httpRequest ; \nthis . httpResponse = httpResponse ; \nthis . attached = true ; \n} \n} \n"}
{"9692": "public class RequestContext { \npublic Cookies getCookies ( ) { \nassertAttached ( ) ; \nif ( cookies == null ) cookies = new Cookies ( httpRequest , httpResponse ) ; \nreturn cookies ; \n} \n} \n"}
{"9693": "public class RequestContext { \npublic void dump ( ) { \nif ( ! attached ) return ; \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"Request context |\" ) ; \nmessage . append ( httpRequest . getRequestURI ( ) ) ; \nmessage . append ( \"|:\" ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- remote-address: \" ) ; \nmessage . append ( httpRequest . getRemoteHost ( ) ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- method: \" ) ; \nmessage . append ( httpRequest . getMethod ( ) ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- query-string: \" ) ; \nif ( httpRequest . getQueryString ( ) != null ) message . append ( httpRequest . getQueryString ( ) ) ; \nEnumeration < String > headerNames = httpRequest . getHeaderNames ( ) ; \nwhile ( headerNames . hasMoreElements ( ) ) { \nmessage . append ( System . lineSeparator ( ) ) ; \nString headerName = headerNames . nextElement ( ) ; \nmessage . append ( \"\\t- \" ) ; \nmessage . append ( headerName ) ; \nmessage . append ( \": \" ) ; \nmessage . append ( httpRequest . getHeader ( headerName ) ) ; \n} \nlog . error ( message . toString ( ) ) ; \n} \n} \n"}
{"9695": "public class EventStream { \nprotected void config ( EventStreamConfig config ) { \nif ( config . hasSecretKey ( ) ) secretKey = config . getSecretKey ( ) ; \nif ( config . hasKeepAlivePeriod ( ) ) keepAlivePeriod = config . getKeepAlivePeriod ( ) ; \nparameters = config . getParameters ( ) ; \n} \n} \n"}
{"9696": "public class EventStream { \nprotected void setRemoteHost ( String remoteHost ) { \nif ( string == null ) string = Strings . concat ( '#' , STREAM_ID ++ , ':' , remoteHost ) ; \n} \n} \n"}
{"9697": "public class EventStream { \nprotected < T > T getParameter ( String name , Class < T > type ) { \nif ( parameters == null ) throw new BugError ( \"Event stream |%s| parameters not configured.\" , this ) ; \nString value = parameters . get ( name ) ; \nif ( value == null ) throw new BugError ( \"Missing event stream parameter |%s| of expected type |%s|.\" , name , type ) ; \nreturn ConverterRegistry . getConverter ( ) . asObject ( value , type ) ; \n} \n} \n"}
{"9698": "public class FileSystemDirectoryHelper { \npublic String removePrefix ( final String path , final String prefix ) { \nString pathWithoutPrefix = path ; \nif ( pathWithoutPrefix . startsWith ( prefix ) ) { \npathWithoutPrefix = pathWithoutPrefix . substring ( prefix . length ( ) ) ; \nwhile ( pathWithoutPrefix . startsWith ( \"/\" ) || pathWithoutPrefix . startsWith ( \"\\\\\" ) ) pathWithoutPrefix = pathWithoutPrefix . substring ( 1 ) ; \n} \nreturn pathWithoutPrefix ; \n} \n} \n"}
{"9699": "public class FileSystemDirectoryHelper { \npublic File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { \nList < File > parts1 = getParentDirs ( dir1 ) ; \nList < File > parts2 = getParentDirs ( dir2 ) ; \nFile matched = null ; \nfinal int maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; \nfor ( int i = 0 ; \ni < maxCommonSize ; \n++ i ) if ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) matched = parts1 . get ( i ) ; \nelse break ; \nreturn matched ; \n} \n} \n"}
{"9700": "public class FileSystemDirectoryHelper { \npublic String abs2rel ( final String basePath , final String absPath ) { \nif ( ! isAbsolutePath ( absPath ) ) return absPath ; \nif ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) return absPath ; \nStringBuilder result = new StringBuilder ( ) ; \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] absParts = getParts ( absPath ) ; \nint start = 0 ; \nfor ( int i = 0 ; \ni < Math . min ( baseParts . length , absParts . length ) ; \n++ i ) if ( baseParts [ i ] . equals ( absParts [ i ] ) ) start = i + 1 ; \nfor ( int i = start ; \ni < baseParts . length ; \n++ i ) { \nif ( result . length ( ) > 0 ) result . append ( File . separator ) ; \nresult . append ( \"..\" ) ; \n} \nfor ( int i = start ; \ni < absParts . length ; \n++ i ) { \nif ( result . length ( ) > 0 ) result . append ( File . separator ) ; \nresult . append ( absParts [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) return new File ( relPath ) ; \nList < String > parts = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < baseParts . length ; \n++ i ) if ( i > 0 || ! isWindowsDrive ( basePath ) ) parts . add ( baseParts [ i ] ) ; \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) parts . remove ( parts . size ( ) - 1 ) ; \nelse if ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) parts . add ( part ) ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) result . append ( baseParts [ 0 ] ) ; \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9705": "public class ParameterizedTemplateModels { \npublic final void addParamTemplate ( final ParameterizedTemplateModel paramTemplate ) { \nif ( paramTemplates == null ) paramTemplates = new ArrayList < ParameterizedTemplateModel > ( ) ; \nparamTemplates . add ( paramTemplate ) ; \n} \n} \n"}
{"9706": "public class ParameterizedTemplateModels { \npublic final void addParamTemplates ( final List < ParameterizedTemplateModel > list ) { \nif ( list != null ) for ( final ParameterizedTemplateModel template : list ) { \naddParamTemplate ( template ) ; \n} \n} \n} \n"}
{"9707": "public class ParameterizedTemplateModels { \npublic final void init ( final SrcGen4JContext context , final Map < String , String > vars ) { \nif ( paramTemplates != null ) for ( final ParameterizedTemplateModel paramTemplate : paramTemplates ) { \nparamTemplate . init ( context , vars ) ; \n} \n} \n} \n"}
{"9708": "public class ParameterizedTemplateModels { \npublic final List < ParameterizedTemplateModel > findReferencesTo ( final File templateDir , final File templateFile ) { \nfinal List < ParameterizedTemplateModel > result = new ArrayList < ParameterizedTemplateModel > ( ) ; \nif ( ( paramTemplates != null ) && Utils4J . fileInsideDirectory ( templateDir , templateFile ) ) for ( final ParameterizedTemplateModel paramTemplate : paramTemplates ) { \nif ( paramTemplate . hasReferenceTo ( templateDir , templateFile ) ) result . add ( paramTemplate ) ; \n} \nreturn result ; \n} \n} \n"}
{"9710": "public class ElementView { \nprotected void delete ( ) { \nString question = \"Are you sure you want to delete \" + getCaption ( ) + \"?\" ; \nConfirmDialog . show ( getUI ( ) , question , ( ConfirmDialog cd ) -> { \nif ( cd . isConfirmed ( ) ) try { \nonDelete ( ) ; \nclose ( ) ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { \nonError ( ex ) ; \n} \ncatch ( RuntimeException ex ) { \ngetUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; \n} \n} \n) ; \n} \n} \n"}
{"9712": "public class LocalInstanceFactory { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < T > T newInstance ( ManagedClassSPI managedClass , Object ... args ) { \nConstructor < ? > constructor = managedClass . getConstructor ( ) ; \nif ( constructor == null ) throw new BugError ( \"Local instance factory cannot instantiate |%s|. Missing constructor.\" , managedClass ) ; \nObject instance = null ; \ntry { \ninstance = constructor . newInstance ( args ) ; \n} \ncatch ( IllegalArgumentException e ) { \nlog . error ( \"Wrong number of arguments or bad types for |%s|: [%s].\" , constructor , Strings . join ( Classes . getParameterTypes ( args ) ) ) ; \nthrow e ; \n} \ncatch ( InstantiationException e ) { \nthrow new BugError ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new BugError ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nlog . error ( \"Managed instance constructor |%s| fail due to: %s.\" , constructor , e . getCause ( ) ) ; \nthrow new InvocationException ( e ) ; \n} \nif ( managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { \nManagedProxyHandler handler = null ; \nif ( managedClass . isTransactional ( ) ) { \nTransactionalResource transactionalResource = managedClass . getContainer ( ) . getInstance ( TransactionalResource . class ) ; \nhandler = new ManagedProxyHandler ( transactionalResource , managedClass , instance ) ; \n} \nelse handler = new ManagedProxyHandler ( managedClass , instance ) ; \nfinal ClassLoader classLoader = managedClass . getImplementationClass ( ) . getClassLoader ( ) ; \nfinal Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; \nreturn ( T ) Proxy . newProxyInstance ( classLoader , interfaceClasses , handler ) ; \n} \nreturn ( T ) instance ; \n} \n} \n"}
{"9714": "public class FitResultTable { \npublic Counts getSummary ( ) { \nCounts result = new Counts ( ) ; \nfor ( FileCount fileCount : results ) { \nif ( fileCount . getCounts ( ) != null ) result . tally ( fileCount . getCounts ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"9717": "public class ServiceInstanceFactory { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < I > I newInstance ( ManagedClassSPI managedClass , Object ... args ) { \nif ( args . length > 0 ) throw new IllegalArgumentException ( \"Service instances factory does not support arguments.\" ) ; \nClass < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; \nif ( interfaceClasses == null ) throw new BugError ( \"Invalid managed class. Null interface classes.\" ) ; \nif ( interfaceClasses . length != 1 ) throw new BugError ( \"Invalid managed class. It should have exactly one interface class.\" ) ; \nreturn ( I ) Classes . loadService ( interfaceClasses [ 0 ] ) ; \n} \n} \n"}
{"9718": "public class XtextParserConfig { \npublic final Class < ? > getSetupClass ( ) { \nif ( setupClass != null ) return setupClass ; \nLOG . info ( \"Creating setup class: {}\" , setupClassName ) ; \ntry { \nsetupClass = Class . forName ( setupClassName , true , context . getClassLoader ( ) ) ; \n} \ncatch ( final ClassNotFoundException ex ) { \nthrow new RuntimeException ( \"Couldn't load setup class: \" + setupClassName , ex ) ; \n} \nreturn setupClass ; \n} \n} \n"}
{"9719": "public class XtextParserConfig { \npublic final List < File > getModelDirs ( ) { \nif ( ( modelDirs == null ) && ( modelPath != null ) ) modelDirs = paths ( ) . stream ( ) . filter ( XtextParserConfig :: isFile ) . map ( XtextParserConfig :: asFile ) . collect ( Collectors . toList ( ) ) ; \nreturn modelDirs ; \n} \n} \n"}
{"9724": "public class QueryParametersParser { \nprivate static boolean isObject ( Type [ ] formalParameters ) { \nif ( formalParameters . length != 1 ) return false ; \nfinal Type type = formalParameters [ 0 ] ; \nif ( ! ( type instanceof Class ) ) return false ; \nif ( Types . isPrimitive ( type ) ) return false ; \nif ( Types . isArrayLike ( type ) ) return false ; \nif ( Types . isMap ( type ) ) return false ; \nif ( ConverterRegistry . hasType ( type ) ) return false ; \nreturn true ; \n} \n} \n"}
{"9727": "public class FitUtils { \npublic static String extractCellParameter ( FitCell cell ) { \nfinal Matcher matcher = PARAMETER_PATTERN . matcher ( cell . getFitValue ( ) ) ; \nif ( matcher . matches ( ) ) { \ncell . setFitValue ( matcher . group ( 1 ) ) ; \nreturn matcher . group ( 2 ) ; \n} \nelse return null ; \n} \n} \n"}
{"9731": "public class AbstractCollectionView { \n@ Subscribe public void handle ( ElementEvent < TEntity > message ) { \nif ( message . getEndpoint ( ) . getEntityType ( ) == this . endpoint . getEntityType ( ) ) refresh ( ) ; \n} \n} \n"}
{"9732": "public class BeanUtils { \npublic static < TAnnotation extends Annotation > List < PropertyDescriptor > getPropertiesWithAnnotation ( Class < ? > beanType , Class < TAnnotation > annotationType ) { \nLinkedList < PropertyDescriptor > result = new LinkedList < > ( ) ; \ngetProperties ( beanType ) . forEach ( property -> { \nif ( property . getReadMethod ( ) != null && property . getReadMethod ( ) . getAnnotation ( annotationType ) != null || isFieldAnnotated ( beanType , property . getName ( ) , annotationType ) ) result . add ( property ) ; \n} \n) ; \nreturn result ; \n} \n} \n"}
{"9735": "public class JRubyWhois { \npublic WhoisResult lookup ( String domain , int timeout ) { \ncontainer . put ( \"domain\" , domain ) ; \ncontainer . put ( \"timeout_param\" , timeout ) ; \ntry { \nreturn ( WhoisResult ) container . runScriptlet ( JRubyWhois . class . getResourceAsStream ( \"jruby-whois.rb\" ) , \"jruby-whois.rb\" ) ; \n} \ncatch ( EvalFailedException e ) { \nif ( e . getMessage ( ) . startsWith ( \"(ServerNotFound)\" ) ) throw new ServerNotFoundException ( e ) ; \nif ( e . getMessage ( ) . startsWith ( \"(WebInterfaceError\" ) ) throw new WebInterfaceErrorException ( e ) ; \nthrow e ; \n} \n} \n} \n"}
{"9739": "public class LogEventAnalyzer { \npublic void processNotContainsException ( Map < String , String > parameters ) { \nLoggingEvent match = getMessageWithException ( parameters ) ; \nif ( match == null ) cell . right ( ) ; \nelse cell . wrong ( match . getThrowableInformation ( ) . getThrowableStrRep ( ) [ 0 ] ) ; \n} \n} \n"}
{"9740": "public class LogEventAnalyzer { \npublic void processNotContains ( Map < String , String > parameters ) { \nLoggingEvent match = getMessageWithString ( parameters ) ; \nif ( match == null ) cell . right ( ) ; \nelse cell . wrong ( match . getMessage ( ) . toString ( ) ) ; \n} \n} \n"}
{"9744": "public class Cookies { \npublic String get ( String name ) { \nParams . notNullOrEmpty ( name , \"Cookie name\" ) ; \nif ( cookies == null ) return null ; \nfor ( Cookie cookie : cookies ) { \nif ( name . equals ( cookie . getName ( ) ) ) return cookie . getValue ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"9746": "public class Cookies { \npublic void remove ( String name ) { \nParams . notNullOrEmpty ( name , \"Cookie name\" ) ; \nif ( cookies == null ) return ; \nfor ( Cookie cookie : cookies ) { \nif ( name . equals ( cookie . getName ( ) ) ) { \ncookie . setMaxAge ( 0 ) ; \ncookie . setValue ( \"\" ) ; \ncookie . setPath ( \"/\" ) ; \nhttpResponse . addCookie ( cookie ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"9747": "public class Cookies { \npublic Iterator < Cookie > iterator ( ) { \nif ( cookies == null ) return Collections . emptyIterator ( ) ; \nreturn Arrays . asList ( cookies ) . iterator ( ) ; \n} \n} \n"}
{"9748": "public class TargetFileListProducerConfig { \npublic final TargetFileListProducer getTargetFileListProducer ( ) { \nif ( tflProducer != null ) return tflProducer ; \nfinal Object obj = Utils4J . createInstance ( className ) ; \nif ( ! ( obj instanceof TargetFileListProducer ) ) throw new IllegalStateException ( \"Expected class to be of type '\" + TargetFileListProducer . class . getName ( ) + \"', but was: \" + className ) ; \ntflProducer = ( TargetFileListProducer ) obj ; \nreturn tflProducer ; \n} \n} \n"}
{"9749": "public class DynamicObjectFactory { \npublic void add ( final Class < ? > type , final String name ) throws ClassNotFoundException { \nFieldGen fg ; \nif ( result != null ) throw new IllegalStateException ( \"Class already generated\" ) ; \nfg = new FieldGen ( Constants . ACC_PUBLIC | Constants . ACC_SUPER , Type . getType ( type ) , name , cg . getConstantPool ( ) ) ; \ncg . addField ( fg . getField ( ) ) ; \n} \n} \n"}
{"9752": "public class Challenge { \nprivate static String getValue ( File file ) throws NullPointerException { \nif ( file == null ) return null ; \nreturn file . getName ( ) . toLowerCase ( ) . replaceAll ( EXTENSION_REX , \"\" ) . replaceAll ( NOT_LETTERS_REX , \" \" ) ; \n} \n} \n"}
{"9753": "public class URIUtils { \n@ SneakyThrows public static URI ensureTrailingSlash ( URI uri ) { \nURIBuilder builder = new URIBuilder ( uri ) ; \nif ( ! builder . getPath ( ) . endsWith ( \"/\" ) ) builder . setPath ( builder . getPath ( ) + \"/\" ) ; \nreturn builder . build ( ) ; \n} \n} \n"}
{"9755": "public class TinyContainer { \nprivate HttpServletRequest getHttpServletRequest ( ) { \nRequestContext context = getInstance ( RequestContext . class ) ; \nHttpServletRequest request = context . getRequest ( ) ; \nif ( request == null ) throw new BugError ( \"Attempt to use not initialized HTTP request.\" ) ; \nreturn request ; \n} \n} \n"}
{"9756": "public class ManagedProxyHandler { \n@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { \nfinal ManagedMethodSPI managedMethod = managedClass . getManagedMethod ( method ) ; \nlog . trace ( \"Invoke |%s|.\" , managedMethod ) ; \nif ( ! managedMethod . isTransactional ( ) ) try { \nreturn managedMethod . invoke ( managedInstance , args ) ; \n} \ncatch ( Throwable t ) { \nthrow throwable ( t , \"Non transactional method |%s| invocation fails.\" , managedMethod ) ; \n} \nif ( managedMethod . isImmutable ( ) ) return executeImmutableTransaction ( managedMethod , args ) ; \nreturn executeMutableTransaction ( managedMethod , args ) ; \n} \n} \n"}
{"9757": "public class ManagedProxyHandler { \nprivate Object executeMutableTransaction ( ManagedMethodSPI managedMethod , Object [ ] args ) throws Throwable { \nTransaction transaction = transactionalResource . createTransaction ( ) ; \ntransactionalResource . storeSession ( transaction . getSession ( ) ) ; \ntry { \nObject result = managedMethod . invoke ( managedInstance , args ) ; \ntransaction . commit ( ) ; \nif ( transaction . unused ( ) ) log . debug ( \"Method |%s| superfluously declared transactional.\" , managedMethod ) ; \nreturn result ; \n} \ncatch ( Throwable throwable ) { \ntransaction . rollback ( ) ; \nthrow throwable ( throwable , \"Mutable transactional method |%s| invocation fail.\" , managedMethod ) ; \n} \nfinally { \nif ( transaction . close ( ) ) transactionalResource . releaseSession ( ) ; \n} \n} \n} \n"}
{"9758": "public class ManagedProxyHandler { \nprivate Object executeImmutableTransaction ( ManagedMethodSPI managedMethod , Object [ ] args ) throws Throwable { \nTransaction transaction = transactionalResource . createReadOnlyTransaction ( ) ; \ntransactionalResource . storeSession ( transaction . getSession ( ) ) ; \ntry { \nObject result = managedMethod . invoke ( managedInstance , args ) ; \nif ( transaction . unused ( ) ) log . debug ( \"Method |%s| superfluously declared transactional.\" , managedMethod ) ; \nreturn result ; \n} \ncatch ( Throwable throwable ) { \nthrow throwable ( throwable , \"Immutable transactional method |%s| invocation fail.\" , managedMethod ) ; \n} \nfinally { \nif ( transaction . close ( ) ) transactionalResource . releaseSession ( ) ; \n} \n} \n} \n"}
{"9759": "public class FileSelector { \npublic File [ ] getFiles ( ) { \nfinal File [ ] files = directory . listFiles ( filter ) ; \nif ( files == null ) return new File [ 0 ] ; \nelse return files ; \n} \n} \n"}
{"9760": "public class FileSelector { \npublic File getLastFile ( ) throws FileNotFoundException { \nFile [ ] files = directory . listFiles ( filter ) ; \nif ( files == null || files . length == 0 ) throw new FileNotFoundException ( ) ; \nreturn files [ files . length - 1 ] ; \n} \n} \n"}
{"9761": "public class AbstractParser { \n@ SuppressWarnings ( \"unchecked\" ) protected final CONFIG_TYPE getConcreteConfig ( final ParserConfig config ) { \nfinal Config < ParserConfig > cfg = config . getConfig ( ) ; \nif ( cfg == null ) throw new IllegalStateException ( \"The configuration is expected to be of type '\" + concreteConfigClass . getName ( ) + \"', but was: null\" ) ; \nelse if ( ! ( concreteConfigClass . isAssignableFrom ( cfg . getConfig ( ) . getClass ( ) ) ) ) throw new IllegalStateException ( \"The configuration is expected to be of type '\" + concreteConfigClass . getName ( ) + \"', but was: \" + cfg . getConfig ( ) . getClass ( ) . getName ( ) + \" - Did you add the configuration class to the JXB context?\" ) ; \nreturn ( CONFIG_TYPE ) cfg . getConfig ( ) ; \n} \n} \n"}
{"9762": "public class RequestPreprocessor { \nprivate static boolean startsWith ( String requestPath , String pathComponent ) { \nif ( requestPath . charAt ( 0 ) != '/' ) return false ; \nint i = 1 ; \nfor ( int j = 0 ; \ni < requestPath . length ( ) ; \n++ i , ++ j ) { \nif ( requestPath . charAt ( i ) == '/' ) return j == pathComponent . length ( ) ; \nif ( j == pathComponent . length ( ) ) return false ; \nif ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) return false ; \n} \nreturn false ; \n} \n} \n"}
{"9763": "public class EMFGeneratorConfig { \n@ SuppressWarnings ( \"unchecked\" ) @ NotNull public final < MODEL > List < ArtifactFactory < MODEL > > getFactories ( final Class < MODEL > modelType ) { \nfinal List < ArtifactFactory < MODEL > > list = new ArrayList < ArtifactFactory < MODEL > > ( ) ; \nif ( factories == null ) { \nfactories = new ArrayList < ArtifactFactory < ? > > ( ) ; \nif ( factoryConfigs != null ) for ( final ArtifactFactoryConfig factoryConfig : factoryConfigs ) { \nfactories . add ( factoryConfig . getFactory ( ) ) ; \n} \n} \nfor ( final ArtifactFactory < ? > factory : factories ) { \nif ( modelType . isAssignableFrom ( factory . getModelType ( ) ) ) list . add ( ( ArtifactFactory < MODEL > ) factory ) ; \n} \nreturn list ; \n} \n} \n"}
{"9764": "public class SessionScopeFactory { \nprivate HttpSession getSession ( InstanceKey instanceKey ) { \nRequestContext requestContext = appFactory . getInstance ( RequestContext . class ) ; \nHttpServletRequest httpRequest = requestContext . getRequest ( ) ; \nif ( httpRequest == null ) throw new BugError ( \"Invalid web context due to null HTTP request. Cannot create managed instance for |%s| with scope SESSION.\" , instanceKey ) ; \nreturn httpRequest . getSession ( true ) ; \n} \n} \n"}
{"9767": "public class ResourceServlet { \n@ Override protected void handleRequest ( RequestContext context ) throws ServletException , IOException { \nfinal HttpServletRequest httpRequest = context . getRequest ( ) ; \nfinal HttpServletResponse httpResponse = context . getResponse ( ) ; \nArgumentsReader argumentsReader = null ; \nResource resource = null ; \ntry { \nManagedMethodSPI method = resourceMethods . get ( key ( context . getRequestPath ( ) ) ) ; \nif ( method == null ) throw new NoSuchMethodException ( httpRequest . getRequestURI ( ) ) ; \nfinal Type [ ] formalParameters = method . getParameterTypes ( ) ; \nargumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; \nObject [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; \nObject controller = container . getInstance ( method . getDeclaringClass ( ) ) ; \nresource = method . invoke ( controller , arguments ) ; \nif ( resource == null ) throw new BugError ( \"Null resource |%s|.\" , httpRequest . getRequestURI ( ) ) ; \n} \ncatch ( AuthorizationException e ) { \nString loginPage = container . getLoginPage ( ) ; \nif ( loginPage != null ) httpResponse . sendRedirect ( loginPage ) ; \nelse httpRequest . authenticate ( httpResponse ) ; \nreturn ; \n} \ncatch ( NoSuchMethodException | IllegalArgumentException e ) { \ndumpError ( context , e ) ; \nhttpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; \nreturn ; \n} \ncatch ( InvocationException e ) { \ndumpError ( context , e ) ; \nif ( e . getCause ( ) instanceof NoSuchResourceException ) httpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; \nelse httpResponse . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getCause ( ) . getMessage ( ) ) ; \nreturn ; \n} \nfinally { \nif ( argumentsReader != null ) argumentsReader . clean ( ) ; \n} \nhttpResponse . setStatus ( HttpServletResponse . SC_OK ) ; \nresource . serialize ( httpResponse ) ; \n} \n} \n"}
{"9769": "public class EventStreamManagerImpl { \n@ Override public void preDestroy ( ) { \nif ( eventStreams . isEmpty ( ) ) return ; \nfor ( EventStream eventStream : eventStreams . toArray ( new EventStream [ 0 ] ) ) { \nlog . debug ( \"Force close stale event stream |%s|.\" , eventStream ) ; \neventStream . close ( ) ; \n} \n} \n} \n"}
{"9772": "public class AbstractBlobView { \nprotected void delete ( ) { \nString question = \"Are you sure you want to delete the data from the server?\" ; \nConfirmDialog . show ( getUI ( ) , question , new ConfirmDialog . Listener ( ) { \n@ Override public void onClose ( ConfirmDialog cd ) { \nif ( cd . isConfirmed ( ) ) try { \nendpoint . delete ( ) ; \nclose ( ) ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { \nonError ( ex ) ; \n} \ncatch ( RuntimeException ex ) { \ngetUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"9774": "public class Fixture { \nprotected String [ ] getArgNames ( ) { \nif ( args == null ) return new String [ ] { \n} \n; \nreturn args . keySet ( ) . toArray ( new String [ args . keySet ( ) . size ( ) ] ) ; \n} \n} \n"}
{"9777": "public class ViewManagerImpl { \n@ Override public void config ( Config config ) throws ConfigException , IOException { \nfor ( Config repositorySection : config . findChildren ( \"repository\" ) ) { \nString className = repositorySection . getAttribute ( \"class\" , DEF_IMPLEMENTATION ) ; \nClass < ? > implementation = Classes . forOptionalName ( className ) ; \nif ( implementation == null ) throw new ConfigException ( \"Unable to load view implementation |%s|.\" , className ) ; \nif ( ! Types . isKindOf ( implementation , View . class ) ) throw new ConfigException ( \"View implementation |%s| is not of proper type.\" , className ) ; \nif ( ! Classes . isInstantiable ( implementation ) ) throw new ConfigException ( \"View implementation |%s| is not instantiable. Ensure is not abstract or interface and have default constructor.\" , implementation ) ; \n@ SuppressWarnings ( \"unchecked\" ) Class < ? extends View > viewImplementation = ( Class < ? extends View > ) implementation ; \nString repositoryPath = repositorySection . getAttribute ( \"path\" ) ; \nif ( repositoryPath == null ) throw new ConfigException ( \"Invalid views repository configuration. Missing <path> attribute.\" ) ; \nString filesPattern = repositorySection . getAttribute ( \"files-pattern\" ) ; \nif ( filesPattern == null ) throw new ConfigException ( \"Invalid views repository configuration. Missing <files-pattern> attribute.\" ) ; \nConfigBuilder builder = new I18nRepository . ConfigBuilder ( repositoryPath , filesPattern ) ; \nI18nRepository repository = new I18nRepository ( builder . build ( ) ) ; \nif ( viewsMetaPool == null ) viewsMetaPool = repository . getPoolInstance ( ) ; \nProperties properties = repositorySection . getProperties ( ) ; \nfor ( I18nFile template : repository ) { \nViewMeta meta = new ViewMeta ( template . getFile ( ) , viewImplementation , properties ) ; \nif ( viewsMetaPool . put ( meta . getName ( ) , meta , template . getLocale ( ) ) ) log . warn ( \"Override view |%s|\" , meta ) ; \nelse log . debug ( \"Register view |%s|\" , meta ) ; \n} \n} \n} \n} \n"}
{"9778": "public class RecursiveFileSelector { \n@ Override public final File next ( ) { \nif ( files == null || fileIndex >= files . length ) if ( ! cacheNext ( ) ) throw new NoSuchElementException ( ) ; \nreturn files [ fileIndex ++ ] ; \n} \n} \n"}
{"9779": "public class Launcher { \nprivate static void configureApplication ( ) { \nFile file = new File ( \"chameria.props\" ) ; \nif ( file . exists ( ) ) { \nProperties props = new Properties ( ) ; \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nprops . load ( is ) ; \nString n = props . getProperty ( \"application.name\" ) ; \nif ( n != null ) QApplication . setApplicationName ( n ) ; \nelse QApplication . setApplicationName ( \"akquinet ChameRIA\" ) ; \nn = props . getProperty ( \"application.version\" ) ; \nif ( n != null ) QApplication . setApplicationVersion ( n ) ; \nn = props . getProperty ( \"application.icon\" ) ; \nif ( n != null ) { \nQIcon icon = new QIcon ( n ) ; \nQApplication . setWindowIcon ( icon ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"Cannot read the application configuration \" + e . getMessage ( ) ) ; \ne . printStackTrace ( ) ; \n} \nfinally { \nif ( is != null ) try { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \nQApplication . setOrganizationName ( \"akquinet A.G.\" ) ; \n} \n} \n"}
{"9782": "public class Launcher { \npublic static ChameRIA createChameleon ( String [ ] args ) throws Exception { \nboolean debug = isDebugModeEnabled ( args ) ; \nString core = getCore ( args ) ; \nString app = getApp ( args ) ; \nString runtime = getRuntime ( args ) ; \nString fileinstall = getDeployDirectory ( args ) ; \nString config = getProps ( args ) ; \nif ( config == null || ! new File ( config ) . exists ( ) ) return new ChameRIA ( core , debug , app , runtime , fileinstall , null ) ; \nelse return new ChameRIA ( core , debug , app , runtime , fileinstall , config ) ; \n} \n} \n"}
{"9786": "public class FitParseResult { \npublic void insertAndReplace ( final FitRow row ) { \nif ( results . isEmpty ( ) ) return ; \nint index = row . getIndex ( ) ; \nFitTable table = row . getTable ( ) ; \ntable . remove ( index ) ; \naddRows ( table , index ) ; \n} \n} \n"}
{"9877": "public class BlockLocks { \npublic int nextClearBit ( int index ) { \nint i = index >> 6 ; \nif ( i >= wlen ) return - 1 ; \nint subIndex = index & 0x3f ; \nlong word = ~ bits . get ( i ) >> subIndex ; \nif ( word != 0 ) return ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; \nwhile ( ++ i < wlen ) { \nword = ~ bits . get ( i ) ; \nif ( word != 0 ) return ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"9878": "public class BlockLocks { \npublic boolean set ( int index ) { \nint wordNum = index >> 6 ; \nint bit = index & 0x3f ; \nlong bitmask = 1L << bit ; \nlong word , oword ; \ndo { \nword = bits . get ( wordNum ) ; \nif ( ( word & bitmask ) != 0 ) return false ; \noword = word ; \nword |= bitmask ; \n} \nwhile ( ! bits . compareAndSet ( wordNum , oword , word ) ) ; \nreturn true ; \n} \n} \n"}
{"9879": "public class BlockCache { \nprotected void freeBuffer ( final ByteBuffer buffer ) throws IOException { \nif ( buffer == null ) return ; \nif ( UNMAP_SUPPORTED ) try { \nAccessController . doPrivileged ( new PrivilegedExceptionAction < Void > ( ) { \n@ Override public Void run ( ) throws Exception { \nfinal Method getCleanerMethod = buffer . getClass ( ) . getMethod ( \"cleaner\" ) ; \ngetCleanerMethod . setAccessible ( true ) ; \nfinal Object cleaner = getCleanerMethod . invoke ( buffer ) ; \nif ( cleaner != null ) cleaner . getClass ( ) . getMethod ( \"clean\" ) . invoke ( cleaner ) ; \nreturn null ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException e ) { \nfinal IOException ioe = new IOException ( \"unable to unmap the mapped buffer\" ) ; \nioe . initCause ( e . getCause ( ) ) ; \nthrow ioe ; \n} \n} \n} \n"}
{"9881": "public class SlimSet { \nprivate static Object [ ] rehash ( final Object [ ] values , final int newSize ) { \nObject [ ] newArray = new Object [ newSize ] ; \nfor ( Object value : values ) { \nif ( value == null ) continue ; \nnewArray [ predictedPosition ( newArray , value , value . hashCode ( ) ) ] = value ; \n} \nreturn newArray ; \n} \n} \n"}
{"9882": "public class PolymerElements { \npublic String toHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listMonomerNotations . size ( ) ; \ni ++ ) notation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + \".\" ) ; \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9883": "public class AnnotationsParser { \nprivate boolean checkBracketsParenthesis ( ) { \nLOG . debug ( \"Check of brackets in the annotation section:\" ) ; \nif ( bracketCounterOpen == bracketCounterClose && parenthesisCounterOpen == parenthesisCounterClose && curlyBracketCounterOpen == curlyBracketCounterClose ) return true ; \nreturn false ; \n} \n} \n"}
{"9884": "public class ConnectionNotation { \nprivate void addDetails ( String str ) throws NotationException { \nString [ ] parts = str . split ( \"-\" ) ; \nsourceUnit = parts [ 0 ] . split ( \":\" ) [ 0 ] . toUpperCase ( ) ; \ntargetUnit = parts [ 1 ] . split ( \":\" ) [ 0 ] . toUpperCase ( ) ; \nrGroupSource = parts [ 0 ] . split ( \":\" ) [ 1 ] ; \nrGroupTarget = parts [ 1 ] . split ( \":\" ) [ 1 ] ; \nPattern r = Pattern . compile ( \"R\\\\d\" , Pattern . CASE_INSENSITIVE ) ; \nPattern pair = Pattern . compile ( \"pair\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher mR = r . matcher ( rGroupSource ) ; \nMatcher mPair = pair . matcher ( rGroupTarget ) ; \nif ( mR . matches ( ) ) rGroupSource = rGroupSource . toUpperCase ( ) ; \nelse rGroupSource = rGroupSource . toLowerCase ( ) ; \nif ( mPair . matches ( ) ) rGroupTarget = rGroupTarget . toLowerCase ( ) ; \nelse rGroupTarget = rGroupTarget . toUpperCase ( ) ; \n} \n} \n"}
{"9885": "public class ConnectionNotation { \npublic String toHELM2 ( ) { \nif ( isAnnotationTrue ( ) ) return sourceId . getId ( ) + \",\" + targetId . getId ( ) + \",\" + sourceUnit + \":\" + rGroupSource + \"-\" + targetUnit + \":\" + rGroupTarget + \"\\\"\" + annotation + \"\\\"\" ; \nelse return sourceId . getId ( ) + \",\" + targetId . getId ( ) + \",\" + sourceUnit + \":\" + rGroupSource + \"-\" + targetUnit + \":\" + rGroupTarget ; \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nwhile ( ( line = br . readLine ( ) ) != null ) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) output = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \nelse if ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) output = parser . getJSON ( ) ; \nSystem . out . println ( output ) ; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \nSystem . out . println ( \"Please call the program with the following arguments: \" + \"\\n\" + \"-inputHELM  <\" + options . getOption ( \"inputHELM\" ) . getDescription ( ) + \">\\n\" + \"-output <\" + options . getOption ( \"output\" ) . getDescription ( ) + \">\\n-translate(optional) <\" + options . getOption ( \"translate\" ) . getDescription ( ) + \">\" ) ; \n} \ncatch ( ParseException exp ) { \nSystem . out . println ( \"Unexpected exception: \" + exp . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9892": "public class StateMachineParser { \npublic boolean checkRepeating ( String str ) { \nString pattern = \"\\\\d+|\\\\d+-\\\\d+\" ; \nif ( str . matches ( pattern ) ) return true ; \nreturn false ; \n} \n} \n"}
{"9893": "public class StateMachineParser { \npublic boolean isPeptideOrRna ( ) throws SimplePolymerSectionException { \nif ( polymerElements . size ( ) >= 1 ) { \nif ( polymerElements . get ( polymerElements . size ( ) - 1 ) . matches ( \"(PEPTIDE[1-9][0-9]*+|RNA[1-9][0-9]*)\" ) ) return true ; \nreturn false ; \n} \nelse throw new SimplePolymerSectionException ( \"No Polymer Id is found\" ) ; \n} \n} \n"}
{"9895": "public class HELM2Notation { \npublic PolymerNotation getSimplePolymer ( String string ) { \nfor ( PolymerNotation polymer : listOfPolymers ) { \nif ( polymer . getPolymerID ( ) . getId ( ) . equals ( string ) ) return polymer ; \n} \nreturn null ; \n} \n} \n"}
{"9896": "public class HELM2Notation { \n@ JsonIgnore public GroupingNotation getCurrentGroupingNotation ( ) { \nif ( listOfGroupings . size ( ) == 0 ) return null ; \nreturn listOfGroupings . get ( listOfGroupings . size ( ) - 1 ) ; \n} \n} \n"}
{"9898": "public class HELM2Notation { \npublic String polymerToHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfPolymers . size ( ) ; \ni ++ ) if ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) notation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\\\"\" + listOfPolymers . get ( i ) . getAnnotation ( ) + \"\\\"|\" ) ; \nelse notation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\" + \"|\" ) ; \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9899": "public class HELM2Notation { \npublic String connectionToHELM2 ( ) { \nif ( listOfConnections . size ( ) == 0 ) return \"\" ; \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfConnections . size ( ) ; \ni ++ ) notation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + \"|\" ) ; \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9900": "public class HELM2Notation { \npublic String groupingToHELM2 ( ) { \nif ( listOfGroupings . size ( ) == 0 ) return \"\" ; \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfGroupings . size ( ) ; \ni ++ ) notation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + \"|\" ) ; \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9901": "public class HELM2Notation { \npublic String annotationToHELM2 ( ) { \nif ( ! ( annotationSection . isEmpty ( ) ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < annotationSection . size ( ) ; \ni ++ ) sb . append ( annotationSection . get ( i ) . toHELM2 ( ) + \"|\" ) ; \nsb . setLength ( sb . length ( ) - 1 ) ; \nreturn sb . toString ( ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"9903": "public class HELM2Notation { \n@ JsonIgnore public PolymerNotation getPolymerNotation ( String id ) { \nfor ( PolymerNotation polymer : listOfPolymers ) { \nif ( polymer . getPolymerID ( ) . getId ( ) . equals ( id ) ) return polymer ; \n} \nreturn null ; \n} \n} \n"}
{"9904": "public class PolymerNotation { \nprivate void setPolymerElements ( ) { \nif ( polymerID instanceof RNAEntity || polymerID instanceof PeptideEntity ) this . polymerElements = new PolymerListElements ( polymerID ) ; \nelse this . polymerElements = new PolymerSingleElements ( polymerID ) ; \n} \n} \n"}
{"9905": "public class ConverterHELM1ToHELM2 { \npublic String doConvert ( String str ) { \nParserHELM2 parser = new ParserHELM2 ( ) ; \ntry { \nparser . parse ( str + \"V2.0\" ) ; \nreturn str + \"V2.0\" ; \n} \ncatch ( Exception e ) { \nString helm1 = str + \"f\" ; \nStringBuilder helm2 = new StringBuilder ( ) ; \nString [ ] sections = helm1 . split ( \"}\\\\$\" ) ; \nhelm2 . append ( sections [ 0 ] + \"}$\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 1 ; \ni < sections . length ; \ni ++ ) sb . append ( sections [ i ] + \"}$\" ) ; \nhelm1 = \"$\" + sb . toString ( ) ; \nsections = helm1 . split ( \"\\\\$\" ) ; \nif ( sections . length >= 2 ) if ( ! ( sections [ 1 ] . isEmpty ( ) ) ) helm2 . append ( sections [ 1 ] ) ; \nif ( sections . length >= 3 ) { \nif ( ! ( sections [ 2 ] . isEmpty ( ) ) ) if ( ! ( sections [ 1 ] . isEmpty ( ) ) ) helm2 . append ( \"|\" + sections [ 2 ] ) ; \nelse helm2 . append ( sections [ 2 ] ) ; \nhelm2 . append ( \"$\" ) ; \nhelm2 . append ( \"$\" ) ; \nif ( sections . length >= 4 ) if ( ! ( sections [ 3 ] . isEmpty ( ) ) ) helm2 . append ( sections [ 3 ] ) ; \n} \nhelm2 . append ( \"$V2.0\" ) ; \nreturn helm2 . toString ( ) ; \n} \n} \n} \n"}
{"9907": "public class MonomerNotation { \npublic void setCount ( String str ) { \nisDefault = false ; \nif ( str . equals ( \"1\" ) ) isDefault = true ; \ncount = str ; \n} \n} \n"}
{"9908": "public class ValidationMethod { \npublic static MonomerNotation decideWhichMonomerNotation ( String str , String type ) throws NotationException { \nMonomerNotation mon ; \nif ( str . startsWith ( \"(\" ) && str . endsWith ( \")\" ) ) { \nString str2 = str . substring ( 1 , str . length ( ) - 1 ) ; \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nPattern patternOR = Pattern . compile ( \",\" ) ; \nif ( patternAND . matcher ( str ) . find ( ) ) mon = new MonomerNotationGroupMixture ( str2 , type ) ; \nelse if ( patternOR . matcher ( str ) . find ( ) ) mon = new MonomerNotationGroupOr ( str2 , type ) ; \nelse if ( str . contains ( \".\" ) ) mon = new MonomerNotationList ( str2 , type ) ; \nelse if ( type == \"RNA\" ) mon = new MonomerNotationUnitRNA ( str2 , type ) ; \nelse { \nif ( str2 . length ( ) > 1 ) if ( ! ( str2 . startsWith ( \"[\" ) && str2 . endsWith ( \"]\" ) ) ) throw new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \nmon = new MonomerNotationUnit ( str2 , type ) ; \n} \n} \nelse if ( type == \"RNA\" ) mon = new MonomerNotationUnitRNA ( str , type ) ; \nelse if ( type != \"BLOB\" ) { \nif ( str . length ( ) > 1 ) if ( ! ( str . startsWith ( \"[\" ) && str . endsWith ( \"]\" ) ) ) throw new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nelse mon = new MonomerNotationUnit ( str , type ) ; \nreturn mon ; \n} \n} \n"}
{"9909": "public class ValidationMethod { \npublic static MonomerNotationGroupElement decideWhichMonomerNotationInGroup ( String str , String type , double one , double two , boolean interval , boolean isDefault ) throws NotationException { \nMonomerNotation element ; \nelement = decideWhichMonomerNotation ( str , type ) ; \nif ( interval ) return new MonomerNotationGroupElement ( element , one , two ) ; \nelse return new MonomerNotationGroupElement ( element , one , isDefault ) ; \n} \n} \n"}
{"9910": "public class ValidationMethod { \npublic static HELMEntity decideWhichEntity ( String str ) throws NotationException { \nHELMEntity item ; \nif ( str . toUpperCase ( ) . matches ( \"PEPTIDE[1-9][0-9]*\" ) ) item = new PeptideEntity ( str . toUpperCase ( ) ) ; \nelse if ( str . toUpperCase ( ) . matches ( \"RNA[1-9][0-9]*\" ) ) item = new RNAEntity ( str . toUpperCase ( ) ) ; \nelse if ( str . toUpperCase ( ) . matches ( \"BLOB[1-9][0-9]*\" ) ) item = new BlobEntity ( str . toUpperCase ( ) ) ; \nelse if ( str . toUpperCase ( ) . matches ( \"CHEM[1-9][0-9]*\" ) ) item = new ChemEntity ( str . toUpperCase ( ) ) ; \nelse if ( str . toUpperCase ( ) . matches ( \"G[1-9][0-9]*\" ) ) item = new GroupEntity ( str . toUpperCase ( ) ) ; \nelse throw new NotationException ( \"ID is wrong: \" + str ) ; \nreturn item ; \n} \n} \n"}
{"9911": "public class MonomerNotationGroupElement { \npublic List < Double > getValue ( ) { \nif ( this . isInterval ) return new ArrayList < Double > ( Arrays . asList ( numberOne , numberTwo ) ) ; \nelse return new ArrayList < Double > ( Arrays . asList ( numberOne ) ) ; \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) { \nfor ( int i = 0 ; \ni < test . length ( ) - 4 ; \ni ++ ) parser . doAction ( test . charAt ( i ) ) ; \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \nelse { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \n} \n} \n"}
{"9913": "public class MonomerNotationUnitRNA { \nprivate void setRNAContents ( String str ) throws NotationException { \nString [ ] list ; \nList < String > items = extractContents ( str ) ; \nfor ( String item : items ) { \nif ( item . length ( ) > 1 ) if ( ! ( item . startsWith ( \"[\" ) && item . endsWith ( \"]\" ) ) ) throw new NotationException ( \"Monomers have to be in brackets \" + item ) ; \ncontents . add ( new MonomerNotationUnit ( item , type ) ) ; \n} \n} \n} \n"}
{"9914": "public class GroupingNotation { \nprivate void defineAmbiguity ( String a ) throws NotationException { \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nMatcher m = patternAND . matcher ( a ) ; \nif ( m . find ( ) ) setAmbiguity ( new GroupingMixture ( a ) ) ; \nelse setAmbiguity ( new GroupingOr ( a ) ) ; \n} \n} \n"}
{"9918": "public class ADiGraph { \nprivate void initPathsInternal ( ) { \nsynchronized ( LOCK ) { \nif ( _incomingPathsInternal == null ) { \nAMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; \nincomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; \nAMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; \noutgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; \nAList < AEdgePath < N , E > > cycles = AList . nil ( ) ; \nfor ( N curNode : nodes ( ) ) { \nfinal Iterable < E > curIncoming = incomingEdges ( curNode ) ; \nList < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; \nfor ( E incomingEdge : curIncoming ) { \nunfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; \n} \nAList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; \nwhile ( unfinishedBusiness . size ( ) > 0 ) { \nfinal List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; \nfor ( AEdgePath < N , E > p : unfinishedBusiness ) { \nif ( ! p . hasCycle ( ) || p . isMinimalCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; \nif ( p . isMinimalCycle ( ) ) cycles = cycles . cons ( p ) ; \n} \nunfinishedBusiness = new ArrayList < > ( ) ; \nfor ( AEdgePath < N , E > curPath : curBusiness ) { \nfinal Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; \nfor ( E newEdge : l ) { \nfinal AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; \nif ( ! pathCandidate . hasNonMinimalCycle ( ) ) unfinishedBusiness . add ( pathCandidate ) ; \n} \n} \n} \nincomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; \nfor ( AEdgePath < N , E > p : nonCycles ) { \noutgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; \n} \n} \n_incomingPathsInternal = incomingPaths ; \n_outgoingPathsInternal = outgoingPaths ; \n_cyclesInternal = cycles ; \n} \n} \n} \n} \n"}
{"9919": "public class ADiGraph { \npublic List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { \nif ( hasCycles ( ) ) throw new AGraphCircularityException ( ) ; \nfinal Object [ ] result = new Object [ nodes . length ] ; \nint nextIdx = 0 ; \nfinal Set < N > unprocessed = new HashSet < > ( ) ; \nfor ( Object node : nodes ) { \nunprocessed . add ( ( N ) node ) ; \n} \nwhile ( ! unprocessed . isEmpty ( ) ) { \nfinal Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { \n@ Override public boolean apply ( N n ) { \nfor ( E e : incomingEdges ( n ) ) { \nif ( unprocessed . contains ( e . getFrom ( ) ) ) return false ; \n} \nreturn true ; \n} \n} \n) ; \nunprocessed . removeAll ( nextBatch ) ; \nfor ( N n : nextBatch ) { \nresult [ nextIdx ] = n ; \nnextIdx += 1 ; \n} \n} \nreturn new ArrayIterable < > ( result ) ; \n} \n} \n"}
{"9922": "public class API { \npublic void unsubscribe ( final String pattern ) throws InvalidInputException { \nfinal String s = this . prefix + pattern ; \nLinkedList < FunctionInterface9 > callback_list = this . callbacks . get ( s ) ; \nif ( callback_list == null ) throw new InvalidInputException ( ) ; \nelse { \ncallback_list . removeFirst ( ) ; \nif ( callback_list . isEmpty ( ) ) this . callbacks . remove ( s ) ; \n} \nOtpOutputStream unsubscribe = new OtpOutputStream ( ) ; \nunsubscribe . write ( OtpExternal . versionTag ) ; \nfinal OtpErlangObject [ ] tuple = { \nnew OtpErlangAtom ( \"unsubscribe\" ) , new OtpErlangString ( pattern ) } \n; \nunsubscribe . write_any ( new OtpErlangTuple ( tuple ) ) ; \nsend ( unsubscribe ) ; \n} \n} \n"}
{"9927": "public class AExceptionFilter { \npublic static < T extends Throwable > T forLocalHandling ( T th ) { \nif ( requiresNonLocalHandling ( th ) ) AUnchecker . throwUnchecked ( th ) ; \nreturn th ; \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { \nint s = indexSeed += SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) if ( ++ probes >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) if ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) if ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse if ( w . qlock < 0 ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"9940": "public class ForkJoinPool { \nprivate static ForkJoinPool makeCommonPool ( ) { \nint parallelism = - 1 ; \nForkJoinWorkerThreadFactory factory = null ; \nUncaughtExceptionHandler handler = null ; \ntry { \nString pp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.parallelism\" ) ; \nString fp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.threadFactory\" ) ; \nString hp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\" ) ; \nString mp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" ) ; \nif ( pp != null ) parallelism = Integer . parseInt ( pp ) ; \nif ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; \nif ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; \nif ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( factory == null ) if ( System . getSecurityManager ( ) == null ) factory = defaultForkJoinWorkerThreadFactory ; \nelse factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; \nif ( parallelism < 0 && ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) parallelism = 1 ; \nif ( parallelism > MAX_CAP ) parallelism = MAX_CAP ; \nreturn new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , \"ForkJoinPool.commonPool-worker-\" ) ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( ( s = status ) >= 0 && nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nwhile ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) if ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) synchronized ( this ) { \nif ( status >= 0 ) wait ( ms ) ; \nelse notifyAll ( ) ; \n} \n} \n} \nif ( s >= 0 ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9943": "public class AThreadPoolImpl { \n@ Override public AThreadPoolStatistics getStatistics ( ) { \nfinal AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; \nfor ( int i = 0 ; \ni < localQueues . length ; \ni ++ ) workerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; \nfinal ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; \nfor ( int i = 0 ; \ni < sharedQueues . length ; \ni ++ ) sharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; \nreturn new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; \n} \n} \n"}
{"9946": "public class ACollectionHelper { \npublic static < T , E extends Throwable > boolean forAll ( Iterable < T > coll , APredicate < ? super T , E > pred ) throws E { \nfor ( T o : coll ) { \nif ( ! pred . apply ( o ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"9948": "public class ACollectionHelper { \npublic static < T , R , E extends Throwable > R foldRight ( List < T > coll , R startValue , AFunction2 < R , ? super T , R , E > f ) throws E { \nR result = startValue ; \nListIterator < T > i = coll . listIterator ( coll . size ( ) ) ; \nwhile ( i . hasPrevious ( ) ) result = f . apply ( result , i . previous ( ) ) ; \nreturn result ; \n} \n} \n"}
{"9949": "public class LocalQueue { \nvoid push ( Runnable task ) { \nfinal long _base = UNSAFE . getLongVolatile ( this , OFFS_BASE ) ; \nfinal long _top = top ; \nif ( _top == _base + mask ) throw new RejectedExecutionExceptionWithoutStacktrace ( \"local queue overflow\" ) ; \ntasks [ asArrayindex ( _top ) ] = task ; \nUNSAFE . putLongVolatile ( this , OFFS_TOP , _top + 1 ) ; \nif ( _top - _base <= 1 ) pool . onAvailableTask ( ) ; \n} \n} \n"}
{"9956": "public class UriLoader { \nprivate String normalizeResourceName ( String name ) { \nif ( name . startsWith ( \"//\" ) ) return \"classpath:\" + name ; \nfinal int firstProtocol = name . indexOf ( \"://\" ) ; \nfinal int secondProtocol = name . indexOf ( \"://\" , firstProtocol + 1 ) ; \nfinal int protocol = secondProtocol < 0 ? firstProtocol : secondProtocol ; \nfinal int endOfFirst = name . lastIndexOf ( \"/\" , protocol ) ; \nif ( endOfFirst >= 0 ) return name . substring ( endOfFirst + 1 ) ; \nreturn name ; \n} \n} \n"}
{"9957": "public class ValueTypeXmlAdapter { \n@ Override public String marshal ( BoundType v ) throws Exception { \nClass < ? extends Object > type = v . getClass ( ) ; \nif ( ! Types . isUserDefinedValueType ( type ) ) throw new IllegalArgumentException ( \"Type [\" + type + \"] must be an user-defined value type; \" + \"@XmlJavaTypeAdapter(ValueTypeXmlAdapter.class) \" + \"can be annotated to user-defined value type and field only\" ) ; \nConverter converter = ConvertUtils . lookup ( type ) ; \nif ( ( converter != null && converter instanceof AbstractConverter ) ) { \nString string = ( String ) ConvertUtils . convert ( v , String . class ) ; \nif ( string != null ) return string ; \n} \nreturn v . toString ( ) ; \n} \n} \n"}
{"9962": "public class EMail { \npublic static Future < Boolean > sendMessage ( final Email msg ) { \nif ( asynchronousSend ) return executor . submit ( new Callable < Boolean > ( ) { \npublic Boolean call ( ) { \ntry { \nmsg . setSentDate ( new Date ( ) ) ; \nmsg . send ( ) ; \nreturn true ; \n} \ncatch ( Throwable e ) { \nMailException me = new MailException ( \"Error while sending email\" , e ) ; \nlogger . error ( \"The email has not been sent\" , me ) ; \nreturn false ; \n} \n} \n} \n) ; \nelse { \nfinal StringBuffer result = new StringBuffer ( ) ; \ntry { \nmsg . setSentDate ( new Date ( ) ) ; \nmsg . send ( ) ; \n} \ncatch ( Throwable e ) { \nMailException me = new MailException ( \"Error while sending email\" , e ) ; \nlogger . error ( \"The email has not been sent\" , me ) ; \nresult . append ( \"oops\" ) ; \n} \nreturn new Future < Boolean > ( ) { \npublic boolean cancel ( boolean mayInterruptIfRunning ) { \nreturn false ; \n} \npublic boolean isCancelled ( ) { \nreturn false ; \n} \npublic boolean isDone ( ) { \nreturn true ; \n} \npublic Boolean get ( ) throws InterruptedException , ExecutionException { \nreturn result . length ( ) == 0 ; \n} \npublic Boolean get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nreturn result . length ( ) == 0 ; \n} \n} \n; \n} \n} \n} \n"}
{"9963": "public class ApplicationRouter { \npublic void bind ( final RouteBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null || versions . isEmpty ( ) ) versions = Collections . singletonList ( defaultVersion ) ; \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( method == Method . ANY ) for ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \nelse methods . add ( method ) ; \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nList < PatternRouteBinding > b = routeBindings . get ( key ) ; \nif ( b == null ) { \nb = new ArrayList < > ( ) ; \nrouteBindings . put ( key , b ) ; \n} \nlogger . info ( \"ADD: {}, Pattern: {}, Route: {}\\n\" , key , handler . getPath ( ) , handler ) ; \naddPattern ( handler , b ) ; \n} \n} \n} \n} \n"}
{"9964": "public class ApplicationRouter { \npublic void bind ( final FilterBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nfinal String path = handler . getPath ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null || versions . isEmpty ( ) ) versions = Collections . singletonList ( defaultVersion ) ; \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( method == Method . ANY ) for ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \nelse methods . add ( method ) ; \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nlogger . info ( \"ADD: {}, Pattern: {}, Filter: {}\\n\" , key , path , handler ) ; \nList < PatternFilterBinding > allFilterBindings = this . filterBindings . get ( key ) ; \nif ( allFilterBindings == null ) { \nallFilterBindings = new ArrayList < > ( ) ; \nthis . filterBindings . put ( key , allFilterBindings ) ; \n} \nboolean found = false ; \nfor ( final PatternFilterBinding binding : allFilterBindings ) { \nif ( binding . getPattern ( ) . pattern ( ) . equals ( handler . getPath ( ) ) ) { \nbinding . addFilter ( handler ) ; \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nfinal PatternFilterBinding binding = new PatternFilterBinding ( handler . getPath ( ) , handler ) ; \nallFilterBindings . add ( binding ) ; \n} \n} \n} \n} \n} \n"}
{"9965": "public class HasAnyRolesTag { \n@ Override protected boolean showTagBody ( String roleName ) { \nboolean hasAnyRole = false ; \nSubject subject = getSubject ( ) ; \nif ( subject != null ) for ( String role : roleName . split ( StringPool . COMMA ) ) { \nif ( subject . hasRole ( role . trim ( ) ) ) { \nhasAnyRole = true ; \nbreak ; \n} \n} \nreturn hasAnyRole ; \n} \n} \n"}
{"9967": "public class Strs { \npublic static String [ ] removeDuplicateStrings ( String [ ] array ) { \nif ( ObjectKit . isEmpty ( array ) ) return array ; \nSet < String > set = new TreeSet < String > ( ) ; \nfor ( String element : array ) { \nset . add ( element ) ; \n} \nreturn toStringArray ( set ) ; \n} \n} \n"}
{"9969": "public class PeriodicService { \npublic void doRun ( ) throws Exception { \nif ( inProgress . compareAndSet ( false , true ) ) try { \nrun ( ) ; \n} \nfinally { \ninProgress . set ( false ) ; \n} \nelse throw new IllegalStateException ( \"Another run is already in progress\" ) ; \n} \n} \n"}
{"9970": "public class SecurityKit { \npublic static < T extends Model > boolean login ( T user , String password , boolean remember , HttpServletRequest request , HttpServletResponse response ) { \nboolean matcher = SecurityKit . checkPassword ( user . getStr ( \"salt\" ) , user . getStr ( \"password\" ) , password ) ; \nif ( matcher ) SecurityKit . setLoginMember ( request , response , user , remember ) ; \nreturn matcher ; \n} \n} \n"}
{"9971": "public class SecurityKit { \npublic static < T extends Model > T getLoginWithDb ( HttpServletRequest req , HttpServletResponse response , Function < Long , T > function ) { \nT loginUser = getLoginUser ( req ) ; \nif ( loginUser == null ) { \nCookieUser cookie_user = getUserFromCookie ( req ) ; \nif ( cookie_user == null ) return null ; \nT user = CacheKit . get ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) ) ; \nif ( user == null ) { \nuser = function . apply ( cookie_user . getId ( ) ) ; \nCacheKit . put ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) , user ) ; \n} \nif ( user != null && StringUtils . equalsIgnoreCase ( user . getStr ( \"password\" ) , cookie_user . getPassword ( ) ) ) { \nsetLoginMember ( req , response , user , true ) ; \nreturn user ; \n} \nelse return null ; \n} \nelse return loginUser ; \n} \n} \n"}
{"9976": "public class SecurityKit { \nprivate static CookieUser userForCookie ( String uuid , HttpServletRequest request ) { \nif ( StringUtils . isBlank ( uuid ) ) return null ; \nString ck = decrypt ( uuid ) ; \nfinal String [ ] items = StringUtils . split ( ck , '|' ) ; \nif ( items . length == 5 ) { \nString ua = request . getHeader ( \"user-agent\" ) ; \nint ua_code = ( ua == null ) ? 0 : ua . hashCode ( ) ; \nint old_ua_code = Integer . parseInt ( items [ 3 ] ) ; \nif ( ua_code == old_ua_code ) return new CookieUser ( NumberUtils . toLong ( items [ 0 ] , - 1L ) , items [ 1 ] , false ) ; \n} \nreturn null ; \n} \n} \n"}
{"9978": "public class FileRenamePolicyWrapper { \npublic String appendFileSeparator ( String path ) { \nif ( null == path ) return File . separator ; \nif ( ! path . startsWith ( StringPool . SLASH ) && ! path . startsWith ( StringPool . BACK_SLASH ) ) path = File . separator + path ; \nif ( ! path . endsWith ( StringPool . SLASH ) && ! path . endsWith ( StringPool . BACK_SLASH ) ) path = path + File . separator ; \nreturn path ; \n} \n} \n"}
{"9980": "public class Logger { \npublic static void debug ( String message , Object ... args ) { \nif ( recordCaller ) LoggerFactory . getLogger ( getCallerClassName ( ) ) . debug ( message , args ) ; \nelse slf4j . debug ( message , args ) ; \n} \n} \n"}
{"9982": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length ] ; \nfor ( int i = 0 ; \ni < carr . length ; \ni ++ ) barr [ i ] = ( byte ) carr [ i ] ; \nreturn barr ; \n} \n} \n"}
{"9983": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( int i = 0 ; \ni < barr . length ; \ni ++ ) barr [ i ] = ( byte ) charSequence . charAt ( i ) ; \nreturn barr ; \n} \n} \n"}
{"9984": "public class CharKit { \npublic static char [ ] toSimpleCharArray ( byte [ ] barr ) { \nchar [ ] carr = new char [ barr . length ] ; \nfor ( int i = 0 ; \ni < barr . length ; \ni ++ ) carr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; \nreturn carr ; \n} \n} \n"}
{"9988": "public class Images { \npublic static void crop ( File originalImage , File to , int x1 , int y1 , int x2 , int y2 ) { \ntry { \nBufferedImage source = ImageIO . read ( originalImage ) ; \nString mimeType = \"image/jpeg\" ; \nif ( to . getName ( ) . endsWith ( \".png\" ) ) mimeType = \"image/png\" ; \nif ( to . getName ( ) . endsWith ( \".gif\" ) ) mimeType = \"image/gif\" ; \nint width = x2 - x1 ; \nint height = y2 - y1 ; \nBufferedImage dest = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; \nImage croppedImage = source . getSubimage ( x1 , y1 , width , height ) ; \nGraphics graphics = dest . getGraphics ( ) ; \ngraphics . setColor ( Color . WHITE ) ; \ngraphics . fillRect ( 0 , 0 , width , height ) ; \ngraphics . drawImage ( croppedImage , 0 , 0 , null ) ; \nImageWriter writer = ImageIO . getImageWritersByMIMEType ( mimeType ) . next ( ) ; \nImageWriteParam params = writer . getDefaultWriteParam ( ) ; \nwriter . setOutput ( new FileImageOutputStream ( to ) ) ; \nIIOImage image = new IIOImage ( dest , null , null ) ; \nwriter . write ( null , image , params ) ; \nwriter . dispose ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"9990": "public class Invoker { \npublic static void invokeInThread ( DirectInvocation invocation ) { \nboolean retry = true ; \nwhile ( retry ) { \ninvocation . run ( ) ; \nif ( invocation . retry == null ) retry = false ; \nelse { \ntry { \nif ( invocation . retry . task != null ) invocation . retry . task . get ( ) ; \nelse Thread . sleep ( invocation . retry . timeout ) ; \n} \ncatch ( Exception e ) { \nthrow new UnexpectedException ( e ) ; \n} \nretry = true ; \n} \n} \n} \n} \n"}
{"9995": "public class Controller { \nprotected String parsePath ( String currentActionPath , String url ) { \nif ( url . startsWith ( SLASH ) ) return url . split ( \"\\\\?\" ) [ 0 ] ; \nelse if ( ! url . contains ( SLASH ) ) return SLASH + currentActionPath . split ( SLASH ) [ 1 ] + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \nelse if ( url . contains ( \"http:\" ) || url . contains ( \"https:\" ) ) return null ; \nreturn currentActionPath + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \n} \n"}
{"9999": "public class Redirect { \npublic void to ( WebContext context ) { \nHttpServletResponse response = context . response ( ) ; \nif ( ! mediaType . isEmpty ( ) ) response . setHeader ( \"Content-Type\" , mediaType ) ; \nif ( status > 0 ) response . setStatus ( status ) ; \ntry { \nresponse . sendRedirect ( response . encodeRedirectURL ( url ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UncheckedException ( e ) ; \n} \n} \n} \n"}
{"10000": "public class ExtensionList { \npublic List < T > list ( Injector injector ) { \nList < T > r = new ArrayList < T > ( ) ; \nfor ( Injector i = injector ; \ni != null ; \ni = i . getParent ( ) ) for ( Entry < Key < ? > , Binding < ? > > e : i . getBindings ( ) . entrySet ( ) ) { \nif ( e . getKey ( ) . getTypeLiteral ( ) . equals ( type ) ) r . add ( ( T ) e . getValue ( ) . getProvider ( ) . get ( ) ) ; \n} \nreturn r ; \n} \n} \n"}
{"10002": "public class RuntimeKit { \npublic static void compactMemory ( ) { \ntry { \nfinal byte [ ] [ ] unused = new byte [ 128 ] [ ] ; \nfor ( int i = unused . length ; \ni -- != 0 ; \n) unused [ i ] = new byte [ 2000000000 ] ; \n} \ncatch ( OutOfMemoryError ignore ) { \n} \nSystem . gc ( ) ; \n} \n} \n"}
{"10003": "public class LogUtil { \n@ Nullable public static MetricsCollection propagate ( Metrics metrics ) { \nfinal MetricsCollection metricsCollection = getLocalMetricsCollection ( ) ; \nif ( metricsCollection != null ) metricsCollection . add ( metrics ) ; \nreturn metricsCollection ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nint estimatedSize = 0 ; \nfinal int len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' || ch == ',' ) { \nestimatedSize += 3 ; \ncontinue ; \n} \n++ estimatedSize ; \n} \nif ( value . length ( ) == estimatedSize ) return value ; \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \nfor ( int i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nbuilder . append ( \"%20\" ) ; \ncontinue ; \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \ncontinue ; \n} \nbuilder . append ( ch ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10006": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output ) throws IOException { \nbyte [ ] buffer = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( true ) { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \nif ( read == - 1 ) break ; \noutput . write ( buffer , 0 , read ) ; \ncount += read ; \n} \nreturn count ; \n} \n} \n"}
{"10007": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { \nbyte buffer [ ] = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( byteCount > 0 ) { \nif ( byteCount < ioBufferSize ) read = input . read ( buffer , 0 , byteCount ) ; \nelse read = input . read ( buffer , 0 , ioBufferSize ) ; \nif ( read == - 1 ) break ; \nbyteCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10010": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output , int charCount ) throws IOException { \nchar buffer [ ] = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( charCount > 0 ) { \nif ( charCount < ioBufferSize ) read = input . read ( buffer , 0 , charCount ) ; \nelse read = input . read ( buffer , 0 , ioBufferSize ) ; \nif ( read == - 1 ) break ; \ncharCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10013": "public class StreamUtil { \npublic static boolean compare ( InputStream input1 , InputStream input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedInputStream ) ) input1 = new BufferedInputStream ( input1 ) ; \nif ( ! ( input2 instanceof BufferedInputStream ) ) input2 = new BufferedInputStream ( input2 ) ; \nint ch = input1 . read ( ) ; \nwhile ( ch != - 1 ) { \nint ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) return false ; \nch = input1 . read ( ) ; \n} \nint ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10014": "public class StreamUtil { \npublic static boolean compare ( Reader input1 , Reader input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedReader ) ) input1 = new BufferedReader ( input1 ) ; \nif ( ! ( input2 instanceof BufferedReader ) ) input2 = new BufferedReader ( input2 ) ; \nint ch = input1 . read ( ) ; \nwhile ( ch != - 1 ) { \nint ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) return false ; \nch = input1 . read ( ) ; \n} \nint ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \nfor ( int i = 0 ; \ni < stages . size ( ) ; \ni ++ ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( stage instanceof Function ) if ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) return io ; \nelse if ( stage instanceof Predicate ) if ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) return io ; \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10018": "public class ZipKit { \npublic static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nwhile ( zipEntries . hasMoreElements ( ) ) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( patterns != null && patterns . length > 0 ) if ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) continue ; \nFile file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; \nif ( entry . isDirectory ( ) ) if ( ! file . mkdirs ( ) ) if ( ! file . isDirectory ( ) ) throw new IOException ( \"Failed to create directory: \" + file ) ; \nelse { \nFile parent = file . getParentFile ( ) ; \nif ( parent != null && ! parent . exists ( ) ) if ( ! parent . mkdirs ( ) ) if ( ! file . isDirectory ( ) ) throw new IOException ( \"Failed to create directory: \" + parent ) ; \nInputStream in = zip . getInputStream ( entry ) ; \nOutputStream out = null ; \ntry { \nout = new FileOutputStream ( file ) ; \nStreamUtil . copy ( in , out ) ; \n} \nfinally { \nStreamUtil . close ( out ) ; \nStreamUtil . close ( in ) ; \n} \n} \n} \nclose ( zip ) ; \n} \n} \n"}
{"10025": "public class Validator { \npublic static boolean isBirthDay ( String value ) { \nString check = \"(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\" ; \nif ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { \nint year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; \nint month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; \nint day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; \nif ( month < 1 || month > 12 ) return false ; \nif ( day < 1 || day > 31 ) return false ; \nif ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) return false ; \nif ( month == 2 ) { \nboolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; \nif ( day > 29 || ( day == 29 && ! isleap ) ) return false ; \n} \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"10034": "public class IO { \npublic static String readContentAsString ( File file , String encoding ) { \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nStringWriter result = new StringWriter ( ) ; \nPrintWriter out = new PrintWriter ( result ) ; \nBufferedReader reader = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; \nString line = null ; \nwhile ( ( line = reader . readLine ( ) ) != null ) out . println ( line ) ; \nreturn result . toString ( ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \nfinally { \nif ( is != null ) try { \nis . close ( ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n"}
{"10036": "public class IO { \npublic static void copyDirectory ( File source , File target ) { \nif ( source . isDirectory ( ) ) { \nif ( ! target . exists ( ) ) target . mkdir ( ) ; \nfor ( String child : source . list ( ) ) { \ncopyDirectory ( new File ( source , child ) , new File ( target , child ) ) ; \n} \n} \nelse try { \nwrite ( new FileInputStream ( source ) , new FileOutputStream ( target ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \n} \n} \n"}
{"10043": "public class ClassKit { \npublic static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { \nPreconditions . checkNotNull ( clazz , \"Class must not be null\" ) ; \ntry { \nClassLoader target = clazz . getClassLoader ( ) ; \nif ( target == null ) return true ; \nClassLoader cur = classLoader ; \nif ( cur == target ) return true ; \nwhile ( cur != null ) { \ncur = cur . getParent ( ) ; \nif ( cur == target ) return true ; \n} \nreturn false ; \n} \ncatch ( SecurityException ex ) { \nreturn true ; \n} \n} \n} \n"}
{"10047": "public class ClassKit { \npublic static boolean isAssignable ( Class < ? > lhsType , Class < ? > rhsType ) { \nPreconditions . checkNotNull ( lhsType , \"Left-hand side type must not be null\" ) ; \nPreconditions . checkNotNull ( rhsType , \"Right-hand side type must not be null\" ) ; \nif ( lhsType . isAssignableFrom ( rhsType ) ) return true ; \nif ( lhsType . isPrimitive ( ) ) { \nClass < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( rhsType ) ; \nif ( resolvedPrimitive != null && lhsType . equals ( resolvedPrimitive ) ) return true ; \n} \nelse { \nClass < ? > resolvedWrapper = primitiveTypeToWrapperMap . get ( rhsType ) ; \nif ( resolvedWrapper != null && lhsType . isAssignableFrom ( resolvedWrapper ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"10052": "public class URITemplate { \npublic Map < String , String > variables ( String uri ) { \nMap < String , String > variables = new HashMap < String , String > ( ) ; \nMatcher matcher = pattern . matcher ( uri ) ; \nif ( matcher . matches ( ) ) for ( int i = 0 ; \ni < matcher . groupCount ( ) ; \ni ++ ) variables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; \nreturn variables ; \n} \n} \n"}
{"10054": "public class DruidDbIntializer { \npublic static DruidPlugin druidPlugin ( Properties dbProp ) { \nString dbUrl = dbProp . getProperty ( GojaPropConst . DBURL ) , username = dbProp . getProperty ( GojaPropConst . DBUSERNAME ) , password = dbProp . getProperty ( GojaPropConst . DBPASSWORD ) ; \nif ( ! Strings . isNullOrEmpty ( dbUrl ) ) { \nString dbtype = JdbcUtils . getDbType ( dbUrl , StringUtils . EMPTY ) ; \nString driverClassName ; \ntry { \ndriverClassName = JdbcUtils . getDriverClassName ( dbUrl ) ; \n} \ncatch ( SQLException e ) { \nthrow new DatabaseException ( e . getMessage ( ) , e ) ; \n} \nfinal DruidPlugin druidPlugin = new DruidPlugin ( dbUrl , username , password , driverClassName ) ; \nsetValidatorQuery ( dbtype , druidPlugin ) ; \ndruidPlugin . addFilter ( new StatFilter ( ) ) ; \nfinal String initialSize = dbProp . getProperty ( GojaPropConst . DB_INITIAL_SIZE ) ; \nif ( ! Strings . isNullOrEmpty ( initialSize ) ) druidPlugin . setInitialSize ( MoreObjects . firstNonNull ( Ints . tryParse ( initialSize ) , 6 ) ) ; \nfinal String initial_minidle = dbProp . getProperty ( GojaPropConst . DB_INITIAL_MINIDLE ) ; \nif ( ! Strings . isNullOrEmpty ( initial_minidle ) ) druidPlugin . setMinIdle ( MoreObjects . firstNonNull ( Ints . tryParse ( initial_minidle ) , 5 ) ) ; \nfinal String initial_maxwait = dbProp . getProperty ( GojaPropConst . DB_INITIAL_MAXWAIT ) ; \nif ( ! Strings . isNullOrEmpty ( initial_maxwait ) ) druidPlugin . setMaxWait ( MoreObjects . firstNonNull ( Ints . tryParse ( initial_maxwait ) , 5 ) ) ; \nfinal String initial_active = dbProp . getProperty ( GojaPropConst . DB_INITIAL_ACTIVE ) ; \nif ( ! Strings . isNullOrEmpty ( initial_active ) ) druidPlugin . setMaxActive ( MoreObjects . firstNonNull ( Ints . tryParse ( initial_active ) , 5 ) ) ; \nfinal String timeBetweenEvictionRunsMillis = dbProp . getProperty ( GojaPropConst . DB_TIME_BETWEEN_EVICTION_RUNS_MILLIS ) ; \nif ( ! Strings . isNullOrEmpty ( timeBetweenEvictionRunsMillis ) ) { \nfinal Integer millis = MoreObjects . firstNonNull ( Ints . tryParse ( timeBetweenEvictionRunsMillis ) , 10000 ) ; \ndruidPlugin . setTimeBetweenEvictionRunsMillis ( millis ) ; \n} \nfinal String minEvictableIdleTimeMillis = dbProp . getProperty ( GojaPropConst . DB_MIN_EVICTABLE_IDLE_TIME_MILLIS ) ; \nif ( ! Strings . isNullOrEmpty ( minEvictableIdleTimeMillis ) ) { \nfinal Integer idleTimeMillis = MoreObjects . firstNonNull ( Ints . tryParse ( minEvictableIdleTimeMillis ) , 10000 ) ; \ndruidPlugin . setMinEvictableIdleTimeMillis ( idleTimeMillis ) ; \n} \nfinal WallFilter wall = new WallFilter ( ) ; \nwall . setDbType ( dbtype ) ; \ndruidPlugin . addFilter ( wall ) ; \nif ( GojaConfig . getPropertyToBoolean ( GojaPropConst . DBLOGFILE , false ) ) druidPlugin . addFilter ( new Slf4jLogFilter ( ) ) ; \nreturn druidPlugin ; \n} \nreturn null ; \n} \n} \n"}
{"10056": "public class AbstractRequest { \nprotected Object builtin ( Type type ) { \nClass < ? > rawType = Types . getRawType ( type ) ; \nif ( rawType . equals ( WebContext . class ) ) return context ; \nelse if ( rawType . equals ( HttpServletRequest . class ) ) return context . request ( ) ; \nelse if ( rawType . equals ( HttpServletResponse . class ) ) return context . response ( ) ; \nelse if ( rawType . equals ( HttpSession . class ) ) return context . session ( ) ; \nelse if ( rawType . equals ( ServletContext . class ) ) return context . application ( ) ; \nelse return this ; \n} \n} \n"}
{"10057": "public class AbstractRequest { \nprotected Object primitive ( Type type ) { \nClass < ? > rawType = Types . getRawType ( type ) ; \nif ( rawType . equals ( Boolean . TYPE ) ) return ( boolean ) false ; \nelse if ( rawType . equals ( Character . TYPE ) ) return ( char ) 0 ; \nelse if ( rawType . equals ( Byte . TYPE ) ) return ( byte ) 0 ; \nelse if ( rawType . equals ( Double . TYPE ) ) return ( double ) 0.0 ; \nelse if ( rawType . equals ( Float . TYPE ) ) return ( float ) 0.0 ; \nelse if ( rawType . equals ( Integer . TYPE ) ) return ( int ) 0 ; \nelse return ( short ) 0 ; \n} \n} \n"}
{"10059": "public class AbstractRequest { \nprotected Object convertUserDefinedValueType ( Object object , Class < ? > type ) { \nif ( type . isAssignableFrom ( object . getClass ( ) ) ) return object ; \nelse if ( object instanceof String ) { \ntry { \nConstructor < ? > constructor = type . getConstructor ( String . class ) ; \nreturn constructor . newInstance ( object ) ; \n} \ncatch ( Exception e ) { \nlogger . debug ( \"Cannot invoke [public \" + type . getName ( ) + \"(String.class)] constrcutor on [\" + type + \"]\" , e ) ; \n} \ntry { \nreturn type . getMethod ( \"valueOf\" , String . class ) . invoke ( null , object ) ; \n} \ncatch ( Exception e1 ) { \nlogger . debug ( \"Cannot invoke [public static \" + type . getName ( ) + \".valueOf(String.class)]\" + \"method on [\" + type + \"]\" , e1 ) ; \n} \n} \nelse logger . warn ( \"Parameter [\" + object + \"] cannot be converted to [\" + type + \"]\" ) ; \nreturn null ; \n} \n} \n"}
{"10060": "public class AbstractRequest { \nprotected Object query ( Type type , String name ) { \nreturn parameter ( type , name , new Function < String , Object > ( ) { \npublic Object apply ( String name ) { \nreturn context . request ( ) . getParameter ( name ) ; \n} \n} \n, new Function < String , Collection < Object > > ( ) { \n@ SuppressWarnings ( \"unchecked\" ) public Collection < Object > apply ( String name ) { \nHttpServletRequest request = context . request ( ) ; \nMap < String , Object > map = new TreeMap < String , Object > ( ) ; \nfor ( Object object : Collections . list ( request . getParameterNames ( ) ) ) { \nString key = ( String ) object ; \nif ( key . startsWith ( name + \"[\" ) ) map . put ( key , request . getParameter ( key ) ) ; \n} \nreturn ( map . isEmpty ( ) ) ? null : map . values ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"10061": "public class AbstractRequest { \nprotected Object cookie ( Type type , String name ) { \nreturn parameter ( type , name , new Function < String , Object > ( ) { \npublic Object apply ( String name ) { \nCookie [ ] cookies = context . request ( ) . getCookies ( ) ; \nif ( cookies != null ) for ( Cookie cookie : cookies ) { \nif ( cookie . getName ( ) . equals ( name ) ) return cookie . getValue ( ) ; \n} \nreturn null ; \n} \n} \n, new Function < String , Collection < Object > > ( ) { \npublic Collection < Object > apply ( String name ) { \nHttpServletRequest request = context . request ( ) ; \nMap < String , Object > map = new TreeMap < String , Object > ( ) ; \nCookie [ ] cookies = request . getCookies ( ) ; \nif ( cookies != null ) for ( Cookie cookie : cookies ) { \nString key = cookie . getName ( ) ; \nif ( key . startsWith ( name + \"[\" ) ) map . put ( key , cookie . getValue ( ) ) ; \n} \nreturn ( map . isEmpty ( ) ) ? null : map . values ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"10062": "public class AbstractRequest { \nprotected Object session ( Type type , String name ) { \nreturn parameter ( type , name , new Function < String , Object > ( ) { \npublic Object apply ( String name ) { \nreturn context . session ( ) . getAttribute ( name ) ; \n} \n} \n, new Function < String , Collection < Object > > ( ) { \n@ SuppressWarnings ( \"unchecked\" ) public Collection < Object > apply ( String name ) { \nHttpSession session = context . session ( ) ; \nObject attribute = session . getAttribute ( name ) ; \nif ( attribute instanceof Collection < ? > ) return ( Collection < Object > ) attribute ; \nMap < String , Object > map = new TreeMap < String , Object > ( ) ; \nfor ( Object object : Collections . list ( session . getAttributeNames ( ) ) ) { \nString key = ( String ) object ; \nif ( key . startsWith ( name + \"[\" ) ) map . put ( key , session . getAttribute ( key ) ) ; \n} \nreturn ( map . isEmpty ( ) ) ? null : map . values ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"10063": "public class Goja { \nprivate void initDataSource ( final Plugins plugins ) { \nfinal Map < String , Properties > dbConfig = GojaConfig . loadDBConfig ( GojaConfig . getConfigProps ( ) ) ; \nfor ( String db_config : dbConfig . keySet ( ) ) { \nfinal Properties db_props = dbConfig . get ( db_config ) ; \nif ( db_props != null && ! db_props . isEmpty ( ) ) DruidDbIntializer . init ( db_config , plugins , db_props ) ; \n} \nif ( GojaConfig . getPropertyToBoolean ( GojaPropConst . DB_SQLINXML , true ) ) plugins . add ( new SqlInXmlPlugin ( ) ) ; \n} \n} \n"}
{"10064": "public class Goja { \nprivate void setFtlSharedVariable ( ) { \nfinal Configuration config = FreeMarkerRender . getConfiguration ( ) ; \nconfig . setSharedVariable ( \"block\" , new BlockDirective ( ) ) ; \nconfig . setSharedVariable ( \"extends\" , new ExtendsDirective ( ) ) ; \nconfig . setSharedVariable ( \"override\" , new OverrideDirective ( ) ) ; \nconfig . setSharedVariable ( \"super\" , new SuperDirective ( ) ) ; \nconfig . setSharedVariable ( \"prettytime\" , new PrettyTimeDirective ( ) ) ; \nif ( GojaConfig . isSecurity ( ) ) config . setSharedVariable ( \"shiro\" , new ShiroTags ( config . getObjectWrapper ( ) ) ) ; \n} \n} \n"}
{"10069": "public class RequestPermission { \nprivate static boolean anyValueDenied ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( values instanceof Permission [ ] ) { \nSet < Permission > valueSet = new LinkedHashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) for ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \nreturn true ; \n} \n} \n} \nelse if ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permissionSet = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermissionSet . add ( perm . toString ( ) ) ; \n} \nif ( permissionSet . containsAll ( valueSet ) ) for ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( Permission . get ( ( String ) value ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10073": "public class ReflectionKit { \npublic static boolean declaresException ( Method method , Class < ? > exceptionType ) { \nPreconditions . checkNotNull ( method , \"Method must not be null\" ) ; \nClass < ? > [ ] declaredExceptions = method . getExceptionTypes ( ) ; \nfor ( Class < ? > declaredException : declaredExceptions ) { \nif ( declaredException . isAssignableFrom ( exceptionType ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"10074": "public class ConcurrentSoftHashMap { \nprivate void processQueue ( ) { \nSoftValue < ? , ? > sv ; \nwhile ( ( sv = ( SoftValue < ? , ? > ) queue . poll ( ) ) != null ) map . remove ( sv . key ) ; \n} \n} \n"}
{"10076": "public class WildcharUtils { \npublic static boolean match ( String string , String pattern ) { \nif ( string . equals ( pattern ) ) return true ; \nreturn match ( string , pattern , 0 , 0 ) ; \n} \n} \n"}
{"10077": "public class ArgumentHandler { \npublic static < A > A readArguments ( Class < A > interfaceClass , String [ ] args ) { \nA result = null ; \ntry { \nfinal ArgumentHandler argumentHandler = new ArgumentHandler ( args ) ; \nresult = argumentHandler . getInstance ( interfaceClass ) ; \nargumentHandler . processArguments ( new ArgumentProcessor ( ) { \n@ Override public void process ( List < String > remaining ) throws InvalidArgumentsException { \nif ( remaining . size ( ) > 0 ) throw new InvalidArgumentsException ( \"The following arguments could not be understood: \" + remaining ) ; \n} \n} \n) ; \n} \ncatch ( InvalidArgumentsException e ) { \nSystem . out . println ( e . getMessage ( ) ) ; \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \nif ( result instanceof ArgumentsWithHelp ) if ( ( ( ArgumentsWithHelp ) result ) . getHelp ( ) ) { \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"10078": "public class ProtobufSerializerUtils { \npublic static final ProtobufEntity getProtobufEntity ( Class < ? > clazz ) { \nfinal ProtobufEntity protoBufEntity = clazz . getAnnotation ( ProtobufEntity . class ) ; \nif ( protoBufEntity != null ) return protoBufEntity ; \nreturn null ; \n} \n} \n"}
{"10079": "public class ProtobufSerializerUtils { \npublic static final boolean isProtbufEntity ( Class < ? > clazz ) { \nfinal ProtobufEntity protoBufEntity = getProtobufEntity ( clazz ) ; \nif ( protoBufEntity != null ) return true ; \nreturn false ; \n} \n} \n"}
{"10080": "public class ProtobufSerializerUtils { \npublic static final Map < Field , ProtobufAttribute > getAllProtbufFields ( Class < ? extends Object > fromClazz ) { \nMap < Field , ProtobufAttribute > protoBufFields = CLASS_TO_FIELD_MAP_CACHE . get ( fromClazz . getCanonicalName ( ) ) ; \nif ( protoBufFields != null ) return protoBufFields ; \nelse protoBufFields = new HashMap < > ( ) ; \nfinal List < Field > fields = JReflectionUtils . getAllFields ( new ArrayList < Field > ( ) , fromClazz ) ; \nfor ( Field field : fields ) { \nfinal Annotation annotation = field . getAnnotation ( ProtobufAttribute . class ) ; \nif ( annotation == null ) continue ; \nfinal ProtobufAttribute gpbAnnotation = ( ProtobufAttribute ) annotation ; \nprotoBufFields . put ( field , gpbAnnotation ) ; \n} \nCLASS_TO_FIELD_MAP_CACHE . put ( fromClazz . getCanonicalName ( ) , protoBufFields ) ; \nreturn protoBufFields ; \n} \n} \n"}
{"10081": "public class ProtobufSerializerUtils { \npublic static final String getProtobufGetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_GETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( map != null ) if ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) return map . get ( fieldName ) ; \nelse map = new ConcurrentHashMap < > ( ) ; \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString getter = \"get\" + upperCaseFirstFieldName ; \nif ( Collection . class . isAssignableFrom ( field . getType ( ) ) ) getter += \"List\" ; \nif ( ! protobufAttribute . protobufGetter ( ) . isEmpty ( ) ) return protobufAttribute . protobufGetter ( ) ; \nmap . put ( fieldName , getter ) ; \nCLASS_TO_FIELD_GETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn getter ; \n} \n} \n"}
{"10082": "public class ProtobufSerializerUtils { \npublic static final String getPojoSetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_SETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( map != null ) if ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) return map . get ( fieldName ) ; \nelse map = new ConcurrentHashMap < > ( ) ; \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString setter = \"set\" + upperCaseFirstFieldName ; \nif ( ! protobufAttribute . pojoSetter ( ) . isEmpty ( ) ) return protobufAttribute . pojoSetter ( ) ; \nmap . put ( fieldName , setter ) ; \nCLASS_TO_FIELD_SETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn setter ; \n} \n} \n"}
{"10085": "public class JsonUtil { \npublic static < T > String toJson ( T obj ) { \nStringWriter writer = new StringWriter ( ) ; \nString jsonStr = \"\" ; \nJsonGenerator gen = null ; \ntry { \ngen = getJsonFactory ( ) . createGenerator ( writer ) ; \ngetMapper ( ) . writeValue ( gen , obj ) ; \nwriter . flush ( ) ; \njsonStr = writer . toString ( ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"{}\" , e . getMessage ( ) , e ) ; \n} \nfinally { \nif ( gen != null ) try { \ngen . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nreturn jsonStr ; \n} \n} \n"}
{"10089": "public class AttributeInjector { \nprotected void copyOutAttributes ( Object target , List < Attribute > jmxAttributeValues , Map < String , Method > attributeSetters , String identifierKey , Object identifier ) { \nfor ( Attribute oneAttribute : jmxAttributeValues ) { \nString attributeName = oneAttribute . getName ( ) ; \nMethod setter = attributeSetters . get ( attributeName ) ; \nObject value = oneAttribute . getValue ( ) ; \ntry { \nif ( ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( Integer . class ) ) || ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( int . class ) ) ) if ( value instanceof Long ) value = ( ( Long ) value ) . intValue ( ) ; \nsetter . invoke ( target , value ) ; \n} \ncatch ( InvocationTargetException invocationExc ) { \nthis . log . info ( \"invocation exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , invocationExc ) ; \n} \ncatch ( IllegalAccessException illegalAccessExc ) { \nthis . log . info ( \"illegal access exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , illegalAccessExc ) ; \n} \ncatch ( IllegalArgumentException illegalArgumentExc ) { \nthis . log . info ( \"illegal argument exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , illegalArgumentExc ) ; \n} \n} \n} \n} \n"}
{"10095": "public class ClassLoaderUtils { \npublic static ClassLoader getDefault ( ) { \nClassLoader loader = null ; \ntry { \nloader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \n} \ncatch ( Exception e ) { \n} \nif ( loader == null ) { \nloader = ClassLoaderUtils . class . getClassLoader ( ) ; \nif ( loader == null ) loader = ClassLoader . getSystemClassLoader ( ) ; \n} \nreturn loader ; \n} \n} \n"}
{"10096": "public class ClassLoaderUtils { \npublic static URL getResource ( String name , ClassLoader classLoader ) { \nValidate . notNull ( name , \"resourceName must be not null\" ) ; \nif ( name . startsWith ( \"/\" ) ) name = name . substring ( 1 ) ; \nif ( classLoader != null ) { \nURL url = classLoader . getResource ( name ) ; \nif ( url != null ) return url ; \n} \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( loader != null && loader != classLoader ) { \nURL url = loader . getResource ( name ) ; \nif ( url != null ) return url ; \n} \nreturn ClassLoader . getSystemResource ( name ) ; \n} \n} \n"}
{"10097": "public class ClassLoaderUtils { \npublic static InputStream getResourceAsStream ( String name , ClassLoader classLoader ) throws IOException { \nURL url = getResource ( name , classLoader ) ; \nif ( url != null ) return url . openStream ( ) ; \nreturn null ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) throw new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) break ; \nif ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) throw new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) throw new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) break ; \nif ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) throw new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) throw new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) throw new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) throw new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10102": "public class URI { \nprivate void setScheme ( String p_scheme ) throws MalformedURIException { \nif ( p_scheme == null ) throw new MalformedURIException ( \"Cannot set scheme from null string!\" ) ; \nif ( ! isConformantSchemeName ( p_scheme ) ) throw new MalformedURIException ( \"The scheme is not conformant.\" ) ; \nm_scheme = p_scheme ; \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) m_userinfo = null ; \nelse { \nif ( m_host == null ) throw new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) throw new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \nelse if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) throw new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10104": "public class URI { \nprivate void setHost ( String p_host ) throws MalformedURIException { \nif ( p_host == null || p_host . length ( ) == 0 ) { \nm_host = p_host ; \nm_userinfo = null ; \nm_port = null ; \nn_port = - 1 ; \n} \nelse if ( ! isWellFormedAddress ( p_host ) ) throw new MalformedURIException ( \"Host is not a well formed address!\" ) ; \nm_host = p_host ; \n} \n} \n"}
{"10105": "public class URI { \nprivate void setPort ( int p_port ) throws MalformedURIException { \nif ( p_port >= 0 && p_port <= 65535 ) if ( m_host == null ) throw new MalformedURIException ( \"Port cannot be set when host is null!\" ) ; \nelse if ( p_port != - 1 ) throw new MalformedURIException ( \"Invalid port number!\" ) ; \nn_port = p_port ; \n} \n} \n"}
{"10106": "public class URI { \nprivate void appendPath ( String p_addToPath ) throws MalformedURIException { \nif ( p_addToPath == null || p_addToPath . length ( ) == 0 ) return ; \nif ( ! isURIString ( p_addToPath ) ) throw new MalformedURIException ( \"Path contains invalid character!\" ) ; \nif ( m_path == null || m_path . length ( ) == 0 ) if ( p_addToPath . startsWith ( \"/\" ) ) m_path = p_addToPath ; \nelse m_path = \"/\" + p_addToPath ; \nelse if ( m_path . endsWith ( \"/\" ) ) if ( p_addToPath . startsWith ( \"/\" ) ) m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; \nelse m_path = m_path . concat ( p_addToPath ) ; \nelse if ( p_addToPath . startsWith ( \"/\" ) ) m_path = m_path . concat ( p_addToPath ) ; \nelse m_path = m_path . concat ( \"/\" + p_addToPath ) ; \n} \n} \n"}
{"10107": "public class URI { \nprivate void setQueryString ( String p_queryString ) throws MalformedURIException { \nif ( p_queryString == null ) m_queryString = null ; \nelse if ( ! isGenericURI ( ) ) throw new MalformedURIException ( \"Query string can only be set for a generic URI!\" ) ; \nelse if ( getPath ( ) == null ) throw new MalformedURIException ( \"Query string cannot be set when path is null!\" ) ; \nelse if ( ! isURIString ( p_queryString ) ) throw new MalformedURIException ( \"Query string contains invalid character!\" ) ; \nelse m_queryString = p_queryString ; \n} \n} \n"}
{"10108": "public class URI { \npublic void setFragment ( String p_fragment ) throws MalformedURIException { \nif ( p_fragment == null ) m_fragment = null ; \nelse if ( ! isGenericURI ( ) ) throw new MalformedURIException ( \"Fragment can only be set for a generic URI!\" ) ; \nelse if ( getPath ( ) == null ) throw new MalformedURIException ( \"Fragment cannot be set when path is null!\" ) ; \nelse if ( ! isURIString ( p_fragment ) ) throw new MalformedURIException ( \"Fragment contains invalid character!\" ) ; \nelse m_fragment = p_fragment ; \n} \n} \n"}
{"10110": "public class PreparedStatementCreator { \nprotected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { \nPreparedStatement ps = conn . prepareStatement ( sql ) ; \nif ( parameters != null ) { \nint index = 1 ; \nwhile ( parameters . hasNext ( ) ) { \nObject parameter = parameters . next ( ) ; \nif ( parameter == null ) ps . setObject ( index , null ) ; \nelse ps . setObject ( index , parameter ) ; \nindex ++ ; \n} \n} \nreturn ps ; \n} \n} \n"}
{"10114": "public class MuffinManager { \npublic Transferable getClipboardContents ( ) { \nif ( ( clipboardReadStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) return null ; \nclipboardReadStatus = CLIPBOARD_DISABLED ; \nif ( cs == null ) try { \ncs = ( ClipboardService ) ServiceManager . lookup ( \"javax.jnlp.ClipboardService\" ) ; \n} \ncatch ( UnavailableServiceException e ) { \ncs = null ; \n} \nif ( cs != null ) { \nTransferable tr = cs . getContents ( ) ; \nif ( tr != null ) clipboardReadStatus = CLIPBOARD_ENABLED ; \nreturn tr ; \n} \nreturn null ; \n} \n} \n"}
{"10115": "public class MuffinManager { \npublic boolean setClipboardContents ( Transferable data ) { \nif ( data == null ) return false ; \nif ( ( clipboardWriteStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) return false ; \nclipboardWriteStatus = CLIPBOARD_ENABLED ; \nif ( cs == null ) try { \ncs = ( ClipboardService ) ServiceManager . lookup ( \"javax.jnlp.ClipboardService\" ) ; \n} \ncatch ( UnavailableServiceException e ) { \ncs = null ; \n} \nif ( cs != null ) try { \ncs . setContents ( data ) ; \nclipboardWriteStatus = CLIPBOARD_ENABLED ; \nreturn true ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn false ; \n} \n} \n"}
{"10116": "public class MuffinManager { \npublic InputStream openFileStream ( String pathHint , String [ ] extensions ) { \nif ( fos == null ) try { \nfos = ( FileOpenService ) ServiceManager . lookup ( \"javax.jnlp.FileOpenService\" ) ; \n} \ncatch ( UnavailableServiceException e ) { \nfos = null ; \n} \nif ( fos != null ) try { \nFileContents fc = fos . openFileDialog ( pathHint , extensions ) ; \nreturn fc . getInputStream ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"10118": "public class ServiceManager { \npublic static void setServiceParams ( ParametrizedOperation op , Map < String , Object > params ) { \nif ( params != null ) for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { \nop . setParam ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \n} \n"}
{"10123": "public class FastBuffer { \n@ Override public Iterator < E > iterator ( ) { \nreturn new Iterator < E > ( ) { \nint iteratorIndex ; \nint iteratorBufferIndex ; \nint iteratorOffset ; \n@ Override public boolean hasNext ( ) { \nreturn iteratorIndex < size ; \n} \n@ Override public E next ( ) { \nif ( iteratorIndex >= size ) throw new NoSuchElementException ( ) ; \nE [ ] buf = buffers [ iteratorBufferIndex ] ; \nE result = buf [ iteratorOffset ] ; \niteratorIndex ++ ; \niteratorOffset ++ ; \nif ( iteratorOffset >= buf . length ) { \niteratorOffset = 0 ; \niteratorBufferIndex ++ ; \n} \nreturn result ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"10125": "public class JdbcLogDriver { \n@ Override public java . util . logging . Logger getParentLogger ( ) throws SQLFeatureNotSupportedException { \nif ( drivers . size ( ) == 1 ) return getFirstDriver ( ) . getParentLogger ( ) ; \nreturn null ; \n} \n} \n"}
{"10136": "public class StringEnumeratedMap { \nprotected Map < String , V > getAsMap ( ) { \nMap < String , V > result = map ; \nif ( result == null ) synchronized ( this ) { \nresult = map ; \nif ( result == null ) map = ( result = initialize ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"10137": "public class ReflexUtil { \npublic static < T > void makeAccessible ( final Constructor < T > constructor ) { \nif ( ! Modifier . isPublic ( constructor . getModifiers ( ) ) || ! Modifier . isPublic ( constructor . getDeclaringClass ( ) . getModifiers ( ) ) ) constructor . setAccessible ( true ) ; \n} \n} \n"}
{"10138": "public class ObjectQueryPreparer { \npublic ObjectQueryInfo prepareObjectQuery ( Object obj ) throws MalformedObjectNameException { \nObjectQueryInfo result ; \nString onamePattern = MBeanAnnotationUtil . getLocationONamePattern ( obj ) ; \nif ( onamePattern != null ) { \nMap < String , Method > attributeSetters = MBeanAnnotationUtil . getAttributes ( obj ) ; \nif ( attributeSetters . size ( ) > 0 ) { \nString onameString ; \nif ( obj instanceof MBeanLocationParameterSource ) onameString = this . parameterReplacer . replaceObjectNameParameters ( onamePattern , ( MBeanLocationParameterSource ) obj ) ; \nelse onameString = onamePattern ; \nObjectName oname = new ObjectName ( onameString ) ; \nresult = new ObjectQueryInfo ( obj , oname , attributeSetters ) ; \n} \nelse { \nthis . logNoAttributeThrottle . warn ( log , \"ignoring attempt to prepare to poll an MBean object with no attributes: onamePattern={}\" , onamePattern ) ; \nresult = null ; \n} \n} \nelse { \nlog . warn ( \"ignoring attempt to prepare to poll object that has no MBeanLocation\" ) ; \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"10139": "public class Util { \npublic static String replaceSlashWithHyphen ( String origin ) { \nchar [ ] resulltChars = origin . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < resulltChars . length - 1 ; \ni ++ ) if ( resulltChars [ i ] == '/' ) resulltChars [ i ] = '-' ; \nreturn new String ( resulltChars , 0 , resulltChars . length - 1 ) ; \n} \n} \n"}
{"10140": "public class Util { \npublic static String bytes2HexString ( byte [ ] bytes ) { \nStringBuffer resultBuffer = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni ++ ) resultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; \nreturn resultBuffer . toString ( ) ; \n} \n} \n"}
{"10141": "public class NamedParameterStatement { \nprivate List < Integer > getIndexes ( String name ) { \nList < Integer > indexes = nameIndexMap . get ( name ) ; \nif ( indexes == null ) throw new IllegalArgumentException ( \"Parameter not found: \" + name ) ; \nreturn indexes ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) if ( c == '\\'' ) inSingleQuote = false ; \nelse if ( inDoubleQuote ) if ( c == '\"' ) inDoubleQuote = false ; \nelse if ( c == '\\'' ) inSingleQuote = true ; \nelse if ( c == '\"' ) inDoubleQuote = true ; \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) j ++ ; \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10143": "public class ProtobufSerializer { \nprivate static final Object convertCollectionToProtobufs ( Collection < Object > collectionOfNonProtobufs ) throws JException { \nif ( collectionOfNonProtobufs . isEmpty ( ) ) return collectionOfNonProtobufs ; \nfinal Object first = collectionOfNonProtobufs . toArray ( ) [ 0 ] ; \nif ( ! ProtobufSerializerUtils . isProtbufEntity ( first ) ) return collectionOfNonProtobufs ; \nfinal Collection < Object > newCollectionValues ; \nif ( collectionOfNonProtobufs instanceof Set ) newCollectionValues = new HashSet < > ( ) ; \nelse newCollectionValues = new ArrayList < > ( ) ; \nfor ( Object iProtobufGenObj : collectionOfNonProtobufs ) { \nnewCollectionValues . add ( serializeToProtobufEntity ( iProtobufGenObj ) ) ; \n} \nreturn newCollectionValues ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrIncludeExtensions . length ; \ni ++ ) if ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) for ( int i = 0 ; \ni < m_rgstrExcludeExtensions . length ; \ni ++ ) if ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; \nreturn true ; \n} \n} \n"}
{"10148": "public class StateParser { \nprivate static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { \nfinal Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; \nfinal List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; \nfor ( int index = 0 ; \nindex < labels . size ( ) ; \nindex ++ ) { \nfinal String next = labels . get ( index ) ; \nExpectedLabels labelValue ; \ntry { \nlabelValue = ExpectedLabels . valueOf ( next ) ; \nunusedLabels . remove ( labelValue ) ; \nif ( map . containsKey ( labelValue ) ) LOGGER . warn ( \"Duplicate state label: {} ({})\" , next , labels ) ; \nmap . put ( labelValue , index ) ; \n} \ncatch ( final IllegalArgumentException e ) { \nLOGGER . warn ( \"Unexpected state label: {}\" , next ) ; \n} \n} \nfor ( final ExpectedLabels label : unusedLabels ) { \nLOGGER . warn ( \"Unused label: {}\" , label ) ; \n} \nreturn map ; \n} \n} \n"}
{"10151": "public class JmxAttributePoller { \npublic void poll ( ) throws IOException { \nsynchronized ( this ) { \nif ( shutdownInd ) return ; \npollActiveInd = true ; \n} \ntry { \nthis . checkConnection ( ) ; \nthis . concurrencyTestHooks . beforePollProcessorStart ( ) ; \nif ( this . mBeanAccessConnection instanceof MBeanBatchCapableAccessConnection ) this . batchPollProcessor . pollBatch ( ( MBeanBatchCapableAccessConnection ) this . mBeanAccessConnection , this . polledObjects ) ; \nelse this . pollIndividually ( ) ; \n} \ncatch ( IOException ioExc ) { \nthis . safeClose ( this . mBeanAccessConnection ) ; \nthis . mBeanAccessConnection = null ; \nthrow ioExc ; \n} \nfinally { \nthis . concurrencyTestHooks . afterPollProcessorFinish ( ) ; \nsynchronized ( this ) { \npollActiveInd = false ; \nthis . notifyAll ( ) ; \n} \n} \n} \n} \n"}
{"10152": "public class JmxAttributePoller { \nprotected boolean pollIndividually ( ) throws IOException { \nthis . concurrencyTestHooks . onStartPollIndividually ( ) ; \nList < SchedulerProcessExecutionSlip > processExecutionSlipList = new LinkedList < > ( ) ; \nfor ( final Object onePolledObject : this . polledObjects ) { \nif ( shutdownInd ) return true ; \nSchedulerProcess process = new PollOneObjectSchedulerProcess ( onePolledObject ) ; \nSchedulerProcessExecutionSlip executionSlip = this . scheduler . startProcess ( process ) ; \nprocessExecutionSlipList . add ( executionSlip ) ; \n} \nfor ( SchedulerProcessExecutionSlip oneExecutionSlip : processExecutionSlipList ) { \ntry { \noneExecutionSlip . waitUntilComplete ( ) ; \nPollOneObjectSchedulerProcess process = ( PollOneObjectSchedulerProcess ) oneExecutionSlip . getSchedulerProcess ( ) ; \nException exc = process . getFailureException ( ) ; \nif ( exc != null ) { \nlog . warn ( \"failed to poll object\" , exc ) ; \nif ( exc instanceof IOException ) throw ( IOException ) exc ; \n} \n} \ncatch ( InterruptedException intExc ) { \nlog . info ( \"interrupted while polling object\" ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"10153": "public class ClassUtil { \npublic static Field getDeclaredField ( Class < ? > clazz , String fieldName , boolean recursively ) { \ntry { \nreturn clazz . getDeclaredField ( fieldName ) ; \n} \ncatch ( NoSuchFieldException e ) { \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null && recursively ) return getDeclaredField ( superClass , fieldName , true ) ; \n} \ncatch ( SecurityException e ) { \nlog . error ( \"{}\" , e . getMessage ( ) , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"10155": "public class ClassUtil { \npublic static Method getDeclaredMethod ( Class < ? > clazz , boolean recursively , String methodName , Class < ? > ... parameterTypes ) { \ntry { \nreturn clazz . getDeclaredMethod ( methodName , parameterTypes ) ; \n} \ncatch ( NoSuchMethodException e ) { \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null && recursively ) return getDeclaredMethod ( superClass , true , methodName , parameterTypes ) ; \n} \ncatch ( SecurityException e ) { \nlog . error ( \"{}\" , e . getMessage ( ) , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"10158": "public class DebugOutputStream { \nprotected void dumpByte ( int b ) { \nif ( passThrough == true ) System . out . print ( '\\t' ) ; \nif ( b < 0 ) b += 128 ; \nif ( b < 0x10 ) System . out . print ( '0' ) ; \nSystem . out . print ( ' ' ) ; \nSystem . out . print ( Integer . toHexString ( b ) . toUpperCase ( ) ) ; \n} \n} \n"}
{"10159": "public class StringUtils { \npublic static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { \nif ( startIndex < 0 ) startIndex = 0 ; \nint srclen = s . length ( ) ; \nif ( endIndex > srclen ) endIndex = srclen ; \nint sublen = substr . length ( ) ; \nif ( sublen == 0 ) return startIndex > srclen ? srclen : startIndex ; \nsubstr = substr . toLowerCase ( ) ; \nint total = endIndex - sublen + 1 ; \nchar c = substr . charAt ( 0 ) ; \nmainloop : for ( int i = startIndex ; \ni < total ; \ni ++ ) { \nif ( Character . toLowerCase ( s . charAt ( i ) ) != c ) continue ; \nint j = 1 ; \nint k = i + 1 ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( s . charAt ( k ) ) ; \nif ( substr . charAt ( j ) != source ) continue mainloop ; \nj ++ ; \nk ++ ; \n} \nreturn i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"10160": "public class StringUtils { \npublic static String removeChars ( String s , String chars ) { \nint i = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( i ) ; \nfor ( int j = 0 ; \nj < i ; \nj ++ ) { \nchar c = s . charAt ( j ) ; \nif ( chars . indexOf ( c ) == - 1 ) sb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"10162": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initAudit ( final CommonProperties commonProps ) { \ntry { \nfinal String auditClassName = commonProps . getAuditClassName ( ) ; \nif ( ! commonProps . isAuditEnabled ( ) ) { \nfinal String error = \"Auditing has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse if ( auditClassName == null ) { \nfinal String error = \"Auditing has been enabled in the JAAS configuration, but no audit class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isAuditSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The audit class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10163": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initMessageQueue ( final CommonProperties commonProps ) { \ntry { \nfinal String messageClassName = commonProps . getMessageQueueClassName ( ) ; \nif ( ! commonProps . isMessageQueueEnabled ( ) ) { \nfinal String error = \"Message queue has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse if ( messageClassName == null ) { \nfinal String error = \"Message queue has been enabled in the JAAS configuration, \" + \"but no message queue class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isMessageQueueSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The message class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10164": "public class PasswordLoginModule { \nprivate void initPwValidator ( final CommonProperties commonProps ) { \ntry { \nfinal String validatorClass = commonProps . getPasswordValidatorClassName ( ) ; \nif ( validatorClass == null ) { \nfinal String error = \"No password validator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isPasswordValidatorSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getSingleton ( validatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getInstance ( validatorClass , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10165": "public class PasswordLoginModule { \nprivate void initPwAuthenticator ( final CommonProperties commonProps ) { \ntry { \nfinal String authNticatorClass = commonProps . getPasswordAuthenticatorClassName ( ) ; \nif ( authNticatorClass == null ) { \nfinal String error = \"No password authenticator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isPasswordAuthenticatorSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getSingleton ( authNticatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getInstance ( authNticatorClass , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10169": "public class ArrayStack { \npublic void clear ( ) { \nint i = size ; \nObject [ ] els = elements ; \nwhile ( i -- > 0 ) els [ i ] = null ; \nthis . size = 0 ; \n} \n} \n"}
{"10170": "public class ArrayStack { \npublic T push ( T element ) { \nint i ; \nObject [ ] els ; \nif ( ( i = size ++ ) >= ( els = elements ) . length ) System . arraycopy ( els , 0 , els = elements = new Object [ i << 1 ] , 0 , i ) ; \nels [ i ] = element ; \nreturn element ; \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nint patNdxStart = 0 ; \nint patNdxEnd = patterns . length - 1 ; \nint tokNdxStart = 0 ; \nint tokNdxEnd = tokens . length - 1 ; \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) break ; \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) return false ; \npatNdxStart ++ ; \ntokNdxStart ++ ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) return false ; \nreturn true ; \n} \nif ( patNdxStart > patNdxEnd ) return false ; \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) break ; \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) return false ; \npatNdxEnd -- ; \ntokNdxEnd -- ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) return false ; \nreturn true ; \n} \nwhile ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { \nint patIdxTmp = - 1 ; \nfor ( int i = patNdxStart + 1 ; \ni <= patNdxEnd ; \ni ++ ) if ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart ++ ; \ncontinue ; \n} \nint patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nint strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nint ndx = - 1 ; \nstrLoop : for ( int i = 0 ; \ni <= strLength - patLength ; \ni ++ ) { \nfor ( int j = 0 ; \nj < patLength ; \nj ++ ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) continue strLoop ; \n} \nndx = tokNdxStart + i ; \nbreak ; \n} \nif ( ndx == - 1 ) return false ; \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) return false ; \nreturn true ; \n} \n} \n"}
{"10178": "public class Rectangular { \npublic Rectangular intersection ( Rectangular other ) { \nif ( this . intersects ( other ) ) return new Rectangular ( Math . max ( x1 , other . x1 ) , Math . max ( y1 , other . y1 ) , Math . min ( x2 , other . x2 ) , Math . min ( y2 , other . y2 ) ) ; \nelse return new Rectangular ( ) ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) target . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10187": "public class JdbcLogSupport { \nprotected Throwable unwrapThrowable ( Throwable t ) { \nThrowable e = t ; \nwhile ( true ) if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; \nelse if ( t instanceof UndeclaredThrowableException ) e = ( ( UndeclaredThrowableException ) t ) . getUndeclaredThrowable ( ) ; \nelse return e ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nint fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \nfor ( int i = 2 ; \ni < 32 ; \ni = i * 2 ) if ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) arg += \", \" ; \nswitch ( i ) { \ncase 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) arg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) arg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \nbreak ; \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \n} \n} \n"}
{"10193": "public class QueryParameter { \npublic QueryParameter partialCopy ( final QueryParameterKind ... excludedElements ) { \nList < QueryParameterKind > excludedList = Arrays . asList ( excludedElements ) ; \nQueryParameter returnValue = new QueryParameter ( ) ; \nif ( ! excludedList . contains ( QueryParameterKind . CONSTRAINTS ) ) returnValue . rawConstraints = this . rawConstraints ; \nif ( ! excludedList . contains ( QueryParameterKind . GROUPS ) ) returnValue . groups = this . groups ; \nif ( ! excludedList . contains ( QueryParameterKind . ORDERS ) ) returnValue . orders = this . orders ; \nif ( ! excludedList . contains ( QueryParameterKind . PAGE ) ) { \nreturnValue . pageSize = this . pageSize ; \nreturnValue . page = this . page ; \n} \nif ( ! excludedList . contains ( QueryParameterKind . TIMEZONE ) ) returnValue . timezoneName = this . timezoneName ; \nreturn returnValue ; \n} \n} \n"}
{"10196": "public class SequenceIterator { \nprivate E nextInternal ( ) { \nif ( nextSolution != null ) return nextSolution ; \nnextSolution = nextInSequence ( ) ; \nif ( nextSolution == null ) exhausted = true ; \nreturn nextSolution ; \n} \n} \n"}
{"10198": "public class WAMCompiledClause { \nprivate void addInstructionsAndThisToParent ( SizeableList < WAMInstruction > instructions ) { \nif ( ! addedToParent ) { \nparent . addInstructions ( this , instructions ) ; \naddedToParent = true ; \n} \nelse parent . addInstructions ( instructions ) ; \n} \n} \n"}
{"10202": "public class BigDecimalTypeImpl { \npublic static Type createInstance ( String name , int precision , int scale , String min , String max ) { \nsynchronized ( DECIMAL_TYPES ) { \nBigDecimalTypeImpl newType = new BigDecimalTypeImpl ( name , precision , scale , min , max ) ; \nBigDecimalTypeImpl oldType = DECIMAL_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nDECIMAL_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( comp < 0 ) return - 1 ; \nelse if ( comp > 0 ) return 1 ; \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) return - 1 ; \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) return 1 ; \nreturn 0 ; \n} \n} \n"}
{"10206": "public class DataStreamServlet { \npublic void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { \nlog . fine ( \"void service(HttpServletRequest, HttpServletResponse): called\" ) ; \nString contentType = ( String ) request . getAttribute ( \"contentType\" ) ; \nString contentDisposition = ( String ) request . getAttribute ( \"contentDisposition\" ) ; \nInputStream inputStream = ( InputStream ) request . getAttribute ( \"inputStream\" ) ; \nif ( contentType != null ) response . setContentType ( contentType ) ; \nif ( contentDisposition != null ) response . addHeader ( \"Content-disposition\" , contentDisposition ) ; \nBufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; \nint length = - 1 ; \nbyte [ ] chunk = new byte [ 8192 ] ; \nwhile ( ( length = inputStream . read ( chunk ) ) != - 1 ) outputStream . write ( chunk , 0 , length ) ; \noutputStream . flush ( ) ; \ninputStream . close ( ) ; \n} \n} \n"}
{"10207": "public class PageControlTag { \npublic int doStartTag ( ) throws JspException { \nlog . fine ( \"public int doStartTag(): called\" ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nPagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; \nlog . fine ( \"list = \" + list ) ; \nString url ; \ntry { \nurl = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new JspException ( \"Got malformed URL exception: \" , e ) ; \n} \nrenderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; \nrenderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; \nint from = list . getCurrentIndex ( ) ; \nint to = list . getCurrentIndex ( ) + maxPages ; \nfor ( int i = from ; \n( i < list . size ( ) ) && ( i < to ) ; \ni ++ ) renderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , \"\" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; \nrenderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; \nrenderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; \nrenderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; \nreturn SKIP_BODY ; \n} \n} \n"}
{"10208": "public class PageControlTag { \nprivate void renderButton ( boolean render , int page , int index , String openDelim , String url , String text , boolean active ) throws JspException { \nlog . fine ( \"private void renderButton(boolean render, int page, int index, String openDelim, String url, String text, boolean active): called\" ) ; \nlog . fine ( \"render = \" + render ) ; \nlog . fine ( \"page = \" + page ) ; \nlog . fine ( \"index = \" + index ) ; \nlog . fine ( \"openDelim = \" + openDelim ) ; \nlog . fine ( \"url = \" + url ) ; \nlog . fine ( \"text = \" + text ) ; \nlog . fine ( \"active = \" + active ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nif ( render ) { \ntagUtils . write ( pageContext , openDelim ) ; \nif ( active ) tagUtils . write ( pageContext , \"<a href=\\\"\" + url + \"?varName=\" + name + \"&number=\" + page + \"&index=\" + index + \"\\\">\" + text + \"</a>\" ) ; \nelse tagUtils . write ( pageContext , text ) ; \ntagUtils . write ( pageContext , closeDelim ) ; \n} \n} \n} \n"}
{"10210": "public class AbstractLearningMethod { \nprotected void initialize ( ) throws LearningFailureException { \nif ( inputExamples . isEmpty ( ) ) throw new LearningFailureException ( \"No training examples to learn from.\" , null ) ; \nif ( ! outputPropertiesSet ) addGoalProperty ( \"goal\" ) ; \nif ( ! inputPropertiesSet ) { \nState example = inputExamples . iterator ( ) . next ( ) ; \nSet < String > allProperties = example . getComponentType ( ) . getAllPropertyNames ( ) ; \ninputProperties = new HashSet < String > ( allProperties ) ; \ninputProperties . removeAll ( outputProperties ) ; \ninputPropertiesSet = true ; \n} \nfor ( State example : inputExamples ) { \nSet < String > properties = example . getComponentType ( ) . getAllPropertyNames ( ) ; \nString errorMessage = \"\" ; \nfor ( String inputProperty : inputProperties ) { \nif ( ! properties . contains ( inputProperty ) ) errorMessage += \"The training example, \" + example + \" does not contain the specified input property, \" + inputProperty + \"\\n\" ; \n} \nfor ( String outputProperty : outputProperties ) { \nif ( ! properties . contains ( outputProperty ) ) errorMessage += \"The training example, \" + example + \" does not contain the specified output property, \" + outputProperty + \"\\n\" ; \n} \nif ( ! \"\" . equals ( errorMessage ) ) throw new LearningFailureException ( errorMessage , null ) ; \n} \n} \n} \n"}
{"10211": "public class HashArray { \npublic V get ( Object key ) { \nInteger index = keyToIndex . get ( key ) ; \nif ( index == null ) return null ; \nreturn data . get ( index . intValue ( ) ) ; \n} \n} \n"}
{"10212": "public class HashArray { \npublic int getIndexOf ( Object key ) { \nInteger index = keyToIndex . get ( key ) ; \nif ( index == null ) return - 1 ; \nreturn index ; \n} \n} \n"}
{"10213": "public class HashArray { \npublic V set ( int index , V value ) throws IndexOutOfBoundsException { \nif ( index >= data . size ( ) ) throw new IndexOutOfBoundsException ( ) ; \nreturn data . set ( index , value ) ; \n} \n} \n"}
{"10214": "public class HashArray { \npublic V remove ( Object key ) { \nInteger index = keyToIndex . get ( key ) ; \nif ( index == null ) return null ; \nkeyToIndex . remove ( key ) ; \nkeySet . remove ( key ) ; \nV removedValue = data . remove ( index . intValue ( ) ) ; \nfor ( K nextKey : keyToIndex . keySet ( ) ) { \nInteger nextIndex = keyToIndex . get ( nextKey ) ; \nif ( nextIndex > index ) keyToIndex . put ( nextKey , nextIndex - 1 ) ; \n} \nreturn removedValue ; \n} \n} \n"}
{"10215": "public class HashArray { \npublic V remove ( int index ) throws IndexOutOfBoundsException { \nif ( index >= data . size ( ) ) throw new IndexOutOfBoundsException ( ) ; \nfor ( K nextKey : keyToIndex . keySet ( ) ) { \nint nextIndex = keyToIndex . get ( nextKey ) ; \nif ( index == nextIndex ) return remove ( nextKey ) ; \n} \nthrow new IndexOutOfBoundsException ( ) ; \n} \n} \n"}
{"10217": "public class PropertyIntrospectorBase { \nprotected void setProperty ( Object callee , String property , Object value ) { \nif ( ! initialized ) initialize ( callee ) ; \nMethod [ ] setterMethods = setters . get ( property ) ; \nif ( ( setterMethods == null ) || ( setterMethods . length == 0 ) ) throw new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; \nMethod setterMethod = null ; \nClass valueType = ( value == null ) ? null : value . getClass ( ) ; \nif ( value == null ) setterMethod = setterMethods [ 0 ] ; \nelse { \nfor ( Method method : setterMethods ) { \nClass argType = method . getParameterTypes ( ) [ 0 ] ; \nif ( argType . isAssignableFrom ( valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse if ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse if ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) && isAssignableFromPrimitive ( argType , valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \n} \nif ( setterMethod == null ) { \nClass calleeType = ( callee == null ) ? null : callee . getClass ( ) ; \nthrow new IllegalArgumentException ( \"No setter method for property \" + property + \", of type, \" + calleeType + \" will accept the type of value specified, \" + valueType + \".\" ) ; \n} \n} \ntry { \nObject [ ] args = new Object [ ] { \nvalue } \n; \nsetterMethod . invoke ( callee , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalArgumentException ( \"The setter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"The setter method for the property \" + property + \" cannot be accessed.\" , e ) ; \n} \n} \n} \n"}
{"10218": "public class PropertyIntrospectorBase { \nprotected Object getProperty ( Object callee , String property ) { \nif ( ! initialized ) initialize ( callee ) ; \nMethod getterMethod = getters . get ( property ) ; \nif ( getterMethod == null ) throw new IllegalArgumentException ( \"No getter method for the property \" + property + \" exists.\" ) ; \nObject result ; \ntry { \nresult = getterMethod . invoke ( callee ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( \"The getter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"The getter method for the property \" + property + \" cannot be accessed.\" , e ) ; \n} \nreturn result ; \n} \n} \n"}
{"10219": "public class PropertyIntrospectorBase { \nprivate boolean isAssignableFromPrimitive ( Class wrapperType , Class primitiveType ) { \nboolean result = false ; \nif ( primitiveType . equals ( boolean . class ) && wrapperType . equals ( Boolean . class ) ) result = true ; \nelse if ( primitiveType . equals ( byte . class ) && wrapperType . equals ( Byte . class ) ) result = true ; \nelse if ( primitiveType . equals ( char . class ) && wrapperType . equals ( Character . class ) ) result = true ; \nelse if ( primitiveType . equals ( short . class ) && wrapperType . equals ( Short . class ) ) result = true ; \nelse if ( primitiveType . equals ( int . class ) && wrapperType . equals ( Integer . class ) ) result = true ; \nelse if ( primitiveType . equals ( long . class ) && wrapperType . equals ( Long . class ) ) result = true ; \nelse if ( primitiveType . equals ( float . class ) && wrapperType . equals ( Float . class ) ) result = true ; \nelse if ( primitiveType . equals ( double . class ) && wrapperType . equals ( Double . class ) ) result = true ; \nelse result = false ; \nreturn result ; \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) return true ; \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) return true ; \nelse if ( left . isVar ( ) ) return unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \nelse if ( right . isVar ( ) ) return unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \nelse if ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) return false ; \nint arity = leftFunctor . getArity ( ) ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) return false ; \n} \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"10225": "public class PrologUnifier { \nprotected boolean unifyVar ( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( leftVar . isBound ( ) ) return unifyInternal ( leftVar . getValue ( ) , rightTerm , leftTrail , rightTrail ) ; \nelse if ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) return unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; \nelse { \nleftVar . setSubstitution ( rightTerm ) ; \nleftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; \nreturn true ; \n} \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( cutLevelVarSlot >= 0 ) preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \nfor ( int i = 0 ; \ni < expressions . length ; \ni ++ ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( expression instanceof BuiltIn ) builtIn = ( BuiltIn ) expression ; \nelse builtIn = this ; \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \n} \n} \n"}
{"10227": "public class InstructionCompiler { \nprivate int findMaxArgumentsInClause ( Clause clause ) { \nint result = 0 ; \nFunctor head = clause . getHead ( ) ; \nif ( head != null ) result = head . getArity ( ) ; \nFunctor [ ] body = clause . getBody ( ) ; \nif ( body != null ) for ( int i = 0 ; \ni < body . length ; \ni ++ ) { \nint arity = body [ i ] . getArity ( ) ; \nresult = ( arity > result ) ? arity : result ; \n} \nreturn result ; \n} \n} \n"}
{"10232": "public class ByteBufferUtils { \npublic static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { \nint charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; \nlength = ( charsRequired < length ) ? length : charsRequired ; \nint index = buffer . position ( ) + length - 1 ; \nint start = buffer . position ( ) ; \nbuffer . position ( buffer . position ( ) + length ) ; \nif ( value < 0 ) { \nbuffer . put ( MINUS_ASCII ) ; \nstart ++ ; \n} \nelse value = - value ; \ndo { \nint remainder = value % 10 ; \nvalue = value / 10 ; \nbuffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; \n} \nwhile ( value != 0 ) ; \nwhile ( index >= start ) buffer . put ( index -- , ZERO_ASCII ) ; \nreturn buffer ; \n} \n} \n"}
{"10233": "public class ByteBufferUtils { \npublic static String asString ( ByteBuffer buffer , int length ) { \nchar [ ] chars = new char [ length ] ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) chars [ i ] = ( char ) buffer . get ( i ) ; \nreturn String . valueOf ( chars ) ; \n} \n} \n"}
{"10234": "public class EnumeratedStringAttribute { \npublic String getStringValue ( ) { \nif ( attributeClass . finalized ) return attributeClass . lookupValue [ value ] . label ; \nelse return attributeClass . lookupValueList . get ( value ) . label ; \n} \n} \n"}
{"10235": "public class EnumeratedStringAttribute { \npublic void setStringValue ( String value ) throws IllegalArgumentException { \nByte b = attributeClass . lookupByte . get ( value ) ; \nif ( b == null ) if ( attributeClass . finalized ) throw new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized EnumeratedStringType, \" + attributeClass . attributeClassName + \".\" ) ; \nelse { \nEnumeratedStringAttribute newAttribute = attributeClass . createStringAttribute ( value ) ; \nb = newAttribute . value ; \n} \nthis . value = b ; \n} \n} \n"}
{"10236": "public class LojixTermReader { \nprivate void read ( Term term ) { \nif ( term . isNumber ( ) ) { \nNumericType numericType = ( NumericType ) term ; \nif ( numericType . isInteger ( ) ) { \nIntLiteral jplInteger = ( IntLiteral ) term ; \ngetContentHandler ( ) . startIntegerTerm ( jplInteger . longValue ( ) ) ; \n} \nelse if ( numericType . isFloat ( ) ) { \nFloatLiteral jplFloat = ( FloatLiteral ) term ; \ngetContentHandler ( ) . startFloatTerm ( jplFloat . doubleValue ( ) ) ; \n} \n} \nelse if ( term . isVar ( ) ) { \nVariable var = ( Variable ) term ; \ngetContentHandler ( ) . startVariable ( interner . getVariableName ( var . getName ( ) ) ) ; \n} \nelse if ( term . isAtom ( ) ) { \nFunctor atom = ( Functor ) term ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( atom . getName ( ) ) ) ; \n} \nelse if ( term . isCompound ( ) ) { \nFunctor functor = ( Functor ) term ; \ngetContentHandler ( ) . startCompound ( ) ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( functor . getName ( ) ) ) ; \nfor ( com . thesett . aima . logic . fol . Term child : functor . getArguments ( ) ) { \nread ( child ) ; \n} \ngetContentHandler ( ) . endCompound ( ) ; \n} \nelse throw new IllegalStateException ( \"Unrecognized Lojix term: \" + term ) ; \n} \n} \n"}
{"10245": "public class ReflectionUtils { \npublic static Object callMethod ( Object o , String method , Object [ ] params ) { \nClass cls = o . getClass ( ) ; \nClass [ ] paramClasses = new Class [ params . length ] ; \nfor ( int i = 0 ; \ni < params . length ; \ni ++ ) paramClasses [ i ] = params [ i ] . getClass ( ) ; \ntry { \nMethod m = cls . getMethod ( method , paramClasses ) ; \nreturn m . invoke ( o , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10248": "public class ReflectionUtils { \npublic static Set < Class > findMatchingSetters ( Class obClass , String propertyName ) { \nSet < Class > types = new HashSet < Class > ( ) ; \nString upperPropertyName = Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; \nMethod [ ] methods = obClass . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . equals ( \"set\" + upperPropertyName ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) types . add ( nextMethod . getParameterTypes ( ) [ 0 ] ) ; \n} \nreturn types ; \n} \n} \n"}
{"10251": "public class TypeHelper { \npublic static Type getTypeFromObject ( Object o ) { \nif ( o == null ) return new UnknownType ( ) ; \nif ( o instanceof Attribute ) return ( ( Attribute ) o ) . getType ( ) ; \nreturn new JavaType ( o ) ; \n} \n} \n"}
{"10252": "public class BaseQueueSearch { \npublic void reset ( ) { \nstartStates . clear ( ) ; \nenqueuedOnce = false ; \nqueue = createQueue ( ) ; \ngoalPredicate = null ; \nmaxSteps = 0 ; \nsearchSteps = 0 ; \nif ( repeatedStateFilter != null ) repeatedStateFilter . reset ( ) ; \nsearchAlgorithm . reset ( ) ; \n} \n} \n"}
{"10253": "public class BaseQueueSearch { \npublic T search ( ) throws SearchNotExhaustiveException { \nSearchNode < O , T > path = findGoalPath ( ) ; \nif ( path != null ) return path . getState ( ) ; \nelse return null ; \n} \n} \n"}
{"10254": "public class IntRangeType { \npublic static Type createInstance ( String name , int min , int max ) { \nif ( min > max ) throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \nsynchronized ( INT_RANGE_TYPES ) { \nIntRangeType newType = new IntRangeType ( name , min , max ) ; \nIntRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10255": "public class SchemaDefinitionImpl { \npublic void addSupportedTZ ( String tzName ) { \nif ( ! StringUtils . isBlank ( tzName ) && ! tzNamesAliases . containsKey ( tzName . trim ( ) ) ) { \ntzNamesAliases . put ( tzName . trim ( ) , tzName . trim ( ) ) ; \nif ( LOG . isInfoEnabled ( ) ) LOG . info ( \"Endpoint \" + this . getEndPointName ( ) + \" - add support of TZ: \" + tzName ) ; \n} \n} \n} \n"}
{"10256": "public class SchemaDefinitionImpl { \npublic void addTZAlternateDimension ( String orignalDimensionName , DimensionTable alternateDimension , String tzName ) { \naddSupportedTZ ( tzName ) ; \nif ( tzNamesAliases . containsValue ( tzName ) ) { \nsqlTables . put ( alternateDimension . getTableName ( ) , alternateDimension ) ; \nalternateDimensions . put ( Pair . of ( orignalDimensionName . toUpperCase ( ) , tzName ) , alternateDimension ) ; \n} \nelse LOG . error ( \"Unsuported timezone: \" + tzName ) ; \n} \n} \n"}
{"10257": "public class SchemaDefinitionImpl { \npublic void addDimension ( DimensionTable table , boolean mandatory ) { \nsqlTables . put ( table . getTableName ( ) , table ) ; \ndimensions . put ( table . getDimensionName ( ) . toUpperCase ( ) , table ) ; \nif ( mandatory ) mandatoryDimensionNames . add ( table . getDimensionName ( ) . toUpperCase ( Locale . ENGLISH ) ) ; \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) return \"\" ; \nelse { \nif ( delta >= 1 ) indentStack . push ( delta ) ; \nelse if ( delta < 0 ) indentStack . pop ( ) ; \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( delta < 0 ) ? delta : 0 ; \nfor ( int i = 0 ; \ni < traceIndent ; \ni ++ ) result . append ( \" \" ) ; \ntraceIndent += ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10267": "public class ProtoDTLearningMethod { \nprivate OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { \nMap < OrdinalAttribute , Integer > countMap = null ; \nint biggestCount = 0 ; \nOrdinalAttribute biggestAttribute = null ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( countMap == null ) countMap = new HashMap < OrdinalAttribute , Integer > ( ) ; \nint count ; \nif ( ! countMap . containsKey ( nextAttribute ) ) { \ncount = 1 ; \ncountMap . put ( nextAttribute , count ) ; \n} \nelse { \ncount = countMap . get ( nextAttribute ) ; \ncountMap . put ( nextAttribute , count ++ ) ; \n} \nif ( count > biggestCount ) { \nbiggestCount = count ; \nbiggestAttribute = nextAttribute ; \n} \n} \nreturn biggestAttribute ; \n} \n} \n"}
{"10268": "public class ProtoDTLearningMethod { \nprivate boolean allHaveSameClassification ( String property , Iterable < State > examples ) { \nOrdinalAttribute firstAttribute = null ; \nboolean success = true ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( firstAttribute == null ) firstAttribute = nextAttribute ; \nelse if ( ! nextAttribute . equals ( firstAttribute ) ) { \nsuccess = false ; \nbreak ; \n} \n} \nif ( success ) allClassification = firstAttribute ; \nreturn success ; \n} \n} \n"}
{"10273": "public class PagedList { \npublic List < E > get ( int index ) { \nint originalSize = original . size ( ) ; \nint size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; \nif ( ( index == 0 ) && ( originalSize == 0 ) ) return new ArrayList < E > ( ) ; \nif ( ( index >= size ) || ( index < 0 ) ) throw new IndexOutOfBoundsException ( \"Index \" + index + \" is less than zero or more than the number of pages: \" + size ) ; \nList < E > result = original . subList ( pageSize * index , ( ( pageSize * ( index + 1 ) ) >= originalSize ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; \nreturn result ; \n} \n} \n"}
{"10274": "public class Surface { \npublic void setTexture ( Paint obj ) { \nif ( obj instanceof GradientPaint ) texture = new GradientPaint ( 0 , 0 , Color . white , getSize ( ) . width * 2 , 0 , Color . green ) ; \nelse texture = obj ; \n} \n} \n"}
{"10275": "public class Surface { \npublic void paintImmediately ( int x , int y , int w , int h ) { \nRepaintManager repaintManager = null ; \nboolean save = true ; \nif ( ! isDoubleBuffered ( ) ) { \nrepaintManager = RepaintManager . currentManager ( this ) ; \nsave = repaintManager . isDoubleBufferingEnabled ( ) ; \nrepaintManager . setDoubleBufferingEnabled ( false ) ; \n} \nsuper . paintImmediately ( x , y , w , h ) ; \nif ( repaintManager != null ) repaintManager . setDoubleBufferingEnabled ( save ) ; \n} \n} \n"}
{"10276": "public class Surface { \nprotected BufferedImage createBufferedImage ( int w , int h , int imgType ) { \nBufferedImage bi = null ; \nif ( imgType == 0 ) bi = ( BufferedImage ) createImage ( w , h ) ; \nelse if ( ( imgType > 0 ) && ( imgType < 14 ) ) bi = new BufferedImage ( w , h , imgType ) ; \nelse if ( imgType == 14 ) bi = createBinaryImage ( w , h , 2 ) ; \nelse if ( imgType == 15 ) bi = createBinaryImage ( w , h , 4 ) ; \nelse if ( imgType == 16 ) bi = createSGISurface ( w , h , 32 ) ; \nelse if ( imgType == 17 ) bi = createSGISurface ( w , h , 16 ) ; \nbiw = w ; \nbih = h ; \nreturn bi ; \n} \n} \n"}
{"10277": "public class Surface { \nprotected Graphics2D createGraphics2D ( int width , int height , BufferedImage bi , Graphics g ) { \nGraphics2D g2 = null ; \nif ( bi != null ) g2 = bi . createGraphics ( ) ; \nelse g2 = ( Graphics2D ) g ; \ng2 . setBackground ( getBackground ( ) ) ; \ng2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , antiAlias ) ; \ng2 . setRenderingHint ( RenderingHints . KEY_RENDERING , rendering ) ; \nif ( clearSurface || clearOnce ) { \ng2 . clearRect ( 0 , 0 , width , height ) ; \nclearOnce = false ; \n} \nif ( texture != null ) { \ng2 . setComposite ( AlphaComposite . SrcOver ) ; \ng2 . setPaint ( texture ) ; \ng2 . fillRect ( 0 , 0 , width , height ) ; \n} \nif ( composite != null ) g2 . setComposite ( composite ) ; \nreturn g2 ; \n} \n} \n"}
{"10278": "public class Surface { \nprivate BufferedImage createBinaryImage ( int w , int h , int pixelBits ) { \nint bytesPerRow = w * pixelBits / 8 ; \nif ( ( w * pixelBits % 8 ) != 0 ) bytesPerRow ++ ; \nbyte [ ] imageData = new byte [ h * bytesPerRow ] ; \nIndexColorModel cm = null ; \nswitch ( pixelBits ) { \ncase 1 : { \ncm = new IndexColorModel ( pixelBits , lut1Arr . length , lut1Arr , lut1Arr , lut1Arr ) ; \nbreak ; \n} \ncase 2 : { \ncm = new IndexColorModel ( pixelBits , lut2Arr . length , lut2Arr , lut2Arr , lut2Arr ) ; \nbreak ; \n} \ncase 4 : { \ncm = new IndexColorModel ( pixelBits , lut4Arr . length , lut4Arr , lut4Arr , lut4Arr ) ; \nbreak ; \n} \ndefault : { \nnew Exception ( \"Invalid # of bit per pixel\" ) . printStackTrace ( ) ; \n} \n} \nDataBuffer db = new DataBufferByte ( imageData , imageData . length ) ; \nWritableRaster r = Raster . createPackedRaster ( db , w , h , pixelBits , null ) ; \nreturn new BufferedImage ( cm , r , false , null ) ; \n} \n} \n"}
{"10281": "public class IterativeBoundAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nfor ( float bound = startBound ; \n; \n) { \nmaxBound = bound ; \ntry { \nint numStepsSoFar = initSearch . getStepsTaken ( ) ; \ninitSearch . resetEnqueuedOnceFlag ( ) ; \nSearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; \nif ( node != null ) return node ; \nelse return null ; \n} \ncatch ( MaxBoundException e ) { \ne = null ; \n} \nif ( useEpsilon ) bound = bound + epsilon ; \nelse bound = getMinBeyondBound ( ) ; \n} \n} \n} \n"}
{"10282": "public class MaxStepsAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nif ( ! headNode . isExpanded ( ) ) headNode . expandSuccessors ( queue , reverseEnqueue ) ; \nSearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; \nif ( currentNode . isExpanded ( ) ) { \ncurrentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) return currentNode ; \n} \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) if ( queue . isEmpty ( ) ) return null ; \nelse throw new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"10284": "public class PrologParser { \npublic Clause clause ( ) throws SourceCodeException { \nvariableContext . clear ( ) ; \nTerm term = term ( ) ; \nClause clause = TermUtils . convertToClause ( term , interner ) ; \nif ( clause == null ) throw new SourceCodeException ( \"Only queries and clauses are valid sentences in Prolog, not \" + term + \".\" , null , null , null , term . getSourceCodePosition ( ) ) ; \nreturn clause ; \n} \n} \n"}
{"10287": "public class PrologParser { \npublic Term listFunctor ( ) throws SourceCodeException { \nint nilId = interner . internFunctorName ( \"nil\" , 0 ) ; \nint consId = interner . internFunctorName ( \"cons\" , 2 ) ; \nToken leftDelim = consumeToken ( LSQPAREN ) ; \nTerm [ ] args = null ; \nToken nextToken = tokenSource . peek ( ) ; \nswitch ( nextToken . kind ) { \ncase LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; \nbreak ; \ndefault : } \nTerm accumulator ; \nif ( tokenSource . peek ( ) . kind == CONS ) { \nif ( args == null ) throw new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \nconsumeToken ( CONS ) ; \naccumulator = term ( ) ; \n} \nelse accumulator = new Nil ( nilId , null ) ; \nToken rightDelim = consumeToken ( RSQPAREN ) ; \nif ( args != null ) for ( int i = args . length - 1 ; \ni >= 0 ; \ni -- ) { \nTerm previousAccumulator = accumulator ; \naccumulator = new Cons ( consId , new Term [ ] { \nargs [ i ] , previousAccumulator } \n) ; \n} \nSourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; \naccumulator . setSourceCodePosition ( position ) ; \nreturn ( Functor ) accumulator ; \n} \n} \n"}
{"10289": "public class PrologParser { \npublic Term variable ( ) throws SourceCodeException { \nToken name = consumeToken ( VAR ) ; \nint nameId = interner . internVariableName ( name . image ) ; \nVariable var = null ; \nif ( ! \"_\" . equals ( name . image ) ) var = variableContext . get ( nameId ) ; \nif ( var != null ) return var ; \nelse { \nvar = new Variable ( nameId , null , name . image . equals ( \"_\" ) ) ; \nvariableContext . put ( nameId , var ) ; \nreturn var ; \n} \n} \n} \n"}
{"10293": "public class PrologParser { \npublic Directive peekAndConsumeDirective ( ) throws SourceCodeException { \nif ( peekAndConsumeTrace ( ) ) return Directive . Trace ; \nif ( peekAndConsumeInfo ( ) ) return Directive . Info ; \nif ( peekAndConsumeUser ( ) ) return Directive . User ; \nreturn null ; \n} \n} \n"}
{"10294": "public class PrologParser { \npublic void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { \nint arity ; \nif ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) arity = 2 ; \nelse arity = 1 ; \nint name = interner . internFunctorName ( operatorName , arity ) ; \noperatorTable . setOperator ( name , operatorName , priority , associativity ) ; \n} \n} \n"}
{"10296": "public class PrologParser { \nprotected Token consumeToken ( int kind ) throws SourceCodeException { \nToken nextToken = tokenSource . peek ( ) ; \nif ( nextToken . kind != kind ) throw new SourceCodeException ( \"Was expecting \" + tokenImage [ kind ] + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \nelse { \nnextToken = tokenSource . poll ( ) ; \nreturn nextToken ; \n} \n} \n} \n"}
{"10297": "public class PrologParser { \nprivate boolean peekAndConsume ( int kind ) { \nToken nextToken = tokenSource . peek ( ) ; \nif ( nextToken . kind == kind ) { \ntry { \nconsumeToken ( kind ) ; \n} \ncatch ( SourceCodeException e ) { \nthrow new IllegalStateException ( e ) ; \n} \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"10298": "public class TxSessionImpl { \npublic void bind ( ) { \nif ( ( txId == null ) || ! txId . isValid ( ) ) txId = TxManager . createTxId ( ) ; \nTxManager . assignTxIdToThread ( txId ) ; \nthreadSession . set ( this ) ; \n} \n} \n"}
{"10300": "public class Filterators { \npublic static < T > Collection < T > collectIterator ( Iterator < T > iterator , Collection < T > targetCollection ) { \nwhile ( iterator . hasNext ( ) ) targetCollection . add ( iterator . next ( ) ) ; \nreturn targetCollection ; \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( i2 < 0 ) i2 = i2 - unitMillis + 1 ; \nint year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( diff < 0 ) year -- ; \nelse if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { \nlong oneYear ; \nif ( isLeapYear ( year ) ) oneYear = MILLIS_PER_DAY * 366L ; \nelse oneYear = MILLIS_PER_DAY * 365L ; \nyearStart += oneYear ; \nif ( yearStart <= ticks ) year ++ ; \n} \nreturn year ; \n} \n} \n"}
{"10310": "public class TimeUtils { \npublic static long millisToYearStart ( int year ) { \nint leapYears = year / 100 ; \nif ( year < 0 ) leapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; \nelse { \nleapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; \nif ( isLeapYear ( year ) ) leapYears -- ; \n} \nreturn ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; \n} \n} \n"}
{"10313": "public class SequentialCuckooFunction { \nprivate Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { \nEntry < K > uninsertedEntry = entry ; \nboolean createdNewEntry = false ; \nEntry < K > existingEntry = entryForKey ( key ) ; \nInteger result = null ; \nif ( existingEntry != null ) result = existingEntry . seq ; \nelse { \nif ( uninsertedEntry == null ) { \nuninsertedEntry = new Entry < K > ( ) ; \nuninsertedEntry . key = key ; \nuninsertedEntry . seq = nextSequenceNumber ; \nnextSequenceNumber ++ ; \ncount ++ ; \ncreatedNewEntry = true ; \nresult = uninsertedEntry . seq ; \n} \nwhile ( true ) { \nint keyHashCode = uninsertedEntry . key . hashCode ( ) ; \nuninsertedEntry . hash1 = hash1 ( keyHashCode ) ; \nuninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; \nuninsertedEntry = cuckoo ( uninsertedEntry ) ; \nif ( uninsertedEntry == null ) { \nresult = createdNewEntry ? result : - 1 ; \nbreak ; \n} \nif ( tryRehashing ) rehash ( ) ; \nelse { \nresult = null ; \nbreak ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"10314": "public class SequentialCuckooFunction { \nprivate Entry < K > entryForKey ( K key ) { \nint keyHashCode = key . hashCode ( ) ; \nint hash1 = hash1 ( keyHashCode ) ; \nEntry < K > entry = hashTable [ indexFor ( hash1 ) ] ; \nif ( ( entry != null ) && key . equals ( entry . key ) ) return entry ; \nint hash2 = hash2 ( hash1 , keyHashCode ) ; \nentry = hashTable [ indexFor ( hash2 ) ] ; \nif ( ( entry != null ) && key . equals ( entry . key ) ) return entry ; \nreturn null ; \n} \n} \n"}
{"10315": "public class SequentialCuckooFunction { \nprivate Entry < K > cuckoo ( Entry < K > entry ) { \nEntry < K > currentEntry = entry ; \nint hash = entry . hash1 ; \nint index = indexFor ( hash ) ; \nEntry < K > nextEntry = hashTable [ index ] ; \nint previousFlag = 0 ; \nint [ ] previousIndex = new int [ 2 ] ; \nint [ ] previousSeq = new int [ 2 ] ; \nfor ( int i = 0 ; \ni < hashTableSize ; \ni ++ ) { \nif ( nextEntry == null ) { \nhashTable [ index ] = currentEntry ; \nreturn null ; \n} \nhashTable [ index ] = currentEntry ; \ncurrentEntry = nextEntry ; \nint firstPosition = indexFor ( currentEntry . hash1 ) ; \nhash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; \nindex = indexFor ( hash ) ; \npreviousIndex [ previousFlag ] = index ; \npreviousSeq [ previousFlag ] = nextEntry . seq ; \npreviousFlag = ( previousFlag == 1 ) ? 0 : 1 ; \nnextEntry = hashTable [ index ] ; \nif ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) break ; \n} \nreturn currentEntry ; \n} \n} \n"}
{"10316": "public class SequentialCuckooFunction { \nprivate void rehash ( ) { \nint newSize = hashTableSize ; \nif ( hashTableSize < ( count * 2 ) ) { \nnewSize = hashTableSize * 2 ; \nif ( newSize > maxSize ) throw new IllegalStateException ( \"'newSize' of \" + newSize + \" would put the table over the maximum size limit of \" + maxSize ) ; \n} \nEntry < K > [ ] oldTable = hashTable ; \nhashTableSize = newSize ; \nlength = hashTable . length ; \nboolean rehashedOk ; \ndo { \nrehashedOk = true ; \nchangeHashFunctions ( ) ; \nhashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; \nfor ( Entry < K > entry : oldTable ) { \nif ( entry != null ) if ( applyWithEntry ( entry . key , entry , false ) == null ) { \nrehashedOk = false ; \nbreak ; \n} \n} \n} \nwhile ( ! rehashedOk ) ; \n} \n} \n"}
{"10317": "public class WorkPanel { \npublic void actionPerformed ( ActionEvent event ) { \nString action = event . getActionCommand ( ) ; \nif ( \"OK\" . equals ( action ) ) if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) saveWork ( ) ; \nelse if ( \"Cancel\" . equals ( action ) ) if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) discardWork ( ) ; \nelse if ( \"Apply\" . equals ( action ) ) if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) saveWork ( ) ; \n} \n} \n"}
{"10321": "public class WAMResolvingNativeMachine { \npublic static WAMResolvingNativeMachine getInstance ( SymbolTableImpl < Integer , String , Object > symbolTable ) throws ImplementationUnavailableException { \ntry { \nif ( ! libraryLoadAttempted ) { \nlibraryLoadAttempted = true ; \nSystem . loadLibrary ( \"aima_native\" ) ; \nlibraryFound = true ; \n} \nif ( libraryFound ) return new WAMResolvingNativeMachine ( symbolTable ) ; \nelse throw new ImplementationUnavailableException ( \"The native library could not be found.\" , null , null , null ) ; \n} \ncatch ( UnsatisfiedLinkError e ) { \nlibraryFound = false ; \nthrow new ImplementationUnavailableException ( \"The native library could not be found.\" , e , null , null ) ; \n} \n} \n} \n"}
{"10323": "public class InformationTheory { \npublic static double expectedI ( double [ ] probabilities ) { \ndouble result = 0.0d ; \nfor ( double p : probabilities ) { \nif ( p > 0.0d ) result -= p * Math . log ( p ) ; \n} \nreturn result / LN2 ; \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nint total = 0 ; \nfor ( int c : counts ) { \ntotal += c ; \n} \nfor ( int i = 0 ; \ni < probabilities . length ; \ni ++ ) if ( total > 0 ) probabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \nelse probabilities [ i ] = 0.0d ; \nreturn probabilities ; \n} \n} \n"}
{"10326": "public class SortAction { \npublic ActionForward perform ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { \nlog . fine ( \"perform: called\" ) ; \nSortForm sortForm = ( SortForm ) form ; \nHttpSession session = request . getSession ( ) ; \nServletContext application = session . getServletContext ( ) ; \nlog . fine ( \"variables in the servlet context: \" ) ; \nfor ( Enumeration e = application . getAttributeNames ( ) ; \ne . hasMoreElements ( ) ; \n) log . fine ( e . nextElement ( ) . toString ( ) ) ; \nList list = ( List ) session . getAttribute ( sortForm . getList ( ) ) ; \nComparator comparator = ( Comparator ) application . getAttribute ( sortForm . getComparator ( ) ) ; \nlog . fine ( \"comparator = \" + comparator ) ; \nSortStateBean sortStateBean = ( SortStateBean ) session . getAttribute ( sortForm . getSortState ( ) ) ; \nif ( sortStateBean == null ) { \nlog . fine ( \"There is no sort state bean\" ) ; \nsortStateBean = new SortStateBean ( ) ; \n} \nif ( ! sortStateBean . getState ( ) . equals ( SortStateBean . FORWARD ) || ! sortStateBean . getSortProperty ( ) . equals ( sortForm . getSortStateProperty ( ) ) ) { \nCollections . sort ( list , comparator ) ; \nsortStateBean . setState ( SortStateBean . FORWARD ) ; \n} \nelse { \nCollections . sort ( list , comparator ) ; \nCollections . reverse ( list ) ; \nsortStateBean . setState ( SortStateBean . REVERSE ) ; \n} \nsession . setAttribute ( sortForm . getList ( ) , list ) ; \nsortStateBean . setSortProperty ( sortForm . getSortStateProperty ( ) ) ; \nsession . setAttribute ( sortForm . getSortState ( ) , sortStateBean ) ; \nreturn ( mapping . findForward ( \"success\" ) ) ; \n} \n} \n"}
{"10329": "public class DebugTag { \npublic String getHeaders ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getHeaderNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString name = ( String ) names . nextElement ( ) ; \nEnumeration values = req . getHeaders ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nboolean first = true ; \nwhile ( values . hasMoreElements ( ) ) { \nif ( ! first ) sb . append ( \" | \" ) ; \nfirst = false ; \nsb . append ( values . nextElement ( ) ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"headers\" , info ) ; \n} \n} \n"}
{"10330": "public class DebugTag { \npublic String getCookies ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nCookie [ ] cookies = req . getCookies ( ) ; \nif ( cookies != null ) for ( int i = 0 ; \ni < cookies . length ; \ni ++ ) { \nCookie cooky = cookies [ i ] ; \ninfo . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; \n} \nreturn toHTMLTable ( \"cookies\" , info ) ; \n} \n} \n"}
{"10331": "public class DebugTag { \npublic String getParameters ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString name = ( String ) names . nextElement ( ) ; \nString [ ] values = req . getParameterValues ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < values . length ; \ni ++ ) { \nif ( i != 0 ) sb . append ( \" | \" ) ; \nsb . append ( values [ i ] ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"request parameters\" , info ) ; \n} \n} \n"}
{"10336": "public class DebugTag { \npublic String getUserPrincipal ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nPrincipal principal = request . getUserPrincipal ( ) ; \nif ( principal != null ) info . put ( \"principal name\" , principal . getName ( ) ) ; \nelse info . put ( \"principal name\" , \"no principal\" ) ; \nreturn toHTMLTable ( \"container security\" , info ) ; \n} \n} \n"}
{"10339": "public class BoundedAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nboolean beyondFringe = false ; \nminBeyondBound = Float . POSITIVE_INFINITY ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nQueue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; \nheadNode . expandSuccessors ( successors , reverseEnqueue ) ; \nfor ( SearchNode < O , T > successor : successors ) { \nfloat boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; \nif ( boundProperty <= maxBound ) queue . offer ( successor ) ; \nelse { \nbeyondFringe = true ; \nminBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; \n} \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) return currentNode ; \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) if ( queue . isEmpty ( ) ) return null ; \nelse throw new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \nif ( beyondFringe ) throw new MaxBoundException ( \"Max bound reached.\" , null ) ; \nelse return null ; \n} \n} \n"}
{"10341": "public class TermWalker { \npublic void walk ( Term term ) { \nterm . setTermTraverser ( traverser ) ; \nsearch . reset ( ) ; \nif ( goalPredicate != null ) search . setGoalPredicate ( goalPredicate ) ; \nsearch . addStartState ( term ) ; \nIterator < Term > treeWalker = Searches . allSolutions ( search ) ; \nif ( traverser instanceof TermVisitor ) term . accept ( ( TermVisitor ) traverser ) ; \nwhile ( treeWalker . hasNext ( ) ) { \nTerm nextTerm = treeWalker . next ( ) ; \nnextTerm . accept ( visitor ) ; \n} \nterm . setTermTraverser ( null ) ; \n} \n} \n"}
{"10344": "public class InternalRegisterBean { \nprivate void notifyChanges ( Iterable < PropertyChangeEvent > changes ) { \nList < PropertyChangeListener > activeListeners = listeners . getActiveListeners ( ) ; \nif ( activeListeners != null ) for ( PropertyChangeListener listener : activeListeners ) { \nfor ( PropertyChangeEvent event : changes ) { \nlistener . propertyChange ( event ) ; \n} \n} \n} \n} \n"}
{"10347": "public class AbstractHeap { \npublic < T > T [ ] toArray ( T [ ] a ) { \nint size = size ( ) ; \nif ( a . length < size ) a = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; \nIterator < E > it = iterator ( ) ; \nObject [ ] result = a ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) result [ i ] = it . next ( ) ; \nif ( a . length > size ) a [ size ] = null ; \nreturn a ; \n} \n} \n"}
{"10348": "public class OpSymbol { \npublic void setArguments ( Term [ ] arguments ) { \nif ( ( arguments == null ) || ( arguments . length < 1 ) || ( arguments . length > 2 ) ) throw new IllegalArgumentException ( \"An operator has minimum 1 and maximum 2 arguments.\" ) ; \nthis . arguments = arguments ; \nthis . arity = arguments . length ; \n} \n} \n"}
{"10352": "public class WorkFlowButtonsPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nObject source = event . getSource ( ) ; \nObject oldValue = event . getOldValue ( ) ; \nString propertyName = event . getPropertyName ( ) ; \nif ( source instanceof WorkFlowScreenState ) { \nWorkFlowScreenState wfsState = ( WorkFlowScreenState ) source ; \nupdateButtonsForScreen ( wfsState ) ; \n} \nif ( source instanceof WorkFlowState ) { \nWorkFlowState wfState = ( WorkFlowState ) source ; \nif ( \"currentScreenState\" . equals ( propertyName ) ) { \nWorkFlowScreenState newScreenState = wfState . getCurrentScreenState ( ) ; \nWorkFlowScreenState oldScreenState = ( WorkFlowScreenState ) oldValue ; \nif ( oldScreenState != null ) oldScreenState . removePropertyChangeListener ( this ) ; \nif ( newScreenState != null ) newScreenState . addPropertyChangeListener ( this ) ; \nupdateButtonsForScreen ( newScreenState ) ; \n} \nelse if ( \"state\" . equals ( propertyName ) ) updateButtonsForWorkFlow ( wfState ) ; \n} \n} \n} \n"}
{"10353": "public class WorkFlowButtonsPanel { \npublic void registerWorkFlowController ( WorkFlowController controller ) { \nbackButton . addActionListener ( controller ) ; \nnextButton . addActionListener ( controller ) ; \nfinishButton . addActionListener ( controller ) ; \ncancelButton . addActionListener ( controller ) ; \ncontroller . getWorkFlowState ( ) . addPropertyChangeListener ( this ) ; \nWorkFlowScreenState currentScreenState = controller . getWorkFlowState ( ) . getCurrentScreenState ( ) ; \nif ( currentScreenState != null ) currentScreenState . addPropertyChangeListener ( this ) ; \n} \n} \n"}
{"10354": "public class EnumAttribute { \npublic static EnumAttributeFactory getFactoryForClass ( Class cls ) { \nif ( ! cls . isEnum ( ) ) throw new IllegalArgumentException ( \"Can only create enum attribute factories for classes that are enums.\" ) ; \nreturn EnumClassImpl . getInstance ( cls ) ; \n} \n} \n"}
{"10356": "public class StackVariable { \npublic Variable getStorageCell ( Variable variable ) { \nVariableBindingContext < Variable > context = getBindingContext ( ) ; \nif ( context == null ) return null ; \nelse return context . getStorageCell ( this ) ; \n} \n} \n"}
{"10358": "public class AttributeGridImpl { \nprivate void setColumnAttribute ( AttributeSet attributes , int c ) { \nif ( c >= columnAttributes . size ( ) ) for ( int i = columnAttributes . size ( ) ; \ni <= c ; \ni ++ ) columnAttributes . add ( null ) ; \ncolumnAttributes . set ( c , attributes ) ; \n} \n} \n"}
{"10359": "public class AttributeGridImpl { \nprivate void setRowAttribute ( AttributeSet attributes , int r ) { \nif ( r >= rowAttributes . size ( ) ) for ( int i = rowAttributes . size ( ) ; \ni <= r ; \ni ++ ) rowAttributes . add ( null ) ; \nrowAttributes . set ( r , attributes ) ; \n} \n} \n"}
{"10360": "public class AttributeGridImpl { \nprivate AttributeSet getColumnAttributeOrNull ( int c ) { \nif ( ( c >= 0 ) && ( c < columnAttributes . size ( ) ) ) return columnAttributes . get ( c ) ; \nelse return null ; \n} \n} \n"}
{"10361": "public class AttributeGridImpl { \nprivate AttributeSet getRowAttributeOrNull ( int r ) { \nif ( ( r >= 0 ) && ( r < rowAttributes . size ( ) ) ) return rowAttributes . get ( r ) ; \nelse return null ; \n} \n} \n"}
{"10363": "public class TimeRangeType { \npublic static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { \nif ( ( min != null ) && ( max != null ) && ( min . compareTo ( max ) > 0 ) ) throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \nsynchronized ( INT_RANGE_TYPES ) { \nTimeRangeType newType = new TimeRangeType ( name , min , max ) ; \nTimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10364": "public class StringPatternType { \npublic static Type createInstance ( String name , int maxLength , String pattern ) { \nsynchronized ( STRING_PATTERN_TYPES ) { \nStringPatternType newType = new StringPatternType ( name , maxLength , pattern ) ; \nStringPatternType oldType = STRING_PATTERN_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nSTRING_PATTERN_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10368": "public class VariableReferenceNode { \npublic String getValue ( ) { \nfor ( ScopeNode scope = NodeTreeUtils . getParentScope ( this ) ; \nscope != null ; \nscope = NodeTreeUtils . getParentScope ( scope ) ) { \nExpressionGroupNode value = scope . getVariable ( _name ) ; \nif ( value == null ) continue ; \nreturn value . toString ( ) ; \n} \nreturn _name ; \n} \n} \n"}
{"10369": "public class BaseBiDirectionalQueueSearch { \npublic SearchNode < O , T > findGoalPath ( ) throws SearchNotExhaustiveException { \nwhile ( ! forwardQueue . isEmpty ( ) || ! reverseQueue . isEmpty ( ) ) { \nif ( ! forwardQueue . isEmpty ( ) ) { \nSearchNode < O , T > currentForwardNode = forwardQueue . remove ( ) ; \nforwardFringe . remove ( currentForwardNode . getState ( ) ) ; \nif ( reverseFringe . containsKey ( currentForwardNode . getState ( ) ) ) return joinBothPaths ( currentForwardNode , reverseFringe . get ( currentForwardNode . getState ( ) ) ) ; \nelse { \nQueue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; \ncurrentForwardNode . expandSuccessors ( newStates , false ) ; \nforwardQueue . addAll ( newStates ) ; \nfor ( SearchNode < O , T > nextSearchNode : newStates ) { \nforwardFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; \n} \n} \n} \nif ( ! reverseQueue . isEmpty ( ) ) { \nSearchNode < O , T > currentReverseNode = reverseQueue . remove ( ) ; \nreverseFringe . remove ( currentReverseNode . getState ( ) ) ; \nif ( forwardFringe . containsKey ( currentReverseNode . getState ( ) ) ) return joinBothPaths ( forwardFringe . get ( currentReverseNode . getState ( ) ) , currentReverseNode ) ; \nelse { \nQueue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; \ncurrentReverseNode . expandSuccessors ( newStates , false ) ; \nreverseQueue . addAll ( newStates ) ; \nfor ( SearchNode < O , T > nextSearchNode : newStates ) { \nreverseFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10370": "public class BaseBiDirectionalQueueSearch { \nprivate SearchNode < O , T > joinBothPaths ( SearchNode < O , T > forwardPath , SearchNode < O , T > reversePath ) throws SearchNotExhaustiveException { \nif ( pathJoiner != null ) return pathJoiner . joinBothPaths ( forwardPath , reversePath ) ; \nelse { \nSearchNode < O , T > currentReverseNode = reversePath ; \nSearchNode < O , T > currentForwardNode = forwardPath ; \nwhile ( ! goalPredicate . evaluate ( currentReverseNode . getState ( ) ) ) { \nSearchNode < O , T > reverseParentNode = currentReverseNode . getParent ( ) ; \nT state = currentReverseNode . getParent ( ) . getState ( ) ; \nOperator < O > operation = currentReverseNode . getAppliedOp ( ) ; \nfloat cost = currentReverseNode . getPathCost ( ) - reverseParentNode . getPathCost ( ) ; \ncurrentForwardNode = currentForwardNode . makeNode ( new Successor < O > ( state , operation , cost ) ) ; \ncurrentReverseNode = reverseParentNode ; \n} \nreturn currentForwardNode ; \n} \n} \n} \n"}
{"10372": "public class DefaultPropertyReader { \npublic static synchronized Properties getProperties ( String resourceName ) { \nPropertyReaderBase propertyReader = ( PropertyReaderBase ) propertyReaders . get ( resourceName ) ; \nif ( propertyReader != null ) return propertyReader . getProperties ( ) ; \npropertyReader = new DefaultPropertyReader ( resourceName ) ; \npropertyReaders . put ( resourceName , propertyReader ) ; \nreturn propertyReader . getProperties ( ) ; \n} \n} \n"}
{"10384": "public class TreeSearchState { \npublic Iterator < Operator < Tree < E > > > validOperators ( boolean reverse ) { \nif ( tree . isLeaf ( ) ) return new ArrayList < Operator < Tree < E > > > ( ) . iterator ( ) ; \nelse { \nTree . Node < E > node = tree . getAsNode ( ) ; \nreturn new TreeSearchOperatorIterator < E > ( node . getChildIterator ( ) ) ; \n} \n} \n} \n"}
{"10385": "public class IdAttribute { \npublic long getId ( ) { \nif ( attributeClass . finalized ) return attributeClass . lookupValue [ value ] . id ; \nelse return attributeClass . lookupValueList . get ( value ) . id ; \n} \n} \n"}
{"10386": "public class IdAttribute { \npublic T getValue ( ) { \nif ( attributeClass . finalized ) return attributeClass . lookupValue [ value ] . label ; \nelse return attributeClass . lookupValueList . get ( value ) . label ; \n} \n} \n"}
{"10387": "public class IdAttribute { \npublic void setValue ( T value ) throws IllegalArgumentException { \nInteger b = attributeClass . lookupInt . get ( value ) ; \nif ( b == null ) if ( attributeClass . finalized ) throw new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized IdType, \" + attributeClass . attributeClassName + \".\" ) ; \nelse { \nIdAttribute newAttribute = attributeClass . createIdAttribute ( value ) ; \nb = newAttribute . value ; \n} \nthis . value = b ; \n} \n} \n"}
{"10388": "public class StringUtils { \npublic static String [ ] listToArray ( String value , String delim ) { \nList < String > result = new ArrayList < String > ( ) ; \nStringTokenizer tokenizer = new StringTokenizer ( value , delim ) ; \nwhile ( tokenizer . hasMoreTokens ( ) ) result . add ( tokenizer . nextToken ( ) ) ; \nreturn result . toArray ( new String [ result . size ( ) ] ) ; \n} \n} \n"}
{"10389": "public class StringUtils { \npublic static String arrayToList ( String [ ] array , String delim ) { \nString result = \"\" ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) result += array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; \nreturn result ; \n} \n} \n"}
{"10390": "public class StringUtils { \npublic static String toCamelCase ( String name ) { \nString [ ] parts = name . split ( \"_\" ) ; \nString result = parts [ 0 ] ; \nfor ( int i = 1 ; \ni < parts . length ; \ni ++ ) if ( parts [ i ] . length ( ) > 0 ) result += upperFirstChar ( parts [ i ] ) ; \nreturn result ; \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; \nelse result . append ( Character . toLowerCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \nfor ( int i = 0 ; \ni < value . length ( ) ; \ni ++ ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) result . append ( separator ) ; \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse if ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) result . append ( separator ) ; \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10392": "public class LoggingDiagnostic { \npublic static String currentConfiguration ( ) { \nStringBuffer rtn = new StringBuffer ( 1024 ) ; \nString loggingConfigClass = System . getProperty ( \"java.util.logging.config.class\" ) ; \nString loggingConfigFile = System . getProperty ( \"java.util.logging.config.file\" ) ; \nboolean configClassOK = false ; \nif ( loggingConfigClass == null ) rtn . append ( \"No java.util.logging.config.class class is set.\\n\" ) ; \nelse { \nrtn . append ( \"java.util.logging.config.class is set to '\" ) . append ( loggingConfigClass ) . append ( \"'\\n\" ) ; \ntry { \nClass c = Class . forName ( loggingConfigClass ) ; \nc . newInstance ( ) ; \nrtn . append ( \"This class was loaded and a new instance was sucessfully created.\\n\" ) ; \nconfigClassOK = true ; \n} \ncatch ( ClassNotFoundException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be found.\" ) ; \n} \ncatch ( InstantiationException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be instantiated.\" ) ; \n} \ncatch ( IllegalAccessException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be accessed.\" ) ; \n} \n} \nif ( loggingConfigFile == null ) rtn . append ( \"No java.util.logging.config.file file is set.\\n\" ) ; \nelse { \nrtn . append ( \"java.util.logging.config.file is set to '\" ) . append ( loggingConfigFile ) . append ( \"'\\n\" ) ; \nFile loggingFile = new File ( loggingConfigFile ) ; \nrtn . append ( loggingFile . getAbsolutePath ( ) ) . append ( \"\\n\" ) ; \nif ( ! loggingFile . exists ( ) || ! loggingFile . isFile ( ) ) rtn . append ( \"This file does NOT EXIST.\\n\" ) ; \nif ( loggingConfigClass != null ) if ( configClassOK ) rtn . append ( \"This file is ignored because java.util.logging.config.class is set.\\n\" ) ; \n} \nHandler [ ] handlers = Logger . getLogger ( \"\" ) . getHandlers ( ) ; \nlistHandlers ( handlers , rtn ) ; \nreturn rtn . toString ( ) ; \n} \n} \n"}
{"10393": "public class LoggingDiagnostic { \nprivate static StringBuffer listHandlers ( Handler [ ] handlers , StringBuffer buffer ) { \nfor ( Handler handler : handlers ) { \nClass < ? extends Handler > handlerClass = handler . getClass ( ) ; \nFormatter formatter = handler . getFormatter ( ) ; \nbuffer . append ( \"Handler:\" ) . append ( handlerClass . getName ( ) ) . append ( \"\\n\" ) ; \nbuffer . append ( \"Level:\" ) . append ( handler . getLevel ( ) . toString ( ) ) . append ( \"\\n\" ) ; \nif ( formatter != null ) buffer . append ( \"Formatter:\" ) . append ( formatter . getClass ( ) . getName ( ) ) . append ( \"\\n\" ) ; \n} \nreturn buffer ; \n} \n} \n"}
{"10394": "public class WAMBaseMachine { \npublic WAMCallPoint resolveCallPoint ( int functorName ) { \nWAMCallPoint result = ( WAMCallPoint ) symbolTable . get ( functorName , SYMKEY_CALLPOINTS ) ; \nif ( result == null ) result = new WAMCallPoint ( - 1 , 0 , functorName ) ; \nreturn result ; \n} \n} \n"}
{"10396": "public class HierarchyAttribute { \npublic boolean isSubCategory ( HierarchyAttribute comp ) { \nif ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) return false ; \nList < String > otherPath = comp . getPathValue ( ) ; \nList < String > path = getPathValue ( ) ; \nif ( otherPath . size ( ) <= path . size ( ) ) return false ; \nboolean subcat = true ; \nfor ( int i = 0 ; \ni < path . size ( ) ; \ni ++ ) if ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { \nsubcat = false ; \nbreak ; \n} \nreturn subcat ; \n} \n} \n"}
{"10398": "public class HierarchyAttribute { \npublic String getValueAtLevel ( String level ) { \nint index = attributeClass . levels . indexOf ( level ) ; \nif ( index == - 1 ) throw new IllegalArgumentException ( \"Level name \" + level + \" is not known to this hierarchy attribute type.\" ) ; \nreturn getValueAtLevel ( index ) ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( parentNode == null ) { \nint h = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) for ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nint goalX = state . getGoalXForTile ( nextTile ) ; \nint goalY = state . getGoalYForTile ( nextTile ) ; \nint diffX = goalX - i ; \ndiffX = ( diffX < 0 ) ? - diffX : diffX ; \nint diffY = goalY - j ; \ndiffY = ( diffY < 0 ) ? - diffY : diffY ; \nh += diffX + diffY ; \n} \nreturn ( float ) h ; \n} \nelse { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nint emptyX = parentState . getEmptyX ( ) ; \nint emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nint oldX = 0 ; \nint oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nint change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nint goalX = state . getGoalXForTile ( movedTile ) ; \nint newX = emptyX ; \nint oldDiffX = oldX - goalX ; \noldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; \nint newDiffX = newX - goalX ; \nnewDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nint goalY = state . getGoalYForTile ( movedTile ) ; \nint newY = emptyY ; \nint oldDiffY = oldY - goalY ; \noldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; \nint newDiffY = newY - goalY ; \nnewDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \n} \n} \n"}
{"10405": "public class ErrorHandler { \npublic static void handleErrors ( Throwable exception , ActionErrors errors ) { \nlog . log ( Level . SEVERE , exception . getMessage ( ) , exception ) ; \nif ( exception . getCause ( ) == null ) log . fine ( \"Exception.getCause() is null\" ) ; \nif ( ( exception instanceof WrappedStrutsServletException ) && ( exception . getCause ( ) != null ) ) { \nexception = exception . getCause ( ) ; \nlog . fine ( \"Unwrapped WrappedStrutsServletException\" ) ; \n} \nWriter stackTrace = new StringWriter ( ) ; \nexception . printStackTrace ( new PrintWriter ( new HTMLFilter ( stackTrace ) ) ) ; \nerrors . add ( \"exception\" , new ActionError ( \"error.general\" , stackTrace ) ) ; \nif ( exception instanceof UserReadableError ) { \nUserReadableError userError = ( UserReadableError ) exception ; \nif ( userError . isUserReadable ( ) ) { \nif ( userError . getUserMessageKey ( ) != null ) errors . add ( \"generalerror\" , new ActionError ( userError . getUserMessageKey ( ) , userError . getUserMessageKey ( ) ) ) ; \nelse errors . add ( \"generalerror\" , new ActionError ( \"error.general\" , userError . getUserMessage ( ) ) ) ; \nreturn ; \n} \n} \nerrors . add ( \"generalerror\" , new ActionError ( \"error.internalerror\" ) ) ; \n} \n} \n"}
{"10406": "public class HTMLFilter { \npublic void write ( String str , int off , int len ) throws IOException { \nString inputString = str . substring ( off , off + len ) ; \nStringBuffer outputString = new StringBuffer ( ) ; \nfor ( StringTokenizer tokenizer = new StringTokenizer ( inputString , \"\\n\" , true ) ; \ntokenizer . hasMoreTokens ( ) ; \n) { \nString nextToken = tokenizer . nextToken ( ) ; \nif ( \"\\n\" . equals ( nextToken ) ) outputString . append ( \"<br>\" ) ; \nelse outputString . append ( nextToken ) ; \n} \nout . write ( outputString . toString ( ) ) ; \n} \n} \n"}
{"10407": "public class ProtoDTMachine { \npublic Map < String , OrdinalAttribute > classify ( State state ) throws ClassifyingFailureException { \nDecisionTree currentNode = dt ; \nwhile ( true ) { \nDecisionTreeElement element = currentNode . getElement ( ) ; \nif ( element instanceof Decision ) { \nDecision decision = ( Decision ) element ; \ncurrentNode = decision . decide ( state ) ; \n} \nelse if ( element instanceof Assignment ) { \nAssignment assignment = ( Assignment ) element ; \nMap < String , OrdinalAttribute > assignmentMap = new HashMap < String , OrdinalAttribute > ( ) ; \nassignmentMap . put ( assignment . getPropertyName ( ) , assignment . getAttribute ( ) ) ; \nreturn assignmentMap ; \n} \nelse throw new ClassifyingFailureException ( \"A node which is not a decision was encountered.\" , null ) ; \n} \n} \n} \n"}
{"10408": "public class PartialOrdering { \npublic int compare ( T a , T b ) { \nboolean aRb = partialOrdering . evaluate ( a , b ) ; \nif ( ! aRb ) return - 1 ; \nboolean bRa = partialOrdering . evaluate ( b , a ) ; \nreturn ( aRb && bRa ) ? 0 : 1 ; \n} \n} \n"}
{"10411": "public class BitHackUtils { \npublic static int intLogBase2v2 ( int value ) { \nint temp ; \nif ( ( temp = value >> 24 ) > 0 ) return 24 + LOG_TABLE_256 [ temp ] ; \nelse if ( ( temp = value >> 16 ) > 0 ) return 16 + LOG_TABLE_256 [ temp ] ; \nelse if ( ( temp = value >> 8 ) > 0 ) return 8 + LOG_TABLE_256 [ temp ] ; \nelse return LOG_TABLE_256 [ value ] ; \n} \n} \n"}
{"10416": "public class BitHackUtils { \npublic static int getCharacterCountInt32 ( int value ) { \nif ( value >= 0 ) return getCharacterCountUInt32 ( value ) ; \nelse if ( value == Integer . MIN_VALUE ) return getCharacterCountUInt32 ( Integer . MAX_VALUE ) + 1 ; \nelse return getCharacterCountUInt32 ( - value ) + 1 ; \n} \n} \n"}
{"10417": "public class BitHackUtils { \npublic static int getCharacterCountInt64 ( long value ) { \nif ( value >= 0 ) return getCharacterCountUInt64 ( value ) ; \nelse if ( value == Long . MIN_VALUE ) return getCharacterCountUInt64 ( Long . MAX_VALUE ) + 1 ; \nelse return getCharacterCountUInt64 ( - value ) + 1 ; \n} \n} \n"}
{"10418": "public class BitHackUtils { \npublic static int getCharacterCountDecimal ( long integerValue , int scale ) { \nboolean isNeg = integerValue < 0 ; \nint totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; \nint totalLength = totalDigits ; \nif ( isNeg ) totalDigits -- ; \nif ( scale > 0 ) { \ntotalLength ++ ; \nif ( scale >= totalDigits ) totalLength += ( scale - totalDigits ) + 1 ; \n} \nelse totalLength -= scale ; \nreturn totalLength ; \n} \n} \n"}
{"10420": "public class WAMCompiledQuery { \npublic void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { \nif ( sizeof ( ) > Integer . MAX_VALUE ) throw new IllegalStateException ( \"The instruction listing size exceeds Integer.MAX_VALUE.\" ) ; \nint length = 0 ; \nfor ( WAMInstruction instruction : instructions ) { \ninstruction . emmitCode ( buffer , machine ) ; \nlength += instruction . sizeof ( ) ; \n} \nthis . machine = machine ; \nthis . callPoint = callPoint ; \nthis . status = LinkStatus . Linked ; \n} \n} \n"}
{"10421": "public class WorkFlowController { \nprotected void setCurrentScreen ( WorkFlowScreenPanel screen ) { \npanel . removeAll ( ) ; \npanel . add ( screen ) ; \nif ( ! accessedScreens . contains ( screen ) ) accessedScreens . push ( screen ) ; \nstate . setCurrentScreenState ( screen . getState ( ) ) ; \ncurrentScreen = screen ; \nscreen . initialize ( ) ; \npanel . validate ( ) ; \n} \n} \n"}
{"10425": "public class ContextualProperties { \nprotected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { \nreturn new Iterator ( ) { \nprivate int i ; \npublic boolean hasNext ( ) { \nreturn ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; \n} \npublic Object next ( ) { \nif ( ! hasNext ( ) ) return null ; \nint o = ORDER [ i ] ; \nString result = ( ( ( o & E ) != 0 ) ? ( environment + \".\" ) : \"\" ) + ( ( ( o & B ) != 0 ) ? ( base + \".\" ) : \"\" ) + ( ( ( o & M ) != 0 ) ? ( modifier + \".\" ) : \"\" ) + key ; \ni ++ ; \nreturn result ; \n} \npublic void remove ( ) { \nthrow new UnsupportedOperationException ( \"remove() is not supported on this key order iterator as \" + \"the ordering cannot be changed\" ) ; \n} \n} \n; \n} \n} \n"}
{"10427": "public class BaseThrottle { \npublic void setRate ( float hertz ) { \nif ( hertz <= 0.0f ) throw new IllegalArgumentException ( \"The throttle rate must be above zero.\" ) ; \ncycleTimeNanos = ( long ) ( 1000000000f / hertz ) ; \nfirstCall = false ; \nfirstCheckCall = false ; \n} \n} \n"}
{"10428": "public class UMinus { \nprotected NumericType evaluate ( NumericType firstNumber ) { \nif ( firstNumber . isInteger ( ) ) return new IntLiteral ( - firstNumber . intValue ( ) ) ; \nelse return new DoubleLiteral ( - firstNumber . doubleValue ( ) ) ; \n} \n} \n"}
{"10429": "public class PropertyReaderBase { \nprotected void findProperties ( ) { \nproperties = getPropertiesUsingSystemProperty ( ) ; \nif ( properties != null ) return ; \nproperties = getPropertiesUsingClasspath ( ) ; \nif ( properties != null ) return ; \nproperties = getPropertiesUsingCWD ( ) ; \nif ( properties != null ) return ; \n} \n} \n"}
{"10431": "public class PropertyReaderBase { \nprotected Properties getPropertiesUsingClasspath ( ) { \nInputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( getPropertiesResourceName ( ) ) ; \nif ( is != null ) try { \nreturn PropertiesHelper . getProperties ( is ) ; \n} \ncatch ( IOException e ) { \ne = null ; \n} \nreturn null ; \n} \n} \n"}
{"10434": "public class Variable { \npublic Term getValue ( ) { \nTerm result = this ; \nTerm assignment = this . substitution ; \nwhile ( assignment != null ) { \nresult = assignment ; \nif ( ! assignment . isVar ( ) ) break ; \nelse assignment = ( ( Variable ) assignment ) . substitution ; \n} \nreturn result ; \n} \n} \n"}
{"10438": "public class SilentFailSocketAppender { \npublic void append ( LoggingEvent event ) { \nif ( event == null ) return ; \nif ( address == null ) { \nerrorHandler . error ( \"No remote host is set for SocketAppender named \\\"\" + this . name + \"\\\".\" ) ; \nreturn ; \n} \nif ( oos != null ) try { \nif ( locationInfo ) event . getLocationInformation ( ) ; \noos . writeObject ( event ) ; \noos . flush ( ) ; \nif ( ++ counter >= RESET_FREQUENCY ) { \ncounter = 0 ; \noos . reset ( ) ; \n} \n} \ncatch ( IOException e ) { \noos = null ; \nLogLog . warn ( \"Detected problem with connection: \" + e ) ; \nif ( reconnectionDelay > 0 ) fireConnector ( ) ; \n} \n} \n} \n"}
{"10442": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void rollback ( ) { \nTxId txId = null ; \nif ( ! getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \nList < TxOperation > alterations = txWrites . get ( txId ) ; \nif ( alterations != null ) for ( TxOperation nextAlteration : alterations ) { \nnextAlteration . cancel ( false ) ; \n} \ntxWrites . remove ( txId ) ; \n} \n} \n} \n"}
{"10443": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void requestWriteOperation ( TxOperation op ) { \nTxId txId = null ; \nif ( getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) > 0 ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \nenlistWithSession ( ) ; \n} \nif ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) op . execute ( ) ; \nelse addCachedOperation ( txId , op ) ; \n} \n} \n"}
{"10445": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void acquireGlobalWriteLock ( TxId txId ) throws InterruptedException { \nglobalLock . writeLock ( ) . lock ( ) ; \ntry { \nif ( ! txId . equals ( globalWriteLockTxId ) ) { \nwhile ( globalWriteLockTxId != null ) globalWriteLockFree . await ( ) ; \nglobalWriteLockTxId = txId ; \n} \n} \nfinally { \nglobalLock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"10447": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void enlistWithSession ( ) { \nTxSession session = TxSessionImpl . getCurrentSession ( ) ; \nif ( session == null ) throw new IllegalStateException ( \"Cannot access transactional resource outside of a session.\" ) ; \nsession . enlist ( this ) ; \n} \n} \n"}
{"10448": "public class NestedMediaQueries { \n@ Override public boolean enter ( RuleSetNode ruleSetNode ) { \nScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; \nSelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; \nif ( selectorGroupNode == null ) return true ; \nList < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; \nif ( selectorNodes . size ( ) < 0 ) return true ; \nList < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; \nfor ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { \nScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; \nList < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; \nif ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { \nRuleSetNode newRuleSetNode = new RuleSetNode ( ) ; \nScopeNode newScopeNode = new ScopeNode ( ) ; \nnewRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; \nnewRuleSetNode . addChild ( newScopeNode ) ; \nNodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; \nmediaScopeNode . clearChildren ( ) ; \nmediaScopeNode . addChild ( newRuleSetNode ) ; \n} \nfor ( RuleSetNode nestedRuleSet : nestedRuleSets ) { \nList < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; \nfor ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { \nList < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; \nNodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; \nfor ( SelectorNode selectorNode : selectorNodes ) { \nfor ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) if ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; \nselectorSegmentNode . setCombinator ( \" \" ) ; \n} \nfor ( int j = selectorNode . getChildren ( ) . size ( ) - 1 ; \nj >= 0 ; \nj -- ) if ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; \nnestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; \n} \nnestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; \nnestedSelectorGroupNode . addChild ( new SpacingNode ( \" \" ) ) ; \n} \n} \n} \nmediaScopeNode . addChild ( nestedRuleSet ) ; \n} \nif ( ruleSetNode . getParent ( ) != null ) { \nruleSetNode . getParent ( ) . addChild ( new SpacingNode ( \"\\n\" ) ) ; \nruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10449": "public class BatchSynchQueueBase { \npublic boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { \nif ( e == null ) throw new IllegalArgumentException ( \"The 'e' parameter may not be null.\" ) ; \nReentrantLock lock = this . lock ; \nlock . lockInterruptibly ( ) ; \nlong nanos = unit . toNanos ( timeout ) ; \ntry { \ndo { \nif ( insert ( e , false ) ) return true ; \ntry { \nnanos = notFull . awaitNanos ( nanos ) ; \n} \ncatch ( InterruptedException ie ) { \nnotFull . signal ( ) ; \nthrow ie ; \n} \n} \nwhile ( nanos > 0 ) ; \nreturn false ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"10450": "public class BatchSynchQueueBase { \npublic E poll ( long timeout , TimeUnit unit ) throws InterruptedException { \nReentrantLock lock = this . lock ; \nlock . lockInterruptibly ( ) ; \ntry { \nlong nanos = unit . toNanos ( timeout ) ; \ndo { \nif ( count != 0 ) return extract ( true , true ) . getElement ( ) ; \ntry { \nnanos = notEmpty . awaitNanos ( nanos ) ; \n} \ncatch ( InterruptedException ie ) { \nnotEmpty . signal ( ) ; \nthrow ie ; \n} \n} \nwhile ( nanos > 0 ) ; \nreturn null ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"10452": "public class BatchSynchQueueBase { \nprotected boolean insert ( E element , boolean unlockAndBlock ) { \nSynchRecordImpl < E > record = new SynchRecordImpl < E > ( element ) ; \nboolean result = buffer . offer ( record ) ; \nif ( result ) { \ncount ++ ; \nnotEmpty . signal ( ) ; \nif ( unlockAndBlock ) { \nlock . unlock ( ) ; \nrecord . waitForConsumer ( ) ; \n} \nreturn true ; \n} \nelse return false ; \n} \n} \n"}
{"10457": "public class ScopeNode { \npublic ScopeNode callMixin ( String name , ArgumentsNode arguments ) { \nList < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; \nif ( argumentList . size ( ) > _parameterDefinitions . size ( ) ) throw new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; \nScopeNode mixinScope = clone ( ) ; \nNodeTreeUtils . filterLineBreaks ( mixinScope ) ; \nfor ( int i = 0 ; \ni < argumentList . size ( ) ; \ni ++ ) { \nExpressionGroupNode argument = argumentList . get ( i ) ; \nVariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; \nparameter . clearChildren ( ) ; \nparameter . addChild ( argument ) ; \n} \ngetParent ( ) . setVisible ( false ) ; \nreturn mixinScope ; \n} \n} \n"}
{"10458": "public class ScopeNode { \nprivate void setAdditionVisitor ( ) { \nsetAdditionVisitor ( new InclusiveNodeVisitor ( ) { \n@ Override public boolean add ( ParametersNode node ) { \nfor ( VariableDefinitionNode variable : NodeTreeUtils . getChildren ( node , VariableDefinitionNode . class ) ) { \n_parameterDefinitions . add ( variable ) ; \nadd ( variable ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( RuleSetNode node ) { \nSelectorGroupNode selectorGroup = NodeTreeUtils . getFirstChild ( node , SelectorGroupNode . class ) ; \nfor ( SelectorNode selectorNode : NodeTreeUtils . getChildren ( selectorGroup , SelectorNode . class ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( Node selectorChild : selectorNode . getChildren ( ) ) { \nsb . append ( selectorChild . toString ( ) ) ; \n} \nString selector = sb . toString ( ) ; \nif ( ! _selectorToRuleSetMap . containsKey ( selector ) ) _selectorToRuleSetMap . put ( selector , node ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( ScopeNode node ) { \nNodeTreeUtils . moveChildren ( node , ScopeNode . this ) ; \nreturn false ; \n} \n@ Override public boolean add ( VariableDefinitionNode node ) { \nString name = node . getName ( ) ; \nif ( ! _variableNameToValueMap . containsKey ( name ) ) _variableNameToValueMap . put ( name , NodeTreeUtils . getFirstChild ( node , ExpressionGroupNode . class ) ) ; \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( PropertyNode node ) { \nString name = node . getName ( ) ; \nif ( name . equals ( FILTER_PROPERTY ) ) return super . add ( node ) ; \nif ( node . getChildren ( ) . get ( 0 ) . toString ( ) . startsWith ( \"-\" ) ) return super . add ( node ) ; \nif ( _propertyNameToNodeMap . containsKey ( name ) ) { \nPropertyNode oldPropertyNode = _propertyNameToNodeMap . get ( name ) ; \nint oldPropertyIndex = getChildren ( ) . indexOf ( oldPropertyNode ) ; \nif ( oldPropertyNode . isVisible ( ) ) { \noldPropertyNode . setVisible ( false ) ; \nif ( ! hideWhiteSpaceNode ( oldPropertyIndex - 1 ) ) hideWhiteSpaceNode ( oldPropertyIndex + 1 ) ; \n} \n} \n_propertyNameToNodeMap . put ( name , node ) ; \nreturn super . add ( node ) ; \n} \n} \n) ; \n} \n} \n"}
{"10462": "public class WAMResolvingMachine { \nprotected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { \nTerm result = null ; \nint addr = deref ( start ) ; \nbyte tag = getDerefTag ( ) ; \nint val = getDerefVal ( ) ; \nswitch ( tag ) { \ncase REF : { \nVariable var = variableContext . get ( val ) ; \nif ( var == null ) { \nvar = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; \nvariableContext . put ( val , var ) ; \n} \nresult = var ; \nbreak ; \n} \ncase STR : { \nint fn = getHeap ( val ) ; \nint f = fn & 0x00ffffff ; \nFunctorName functorName = getDeinternedFunctorName ( f ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) arguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ncase WAMInstruction . CON : { \nint f = val & 0x3fffffff ; \nresult = new Functor ( f , null ) ; \nbreak ; \n} \ncase WAMInstruction . LIS : { \nFunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; \nint f = internFunctorName ( functorName ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) arguments [ i ] = decodeHeap ( val + i , variableContext ) ; \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ndefault : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"10463": "public class DirectMemento { \npublic void capture ( ) { \nClass cls = ob . getClass ( ) ; \nwhile ( ! cls . equals ( Object . class ) ) { \nField [ ] attrs = cls . getDeclaredFields ( ) ; \nHashMap map = new HashMap ( ) ; \nvalues . put ( cls , map ) ; \nfor ( Field attr : attrs ) { \nattr . setAccessible ( true ) ; \nif ( shouldBeSaved ( attr ) ) try { \nmap . put ( attr . getName ( ) , attr . get ( ob ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"Field '\" + attr . getName ( ) + \"' could not be accessed but the 'setAccessible(true)' method was invoked on it.\" , e ) ; \n} \n} \ncls = cls . getSuperclass ( ) ; \n} \n} \n} \n"}
{"10465": "public class DirectMemento { \npublic Object get ( Class cls , String attr ) { \nHashMap map ; \nif ( ! values . containsKey ( cls ) ) return null ; \nmap = ( HashMap ) values . get ( cls ) ; \nreturn map . get ( attr ) ; \n} \n} \n"}
{"10466": "public class DirectMemento { \npublic void put ( Class cls , String attr , Object val ) { \nHashMap map ; \nif ( values . containsKey ( cls ) ) map = ( HashMap ) values . get ( cls ) ; \nelse { \nmap = new HashMap ( ) ; \nvalues . put ( cls , map ) ; \n} \nmap . put ( attr , val ) ; \n} \n} \n"}
{"10467": "public class DirectMemento { \npublic Collection getAllFieldNames ( Class cls ) { \nif ( ! values . containsKey ( cls ) ) return null ; \nMap map = ( HashMap ) values . get ( cls ) ; \nreturn map . keySet ( ) ; \n} \n} \n"}
{"10469": "public class LockFreeNQueue { \npublic boolean offer ( E o ) { \nif ( o == null ) throw new IllegalArgumentException ( \"The 'o' parameter may not be null.\" ) ; \nint level = priorityToLevel ( p . apply ( o ) ) ; \nNode < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; \nwhile ( true ) { \nNode < E > t = markers [ level + 1 ] . getTail ( ) ; \nNode < E > s = t . getNext ( ) ; \nif ( t == markers [ level + 1 ] . getTail ( ) ) if ( s == markers [ level + 1 ] ) if ( t . casNext ( s , newNode ) ) { \nmarkers [ level + 1 ] . casTail ( t , newNode ) ; \ncount . incrementAndGet ( ) ; \nreturn true ; \n} \nelse markers [ level + 1 ] . casTail ( t , s ) ; \n} \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \ncurrentLevel < n ; \ncurrentLevel ++ ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) break ; \nelse if ( currentLevel == ( n - 1 ) ) return null ; \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) if ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) if ( first == null ) return null ; \nelse markers [ currentLevel + 1 ] . casTail ( t , first ) ; \nelse if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n"}
{"10481": "public class PropertiesHelper { \npublic static Properties getProperties ( String pathname ) throws IOException { \nif ( pathname == null ) return null ; \nif ( isURL ( pathname ) ) return getProperties ( new URL ( pathname ) ) ; \nelse return getProperties ( new File ( pathname ) ) ; \n} \n} \n"}
{"10484": "public class BaseState { \npublic void addPropertyChangeListener ( PropertyChangeListener l ) { \nif ( listeners == null ) listeners = new ArrayList ( ) ; \nsynchronized ( listeners ) { \nlisteners . add ( l ) ; \n} \n} \n} \n"}
{"10485": "public class BaseState { \npublic void addPropertyChangeListener ( String p , PropertyChangeListener l ) { \nif ( listeners == null ) listeners = new ArrayList ( ) ; \nsynchronized ( listeners ) { \nlisteners . add ( l ) ; \n} \n} \n} \n"}
{"10486": "public class BaseState { \npublic void removePropertyChangeListener ( String p , PropertyChangeListener l ) { \nif ( listeners == null ) return ; \nsynchronized ( listeners ) { \nlisteners . remove ( l ) ; \n} \n} \n} \n"}
{"10487": "public class BaseState { \nprotected void firePropertyChange ( PropertyChangeEvent evt ) { \nfinal PropertyChangeEvent finalEvent = evt ; \nIterator it ; \nif ( listeners == null ) return ; \nsynchronized ( listeners ) { \nit = listeners . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nfinal PropertyChangeListener l = ( PropertyChangeListener ) it . next ( ) ; \nRunnable r = new Runnable ( ) { \npublic void run ( ) { \nl . propertyChange ( finalEvent ) ; \n} \n} \n; \nSwingUtilities . invokeLater ( r ) ; \n} \n} \n} \n} \n"}
{"10488": "public class DoubleRangeType { \npublic static Type createInstance ( String name , double min , double max ) { \nif ( min > max ) throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \nsynchronized ( DOUBLE_RANGE_TYPES ) { \nDoubleRangeType newType = new DoubleRangeType ( name , min , max ) ; \nDoubleRangeType oldType = DOUBLE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nDOUBLE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10493": "public class JsoupMicrodataDocument { \nprivate static void sanitizeRadioControls ( FormElement form ) { \nMap < String , Element > controlsByName = new HashMap < String , Element > ( ) ; \nfor ( Element control : form . elements ( ) ) { \nif ( \"radio\" . equals ( control . attr ( \"type\" ) ) && control . hasAttr ( \"checked\" ) ) { \nString name = control . attr ( \"name\" ) ; \nif ( controlsByName . containsKey ( name ) ) controlsByName . get ( name ) . attr ( \"checked\" , false ) ; \ncontrolsByName . put ( name , control ) ; \n} \n} \n} \n} \n"}
{"10495": "public class BaseUnaryCondition { \npublic boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( waitNanos > 0 ) { \nlong remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; \nif ( remainingTimeNanos <= 0 ) return false ; \nlong timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; \nlong milliPause = timeToPauseNanos / 1000000 ; \nint nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10498": "public class DateRangeType { \npublic static Type createInstance ( String name , DateOnly from , DateOnly to ) { \nif ( ( from != null ) && ( to != null ) && ( from . compareTo ( to ) > 0 ) ) throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \nsynchronized ( DATE_RANGE_TYPES ) { \nDateRangeType newType = new DateRangeType ( name , from , to ) ; \nDateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nDATE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \"false. \" ) ; \nreturn ; \n} \nfor ( ; \ni . hasNext ( ) ; \n) { \nSet < Variable > solution = i . next ( ) ; \nif ( solution . isEmpty ( ) ) System . out . print ( \"true\" ) ; \nelse for ( Iterator < Variable > j = solution . iterator ( ) ; \nj . hasNext ( ) ; \n) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \nSystem . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; \nif ( j . hasNext ( ) ) System . out . println ( ) ; \n} \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \".\" ) ; \nbreak ; \n} \ntry { \nint key = consoleReader . readVirtualKey ( ) ; \nif ( key == SEMICOLON ) System . out . println ( \" ;\" ) ; \nelse { \nSystem . out . println ( ) ; \nbreak ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n"}
{"10513": "public class TypeConverter { \npublic static Object convert ( MultiTypeData d , Class c ) { \nif ( ( ( d . typeFlags & BOOLEAN ) != 0 ) && ( Boolean . TYPE . equals ( c ) || Boolean . class . equals ( c ) ) ) return d . booleanValue ; \nelse if ( ( ( d . typeFlags & INT ) != 0 ) && ( Integer . TYPE . equals ( c ) || Integer . class . equals ( c ) ) ) return d . intValue ; \nelse if ( ( ( d . typeFlags & CHAR ) != 0 ) && ( Character . TYPE . equals ( c ) || Character . class . equals ( c ) ) ) return d . charValue ; \nelse if ( ( ( d . typeFlags & BYTE ) != 0 ) && ( Byte . TYPE . equals ( c ) || Byte . class . equals ( c ) ) ) return d . byteValue ; \nelse if ( ( ( d . typeFlags & SHORT ) != 0 ) && ( Short . TYPE . equals ( c ) || Short . class . equals ( c ) ) ) return d . shortValue ; \nelse if ( ( ( d . typeFlags & LONG ) != 0 ) && ( Long . TYPE . equals ( c ) || Long . class . equals ( c ) ) ) return d . longValue ; \nelse if ( ( ( d . typeFlags & FLOAT ) != 0 ) && ( Float . TYPE . equals ( c ) || Float . class . equals ( c ) ) ) return d . floatValue ; \nelse if ( ( ( d . typeFlags & DOUBLE ) != 0 ) && ( Double . TYPE . equals ( c ) || Double . class . equals ( c ) ) ) return d . doubleValue ; \nelse if ( ( ( d . typeFlags & STRING ) != 0 ) && String . class . equals ( c ) ) return d . stringValue ; \nelse if ( ( ( d . typeFlags & OBJECT ) != 0 ) && d . objectValue . getClass ( ) . equals ( c ) ) return d . objectValue ; \nelse throw new ClassCastException ( \"The multi data type, \" + d + \", cannot be converted to the class, \" + c + \".\" ) ; \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) && ( newStart <= key ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nfor ( ; \nnewStart <= end ; \nnewStart ++ ) if ( data [ offset ( newStart ) ] != null ) break ; \nstart = newStart ; \n} \nelse { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \n} \n} \n"}
{"10516": "public class CircularArrayMap { \nprivate void expand ( int key ) { \nint newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; \nint newSpaceSize = spaceRequired ( key ) ; \nint newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; \nObject [ ] oldData = data ; \ndata = new Object [ newSize ] ; \nint offsetStart = offset ( start ) ; \nint offsetEnd = offset ( end ) ; \nif ( offsetStart < offsetEnd ) System . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; \nelse { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; \nSystem . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; \n} \noffset = - start ; \nlength = newSize ; \n} \n} \n"}
{"10519": "public class DynamicOperatorParser { \npublic Term parseOperators ( Term [ ] terms ) throws SourceCodeException { \nstack . offer ( 0 ) ; \nstate = 0 ; \nposition = 0 ; \nnextTerm = null ; \nfor ( position = 0 ; \nposition <= terms . length ; \n) { \nSymbol nextSymbol ; \nif ( position < terms . length ) { \nnextTerm = terms [ position ] ; \nif ( nextTerm instanceof CandidateOpSymbol ) nextSymbol = Symbol . Op ; \nelse nextSymbol = Symbol . Term ; \n} \nelse nextSymbol = Symbol . Final ; \nAction action = actionTable [ state ] [ nextSymbol . ordinal ( ) ] ; \naction . apply ( ) ; \n} \nreturn ( Functor ) outputStack . poll ( ) ; \n} \n} \n"}
{"10521": "public class DynamicOperatorParser { \nprotected static OpSymbol checkAndResolveToFixity ( CandidateOpSymbol candidate , OpSymbol . Fixity ... fixities ) throws SourceCodeException { \nOpSymbol result = null ; \nfor ( OpSymbol . Fixity fixity : fixities ) { \nresult = candidate . getPossibleOperators ( ) . get ( fixity ) ; \nif ( result != null ) break ; \n} \nif ( result == null ) throw new SourceCodeException ( \"Operator \" + candidate + \" must be one of \" + Arrays . toString ( fixities ) + \", but does not have the required form.\" , null , null , null , candidate . getSourceCodePosition ( ) ) ; \nreturn result ; \n} \n} \n"}
{"10522": "public class SearchNode { \npublic SearchNode < O , T > makeNode ( Successor successor ) throws SearchNotExhaustiveException { \nSearchNode newNode ; \ntry { \nnewNode = getClass ( ) . newInstance ( ) ; \nnewNode . state = successor . getState ( ) ; \nnewNode . parent = this ; \nnewNode . appliedOp = successor . getOperator ( ) ; \nnewNode . depth = depth + 1 ; \nnewNode . pathCost = pathCost + successor . getCost ( ) ; \nif ( repeatedStateFilter != null ) newNode . setRepeatedStateFilter ( repeatedStateFilter ) ; \nreturn newNode ; \n} \ncatch ( InstantiationException e ) { \nthrow new IllegalStateException ( \"InstantiationException during creation of new search node.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"IllegalAccessException during creation of new search node.\" , e ) ; \n} \n} \n} \n"}
{"10523": "public class CommandLineParser { \npublic static String rightPad ( String stringToPad , String padder , int size ) { \nif ( padder . length ( ) == 0 ) return stringToPad ; \nStringBuffer strb = new StringBuffer ( stringToPad ) ; \nCharacterIterator sci = new StringCharacterIterator ( padder ) ; \nwhile ( strb . length ( ) < size ) for ( char ch = sci . first ( ) ; \nch != CharacterIterator . DONE ; \nch = sci . next ( ) ) if ( strb . length ( ) < size ) strb . append ( String . valueOf ( ch ) ) ; \nreturn strb . toString ( ) ; \n} \n} \n"}
{"10524": "public class CommandLineParser { \npublic String getErrors ( ) { \nif ( parsingErrors . isEmpty ( ) ) return \"\" ; \nString result = \"\" ; \nfor ( String s : parsingErrors ) { \nresult += s ; \n} \nreturn result ; \n} \n} \n"}
{"10525": "public class CommandLineParser { \npublic String getOptionsInForce ( ) { \nif ( parsedProperties == null ) return \"\" ; \nString result = \"Options in force:\\n\" ; \nfor ( Map . Entry < Object , Object > property : parsedProperties . entrySet ( ) ) { \nresult += property . getKey ( ) + \" = \" + property . getValue ( ) + \"\\n\" ; \n} \nreturn result ; \n} \n} \n"}
{"10527": "public class CommandLineParser { \npublic void addTrailingPairsToProperties ( Properties properties ) { \nif ( trailingProperties != null ) for ( Object propKey : trailingProperties . keySet ( ) ) { \nString name = ( String ) propKey ; \nString value = trailingProperties . getProperty ( name ) ; \nproperties . setProperty ( name , value ) ; \n} \n} \n} \n"}
{"10528": "public class CommandLineParser { \npublic void addOptionsToProperties ( Properties properties ) { \nif ( parsedProperties != null ) for ( Object propKey : parsedProperties . keySet ( ) ) { \nString name = ( String ) propKey ; \nString value = parsedProperties . getProperty ( name ) ; \nif ( ! name . matches ( \"^[0-9]+$\" ) ) properties . setProperty ( name , value ) ; \n} \n} \n} \n"}
{"10530": "public class CommandLineParser { \nprivate Properties takeFreeArgsAsProperties ( Properties properties , int from ) { \nProperties result = new Properties ( ) ; \nfor ( int i = from ; \ntrue ; \ni ++ ) { \nString nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; \nif ( nextFreeArg == null ) break ; \nString [ ] nameValuePair = nextFreeArg . split ( \"=\" ) ; \nif ( nameValuePair . length == 2 ) result . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; \n} \nreturn result ; \n} \n} \n"}
{"10531": "public class CommandLineParser { \nprivate void checkArgumentFormat ( CommandLineOption optionInfo , CharSequence matchedArg ) { \nif ( optionInfo . argumentFormatRegexp != null ) { \nPattern pattern = Pattern . compile ( optionInfo . argumentFormatRegexp ) ; \nMatcher argumentMatcher = pattern . matcher ( matchedArg ) ; \nif ( ! argumentMatcher . matches ( ) ) parsingErrors . add ( \"The argument to option \" + optionInfo . option + \" does not meet its required format.\\n\" ) ; \n} \n} \n} \n"}
{"10532": "public class Comparisons { \npublic static < T , U > String compareIterators ( Iterator < U > iterator , Iterator < T > expectedIterator , Function < U , T > mapping ) { \nString errorMessage = \"\" ; \nwhile ( iterator . hasNext ( ) ) { \nU next = iterator . next ( ) ; \nT nextMapped = mapping . apply ( next ) ; \nT nextExpected = expectedIterator . next ( ) ; \nif ( ! nextMapped . equals ( nextExpected ) ) errorMessage += \"Expecting \" + nextExpected + \" but got \" + nextMapped ; \n} \nreturn errorMessage ; \n} \n} \n"}
{"10539": "public class FloatRangeType { \npublic static Type createInstance ( String name , float min , float max ) { \nif ( min > max ) throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \nsynchronized ( FLOAT_RANGE_TYPES ) { \nFloatRangeType newType = new FloatRangeType ( name , min , max ) ; \nFloatRangeType oldType = FLOAT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; \nelse { \nFLOAT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10540": "public class WAMResolvingJavaMachine { \npublic void reset ( ) { \ndata = ByteBuffer . allocateDirect ( TOP << 2 ) . order ( ByteOrder . LITTLE_ENDIAN ) . asIntBuffer ( ) ; \ncodeBuffer = ByteBuffer . allocateDirect ( CODE_SIZE ) ; \ncodeBuffer . order ( ByteOrder . LITTLE_ENDIAN ) ; \nhp = HEAP_BASE ; \nhbp = HEAP_BASE ; \nsp = HEAP_BASE ; \nep = 0 ; \nbp = 0 ; \nb0 = 0 ; \ntrp = TRAIL_BASE ; \nup = TOP ; \nwriteMode = false ; \nip = 0 ; \nderefTag = 0 ; \nderefVal = 0 ; \nsuspended = false ; \nsuper . reset ( ) ; \nsetInternalCodeAddress ( internFunctorName ( \"call\" , 1 ) , CALL_1_ID ) ; \nsetInternalCodeAddress ( internFunctorName ( \"execute\" , 1 ) , EXECUTE_1_ID ) ; \nif ( monitor != null ) monitor . onReset ( this ) ; \n} \n} \n"}
{"10542": "public class WAMResolvingJavaMachine { \nprotected String traceChoiceFrame ( ) { \nif ( bp == 0 ) return \"\" ; \nint n = data . get ( bp ) ; \nreturn \"choice: [ n = \" + data . get ( bp ) + \", ep = \" + data . get ( bp + n + 1 ) + \", cp = \" + data . get ( bp + n + 2 ) + \", bp = \" + data . get ( bp + n + 3 ) + \", l = \" + data . get ( bp + n + 4 ) + \", trp = \" + data . get ( bp + n + 5 ) + \", hp = \" + data . get ( bp + n + 6 ) + \", b0 = \" + data . get ( bp + n + 7 ) ; \n} \n} \n"}
{"10544": "public class WAMResolvingJavaMachine { \nprivate int nextStackFrame ( ) { \nif ( ep == bp ) return STACK_BASE ; \nelse if ( ep > bp ) return ep + data . get ( ep + 2 ) + 3 ; \nelse return bp + data . get ( bp ) + 8 ; \n} \n} \n"}
{"10545": "public class WAMResolvingJavaMachine { \nprivate boolean backtrack ( ) { \nif ( bp == 0 ) return true ; \nelse { \nb0 = data . get ( bp + data . get ( bp ) + 7 ) ; \nip = data . get ( bp + data . get ( bp ) + 4 ) ; \nreturn false ; \n} \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nint i ; \nif ( bp == 0 ) i = TRAIL_BASE ; \nelse i = data . get ( bp + data . get ( bp ) + 5 ) ; \nwhile ( i < trp ) { \nint addr = data . get ( i ) ; \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) i ++ ; \nelse { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp -- ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) if ( ( t1 == WAMInstruction . REF ) ) bind ( d1 , d2 ) ; \nelse if ( t2 == WAMInstruction . REF ) bind ( d1 , d2 ) ; \nelse if ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) for ( int i = 1 ; \ni <= n1 ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \nelse fail = true ; \n} \nelse if ( t2 == WAMInstruction . CON ) if ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) fail = true ; \nelse if ( t2 == WAMInstruction . LIS ) if ( t1 != WAMInstruction . LIS ) fail = true ; \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10553": "public class EightPuzzleState { \npublic static boolean isSolvable ( EightPuzzleState state ) { \nEightPuzzleState checkState ; \ntry { \ncheckState = ( EightPuzzleState ) state . clone ( ) ; \n} \ncatch ( CloneNotSupportedException e ) { \nthrow new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; \n} \nEightPuzzleState goalState = getGoalState ( ) ; \nint illegalSwaps = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) for ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nchar t = goalState . getTileAt ( i , j ) ; \nillegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; \n} \nreturn ( illegalSwaps % 2 ) == 0 ; \n} \n} \n"}
{"10555": "public class EightPuzzleState { \npublic Iterator < Operator < String > > validOperators ( boolean reverse ) { \nList < Operator < String > > moves = new ArrayList < Operator < String > > ( 4 ) ; \nif ( emptyY != 0 ) moves . add ( new OperatorImpl < String > ( \"U\" ) ) ; \nif ( emptyY != 2 ) moves . add ( new OperatorImpl < String > ( \"D\" ) ) ; \nif ( emptyX != 0 ) moves . add ( new OperatorImpl < String > ( \"L\" ) ) ; \nif ( emptyX != 2 ) moves . add ( new OperatorImpl < String > ( \"R\" ) ) ; \nreturn moves . iterator ( ) ; \n} \n} \n"}
{"10556": "public class EightPuzzleState { \npublic String prettyPrint ( ) { \nString result = \"\" ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) result += new String ( board [ j ] ) + \"\\n\" ; \nresult = result . replace ( 'E' , ' ' ) ; \nreturn result ; \n} \n} \n"}
{"10557": "public class EightPuzzleState { \nprotected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { \nint illegal = 0 ; \nint tileX = getXForTile ( t ) ; \nint tileY = getYForTile ( t ) ; \nwhile ( tileX != x ) if ( ( tileX - x ) > 0 ) { \nif ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) illegal ++ ; \ntileX -- ; \n} \nelse { \nif ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) illegal ++ ; \ntileX ++ ; \n} \nwhile ( tileY != y ) { \nif ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) illegal ++ ; \ntileY -- ; \n} \nreturn illegal ; \n} \n} \n"}
{"10559": "public class EightPuzzleState { \nprivate static List < Character > stringToCharList ( String boardString ) { \nchar [ ] chars = new char [ 9 ] ; \nboardString . getChars ( 0 , 9 , chars , 0 ) ; \nList < Character > charList = new ArrayList < Character > ( ) ; \nfor ( int l = 0 ; \nl < 9 ; \nl ++ ) charList . add ( chars [ l ] ) ; \nreturn charList ; \n} \n} \n"}
{"10560": "public class EightPuzzleState { \nprivate static EightPuzzleState charListToState ( List < Character > charList ) { \nEightPuzzleState newState = new EightPuzzleState ( ) ; \nIterator < Character > k = charList . iterator ( ) ; \nfor ( int j = 0 ; \nj < 3 ; \nj ++ ) for ( int i = 0 ; \ni < 3 ; \ni ++ ) { \nchar nextChar = k . next ( ) ; \nif ( nextChar == 'E' ) { \nnewState . emptyX = i ; \nnewState . emptyY = j ; \n} \nnewState . board [ j ] [ i ] = nextChar ; \n} \nreturn newState ; \n} \n} \n"}
{"10561": "public class LoggingToLog4JHandler { \nprivate String toLog4jMessage ( LogRecord record ) { \nString message = record . getMessage ( ) ; \nObject [ ] parameters = record . getParameters ( ) ; \nif ( ( parameters != null ) && ( parameters . length != 0 ) ) if ( ( message . indexOf ( \"{0}\" ) >= 0 ) || ( message . indexOf ( \"{1}\" ) >= 0 ) || ( message . indexOf ( \"{2}\" ) >= 0 ) || ( message . indexOf ( \"{3}\" ) >= 0 ) ) message = MessageFormat . format ( message , parameters ) ; \nreturn message ; \n} \n} \n"}
{"10562": "public class LoggingToLog4JHandler { \nprivate org . apache . log4j . Level toLog4j ( Level level ) { \nif ( Level . SEVERE == level ) return org . apache . log4j . Level . ERROR ; \nelse if ( Level . WARNING == level ) return org . apache . log4j . Level . WARN ; \nelse if ( Level . INFO == level ) return org . apache . log4j . Level . INFO ; \nelse if ( Level . FINE == level ) return org . apache . log4j . Level . DEBUG ; \nelse if ( Level . FINER == level ) return org . apache . log4j . Level . TRACE ; \nelse if ( Level . OFF == level ) return org . apache . log4j . Level . OFF ; \nreturn org . apache . log4j . Level . OFF ; \n} \n} \n"}
{"10565": "public class WrapperQueue { \nprivate void incrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) count . incrementAndGet ( ) ; \nif ( sizeable && ( record instanceof Sizeable ) ) dataSize . addAndGet ( ( ( Sizeable ) record ) . sizeof ( ) ) ; \nelse if ( sizeable ) dataSize . incrementAndGet ( ) ; \n} \n} \n"}
{"10566": "public class WrapperQueue { \nprivate void decrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) count . decrementAndGet ( ) ; \nif ( sizeable && ( record instanceof Sizeable ) ) { \nlong recordSize = - ( ( Sizeable ) record ) . sizeof ( ) ; \nlong oldSize = dataSize . getAndAdd ( recordSize ) ; \nlong newSize = oldSize + recordSize ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \nelse if ( sizeable ) { \nlong oldSize = dataSize . getAndDecrement ( ) ; \nlong newSize = oldSize - 1 ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \n} \n} \n"}
{"10567": "public class WrapperQueue { \nprivate void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { \nif ( signalable != null ) if ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) signalable . signalAll ( ) ; \nelse if ( ( oldSize >= highWaterSizeThreshold ) && ( newSize < highWaterSizeThreshold ) ) signalable . signal ( ) ; \n} \n} \n"}
{"10568": "public class SimpleContext { \npublic NamingEnumeration list ( String name ) throws NamingException { \nif ( \"\" . equals ( name ) ) return new FlatNames ( bindings . keys ( ) ) ; \nObject target = lookup ( name ) ; \nif ( target instanceof Context ) return ( ( Context ) target ) . list ( \"\" ) ; \nthrow new NotContextException ( name + \" cannot be listed\" ) ; \n} \n} \n"}
{"10569": "public class SimpleContext { \npublic NamingEnumeration listBindings ( String name ) throws NamingException { \nif ( \"\" . equals ( name ) ) return new FlatBindings ( bindings . keys ( ) ) ; \nObject target = lookup ( name ) ; \nif ( target instanceof Context ) return ( ( Context ) target ) . listBindings ( \"\" ) ; \nthrow new NotContextException ( name + \" cannot be listed\" ) ; \n} \n} \n"}
{"10570": "public class SimpleContext { \npublic Object addToEnvironment ( String propName , Object propVal ) { \nif ( myEnv == null ) myEnv = new Hashtable ( 5 , 0.75f ) ; \nreturn myEnv . put ( propName , propVal ) ; \n} \n} \n"}
{"10571": "public class SimpleContext { \npublic Object removeFromEnvironment ( String propName ) { \nif ( myEnv == null ) return null ; \nreturn myEnv . remove ( propName ) ; \n} \n} \n"}
{"10574": "public class Parser { \nboolean resolveMixinReference ( String name , ArgumentsNode arguments ) { \nif ( ! isParserTranslationEnabled ( ) ) return push ( new PlaceholderNode ( new SimpleNode ( name ) ) ) ; \nfor ( Node node : getContext ( ) . getValueStack ( ) ) { \nif ( ! ( node instanceof ScopeNode ) ) continue ; \nScopeNode scope = ( ScopeNode ) node ; \nRuleSetNode ruleSet = scope . getRuleSet ( name ) ; \nif ( ruleSet == null ) continue ; \nScopeNode ruleSetScope = NodeTreeUtils . getFirstChild ( ruleSet , ScopeNode . class ) . callMixin ( name , arguments ) ; \nreturn push ( ruleSetScope ) ; \n} \nthrow new UndefinedMixinException ( name ) ; \n} \n} \n"}
{"10575": "public class Parser { \nboolean pushVariableReference ( String name ) { \nif ( ! isParserTranslationEnabled ( ) ) return push ( new SimpleNode ( name ) ) ; \nfor ( Node node : getContext ( ) . getValueStack ( ) ) { \nif ( ! ( node instanceof ScopeNode ) ) continue ; \nScopeNode scope = ( ScopeNode ) node ; \nif ( ! scope . isVariableDefined ( name ) ) continue ; \nreturn push ( new VariableReferenceNode ( name ) ) ; \n} \nthrow new UndefinedVariableException ( name ) ; \n} \n} \n"}
{"10576": "public class TextTableImpl { \npublic void setMaxRowHeight ( int row , int height ) { \nInteger previousValue = maxRowSizes . get ( row ) ; \nif ( previousValue == null ) maxRowSizes . put ( row , height ) ; \nelse if ( previousValue < height ) maxRowSizes . put ( row , height ) ; \n} \n} \n"}
{"10577": "public class TextTableImpl { \nprivate void updateMaxColumnWidth ( int column , int width ) { \nInteger previousValue = maxColumnSizes . get ( column ) ; \nif ( previousValue == null ) maxColumnSizes . put ( column , width ) ; \nelse if ( previousValue < width ) maxColumnSizes . put ( column , width ) ; \n} \n} \n"}
{"10578": "public class PageAction { \npublic ActionForward executeWithErrorHandling ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response , ActionErrors errors ) throws Exception { \nHttpSession session = request . getSession ( false ) ; \nDynaActionForm pageForm = ( DynaActionForm ) form ; \nlog . fine ( \"pageForm = \" + pageForm ) ; \nString listingVarName = pageForm . getString ( VAR_NAME_PARAM ) ; \nlog . fine ( \"listingVarName = \" + listingVarName ) ; \nPagedList pagedList = ( PagedList ) session . getAttribute ( listingVarName ) ; \npagedList . setCurrentPage ( ( Integer ) pageForm . get ( NUMBER_PARAM ) ) ; \nInteger index = ( Integer ) pageForm . get ( INDEX_PARAM ) ; \nif ( index != null ) pagedList . setCurrentIndex ( index ) ; \nreturn mapping . findForward ( SUCCESS_FORWARD ) ; \n} \n} \n"}
{"10584": "public class Cons { \nprivate String listToString ( VariableAndFunctorInterner interner , boolean isFirst , boolean printVarName , boolean printBindings ) { \nString result = \"\" ; \nif ( isFirst ) result += \"[\" ; \nresult += arguments [ 0 ] . toString ( interner , printVarName , printBindings ) ; \nTerm consArgument = arguments [ 1 ] . getValue ( ) ; \nif ( consArgument instanceof Cons ) result += \", \" + ( ( Cons ) consArgument ) . listToString ( interner , false , printVarName , printBindings ) ; \nif ( isFirst ) result += \"]\" ; \nreturn result ; \n} \n} \n"}
{"10585": "public class LessThan { \nprotected boolean evaluate ( NumericType firstNumber , NumericType secondNumber ) { \nif ( firstNumber . isInteger ( ) && secondNumber . isInteger ( ) ) return firstNumber . intValue ( ) < secondNumber . intValue ( ) ; \nelse return firstNumber . doubleValue ( ) < secondNumber . doubleValue ( ) ; \n} \n} \n"}
{"10590": "public class FibonacciHeap { \nprivate static int ceilingLog2 ( int n ) { \nint oa ; \nint i ; \nint b ; \noa = n ; \nb = 32 / 2 ; \ni = 0 ; \nwhile ( b != 0 ) { \ni = ( i << 1 ) ; \nif ( n >= ( 1 << b ) ) { \nn /= ( 1 << b ) ; \ni = i | 1 ; \n} \nelse n &= ( 1 << b ) - 1 ; \nb /= 2 ; \n} \nif ( ( 1 << i ) == oa ) return i ; \nelse return i + 1 ; \n} \n} \n"}
{"10591": "public class FibonacciHeap { \nprivate void updateMinimum ( Node node ) { \nif ( entryComparator != null ) if ( entryComparator . compare ( node . element , minNode . element ) < 0 ) minNode = node ; \nelse if ( ( ( Comparable ) node . element ) . compareTo ( minNode . element ) < 0 ) minNode = node ; \n} \n} \n"}
{"10592": "public class FibonacciHeap { \nprivate int compare ( Node node1 , Node node2 ) { \nif ( entryComparator != null ) return entryComparator . compare ( node1 . element , node2 . element ) ; \nelse return ( ( Comparable ) node1 . element ) . compareTo ( node2 . element ) ; \n} \n} \n"}
{"10598": "public class Filterator { \npublic T nextInSequence ( ) { \nT result = null ; \nwhile ( source . hasNext ( ) ) { \nS next = source . next ( ) ; \nresult = mapping . apply ( next ) ; \nif ( result != null ) break ; \n} \nreturn result ; \n} \n} \n"}
{"10600": "public class BeanMemento { \npublic Object get ( Class cls , String property ) throws NoSuchFieldException { \nif ( ! values . containsKey ( property ) ) throw new NoSuchFieldException ( \"The property, \" + property + \", does not exist on the underlying class.\" ) ; \nreturn values . get ( property ) ; \n} \n} \n"}
{"10603": "public class BeanMemento { \nprivate void capture ( boolean ignoreNull ) { \nClass cls = ob . getClass ( ) ; \nMethod [ ] methods = cls . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propName = Character . toLowerCase ( methodName . charAt ( 3 ) ) + methodName . substring ( 4 ) ; \ntry { \nObject [ ] params = new Object [ ] { \n} \n; \nObject value = nextMethod . invoke ( ob , params ) ; \nif ( ! ignoreNull || ( value != null ) ) values . put ( propName , value ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n} \n"}
{"10604": "public class FifoStack { \npublic E pop ( ) { \nE ob ; \nif ( size ( ) == 0 ) return null ; \nob = get ( 0 ) ; \nremove ( 0 ) ; \nreturn ob ; \n} \n} \n"}
{"10605": "public class SwingKeyCombinationBuilder { \nprivate String modifiersToString ( int modifiers ) { \nString result = \"\" ; \nif ( ( modifiers & InputEvent . SHIFT_MASK ) != 0 ) result += \"shift \" ; \nif ( ( modifiers & InputEvent . CTRL_MASK ) != 0 ) result += \"ctrl \" ; \nif ( ( modifiers & InputEvent . META_MASK ) != 0 ) result += \"meta \" ; \nif ( ( modifiers & InputEvent . ALT_MASK ) != 0 ) result += \"alt \" ; \nif ( ( modifiers & InputEvent . ALT_GRAPH_MASK ) != 0 ) result += \"altGraph \" ; \nreturn result ; \n} \n} \n"}
{"10614": "public class OptimizeInstructions { \npublic boolean isConstant ( WAMInstruction instruction ) { \nInteger name = instruction . getFunctorNameReg1 ( ) ; \nif ( name != null ) { \nFunctorName functorName = interner . getDeinternedFunctorName ( name ) ; \nif ( functorName . getArity ( ) == 0 ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"10615": "public class OptimizeInstructions { \nprivate boolean isVoidVariable ( WAMInstruction instruction ) { \nSymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; \nif ( symbolKey != null ) { \nInteger count = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_OCCURRENCE_COUNT ) ; \nBoolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_NON_ARG ) ; \nInteger allocation = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_ALLOCATION ) ; \nboolean singleton = ( count != null ) && count . equals ( 1 ) ; \nboolean nonArgPosition = ( nonArgPositionOnly != null ) && TRUE . equals ( nonArgPositionOnly ) ; \nboolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & 0xff00 ) >> 8 ) == WAMInstruction . STACK_ADDR ) ; \nif ( singleton && nonArgPosition && ! permanent ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"10616": "public class OptimizeInstructions { \nprivate boolean isNonArg ( WAMInstruction instruction ) { \nSymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; \nif ( symbolKey != null ) { \nBoolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_FUNCTOR_NON_ARG ) ; \nif ( TRUE . equals ( nonArgPositionOnly ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"10617": "public class Clause { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof ClauseTraverser ) ) return ( ( ClauseTraverser ) traverser ) . traverse ( this , reverse ) ; \nelse { \nLinkedList < Operator < Term > > resultList = null ; \nif ( ! reverse ) resultList = new LinkedList < Operator < Term > > ( ) ; \nelse resultList = new StackQueue < Operator < Term > > ( ) ; \nif ( head != null ) resultList . add ( head ) ; \nif ( body != null ) for ( Term bodyTerm : body ) { \nresultList . add ( bodyTerm ) ; \n} \nreturn resultList . iterator ( ) ; \n} \n} \n} \n"}
{"10618": "public class Functor { \npublic Term getArgument ( int index ) { \nif ( ( arguments == null ) || ( index > ( arguments . length - 1 ) ) ) return null ; \nelse return arguments [ index ] ; \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) return ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \nelse if ( arguments == null ) return new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \nelse if ( ! reverse ) return Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( int i = arity - 1 ; \ni >= 0 ; \ni -- ) argList . add ( arguments [ i ] ) ; \nreturn argList . iterator ( ) ; \n} \n} \n} \n"}
{"10621": "public class SqlQueryEngine { \npublic < T extends MeasureAppender > T retrieveSummary ( SchemaDefinition schemaDefinition , Class < T > resultClazz , QueryParameter queryParameter ) throws NovieRuntimeException { \nfinal SqlQueryBuilder < T > sqlQueryBuilder = new SqlQueryBuilder < T > ( schemaDefinition , resultClazz , queryParameter . partialCopy ( QueryParameterKind . GROUPS , QueryParameterKind . PAGE ) ) ; \nList < T > result = executeQuery ( sqlQueryBuilder ) ; \nif ( result . isEmpty ( ) ) throw new NovieRuntimeException ( \"Summary doesn't return any result.\" ) ; \nif ( result . size ( ) > 1 ) throw new NovieRuntimeException ( \"Summary returns more than one result.\" ) ; \nreturn result . get ( 0 ) ; \n} \n} \n"}
{"10623": "public class SqlQueryEngine { \nprivate < T extends MeasureAppender > List < T > executeQuery ( final SqlQueryBuilder < T > sqlQueryBuilder ) throws NovieRuntimeException { \nsqlQueryBuilder . buildQuery ( ) ; \nfinal String queryString = sqlQueryBuilder . getQueryString ( ) ; \nLOG . debug ( queryString ) ; \nlong beforeQuery = System . currentTimeMillis ( ) ; \nList < T > returnValue = jdbcTemplate . query ( queryString , sqlQueryBuilder . getMapSqlParameterSource ( ) , sqlQueryBuilder ) ; \nif ( LOG . isInfoEnabled ( ) ) LOG . info ( \"SQL query successfully ran in \" + ( System . currentTimeMillis ( ) - beforeQuery ) + \"ms.\" ) ; \nif ( LOG . isDebugEnabled ( ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( Entry < String , Object > e : sqlQueryBuilder . getMapSqlParameterSource ( ) . getValues ( ) . entrySet ( ) ) { \nif ( sb . length ( ) > 0 ) sb . append ( \",\" ) ; \nsb . append ( e . getKey ( ) ) ; \nsb . append ( \"=\" ) ; \nsb . append ( e . getValue ( ) ) ; \n} \nsb . insert ( 0 , \"Parameters [\" ) ; \nsb . append ( \"]\" ) ; \nLOG . debug ( sb . toString ( ) ) ; \n} \nreturn returnValue ; \n} \n} \n"}
{"10625": "public class JavaType { \nprivate void setBasicType ( Class c ) { \nif ( Boolean . class . equals ( c ) ) type = BasicTypes . BOOLEAN ; \nelse if ( Character . class . equals ( c ) ) type = BasicTypes . CHARACTER ; \nelse if ( Byte . class . equals ( c ) ) type = BasicTypes . BYTE ; \nelse if ( Short . class . equals ( c ) ) type = BasicTypes . SHORT ; \nelse if ( Integer . class . equals ( c ) ) type = BasicTypes . INTEGER ; \nelse if ( Long . class . equals ( c ) ) type = BasicTypes . LONG ; \nelse if ( Float . class . equals ( c ) ) type = BasicTypes . FLOAT ; \nelse if ( Double . class . equals ( c ) ) type = BasicTypes . DOUBLE ; \nelse type = BasicTypes . OTHER ; \n} \n} \n"}
{"10626": "public class ResolutionEngine { \npublic void consultInputStream ( InputStream stream ) throws SourceCodeException { \nSource < Token > tokenSource = TokenSource . getTokenSourceForInputStream ( stream ) ; \ngetParser ( ) . setTokenSource ( tokenSource ) ; \nwhile ( true ) { \nSentence < S > sentence = getParser ( ) . parse ( ) ; \nif ( sentence == null ) break ; \ngetCompiler ( ) . compile ( sentence ) ; \n} \n} \n} \n"}
{"10630": "public class SocketReadThread { \nprivate void readStream ( ) throws Exception { \nwhile ( ! shutdown ) { \nElement doc = reader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) return ; \nPacket packet ; \nString tag = doc . getName ( ) ; \nif ( \"message\" . equals ( tag ) ) packet = new Message ( doc ) ; \nelse if ( \"presence\" . equals ( tag ) ) packet = new Presence ( doc ) ; \nelse if ( \"iq\" . equals ( tag ) ) packet = getIQ ( doc ) ; \nelse throw new XmlPullParserException ( \"Unknown packet type was read: \" + tag ) ; \ncomponent . processPacket ( packet ) ; \n} \n} \n} \n"}
{"10635": "public class Player { \n@ Override public void renderFinalOutput ( List < T > data , EventModel eventModel ) { \nif ( StartMusicRequest . verify ( eventModel , capabilities , this , activators ) ) if ( isOutputRunning ( ) ) playerError ( PlayerError . ERROR_ALREADY_PLAYING , eventModel . getSource ( ) ) ; \nelse handleEventRequest ( eventModel ) ; \nelse if ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( MusicUsageResource . ID ) ) ) if ( isOutputRunning ( ) ) eventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . forEach ( resourceModel -> playerError ( PlayerError . ERROR_ALREADY_PLAYING , resourceModel . getProvider ( ) ) ) ; \nelse handleResourceRequest ( eventModel ) ; \nelse handleCommands ( eventModel ) ; \n} \n} \n"}
{"10637": "public class Player { \nprivate void handleEventRequest ( EventModel eventModel ) { \nplayingThread = submit ( ( Runnable ) ( ) -> { \nif ( runsInPlay ) isRunning = false ; \nelse isRunning = true ; \nisPlaying = true ; \nfireStartMusicRequest ( eventModel ) ; \n} \n) . thenRun ( ( ) -> play ( eventModel ) ) . thenRun ( ( ) -> { \nif ( runsInPlay ) { \nisRunning = false ; \nisPlaying = false ; \nendedSound ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"10640": "public class PacketReader { \nsynchronized public void startup ( ) throws XMPPException { \nfinal List < Exception > errors = new LinkedList < Exception > ( ) ; \nAbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { \n@ Override public void connectionClosedOnError ( Exception e ) { \nerrors . add ( e ) ; \n} \n} \n; \nconnection . addConnectionListener ( connectionErrorListener ) ; \nreaderThread . start ( ) ; \ntry { \nint waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; \nwait ( 3 * waitTime ) ; \n} \ncatch ( InterruptedException ie ) { \n} \nconnection . removeConnectionListener ( connectionErrorListener ) ; \nif ( connectionID == null ) throw new XMPPException ( \"Connection failed. No response from server.\" ) ; \nelse if ( ! errors . isEmpty ( ) ) throw new XMPPException ( errors . iterator ( ) . next ( ) ) ; \nelse connection . connectionID = connectionID ; \n} \n} \n"}
{"10641": "public class PacketReader { \npublic void shutdown ( ) { \nif ( ! done ) for ( ConnectionListener listener : connection . getConnectionListeners ( ) ) { \ntry { \nlistener . connectionClosed ( ) ; \n} \ncatch ( Exception e ) { \nLOGGER . log ( Level . ERROR , \"Error in listener while closing connection\" , e ) ; \n} \n} \ndone = true ; \nlistenerExecutor . shutdown ( ) ; \n} \n} \n"}
{"10643": "public class PacketReader { \nprivate void parsePackets ( Thread thread ) { \ntry { \nwhile ( ! done ) { \nif ( reset ) { \nstartStream ( ) ; \nLOGGER . debug ( \"Started xmlstream...\" ) ; \nreset = false ; \ncontinue ; \n} \nElement doc = innerReader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nconnection . disconnect ( ) ; \nLOGGER . debug ( \"End of xmlstream.\" ) ; \ncontinue ; \n} \nPacket packet = null ; \nLOGGER . debug ( \"Processing packet \" + doc . asXML ( ) ) ; \npacket = parseFromPlugins ( doc , packet ) ; \nif ( packet == null ) packet = parseFromCore ( doc ) ; \nif ( packet != null ) processPacket ( packet ) ; \n} \n} \ncatch ( Exception e ) { \nif ( ! done && ! connection . isSocketClosed ( ) ) { \nconnection . notifyConnectionError ( e ) ; \nif ( ! connection . isConnected ( ) ) releaseConnectionIDLock ( ) ; \n} \n} \n} \n} \n"}
{"10644": "public class PacketReader { \nprivate void processPacket ( Packet packet ) { \nif ( packet == null ) return ; \nfor ( PacketCollector collector : connection . getPacketCollectors ( ) ) { \ncollector . processPacket ( packet ) ; \n} \nlistenerExecutor . submit ( new ListenerNotification ( packet ) ) ; \n} \n} \n"}
{"10645": "public class AbstractApplicationOption { \nprotected final void setCliOption ( Option option ) { \nif ( option != null ) this . cliOption = option ; \nif ( this . cliOption . getDescription ( ) != null ) this . descr = this . cliOption . getDescription ( ) ; \nelse this . cliOption . setDescription ( this . descr ) ; \n} \n} \n"}
{"10649": "public class InternalContent { \npublic void setProperty ( String key , Object value ) { \nif ( readOnly ) return ; \nif ( value == null ) throw new IllegalArgumentException ( \"value must not be null\" ) ; \nObject o = content . get ( key ) ; \nif ( ! value . equals ( o ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \nelse if ( updatedContent . containsKey ( key ) && ! value . equals ( updatedContent . get ( key ) ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \n} \n} \n"}
{"10650": "public class OrFilter { \npublic void addFilter ( PacketFilter filter ) { \nif ( filter == null ) throw new IllegalArgumentException ( \"Parameter cannot be null.\" ) ; \nif ( size == filters . length ) { \nPacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; \nfor ( int i = 0 ; \ni < filters . length ; \ni ++ ) newFilters [ i ] = filters [ i ] ; \nfilters = newFilters ; \n} \nfilters [ size ] = filter ; \nsize ++ ; \n} \n} \n"}
{"10651": "public class ModificationRequest { \npublic void processRequest ( HttpServletRequest request ) throws IOException , FileUploadException , StorageClientException , AccessDeniedException { \nboolean debug = LOGGER . isDebugEnabled ( ) ; \nif ( ServletFileUpload . isMultipartContent ( request ) ) { \nif ( debug ) LOGGER . debug ( \"Multipart POST \" ) ; \nfeedback . add ( \"Multipart Upload\" ) ; \nServletFileUpload upload = new ServletFileUpload ( ) ; \nFileItemIterator iterator = upload . getItemIterator ( request ) ; \nwhile ( iterator . hasNext ( ) ) { \nFileItemStream item = iterator . next ( ) ; \nif ( debug ) LOGGER . debug ( \"Got Item {}\" , item ) ; \nString name = item . getFieldName ( ) ; \nInputStream stream = item . openStream ( ) ; \nif ( item . isFormField ( ) ) { \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \nelse if ( streamProcessor != null ) feedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; \n} \nif ( debug ) LOGGER . debug ( \"No More items \" ) ; \n} \nelse { \nif ( debug ) LOGGER . debug ( \"Trad Post \" ) ; \n@ SuppressWarnings ( \"unchecked\" ) Map < String , String [ ] > parameters = request . getParameterMap ( ) ; \nif ( debug ) LOGGER . debug ( \"Traditional POST {} \" , parameters ) ; \nSet < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; \nfor ( Entry < String , String [ ] > param : entries ) { \nString name = ( String ) param . getKey ( ) ; \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \n} \n} \n} \n"}
{"10655": "public class PacketWriter { \nprivate Packet nextPacket ( ) { \nPacket packet = null ; \nwhile ( ! done && ( packet = queue . poll ( ) ) == null ) try { \nsynchronized ( queue ) { \nqueue . wait ( ) ; \n} \n} \ncatch ( InterruptedException ie ) { \n} \nreturn packet ; \n} \n} \n"}
{"10674": "public class StringUtils { \nprivate static String xmlAttribEncodeBinary ( String value ) { \nStringBuilder s = new StringBuilder ( ) ; \nchar buf [ ] = value . toCharArray ( ) ; \nfor ( char c : buf ) { \nswitch ( c ) { \ncase '<' : s . append ( \"&lt;\" ) ; \nbreak ; \ncase '>' : s . append ( \"&gt;\" ) ; \nbreak ; \ncase '&' : s . append ( \"&amp;\" ) ; \nbreak ; \ncase '\"' : s . append ( \"&quot;\" ) ; \nbreak ; \ncase '\\'' : s . append ( \"&apos;\" ) ; \nbreak ; \ndefault : if ( c <= 0x1f || ( 0x7f <= c && c <= 0x9f ) ) { \ns . append ( \"&#x\" ) ; \ns . append ( String . format ( \"%X\" , ( int ) c ) ) ; \ns . append ( ';' ) ; \n} \nelse s . append ( c ) ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"10675": "public class StringUtils { \npublic static String encodeHex ( byte [ ] bytes ) { \nStringBuilder hex = new StringBuilder ( bytes . length * 2 ) ; \nfor ( byte aByte : bytes ) { \nif ( ( ( int ) aByte & 0xff ) < 0x10 ) hex . append ( \"0\" ) ; \nhex . append ( Integer . toString ( ( int ) aByte & 0xff , 16 ) ) ; \n} \nreturn hex . toString ( ) ; \n} \n} \n"}
{"10685": "public class CommandHandler { \nprivate void handleVolume ( EventModel eventModel , ResourceModel < String > resourceModel ) { \nOptional < Volume > volumeResource = VolumeResource . getVolume ( eventModel ) ; \nif ( ! volumeResource . isPresent ( ) ) musicHelper . playerError ( PlayerError . ERROR_ILLEGAL + \"command: \" + resourceModel . getResource ( ) + \"missing resource\" , resourceModel . getProvider ( ) ) ; \nchangeVolume . accept ( volumeResource . get ( ) ) ; \n} \n} \n"}
{"10686": "public class CommandHandler { \nprivate void handleJump ( EventModel eventModel , ResourceModel < String > resourceModel ) { \nOptional < Progress > progress = ProgressResource . getProgress ( eventModel ) ; \nif ( ! progress . isPresent ( ) ) musicHelper . playerError ( PlayerError . ERROR_ILLEGAL + \"command: \" + resourceModel . getResource ( ) + \"missing resource\" , resourceModel . getProvider ( ) ) ; \njumpProgress . accept ( progress . get ( ) ) ; \n} \n} \n"}
{"10687": "public class CommandHandler { \nprivate void handleSelectTrack ( EventModel eventModel , ResourceModel < String > resourceModel ) { \nOptional < TrackInfo > trackInfo = TrackInfoResource . getTrackInfo ( eventModel ) ; \nif ( ! trackInfo . isPresent ( ) ) musicHelper . playerError ( PlayerError . ERROR_ILLEGAL + \"command: \" + resourceModel . getResource ( ) + \"missing resource\" , resourceModel . getProvider ( ) ) ; \nselectTrack . accept ( trackInfo . get ( ) ) ; \n} \n} \n"}
{"10690": "public class StorageClientUtils { \npublic static String getAltField ( String field , String streamId ) { \nif ( streamId == null ) return field ; \nreturn field + \"/\" + streamId ; \n} \n} \n"}
{"10691": "public class StorageClientUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > Map < K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { \nif ( ( modified == null || modified . size ( ) == 0 ) && ( include == null ) && ( exclude == null || exclude . size ( ) == 0 ) ) if ( source instanceof ImmutableMap ) return source ; \nelse return ImmutableMap . copyOf ( source ) ; \nBuilder < K , V > filteredMap = new ImmutableMap . Builder < K , V > ( ) ; \nfor ( Entry < K , V > e : source . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( include == null || include . contains ( k ) ) if ( exclude == null || ! exclude . contains ( k ) ) if ( modified != null && modified . containsKey ( k ) ) { \nV o = modified . get ( k ) ; \nif ( o instanceof Map ) filteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; \nelse if ( includingRemoveProperties ) filteredMap . put ( k , o ) ; \nelse if ( ! ( o instanceof RemoveProperty ) ) filteredMap . put ( k , o ) ; \n} \nelse { \nObject o = e . getValue ( ) ; \nif ( o instanceof Map ) filteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; \nelse filteredMap . put ( k , e . getValue ( ) ) ; \n} \n} \nif ( modified != null ) for ( Entry < K , V > e : modified . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( ! source . containsKey ( k ) ) { \nV v = e . getValue ( ) ; \nif ( ! ( v instanceof RemoveProperty ) && v != null ) filteredMap . put ( k , v ) ; \n} \n} \nreturn filteredMap . build ( ) ; \n} \n} \n"}
{"10693": "public class StorageClientUtils { \npublic static Session adaptToSession ( Object source ) { \nif ( source instanceof SessionAdaptable ) return ( ( SessionAdaptable ) source ) . getSession ( ) ; \nelse { \nObject userManager = safeMethod ( source , \"getUserManager\" , new Object [ 0 ] , new Class [ 0 ] ) ; \nif ( userManager != null ) return ( Session ) safeMethod ( userManager , \"getSession\" , new Object [ 0 ] , new Class [ 0 ] ) ; \nreturn null ; \n} \n} \n} \n"}
{"10694": "public class StorageClientUtils { \nprivate static Object safeMethod ( Object target , String methodName , Object [ ] args , @ SuppressWarnings ( \"rawtypes\" ) Class [ ] argsTypes ) { \nif ( target != null ) try { \nMethod m = target . getClass ( ) . getMethod ( methodName , argsTypes ) ; \nif ( ! m . isAccessible ( ) ) m . setAccessible ( true ) ; \nreturn m . invoke ( target , args ) ; \n} \ncatch ( Throwable e ) { \nLOGGER . info ( \"Failed to invoke method \" + methodName + \" \" + target , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"10695": "public class StorageClientUtils { \npublic static void deleteTree ( ContentManager contentManager , String path ) throws AccessDeniedException , StorageClientException { \nContent content = contentManager . get ( path ) ; \nif ( content != null ) for ( String childPath : content . listChildPaths ( ) ) { \ndeleteTree ( contentManager , childPath ) ; \n} \ncontentManager . delete ( path ) ; \n} \n} \n"}
{"10696": "public class AbstractDao { \n@ Override public void updateOne ( E object , String ... properties ) { \nif ( object . getId ( ) == null ) throw new RuntimeException ( \"Not a Persisted entity\" ) ; \nif ( properties == null || properties . length == 0 ) { \nentityManager . merge ( object ) ; \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"Update \" + clazz . getName ( ) + \" SET \" ) ; \nMap < String , Object > cache = new HashMap < String , Object > ( ) ; \nfor ( String prop : properties ) { \ntry { \nField field = object . getClass ( ) . getDeclaredField ( prop ) ; \nfield . setAccessible ( true ) ; \nObject value = field . get ( object ) ; \nif ( value instanceof Collection ) throw new RuntimeException ( \"Collection property is not suppotred.\" ) ; \ncache . put ( prop , value ) ; \nif ( cache . size ( ) > 1 ) sb . append ( \" ,\" ) ; \nsb . append ( prop ) ; \nsb . append ( \" = :\" ) ; \nsb . append ( prop ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( cache . size ( ) == 0 ) return ; \nsb . append ( \" WHERE id = \" + object . getId ( ) ) ; \nQuery query = entityManager . createQuery ( sb . toString ( ) ) ; \nfor ( Entry < String , Object > entry : cache . entrySet ( ) ) { \nquery . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nquery . executeUpdate ( ) ; \n} \n} \n"}
{"10697": "public class KeepAliveManager { \npublic void setPingInterval ( long newPingInterval ) { \nif ( pingInterval == newPingInterval ) return ; \nif ( newPingInterval > 0 ) enableExecutorService ( ) ; \npingInterval = newPingInterval ; \nif ( pingInterval < 0 ) stopPinging ( ) ; \nelse schedulePingServerTask ( ) ; \n} \n} \n"}
{"10698": "public class KeepAliveManager { \nprivate synchronized void schedulePingServerTask ( ) { \nenableExecutorService ( ) ; \nstopPingServerTask ( ) ; \nif ( pingInterval > 0 ) periodicPingTask = periodicPingExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nPing ping = new Ping ( ) ; \nPacketFilter responseFilter = new PacketIDFilter ( ping . getID ( ) ) ; \nConnection connection = weakRefConnection . get ( ) ; \nfinal PacketCollector response = pingFailedListeners . isEmpty ( ) ? null : connection . createPacketCollector ( responseFilter ) ; \nconnection . sendPacket ( ping ) ; \nif ( response != null ) periodicPingExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nPacket result = response . nextResult ( 1 ) ; \nresponse . cancel ( ) ; \nif ( result == null ) for ( PingFailedListener listener : pingFailedListeners ) { \nlistener . pingFailed ( ) ; \n} \n} \n} \n, SmackConfiguration . getPacketReplyTimeout ( ) , TimeUnit . MILLISECONDS ) ; \n} \n} \n, getPingInterval ( ) , TimeUnit . MILLISECONDS ) ; \n} \n} \n"}
{"10699": "public class ExecS_CliParser { \npublic ExecS_CliParser addAllOptions ( ApplicationOption < ? > [ ] options ) { \nif ( options != null ) for ( ApplicationOption < ? > option : options ) { \nthis . addOption ( option ) ; \n} \nreturn this ; \n} \n} \n"}
{"10700": "public class ExecS_CliParser { \npublic boolean hasOption ( Option option ) { \nif ( option == null ) return false ; \nif ( this . usedOptions . contains ( option . getOpt ( ) ) ) return true ; \nif ( this . usedOptions . contains ( option . getLongOpt ( ) ) ) return true ; \nreturn false ; \n} \n} \n"}
{"10704": "public class XMPPConnection { \nprivate void initConnection ( ) throws XMPPException { \nboolean isFirstInitialization = packetReader == null || packetWriter == null ; \ncompressionHandler = null ; \nserverAckdCompression = false ; \ninitReaderAndWriter ( ) ; \ntry { \nif ( isFirstInitialization ) { \npacketWriter = new PacketWriter ( this ) ; \npacketReader = new PacketReader ( this ) ; \nif ( config . isDebuggerEnabled ( ) ) { \naddPacketListener ( debugger . getReaderListener ( ) , null ) ; \nif ( debugger . getWriterListener ( ) != null ) addPacketSendingListener ( debugger . getWriterListener ( ) , null ) ; \n} \n} \nelse { \npacketWriter . init ( ) ; \npacketReader . init ( ) ; \n} \npacketWriter . startup ( ) ; \npacketReader . startup ( ) ; \nconnected = true ; \nif ( isFirstInitialization ) for ( ConnectionCreationListener listener : getConnectionCreationListeners ( ) ) { \nlistener . connectionCreated ( this ) ; \n} \n} \ncatch ( XMPPException ex ) { \nif ( packetWriter != null ) { \ntry { \npacketWriter . shutdown ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \npacketWriter = null ; \n} \nif ( packetReader != null ) { \ntry { \npacketReader . shutdown ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \npacketReader = null ; \n} \nif ( reader != null ) { \ntry { \nreader . close ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \nreader = null ; \n} \nif ( writer != null ) { \ntry { \nwriter . close ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \nwriter = null ; \n} \nif ( socket != null ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception e ) { \n} \nsocket = null ; \n} \nthis . setWasAuthenticated ( authenticated ) ; \nauthenticated = false ; \nconnected = false ; \nthrow ex ; \n} \n} \n} \n"}
{"10705": "public class XMPPConnection { \nvoid startTLSReceived ( boolean required ) { \nif ( required && config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) { \nnotifyConnectionError ( new IllegalStateException ( \"TLS required by server but not allowed by connection configuration\" ) ) ; \nreturn ; \n} \nif ( config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) return ; \ntry { \nwriter . write ( \"<starttls xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\"/>\" ) ; \nwriter . flush ( ) ; \n} \ncatch ( IOException e ) { \nnotifyConnectionError ( e ) ; \n} \n} \n} \n"}
{"10706": "public class XMPPConnection { \nprivate XMPPInputOutputStream maybeGetCompressionHandler ( ) { \nif ( compressionMethods != null ) for ( XMPPInputOutputStream handler : compressionHandlers ) { \nif ( ! handler . isSupported ( ) ) continue ; \nString method = handler . getCompressionMethod ( ) ; \nif ( compressionMethods . contains ( method ) ) return handler ; \n} \nreturn null ; \n} \n} \n"}
{"10716": "public class NakamuraMain { \nprivate static void log ( PrintStream out , String prefix , String message , Throwable t ) { \nfinal StringBuilder linePrefixBuilder = new StringBuilder ( ) ; \nsynchronized ( fmt ) { \nlinePrefixBuilder . append ( fmt . format ( new Date ( ) ) ) ; \n} \nlinePrefixBuilder . append ( prefix ) ; \nlinePrefixBuilder . append ( \" [\" ) ; \nlinePrefixBuilder . append ( Thread . currentThread ( ) . getName ( ) ) ; \nlinePrefixBuilder . append ( \"] \" ) ; \nfinal String linePrefix = linePrefixBuilder . toString ( ) ; \nout . print ( linePrefix ) ; \nout . println ( message ) ; \nif ( t != null ) t . printStackTrace ( new PrintStream ( out ) { \n@ Override public void println ( String x ) { \nsynchronized ( this ) { \nprint ( linePrefix ) ; \nsuper . println ( x ) ; \nflush ( ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"10718": "public class StartEvent { \npublic static Optional < StartEvent > createStartEvent ( Identification source , boolean isUsingJava ) { \ntry { \nStartEvent startEvent ; \nif ( isUsingJava ) startEvent = new StartEvent ( source ) ; \nelse startEvent = new StartEvent ( source , IS_USING_NON_JAVA_OUTPUT ) ; \nreturn Optional . of ( startEvent ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10719": "public class ObservableWriter { \nprivate void notifyListeners ( String str ) { \nWriterListener [ ] writerListeners = null ; \nsynchronized ( listeners ) { \nwriterListeners = new WriterListener [ listeners . size ( ) ] ; \nlisteners . toArray ( writerListeners ) ; \n} \nfor ( int i = 0 ; \ni < writerListeners . length ; \ni ++ ) writerListeners [ i ] . write ( str ) ; \n} \n} \n"}
{"10724": "public class CachingManagerImpl { \nprotected Map < String , Object > getCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { \nMap < String , Object > m = null ; \nString cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \nCacheHolder cacheHolder = getFromCacheInternal ( cacheKey ) ; \nif ( cacheHolder != null ) { \nm = cacheHolder . get ( ) ; \nif ( m != null ) LOGGER . debug ( \"Cache Hit {} {} {} \" , new Object [ ] { \ncacheKey , cacheHolder , m } \n) ; \n} \nif ( m == null ) { \nm = client . get ( keySpace , columnFamily , key ) ; \nif ( m != null ) LOGGER . debug ( \"Cache Miss, Found Map {} {}\" , cacheKey , m ) ; \nputToCacheInternal ( cacheKey , new CacheHolder ( m ) , true ) ; \n} \nreturn m ; \n} \n} \n"}
{"10725": "public class CachingManagerImpl { \nprivate String getCacheKey ( String keySpace , String columnFamily , String key ) throws StorageClientException { \nif ( client instanceof RowHasher ) return ( ( RowHasher ) client ) . rowHash ( keySpace , columnFamily , key ) ; \nreturn keySpace + \":\" + columnFamily + \":\" + key ; \n} \n} \n"}
{"10726": "public class CachingManagerImpl { \nprotected void removeCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { \nif ( sharedCache != null ) { \nfinal String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \nputToCacheInternal ( cacheKey , new CacheHolder ( null , managerId ) , false ) ; \nLOGGER . debug ( \"Marked as deleted in Cache {} \" , cacheKey ) ; \nif ( client instanceof Disposer ) ( ( Disposer ) client ) . registerDisposable ( new Disposable ( ) { \n@ Override public void setDisposer ( Disposer disposer ) { \n} \n@ Override public void close ( ) { \nCacheHolder ch = sharedCache . get ( cacheKey ) ; \nif ( ch != null && ch . wasLockedTo ( managerId ) ) { \nsharedCache . remove ( cacheKey ) ; \nLOGGER . debug ( \"Removed deleted marker from Cache {} \" , cacheKey ) ; \n} \n} \n} \n) ; \n} \nclient . remove ( keySpace , columnFamily , key ) ; \n} \n} \n"}
{"10727": "public class CachingManagerImpl { \nprotected void putCached ( String keySpace , String columnFamily , String key , Map < String , Object > encodedProperties , boolean probablyNew ) throws StorageClientException { \nString cacheKey = null ; \nif ( sharedCache != null ) cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \nif ( sharedCache != null && ! probablyNew ) { \nCacheHolder ch = getFromCacheInternal ( cacheKey ) ; \nif ( ch != null && ch . isLocked ( this . managerId ) ) { \nLOGGER . debug ( \"Is Locked {} \" , ch ) ; \nreturn ; \n} \n} \nLOGGER . debug ( \"Saving {} {} {} {} \" , new Object [ ] { \nkeySpace , columnFamily , key , encodedProperties } \n) ; \nclient . insert ( keySpace , columnFamily , key , encodedProperties , probablyNew ) ; \nif ( sharedCache != null ) sharedCache . remove ( cacheKey ) ; \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) return ; \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) ok = true ; \n} \nif ( ok == false ) return ; \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) name = \"\" ; \nelse name += \".\" ; \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( int i = 0 ; \ni < dirs . length ; \ni ++ ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \n} \n} \n"}
{"10730": "public class CF_Locator { \nprivate void includeJar ( File file ) { \nif ( file . isDirectory ( ) ) return ; \nURL jarURL = null ; \nJarFile jar = null ; \ntry { \njarURL = new URL ( \"jar:\" + new URL ( \"file:/\" + file . getCanonicalPath ( ) ) . toExternalForm ( ) + \"!/\" ) ; \nJarURLConnection conn = ( JarURLConnection ) jarURL . openConnection ( ) ; \njar = conn . getJarFile ( ) ; \n} \ncatch ( MalformedURLException ignore ) { \nreturn ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \nif ( jar == null ) return ; \ntry { \nthis . locationMap . put ( jarURL . toURI ( ) , \"\" ) ; \n} \ncatch ( URISyntaxException ignore ) { \n} \nfor ( Enumeration < JarEntry > e = jar . entries ( ) ; \ne . hasMoreElements ( ) ; \n) { \nJarEntry entry = e . nextElement ( ) ; \nif ( this . pkgFilter != null && entry . getName ( ) . startsWith ( this . pkgFilter ) ) continue ; \nif ( entry . isDirectory ( ) ) { \nif ( entry . getName ( ) . toUpperCase ( Locale . ENGLISH ) . equals ( \"META-INF/\" ) ) continue ; \ntry { \nthis . locationMap . put ( new URI ( jarURL . toExternalForm ( ) + entry . getName ( ) ) , CF_Utils . getPkgName ( entry ) ) ; \n} \ncatch ( URISyntaxException ignore ) { \ncontinue ; \n} \n} \n} \n} \n} \n"}
{"10731": "public class SmackConfiguration { \npublic static void addSaslMech ( String mech ) { \ninitialize ( ) ; \nif ( ! defaultMechs . contains ( mech ) ) defaultMechs . add ( mech ) ; \n} \n} \n"}
{"10733": "public class ConsoleDebugger { \nprivate void createDebug ( ) { \nObservableReader debugReader = new ObservableReader ( reader ) ; \nreaderListener = new ReaderListener ( ) { \npublic void read ( String str ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" RCV  (\" + connection . hashCode ( ) + \"): \" + str ) ; \n} \n} \n; \ndebugReader . addReaderListener ( readerListener ) ; \nObservableWriter debugWriter = new ObservableWriter ( writer ) ; \nwriterListener = new WriterListener ( ) { \npublic void write ( String str ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" SENT (\" + connection . hashCode ( ) + \"): \" + str ) ; \n} \n} \n; \ndebugWriter . addWriterListener ( writerListener ) ; \nreader = debugReader ; \nwriter = debugWriter ; \nlistener = new PacketListener ( ) { \npublic void processPacket ( Packet packet ) { \nif ( printInterpreted ) System . out . println ( dateFormatter . format ( new Date ( ) ) + \" RCV PKT (\" + connection . hashCode ( ) + \"): \" + packet . toXML ( ) ) ; \n} \n} \n; \nconnListener = new ConnectionListener ( ) { \npublic void connectionClosed ( ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection closed (\" + connection . hashCode ( ) + \")\" ) ; \n} \npublic void connectionClosedOnError ( Exception e ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection closed due to an exception (\" + connection . hashCode ( ) + \")\" ) ; \ne . printStackTrace ( ) ; \n} \npublic void reconnectionFailed ( Exception e ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Reconnection failed due to an exception (\" + connection . hashCode ( ) + \")\" ) ; \ne . printStackTrace ( ) ; \n} \npublic void reconnectionSuccessful ( ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection reconnected (\" + connection . hashCode ( ) + \")\" ) ; \n} \npublic void reconnectingIn ( int seconds ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection (\" + connection . hashCode ( ) + \") will reconnect in \" + seconds ) ; \n} \n} \n; \n} \n} \n"}
{"10734": "public class ProxyClientServiceImpl { \nprotected void activate ( Map < String , Object > properties ) throws Exception { \nconfigProperties = properties ; \nString [ ] safePostProcessorNames = ( String [ ] ) configProperties . get ( SAFE_POSTPROCESSORS ) ; \nif ( safePostProcessorNames == null ) { \nsafeOpenProcessors . add ( \"rss\" ) ; \nsafeOpenProcessors . add ( \"trustedLoginTokenProxyPostProcessor\" ) ; \n} \nelse for ( String pp : safePostProcessorNames ) { \nsafeOpenProcessors . add ( pp ) ; \n} \nString proxyHost = System . getProperty ( \"http.proxyHost\" , \"\" ) ; \nif ( ! proxyHost . equals ( \"\" ) ) useJreProxy = true ; \n} \n} \n"}
{"10737": "public class EventPropertiesAssistant { \npublic void registerEventID ( String description , String key , String value ) { \nBufferedWriter bufferedWriter ; \nFileOutputStream out = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nbufferedWriter = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( key ) != null ) return ; \ntry { \nbufferedWriter . write ( \"\\n\\n\" + key + \"_DESCRIPTION = \" + description + \"\\n\" + key + \" = \" + value ) ; \nbufferedWriter . flush ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \n} \ncatch ( FileNotFoundException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) out . close ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10738": "public class EventPropertiesAssistant { \nprivate void doWithLock ( FileChannel channel , Consumer < FileLock > consumer ) { \nFileLock lock = null ; \ntry { \nwhile ( lock == null ) try { \nlock = channel . tryLock ( ) ; \n} \ncatch ( OverlappingFileLockException e ) { \nThread . sleep ( 500 ) ; \n} \nconsumer . accept ( lock ) ; \n} \ncatch ( IOException | InterruptedException e ) { \nerror ( \"Unable to write\" , e ) ; \n} \nfinally { \ntry { \nif ( lock != null ) lock . release ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10739": "public class EventPropertiesAssistant { \npublic void unregisterEventID ( String eventKey ) { \nproperties . remove ( eventKey + \"_DESCRIPTION\" ) ; \nproperties . remove ( eventKey ) ; \nFileOutputStream out = null ; \nBufferedReader reader = null ; \nBufferedWriter writer = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nfinal File tempFile = new File ( eventPropertiesPath + \"temp.properties\" ) ; \nfinal BufferedReader readerFinal = new BufferedReader ( new FileReader ( eventPropertiesPath ) ) ; \nfinal BufferedWriter writerFinal = new BufferedWriter ( new FileWriter ( tempFile ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( eventKey ) != null ) return ; \ntry { \nString currentLine = readerFinal . readLine ( ) ; \nwhile ( currentLine != null ) { \nString trimmedLine = currentLine . trim ( ) ; \nif ( trimmedLine . equals ( eventKey + \"_DESCRIPTION\" ) || trimmedLine . equals ( eventKey ) ) continue ; \nwriterFinal . write ( currentLine + System . getProperty ( \"line.separator\" ) ) ; \ncurrentLine = readerFinal . readLine ( ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \nreader = readerFinal ; \nwriter = writerFinal ; \ntempFile . renameTo ( new File ( eventPropertiesPath ) ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) out . close ( ) ; \nif ( writer != null ) writer . close ( ) ; \nif ( reader != null ) reader . close ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10740": "public class OutputExtensionArgument { \n@ Override public boolean canRun ( EventModel event ) { \nif ( event != null ) return event . getListResourceContainer ( ) . providesResource ( getResourceIdWishList ( ) ) ; \nreturn false ; \n} \n} \n"}
{"10745": "public class PlayerController { \npublic void command ( String command , Playlist playlist , Progress progress , TrackInfo trackInfo , Volume volume ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) || ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nOptional < PlayerCommand > playerCommand = PlayerCommand . createPlayerCommand ( ownIdentification . get ( ) , playerIdentification . get ( ) , command , player . getCapabilities ( ) , getContext ( ) ) ; \nif ( playlist != null ) playerCommand . get ( ) . addResource ( new PlaylistResource ( ownIdentification . get ( ) , playlist ) ) ; \nif ( progress != null ) playerCommand . get ( ) . addResource ( new ProgressResource ( ownIdentification . get ( ) , progress ) ) ; \nif ( trackInfo != null ) playerCommand . get ( ) . addResource ( new TrackInfoResource ( ownIdentification . get ( ) , trackInfo ) ) ; \nif ( volume != null ) playerCommand . get ( ) . addResource ( new VolumeResource ( ownIdentification . get ( ) , volume ) ) ; \nfire ( playerCommand . get ( ) , 5 ) ; \n} \n} \n"}
{"10748": "public class UrlBuilder { \npublic UrlBuilder append ( boolean encode , String ... postFix ) { \nfor ( String part : postFix ) { \nif ( StringUtils . isNotBlank ( part ) ) { \nif ( url . charAt ( url . length ( ) - 1 ) != '/' && ! part . startsWith ( \"/\" ) ) url . append ( '/' ) ; \nif ( encode ) try { \nurl . append ( URLEncoder . encode ( part , \"UTF-8\" ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new IllegalStateException ( e ) ; \n} \nelse url . append ( part ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"10749": "public class UrlBuilder { \npublic UrlBuilder queryParam ( String name , Boolean value ) { \nif ( value != null ) return queryParam ( name , value . toString ( ) ) ; \nelse return null ; \n} \n} \n"}
{"10750": "public class UrlBuilder { \npublic UrlBuilder queryParam ( String name , Number value ) { \nif ( value != null ) return queryParam ( name , value . toString ( ) ) ; \nelse return null ; \n} \n} \n"}
{"10752": "public class UrlBuilder { \npublic UrlBuilder queryParam ( String name , String value , boolean encode ) { \nif ( StringUtils . isNotEmpty ( value ) ) { \nif ( encode ) try { \nvalue = URLEncoder . encode ( value , \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new IllegalStateException ( e ) ; \n} \nparams . add ( new EntryImpl ( name , value ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"10753": "public class PlaylistResource { \npublic static Optional < Playlist > getPlaylist ( EventModel eventModel ) { \nif ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . findAny ( ) . flatMap ( Playlist :: importResource ) ; \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10754": "public class LaunchNakamura { \nprivate void launchButtonActionPerformed ( java . awt . event . ActionEvent evt ) { \nif ( runStatus == APP_NOT_RUNNING ) { \nSystem . setSecurityManager ( null ) ; \ntry { \nNakamuraMain . main ( savedArgs ) ; \nstatusLabel . setText ( \"Nakamura is starting...\" ) ; \nJOptionPane . showMessageDialog ( this , \"Nakamura has been started.\\nPlease allow 30-60 seconds for it to be ready.\" , \"Information\" , JOptionPane . INFORMATION_MESSAGE ) ; \nrunStatus = APP_RUNNING ; \nisStartupFinished ( ) ; \n} \ncatch ( IOException e ) { \nstatusLabel . setText ( \"Nakamura is startup failed \" + e . getMessage ( ) ) ; \n} \n} \nelse JOptionPane . showMessageDialog ( this , \"Nakamura is already running.\" , \"Warning\" , JOptionPane . WARNING_MESSAGE ) ; \n} \n} \n"}
{"10758": "public class LaunchNakamura { \nprotected ImageIcon createImageIcon ( String path , String description ) { \njava . net . URL imgURL = getClass ( ) . getResource ( path ) ; \nif ( imgURL != null ) return new ImageIcon ( imgURL , description ) ; \nelse { \nSystem . err . println ( \"Couldn't find file: \" + path ) ; \nreturn null ; \n} \n} \n} \n"}
{"10762": "public class JSONResult { \npublic JSONResult get ( int index ) { \nif ( value instanceof JSONArray ) { \nJSONArray array = ( JSONArray ) value ; \nObject result = array . get ( index ) ; \nreturn new JSONResult ( result ) ; \n} \nelse if ( value instanceof JSONObject ) return get ( String . valueOf ( index ) ) ; \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10763": "public class JSONResult { \npublic JSONResult get ( String key ) { \nif ( value instanceof JSONObject ) { \nJSONObject obj = ( JSONObject ) value ; \nObject result = obj . get ( key ) ; \nreturn new JSONResult ( result ) ; \n} \nelse if ( value instanceof JSONArray ) try { \nint index = Integer . parseInt ( key ) ; \nreturn get ( index ) ; \n} \ncatch ( NumberFormatException e ) { \nthrow createException ( \"Excpected JSONObject \" + key + \":\" ) ; \n} \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10764": "public class JSONResult { \npublic Integer getInt ( Integer defaultValue ) { \nif ( value instanceof Number ) return ( ( Number ) value ) . intValue ( ) ; \nif ( value instanceof String ) { \nString s = ( String ) value ; \nreturn Integer . parseInt ( s ) ; \n} \nif ( value == null ) return defaultValue ; \nthrow createException ( \"Expected integer:\" ) ; \n} \n} \n"}
{"10765": "public class JSONResult { \npublic Double getDouble ( Double defaultValue ) { \nif ( value instanceof Number ) return ( ( Number ) value ) . doubleValue ( ) ; \nif ( value instanceof String ) { \nString s = ( String ) value ; \nreturn Double . parseDouble ( s ) ; \n} \nif ( value == null ) return defaultValue ; \nthrow createException ( \"Expected number:\" ) ; \n} \n} \n"}
{"10766": "public class JSONResult { \npublic String getString ( String defaultValue ) { \nif ( value instanceof String || value instanceof Number ) return value . toString ( ) ; \nif ( value == null ) return null ; \nif ( value instanceof JSONArray ) return ( ( JSONArray ) value ) . toJSONString ( ) ; \nif ( value instanceof JSONObject ) return ( ( JSONObject ) value ) . toJSONString ( ) ; \nif ( value == null ) return defaultValue ; \nthrow createException ( \"Expected string:\" ) ; \n} \n} \n"}
{"10771": "public class SessionManager { \npublic void executeBatchAsync ( FutureCallback < ResultSet > callback , Statement ... statements ) throws ExceedMaxAsyncJobsException { \nif ( ! asyncSemaphore . tryAcquire ( ) ) if ( callback == null ) throw new ExceedMaxAsyncJobsException ( maxSyncJobs ) ; \nelse callback . onFailure ( new ExceedMaxAsyncJobsException ( maxSyncJobs ) ) ; \nelse try { \nResultSetFuture rsf = CqlUtils . executeBatchAsync ( getSession ( ) , statements ) ; \nif ( callback != null ) Futures . addCallback ( rsf , wrapCallbackResultSet ( callback ) , asyncExecutor ) ; \n} \ncatch ( Exception e ) { \nasyncSemaphore . release ( ) ; \nLOGGER . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"10772": "public class CF { \npublic Set < Class < ? > > getSubclasses ( Class < ? > clazz ) { \nSet < Class < ? > > ret = new HashSet < Class < ? > > ( ) ; \nSet < Class < ? > > w = null ; \nif ( clazz != null ) { \nthis . clear ( ) ; \nMap < URI , String > locations = this . locator . getCfLocations ( ) ; \nfor ( Entry < URI , String > entry : locations . entrySet ( ) ) { \ntry { \nw = search ( clazz , entry . getKey ( ) , locations . get ( entry . getKey ( ) ) ) ; \nif ( w != null && ( w . size ( ) > 0 ) ) ret . addAll ( w ) ; \n} \ncatch ( MalformedURLException ex ) { \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10773": "public class CF { \npublic Set < Class < ? > > getSubclasses ( String fqcn ) { \nif ( fqcn == null ) return new HashSet < Class < ? > > ( ) ; \nelse if ( StringUtils . startsWith ( fqcn , \".\" ) || StringUtils . endsWith ( fqcn , \".\" ) ) return new HashSet < Class < ? > > ( ) ; \nClass < ? > clazz = null ; \ntry { \nclazz = Class . forName ( fqcn ) ; \n} \ncatch ( ClassNotFoundException ex ) { \nthis . clear ( ) ; \nthis . errors . add ( ex ) ; \nreturn new HashSet < Class < ? > > ( ) ; \n} \nreturn getSubclasses ( clazz ) ; \n} \n} \n"}
{"10774": "public class CF { \nprivate final Set < Class < ? > > search ( Class < ? > clazz , URI location , String packageName ) throws MalformedURLException { \nif ( clazz == null || location == null ) return new HashSet < Class < ? > > ( ) ; \nFile directory = new File ( location . toURL ( ) . getFile ( ) ) ; \nif ( directory . exists ( ) ) return this . searchDirectory ( clazz , directory , location , packageName ) . keySet ( ) ; \nelse return this . searchJar ( clazz , location ) . keySet ( ) ; \n} \n} \n"}
{"10775": "public class CF { \nprotected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \nString [ ] files = directory . list ( ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) if ( files [ i ] . endsWith ( \".class\" ) ) { \nString classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; \ntry { \nClass < ? > c = Class . forName ( packageName + \".\" + classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + \".\" + classname ) ) ret . put ( c , location ) ; \n} \ncatch ( Exception ex ) { \nerrors . add ( ex ) ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"10776": "public class CF { \nprotected final Map < Class < ? > , URI > searchJar ( Class < ? > clazz , URI location ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \ntry { \nJarURLConnection conn = ( JarURLConnection ) location . toURL ( ) . openConnection ( ) ; \nJarFile jarFile = conn . getJarFile ( ) ; \nfor ( Enumeration < JarEntry > e = jarFile . entries ( ) ; \ne . hasMoreElements ( ) ; \n) { \nJarEntry entry = e . nextElement ( ) ; \nString entryname = entry . getName ( ) ; \nif ( this . processed . contains ( entryname ) ) continue ; \nthis . processed . add ( entryname ) ; \nif ( ! entry . isDirectory ( ) && entryname . endsWith ( \".class\" ) ) { \nString classname = entryname . substring ( 0 , entryname . length ( ) - 6 ) ; \nif ( classname . startsWith ( \"/\" ) ) classname = classname . substring ( 1 ) ; \nclassname = classname . replace ( '/' , '.' ) ; \nif ( ! StringUtils . startsWithAny ( classname , this . excludedNames ) ) try { \nClass < ? > c = Class . forName ( classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( classname ) ) ret . put ( c , location ) ; \n} \ncatch ( Exception exception ) { \nerrors . add ( exception ) ; \n} \ncatch ( Error error ) { \nerrors . add ( error ) ; \n} \n} \n} \n} \ncatch ( IOException ignore ) { \nerrors . add ( ignore ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10779": "public class PacketCollector { \nprotected void processPacket ( Packet packet ) { \nif ( packet == null ) return ; \nif ( packetFilter == null || packetFilter . accept ( packet ) ) while ( ! resultQueue . offer ( packet ) ) resultQueue . poll ( ) ; \n} \n} \n"}
{"10780": "public class VolumeResource { \npublic static Optional < Volume > getVolume ( EventModel eventModel ) { \nif ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Integer ) . map ( ob -> ( Integer ) ob ) . findAny ( ) . flatMap ( Volume :: createVolume ) ; \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10782": "public class XMPPUtils { \npublic static IQ createErrorResponse ( final IQ request , final String message , Condition condition , Type type ) { \nfinal IQ result = request . createCopy ( ) ; \nresult . setID ( request . getID ( ) ) ; \nresult . setFrom ( request . getTo ( ) ) ; \nresult . setTo ( request . getFrom ( ) ) ; \nPacketError e = new PacketError ( condition , type ) ; \nif ( message != null ) e . setText ( message ) ; \nresult . setError ( e ) ; \nreturn result ; \n} \n} \n"}
{"10783": "public class SelectorResource { \npublic static Optional < Boolean > isTarget ( EventModel eventModel , Identifiable identifiable ) { \nif ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( SelectorResource . RESOURCE_ID ) ) ) return Optional . of ( eventModel . getListResourceContainer ( ) . provideResource ( SelectorResource . RESOURCE_ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( resource -> resource instanceof Identification ) . map ( object -> ( Identification ) object ) . anyMatch ( identifiable :: isOwner ) ) ; \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10784": "public class User { \npublic void setLoginEnabled ( long from , long to , boolean day , TimeZone timeZone ) { \nString enabledSetting = EnabledPeriod . getEnableValue ( from , to , day , timeZone ) ; \nif ( enabledSetting == null ) removeProperty ( LOGIN_ENABLED_PERIOD_FIELD ) ; \nelse setProperty ( LOGIN_ENABLED_PERIOD_FIELD , enabledSetting ) ; \n} \n} \n"}
{"10786": "public class RosterEntry { \npublic void setName ( String name ) { \nif ( name != null && name . equals ( this . name ) ) return ; \nthis . name = name ; \nRoster packet = new Roster ( ) ; \npacket . setType ( IQ . Type . set ) ; \npacket . addItem ( new JID ( user ) , name , ask , subscription , getGroupNames ( ) ) ; \nconnection . sendPacket ( packet ) ; \n} \n} \n"}
{"10788": "public class RosterEntry { \npublic Collection < RosterGroup > getGroups ( ) { \nList < RosterGroup > results = new ArrayList < RosterGroup > ( ) ; \nfor ( RosterGroup group : roster . getGroups ( ) ) { \nif ( group . contains ( this ) ) results . add ( group ) ; \n} \nreturn Collections . unmodifiableCollection ( results ) ; \n} \n} \n"}
{"10790": "public class RSMUtils { \npublic static RSM parseRSM ( Element queryElement ) { \nRSM rsm = new RSM ( ) ; \nElement setElement = queryElement . element ( \"set\" ) ; \nif ( setElement == null ) return rsm ; \nElement after = setElement . element ( \"after\" ) ; \nif ( after != null ) rsm . setAfter ( after . getText ( ) ) ; \nElement before = setElement . element ( \"before\" ) ; \nif ( before != null ) { \nString beforeText = before . getText ( ) ; \nrsm . setBefore ( beforeText == null ? \"\" : beforeText ) ; \n} \nElement index = setElement . element ( \"index\" ) ; \nif ( index != null ) rsm . setIndex ( Integer . parseInt ( index . getText ( ) ) ) ; \nElement max = setElement . element ( \"max\" ) ; \nif ( max != null ) rsm . setMax ( Integer . parseInt ( max . getText ( ) ) ) ; \nreturn rsm ; \n} \n} \n"}
{"10791": "public class RSMUtils { \npublic static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { \nString after = rsm . getAfter ( ) ; \nString before = rsm . getBefore ( ) ; \nint initialIndex = rsm . getIndex ( ) ; \nint lastIndex = objects . size ( ) ; \nif ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nint i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null && after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \nif ( before != null && before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \ni ++ ; \n} \nif ( after != null && ! afterItemFound ) throw new IllegalArgumentException ( ) ; \nif ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) throw new IllegalArgumentException ( ) ; \n} \nif ( rsm . getMax ( ) != null ) if ( before != null ) initialIndex = lastIndex - rsm . getMax ( ) ; \nelse lastIndex = initialIndex + rsm . getMax ( ) ; \nboolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; \nList < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; \nrsm . setCount ( objects . size ( ) ) ; \nrsm . setIndex ( initialIndex ) ; \nif ( ! filteredList . isEmpty ( ) ) { \nrsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; \nrsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; \n} \nreturn filteredList ; \n} \n} \n"}
{"10792": "public class LeavingEvent { \npublic static Optional < LeavingEvent > createLeavingEvent ( Identification source , boolean strict , List < String > descriptors ) { \ntry { \nif ( strict ) descriptors . add ( STRICT_DESCRIPTOR ) ; \nelse descriptors . add ( GENERAL_DESCRIPTOR ) ; \ndescriptors . add ( ID ) ; \ndescriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; \nLeavingEvent stopRequest = new LeavingEvent ( source , descriptors ) ; \nreturn Optional . of ( stopRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10793": "public class UserRoster { \npublic void reload ( ) { \nif ( ! connection . isAuthenticated ( ) ) throw new IllegalStateException ( \"Not logged in to server.\" ) ; \nif ( connection . isAnonymous ( ) ) throw new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \nRoster packet = new Roster ( ) ; \nif ( rosterStore != null && connection . isRosterVersioningSupported ( ) ) { \npacket . getElement ( ) . element ( \"query\" ) . addAttribute ( \"ver\" , rosterStore . getRosterVersion ( ) ) ; \nPacketFilter filter = new PacketIDFilter ( packet . getID ( ) ) ; \nconnection . addPacketListener ( new RosterResultListener ( ) , filter ) ; \n} \nconnection . sendPacket ( packet ) ; \n} \n} \n"}
{"10794": "public class UserRoster { \npublic void createEntry ( String user , String name , String [ ] groups ) throws XMPPException { \nif ( ! connection . isAuthenticated ( ) ) throw new IllegalStateException ( \"Not logged in to server.\" ) ; \nif ( connection . isAnonymous ( ) ) throw new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \nRoster rosterPacket = new Roster ( ) ; \nrosterPacket . setType ( IQ . Type . set ) ; \nrosterPacket . addItem ( new JID ( user ) , name , null , null , Arrays . asList ( groups ) ) ; \nPacketCollector collector = connection . createPacketCollector ( new PacketIDFilter ( rosterPacket . getID ( ) ) ) ; \nconnection . sendPacket ( rosterPacket ) ; \nIQ response = ( IQ ) collector . nextResult ( SmackConfiguration . getPacketReplyTimeout ( ) ) ; \ncollector . cancel ( ) ; \nif ( response == null ) throw new XMPPException ( \"No response from the server.\" ) ; \nelse if ( response . getType ( ) == IQ . Type . error ) throw new XMPPException ( response . getError ( ) ) ; \nPresence presencePacket = new Presence ( Presence . Type . subscribe ) ; \npresencePacket . setTo ( user ) ; \nconnection . sendPacket ( presencePacket ) ; \n} \n} \n"}
{"10796": "public class UserRoster { \npublic Presence getPresenceResource ( String userWithResource ) { \nString key = getPresenceMapKey ( userWithResource ) ; \nString resource = StringUtils . parseResource ( userWithResource ) ; \nMap < String , Presence > userPresences = presenceMap . get ( key ) ; \nif ( userPresences == null ) { \nPresence presence = new Presence ( Presence . Type . unavailable ) ; \npresence . setFrom ( userWithResource ) ; \nreturn presence ; \n} \nelse { \nPresence presence = userPresences . get ( resource ) ; \nif ( presence == null ) { \npresence = new Presence ( Presence . Type . unavailable ) ; \npresence . setFrom ( userWithResource ) ; \nreturn presence ; \n} \nelse return presence ; \n} \n} \n} \n"}
{"10797": "public class UserRoster { \nprivate void setOfflinePresences ( ) { \nPresence packetUnavailable ; \nfor ( String user : presenceMap . keySet ( ) ) { \nMap < String , Presence > resources = presenceMap . get ( user ) ; \nif ( resources != null ) for ( String resource : resources . keySet ( ) ) { \npacketUnavailable = new Presence ( Presence . Type . unavailable ) ; \npacketUnavailable . setFrom ( user + \"/\" + resource ) ; \npresencePacketListener . processPacket ( packetUnavailable ) ; \n} \n} \n} \n} \n"}
{"10798": "public class UserRoster { \nprivate void fireRosterChangedEvent ( Collection < String > addedEntries , Collection < String > updatedEntries , Collection < String > deletedEntries ) { \nfor ( RosterListener listener : rosterListeners ) { \nif ( ! addedEntries . isEmpty ( ) ) listener . entriesAdded ( addedEntries ) ; \nif ( ! updatedEntries . isEmpty ( ) ) listener . entriesUpdated ( updatedEntries ) ; \nif ( ! deletedEntries . isEmpty ( ) ) listener . entriesDeleted ( deletedEntries ) ; \n} \n} \n} \n"}
{"10802": "public class LastEncountered { \n@ SuppressWarnings ( \"unused\" ) public static Optional < Long > getTimePassed ( EventModel eventModel ) { \nif ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Long ) . map ( ob -> ( Long ) ob ) . findAny ( ) ; \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10805": "public class PropertiesAssistant { \nprivate void reloadProperties ( ) { \nProperties temp = new Properties ( ) ; \nBufferedReader bufferedReader = null ; \ntry { \nFile properties = new File ( propertiesPath ) ; \nbufferedReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( properties ) , \"UTF8\" ) ) ; \ntemp . load ( bufferedReader ) ; \nthis . properties = temp ; \nlisteners . removeIf ( weakReference -> weakReference . get ( ) == null ) ; \nlisteners . forEach ( weakReference -> { \nConsumer < PropertiesAssistant > consumer = weakReference . get ( ) ; \nif ( consumer != null ) consumer . accept ( this ) ; \n} \n) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to load the Properties-File: \" + propertiesPath , e ) ; \n} \nfinally { \nif ( bufferedReader != null ) try { \nbufferedReader . close ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close input stream\" , e ) ; \n} \n} \n} \n} \n"}
{"10806": "public class PacketParserUtils { \npublic static StreamError parseStreamError ( Element el ) throws IOException , XmlPullParserException { \nString code = null ; \nElement condEl = ( Element ) el . elements ( ) . iterator ( ) . next ( ) ; \nif ( condEl . getNamespace ( ) . getURI ( ) . equals ( StreamError . NAMESPACE ) ) code = condEl . getName ( ) ; \nString text = condEl . elementText ( \"text\" ) ; \nreturn new StreamError ( code , text ) ; \n} \n} \n"}
{"10809": "public class PacketParserUtils { \npublic static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { \nDefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; \nboolean done = false ; \nwhile ( ! done ) { \nint eventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . START_TAG ) { \nString name = parser . getName ( ) ; \nif ( parser . isEmptyElementTag ( ) ) extension . setValue ( name , \"\" ) ; \nelse { \neventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . TEXT ) { \nString value = parser . getText ( ) ; \nextension . setValue ( name , value ) ; \n} \n} \n} \nelse if ( eventType == XmlPullParser . END_TAG ) if ( parser . getName ( ) . equals ( elementName ) ) done = true ; \n} \nreturn extension ; \n} \n} \n"}
{"10810": "public class PacketParserUtils { \nprivate static Object decode ( Class < ? > type , String value ) throws Exception { \nif ( type . getName ( ) . equals ( \"java.lang.String\" ) ) return value ; \nif ( type . getName ( ) . equals ( \"boolean\" ) ) return Boolean . valueOf ( value ) ; \nif ( type . getName ( ) . equals ( \"int\" ) ) return Integer . valueOf ( value ) ; \nif ( type . getName ( ) . equals ( \"long\" ) ) return Long . valueOf ( value ) ; \nif ( type . getName ( ) . equals ( \"float\" ) ) return Float . valueOf ( value ) ; \nif ( type . getName ( ) . equals ( \"double\" ) ) return Double . valueOf ( value ) ; \nif ( type . getName ( ) . equals ( \"java.lang.Class\" ) ) return Class . forName ( value ) ; \nreturn null ; \n} \n} \n"}
{"10811": "public class StartMusicRequest { \npublic static boolean verify ( EventModel eventModel , Capabilities capabilities , Identifiable player , List < Identifiable > activators ) { \nif ( ! eventModel . containsDescriptor ( StartMusicRequest . ID ) ) return false ; \nif ( ! capabilities . handlesPlayRequestFromOutside ( ) ) if ( activators . stream ( ) . noneMatch ( identifiable -> identifiable . isOwner ( eventModel . getSource ( ) ) ) ) return false ; \nif ( ! PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> playlist . verify ( capabilities ) ) . orElse ( true ) ) return false ; \nreturn SelectorResource . isTarget ( eventModel , player ) . orElse ( false ) ; \n} \n} \n"}
{"10812": "public class PlaybackStateResource { \npublic static Optional < PlaybackState > getPlaybackStateFromResource ( ResourceModel x ) { \nif ( ! x . getResourceID ( ) . equals ( ID ) ) return Optional . empty ( ) ; \nObject resource = x . getResource ( ) ; \nif ( resource instanceof String ) { \nString state = ( String ) resource ; \ntry { \nreturn Optional . of ( PlaybackState . valueOf ( state ) ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10813": "public class ExternalComponentManager { \npublic String getSecretKey ( String subdomain ) { \nString secretKey = secretKeys . get ( subdomain ) ; \nif ( secretKey == null ) secretKey = defaultSecretKey ; \nreturn secretKey ; \n} \n} \n"}
{"10815": "public class AbstractReferenceMap { \npublic V put ( K key , V value ) { \nif ( key == null ) throw new NullPointerException ( \"null keys not allowed\" ) ; \nif ( value == null ) throw new NullPointerException ( \"null values not allowed\" ) ; \npurgeBeforeWrite ( ) ; \nreturn super . put ( key , value ) ; \n} \n} \n"}
{"10816": "public class AbstractReferenceMap { \npublic Set < K > keySet ( ) { \nif ( keySet == null ) keySet = new ReferenceKeySet < K , V > ( this ) ; \nreturn keySet ; \n} \n} \n"}
{"10817": "public class AbstractReferenceMap { \npublic Collection < V > values ( ) { \nif ( values == null ) values = new ReferenceValues < K , V > ( this ) ; \nreturn values ; \n} \n} \n"}
{"10818": "public class AbstractReferenceMap { \nprotected void purge ( Reference ref ) { \nint hash = ref . hashCode ( ) ; \nint index = hashIndex ( hash , data . length ) ; \nHashEntry < K , V > previous = null ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { \nif ( previous == null ) data [ index ] = entry . next ; \nelse previous . next = entry . next ; \nthis . size -- ; \nreturn ; \n} \nprevious = entry ; \nentry = entry . next ; \n} \n} \n} \n"}
{"10819": "public class AbstractReferenceMap { \nprotected HashEntry < K , V > getEntry ( Object key ) { \nif ( key == null ) return null ; \nelse return super . getEntry ( key ) ; \n} \n} \n"}
{"10822": "public class PresenceConstant { \n@ Override public boolean controlEvents ( EventModel eventModel ) { \nif ( level . compareTo ( PresenceIndicatorLevel . WEAK ) >= 0 ) return present ; \nelse if ( level . compareTo ( PresenceIndicatorLevel . WEAK ) < 0 && mostVague . get ( ) ) return present ; \nelse return true ; \n} \n} \n"}
{"10823": "public class PresenceConstant { \npublic void setPresence ( boolean present ) { \nif ( this . present == present ) return ; \nthis . present = present ; \nupdateVague ( ) ; \nif ( present ) firePresence ( true ) ; \nelse fireLeaving ( ) ; \n} \n} \n"}
{"10828": "public class Gen_RunScripts { \nprotected final Properties loadProperties ( String filename ) { \nProperties ret = new Properties ( ) ; \nURL url = null ; \nFile f = new File ( filename . toString ( ) ) ; \nif ( f . exists ( ) ) try { \nurl = f . toURI ( ) . toURL ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nelse { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nurl = loader . getResource ( filename ) ; \nif ( url == null ) { \nloader = Gen_RunScripts . class . getClassLoader ( ) ; \nurl = loader . getResource ( filename ) ; \n} \n} \ntry { \nret . load ( url . openStream ( ) ) ; \n} \ncatch ( IOException e ) { \nSystem . err . println ( this . getAppName ( ) + \": cannot load property file <\" + filename + \">, IO exception\\n--><\" + e + \">\" ) ; \n} \ncatch ( Exception e ) { \nSystem . err . println ( this . getAppName ( ) + \": cannot load property file <\" + filename + \">, general exception\\n--><\" + e + \">\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10830": "public class ProgressResource { \npublic static Optional < Progress > getProgress ( EventModel eventModel ) { \nif ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . findAny ( ) . flatMap ( Progress :: importResource ) ; \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10832": "public class ServiceResolver { \npublic static Collection < ServiceResolver > discover ( InetAddress start , int count , int msTimeout ) { \nCollection < ServiceResolver > result = new ArrayList < ServiceResolver > ( ) ; \nCollection < InetAddress > hosts = IPv4Scanner . scanRange ( start , count , msTimeout ) ; \nfor ( InetAddress host : hosts ) { \nServiceResolver resolver = new ServiceResolver ( host ) ; \nlogger . info ( \"resolving {} {}\" , host . getHostAddress ( ) , host . getCanonicalHostName ( ) ) ; \nJSONResult config = resolver . getConfig ( ) ; \nif ( config != null ) result . add ( resolver ) ; \n} \nreturn result ; \n} \n} \n"}
{"10833": "public class ServiceResolver { \npublic JSONResult getConfig ( ) { \nif ( attempts == 0 ) try { \nresolve ( ) ; \n} \ncatch ( Exception e ) { \n} \nif ( config == null ) { \nlogger . info ( \"{} => no response\" , url ) ; \nreturn null ; \n} \nlogger . info ( \"{} => {}\" , url , config . get ( \"FireREST\" ) . getString ( ) ) ; \nreturn config ; \n} \n} \n"}
{"10838": "public class Connection { \npublic void addConnectionListener ( ConnectionListener connectionListener ) { \nif ( connectionListener == null ) return ; \nif ( ! connectionListeners . contains ( connectionListener ) ) connectionListeners . add ( connectionListener ) ; \n} \n} \n"}
{"10839": "public class Connection { \npublic void addPacketListener ( PacketListener packetListener , PacketFilter packetFilter ) { \nif ( packetListener == null ) throw new NullPointerException ( \"Packet listener is null.\" ) ; \nListenerWrapper wrapper = new ListenerWrapper ( packetListener , packetFilter ) ; \nrecvListeners . put ( packetListener , wrapper ) ; \n} \n} \n"}
{"10840": "public class Connection { \npublic void addPacketSendingListener ( PacketListener packetListener , PacketFilter packetFilter ) { \nif ( packetListener == null ) throw new NullPointerException ( \"Packet listener is null.\" ) ; \nListenerWrapper wrapper = new ListenerWrapper ( packetListener , packetFilter ) ; \nsendListeners . put ( packetListener , wrapper ) ; \n} \n} \n"}
{"10842": "public class Connection { \npublic void addPacketInterceptor ( PacketInterceptor packetInterceptor , PacketFilter packetFilter ) { \nif ( packetInterceptor == null ) throw new NullPointerException ( \"Packet interceptor is null.\" ) ; \ninterceptors . put ( packetInterceptor , new InterceptorWrapper ( packetInterceptor , packetFilter ) ) ; \n} \n} \n"}
{"10843": "public class Connection { \nprotected void firePacketInterceptors ( Packet packet ) { \nif ( packet != null ) for ( InterceptorWrapper interceptorWrapper : interceptors . values ( ) ) { \ninterceptorWrapper . notifyListener ( packet ) ; \n} \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse if ( parts . length == 1 ) fieldName = parts [ 0 ] ; \nelse throw new IllegalArgumentException ( \"Invalid property name\" ) ; \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) rpt = TYPES . get ( RequestParameterType . STRING ) ; \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) return rpt . newInstance ( Array . get ( value , 0 ) ) ; \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( int i = 0 ; \ni < l ; \ni ++ ) a [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) rpt = TYPES . get ( RequestParameterType . STRING ) ; \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10845": "public class ExternalComponent { \npublic void connectionLost ( ) { \nsynchronized ( this ) { \nif ( reconnecting ) return ; \nreconnecting = true ; \n} \nreaderThread = null ; \nboolean isConnected = false ; \nif ( ! shutdown ) component . shutdown ( ) ; \nwhile ( ! isConnected && ! shutdown ) try { \nconnect ( host , port , subdomain ) ; \nisConnected = true ; \nif ( shutdown ) disconnect ( ) ; \nelse start ( ) ; \n} \ncatch ( ComponentException e ) { \nmanager . getLog ( ) . error ( \"Error trying to reconnect with the server\" , e ) ; \ntry { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e1 ) { \n} \n} \nreconnecting = false ; \n} \n} \n"}
{"10851": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > lookup ( final Object data , final int index ) { \nNode < K , V > rval = null ; \nNode < K , V > node = rootNode [ index ] ; \nwhile ( node != null ) { \nint cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; \nif ( cmp == 0 ) { \nrval = node ; \nbreak ; \n} \nelse node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; \n} \nreturn rval ; \n} \n} \n"}
{"10852": "public class TransactionalBidiTreeMap { \nprivate int compare ( final int o1_status , final Object o1 , final int o2_status , final Object o2 , final int index ) { \nif ( comparators [ index ] == null ) if ( o1 instanceof TransactionalComparable ) return ( ( TransactionalComparable ) o1 ) . compareTo ( o1_status , o2 , o2_status ) ; \nelse return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; \nelse return comparators [ index ] . compare ( o1 , o2 ) ; \n} \n} \n"}
{"10853": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > leastNode ( final Node < K , V > node , final int index ) { \nNode < K , V > lval = node ; \nif ( lval != null ) while ( lval . getLeft ( index ) != null ) lval = lval . getLeft ( index ) ; \nreturn lval ; \n} \n} \n"}
{"10854": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > mostNode ( final Node < K , V > node , final int index ) { \nNode < K , V > rval = node ; \nif ( rval != null ) while ( rval . getRight ( index ) != null ) rval = rval . getRight ( index ) ; \nreturn rval ; \n} \n} \n"}
{"10855": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > nextGreater ( final Node < K , V > node , final int index ) { \nNode < K , V > rval ; \nif ( node == null ) rval = null ; \nelse if ( node . getRight ( index ) != null ) rval = leastNode ( node . getRight ( index ) , index ) ; \nelse { \nNode < K , V > parent = node . getParent ( index ) ; \nNode < K , V > child = node ; \nwhile ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { \nchild = parent ; \nparent = parent . getParent ( index ) ; \n} \nrval = parent ; \n} \nreturn rval ; \n} \n} \n"}
{"10856": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > mostValidNode ( final Node < K , V > node , final int index , final String thread_id ) { \nNode < K , V > rval = node ; \nwhile ( rval != null && ! validNode ( rval , thread_id ) ) rval = nextGreater ( rval , index ) ; \nreturn rval ; \n} \n} \n"}
{"10857": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > leastValidNode ( final Node < K , V > node , final int index , final String thread_id ) { \nNode < K , V > lval = node ; \nwhile ( lval != null && ! validNode ( lval , thread_id ) ) lval = nextSmaller ( lval , index ) ; \nreturn lval ; \n} \n} \n"}
{"10858": "public class TransactionalBidiTreeMap { \nprivate static < K , V > void copyColor ( final Node < K , V > from , final Node < K , V > to , final int index ) { \nif ( to != null ) if ( from == null ) to . setBlack ( index ) ; \nelse to . copyColor ( from , index ) ; \n} \n} \n"}
{"10865": "public class TransactionalBidiTreeMap { \nprivate void rotateLeft ( final Node < K , V > node , final int index ) { \nNode < K , V > rightChild = node . getRight ( index ) ; \nnode . setRight ( rightChild . getLeft ( index ) , index ) ; \nif ( rightChild . getLeft ( index ) != null ) rightChild . getLeft ( index ) . setParent ( node , index ) ; \nrightChild . setParent ( node . getParent ( index ) , index ) ; \nif ( node . getParent ( index ) == null ) rootNode [ index ] = rightChild ; \nelse if ( node . getParent ( index ) . getLeft ( index ) == node ) node . getParent ( index ) . setLeft ( rightChild , index ) ; \nelse node . getParent ( index ) . setRight ( rightChild , index ) ; \nrightChild . setLeft ( node , index ) ; \nnode . setParent ( rightChild , index ) ; \n} \n} \n"}
{"10866": "public class TransactionalBidiTreeMap { \nprivate void rotateRight ( final Node < K , V > node , final int index ) { \nNode < K , V > leftChild = node . getLeft ( index ) ; \nnode . setLeft ( leftChild . getRight ( index ) , index ) ; \nif ( leftChild . getRight ( index ) != null ) leftChild . getRight ( index ) . setParent ( node , index ) ; \nleftChild . setParent ( node . getParent ( index ) , index ) ; \nif ( node . getParent ( index ) == null ) rootNode [ index ] = leftChild ; \nelse if ( node . getParent ( index ) . getRight ( index ) == node ) node . getParent ( index ) . setRight ( leftChild , index ) ; \nelse node . getParent ( index ) . setLeft ( leftChild , index ) ; \nleftChild . setRight ( node , index ) ; \nnode . setParent ( leftChild , index ) ; \n} \n} \n"}
{"10867": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackInsert ( final Node < K , V > insertedNode , final int index ) { \nNode < K , V > currentNode = insertedNode ; \nmakeRed ( currentNode , index ) ; \nwhile ( ( currentNode != null ) && ( currentNode != rootNode [ index ] ) && ( isRed ( currentNode . getParent ( index ) , index ) ) ) if ( isLeftChild ( getParent ( currentNode , index ) , index ) ) { \nNode < K , V > y = getRightChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( isRed ( y , index ) ) { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \nelse { \nif ( isRightChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateLeft ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) rotateRight ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \nelse { \nNode < K , V > y = getLeftChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( isRed ( y , index ) ) { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \nelse { \nif ( isLeftChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateRight ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) rotateLeft ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \nmakeBlack ( rootNode [ index ] , index ) ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) swapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) rootNode [ index ] = replacement ; \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) deletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \nelse deletedNode . getParent ( index ) . setRight ( replacement , index ) ; \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) doRedBlackDeleteFixup ( replacement , index ) ; \n} \nelse if ( deletedNode . getParent ( index ) == null ) rootNode [ index ] = null ; \nelse { \nif ( isBlack ( deletedNode , index ) ) doRedBlackDeleteFixup ( deletedNode , index ) ; \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) deletedNode . getParent ( index ) . setLeft ( null , index ) ; \nelse deletedNode . getParent ( index ) . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10869": "public class TransactionalBidiTreeMap { \nprivate void checkNonNullComparable ( final Object o , final int index ) { \nif ( o == null ) throw new NullPointerException ( dataName [ index ] + \" cannot be null\" ) ; \nif ( comparators [ index ] == null && ! ( o instanceof Comparable ) ) throw new ClassCastException ( dataName [ index ] + \" must be Comparable\" ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) node = node . getRight ( VALUE ) ; \nelse if ( node . getLeft ( VALUE ) != null ) node = node . getLeft ( VALUE ) ; \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( cmp < 0 ) if ( node . getLeft ( VALUE ) != null ) node = node . getLeft ( VALUE ) ; \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \nelse if ( node . getRight ( VALUE ) != null ) node = node . getRight ( VALUE ) ; \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"10875": "public class TransactionalBidiTreeMap { \n@ Override public void clear ( ) { \nif ( auto_commit ) { \nmodify ( ) ; \nnodeCount = 0 ; \nrootNode [ KEY ] = null ; \nrootNode [ VALUE ] = null ; \n} \nelse { \nString thread_id = getCurrentThreadId ( ) ; \nArrayList < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( entrySet ( ) ) ; \nfor ( Iterator < Entry < K , V > > i = list . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nNode < K , V > node = ( Node < K , V > ) i . next ( ) ; \nif ( node . is ( Node . ADDED , thread_id ) ) doRedBlackDelete ( node ) ; \nelse node . setStatus ( Node . DELETED , thread_id ) ; \n} \n} \n} \n} \n"}
{"10876": "public class TransactionalBidiTreeMap { \n@ Override public Set < K > keySet ( ) { \nif ( setOfKeysByKey == null ) setOfKeysByKey = new AbstractFilterableSet < K > ( ) { \n@ Override public Iterator < K > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < K > ( KEY ) { \n@ Override protected K doGetNext ( ) { \nreturn ( K ) lastReturnedNode . getData ( KEY ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsKey ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nint oldNodeCount = nodeCount ; \nTransactionalBidiTreeMap . this . remove ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \n} \n} \n; \nreturn setOfKeysByKey ; \n} \n} \n"}
{"10877": "public class TransactionalBidiTreeMap { \n@ Override public Collection < V > values ( ) { \nif ( collectionOfValuesByKey == null ) collectionOfValuesByKey = new AbstractFilterableCollection < V > ( ) { \n@ Override public Iterator < V > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < V > ( KEY ) { \n@ Override protected V doGetNext ( ) { \nreturn ( V ) lastReturnedNode . getData ( VALUE ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsValue ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nint oldNodeCount = nodeCount ; \nremoveValue ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nboolean modified = false ; \nIterator < ? > iter = c . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) if ( removeValue ( iter . next ( ) ) != null ) modified = true ; \nreturn modified ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \n} \n} \n; \nreturn collectionOfValuesByKey ; \n} \n} \n"}
{"10878": "public class TransactionalBidiTreeMap { \npublic FilterableSet < Entry < K , V > > allEntrySet ( ) { \nif ( setOfAllEntries == null ) setOfAllEntries = new AbstractFilterableSet < Entry < K , V > > ( ) { \n@ Override public Iterator < Entry < K , V > > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < Entry < K , V > > ( KEY ) { \n@ Override protected Entry < K , V > doGetNext ( ) { \nreturn lastReturnedNode ; \n} \n@ Override protected Node < K , V > getNextValidNode ( Node < K , V > node , String thread_id ) { \nreturn node ; \n} \n} \n; \n} \n@ Override public boolean contains ( Object o ) { \nthrow new UtilsjException ( \"method not supported\" ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UtilsjException ( \"method not supported\" ) ; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( true ) ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \n} \n} \n; \nreturn setOfAllEntries ; \n} \n} \n"}
{"10879": "public class TransactionalBidiTreeMap { \npublic final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { \nK key ; \nV val ; \nint transaction_status ; \nString transaction_id ; \nnew_map . setAutoCommit ( isAutoCommit ( ) ) ; \nif ( ! isAutoCommit ( ) ) { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { \ntry { \nnew_map . put ( key , val ) ; \nnew_map . commit ( ) ; \n} \ncatch ( Exception e ) { \n} \ntry { \nif ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { \nnew_map . attach ( transaction_id ) ; \nnew_map . remove ( key ) ; \n} \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { \nnew_map . attach ( transaction_id ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \n} \nelse for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n"}
{"10880": "public class Cache { \nprotected synchronized void deleteExpiredEntries ( ) { \nif ( maxLifetime <= 0 ) return ; \nLinkedListNode node = ageList . getLast ( ) ; \nif ( node == null ) return ; \nlong expireTime = System . currentTimeMillis ( ) - maxLifetime ; \nwhile ( expireTime > node . timestamp ) { \nif ( remove ( node . object , true ) == null ) { \nlog . warn ( \"Error attempting to remove(\" + node . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nnode . remove ( ) ; \n} \nnode = ageList . getLast ( ) ; \nif ( node == null ) return ; \n} \n} \n} \n"}
{"10881": "public class Cache { \nprotected synchronized void cullCache ( ) { \nif ( maxCacheSize < 0 ) return ; \nif ( map . size ( ) > maxCacheSize ) { \ndeleteExpiredEntries ( ) ; \nint desiredSize = ( int ) ( maxCacheSize * .90 ) ; \nfor ( int i = map . size ( ) ; \ni > desiredSize ; \ni -- ) if ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { \nlog . warn ( \"Error attempting to cullCache with remove(\" + lastAccessedList . getLast ( ) . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nlastAccessedList . getLast ( ) . remove ( ) ; \n} \n} \n} \n} \n"}
{"10884": "public class DefaultRosterStore { \npublic static DefaultRosterStore init ( final File baseDir ) { \nDefaultRosterStore store = new DefaultRosterStore ( baseDir ) ; \nif ( store . setRosterVersion ( \"\" ) ) return store ; \nelse return null ; \n} \n} \n"}
{"10885": "public class DefaultRosterStore { \npublic static DefaultRosterStore open ( final File baseDir ) { \nDefaultRosterStore store = new DefaultRosterStore ( baseDir ) ; \nString s = store . readFile ( store . getVersionFile ( ) ) ; \nif ( s != null && s . startsWith ( STORE_ID + \"\\n\" ) ) return store ; \nelse return null ; \n} \n} \n"}
{"10886": "public class IPv4Scanner { \npublic static Collection < InetAddress > scanRange ( InetAddress addr , int count , int msTimeout ) { \nCollection < InetAddress > addresses = new ArrayList < InetAddress > ( ) ; \nCollection < InetAddress > result = new ArrayList < InetAddress > ( ) ; \nif ( addr == null ) try { \naddresses . addAll ( localhostNetworkAddresses ( ) ) ; \n} \ncatch ( Exception e ) { \nthrow new FireRESTException ( e ) ; \n} \nelse addresses . add ( addr ) ; \nfor ( InetAddress a : addresses ) { \nif ( a instanceof Inet4Address ) { \nInetAddress start = subnetAddress0 ( a , 24 ) ; \nresult . addAll ( scanRangeCore ( start , count , msTimeout ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10887": "public class IPv4Scanner { \npublic static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { \nif ( subnetBits < 1 || 32 <= subnetBits ) throw new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \nlong mask = 1 ; \nfor ( int i = 0 ; \ni < 32 ; \ni ++ ) { \nmask <<= 1 ; \nmask |= i < subnetBits ? 1 : 0 ; \n} \nlong host0 = asLongAddress ( addr ) & mask ; \ntry { \nreturn asInetAddress ( host0 ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \n} \n"}
{"10890": "public class ExecS { \nprotected final void addAllApplications ( Set < Class < ? > > set ) { \nfor ( Class < ? > cls : set ) { \nif ( ! cls . isInterface ( ) && ! Modifier . isAbstract ( cls . getModifiers ( ) ) ) if ( ! this . classmap . containsValue ( cls ) ) this . classNames . add ( cls . getName ( ) ) ; \n} \n} \n} \n"}
{"10891": "public class ExecS { \nprotected int executeApplication ( Object svc , String [ ] args , String orig ) { \nif ( svc != null && ( svc instanceof ExecS_Application ) ) { \nif ( svc instanceof Gen_RunScripts ) ( ( Gen_RunScripts ) svc ) . setClassMap ( this . classmap ) ; \nif ( svc instanceof Gen_ExecJarScripts ) ( ( Gen_ExecJarScripts ) svc ) . setClassMap ( this . classmap ) ; \nreturn ( ( ExecS_Application ) svc ) . executeApplication ( ArrayUtils . remove ( args , 0 ) ) ; \n} \nelse if ( svc == null ) { \nSystem . err . println ( \"could not create object for class or application name <\" + orig + \">\" ) ; \nreturn - 1 ; \n} \nelse if ( ! ( svc instanceof ExecS_Application ) ) { \nSystem . err . println ( \"given class or application name <\" + orig + \"> is not instance of \" + ExecS_Application . class . getName ( ) ) ; \nreturn - 2 ; \n} \nelse { \nSystem . err . println ( \"unexpected error processing for class or application name <\" + orig + \">\" ) ; \nreturn - 3 ; \n} \n} \n} \n"}
{"10898": "public class Gen_ExecJarScripts { \npublic boolean writeFile ( File file , List < String > lines ) { \nif ( file . exists ( ) ) file . delete ( ) ; \ntry { \nFileWriter out = new FileWriter ( file ) ; \nfor ( String s : lines ) { \nout . write ( s ) ; \nout . write ( System . getProperty ( \"line.separator\" ) ) ; \n} \nout . close ( ) ; \nfile . setExecutable ( true ) ; \n} \ncatch ( IOException ex ) { \nSystem . err . println ( this . getAppName ( ) + \": IO exception while writing to file - \" + file + \" with message: \" + ex . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"10902": "public class GoodwillSchema { \npublic GoodwillSchemaField getFieldByName ( final String name ) { \nfor ( final GoodwillSchemaField field : thriftItems . values ( ) ) { \nif ( field . getName ( ) . equals ( name ) ) return field ; \n} \nreturn null ; \n} \n} \n"}
{"10903": "public class CF_Utils { \npublic final static String getPkgName ( JarEntry entry ) { \nif ( entry == null ) return \"\" ; \nString s = entry . getName ( ) ; \nif ( s == null ) return \"\" ; \nif ( s . length ( ) == 0 ) return s ; \nif ( s . startsWith ( \"/\" ) ) s = s . substring ( 1 , s . length ( ) ) ; \nif ( s . endsWith ( \"/\" ) ) s = s . substring ( 0 , s . length ( ) - 1 ) ; \nreturn s . replace ( '/' , '.' ) ; \n} \n} \n"}
{"10907": "public class IterativeCallback { \npublic R iterate ( final FilterableCollection < ? extends T > c ) { \ninitState ( ) ; \ncheckUsed ( ) ; \nif ( c instanceof SynchronizedFilterableCollection ) return SyncUtils . synchronizeRead ( c , new Callback < R > ( ) { \n@ Override protected void doAction ( ) { \n_return ( doIteration ( c . iterator ( ) ) ) ; \n} \n} \n) ; \nreturn doIteration ( c . iterator ( ) ) ; \n} \n} \n"}
{"10909": "public class TrackInfoResource { \npublic static Optional < TrackInfo > getTrackInfo ( EventModel eventModel ) { \nif ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( RESOURCE_ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( RESOURCE_ID ) . stream ( ) . findAny ( ) . flatMap ( TrackInfo :: importFromResource ) ; \nelse return Optional . empty ( ) ; \n} \n} \n"}
{"10912": "public class FireREST { \npublic BufferedImage errorImage ( String ... lines ) { \nif ( imageBuffer == null || imageBuffer . getWidth ( ) != imageWidth || imageBuffer . getHeight ( ) != imageHeight ) imageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; \nGraphics2D g = ( Graphics2D ) imageBuffer . getGraphics ( ) ; \ng . setBackground ( new Color ( 64 , 32 , 32 ) ) ; \ng . setColor ( new Color ( 255 , 64 , 64 ) ) ; \ng . clearRect ( 0 , 0 , imageWidth , imageHeight ) ; \nint maxLen = 0 ; \nfor ( String line : lines ) { \nif ( line != null ) for ( String innerLine : line . split ( \"\\n\" ) ) { \nmaxLen = Math . max ( innerLine . length ( ) , maxLen ) ; \n} \n} \nint padding = 20 ; \nfloat sizeForWidth = 1.8f * ( imageWidth - padding - padding ) / maxLen ; \nfloat sizeForHeight = ( imageHeight - padding - padding ) / lines . length ; \nfloat lineHeight = Math . min ( 80 , Math . max ( 12 , Math . min ( sizeForWidth , sizeForHeight ) ) ) ; \nfloat fontSize = 0.8f * lineHeight ; \nFont font = g . getFont ( ) . deriveFont ( fontSize ) ; \ng . setFont ( font ) ; \nfloat y = fontSize + padding ; \nfor ( String line : lines ) { \nif ( line != null ) { \ng . drawString ( line , padding , y ) ; \ny += lineHeight ; \n} \n} \nreturn imageBuffer ; \n} \n} \n"}
{"10913": "public class FireREST { \npublic BufferedImage getImage ( URL url ) { \nString now = new Date ( ) . toString ( ) ; \nif ( url == null ) return errorImage ( now , \"(No image url)\" ) ; \ntry { \nHttpURLConnection urlconn = ( HttpURLConnection ) url . openConnection ( ) ; \nurlconn . setReadTimeout ( msTimeout ) ; \nurlconn . setConnectTimeout ( msTimeout ) ; \nurlconn . setRequestMethod ( \"GET\" ) ; \nurlconn . connect ( ) ; \nBufferedImage image = ImageIO . read ( urlconn . getInputStream ( ) ) ; \nif ( image == null ) return errorImage ( now , \"(Null image read)\" ) ; \nimageWidth = image . getWidth ( ) ; \nimageHeight = image . getHeight ( ) ; \nreturn image ; \n} \ncatch ( SocketTimeoutException e ) { \nlogger . warn ( \"getImage({}) => {} {}\" , url , e . getClass ( ) . getCanonicalName ( ) , e . getMessage ( ) ) ; \nreturn errorImage ( now , msTimeout + \"ms TIMEOUT\" ) ; \n} \ncatch ( Exception e ) { \nlogger . warn ( \"getImage({}) => {} {}\" , url , e . getClass ( ) . getCanonicalName ( ) , e . getMessage ( ) ) ; \nreturn errorImage ( now , \"(No image)\" , url . toString ( ) , e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"10914": "public class FireREST { \npublic JSONResult getJSON ( URL url ) { \ntry { \nlogger . debug ( \"Requesting {}\" , url ) ; \nStringBuilder text = new StringBuilder ( ) ; \nString line ; \nHttpURLConnection urlconn = ( HttpURLConnection ) url . openConnection ( ) ; \nurlconn . setReadTimeout ( msTimeout ) ; \nurlconn . setConnectTimeout ( msTimeout ) ; \nurlconn . setRequestMethod ( \"GET\" ) ; \nurlconn . connect ( ) ; \nBufferedReader br = new BufferedReader ( new InputStreamReader ( urlconn . getInputStream ( ) ) ) ; \nwhile ( ( line = br . readLine ( ) ) != null ) text . append ( line ) ; \nreturn new JSONResult ( text . toString ( ) ) ; \n} \ncatch ( Throwable e ) { \nthrow new FireRESTException ( url . toString ( ) , e ) ; \n} \n} \n} \n"}
{"10916": "public class CartesianProduct { \nprivate Set < R > multiplication ( ) { \nfinal Set < R > answer = new LinkedHashSet < > ( this . one . size ( ) * this . two . size ( ) ) ; \nfor ( final A left : this . one ) { \nfor ( final B right : this . two ) { \nfinal R element = this . function . apply ( left , right ) ; \nif ( answer . contains ( element ) ) throw new IllegalStateException ( String . format ( \"Cartesian product result contains duplicated element %s\" , element ) ) ; \nanswer . add ( element ) ; \n} \n} \nreturn ImmutableSet . copyOf ( answer ) ; \n} \n} \n"}
{"10923": "public class Playlist { \npublic boolean verify ( Capabilities capabilities ) { \nfor ( PlaybackMode playbackMode : playbackModes ) { \nswitch ( playbackMode ) { \ncase REPEAT : if ( ! capabilities . canRepeatPlayback ( ) ) return false ; \nelse break ; \ncase REPEAT_SONG : if ( ! capabilities . canRepeatPlaybackOfSong ( ) ) return false ; \nelse break ; \ncase SHUFFLE : if ( ! capabilities . canShufflePlayback ( ) ) return false ; \nelse break ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10924": "public class Playlist { \npublic HashMap < String , Object > export ( ) { \nHashMap < String , Object > data = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < queue . size ( ) ; \ni ++ ) data . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; \nfor ( int i = 0 ; \ni < playbackModes . size ( ) ; \ni ++ ) data . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; \ndata . put ( NAME_DESCRIPTOR , name ) ; \ndata . put ( POSITION_DESCRIPTOR , position ) ; \ndata . put ( DATA_DESCRIPTOR , this . data ) ; \nreturn data ; \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) return null ; \nchar ch ; \nint i = 0 ; \nint last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nint len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \nfor ( ; \ni < len ; \ni ++ ) { \nch = input [ i ] ; \nif ( ch > '>' ) continue ; \nelse if ( ch == '<' ) { \nif ( i > last ) out . append ( input , last , i - last ) ; \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse if ( ch == '>' ) { \nif ( i > last ) out . append ( input , last , i - last ) ; \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse if ( ch == '&' ) { \nif ( i > last ) out . append ( input , last , i - last ) ; \nif ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse if ( ch == '\"' ) { \nif ( i > last ) out . append ( input , last , i - last ) ; \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \n} \nif ( last == 0 ) return string ; \nif ( i > last ) out . append ( input , last , i - last ) ; \nreturn out . toString ( ) ; \n} \n} \n"}
{"10926": "public class SASLMechanism { \npublic void challengeReceived ( String challenge ) throws IOException { \nbyte response [ ] ; \nif ( challenge != null ) response = sc . evaluateChallenge ( StringUtils . decodeBase64 ( challenge ) ) ; \nelse response = sc . evaluateChallenge ( new byte [ 0 ] ) ; \nPacket responseStanza ; \nif ( response == null ) responseStanza = new Response ( ) ; \nelse responseStanza = new Response ( StringUtils . encodeBase64 ( response , false ) ) ; \ngetSASLAuthentication ( ) . send ( responseStanza ) ; \n} \n} \n"}
{"10929": "public class ContentEventListener { \npublic void handleEvent ( Event event ) { \nString topic = event . getTopic ( ) ; \nLOGGER . debug ( \"Got Event {} {} \" , event , handlers ) ; \nCollection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; \nif ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) try { \nint ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; \nfor ( IndexingHandler indexingHandler : contentIndexHandler ) { \nif ( indexingHandler instanceof QoSIndexHandler ) ttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; \n} \nQueueManager q = null ; \nif ( ttl < queues [ 0 ] . batchDelay ) { \nLOGGER . warn ( \"Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. \" + \"If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. \" + \"Filling the highest priority queue is counter productive. \" , ttl , event ) ; \nqueues [ 0 ] . saveEvent ( event ) ; \n} \nelse { \nfor ( QueueManager qm : queues ) { \nif ( ttl < qm . batchDelay ) { \nq . saveEvent ( event ) ; \nq = null ; \nbreak ; \n} \nq = qm ; \n} \nif ( q != null ) q . saveEvent ( event ) ; \n} \n} \ncatch ( IOException e ) { \nLOGGER . warn ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"10930": "public class ContentEventListener { \nprotected void joinAll ( ) throws InterruptedException { \nif ( queues != null ) for ( QueueManager q : queues ) { \nq . getQueueDispatcher ( ) . join ( ) ; \n} \n} \n} \n"}
{"10931": "public class Authorizable { \npublic void setProperty ( String name , Object value ) { \nif ( ! readOnly && ! FILTER_PROPERTIES . contains ( name ) ) { \nObject cv = authorizableMap . get ( name ) ; \nif ( value == null ) if ( cv != null && ! ( cv instanceof RemoveProperty ) ) modifiedMap . put ( name , new RemoveProperty ( ) ) ; \nelse if ( ! value . equals ( cv ) ) modifiedMap . put ( name , value ) ; \nelse if ( modifiedMap . containsKey ( name ) && ! value . equals ( modifiedMap . get ( name ) ) ) modifiedMap . put ( name , value ) ; \n} \n} \n} \n"}
{"10932": "public class Authorizable { \npublic void removeProperty ( String key ) { \nif ( ! readOnly && ( authorizableMap . containsKey ( key ) || modifiedMap . containsKey ( key ) ) ) modifiedMap . put ( key , new RemoveProperty ( ) ) ; \n} \n} \n"}
{"10936": "public class PresenceNonConstant { \n@ SuppressWarnings ( \"unused\" ) public void userEncountered ( ) { \nList < String > descriptors = new ArrayList < > ( ) ; \ndescriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; \nboolean known = ! fireUnknownIfNotPresent || present ; \nboolean firstPresent = ( ! strict && ! present ) || ( strict && ! strictPresent ) ; \nlong lastSeen = this . lastSeen . until ( LocalDateTime . now ( ) , ChronoUnit . SECONDS ) ; \nOptional < Event > presenceEvent = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( id -> PresenceEvent . createPresenceEvent ( id , strict , known , firstPresent , descriptors , lastSeen ) ) . map ( event -> event . addEventLifeCycleListener ( EventLifeCycle . APPROVED , lifeCycle -> { \nif ( known ) { \nthis . lastSeen = LocalDateTime . now ( ) ; \nif ( strict ) this . strictPresent = true ; \npresent = true ; \n} \n} \n) ) ; \nif ( ! presenceEvent . isPresent ( ) ) error ( \"unable to create PresenceEvent\" ) ; \nelse fire ( presenceEvent . get ( ) , 5 ) ; \n} \n} \n"}
{"10937": "public class PresenceNonConstant { \n@ Override public void eventFired ( EventModel event ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) || event . containsDescriptor ( PresenceEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) if ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { \npresent = false ; \nstrictPresent = false ; \n} \nelse if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) nonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) present = false ; \nstrictPresent = false ; \n} \n) ; \nelse { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; \n} \n} \n} \n"}
{"10940": "public class AbstractHashedMap { \npublic boolean containsKey ( Object key ) { \nint hashCode = hash ( ( key == null ) ? NULL : key ) ; \nHashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; \nwhile ( entry != null ) { \nif ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) return true ; \nentry = entry . next ; \n} \nreturn false ; \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) for ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) return true ; \nentry = entry . next ; \n} \n} \nelse for ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) return true ; \nentry = entry . next ; \n} \n} \nreturn false ; \n} \n} \n"}
{"10943": "public class AbstractHashedMap { \npublic void clear ( ) { \nmodCount ++ ; \nHashEntry [ ] data = this . data ; \nfor ( int i = data . length - 1 ; \ni >= 0 ; \ni -- ) data [ i ] = null ; \nsize = 0 ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nint oldCapacity = data . length ; \nif ( newCapacity <= oldCapacity ) return ; \nif ( size == 0 ) { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \nelse { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount ++ ; \nfor ( int i = oldCapacity - 1 ; \ni >= 0 ; \ni -- ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nint index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \n} \n} \n"}
{"10948": "public class AbstractHashedMap { \nprotected int calculateNewCapacity ( int proposedCapacity ) { \nint newCapacity = 1 ; \nif ( proposedCapacity > MAXIMUM_CAPACITY ) newCapacity = MAXIMUM_CAPACITY ; \nelse { \nwhile ( newCapacity < proposedCapacity ) newCapacity <<= 1 ; \nif ( newCapacity > MAXIMUM_CAPACITY ) newCapacity = MAXIMUM_CAPACITY ; \n} \nreturn newCapacity ; \n} \n} \n"}
{"10949": "public class AbstractHashedMap { \nprotected Iterator < Map . Entry < K , V > > createEntrySetIterator ( ) { \nif ( size ( ) == 0 ) return EmptyIterator . INSTANCE ; \nreturn new EntrySetIterator < K , V > ( this ) ; \n} \n} \n"}
{"10950": "public class Types { \npublic static void loadFromStream ( String key , Map < String , Object > output , InputStream binaryStream , String type ) throws IOException { \nDataInputStream dis = new DataInputStream ( binaryStream ) ; \nString ckey = dis . readUTF ( ) ; \nif ( ! key . equals ( ckey ) ) throw new IOException ( \"Body Key does not match row key, unable to read\" ) ; \nreadMapFromStream ( output , dis ) ; \nString cftype = null ; \ntry { \ncftype = dis . readUTF ( ) ; \n} \ncatch ( IOException e ) { \nLOGGER . debug ( \"No type specified\" ) ; \n} \nif ( cftype != null && ! cftype . equals ( type ) ) throw new IOException ( \"Object is not of expected column family, unable to read expected [\" + type + \"] was [\" + cftype + \"]\" ) ; \nLOGGER . debug ( \"Finished Reading\" ) ; \ndis . close ( ) ; \nbinaryStream . close ( ) ; \n} \n} \n"}
{"10951": "public class AddOn { \n@ Override public void register ( ) { \nprepare ( ) ; \nContentGenerator [ ] contentGenerators = registerContentGenerator ( ) ; \nif ( contentGenerators != null ) for ( ContentGenerator contentGenerator : contentGenerators ) { \ntry { \ngetContext ( ) . getContentGenerators ( ) . registerContentGenerator ( contentGenerator ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + contentGenerator . getID ( ) , e ) ; \n} \n} \nEventsControllerModel [ ] eventsControllerModels = registerEventController ( ) ; \nif ( eventsControllerModels != null ) for ( EventsControllerModel eventsController : eventsControllerModels ) { \ntry { \ngetContext ( ) . getEvents ( ) . distributor ( ) . registerEventsController ( eventsController ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + eventsController . getID ( ) , e ) ; \n} \n} \nOutputPluginModel [ ] outputPluginModels = registerOutputPlugin ( ) ; \nif ( outputPluginModels != null ) for ( OutputPluginModel outputPlugin : outputPluginModels ) { \ntry { \ngetContext ( ) . getOutput ( ) . addOutputPlugin ( outputPlugin ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + outputPlugin . getID ( ) , e ) ; \n} \n} \nOutputExtensionModel [ ] outputExtensionModels = registerOutputExtension ( ) ; \nif ( outputExtensionModels != null ) for ( OutputExtensionModel outputExtension : outputExtensionModels ) { \ntry { \ngetContext ( ) . getOutput ( ) . addOutputExtension ( outputExtension ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + outputExtension . getID ( ) , e ) ; \n} \n} \nOutputControllerModel [ ] outputControllerModels = registerOutputController ( ) ; \nif ( outputControllerModels != null ) for ( OutputControllerModel outputController : outputControllerModels ) { \ntry { \ngetContext ( ) . getOutput ( ) . addOutputController ( outputController ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + outputController . getID ( ) , e ) ; \n} \n} \nActivatorModel [ ] activatorModels = registerActivator ( ) ; \ngetContext ( ) . getSystem ( ) . registerInitializedListener ( ( ) -> { \nif ( activatorModels != null ) for ( ActivatorModel activator : activatorModels ) { \ntry { \ngetContext ( ) . getActivators ( ) . addActivator ( activator ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + activator . getID ( ) , e ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"10953": "public class ReconnectionManager { \nprotected void notifyReconnectionFailed ( Exception exception ) { \nif ( isReconnectionAllowed ( ) ) for ( ConnectionListener listener : connection . connectionListeners ) { \nlistener . reconnectionFailed ( exception ) ; \n} \n} \n} \n"}
{"10954": "public class ReconnectionManager { \nprotected void notifyAttemptToReconnectIn ( int seconds ) { \nif ( isReconnectionAllowed ( ) ) for ( ConnectionListener listener : connection . connectionListeners ) { \nlistener . reconnectingIn ( seconds ) ; \n} \n} \n} \n"}
