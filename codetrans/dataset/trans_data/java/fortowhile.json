{"24": "public class QueueDrainHelper { \npublic static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { \nint missed = 1 ; \n{ \nwhile ( ) { \n{ \nwhile ( ) { \nboolean d = qd . done ( ) ; \nT v = q . poll ( ) ; \nboolean empty = v == null ; \nif ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \nreturn ; \n} \nif ( empty ) { \nbreak ; \n} \nlong r = qd . requested ( ) ; \nif ( r != 0L ) { \nif ( qd . accept ( a , v ) ) { \nif ( r != Long . MAX_VALUE ) { \nqd . produced ( 1 ) ; \n} \n} \n} \nelse { \nq . clear ( ) ; \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \na . onError ( new MissingBackpressureException ( \"Could not emit value due to lack of requests.\" ) ) ; \nreturn ; \n} \n} \n} \nmissed = qd . leave ( - missed ) ; \nif ( missed == 0 ) { \nbreak ; \n} \n} \n} \n} \n} \n"}
{"26": "public class QueueDrainHelper { \npublic static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { \nif ( queue . isEmpty ( ) ) { \nactual . onComplete ( ) ; \nreturn ; \n} \nif ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { \nreturn ; \n} \n{ \nwhile ( ) { \nlong r = state . get ( ) ; \nif ( ( r & COMPLETED_MASK ) != 0L ) { \nreturn ; \n} \nlong u = r | COMPLETED_MASK ; \nif ( state . compareAndSet ( r , u ) ) { \nif ( r != 0L ) { \npostCompleteDrain ( u , actual , queue , state , isCancelled ) ; \n} \nreturn ; \n} \n} \n} \n} \n} \n"}
{"27": "public class SinglePostCompleteSubscriber { \nprotected final void complete ( R n ) { \nlong p = produced ; \nif ( p != 0 ) { \nBackpressureHelper . produced ( this , p ) ; \n} \n{ \nwhile ( ) { \nlong r = get ( ) ; \nif ( ( r & COMPLETE_MASK ) != 0 ) { \nonDrop ( n ) ; \nreturn ; \n} \nif ( ( r & REQUEST_MASK ) != 0 ) { \nlazySet ( COMPLETE_MASK + 1 ) ; \ndownstream . onNext ( n ) ; \ndownstream . onComplete ( ) ; \nreturn ; \n} \nvalue = n ; \nif ( compareAndSet ( 0 , COMPLETE_MASK ) ) { \nreturn ; \n} \nvalue = null ; \n} \n} \n} \n} \n"}
{"36": "public class BackpressureHelper { \npublic static long add ( AtomicLong requested , long n ) { \n{ \nwhile ( ) { \nlong r = requested . get ( ) ; \nif ( r == Long . MAX_VALUE ) { \nreturn Long . MAX_VALUE ; \n} \nlong u = addCap ( r , n ) ; \nif ( requested . compareAndSet ( r , u ) ) { \nreturn r ; \n} \n} \n} \n} \n} \n"}
{"42": "public class SerializedSubject { \nvoid emitLoop ( ) { \n{ \nwhile ( ) { \nAppendOnlyLinkedArrayList < Object > q ; \nsynchronized ( this ) { \nq = queue ; \nif ( q == null ) { \nemitting = false ; \nreturn ; \n} \nqueue = null ; \n} \nq . forEachWhile ( this ) ; \n} \n} \n} \n} \n"}
{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nwhile ( ! deque . isEmpty ( ) ) { \nThrowable e = deque . removeFirst ( ) ; \nif ( e instanceof CompositeException ) { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \n{ \nint i = exceptions . size ( ) - 1 ; \nwhile ( i >= 0 ) { \ndeque . offerFirst ( exceptions . get ( i ) ) ; \ni -- ; \n} \n} \n} \nelse { \nlist . add ( e ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \n{ \nint i = 0 ; \nwhile ( i < c ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , subscriber ) ) { \nreturn true ; \n} \ni ++ ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \n{ \nint i = 0 ; \nwhile ( i < c ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , observer ) ) { \nreturn true ; \n} \ni ++ ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"64": "public class PublishSubject { \nboolean add ( PublishDisposable < T > ps ) { \n{ \nwhile ( ) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED ) { \nreturn false ; \n} \nint n = a . length ; \n@ SuppressWarnings ( \"unchecked\" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , n ) ; \nb [ n ] = ps ; \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn true ; \n} \n} \n} \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \n{ \nwhile ( ) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) { \nreturn ; \n} \nint n = a . length ; \nint j = - 1 ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( j < 0 ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) { \nb = EMPTY ; \n} \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \n} \n} \n} \n"}
{"86": "public class SpringSecurityLdapTemplate { \npublic Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { \nObject [ ] encodedParams = new String [ params . length ] ; \n{ \nint i = 0 ; \nwhile ( i < params . length ) { \nencodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; \ni ++ ; \n} \n} \nString formattedFilter = MessageFormat . format ( filter , encodedParams ) ; \nlogger . debug ( \"Using filter: \" + formattedFilter ) ; \nfinal HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; \nContextMapper roleMapper = new ContextMapper ( ) { \npublic Object mapFromContext ( Object ctx ) { \nDirContextAdapter adapter = ( DirContextAdapter ) ctx ; \nMap < String , List < String > > record = new HashMap < String , List < String > > ( ) ; \nif ( attributeNames == null || attributeNames . length == 0 ) { \ntry { \n{ \nNamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; \nwhile ( ae . hasMore ( ) ) { \nAttribute attr = ( Attribute ) ae . next ( ) ; \nextractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; \n} \n} \n} \ncatch ( NamingException x ) { \norg . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; \n} \n} \nelse { \nfor ( String attributeName : attributeNames ) { \nextractStringAttributeValues ( adapter , record , attributeName ) ; \n} \n} \nrecord . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; \nset . add ( record ) ; \nreturn null ; \n} \n} \n; \nSearchControls ctls = new SearchControls ( ) ; \nctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; \nctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; \nsearch ( base , formattedFilter , ctls , roleMapper ) ; \nreturn set ; \n} \n} \n"}
{"110": "public class AbstractRememberMeServices { \nprotected String encodeCookie ( String [ ] cookieTokens ) { \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < cookieTokens . length ) { \ntry { \nsb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( i < cookieTokens . length - 1 ) { \nsb . append ( DELIMITER ) ; \n} \ni ++ ; \n} \n} \nString value = sb . toString ( ) ; \nsb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; \nwhile ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"147": "public class UrlAuthorizationConfigurer { \nprivate static String [ ] hasAnyRole ( String ... roles ) { \n{ \nint i = 0 ; \nwhile ( i < roles . length ) { \nroles [ i ] = \"ROLE_\" + roles [ i ] ; \ni ++ ; \n} \n} \nreturn roles ; \n} \n} \n"}
{"170": "public class AnnotationParameterNameDiscoverer { \nprivate < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { \nAnnotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; \nint parameterCount = parameterAnnotations . length ; \nString [ ] paramNames = new String [ parameterCount ] ; \nboolean found = false ; \n{ \nint i = 0 ; \nwhile ( i < parameterCount ) { \nAnnotation [ ] annotations = parameterAnnotations [ i ] ; \nString parameterName = findParameterName ( annotations ) ; \nif ( parameterName != null ) { \nfound = true ; \nparamNames [ i ] = parameterName ; \n} \ni ++ ; \n} \n} \nreturn found ? paramNames : null ; \n} \n} \n"}
{"190": "public class StandardPasswordEncoder { \nprivate boolean matches ( byte [ ] expected , byte [ ] actual ) { \nif ( expected . length != actual . length ) { \nreturn false ; \n} \nint result = 0 ; \n{ \nint i = 0 ; \nwhile ( i < expected . length ) { \nresult |= expected [ i ] ^ actual [ i ] ; \ni ++ ; \n} \n} \nreturn result == 0 ; \n} \n} \n"}
{"215": "public class FastHttpDateFormat { \nprivate static Long internalParseDate ( String value , DateFormat [ ] formats ) { \nDate date = null ; \n{ \nint i = 0 ; \nwhile ( ( date == null ) && ( i < formats . length ) ) { \ntry { \ndate = formats [ i ] . parse ( value ) ; \n} \ncatch ( ParseException ignored ) { \n} \ni ++ ; \n} \n} \nif ( date == null ) { \nreturn null ; \n} \nreturn new Long ( date . getTime ( ) ) ; \n} \n} \n"}
{"319": "public class SingleParameterInjector { \nstatic Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { \nif ( parameterInjectors == null ) { \nreturn NO_ARGUMENTS ; \n} \nint size = parameterInjectors . length ; \nObject [ ] parameters = new Object [ size ] ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nparameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; \ni ++ ; \n} \n} \nreturn parameters ; \n} \n} \n"}
{"326": "public class TypeLiteral { \nprivate List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { \nTypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; \n{ \nint t = 0 ; \nwhile ( t < types . length ) { \nresult [ t ] = resolve ( types [ t ] ) ; \nt ++ ; \n} \n} \nreturn ImmutableList . copyOf ( result ) ; \n} \n} \n"}
{"352": "public class Message { \nprivate Object writeReplace ( ) throws ObjectStreamException { \nObject [ ] sourcesAsStrings = sources . toArray ( ) ; \n{ \nint i = 0 ; \nwhile ( i < sourcesAsStrings . length ) { \nsourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; \ni ++ ; \n} \n} \nreturn new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! sameTypes . isEmpty ( ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nint howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \n{ \nint i = 0 ; \nwhile ( i < howMany ) { \nsb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \n++ i ; \n} \n} \nint remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( remaining > 0 ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nelse { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) || want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { \nbreak ; \n} \n} \n} \nif ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { \nsb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \n} \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"382": "public class InterceptorStackCallback { \nprivate void pruneStacktrace ( Throwable throwable ) { \n{ \nThrowable t = throwable ; \nwhile ( t != null ) { \nStackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; \nList < StackTraceElement > pruned = Lists . newArrayList ( ) ; \nfor ( StackTraceElement element : stackTrace ) { \nString className = element . getClassName ( ) ; \nif ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( \"$EnhancerByGuice$\" ) ) { \npruned . add ( element ) ; \n} \n} \nt . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; \nt = t . getCause ( ) ; \n} \n} \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nint index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nint thisIdx = index ++ ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \n{ \nint i = dependencies . size ( ) - 1 ; \nwhile ( i >= 0 ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \ni -- ; \n} \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses && cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! causes . containsKey ( causeEquivalence ) ) { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \nelse { \nint causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( errorMessages . size ( ) == 1 ) { \nfmt . format ( \"1 error\" ) ; \n} \nelse { \nfmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \n} \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( url . isConnWarmup ( ) ) { \n{ \nint i = actualNum ; \nwhile ( i < expectNum ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n++ i ; \n} \n} \n} \nelse { \nif ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( syncCreateNumWhenNotWarmup > 0 ) { \n{ \nint i = 0 ; \nwhile ( i < syncCreateNumWhenNotWarmup ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n++ i ; \n} \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \n{ \nint i = pool . size ( ) ; \nwhile ( i < url . getConnNum ( ) ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n++ i ; \n} \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \n} \n} \n"}
{"426": "public class ProtocolSwitch { \npublic static byte toByte ( BitSet bs ) { \nint value = 0 ; \n{ \nint i = 0 ; \nwhile ( i < bs . length ( ) ) { \nif ( bs . get ( i ) ) { \nvalue += 1 << i ; \n} \n++ i ; \n} \n} \nif ( bs . length ( ) > 7 ) { \nthrow new IllegalArgumentException ( \"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nreturn ( byte ) value ; \n} \n} \n"}
{"561": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { \nassert ( files . length == baseDirs . length ) ; \nFileRepository [ ] repositories = new FileRepository [ files . length ] ; \nList < JarFile > jarFiles = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < files . length ) { \nFile file = files [ i ] ; \nString baseDir = baseDirs [ i ] ; \nif ( file . isDirectory ( ) ) { \nrepositories [ i ] = new FilesystemRepository ( file ) ; \n} \nelse { \nJarFile jarFile = new JarFile ( file ) ; \njarFiles . add ( jarFile ) ; \nrepositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; \n} \ni ++ ; \n} \n} \nreturn new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { \nfor ( JarFile jarFile : jarFiles ) { \njarFile . close ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"593": "public class ClassUtils { \npublic static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { \nif ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { \nreturn false ; \n} \nif ( classArray == null ) { \nclassArray = EMPTY_CLASS_ARRAY ; \n} \nif ( toClassArray == null ) { \ntoClassArray = EMPTY_CLASS_ARRAY ; \n} \n{ \nint i = 0 ; \nwhile ( i < classArray . length ) { \nif ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"649": "public class MemberUtils { \nprivate static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { \nfloat cost = 0.0f ; \nClass < ? > cls = srcClass ; \nif ( ! cls . isPrimitive ( ) ) { \ncost += 0.1f ; \ncls = ClassUtils . wrapperToPrimitive ( cls ) ; \n} \n{ \nint i = 0 ; \nwhile ( cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ) { \nif ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { \ncost += 0.1f ; \nif ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { \ncls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; \n} \n} \ni ++ ; \n} \n} \nreturn cost ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) { \nreturn Float . MAX_VALUE ; \n} \n{ \nint i = 0 ; \nwhile ( i < normalArgsLen ) { \ntotalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \ni ++ ; \n} \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) { \ntotalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \nelse if ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \n{ \nint i = destArgs . length - 1 ; \nwhile ( i < srcArgs . length ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \ni ++ ; \n} \n} \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"666": "public class BridgeMethodResolver { \npublic Map resolveAll ( ) { \nMap resolved = new HashMap ( ) ; \n{ \nIterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; \nwhile ( entryIter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) entryIter . next ( ) ; \nClass owner = ( Class ) entry . getKey ( ) ; \nSet bridges = ( Set ) entry . getValue ( ) ; \ntry { \nInputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( '.' , '/' ) + \".class\" ) ; \nif ( is == null ) { \nreturn resolved ; \n} \ntry { \nnew ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; \n} \nfinally { \nis . close ( ) ; \n} \n} \ncatch ( IOException ignored ) { \n} \n} \n} \nreturn resolved ; \n} \n} \n"}
{"674": "public class ReflectUtils { \npublic static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { \nMap map = new HashMap ( ) ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nMethod method = methods [ i ] ; \nmap . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; \ni ++ ; \n} \n} \nMethod [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; \n{ \nint i = 0 ; \nwhile ( i < result . length ) { \nresult [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; \nif ( result [ i ] == null ) { \n} \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"690": "public class HttpRequest { \npublic HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { \nquery ( name1 , value1 == null ? null : value1 . toString ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < parameters . length ) { \nString name = parameters [ i ] . toString ( ) ; \nString value = parameters [ i + 1 ] . toString ( ) ; \nquery . add ( name , value ) ; \ni += 2 ; \n} \n} \nreturn this ; \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) { \n{ \nint j = 0 ; \nwhile ( j < paramValues . length ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \nj ++ ; \n} \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \n{ \nint j = 0 ; \nwhile ( j < paramValues . length ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { \nparamValues [ j ] = null ; \n} \nj ++ ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"723": "public class ColumnNamingStrategy { \npublic String convertColumnNameToPropertyName ( final String columnName ) { \nStringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; \nint len = columnName . length ( ) ; \nif ( splitCamelCase ) { \nboolean toUpper = false ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c = columnName . charAt ( i ) ; \nif ( c == separatorChar ) { \ntoUpper = true ; \n{ \ni ++ ; \ncontinue ; \n} \n} \nif ( toUpper ) { \npropertyName . append ( Character . toUpperCase ( c ) ) ; \ntoUpper = false ; \n} \nelse { \npropertyName . append ( Character . toLowerCase ( c ) ) ; \n} \ni ++ ; \n} \n} \nreturn propertyName . toString ( ) ; \n} \nreturn columnName ; \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nint length = arr . length ; \nif ( length == 0 ) { \nreturn new byte [ 0 ] ; \n} \nint sndx = 0 , endx = length - 1 ; \nint pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nint cnt = endx - sndx + 1 ; \nint sepCnt = length > 76 ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nint len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nint d = 0 ; \n{ \nint cc = 0 , eLen = ( len / 3 ) * 3 ; \nwhile ( d < eLen ) { \nint i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; \ndest [ d ++ ] = ( byte ) ( i >> 16 ) ; \ndest [ d ++ ] = ( byte ) ( i >> 8 ) ; \ndest [ d ++ ] = ( byte ) i ; \nif ( sepCnt > 0 && ++ cc == 19 ) { \nsndx += 2 ; \ncc = 0 ; \n} \n} \n} \nif ( d < len ) { \nint i = 0 ; \n{ \nint j = 0 ; \nwhile ( sndx <= endx - pad ) { \ni |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; \nj ++ ; \n} \n} \n{ \nint r = 16 ; \nwhile ( d < len ) { \ndest [ d ++ ] = ( byte ) ( i >> r ) ; \nr -= 8 ; \n} \n} \n} \nreturn dest ; \n} \n} \n"}
{"769": "public class PetiteBeans { \npublic void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( initMethodNames == null ) { \ninitMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = initMethodNames . length ; \nInitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; \nint i ; \n{ \ni = 0 ; \nwhile ( i < initMethodNames . length ) { \nMethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; \n} \ninitMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; \ni ++ ; \n} \n} \nbeanDefinition . addInitMethodPoints ( initMethodPoints ) ; \n} \n} \n"}
{"770": "public class PetiteBeans { \npublic void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( destroyMethodNames == null ) { \ndestroyMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = destroyMethodNames . length ; \nDestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; \nint i ; \n{ \ni = 0 ; \nwhile ( i < destroyMethodNames . length ) { \nMethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; \n} \ndestroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; \ni ++ ; \n} \n} \nbeanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; \n} \n} \n"}
{"781": "public class ProxettaAsmUtil { \npublic static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \n{ \nint i = 1 ; \nwhile ( i <= methodInfo . getArgumentsCount ( ) ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"782": "public class ProxettaAsmUtil { \npublic static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \n{ \nint i = 0 ; \nwhile ( i < methodInfo . getArgumentsCount ( ) ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"783": "public class ProxettaAsmUtil { \npublic static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \n{ \nint i = 1 ; \nwhile ( i <= methodInfo . getArgumentsCount ( ) ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"802": "public class ServletUtil { \npublic static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nif ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { \nint emptyCount = 0 ; \nint total = paramValues . length ; \n{ \nint i = 0 ; \nwhile ( i < paramValues . length ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount ++ ; \n{ \ni ++ ; \ncontinue ; \n} \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount ++ ; \nif ( treatEmptyParamsAsNull ) { \nparamValue = null ; \n} \n} \nparamValues [ i ] = paramValue ; \ni ++ ; \n} \n} \nif ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { \nreturn null ; \n} \n} \nreturn paramValues ; \n} \n} \n"}
{"809": "public class BeanData { \npublic Object newBeanInstance ( ) { \nif ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { \nthrow new PetiteException ( \"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nint paramNo = beanDefinition . ctor . references . length ; \nObject [ ] args = new Object [ paramNo ] ; \nif ( beanDefinition . wiringMode != WiringMode . NONE ) { \n{ \nint i = 0 ; \nwhile ( i < paramNo ) { \nargs [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; \nif ( args [ i ] == null ) { \nif ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { \nthrow new PetiteException ( \"Wiring constructor failed. References '\" + beanDefinition . ctor . references [ i ] + \"' not found for constructor: \" + beanDefinition . ctor . constructor ) ; \n} \n} \ni ++ ; \n} \n} \n} \nfinal Object bean ; \ntry { \nbean = beanDefinition . ctor . constructor . newInstance ( args ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Failed to create new bean instance '\" + beanDefinition . type . getName ( ) + \"' using constructor: \" + beanDefinition . ctor . constructor , ex ) ; \n} \nreturn bean ; \n} \n} \n"}
{"819": "public class BCrypt { \nprivate static int streamtoword ( byte [ ] data , int [ ] offp ) { \nint i ; \nint word = 0 ; \nint off = offp [ 0 ] ; \n{ \ni = 0 ; \nwhile ( i < 4 ) { \nword = ( word << 8 ) | ( data [ off ] & 0xff ) ; \noff = ( off + 1 ) % data . length ; \ni ++ ; \n} \n} \noffp [ 0 ] = off ; \nreturn word ; \n} \n} \n"}
{"821": "public class BCrypt { \npublic static boolean checkpw ( String plaintext , String hashed ) { \nbyte [ ] hashed_bytes ; \nbyte [ ] try_bytes ; \ntry { \nString try_pw = hashpw ( plaintext , hashed ) ; \nhashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; \ntry_bytes = try_pw . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nreturn false ; \n} \nif ( hashed_bytes . length != try_bytes . length ) { \nreturn false ; \n} \nbyte ret = 0 ; \n{ \nint i = 0 ; \nwhile ( i < try_bytes . length ) { \nret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; \ni ++ ; \n} \n} \nreturn ret == 0 ; \n} \n} \n"}
{"832": "public class ActionMethodParser { \npublic ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { \nif ( actionHandler != null ) { \nreturn new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; \n} \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; \nfinal Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; \nfinal MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; \nfinal Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; \nString [ ] methodParamNames = null ; \n{ \nint ndx = 0 ; \nwhile ( ndx < paramTypes . length ) { \nClass paramType = paramTypes [ ndx ] ; \nif ( methodParamNames == null ) { \nmethodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; \n} \nfinal String paramName = methodParamNames [ ndx ] ; \nfinal Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; \nfinal ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; \nMapperFunction mapperFunction = null ; \nfor ( final Annotation annotation : parameterAnnotations ) { \nif ( annotation instanceof Mapper ) { \nmapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; \nbreak ; \n} \n} \nparams [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; \nndx ++ ; \n} \n} \nreturn new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nint currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \n{ \nint i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \nwhile ( i > 0 ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n-- i ; \n} \n} \nif ( bootstrapMethodCount > 0 ) { \nint bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nint bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nint currentOffset = bootstrapMethodsOffset ; \n{ \nint i = 0 ; \nwhile ( i < bootstrapMethodCount ) { \nint offset = currentOffset - bootstrapMethodsOffset ; \nint bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nwhile ( numBootstrapArguments -- > 0 ) { \nint bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nint h = 0 ; \n{ \nint i = name . length ( ) - 1 ; \nwhile ( i >= 0 ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) { \nif ( c >= 'A' && c <= 'Z' ) { \nc += 32 ; \n} \n} \nh = 31 * h + c ; \ni -- ; \n} \n} \nif ( h > 0 ) { \nreturn h ; \n} \nif ( h == Integer . MIN_VALUE ) { \nreturn Integer . MAX_VALUE ; \n} \nreturn - h ; \n} \n} \n"}
{"872": "public class HttpMultiMap { \npublic HttpMultiMap < V > clear ( ) { \n{ \nint i = 0 ; \nwhile ( i < entries . length ) { \nentries [ i ] = null ; \ni ++ ; \n} \n} \nhead . before = head . after = head ; \nreturn this ; \n} \n} \n"}
{"877": "public class FastCharBuffer { \n@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { \n{ \nint i = start ; \nwhile ( i < end ) { \nappend ( csq . charAt ( i ) ) ; \ni ++ ; \n} \n} \nreturn this ; \n} \n} \n"}
{"879": "public class ProxettaMethodBuilder { \n@ Override public void visitEnd ( ) { \ncreateFirstChainDelegate_Continue ( tmd ) ; \n{ \nint p = 0 ; \nwhile ( p < tmd . proxyData . length ) { \ntmd . selectCurrentProxy ( p ) ; \ncreateProxyMethod ( tmd ) ; \np ++ ; \n} \n} \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( filter == null ) { \nmessages = folder . getMessages ( ) ; \n} \nelse { \nmessages = folder . search ( filter . getSearchTerm ( ) ) ; \n} \nif ( messages . length == 0 ) { \nreturn ReceivedEmail . EMPTY_ARRAY ; \n} \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \n{ \nint i = 0 ; \nwhile ( i < messages . length ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { \nmsg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \ni ++ ; \n} \n} \nif ( processedMessageConsumer != null ) { \nprocessedMessageConsumer . accept ( messages ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { \nfolder . expunge ( ) ; \n} \n} \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"944": "public class Threefish { \npublic void init ( final long [ ] key , final long [ ] tweak ) { \nfinal int newNw = key . length ; \nif ( nw != newNw ) { \nnw = newNw ; \nswitch ( nw ) { \ncase WORDS_4 : pi = PI4 ; \nrpi = RPI4 ; \nr = R4 ; \nbreak ; \ncase WORDS_8 : pi = PI8 ; \nrpi = RPI8 ; \nr = R8 ; \nbreak ; \ncase WORDS_16 : pi = PI16 ; \nrpi = RPI16 ; \nr = R16 ; \nbreak ; \ndefault : throw new RuntimeException ( \"Invalid threefish key\" ) ; \n} \nthis . k = new long [ nw + 1 ] ; \nvd = new long [ nw ] ; \ned = new long [ nw ] ; \nfd = new long [ nw ] ; \nksd = new long [ nw ] ; \n} \nSystem . arraycopy ( key , 0 , this . k , 0 , key . length ) ; \nlong knw = EXTENDED_KEY_SCHEDULE_CONST ; \n{ \nint i = 0 ; \nwhile ( i < nw ) { \nknw ^= this . k [ i ] ; \ni ++ ; \n} \n} \nthis . k [ nw ] = knw ; \nt [ 0 ] = tweak [ 0 ] ; \nt [ 1 ] = tweak [ 1 ] ; \nt [ 2 ] = t [ 0 ] ^ t [ 1 ] ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \n{ \nint i = 0 ; \nwhile ( i < nw ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 2 ) { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"950": "public class Threefish { \nprotected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { \nlong [ ] result = new long [ size >> 3 ] ; \nint i8 = offset ; \n{ \nint i = 0 ; \nwhile ( i < result . length ) { \nresult [ i ] = Bits . getLong ( ba , i8 ) ; \ni8 += 8 ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"973": "public class ClassReader { \nprivate int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { \nchar [ ] charBuffer = new char [ maxStringLength ] ; \nint currentAttributeOffset = getFirstAttributeOffset ( ) ; \nint [ ] currentBootstrapMethodOffsets = null ; \n{ \nint i = readUnsignedShort ( currentAttributeOffset - 2 ) ; \nwhile ( i > 0 ) { \nString attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; \nint attributeLength = readInt ( currentAttributeOffset + 2 ) ; \ncurrentAttributeOffset += 6 ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \ncurrentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; \nint currentBootstrapMethodOffset = currentAttributeOffset + 2 ; \n{ \nint j = 0 ; \nwhile ( j < currentBootstrapMethodOffsets . length ) { \ncurrentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; \ncurrentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; \n++ j ; \n} \n} \nreturn currentBootstrapMethodOffsets ; \n} \ncurrentAttributeOffset += attributeLength ; \n-- i ; \n} \n} \nreturn null ; \n} \n} \n"}
{"974": "public class Ctors { \nprotected CtorDescriptor [ ] inspectConstructors ( ) { \nClass type = classDescriptor . getType ( ) ; \nConstructor [ ] ctors = type . getDeclaredConstructors ( ) ; \nCtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; \n{ \nint i = 0 ; \nwhile ( i < ctors . length ) { \nConstructor ctor = ctors [ i ] ; \nCtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; \nallCtors [ i ] = ctorDescriptor ; \nif ( ctorDescriptor . isDefault ( ) ) { \ndefaultCtor = ctorDescriptor ; \n} \ni ++ ; \n} \n} \nreturn allCtors ; \n} \n} \n"}
{"975": "public class Ctors { \npublic CtorDescriptor getCtorDescriptor ( final Class ... args ) { \nctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { \nClass [ ] arg = ctorDescriptor . getParameters ( ) ; \nif ( arg . length != args . length ) { \ncontinue ; \n} \n{ \nint j = 0 ; \nwhile ( j < arg . length ) { \nif ( arg [ j ] != args [ j ] ) { \n{ \nj ++ ; \ncontinue ctors ; \n} \n} \nj ++ ; \n} \n} \nreturn ctorDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"978": "public class LongArrayConverter { \nprotected long [ ] convertArrayToArray ( final Object value ) { \nfinal Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; \nfinal long [ ] result ; \nif ( valueComponentType . isPrimitive ( ) ) { \nresult = convertPrimitiveArrayToArray ( value , valueComponentType ) ; \n} \nelse { \nfinal Object [ ] array = ( Object [ ] ) value ; \nresult = new long [ array . length ] ; \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nresult [ i ] = convertType ( array [ i ] ) ; \ni ++ ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"993": "public class Type { \npublic String getClassName ( ) { \nswitch ( sort ) { \ncase VOID : return \"void\" ; \ncase BOOLEAN : return \"boolean\" ; \ncase CHAR : return \"char\" ; \ncase BYTE : return \"byte\" ; \ncase SHORT : return \"short\" ; \ncase INT : return \"int\" ; \ncase FLOAT : return \"float\" ; \ncase LONG : return \"long\" ; \ncase DOUBLE : return \"double\" ; \ncase ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; \n{ \nint i = getDimensions ( ) ; \nwhile ( i > 0 ) { \nstringBuilder . append ( \"[]\" ) ; \n-- i ; \n} \n} \nreturn stringBuilder . toString ( ) ; \ncase OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nint len = value . length ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( strictStringEncoding ) { \nwrite ( \"\\\\/\" ) ; \n} \nelse { \nwrite ( c ) ; \n} \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( Character . isISOControl ( c ) ) { \nunicode ( c ) ; \n} \nelse { \nwrite ( c ) ; \n} \n} \ni ++ ; \n} \n} \nwrite ( StringPool . QUOTE ) ; \n} \n} \n"}
{"1006": "public class JsonWriter { \nprotected void unicode ( final char c ) { \nwrite ( \"\\\\u\" ) ; \nint n = c ; \n{ \nint i = 0 ; \nwhile ( i < 4 ) { \nint digit = ( n & 0xf000 ) >> 12 ; \nchar hex = CharUtil . int2hex ( digit ) ; \nwrite ( hex ) ; \nn <<= 4 ; \n++ i ; \n} \n} \n} \n} \n"}
{"1013": "public class ProxettaClassBuilder { \n@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \nwd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; \naccess &= ~ AsmUtil . ACC_ABSTRACT ; \nfinal int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; \nwd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; \nwd . proxyAspects = new ProxyAspectData [ aspects . length ] ; \n{ \nint i = 0 ; \nwhile ( i < aspects . length ) { \nwd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1024": "public class SqlTypeManager { \npublic SqlType lookup ( final Class clazz ) { \nSqlType sqlType ; \n{ \nClass x = clazz ; \nwhile ( x != null ) { \nsqlType = types . get ( clazz ) ; \nif ( sqlType != null ) { \nreturn sqlType ; \n} \nClass [ ] interfaces = x . getInterfaces ( ) ; \nfor ( Class i : interfaces ) { \nsqlType = types . get ( i ) ; \nif ( sqlType != null ) { \nreturn sqlType ; \n} \n} \nx = x . getSuperclass ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) { \nreturn StringPool . NULL ; \n} \nfinal Class < ? > type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( componentType == int . class ) { \nsb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \n} \nelse if ( componentType == long . class ) { \nsb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \n} \nelse if ( componentType == double . class ) { \nsb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \n} \nelse if ( componentType == float . class ) { \nsb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \n} \nelse if ( componentType == boolean . class ) { \nsb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \n} \nelse if ( componentType == short . class ) { \nsb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \n} \nelse if ( componentType == byte . class ) { \nsb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( array [ i ] ) ) ; \ni ++ ; \n} \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse if ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nint i = 0 ; \nfor ( final Object o : iterable ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( o ) ) ; \ni ++ ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal int length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ch == separator ) { \nupperCase = true ; \n} \nelse if ( upperCase ) { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse { \nsb . append ( ch ) ; \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1041": "public class Format { \npublic static String escapeJava ( final String string ) { \nint strLen = string . length ( ) ; \nStringBuilder sb = new StringBuilder ( strLen ) ; \n{ \nint i = 0 ; \nwhile ( i < strLen ) { \nchar c = string . charAt ( i ) ; \nswitch ( c ) { \ncase '\\b' : sb . append ( \"\\\\b\" ) ; \nbreak ; \ncase '\\t' : sb . append ( \"\\\\t\" ) ; \nbreak ; \ncase '\\n' : sb . append ( \"\\\\n\" ) ; \nbreak ; \ncase '\\f' : sb . append ( \"\\\\f\" ) ; \nbreak ; \ncase '\\r' : sb . append ( \"\\\\r\" ) ; \nbreak ; \ncase '\\\"' : sb . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : sb . append ( \"\\\\\\\\\" ) ; \nbreak ; \ndefault : if ( ( c < 32 ) || ( c > 127 ) ) { \nString hex = Integer . toHexString ( c ) ; \nsb . append ( \"\\\\u\" ) ; \n{ \nint k = hex . length ( ) ; \nwhile ( k < 4 ) { \nsb . append ( '0' ) ; \nk ++ ; \n} \n} \nsb . append ( hex ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1042": "public class Format { \npublic static String unescapeJava ( final String str ) { \nchar [ ] chars = str . toCharArray ( ) ; \nStringBuilder sb = new StringBuilder ( str . length ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < chars . length ) { \nchar c = chars [ i ] ; \nif ( c != '\\\\' ) { \nsb . append ( c ) ; \n{ \ni ++ ; \ncontinue ; \n} \n} \ni ++ ; \nc = chars [ i ] ; \nswitch ( c ) { \ncase 'b' : sb . append ( '\\b' ) ; \nbreak ; \ncase 't' : sb . append ( '\\t' ) ; \nbreak ; \ncase 'n' : sb . append ( '\\n' ) ; \nbreak ; \ncase 'f' : sb . append ( '\\f' ) ; \nbreak ; \ncase 'r' : sb . append ( '\\r' ) ; \nbreak ; \ncase '\"' : sb . append ( '\\\"' ) ; \nbreak ; \ncase '\\\\' : sb . append ( '\\\\' ) ; \nbreak ; \ncase 'u' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; \nsb . append ( hex ) ; \ni += 4 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Invalid escaping character: \" + c ) ; \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1062": "public class IteratorTag { \nprotected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nint len = array . length ; \nint to = calculateTo ( from , count , len ) ; \nint last = to - 1 ; \n{ \nint i = from ; \nwhile ( i < to ) { \nObject item = array [ i ] ; \nif ( status != null ) { \niteratorStatus . next ( i == last ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1064": "public class StringUtil { \npublic static String replaceChar ( final String s , final char sub , final char with ) { \nint startIndex = s . indexOf ( sub ) ; \nif ( startIndex == - 1 ) { \nreturn s ; \n} \nchar [ ] str = s . toCharArray ( ) ; \n{ \nint i = startIndex ; \nwhile ( i < str . length ) { \nif ( str [ i ] == sub ) { \nstr [ i ] = with ; \n} \ni ++ ; \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1065": "public class StringUtil { \npublic static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { \nchar [ ] str = s . toCharArray ( ) ; \n{ \nint i = 0 ; \nwhile ( i < str . length ) { \nchar c = str [ i ] ; \n{ \nint j = 0 ; \nwhile ( j < sub . length ) { \nif ( c == sub [ j ] ) { \nstr [ i ] = with [ j ] ; \nbreak ; \n} \nj ++ ; \n} \n} \ni ++ ; \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1071": "public class StringUtil { \npublic static String remove ( final String string , final char ch ) { \nint stringLen = string . length ( ) ; \nchar [ ] result = new char [ stringLen ] ; \nint offset = 0 ; \n{ \nint i = 0 ; \nwhile ( i < stringLen ) { \nchar c = string . charAt ( i ) ; \nif ( c == ch ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nresult [ offset ] = c ; \noffset ++ ; \ni ++ ; \n} \n} \nif ( offset == stringLen ) { \nreturn string ; \n} \nreturn new String ( result , 0 , offset ) ; \n} \n} \n"}
{"1076": "public class StringUtil { \npublic static String title ( final String string ) { \nchar [ ] chars = string . toCharArray ( ) ; \nboolean wasWhitespace = true ; \n{ \nint i = 0 ; \nwhile ( i < chars . length ) { \nchar c = chars [ i ] ; \nif ( CharUtil . isWhitespace ( c ) ) { \nwasWhitespace = true ; \n} \nelse { \nif ( wasWhitespace ) { \nchars [ i ] = Character . toUpperCase ( c ) ; \n} \nelse { \nchars [ i ] = Character . toLowerCase ( c ) ; \n} \nwasWhitespace = false ; \n} \ni ++ ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1077": "public class StringUtil { \npublic static String compressChars ( final String s , final char c ) { \nint len = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( len ) ; \nboolean wasChar = false ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c1 = s . charAt ( i ) ; \nif ( c1 == c ) { \nif ( wasChar ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nwasChar = true ; \n} \nelse { \nwasChar = false ; \n} \nsb . append ( c1 ) ; \ni ++ ; \n} \n} \nif ( sb . length ( ) == len ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1081": "public class StringUtil { \npublic static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { \nif ( as . length != as1 . length ) { \nreturn false ; \n} \n{ \nint i = 0 ; \nwhile ( i < as . length ) { \nif ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1082": "public class StringUtil { \npublic static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { \n{ \nint i = startindex ; \nwhile ( i < endindex ) { \nif ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1088": "public class StringUtil { \npublic static void cropAll ( final String ... strings ) { \n{ \nint i = 0 ; \nwhile ( i < strings . length ) { \nString string = strings [ i ] ; \nif ( string != null ) { \nstring = crop ( strings [ i ] ) ; \n} \nstrings [ i ] = string ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1092": "public class StringUtil { \npublic static String join ( final Collection collection , final char separator ) { \nif ( collection == null ) { \nreturn null ; \n} \nif ( collection . size ( ) == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; \nfinal Iterator it = collection . iterator ( ) ; \n{ \nint i = 0 ; \nwhile ( i < collection . size ( ) ) { \nif ( i > 0 ) { \nsb . append ( separator ) ; \n} \nsb . append ( it . next ( ) ) ; \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1093": "public class StringUtil { \npublic static String join ( final Object [ ] array , final String separator ) { \nif ( array == null ) { \nreturn null ; \n} \nif ( array . length == 0 ) { \nreturn StringPool . EMPTY ; \n} \nif ( array . length == 1 ) { \nreturn String . valueOf ( array [ 0 ] ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( array . length * 16 ) ; \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( i > 0 ) { \nsb . append ( separator ) ; \n} \nsb . append ( array [ i ] ) ; \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1106": "public class StringUtil { \npublic static String reverse ( final String s ) { \nStringBuilder result = new StringBuilder ( s . length ( ) ) ; \n{ \nint i = s . length ( ) - 1 ; \nwhile ( i >= 0 ) { \nresult . append ( s . charAt ( i ) ) ; \ni -- ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1107": "public class StringUtil { \npublic static String maxCommonPrefix ( final String one , final String two ) { \nfinal int minLength = Math . min ( one . length ( ) , two . length ( ) ) ; \nfinal StringBuilder sb = new StringBuilder ( minLength ) ; \n{ \nint pos = 0 ; \nwhile ( pos < minLength ) { \nfinal char currentChar = one . charAt ( pos ) ; \nif ( currentChar != two . charAt ( pos ) ) { \nbreak ; \n} \nsb . append ( currentChar ) ; \npos ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \n{ \nint i = 0 ; \nwhile ( i < strings . length ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( i == 0 ) { \nc = s . charAt ( index ) ; \n} \nelse { \nif ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \ni ++ ; \n} \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1109": "public class StringUtil { \npublic static String shorten ( String s , int length , final String suffix ) { \nlength -= suffix . length ( ) ; \nif ( s . length ( ) > length ) { \n{ \nint j = length ; \nwhile ( j >= 0 ) { \nif ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { \nlength = j ; \nbreak ; \n} \nj -- ; \n} \n} \nString temp = s . substring ( 0 , length ) ; \ns = temp . concat ( suffix ) ; \n} \nreturn s ; \n} \n} \n"}
{"1110": "public class StringUtil { \npublic static String toUpperCase ( final String s , Locale locale ) { \nif ( s == null ) { \nreturn null ; \n} \nStringBuilder sb = null ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nchar c = s . charAt ( i ) ; \nif ( c > 127 ) { \nif ( locale == null ) { \nlocale = Locale . getDefault ( ) ; \n} \nreturn s . toUpperCase ( locale ) ; \n} \nif ( ( c >= 'a' ) && ( c <= 'z' ) ) { \nif ( sb == null ) { \nsb = new StringBuilder ( s ) ; \n} \nsb . setCharAt ( i , ( char ) ( c - 32 ) ) ; \n} \ni ++ ; \n} \n} \nif ( sb == null ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \n{ \nint i = 0 ; \nwhile ( i < textLength ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) { \nif ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse { \n{ \ni ++ ; \ncontinue ; \n} \n} \n} \nelse { \nregularChar = true ; \n} \ndest [ ndx ] = c ; \nndx ++ ; \ni ++ ; \n} \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \nelse { \nstrippedCharsCount += textLength ; \n} \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nwhile ( ! nodes . isEmpty ( ) ) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nint childCount = node . getChildNodesCount ( ) ; \n{ \nint i = childCount - 1 ; \nwhile ( i >= 0 ) { \nnodes . addFirst ( node . getChild ( i ) ) ; \ni -- ; \n} \n} \n} \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nint childCount = rootNode . getChildNodesCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < childCount ) { \nnodes . add ( rootNode . getChild ( i ) ) ; \ni ++ ; \n} \n} \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < childCount ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \ni ++ ; \n} \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) { \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nwhile ( true ) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) { \nbreak ; \n} \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \n} \n} \n"}
{"1154": "public class HtmlDecoder { \npublic static String detectName ( final char [ ] input , int ndx ) { \nfinal Ptr ptr = new Ptr ( ) ; \nint firstIndex = 0 ; \nint lastIndex = ENTITY_NAMES . length - 1 ; \nint len = input . length ; \nchar [ ] lastName = null ; \nfinal BinarySearchBase binarySearch = new BinarySearchBase ( ) { \n@ Override protected int compare ( final int index ) { \nchar [ ] name = ENTITY_NAMES [ index ] ; \nif ( ptr . offset >= name . length ) { \nreturn - 1 ; \n} \nreturn name [ ptr . offset ] - ptr . c ; \n} \n} \n; \nwhile ( true ) { \nptr . c = input [ ndx ] ; \nif ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nfirstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; \nif ( firstIndex < 0 ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nchar [ ] element = ENTITY_NAMES [ firstIndex ] ; \nif ( element . length == ptr . offset + 1 ) { \nlastName = ENTITY_NAMES [ firstIndex ] ; \n} \nlastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; \nif ( firstIndex == lastIndex ) { \n{ \nint i = ptr . offset ; \nwhile ( i < element . length ) { \nif ( element [ i ] != input [ ndx ] ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nndx ++ ; \ni ++ ; \n} \n} \nreturn new String ( element ) ; \n} \nptr . offset ++ ; \nndx ++ ; \nif ( ndx == len ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \n} \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( newIndex > index ) { \n{ \nint i = index ; \nwhile ( i < newIndex ) { \narray [ i ] = StringPool . EMPTY ; \ni ++ ; \n} \n} \n} \nelse if ( newIndex < index ) { \n{ \nint i = newIndex ; \nwhile ( i < index ) { \narray [ i ] = null ; \ni ++ ; \n} \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1168": "public class StringBand { \nprotected int calculateLength ( ) { \nint len = 0 ; \n{ \nint i = 0 ; \nwhile ( i < index ) { \nlen += array [ i ] . length ( ) ; \ni ++ ; \n} \n} \nreturn len ; \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers && lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) { \n{ \nint i = 1 ; \nwhile ( i <= otherLineNumbers [ 0 ] ) { \nmethodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n++ i ; \n} \n} \n} \n} \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \n{ \nint i = forwardReferences [ 0 ] ; \nwhile ( i > 0 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \ni -= 2 ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1234": "public class NaturalOrderComparator { \nprivate char fixAccent ( final char c ) { \n{ \nint i = 0 ; \nwhile ( i < ACCENT_CHARS . length ) { \nfinal char accentChar = ACCENT_CHARS [ i ] ; \nif ( accentChar == c ) { \nreturn ACCENT_CHARS [ i + 1 ] ; \n} \ni += 2 ; \n} \n} \nreturn c ; \n} \n} \n"}
{"1272": "public class ExceptionUtil { \npublic static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { \nArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; \nwhile ( t != null ) { \nStackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; \nresult . add ( stack ) ; \nt = t . getCause ( ) ; \n} \nStackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; \n{ \nint i = 0 ; \nwhile ( i < allStacks . length ) { \nallStacks [ i ] = result . get ( i ) ; \ni ++ ; \n} \n} \nreturn allStacks ; \n} \n} \n"}
{"1304": "public class URLCoder { \nprivate static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { \nif ( source == null ) { \nreturn null ; \n} \nbyte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; \nchar [ ] chars = new char [ bytes . length ] ; \n{ \nint i = 0 ; \nwhile ( i < bytes . length ) { \nchars [ i ] = ( char ) bytes [ i ] ; \ni ++ ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1313": "public class Properties { \nprotected HashMap < String , PropertyDescriptor > inspectProperties ( ) { \nboolean scanAccessible = classDescriptor . isScanAccessible ( ) ; \nClass type = classDescriptor . getType ( ) ; \nHashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; \nMethod [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; \n{ \nint iteration = 0 ; \nwhile ( iteration < 2 ) { \nfor ( Method method : methods ) { \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) { \n{ \niteration ++ ; \ncontinue ; \n} \n} \nboolean add = false ; \nboolean issetter = false ; \nString propertyName ; \nif ( iteration == 0 ) { \npropertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = false ; \n} \n} \nelse { \npropertyName = ClassUtil . getBeanPropertySetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = true ; \n} \n} \nif ( add ) { \nMethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; \naddProperty ( map , propertyName , methodDescriptor , issetter ) ; \n} \n} \niteration ++ ; \n} \n} \nif ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { \nFieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; \nString [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; \nfor ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { \nField field = fieldDescriptor . getField ( ) ; \nif ( Modifier . isStatic ( field . getModifiers ( ) ) ) { \ncontinue ; \n} \nString name = field . getName ( ) ; \nif ( prefix != null ) { \nfor ( String p : prefix ) { \nif ( ! name . startsWith ( p ) ) { \ncontinue ; \n} \nname = name . substring ( p . length ( ) ) ; \nbreak ; \n} \n} \nif ( ! map . containsKey ( name ) ) { \nmap . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; \n} \n} \n} \nreturn map ; \n} \n} \n"}
{"1320": "public class BlockCipher { \npublic byte [ ] encrypt ( final byte [ ] content ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = content . length + 1 ; \nint blockCount = length / blockSizeInBytes ; \nint remaining = length ; \nint offset = 0 ; \n{ \nint i = 0 ; \nwhile ( i < blockCount ) { \nif ( remaining == blockSizeInBytes ) { \nbreak ; \n} \nbyte [ ] encrypted = encryptBlock ( content , offset ) ; \nfbb . append ( encrypted ) ; \noffset += blockSizeInBytes ; \nremaining -= blockSizeInBytes ; \ni ++ ; \n} \n} \nif ( remaining != 0 ) { \nbyte [ ] block = new byte [ blockSizeInBytes ] ; \nSystem . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; \nblock [ remaining - 1 ] = TERMINATOR ; \nbyte [ ] encrypted = encryptBlock ( block , 0 ) ; \nfbb . append ( encrypted ) ; \n} \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = encryptedContent . length ; \nint blockCount = length / blockSizeInBytes ; \nint offset = 0 ; \n{ \nint i = 0 ; \nwhile ( i < blockCount - 1 ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset += blockSizeInBytes ; \ni ++ ; \n} \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nint ndx = blockSizeInBytes - 1 ; \nwhile ( ndx >= 0 ) { \nif ( decrypted [ ndx ] == TERMINATOR ) { \nbreak ; \n} \nndx -- ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1323": "public class MapToBean { \nprivate Object generifyList ( final List list , final Class componentType ) { \n{ \nint i = 0 ; \nwhile ( i < list . size ( ) ) { \nObject element = list . get ( i ) ; \nif ( element != null ) { \nif ( element instanceof Map ) { \nObject bean = map2bean ( ( Map ) element , componentType ) ; \nlist . set ( i , bean ) ; \n} \nelse { \nObject value = convert ( element , componentType ) ; \nlist . set ( i , value ) ; \n} \n} \ni ++ ; \n} \n} \nreturn list ; \n} \n} \n"}
{"1369": "public class DefaultResultSetMapper { \nprotected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { \nif ( cachedMappedNames == null ) { \nString [ ] [ ] names = new String [ types . length ] [ ] ; \n{ \nint i = 0 ; \nwhile ( i < types . length ) { \nClass type = types [ i ] ; \nif ( type != null ) { \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded != null ) { \nClass [ ] mappedTypes = ded . getMappedTypes ( ) ; \nif ( mappedTypes != null ) { \nnames [ i ] = createTypesTableNames ( mappedTypes ) ; \n} \n} \n} \ni ++ ; \n} \n} \ncachedMappedNames = names ; \n} \nreturn cachedMappedNames ; \n} \n} \n"}
{"1370": "public class DefaultResultSetMapper { \nprotected String [ ] createTypesTableNames ( final Class [ ] types ) { \nString [ ] names = new String [ types . length ] ; \n{ \nint i = 0 ; \nwhile ( i < types . length ) { \nif ( types [ i ] == null ) { \nnames [ i ] = null ; \n{ \ni ++ ; \ncontinue ; \n} \n} \nDbEntityDescriptor ded = dbEntityManager . lookupType ( types [ i ] ) ; \nif ( ded != null ) { \nString tableName = ded . getTableName ( ) ; \ntableName = tableName . toUpperCase ( ) ; \nnames [ i ] = tableName ; \n} \ni ++ ; \n} \n} \nreturn names ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) { \nentitiesCache = new HashMap < > ( ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < result . length ) { \nObject object = result [ i ] ; \nif ( object == null ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nObject key ; \nif ( ded . hasIdColumn ( ) ) { \nkey = ded . getKeyValue ( object ) ; \n} \nelse { \nkey = object ; \n} \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( cachedObject == null ) { \nentitiesCache . put ( key , object ) ; \n} \nelse { \nresult [ i ] = cachedObject ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"1416": "public class Scanner { \npublic final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { \nif ( ndx + uppercaseTarget . length > total ) { \nreturn false ; \n} \nint j = ndx ; \n{ \nint i = 0 ; \nwhile ( i < uppercaseTarget . length ) { \nfinal char c = CharUtil . toUpperAscii ( input [ j ] ) ; \nif ( c != uppercaseTarget [ i ] ) { \nreturn false ; \n} \nj ++ ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1433": "public class HttpUtil { \npublic static String prepareHeaderParameterName ( final String headerName ) { \nif ( headerName . equals ( \"etag\" ) ) { \nreturn HttpBase . HEADER_ETAG ; \n} \nif ( headerName . equals ( \"www-authenticate\" ) ) { \nreturn \"WWW-Authenticate\" ; \n} \nchar [ ] name = headerName . toCharArray ( ) ; \nboolean capitalize = true ; \n{ \nint i = 0 ; \nwhile ( i < name . length ) { \nchar c = name [ i ] ; \nif ( c == '-' ) { \ncapitalize = true ; \n{ \ni ++ ; \ncontinue ; \n} \n} \nif ( capitalize ) { \nname [ i ] = Character . toUpperCase ( c ) ; \ncapitalize = false ; \n} \nelse { \nname [ i ] = Character . toLowerCase ( c ) ; \n} \ni ++ ; \n} \n} \nreturn new String ( name ) ; \n} \n} \n"}
{"1456": "public class ReferencesResolver { \npublic BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { \nPetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; \nfinal Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; \nBeanReferences [ ] references ; \nfinal boolean hasAnnotationOnMethodOrCtor ; \nif ( petiteInject != null ) { \nreferences = convertAnnValueToReferences ( petiteInject . value ( ) ) ; \nhasAnnotationOnMethodOrCtor = true ; \n} \nelse { \nreferences = new BeanReferences [ parameters . length ] ; \nhasAnnotationOnMethodOrCtor = false ; \n} \nint parametersWithAnnotationCount = 0 ; \n{ \nint i = 0 ; \nwhile ( i < parameters . length ) { \nParameter parameter = parameters [ i ] ; \npetiteInject = parameter . getAnnotation ( PetiteInject . class ) ; \nif ( petiteInject == null ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nString annotationValue = readAnnotationValue ( petiteInject ) ; \nif ( annotationValue != null ) { \nreferences [ i ] = BeanReferences . of ( annotationValue ) ; \n} \nparametersWithAnnotationCount ++ ; \ni ++ ; \n} \n} \nif ( ! hasAnnotationOnMethodOrCtor ) { \nif ( parametersWithAnnotationCount == 0 ) { \nreturn null ; \n} \nif ( parametersWithAnnotationCount != parameters . length ) { \nthrow new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; \n} \n} \nreferences = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1457": "public class ReferencesResolver { \nprivate BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { \nfinal boolean useParamo = petiteConfig . getUseParamo ( ) ; \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nMethodParameter [ ] methodParameters = null ; \nif ( useParamo ) { \nmethodParameters = Paramo . resolveParameters ( methodOrCtor ) ; \n} \nfinal Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; \nfinal BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; \n{ \nint j = 0 ; \nwhile ( j < paramTypes . length ) { \nString [ ] ref = new String [ lookupReferences . length ] ; \nreferences [ j ] = BeanReferences . of ( ref ) ; \n{ \nint i = 0 ; \nwhile ( i < ref . length ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; \nbreak ; \ncase TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; \nbreak ; \n} \ni ++ ; \n} \n} \nj ++ ; \n} \n} \nreturn references ; \n} \n} \n"}
{"1458": "public class ReferencesResolver { \npublic BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nfinal String [ ] references = new String [ lookupReferences . length ] ; \n{ \nint i = 0 ; \nwhile ( i < references . length ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : references [ i ] = propertyDescriptor . getName ( ) ; \nbreak ; \ncase TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; \nbreak ; \n} \ni ++ ; \n} \n} \nreturn BeanReferences . of ( references ) ; \n} \n} \n"}
{"1459": "public class ReferencesResolver { \nprivate void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { \n{ \nint i = 0 ; \nwhile ( i < allBeanReferences . length ) { \nBeanReferences references = allBeanReferences [ i ] ; \nallBeanReferences [ i ] = references . removeDuplicateNames ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1460": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { \nif ( references == null ) { \nreturn null ; \n} \nBeanReferences [ ] ref = new BeanReferences [ references . length ] ; \n{ \nint i = 0 ; \nwhile ( i < references . length ) { \nref [ i ] = BeanReferences . of ( references [ i ] ) ; \ni ++ ; \n} \n} \nreturn ref ; \n} \n} \n"}
{"1461": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertAnnValueToReferences ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nvalue = value . trim ( ) ; \nif ( value . length ( ) == 0 ) { \nreturn null ; \n} \nString [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; \nBeanReferences [ ] references = new BeanReferences [ refNames . length ] ; \n{ \nint i = 0 ; \nwhile ( i < refNames . length ) { \nreferences [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; \ni ++ ; \n} \n} \nreturn references ; \n} \n} \n"}
{"1466": "public class ClassUtil { \npublic static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { \nif ( first . length != second . length ) { \nreturn false ; \n} \n{ \nint i = 0 ; \nwhile ( i < first . length ) { \nif ( first [ i ] != second [ i ] ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1469": "public class ClassUtil { \npublic static Class [ ] getSuperclasses ( final Class type ) { \nint i = 0 ; \n{ \nClass x = type . getSuperclass ( ) ; \nwhile ( x != null ) { \ni ++ ; \nx = x . getSuperclass ( ) ; \n} \n} \nClass [ ] result = new Class [ i ] ; \ni = 0 ; \n{ \nClass x = type . getSuperclass ( ) ; \nwhile ( x != null ) { \nresult [ i ] = x ; \ni ++ ; \nx = x . getSuperclass ( ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"1497": "public class ArraysUtil { \npublic static int indexOf ( char [ ] array , char value ) { \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( array [ i ] == value ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1498": "public class ArraysUtil { \npublic static int indexOf ( Object [ ] array , Object value ) { \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( array [ i ] . equals ( value ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \n{ \nshort currentSubroutine = 1 ; \nwhile ( currentSubroutine <= numSubroutines ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n++ currentSubroutine ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null || sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \n{ \nint i = 0 , sourcesArrayLength = sourcesArray . length ; \nwhile ( i < sourcesArrayLength ) { \nsourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \ni ++ ; \n} \n} \nif ( sortResources ) { \nArrays . sort ( sourcesArray ) ; \n} \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId += '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1545": "public class AnnotationTxAdviceManager { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { \nthis . annotations = annotations ; \nthis . annotationParsers = new AnnotationParser [ annotations . length ] ; \n{ \nint i = 0 ; \nwhile ( i < annotations . length ) { \nannotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1547": "public class CssSelector { \n@ Override public boolean accept ( final Node node ) { \nif ( ! matchElement ( node ) ) { \nreturn false ; \n} \nint totalSelectors = selectorsCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < totalSelectors ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1549": "public class CssSelector { \npublic boolean accept ( final List < Node > currentResults , final Node node , final int index ) { \nint totalSelectors = selectorsCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < totalSelectors ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ndefault : } \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1552": "public class Node { \nprotected < T extends Node > T cloneTo ( final T dest ) { \ndest . parentNode = parentNode ; \nif ( attributes != null ) { \ndest . attributes = new ArrayList < > ( attributes . size ( ) ) ; \n{ \nint i = 0 , attributesSize = attributes . size ( ) ; \nwhile ( i < attributesSize ) { \nAttribute attr = attributes . get ( i ) ; \ndest . attributes . add ( attr . clone ( ) ) ; \ni ++ ; \n} \n} \n} \nif ( childNodes != null ) { \ndest . childNodes = new ArrayList < > ( childNodes . size ( ) ) ; \n{ \nint i = 0 , childNodesSize = childNodes . size ( ) ; \nwhile ( i < childNodesSize ) { \nNode child = childNodes . get ( i ) ; \nNode childClone = child . clone ( ) ; \nchildClone . parentNode = dest ; \ndest . childNodes . add ( childClone ) ; \ni ++ ; \n} \n} \n} \nreturn dest ; \n} \n} \n"}
{"1560": "public class Node { \npublic void removeAllChilds ( ) { \nList < Node > removedNodes = childNodes ; \nchildNodes = null ; \nchildElementNodes = null ; \nchildElementNodesCount = 0 ; \nif ( removedNodes != null ) { \n{ \nint i = 0 , removedNodesSize = removedNodes . size ( ) ; \nwhile ( i < removedNodesSize ) { \nNode removedNode = removedNodes . get ( i ) ; \nremovedNode . detachFromParent ( ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) { \nreturn true ; \n} \nint siblingElementIndex = 0 ; \n{ \nint i = 0 , childNodesSize = childNodes . size ( ) ; \nwhile ( i < childNodesSize ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) { \nreturn false ; \n} \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) { \nreturn false ; \n} \nsiblingElementIndex ++ ; \n} \ni ++ ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) { \nreturn false ; \n} \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) { \nreturn false ; \n} \nint childCount = getChildNodesCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < childCount ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nif ( childElementNodes [ child . siblingElementIndex ] != child ) { \nreturn false ; \n} \n} \ni ++ ; \n} \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \n{ \nint i = 0 , siblingsSize = siblings . size ( ) ; \nwhile ( i < siblingsSize ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nif ( sibling . siblingNameIndex != index ++ ) { \nreturn false ; \n} \n} \ni ++ ; \n} \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1564": "public class Node { \nprotected void initChildElementNodes ( ) { \nif ( childElementNodes == null ) { \nchildElementNodes = new Element [ childElementNodesCount ] ; \nint childCount = getChildNodesCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < childCount ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nchildElementNodes [ child . siblingElementIndex ] = ( Element ) child ; \n} \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \n{ \nint i = 0 , siblingsSize = siblings . size ( ) ; \nwhile ( i < siblingsSize ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nsibling . siblingNameIndex = index ++ ; \n} \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"1567": "public class Node { \nprotected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { \nnode . ownerDocument = ownerDocument ; \nint childCount = node . getChildNodesCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < childCount ) { \nNode child = node . getChild ( i ) ; \nchangeOwnerDocument ( child , ownerDocument ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1568": "public class Node { \npublic Node getPreviousSiblingName ( ) { \nif ( nodeName == null ) { \nreturn null ; \n} \ninitSiblingNames ( ) ; \nint index = siblingNameIndex - 1 ; \n{ \nint i = siblingIndex ; \nwhile ( i >= 0 ) { \nNode sibling = parentNode . childNodes . get ( i ) ; \nif ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nreturn sibling ; \n} \ni -- ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1572": "public class Node { \nprotected void visitChildren ( final NodeVisitor nodeVisitor ) { \nif ( childNodes != null ) { \n{ \nint i = 0 , childNodesSize = childNodes . size ( ) ; \nwhile ( i < childNodesSize ) { \nNode childNode = childNodes . get ( i ) ; \nchildNode . visit ( nodeVisitor ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"1578": "public class RootPackages { \npublic void addRootPackage ( final String rootPackage , String mapping ) { \nif ( packages == null ) { \npackages = new String [ 0 ] ; \n} \nif ( mappings == null ) { \nmappings = new String [ 0 ] ; \n} \nif ( mapping . length ( ) > 0 ) { \nif ( ! mapping . startsWith ( StringPool . SLASH ) ) { \nmapping = StringPool . SLASH + mapping ; \n} \nif ( mapping . endsWith ( StringPool . SLASH ) ) { \nmapping = StringUtil . substring ( mapping , 0 , - 1 ) ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < packages . length ) { \nif ( packages [ i ] . equals ( rootPackage ) ) { \nif ( mappings [ i ] . equals ( mapping ) ) { \nreturn ; \n} \nthrow new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; \n} \ni ++ ; \n} \n} \npackages = ArraysUtil . append ( packages , rootPackage ) ; \nmappings = ArraysUtil . append ( mappings , mapping ) ; \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) { \nreturn null ; \n} \nint ndx = - 1 ; \nint delta = Integer . MAX_VALUE ; \n{ \nint i = 0 ; \nwhile ( i < mappings . length ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( actionPath . equals ( mapping ) ) { \nfound = true ; \n} \nelse { \nmapping += StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) { \nfound = true ; \n} \n} \nif ( found ) { \nint distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( distance < delta ) { \nndx = i ; \ndelta = distance ; \n} \n} \ni ++ ; \n} \n} \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1582": "public class BeanReferences { \npublic BeanReferences removeDuplicateNames ( ) { \nif ( names . length < 2 ) { \nreturn this ; \n} \nint nullCount = 0 ; \n{ \nint i = 1 ; \nwhile ( i < names . length ) { \nString thisRef = names [ i ] ; \nif ( thisRef == null ) { \nnullCount ++ ; \n{ \ni ++ ; \ncontinue ; \n} \n} \n{ \nint j = 0 ; \nwhile ( j < i ) { \nif ( names [ j ] == null ) { \n{ \nj ++ ; \ncontinue ; \n} \n} \nif ( thisRef . equals ( names [ j ] ) ) { \nnames [ i ] = null ; \nbreak ; \n} \nj ++ ; \n} \n} \ni ++ ; \n} \n} \nif ( nullCount == 0 ) { \nreturn this ; \n} \nString [ ] newRefs = new String [ names . length - nullCount ] ; \nint ndx = 0 ; \nfor ( String name : names ) { \nif ( name == null ) { \ncontinue ; \n} \nnewRefs [ ndx ] = name ; \nndx ++ ; \n} \nreturn new BeanReferences ( newRefs ) ; \n} \n} \n"}
{"1587": "public class Targets { \npublic Object [ ] extractParametersValues ( ) { \nfinal Object [ ] values = new Object [ targets . length - 1 ] ; \n{ \nint i = 1 ; \nwhile ( i < targets . length ) { \nvalues [ i - 1 ] = targets [ i ] . value ( ) ; \ni ++ ; \n} \n} \nreturn values ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) { \nreturn new Target [ ] { \nactionTarget } \n; \n} \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \n{ \nint i = 0 ; \nwhile ( i < methodParams . length ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( methodParam . annotationType ( ) == null ) { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \nelse if ( methodParam . annotationType ( ) == Out . class ) { \nparamTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \n} \nelse { \nparamTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \n} \ntarget [ i + 1 ] = paramTarget ; \ni ++ ; \n} \n} \nreturn target ; \n} \n} \n"}
{"1604": "public class CharSequenceUtil { \npublic static boolean equalsOne ( final char c , final CharSequence match ) { \n{ \nint i = 0 ; \nwhile ( i < match . length ( ) ) { \nchar aMatch = match . charAt ( i ) ; \nif ( c == aMatch ) { \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1605": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { \n{ \nint i = index ; \nwhile ( i < source . length ( ) ) { \nif ( equalsOne ( source . charAt ( i ) , match ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1606": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final char [ ] source , final int index , final char match ) { \n{ \nint i = index ; \nwhile ( i < source . length ) { \nif ( source [ i ] == match ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \n{ \nint i = 0 ; \nwhile ( i < numLocal ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \n++ i ; \n} \n} \nwhile ( inputLocalIndex < inputLocals . length ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nint numStackTop = 0 ; \n{ \nint i = 0 ; \nwhile ( i < numStack ) { \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \n++ numStackTop ; \n} \n++ i ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \n{ \nint i = 0 ; \nwhile ( i < numStack ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \n++ i ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \n{ \nint i = 0 ; \nwhile ( i < initializationCount ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n++ i ; \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1641": "public class CharUtil { \npublic static byte [ ] toRawByteArray ( final char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length << 1 ] ; \n{ \nint i = 0 , bpos = 0 ; \nwhile ( i < carr . length ) { \nchar c = carr [ i ] ; \nbarr [ bpos ++ ] = ( byte ) ( ( c & 0xFF00 ) >> 8 ) ; \nbarr [ bpos ++ ] = ( byte ) ( c & 0x00FF ) ; \ni ++ ; \n} \n} \nreturn barr ; \n} \n} \n"}
{"1642": "public class CharUtil { \npublic static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { \n{ \nint i = index ; \nwhile ( i < source . length ) { \nif ( ! equalsOne ( source [ i ] , match ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \nreturn true ; \n} \n} \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sNdx >= sLen ) ) { \nwhile ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) { \npNdx ++ ; \n} \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) { \nreturn false ; \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nint i ; \npNdx ++ ; \n{ \ni = string . length ( ) ; \nwhile ( i >= sNdx ) { \nif ( match ( string , pattern , i , pNdx ) ) { \nreturn true ; \n} \ni -- ; \n} \n} \nreturn false ; \n} \n} \nelse { \nnextIsNotWildcard = false ; \n} \nif ( p != string . charAt ( sNdx ) ) { \nreturn false ; \n} \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nint i = 0 ; \nint len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nwhile ( i < ranges . length ) { \nint gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen += gap ; \nlens [ i ] = len ; \ni += 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( count -- > 0 ) { \nchar c = 0 ; \nint r = rnd . nextInt ( len ) ; \n{ \ni = 0 ; \nwhile ( i < ranges . length ) { \nif ( r < lens [ i ] ) { \nr += ranges [ i ] ; \nif ( i != 0 ) { \nr -= lens [ i - 2 ] ; \n} \nc = ( char ) r ; \nbreak ; \n} \ni += 2 ; \n} \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) { \nreturn false ; \n} \nint hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nchar c = data [ i ] ; \nint b = 0 ; \ndo { \nif ( c < '0' || c > '9' ) { \nreturn false ; \n} \nb = ( b * 10 + c ) - 48 ; \nif ( ++ i >= data . length ) { \nbreak ; \n} \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( b > 255 ) { \nreturn false ; \n} \nhitDots ++ ; \ni ++ ; \n} \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) { \nreturn ; \n} \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \n{ \nint i = 0 ; \nwhile ( i < generatedColumns . length ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \ni ++ ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! keyValues . getClass ( ) . isArray ( ) ) { \nBeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \n} \nelse { \n{ \nint i = 0 ; \nwhile ( i < properties . length ) { \nBeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"1751": "public class ActionMethodParamNameResolver { \npublic String [ ] resolveParamNames ( final Method actionClassMethod ) { \nMethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; \nString [ ] names = new String [ methodParameters . length ] ; \n{ \nint i = 0 ; \nwhile ( i < methodParameters . length ) { \nnames [ i ] = methodParameters [ i ] . getName ( ) ; \ni ++ ; \n} \n} \nreturn names ; \n} \n} \n"}
{"1765": "public class EmailFilter { \npublic EmailFilter and ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \n{ \nint i = 0 ; \nwhile ( i < emailFilters . length ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \ni ++ ; \n} \n} \nconcat ( new AndTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1766": "public class EmailFilter { \npublic EmailFilter or ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \n{ \nint i = 0 ; \nwhile ( i < emailFilters . length ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \ni ++ ; \n} \n} \nconcat ( new OrTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1770": "public class ByteArrayConverter { \nprotected byte [ ] convertValueToArray ( final Object value ) { \nif ( value instanceof Blob ) { \nfinal Blob blob = ( Blob ) value ; \ntry { \nfinal long length = blob . length ( ) ; \nif ( length > Integer . MAX_VALUE ) { \nthrow new TypeConversionException ( \"Blob is too big.\" ) ; \n} \nreturn blob . getBytes ( 1 , ( int ) length ) ; \n} \ncatch ( SQLException sex ) { \nthrow new TypeConversionException ( value , sex ) ; \n} \n} \nif ( value instanceof File ) { \ntry { \nreturn FileUtil . readBytes ( ( File ) value ) ; \n} \ncatch ( IOException ioex ) { \nthrow new TypeConversionException ( value , ioex ) ; \n} \n} \nif ( value instanceof Collection ) { \nfinal Collection collection = ( Collection ) value ; \nfinal byte [ ] target = new byte [ collection . size ( ) ] ; \nint i = 0 ; \nfor ( final Object element : collection ) { \ntarget [ i ] = convertType ( element ) ; \ni ++ ; \n} \nreturn target ; \n} \nif ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; \nfor ( final Object element : iterable ) { \nfinal byte convertedValue = convertType ( element ) ; \nbyteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; \n} \nfinal byte [ ] array = new byte [ byteArrayList . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < byteArrayList . size ( ) ) { \nfinal Byte b = byteArrayList . get ( i ) ; \narray [ i ] = b . byteValue ( ) ; \ni ++ ; \n} \n} \nreturn array ; \n} \nif ( value instanceof CharSequence ) { \nfinal String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; \nreturn convertArrayToArray ( strings ) ; \n} \nreturn convertToSingleElementArray ( value ) ; \n} \n} \n"}
{"1787": "public class PBKDF2Hash { \nprivate static byte [ ] fromHex ( final String hex ) { \nfinal byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; \n{ \nint i = 0 ; \nwhile ( i < binary . length ) { \nbinary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; \ni ++ ; \n} \n} \nreturn binary ; \n} \n} \n"}
{"1802": "public class CsvUtil { \npublic static String toCsvString ( final Object ... elements ) { \nStringBuilder line = new StringBuilder ( ) ; \nint last = elements . length - 1 ; \n{ \nint i = 0 ; \nwhile ( i < elements . length ) { \nif ( elements [ i ] == null ) { \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \n{ \ni ++ ; \ncontinue ; \n} \n} \nString field = elements [ i ] . toString ( ) ; \nint ndx = field . indexOf ( FIELD_SEPARATOR ) ; \nif ( ndx == - 1 ) { \nndx = field . indexOf ( FIELD_QUOTE ) ; \n} \nif ( ndx == - 1 ) { \nif ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) { \nndx = 1 ; \n} \n} \nif ( ndx == - 1 ) { \nndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; \n} \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nfield = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; \nline . append ( field ) ; \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \ni ++ ; \n} \n} \nreturn line . toString ( ) ; \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \nelse if ( c == FIELD_QUOTE ) { \nif ( inQuotedField ) { \nif ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \n} \nelse if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \n} \ni ++ ; \n} \n} \nif ( len > 0 && fieldStart <= len ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \n{ \nint n = 0 ; \nwhile ( n < name . length ( ) ) { \nchar c = name . charAt ( n ) ; \nif ( c <= 0x20 || c >= 0x7f ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nn ++ ; \n} \n} \nthis . name = name ; \n} \n} \n"}
{"1860": "public class ClusterControl { \npublic static AtomicCounter findControlToggle ( final CountersReader counters ) { \nfinal AtomicBuffer buffer = counters . metaDataBuffer ( ) ; \n{ \nint i = 0 , size = counters . maxCounterId ( ) ; \nwhile ( i < size ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { \nreturn new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1897": "public class ClusterMember { \npublic static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \n{ \nint i = 0 , length = clusterMembers . length ; \nwhile ( i < length ) { \nfinal ClusterMember member = clusterMembers [ i ] ; \nbuilder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; \nif ( ( length - 1 ) != i ) { \nbuilder . append ( '|' ) ; \n} \ni ++ ; \n} \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"1901": "public class ClusterMember { \npublic static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { \nfinal int length = rankedPositions . length ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nrankedPositions [ i ] = 0 ; \ni ++ ; \n} \n} \nfor ( final ClusterMember member : members ) { \nlong newPosition = member . logPosition ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nfinal long rankedPosition = rankedPositions [ i ] ; \nif ( newPosition > rankedPosition ) { \nrankedPositions [ i ] = newPosition ; \nnewPosition = rankedPosition ; \n} \ni ++ ; \n} \n} \n} \nreturn rankedPositions [ length - 1 ] ; \n} \n} \n"}
{"1912": "public class ClusterMember { \npublic static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { \nfinal int length = clusterMembers . length ; \nint index = ArrayUtil . UNKNOWN_INDEX ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nif ( clusterMembers [ i ] . id ( ) == memberId ) { \nindex = i ; \n} \ni ++ ; \n} \n} \nreturn index ; \n} \n} \n"}
{"1926": "public class RecordingPos { \npublic static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \n{ \nint i = 0 , size = countersReader . maxCounterId ( ) ; \nwhile ( i < size ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { \nreturn i ; \n} \n} \ni ++ ; \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1927": "public class RecordingPos { \npublic static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \n{ \nint i = 0 , size = countersReader . maxCounterId ( ) ; \nwhile ( i < size ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { \nreturn i ; \n} \n} \ni ++ ; \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1932": "public class RecordingLog { \npublic Entry findLastTerm ( ) { \n{ \nint i = entries . size ( ) - 1 ; \nwhile ( i >= 0 ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nreturn entry ; \n} \ni -- ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nint index = - 1 ; \n{ \nint i = 0 , size = entries . size ( ) ; \nwhile ( i < size ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nindexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \n} \nbreak ; \n} \ni ++ ; \n} \n} \nif ( - 1 == index ) { \nthrow new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \n} \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { \nthrow new ClusterException ( \"failed to write field atomically\" ) ; \n} \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1957": "public class RecoveryState { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { \ntempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; \ntempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; \ntempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; \ntempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; \nfinal int serviceCount = snapshotRecordingIds . length ; \ntempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; \nfinal int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; \nif ( keyLength > MAX_KEY_LENGTH ) { \nthrow new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < serviceCount ) { \ntempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; \ni ++ ; \n} \n} \nfinal int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; \nint labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; \nlabelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; \nreturn aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1958": "public class RecoveryState { \npublic static int findCounterId ( final CountersReader counters ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \n{ \nint i = 0 , size = counters . maxCounterId ( ) ; \nwhile ( i < size ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nreturn i ; \n} \n} \ni ++ ; \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1961": "public class HeaderFlyweight { \npublic static char [ ] flagsToChars ( final short flags ) { \nfinal char [ ] chars = new char [ ] { \n'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } \n; \nfinal int length = chars . length ; \nshort mask = ( short ) ( 1 << ( length - 1 ) ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nif ( ( flags & mask ) == mask ) { \nchars [ i ] = '1' ; \n} \nmask >>= 1 ; \ni ++ ; \n} \n} \nreturn chars ; \n} \n} \n"}
{"1971": "public class ServiceHeartbeat { \npublic static int findCounterId ( final CountersReader counters , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \n{ \nint i = 0 , size = counters . maxCounterId ( ) ; \nwhile ( i < size ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { \nreturn i ; \n} \n} \ni ++ ; \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1977": "public class CapacityByteArrayOutputStream { \npublic void setByte ( long index , byte value ) { \ncheckArgument ( index < bytesUsed , \"Index: \" + index + \" is >= the current size of: \" + bytesUsed ) ; \nlong seen = 0 ; \n{ \nint i = 0 ; \nwhile ( i < slabs . size ( ) ) { \nByteBuffer slab = slabs . get ( i ) ; \nif ( index < seen + slab . limit ( ) ) { \nslab . put ( ( int ) ( index - seen ) , value ) ; \nbreak ; \n} \nseen += slab . limit ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"1982": "public class GlobParser { \nprivate static String annotateMessage ( String message , int pos ) { \nStringBuilder sb = new StringBuilder ( message ) ; \nsb . append ( '\\n' ) ; \n{ \nint i = 0 ; \nwhile ( i < pos ) { \nsb . append ( '-' ) ; \ni ++ ; \n} \n} \nsb . append ( '^' ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2020": "public class DeltaBinaryPackingValuesWriterForInteger { \nprivate void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { \n{ \nint miniBlockIndex = 0 ; \nwhile ( miniBlockIndex < miniBlocksToFlush ) { \nint mask = 0 ; \nint miniStart = miniBlockIndex * config . miniBlockSizeInValues ; \nint miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; \n{ \nint i = miniStart ; \nwhile ( i < miniEnd ) { \nmask |= deltaBlockBuffer [ i ] ; \ni ++ ; \n} \n} \nbitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; \nminiBlockIndex ++ ; \n} \n} \n} \n} \n"}
{"2039": "public class ProtocolEventsAmender { \nprivate void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { \nTSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; \nThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; \nint setSize = thriftSet . size ; \n{ \nint i = 0 ; \nwhile ( i < setSize ) { \ncheckField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; \ni ++ ; \n} \n} \nacceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; \n} \n} \n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nint setOpen = 0 ; \nint curlyOpen = 0 ; \nint len = glob . length ( ) ; \nhasWildcard = false ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( ++ i >= len ) { \nerror ( \"Missing escaped character\" , glob , i ) ; \n} \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \n{ \ni ++ ; \ncontinue ; \n} \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni ++ ; \nbreak ; \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \n{ \ni ++ ; \ncontinue ; \n} \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen ++ ; \nhasWildcard = true ; \n{ \ni ++ ; \ncontinue ; \n} \ncase ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; \n{ \ni ++ ; \ncontinue ; \n} \ncase '}' : if ( curlyOpen > 0 ) { \ncurlyOpen -- ; \nregex . append ( \")\" ) ; \n{ \ni ++ ; \ncontinue ; \n} \n} \nbreak ; \ncase '[' : if ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , i ) ; \n} \nsetOpen ++ ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) { \nregex . append ( BACKSLASH ) ; \n} \nbreak ; \ncase '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \n{ \ni ++ ; \ncontinue ; \n} \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \ni ++ ; \n} \n} \nif ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , len ) ; \n} \nif ( curlyOpen > 0 ) { \nerror ( \"Unclosed group\" , glob , len ) ; \n} \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \n} \n} \n"}
{"2142": "public class MultiLineLiveFileReader { \nint findNextMainLine ( LiveFileChunk chunk , int startIdx ) { \nList < FileLine > lines = chunk . getLines ( ) ; \nint found = - 1 ; \n{ \nint i = startIdx ; \nwhile ( found == - 1 && i < lines . size ( ) ) { \nif ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) { \nfound = i ; \n} \ni ++ ; \n} \n} \nreturn found ; \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nwhile ( idx > - 1 ) { \n{ \nint i = pos ; \nwhile ( i < idx ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \ni ++ ; \n} \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \n{ \nint i = pos ; \nwhile ( i < chunkLines . size ( ) ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \ni ++ ; \n} \n} \nif ( completeLines . isEmpty ( ) ) { \nchunk = null ; \n} \nelse { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nreturn chunk ; \n} \n} \n"}
{"2145": "public class FieldRenamerProcessor { \nprivate static String escapeQuotedSubstring ( String input ) { \nString [ ] parts = input . split ( \"'\" ) ; \nStringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; \n{ \nint i = 0 ; \nwhile ( i < parts . length ) { \nif ( ( i % 2 ) == 1 ) { \noutput . append ( \"'\" ) . append ( parts [ i ] . replace ( \"|\" , \"\\\\|\" ) ) . append ( \"'\" ) ; \n} \nelse { \noutput . append ( parts [ i ] ) ; \n} \ni ++ ; \n} \n} \nreturn output . toString ( ) ; \n} \n} \n"}
{"2175": "public class Utils { \npublic static String format ( String template , Object ... args ) { \nString [ ] templateArr = TEMPLATES . get ( template ) ; \nif ( templateArr == null ) { \ntemplateArr = prepareTemplate ( template ) ; \nTEMPLATES . put ( template , templateArr ) ; \n} \nStringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; \n{ \nint i = 0 ; \nwhile ( i < templateArr . length ) { \nsb . append ( templateArr [ i ] ) ; \nif ( args != null && ( i < templateArr . length - 1 ) ) { \nsb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < values . size ( ) ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) { \nroot . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) { \nroot . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { \nroot . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \ni ++ ; \n} \n} \nreturn root ; \n} \n} \n"}
{"2287": "public class KineticaTableUtils { \nprivate Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { \nClass < ? > columnType = null ; \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \n{ \nint j = 0 ; \nwhile ( j < columnTypes . length ( ) ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ! ct . equals ( \"null\" ) ) { \ncolumnType = getClassForType ( ct ) ; \nbreak ; \n} \nj ++ ; \n} \n} \n} \nelse { \ncolumnType = getClassForType ( field . getString ( \"type\" ) ) ; \n} \nif ( columnType == null ) { \nthrow new GPUdbException ( \"Error getting column type for field: \" + field . toString ( ) ) ; \n} \nreturn columnType ; \n} \n} \n"}
{"2288": "public class KineticaTableUtils { \nprivate boolean typeIsNullable ( JSONObject field ) throws GPUdbException { \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \n{ \nint j = 0 ; \nwhile ( j < columnTypes . length ( ) ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ct . equals ( \"null\" ) ) { \nreturn true ; \n} \nj ++ ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2349": "public class CollectdParser { \nprivate int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { \nint offset = startOffset ; \nint numValues = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nList < Byte > types = new ArrayList < > ( numValues ) ; \nwhile ( numValues -- > 0 ) { \ntypes . add ( buf . getByte ( offset ) ) ; \noffset += 1 ; \n} \n{ \nint i = 0 ; \nwhile ( i < types . size ( ) ) { \nByte type = types . get ( i ) ; \nString label = getValueLabel ( i , type ) ; \nswitch ( type ) { \ncase COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ndefault : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; \n} \ni ++ ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2465": "public class MethodInfoHelper { \npublic static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { \nClass < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; \nif ( parameterTypes == null ) { \nreturn NO_STRINGS ; \n} \nString [ ] canonicalNames = new String [ parameterTypes . length ] ; \n{ \nint i = 0 ; \nwhile ( i < parameterTypes . length ) { \ncanonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; \ni ++ ; \n} \n} \nreturn canonicalNames ; \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \ni ++ ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) { \nthrow duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \n} \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) { \nthrow missingRequiredElement ( reader , required ) ; \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \ni ++ ; \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \n{ \nint i = 0 ; \nwhile ( i < fields . length ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \ni ++ ; \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2513": "public class AuditNotificationReceiver { \nprivate static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; \nsb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; \nEnumeration < ? > en = httpRequest . getHeaderNames ( ) ; \nwhile ( en . hasMoreElements ( ) ) { \nString headerName = ( String ) en . nextElement ( ) ; \nsb . append ( headerName ) . append ( \"=\" ) ; \nif ( ! headerName . contains ( \"authorization\" ) ) { \nsb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; \n} \n} \nsb . append ( \"]\" ) ; \nsb . append ( \"[parameters=\" ) ; \nEnumeration < ? > enparam = httpRequest . getParameterNames ( ) ; \nwhile ( enparam . hasMoreElements ( ) ) { \nString paramName = ( String ) enparam . nextElement ( ) ; \nString [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; \nint len = paramValues != null ? paramValues . length : 0 ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nsb . append ( paramValues [ i ] ) . append ( \"::\" ) ; \ni ++ ; \n} \n} \nsb . append ( \",\" ) ; \n} \nsb . append ( \"][attributes=\" ) ; \nEnumeration < ? > enu = httpRequest . getAttributeNames ( ) ; \nwhile ( enu . hasMoreElements ( ) ) { \nString attrName = ( String ) enu . nextElement ( ) ; \nsb . append ( attrName ) . append ( \"=\" ) ; \nsb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2519": "public class StubStrategy { \npublic void writeParams ( OutputStream out , Object [ ] params ) { \nint len = params . length ; \nif ( len != paramWriters . length ) { \nthrow IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < len ) { \nObject param = params [ i ] ; \nif ( param instanceof PortableRemoteObject ) { \ntry { \nparam = PortableRemoteObject . toStub ( ( Remote ) param ) ; \n} \ncatch ( NoSuchObjectException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nparamWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) return false ; \n{ \nint i = 0 ; \nwhile ( i < sourceParams . length ) { \nif ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nint attributeSize = reader . getAttributeCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < attributeSize ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \ni ++ ; \n} \n} \nif ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) { \nif ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { \nif ( jndiName . contains ( \"/\" ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \n} \nelse { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \n} \nreturn poolName ; \n} \n} \n"}
{"2616": "public class SkeletonStrategy { \npublic Object [ ] readParams ( InputStream in ) { \nint len = paramReaders . length ; \nObject [ ] params = new Object [ len ] ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nparams [ i ] = paramReaders [ i ] . read ( in ) ; \ni ++ ; \n} \n} \nreturn params ; \n} \n} \n"}
{"2618": "public class SkeletonStrategy { \npublic void writeException ( OutputStream out , Throwable e ) { \nint len = excepWriters . length ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nif ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { \nexcepWriters [ i ] . write ( out , e ) ; \nreturn ; \n} \ni ++ ; \n} \n} \nthrow new UnknownException ( e ) ; \n} \n} \n"}
{"2619": "public class DefaultBeanInfo { \nprotected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { \nint size ; \nsynchronized ( indexes ) { \nsize = indexes . size ( ) ; \n{ \nint i = start ; \nwhile ( i < depth && i < size ) { \nU result = lookup . lookup ( indexes . get ( i ) ) ; \nif ( result != null ) return result ; \ni ++ ; \n} \n} \n} \nif ( currentClass == null ) return null ; \nsynchronized ( indexes ) { \nClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; \nindexes . add ( cri ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \n} \nreturn lookup ( lookup , size , depth ) ; \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; \n{ \nint i = 0 ; \nwhile ( i < name . length ( ) ) { \nchar c = name . charAt ( i ) ; \nif ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; \nelse res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \n++ i ; \n} \n} \nString s = res . toString ( ) ; \nif ( isReservedIDLKeyword ( s ) ) return \"_\" + s ; \nelse return s ; \n} \n} \n"}
{"2632": "public class Util { \nprivate static boolean isReservedIDLKeyword ( String s ) { \n{ \nint i = 0 ; \nwhile ( i < reservedIDLKeywords . length ) { \nif ( reservedIDLKeywords [ i ] . equals ( s ) ) return true ; \n++ i ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2634": "public class Util { \nprivate static String getSignature ( Method method ) { \nStringBuffer b = new StringBuffer ( \"(\" ) ; \nClass [ ] parameterTypes = method . getParameterTypes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < parameterTypes . length ) { \nb . append ( getSignature ( parameterTypes [ i ] ) ) ; \n++ i ; \n} \n} \nb . append ( ')' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { \n{ \nint i = 1 ; \nwhile ( i < name . size ( ) ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \ni ++ ; \n} \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \n} \n} \n"}
{"2685": "public class RmiIdlUtil { \npublic static boolean isAllFieldsPublic ( Class c ) { \ntry { \nfinal Field [ ] list = c . getFields ( ) ; \n{ \nint i = 0 ; \nwhile ( i < list . length ) { \nif ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; \ni ++ ; \n} \n} \n} \ncatch ( Exception e ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse if ( str . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse { \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \n++ i ; \n} \n} \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nint kindSep = - 1 ; \nint len = compStr . length ( ) ; \nint j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \n{ \nint i = 0 ; \nwhile ( i < len && kindSep < 0 ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse if ( compStr . charAt ( i ) == kindSeparator ) { \nkindSep = i ; \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \ni ++ ; \n} \n} \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( kindSep < 0 ) { \ncomp . kind = \"\" ; \n} \nelse { \nj = 0 ; \nescaped = false ; \n{ \nint i = kindSep + 1 ; \nwhile ( i < len ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \ni ++ ; \n} \n} \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nreturn comp ; \n} \n} \n"}
{"2750": "public class ContainerAnalysis { \nprotected boolean hasNonAppExceptions ( Method m ) { \nClass [ ] ex = m . getExceptionTypes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < ex . length ) { \nif ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) return false ; \n++ i ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) { \n++ i ; \ncontinue ; \n} \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \n{ \nint opIdx = 0 ; \nwhile ( oa == null && opIdx < operations . length ) { \nif ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \n++ opIdx ; \n} \n} \nif ( oa == null ) { \n++ i ; \ncontinue ; \n} \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \n{ \nint j = 0 ; \nwhile ( j < params . length ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n++ j ; \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n++ i ; \n} \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < entries . size ( ) ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \n{ \nint j = 0 ; \nwhile ( j < i ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n++ j ; \n} \n} \n++ i ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < entries . size ( ) ) { \nif ( ! clash [ i ] ) { \n++ i ; \ncontinue ; \n} \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \n{ \nint j = 0 ; \nwhile ( j < name . length ( ) ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) { \n++ j ; \ncontinue ; \n} \nif ( noUpper ) noUpper = false ; \nelse b . append ( '_' ) ; \nb . append ( j ) ; \n++ j ; \n} \n} \naa . setIDLName ( b . toString ( ) ) ; \n++ i ; \n} \n} \n} \n} \n"}
{"2755": "public class ContainerAnalysis { \nprotected String escapeIRName ( String name ) { \nStringBuffer b = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < name . length ( ) ) { \nchar c = name . charAt ( i ) ; \nif ( c < 256 ) b . append ( c ) ; \nelse b . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; \n++ i ; \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"2758": "public class XTSSubsystemParser { \nprivate void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nParseUtils . requireNoNamespaceAttribute ( reader , i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nattributeProcessorCallback . process ( i , attribute ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"2819": "public class PooledConnectionFactoryRemove { \nprotected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { \nif ( entries . size ( ) > 1 ) { \n{ \nint i = 1 ; \nwhile ( i < entries . size ( ) ) { \nContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; \ncontext . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"2826": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembers ( ) { \nif ( valueMembers != null ) return valueMembers ; \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nvalueMembers = new ValueMember [ c . length ] ; \n{ \nint i = 0 ; \nwhile ( i < c . length ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvalueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; \n++ i ; \n} \n} \nreturn valueMembers ; \n} \n} \n"}
{"2827": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembersForTypeCode ( ) { \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nValueMember [ ] vms = new ValueMember [ c . length ] ; \n{ \nint i = 0 ; \nwhile ( i < c . length ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvms [ i ] = new ValueMember ( vmdi . name ( ) , null , null , null , vmdi . type ( ) , null , vmdi . access ( ) ) ; \n++ i ; \n} \n} \nreturn vms ; \n} \n} \n"}
{"2829": "public class AbstractFederationSubsystemReader { \nprotected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { \nif ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { \nreturn null ; \n} \nModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; \nint attributeCount = reader . getAttributeCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < attributeCount ) { \nString attributeLocalName = reader . getAttributeLocalName ( i ) ; \nif ( ModelElement . forName ( attributeLocalName ) == null ) { \nthrow unexpectedAttribute ( reader , i ) ; \n} \ni ++ ; \n} \n} \nfor ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { \nString attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; \nsimpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; \n} \nString name = xmlElement . getName ( ) ; \nif ( key != null ) { \nname = key ; \nif ( modelNode . hasDefined ( key ) ) { \nname = modelNode . get ( key ) . asString ( ) ; \n} \nelse { \nString attributeValue = reader . getAttributeValue ( \"\" , key ) ; \nif ( attributeValue != null ) { \nname = attributeValue ; \n} \n} \n} \nmodelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; \naddOperations . add ( modelNode ) ; \nreturn modelNode ; \n} \n} \n"}
{"2849": "public class InterfaceRepository { \nprivate String [ ] addInterfaces ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nInterfaceAnalysis [ ] interfaces = ca . getInterfaces ( ) ; \nList base_interfaces = new ArrayList ( ) ; \n{ \nint i = 0 ; \nwhile ( i < interfaces . length ) { \nInterfaceDefImpl idi = addInterface ( interfaces [ i ] ) ; \nbase_interfaces . add ( idi . id ( ) ) ; \n++ i ; \n} \n} \nString [ ] strArr = new String [ base_interfaces . size ( ) ] ; \nreturn ( String [ ] ) base_interfaces . toArray ( strArr ) ; \n} \n} \n"}
{"2850": "public class InterfaceRepository { \nprivate String [ ] addAbstractBaseValuetypes ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nValueAnalysis [ ] abstractValuetypes = ca . getAbstractBaseValuetypes ( ) ; \nList abstract_base_valuetypes = new ArrayList ( ) ; \n{ \nint i = 0 ; \nwhile ( i < abstractValuetypes . length ) { \nValueDefImpl vdi = addValue ( abstractValuetypes [ i ] ) ; \nabstract_base_valuetypes . add ( vdi . id ( ) ) ; \n++ i ; \n} \n} \nString [ ] strArr = new String [ abstract_base_valuetypes . size ( ) ] ; \nreturn ( String [ ] ) abstract_base_valuetypes . toArray ( strArr ) ; \n} \n} \n"}
{"2853": "public class InterfaceRepository { \nprivate ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { \nValueDefImpl vDef ; \nClass cls = va . getCls ( ) ; \nvDef = ( ValueDefImpl ) valueMap . get ( cls ) ; \nif ( vDef != null ) return vDef ; \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] supported_interfaces = addInterfaces ( va ) ; \nString [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; \nValueDefImpl superValue = null ; \nValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; \nif ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \nTypeCode baseTypeCode ; \nif ( superValue == null ) baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; \nelse baseTypeCode = superValue . type ( ) ; \nvDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; \naddTypeCode ( cls , vDef . type ( ) ) ; \nm . add ( base , vDef ) ; \nvalueMap . put ( cls , vDef ) ; \naddConstants ( vDef , va ) ; \nValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; \n{ \nint i = 0 ; \nwhile ( i < vmas . length ) { \nValueMemberDefImpl vmDef ; \nString vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; \nString vmName = vmas [ i ] . getIDLName ( ) ; \nClass vmCls = vmas [ i ] . getCls ( ) ; \nTypeCode typeCode = getTypeCode ( vmCls ) ; \nboolean vmPublic = vmas [ i ] . isPublic ( ) ; \nvmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; \nvDef . add ( vmName , vmDef ) ; \n++ i ; \n} \n} \naddAttributes ( vDef , va ) ; \nreturn vDef ; \n} \n} \n"}
{"2867": "public class Configurator { \npublic static String [ ] getTypes ( ValueConfig [ ] values ) { \nif ( values == null || values . length == 0 ) return NO_PARAMS_TYPES ; \nString [ ] types = new String [ values . length ] ; \n{ \nint i = 0 ; \nwhile ( i < types . length ) { \ntypes [ i ] = values [ i ] . getType ( ) ; \ni ++ ; \n} \n} \nreturn types ; \n} \n} \n"}
{"2890": "public class InterfaceAnalysis { \nprotected void calculateOperationAnalysisMap ( ) { \noperationAnalysisMap = new HashMap ( ) ; \nOperationAnalysis oa ; \n{ \nint i = 0 ; \nwhile ( i < operations . length ) { \noa = operations [ i ] ; \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n++ i ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < attributes . length ) { \nAttributeAnalysis attr = attributes [ i ] ; \noa = attr . getAccessorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \noa = attr . getMutatorAnalysis ( ) ; \nif ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \n++ i ; \n} \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \n{ \nint i = 0 ; \nwhile ( i < info . orderBy . getItems ( ) . size ( ) ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse { \nif ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2938": "public class OHazelcastPlugin { \n@ Override public String electNewLockManager ( ) { \nif ( hazelcastInstance == null ) throw new HazelcastInstanceNotActiveException ( ) ; \nfinal ILock lock = hazelcastInstance . getLock ( \"orientdb.lockManagerElection\" ) ; \nlock . lock ( ) ; \ntry { \nString lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; \nif ( lockManagerServer != null && getActiveServers ( ) . contains ( lockManagerServer ) ) return lockManagerServer ; \nfinal String originalLockManager = lockManagerServer ; \nODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , \"lock '%s' is unreachable, electing a new lock...\" , originalLockManager ) ; \nint lockManagerServerId = - 1 ; \nif ( lockManagerServer != null && registeredNodeByName . containsKey ( lockManagerServer ) ) lockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; \nString newServer = null ; \nint currIndex = lockManagerServerId ; \n{ \nint i = 0 ; \nwhile ( i < registeredNodeById . size ( ) ) { \ncurrIndex ++ ; \nif ( currIndex >= registeredNodeById . size ( ) ) currIndex = 0 ; \nnewServer = registeredNodeById . get ( currIndex ) ; \nif ( newServer == null ) throw new OConfigurationException ( \"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById ) ; \nif ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) || activeNodes . containsKey ( newServer ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \n++ i ; \n} \n} \nreturn newServer ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"2942": "public class OMicroTransaction { \npublic void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { \nif ( oldRid . equals ( newRid ) ) return ; \nfinal List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList < > ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfor ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { \nfinal OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; \nif ( index == null ) throw new OTransactionException ( \"Cannot find index '\" + entry . getValue ( ) + \"' while committing transaction\" ) ; \nfinal Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; \nif ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) continue ; \nfinal OTransactionIndexChanges indexChanges = entry . getValue ( ) ; \n{ \nfinal Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nfinal OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; \nif ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { \nkeyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; \niterator . remove ( ) ; \n} \n} \n} \n} \nfinal ORecordOperation rec = resolveRecordOperation ( oldRid ) ; \nif ( rec != null ) { \nupdatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; \nif ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { \nORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; \nfinal ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; \nif ( recordId == null ) { \nORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; \n} \nelse { \nrecordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; \nrecordId . setClusterId ( newRid . getClusterId ( ) ) ; \n} \nORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; \n} \n} \nfor ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; \nfinal List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; \nif ( transactionIndexOperations != null ) { \nfor ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { \nOTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; \nif ( indexEntryChanges == null ) continue ; \nfinal OTransactionIndexChangesPerKey keyChanges ; \nif ( indexOperation . key == null ) { \nkeyChanges = indexEntryChanges . nullKeyChanges ; \n} \nelse { \nkeyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; \n} \nif ( keyChanges != null ) updateChangesIdentity ( oldRid , newRid , keyChanges ) ; \n} \n} \n} \n} \n"}
{"2972": "public class OSchemaProxyObject { \npublic synchronized void synchronizeSchema ( ) { \nOObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; \nCollection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; \nboolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; \nboolean reloadSchema = false ; \nfor ( Class < ? > iClass : registeredEntities ) { \nif ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) || iClass . isAnonymousClass ( ) ) return ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \n{ \nClass < ? > currentClass = iClass ; \nwhile ( currentClass != Object . class ) { \nif ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) && ! currentClass . equals ( ODocument . class ) ) { \n( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; \n} \nString iClassName = currentClass . getSimpleName ( ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \nif ( database != null && ! database . isClosed ( ) && ! currentClass . equals ( Object . class ) ) { \nOClass oSuperClass ; \nOClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nelse { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nif ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { \ncurrentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; \nreloadSchema = true ; \n} \n} \n} \n} \n} \nif ( database != null && ! database . isClosed ( ) && reloadSchema ) { \ndatabase . getMetadata ( ) . getSchema ( ) . reload ( ) ; \n} \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nint read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \n{ \nint i = 0 ; \nwhile ( i < 4 ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n++ i ; \n} \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse { \nmissedChar = c2 ; \n} \n} \n} \ncursor ++ ; \nif ( c == NEW_LINE ) { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nelse ++ columnNumber ; \nreturn ( char ) c ; \n} \n} \n"}
{"2983": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeUntilReturn ( ) { \nif ( steps . size ( ) > 0 ) { \nlastStep = steps . get ( steps . size ( ) - 1 ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < steps . size ( ) - 1 ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nlastStep = returnStep ; \nreturn lastStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \ni ++ ; \n} \n} \nthis . lastStep = steps . get ( steps . size ( ) - 1 ) ; \nreturn lastStep ; \n} \n} \n"}
{"2984": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeFull ( ) { \n{ \nint i = 0 ; \nwhile ( i < steps . size ( ) ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nreturn returnStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2994": "public class OSQLFilterItemField { \npublic OCollate getCollate ( Object doc ) { \nif ( collate != null || operationsChain == null || ! isFieldChain ( ) ) { \nreturn collate ; \n} \nif ( ! ( doc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nFieldChain chain = getFieldChain ( ) ; \nODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; \n{ \nint i = 0 ; \nwhile ( i < chain . getItemCount ( ) - 1 ) { \nif ( lastDoc == null ) { \nreturn null ; \n} \nObject nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; \nif ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nlastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; \ni ++ ; \n} \n} \nif ( lastDoc == null ) { \nreturn null ; \n} \nOClass schemaClass = lastDoc . getSchemaClass ( ) ; \nif ( schemaClass == null ) { \nreturn null ; \n} \nOProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; \nif ( property == null ) { \nreturn null ; \n} \nreturn property . getCollate ( ) ; \n} \n} \n"}
{"3005": "public class OAbstract2pcTask { \n@ Override public int [ ] getPartitionKey ( ) { \nif ( tasks . size ( ) == 1 ) return tasks . get ( 0 ) . getPartitionKey ( ) ; \nfinal int [ ] partitions = new int [ tasks . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < tasks . size ( ) ) { \nfinal OAbstractRecordReplicatedTask task = tasks . get ( i ) ; \npartitions [ i ] = task . getPartitionKey ( ) [ 0 ] ; \n++ i ; \n} \n} \nreturn partitions ; \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \n{ \nint i = 0 ; \nwhile ( i < parameterItems . size ( ) ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"3020": "public class FrequencySketch { \nprivate void reset ( ) { \nint count = 0 ; \n{ \nint i = 0 ; \nwhile ( i < table . length ) { \ncount += Long . bitCount ( table [ i ] & ONE_MASK ) ; \ntable [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; \ni ++ ; \n} \n} \nsize = ( size >>> 1 ) - ( count >>> 2 ) ; \n} \n} \n"}
{"3092": "public class ODistributedConfiguration { \npublic List < String > getMasterServers ( ) { \nfinal List < String > serverList = getClusterConfiguration ( null ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nList < String > masters = new ArrayList < String > ( serverList . size ( ) ) ; \nfor ( String s : serverList ) { \nif ( ! s . equals ( NEW_NODE_TAG ) ) masters . add ( s ) ; \n} \nfinal ROLES defRole = getDefaultServerRole ( ) ; \nfinal ODocument servers = configuration . field ( SERVERS ) ; \nif ( servers != null ) { \n{ \nIterator < String > it = masters . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nfinal String server = it . next ( ) ; \nfinal String roleAsString = servers . field ( server ) ; \nfinal ROLES role = roleAsString != null ? ROLES . valueOf ( roleAsString . toUpperCase ( Locale . ENGLISH ) ) : defRole ; \nif ( role != ROLES . MASTER ) it . remove ( ) ; \n} \n} \n} \nreturn masters ; \n} \nreturn Collections . EMPTY_LIST ; \n} \n} \n"}
{"3147": "public class ODistributedResponseManagerImpl { \nprotected List < ODistributedResponse > getConflictResponses ( ) { \nfinal List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; \nint bestGroupSoFar = getBestResponsesGroup ( ) ; \n{ \nint i = 0 ; \nwhile ( i < responseGroups . size ( ) ) { \nif ( i != bestGroupSoFar ) { \nfor ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; \n} \n++ i ; \n} \n} \nreturn servers ; \n} \n} \n"}
{"3148": "public class ODistributedResponseManagerImpl { \nprotected int getBestResponsesGroup ( ) { \nint maxCoherentResponses = 0 ; \nint bestGroupSoFar = 0 ; \n{ \nint i = 0 ; \nwhile ( i < responseGroups . size ( ) ) { \nfinal int currentGroupSize = responseGroups . get ( i ) . size ( ) ; \nif ( currentGroupSize > maxCoherentResponses ) { \nmaxCoherentResponses = currentGroupSize ; \nbestGroupSoFar = i ; \n} \n++ i ; \n} \n} \nreturn bestGroupSoFar ; \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) return false ; \nif ( ! index . supportsOrderedIterations ( ) ) return false ; \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nint endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \n{ \nint i = 0 ; \nwhile ( i < endIndex ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; \ni ++ ; \n} \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) { \nreturn false ; \n} \n{ \nint i = equalsFilterFields . size ( ) ; \nwhile ( i < endIndex ) { \nint fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3161": "public class OStringParser { \npublic static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { \nif ( iCurrentPosition < 0 ) return - 1 ; \nfinal int size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; \nfinal int jumpCharSize = iJumpChars . length ( ) ; \nboolean found = true ; \nchar c ; \n{ \nwhile ( iCurrentPosition < size ) { \nfound = false ; \nc = iText . charAt ( iCurrentPosition ) ; \n{ \nint jumpIndex = 0 ; \nwhile ( jumpIndex < jumpCharSize ) { \nif ( iJumpChars . charAt ( jumpIndex ) == c ) { \nfound = true ; \nbreak ; \n} \n++ jumpIndex ; \n} \n} \nif ( ! found ) break ; \n++ iCurrentPosition ; \n} \n} \nreturn iCurrentPosition >= size ? - 1 : iCurrentPosition ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \n{ \nint i = 0 ; \nwhile ( i < index ) { \nif ( t . next != null ) t = t . next ; \nelse t = t . next = token_source . getNextToken ( ) ; \ni ++ ; \n} \n} \nreturn t ; \n} \n} \n"}
{"3206": "public class OrientSql { \npublic ParseException generateParseException ( ) { \njj_expentries . clear ( ) ; \nboolean [ ] la1tokens = new boolean [ 279 ] ; \nif ( jj_kind >= 0 ) { \nla1tokens [ jj_kind ] = true ; \njj_kind = - 1 ; \n} \n{ \nint i = 0 ; \nwhile ( i < 424 ) { \nif ( jj_la1 [ i ] == jj_gen ) { \n{ \nint j = 0 ; \nwhile ( j < 32 ) { \nif ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ j ] = true ; \n} \nif ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 32 + j ] = true ; \n} \nif ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 64 + j ] = true ; \n} \nif ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 96 + j ] = true ; \n} \nif ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 128 + j ] = true ; \n} \nif ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 160 + j ] = true ; \n} \nif ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 192 + j ] = true ; \n} \nif ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 224 + j ] = true ; \n} \nif ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 256 + j ] = true ; \n} \nj ++ ; \n} \n} \n} \ni ++ ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < 279 ) { \nif ( la1tokens [ i ] ) { \njj_expentry = new int [ 1 ] ; \njj_expentry [ 0 ] = i ; \njj_expentries . add ( jj_expentry ) ; \n} \ni ++ ; \n} \n} \njj_endpos = 0 ; \njj_rescan_token ( ) ; \njj_add_error_token ( 0 , 0 ) ; \nint [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; \n{ \nint i = 0 ; \nwhile ( i < jj_expentries . size ( ) ) { \nexptokseq [ i ] = jj_expentries . get ( i ) ; \ni ++ ; \n} \n} \nreturn new ParseException ( token , exptokseq , tokenImage ) ; \n} \n} \n"}
{"3216": "public class ODistributedAbstractPlugin { \n@ Override public int getNodesWithStatus ( final Collection < String > iNodes , final String databaseName , final DB_STATUS ... statuses ) { \n{ \nIterator < String > it = iNodes . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nfinal String node = it . next ( ) ; \nif ( ! isNodeStatusEqualsTo ( node , databaseName , statuses ) ) it . remove ( ) ; \n} \n} \nreturn iNodes . size ( ) ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \n{ \nint n = 0 ; \nwhile ( n < NUMBER_OF_READ_BUFFERS ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \n{ \nint i = 0 ; \nwhile ( i < READ_BUFFER_SIZE ) { \nbuffer [ i ] . set ( null ) ; \ni ++ ; \n} \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \nn ++ ; \n} \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \n{ \nint n = 0 ; \nwhile ( n < NUMBER_OF_READ_BUFFERS ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nwhile ( true ) { \nfinal int bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) break ; \napplyRead ( entry ) ; \ncounter ++ ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \nn ++ ; \n} \n} \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \n{ \nint i = 0 ; \nwhile ( i < parallel - 1 ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \ni ++ ; \n} \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) { \nsynchronized ( runningThreads ) { \nwhile ( runningThreads . get ( ) > 0 ) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n"}
{"3279": "public class ORecordSerializerBinaryV0 { \nprivate List < RecordInfo > getPositionsFromEmbeddedCollection ( final BytesContainer bytes , int serializerVersion ) { \nList < RecordInfo > retList = new ArrayList < > ( ) ; \nint numberOfElements = OVarIntSerializer . readAsInteger ( bytes ) ; \nreadByte ( bytes ) ; \n{ \nint i = 0 ; \nwhile ( i < numberOfElements ) { \nOType dataType = readOType ( bytes , false ) ; \nint fieldStart = bytes . offset ; \nRecordInfo fieldInfo = new RecordInfo ( ) ; \nfieldInfo . fieldStartOffset = fieldStart ; \nfieldInfo . fieldType = dataType ; \ndeserializeValue ( bytes , dataType , null , true , - 1 , serializerVersion , true ) ; \nfieldInfo . fieldLength = bytes . offset - fieldStart ; \nretList . add ( fieldInfo ) ; \ni ++ ; \n} \n} \nreturn retList ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \n{ \nint retry = 0 ; \nwhile ( retry < 100 ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n++ retry ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n"}
{"3293": "public class OObjectProxyMethodHandler { \npublic void attach ( final Object self ) throws IllegalArgumentException , IllegalAccessException , NoSuchMethodException , InvocationTargetException { \n{ \nClass < ? > currentClass = self . getClass ( ) ; \nwhile ( currentClass != Object . class ) { \nif ( Proxy . class . isAssignableFrom ( currentClass ) ) { \ncurrentClass = currentClass . getSuperclass ( ) ; \n{ \ncontinue ; \n} \n} \nfor ( Field f : currentClass . getDeclaredFields ( ) ) { \nfinal String fieldName = f . getName ( ) ; \nfinal Class < ? > declaringClass = f . getDeclaringClass ( ) ; \nif ( OObjectEntitySerializer . isTransientField ( declaringClass , fieldName ) || OObjectEntitySerializer . isVersionField ( declaringClass , fieldName ) || OObjectEntitySerializer . isIdField ( declaringClass , fieldName ) ) { \ncontinue ; \n} \nObject value = OObjectEntitySerializer . getFieldValue ( f , self ) ; \nvalue = setValue ( self , fieldName , value ) ; \nOObjectEntitySerializer . setFieldValue ( f , self , value ) ; \n} \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \n} \n} \n} \n} \n"}
{"3307": "public class OCollections { \npublic static int indexOf ( final Object [ ] array , final Comparable object ) { \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( object . compareTo ( array [ i ] ) == 0 ) return i ; \n++ i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3308": "public class OCollections { \npublic static int indexOf ( final int [ ] array , final int object ) { \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( array [ i ] == object ) return i ; \n++ i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal int max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \n{ \nint i = 0 ; \nwhile ( parserCurrentPos <= max ) { \nfinal char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) parserLastWord . append ( ch ) ; \nint candidatesWordsCount = 0 ; \nint candidatesWordsPos = - 1 ; \n{ \nint c = 0 ; \nwhile ( c < processedWords . length ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal int wordSize = w . length ( ) ; \nif ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) processedWords [ c ] = null ; \nelse { \ncandidatesWordsCount ++ ; \nif ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; \n} \n} \n++ c ; \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) return candidatesWordsPos ; \n} \nif ( candidatesWordsCount == 0 || separator ) break ; \nparserCurrentPos ++ ; \n++ i ; \n} \n} \nif ( iMandatory ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \nreturn - 1 ; \n} \n} \n"}
{"3338": "public class OBaseParser { \nprivate boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { \n{ \nint sepIndex = 0 ; \nwhile ( sepIndex < iSeparatorChars . length ( ) ) { \nif ( iSeparatorChars . charAt ( sepIndex ) == c ) { \nparserLastSeparator = c ; \nreturn true ; \n} \n++ sepIndex ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \n{ \nwhile ( ) { \n{ \ni = 0 ; \nwhile ( i < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ) { \n; \ni ++ ; \n} \n} \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal int length = to - from ; \nif ( length < MERGESORT_NO_REC ) { \n{ \nint i = from ; \nwhile ( i < to ) { \n{ \nint j = i ; \nwhile ( j > from && ( c . compare ( j - 1 , j ) > 0 ) ) { \nswapper . swap ( j , j - 1 ) ; \nj -- ; \n} \n} \ni ++ ; \n} \n} \nreturn ; \n} \nint mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( c . compare ( mid - 1 , mid ) <= 0 ) return ; \ninPlaceMerge ( from , mid , to , c , swapper ) ; \n} \n} \n"}
{"3352": "public class Arrays { \nprotected static void swap ( final Swapper swapper , int a , int b , final int n ) { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nswapper . swap ( a , b ) ; \nb ++ ; \na ++ ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null || files . length <= numOfSnapshotsToKeep ) { \nreturn ; \n} \nsortByLastModified ( files ) ; \n{ \nint i = numOfSnapshotsToKeep ; \nwhile ( i < files . length ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) { \nlog . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"3369": "public class HollowBlobHeaderReader { \nprivate Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { \nint numHeaderTags = dis . readShort ( ) ; \nMap < String , String > headerTags = new HashMap < String , String > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numHeaderTags ) { \nheaderTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; \ni ++ ; \n} \n} \nreturn headerTags ; \n} \n} \n"}
{"3371": "public class ThreadSafeBitSet { \npublic void clearAll ( ) { \nThreadSafeBitSetSegments segments = this . segments . get ( ) ; \n{ \nint i = 0 ; \nwhile ( i < segments . numSegments ( ) ) { \nAtomicLongArray segment = segments . getSegment ( i ) ; \n{ \nint j = 0 ; \nwhile ( j < segment . length ( ) ) { \nsegment . set ( j , 0L ) ; \nj ++ ; \n} \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"3372": "public class SnapshotPopulatedOrdinalsReader { \npublic static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { \nint numLongs = dis . readInt ( ) ; \nint currentOrdinal = 0 ; \n{ \nint i = 0 ; \nwhile ( i < numLongs ) { \nlong l = dis . readLong ( ) ; \nnotifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; \ncurrentOrdinal += 64 ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3375": "public class SegmentedByteArray { \npublic void copy ( ByteData src , long srcPos , long destPos , long length ) { \n{ \nlong i = 0 ; \nwhile ( i < length ) { \nset ( destPos ++ , src . get ( srcPos ++ ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3377": "public class SegmentedByteArray { \npublic boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { \n{ \nint i = 0 ; \nwhile ( i < length ) { \nif ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \n{ \nint i = 0 ; \nwhile ( i < elementArray . numLists ( ) ) { \nint listSize = elementArray . listSize ( i ) ; \nint setSize = 0 ; \nint predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nint hashMask = predictedBuckets - 1 ; \nif ( predictedBuckets > selectArray . length ) selectArray = new int [ predictedBuckets ] ; \n{ \nint j = 0 ; \nwhile ( j < predictedBuckets ) { \nselectArray [ j ] = - 1 ; \nj ++ ; \n} \n} \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nint selectOrdinal = iter . next ( ) ; \nwhile ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { \nint hash = HashCodes . hashInt ( selectOrdinal ) ; \nint bucket = hash & hashMask ; \nwhile ( true ) { \nif ( selectArray [ bucket ] == selectOrdinal ) break ; \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize ++ ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets += HashCodes . hashTableSize ( setSize ) ; \nif ( setSize > maxSize ) maxSize = setSize ; \ni ++ ; \n} \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) return false ; \n{ \nint i = 0 ; \nwhile ( i < keys . length ) { \nif ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3389": "public class HollowPrimaryKeyValueDeriver { \npublic Object [ ] getRecordKey ( int ordinal ) { \nObject [ ] results = new Object [ fieldPathIndexes . length ] ; \n{ \nint i = 0 ; \nwhile ( i < fieldPathIndexes . length ) { \nresults [ i ] = readValue ( ordinal , i ) ; \ni ++ ; \n} \n} \nreturn results ; \n} \n} \n"}
{"3404": "public class HollowSpecificDiff { \npublic void setElementKeyPaths ( String ... paths ) { \nresetResults ( ) ; \nelementKeyPaths = new BitSet ( elementPaths . length ) ; \n{ \nint i = 0 ; \nwhile ( i < paths . length ) { \nint elementPathIdx = getElementPathIdx ( paths [ i ] ) ; \nif ( elementPathIdx == - 1 ) throw new IllegalArgumentException ( \"Key path must have been specified as an element match path.  Offending path: \" + paths [ i ] ) ; \nelementKeyPaths . set ( elementPathIdx ) ; \ni ++ ; \n} \n} \nelementNonKeyPaths = new BitSet ( elementPaths . length ) ; \nelementNonKeyPaths . set ( 0 , elementPaths . length ) ; \nelementNonKeyPaths . andNot ( elementKeyPaths ) ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal int numThreads = executor . getCorePoolSize ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numThreads ) { \nfinal int threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nint hashedResults [ ] = new int [ 16 ] ; \n{ \nint i = threadNumber ; \nwhile ( i < matcher . getMatchedOrdinals ( ) . size ( ) ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nint fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nint toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \ni += numThreads ; \n} \n} \n{ \nint i = threadNumber ; \nwhile ( i < matcher . getExtraInFrom ( ) . size ( ) ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \ni += numThreads ; \n} \n} \n{ \nint i = threadNumber ; \nwhile ( i < matcher . getExtraInTo ( ) . size ( ) ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \ni += numThreads ; \n} \n} \n} \n} \n) ; \ni ++ ; \n} \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"3412": "public class HollowObjectWriteRecord { \npublic void writeDataTo ( ByteDataBuffer buf ) { \n{ \nint i = 0 ; \nwhile ( i < fieldData . length ) { \nwriteField ( buf , i ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3416": "public class FreeOrdinalTracker { \npublic void sort ( ) { \nArrays . sort ( freeOrdinals , 0 , size ) ; \nint midpoint = size / 2 ; \n{ \nint i = 0 ; \nwhile ( i < midpoint ) { \nint temp = freeOrdinals [ i ] ; \nfreeOrdinals [ i ] = freeOrdinals [ size - i - 1 ] ; \nfreeOrdinals [ size - i - 1 ] = temp ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3417": "public class SetMapKeyHasher { \npublic static int hash ( Object key [ ] , FieldType fieldType [ ] ) { \nint hash = 0 ; \n{ \nint i = 0 ; \nwhile ( i < key . length ) { \nhash *= 31 ; \nhash ^= hash ( key [ i ] , fieldType [ i ] ) ; \ni ++ ; \n} \n} \nreturn hash ; \n} \n} \n"}
{"3419": "public class FixedLengthMultipleOccurrenceElementArray { \nprivate void resizeStorage ( ) { \nint currentElementsPerNode = maxElementsPerNode ; \nint newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; \nif ( newElementsPerNode <= currentElementsPerNode ) { \nthrow new IllegalStateException ( \"cannot resize fixed length array from \" + currentElementsPerNode + \" to \" + newElementsPerNode ) ; \n} \nFixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; \nLongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { \nlong currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; \nlong newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; \n{ \nint offset = 0 ; \nwhile ( offset < currentElementsPerNode ) { \nlong element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; \nif ( element == NO_ELEMENT ) { \nbreak ; \n} \nnewStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; \noffset ++ ; \n} \n} \n} \n) ; \nstorage . destroy ( memoryRecycler ) ; \nstorage = newStorage ; \nmaxElementsPerNode = newElementsPerNode ; \n} \n} \n"}
{"3421": "public class ByteArrayOrdinalMap { \npublic void prepareForWrite ( ) { \nint maxOrdinal = 0 ; \nAtomicLongArray pao = pointersAndOrdinals ; \n{ \nint i = 0 ; \nwhile ( i < pao . length ( ) ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \nif ( ordinal > maxOrdinal ) { \nmaxOrdinal = ordinal ; \n} \n} \ni ++ ; \n} \n} \nlong [ ] pbo = new long [ maxOrdinal + 1 ] ; \nArrays . fill ( pbo , - 1 ) ; \n{ \nint i = 0 ; \nwhile ( i < pao . length ( ) ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \npbo [ ordinal ] = key & POINTER_MASK ; \n} \ni ++ ; \n} \n} \npointersByOrdinal = pbo ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) { \nreturn false ; \n} \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \n{ \nint i = 0 ; \nwhile ( i < sizeOfData ) { \nif ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3425": "public class ByteArrayOrdinalMap { \nprivate AtomicLongArray emptyKeyArray ( int size ) { \nAtomicLongArray arr = new AtomicLongArray ( size ) ; \n{ \nint i = 0 ; \nwhile ( i < arr . length ( ) ) { \narr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; \ni ++ ; \n} \n} \nreturn arr ; \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \n{ \nint i = 0 ; \nwhile ( i < getNumFieldPaths ( ) ) { \nif ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3434": "public class HollowCodeGenerationUtils { \npublic static String normalizeFieldPathToParamName ( String fieldPath ) { \nString result = null ; \nif ( fieldPath . contains ( \".\" ) ) { \nString [ ] parts = fieldPath . split ( \"\\\\.\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( lowercase ( parts [ 0 ] ) ) ; \n{ \nint i = 1 ; \nwhile ( i < parts . length ) { \nsb . append ( uppercase ( parts [ i ] ) ) ; \ni ++ ; \n} \n} \nresult = sb . toString ( ) ; \n} \nelse { \nresult = lowercase ( fieldPath ) ; \n} \nif ( result . endsWith ( \"!\" ) ) { \nreturn result . substring ( 0 , result . length ( ) - 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"3436": "public class HollowHashIndex { \npublic HollowHashIndexResult findMatches ( Object ... query ) { \nint hashCode = 0 ; \n{ \nint i = 0 ; \nwhile ( i < query . length ) { \nif ( query [ i ] == null ) throw new IllegalArgumentException ( \"querying by null unsupported; i=\" + i ) ; \nhashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; \ni ++ ; \n} \n} \nHollowHashIndexResult result ; \nHollowHashIndexState hashState ; \ndo { \nresult = null ; \nhashState = hashStateVolatile ; \nlong bucket = hashCode & hashState . getMatchHashMask ( ) ; \nlong hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nboolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \nwhile ( ! bucketIsEmpty ) { \nif ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { \nint selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; \nlong selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; \nresult = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; \nhashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nbucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \n} \n} \nwhile ( hashState != hashStateVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3474": "public class DefaultServiceEnricher { \nprivate Service [ ] toArray ( List < Service > services ) { \nif ( services == null ) { \nreturn new Service [ 0 ] ; \n} \nif ( services instanceof ArrayList ) { \nreturn ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; \n} \nelse { \nService [ ] ret = new Service [ services . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < services . size ( ) ) { \nret [ i ] = services . get ( i ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n} \n"}
{"3490": "public class KubernetesHelper { \npublic static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { \nif ( StringUtils . isBlank ( currentValue ) ) { \nthrow new IllegalArgumentException ( \"No \" + description + \" is specified!\" ) ; \n} \nint size = currentValue . length ( ) ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nchar ch = currentValue . charAt ( i ) ; \nif ( Character . isUpperCase ( ch ) ) { \nthrow new IllegalArgumentException ( \"Invalid upper case letter '\" + ch + \"' at index \" + i + \" for \" + description + \" value: \" + currentValue ) ; \n} \ni ++ ; \n} \n} \nreturn currentValue ; \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nint diff ; \nint length = Math . min ( components1 . length , components2 . length ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( i1 != null && i2 != null ) { \ndiff = i1 . compareTo ( i2 ) ; \n} \nelse { \ndiff = s1 . compareTo ( s2 ) ; \n} \nif ( diff != 0 ) { \nreturn diff ; \n} \ni ++ ; \n} \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) { \nreturn 0 ; \n} \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3519": "public class XmlUtils { \npublic static Element firstChild ( Element element , String name ) { \nNodeList nodes = element . getChildNodes ( ) ; \nif ( nodes != null ) { \n{ \nint i = 0 , size = nodes . getLength ( ) ; \nwhile ( i < size ) { \nNode item = nodes . item ( i ) ; \nif ( item instanceof Element ) { \nElement childElement = ( Element ) item ; \nif ( name . equals ( childElement . getTagName ( ) ) ) { \nreturn childElement ; \n} \n} \ni ++ ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3531": "public class GoTimeUtil { \npublic static BigDecimal durationNs ( String durationP ) { \nif ( durationP == null ) { \nreturn null ; \n} \nString duration = durationP . trim ( ) ; \nif ( duration . length ( ) == 0 ) { \nreturn null ; \n} \nint unitPos = 1 ; \nwhile ( unitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) { \nunitPos ++ ; \n} \nif ( unitPos >= duration . length ( ) ) { \nthrow new IllegalArgumentException ( \"Time unit not found in string: \" + duration ) ; \n} \nString tail = duration . substring ( unitPos ) ; \nLong multiplier = null ; \nInteger unitEnd = null ; \n{ \nint i = 0 ; \nwhile ( i < TIME_UNITS . length ) { \nif ( tail . startsWith ( TIME_UNITS [ i ] ) ) { \nmultiplier = UNIT_MULTIPLIERS [ i ] ; \nunitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( multiplier == null ) { \nthrow new IllegalArgumentException ( \"Unknown time unit in string: \" + duration ) ; \n} \nBigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; \nvalue = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; \nString remaining = duration . substring ( unitEnd ) ; \nBigDecimal remainingValue = durationNs ( remaining ) ; \nif ( remainingValue != null ) { \nvalue = value . add ( remainingValue ) ; \n} \nreturn value ; \n} \n} \n"}
{"3576": "public class PaymentMethodNonce { \npublic static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { \nJSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; \nif ( paymentMethods == null ) { \nreturn Collections . emptyList ( ) ; \n} \nList < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; \nJSONObject json ; \nPaymentMethodNonce paymentMethodNonce ; \n{ \nint i = 0 ; \nwhile ( i < paymentMethods . length ( ) ) { \njson = paymentMethods . getJSONObject ( i ) ; \npaymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; \nif ( paymentMethodNonce != null ) { \npaymentMethodsNonces . add ( paymentMethodNonce ) ; \n} \ni ++ ; \n} \n} \nreturn paymentMethodsNonces ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \n{ \nint i = 0 ; \nwhile ( i < taps . length ) { \nsum += taps [ i ] ; \ni ++ ; \n} \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \n{ \nint i = 0 ; \nwhile ( i < taps . length ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \ni ++ ; \n} \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \n{ \nint i = 0 ; \nwhile ( i < taps . length ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \ni ++ ; \n} \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < taps . length ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n{ \nwhile ( bytesInMarker > 0 && out . hasRemaining ( ) ) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3601": "public class ImageSequenceDemuxer { \npublic int getMaxAvailableFrame ( ) { \nif ( maxAvailableFrame == - 1 ) { \nint firstPoint = 0 ; \n{ \nint i = MAX_MAX ; \nwhile ( i > 0 ) { \nif ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { \nfirstPoint = i ; \nbreak ; \n} \ni /= 2 ; \n} \n} \nint pos = firstPoint ; \n{ \nint interv = firstPoint / 2 ; \nwhile ( interv > 1 ) { \nif ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) { \npos += interv ; \n} \ninterv /= 2 ; \n} \n} \nmaxAvailableFrame = pos ; \nLogger . info ( \"Max frame found: \" + maxAvailableFrame ) ; \n} \nreturn Math . min ( maxAvailableFrame , maxFrames ) ; \n} \n} \n"}
{"3606": "public class QTTimeUtil { \npublic static int timevalueToFrame ( TrakBox trak , long tv ) { \nTimeToSampleEntry [ ] tts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) . getEntries ( ) ; \nint frame = 0 ; \n{ \nint i = 0 ; \nwhile ( tv > 0 && i < tts . length ) { \nlong rem = tv / tts [ i ] . getSampleDuration ( ) ; \ntv -= tts [ i ] . getSampleCount ( ) * tts [ i ] . getSampleDuration ( ) ; \nframe += tv > 0 ? tts [ i ] . getSampleCount ( ) : rem ; \ni ++ ; \n} \n} \nreturn frame ; \n} \n} \n"}
{"3620": "public class WavHeader { \npublic static WavHeader multiChannelWav ( WavHeader [ ] headers ) { \nWavHeader w = emptyWavHeader ( ) ; \nint totalSize = 0 ; \n{ \nint i = 0 ; \nwhile ( i < headers . length ) { \nWavHeader wavHeader = headers [ i ] ; \ntotalSize += wavHeader . dataSize ; \ni ++ ; \n} \n} \nw . dataSize = totalSize ; \nFmtChunk fmt = headers [ 0 ] . fmt ; \nint bitsPerSample = fmt . bitsPerSample ; \nint bytesPerSample = bitsPerSample / 8 ; \nint sampleRate = ( int ) fmt . sampleRate ; \nw . fmt . bitsPerSample = ( short ) bitsPerSample ; \nw . fmt . blockAlign = ( short ) ( headers . length * bytesPerSample ) ; \nw . fmt . byteRate = headers . length * bytesPerSample * sampleRate ; \nw . fmt . numChannels = ( short ) headers . length ; \nw . fmt . sampleRate = sampleRate ; \nreturn w ; \n} \n} \n"}
{"3626": "public class SampleBuffer { \npublic void setBigEndian ( boolean bigEndian ) { \nif ( bigEndian != this . bigEndian ) { \nbyte tmp ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \ntmp = data [ i ] ; \ndata [ i ] = data [ i + 1 ] ; \ndata [ i + 1 ] = tmp ; \ni += 2 ; \n} \n} \nthis . bigEndian = bigEndian ; \n} \n} \n} \n"}
{"3629": "public class EbmlUtil { \npublic static byte [ ] ebmlEncodeLen ( long value , int length ) { \nbyte [ ] b = new byte [ length ] ; \n{ \nint idx = 0 ; \nwhile ( idx < length ) { \nb [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; \nidx ++ ; \n} \n} \nb [ 0 ] |= 0x80 >>> ( length - 1 ) ; \nreturn b ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \n{ \nint i = 0 ; \nwhile ( i < REPOSITION_BUFFER_READS ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3638": "public class SparseIDCT { \npublic static final void start ( int [ ] block , int dc ) { \ndc <<= DC_SHIFT ; \n{ \nint i = 0 ; \nwhile ( i < 64 ) { \nblock [ i + 0 ] = dc ; \nblock [ i + 1 ] = dc ; \nblock [ i + 2 ] = dc ; \nblock [ i + 3 ] = dc ; \ni += 4 ; \n} \n} \n} \n} \n"}
{"3639": "public class SparseIDCT { \npublic static final void coeff ( int [ ] block , int ind , int level ) { \n{ \nint i = 0 ; \nwhile ( i < 64 ) { \nblock [ i ] += COEFF [ ind ] [ i ] * level ; \nblock [ i + 1 ] += COEFF [ ind ] [ i + 1 ] * level ; \nblock [ i + 2 ] += COEFF [ ind ] [ i + 2 ] * level ; \nblock [ i + 3 ] += COEFF [ ind ] [ i + 3 ] * level ; \ni += 4 ; \n} \n} \n} \n} \n"}
{"3640": "public class SparseIDCT { \npublic static final void finish ( int block [ ] ) { \n{ \nint i = 0 ; \nwhile ( i < 64 ) { \nblock [ i ] = div ( block [ i ] ) ; \nblock [ i + 1 ] = div ( block [ i + 1 ] ) ; \nblock [ i + 2 ] = div ( block [ i + 2 ] ) ; \nblock [ i + 3 ] = div ( block [ i + 3 ] ) ; \ni += 4 ; \n} \n} \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \n{ \nint i = 0 ; \nwhile ( i < ID_GAIN ) { \nif ( lngain == LN_GAIN [ i ] ) return i ; \ni ++ ; \n} \n} \nreturn 0 ; \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \n{ \nint i = 0 ; \nwhile ( i < ins . length ) { \nif ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; \ni ++ ; \n} \n} \n{ \nint frames = 0 ; \nwhile ( frames < max && outb . remaining ( ) >= bytesPerFrame ) { \n{ \nint j = 0 ; \nwhile ( j < ins . length ) { \nif ( ins [ j ] . remaining ( ) < bytesPerSample ) { \n{ \nint i = 0 ; \nwhile ( i < bytesPerSample ) { \noutb . put ( ( byte ) 0 ) ; \ni ++ ; \n} \n} \n} \nelse { \n{ \nint i = 0 ; \nwhile ( i < bytesPerSample ) { \noutb . put ( ins [ j ] . get ( ) ) ; \ni ++ ; \n} \n} \n} \nj ++ ; \n} \n} \nframes ++ ; \n} \n} \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * outs . length ; \nwhile ( inb . remaining ( ) >= bytesPerFrame ) { \n{ \nint j = 0 ; \nwhile ( j < outs . length ) { \n{ \nint i = 0 ; \nwhile ( i < bytesPerSample ) { \nouts [ j ] . put ( inb . get ( ) ) ; \ni ++ ; \n} \n} \nj ++ ; \n} \n} \n} \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \n{ \nint i = 0 ; \nwhile ( i < picSizeInMbs ) { \ngroups [ i ] = 1 ; \ni ++ ; \n} \n} \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \n{ \nint k = 0 ; \nwhile ( k < numberOfMbsInBox ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \nk += ( mapUnitVacant ? 1 : 0 ) ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3655": "public class SliceGroupMapBuilder { \npublic static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nint k = 0 ; \n{ \nint j = 0 ; \nwhile ( j < picWidthInMbs ) { \n{ \nint i = 0 ; \nwhile ( i < picHeightInMbs ) { \nint mbAddr = i * picWidthInMbs + j ; \nif ( k ++ < sizeOfUpperLeftGroup ) { \ngroups [ mbAddr ] = changeDirectionInt ; \n} \nelse { \ngroups [ mbAddr ] = 1 - changeDirectionInt ; \n} \ni ++ ; \n} \n} \nj ++ ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3656": "public class MXFMetadata { \nprotected static UL [ ] readULBatch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nUL [ ] result = new UL [ count ] ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nresult [ i ] = UL . read ( _bb ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3657": "public class MXFMetadata { \nprotected static int [ ] readInt32Batch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nint [ ] result = new int [ count ] ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nresult [ i ] = _bb . getInt ( ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3662": "public class ContainerFormat { \npublic java . util . Collection < Codec . ID > getSupportedCodecs ( ) { \nfinal java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; \nfinal java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numCodecs ) { \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) retval . add ( id ) ; \nuniqueSet . add ( id ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3663": "public class ContainerFormat { \npublic java . util . Collection < Long > getSupportedTags ( ) { \nfinal java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; \nfinal java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numCodecs ) { \nlong tag = getSupportedCodecTag ( i ) ; \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( tag ) ) retval . add ( tag ) ; \nuniqueSet . add ( tag ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3666": "public class JNIMemoryManager { \nfinal public void flush ( ) { \nblockingLock ( ) ; \ntry { \nint numSurvivors = sweepAndCollect ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numSurvivors ) { \nfinal JNIReference ref = mValidReferences [ i ] ; \nif ( ref != null ) ref . delete ( ) ; \ni ++ ; \n} \n} \nsweepAndCollect ( ) ; \nmValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; \nmNextAvailableReferenceSlot = 0 ; \nmMaxValidReference = mMinimumReferencesToCache ; \n} \nfinally { \nblockingUnlock ( ) ; \n} \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \n{ \nint i = 0 ; \nwhile ( i < numStreams ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) { \nstream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \n} \nelse { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nint numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < numSettings ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = ( value & flagMask ) > 0 ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \ni ++ ; \n} \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \n} \n} \n"}
{"3683": "public class Codec { \npublic java . util . Collection < Rational > getSupportedVideoFrameRates ( ) { \njava . util . List < Rational > retval = new java . util . LinkedList < Rational > ( ) ; \nint count = getNumSupportedVideoFrameRates ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nRational rate = getSupportedVideoFrameRate ( i ) ; \nif ( rate != null ) retval . add ( rate ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3684": "public class Codec { \npublic java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { \njava . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; \nint count = getNumSupportedVideoPixelFormats ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nPixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; \nif ( type != null && type != PixelFormat . Type . PIX_FMT_NONE ) retval . add ( type ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3685": "public class Codec { \npublic java . util . Collection < Integer > getSupportedAudioSampleRates ( ) { \njava . util . List < Integer > retval = new java . util . LinkedList < Integer > ( ) ; \nint count = getNumSupportedAudioSampleRates ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nint rate = getSupportedAudioSampleRate ( i ) ; \nif ( rate != 0 ) retval . add ( rate ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3686": "public class Codec { \npublic java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { \njava . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; \nint count = getNumSupportedAudioFormats ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nAudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; \nif ( fmt != null && fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) retval . add ( fmt ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3687": "public class Codec { \npublic java . util . Collection < AudioChannel . Layout > getSupportedAudioChannelLayouts ( ) { \njava . util . List < AudioChannel . Layout > retval = new java . util . LinkedList < AudioChannel . Layout > ( ) ; \nint count = getNumSupportedAudioChannelLayouts ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nAudioChannel . Layout layout = getSupportedAudioChannelLayout ( i ) ; \nif ( layout != AudioChannel . Layout . CH_LAYOUT_UNKNOWN ) retval . add ( layout ) ; \ni ++ ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3692": "public class MuxerFormat { \npublic static java . util . Collection < MuxerFormat > getFormats ( ) { \njava . util . Collection < MuxerFormat > retval = new java . util . HashSet < MuxerFormat > ( ) ; \nint count = getNumFormats ( ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nMuxerFormat fmt = getFormat ( i ) ; \nif ( fmt != null ) retval . add ( fmt ) ; \n++ i ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \n{ \nint i = 0 ; \nwhile ( i < numStreams ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nelse { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \n{ \nint i = 0 ; \nwhile ( i < duration / framerate . getDouble ( ) ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \ni ++ ; \n} \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) input = input . substring ( 7 ) ; \nif ( input . length ( ) == 0 ) return new byte [ 0 ] ; \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < input . length ( ) ) { \nchar c = input . charAt ( i ) ; \nint digit = c < 128 ? INDEXES [ c ] : - 1 ; \nif ( digit < 0 ) { \nthrow new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \n} \ninput58 [ i ] = ( byte ) digit ; \n++ i ; \n} \n} \nint zeros = 0 ; \nwhile ( zeros < input58 . length && input58 [ zeros ] == 0 ) { \n++ zeros ; \n} \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nint outputStart = decoded . length ; \n{ \nint inputStart = zeros ; \nwhile ( inputStart < input58 . length ) { \ndecoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) { \n++ inputStart ; \n} \n} \n} \nwhile ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) { \n++ outputStart ; \n} \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3718": "public class PrivateKeyAccount { \npublic static String generateSeed ( ) { \nbyte [ ] bytes = new byte [ 21 ] ; \nnew SecureRandom ( ) . nextBytes ( bytes ) ; \nbyte [ ] rhash = hash ( bytes , 0 , 20 , SHA256 ) ; \nbytes [ 20 ] = rhash [ 0 ] ; \nBigInteger rand = new BigInteger ( bytes ) ; \nBigInteger mask = new BigInteger ( new byte [ ] { \n0 , 0 , 7 , - 1 } \n) ; \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < 15 ) { \nsb . append ( i > 0 ? ' ' : \"\" ) . append ( SEED_WORDS [ rand . and ( mask ) . intValue ( ) ] ) ; \nrand = rand . shiftRight ( 11 ) ; \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( required <= memory . length ( ) ) return ; \nmutationCount ++ ; \nSystem . out . println ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \n{ \nlong i = 0 ; \nwhile ( i < max + 2 ) { \nf . write ( toWrite ) ; \ni ++ ; \n} \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . println ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3746": "public class FSTConfiguration { \npublic FSTConfiguration registerCrossPlatformClassMapping ( String [ ] [ ] keysAndVals ) { \n{ \nint i = 0 ; \nwhile ( i < keysAndVals . length ) { \nString [ ] keysAndVal = keysAndVals [ i ] ; \nregisterCrossPlatformClassMapping ( keysAndVal [ 0 ] , keysAndVal [ 1 ] ) ; \ni ++ ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3749": "public class MBOut { \nprotected void writeRawInt ( byte type , long data ) { \nint numBytes = MinBin . extractNumBytes ( type ) ; \n{ \nint i = 0 ; \nwhile ( i < numBytes ) { \nwriteOut ( ( byte ) ( data & 0xff ) ) ; \ndata = data >>> 8 ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse if ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse if ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \n{ \nint i = start ; \nwhile ( i < start + len ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \ni ++ ; \n} \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \n{ \nint i = start ; \nwhile ( i < start + len ) { \nwriteRawInt ( type , arr [ i ] ) ; \ni ++ ; \n} \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \n{ \nint i = start ; \nwhile ( i < start + len ) { \nwriteRawInt ( type , charArr [ i ] ) ; \ni ++ ; \n} \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \n{ \nint i = start ; \nwhile ( i < start + len ) { \nwriteRawInt ( type , arr [ i ] ) ; \ni ++ ; \n} \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \n{ \nint i = start ; \nwhile ( i < start + len ) { \nwriteRawInt ( type , arr [ i ] ) ; \ni ++ ; \n} \n} \n} \nbreak ; \ndefault : { \n{ \nint i = start ; \nwhile ( i < start + len ) { \nif ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \ni ++ ; \n} \n} \n} \n} \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) { \nif ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse writeObjectWithContext ( referencee , toWrite , null ) ; \ni ++ ; \n} \n} \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( subArr == null ) { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"3758": "public class StructString { \npublic void setString ( String s ) { \nif ( s == null ) { \nsetLen ( 0 ) ; \nreturn ; \n} \nif ( s . length ( ) > charsLen ( ) ) { \nthrow new RuntimeException ( \"String length exceeds buffer size. String len \" + s . length ( ) + \" charsLen:\" + charsLen ( ) ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nchars ( i , s . charAt ( i ) ) ; \ni ++ ; \n} \n} \nlen = s . length ( ) ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nint sumLen = 0 ; \n{ \nint i = 0 ; \nwhile ( i < curIndex ) { \nsumLen += changeLength [ i ] ; \ni ++ ; \n} \n} \nsnapshot = new byte [ sumLen ] ; \nint targetIdx = 0 ; \n{ \nint i = 0 ; \nwhile ( i < curIndex ) { \nint changeOffset = changeOffsets [ i ] ; \nint len = changeLength [ i ] ; \n{ \nint ii = 0 ; \nwhile ( ii < len ) { \nsnapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; \nii ++ ; \n} \n} \ni ++ ; \n} \n} \nrebase ( originBase ) ; \n} \n} \n"}
{"3777": "public class BooleanIndexing { \npublic static boolean or ( IComplexNDArray n , Condition cond ) { \nboolean ret = false ; \nIComplexNDArray linear = n . linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < linear . length ( ) ) { \nret = ret || cond . apply ( linear . getComplex ( i ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \n{ \nint i = 0 ; \nwhile ( i < arr . length ( ) ) { \nif ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; \nelse result [ i ] = false ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < arr . length ( ) ) { \nif ( arr . getDouble ( i ) > 0 ) result [ i ] = true ; \nelse result [ i ] = false ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3784": "public class FunctionProperties { \npublic static FunctionProperties fromFlatProperties ( FlatProperties properties ) { \nval props = new FunctionProperties ( ) ; \n{ \nint e = 0 ; \nwhile ( e < properties . iLength ( ) ) { \nprops . getI ( ) . add ( properties . i ( e ) ) ; \ne ++ ; \n} \n} \n{ \nint e = 0 ; \nwhile ( e < properties . lLength ( ) ) { \nprops . getL ( ) . add ( properties . l ( e ) ) ; \ne ++ ; \n} \n} \n{ \nint e = 0 ; \nwhile ( e < properties . dLength ( ) ) { \nprops . getD ( ) . add ( properties . d ( e ) ) ; \ne ++ ; \n} \n} \n{ \nint e = 0 ; \nwhile ( e < properties . iLength ( ) ) { \nprops . getA ( ) . add ( Nd4j . createFromFlatArray ( properties . a ( e ) ) ) ; \ne ++ ; \n} \n} \nreturn props ; \n} \n} \n"}
{"3788": "public class MathUtils { \npublic static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { \nif ( x . size ( ) != y . size ( ) ) throw new IllegalArgumentException ( \"Sample sizes must be the same for each data applyTransformToDestination.\" ) ; \nList < Double > ret = new ArrayList < Double > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < x . size ( ) ) { \nret . add ( x . get ( i ) ) ; \nret . add ( y . get ( i ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) { \n{ \nint i = 1 ; \nwhile ( i < arrs . length ) { \nif ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \ni ++ ; \n} \n} \n} \nelse { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \n{ \nint i = 1 ; \nwhile ( i < arrs . length ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"3799": "public class BaseNDArrayFactory { \n@ Override public INDArray linspace ( int lower , int upper , int num ) { \ndouble [ ] data = new double [ num ] ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \ndouble t = ( double ) i / ( num - 1 ) ; \ndata [ i ] = lower * ( 1 - t ) + t * upper ; \ni ++ ; \n} \n} \nINDArray ret = Nd4j . create ( data . length ) ; \nif ( ret . isScalar ( ) ) return ret ; \n{ \nint i = 0 ; \nwhile ( i < ret . length ( ) ) { \nret . putScalar ( i , data [ i ] ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3801": "public class BaseNDArrayFactory { \n@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { \nassert curr . shape ( ) . length == 3 ; \nif ( in . columns ( ) != 1 ) { \nthrow new AssertionError ( \"Expected a column vector\" ) ; \n} \nif ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Number of rows in the input does not match number of columns in tensor\" ) ; \n} \nif ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Can only perform this operation on a SimpleTensor with square slices\" ) ; \n} \nINDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; \nINDArray inT = in . transpose ( ) ; \n{ \nint i = 0 ; \nwhile ( i < curr . slices ( ) ) { \nINDArray slice = curr . slice ( i ) ; \nINDArray inTTimesSlice = inT . mmul ( slice ) ; \nret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < getFeatures ( ) . length ( ) ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( curr > cutoff ) getFeatures ( ) . putScalar ( i , 1 ) ; \nelse getFeatures ( ) . putScalar ( i , 0 ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3814": "public class DataSet { \n@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { \nINDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; \nINDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; \nSet < Integer > added = new HashSet < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numSamples ) { \nint picked = rng . nextInt ( numExamples ( ) ) ; \nif ( ! withReplacement ) while ( added . contains ( picked ) ) picked = rng . nextInt ( numExamples ( ) ) ; \nexamples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; \noutcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; \ni ++ ; \n} \n} \nreturn new DataSet ( examples , outcomes ) ; \n} \n} \n"}
{"3818": "public class StringUtils { \npublic static String arrayToString ( String [ ] strs ) { \nif ( strs . length == 0 ) { \nreturn \"\" ; \n} \nStringBuilder sbuf = new StringBuilder ( ) ; \nsbuf . append ( strs [ 0 ] ) ; \n{ \nint idx = 1 ; \nwhile ( idx < strs . length ) { \nsbuf . append ( \",\" ) ; \nsbuf . append ( strs [ idx ] ) ; \nidx ++ ; \n} \n} \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"3819": "public class StringUtils { \npublic static String byteToHexString ( byte [ ] bytes , int start , int end ) { \nif ( bytes == null ) { \nthrow new IllegalArgumentException ( \"bytes == null\" ) ; \n} \nStringBuilder s = new StringBuilder ( ) ; \n{ \nint i = start ; \nwhile ( i < end ) { \ns . append ( format ( \"%02x\" , bytes [ i ] ) ) ; \ni ++ ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"3823": "public class StringUtils { \npublic static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { \nint numPreEscapes = 0 ; \n{ \nint i = start ; \nwhile ( i < str . length ( ) ) { \nchar curChar = str . charAt ( i ) ; \nif ( numPreEscapes == 0 && curChar == separator ) { \nreturn i ; \n} \nelse { \nsplit . append ( curChar ) ; \nnumPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3838": "public class Shape { \npublic static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { \nINDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; \n{ \nint i = 0 ; \nwhile ( i < ret . length ) { \nret [ i ] = new NDArrayIndex ( indices [ i ] ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3841": "public class NioUtil { \npublic static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { \nByteBuffer fromView = from ; \nByteBuffer toView = to ; \nfromView . order ( ByteOrder . nativeOrder ( ) ) ; \ntoView . order ( ByteOrder . nativeOrder ( ) ) ; \nswitch ( bufferType ) { \ncase INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; \nIntBuffer toInt = toView . asIntBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nint put = fromInt . get ( fromOffset + i * fromStride ) ; \ntoInt . put ( toOffset + i * toStride , put ) ; \ni ++ ; \n} \n} \nbreak ; \ncase FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; \nFloatBuffer toFloat = toView . asFloatBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nfloat put = fromFloat . get ( fromOffset + i * fromStride ) ; \ntoFloat . put ( toOffset + i * toStride , put ) ; \ni ++ ; \n} \n} \nbreak ; \ncase DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; \nDoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \ntoDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; \ni ++ ; \n} \n} \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Only floats and double supported\" ) ; \n} \n} \n} \n"}
{"3856": "public class CpuLapack { \n@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { \nINDArray tau = Nd4j . create ( N ) ; \nint status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sgeqrf\" , status ) ; \n} \nif ( R != null ) { \nR . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; \nINDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; \n{ \nint i = 1 ; \nwhile ( i < Math . min ( A . rows ( ) , A . columns ( ) ) ) { \nix [ 0 ] = NDArrayIndex . point ( i ) ; \nix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; \nR . put ( ix , 0 ) ; \ni ++ ; \n} \n} \n} \nstatus = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sorgqr\" , status ) ; \n} \n} \n} \n"}
{"3860": "public class AsynchronousFlowController { \nprotected void sweepTail ( ) { \nInteger deviceId = allocator . getDeviceId ( ) ; \nint cnt = 0 ; \nlong lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; \n{ \nint l = 0 ; \nwhile ( l < configuration . getCommandLanesNumber ( ) ) { \nQueue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; \nif ( queue . size ( ) >= MAX_EXECUTION_QUEUE || laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null && ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt ++ ; \n} \n} \nl ++ ; \n} \n} \ndeviceClocks . get ( deviceId ) . incrementAndGet ( ) ; \n} \n} \n"}
{"3888": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray expi ( IComplexNDArray toExp ) { \nIComplexNDArray flattened = toExp . ravel ( ) ; \n{ \nint i = 0 ; \nwhile ( i < flattened . length ( ) ) { \nIComplexNumber n = flattened . getComplex ( i ) ; \nflattened . put ( i , Nd4j . scalar ( ComplexUtil . exp ( n ) ) ) ; \ni ++ ; \n} \n} \nreturn flattened . reshape ( toExp . shape ( ) ) ; \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; \n{ \nint i = 0 ; \nwhile ( i < shape . length ) { \nif ( shape [ i ] < 1 ) shape [ i ] = 1 ; \ni ++ ; \n} \n} \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( shapeMatrix . length ( ) > 1 ) return arr . get ( indexes ) ; \nelse { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nint start = ( int ) startIndex . getDouble ( 0 ) ; \nint end = ( int ) endIndex . getDouble ( 0 ) ; \nint count = 0 ; \n{ \nint i = start ; \nwhile ( i < end ) { \nret . putScalar ( count ++ , arr . getComplex ( i ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n} \n"}
{"3890": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray truncate ( IComplexNDArray nd , int n , int dimension ) { \nif ( nd . isVector ( ) ) { \nIComplexNDArray truncated = Nd4j . createComplex ( new int [ ] { \n1 , n } \n) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \ntruncated . putScalar ( i , nd . getComplex ( i ) ) ; \ni ++ ; \n} \n} \nreturn truncated ; \n} \nif ( nd . size ( dimension ) > n ) { \nlong [ ] shape = ArrayUtil . copy ( nd . shape ( ) ) ; \nshape [ dimension ] = n ; \nIComplexNDArray ret = Nd4j . createComplex ( shape ) ; \nIComplexNDArray ndLinear = nd . linearView ( ) ; \nIComplexNDArray retLinear = ret . linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < ret . length ( ) ) { \nretLinear . putScalar ( i , ndLinear . getComplex ( i ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \nreturn nd ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numDevices ) { \nif ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { \nset ( i , array ) ; \n} \nelse { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"3895": "public class BigDecimalMath { \nstatic public BigDecimal gamma ( MathContext mc ) { \nif ( mc . getPrecision ( ) < GAMMA . precision ( ) ) { \nreturn GAMMA . round ( mc ) ; \n} \nelse { \ndouble eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; \nMathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; \nBigDecimal resul = BigDecimal . ONE ; \nresul = resul . add ( log ( 2 , mcloc ) ) ; \nresul = resul . subtract ( log ( 3 , mcloc ) ) ; \nint kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; \nmcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; \n{ \nint n = 1 ; \nwhile ( ) { \nBigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; \nBigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; \nfourn = fourn . shiftLeft ( 2 * n ) ; \nc = divideRound ( c , fourn ) ; \nresul = resul . subtract ( c ) ; \nif ( c . doubleValue ( ) < 0.1 * eps ) { \nbreak ; \n} \nn ++ ; \n} \n} \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3898": "public class BigDecimalMath { \nstatic public BigDecimal root ( final int n , final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nthrow new ArithmeticException ( \"negative argument \" + x . toString ( ) + \" of root\" ) ; \n} \nif ( n <= 0 ) { \nthrow new ArithmeticException ( \"negative power \" + n + \" of root\" ) ; \n} \nif ( n == 1 ) { \nreturn x ; \n} \nBigDecimal s = new BigDecimal ( Math . pow ( x . doubleValue ( ) , 1.0 / n ) ) ; \nfinal BigDecimal nth = new BigDecimal ( n ) ; \nfinal BigDecimal xhighpr = scalePrec ( x , 2 ) ; \nMathContext mc = new MathContext ( 2 + x . precision ( ) ) ; \nfinal double eps = x . ulp ( ) . doubleValue ( ) / ( 2 * n * x . doubleValue ( ) ) ; \n{ \nwhile ( ) { \nBigDecimal c = xhighpr . divide ( s . pow ( n - 1 ) , mc ) ; \nc = s . subtract ( c ) ; \nMathContext locmc = new MathContext ( c . precision ( ) ) ; \nc = c . divide ( nth , locmc ) ; \ns = s . subtract ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) / s . doubleValue ( ) ) < eps ) { \nbreak ; \n} \n} \n} \nreturn s . round ( new MathContext ( err2prec ( eps ) ) ) ; \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \n{ \nint i = 1 ; \nwhile ( i <= TAYLOR_NTERM ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \ni ++ ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub -- > 0 ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( res . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \nelse if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse { \nif ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \n{ \nint i = 1 ; \nwhile ( ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \ni ++ ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn tan ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( xDbl > 0.8 ) { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \nelse { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \n{ \nint i = 2 ; \nwhile ( ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) { \nbreak ; \n} \ni ++ ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn cos ( x . negate ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ONE ; \n} \nelse { \nif ( x . doubleValue ( ) > 1.5 ) { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \n{ \nint i = 1 ; \nwhile ( ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \ni ++ ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nif ( x . doubleValue ( ) > 2.4 ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \n{ \nint i = 1 ; \nwhile ( ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \ni ++ ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \nelse if ( x . doubleValue ( ) > 1.5 ) { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \n{ \nint n = 2 ; \nwhile ( ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( eps / 100. / c . doubleValue ( ) < 0.01 ) { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nelse { \nm = new MathContext ( 2 ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) { \nresul = resul . add ( c ) ; \n} \nelse { \nresul = resul . subtract ( c ) ; \n} \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) { \nbreak ; \n} \nn ++ ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \n{ \nint n = 1 ; \nwhile ( n < 5 ) { \npsi += zdbl / n / ( n + zdbl ) ; \nn ++ ; \n} \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n"}
{"3911": "public class BigDecimalMath { \nstatic protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { \ndouble x = 0.0 ; \n{ \nint k = 1 ; \nwhile ( k < 10 ) { \nx += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; \nk ++ ; \n} \n} \ndouble eps = prec2err ( x , mc . getPrecision ( ) ) ; \nint kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; \neps /= kmax ; \nBigDecimal res = BigDecimal . ZERO ; \n{ \nint c = 0 ; \nwhile ( ) { \nRational r = new Rational ( ) ; \n{ \nint k = 0 ; \nwhile ( k < 8 ) { \nRational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; \nint pk1h = p * ( 2 + 8 * c + k ) / 2 ; \ntmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; \nr = r . add ( tmp ) ; \nk ++ ; \n} \n} \nif ( Math . abs ( r . doubleValue ( ) ) < eps ) { \nbreak ; \n} \nMathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; \nres = res . add ( r . BigDecimalValue ( mcloc ) ) ; \nc ++ ; \n} \n} \nreturn res . round ( mc ) ; \n} \n} \n"}
{"3918": "public class SameDiff { \npublic void putShapeForVarName ( String varName , long [ ] shape ) { \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Shape must not be null!\" ) ; \n} \nif ( variableNameToShape . containsKey ( varName ) ) { \nthrow new ND4JIllegalStateException ( \"Shape for \" + varName + \" already exists!\" ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < shape . length ) { \nif ( shape [ i ] < 1 ) { \naddAsPlaceHolder ( varName ) ; \nplaceHolderOriginalShapes . put ( varName , shape ) ; \nreturn ; \n} \ni ++ ; \n} \n} \nvariableNameToShape . put ( varName , shape ) ; \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \n} \nif ( varNames == null ) throw new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \n{ \nint i = 0 ; \nwhile ( i < varNames . length ) { \nif ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \ni ++ ; \n} \n} \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3925": "public class SameDiff { \npublic INDArray [ ] eval ( Map < String , INDArray > inputs ) { \nSameDiff execPipeline = dup ( ) ; \nList < DifferentialFunction > opExecAction = execPipeline . exec ( ) . getRight ( ) ; \nif ( opExecAction . isEmpty ( ) ) throw new IllegalStateException ( \"No ops found to execute.\" ) ; \nINDArray [ ] ret = new INDArray [ opExecAction . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < ret . length ) { \nval varName = opExecAction . get ( i ) . outputVariables ( ) [ 0 ] . getVarName ( ) ; \nret [ i ] = execPipeline . getArrForVarName ( varName ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3929": "public class SameDiff { \npublic void removeArgFromFunction ( String varName , DifferentialFunction function ) { \nval args = function . args ( ) ; \n{ \nint i = 0 ; \nwhile ( i < args . length ) { \nif ( args [ i ] . getVarName ( ) . equals ( varName ) ) { \nval reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nincomingArgs . remove ( reverseArgs ) ; \nincomingArgsReverse . remove ( function . getOwnName ( ) ) ; \nval newArgs = new ArrayList < String > ( args . length - 1 ) ; \n{ \nint arg = 0 ; \nwhile ( arg < args . length ) { \nif ( ! reverseArgs [ arg ] . equals ( varName ) ) { \nnewArgs . add ( reverseArgs [ arg ] ) ; \n} \narg ++ ; \n} \n} \nval newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; \nincomingArgs . put ( newArgsArr , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; \nbreak ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"3933": "public class SameDiff { \npublic List < DifferentialFunction > exec ( List < DifferentialFunction > ops ) { \n{ \nint i = 0 ; \nwhile ( i < ops . size ( ) ) { \nOp op = ( Op ) ops . get ( i ) ; \nNd4j . getExecutioner ( ) . exec ( op ) ; \ni ++ ; \n} \n} \nreturn ops ; \n} \n} \n"}
{"3960": "public class BaseDataFetcher { \nprotected void initializeCurrFromList ( List < DataSet > examples ) { \nif ( examples . isEmpty ( ) ) log . warn ( \"Warning: empty dataset from the fetcher\" ) ; \nINDArray inputs = createInputMatrix ( examples . size ( ) ) ; \nINDArray labels = createOutputMatrix ( examples . size ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < examples . size ( ) ) { \ninputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; \nlabels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; \ni ++ ; \n} \n} \ncurr = new DataSet ( inputs , labels ) ; \n} \n} \n"}
{"3961": "public class AtomicAllocator { \nprotected void initHostCollectors ( ) { \n{ \nint i = 0 ; \nwhile ( i < configuration . getNumberOfGcThreads ( ) ) { \nReferenceQueue < BaseDataBuffer > queue = new ReferenceQueue < > ( ) ; \nUnifiedGarbageCollectorThread uThread = new UnifiedGarbageCollectorThread ( i , queue ) ; \nNd4j . getAffinityManager ( ) . attachThreadToDevice ( uThread , getDeviceId ( ) ) ; \nqueueMap . put ( i , queue ) ; \nuThread . start ( ) ; \ncollectorsUnified . put ( i , uThread ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < index . rows ( ) ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \n{ \nint j = 0 ; \nwhile ( j < row . columns ( ) ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \nj ++ ; \n} \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \ni ++ ; \n} \n} \nreturn ret ; \n} \nelse if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3969": "public class DifferentialFunction { \npublic List < SDVariable > diff ( List < SDVariable > i_v1 ) { \nList < SDVariable > vals = doDiff ( i_v1 ) ; \nif ( vals == null ) { \nthrow new IllegalStateException ( \"Error executing diff operation: doDiff returned null for op: \" + this . opName ( ) ) ; \n} \nval outputVars = args ( ) ; \n{ \nint i = 0 ; \nwhile ( i < vals . size ( ) ) { \nSDVariable var = outputVars [ i ] ; \nSDVariable grad = var . getGradient ( ) ; \nif ( grad != null ) { \nSDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; \ntry { \nvals . set ( i , gradVar ) ; \n} \ncatch ( UnsupportedOperationException e ) { \nthrow new UnsupportedOperationException ( \"Use a mutable list when returning values from \" + this . getClass ( ) . getSimpleName ( ) + \".doDiff (e.g. Arrays.asList instead of Collections.singletonList)\" , e ) ; \n} \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \n} \nelse { \nSDVariable gradVar = vals . get ( i ) ; \nsameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + \"-grad\" ) ; \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \nsameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; \n} \ni ++ ; \n} \n} \nreturn vals ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse { \nint i = 0 ; \nwhile ( i < linear . length ( ) ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse { \nint i = 0 ; \nwhile ( i < linear . length ( ) ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"3977": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray epsi ( Number other ) { \nIComplexNDArray linear = linearView ( ) ; \ndouble otherVal = other . doubleValue ( ) ; \n{ \nint i = 0 ; \nwhile ( i < linearView ( ) . length ( ) ) { \nIComplexNumber n = linear . getComplex ( i ) ; \ndouble real = n . realComponent ( ) . doubleValue ( ) ; \ndouble diff = Math . abs ( real - otherVal ) ; \nif ( diff <= Nd4j . EPS_THRESHOLD ) linear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; \nelse linear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; \ni ++ ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3978": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { \nif ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; \nIComplexNDArray linear = linearView ( ) ; \nIComplexNDArray otherLinear = arr . linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < linear . length ( ) ) { \nlinear . putScalar ( i , otherLinear . getComplex ( i ) ) ; \ni ++ ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3979": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray getRows ( int [ ] rindices ) { \nINDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < rindices . length ) { \nrows . putRow ( i , getRow ( rindices [ i ] ) ) ; \ni ++ ; \n} \n} \nreturn ( IComplexNDArray ) rows ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( toPut instanceof IComplexNDArray ) { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \n{ \nint i = 0 ; \nwhile ( i < r . length ( ) ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \ni ++ ; \n} \n} \n} \nelse { \n{ \nint i = 0 ; \nwhile ( i < r . length ( ) ) { \nr . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \ni ++ ; \n} \n} \n} \nreturn this ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) { \nreturn cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( isScalar ( ) ) { \nreturn cOther . addi ( getComplex ( 0 ) , result ) ; \n} \nif ( result == this ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \n} \nelse if ( result == other ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < resultLinear . length ( ) ) { \nresultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \ni ++ ; \n} \n} \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3986": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( Number value ) { \nIComplexNDArray one = linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < one . length ( ) ) { \none . putScalar ( i , Nd4j . createDouble ( value . doubleValue ( ) , 0 ) ) ; \ni ++ ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3987": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray ravel ( ) { \nif ( length ( ) >= Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"length() can not be >= Integer.MAX_VALUE\" ) ; \nIComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; \nIComplexNDArray linear = linearView ( ) ; \n{ \nint i = 0 ; \nwhile ( i < length ( ) ) { \nret . putScalar ( i , linear . getComplex ( i ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( negSamples > 0 ) { \nint negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nint resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nint e = 0 ; \n{ \nwhile ( e < codes . length ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \ne ++ ; \n} \n} \n{ \nwhile ( e < resultLength ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \ne ++ ; \n} \n} \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \nelse if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \n} \n} \n"}
{"4020": "public class GenericTypeReflector { \nstatic boolean isMissingTypeParameters ( Type type ) { \nif ( type instanceof Class ) { \n{ \nClass < ? > clazz = ( Class < ? > ) type ; \nwhile ( clazz != null ) { \nif ( clazz . getTypeParameters ( ) . length != 0 ) return true ; \nclazz = clazz . getEnclosingClass ( ) ; \n} \n} \nreturn false ; \n} \nelse if ( type instanceof ParameterizedType ) { \nreturn false ; \n} \nelse { \nthrow new AssertionError ( \"Unexpected type \" + type . getClass ( ) ) ; \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \nreturn false ; \n} \nelse if ( superType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \n{ \nint i = 0 ; \nwhile ( i < superTypeArgs . length ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n"}
{"4074": "public class Values { \npublic static void homogenizeIndexes ( final List < Value < ? > > list ) { \nif ( isIndexHomogeneous ( list ) ) return ; \n{ \nint i = 0 ; \nwhile ( i < list . size ( ) ) { \nfinal Value < ? > value = list . get ( i ) ; \nif ( value . excludeFromIndexes ( ) ) list . set ( i , index ( value , true ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"4079": "public class IfConditionGenerator { \npublic If < ? , ? > [ ] generateIfConditions ( Class < ? extends If < ? , ? > > [ ] ifClasses , Field field ) { \nif ( ifClasses . length == 0 ) return ALWAYS ; \nIf < ? , ? > [ ] result = new If < ? , ? > [ ifClasses . length ] ; \n{ \nint i = 0 ; \nwhile ( i < ifClasses . length ) { \nClass < ? extends If < ? , ? > > ifClass = ifClasses [ i ] ; \nresult [ i ] = this . createIf ( ifClass , field ) ; \nType valueType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 0 ] ) ; \nClass < ? > valueClass = GenericTypeReflector . erase ( valueType ) ; \nType pojoType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 1 ] ) ; \nClass < ? > pojoClass = GenericTypeReflector . erase ( pojoType ) ; \nif ( ! TypeUtils . isAssignableFrom ( valueClass , field . getType ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because you cannot assign \" + field . getType ( ) . getName ( ) + \" to \" + valueClass . getName ( ) ) ; \nif ( ! TypeUtils . isAssignableFrom ( pojoClass , field . getDeclaringClass ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because the containing class \" + field . getDeclaringClass ( ) . getName ( ) + \" is not compatible with \" + pojoClass . getName ( ) ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { \nreturn imps ; \n} \nelse if ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \n{ \ni = 1 ; \nwhile ( i < size ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n++ i ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4108": "public class ProtoUtils { \npublic static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { \ncheckNotNull ( filter ) ; \n{ \nint i = 0 ; \nwhile ( i < objs . size ( ) ) { \nif ( ! filter . test ( objs . get ( i ) ) ) { \nreturn filterFrom ( objs , filter , i ) ; \n} \n++ i ; \n} \n} \nreturn objs ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nint equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \n{ \nint i = 1 ; \nwhile ( i < tokens . length ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) secure = true ; \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) { \npath = ti . substring ( 5 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) { \ndomain = ti . substring ( 7 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) { \nexpires = ti . substring ( 8 ) ; \n} \ni ++ ; \n} \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) continue ; \n} \nif ( expires != null ) { \ntry { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) continue ; \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4139": "public class CookieConverter { \npublic static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { \ntry { \nif ( cookieDomain . startsWith ( \".\" ) ) { \ncookieDomain = cookieDomain . substring ( 1 ) ; \n} \nString [ ] domainTokens = cookieDomain . split ( \"\\\\.\" ) ; \nString [ ] hostTokens = urlHostName . split ( \"\\\\.\" ) ; \nint tokenDif = hostTokens . length - domainTokens . length ; \nif ( tokenDif < 0 ) { \nreturn false ; \n} \n{ \nint i = domainTokens . length - 1 ; \nwhile ( i >= 0 ) { \nif ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) { \nreturn false ; \n} \ni -- ; \n} \n} \nreturn true ; \n} \ncatch ( Exception e ) { \nreturn true ; \n} \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) return ; \nint numNodes = nodes . getLength ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numNodes ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \n{ \nint att = 0 ; \nwhile ( att < attrs . getLength ( ) ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \n{ \natt ++ ; \ncontinue ; \n} \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \n{ \natt ++ ; \ncontinue ; \n} \n} \natt ++ ; \n} \n} \nif ( isRobots && content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"4144": "public class Rules { \npublic boolean filter ( String url , Metadata metadata ) throws MalformedURLException { \nURL u = new URL ( url ) ; \nString hostname = u . getHost ( ) ; \nif ( checkScope ( hostNameRules . get ( hostname ) , u ) ) { \nreturn true ; \n} \nString [ ] domainParts = hostname . split ( \"\\\\.\" ) ; \nString domain = null ; \n{ \nint i = domainParts . length - 1 ; \nwhile ( i >= 0 ) { \ndomain = domainParts [ i ] + ( domain == null ? \"\" : \".\" + domain ) ; \nif ( checkScope ( domainRules . get ( domain ) , u ) ) { \nreturn true ; \n} \ni -- ; \n} \n} \nfor ( MDScope scope : metadataRules ) { \nString [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; \nif ( vals == null ) { \ncontinue ; \n} \nfor ( String v : vals ) { \nif ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { \nFastURLFilter . LOG . debug ( \"Filtering {} matching metadata {}:{}\" , url , scope . getKey ( ) , scope . getValue ( ) ) ; \nif ( checkScope ( scope , u ) ) { \nreturn true ; \n} \n} \n} \n} \nif ( checkScope ( globalRules , u ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4176": "public class ArrayChar { \npublic void setString ( String val ) { \nint rank = getRank ( ) ; \nif ( rank != 1 ) throw new IllegalArgumentException ( \"ArayChar.setString rank must be 1\" ) ; \nint arrayLen = indexCalc . getShape ( 0 ) ; \nint strLen = Math . min ( val . length ( ) , arrayLen ) ; \n{ \nint k = 0 ; \nwhile ( k < strLen ) { \nstorage [ k ] = val . charAt ( k ) ; \nk ++ ; \n} \n} \nchar c = 0 ; \n{ \nint k = strLen ; \nwhile ( k < arrayLen ) { \nstorage [ k ] = c ; \nk ++ ; \n} \n} \n} \n} \n"}
{"4178": "public class ArrayChar { \npublic static ArrayChar makeFromString ( String s , int max ) { \nArrayChar result = new ArrayChar . D1 ( max ) ; \n{ \nint i = 0 ; \nwhile ( i < max && i < s . length ( ) ) { \nresult . setChar ( i , s . charAt ( i ) ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nint start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \n{ \nint k = 0 ; \nwhile ( k < s . length ( ) && k < strlen ) { \ncdata [ start + k ] = s . charAt ( k ) ; \nk ++ ; \n} \n} \nstart += strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4206": "public class CatalogWatcher { \npublic void processEvents ( ) { \nif ( ! enable ) return ; \n{ \nwhile ( ) { \nWatchKey key ; \ntry { \nkey = watcher . take ( ) ; \n} \ncatch ( InterruptedException x ) { \nreturn ; \n} \nPath dir = keys . get ( key ) ; \nif ( dir == null ) { \nSystem . err . println ( \"WatchKey not recognized!!\" ) ; \n{ \ncontinue ; \n} \n} \nfor ( WatchEvent < ? > event : key . pollEvents ( ) ) { \nWatchEvent . Kind kind = event . kind ( ) ; \nif ( kind == OVERFLOW ) { \n{ \ncontinue ; \n} \n} \nWatchEvent < Path > ev = cast ( event ) ; \nPath name = ev . context ( ) ; \nPath child = dir . resolve ( name ) ; \nSystem . out . format ( \"%s: %s%n\" , event . kind ( ) . name ( ) , child ) ; \nif ( recursive && ( kind == ENTRY_CREATE ) ) { \ntry { \nif ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) { \nregisterAll ( child ) ; \n} \n} \ncatch ( IOException x ) { \n} \n} \n} \nboolean valid = key . reset ( ) ; \nif ( ! valid ) { \nkeys . remove ( key ) ; \nif ( keys . isEmpty ( ) ) { \nbreak ; \n} \n} \n} \n} \n} \n} \n"}
{"4227": "public class GradsAttribute { \npublic static GradsAttribute parseAttribute ( String attrSpec ) { \nString [ ] toks = attrSpec . split ( \"\\\\s+\" ) ; \nStringBuffer buf = new StringBuffer ( ) ; \n{ \nint i = 4 ; \nwhile ( i < toks . length ) { \nbuf . append ( toks [ i ] ) ; \nbuf . append ( \" \" ) ; \ni ++ ; \n} \n} \nreturn new GradsAttribute ( toks [ 1 ] , toks [ 2 ] , toks [ 3 ] , buf . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) { \nif ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \nbreak ; \n} \n{ \nint pos = 1 ; \nwhile ( pos < sb . length ( ) ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) { \nif ( cp < ' ' || cp > 0x7E || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \n++ pos ; \n} \n} \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( cp <= 0x7f && Character . isWhitespace ( cp ) ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4240": "public class GradsTimeDimension { \npublic static boolean hasTimeTemplate ( String template ) { \n{ \nint i = 0 ; \nwhile ( i < timeTemplates . length ) { \nif ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) { \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \n{ \nint i = 0 ; \nwhile ( i < args . length ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \ni ++ ; \n} \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4258": "public class SerialWriter { \npublic void writeAtomicArray ( DapType daptype , Object values ) throws IOException { \nassert values != null && values . getClass ( ) . isArray ( ) ; \nByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; \nbyte [ ] bytes = buf . array ( ) ; \nint len = buf . position ( ) ; \nwriteBytes ( bytes , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"%s: \" , daptype . getShortName ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nint x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; \nSystem . err . printf ( \"%02x\" , ( int ) ( x & 0xff ) ) ; \ni ++ ; \n} \n} \nSystem . err . println ( ) ; \n} \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nSystem . err . printf ( \"%02x\" , bytes [ i ] ) ; \ni ++ ; \n} \n} \nSystem . err . println ( ) ; \n} \n} \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nSystem . err . printf ( \" %02x\" , bytes [ i ] ) ; \ni ++ ; \n} \n} \nSystem . err . println ( \"\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \n} \n} \n"}
{"4267": "public class McIDASGridReader { \npublic float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { \nfloat [ ] data ; \nint te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; \nint rows = gr . getRows ( ) ; \nint cols = gr . getColumns ( ) ; \nrf . seek ( te ) ; \nfloat scale = ( float ) gr . getParamScale ( ) ; \ndata = new float [ rows * cols ] ; \nrf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; \n{ \nint nc = 0 ; \nwhile ( nc < cols ) { \n{ \nint nr = 0 ; \nwhile ( nr < rows ) { \nint temp = rf . readInt ( ) ; \ndata [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; \nnr ++ ; \n} \n} \nnc ++ ; \n} \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn data ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . println ( \"found \" + grids . size ( ) + \" grids\" ) ; \nint num = Math . min ( grids . size ( ) , 10 ) ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \nSystem . out . println ( grids . get ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( nbits <= 1 ) || ( nbits > 31 ) ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \n{ \nint i = 0 ; \nwhile ( i < kxky ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft -= 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) { \ngrid [ i ] = RMISSD ; \n} \nelse { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nibit += nbits ; \nif ( ibit > 32 ) { \nibit -= 32 ; \niword ++ ; \n} \ni ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4279": "public class GempakGridReader { \nprivate float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { \nfloat [ ] values = new float [ kxky ] ; \nbitPos = 0 ; \nbitBuf = 0 ; \nnext = 0 ; \nch1 = 0 ; \nch2 = 0 ; \nch3 = 0 ; \nch4 = 0 ; \nrf . seek ( getOffset ( iiword ) ) ; \nint idat ; \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \n{ \nint i = 0 ; \nwhile ( i < values . length ) { \nidat = bits2UInt ( nbits ) ; \nif ( miss && ( idat == IMISSD ) ) { \nvalues [ i ] = IMISSD ; \n} \nelse { \nvalues [ i ] = ( ref + scale * idat ) * scaleFactor ; \n} \ni ++ ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4291": "public class DownloadController { \nstatic protected String escapeString ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nint c = s . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : buf . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : buf . append ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '\\n' : buf . append ( '\\n' ) ; \nbreak ; \ncase '\\r' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\t' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\f' : buf . append ( '\\f' ) ; \nbreak ; \ndefault : if ( c < ' ' ) buf . append ( String . format ( \"\\\\x%02x\" , ( c & 0xff ) ) ) ; \nelse buf . append ( ( char ) c ) ; \nbreak ; \n} \ni ++ ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4292": "public class CDMUtil { \nstatic public List < Slice > createSlices ( List < Range > rangelist ) throws dap4 . core . util . DapException { \nList < Slice > slices = new ArrayList < Slice > ( rangelist . size ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < rangelist . size ( ) ) { \nRange r = rangelist . get ( i ) ; \nint stride = r . stride ( ) ; \nint first = r . first ( ) ; \nint n = r . length ( ) ; \nint stop = first + ( n * stride ) ; \nSlice cer = new Slice ( first , stop - 1 , stride ) ; \nslices . add ( cer ) ; \ni ++ ; \n} \n} \nreturn slices ; \n} \n} \n"}
{"4293": "public class CDMUtil { \nstatic public NetcdfFile unwrapfile ( NetcdfFile file ) { \n{ \nwhile ( ) { \nif ( file instanceof NetcdfDataset ) { \nNetcdfDataset ds = ( NetcdfDataset ) file ; \nfile = ds . getReferencedFile ( ) ; \nif ( file == null ) break ; \n} \nelse break ; \n} \n} \nreturn file ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; \nint effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \n{ \nint i = 0 ; \nwhile ( i < effectiverank ) { \nshape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \ni ++ ; \n} \n} \nreturn shape ; \n} \n} \n"}
{"4302": "public class ScaledUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfinal float scale = ( float ) getScale ( ) ; \n{ \nint i = input . length ; \nwhile ( -- i >= 0 ) { \noutput [ i ] = input [ i ] * scale ; \n} \n} \nif ( ! ( _unit instanceof DerivableUnit ) ) { \nthrow new ConversionException ( this , getDerivedUnit ( ) ) ; \n} \nreturn ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"4313": "public class MFlowLayout { \npublic Dimension preferredLayoutSize ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nDimension dim = new Dimension ( 0 , 0 ) ; \n{ \nint i = 0 ; \nwhile ( i < target . getComponentCount ( ) ) { \nComponent m = target . getComponent ( i ) ; \nif ( m . isVisible ( ) ) { \nDimension d = m . getPreferredSize ( ) ; \nPoint p = m . getLocation ( ) ; \ndim . width = Math . max ( dim . width , p . x + d . width ) ; \ndim . height = Math . max ( dim . height , p . y + d . height ) ; \n} \ni ++ ; \n} \n} \nInsets insets = target . getInsets ( ) ; \ndim . width += insets . left + insets . right + getHgap ( ) * 2 ; \ndim . height += insets . top + insets . bottom + getVgap ( ) * 2 ; \nreturn dim ; \n} \n} \n} \n"}
{"4314": "public class CatalogBuilderHelper { \nstatic CrawlableDataset verifyDescendantDataset ( CrawlableDataset ancestorCrDs , String path , CrawlableDatasetFilter filter ) { \nif ( ! ancestorCrDs . isCollection ( ) ) throw new IllegalArgumentException ( \"Ancestor dataset <\" + ancestorCrDs . getPath ( ) + \"> not a collection.\" ) ; \nif ( ! path . startsWith ( ancestorCrDs . getPath ( ) ) ) throw new IllegalArgumentException ( \"Dataset path <\" + path + \"> not descendant of given dataset <\" + ancestorCrDs . getPath ( ) + \">.\" ) ; \nif ( path . length ( ) == ancestorCrDs . getPath ( ) . length ( ) ) return ancestorCrDs ; \nString remainingPath = path . substring ( ancestorCrDs . getPath ( ) . length ( ) ) ; \nif ( remainingPath . startsWith ( \"/\" ) ) remainingPath = remainingPath . substring ( 1 ) ; \nString [ ] pathSegments = remainingPath . split ( \"/\" ) ; \nCrawlableDataset curCrDs = ancestorCrDs ; \n{ \nint i = 0 ; \nwhile ( i < pathSegments . length ) { \ncurCrDs = curCrDs . getDescendant ( pathSegments [ i ] ) ; \nif ( filter != null ) if ( ! filter . accept ( curCrDs ) ) return null ; \ni ++ ; \n} \n} \nif ( ! curCrDs . exists ( ) ) return null ; \nreturn curCrDs ; \n} \n} \n"}
{"4321": "public class UnitDimension { \npublic QuantityDimension getQuantityDimension ( ) { \nFactor [ ] factors = getFactors ( ) ; \n{ \nint i = factors . length ; \nwhile ( -- i >= 0 ) { \nFactor factor = factors [ i ] ; \nfactors [ i ] = new Factor ( ( ( BaseUnit ) factor . getBase ( ) ) . getBaseQuantity ( ) , factor . getExponent ( ) ) ; \n} \n} \nreturn new QuantityDimension ( factors ) ; \n} \n} \n"}
{"4335": "public class GridServiceProvider { \nprivate void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nGridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; \nint nx = hsys . getNx ( ) ; \nGridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; \nif ( record == null ) { \nAttribute att = v2 . findAttribute ( \"missing_value\" ) ; \nfloat missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; \nint xyCount = yRange . length ( ) * xRange . length ( ) ; \n{ \nint j = 0 ; \nwhile ( j < xyCount ) { \nii . setFloatNext ( missing_value ) ; \nj ++ ; \n} \n} \nreturn ; \n} \nfloat [ ] data = _readData ( record ) ; \nif ( data == null ) { \n_readData ( record ) ; \nreturn ; \n} \nfor ( int y : yRange ) { \nfor ( int x : xRange ) { \nint index = y * nx + x ; \nii . setFloatNext ( data [ index ] ) ; \n} \n} \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \n{ \nint i = 0 ; \nwhile ( i < nelems ) { \nsequenceOffset [ i ] = total ; \ntotal += sequenceLen [ i ] ; \ni ++ ; \n} \n} \nsdata = new StructureData [ nelems ] ; \n{ \nint i = 0 ; \nwhile ( i < nelems ) { \nsdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \ni ++ ; \n} \n} \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( tabStop > len ) { \nsbuff . setLength ( tabStop ) ; \n{ \nint i = len ; \nwhile ( i < tabStop ) { \nsbuff . setCharAt ( i , ' ' ) ; \ni ++ ; \n} \n} \n} \nelse if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \n} \n} \n"}
{"4340": "public class Format { \npublic static String pad ( String s , int width , boolean rightJustify ) { \nif ( s . length ( ) >= width ) { \nreturn s ; \n} \nStringBuilder sbuff = new StringBuilder ( width ) ; \nint need = width - s . length ( ) ; \nsbuff . setLength ( need ) ; \n{ \nint i = 0 ; \nwhile ( i < need ) { \nsbuff . setCharAt ( i , ' ' ) ; \ni ++ ; \n} \n} \nif ( rightJustify ) { \nsbuff . append ( s ) ; \n} \nelse { \nsbuff . insert ( 0 , s ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4346": "public class GridDatasetInfo { \nprivate String getShapeString ( int [ ] shape ) { \nStringBuilder buf = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < shape . length ) { \nif ( i != 0 ) buf . append ( \" \" ) ; \nbuf . append ( shape [ i ] ) ; \ni ++ ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \n{ \ni = 0 ; \nwhile ( buf . position ( ) < stop ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \ni ++ ; \n} \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4355": "public class NcStreamDataCol { \npublic Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nArray [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; \nint count = 0 ; \nfor ( int len : dproto . getVlensList ( ) ) { \nArray primdata = Array . factory ( dataType , new int [ ] { \nlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \ni ++ ; \n} \n} \ndata [ count ++ ] = primdata ; \n} \nreturn Array . makeVlenArray ( section . getShape ( ) , data ) ; \n} \n} \n"}
{"4356": "public class NcStreamDataCol { \nprivate Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nint psize = ( int ) parentSection . computeSize ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nSection vsection = section . removeFirst ( parentSection ) ; \nint vsectionSize = ( int ) vsection . computeSize ( ) ; \nint countInner = 0 ; \nArray [ ] pdata = new Array [ psize ] ; \n{ \nint pCount = 0 ; \nwhile ( pCount < psize ) { \nArray [ ] vdata = new Array [ vsectionSize ] ; \n{ \nint vCount = 0 ; \nwhile ( vCount < vsectionSize ) { \nint vlen = dproto . getVlens ( countInner ++ ) ; \nArray primdata = Array . factory ( dataType , new int [ ] { \nvlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \n{ \nint i = 0 ; \nwhile ( i < vlen ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \ni ++ ; \n} \n} \nvdata [ vCount ] = primdata ; \nvCount ++ ; \n} \n} \npdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; \npCount ++ ; \n} \n} \nreturn Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; \n} \n} \n"}
{"4364": "public class CoordinateRuntime { \npublic List < Double > getOffsetsInTimeUnits ( ) { \ndouble start = firstDate . getMillis ( ) ; \nList < Double > result = new ArrayList < > ( runtimes . length ) ; \n{ \nint idx = 0 ; \nwhile ( idx < runtimes . length ) { \ndouble runtime = ( double ) getRuntime ( idx ) ; \ndouble msecs = ( runtime - start ) ; \nresult . add ( msecs / timeUnit . getValueInMillisecs ( ) ) ; \nidx ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4375": "public class GridHorizCoordSys { \nprivate double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . setDimensions ( name ) ; \ndouble [ ] data = new double [ n ] ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \ndata [ i ] = start + incr * i ; \ni ++ ; \n} \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nn } \n, data ) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( \"units\" , units ) ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , desc ) ) ; \nv . addAttribute ( new Attribute ( \"standard_name\" , standard_name ) ) ; \nv . addAttribute ( new Attribute ( \"grid_spacing\" , incr + \" \" + units ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; \nncfile . addVariable ( g , v ) ; \nreturn data ; \n} \n} \n"}
{"4412": "public class Index { \npublic long index ( ) { \nlong offset = 0 ; \n{ \nint i = 0 ; \nwhile ( i < this . indices . length ) { \noffset *= this . dimsizes [ i ] ; \noffset += this . indices [ i ] ; \ni ++ ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) return ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nd [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nint checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; \n{ \nint i = 0 ; \nwhile ( i < checkDims ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4447": "public class DSPRegistry { \nsynchronized public void unregister ( Class < ? extends DSP > klass ) { \n{ \nint i = 0 ; \nwhile ( i < registry . size ( ) ) { \nif ( registry . get ( i ) . dspclass == klass ) { \nregistry . remove ( i ) ; \nbreak ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) return ; \nif ( this . ce == null ) this . visiblenodes = nodelist ; \nelse { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < nodelist . size ( ) ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) visiblenodes . add ( node ) ; \ni ++ ; \n} \n} \n} \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \n} \n} \n"}
{"4453": "public class DapDataset { \npublic void sort ( ) { \nList < DapNode > sorted = new ArrayList < DapNode > ( ) ; \nsortR ( this , sorted ) ; \n{ \nint i = 0 ; \nwhile ( i < sorted . size ( ) ) { \nsorted . get ( i ) . setIndex ( i ) ; \ni ++ ; \n} \n} \nthis . nodelist = sorted ; \n} \n} \n"}
{"4468": "public class CoordinateAxis2D { \nprivate int findClosest ( ArrayDouble . D2 boundsForRun , double target ) { \ndouble minDiff = Double . MAX_VALUE ; \nint idxFound = - 1 ; \nint n = boundsForRun . getShape ( ) [ 0 ] ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \ndouble midpoint = ( boundsForRun . get ( i , 0 ) + boundsForRun . get ( i , 1 ) ) / 2.0 ; \ndouble diff = Math . abs ( midpoint - target ) ; \nif ( diff < minDiff ) { \nminDiff = diff ; \nidxFound = i ; \n} \ni ++ ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( start + max > data . length ) System . out . println ( \"HEY KMPMatch\" ) ; \n{ \nint i = start ; \nwhile ( i < start + max ) { \nwhile ( j > 0 && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j ++ ; \nif ( j == match . length ) return i - match . length + 1 ; \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4489": "public class ColorScale { \npublic void setNumColors ( int n ) { \nif ( n != ncolors ) { \ncolors = new Color [ n ] ; \nint prevn = Math . min ( ncolors , n ) ; \nSystem . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; \n{ \nint i = ncolors ; \nwhile ( i < n ) { \ncolors [ i ] = Color . white ; \ni ++ ; \n} \n} \nuseColors = colors ; \nncolors = n ; \nedge = new double [ ncolors ] ; \nhist = new int [ ncolors + 1 ] ; \n} \n} \n} \n"}
{"4495": "public class SmartArrayInt { \npublic int findIdx ( int want ) { \nif ( isConstant ) return ( want == start ) ? 0 : - 1 ; \nif ( isSequential ) return want - start ; \nif ( isSorted ) { \nreturn Arrays . binarySearch ( raw , want ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < raw . length ) { \nif ( raw [ i ] == want ) return i ; \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4500": "public class CatGenConfigMetadataFactory { \nprivate CatalogGenConfig readCatGenConfigElement ( InvDataset parentDataset , Element catGenConfElement ) { \nString type = catGenConfElement . getAttributeValue ( \"type\" ) ; \nCatalogGenConfig catGenConf = new CatalogGenConfig ( parentDataset , type ) ; \njava . util . List list = catGenConfElement . getChildren ( \"datasetSource\" , catGenConfElement . getNamespace ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < list . size ( ) ) { \nElement dsSourceElement = ( Element ) list . get ( i ) ; \ncatGenConf . setDatasetSource ( readDatasetSourceElement ( parentDataset , dsSourceElement ) ) ; \ni ++ ; \n} \n} \nreturn ( catGenConf ) ; \n} \n} \n"}
{"4501": "public class CatGenConfigMetadataFactory { \nprivate DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { \nString name = dsSourceElement . getAttributeValue ( \"name\" ) ; \nString type = dsSourceElement . getAttributeValue ( \"type\" ) ; \nString structure = dsSourceElement . getAttributeValue ( \"structure\" ) ; \nString accessPoint = dsSourceElement . getAttributeValue ( \"accessPoint\" ) ; \nString createCatalogRefs = dsSourceElement . getAttributeValue ( \"createCatalogRefs\" ) ; \nElement resultServiceElement = dsSourceElement . getChild ( \"resultService\" , dsSourceElement . getNamespace ( ) ) ; \nResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; \nDatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; \nif ( createCatalogRefs != null ) { \ndsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; \n} \njava . util . List list = dsSourceElement . getChildren ( \"datasetNamer\" , dsSourceElement . getNamespace ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < list . size ( ) ) { \nElement dsNamerElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; \ni ++ ; \n} \n} \nlist = dsSourceElement . getChildren ( \"datasetFilter\" , dsSourceElement . getNamespace ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < list . size ( ) ) { \nElement dsFilterElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; \ni ++ ; \n} \n} \nreturn ( dsSource ) ; \n} \n} \n"}
{"4506": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { \nElement dssElem = new Element ( \"datasetSource\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsSource != null ) { \nif ( dsSource . getName ( ) != null ) { \ndssElem . setAttribute ( \"name\" , dsSource . getName ( ) ) ; \n} \nif ( dsSource . getType ( ) != null ) { \ndssElem . setAttribute ( \"type\" , dsSource . getType ( ) . toString ( ) ) ; \n} \nif ( dsSource . getStructure ( ) != null ) { \ndssElem . setAttribute ( \"structure\" , dsSource . getStructure ( ) . toString ( ) ) ; \n} \nif ( dsSource . getAccessPoint ( ) != null ) { \ndssElem . setAttribute ( \"accessPoint\" , dsSource . getAccessPoint ( ) ) ; \n} \ndssElem . setAttribute ( \"createCatalogRefs\" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; \nResultService rs = dsSource . getResultService ( ) ; \ndssElem . addContent ( createResultServiceElement ( rs ) ) ; \njava . util . List list = dsSource . getDatasetNamerList ( ) ; \n{ \nint j = 0 ; \nwhile ( j < list . size ( ) ) { \nDatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; \ndssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; \nj ++ ; \n} \n} \nlist = dsSource . getDatasetFilterList ( ) ; \n{ \nint j = 0 ; \nwhile ( j < list . size ( ) ) { \nDatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; \ndssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; \nj ++ ; \n} \n} \n} \nreturn ( dssElem ) ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) { \nthrow new IOException ( \"Unable to open \" + tbl ) ; \n} \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) { \ncontinue ; \n} \nif ( tline . startsWith ( \"!\" ) ) { \ncontinue ; \n} \nString [ ] words = new String [ indices . length ] ; \n{ \nint idx = 0 ; \nwhile ( idx < indices . length ) { \nif ( indices [ idx ] >= tline . length ( ) ) { \n{ \nidx ++ ; \ncontinue ; \n} \n} \nif ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) { \nwords [ idx ] = line . substring ( indices [ idx ] ) ; \n} \nelse { \nwords [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \n} \nwords [ idx ] = words [ idx ] . trim ( ) ; \nidx ++ ; \n} \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) { \nif ( p . getName ( ) . contains ( \"(\" ) ) { \ntemplateParamMap . put ( p . getName ( ) , p ) ; \n} \nelse { \nparamMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nint num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) { \nnum = ( int ) Double . parseDouble ( words [ 0 ] ) ; \n} \nif ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( \"\" ) ) { \nreturn null ; \n} \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nint first = name . indexOf ( \"-\" ) ; \nint last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \n{ \nint i = first ; \nwhile ( i <= last ) { \nbuf . append ( \"\\\\d\" ) ; \ni ++ ; \n} \n} \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) { \ndescription = words [ 3 ] ; \n} \nelse { \ndescription = words [ 1 ] ; \n} \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) { \nunit = \"\" ; \n} \n} \nint decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4541": "public class IospHelper { \nstatic public char [ ] convertByteToChar ( byte [ ] byteArray ) { \nint size = byteArray . length ; \nchar [ ] cbuff = new char [ size ] ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \ncbuff [ i ] = ( char ) DataType . unsignedByteToShort ( byteArray [ i ] ) ; \ni ++ ; \n} \n} \nreturn cbuff ; \n} \nstatic public byte [ ] convertCharToByte ( char [ ] from ) { \nbyte [ ] to = null ; \nif ( from != null ) { \nint size = from . length ; \nto = new byte [ size ] ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nto [ i ] = ( byte ) from [ i ] ; \ni ++ ; \n} \n} \n} \nreturn to ; \n} \n} \n"}
{"4547": "public class CDMArrayStructure { \nstatic StructureMembers computemembers ( DapVariable var ) { \nDapStructure ds = ( DapStructure ) var . getBaseType ( ) ; \nStructureMembers sm = new StructureMembers ( ds . getShortName ( ) ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \n{ \nint i = 0 ; \nwhile ( i < fields . size ( ) ) { \nDapVariable field = fields . get ( i ) ; \nDapType dt = field . getBaseType ( ) ; \nDataType cdmtype = CDMTypeFcns . daptype2cdmtype ( dt ) ; \nStructureMembers . Member m = sm . addMember ( field . getShortName ( ) , \"\" , null , cdmtype , CDMUtil . computeEffectiveShape ( field . getDimensions ( ) ) ) ; \nm . setDataParam ( i ) ; \nif ( dt . getTypeSort ( ) . isStructType ( ) ) { \nStructureMembers subsm = computemembers ( field ) ; \nm . setStructureMembers ( subsm ) ; \n} \ni ++ ; \n} \n} \nreturn sm ; \n} \n} \n"}
{"4554": "public class Aggregation { \nprotected void makeDatasets ( CancelTask cancelTask ) throws IOException { \ndatasets = new ArrayList < > ( ) ; \nfor ( MFile cd : datasetManager . getFilesSorted ( ) ) { \ndatasets . add ( makeDataset ( cd ) ) ; \n} \nCollections . sort ( datasets ) ; \nfor ( Aggregation . Dataset dataset : explicitDatasets ) { \ndatasets . add ( dataset ) ; \n} \n{ \nIterator < Dataset > datasetsIter = datasets . iterator ( ) ; \nwhile ( datasetsIter . hasNext ( ) ) { \nDataset dataset = datasetsIter . next ( ) ; \nPath datasetPath ; \nif ( dataset . getMFile ( ) instanceof MFileOS ) { \ndatasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; \n} \nelse if ( dataset . getMFile ( ) instanceof MFileOS7 ) { \ndatasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; \n} \nelse { \n{ \ncontinue ; \n} \n} \nif ( ! Files . isReadable ( datasetPath ) ) { \nlogger . warn ( \"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath ) ; \ndatasetsIter . remove ( ) ; \n} \n} \n} \nSet < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; \nfor ( Aggregation . Dataset dataset : datasets ) { \nif ( dset . contains ( dataset . cacheLocation ) ) logger . warn ( \"Duplicate dataset in aggregation = \" + dataset . cacheLocation ) ; \ndset . add ( dataset . cacheLocation ) ; \n} \nif ( datasets . size ( ) == 0 ) { \nthrow new IllegalStateException ( \"There are no datasets in the aggregation \" + datasetManager ) ; \n} \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) { \nreturn ; \n} \nIterator < Element > iter = values . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) { \niter . remove ( ) ; \n} \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \n{ \nint i = 0 ; \nwhile ( i < values . size ( ) ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) { \ndim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \n} \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \ni ++ ; \n} \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) { \nlog . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . println ( name + \" layoutContainer \" ) ; \nint n = target . getComponentCount ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \ni ++ ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4581": "public class URLDumpPane { \nprivate void openURL ( String urlString , Command command ) { \ntry { \nURL u = new URL ( urlString ) ; \ncurrentConnection = ( HttpURLConnection ) u . openConnection ( ) ; \ncurrentConnection . setRequestMethod ( command . toString ( ) ) ; \ncurrentConnection . setAllowUserInteraction ( true ) ; \nclear ( ) ; \nappendLine ( command + \" request for \" + urlString ) ; \nMap < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; \nfor ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { \nappend ( \" \" + ent . getKey ( ) + \": \" ) ; \nfor ( String v : ent . getValue ( ) ) append ( v + \" \" ) ; \nappendLine ( \"\" ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"getFollowRedirects=\" + HttpURLConnection . getFollowRedirects ( ) ) ; \nappendLine ( \"getInstanceFollowRedirects=\" + currentConnection . getInstanceFollowRedirects ( ) ) ; \nappendLine ( \"AllowUserInteraction=\" + currentConnection . getAllowUserInteraction ( ) ) ; \nappendLine ( \"\" ) ; \nint code = currentConnection . getResponseCode ( ) ; \nString response = currentConnection . getResponseMessage ( ) ; \nappendLine ( \" HTTP/1.x \" + code + \" \" + response ) ; \nappendLine ( \" content-length: \" + currentConnection . getContentLength ( ) ) ; \nappendLine ( \" content-encoding: \" + currentConnection . getContentEncoding ( ) ) ; \nappendLine ( \" content-type: \" + currentConnection . getContentType ( ) ) ; \nappendLine ( \"\\nHeaders: \" ) ; \n{ \nint j = 1 ; \nwhile ( true ) { \nString header = currentConnection . getHeaderField ( j ) ; \nString key = currentConnection . getHeaderFieldKey ( j ) ; \nif ( header == null || key == null ) break ; \nappendLine ( \" \" + key + \": \" + header ) ; \nj ++ ; \n} \n} \nappendLine ( \"\" ) ; \nappendLine ( \"contents:\" ) ; \njava . io . InputStream is = currentConnection . getInputStream ( ) ; \nByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; \nIO . copy ( is , bout ) ; \nis . close ( ) ; \nappend ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; \nappendLine ( \"end contents\" ) ; \n} \ncatch ( MalformedURLException e ) { \nappend ( urlString + \" is not a parseable URL\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4587": "public class CoordinateTime2DUnionizer { \nvoid setRuntimeCoords ( CoordinateRuntime runtimes ) { \n{ \nint idx = 0 ; \nwhile ( idx < runtimes . getSize ( ) ) { \nCalendarDate cd = runtimes . getRuntimeDate ( idx ) ; \nlong runtime = runtimes . getRuntime ( idx ) ; \nCoordinateTimeAbstract time = timeMap . get ( runtime ) ; \nif ( time == null ) { \ntime = isTimeInterval ? new CoordinateTimeIntv ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) : new CoordinateTime ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) ; \ntimeMap . put ( runtime , time ) ; \n} \nidx ++ ; \n} \n} \n} \n} \n"}
{"4601": "public class WRFEta { \nprivate ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { \nint [ ] shape = array . getShape ( ) ; \nint [ ] newShape = new int [ 3 ] ; \nSystem . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; \nnewShape [ dimIndex ] ++ ; \nint ni = newShape [ 0 ] ; \nint nj = newShape [ 1 ] ; \nint nk = newShape [ 2 ] ; \nArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; \nint n = shape [ dimIndex ] ; \ndouble [ ] d = new double [ n ] ; \nint [ ] eshape = new int [ 3 ] ; \nint [ ] neweshape = new int [ 3 ] ; \n{ \nint i = 0 ; \nwhile ( i < 3 ) { \neshape [ i ] = ( i == dimIndex ) ? n : 1 ; \nneweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; \ni ++ ; \n} \n} \nint [ ] origin = new int [ 3 ] ; \ntry { \n{ \nint i = 0 ; \nwhile ( i < ( ( dimIndex == 0 ) ? 1 : ni ) ) { \n{ \nint j = 0 ; \nwhile ( j < ( ( dimIndex == 1 ) ? 1 : nj ) ) { \n{ \nint k = 0 ; \nwhile ( k < ( ( dimIndex == 2 ) ? 1 : nk ) ) { \norigin [ 0 ] = i ; \norigin [ 1 ] = j ; \norigin [ 2 ] = k ; \nIndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; \n{ \nint l = 0 ; \nwhile ( l < n ) { \nd [ l ] = it . getDoubleNext ( ) ; \nl ++ ; \n} \n} \ndouble [ ] d2 = extrapinterpolate ( d ) ; \nIndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; \n{ \nint l = 0 ; \nwhile ( l < n + 1 ) { \nnewit . setDoubleNext ( d2 [ l ] ) ; \nl ++ ; \n} \n} \nk ++ ; \n} \n} \nj ++ ; \n} \n} \ni ++ ; \n} \n} \n} \ncatch ( InvalidRangeException e ) { \nreturn null ; \n} \nreturn newArray ; \n} \n} \n"}
{"4602": "public class WRFEta { \nprivate double [ ] extrapinterpolate ( double [ ] array ) { \nint n = array . length ; \ndouble [ ] d = new double [ n + 1 ] ; \nd [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; \nd [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; \n{ \nint i = 1 ; \nwhile ( i < n ) { \nd [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; \ni ++ ; \n} \n} \nreturn d ; \n} \n} \n"}
{"4609": "public class GempakStationFileIOSP { \nprotected int getStnVarSize ( String name ) { \nint size = - 1 ; \n{ \nint i = 0 ; \nwhile ( i < stnVarNames . length ) { \nif ( name . equals ( stnVarNames [ i ] ) ) { \nsize = stnVarSizes [ i ] ; \nbreak ; \n} \ni ++ ; \n} \n} \nreturn size ; \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) { \nif ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nint yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nint yyxbegin = yyn < 0 ? - yyn : 0 ; \nint yychecklim = yylast_ - yyn + 1 ; \nint yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; \nint count = 0 ; \n{ \nint x = yyxbegin ; \nwhile ( x < yyxend ) { \nif ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; \n++ x ; \n} \n} \nif ( count < 5 ) { \ncount = 0 ; \n{ \nint x = yyxbegin ; \nwhile ( x < yyxend ) { \nif ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count ++ == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n++ x ; \n} \n} \n} \n} \nreturn res . toString ( ) ; \n} \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4613": "public class CeParser { \nprivate void yy_reduce_print ( int yyrule , YYStack yystack ) { \nif ( yydebug == 0 ) return ; \nint yylno = yyrline_ [ yyrule ] ; \nint yynrhs = yyr2_ [ yyrule ] ; \nyycdebug ( \"Reducing stack by rule \" + ( yyrule - 1 ) + \" (line \" + yylno + \"), \" ) ; \n{ \nint yyi = 0 ; \nwhile ( yyi < yynrhs ) { \nyy_symbol_print ( \"   $\" + ( yyi + 1 ) + \" =\" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; \nyyi ++ ; \n} \n} \n} \n} \n"}
{"4623": "public class SimpleGeometryIndexFinder { \npublic int getBeginning ( int index ) { \nif ( index == ( pastIndex + 1 ) ) { \nreturn previousEnd + 1 ; \n} \nint newBeginning = 0 ; \n{ \nint i = 0 ; \nwhile ( i < index ) { \nnewBeginning += getNodeCount ( i ) ; \ni ++ ; \n} \n} \npastIndex = index ; \npreviousBegin = newBeginning ; \nreturn newBeginning ; \n} \n} \n"}
{"4624": "public class SimpleGeometryIndexFinder { \npublic int getEnd ( int index ) { \nif ( index == ( pastIndex - 1 ) ) { \nreturn previousBegin - 1 ; \n} \nint new_end = 0 ; \n{ \nint i = 0 ; \nwhile ( i < index + 1 ) { \nnew_end += getNodeCount ( i ) ; \ni ++ ; \n} \n} \npastIndex = index ; \npreviousEnd = new_end ; \nreturn new_end - 1 ; \n} \n} \n"}
{"4640": "public class Variable { \npublic int findDimensionIndex ( String name ) { \n{ \nint i = 0 ; \nwhile ( i < dimensions . size ( ) ) { \nDimension d = dimensions . get ( i ) ; \nif ( name . equals ( d . getShortName ( ) ) ) return i ; \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4653": "public class Variable { \npublic void resetShape ( ) { \nthis . shape = new int [ dimensions . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < dimensions . size ( ) ) { \nDimension dim = dimensions . get ( i ) ; \nshape [ i ] = dim . getLength ( ) ; \nif ( dim . isVariableLength ( ) ) { \nisVariableLength = true ; \n} \ni ++ ; \n} \n} \nthis . shapeAsSection = null ; \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) { \nbuildseqtype ( cdmvar ) ; \n} \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \n{ \nint i = 0 ; \nwhile ( i < fields . size ( ) ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \n{ \nint i = 0 ; \nwhile ( i < dimset . size ( ) ) { \nif ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount ++ ; \n} \nelse core . add ( dimset . get ( i ) ) ; \ni ++ ; \n} \n} \nif ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \n{ \nint i = 0 ; \nwhile ( i < m . groupCount ( ) ) { \nSystem . out . println ( \" \" + i + \" \" + m . group ( i ) ) ; \ni ++ ; \n} \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \n{ \nwhile ( ) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4712": "public class Parse { \nstatic public String cleanCharacterData ( String text ) { \nif ( text == null ) return null ; \nboolean bad = false ; \n{ \nint i = 0 , len = text . length ( ) ; \nwhile ( i < len ) { \nint ch = text . charAt ( i ) ; \nif ( ! org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { \nbad = true ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( ! bad ) return text ; \nStringBuilder sbuff = new StringBuilder ( text . length ( ) ) ; \n{ \nint i = 0 , len = text . length ( ) ; \nwhile ( i < len ) { \nint ch = text . charAt ( i ) ; \nif ( org . jdom2 . Verifier . isXMLCharacter ( ch ) ) sbuff . append ( ( char ) ch ) ; \ni ++ ; \n} \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \n{ \nint i = 0 ; \nwhile ( i < utf8 . length ) { \nbyte b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 ++ ] = blank ; \n} \nelse if ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \nout [ index8 ++ ] = b ; \n} \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4717": "public class Escape { \npublic static String backslashEncode ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nint c = buf . charAt ( i ) ; \nif ( _MustBackslashEscape . indexOf ( c ) >= 0 ) buf . append ( _BACKSLASHEscape ) ; \nbuf . append ( ( char ) c ) ; \ni ++ ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4720": "public class Swap { \nstatic public int swapInt ( byte [ ] b , int offset ) { \nint accum = 0 ; \n{ \nint shiftBy = 0 , i = offset ; \nwhile ( shiftBy < 32 ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \ni ++ ; \nshiftBy += 8 ; \n} \n} \nreturn accum ; \n} \n} \n"}
{"4721": "public class Swap { \nstatic public double swapDouble ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \n{ \nint shiftBy = 0 , i = offset ; \nwhile ( shiftBy < 64 ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \ni ++ ; \nshiftBy += 8 ; \n} \n} \nreturn Double . longBitsToDouble ( accum ) ; \n} \n} \n"}
{"4724": "public class Swap { \nstatic public byte [ ] shortToBytes ( short v ) { \nbyte [ ] b = new byte [ 2 ] ; \nint allbits = 255 ; \n{ \nint i = 0 ; \nwhile ( i < 2 ) { \nb [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \ni ++ ; \n} \n} \nreturn b ; \n} \n} \n"}
{"4725": "public class Swap { \nstatic public byte [ ] intToBytes ( int v ) { \nbyte [ ] b = new byte [ 4 ] ; \nint allbits = 255 ; \n{ \nint i = 0 ; \nwhile ( i < 4 ) { \nb [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \ni ++ ; \n} \n} \nreturn b ; \n} \n} \n"}
{"4726": "public class Swap { \nstatic public byte [ ] longToBytes ( long v ) { \nbyte [ ] b = new byte [ 8 ] ; \nlong allbits = 255 ; \n{ \nint i = 0 ; \nwhile ( i < 8 ) { \nb [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \ni ++ ; \n} \n} \nreturn b ; \n} \n} \n"}
{"4729": "public class OceanS { \nprivate Array makeC ( Array s , double a , double b ) { \nint nz = ( int ) s . getSize ( ) ; \nIndex sIndex = s . getIndex ( ) ; \nif ( a == 0 ) return s ; \nArrayDouble . D1 c = new ArrayDouble . D1 ( nz ) ; \ndouble fac1 = 1.0 - b ; \ndouble denom1 = 1.0 / Math . sinh ( a ) ; \ndouble denom2 = 1.0 / ( 2.0 * Math . tanh ( 0.5 * a ) ) ; \n{ \nint i = 0 ; \nwhile ( i < nz ) { \ndouble sz = s . getDouble ( sIndex . set ( i ) ) ; \ndouble term1 = fac1 * Math . sinh ( a * sz ) * denom1 ; \ndouble term2 = b * ( Math . tanh ( a * ( sz + 0.5 ) ) * denom2 - 0.5 ) ; \nc . set ( i , term1 + term2 ) ; \ni ++ ; \n} \n} \nreturn c ; \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( hcs . isLatLon ( ) ) { \ndims = dims + \" lat lon\" ; \n} \nelse { \ndims = dims + \" y x\" ; \n} \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) { \naxisType = AxisType . Pressure ; \n} \nelse if ( SimpleUnit . isCompatible ( \"m\" , units ) ) { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . GeoZ ; \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \n{ \nint i = 0 ; \nwhile ( i < levels . size ( ) ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \ni ++ ; \n} \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n} \n"}
{"4757": "public class DataDescriptor { \nstatic public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { \nif ( fromList . size ( ) != toList . size ( ) ) throw new IllegalArgumentException ( \"list sizes dont match \" + fromList . size ( ) + \" != \" + toList . size ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < fromList . size ( ) ) { \nDataDescriptor from = fromList . get ( i ) ; \nDataDescriptor to = toList . get ( i ) ; \nto . refersTo = from . refersTo ; \nto . name = from . name ; \nif ( from . getSubKeys ( ) != null ) transferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \nSystem . out . println ( \"nfields = \" + nfields ) ; \nSystem . out . println ( \"nbytesheader = \" + nbytesheader ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \n{ \nint i = 0 ; \nwhile ( i < nfields ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \ni ++ ; \n} \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \n{ \nint i = 0 ; \nwhile ( i < nrecords ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) { \n{ \nint j = 0 ; \nwhile ( j < nfields ) { \ndata [ j ] . readRowN ( ds , i ) ; \nj ++ ; \n} \n} \n} \nelse { \nnrecords -- ; \ni -- ; \n} \ni ++ ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4762": "public class DbaseFile { \npublic DbaseData getField ( String Name ) { \n{ \nint i = 0 ; \nwhile ( i < nfields ) { \nif ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) return null ; \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \n{ \nint i = 0 ; \nwhile ( i < s . length ) { \ndd [ i ] = Double . valueOf ( s [ i ] ) ; \ni ++ ; \n} \n} \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \n{ \nint i = 0 ; \nwhile ( i < b . length ) { \nif ( b [ i ] ) { \ndd [ i ] = 1 ; \n} \nelse { \ndd [ i ] = 0 ; \n} \ni ++ ; \n} \n} \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4767": "public class DbaseFile { \npublic String [ ] getFieldNames ( ) { \nString [ ] s = new String [ nfields ] ; \n{ \nint i = 0 ; \nwhile ( i < nfields ) { \ns [ i ] = getFieldName ( i ) ; \ni ++ ; \n} \n} \nreturn s ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \n{ \nint field = 0 ; \nwhile ( field < nf ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nfield ++ ; \n} \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \n{ \nint rec = 0 ; \nwhile ( rec < dbf . getNumRecords ( ) ) { \n{ \nint field = 0 ; \nwhile ( field < nf ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nelse System . out . println ( ) ; \nfield ++ ; \n} \n} \nrec ++ ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4775": "public class DapNode { \npublic List < DapNode > getContainerPath ( ) { \nList < DapNode > path = new ArrayList < DapNode > ( ) ; \nDapNode current = this . getContainer ( ) ; \n{ \nwhile ( ) { \npath . add ( 0 , current ) ; \nif ( current . getContainer ( ) == null ) break ; \ncurrent = current . getContainer ( ) ; \n} \n} \nreturn path ; \n} \n} \n"}
{"4776": "public class DapNode { \npublic List < DapGroup > getGroupPath ( ) { \nList < DapGroup > path = new ArrayList < DapGroup > ( ) ; \nDapNode current = this ; \n{ \nwhile ( ) { \nif ( current . getSort ( ) == DapSort . GROUP || current . getSort ( ) == DapSort . DATASET ) path . add ( 0 , ( DapGroup ) current ) ; \nif ( current . getContainer ( ) == null ) break ; \ncurrent = current . getContainer ( ) ; \n} \n} \nreturn path ; \n} \n} \n"}
{"4777": "public class DapNode { \npublic String computefqn ( ) { \nList < DapNode > path = getPath ( ) ; \nStringBuilder fqn = new StringBuilder ( ) ; \nDapNode parent = path . get ( 0 ) ; \n{ \nint i = 1 ; \nwhile ( i < path . size ( ) ) { \nDapNode current = path . get ( i ) ; \nswitch ( parent . getSort ( ) ) { \ncase DATASET : case GROUP : case ENUMERATION : fqn . append ( '/' ) ; \nfqn . append ( Escape . backslashEscape ( current . getShortName ( ) , \"/.\" ) ) ; \nbreak ; \ncase STRUCTURE : case SEQUENCE : case ENUMCONST : case VARIABLE : fqn . append ( '.' ) ; \nfqn . append ( current . getEscapedShortName ( ) ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Illegal FQN parent\" ) ; \n} \nparent = current ; \ni ++ ; \n} \n} \nreturn fqn . toString ( ) ; \n} \n} \n"}
{"4784": "public class DSPPrinter { \npublic DSPPrinter print ( ) throws DapException { \nDapDataset dmr = this . dsp . getDMR ( ) ; \nif ( this . ce == null ) this . ce = CEConstraint . getUniversal ( dmr ) ; \nthis . printer . setIndent ( 0 ) ; \nList < DapVariable > topvars = dmr . getTopVariables ( ) ; \n{ \nint i = 0 ; \nwhile ( i < topvars . size ( ) ) { \nDapVariable top = topvars . get ( i ) ; \nList < Slice > slices = this . ce . getConstrainedSlices ( top ) ; \nif ( this . ce . references ( top ) ) { \nDataCursor data = dsp . getVariableData ( top ) ; \nprintVariable ( data , slices ) ; \n} \ni ++ ; \n} \n} \nprinter . eol ( ) ; \nreturn this ; \n} \n} \n"}
{"4785": "public class DSPPrinter { \nprotected void printCompoundInstance ( DataCursor datav ) throws DapException { \nDapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; \nswitch ( datav . getScheme ( ) ) { \ncase STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; \n{ \nint f = 0 ; \nwhile ( f < dfields . size ( ) ) { \nDapVariable field = dfields . get ( f ) ; \nList < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; \nDataCursor fdata = datav . readField ( f ) ; \nprintVariable ( fdata , fieldslices ) ; \nf ++ ; \n} \n} \nbreak ; \ncase SEQUENCE : DapSequence dseq = ( DapSequence ) dstruct ; \nlong count = datav . getRecordCount ( ) ; \n{ \nlong r = 0 ; \nwhile ( r < count ) { \nDataCursor dr = datav . readRecord ( r ) ; \nprinter . marginPrint ( \"[\" ) ; \nprinter . eol ( ) ; \nprinter . indent ( ) ; \nprintCompoundInstance ( dr ) ; \nprinter . outdent ( ) ; \nprinter . marginPrint ( \"]\" ) ; \nr ++ ; \n} \n} \nbreak ; \ndefault : throw new DapException ( \"Unexpected data cursor scheme:\" + datav . getScheme ( ) ) ; \n} \n} \n} \n"}
{"4799": "public class CoordAxisHelper { \nprivate int findClosest ( double target ) { \ndouble minDiff = Double . MAX_VALUE ; \ndouble useValue = Double . MIN_VALUE ; \nint idxFound = - 1 ; \n{ \nint i = 0 ; \nwhile ( i < axis . getNcoords ( ) ) { \ndouble coord = axis . getCoordMidpoint ( i ) ; \ndouble diff = Math . abs ( coord - target ) ; \nif ( diff < minDiff || ( diff == minDiff && coord > useValue ) ) { \nminDiff = diff ; \nidxFound = i ; \nuseValue = coord ; \n} \ni ++ ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < var . getRank ( ) ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . println ( \"/>\" ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( ( dirBlock == null ) || ( ad == null ) ) { \nreturn ; \n} \n{ \nint i = 1 ; \nwhile ( i < 14 ) { \nif ( i == 7 ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"4829": "public class DSequence { \npublic BaseType getVariable ( int row , String name ) throws NoSuchVariableException { \nint dotIndex = name . indexOf ( '.' ) ; \nif ( dotIndex != - 1 ) { \nString aggregate = name . substring ( 0 , dotIndex ) ; \nString field = name . substring ( dotIndex + 1 ) ; \nBaseType aggRef = getVariable ( aggregate ) ; \nif ( aggRef instanceof DConstructor ) return ( ( DConstructor ) aggRef ) . getVariable ( field ) ; \nelse ; \n} \nelse { \nVector selectedRow = ( Vector ) allValues . elementAt ( row ) ; \n{ \nEnumeration e = selectedRow . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nBaseType v = ( BaseType ) e . nextElement ( ) ; \nif ( v . getEncodedName ( ) . equals ( name ) ) return v ; \n} \n} \n} \nthrow new NoSuchVariableException ( \"DSequence: getVariable()\" ) ; \n} \n} \n"}
{"4830": "public class DSequence { \nprivate void oldDeserialize ( DataInputStream source , ServerVersion sv , StatusUI statusUI ) throws IOException , DataReadException { \ntry { \n{ \nwhile ( ) { \ndeserializeSingle ( source , sv , statusUI ) ; \n} \n} \n} \ncatch ( EOFException e ) { \n} \n} \n} \n"}
{"4831": "public class DSequence { \nprivate byte readMarker ( DataInputStream source ) throws IOException { \nbyte marker = source . readByte ( ) ; \nbyte unused ; \n{ \nint i = 0 ; \nwhile ( i < 3 ) { \nunused = source . readByte ( ) ; \ni ++ ; \n} \n} \nreturn marker ; \n} \n} \n"}
{"4834": "public class MultipleAxisChart { \nprivate static TimeSeries createDataset ( String name , double base , RegularTimePeriod start , int count ) { \nTimeSeries series = new TimeSeries ( name , start . getClass ( ) ) ; \nRegularTimePeriod period = start ; \ndouble value = base ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nseries . add ( period , value ) ; \nperiod = period . next ( ) ; \nvalue = value * ( 1 + ( Math . random ( ) - 0.495 ) / 10.0 ) ; \ni ++ ; \n} \n} \nreturn series ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \n{ \nint i = 0 ; \nwhile ( i < result . length ) { \nresult [ i ] = ( String ) data . getObject ( i ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \nelse if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) result [ count ++ ] = iter . next ( ) ; \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4837": "public class DoradeVOLD { \npublic DoradePARM [ ] getParamList ( ) { \nint paramCount = 0 ; \n{ \nint i = 0 ; \nwhile ( i < nSensors ) { \nparamCount += myRADDs [ i ] . getNParams ( ) ; \ni ++ ; \n} \n} \nDoradePARM [ ] list = new DoradePARM [ paramCount ] ; \nint next = 0 ; \n{ \nint i = 0 ; \nwhile ( i < nSensors ) { \nint nParams = myRADDs [ i ] . getNParams ( ) ; \nSystem . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; \nnext += nParams ; \ni ++ ; \n} \n} \nreturn list ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < renderers . size ( ) ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \ni ++ ; \n} \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( \"parameter name mismatch\" ) ; \nbyte [ ] paramData = rdat . getRawData ( ) ; \nint nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( workingArray != null && workingArray . length == nCells ) { \nvalues = workingArray ; \n} \nelse { \nvalues = new float [ nCells ] ; \n} \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { \nthrow new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \n} \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \n{ \nint cell = 0 ; \nwhile ( cell < nCells ) { \nswitch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \ncell ++ ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4876": "public class GempakUtil { \npublic static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { \n{ \nint i = startIndex ; \nwhile ( i < startIndex + number ) { \nvalues [ i ] = Integer . reverseBytes ( values [ i ] ) ; \ni ++ ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4879": "public class DataDDS { \npublic void readData ( InputStream is , StatusUI statusUI ) throws IOException , EOFException , DAP2Exception { \nBufferedInputStream bufferedIS = new BufferedInputStream ( is ) ; \nDataInputStream dataIS = new DataInputStream ( bufferedIS ) ; \n{ \nEnumeration e = getVariables ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nif ( statusUI != null && statusUI . userCancelled ( ) ) throw new DataReadException ( \"User cancelled\" ) ; \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . deserialize ( dataIS , ver , statusUI ) ; \n} \n} \nif ( statusUI != null ) statusUI . finished ( ) ; \n} \n} \n"}
{"4880": "public class DataDDS { \npublic final void externalize ( OutputStream os , boolean compress , boolean headers ) throws IOException { \nif ( headers ) { \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os , Util . UTF8 ) ) ; \npw . println ( \"HTTP/1.0 200 OK\" ) ; \npw . println ( \"XDAP: \" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"XDODS-Server: DODS/\" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"Content-type: application/octet-stream\" ) ; \npw . println ( \"Content-Description: dods-data\" ) ; \nif ( compress ) { \npw . println ( \"Content-Encoding: deflate\" ) ; \n} \npw . println ( ) ; \npw . flush ( ) ; \n} \nOutputStream bufferedOS ; \nif ( compress ) { \nbufferedOS = new BufferedOutputStream ( new DeflaterOutputStream ( os ) ) ; \n} \nelse { \nbufferedOS = new BufferedOutputStream ( os ) ; \n} \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bufferedOS , Util . UTF8 ) ) ; \nprint ( pw ) ; \npw . flush ( ) ; \nbufferedOS . write ( \"\\nData:\\n\" . getBytes ( CDM . utf8Charset ) ) ; \nbufferedOS . flush ( ) ; \nDataOutputStream dataOS = new DataOutputStream ( bufferedOS ) ; \n{ \nEnumeration e = getVariables ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . externalize ( dataOS ) ; \n} \n} \ndataOS . close ( ) ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time ++ ; \nif ( this . time >= this . ntimes ) this . time = 0 ; \n} \nelse { \nthis . time -- ; \nif ( this . time < 0 ) this . time = this . ntimes - 1 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \n{ \nint i = 0 ; \nwhile ( i < currentDirFileList . size ( ) ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \ni ++ ; \n} \n} \n} \nif ( forward ) { \ncurrentDirFileNo ++ ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; \n} \nelse { \ncurrentDirFileNo -- ; \nif ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . println ( \"Open image \" + nextFile ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"Failed to open image \" + nextFile ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) throw new NullPointerException ( \"null array\" ) ; \nif ( arr . length == 0 ) throw new IllegalArgumentException ( \"Zero-length array\" ) ; \nint sum = 0 ; \n{ \nint i = 0 ; \nwhile ( i < arr . length ) { \nif ( arr [ i ] <= 0 ) { \nthrow new IllegalArgumentException ( \"All array values must be > 0\" ) ; \n} \nsum += arr [ i ] ; \ni ++ ; \n} \n} \nreturn sum ; \n} \n} \n"}
{"4887": "public class SpatialGrid { \npublic void clear ( ) { \n{ \nint y = 0 ; \nwhile ( y < countY ) { \n{ \nint x = 0 ; \nwhile ( x < countX ) { \ngridArray [ y ] [ x ] . used = false ; \nx ++ ; \n} \n} \ny ++ ; \n} \n} \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \n{ \nint y = Math . max ( 0 , indexY - 1 ) ; \nwhile ( y <= Math . min ( countY - 1 , indexY + 1 ) ) { \n{ \nint x = Math . max ( 0 , indexX - 1 ) ; \nwhile ( x <= Math . min ( countX - 1 , indexX + 1 ) ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) { \nx ++ ; \ncontinue ; \n} \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; \nx ++ ; \n} \n} \ny ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nint indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \n{ \nint y = Math . max ( 0 , indexY - 1 ) ; \nwhile ( y <= Math . min ( countY - 1 , indexY + 1 ) ) { \n{ \nint x = Math . max ( 0 , indexX - 1 ) ; \nwhile ( x <= Math . min ( countX - 1 , indexX + 1 ) ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) { \nx ++ ; \ncontinue ; \n} \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; \nx ++ ; \n} \n} \ny ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) System . out . println ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \n{ \nint p = 1 ; \nwhile ( p < Math . max ( countX - 1 , countY - 1 ) ) { \nif ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \np ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null || url . length ( ) == 0 ) return null ; \nurl = url . toLowerCase ( ) ; \n{ \nint i = 0 ; \nwhile ( i < FRAGPROTOCOLS . length ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) >= 0 ) { \nreturn FRAGPROTOSVCTYPE [ i ] ; \n} \ni ++ ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4902": "public class DapUtil { \nstatic public String locateFile ( String filename , String abspath , boolean wantdir ) { \nDeque < String > q = new ArrayDeque < String > ( ) ; \nfilename = filename . trim ( ) . replace ( '\\\\' , '/' ) ; \nabspath = abspath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( filename . charAt ( 0 ) == '/' ) filename = filename . substring ( 1 ) ; \nif ( filename . endsWith ( \"/\" ) ) filename = filename . substring ( 0 , filename . length ( ) - 1 ) ; \nif ( abspath . endsWith ( \"/\" ) ) abspath = abspath . substring ( 0 , abspath . length ( ) - 1 ) ; \nq . addFirst ( abspath ) ; \n{ \nwhile ( ) { \nString currentpath = q . poll ( ) ; \nif ( currentpath == null ) break ; \nFile current = new File ( currentpath ) ; \nFile [ ] contents = current . listFiles ( ) ; \nif ( contents != null ) { \nfor ( File subfile : contents ) { \nif ( ! subfile . getName ( ) . equals ( filename ) ) { \ncontinue ; \n} \nif ( ( wantdir && subfile . isDirectory ( ) ) || ( ! wantdir && subfile . isFile ( ) ) ) { \nreturn DapUtil . canonicalpath ( subfile . getAbsolutePath ( ) ) ; \n} \n} \nfor ( File subfile : contents ) { \nif ( subfile . isDirectory ( ) ) q . addFirst ( currentpath + \"/\" + subfile . getName ( ) ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4903": "public class DapUtil { \nstatic public String locateRelative ( String relpath , String abspath , boolean wantdir ) { \nrelpath = relpath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( relpath . charAt ( 0 ) == '/' ) relpath = relpath . substring ( 1 ) ; \nif ( relpath . endsWith ( \"/\" ) ) relpath = relpath . substring ( 0 , relpath . length ( ) - 1 ) ; \nString [ ] pieces = relpath . split ( \"[/]\" ) ; \nString partial = abspath ; \n{ \nint i = 0 ; \nwhile ( i < pieces . length - 1 ) { \nString nextdir = locateFile ( pieces [ i ] , abspath , true ) ; \nif ( nextdir == null ) return null ; \npartial = nextdir ; \ni ++ ; \n} \n} \nString finalpath = locateFile ( pieces [ pieces . length - 1 ] , partial , wantdir ) ; \nreturn finalpath ; \n} \n} \n"}
{"4905": "public class DapUtil { \nstatic public List < DapVariable > getStructurePath ( DapVariable var ) { \nList < DapNode > path = var . getPath ( ) ; \nList < DapVariable > structpath = new ArrayList < DapVariable > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < path . size ( ) ) { \nDapNode node = path . get ( i ) ; \nswitch ( node . getSort ( ) ) { \ncase DATASET : case GROUP : break ; \ncase VARIABLE : structpath . add ( ( DapVariable ) node ) ; \nbreak ; \ndefault : assert false : \"Internal error\" ; \n} \ni ++ ; \n} \n} \nreturn structpath ; \n} \n} \n"}
{"4907": "public class DapUtil { \nstatic public String join ( String [ ] array , String sep , int from , int upto ) { \nif ( sep == null ) sep = \"\" ; \nif ( from < 0 || upto > array . length ) throw new IndexOutOfBoundsException ( ) ; \nif ( upto <= from ) return \"\" ; \nStringBuilder result = new StringBuilder ( ) ; \nboolean first = true ; \n{ \nint i = from ; \nwhile ( i < upto ) { \nif ( ! first ) result . append ( sep ) ; \nresult . append ( array [ i ] ) ; \nfirst = false ; \ni ++ ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"4909": "public class DapUtil { \nstatic public List < String > getProtocols ( String url , int [ ] breakpoint ) { \nList < String > allprotocols = new ArrayList < > ( ) ; \nStringBuilder buf = new StringBuilder ( url ) ; \nint protosize = 0 ; \n{ \nwhile ( ) { \nint index = buf . indexOf ( \":\" ) ; \nif ( index < 0 ) break ; \nString protocol = buf . substring ( 0 , index ) ; \nif ( index == 1 && \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . indexOf ( buf . charAt ( 0 ) ) >= 0 ) break ; \nallprotocols . add ( protocol ) ; \nbuf . delete ( 0 , index + 1 ) ; \nprotosize += ( index + 1 ) ; \nif ( buf . indexOf ( \"/\" ) == 0 ) break ; \n} \n} \nbreakpoint [ 0 ] = protosize ; \nreturn allprotocols ; \n} \n} \n"}
{"4914": "public class DapUtil { \nstatic public Index slicesToIndex ( List < Slice > slices ) throws DapException { \nlong [ ] positions = new long [ slices . size ( ) ] ; \nlong [ ] dimsizes = new long [ slices . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < positions . length ) { \nSlice s = slices . get ( i ) ; \nif ( s . getCount ( ) != 1 ) throw new DapException ( \"Attempt to convert non-singleton sliceset to index\" ) ; \npositions [ i ] = s . getFirst ( ) ; \ndimsizes [ i ] = s . getMax ( ) ; \ni ++ ; \n} \n} \nreturn new Index ( positions , dimsizes ) ; \n} \n} \n"}
{"4936": "public class Index { \nstatic private long computeStrides ( int [ ] shape , int [ ] stride ) { \nlong product = 1 ; \n{ \nint ii = shape . length - 1 ; \nwhile ( ii >= 0 ) { \nfinal int thisDim = shape [ ii ] ; \nif ( thisDim < 0 ) { \nii -- ; \ncontinue ; \n} \nstride [ ii ] = ( int ) product ; \nproduct *= thisDim ; \nii -- ; \n} \n} \nreturn product ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \n{ \nint ii = 0 ; \nwhile ( ii < rank ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nii ++ ; \ncontinue ; \n} \nif ( r == Range . VLEN ) { \nii ++ ; \ncontinue ; \n} \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \nii ++ ; \n} \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \n{ \nint ii = 0 ; \nwhile ( ii < rank ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \nii ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4938": "public class Index { \nIndex reduce ( ) { \nIndex c = this ; \n{ \nint ii = 0 ; \nwhile ( ii < rank ) { \nif ( shape [ ii ] == 1 ) { \nIndex newc = c . reduce ( ii ) ; \nreturn newc . reduce ( ) ; \n} \nii ++ ; \n} \n} \nreturn c ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nif ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nint count = 0 ; \n{ \nint ii = 0 ; \nwhile ( ii < rank ) { \nif ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount ++ ; \n} \nii ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4941": "public class Index { \nIndex permute ( int [ ] dims ) { \nif ( dims . length != shape . length ) throw new IllegalArgumentException ( ) ; \nfor ( int dim : dims ) if ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( ) ; \nboolean isPermuted = false ; \nIndex newIndex = ( Index ) this . clone ( ) ; \n{ \nint i = 0 ; \nwhile ( i < dims . length ) { \nnewIndex . stride [ i ] = stride [ dims [ i ] ] ; \nnewIndex . shape [ i ] = shape [ dims [ i ] ] ; \nif ( i != dims [ i ] ) isPermuted = true ; \ni ++ ; \n} \n} \nnewIndex . fastIterator = fastIterator && ! isPermuted ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4943": "public class Index { \npublic int currentElement ( ) { \nint value = offset ; \n{ \nint ii = 0 ; \nwhile ( ii < rank ) { \nif ( shape [ ii ] < 0 ) break ; \nvalue += current [ ii ] * stride [ ii ] ; \nii ++ ; \n} \n} \nreturn value ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \n{ \nint i = 0 ; \nwhile ( i < seqArray . getSize ( ) ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \ni ++ ; \n} \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4979": "public class GempakSoundingIOSP { \nprivate ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { \nif ( values == null ) { \nreturn makeEmptySequence ( seq ) ; \n} \nint numLevels = values . length / params . size ( ) ; \nStructureMembers members = seq . makeStructureMembers ( ) ; \nint offset = ArrayStructureBB . setOffsets ( members ) ; \nint size = offset * numLevels ; \nbyte [ ] bytes = new byte [ size ] ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) ; \nArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { \nnumLevels } \n, buf , 0 ) ; \nint var = 0 ; \n{ \nint i = 0 ; \nwhile ( i < numLevels ) { \nfor ( GempakParameter param : params ) { \nif ( members . findMember ( param . getName ( ) ) != null ) { \nbuf . putFloat ( values [ var ] ) ; \n} \nvar ++ ; \n} \ni ++ ; \n} \n} \nreturn new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; \n} \n} \n"}
{"4997": "public class DOM4Parser { \nList < Node > getSubnodes ( Node parent ) { \nList < Node > subs = new ArrayList < > ( ) ; \nNodeList nodes = parent . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nodes . getLength ( ) ) { \nNode n = nodes . item ( i ) ; \nif ( n . getNodeType ( ) == Node . ELEMENT_NODE ) subs . add ( n ) ; \ni ++ ; \n} \n} \nreturn subs ; \n} \n} \n"}
{"4999": "public class DOM4Parser { \nprotected void passReserved ( Node node , DapNode dap ) throws ParseException { \ntry { \nNamedNodeMap attrs = node . getAttributes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < attrs . getLength ( ) ) { \nNode n = attrs . item ( i ) ; \nString key = n . getNodeName ( ) ; \nString value = n . getNodeValue ( ) ; \nif ( isReserved ( key ) ) dap . addXMLAttribute ( key , value ) ; \ni ++ ; \n} \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \n{ \nint i = 0 ; \nwhile ( i < dimList . size ( ) ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) { \ni ++ ; \ncontinue ; \n} \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse { \nif ( beginInd < 0 || endInd < 0 ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \ni ++ ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) { \nreturn null ; \n} \nelse if ( reservedChars == null ) { \nreturn x ; \n} \nboolean ok = true ; \n{ \nint pos = 0 ; \nwhile ( pos < x . length ( ) ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \npos ++ ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \n{ \nint pos = 0 ; \nwhile ( pos < sb . length ( ) ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) { \n{ \npos ++ ; \ncontinue ; \n} \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \npos ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5029": "public class EscapeStrings { \nstatic public String backslashUnescape ( String x ) { \nif ( ! x . contains ( \"\\\\\" ) ) return x ; \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \n{ \nint pos = 0 ; \nwhile ( pos < x . length ( ) ) { \nchar c = x . charAt ( pos ) ; \nif ( c == '\\\\' ) { \nc = x . charAt ( ++ pos ) ; \n} \nsb . append ( c ) ; \npos ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) && c == '\\\\' ) { \nc = bs . charAt ( ++ i ) ; \n} \nif ( _allowableInDAP . indexOf ( c ) < 0 ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \nelse buf . append ( c ) ; \ni ++ ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5034": "public class Nc4Cursor { \nstatic List < Nc4Cursor > getCursorPath ( Nc4Cursor cursor ) { \nList < Nc4Cursor > path = new ArrayList < > ( ) ; \n{ \nwhile ( ) { \nif ( ! cursor . getScheme ( ) . isCompoundArray ( ) ) path . add ( 0 , cursor ) ; \nif ( cursor . getScheme ( ) == Scheme . SEQUENCE ) { \nbreak ; \n} \nNc4Cursor next = ( Nc4Cursor ) cursor . getContainer ( ) ; \nif ( next == null ) { \nassert cursor . getTemplate ( ) . isTopLevel ( ) ; \nbreak ; \n} \nassert next . getTemplate ( ) . getSort ( ) == DapSort . VARIABLE ; \ncursor = next ; \n} \n} \nreturn path ; \n} \n} \n"}
{"5039": "public class D4DataCompiler { \nprotected D4Cursor compileStructure ( DapVariable var , DapStructure dapstruct , D4Cursor container ) throws DapException { \nint pos = getPos ( this . databuffer ) ; \nD4Cursor d4ds = new D4Cursor ( Scheme . STRUCTURE , ( D4DSP ) this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapstruct . getFields ( ) ; \n{ \nint m = 0 ; \nwhile ( m < dfields . size ( ) ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , d4ds ) ; \nd4ds . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \nm ++ ; \n} \n} \nreturn d4ds ; \n} \n} \n"}
{"5041": "public class D4DataCompiler { \npublic D4Cursor compileSequence ( DapVariable var , DapSequence dapseq , D4Cursor container ) throws DapException { \nint pos = getPos ( this . databuffer ) ; \nD4Cursor seq = new D4Cursor ( Scheme . SEQUENCE , this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapseq . getFields ( ) ; \nlong nrecs = getCount ( this . databuffer ) ; \n{ \nint r = 0 ; \nwhile ( r < nrecs ) { \npos = getPos ( this . databuffer ) ; \nD4Cursor rec = ( D4Cursor ) new D4Cursor ( D4Cursor . Scheme . RECORD , this . dsp , var , container ) . setOffset ( pos ) . setRecordIndex ( r ) ; \n{ \nint m = 0 ; \nwhile ( m < dfields . size ( ) ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , rec ) ; \nrec . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \nm ++ ; \n} \n} \nseq . addRecord ( rec ) ; \nr ++ ; \n} \n} \nreturn seq ; \n} \n} \n"}
{"5059": "public class DoradeRADD { \npublic float getCellSpacing ( ) throws DescriptorException { \nfloat [ ] cellRanges = myCELV . getCellRanges ( ) ; \nfloat cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; \n{ \nint i = 2 ; \nwhile ( i < cellRanges . length ) { \nfloat space = cellRanges [ i ] - cellRanges [ i - 1 ] ; \nif ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) ) { \nthrow new DescriptorException ( \"variable cell spacing\" ) ; \n} \ni ++ ; \n} \n} \nreturn cellSpacing ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \n{ \nwhile ( ) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( comp < 0 ) { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \nelse if ( comp == 0 ) { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \n} \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5062": "public class Dimension { \nprotected Factor [ ] pow ( final int power ) { \nFactor [ ] factors ; \nif ( power == 0 ) { \nfactors = new Factor [ 0 ] ; \n} \nelse { \nfactors = getFactors ( ) ; \nif ( power != 1 ) { \n{ \nint i = factors . length ; \nwhile ( -- i >= 0 ) { \nfactors [ i ] = factors [ i ] . pow ( power ) ; \n} \n} \n} \n} \nreturn factors ; \n} \n} \n"}
{"5063": "public class Dimension { \npublic final boolean isReciprocalOf ( final Dimension that ) { \nfinal Factor [ ] theseFactors = _factors ; \nfinal Factor [ ] thoseFactors = that . _factors ; \nboolean isReciprocalOf ; \nif ( theseFactors . length != thoseFactors . length ) { \nisReciprocalOf = false ; \n} \nelse { \nint i ; \n{ \ni = theseFactors . length ; \nwhile ( -- i >= 0 ) { \nif ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) { \nbreak ; \n} \n} \n} \nisReciprocalOf = i < 0 ; \n} \nreturn isReciprocalOf ; \n} \n} \n"}
{"5064": "public class Dimension { \npublic final boolean isDimensionless ( ) { \n{ \nint i = _factors . length ; \nwhile ( -- i >= 0 ) { \nif ( ! _factors [ i ] . isDimensionless ( ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"5070": "public class LogarithmicUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \n{ \nint i = input . length ; \nwhile ( -- i >= 0 ) { \noutput [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; \n} \n} \nreturn reference . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"5072": "public class Vis5DIosp { \nprivate Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { \nString vert_unit = null ; \nString vert_type ; \nArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; \nAxisType axisType = null ; \nswitch ( vert_sys ) { \ncase ( 0 ) : vert_unit = null ; \nvert_type = \"height\" ; \nbreak ; \ncase ( 1 ) : case ( 2 ) : vert_unit = \"km\" ; \nvert_type = \"altitude\" ; \naxisType = AxisType . Height ; \nbreak ; \ncase ( 3 ) : vert_unit = \"mbar\" ; \nvert_type = \"pressure\" ; \naxisType = AxisType . Pressure ; \nbreak ; \ndefault : throw new IOException ( \"vert_sys unknown\" ) ; \n} \nVariable vertVar = new Variable ( ncfile , null , null , vert_type ) ; \nvertVar . setDimensions ( LEVEL ) ; \nvertVar . setDataType ( DataType . FLOAT ) ; \nif ( vert_unit != null ) { \nvertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; \n} \nif ( axisType != null ) { \nvertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \n} \nswitch ( vert_sys ) { \ncase ( 0 ) : case ( 1 ) : { \nint i = 0 ; \nwhile ( i < n_levels ) { \ndata . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; \ni ++ ; \n} \n} \nbreak ; \ncase ( 2 ) : { \nint i = 0 ; \nwhile ( i < n_levels ) { \ndata . set ( i , vert_args [ i ] ) ; \ni ++ ; \n} \n} \nbreak ; \ncase ( 3 ) : try { \nVis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; \nfloat [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; \nSystem . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; \n{ \nint i = 0 ; \nwhile ( i < n_levels ) { \npressures [ 0 ] [ i ] *= 1000 ; \ni ++ ; \n} \n} \npressures = vert_cs . fromReference ( pressures ) ; \n{ \nint i = 0 ; \nwhile ( i < n_levels ) { \ndata . set ( i , pressures [ 0 ] [ i ] ) ; \ni ++ ; \n} \n} \n} \ncatch ( VisADException ve ) { \nthrow new IOException ( \"unable to make vertical system\" ) ; \n} \nbreak ; \n} \nvertVar . setCachedData ( data , false ) ; \nreturn vertVar ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \n{ \nwhile ( bytesRead < lineBuf . length ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \nbytesRead ++ ; \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( len <= 0 ) { \nreturn 0 ; \n} \nint c = read ( ) ; \nif ( c == - 1 ) return - 1 ; \nb [ off ] = ( byte ) c ; \nint i = 1 ; \ntry { \n{ \nwhile ( i < len ) { \nc = read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nb [ off + i ] = ( byte ) c ; \ni ++ ; \n} \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val > val2 ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < levels . size ( ) ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \nelse { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5095": "public class NOWRadiosp { \npublic byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { \nint run ; \nbyte [ ] bdata = new byte [ xt ] ; \nint nbin = 0 ; \nint total = 0 ; \n{ \nrun = 0 ; \nwhile ( run < rLen ) { \nint drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; \nbyte dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; \n{ \nint i = 0 ; \nwhile ( i < drun ) { \nbdata [ nbin ++ ] = dcode1 ; \ntotal ++ ; \ni ++ ; \n} \n} \nrun ++ ; \n} \n} \nif ( total < xt ) { \n{ \nrun = total ; \nwhile ( run < xt ) { \nbdata [ run ] = 0 ; \nrun ++ ; \n} \n} \n} \nreturn bdata ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; \nddsvars . add ( v ) ; \nboolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) continue ; \nList < Dimension > dimset = v . getDimensions ( ) ; \nint rank = dimset . size ( ) ; \n{ \nint i = 0 ; \nwhile ( isgridarray && i < rank ) { \nDimension dim = dimset . get ( i ) ; \nif ( dim . getShortName ( ) == null ) isgridarray = false ; \nelse { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) isgridarray = false ; \n} \ni ++ ; \n} \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) { \nreturn ; \n} \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nwhile ( vp . isMemberOfStructure ( ) ) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nwhile ( gp . getParentGroup ( ) != null ) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \n{ \nint i = 1 ; \nwhile ( i < gchain . size ( ) ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \ni ++ ; \n} \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \n{ \nint i = 1 ; \nwhile ( i < vchain . size ( ) ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \ni ++ ; \n} \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \n{ \nint e = 0 ; \nwhile ( e < eDim . getSize ( ) ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \ne ++ ; \n} \n} \n} \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \n{ \nint t = 0 ; \nwhile ( t < tDim . getSize ( ) ) { \n{ \nint e = 0 ; \nwhile ( e < numens ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \ne ++ ; \n} \n} \nt ++ ; \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5124": "public class Nidsheader { \nint pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { \nint vlen = 0 ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nvlen = vlen + dlen [ i ] ; \ni ++ ; \n} \n} \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"graphicSymbolSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"special graphic symbol for code \" + code ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . FLOAT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . FLOAT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5129": "public class Nidsheader { \nint pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nVariable v ; \nint vlen = 0 ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nvlen = vlen + dlen [ i ] ; \ni ++ ; \n} \n} \nDimension sDim = new Dimension ( \"unlinkedVectorSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"unlinkedVectorStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Unlinked Vector Packet\" ) ) ; \nv = new Variable ( ncfile , null , null , \"iValue\" ) ; \nv . setDataType ( DataType . SHORT ) ; \nv . setDimensions ( ( String ) null ) ; \ndist . addMemberVariable ( v ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"x_end\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nVariable jj1 = new Variable ( ncfile , null , dist , \"y_end\" ) ; \njj1 . setDimensions ( ( String ) null ) ; \njj1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj1 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nint ival ; \nint isign ; \n{ \nint i = 0 ; \nwhile ( i < nlevel ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ( ival & 0x00008000 ) == 0 ) { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \nelse { \nlevels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \ni ++ ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5131": "public class Nidsheader { \npublic int [ ] getDualpolLevels ( short [ ] th ) { \nint inc = th . length ; \nint [ ] levels = new int [ inc ] ; \n{ \nint i = 0 ; \nwhile ( i < inc ) { \nlevels [ i ] = th [ i ] ; \ni ++ ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5135": "public class Nidsheader { \nint getUInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \n{ \ni = 0 ; \nwhile ( i < num ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \ni ++ ; \n} \n} \n{ \ni = num - 1 ; \nwhile ( i >= 0 ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \ni -- ; \n} \n} \nreturn word ; \n} \n} \n"}
{"5136": "public class Nidsheader { \nint getInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \n{ \ni = 0 ; \nwhile ( i < num ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \ni ++ ; \n} \n} \nif ( bv [ 0 ] > 127 ) { \nbv [ 0 ] -= 128 ; \nbase = - 1 ; \n} \n{ \ni = num - 1 ; \nwhile ( i >= 0 ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \ni -- ; \n} \n} \nreturn word ; \n} \n} \n"}
{"5159": "public class Escape { \nstatic public String entityEscape ( String s , String wrt ) { \nif ( wrt == null ) wrt = ENTITYESCAPES ; \nStringBuilder escaped = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nchar c = s . charAt ( i ) ; \nint index = wrt . indexOf ( c ) ; \nif ( index < 0 ) escaped . append ( c ) ; \nelse switch ( c ) { \ncase '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; \nbreak ; \ncase '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; \nbreak ; \ncase '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; \nbreak ; \ncase '\"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; \nbreak ; \ncase '\\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; \nbreak ; \ncase '\\r' : case '\\t' : case '\\n' : escaped . append ( c ) ; \nbreak ; \ncase '\\0' : break ; \ndefault : if ( c >= ' ' ) escaped . append ( c ) ; \nbreak ; \n} \ni ++ ; \n} \n} \nreturn escaped . toString ( ) ; \n} \n} \n"}
{"5160": "public class Escape { \nstatic public String backslashUnescape ( String s ) { \nStringBuilder clear = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nchar c = s . charAt ( i ++ ) ; \nif ( c == '\\\\' ) { \nc = s . charAt ( i ++ ) ; \nswitch ( c ) { \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ndefault : break ; \n} \nclear . append ( c ) ; \n} \nelse clear . append ( c ) ; \n} \n} \nreturn clear . toString ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nint len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nint i = 0 ; \n{ \nwhile ( i <= len - 1 ) { \nchar c = s . charAt ( i ) ; \nif ( c == '\\\\' && i < ( len - 1 ) ) { \npiece . append ( c ) ; \npiece . append ( s . charAt ( ++ i ) ) ; \n} \nelse if ( c == sep ) { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse piece . append ( c ) ; \ni ++ ; \n} \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal int end = start + length ; \nint count = 0 ; \n{ \nint i = start ; \nwhile ( i < end ) { \nfinal int code = ( int ) s . charAt ( i ) ; \nif ( code >= 0x01 && code <= 0x7F ) { \nwriteByte ( ( byte ) code ) ; \ncount ++ ; \n} \nelse if ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 2 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 3 ; \n} \ni ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \n{ \nint i = start ; \nwhile ( i < end ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse if ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \n{ \nint i = 0 ; \nwhile ( i < ncols ) { \nif ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \ni ++ ; \n} \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \ni ++ ; \n} \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \n{ \nint i = 0 ; \nwhile ( i < table . getColumnCount ( ) ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \ni ++ ; \n} \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5205": "public class JTreeTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ model . getColumnCount ( ) ] ; \ntry { \nTableColumnModel tcm = table . getColumnModel ( ) ; \n{ \nint i = 0 ; \nwhile ( i < model . getColumnCount ( ) ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \ni ++ ; \n} \n} \n} \ncatch ( java . lang . ArrayIndexOutOfBoundsException e ) { \n} \nreturn modelIndex ; \n} \n} \n"}
{"5227": "public class GridVariable { \npublic void showMissing ( Formatter f ) { \nint count = 0 , total = 0 ; \nf . format ( \"  %s%n\" , name ) ; \n{ \nint j = 0 ; \nwhile ( j < nlevels ) { \nf . format ( \"   \" ) ; \n{ \nint i = 0 ; \nwhile ( i < ntimes ) { \nboolean missing = recordTracker [ i * nlevels + j ] == null ; \nf . format ( \"%s\" , missing ? \"-\" : \"X\" ) ; \nif ( missing ) count ++ ; \ntotal ++ ; \ni ++ ; \n} \n} \nf . format ( \"%n\" ) ; \nj ++ ; \n} \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \n} \n} \n"}
{"5228": "public class GridVariable { \npublic int showMissingSummary ( Formatter f ) { \nint count = 0 ; \nint total = recordTracker . length ; \n{ \nint i = 0 ; \nwhile ( i < total ) { \nif ( recordTracker [ i ] == null ) count ++ ; \ni ++ ; \n} \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn count ; \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) return true ; \nif ( b1 == null || b2 == null ) return false ; \nif ( b1 . length < len || b2 . length < len ) return false ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nif ( b1 [ i ] != b2 [ i ] ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \n{ \nint i = 0 ; \nwhile ( i < nlats ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \ni ++ ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \n{ \nint i = 0 ; \nwhile ( i < nyRaw ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) { \nuseIndex ++ ; \n} \nelse { \nuseIndex -- ; \n} \ni ++ ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5240": "public class GeoGridCoordinate2D { \nprivate boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { \nint row = rectIndex [ 0 ] ; \nint minrow = Math . max ( row - 1 , 0 ) ; \nint maxrow = Math . min ( row + 1 , nrows ) ; \nint col = rectIndex [ 1 ] ; \nint mincol = Math . max ( col - 1 , 0 ) ; \nint maxcol = Math . min ( col + 1 , ncols ) ; \nif ( debug ) System . out . printf ( \"%n   box9:\" ) ; \n{ \nint i = minrow ; \nwhile ( i <= maxrow ) { \n{ \nint j = mincol ; \nwhile ( j <= maxcol ) { \nrectIndex [ 0 ] = i ; \nrectIndex [ 1 ] = j ; \nif ( contains ( wantLat , wantLon , rectIndex ) ) return true ; \nj ++ ; \n} \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5283": "public class BooleanPrimitiveVector { \npublic PrimitiveVector subset ( int start , int stop , int stride ) { \nBooleanPrimitiveVector n = new BooleanPrimitiveVector ( getTemplate ( ) ) ; \nstride = Math . max ( stride , 1 ) ; \nstop = Math . max ( start , stop ) ; \nint length = 1 + ( stop - start ) / stride ; \nn . setLength ( length ) ; \nint count = 0 ; \n{ \nint i = start ; \nwhile ( i <= stop ) { \nn . setValue ( count , vals [ i ] ) ; \ncount ++ ; \ni += stride ; \n} \n} \nreturn n ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \n{ \nlong tnum = trackerNumber - 1 ; \nwhile ( tnum > 0 ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) break ; \nif ( oldDatabaseFile . delete ( ) ) { \ncatalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \nelse { \ncatalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \ntnum -- ; \n} \n} \n} \n} \n"}
{"5288": "public class McIDASAreaProjection { \nprivate double [ ] makeDoubleArray ( int [ ] ints ) { \ndouble [ ] newArray = new double [ ints . length ] ; \n{ \nint i = 0 ; \nwhile ( i < ints . length ) { \nnewArray [ i ] = ints [ i ] ; \ni ++ ; \n} \n} \nreturn newArray ; \n} \n} \n"}
{"5302": "public class InvDatasetImpl { \npublic boolean replaceDataset ( InvDatasetImpl remove , InvDatasetImpl add ) { \n{ \nint i = 0 ; \nwhile ( i < datasets . size ( ) ) { \nInvDataset dataset = datasets . get ( i ) ; \nif ( dataset . equals ( remove ) ) { \ndatasets . set ( i , add ) ; \nInvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; \nif ( cat != null ) { \ncat . removeDatasetByID ( remove ) ; \ncat . addDatasetByID ( add ) ; \n} \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \n{ \nint ind = 0 ; \nwhile ( ind < versionParts . length ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \nind ++ ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \n{ \nint i = 0 ; \nwhile ( i < nrows ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; \nelse { \nif ( debug ) System . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \n} \ni ++ ; \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) return ; \n{ \nint i = 0 ; \nwhile ( i < getItemCount ( ) ) { \nif ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \ni ++ ; \n} \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \n{ \nint i = lastpos - 1 ; \nwhile ( i >= firstpos ) { \nif ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \nelse { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \ni -- ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5361": "public class DTSServlet { \nprotected void printStatus ( PrintWriter os ) { \nos . println ( \"<h2>Server version = \" + getServerVersion ( ) + \"</h2>\" ) ; \nos . println ( \"<h2>Number of Requests Received = \" + HitCounter + \"</h2>\" ) ; \nif ( track ) { \nint n = prArr . size ( ) ; \nint pending = 0 ; \nStringBuilder preqs = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nReqState rs = ( ReqState ) prArr . get ( i ) ; \nRequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; \nif ( ! reqD . done ) { \npreqs . append ( \"<pre>-----------------------\\n\" ) ; \npreqs . append ( \"Request[\" ) ; \npreqs . append ( reqD . reqno ) ; \npreqs . append ( \"](\" ) ; \npreqs . append ( reqD . threadDesc ) ; \npreqs . append ( \") is pending.\\n\" ) ; \npreqs . append ( rs . toString ( ) ) ; \npreqs . append ( \"</pre>\" ) ; \npending ++ ; \n} \ni ++ ; \n} \n} \nos . println ( \"<h2>\" + pending + \" Pending Request(s)</h2>\" ) ; \nos . println ( preqs . toString ( ) ) ; \n} \n} \n} \n"}
{"5364": "public class NcStreamIosp { \nprivate Array readVlenData ( Variable v , Section section , DataStorage dataStorage ) throws IOException , InvalidRangeException { \nraf . seek ( dataStorage . filePos ) ; \nint nelems = readVInt ( raf ) ; \nArray [ ] result = new Array [ nelems ] ; \n{ \nint elem = 0 ; \nwhile ( elem < nelems ) { \nint dsize = readVInt ( raf ) ; \nbyte [ ] data = new byte [ dsize ] ; \nraf . readFully ( data ) ; \nArray dataArray = Array . factory ( v . getDataType ( ) , ( int [ ] ) null , ByteBuffer . wrap ( data ) ) ; \nresult [ elem ] = dataArray ; \nelem ++ ; \n} \n} \nreturn Array . makeVlenArray ( new int [ ] { \nnelems } \n, result ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \n{ \nint pos = 0 ; \nwhile ( pos < x . length ( ) ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \npos ++ ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \n{ \nint pos = 0 ; \nwhile ( pos < sb . length ( ) ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) { \n{ \npos ++ ; \ncontinue ; \n} \n} \nsb . setCharAt ( pos , replaceChar ) ; \npos ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5369": "public class StringUtil2 { \nstatic public String filter ( String x , String okChars ) { \nboolean ok = true ; \n{ \nint pos = 0 ; \nwhile ( pos < x . length ( ) ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \npos ++ ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \n{ \nint pos = 0 ; \nwhile ( pos < x . length ( ) ) { \nchar c = x . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) { \nsb . append ( c ) ; \n} \npos ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) return null ; \nchar [ ] bo = new char [ s . length ( ) ] ; \nint count = 0 ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nchar c = s . charAt ( i ) ; \nif ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\\n' ) || ( c == '\\t' ) ) ) { \nbo [ count ++ ] = c ; \n} \ni ++ ; \n} \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \n{ \nint i = 0 ; \nwhile ( i < name . length ( ) ) { \nint c = name . charAt ( i ) ; \nif ( c < 0x20 ) ok = false ; \nif ( c == '/' ) ok = false ; \nif ( c == ' ' ) ok = false ; \nif ( ! ok ) break ; \ni ++ ; \n} \n} \nif ( ok ) return name ; \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \n{ \nint i = 0 , len = name . length ( ) ; \nwhile ( i < len ) { \nint c = name . charAt ( i ) ; \nif ( ( c == '/' ) || ( c == ' ' ) ) sbuff . append ( '_' ) ; \nelse if ( c >= 0x20 ) sbuff . append ( ( char ) c ) ; \ni ++ ; \n} \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nint len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar c = s . charAt ( i ) ; \nif ( ! Character . isWhitespace ( c ) ) { \nb . append ( c ) ; \n} \nelse { \nb . append ( ' ' ) ; \nwhile ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) { \ni ++ ; \n} \n} \ni ++ ; \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5380": "public class StringUtil2 { \nstatic public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { \nboolean ok = true ; \nfor ( char aReplaceChar : replaceChar ) { \nint pos = x . indexOf ( aReplaceChar ) ; \nok = ( pos < 0 ) ; \nif ( ! ok ) break ; \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \n{ \nint i = 0 ; \nwhile ( i < replaceChar . length ) { \nint pos = x . indexOf ( replaceChar [ i ] ) ; \nif ( pos >= 0 ) { \nreplace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5383": "public class StringUtil2 { \nstatic public String substitute ( String original , String [ ] match , String [ ] subst ) { \nboolean ok = true ; \nfor ( String aMatch : match ) { \nif ( original . contains ( aMatch ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn original ; \n} \nStringBuilder sb = new StringBuilder ( original ) ; \n{ \nint i = 0 ; \nwhile ( i < match . length ) { \nsubstitute ( sb , match [ i ] , subst [ i ] ) ; \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nwhile ( i < sb . length ( ) ) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \n{ \nint j = 0 ; \nwhile ( j < out . length ( ) ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \nj ++ ; \n} \n} \nif ( ok ) i ++ ; \n} \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \n{ \nint i = 0 ; \nwhile ( i < sb . length ( ) ) { \nint c = sb . charAt ( i ) ; \n{ \nint j = 0 ; \nwhile ( j < out . length ( ) ) { \nif ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; \nj ++ ; \n} \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"5401": "public class CoordinateAxis1D { \npublic CoordinateAxis1D section ( Range r ) throws InvalidRangeException { \nSection section = new Section ( ) . appendRange ( r ) ; \nCoordinateAxis1D result = ( CoordinateAxis1D ) section ( section ) ; \nint len = r . length ( ) ; \nif ( isNumeric ( ) ) { \ndouble [ ] new_mids = new double [ len ] ; \n{ \nint idx = 0 ; \nwhile ( idx < len ) { \nint old_idx = r . element ( idx ) ; \nnew_mids [ idx ] = coords [ old_idx ] ; \nidx ++ ; \n} \n} \nresult . coords = new_mids ; \nif ( isInterval ) { \ndouble [ ] new_bound1 = new double [ len ] ; \ndouble [ ] new_bound2 = new double [ len ] ; \ndouble [ ] new_edge = new double [ len + 1 ] ; \n{ \nint idx = 0 ; \nwhile ( idx < len ) { \nint old_idx = r . element ( idx ) ; \nnew_bound1 [ idx ] = bound1 [ old_idx ] ; \nnew_bound2 [ idx ] = bound2 [ old_idx ] ; \nnew_edge [ idx ] = bound1 [ old_idx ] ; \nnew_edge [ idx + 1 ] = bound2 [ old_idx ] ; \nidx ++ ; \n} \n} \nresult . bound1 = new_bound1 ; \nresult . bound2 = new_bound2 ; \nresult . edge = new_edge ; \n} \nelse { \ndouble [ ] new_edge = new double [ len + 1 ] ; \n{ \nint idx = 0 ; \nwhile ( idx < len ) { \nint old_idx = r . element ( idx ) ; \nnew_edge [ idx ] = edge [ old_idx ] ; \nnew_edge [ idx + 1 ] = edge [ old_idx + 1 ] ; \nidx ++ ; \n} \n} \nresult . edge = new_edge ; \n} \n} \nif ( names != null ) { \nString [ ] new_names = new String [ len ] ; \n{ \nint idx = 0 ; \nwhile ( idx < len ) { \nint old_idx = r . element ( idx ) ; \nnew_names [ idx ] = names [ old_idx ] ; \nidx ++ ; \n} \n} \nresult . names = new_names ; \n} \nresult . wasCalcRegular = false ; \nresult . calcIsRegular ( ) ; \nreturn result ; \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart -- ; \nif ( type . equalsIgnoreCase ( GAUST62 ) ) { \nbaseArray = gltst62 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR15 ) ) { \nbaseArray = glts15 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR20 ) ) { \nbaseArray = glts20 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR30 ) ) { \nbaseArray = glts30 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR40 ) ) { \nbaseArray = glats ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \n} \nif ( start + num > baseArray . length ) { \nthrow new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \n} \ndouble [ ] retVals = new double [ num ] ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \nretVals [ i ] = baseArray [ start + i ] ; \ni ++ ; \n} \n} \nreturn retVals ; \n} \n} \n"}
{"5407": "public class Swap { \nstatic public long swapLong ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \n{ \nint shiftBy = 0 , i = offset ; \nwhile ( shiftBy < 64 ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \ni ++ ; \nshiftBy += 8 ; \n} \n} \nreturn accum ; \n} \n} \n"}
{"5408": "public class Swap { \nstatic public float swapFloat ( byte [ ] b , int offset ) { \nint accum = 0 ; \n{ \nint shiftBy = 0 , i = offset ; \nwhile ( shiftBy < 32 ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \ni ++ ; \nshiftBy += 8 ; \n} \n} \nreturn Float . intBitsToFloat ( accum ) ; \n} \n} \n"}
{"5420": "public class Group { \npublic boolean removeDimension ( String dimName ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \n{ \nint i = 0 ; \nwhile ( i < dimensions . size ( ) ) { \nDimension d = dimensions . get ( i ) ; \nif ( dimName . equals ( d . getShortName ( ) ) ) { \ndimensions . remove ( d ) ; \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \n{ \nint lineno = 1 ; \nwhile ( ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) { \nlineno ++ ; \ncontinue ; \n} \nif ( line . charAt ( 0 ) == '#' ) { \nlineno ++ ; \ncontinue ; \n} \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \nlineno ++ ; \n} \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5465": "public class ArrayStructure { \npublic ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { \nif ( ( m . getDataType ( ) != DataType . STRUCTURE ) && ( m . getDataType ( ) != DataType . SEQUENCE ) ) throw new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Structure or Sequence\" ) ; \nif ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; \nArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; \nint count = m . getSize ( ) ; \nStructureData [ ] this_sdata = new StructureData [ count ] ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nthis_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; \ni ++ ; \n} \n} \nStructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; \nreturn new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; \n} \n} \n"}
{"5470": "public class CEConstraint { \npublic String toConstraintString ( ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \n{ \nint i = 0 ; \nwhile ( i < segments . size ( ) ) { \nSegment seg = segments . get ( i ) ; \nif ( ! seg . var . isTopLevel ( ) ) { \ni ++ ; \ncontinue ; \n} \nif ( ! first ) buf . append ( \";\" ) ; \nfirst = false ; \ndumpvar ( seg , buf , true ) ; \ni ++ ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5474": "public class CEConstraint { \nprotected void computeenums ( ) { \n{ \nint i = 0 ; \nwhile ( i < variables . size ( ) ) { \nDapVariable var = variables . get ( i ) ; \nif ( var . getSort ( ) != DapSort . VARIABLE ) { \ni ++ ; \ncontinue ; \n} \nDapType daptype = var . getBaseType ( ) ; \nif ( ! daptype . isEnumType ( ) ) { \ni ++ ; \ncontinue ; \n} \nif ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) this . enums . add ( ( DapEnumeration ) daptype ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5475": "public class CEConstraint { \nprotected void computegroups ( ) { \n{ \nint i = 0 ; \nwhile ( i < variables . size ( ) ) { \nDapVariable var = variables . get ( i ) ; \nList < DapGroup > path = var . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \ni ++ ; \n} \n} \nfor ( DapDimension dim : this . dimrefs ) { \nif ( ! dim . isShared ( ) ) continue ; \nList < DapGroup > path = dim . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapEnumeration en : this . enums ) { \nList < DapGroup > path = en . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) { \nreturn null ; \n} \nint knt = fileHeaderInfo . indexOf ( fh ) ; \nint iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \n{ \nint i = 0 ; \nwhile ( i < knt ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \ni ++ ; \n} \n} \nint nword = DM_RINT ( iread ) ; \nif ( nword <= 0 ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread ++ ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( name . equals ( \"NAVB\" ) && needToSwap ) { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread ++ ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread ++ ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nelse { \nDM_RFLT ( iread , rheader ) ; \n} \nreturn rheader ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \n{ \nint i = 0 ; \nwhile ( i < parts . size ( ) ) { \nSystem . out . println ( \"\\nParts[\" + i + \"]:\" ) ; \nSystem . out . println ( parts . get ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nint nparms = part . kparms ; \nint nwordp = part . kwordp ; \nint npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) { \nreturn null ; \n} \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nint ir = 0 ; \nint ii = 0 ; \n{ \nint pack = 0 ; \nwhile ( pack < npack ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \n{ \nint idata = 0 ; \nwhile ( idata < nparms ) { \nint jbit = pkinf . nbitsc [ idata ] ; \nint jsbit = pkinf . isbitc [ idata ] ; \nint jshift = 1 - jsbit ; \nint jsword = pkinf . iswrdc [ idata ] ; \nint jword = jdata [ jsword ] ; \nint mask = mskpat >>> ( 32 - jbit ) ; \nint ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( ( jsbit + jbit - 1 ) > 32 ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nint iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ifield == pkinf . imissc [ idata ] ) { \ndata [ ir + idata ] = RMISSD ; \n} \nelse { \ndata [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \nidata ++ ; \n} \n} \nir += nparms ; \nii += nwordp ; \npack ++ ; \n} \n} \nreturn data ; \n} \n} \n"}
{"5489": "public class GempakFileReader { \nprotected static String getBits ( int b ) { \nFormatter s = new Formatter ( ) ; \n{ \nint i = 31 ; \nwhile ( i >= 0 ) { \nif ( ( b & ( 1 << i ) ) != 0 ) { \ns . format ( \"1\" ) ; \n} \nelse { \ns . format ( \"0\" ) ; \n} \nif ( i % 8 == 0 ) { \ns . format ( \"|\" ) ; \n} \ni -- ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \n{ \nint j = 0 ; \nwhile ( j < dk . x && dkIter . hasNext ( ) ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \nj ++ ; \n} \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \n{ \nint i = 0 ; \nwhile ( i < interfaces . length ) { \nSystem . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \ni ++ ; \n} \n} \nSystem . out . println ( \"Methods:\" ) ; \n{ \nint i = 0 ; \nwhile ( i < m . length ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \n{ \nint j = 0 ; \nwhile ( j < params . length ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \nj ++ ; \n} \n} \nSystem . out . print ( \")  throws \" ) ; \n{ \nint j = 0 ; \nwhile ( j < excepts . length ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \nj ++ ; \n} \n} \nSystem . out . println ( \"\" ) ; \ni ++ ; \n} \n} \nSystem . out . println ( \"******************\" ) ; \n} \n} \n"}
{"5503": "public class CoordinateTimeAbstract { \npublic CoordinateTimeAbstract makeBestFromComplete ( ) { \nint [ ] best = new int [ time2runtime . length ] ; \nint last = - 1 ; \nint count = 0 ; \n{ \nint i = 0 ; \nwhile ( i < time2runtime . length ) { \nint time = time2runtime [ i ] ; \nif ( time >= last ) { \nlast = time ; \nbest [ i ] = time ; \ncount ++ ; \n} \nelse { \nbest [ i ] = - 1 ; \n} \ni ++ ; \n} \n} \nreturn makeBestFromComplete ( best , count ) ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \n{ \nint i = 0 ; \nwhile ( i < getLength ( ) ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \ni ++ ; \n} \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \n{ \nint i = 0 ; \nwhile ( i < getLength ( ) ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \ni ++ ; \n} \n} \n} \nelse { \nf . format ( \" = \" ) ; \n{ \nint i = 0 ; \nwhile ( i < getLength ( ) ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( String ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( Integer ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( Double ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( Float ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( Short ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( Byte ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nva [ i ] = ( Long ) values . get ( i ) ; \ni ++ ; \n} \n} \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) throw new IllegalStateException ( \"Scan already underway.\" ) ; \nif ( state >= 2 ) throw new IllegalStateException ( \"Scan has already been generated.\" ) ; \nstate = 1 ; \nif ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) sorter . sort ( crDsList ) ; \n{ \nint i = 0 ; \nwhile ( i < crDsList . size ( ) ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( curCrDs . isCollection ( ) ) catRefInfo . add ( dsInfo ) ; \nelse atomicDsInfo . add ( dsInfo ) ; \ntopInvDs . addDataset ( curInvDs ) ; \ni ++ ; \n} \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( atomicDsInfo . size ( ) > 0 ) { \nboolean anyProxiesAdded = false ; \n{ \nIterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nint index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \n} \nif ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \n} \n} \n"}
{"5522": "public class CoordinateSystem { \nstatic public String makeName ( List < CoordinateAxis > axes ) { \nList < CoordinateAxis > axesSorted = new ArrayList < > ( axes ) ; \nCollections . sort ( axesSorted , new CoordinateAxis . AxisComparator ( ) ) ; \nStringBuilder buff = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < axesSorted . size ( ) ) { \nCoordinateAxis axis = axesSorted . get ( i ) ; \nif ( i > 0 ) buff . append ( \" \" ) ; \nbuff . append ( axis . getFullNameEscaped ( ) ) ; \ni ++ ; \n} \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5537": "public class BeanTable { \npublic ArrayList < Object > getSelectedCells ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nint [ ] viewColumnIndices = jtable . getSelectedColumns ( ) ; \n{ \nint i = 0 ; \nwhile ( i < viewRowIndices . length ) { \n{ \nint j = 0 ; \nwhile ( i < viewColumnIndices . length ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndices [ i ] ) ; \nint modelColumnIndex = jtable . convertColumnIndexToModel ( viewColumnIndices [ j ] ) ; \nlist . add ( model . getValueAt ( modelRowIndex , modelColumnIndex ) ) ; \nj ++ ; \n} \n} \ni ++ ; \n} \n} \nreturn list ; \n} \n} \n"}
{"5574": "public class RandomAccessFile { \npublic final void readShort ( short [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \npa [ start + i ] = readShort ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5576": "public class RandomAccessFile { \npublic final void readInt ( int [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \npa [ start + i ] = readInt ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5577": "public class RandomAccessFile { \npublic final void readLong ( long [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \npa [ start + i ] = readLong ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5578": "public class RandomAccessFile { \npublic final void readFloat ( float [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \npa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5579": "public class RandomAccessFile { \npublic final void readDouble ( double [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \npa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5581": "public class RandomAccessFile { \npublic String readStringMax ( int nbytes ) throws IOException { \nbyte [ ] b = new byte [ nbytes ] ; \nreadFully ( b ) ; \nint count ; \n{ \ncount = 0 ; \nwhile ( count < nbytes ) { \nif ( b [ count ] == 0 ) break ; \ncount ++ ; \n} \n} \nreturn new String ( b , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5582": "public class RandomAccessFile { \npublic final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteBoolean ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5583": "public class RandomAccessFile { \npublic final void writeShort ( short [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteShort ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5584": "public class RandomAccessFile { \npublic final void writeChar ( char [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteChar ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5585": "public class RandomAccessFile { \npublic final void writeInt ( int [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteInt ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5586": "public class RandomAccessFile { \npublic final void writeLong ( long [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteLong ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5587": "public class RandomAccessFile { \npublic final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteFloat ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5588": "public class RandomAccessFile { \npublic final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < n ) { \nwriteDouble ( pa [ start + i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5589": "public class RandomAccessFile { \npublic final void writeBytes ( String s ) throws IOException { \nint len = s . length ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nwrite ( ( byte ) s . charAt ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5590": "public class RandomAccessFile { \npublic final void writeBytes ( char b [ ] , int off , int len ) throws IOException { \n{ \nint i = off ; \nwhile ( i < len ) { \nwrite ( ( byte ) b [ i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5670": "public class DatasetSource { \npublic InvCatalog fullExpand ( ) throws IOException { \nlogger . debug ( \"fullExpand(): expanding DatasetSource named \\\"{}\\\"\" , this . getName ( ) ) ; \nInvDataset topDs = this . expand ( ) ; \nInvCatalog generatedCat = topDs . getParentCatalog ( ) ; \n{ \nIterator it = this . getDatasetEnhancerList ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nDatasetEnhancer1 dsE = ( DatasetEnhancer1 ) it . next ( ) ; \ndsE . addMetadata ( topDs ) ; \n} \n} \nlogger . debug ( \"fullExpand(): naming the datasets.\" ) ; \nthis . nameDatasets ( ( InvDatasetImpl ) topDs ) ; \nlogger . debug ( \"fullExpand(): sorting the datasets.\" ) ; \nthis . sortDatasets ( topDs ) ; \n( ( InvCatalogImpl ) generatedCat ) . finish ( ) ; \nreturn ( generatedCat ) ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; \nif ( this . isFlatten ( ) ) { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \n{ \nint j = 0 ; \nwhile ( j < datasetContainer . getDatasets ( ) . size ( ) ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \nj ++ ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \n{ \nint i = 0 ; \nwhile ( i < this . datasetNamerList . size ( ) ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs . addDataset ( curDs ) ; \n} \nelse { \nnamedDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \ni ++ ; \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < namedDs . getDatasets ( ) . size ( ) ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \ni ++ ; \n} \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5673": "public class DatasetSource { \nprivate void nameDatasetTree ( InvDatasetImpl dataset ) { \nif ( dataset . getName ( ) . equals ( \"\" ) || ! dataset . hasAccess ( ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \n{ \nint i = 0 ; \nwhile ( i < this . datasetNamerList . size ( ) ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \ni ++ ; \n} \n} \n} \nInvDatasetImpl curDs = null ; \n{ \nint j = 0 ; \nwhile ( j < dataset . getDatasets ( ) . size ( ) ) { \ncurDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; \nlogger . debug ( \"nameDatasetTree(): recurse to name child dataset ({})\" , curDs . getUrlPath ( ) ) ; \nthis . nameDatasetTree ( curDs ) ; \nj ++ ; \n} \n} \nreturn ; \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nwhile ( ! done ) { \n{ \nint group = 0 ; \nwhile ( group < belowGroups . length ) { \nif ( above ) { \npartToCheck = aboveGroups [ group ] ; \n} \nelse { \npartToCheck = belowGroups [ group ] ; \n} \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { \ntypes . add ( partToCheck ) ; \n} \ngroup ++ ; \n} \n} \nif ( ! above ) { \nabove = true ; \n} \nelse { \ndone = true ; \n} \n} \nreturn types ; \n} \n} \n"}
{"5699": "public class JTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ colName . length ] ; \nTableColumnModel tcm = jtable . getColumnModel ( ) ; \n{ \nint i = 0 ; \nwhile ( i < colName . length ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \ni ++ ; \n} \n} \nreturn modelIndex ; \n} \n} \n"}
{"5713": "public class DapSerializer { \nprotected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { \nassert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; \nDapVariable template = ( DapVariable ) instance . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \n{ \nint i = 0 ; \nwhile ( i < fields . size ( ) ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) { \ni ++ ; \ncontinue ; \n} \nDataCursor df = ( DataCursor ) instance . readField ( i ) ; \nwriteVariable ( df , dst ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \n{ \nint i = 0 ; \nwhile ( i < instances . length ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"5715": "public class DapSerializer { \nprotected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) record . getTemplate ( ) ; \nDapSequence seq = ( DapSequence ) template . getBaseType ( ) ; \nList < DapVariable > fields = seq . getFields ( ) ; \n{ \nint i = 0 ; \nwhile ( i < fields . size ( ) ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) { \ni ++ ; \ncontinue ; \n} \nDataCursor df = ( DataCursor ) record . readField ( i ) ; \nwriteVariable ( df , dst ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"5720": "public class Grib2DataReader { \nprivate float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nBitReader reader = new BitReader ( raf , startPos + 5 ) ; \nif ( bitmap == null ) { \n{ \nint i = 0 ; \nwhile ( i < totalNPoints ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \ni ++ ; \n} \n} \n} \nelse { \n{ \nint i = 0 ; \nwhile ( i < totalNPoints ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \nelse { \ndata [ i ] = staticMissingValue ; \n} \ni ++ ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5721": "public class Grib2DataReader { \nprivate float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nif ( nb == 0 ) { \nArrays . fill ( data , R ) ; \nreturn data ; \n} \nbyte [ ] buf = new byte [ dataLength - 5 ] ; \nraf . readFully ( buf ) ; \nInputStream in = new ByteArrayInputStream ( buf ) ; \nBufferedImage image = ImageIO . read ( in ) ; \nif ( nb != image . getColorModel ( ) . getPixelSize ( ) ) { \nlogger . debug ( \"PNG pixel size disagrees with grib number of bits: \" , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; \n} \nDataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; \nif ( bitmap == null ) { \n{ \nint i = 0 ; \nwhile ( i < dataNPoints ) { \ndata [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; \ni ++ ; \n} \n} \n} \nelse { \n{ \nint bitPt = 0 , dataPt = 0 ; \nwhile ( bitPt < totalNPoints ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) { \ndata [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; \n} \nelse { \ndata [ bitPt ] = staticMissingValue ; \n} \nbitPt ++ ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \n{ \nint i = 0 ; \nwhile ( odom . hasNext ( ) ) { \ninstances [ i ] = readStructure ( odom . next ( ) ) ; \ni ++ ; \n} \n} \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5726": "public class StationRenderer { \npublic void setStations ( java . util . List < ucar . unidata . geoloc . Station > stns ) { \nstations = new ArrayList < StationUI > ( stns . size ( ) ) ; \nstationHash . clear ( ) ; \n{ \nint i = 0 ; \nwhile ( i < stns . size ( ) ) { \nucar . unidata . geoloc . Station s = ( ucar . unidata . geoloc . Station ) stns . get ( i ) ; \nStationUI sui = new StationUI ( s ) ; \nstations . add ( sui ) ; \nstationHash . put ( s . getName ( ) , sui ) ; \ni ++ ; \n} \n} \nposWasCalc = false ; \ncalcWorldPos ( ) ; \n} \n} \n"}
{"5737": "public class MAVector { \npublic double dot ( MAVector v ) { \nif ( nelems != v . getNelems ( ) ) throw new IllegalArgumentException ( \"MAVector.dot \" + nelems + \" != \" + v . getNelems ( ) ) ; \ndouble sum = 0.0 ; \n{ \nint k = 0 ; \nwhile ( k < nelems ) { \nsum += getDouble ( k ) * v . getDouble ( k ) ; \nk ++ ; \n} \n} \nreturn sum ; \n} \n} \n"}
{"5738": "public class MAVector { \npublic double norm ( ) { \ndouble sum = 0.0 ; \n{ \nint k = 0 ; \nwhile ( k < nelems ) { \ndouble val = getDouble ( k ) ; \nsum += val * val ; \nk ++ ; \n} \n} \nreturn Math . sqrt ( sum ) ; \n} \n} \n"}
{"5739": "public class MAVector { \npublic void normalize ( ) { \ndouble norm = norm ( ) ; \nif ( norm <= 0.0 ) return ; \n{ \nint k = 0 ; \nwhile ( k < nelems ) { \ndouble val = getDouble ( k ) ; \nsetDouble ( k , val / norm ) ; \nk ++ ; \n} \n} \n} \n} \n"}
{"5745": "public class PrefixDBImpl { \nprivate static Prefix getPrefix ( final String string , final Set < Prefix > set ) { \n{ \nfinal Iterator < Prefix > iter = set . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nfinal Prefix prefix = iter . next ( ) ; \nfinal int comp = prefix . compareTo ( string ) ; \nif ( comp == 0 ) { \nreturn prefix ; \n} \nif ( comp > 0 ) { \nbreak ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"5760": "public class NetcdfFile { \nstatic public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { \niospDeRegister ( iospClass ) ; \nint pos = - 1 ; \n{ \nint i = 0 ; \nwhile ( i < registeredProviders . size ( ) ) { \nIOServiceProvider candidate = registeredProviders . get ( i ) ; \nif ( candidate . getClass ( ) == target ) { \nif ( pos < i ) pos = i ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( pos < 0 ) pos = 0 ; \nIOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nregisteredProviders . add ( pos , spi ) ; \n} \n} \n"}
{"5762": "public class NetcdfFile { \nstatic public boolean iospDeRegister ( Class iospClass ) { \n{ \nint i = 0 ; \nwhile ( i < registeredProviders . size ( ) ) { \nIOServiceProvider spi = registeredProviders . get ( i ) ; \nif ( spi . getClass ( ) == iospClass ) { \nregisteredProviders . remove ( i ) ; \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \n{ \nint indxOrigSegs = 0 ; \nwhile ( indxOrigSegs < pathSegments . length ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) { \nindxOrigSegs ++ ; \ncontinue ; \n} \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) return false ; \ni -- ; \n} \nelse { \ni ++ ; \n} \nindxOrigSegs ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5809": "public class StringValidateEncodeUtils { \npublic static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { \nif ( ! Character . isDefined ( codePoint ) ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] not assigned to an abstract character.\" , codePoint ) ) ; \nif ( Character . getType ( codePoint ) == Character . SURROGATE ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] is an unencodable (by itself) surrogate character.\" , codePoint ) ) ; \nCharset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; \nif ( charset == null ) throw new IllegalArgumentException ( String . format ( \"Unsupported charset [%s].\" , charsetName ) ) ; \nchar [ ] chars = Character . toChars ( codePoint ) ; \nByteBuffer byteBuffer = null ; \ntry { \nbyteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; \n} \ncatch ( CharacterCodingException e ) { \nString message = String . format ( \"Given code point [U+%1$04X - %1$d] cannot be encode in given charset [%2$s].\" , codePoint , charsetName ) ; \nthrow new IllegalArgumentException ( message , e ) ; \n} \nbyteBuffer . rewind ( ) ; \nStringBuilder encodedString = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < byteBuffer . limit ( ) ) { \nString asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; \nencodedString . append ( \"%\" ) . append ( asHex . length ( ) == 1 ? \"0\" : \"\" ) . append ( asHex ) ; \ni ++ ; \n} \n} \nreturn encodedString . toString ( ) ; \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \n{ \nint i = task . len - 4 ; \nwhile ( i < task . len ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \ni ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5823": "public class DoradeSWIB { \npublic float [ ] getLatitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lats = new float [ nRays ] ; \n{ \nint i = 0 ; \nwhile ( i < nRays ) { \nlats [ i ] = myASIBs [ i ] . getLatitude ( ) ; \ni ++ ; \n} \n} \nreturn lats ; \n} \n} \n"}
{"5824": "public class DoradeSWIB { \npublic float [ ] getLongitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lons = new float [ nRays ] ; \n{ \nint i = 0 ; \nwhile ( i < nRays ) { \nlons [ i ] = myASIBs [ i ] . getLongitude ( ) ; \ni ++ ; \n} \n} \nreturn lons ; \n} \n} \n"}
{"5825": "public class DoradeSWIB { \npublic float [ ] getAltitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] alts = new float [ nRays ] ; \n{ \nint i = 0 ; \nwhile ( i < nRays ) { \nalts [ i ] = myASIBs [ i ] . getAltitude ( ) ; \ni ++ ; \n} \n} \nreturn alts ; \n} \n} \n"}
{"5826": "public class DoradeSWIB { \npublic float [ ] getAzimuths ( ) { \nif ( azimuths == null ) { \nazimuths = new float [ nRays ] ; \n{ \nint r = 0 ; \nwhile ( r < nRays ) { \nazimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; \nr ++ ; \n} \n} \n} \nreturn azimuths ; \n} \n} \n"}
{"5827": "public class DoradeSWIB { \npublic float [ ] getElevations ( ) { \nif ( elevations == null ) { \nelevations = new float [ nRays ] ; \n{ \nint r = 0 ; \nwhile ( r < nRays ) { \nelevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; \nr ++ ; \n} \n} \n} \nreturn elevations ; \n} \n} \n"}
{"5849": "public class TableAligner { \npublic static void installInAllColumns ( JTable table , int alignment ) { \n{ \nint colViewIndex = 0 ; \nwhile ( colViewIndex < table . getColumnCount ( ) ) { \ninstallInOneColumn ( table , colViewIndex , alignment ) ; \n++ colViewIndex ; \n} \n} \n} \n} \n"}
{"5855": "public class CoreSocketFactory { \nprivate static List < String > listIpTypes ( String cloudSqlIpTypes ) { \nString [ ] rawTypes = cloudSqlIpTypes . split ( \",\" ) ; \nArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; \n{ \nint i = 0 ; \nwhile ( i < rawTypes . length ) { \nif ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( \"PUBLIC\" ) ) { \nresult . add ( i , \"PRIMARY\" ) ; \n} \nelse { \nresult . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; \n} \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5858": "public class InMemoryJavaCompiler { \npublic Map < String , Class < ? > > compileAll ( ) throws Exception { \nif ( sourceCodes . size ( ) == 0 ) { \nthrow new CompilationException ( \"No source code to compile\" ) ; \n} \nCollection < SourceCode > compilationUnits = sourceCodes . values ( ) ; \nCompiledCode [ ] code ; \ncode = new CompiledCode [ compilationUnits . size ( ) ] ; \nIterator < SourceCode > iter = compilationUnits . iterator ( ) ; \n{ \nint i = 0 ; \nwhile ( i < code . length ) { \ncode [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; \ni ++ ; \n} \n} \nDiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; \nExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; \nJavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; \nboolean result = task . call ( ) ; \nif ( ! result || collector . getDiagnostics ( ) . size ( ) > 0 ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings || hasErrors ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \n} \nMap < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; \nfor ( String className : sourceCodes . keySet ( ) ) { \nclasses . put ( className , classLoader . loadClass ( className ) ) ; \n} \nreturn classes ; \n} \n} \n"}
{"5900": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \n{ \nlong zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; \nwhile ( zoomLevel <= tileDao . getMaxZoom ( ) ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) { \nbreak ; \n} \n} \nzoomLevel ++ ; \n} \n} \nreturn results ; \n} \n} \n"}
{"5901": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \n{ \nlong zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; \nwhile ( zoomLevel >= tileDao . getMinZoom ( ) ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) { \nbreak ; \n} \n} \nzoomLevel -- ; \n} \n} \nreturn results ; \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) { \ntransformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \n} \n{ \nint zoom = minZoom ; \nwhile ( zoom <= maxZoom ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( degrees ) { \ntileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \n} \nelse { \ntileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \n} \ncount += tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \nzoom ++ ; \n} \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"5946": "public class CoverageDataTiff { \npublic float [ ] getPixelValues ( byte [ ] imageBytes ) { \nTIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; \nFileDirectory directory = tiffImage . getFileDirectory ( ) ; \nvalidateImageType ( directory ) ; \nRasters rasters = directory . readRasters ( ) ; \nfloat [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; \n{ \nint y = 0 ; \nwhile ( y < rasters . getHeight ( ) ) { \n{ \nint x = 0 ; \nwhile ( x < rasters . getWidth ( ) ) { \nint index = rasters . getSampleIndex ( x , y ) ; \npixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; \nx ++ ; \n} \n} \ny ++ ; \n} \n} \nreturn pixels ; \n} \n} \n"}
{"5989": "public class TileCreator { \npublic GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { \nGeoPackageTile tile = null ; \nProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; \nBoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nList < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; \n{ \nint i = 0 ; \nwhile ( tile == null && i < tileMatrices . size ( ) ) { \nTileMatrix tileMatrix = tileMatrices . get ( i ) ; \nTileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; \nif ( tileResults != null ) { \ntry { \nif ( tileResults . getCount ( ) > 0 ) { \nBoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nint requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; \nint requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; \nint tileWidth = requestedTileWidth ; \nint tileHeight = requestedTileHeight ; \nif ( ! sameProjection ) { \ntileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; \ntileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; \n} \nBitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; \nif ( tileBitmap != null ) { \nif ( ! sameProjection ) { \nBitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; \ntileBitmap . recycle ( ) ; \ntileBitmap = reprojectTile ; \n} \ntry { \nbyte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; \ntileBitmap . recycle ( ) ; \ntile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; \n} \ncatch ( IOException e ) { \nLog . e ( TileCreator . class . getSimpleName ( ) , \"Failed to create tile. min lat: \" + requestBoundingBox . getMinLatitude ( ) + \", max lat: \" + requestBoundingBox . getMaxLatitude ( ) + \", min lon: \" + requestBoundingBox . getMinLongitude ( ) + \", max lon: \" + requestBoundingBox . getMaxLongitude ( ) , e ) ; \n} \n} \n} \n} \nfinally { \ntileResults . close ( ) ; \n} \n} \ni ++ ; \n} \n} \nreturn tile ; \n} \n} \n"}
{"5991": "public class TileCreator { \nprivate Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { \nfinal double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; \nfinal double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; \nfinal double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; \nfinal double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; \nfinal int width = tile . getWidth ( ) ; \nfinal int height = tile . getHeight ( ) ; \nint [ ] pixels = new int [ width * height ] ; \ntile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; \nint [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; \n{ \nint y = 0 ; \nwhile ( y < requestedTileHeight ) { \n{ \nint x = 0 ; \nwhile ( x < requestedTileWidth ) { \ndouble longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; \ndouble latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; \nProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; \nProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; \ndouble projectedLongitude = toCoord . x ; \ndouble projectedLatitude = toCoord . y ; \nint xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; \nint yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; \nxPixel = Math . max ( 0 , xPixel ) ; \nxPixel = Math . min ( width - 1 , xPixel ) ; \nyPixel = Math . max ( 0 , yPixel ) ; \nyPixel = Math . min ( height - 1 , yPixel ) ; \nint color = pixels [ ( yPixel * width ) + xPixel ] ; \nprojectedPixels [ ( y * requestedTileWidth ) + x ] = color ; \nx ++ ; \n} \n} \ny ++ ; \n} \n} \nBitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; \nprojectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; \nreturn projectedTileBitmap ; \n} \n} \n"}
{"6017": "public class FeatureTileCanvas { \npublic Bitmap createBitmap ( ) { \nBitmap bitmap = null ; \nCanvas canvas = null ; \n{ \nint layer = 0 ; \nwhile ( layer < 4 ) { \nBitmap layerBitmap = layeredBitmap [ layer ] ; \nif ( layerBitmap != null ) { \nif ( bitmap == null ) { \nbitmap = layerBitmap ; \ncanvas = layeredCanvas [ layer ] ; \n} \nelse { \ncanvas . drawBitmap ( layerBitmap , new Matrix ( ) , null ) ; \nlayerBitmap . recycle ( ) ; \n} \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \nlayer ++ ; \n} \n} \nreturn bitmap ; \n} \n} \n"}
{"6018": "public class FeatureTileCanvas { \npublic void recycle ( ) { \n{ \nint layer = 0 ; \nwhile ( layer < 4 ) { \nBitmap bitmap = layeredBitmap [ layer ] ; \nif ( bitmap != null ) { \nbitmap . recycle ( ) ; \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \nlayer ++ ; \n} \n} \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( points . size ( ) >= 2 ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \n{ \nint i = 0 ; \nwhile ( i < points . size ( ) ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( i == 0 ) { \npath . moveTo ( x , y ) ; \n} \nelse { \npath . lineTo ( x , y ) ; \n} \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"6071": "public class DefaultFeatureTiles { \nprivate void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { \nList < LineString > rings = polygon . getRings ( ) ; \nif ( ! rings . isEmpty ( ) ) { \nLineString polygonLineString = rings . get ( 0 ) ; \nList < Point > polygonPoints = polygonLineString . getPoints ( ) ; \nif ( polygonPoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; \n{ \nint i = 1 ; \nwhile ( i < rings . size ( ) ) { \nLineString holeLineString = rings . get ( i ) ; \nList < Point > holePoints = holeLineString . getPoints ( ) ; \nif ( holePoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; \n} \ni ++ ; \n} \n} \n} \n} \n} \n} \n"}
{"6082": "public class UserInvalidCursor { \nprivate void readBlobValue ( UserRow row , UserColumn column ) { \nByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; \ntry { \nbyte [ ] blobChunk = new byte [ ] { \n0 } \n; \n{ \nint i = 1 ; \nwhile ( blobChunk . length > 0 ) { \nif ( i > 1 ) { \nbyteStream . write ( blobChunk ) ; \n} \nblobChunk = new byte [ ] { \n} \n; \nString query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; \nCursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; \ntry { \nif ( blobCursor . moveToNext ( ) ) { \nblobChunk = blobCursor . getBlob ( 0 ) ; \n} \n} \nfinally { \nblobCursor . close ( ) ; \n} \ni += CHUNK_SIZE ; \n} \n} \nbyte [ ] blob = byteStream . toByteArray ( ) ; \nrow . setValue ( column . getIndex ( ) , blob ) ; \n} \ncatch ( IOException e ) { \nLog . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( byteStream ) ; \n} \n} \n} \n"}
{"6153": "public class ParallaxContainer { \nprivate void addParallaxView ( View view , int pageIndex ) { \nif ( view instanceof ViewGroup ) { \nViewGroup viewGroup = ( ViewGroup ) view ; \n{ \nint i = 0 , childCount = viewGroup . getChildCount ( ) ; \nwhile ( i < childCount ) { \naddParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; \ni ++ ; \n} \n} \n} \nParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; \nif ( tag != null ) { \ntag . index = pageIndex ; \nparallaxViews . add ( view ) ; \n} \n} \n} \n"}
{"6183": "public class FilterAttachableImpl { \npublic FilterReply getFilterChainDecision ( E event ) { \nfinal Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; \nfinal int len = filterArrray . length ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nfinal FilterReply r = filterArrray [ i ] . decide ( event ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \ni ++ ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) { \nreturn null ; \n} \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nint found = LINE_NA ; \n{ \nint i = 0 ; \nwhile ( i < steArray . length ) { \nif ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { \nfound = i + 1 ; \n} \nelse { \nif ( found != LINE_NA ) { \nbreak ; \n} \n} \ni ++ ; \n} \n} \nif ( found == LINE_NA ) { \nreturn EMPTY_CALLER_DATA_ARRAY ; \n} \nint availableDepth = steArray . length - found ; \nint desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \n{ \nint i = 0 ; \nwhile ( i < desiredDepth ) { \ncallerDataArray [ i ] = steArray [ found + i ] ; \ni ++ ; \n} \n} \nreturn callerDataArray ; \n} \n} \n"}
{"6208": "public class Interpreter { \nList < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , InterpretationContext ec ) { \nint len = implicitActions . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; \nif ( ia . isApplicable ( elementPath , attributes , ec ) ) { \nList < Action > actionList = new ArrayList < Action > ( 1 ) ; \nactionList . add ( ia ) ; \nreturn actionList ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6231": "public class Logger { \nprivate synchronized void handleParentLevelChange ( int newParentLevelInt ) { \nif ( level == null ) { \neffectiveLevelInt = newParentLevelInt ; \nif ( childrenList != null ) { \nint len = childrenList . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nLogger child = ( Logger ) childrenList . get ( i ) ; \nchild . handleParentLevelChange ( newParentLevelInt ) ; \ni ++ ; \n} \n} \n} \n} \n} \n} \n"}
{"6232": "public class Logger { \npublic void callAppenders ( ILoggingEvent event ) { \nint writes = 0 ; \n{ \nLogger l = this ; \nwhile ( l != null ) { \nwrites += l . appendLoopOnAppenders ( event ) ; \nif ( ! l . additive ) { \nbreak ; \n} \nl = l . parent ; \n} \n} \nif ( writes == 0 ) { \nloggerContext . noAppenderDefinedWarning ( this ) ; \n} \n} \n} \n"}
{"6269": "public class StatusUtil { \npublic long timeOfLastReset ( ) { \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nif ( statusList == null ) return - 1 ; \nint len = statusList . size ( ) ; \n{ \nint i = len - 1 ; \nwhile ( i >= 0 ) { \nStatus s = statusList . get ( i ) ; \nif ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { \nreturn s . getDate ( ) ; \n} \ni -- ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6281": "public class TurboFilterList { \npublic FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { \nfinal int size = size ( ) ; \nif ( size == 1 ) { \ntry { \nTurboFilter tf = get ( 0 ) ; \nreturn tf . decide ( marker , logger , level , format , params , t ) ; \n} \ncatch ( IndexOutOfBoundsException iobe ) { \nreturn FilterReply . NEUTRAL ; \n} \n} \nObject [ ] tfa = toArray ( ) ; \nfinal int len = tfa . length ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nfinal TurboFilter tf = ( TurboFilter ) tfa [ i ] ; \nfinal FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \ni ++ ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \nreturn 0 ; \n} \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) { \nreturn 0 ; \n} \nint minLen = ( lSize <= rSize ) ? lSize : rSize ; \nint match = 0 ; \n{ \nint i = 0 ; \nwhile ( i < minLen ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) { \nmatch ++ ; \n} \nelse { \nbreak ; \n} \ni ++ ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nif ( ( b [ i ] & 0x00FF ) >= 0x30 ) { \nif ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse if ( tmpbuf [ 0 ] > 1 ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \ni ++ ; \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) return ; \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal int SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nint size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < size ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) { \ntreeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \ni ++ ; \n} \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n) ; \n} \n} \n"}
{"6370": "public class DebugUtil { \npublic static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { \nIStatusHandler handler = getStackFrameProvider ( ) ; \nif ( handler != null ) { \nIJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; \nif ( stackFrame != null ) { \nreturn stackFrame ; \n} \n} \nIDebugTarget target = value . getDebugTarget ( ) ; \nIJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; \nif ( javaTarget != null ) { \nIThread [ ] threads = javaTarget . getThreads ( ) ; \n{ \nint i = 0 ; \nwhile ( i < threads . length ) { \nIThread thread = threads [ i ] ; \nif ( thread . isSuspended ( ) ) { \nreturn ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; \n} \ni ++ ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6373": "public class ElementEditor { \npublic static Node cloneNode ( Document document , Node node ) { \nNode nodeClone = null ; \nswitch ( node . getNodeType ( ) ) { \ncase Node . ELEMENT_NODE : { \nnodeClone = document . createElement ( ( ( Element ) node ) . getTagName ( ) ) ; \nNamedNodeMap namedNodeMap = node . getAttributes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < namedNodeMap . getLength ( ) ) { \nAttr attr = ( Attr ) namedNodeMap . item ( i ) ; \nAttr attrClone = document . createAttribute ( attr . getName ( ) ) ; \nattrClone . setValue ( attr . getValue ( ) ) ; \n( ( Element ) nodeClone ) . setAttributeNode ( attrClone ) ; \n++ i ; \n} \n} \n} \nbreak ; \ncase Node . TEXT_NODE : nodeClone = document . createTextNode ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . CDATA_SECTION_NODE : nodeClone = document . createCDATASection ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . ENTITY_REFERENCE_NODE : nodeClone = document . createEntityReference ( node . getNodeName ( ) ) ; \nbreak ; \ncase Node . PROCESSING_INSTRUCTION_NODE : nodeClone = document . createProcessingInstruction ( ( ( ProcessingInstruction ) node ) . getTarget ( ) , ( ( ProcessingInstruction ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . COMMENT_NODE : nodeClone = document . createComment ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . DOCUMENT_FRAGMENT_NODE : nodeClone = document . createDocumentFragment ( ) ; \nbreak ; \ncase Node . DOCUMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . NOTATION_NODE : case Node . ATTRIBUTE_NODE : case Node . ENTITY_NODE : Assert . isTrue ( false , Policy . bind ( \"assert.notSupported\" ) ) ; \nbreak ; \ndefault : Assert . isTrue ( false , Policy . bind ( \"assert.unknownNodeType\" ) ) ; \n} \nreturn nodeClone ; \n} \n} \n"}
{"6382": "public class GraphicalVertex { \npublic static String dumpConstraints ( final Constraint [ ] constraints ) { \nif ( constraints == null ) { \nreturn null ; \n} \nfinal StringBuffer buffer = new StringBuffer ( ) ; \n{ \nint i = 0 , length = constraints . length ; \nwhile ( i < length ) { \nbuffer . append ( constraints [ i ] . toString ( ) + \"<br>\" ) ; \ni ++ ; \n} \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \n{ \nint i = 0 ; \nwhile ( i < patterns . length ) { \nif ( setDateTime ( date , patterns [ i ] ) ) break ; \ni ++ ; \n} \n} \n} \n} \n"}
{"6396": "public class FieldEditorPropertyPage { \nprotected void adjustGridLayout ( ) { \nint numColumns = calcNumberOfColumns ( ) ; \n( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; \nif ( fields != null ) { \n{ \nint i = 0 ; \nwhile ( i < fields . size ( ) ) { \nFieldEditor fieldEditor = fields . get ( i ) ; \nfieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"6400": "public class JsonPreferenceStore { \npublic void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { \nPropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; \nObject [ ] listeners = fListeners . getListeners ( ) ; \n{ \nint i = 0 ; \nwhile ( i < listeners . length ) { \n( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"6447": "public class ReteooLayoutFactory { \npublic static RowList calculateReteRows ( BaseVertex root ) { \nRowList rowList = new RowList ( ) ; \nrowList . add ( 0 , root ) ; \nint curRow = 0 ; \nfinal Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; \nseenVertices . add ( root ) ; \nwhile ( curRow < rowList . getDepth ( ) ) { \nfinal List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; \n{ \nfinal Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; \nwhile ( rowNodeIter . hasNext ( ) ) { \nfinal BaseVertex rowNode = rowNodeIter . next ( ) ; \nfinal List < Connection > edges = rowNode . getSourceConnections ( ) ; \n{ \nfinal Iterator < Connection > edgeIter = edges . iterator ( ) ; \nwhile ( edgeIter . hasNext ( ) ) { \nfinal Connection edge = edgeIter . next ( ) ; \nfinal BaseVertex destNode = edge . getOpposite ( rowNode ) ; \nif ( ! seenVertices . contains ( destNode ) ) { \nrowList . add ( curRow + 1 , destNode ) ; \nseenVertices . add ( destNode ) ; \n} \n} \n} \nseenVertices . add ( rowNode ) ; \n} \n} \n++ curRow ; \n} \nrowList . optimize ( ) ; \nreturn rowList ; \n} \n} \n"}
{"6452": "public class RowList { \npublic void add ( final int depth , final BaseVertex vertex ) { \nif ( this . rows . size ( ) < ( depth + 1 ) ) { \nfinal int addRows = depth - this . rows . size ( ) + 1 ; \n{ \nint i = 0 ; \nwhile ( i < addRows ) { \nthis . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; \n++ i ; \n} \n} \n} \n( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; \n} \n} \n"}
{"6453": "public class RowList { \npublic int getRow ( final BaseVertex vertex ) { \nfinal int numRows = this . rows . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numRows ) { \nif ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) { \nreturn i ; \n} \n++ i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6454": "public class RowList { \npublic int getWidth ( ) { \nint width = 0 ; \n{ \nfinal Iterator < Row > rowIter = this . rows . iterator ( ) ; \nwhile ( rowIter . hasNext ( ) ) { \nfinal Row row = rowIter . next ( ) ; \nfinal int rowWidth = row . getWidth ( ) ; \nif ( rowWidth > width ) { \nwidth = rowWidth ; \n} \n} \n} \nreturn width ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal int numRows = this . rows . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numRows ) { \nSystem . err . println ( i + \": \" + get ( i ) . getVertices ( ) ) ; \n++ i ; \n} \n} \n} \n} \n"}
{"6456": "public class RowList { \npublic void optimize ( ) { \nfinal int numRows = this . rows . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numRows ) { \nget ( i ) . optimize ( ) ; \n++ i ; \n} \n} \n} \n} \n"}
{"6486": "public class HexConverter { \npublic static String toHex ( byte [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < arr . length ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0f ) ) ; \nbuf . append ( Integer . toHexString ( arr [ i ] & 0x0f ) ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6487": "public class HexConverter { \npublic static String toHex ( int [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < arr . length ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 28 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 24 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 20 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 16 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 12 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 8 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] ) & 0x0000000f ) ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) { \nreturn prefix ; \n} \nif ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) { \nreturn \"\" ; \n} \nelse { \nchar [ ] c = prefix . toCharArray ( ) ; \nint start = 0 ; \n{ \nint i = c . length - 1 ; \nwhile ( i >= 0 ) { \nif ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \ni -- ; \n} \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \n} \n} \n"}
{"6495": "public class DroolsBuilder { \nprotected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { \n{ \nIterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject error = iter . next ( ) ; \nif ( error instanceof ParserError ) { \nParserError err = ( ParserError ) error ; \nmarkers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; \n} \nelse if ( error instanceof KnowledgeBuilderResult ) { \nKnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; \nint [ ] errorLines = res . getLines ( ) ; \nmarkers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; \n} \nelse if ( error instanceof ExpanderException ) { \nExpanderException exc = ( ExpanderException ) error ; \nmarkers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; \n} \nelse { \nmarkers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"6511": "public class DSLTree { \npublic void addTokens ( String [ ] tokens , Node rootNode ) { \nNode thenode = rootNode ; \n{ \nint i = 0 ; \nwhile ( i < tokens . length ) { \nNode newnode = thenode . addToken ( tokens [ i ] ) ; \nthenode = newnode ; \ni ++ ; \n} \n} \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \n{ \nint idx = 0 ; \nwhile ( idx < count ) { \nSystem . out . print ( tab ) ; \nidx ++ ; \n} \n} \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nint v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nint v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v1OutDegree < v2OutDegree ) { \nreturn 1 ; \n} \nif ( v1OutDegree > v2OutDegree ) { \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \n{ \nfinal Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nwhile ( vertexIter . hasNext ( ) ) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( front ) { \noptimized . addFirst ( vertex ) ; \n} \nelse { \noptimized . addLast ( vertex ) ; \n} \nfront = ! front ; \n} \n} \nthis . vertices = optimized ; \n} \n} \n"}
{"6545": "public class MultiValuePasswordCallback { \npublic void clearPassword ( ) { \nfor ( char pw [ ] : this . secrets ) { \n{ \nint i = 0 ; \nwhile ( i < pw . length ) { \npw [ i ] = 0 ; \ni ++ ; \n} \n} \n} \nthis . secrets = new ArrayList < char [ ] > ( ) ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \n{ \nint index = 0 , count = classes1 . length ; \nwhile ( index < count ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) { \n++ index ; \ncontinue ; \n} \nelse if ( c1 . isPrimitive ( ) ) return true ; \nelse if ( c1 . isAssignableFrom ( c2 ) ) return false ; \nelse if ( c2 . isAssignableFrom ( c1 ) ) return true ; \n++ index ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6557": "public class OgnlRuntime { \npublic static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { \nMethod result = null ; \nif ( methods != null ) { \nClass typeClass = target != null ? target . getClass ( ) : null ; \nif ( typeClass == null && source != null && Class . class . isInstance ( source ) ) { \ntypeClass = ( Class ) source ; \n} \nClass [ ] argClasses = getArgClasses ( args ) ; \nMatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; \nif ( mm != null ) { \nresult = mm . mMethod ; \nClass [ ] mParameterTypes = mm . mParameterTypes ; \nSystem . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; \n{ \nint j = 0 ; \nwhile ( j < mParameterTypes . length ) { \nClass type = mParameterTypes [ j ] ; \nif ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) { \nactualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \nj ++ ; \n} \n} \n} \n} \nif ( result == null ) { \nresult = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; \n} \nreturn result ; \n} \n} \n"}
{"6559": "public class OgnlRuntime { \npublic static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { \nMap result ; \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nsynchronized ( _propertyDescriptorCache ) { \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nPropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; \nresult = new HashMap ( 101 ) ; \n{ \nint i = 0 , icount = pda . length ; \nwhile ( i < icount ) { \nif ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) { \npda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; \n} \nif ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) { \npda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; \n} \nresult . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; \ni ++ ; \n} \n} \nfindObjectIndexedPropertyDescriptors ( targetClass , result ) ; \n_propertyDescriptorCache . put ( targetClass , result ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6560": "public class OgnlRuntime { \npublic static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { \nPropertyDescriptor result = null ; \nPropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; \n{ \nint i = 0 , icount = pda . length ; \nwhile ( ( result == null ) && ( i < icount ) ) { \nif ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) { \nresult = pda [ i ] ; \n} \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \n{ \nwhile ( ) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( -- bufpos < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \n{ \nint i = 0 ; \nwhile ( i < _children . length ) { \nif ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse ++ newSize ; \n++ i ; \n} \n} \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \n{ \nint i = 0 ; \nwhile ( i < _children . length ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \n{ \nint k = 0 ; \nwhile ( k < c . jjtGetNumChildren ( ) ) { \nnewChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n++ k ; \n} \n} \n} \nelse newChildren [ j ++ ] = c ; \n++ i ; \n} \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6592": "public class AbstractArchivingMojo { \nprotected void checkArchiverForProblems ( Archiver archiver ) { \n{ \nResourceIterator iter = archiver . getResources ( ) ; \nwhile ( iter . hasNext ( ) ) { \niter . next ( ) ; \n} \n} \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nelse if ( ! dir . isDirectory ( ) ) { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories ++ ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \n{ \nint i = 0 , counter = 0 ; \nwhile ( i < numDirectories ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \ncounter ++ ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) { \nif ( size <= 0 ) { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \nelse { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \n{ \nint pos = 0 ; \nwhile ( pos < mFontSizeAdapter . getCount ( ) ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \npos ++ ; \n} \n} \n} \n} \n} \n} \n"}
{"6632": "public class CropImageView { \nprivate void recomputeFocus ( MotionEvent event ) { \n{ \nint i = 0 ; \nwhile ( i < mHighlightViews . size ( ) ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nhv . setFocus ( false ) ; \nhv . invalidate ( ) ; \ni ++ ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < mHighlightViews . size ( ) ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nint edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; \nif ( edge != HighlightView . GROW_NONE ) { \nif ( ! hv . hasFocus ( ) ) { \nhv . setFocus ( true ) ; \nhv . invalidate ( ) ; \n} \nbreak ; \n} \ni ++ ; \n} \n} \ninvalidate ( ) ; \n} \n} \n"}
{"6636": "public class RegexValidator { \npublic String validate ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \n{ \nint i = 0 ; \nwhile ( i < patterns . length ) { \nMatcher matcher = patterns [ i ] . matcher ( value ) ; \nif ( matcher . matches ( ) ) { \nint count = matcher . groupCount ( ) ; \nif ( count == 1 ) { \nreturn matcher . group ( 1 ) ; \n} \nStringBuffer buffer = new StringBuffer ( ) ; \n{ \nint j = 0 ; \nwhile ( j < count ) { \nString component = matcher . group ( j + 1 ) ; \nif ( component != null ) { \nbuffer . append ( component ) ; \n} \nj ++ ; \n} \n} \nreturn buffer . toString ( ) ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ch == '&' && refStart == - 1 ) { \nrefStart = dstlen ; \n} \nelse if ( refStart == - 1 ) { \n} \nelse if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse if ( ch == ';' ) { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ent > 0xFFFF ) { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nrefStart = - 1 ; \n} \nelse { \nrefStart = - 1 ; \n} \ni ++ ; \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) return ; \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) namespace = localName = \"\" ; \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) { \ntheContentHandler . endPrefixMapping ( prefix ) ; \n} \nAttributes atts = theStack . atts ( ) ; \n{ \nint i = atts . getLength ( ) - 1 ; \nwhile ( i >= 0 ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) { \ntheContentHandler . endPrefixMapping ( attPrefix ) ; \n} \ni -- ; \n} \n} \ntheStack = theStack . next ( ) ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \n{ \ne = 0 ; \nwhile ( e < len ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse if ( s < 0 && c != ' ' ) { \ns = e ; \n} \n} \nlastc = c ; \ne ++ ; \n} \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6668": "public class Parser { \nprivate void rectify ( Element e ) throws SAXException { \nElement sp ; \nwhile ( true ) { \n{ \nsp = theStack ; \nwhile ( sp != null ) { \nif ( sp . canContain ( e ) ) break ; \nsp = sp . next ( ) ; \n} \n} \nif ( sp != null ) break ; \nElementType parentType = e . parent ( ) ; \nif ( parentType == null ) break ; \nElement parent = new Element ( parentType , defaultAttributes ) ; \nparent . setNext ( e ) ; \ne = parent ; \n} \nif ( sp == null ) return ; \nwhile ( theStack != sp ) { \nif ( theStack == null || theStack . next ( ) == null || theStack . next ( ) . next ( ) == null ) break ; \nrestartablyPop ( ) ; \n} \nwhile ( e != null ) { \nElement nexte = e . next ( ) ; \nif ( ! e . name ( ) . equals ( \"<pcdata>\" ) ) push ( e ) ; \ne = nexte ; \nrestart ( e ) ; \n} \ntheNewElement = null ; \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \n{ \nwhile ( length -- > 0 ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \noffset ++ ; \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nint i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \nif ( ! name . equals ( value ) ) return false ; \n{ \nint j = 0 ; \nwhile ( j < booleans . length ) { \nif ( name . equals ( booleans [ j ] ) ) return true ; \nj ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6700": "public class StringUtils { \nprivate static String deleteAny ( final String inString , final String charsToDelete ) { \nif ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { \nreturn inString ; \n} \nfinal StringBuffer out = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < inString . length ( ) ) { \nfinal char c = inString . charAt ( i ) ; \nif ( charsToDelete . indexOf ( c ) == - 1 ) { \nout . append ( c ) ; \n} \ni ++ ; \n} \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"6764": "public class AbstractConfigurableMultipleStrategy { \npublic static String createItemsAsString ( final String ... items ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < items . length ) { \nsb . append ( items [ i ] ) ; \nif ( i < items . length - 1 ) { \nsb . append ( TOKEN_DELIMITER ) ; \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6814": "public class XmlModelFactory { \nprivate void processGroups ( final Document document ) { \nfinal NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; \n{ \nint i = 0 ; \nwhile ( i < groupNodeList . getLength ( ) ) { \nfinal Element groupElement = ( Element ) groupNodeList . item ( i ) ; \nfinal String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; \nallGroupElements . put ( name , groupElement ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"6816": "public class XmlModelFactory { \nprotected Group createGroup ( final Element element ) { \nfinal String name = element . getAttribute ( ATTR_GROUP_NAME ) ; \nfinal Group group = new Group ( name ) ; \nfinal List < Resource > resources = new ArrayList < Resource > ( ) ; \nfinal NodeList resourceNodeList = element . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < resourceNodeList . getLength ( ) ) { \nfinal Node node = resourceNodeList . item ( i ) ; \nif ( node instanceof Element ) { \nfinal Element resourceElement = ( Element ) node ; \nparseResource ( resourceElement , resources ) ; \n} \ni ++ ; \n} \n} \ngroup . setResources ( resources ) ; \nreturn group ; \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nint snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \n{ \nwhile ( ) { \nint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) { \nreturn ; \n} \nint updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { \nbreak ; \n} \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \n} \n{ \nwhile ( ) { \nint snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsFinished >= snapshotJobsProcessed ) { \nbreak ; \n} \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { \n{ \ncontinue ; \n} \n} \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) { \nLOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \n} \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo ++ ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \n} \n} \n} \n"}
{"6827": "public class ClassExpressionSaturationFactory { \nprivate static boolean updateIfSmaller ( AtomicInteger counter , int value ) { \n{ \nwhile ( ) { \nint snapshotCoutner = counter . get ( ) ; \nif ( snapshotCoutner >= value ) return false ; \nif ( counter . compareAndSet ( snapshotCoutner , value ) ) return true ; \n} \n} \n} \n} \n"}
{"6841": "public class LinearProbing { \nstatic < E > void remove ( E [ ] d , int pos ) { \n{ \nwhile ( ) { \nint next = getMovedPosition ( d , pos ) ; \nE moved = d [ pos ] = d [ next ] ; \nif ( moved == null ) return ; \npos = next ; \n} \n} \n} \n} \n"}
{"6842": "public class LinearProbing { \nstatic < K , V > void remove ( K [ ] k , V [ ] v , int pos ) { \n{ \nwhile ( ) { \nint next = getMovedPosition ( k , pos ) ; \nK moved = k [ pos ] = k [ next ] ; \nv [ pos ] = v [ next ] ; \nif ( moved == null ) return ; \npos = next ; \n} \n} \n} \n} \n"}
{"6843": "public class LinearProbing { \nstatic < E > int getMovedPosition ( E [ ] d , int del ) { \nint j = del ; \n{ \nwhile ( ) { \nif ( ++ j == d . length ) j = 0 ; \nE test = d [ j ] ; \nif ( test == null ) return j ; \nint k = getIndex ( test , d . length ) ; \nif ( ( del < j ) ? ( del < k ) && ( k <= j ) : ( del < k ) || ( k <= j ) ) { \ncontinue ; \n} \nreturn j ; \n} \n} \n} \n} \n"}
{"6851": "public class ArrayHashMap { \nprivate void enlarge ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( \"Map cannot grow beyond capacity: \" + LinearProbing . MAXIMUM_CAPACITY ) ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity << 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \n{ \nint i = 0 ; \nwhile ( i < oldCapacity ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \ni ++ ; \n} \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6852": "public class ArrayHashMap { \nprivate void shrink ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity <= LinearProbing . DEFAULT_INITIAL_CAPACITY ) return ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity >> 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \n{ \nint i = 0 ; \nwhile ( i < oldCapacity ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \ni ++ ; \n} \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6856": "public class EntryCollection { \n@ Override public void clear ( ) { \nmodCount ++ ; \nE [ ] tab = buckets ; \n{ \nint i = 0 ; \nwhile ( i < tab . length ) { \ntab [ i ] = null ; \ni ++ ; \n} \n} \nsize = 0 ; \n} \n} \n"}
{"6877": "public class StatisticsPrinter { \nstatic String getString ( char c , int n ) { \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nsb . append ( c ) ; \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( possibleValues . length > 0 ) { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \nelse { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \n{ \nint i = 0 ; \nwhile ( i < items ) { \nObject value ; \nif ( i < callValues . length ) { \nvalue = callValues [ i ] ; \n} \nelse { \nvalue = null ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \ni ++ ; \n} \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6911": "public class AbstractUberNode { \n@ Override public Iterator < UberNode > iterator ( ) { \nreturn new Iterator < UberNode > ( ) { \nint index = 0 ; \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( \"removing from uber node is not supported\" ) ; \n} \n@ Override public UberNode next ( ) { \nindex = findNextChildWithData ( ) ; \nreturn data . get ( index ++ ) ; \n} \n@ Override public boolean hasNext ( ) { \nreturn findNextChildWithData ( ) != - 1 ; \n} \nprivate int findNextChildWithData ( ) { \n{ \nint i = index ; \nwhile ( i < data . size ( ) ) { \nif ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \n{ \nint j = opIdx ; \nwhile ( j < ops . length ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { \n{ \nj ++ ; \ncontinue sourceLoop ; \n} \n} \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \nelse if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \n{ \nj ++ ; \ncontinue sourceLoop ; \n} \n} \nj ++ ; \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6950": "public class ServiceManagementImpl { \npublic void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; \n} \nif ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { \n{ \nint i = 0 ; \nwhile ( i < 15 ) { \ntry { \nThread . sleep ( 1000 ) ; \nlogger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nbreak ; \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \ni ++ ; \n} \n} \n} \nif ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nthrow new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; \n} \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; \n} \nServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; \nif ( serviceUsageMBean != null ) { \nserviceUsageMBean . remove ( ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nsleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nsleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; \n} \n} \n"}
{"6958": "public class AbstractOperation { \nprotected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { \nStringBuffer sb = new StringBuffer ( \"[\" ) ; \n{ \nint index = 0 ; \nwhile ( index < array . length ) { \nif ( editor != null ) { \neditor . setValue ( array [ index ] ) ; \nsb . append ( editor . getAsText ( ) ) ; \n} \nelse { \nsb . append ( array [ index ] . toString ( ) ) ; \n} \nif ( index < array . length - 1 ) { \nsb . append ( CID_SEPARATOR ) ; \n} \nindex ++ ; \n} \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6964": "public class NextSbbEntityFinder { \npublic Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { \nSbbEntityID sbbEntityId = null ; \nSbbEntity sbbEntity = null ; \nEventEntryDescriptor mEventEntry = null ; \n{ \nIterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nsbbEntityId = iter . next ( ) ; \nsbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; \nif ( sbbEntity == null ) { \n{ \ncontinue ; \n} \n} \nif ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) { \n{ \ncontinue ; \n} \n} \nif ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) { \nif ( ! sleeEvent . isActivityEndEvent ( ) ) { \n{ \ncontinue ; \n} \n} \nelse { \nreturn new Result ( sbbEntity , false ) ; \n} \n} \nmEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; \nif ( mEventEntry != null && mEventEntry . isReceived ( ) ) { \nreturn new Result ( sbbEntity , true ) ; \n} \nelse { \nif ( ! sleeEvent . isActivityEndEvent ( ) ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Event is not received by sbb descriptor of entity \" + sbbEntityId + \", will not deliver event to sbb entity ...\" ) ; \n} \n{ \ncontinue ; \n} \n} \nelse { \nreturn new Result ( sbbEntity , false ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6966": "public class DeployableUnitJarComponentBuilder { \nprivate void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { \nJarInputStream jarIs = null ; \ntry { \njarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; \n{ \nJarEntry entry = jarIs . getNextJarEntry ( ) ; \nwhile ( jarIs . available ( ) > 0 && entry != null ) { \nlogger . trace ( \"jar entry = \" + entry . getName ( ) ) ; \nif ( entry . isDirectory ( ) ) { \nFile dir = new File ( dstDir , entry . getName ( ) ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \nelse { \nFile file = new File ( dstDir , entry . getName ( ) ) ; \nFile dir = file . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \npipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; \n} \nentry = jarIs . getNextJarEntry ( ) ; \n} \n} \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; \n} \nfinally { \nif ( jarIs != null ) { \ntry { \njarIs . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close jar input stream\" , e ) ; \n} \n} \n} \n} \n} \n"}
{"6967": "public class DeployableUnitJarComponentBuilder { \nprivate void pipeStream ( InputStream is , OutputStream os ) throws IOException { \nsynchronized ( buffer ) { \ntry { \n{ \nint bytesRead = is . read ( buffer ) ; \nwhile ( bytesRead != - 1 ) { \nos . write ( buffer , 0 , bytesRead ) ; \nbytesRead = is . read ( buffer ) ; \n} \n} \nis . close ( ) ; \nos . close ( ) ; \n} \ncatch ( IOException ioe ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \ntry { \nos . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \nthrow ioe ; \n} \n} \n} \n} \n"}
{"7028": "public class ClassUtils { \npublic static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { \nHashMap abstractMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nif ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { \nabstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; \n} \ni ++ ; \n} \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7029": "public class ClassUtils { \npublic static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { \nHashMap interfaceMethods = new HashMap ( ) ; \nCtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nif ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { \nConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; \ninterfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \ni ++ ; \n} \n} \nMap temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; \n{ \nIterator i = temp . keySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nString key = ( String ) i . next ( ) ; \nif ( ! exceptMethods . containsKey ( key ) ) { \ninterfaceMethods . put ( key , temp . get ( key ) ) ; \n} \n} \n} \nreturn interfaceMethods ; \n} \n} \n"}
{"7064": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean containsAll ( Collection c ) { \nif ( c == null ) throw new NullPointerException ( \"null collection!\" ) ; \n{ \nIterator it = c . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nif ( ! contains ( it . next ( ) ) ) { \nreturn false ; \n} \n} \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"containsAll : collection = \" + c + \" > all in child relation\" ) ; \n} \nreturn true ; \n} \n} \n"}
{"7065": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean removeAll ( Collection c ) { \nboolean flag = true ; \nif ( c == null ) throw new NullPointerException ( \" null collection ! \" ) ; \n{ \nIterator it = c . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nflag &= this . remove ( it . next ( ) ) ; \n} \n} \nreturn flag ; \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \n{ \nint i = 0 ; \nwhile ( i < method . getParameterTypes ( ) . length ) { \nconcreteMethodBody += \",$\" + ( i + 1 ) ; \ni ++ ; \n} \n} \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \ni ++ ; \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"7131": "public class ClassUtils { \npublic static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { \nHashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; \nMethod [ ] methods = null ; \nClass [ ] superInterfaces ; \nsuperInterfaces = xInterfaceClass . getInterfaces ( ) ; \nfor ( Class superInterface : superInterfaces ) { \nif ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; \n} \nmethods = xInterfaceClass . getDeclaredMethods ( ) ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nabstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \ni ++ ; \n} \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \n{ \nint charIndex = 0 ; \nwhile ( charIndex < token . length ( ) ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \ncharIndex ++ ; \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7168": "public class SleeContainer { \npublic void initSlee ( ) throws InvalidStateException { \nif ( sleeState != null ) { \nthrow new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; \n} \nbeforeModulesInitialization ( ) ; \n{ \nIterator < SleeContainerModule > i = modules . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \ni . next ( ) . sleeInitialization ( ) ; \n} \n} \nafterModulesInitialization ( ) ; \nsleeState = SleeState . STOPPED ; \n} \n} \n"}
{"7169": "public class SleeContainer { \npublic void shutdownSlee ( ) throws InvalidStateException { \nif ( sleeState != SleeState . STOPPED ) { \nthrow new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; \n} \nbeforeModulesShutdown ( ) ; \n{ \nIterator < SleeContainerModule > i = modules . descendingIterator ( ) ; \nwhile ( i . hasNext ( ) ) { \ni . next ( ) . sleeShutdown ( ) ; \n} \n} \nafterModulesShutdown ( ) ; \nsleeState = null ; \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) { \nbridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \n} \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nwhile ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) { \ntry { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \n{ \nint i = 0 ; \nwhile ( i < devices . length ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \ni ++ ; \n} \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \n} \n} \n"}
{"7196": "public class TextEditor { \npublic TextEditor indent ( int spaces ) { \nStringBuilder sb = new StringBuilder ( spaces ) ; \n{ \nint i = 0 ; \nwhile ( i < spaces ) { \nsb . append ( ' ' ) ; \ni ++ ; \n} \n} \nreturn replaceAll ( \"^\" , sb . toString ( ) ) ; \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \nelse { \nint numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) { \nurl += \"?\" ; \n} \n{ \nint i = 1 ; \nwhile ( i <= numberOfPages ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \ni ++ ; \n} \n} \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7242": "public class Dbl { \npublic static double varianceDouble ( double [ ] values , final int start , final int length ) { \ndouble mean = mean ( values , start , length ) ; \ndouble temp = 0 ; \n{ \nint index = start ; \nwhile ( index < length ) { \ndouble a = values [ index ] ; \ntemp += ( mean - a ) * ( mean - a ) ; \nindex ++ ; \n} \n} \nreturn temp / length ; \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \n{ \nint index = 0 ; \nwhile ( index < chars . length ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \n{ \nindex ++ ; \ncontinue ; \n} \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \n{ \nindex ++ ; \ncontinue ; \n} \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \n{ \nindex ++ ; \ncontinue ; \n} \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \n{ \nindex ++ ; \ncontinue ; \n} \n} \nbuffer . append ( cchar ) ; \nindex ++ ; \n} \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 && ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasNumber = false ; \n} \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 && ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasUpperCase = false ; \n} \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7278": "public class Str { \npublic static String [ ] fromCharArrayOfArrayToStringArray ( char [ ] [ ] split ) { \nString [ ] results = new String [ split . length ] ; \nchar [ ] array ; \n{ \nint index = 0 ; \nwhile ( index < split . length ) { \narray = split [ index ] ; \nresults [ index ] = array . length == 0 ? EMPTY_STRING : FastStringUtils . noCopyStringFromChars ( array ) ; \nindex ++ ; \n} \n} \nreturn results ; \n} \n} \n"}
{"7283": "public class Sort { \npublic static Sort sorts ( Sort ... sorts ) { \nif ( sorts == null || sorts . length == 0 ) { \nreturn null ; \n} \nSort main = sorts [ 0 ] ; \n{ \nint index = 1 ; \nwhile ( index < sorts . length ) { \nmain . then ( sorts [ index ] ) ; \nindex ++ ; \n} \n} \nreturn main ; \n} \n} \n"}
{"7289": "public class Int { \npublic static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { \nif ( expected . length != got . length ) { \ndie ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; \n} \n{ \nint index = 0 ; \nwhile ( index < expected . length ) { \nif ( expected [ index ] != got [ index ] ) { \ndie ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; \n} \nindex ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7290": "public class Int { \npublic static int sum ( int [ ] values , int start , int length ) { \nlong sum = 0 ; \n{ \nint index = start ; \nwhile ( index < length ) { \nsum += values [ index ] ; \nindex ++ ; \n} \n} \nif ( sum < Integer . MIN_VALUE ) { \ndie ( \"overflow the sum is too small\" , sum ) ; \n} \nif ( sum > Integer . MAX_VALUE ) { \ndie ( \"overflow the sum is too big\" , sum ) ; \n} \nreturn ( int ) sum ; \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \n{ \nint index = 1 ; \nwhile ( index < array . length ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \nindex ++ ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \n{ \nint index = 0 ; \nwhile ( index < path . length ) { \nString propName = path [ index ] ; \nif ( o == null ) { \nreturn null ; \n} \nelse if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse { \no = getProp ( o , propName ) ; \n} \nindex ++ ; \n} \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7406": "public class BucketPoint { \npublic static < T extends BucketPoint > List < T > toList ( Map < Long , T > pointMap , Buckets buckets , BiFunction < Long , Long , T > emptyBucketFactory ) { \nList < T > result = new ArrayList < > ( buckets . getCount ( ) ) ; \n{ \nint index = 0 ; \nwhile ( index < buckets . getCount ( ) ) { \nlong from = buckets . getBucketStart ( index ) ; \nT bucketPoint = pointMap . get ( from ) ; \nif ( bucketPoint == null ) { \nlong to = from + buckets . getStep ( ) ; \nbucketPoint = emptyBucketFactory . apply ( from , to ) ; \n} \nresult . add ( bucketPoint ) ; \nindex ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7446": "public class Base64 { \nprivate static int removeWhiteSpace ( char [ ] data ) { \nif ( data == null ) { \nreturn 0 ; \n} \nint newSize = 0 ; \nint len = data . length ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nif ( ! isWhiteSpace ( data [ i ] ) ) { \ndata [ newSize ++ ] = data [ i ] ; \n} \ni ++ ; \n} \n} \nreturn newSize ; \n} \n} \n"}
{"7465": "public class SSPTaskNotificationService { \nprivate NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) { \nString error = readContext . read ( MESSAGE_QUERY ) ; \nreturn notificationError ( error ) ; \n} \nObject rows = readContext . read ( ROWS_QUERY ) ; \nif ( ! ( rows instanceof JSONArray ) ) { \nthrow new RuntimeException ( \"Expected 'rows' to be an array of tasks\" ) ; \n} \nString source = getNotificationSource ( request ) ; \nList < NotificationEntry > list = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < ( ( JSONArray ) rows ) . size ( ) ) { \nNotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; \nif ( entry != null ) { \nattachActions ( request , entry ) ; \nlist . add ( entry ) ; \n} \ni ++ ; \n} \n} \nNotificationResponse notification = new NotificationResponse ( ) ; \nif ( ! list . isEmpty ( ) ) { \nNotificationCategory category = getNotificationCategory ( request ) ; \ncategory . addEntries ( list ) ; \nnotification . setCategories ( Arrays . asList ( category ) ) ; \n} \nreturn notification ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \n{ \nint i = 0 ; \nwhile ( i < polygon . size ( ) ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( p . x < rectangle . p0 . x ) { \nrectangle . p0 . x = p . x ; \n} \nelse if ( p . x > rectangle . p1 . x ) { \nrectangle . p1 . x = p . x ; \n} \nif ( p . y < rectangle . p0 . y ) { \nrectangle . p0 . y = p . y ; \n} \nelse if ( p . y > rectangle . p1 . y ) { \nrectangle . p1 . y = p . y ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"7488": "public class UtilPolygons2D_F64 { \npublic static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { \naverage . setIdx ( 0 , 0 ) ; \n{ \nint i = 0 ; \nwhile ( i < input . size ( ) ) { \nPoint2D_F64 v = input . vertexes . data [ i ] ; \naverage . x += v . x ; \naverage . y += v . y ; \ni ++ ; \n} \n} \naverage . x /= input . size ( ) ; \naverage . y /= input . size ( ) ; \n} \n} \n"}
{"7489": "public class UtilPolygons2D_F64 { \npublic static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { \nPoint2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < points . size ( ) ) { \narray [ i ] = points . get ( i ) ; \ni ++ ; \n} \n} \nAndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; \nandrew . process ( array , array . length , hull ) ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \n{ \nint i = 0 ; \nwhile ( i < polygon . vertexes . size ( ) ) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( angle <= tol ) { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) i = polygon . vertexes . size ( ) - 1 ; \n} \nelse { \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \n{ \nint i = 0 ; \nwhile ( i < target . size ( ) ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength += b0 . distance ( b1 ) ; \ni ++ ; \n} \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nint cornerB = 0 ; \n{ \nint k = 0 ; \nwhile ( k < numberOfSamples ) { \ndouble location = totalLength * k / numberOfSamples ; \nwhile ( location > cornerLocationsB [ cornerB + 1 ] ) { \ncornerB ++ ; \n} \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \n{ \nint i = 0 ; \nwhile ( i < model . size ( ) + 1 ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( d < best ) { \nbest = d ; \n} \ni ++ ; \n} \n} \nerror += best ; \nk ++ ; \n} \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7515": "public class FitPlane3D_F64 { \npublic boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \noutputCenter . set ( 0 , 0 , 0 ) ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \nPoint3D_F64 p = points . get ( i ) ; \noutputCenter . x += p . x ; \noutputCenter . y += p . y ; \noutputCenter . z += p . z ; \ni ++ ; \n} \n} \noutputCenter . x /= N ; \noutputCenter . y /= N ; \noutputCenter . z /= N ; \nreturn solvePoint ( points , outputCenter , outputNormal ) ; \n} \n} \n"}
{"7516": "public class FitPlane3D_F64 { \npublic boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \nA . reshape ( N , 3 ) ; \nint index = 0 ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \nPoint3D_F64 p = points . get ( i ) ; \nA . data [ index ++ ] = p . x - pointOnPlane . x ; \nA . data [ index ++ ] = p . y - pointOnPlane . y ; \nA . data [ index ++ ] = p . z - pointOnPlane . z ; \ni ++ ; \n} \n} \nif ( ! solverNull . process ( A , 1 , nullspace ) ) return false ; \noutputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; \noutputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; \noutputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; \nreturn true ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nhull . get ( i ) . set ( input [ i ] ) ; \ni ++ ; \n} \n} \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \ni ++ ; \n} \n} \nwork . removeTail ( ) ; \nint minSize = work . size + 2 ; \n{ \nint i = length - 1 ; \nwhile ( i >= 0 ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \ni -- ; \n} \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \n{ \nint i = 0 ; \nwhile ( i < work . size ( ) ) { \nhull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"7548": "public class SePointOps_F64 { \npublic static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { \ndouble tranX = se . getX ( ) ; \ndouble tranY = se . getY ( ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nPoint2D_F64 pt = points [ i ] ; \ndouble x = pt . x ; \ndouble y = pt . y ; \npt . x = tranX + x * c - y * s ; \npt . y = tranY + x * s + y * c ; \ni ++ ; \n} \n} \n} \n} \n"}
{"7565": "public class GeoTuple_F64 { \npublic boolean isIdentical ( T t , double tol ) { \nif ( t . getDimension ( ) != getDimension ( ) ) return false ; \nint N = getDimension ( ) ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \ndouble diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; \nif ( diff > tol ) return false ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7566": "public class GeoTuple_F64 { \n@ Override public T copy ( ) { \nT ret = createNewInstance ( ) ; \nint N = getDimension ( ) ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \nret . setIdx ( i , getIdx ( i ) ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7567": "public class GeoTuple_F64 { \npublic double normSq ( ) { \ndouble total = 0 ; \nint N = getDimension ( ) ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \ndouble a = getIdx ( i ) ; \ntotal += a * a ; \ni ++ ; \n} \n} \nreturn total ; \n} \n} \n"}
{"7574": "public class UtilPoint4D_F64 { \npublic static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { \nList < Point4D_F64 > ret = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \nPoint4D_F64 p = new Point4D_F64 ( ) ; \np . x = center . x + rand . nextGaussian ( ) * stdev ; \np . y = center . y + rand . nextGaussian ( ) * stdev ; \np . z = center . z + rand . nextGaussian ( ) * stdev ; \np . w = w ; \nret . add ( p ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7595": "public class Distance2D_F64 { \npublic static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { \nif ( storage == null ) storage = LineSegment2D_F64 . wrap ( null , null ) ; \ndouble minimum = Double . MAX_VALUE ; \n{ \nint i = 0 ; \nwhile ( i < poly . size ( ) ) { \nint j = ( i + 1 ) % poly . size ( ) ; \nstorage . a = poly . vertexes . data [ i ] ; \nstorage . b = poly . vertexes . data [ j ] ; \ndouble d = distanceSq ( storage , p ) ; \nif ( d < minimum ) minimum = d ; \ni ++ ; \n} \n} \nreturn minimum ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \n{ \nint i = offset , idxA = 0 ; \nwhile ( i < end ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \n{ \nint j = 0 ; \nwhile ( j < numCoefs ) { \nA . data [ idxA ++ ] = pow ; \npow *= x ; \nj ++ ; \n} \n} \nb . data [ i / 2 ] = y ; \ni += 2 ; \n} \n} \nif ( ! solver . setA ( A ) ) return false ; \nsolver . solve ( b , x ) ; \n{ \nint i = 0 ; \nwhile ( i < numCoefs ) { \noutput . set ( i , x . data [ i ] ) ; \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7607": "public class UtilVector3D_F64 { \npublic static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { \nif ( R == null ) { \nR = new DMatrixRMaj ( 3 , v . length ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < v . length ) { \nR . set ( 0 , i , v [ i ] . x ) ; \nR . set ( 1 , i , v [ i ] . y ) ; \nR . set ( 2 , i , v [ i ] . z ) ; \ni ++ ; \n} \n} \nreturn R ; \n} \n} \n"}
{"7614": "public class Area2D_F64 { \npublic static double polygonSimple ( Polygon2D_F64 poly ) { \ndouble total = 0 ; \nPoint2D_F64 v0 = poly . get ( 0 ) ; \nPoint2D_F64 v1 = poly . get ( 1 ) ; \n{ \nint i = 2 ; \nwhile ( i < poly . size ( ) ) { \nPoint2D_F64 v2 = poly . get ( i ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \ni ++ ; \n} \n} \nPoint2D_F64 v2 = poly . get ( 0 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \nv2 = poly . get ( 1 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nreturn Math . abs ( total / 2.0 ) ; \n} \n} \n"}
{"7615": "public class UtilPoint2D_F64 { \npublic static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { \nif ( mean == null ) mean = new Point2D_F64 ( ) ; \ndouble x = 0 ; \ndouble y = 0 ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nPoint2D_F64 p = list [ offset + i ] ; \nx += p . getX ( ) ; \ny += p . getY ( ) ; \ni ++ ; \n} \n} \nx /= length ; \ny /= length ; \nmean . set ( x , y ) ; \nreturn mean ; \n} \n} \n"}
{"7616": "public class UtilPoint2D_F64 { \npublic static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { \nPoint2D_F64 center = mean ( points , null ) ; \ndouble angles [ ] = new double [ points . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < angles . length ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - center . x ; \ndouble dy = p . y - center . y ; \nangles [ i ] = Math . atan2 ( dy , dx ) ; \ni ++ ; \n} \n} \nint order [ ] = new int [ points . size ( ) ] ; \nQuickSort_F64 sorter = new QuickSort_F64 ( ) ; \nsorter . sort ( angles , 0 , points . size ( ) , order ) ; \nList < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < points . size ( ) ) { \nout . add ( points . get ( order [ i ] ) ) ; \ni ++ ; \n} \n} \nreturn out ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \n{ \nint i = 0 ; \nwhile ( i < points . size ( ) ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \ni ++ ; \n} \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7618": "public class UtilPolygons2D_I32 { \npublic static boolean isConvex ( Polygon2D_I32 poly ) { \nfinal int N = poly . size ( ) ; \nint numPositive = 0 ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \nint j = ( i + 1 ) % N ; \nint k = ( i + 2 ) % N ; \nPoint2D_I32 a = poly . vertexes . data [ i ] ; \nPoint2D_I32 b = poly . vertexes . data [ j ] ; \nPoint2D_I32 c = poly . vertexes . data [ k ] ; \nint dx0 = a . x - b . x ; \nint dy0 = a . y - b . y ; \nint dx1 = c . x - b . x ; \nint dy1 = c . y - b . y ; \nint z = dx0 * dy1 - dy0 * dx1 ; \nif ( z > 0 ) numPositive ++ ; \ni ++ ; \n} \n} \nreturn ( numPositive == 0 || numPositive == N ) ; \n} \n} \n"}
{"7623": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nVector3D_F64 axisX = new Vector3D_F64 ( ) ; \nVector3D_F64 axisY = new Vector3D_F64 ( ) ; \nUtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \ndouble x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \ndouble y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = plane . p . x + axisX . x * x + axisY . x * y ; \np . y = plane . p . y + axisX . y * x + axisY . y * y ; \np . z = plane . p . z + axisX . z * x + axisY . z * y ; \nret . add ( p ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7624": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( Point3D_F64 mean , double minX , double maxX , double minY , double maxY , double minZ , double maxZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; \np . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; \np . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; \nret . add ( p ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7625": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > randomN ( Point3D_F64 mean , double stdX , double stdY , double stdZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextGaussian ( ) * stdX ; \np . y = mean . y + rand . nextGaussian ( ) * stdY ; \np . z = mean . z + rand . nextGaussian ( ) * stdZ ; \nret . add ( p ) ; \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7627": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { \nif ( mean == null ) mean = new Point3D_F64 ( ) ; \ndouble x = 0 , y = 0 , z = 0 ; \n{ \nint i = 0 ; \nwhile ( i < num ) { \nPoint3D_F64 p = points . get ( i ) ; \nx += p . x ; \ny += p . y ; \nz += p . z ; \ni ++ ; \n} \n} \nmean . x = x / num ; \nmean . y = y / num ; \nmean . z = z / num ; \nreturn mean ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) { \ntry { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nodes . getLength ( ) ) { \nif ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) { \nif ( result == null ) { \nresult = new HashSet < String > ( ) ; \n} \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \nelse if ( \"include\" . equals ( child . getNodeName ( ) ) ) { \nresult = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \n} \ni ++ ; \n} \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7635": "public class InstallFeatureUtil { \nprivate static Set < String > parseFeatureManagerNode ( Element node ) { \nSet < String > result = new HashSet < String > ( ) ; \nNodeList features = node . getElementsByTagName ( \"feature\" ) ; \nif ( features != null ) { \n{ \nint j = 0 ; \nwhile ( j < features . getLength ( ) ) { \nString content = features . item ( j ) . getTextContent ( ) ; \nif ( content != null ) { \nif ( content . contains ( \":\" ) ) { \nString [ ] split = content . split ( \":\" , 2 ) ; \nresult . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; \n} \nelse { \nresult . add ( content . trim ( ) . toLowerCase ( ) ) ; \n} \n} \nj ++ ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \nreturn 0 ; \n} \nelse if ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse if ( version1 != null && version2 == null ) { \nreturn 1 ; \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \n{ \nint i = 0 ; \nwhile ( i < components1 . length && i < components2 . length ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \ni ++ ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7656": "public class Puzzle { \npublic int getDistanceToGoal ( ) { \nint distance = 0 ; \n{ \nint i = 0 ; \nwhile ( i < cells . length ) { \ndistance += getDistance ( i , cells [ i ] ) ; \ni ++ ; \n} \n} \nreturn distance ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) throw new NullPointerException ( \"argument array is null\" ) ; \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \n{ \nint i = 0 ; \nwhile ( i < a . length ) { \nif ( ! ( a [ i ] >= 0.0 ) ) throw new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \nsum = sum + a [ i ] ; \ni ++ ; \n} \n} \nif ( sum > 1.0 + EPSILON || sum < 1.0 - EPSILON ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nwhile ( true ) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \n{ \nint i = 0 ; \nwhile ( i < a . length ) { \nsum = sum + a [ i ] ; \nif ( sum > r ) return i ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nint N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . println ( \"seed = \" + StdRandom . getSeed ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < N ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . println ( ) ; \ni ++ ; \n} \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . println ( ) ; \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < item . getReceivers ( ) . size ( ) ) { \nto [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \ni ++ ; \n} \n} \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) { \nfor ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) { \nentry . setValue ( value ) ; \n} \n} \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nint len = BLOCK_LENGTH - bufferLen ; \nif ( len < 9 ) { \nlen += BLOCK_LENGTH ; \n} \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \n{ \nint i = 1 ; \nwhile ( i < len - 8 ) { \nbuf [ i ] = ( byte ) 0x00 ; \ni ++ ; \n} \n} \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \n} \n} \n"}
{"7726": "public class Passwords { \npublic static boolean verify ( String password , byte [ ] hash ) { \nbyte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; \nint n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; \nint r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; \nint p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; \nif ( n > N || n < N_MIN || r > R || r < R_MIN || p > P || p < P_MIN ) { \nn = N ; \nr = R ; \np = P ; \n} \nbyte [ ] salt = new byte [ SALT_LENGTH ] ; \nSystem . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; \nbyte [ ] expected = hash ( password , salt , r , n , p ) ; \nint result = 0 ; \n{ \nint i = 0 ; \nwhile ( i < h . length ) { \nresult |= h [ i ] ^ expected [ i ] ; \ni ++ ; \n} \n} \nreturn result == 0 ; \n} \n} \n"}
{"7735": "public class Numbers { \npublic static long max ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong max = values [ 0 ] ; \n{ \nint i = 1 ; \nwhile ( i < values . length ) { \nmax = Math . max ( max , values [ i ] ) ; \ni ++ ; \n} \n} \nreturn max ; \n} \n} \n"}
{"7736": "public class Numbers { \npublic static long min ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong min = values [ 0 ] ; \n{ \nint i = 1 ; \nwhile ( i < values . length ) { \nmin = Math . min ( min , values [ i ] ) ; \ni ++ ; \n} \n} \nreturn min ; \n} \n} \n"}
{"7741": "public class LocationForecastHelper { \npublic List < MeteoExtrasForecast > findHourlyPointForecastsFromNow ( int hoursAhead ) { \nList < MeteoExtrasForecast > pointExtrasForecasts = new ArrayList < > ( ) ; \nZonedDateTime now = getNow ( ) ; \n{ \nint i = 0 ; \nwhile ( i < hoursAhead ) { \nZonedDateTime ahead = now . plusHours ( i ) ; \nOptional < PointForecast > pointForecast = getIndexer ( ) . getPointForecast ( ahead ) ; \npointForecast . ifPresent ( pof -> { \nOptional < PeriodForecast > periodForecast = getIndexer ( ) . getTightestFitPeriodForecast ( pof . getFrom ( ) ) ; \nperiodForecast . ifPresent ( pef -> pointExtrasForecasts . add ( new MeteoExtrasForecast ( pof , pef ) ) ) ; \n} \n) ; \ni ++ ; \n} \n} \nreturn pointExtrasForecasts ; \n} \n} \n"}
{"7744": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = getNow ( ) ; \n{ \nint i = 0 ; \nwhile ( i <= 6 ) { \nZonedDateTime dti = dt . plusDays ( i ) ; \nif ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { \nMeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; \nif ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) { \nforecastDays . add ( mefd ) ; \n} \n} \ni ++ ; \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7745": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createLongTermForecast ( ) { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; \n{ \nint i = 0 ; \nwhile ( i < series . getSeries ( ) . size ( ) ) { \ncreateLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; \ni ++ ; \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \n{ \nbegin = open ; \nwhile ( begin <= close ) { \nif ( begin > 0 && lookingAt ) { \nreturn false ; \n} \nestart = begin ; \nestop = data . length ( ) ; \n{ \nwhile ( ) { \nif ( shorter ) { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nelse { \nend = d . longest ( begin , estop , hitend ) ; \n} \nif ( hitend [ 0 ] && cold == - 1 ) { \ncold = begin ; \n} \nif ( end == - 1 ) { \nbreak ; \n} \n{ \nint x = 0 ; \nwhile ( x < match . size ( ) ) { \nmatch . set ( x , null ) ; \nx ++ ; \n} \n} \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( shorter ) { \nestart = end + 1 ; \n} \nelse { \nestop = end - 1 ; \n} \n} \n} \nbegin ++ ; \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nint mid ; \nassert t . op == '.' ; \nassert t . left != null && t . left . machine . states . length > 0 ; \nassert t . right != null && t . right . machine . states . length > 0 ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( mem [ t . retry ] == 0 ) { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nelse { \nmid = begin + ( mem [ t . retry ] - 1 ) ; \n} \n{ \nwhile ( ) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) { \nbreak ; \n} \nif ( mid == end ) { \nreturn false ; \n} \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nint i ; \nint n = t . number ; \nint len ; \nint paren ; \nint p ; \nint stop ; \nint min = t . min ; \nint max = t . max ; \nassert t . op == 'b' ; \nassert n >= 0 ; \nif ( match . get ( n ) == null ) { \nreturn false ; \n} \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) { \nreturn false ; \n} \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) { \nreturn begin == end ; \n} \nassert end >= begin ; \nif ( ( end - begin ) < len ) { \nreturn false ; \n} \nstop = end - len ; \ni = 0 ; \n{ \np = begin ; \nwhile ( p <= stop && ( i < max || max == Compiler . INFINITY ) ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) { \nbreak ; \n} \ni ++ ; \np += len ; \n} \n} \nif ( p != end ) { \nreturn false ; \n} \nreturn min <= i && ( i <= max || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7778": "public class Compiler { \nprivate void cloneouts ( Nfa nfa , State old , State from , State to , int type ) { \nArc a ; \nassert old != from ; \n{ \na = old . outs ; \nwhile ( a != null ) { \nnfa . newarc ( type , a . co , from , to ) ; \na = a . outchain ; \n} \n} \n} \n} \n"}
{"7782": "public class Compiler { \nprivate Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { \nState left ; \nState right ; \nSubre branches ; \nSubre branch ; \nSubre t ; \nint firstbranch ; \nassert stopper == ')' || stopper == EOS ; \nbranches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branches ; \nfirstbranch = 1 ; \ndo { \nif ( 0 == firstbranch ) { \nbranch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branch . right ; \n} \nfirstbranch = 0 ; \nleft = nfa . newstate ( ) ; \nright = nfa . newstate ( ) ; \nnfa . emptyarc ( initState , left ) ; \nnfa . emptyarc ( right , finalState ) ; \nbranch . left = parsebranch ( stopper , type , left , right , false ) ; \nbranch . flags |= up ( branch . flags | branch . left . flags ) ; \nif ( ( branch . flags & ~ branches . flags ) != 0 ) { \n{ \nt = branches ; \nwhile ( t != branch ) { \nt . flags |= branch . flags ; \nt = t . right ; \n} \n} \n} \n} \nwhile ( eat ( '|' ) ) ; \nassert see ( stopper ) || see ( EOS ) ; \nif ( ! see ( stopper ) ) { \nassert stopper == ')' && see ( EOS ) ; \nthrow new RegexException ( \"Unbalanced parentheses.\" ) ; \n} \nif ( branch == branches ) { \nassert branch . right == null ; \nt = branch . left ; \nbranch . left = null ; \nbranches = t ; \n} \nelse if ( ! messy ( branches . flags ) ) { \nbranches . left = null ; \nbranches . right = null ; \nbranches . op = '=' ; \n} \nreturn branches ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nint rangeCount = set . getRangeCount ( ) ; \n{ \nint rx = 0 ; \nwhile ( rx < rangeCount ) { \nint rangeStart = set . getRangeStart ( rx ) ; \nint rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) { \nLOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \n} \nif ( rangeStart == rangeEnd ) { \nnfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \n} \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \nrx ++ ; \n} \n} \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \n{ \nshort co = 0 ; \nwhile ( co < colorDescs . size ( ) ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \n{ \nco ++ ; \ncontinue ; \n} \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \n{ \na = cd . arcs ; \nwhile ( a != null ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \na = a . colorchain ; \n} \n} \n} \nco ++ ; \n} \n} \n} \n} \n"}
{"7797": "public class ColorMap { \nvoid uncolorchain ( Arc a ) { \nColorDesc cd = colorDescs . get ( a . co ) ; \nArc aa ; \naa = cd . arcs ; \nif ( aa == a ) { \ncd . arcs = a . colorchain ; \n} \nelse { \n{ \nwhile ( aa != null && aa . colorchain != a ) { \naa = aa . colorchain ; \n} \n} \nassert aa != null ; \naa . colorchain = a . colorchain ; \n} \na . colorchain = null ; \n} \n} \n"}
{"7798": "public class ColorMap { \nvoid dumpcolors ( ) { \n{ \nint co = 0 ; \nwhile ( co < colorDescs . size ( ) ) { \nColorDesc cd = colorDescs . get ( co ) ; \nif ( cd != null ) { \ndumpcolor ( co , cd ) ; \n} \nco ++ ; \n} \n} \n} \n} \n"}
{"7800": "public class Lex { \nvoid prefixes ( ) throws RegexException { \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nreturn ; \n} \nif ( have ( 4 ) && next3 ( '*' , '*' , '*' ) ) { \nswitch ( charAtNowPlus ( 3 ) ) { \ncase '?' : throw new RegexException ( \"REG_BADPAT\" ) ; \ncase '=' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \nv . now += 4 ; \nreturn ; \ncase ':' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_ADVANCED ; \nv . now += 4 ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADRPT\" ) ; \n} \n} \nif ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) { \nreturn ; \n} \nif ( have ( 3 ) && next2 ( '(' , '?' ) && iscalpha ( charAtNowPlus ( 2 ) ) ) { \nv . note ( Flags . REG_UNONPOSIX ) ; \nv . now += 2 ; \n{ \nwhile ( ! ateos ( ) && iscalpha ( charAtNow ( ) ) ) { \nswitch ( charAtNow ( ) ) { \ncase 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'c' : v . cflags &= ~ Flags . REG_ICASE ; \nbreak ; \ncase 'e' : v . cflags |= Flags . REG_EXTENDED ; \nv . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'i' : v . cflags |= Flags . REG_ICASE ; \nbreak ; \ncase 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; \nbreak ; \ncase 'p' : v . cflags |= Flags . REG_NLSTOP ; \nv . cflags &= ~ Flags . REG_NLANCH ; \nbreak ; \ncase 'q' : v . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ Flags . REG_ADVANCED ; \nbreak ; \ncase 's' : v . cflags &= ~ Flags . REG_NEWLINE ; \nbreak ; \ncase 't' : v . cflags &= ~ Flags . REG_EXPANDED ; \nbreak ; \ncase 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; \nv . cflags |= Flags . REG_NLANCH ; \nbreak ; \ncase 'x' : v . cflags |= Flags . REG_EXPANDED ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADOPT\" ) ; \n} \nv . now ++ ; \n} \n} \nif ( ! next1 ( ')' ) ) { \nthrow new RegexException ( \"REG_BADOPT\" ) ; \n} \nv . now ++ ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nv . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \n} \n} \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nint p ; \nint q ; \nlong tmp ; \nif ( last - first <= 1 ) { \nreturn ; \n} \n{ \np = first ; \nwhile ( p <= last ) { \n{ \nq = p ; \nwhile ( q <= last ) { \nshort pco = Cnfa . carcColor ( arcs [ p ] ) ; \nshort qco = Cnfa . carcColor ( arcs [ q ] ) ; \nint pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nint qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( pco > qco || ( pco == qco && pto > qto ) ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \nq ++ ; \n} \n} \np ++ ; \n} \n} \n} \n} \n"}
{"7812": "public class Nfa { \nvoid copyins ( State old , State newState ) { \nArc a ; \nassert old != newState ; \n{ \na = old . ins ; \nwhile ( a != null ) { \ncparc ( a , a . from , newState ) ; \na = a . inchain ; \n} \n} \n} \n} \n"}
{"7813": "public class Nfa { \nvoid copyouts ( State old , State newState ) { \nArc a ; \nassert old != newState ; \n{ \na = old . outs ; \nwhile ( a != null ) { \ncparc ( a , newState , a . to ) ; \na = a . outchain ; \n} \n} \n} \n} \n"}
{"7817": "public class Nfa { \nvoid duptraverse ( State s , State stmp ) { \nArc a ; \nif ( s . tmp != null ) { \nreturn ; \n} \ns . tmp = ( stmp == null ) ? newstate ( ) : stmp ; \nif ( s . tmp == null ) { \nreturn ; \n} \n{ \na = s . outs ; \nwhile ( a != null ) { \nduptraverse ( a . to , null ) ; \nassert a . to . tmp != null ; \ncparc ( a , s . tmp , a . to . tmp ) ; \na = a . outchain ; \n} \n} \n} \n} \n"}
{"7819": "public class Nfa { \nvoid dumpnfa ( ) { \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) { \nreturn ; \n} \nLOG . debug ( \"dump nfa\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"pre %d, post %d init %d final %d\" , pre . no , post . no , init . no , finalState . no ) ) ; \nif ( bos [ 0 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", bos [%d]\" , bos [ 0 ] ) ) ; \n} \nif ( bos [ 1 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", bol [%d]\" , bos [ 1 ] ) ) ; \n} \nif ( eos [ 0 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", eos [%d]\" , eos [ 0 ] ) ) ; \n} \nif ( eos [ 1 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", eol [%d]\" , eos [ 1 ] ) ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \n{ \nState s = states ; \nwhile ( s != null ) { \ndumpstate ( s ) ; \ns = s . next ; \n} \n} \nif ( parent == null ) { \ncm . dumpcolors ( ) ; \n} \n} \n} \n"}
{"7820": "public class Nfa { \nvoid dumpstate ( State s ) { \nArc a ; \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) { \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"State %d%s%c\" , s . no , ( s . tmp != null ) ? \"T\" : \"\" , ( s . flag != 0 ) ? ( char ) s . flag : '.' ) ) ; \nif ( s . prev != null && s . prev . next != s ) { \nsb . append ( String . format ( \"\\tstate chain bad\" ) ) ; \n} \nif ( s . nouts == 0 ) { \nsb . append ( \"\\tno out arcs\" ) ; \n} \nelse { \ndumparcs ( s , sb ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \n{ \na = s . ins ; \nwhile ( a != null ) { \nif ( a . to != s ) { \nLOG . debug ( String . format ( \"\\tlink from %d to %d on %d's in-chain\" , a . from . no , a . to . no , s . no ) ) ; \n} \na = a . inchain ; \n} \n} \n} \n} \n"}
{"7823": "public class Nfa { \nvoid dumparc ( Arc a , State s , StringBuilder sb ) { \nsb . append ( \"\\t\" ) ; \nswitch ( a . type ) { \ncase Compiler . PLAIN : sb . append ( String . format ( \"[%d]\" , a . co ) ) ; \nbreak ; \ncase Compiler . AHEAD : sb . append ( String . format ( \">%d>\" , a . co ) ) ; \nbreak ; \ncase Compiler . BEHIND : sb . append ( String . format ( \"<%d<\" , a . co ) ) ; \nbreak ; \ncase Compiler . LACON : sb . append ( String . format ( \":%d:\" , a . co ) ) ; \nbreak ; \ncase '^' : case '$' : sb . append ( String . format ( \"%c%d\" , ( char ) a . type , a . co ) ) ; \nbreak ; \ncase Compiler . EMPTY : break ; \ndefault : sb . append ( String . format ( \"0x%x/0%d\" , a . type , a . co ) ) ; \nbreak ; \n} \nif ( a . from != s ) { \nsb . append ( String . format ( \"?%d?\" , a . from . no ) ) ; \n} \nsb . append ( \"->\" ) ; \nif ( a . to == null ) { \nsb . append ( \"null\" ) ; \nArc aa ; \n{ \naa = a . to . ins ; \nwhile ( aa != null ) { \nif ( aa == a ) { \nbreak ; \n} \naa = aa . inchain ; \n} \n} \nif ( aa == null ) { \nLOG . debug ( \"?!?\" ) ; \n} \n} \nelse { \nsb . append ( String . format ( \"%d\" , a . to . no ) ) ; \n} \n} \n} \n"}
{"7825": "public class Nfa { \nlong analyze ( ) { \nArc a ; \nArc aa ; \nif ( pre . outs == null ) { \nreturn Flags . REG_UIMPOSSIBLE ; \n} \n{ \na = pre . outs ; \nwhile ( a != null ) { \n{ \naa = a . to . outs ; \nwhile ( aa != null ) { \nif ( aa . to == post ) { \nreturn Flags . REG_UEMPTYMATCH ; \n} \naa = aa . outchain ; \n} \n} \na = a . outchain ; \n} \n} \nreturn 0 ; \n} \n} \n"}
{"7827": "public class Nfa { \nvoid cleanup ( ) { \nState s ; \nState nexts ; \nint n ; \nmarkreachable ( pre , null , pre ) ; \nmarkcanreach ( post , pre , post ) ; \n{ \ns = states ; \nwhile ( s != null ) { \nnexts = s . next ; \nif ( s . tmp != post && 0 == s . flag ) { \ndropstate ( s ) ; \n} \ns = nexts ; \n} \n} \nassert post . nins == 0 || post . tmp == post ; \ncleartraverse ( pre ) ; \nassert post . nins == 0 || post . tmp == null ; \nn = 0 ; \n{ \ns = states ; \nwhile ( s != null ) { \ns . no = n ++ ; \ns = s . next ; \n} \n} \nnstates = n ; \n} \n} \n"}
{"7828": "public class Nfa { \nvoid markreachable ( State s , State okay , State mark ) { \nArc a ; \nif ( s . tmp != okay ) { \nreturn ; \n} \ns . tmp = mark ; \n{ \na = s . outs ; \nwhile ( a != null ) { \nmarkreachable ( a . to , okay , mark ) ; \na = a . outchain ; \n} \n} \n} \n} \n"}
{"7829": "public class Nfa { \nvoid markcanreach ( State s , State okay , State mark ) { \nArc a ; \nif ( s . tmp != okay ) { \nreturn ; \n} \ns . tmp = mark ; \n{ \na = s . ins ; \nwhile ( a != null ) { \nmarkcanreach ( a . from , okay , mark ) ; \na = a . inchain ; \n} \n} \n} \n} \n"}
{"7830": "public class Nfa { \nvoid fixempties ( ) { \nState s ; \nState nexts ; \nArc a ; \nArc nexta ; \nboolean progress ; \ndo { \nprogress = false ; \n{ \ns = states ; \nwhile ( s != null ) { \nnexts = s . next ; \n{ \na = s . outs ; \nwhile ( a != null ) { \nnexta = a . outchain ; \nif ( a . type == Compiler . EMPTY && unempty ( a ) ) { \nprogress = true ; \n} \nassert nexta == null || s . no != State . FREESTATE ; \na = nexta ; \n} \n} \ns = nexts ; \n} \n} \nif ( progress ) { \ndumpnfa ( ) ; \n} \n} \nwhile ( progress ) ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \n{ \nint i = 1 ; \nwhile ( i < stack . length ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { \nif ( checkClassLoader ( tmp ) ) { \nif ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) break ; \n} \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7880": "public class JSPContextFinder { \nprivate boolean checkClassLoader ( ClassLoader classloader ) { \nif ( classloader == null || classloader == getParent ( ) ) return false ; \n{ \nClassLoader parent = classloader . getParent ( ) ; \nwhile ( parent != null ) { \nif ( parent == this ) return false ; \nparent = parent . getParent ( ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( pos < 0 || pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nIndexDecoder index ; \n{ \nint i = 0 ; \nwhile ( ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) break ; \n++ i ; \n} \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert info . uncompressedSize > 0 ; \nassert pos >= info . uncompressedOffset ; \nassert pos < info . uncompressedOffset + info . uncompressedSize ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \n-- optPrev ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; \nelse opts [ optCur ] . state . updateLiteral ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nint back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nif ( back < REPS ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \n{ \nrep = 1 ; \nwhile ( rep <= back ) { \nopts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \n++ rep ; \n} \n} \n{ \nwhile ( rep < REPS ) { \nopts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n++ rep ; \n} \n} \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nint startLen = MATCH_LEN_MIN ; \nint lenLimit = Math . min ( avail , niceLen ) ; \n{ \nint rep = 0 ; \nwhile ( rep < REPS ) { \nint len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( len < MATCH_LEN_MIN ) { \n++ rep ; \ncontinue ; \n} \nwhile ( optEnd < optCur + len ) opts [ ++ optEnd ] . reset ( ) ; \nint longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \n{ \nint i = len ; \nwhile ( i >= MATCH_LEN_MIN ) { \nint price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( price < opts [ optCur + i ] . price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n-- i ; \n} \n} \nif ( rep == 0 ) startLen = len + 1 ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nint price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nprice += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n++ rep ; \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nwhile ( matches . len [ matches . count ] < avail ) ++ matches . count ; \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) return ; \nwhile ( optEnd < optCur + matches . len [ matches . count - 1 ] ) opts [ ++ optEnd ] . reset ( ) ; \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nwhile ( startLen > matches . len [ match ] ) ++ match ; \n{ \nint len = startLen ; \nwhile ( ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) { \n++ len ; \ncontinue ; \n} \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( ++ match == matches . count ) break ; \n++ len ; \n} \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \n{ \nint i = 0 ; \nwhile ( ( files != null ) && i < files . length ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \ni ++ ; \n} \n} \n} \n} \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nskip : { \nret = mark ( ) ; \nch = nextChar ( ) ; \nwhile ( ch != - 1 ) { \nif ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \n{ \nint i = 1 ; \nwhile ( i < limlen ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse { \nreset ( restart ) ; \n{ \ni ++ ; \ncontinue skip ; \n} \n} \ni ++ ; \n} \n} \nreturn ret ; \n} \nch = nextChar ( ) ; \nret = mark ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : { \nret = mark ( ) ; \nch = nextChar ( ) ; \nwhile ( ch != - 1 ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \n{ \nint i = 1 ; \nwhile ( i < limlen ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse { \ni ++ ; \ncontinue skip ; \n} \ni ++ ; \n} \n} \nreturn ret ; \n} \nch = nextChar ( ) ; \nprev = ch ; \nret = mark ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) { \nreturn \"\" ; \n} \nint ch = peekChar ( ) ; \nif ( quoted ) { \nif ( ch == '\"' || ch == '\\'' ) { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \n{ \nch = nextChar ( ) ; \nwhile ( ch != - 1 && ch != endQuote ) { \nif ( ch == '\\\\' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \nch = nextChar ( ) ; \n} \n} \nif ( ch == - 1 ) { \nerr . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \n} \nelse { \nerr . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \n} \n} \nelse { \nif ( ! isDelimiter ( ) ) { \ndo { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) { \nif ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \n} \n} \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nelse { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \n{ \nint i = 0 ; \nwhile ( i < CACHED_SCHEMA_RESOURCE_PATHS . length ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nelse { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \n{ \nint i = 0 ; \nwhile ( i < CACHED_DTD_RESOURCE_PATHS . length ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \ni ++ ; \n} \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \n{ \nint i = 0 ; \nwhile ( i < n ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) { \ni ++ ; \ncontinue ; \n} \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; \n} \n} \nelse { \nTreeNode treeChild = convert ( treeNode , child ) ; \n} \ni ++ ; \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \n{ \nint i = 0 ; \nwhile ( i < theFiles . length ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \ni ++ ; \n} \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8007": "public class LZEncoder { \npublic boolean verifyMatches ( Matches matches ) { \nint lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; \n{ \nint i = 0 ; \nwhile ( i < matches . count ) { \nif ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return false ; \n++ i ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8025": "public class Generator { \nprivate void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { \nclass TagHandlerPoolVisitor extends Node . Visitor { \nprivate Set < String > names = new HashSet < String > ( ) ; \nTagHandlerPoolVisitor ( Set < String > v ) { \nnames = v ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! n . implementsSimpleTag ( ) ) { \nString name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; \nn . setTagHandlerPoolName ( name ) ; \nif ( ! names . contains ( name ) ) { \nnames . add ( name ) ; \n} \n} \nvisitBody ( n ) ; \n} \nprivate String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { \nString poolName = null ; \npoolName = \"_jspx_tagPool_\" + prefix + \"_\" + shortName ; \nif ( attrs != null ) { \nString [ ] attrNames = new String [ attrs . getLength ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < attrNames . length ) { \nattrNames [ i ] = attrs . getQName ( i ) ; \ni ++ ; \n} \n} \nArrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < attrNames . length ) { \npoolName = poolName + \"_\" + attrNames [ i ] ; \ni ++ ; \n} \n} \n} \nif ( hasEmptyBody ) { \npoolName = poolName + \"_nobody\" ; \n} \nreturn JspUtil . makeXmlJavaIdentifier ( poolName ) ; \n} \n} \npage . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; \n} \n} \n"}
{"8027": "public class Generator { \nprivate void genCommonPostamble ( ) { \n{ \nint i = 0 ; \nwhile ( i < methodsBuffered . size ( ) ) { \nGenBuffer methodBuffer = methodsBuffered . get ( i ) ; \nmethodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( methodBuffer . toString ( ) ) ; \ni ++ ; \n} \n} \nif ( fragmentHelperClass . isUsed ( ) ) { \nfragmentHelperClass . generatePostamble ( ) ; \nfragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( fragmentHelperClass . toString ( ) ) ; \n} \nif ( arrayBuffer != null ) { \nout . printMultiLn ( arrayBuffer . toString ( ) ) ; \n} \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < attrInfos . length ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \ni ++ ; \n} \n} \nout . println ( ) ; \n{ \nint i = 0 ; \nwhile ( i < attrInfos . length ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \n{ \nIterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) { \ncontinue ; \n} \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \n{ \nint i = 0 ; \nwhile ( i < errors . length ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \ni ++ ; \n} \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) { \nint i = 0 ; \nwhile ( i < chars . length ) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) writer . print ( chars [ i ++ ] ) ; \n} \n} \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < s . length ( ) ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) { \nsb . append ( \"&lt;\" ) ; \n} \nelse if ( c == '>' ) { \nsb . append ( \"&gt;\" ) ; \n} \nelse if ( c == '\\'' ) { \nsb . append ( \"&apos;\" ) ; \n} \nelse if ( c == '&' ) { \nsb . append ( \"&amp;\" ) ; \n} \nelse if ( c == '\"' ) { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( c ) ; \n} \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8047": "public class JspUtil { \npublic static final String makeJavaPackage ( String path ) { \nString classNameComponents [ ] = split ( path , \"/\" ) ; \nStringBuilder legalClassNames = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < classNameComponents . length ) { \nlegalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; \nif ( i < classNameComponents . length - 1 ) { \nlegalClassNames . append ( '.' ) ; \n} \ni ++ ; \n} \n} \nreturn legalClassNames . toString ( ) ; \n} \n} \n"}
{"8048": "public class JspUtil { \nprivate static final String [ ] split ( String path , String pat ) { \nArrayList < String > comps = new ArrayList < String > ( ) ; \nint pos = path . indexOf ( pat ) ; \nint start = 0 ; \nwhile ( pos >= 0 ) { \nif ( pos > start ) { \nString comp = path . substring ( start , pos ) ; \ncomps . add ( comp ) ; \n} \nstart = pos + pat . length ( ) ; \npos = path . indexOf ( pat , start ) ; \n} \nif ( start < path . length ( ) ) { \ncomps . add ( path . substring ( start ) ) ; \n} \nString [ ] result = new String [ comps . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < comps . size ( ) ) { \nresult [ i ] = comps . get ( i ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < identifier . length ( ) ) { \nchar ch = identifier . charAt ( i ) ; \nif ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) { \nmodifiedIdentifier . append ( ch ) ; \n} \nelse if ( ch == '.' ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nelse { \nmodifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \ni ++ ; \n} \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8084": "public class OutputFormatter { \npublic static int [ ] computeMaximums ( String [ ] headers , OutputFormatter ... outputs ) { \nint [ ] max = new int [ headers . length ] ; \n{ \nint i = 0 ; \nwhile ( i < headers . length ) { \nmax [ i ] = headers [ i ] . length ( ) ; \ni ++ ; \n} \n} \nfor ( OutputFormatter output : outputs ) { \nmax [ 0 ] = Math . max ( output . host . length ( ) , max [ 0 ] ) ; \n{ \nint i = 1 ; \nwhile ( i < headers . length ) { \nmax [ i ] = Math . max ( output . results [ i - 1 ] . length ( ) , max [ i ] ) ; \ni ++ ; \n} \n} \n} \nreturn max ; \n} \n} \n"}
{"8085": "public class OutputFormatter { \npublic static String formatHeader ( int [ ] maximums , String [ ] headers ) { \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < headers . length ) { \nsb = sb . append ( formatIn ( headers [ i ] , maximums [ i ] , false ) ) . append ( GAP ) ; \ni ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8086": "public class OutputFormatter { \npublic static String [ ] format ( int [ ] maximums , OutputFormatter ... outputs ) { \nString [ ] formattedStrings = new String [ outputs . length ] ; \nint pos = 0 ; \nfor ( OutputFormatter output : outputs ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb = sb . append ( formatIn ( output . host , maximums [ 0 ] , false ) ) ; \n{ \nint i = 0 ; \nwhile ( i < output . results . length ) { \nsb = sb . append ( GAP ) . append ( formatIn ( output . results [ i ] , maximums [ i + 1 ] , true ) ) ; \ni ++ ; \n} \n} \nformattedStrings [ pos ++ ] = sb . toString ( ) ; \n} \nreturn formattedStrings ; \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) return false ; \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) start ++ ; \nboolean fraction = false ; \n{ \nint i = start ; \nwhile ( i < value . length ( ) ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \n{ \ni ++ ; \ncontinue ; \n} \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nif ( ! Character . isDigit ( c ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8205": "public class CsvRecord { \npublic void dump ( Writer writer , String lineSeparator ) throws IOException { \n{ \nint i = 0 ; \nwhile ( i < this . getRecordLenth ( ) ) { \nStringBuilder txt = new StringBuilder ( ) ; \ntry ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { \nfor ( String line : IOUtils . readLines ( reader ) ) { \nif ( txt . length ( ) > 0 ) txt . append ( lineSeparator ) ; \ntxt . append ( line ) ; \n} \n} \nwriter . write ( i + \":\" + txt . toString ( ) ) ; \nwriter . write ( System . lineSeparator ( ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"8207": "public class CsvRecord { \nprotected Iterable < String > print ( ) { \nfinal int length = this . getRecordLenth ( ) ; \nList < String > row = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nrow . add ( this . get ( i ) ) ; \ni ++ ; \n} \n} \nreturn row ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \n{ \nint i = 1 ; \nwhile ( i < curArg . length ( ) ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \ni ++ ; \n} \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \n{ \nwhile ( position < argv . length ) { \notherArgs . addElement ( argv [ position ] ) ; \n++ position ; \n} \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8367": "public class SingletonLoader { \npublic Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { \nObject ret = null ; \nMethod [ ] methods = c . getDeclaredMethods ( ) ; \nMethod m ; \nint modifiers ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nm = methods [ i ] ; \nmodifiers = m . getModifiers ( ) ; \nif ( ( modifiers & Modifier . STATIC ) != 0 ) { \nif ( ( modifiers & Modifier . PUBLIC ) != 0 ) { \nif ( m . getParameterTypes ( ) . length == 0 ) { \nif ( m . getReturnType ( ) == c ) { \nif ( m . getName ( ) . toLowerCase ( ) . indexOf ( \"instance\" ) != - 1 ) { \ntry { \nret = m . invoke ( null , dummyParameters ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalAccessException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n} \n} \ni ++ ; \n} \n} \nif ( ret == null ) { \nConstructor [ ] constructors = c . getConstructors ( ) ; \nConstructor con = null ; \n{ \nint i = 0 ; \nwhile ( i < constructors . length ) { \ncon = constructors [ i ] ; \nif ( con . getParameterTypes ( ) . length == 0 ) { \nmodifiers = con . getModifiers ( ) ; \ntry { \nif ( ( modifiers & Modifier . PUBLIC ) == 0 ) { \ncon . setAccessible ( true ) ; \n} \nret = c . newInstance ( ) ; \n} \ncatch ( SecurityException se ) { \n} \n} \ni ++ ; \n} \n} \n} \nif ( ret == null ) { \nSystem . err . println ( \"Unable to instantiate: \" + c . getName ( ) + \": no singleton method, no public default constructor.\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nint lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) { \nthrow new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \n} \nif ( targetMethod == null ) { \nthrow new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \n} \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \n{ \nint i = 0 ; \nwhile ( i < arguments . length ) { \nargTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \n++ i ; \n} \n} \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) { \nthrow ex ; \n} \n} \n} \n} \n"}
{"8375": "public class DomUtils { \npublic static Element getChildElementByTagName ( Element ele , String childEleName ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nAssert . notNull ( childEleName , \"Element name must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nl . getLength ( ) ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) { \nreturn ( Element ) node ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8377": "public class DomUtils { \npublic static List < Element > getChildElements ( Element ele ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nList < Element > childEles = new ArrayList < Element > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nl . getLength ( ) ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element ) { \nchildEles . add ( ( Element ) node ) ; \n} \ni ++ ; \n} \n} \nreturn childEles ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( this . values != null ) { \nlayouts = new BoringLayout [ this . values . length ] ; \n{ \nint i = 0 ; \nwhile ( i < layouts . length ) { \nlayouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \ni ++ ; \n} \n} \n} \nelse { \nlayouts = new BoringLayout [ 0 ] ; \n} \nif ( getWidth ( ) > 0 ) { \nstartMarqueeIfNeeded ( ) ; \n} \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \n} \n} \n"}
{"8454": "public class Args { \npublic static List < String > parse ( Object target , String [ ] args ) { \nList < String > arguments = new ArrayList < String > ( ) ; \narguments . addAll ( Arrays . asList ( args ) ) ; \nClass < ? > clazz ; \nif ( target instanceof Class ) { \nclazz = ( Class ) target ; \n} \nelse { \nclazz = target . getClass ( ) ; \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \nprocessProperty ( target , pd , arguments ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n{ \nClass < ? > currentClazz = clazz ; \nwhile ( currentClazz != null ) { \nfor ( Field field : currentClazz . getDeclaredFields ( ) ) { \nprocessField ( target , field , arguments ) ; \n} \ncurrentClazz = currentClazz . getSuperclass ( ) ; \n} \n} \nfor ( String argument : arguments ) { \nif ( argument . startsWith ( \"-\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid argument: \" + argument ) ; \n} \n} \nreturn arguments ; \n} \n} \n"}
{"8455": "public class Args { \npublic static void usage ( PrintStream errStream , Object target ) { \nClass < ? > clazz ; \nif ( target instanceof Class ) { \nclazz = ( Class ) target ; \n} \nelse { \nclazz = target . getClass ( ) ; \n} \nerrStream . println ( \"Usage: \" + clazz . getName ( ) ) ; \n{ \nClass < ? > currentClazz = clazz ; \nwhile ( currentClazz != null ) { \nfor ( Field field : currentClazz . getDeclaredFields ( ) ) { \nfieldUsage ( errStream , target , field ) ; \n} \ncurrentClazz = currentClazz . getSuperclass ( ) ; \n} \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \npropertyUsage ( errStream , target , pd ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal int contextValuesLength = values == null ? 0 : values . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < keys . size ( ) ) { \nfinal String key = keys . get ( i ) ; \nif ( i >= contextValuesLength ) { \njsonGenerator . writeObjectField ( key , null ) ; \n} \nelse { \nfinal Object value = values . get ( i ) ; \nif ( isSimpleType ( value ) ) { \njsonGenerator . writeObjectField ( key , value ) ; \n} \nelse { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \n} \n++ i ; \n} \n} \n} \n} \n} \n"}
{"8485": "public class StenoSerializationHelper { \npublic static void serializeThrowable ( final IThrowableProxy throwableProxy , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper ) throws IOException { \njsonGenerator . writeStringField ( \"type\" , throwableProxy . getClassName ( ) ) ; \njsonGenerator . writeStringField ( \"message\" , throwableProxy . getMessage ( ) ) ; \njsonGenerator . writeArrayFieldStart ( \"backtrace\" ) ; \nfor ( final StackTraceElementProxy ste : throwableProxy . getStackTraceElementProxyArray ( ) ) { \njsonGenerator . writeString ( ste . toString ( ) ) ; \n} \njsonGenerator . writeEndArray ( ) ; \njsonGenerator . writeObjectFieldStart ( \"data\" ) ; \nif ( throwableProxy instanceof ThrowableProxy ) { \nfinal JsonNode jsonNode = objectMapper . valueToTree ( ( ( ThrowableProxy ) throwableProxy ) . getThrowable ( ) ) ; \n{ \nfinal Iterator < Map . Entry < String , JsonNode > > iterator = jsonNode . fields ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nfinal Map . Entry < String , JsonNode > field = iterator . next ( ) ; \njsonGenerator . writeFieldName ( field . getKey ( ) ) ; \nobjectMapper . writeValue ( jsonGenerator , field . getValue ( ) ) ; \n} \n} \n} \nif ( throwableProxy . getSuppressed ( ) != null && throwableProxy . getSuppressed ( ) . length > 0 ) { \njsonGenerator . writeArrayFieldStart ( \"suppressed\" ) ; \nfor ( final IThrowableProxy suppressed : throwableProxy . getSuppressed ( ) ) { \njsonGenerator . writeStartObject ( ) ; \nserializeThrowable ( suppressed , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndArray ( ) ; \n} \nif ( throwableProxy . getCause ( ) != null ) { \njsonGenerator . writeObjectFieldStart ( \"cause\" ) ; \nserializeThrowable ( throwableProxy . getCause ( ) , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndObject ( ) ; \n} \n} \n"}
{"8487": "public class AbstractStenoCallerConverter { \nprotected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { \nfinal StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; \nif ( callerData != null ) { \n{ \nint i = 0 ; \nwhile ( i < callerData . length ) { \nfinal String callerClassName = callerData [ i ] . getClassName ( ) ; \nif ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) { \nreturn callerData [ i ] ; \n} \n++ i ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8522": "public class ShiftFormulaUtility { \npublic static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { \nList < Ptg > newPtgList = new ArrayList < > ( ) ; \nObject ptg ; \n{ \nint k = 0 ; \nwhile ( k < ptgs . length ) { \nptg = ptgs [ k ] ; \nnewPtgList . addAll ( Arrays . asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; \n++ k ; \n} \n} \nreturn newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \n{ \nint i = 0 ; \nwhile ( i < rowList . size ( ) ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nint originFirstRow = areaPtg . getFirstRow ( ) ; \nint originLastRow = areaPtg . getLastRow ( ) ; \nint unitSize = 2 ; \n{ \nint i = 0 ; \nwhile ( i < rowList . size ( ) ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nint shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nif ( i < ( rowList . size ( ) - 1 ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \n{ \nint i = 0 ; \nwhile ( i < wb . getNumberOfSheets ( ) ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { \nfor ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < ( parts . length - 1 ) ) { \nif ( i == 0 ) { \nfname . append ( parts [ i ] ) ; \n} \nelse { \nfname . append ( \":\" ) . append ( parts [ i ] ) ; \n} \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \n{ \nint i = startRowIndex ; \nwhile ( i <= sheet . getLastRowNum ( ) ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { \nint sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nint sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( sufindex > 0 ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nint increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) { \nchangeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \n} \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \nelse { \nreturn ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"8571": "public class ConfigurationUtility { \npublic static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { \nStringBuilder fullName = new StringBuilder ( ) ; \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \n{ \nint i = 1 ; \nwhile ( i < parts . length - 1 ) { \nString part = parts [ i ] ; \nif ( fullName . length ( ) == 0 ) { \nfullName . append ( part ) ; \n} \nelse { \nfullName . append ( \":\" + part ) ; \n} \nif ( fullName . length ( ) > 0 ) { \nConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; \nif ( rangeAttrs != null ) { \nrowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; \n} \n} \ni ++ ; \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \n{ \nint i = 0 ; \nwhile ( i < sourceConfigRange . getCommandList ( ) . size ( ) ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \n{ \nint i = 0 ; \nwhile ( i < sourceConfigRange . getCommandList ( ) . size ( ) ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nint rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8578": "public class ConfigurationUtility { \npublic static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nMap < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numRegions ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \ncellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; \n} \ni ++ ; \n} \n} \nreturn cellRangeMap ; \n} \n} \n"}
{"8579": "public class ConfigurationUtility { \npublic static List < String > skippedRegionCells ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nList < String > skipCellList = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < numRegions ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \naddSkipCellToListInTheRegion ( skipCellList , caddress ) ; \n} \ni ++ ; \n} \n} \nreturn skipCellList ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \n{ \nint col = caddress . getFirstColumn ( ) ; \nwhile ( col <= caddress . getLastColumn ( ) ) { \n{ \nint row = caddress . getFirstRow ( ) ; \nwhile ( row <= caddress . getLastRow ( ) ) { \nif ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { \n{ \nrow ++ ; \ncontinue ; \n} \n} \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \nrow ++ ; \n} \n} \ncol ++ ; \n} \n} \n} \n} \n"}
{"8583": "public class ConfigurationHandler { \npublic final Map < String , SheetConfiguration > buildConfiguration ( ) { \nMap < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; \nList < String > sheetNames = new ArrayList < > ( ) ; \nString sname ; \n{ \nint i = 0 ; \nwhile ( i < parent . getWb ( ) . getNumberOfSheets ( ) ) { \nsname = parent . getWb ( ) . getSheetName ( i ) ; \nif ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { \nsheetNames . add ( sname ) ; \n} \ni ++ ; \n} \n} \nfor ( String sheetName : sheetNames ) { \nSheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; \nConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; \nbuildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; \n} \nreturn sheetConfigMap ; \n} \n} \n"}
{"8586": "public class ConfigurationHandler { \nprivate int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { \nint lastCol = sheetRightCol ; \nint col ; \n{ \ncol = lastCol ; \nwhile ( col >= stoppoint ) { \nCell cell = row . getCell ( col ) ; \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { \nbreak ; \n} \ncol -- ; \n} \n} \nreturn col ; \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nint matchIndex = - 1 ; \nConfigRange matchRange = null ; \n{ \nint j = 0 ; \nwhile ( j < commandList . size ( ) ) { \nif ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \nj ++ ; \n} \n} \nif ( matchIndex >= 0 ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \n} \n} \n"}
{"8606": "public class CommandUtility { \nprivate static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { \nList < String > list = new ArrayList < > ( ) ; \n{ \nint rowIndex = startRow ; \nwhile ( rowIndex <= endRow ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; \nif ( ! list . contains ( fullName ) ) { \nlist . add ( fullName ) ; \n} \nrowIndex ++ ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8611": "public class CommandUtility { \npublic static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \n{ \nint i = 0 ; \nwhile ( i < sourceConfigRange . getCommandList ( ) . size ( ) ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nindexMap . put ( command . getCommandName ( ) , command ) ; \ncommand . getConfigRange ( ) . indexCommandRange ( indexMap ) ; \ni ++ ; \n} \n} \n} \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nint srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nint srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { \ncopyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \n} \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( index > 0 ) { \nCellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \n} \n{ \nint rowIndex = srcStartRow ; \nwhile ( rowIndex <= srcEndRow ) { \nif ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { \nunitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \nrowIndex ++ ; \n} \n} \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \n{ \nint irow = rowIndexStart ; \nwhile ( irow <= rowIndexEnd ) { \nremoveCachedCellForRow ( sheet , irow , cachedMap ) ; \nirow ++ ; \n} \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { \nreturn ; \n} \nint lastRowNum = sheet . getLastRowNum ( ) ; \nif ( rowIndexEnd < lastRowNum ) { \nsheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \n} \nif ( rowIndexEnd == lastRowNum ) { \n{ \nint i = rowIndexEnd ; \nwhile ( i >= rowIndexStart ) { \nremoveSingleRowInSheet ( sheet , rowIndexStart ) ; \ni -- ; \n} \n} \n} \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { \nreturn ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \n{ \nint rowIndex = rowIndexEnd ; \nwhile ( rowIndex >= rowIndexStart ) { \nbodyRows . remove ( rowIndex - top ) ; \nrowIndex -- ; \n} \n} \n{ \nint irow = rowIndexStart - top ; \nwhile ( irow < bodyRows . size ( ) ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \nirow ++ ; \n} \n} \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nint length = srcRowEnd - srcRowStart + 1 ; \nif ( length <= 0 ) { \nreturn ; \n} \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \ncopySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \ni ++ ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < srcSheet . getNumMergedRegions ( ) ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { \nint targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nint targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"8636": "public class CellUtility { \nprivate static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { \nRow newRow = destSheet . getRow ( destinationRowNum ) ; \nRow sourceRow = srcSheet . getRow ( sourceRowNum ) ; \nif ( newRow == null ) { \nnewRow = destSheet . createRow ( destinationRowNum ) ; \n} \nnewRow . setHeight ( sourceRow . getHeight ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < sourceRow . getLastCellNum ( ) ) { \ncopyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; \ni ++ ; \n} \n} \nif ( setHiddenColumn ) { \nConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8655": "public class TieWebSheetBeanCurrent { \npublic final String getCurrentDataContextName ( ) { \nif ( currentDataContextName == null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nList < String > list = this . getCurrentDataContextNameList ( ) ; \n{ \nint i = 0 ; \nwhile ( i < list . size ( ) ) { \nif ( i > 0 ) { \nsb . append ( \":\" + list . get ( i ) ) ; \n} \nelse { \nsb . append ( list . get ( i ) ) ; \n} \ni ++ ; \n} \n} \nthis . setCurrentDataContextName ( sb . toString ( ) ) ; \n} \nreturn currentDataContextName ; \n} \n} \n"}
{"8666": "public class ChartUtility { \npublic static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { \nMap < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; \nMap < String , String > positionMap = charsData . getChartPositionMap ( ) ; \nanchortMap . clear ( ) ; \npositionMap . clear ( ) ; \n{ \nint i = 0 ; \nwhile ( i < wb . getNumberOfSheets ( ) ) { \ninitXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"8667": "public class ChartUtility { \nprivate static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nCTDrawing ctDrawing = drawing . getCTDrawing ( ) ; \nif ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { \nreturn ; \n} \nList < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; \n{ \nint j = 0 ; \nwhile ( j < alist . size ( ) ) { \nCTTwoCellAnchor ctanchor = alist . get ( j ) ; \nString singleChartId = getAnchorAssociateChartId ( ctanchor ) ; \nif ( singleChartId != null ) { \nString chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; \nint dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; \nint dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; \nint dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; \nint dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; \nint col1 = ctanchor . getFrom ( ) . getCol ( ) ; \nint row1 = ctanchor . getFrom ( ) . getRow ( ) ; \nint col2 = ctanchor . getTo ( ) . getCol ( ) ; \nint row2 = ctanchor . getTo ( ) . getRow ( ) ; \nanchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; \npositionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; \n} \nj ++ ; \n} \n} \n} \n} \n"}
{"8668": "public class ChartUtility { \nprivate static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { \nif ( ctanchor . getGraphicFrame ( ) == null ) { \nreturn null ; \n} \nNode parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; \nNodeList childNodes = parentNode . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < childNodes . getLength ( ) ) { \nNode childNode = childNodes . item ( i ) ; \nif ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { \nString rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; \nif ( rId != null ) { \nreturn rId ; \n} \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8669": "public class ChartUtility { \nprivate static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { \n{ \nint j = 0 ; \nwhile ( j < attrs . getLength ( ) ) { \nAttr attribute = ( Attr ) attrs . item ( j ) ; \nif ( \"r:id\" . equalsIgnoreCase ( attribute . getName ( ) ) ) { \nreturn attribute . getValue ( ) ; \n} \nj ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) { \nreturn ; \n} \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nint listSize = list . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < parts . length ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ( ! stopSkip ) && ( i < listSize ) ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) { \nskip = true ; \n} \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \ni ++ ; \n} \n} \nif ( stopSkip ) { \nparent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \n} \nreturn ; \n} \n} \n"}
{"8685": "public class ChartData { \npublic final void buildCategoryList ( final CTAxDataSource ctAxDs ) { \nList < ParsedCell > cells = new ArrayList < > ( ) ; \ntry { \nString fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \n{ \nint row = region . getFirstRow ( ) ; \nwhile ( row <= region . getLastRow ( ) ) { \n{ \nint col = region . getFirstColumn ( ) ; \nwhile ( col <= region . getLastColumn ( ) ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \ncol ++ ; \n} \n} \nrow ++ ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; \n} \nthis . setCategoryList ( cells ) ; \n} \n} \n"}
{"8686": "public class ChartData { \n@ SuppressWarnings ( \"rawtypes\" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < ChartSeries > lseriesList = new ArrayList < > ( ) ; \ntry { \n{ \nint index = 0 ; \nwhile ( index < bsers . size ( ) ) { \nObject ctObjSer = bsers . get ( index ) ; \nChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; \nlseriesList . add ( ctSer ) ; \nindex ++ ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildSerialList\" , ex ) ; \n} \nthis . setSeriesList ( lseriesList ) ; \n} \n} \n"}
{"8687": "public class ChartData { \nprivate ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { \nChartSeries ctSer = new ChartSeries ( ) ; \nctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; \nctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; \nList < ParsedCell > cells = new ArrayList < > ( ) ; \nString fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \n{ \nint row = region . getFirstRow ( ) ; \nwhile ( row <= region . getLastRow ( ) ) { \n{ \nint col = region . getFirstColumn ( ) ; \nwhile ( col <= region . getLastColumn ( ) ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \ncol ++ ; \n} \n} \nrow ++ ; \n} \n} \nctSer . setValueList ( cells ) ; \nctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; \nreturn ctSer ; \n} \n} \n"}
{"8688": "public class ChartData { \nprivate List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < XColor > colors = new ArrayList < > ( ) ; \nif ( ( dptList != null ) && ( cells != null ) ) { \n{ \nint index = 0 ; \nwhile ( index < cells . size ( ) ) { \nCTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; \nCTShapeProperties ctSpPr = null ; \nif ( dpt != null ) { \nctSpPr = dpt . getSpPr ( ) ; \n} \ncolors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; \nindex ++ ; \n} \n} \n} \nreturn colors ; \n} \n} \n"}
{"8692": "public class PicturesUtility { \nprivate static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { \npicMap . clear ( ) ; \nList < XSSFPictureData > pictures = wb . getAllPictures ( ) ; \nif ( pictures . isEmpty ( ) ) { \nreturn ; \n} \n{ \nint i = 0 ; \nwhile ( i < wb . getNumberOfSheets ( ) ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nfor ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { \ntry { \nindexPictureInMap ( picMap , sheet , dr ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \ni ++ ; \n} \n} \nreturn ; \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) { \nreturn null ; \n} \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nint left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nint right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ( cell != null ) && ( fcell != null ) ) { \n{ \nint col = cell . getColumnIndex ( ) ; \nwhile ( col < cell . getColumnIndex ( ) + fcell . getColspan ( ) ) { \ncellWidth += sheet1 . getColumnWidthInPixels ( col ) ; \ncol ++ ; \n} \n} \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \n{ \nint rowIndex = cell . getRowIndex ( ) ; \nwhile ( rowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ) { \ncellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \nrowIndex ++ ; \n} \n} \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nelse { \n{ \nshort col = anchor . getCol1 ( ) ; \nwhile ( col < anchor . getCol2 ( ) ) { \npicWidth += sheet1 . getColumnWidthInPixels ( col ) ; \ncol ++ ; \n} \n} \n{ \nint rowindex = anchor . getRow1 ( ) ; \nwhile ( rowindex < anchor . getRow2 ( ) ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) { \npicHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \nrowindex ++ ; \n} \n} \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8708": "public class CellStyleUtility { \npublic static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { \nint totalHeight = additionalHeight ; \n{ \nint i = firstRow ; \nwhile ( i <= lastRow ) { \ntotalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; \ni ++ ; \n} \n} \nreturn totalHeight ; \n} \n} \n"}
{"8716": "public class FacesUtility { \npublic static String strJoin ( final short [ ] aArr , final String sSep ) { \nStringBuilder sbStr = new StringBuilder ( ) ; \n{ \nint i = 0 , il = aArr . length ; \nwhile ( i < il ) { \nif ( i > 0 ) { \nsbStr . append ( sSep ) ; \n} \nsbStr . append ( aArr [ i ] ) ; \ni ++ ; \n} \n} \nreturn sbStr . toString ( ) ; \n} \n} \n"}
{"8724": "public class FormCommand { \nprivate List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { \nList < Integer > watchList = new ArrayList < > ( ) ; \nConfigRange cRange = this . getConfigRange ( ) ; \nList < ConfigCommand > commandList = cRange . getCommandList ( ) ; \nif ( commandList . isEmpty ( ) ) { \nreturn watchList ; \n} \nint lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; \nif ( lastStaticRow < 0 ) { \nlastStaticRow = this . getTopRow ( ) ; \n} \nint sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; \n{ \nint i = this . getTopRow ( ) ; \nwhile ( i <= this . getLastRow ( ) ) { \nRow row = sheet . getRow ( i ) ; \nfor ( Cell cell : row ) { \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nbuildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; \n} \n} \ni ++ ; \n} \n} \nreturn watchList ; \n} \n} \n"}
{"8725": "public class FormCommand { \nprivate void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { \nString formula = cell . getCellFormula ( ) ; \nPtg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; \n{ \nint k = 0 ; \nwhile ( k < ptgs . length ) { \nObject ptg = ptgs [ k ] ; \nint areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( areaInt >= 0 ) { \naddToWatchList ( areaInt , lastStaticRow , watchList ) ; \n} \nk ++ ; \n} \n} \ncell . setCellType ( CellType . STRING ) ; \ncell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nint bracketNum = 0 ; \n{ \nint i = startPos ; \nwhile ( i < str . length ( ) ) { \nchar current = str . charAt ( i ) ; \nif ( current == TieConstants . EL_START_BRACKET ) { \nbracketNum ++ ; \n} \nelse if ( current == TieConstants . EL_END ) { \nbracketNum -- ; \nif ( bracketNum <= 0 ) { \nreturn i ; \n} \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) { \nsmap = new LinkedHashMap < > ( ) ; \n} \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) { \nsmap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < sAttr . selectLabels . length ) { \nsmap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \ni ++ ; \n} \n} \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \n} \n} \n"}
{"8741": "public class ParserUtility { \npublic static int findFirstNonCellNamePosition ( String input , int startPosition ) { \nchar c ; \n{ \nint i = startPosition ; \nwhile ( i < input . length ( ) ) { \nc = input . charAt ( i ) ; \nif ( c != '$' && ! Character . isLetterOrDigit ( c ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8744": "public class WebSheetUtility { \npublic static int convertColToInt ( final String col ) { \nString name = col . toUpperCase ( ) ; \nint number = 0 ; \nint pow = 1 ; \n{ \nint i = name . length ( ) - 1 ; \nwhile ( i >= 0 ) { \nnumber += ( name . charAt ( i ) - 'A' + 1 ) * pow ; \npow *= TieConstants . EXCEL_LETTER_NUMBERS ; \ni -- ; \n} \n} \nreturn number - 1 ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \n{ \ni = 0 ; \nwhile ( i < sLen ) { \nc = s . charAt ( i ) ; \nif ( c < '0' || c > '9' ) { \nif ( ! shouldContinue ( c , sPara ) ) { \nreturn false ; \n} \n} \nelse { \nif ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8765": "public class ValidationHandler { \npublic final boolean validateCurrentPage ( ) { \nboolean allpass = true ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \n{ \nint irow = 0 ; \nwhile ( irow < parent . getBodyRows ( ) . size ( ) ) { \nif ( ! validateRowInCurrentPage ( irow + top , false ) ) { \nallpass = false ; \n} \nirow ++ ; \n} \n} \nreturn allpass ; \n} \n} \n"}
{"8767": "public class ValidationHandler { \nprivate boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { \nboolean pass = true ; \nif ( sheetConfig == null ) { \nreturn pass ; \n} \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nList < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; \n{ \nint index = 0 ; \nwhile ( index < cellRow . size ( ) ) { \nFacesCell fcell = cellRow . get ( index ) ; \nif ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { \npass = false ; \n} \nindex ++ ; \n} \n} \nreturn pass ; \n} \n} \n"}
{"8768": "public class ValidationHandler { \nprivate void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { \nUIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; \nif ( s == null ) { \nreturn ; \n} \nDataTable webDataTable = ( DataTable ) s ; \nint first = webDataTable . getFirst ( ) ; \nint rowsToRender = webDataTable . getRowsToRender ( ) ; \nint rowCounts = webDataTable . getRowCount ( ) ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \n{ \nint i = first ; \nwhile ( i <= ( first + rowsToRender ) ) { \nif ( i < rowCounts ) { \nrefreshCachedCellsInRow ( tblName , top , left , i ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"8769": "public class ValidationHandler { \nprivate void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { \nFacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; \nint isize = dataRow . getCells ( ) . size ( ) ; \n{ \nint index = 0 ; \nwhile ( index < isize ) { \nFacesCell fcell = dataRow . getCells ( ) . get ( index ) ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; \nif ( poiCell != null ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; \n} \nindex ++ ; \n} \n} \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nint bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nint left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nint totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) { \nparent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \n} \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( top < 0 ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \n{ \nint i = top ; \nwhile ( i <= bottom ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \ni ++ ; \n} \n} \nparent . setShowLineNumber ( false ) ; \n} \n} \n} \n"}
{"8774": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { \nint firstCol = rangeBuildRef . getLeft ( ) ; \nint lastCol = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \n{ \nint i = firstCol ; \nwhile ( i <= lastCol ) { \nif ( ! sheet1 . isColumnHidden ( i ) ) { \nString style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; \n} \ni ++ ; \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8775": "public class WebSheetLoader { \nprivate void fillToMaxColumns ( final List < HeaderCell > headercells ) { \nif ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { \nint fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; \n{ \nint s = 0 ; \nwhile ( s < fills ) { \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; \ns ++ ; \n} \n} \n} \n} \n} \n"}
{"8778": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nint left = rangeBuildRef . getLeft ( ) ; \nint right = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nRow row = sheet1 . getRow ( currentRow ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \n{ \nint cindex = left ; \nwhile ( cindex <= right ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nint originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nheadercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; \n} \n} \ncindex ++ ; \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8783": "public class WebSheetLoader { \npublic void refreshData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \n{ \nint irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; \nwhile ( irow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ) { \nrefreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; \nirow ++ ; \n} \n} \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8786": "public class WebSheetLoader { \npublic final int findTabIndexWithName ( final String tabname ) { \n{ \nint i = 0 ; \nwhile ( i < parent . getTabs ( ) . size ( ) ) { \nif ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { \nreturn i ; \n} \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8792": "public class WebSheetLoader { \nprivate void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nclearCache ( ) ; \n{ \nint i = top ; \nwhile ( i <= bottom ) { \nparent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \ni ++ ; \n} \n} \nsheetConfig . setBodyPopulated ( true ) ; \nparent . getCurrent ( ) . setCurrentTopRow ( top ) ; \nparent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; \n} \n} \n"}
{"8793": "public class WebSheetLoader { \nprivate FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nFacesRow facesRow = new FacesRow ( rowIndex ) ; \nRow row = sheet1 . getRow ( rowIndex ) ; \nsetupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nList < FacesCell > bodycells = new ArrayList < > ( ) ; \n{ \nint cindex = left ; \nwhile ( cindex <= right ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nbodycells . add ( fcell ) ; \naddCache ( cell ) ; \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nelse { \nbodycells . add ( null ) ; \n} \ncindex ++ ; \n} \n} \nfacesRow . setCells ( bodycells ) ; \nreturn facesRow ; \n} \n} \n"}
{"8796": "public class WebSheetLoader { \nprivate void createDynamicColumns ( final String tabName ) { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nparent . getColumns ( ) . clear ( ) ; \n{ \nint i = left ; \nwhile ( i <= right ) { \nparent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"8798": "public class WebSheetLoader { \nprivate void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \n{ \nint irow = insertPosition ; \nwhile ( irow < ( insertPosition + length ) ) { \nparent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \nirow ++ ; \n} \n} \n{ \nint irow = insertPosition + length - top ; \nwhile ( irow < parent . getBodyRows ( ) . size ( ) ) { \nFacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; \nirow ++ ; \n} \n} \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nif ( partBoundary == null || partBoundary . length == 0 ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < parts . length ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \ni ++ ; \n} \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8831": "public class Part { \npublic static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"getLengthOfParts(Parts[])\" ) ; \n} \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nlong total = 0 ; \n{ \nint i = 0 ; \nwhile ( i < parts . length ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nfinal long l = parts [ i ] . length ( ) ; \nif ( l < 0 ) { \nreturn - 1 ; \n} \ntotal += l ; \ni ++ ; \n} \n} \ntotal += EXTRA_BYTES . length ; \ntotal += partBoundary . length ; \ntotal += EXTRA_BYTES . length ; \ntotal += CRLF_BYTES . length ; \nreturn total ; \n} \n} \n"}
{"8891": "public class MetricDataRequest { \nprotected List < MetricData > process ( JsonNode node ) { \nJSONArray dataArray = node . getArray ( ) ; \nList < MetricData > list = new LinkedList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < dataArray . length ( ) ) { \nJSONObject data = dataArray . getJSONObject ( i ) ; \nMetricData metricData = new MetricData ( data . getString ( \"frequency\" ) , data . getLong ( \"metricId\" ) , data . getString ( \"metricName\" ) , data . getString ( \"metricPath\" ) ) ; \nlist . add ( metricData ) ; \nJSONArray valueArray = data . getJSONArray ( \"metricValues\" ) ; \n{ \nint j = 0 ; \nwhile ( j < valueArray . length ( ) ) { \nJSONObject value = valueArray . getJSONObject ( j ) ; \nmetricData . metricValues . add ( new MetricValue ( value . getLong ( \"count\" ) , value . getLong ( \"value\" ) , value . getLong ( \"max\" ) , value . getLong ( \"min\" ) , value . getLong ( \"sum\" ) , value . getLong ( \"startTimeInMillis\" ) ) ) ; \nj ++ ; \n} \n} \ni ++ ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) { \nreturn ; \n} \nelse { \ntry { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < savedArray . length ( ) ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) { \ntimeSentMap . put ( instanceName , actualTimeSent ) ; \n} \ni ++ ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < savedArray . length ( ) ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \ni ++ ; \n} \n} \n} \ncatch ( JSONException je ) { \n} \n} \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nint regionSize = primaryDataSet . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = primaryDataSet . size ( ) ; \n} \nelse if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nint count = 0 ; \n{ \nIterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nif ( count == numEntries ) { \nbreak ; \n} \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nint regionSize = entries . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = entries . size ( ) ; \n} \nelse if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nint count = 0 ; \n{ \nIterator < ? > i = entries . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nif ( count == numEntries ) { \nbreak ; \n} \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nif ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \ni ++ ; \n} \n} \nstream . println ( \"]\" ) ; \n} \n} \n"}
{"8940": "public class TimeStampSeries { \ndouble [ ] getTimeValuesSinceIdx ( int idx ) { \nint resultSize = this . count - idx ; \ndouble [ ] result = new double [ resultSize ] ; \n{ \nint i = 0 ; \nwhile ( i < resultSize ) { \nresult [ i ] = getMilliTimeStamp ( idx + i ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nint typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \n{ \nint i = 0 ; \nwhile ( i < this . resourceTypeTable . length ) { \nif ( this . resourceTypeTable [ i ] != null ) { \nif ( this . resourceTypeTable [ i ] . close ( ) ) { \nthis . resourceTypeTable [ i ] = null ; \n} \nelse { \ntypeCount ++ ; \n} \n} \ni ++ ; \n} \n} \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount ++ ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nint instCount = 0 ; \n{ \nint i = 0 ; \nwhile ( i < this . resourceInstTable . length ) { \nif ( this . resourceInstTable [ i ] != null ) { \nif ( this . resourceInstTable [ i ] . close ( ) ) { \nthis . resourceInstTable [ i ] = null ; \n} \nelse { \ninstCount ++ ; \n} \n} \ni ++ ; \n} \n} \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount ++ ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \n{ \nint i = 0 ; \nwhile ( i < addresses . length ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \ni ++ ; \n} \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"9005": "public class ColumnVector { \nprotected void set ( final float values [ ] ) { \nthis . m_nRows = values . length ; \nthis . m_nCols = 1 ; \nthis . m_aValues = new float [ m_nRows ] [ 1 ] ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \nthis . m_aValues [ r ] [ 0 ] = values [ r ] ; \n++ r ; \n} \n} \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \n{ \nint i = 0 ; \nwhile ( i < m_n ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n++ i ; \n} \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \n{ \nint i = 0 ; \nwhile ( i < m_n ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \n{ \nint j = 0 ; \nwhile ( j < length ) { \nSystem . out . print ( \"*\" ) ; \n++ j ; \n} \n} \nSystem . out . println ( ) ; \n++ i ; \n} \n} \n} \n} \n"}
{"9024": "public class Matrix { \npublic RowVector getRow ( final int r ) throws MatrixException { \nif ( ( r < 0 ) || ( r >= m_nRows ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal RowVector rv = new RowVector ( m_nCols ) ; \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \nrv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; \n++ c ; \n} \n} \nreturn rv ; \n} \n} \n"}
{"9025": "public class Matrix { \npublic ColumnVector getColumn ( final int c ) throws MatrixException { \nif ( ( c < 0 ) || ( c >= m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal ColumnVector cv = new ColumnVector ( m_nRows ) ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \ncv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; \n++ r ; \n} \n} \nreturn cv ; \n} \n} \n"}
{"9026": "public class Matrix { \nprotected void set ( final float values [ ] [ ] ) { \nm_nRows = values . length ; \nm_nCols = values [ 0 ] . length ; \nm_aValues = values ; \n{ \nint r = 1 ; \nwhile ( r < m_nRows ) { \nm_nCols = Math . min ( m_nCols , values [ r ] . length ) ; \n++ r ; \n} \n} \n} \n} \n"}
{"9027": "public class Matrix { \npublic Matrix transpose ( ) { \nfinal float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \ntv [ c ] [ r ] = m_aValues [ r ] [ c ] ; \n++ c ; \n} \n} \n++ r ; \n} \n} \nreturn new Matrix ( tv ) ; \n} \n} \n"}
{"9028": "public class Matrix { \npublic Matrix add ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \nsv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; \n++ c ; \n} \n} \n++ r ; \n} \n} \nreturn new Matrix ( sv ) ; \n} \n} \n"}
{"9029": "public class Matrix { \npublic Matrix subtract ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \ndv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; \n++ c ; \n} \n} \n++ r ; \n} \n} \nreturn new Matrix ( dv ) ; \n} \n} \n"}
{"9030": "public class Matrix { \npublic Matrix multiply ( final float k ) { \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \npv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; \n++ c ; \n} \n} \n++ r ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9031": "public class Matrix { \npublic Matrix multiply ( final Matrix m ) throws MatrixException { \nif ( m_nCols != m . m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < m . m_nCols ) { \nfloat dot = 0 ; \n{ \nint k = 0 ; \nwhile ( k < m_nCols ) { \ndot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; \n++ k ; \n} \n} \npv [ r ] [ c ] = dot ; \n++ c ; \n} \n} \n++ r ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \nar . print ( m_aValues [ r ] [ c ] , width ) ; \n++ c ; \n} \n} \nar . println ( ) ; \n++ r ; \n} \n} \n} \n} \n"}
{"9044": "public class InvertibleMatrix { \npublic InvertibleMatrix inverse ( ) throws MatrixException { \nfinal InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; \nfinal IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \nfinal ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; \ninverse . setColumn ( col , c ) ; \n++ c ; \n} \n} \nreturn inverse ; \n} \n} \n"}
{"9045": "public class InvertibleMatrix { \npublic float determinant ( ) throws MatrixException { \ndecompose ( ) ; \nfloat determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; \n{ \nint i = 0 ; \nwhile ( i < m_nRows ) { \nfinal int pi = m_aPermutation [ i ] ; \ndeterminant *= m_aLU . at ( pi , i ) ; \n++ i ; \n} \n} \nreturn determinant ; \n} \n} \n"}
{"9046": "public class InvertibleMatrix { \npublic float norm ( ) { \nfloat sum = 0 ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \nfinal float v = m_aValues [ r ] [ c ] ; \nsum += v * v ; \n++ c ; \n} \n} \n++ r ; \n} \n} \nreturn ( float ) Math . sqrt ( sum ) ; \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \nfinal int pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \n{ \nint c = 0 ; \nwhile ( c < m_nCols ) { \nar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \n++ c ; \n} \n} \nar . println ( ) ; \n++ r ; \n} \n} \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \n{ \nint rPivot = 0 ; \nwhile ( rPivot < m_nRows - 1 ) { \nfloat largestScaledElmt = 0 ; \nint rLargest = 0 ; \n{ \nint r = rPivot ; \nwhile ( r < m_nRows ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( largestScaledElmt < scaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n++ r ; \n} \n} \nif ( largestScaledElmt == 0 ) { \nthrow new MatrixException ( MatrixException . SINGULAR ) ; \n} \nif ( rLargest != rPivot ) { \nfinal int temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \n++ m_nExchangeCount ; \n} \nfinal int prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \n{ \nint r = rPivot + 1 ; \nwhile ( r < m_nRows ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) { \n{ \nint c = rPivot + 1 ; \nwhile ( c < m_nCols ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt -= multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n++ c ; \n} \n} \n} \n++ r ; \n} \n} \n++ rPivot ; \n} \n} \n} \n} \n"}
{"9050": "public class LinearSystem { \nprivate ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { \nfinal ColumnVector y = new ColumnVector ( m_nRows ) ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \n{ \nint c = 0 ; \nwhile ( c < r ) { \ndot += m_aLU . at ( pr , c ) * y . at ( c ) ; \n++ c ; \n} \n} \ny . set ( r , b . at ( pr ) - dot ) ; \n++ r ; \n} \n} \nreturn y ; \n} \n} \n"}
{"9051": "public class LinearSystem { \nprivate ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { \nfinal ColumnVector x = new ColumnVector ( m_nRows ) ; \n{ \nint r = m_nRows - 1 ; \nwhile ( r >= 0 ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \n{ \nint c = r + 1 ; \nwhile ( c < m_nRows ) { \ndot += m_aLU . at ( pr , c ) * x . at ( c ) ; \n++ c ; \n} \n} \nx . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; \n-- r ; \n} \n} \nreturn x ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( largestX < absX ) largestX = absX ; \n++ r ; \n} \n} \nif ( largestX == 0 ) return ; \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \n{ \nint iter = 0 ; \nwhile ( iter < MAX_ITER ) { \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \ndouble dot = 0 ; \n{ \nint c = 0 ; \nwhile ( c < m_nRows ) { \nfinal double elmt = at ( r , c ) ; \ndot += elmt * x . at ( c ) ; \n++ c ; \n} \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n++ r ; \n} \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \n{ \nint r = 0 ; \nwhile ( r < m_nRows ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( largestDiff < diff ) largestDiff = diff ; \n++ r ; \n} \n} \nif ( largestDiff < largestX * TOLERANCE ) return ; \n++ iter ; \n} \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \n} \n} \n"}
{"9053": "public class IdentityMatrix { \npublic static void convert ( final SquareMatrix sm ) { \n{ \nint r = 0 ; \nwhile ( r < sm . m_nRows ) { \n{ \nint c = 0 ; \nwhile ( c < sm . m_nCols ) { \nsm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; \n++ c ; \n} \n} \n++ r ; \n} \n} \n} \n} \n"}
{"9054": "public class RandomExponential { \npublic float nextVonNeumann ( ) { \nint n ; \nint k = 0 ; \nfloat u1 ; \n{ \nwhile ( ) { \nn = 1 ; \nu1 = GENERATOR . nextFloat ( ) ; \nfloat u = u1 ; \nfloat uPrev = Float . NaN ; \n{ \nwhile ( ) { \nuPrev = u ; \nu = GENERATOR . nextFloat ( ) ; \nif ( u > uPrev ) { \nif ( ( n & 1 ) == 0 ) { \nreturn u1 + k ; \n} \n++ k ; \nbreak ; \n} \n++ n ; \n} \n} \n} \n} \n} \n} \n"}
{"9065": "public class IEEE754 { \nprivate static char [ ] _toCharBitArray ( final long pvalue , final int size ) { \nlong value = pvalue ; \nfinal char bits [ ] = new char [ size ] ; \n{ \nint i = size - 1 ; \nwhile ( i >= 0 ) { \nbits [ i ] = ( value & 1 ) == 0 ? '0' : '1' ; \nvalue >>>= 1 ; \n-- i ; \n} \n} \nreturn bits ; \n} \n} \n"}
{"9073": "public class RandomNormal { \npublic float nextCentral ( ) { \nfloat sum = 0.0f ; \n{ \nint j = 0 ; \nwhile ( j < 12 ) { \nsum += GENERATOR . nextFloat ( ) ; \n++ j ; \n} \n} \nreturn m_fStddev * ( sum - 6 ) + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal int halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \n{ \nint i = 2 ; \nwhile ( i <= n ) { \nsieve [ i ] = true ; \n++ i ; \n} \n} \nint prime = 2 ; \nwhile ( prime < halfN ) { \n{ \nint composite = prime << 1 ; \nwhile ( composite <= n ) { \nsieve [ composite ] = false ; \ncomposite += prime ; \n} \n} \nwhile ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nint n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \n{ \nint factor = 2 ; \nwhile ( n > 1 ) { \nif ( isPrime [ factor ] && ( n % factor == 0 ) ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn /= factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \n++ factor ; \n} \n} \nfinal int factors [ ] = new int [ v . size ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < v . size ( ) ) { \nfactors [ i ] = v . get ( i ) . intValue ( ) ; \n++ i ; \n} \n} \nreturn factors ; \n} \n} \n"}
{"9091": "public class GeocodeRequestBuilder { \npublic GeocodeRequestBuilder componenets ( Map < String , String > components ) { \nStringBuffer filters = new StringBuffer ( ) ; \n{ \nIterator < Map . Entry < String , String > > iterator = components . entrySet ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nMap . Entry < String , String > entry = iterator . next ( ) ; \nfilters . append ( entry . getKey ( ) + \":\" + entry . getValue ( ) != null ? entry . getValue ( ) . replace ( ' ' , '+' ) : entry . getValue ( ) ) ; \nif ( iterator . hasNext ( ) ) filters . append ( \"|\" ) ; \n} \n} \nparameters . put ( \"components\" , filters . toString ( ) ) ; \nreturn this ; \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \n{ \nint count = 0 ; \nwhile ( count < readerMap . size ( ) ) { \nmapArr . add ( null ) ; \ncount ++ ; \n} \n} \nEnumeration enumt = readerMap . keys ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \n{ \nint count = 0 ; \nwhile ( count < mapArr . size ( ) ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \ncount ++ ; \n} \n} \n} \n} \n"}
{"9277": "public class Catalog { \npublic void loadSystemCatalogs ( ) throws MalformedURLException , IOException { \nVector catalogs = catalogManager . getCatalogFiles ( ) ; \nif ( catalogs != null ) { \n{ \nint count = 0 ; \nwhile ( count < catalogs . size ( ) ) { \ncatalogFiles . addElement ( catalogs . elementAt ( count ) ) ; \ncount ++ ; \n} \n} \n} \nif ( catalogFiles . size ( ) > 0 ) { \nString catfile = ( String ) catalogFiles . lastElement ( ) ; \ncatalogFiles . removeElement ( catfile ) ; \nparseCatalog ( catfile ) ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \n{ \nint count = 0 ; \nwhile ( ! parsed && count < readerArr . size ( ) ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \ncount ++ ; \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \n{ \nint curCat = 0 ; \nwhile ( curCat < catalogFiles . size ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \ncurCat ++ ; \n} \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \n{ \nint curCat = 0 ; \nwhile ( curCat < catalogFiles . size ( ) ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \ncurCat ++ ; \n} \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \n{ \nint count = 0 ; \nwhile ( ! parsed && count < readerArr . size ( ) ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \ncount ++ ; \n} \n} \nif ( ! parsed ) { \nif ( notFound ) { \ncatalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \n} \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \n{ \nint catPos = 0 ; \nwhile ( catPos < catalogs . size ( ) ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \ncatPos ++ ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \n{ \nint catPos = 0 ; \nwhile ( catPos < catalogs . size ( ) ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \n} \nelse if ( entityType == SYSTEM ) { \nresolved = c . resolveSystem ( systemId ) ; \n} \nelse if ( entityType == URI ) { \nresolved = c . resolveURI ( systemId ) ; \n} \nif ( resolved != null ) { \nreturn resolved ; \n} \ncatPos ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) { \nreturn null ; \n} \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \n{ \nint count = 0 ; \nwhile ( count < bytes . length ) { \nint ch = bytes [ count ] & 0xFF ; \nif ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) { \nnewRef += encodedByte ( ch ) ; \n} \nelse { \nnewRef += ( char ) bytes [ count ] ; \n} \ncount ++ ; \n} \n} \nreturn newRef ; \n} \n} \n"}
{"9293": "public class ThrowableHandler { \nprotected static void fireOnThrowable ( int type , Throwable t ) { \nObject [ ] list = listeners . toArray ( ) ; \n{ \nint i = 0 ; \nwhile ( i < list . length ) { \n( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \n{ \nint i = 0 ; \nwhile ( i < PROTOCOLS . length ) { \ntry { \nURL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) return handler ; \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \n{ \nint p = 0 ; \nwhile ( p < handlerPkgs . length ) { \ntry { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \np ++ ; \n} \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( limit > 0 && count > limit ) { \ncount = limit ; \n} \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \n{ \nint i = 0 ; \nwhile ( i < count ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) end = string . length ( ) ; \nif ( end == 0 ) strings [ i ] = EMPTY ; \nelse strings [ i ] = string . substring ( begin , end ) ; \nbegin = end + 1 ; \ni ++ ; \n} \n} \nreturn strings ; \n} \n} \n"}
{"9323": "public class Strings { \npublic static String join ( final byte array [ ] ) { \nByte bytes [ ] = new Byte [ array . length ] ; \n{ \nint i = 0 ; \nwhile ( i < bytes . length ) { \nbytes [ i ] = new Byte ( array [ i ] ) ; \ni ++ ; \n} \n} \nreturn join ( bytes , null ) ; \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) return null ; \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \n{ \nint i = 0 ; \nwhile ( i < children . getLength ( ) ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { \ngoodChildren . add ( currentChild ) ; \n} \ni ++ ; \n} \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \n{ \nint i = 0 ; \nwhile ( i < children . getLength ( ) ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \ni ++ ; \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9349": "public class Resolver { \nprivate Vector appendVector ( Vector vec , Vector appvec ) { \nif ( appvec != null ) { \n{ \nint count = 0 ; \nwhile ( count < appvec . size ( ) ) { \nvec . addElement ( appvec . elementAt ( count ) ) ; \ncount ++ ; \n} \n} \n} \nreturn vec ; \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \n{ \nint catPos = 0 ; \nwhile ( catPos < catalogs . size ( ) ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == SYSTEM ) { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse if ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \ncatPos ++ ; \n} \n} \nif ( resolutions != null ) { \nreturn resolutions ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9365": "public class JBossObject { \npublic static void list ( JBossStringBuilder buffer , Collection objects ) { \nif ( objects == null ) return ; \nbuffer . append ( '[' ) ; \nif ( objects . isEmpty ( ) == false ) { \n{ \nIterator i = objects . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nObject object = i . next ( ) ; \nif ( object instanceof JBossObject ) ( ( JBossObject ) object ) . toShortString ( buffer ) ; \nelse buffer . append ( object . toString ( ) ) ; \nif ( i . hasNext ( ) ) buffer . append ( \", \" ) ; \n} \n} \n} \nbuffer . append ( ']' ) ; \n} \n} \n"}
{"9370": "public class Objects { \npublic static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \nvalueType } \n) ; \n} \ncatch ( Exception ignore ) { \nClass [ ] types = type . getClasses ( ) ; \n{ \nint i = 0 ; \nwhile ( i < types . length ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \ntypes [ i ] } \n) ; \n} \ncatch ( Exception ignore2 ) { \n} \ni ++ ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9378": "public class PropertyMap { \nprivate void firePropertyAdded ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyAdded ( event ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9379": "public class PropertyMap { \nprivate void firePropertyRemoved ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyRemoved ( event ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9380": "public class PropertyMap { \nprivate void firePropertyChanged ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyChanged ( event ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9399": "public class HashCode { \npublic static int generate ( final byte [ ] bytes ) { \nint hashcode = 0 ; \n{ \nint i = 0 ; \nwhile ( i < bytes . length ) { \nhashcode <<= 1 ; \nhashcode ^= bytes [ i ] ; \ni ++ ; \n} \n} \nreturn hashcode ; \n} \n} \n"}
{"9400": "public class HashCode { \npublic static int generate ( final Object array [ ] , final boolean deep ) { \nint hashcode = 0 ; \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nif ( deep && ( array [ i ] instanceof Object [ ] ) ) { \nhashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; \n} \nelse { \nhashcode ^= array [ i ] . hashCode ( ) ; \n} \ni ++ ; \n} \n} \nreturn hashcode ; \n} \n} \n"}
{"9407": "public class Graph { \npublic boolean removeVertex ( Vertex < T > v ) { \nif ( ! verticies . containsValue ( v ) ) return false ; \nverticies . remove ( v . getName ( ) ) ; \nif ( v == rootVertex ) rootVertex = null ; \n{ \nint n = 0 ; \nwhile ( n < v . getOutgoingEdgeCount ( ) ) { \nEdge < T > e = v . getOutgoingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > to = e . getTo ( ) ; \nto . remove ( e ) ; \nedges . remove ( e ) ; \nn ++ ; \n} \n} \n{ \nint n = 0 ; \nwhile ( n < v . getIncomingEdgeCount ( ) ) { \nEdge < T > e = v . getIncomingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > predecessor = e . getFrom ( ) ; \npredecessor . remove ( e ) ; \nn ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9409": "public class Graph { \npublic void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { \nv . visit ( ) ; \nif ( visitor != null ) visitor . visit ( this , v ) ; \n{ \nint i = 0 ; \nwhile ( i < v . getOutgoingEdgeCount ( ) ) { \nEdge < T > e = v . getOutgoingEdge ( i ) ; \nif ( ! e . getTo ( ) . visited ( ) ) { \nif ( visitor != null ) visitor . visit ( this , v , e ) ; \ne . mark ( ) ; \ndfsSpanningTree ( e . getTo ( ) , visitor ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"9411": "public class Graph { \npublic Edge < T > [ ] findCycles ( ) { \nArrayList < Edge < T > > cycleEdges = new ArrayList < Edge < T > > ( ) ; \n{ \nint n = 0 ; \nwhile ( n < verticies . size ( ) ) { \nVertex < T > v = getVertex ( n ) ; \nv . setMarkState ( VISIT_COLOR_WHITE ) ; \nn ++ ; \n} \n} \n{ \nint n = 0 ; \nwhile ( n < verticies . size ( ) ) { \nVertex < T > v = getVertex ( n ) ; \nvisit ( v , cycleEdges ) ; \nn ++ ; \n} \n} \nEdge < T > [ ] cycles = new Edge [ cycleEdges . size ( ) ] ; \ncycleEdges . toArray ( cycles ) ; \nreturn cycles ; \n} \n} \n"}
{"9412": "public class DOMWriter { \npublic static String normalize ( String s , boolean canonical ) { \nStringBuffer str = new StringBuffer ( ) ; \nint len = ( s != null ) ? s . length ( ) : 0 ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nchar ch = s . charAt ( i ) ; \nswitch ( ch ) { \ncase '<' : { \nstr . append ( \"&lt;\" ) ; \nbreak ; \n} \ncase '>' : { \nstr . append ( \"&gt;\" ) ; \nbreak ; \n} \ncase '&' : { \nstr . append ( \"&amp;\" ) ; \nbreak ; \n} \ncase '\"' : { \nstr . append ( \"&quot;\" ) ; \nbreak ; \n} \ncase '\\'' : { \nstr . append ( \"&apos;\" ) ; \nbreak ; \n} \ncase '\\r' : case '\\n' : { \nif ( canonical ) { \nstr . append ( \"&#\" ) ; \nstr . append ( Integer . toString ( ch ) ) ; \nstr . append ( ';' ) ; \nbreak ; \n} \n} \ndefault : { \nstr . append ( ch ) ; \n} \n} \ni ++ ; \n} \n} \nreturn ( str . toString ( ) ) ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < attribs . getLength ( ) ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( uri == null && qname . startsWith ( \"xmlns\" ) ) { \nlog . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \n} \nelse { \ndestElement . setAttributeNS ( uri , qname , value ) ; \n} \ni ++ ; \n} \n} \n} \n} \n"}
{"9419": "public class DOMUtils { \npublic static boolean hasChildElements ( Node node ) { \nNodeList nlist = node . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nlist . getLength ( ) ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) return true ; \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9420": "public class DOMUtils { \npublic static Iterator getChildElements ( Node node ) { \nArrayList list = new ArrayList ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nlist . getLength ( ) ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) list . add ( child ) ; \ni ++ ; \n} \n} \nreturn list . iterator ( ) ; \n} \n} \n"}
{"9421": "public class DOMUtils { \npublic static String getTextContent ( Node node , boolean replaceProps ) { \nboolean hasTextContent = false ; \nStringBuffer buffer = new StringBuffer ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \n{ \nint i = 0 ; \nwhile ( i < nlist . getLength ( ) ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . TEXT_NODE ) { \nbuffer . append ( child . getNodeValue ( ) ) ; \nhasTextContent = true ; \n} \ni ++ ; \n} \n} \nString text = ( hasTextContent ? buffer . toString ( ) : null ) ; \nif ( text != null && replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; \nreturn text ; \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \n{ \nint u = 0 ; \nwhile ( u < length ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \nu ++ ; \n} \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \n{ \nint i = 0 ; \nwhile ( i < ifaces . length ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( clazz == null ) buffer . append ( \"**null**\" ) ; \nelse { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( intfs . length > 0 ) { \nbuffer . append ( \" intfs=\" ) ; \n{ \nint i = 0 ; \nwhile ( i < intfs . length ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( i < intfs . length - 1 ) buffer . append ( \", \" ) ; \n++ i ; \n} \n} \n} \nbuffer . append ( \"}\" ) ; \n} \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \n{ \nint i = 0 ; \nwhile ( i < methods . length ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9435": "public class Classes { \npublic static Class getPrimitiveWrapper ( final Class type ) { \nif ( ! type . isPrimitive ( ) ) { \nthrow new IllegalArgumentException ( \"type is not a primitive class\" ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < PRIMITIVE_WRAPPER_MAP . length ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; \ni += 2 ; \n} \n} \nthrow new UnreachableStatementException ( ) ; \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \n{ \nint n = 0 ; \nwhile ( n < ifaces . length ) { \nallIfaces . add ( ifaces [ n ] ) ; \nn ++ ; \n} \n} \nc = c . getSuperclass ( ) ; \n} \n} \n} \n"}
{"9437": "public class Classes { \npublic static Class [ ] getAllUniqueInterfaces ( Class c ) { \nSet uniqueIfaces = new HashSet ( ) ; \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \n{ \nint n = 0 ; \nwhile ( n < ifaces . length ) { \nuniqueIfaces . add ( ifaces [ n ] ) ; \nn ++ ; \n} \n} \nc = c . getSuperclass ( ) ; \n} \nreturn ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; \n} \n} \n"}
{"9438": "public class Classes { \npublic static boolean isPrimitiveWrapper ( final Class type ) { \n{ \nint i = 0 ; \nwhile ( i < PRIMITIVE_WRAPPER_MAP . length ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { \nreturn true ; \n} \ni += 2 ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9442": "public class Classes { \nprivate final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { \nint arraySize = 0 ; \nwhile ( name . endsWith ( \"[]\" ) ) { \nname = name . substring ( 0 , name . length ( ) - 2 ) ; \narraySize ++ ; \n} \nClass c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; \nif ( c == null ) { \ntry { \nc = cl . loadClass ( name ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; \n} \n} \nif ( arraySize > 0 ) { \nint [ ] dims = new int [ arraySize ] ; \n{ \nint i = 0 ; \nwhile ( i < arraySize ) { \ndims [ i ] = 1 ; \ni ++ ; \n} \n} \nc = Array . newInstance ( c , dims ) . getClass ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"9462": "public class Util { \nprotected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { \nbuffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; \nbuffer . append ( \" interfaces={\" ) ; \nClass [ ] interfaces = clazz . getInterfaces ( ) ; \n{ \nint i = 0 ; \nwhile ( i < interfaces . length ) { \nif ( i > 0 ) buffer . append ( \", \" ) ; \nbuffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; \n++ i ; \n} \n} \nbuffer . append ( \"}]\" ) ; \n} \n} \n"}
{"9482": "public class FilePropertyReader { \npublic Map readProperties ( ) throws PropertyException , IOException { \nProperties props = new Properties ( ) ; \n{ \nint i = 0 ; \nwhile ( i < filenames . length ) { \nloadProperties ( props , filenames [ i ] ) ; \ni ++ ; \n} \n} \nreturn props ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \n{ \nint i = 0 ; \nwhile ( i < files . length ) { \njar ( files [ i ] , prefix , info ) ; \ni ++ ; \n} \n} \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n"}
{"9492": "public class CompoundIterator { \npublic boolean hasNext ( ) { \n{ \nwhile ( index < iters . length ) { \nif ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) { \nreturn true ; \n} \nindex ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \n{ \nint j = 0 ; \nwhile ( j < contents . length ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \nj ++ ; \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9524": "public class UBValue { \npublic boolean [ ] asBoolArray ( ) { \nboolean [ ] retval ; \nUBArray array = asArray ( ) ; \nswitch ( array . getStrongType ( ) ) { \ncase Int8 : { \nbyte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nretval [ i ] = data [ i ] > 0 ; \ni ++ ; \n} \n} \nbreak ; \n} \ncase Int16 : { \nshort [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nretval [ i ] = data [ i ] > 0 ; \ni ++ ; \n} \n} \nbreak ; \n} \ncase Int32 : { \nint [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nretval [ i ] = data [ i ] > 0 ; \ni ++ ; \n} \n} \nbreak ; \n} \ncase Int64 : { \nlong [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nretval [ i ] = data [ i ] > 0 ; \ni ++ ; \n} \n} \nbreak ; \n} \ncase Float32 : { \nfloat [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nretval [ i ] = data [ i ] > 0 ; \ni ++ ; \n} \n} \nbreak ; \n} \ncase Float64 : { \ndouble [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \n{ \nint i = 0 ; \nwhile ( i < data . length ) { \nretval [ i ] = data [ i ] > 0 ; \ni ++ ; \n} \n} \nbreak ; \n} \ndefault : throw new RuntimeException ( \"not an int32[] type\" ) ; \n} \nreturn retval ; \n} \n} \n"}
{"9530": "public class CsvTableWriter { \npublic int dumpToCsv ( Context ctx , SQLiteDatabase db , String suffix ) throws FileNotFoundException { \nint numRowsWritten = 0 ; \nCursor c ; \nString filename = getCsvFilename ( db . getPath ( ) , db . getVersion ( ) , suffix ) ; \nc = db . query ( th . getTableName ( ) , null , null , null , null , null , null ) ; \nFileOutputStream fos ; \nfos = ctx . openFileOutput ( filename , 0 ) ; \nPrintWriter printWriter = new PrintWriter ( fos ) ; \nString headerRow = buildHeaderRow ( ) ; \nprintWriter . println ( headerRow ) ; \n{ \nboolean hasItem = c . moveToFirst ( ) ; \nwhile ( hasItem ) { \nString csv = buildCsvRow ( c ) ; \nprintWriter . println ( csv ) ; \nnumRowsWritten ++ ; \nhasItem = c . moveToNext ( ) ; \n} \n} \nprintWriter . flush ( ) ; \nprintWriter . close ( ) ; \nreturn numRowsWritten ; \n} \n} \n"}
{"9569": "public class Program { \nstatic void initIntentionSelectionThreads ( Config config ) { \nint ncores = config . getNumThreads ( ) ; \nMain . intentionSelectors = new IntentionSelector [ ncores ] ; \n{ \nint i = 0 ; \nwhile ( i < Main . npools ) { \nMain . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9570": "public class Program { \nstatic void startIntentionSelectionThreads ( ) { \n{ \nint i = 0 ; \nwhile ( i < Main . npools ) { \nThread thread = new Thread ( Main . intentionSelectors [ i ] ) ; \nthread . setName ( \"jill-\" + i ) ; \nthread . start ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9571": "public class Program { \nstatic void shutdownIntentionSelectionThreads ( ) { \n{ \nint i = 0 ; \nwhile ( i < Main . npools ) { \nMain . intentionSelectors [ i ] . shutdown ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9575": "public class ProgramLoader { \nprivate static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { \n{ \nint j = 0 ; \nwhile ( j < plans . length ) { \nClass < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; \nif ( pclass == null ) { \nreturn false ; \n} \nlogger . info ( \"Found Plan \" + pclass . getName ( ) + \" that handles Goal \" + gtype . getName ( ) ) ; \nPlanType ptype = new PlanType ( pclass . getName ( ) ) ; \nptype . setPlanClass ( pclass ) ; \nGlobalState . planTypes . push ( ptype ) ; \nptype . addParent ( ( byte ) gtype . getId ( ) ) ; \ngtype . addChild ( ( byte ) ptype . getId ( ) ) ; \nj ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9576": "public class ProgramLoader { \nprivate static void createAgentsInCatalog ( AObjectCatalog agents , AgentType atype , Class < ? > aclass , int num ) { \nint added = 0 ; \ntry { \n{ \nint i = 0 ; \nwhile ( i < num ) { \nAgent agent = ( Agent ) ( aclass . getConstructor ( String . class ) . newInstance ( \"a\" + Integer . toString ( i ) ) ) ; \nagent . setGoals ( atype . getGoals ( ) ) ; \nagents . push ( agent ) ; \nadded ++ ; \ni ++ ; \n} \n} \nlogger . info ( \"Finished loading {} agents\" , added ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create instance of class \" + aclass . getName ( ) ) ; \n} \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) { \nreturn false ; \n} \n{ \nint i = 0 ; \nwhile ( i < obj1 . name . length ) { \nif ( obj1 . name [ i ] != obj2 . name [ i ] ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \n{ \nint i = 0 ; \nwhile ( args != null && i < args . length ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \ni ++ ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n} \n"}
{"9585": "public class AObjectCatalog { \npublic AObject find ( String name ) { \n{ \nint i = 0 ; \nwhile ( i < nextid ) { \nif ( objects [ i ] . getName ( ) . equals ( name ) ) { \nreturn objects [ i ] ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9602": "public class BeliefSet { \npublic BeliefSetField getFieldByName ( String name ) { \nBeliefSetField field = null ; \n{ \nint i = 0 ; \nwhile ( i < fields . length ) { \nif ( name . equals ( fields [ i ] . getName ( ) ) ) { \nfield = fields [ i ] ; \nbreak ; \n} \ni ++ ; \n} \n} \nreturn field ; \n} \n} \n"}
{"9603": "public class Greeter { \nprivate void registerNeighbours ( Random rand , int count ) throws BeliefBaseException { \nint size = ( count < 0 ) ? 0 : count ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nboolean male = ( rand . nextDouble ( ) < 0.5 ) ? true : false ; \nthis . addBelief ( beliefset , buildName ( male ) , male ? \"male\" : \"female\" ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9608": "public class IntentionSelector { \nprivate boolean manageGoal ( int agentIndex , Agent agent , Stack255 agentExecutionStack , Goal node ) { \nGoalType gtype = ( GoalType ) GlobalState . goalTypes . find ( node . getClass ( ) . getName ( ) ) ; \nbyte [ ] ptypes = gtype . getChildren ( ) ; \nassert ( ptypes != null ) ; \nbindings . clear ( ) ; \n{ \nint p = 0 ; \nwhile ( p < ptypes . length ) { \nPlanType ptype = ( PlanType ) GlobalState . planTypes . get ( ptypes [ p ] ) ; \ntry { \nPlan planInstance = ( Plan ) ( ptype . getPlanClass ( ) . getConstructor ( Agent . class , Goal . class , String . class ) . newInstance ( GlobalState . agents . get ( agentIndex ) , node , \"p\" ) ) ; \nagent . clearLastResults ( ) ; \nif ( planInstance . context ( ) ) { \nSet < Belief > results = agent . getLastResults ( ) ; \nbindings . add ( planInstance , ( results == null ) ? null : new LinkedHashSet < Belief > ( results ) ) ; \n} \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create plan object of type \" + ptype . getClass ( ) . getName ( ) , e ) ; \n} \np ++ ; \n} \n} \nint numBindings = bindings . size ( ) ; \nif ( numBindings == 0 ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" has no applicable plans for goal \" + gtype + \" and will continue to wait indefinitely\" ) ; \nreturn false ; \n} \nagent . notifyAgentPrePlanSelection ( bindings ) ; \nPlan planInstance = bindings . selectPlan ( GlobalConstant . PLAN_SELECTION_POLICY ) ; \nsynchronized ( agentExecutionStack ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" choose an instance of plan \" + planInstance . getClass ( ) . getSimpleName ( ) + \" to handle goal \" + node . getClass ( ) . getSimpleName ( ) ) ; \nagentExecutionStack . push ( planInstance ) ; \n} \nreturn true ; \n} \n} \n"}
{"9614": "public class Main { \npublic static void finish ( ) { \nfor ( JillExtension extension : GlobalState . eventHandlers ) { \nextension . finish ( ) ; \n} \nProgram . shutdownIntentionSelectionThreads ( ) ; \nlong t0 = System . currentTimeMillis ( ) ; \n{ \nint i = 0 ; \nwhile ( i < GlobalState . agents . size ( ) ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nagent . finish ( ) ; \ni ++ ; \n} \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Terminated \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9615": "public class Main { \npublic static boolean arePoolsIdle ( ) { \nboolean idle = true ; \n{ \nint i = 0 ; \nwhile ( i < npools ) { \nidle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; \ni ++ ; \n} \n} \nreturn idle ; \n} \n} \n"}
{"9627": "public class ContentType { \nprivate static Map < String , String > parseParameters ( String expression ) { \nMap < String , String > parameters = new HashMap < > ( ) ; \nint parametersSeparatorIndex = 0 ; \n{ \nwhile ( ) { \nint valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; \nif ( valueSeparatorIndex == - 1 ) { \nbreak ; \n} \nString name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; \n++ valueSeparatorIndex ; \nparametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; \nif ( parametersSeparatorIndex == - 1 ) { \nparametersSeparatorIndex = expression . length ( ) ; \n} \nif ( valueSeparatorIndex == parametersSeparatorIndex ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Value is empty.\" , expression ) ; \n} \nif ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Name override |%s|.\" , expression , name ) ; \n} \n++ parametersSeparatorIndex ; \n} \n} \nif ( parameters . isEmpty ( ) ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Missing name/value separator.\" , expression ) ; \n} \nreturn parameters ; \n} \n} \n"}
{"9672": "public class AbstractEMFParser { \nprivate static Set < EObject > findAllEObjects ( final ResourceSet resourceSet ) { \nfinal Set < EObject > list = new HashSet < EObject > ( ) ; \n{ \nfinal Iterator < Notifier > i = resourceSet . getAllContents ( ) ; \nwhile ( i . hasNext ( ) ) { \nfinal Notifier next = i . next ( ) ; \nif ( next instanceof EObject ) { \nlist . add ( ( EObject ) next ) ; \n} \n} \n} \nreturn list ; \n} \n} \n"}
{"9677": "public class StatementImpl { \npublic void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { \nint arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; \nAssertUtils . assertTrue ( values . length <= arrayLen ) ; \n{ \nint i = 0 ; \nwhile ( i < arrayLen ) { \nsetString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"9688": "public class WebViewFactory { \npublic static void write ( InputStream in , OutputStream out ) throws IOException { \nbyte [ ] b = new byte [ 4096 ] ; \n{ \nint n ; \nwhile ( ( n = in . read ( b ) ) != - 1 ) { \nout . write ( b , 0 , n ) ; \n} \n} \nin . close ( ) ; \nout . close ( ) ; \n} \n} \n"}
{"9699": "public class FileSystemDirectoryHelper { \npublic File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { \nList < File > parts1 = getParentDirs ( dir1 ) ; \nList < File > parts2 = getParentDirs ( dir2 ) ; \nFile matched = null ; \nfinal int maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; \n{ \nint i = 0 ; \nwhile ( i < maxCommonSize ) { \nif ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { \nmatched = parts1 . get ( i ) ; \n} \nelse { \nbreak ; \n} \n++ i ; \n} \n} \nreturn matched ; \n} \n} \n"}
{"9700": "public class FileSystemDirectoryHelper { \npublic String abs2rel ( final String basePath , final String absPath ) { \nif ( ! isAbsolutePath ( absPath ) ) { \nreturn absPath ; \n} \nif ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { \nreturn absPath ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] absParts = getParts ( absPath ) ; \nint start = 0 ; \n{ \nint i = 0 ; \nwhile ( i < Math . min ( baseParts . length , absParts . length ) ) { \nif ( baseParts [ i ] . equals ( absParts [ i ] ) ) { \nstart = i + 1 ; \n} \n++ i ; \n} \n} \n{ \nint i = start ; \nwhile ( i < baseParts . length ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( \"..\" ) ; \n++ i ; \n} \n} \n{ \nint i = start ; \nwhile ( i < absParts . length ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( absParts [ i ] ) ; \n++ i ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < baseParts . length ) { \nif ( i > 0 || ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n++ i ; \n} \n} \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \nelse if ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9762": "public class RequestPreprocessor { \nprivate static boolean startsWith ( String requestPath , String pathComponent ) { \nif ( requestPath . charAt ( 0 ) != '/' ) { \nreturn false ; \n} \nint i = 1 ; \n{ \nint j = 0 ; \nwhile ( i < requestPath . length ( ) ) { \nif ( requestPath . charAt ( i ) == '/' ) { \nreturn j == pathComponent . length ( ) ; \n} \nif ( j == pathComponent . length ( ) ) { \nreturn false ; \n} \nif ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { \nreturn false ; \n} \n++ j ; \n++ i ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9882": "public class PolymerElements { \npublic String toHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < listMonomerNotations . size ( ) ) { \nnotation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + \".\" ) ; \ni ++ ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9898": "public class HELM2Notation { \npublic String polymerToHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < listOfPolymers . size ( ) ) { \nif ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\\\"\" + listOfPolymers . get ( i ) . getAnnotation ( ) + \"\\\"|\" ) ; \n} \nelse { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\" + \"|\" ) ; \n} \ni ++ ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9899": "public class HELM2Notation { \npublic String connectionToHELM2 ( ) { \nif ( listOfConnections . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < listOfConnections . size ( ) ) { \nnotation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + \"|\" ) ; \ni ++ ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9900": "public class HELM2Notation { \npublic String groupingToHELM2 ( ) { \nif ( listOfGroupings . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < listOfGroupings . size ( ) ) { \nnotation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + \"|\" ) ; \ni ++ ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9901": "public class HELM2Notation { \npublic String annotationToHELM2 ( ) { \nif ( ! ( annotationSection . isEmpty ( ) ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 0 ; \nwhile ( i < annotationSection . size ( ) ) { \nsb . append ( annotationSection . get ( i ) . toHELM2 ( ) + \"|\" ) ; \ni ++ ; \n} \n} \nsb . setLength ( sb . length ( ) - 1 ) ; \nreturn sb . toString ( ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"9905": "public class ConverterHELM1ToHELM2 { \npublic String doConvert ( String str ) { \nParserHELM2 parser = new ParserHELM2 ( ) ; \ntry { \nparser . parse ( str + \"V2.0\" ) ; \nreturn str + \"V2.0\" ; \n} \ncatch ( Exception e ) { \nString helm1 = str + \"f\" ; \nStringBuilder helm2 = new StringBuilder ( ) ; \nString [ ] sections = helm1 . split ( \"}\\\\$\" ) ; \nhelm2 . append ( sections [ 0 ] + \"}$\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \n{ \nint i = 1 ; \nwhile ( i < sections . length ) { \nsb . append ( sections [ i ] + \"}$\" ) ; \ni ++ ; \n} \n} \nhelm1 = \"$\" + sb . toString ( ) ; \nsections = helm1 . split ( \"\\\\$\" ) ; \nif ( sections . length >= 2 ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 1 ] ) ; \n} \n} \nif ( sections . length >= 3 ) { \nif ( ! ( sections [ 2 ] . isEmpty ( ) ) ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( \"|\" + sections [ 2 ] ) ; \n} \nelse { \nhelm2 . append ( sections [ 2 ] ) ; \n} \n} \nhelm2 . append ( \"$\" ) ; \nhelm2 . append ( \"$\" ) ; \nif ( sections . length >= 4 ) { \nif ( ! ( sections [ 3 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 3 ] ) ; \n} \n} \n} \nhelm2 . append ( \"$V2.0\" ) ; \nreturn helm2 . toString ( ) ; \n} \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) { \n{ \nint i = 0 ; \nwhile ( i < test . length ( ) - 4 ) { \nparser . doAction ( test . charAt ( i ) ) ; \ni ++ ; \n} \n} \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \nelse { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \n{ \nwhile ( ) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \n} \n} \n"}
{"9934": "public class ForkJoinPool { \nfinal void runWorker ( WorkQueue w ) { \nw . growArray ( ) ; \nint seed = w . hint ; \nint r = ( seed == 0 ) ? 1 : seed ; \n{ \nForkJoinTask < ? > t ; \nwhile ( ) { \nif ( ( t = scan ( w , r ) ) != null ) w . runTask ( t ) ; \nelse if ( ! awaitWork ( w , r ) ) break ; \nr ^= r << 13 ; \nr ^= r >>> 17 ; \nr ^= r << 5 ; \n} \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \n{ \nint pred = w . stackPred , spins = SPINS , ss ; \nwhile ( ) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse if ( w . qlock < 0 ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"9943": "public class AThreadPoolImpl { \n@ Override public AThreadPoolStatistics getStatistics ( ) { \nfinal AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; \n{ \nint i = 0 ; \nwhile ( i < localQueues . length ) { \nworkerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; \ni ++ ; \n} \n} \nfinal ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; \n{ \nint i = 0 ; \nwhile ( i < sharedQueues . length ) { \nsharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; \ni ++ ; \n} \n} \nreturn new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; \n} \n} \n"}
{"9982": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length ] ; \n{ \nint i = 0 ; \nwhile ( i < carr . length ) { \nbarr [ i ] = ( byte ) carr [ i ] ; \ni ++ ; \n} \n} \nreturn barr ; \n} \n} \n"}
{"9983": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < barr . length ) { \nbarr [ i ] = ( byte ) charSequence . charAt ( i ) ; \ni ++ ; \n} \n} \nreturn barr ; \n} \n} \n"}
{"9984": "public class CharKit { \npublic static char [ ] toSimpleCharArray ( byte [ ] barr ) { \nchar [ ] carr = new char [ barr . length ] ; \n{ \nint i = 0 ; \nwhile ( i < barr . length ) { \ncarr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; \ni ++ ; \n} \n} \nreturn carr ; \n} \n} \n"}
{"9985": "public class CharKit { \npublic static byte [ ] toAsciiByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \n{ \nint i = 0 ; \nwhile ( i < barr . length ) { \nchar c = charSequence . charAt ( i ) ; \nbarr [ i ] = ( byte ) ( ( int ) ( c <= 0xFF ? c : 0x3F ) ) ; \ni ++ ; \n} \n} \nreturn barr ; \n} \n} \n"}
{"10000": "public class ExtensionList { \npublic List < T > list ( Injector injector ) { \nList < T > r = new ArrayList < T > ( ) ; \n{ \nInjector i = injector ; \nwhile ( i != null ) { \nfor ( Entry < Key < ? > , Binding < ? > > e : i . getBindings ( ) . entrySet ( ) ) { \nif ( e . getKey ( ) . getTypeLiteral ( ) . equals ( type ) ) r . add ( ( T ) e . getValue ( ) . getProvider ( ) . get ( ) ) ; \n} \ni = i . getParent ( ) ; \n} \n} \nreturn r ; \n} \n} \n"}
{"10002": "public class RuntimeKit { \npublic static void compactMemory ( ) { \ntry { \nfinal byte [ ] [ ] unused = new byte [ 128 ] [ ] ; \n{ \nint i = unused . length ; \nwhile ( i -- != 0 ) { \nunused [ i ] = new byte [ 2000000000 ] ; \n} \n} \n} \ncatch ( OutOfMemoryError ignore ) { \n} \nSystem . gc ( ) ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nint estimatedSize = 0 ; \nfinal int len = value . length ( ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' || ch == ',' ) { \nestimatedSize += 3 ; \n{ \n++ i ; \ncontinue ; \n} \n} \n++ estimatedSize ; \n++ i ; \n} \n} \nif ( value . length ( ) == estimatedSize ) { \nreturn value ; \n} \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \n{ \nint i = 0 ; \nwhile ( i < len ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nbuilder . append ( \"%20\" ) ; \n{ \n++ i ; \ncontinue ; \n} \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \n{ \n++ i ; \ncontinue ; \n} \n} \nbuilder . append ( ch ) ; \n++ i ; \n} \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \n{ \nint i = 0 ; \nwhile ( i < stages . size ( ) ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( stage instanceof Function ) { \nif ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { \nreturn io ; \n} \n} \nelse if ( stage instanceof Predicate ) { \nif ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { \nreturn io ; \n} \n} \ni ++ ; \n} \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10052": "public class URITemplate { \npublic Map < String , String > variables ( String uri ) { \nMap < String , String > variables = new HashMap < String , String > ( ) ; \nMatcher matcher = pattern . matcher ( uri ) ; \nif ( matcher . matches ( ) ) { \n{ \nint i = 0 ; \nwhile ( i < matcher . groupCount ( ) ) { \nvariables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; \ni ++ ; \n} \n} \n} \nreturn variables ; \n} \n} \n"}
{"10139": "public class Util { \npublic static String replaceSlashWithHyphen ( String origin ) { \nchar [ ] resulltChars = origin . toCharArray ( ) ; \n{ \nint i = 0 ; \nwhile ( i < resulltChars . length - 1 ) { \nif ( resulltChars [ i ] == '/' ) { \nresulltChars [ i ] = '-' ; \n} \ni ++ ; \n} \n} \nreturn new String ( resulltChars , 0 , resulltChars . length - 1 ) ; \n} \n} \n"}
{"10140": "public class Util { \npublic static String bytes2HexString ( byte [ ] bytes ) { \nStringBuffer resultBuffer = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < bytes . length ) { \nresultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; \ni ++ ; \n} \n} \nreturn resultBuffer . toString ( ) ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \nparsedSql . append ( c ) ; \ni ++ ; \n} \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; \nif ( m_rgstrIncludeExtensions != null ) { \n{ \nint i = 0 ; \nwhile ( i < m_rgstrIncludeExtensions . length ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; \ni ++ ; \n} \n} \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) { \n{ \nint i = 0 ; \nwhile ( i < m_rgstrExcludeExtensions . length ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; \ni ++ ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"10148": "public class StateParser { \nprivate static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { \nfinal Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; \nfinal List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; \n{ \nint index = 0 ; \nwhile ( index < labels . size ( ) ) { \nfinal String next = labels . get ( index ) ; \nExpectedLabels labelValue ; \ntry { \nlabelValue = ExpectedLabels . valueOf ( next ) ; \nunusedLabels . remove ( labelValue ) ; \nif ( map . containsKey ( labelValue ) ) { \nLOGGER . warn ( \"Duplicate state label: {} ({})\" , next , labels ) ; \n} \nmap . put ( labelValue , index ) ; \n} \ncatch ( final IllegalArgumentException e ) { \nLOGGER . warn ( \"Unexpected state label: {}\" , next ) ; \n} \nindex ++ ; \n} \n} \nfor ( final ExpectedLabels label : unusedLabels ) { \nLOGGER . warn ( \"Unused label: {}\" , label ) ; \n} \nreturn map ; \n} \n} \n"}
{"10159": "public class StringUtils { \npublic static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { \nif ( startIndex < 0 ) { \nstartIndex = 0 ; \n} \nint srclen = s . length ( ) ; \nif ( endIndex > srclen ) { \nendIndex = srclen ; \n} \nint sublen = substr . length ( ) ; \nif ( sublen == 0 ) { \nreturn startIndex > srclen ? srclen : startIndex ; \n} \nsubstr = substr . toLowerCase ( ) ; \nint total = endIndex - sublen + 1 ; \nchar c = substr . charAt ( 0 ) ; \nmainloop : { \nint i = startIndex ; \nwhile ( i < total ) { \nif ( Character . toLowerCase ( s . charAt ( i ) ) != c ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nint j = 1 ; \nint k = i + 1 ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( s . charAt ( k ) ) ; \nif ( substr . charAt ( j ) != source ) { \ncontinue mainloop ; \n} \nj ++ ; \nk ++ ; \n} \nreturn i ; \ni ++ ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"10160": "public class StringUtils { \npublic static String removeChars ( String s , String chars ) { \nint i = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( i ) ; \n{ \nint j = 0 ; \nwhile ( j < i ) { \nchar c = s . charAt ( j ) ; \nif ( chars . indexOf ( c ) == - 1 ) { \nsb . append ( c ) ; \n} \nj ++ ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"10173": "public class AppUtilities { \npublic static Properties parseArgs ( Properties properties , String [ ] args ) { \nif ( properties == null ) properties = new Properties ( ) ; \nif ( args == null ) return properties ; \n{ \nint i = 0 ; \nwhile ( i < args . length ) { \nAppUtilities . addParam ( properties , args [ i ] , false ) ; \ni ++ ; \n} \n} \nreturn properties ; \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nint patNdxStart = 0 ; \nint patNdxEnd = patterns . length - 1 ; \nint tokNdxStart = 0 ; \nint tokNdxEnd = tokens . length - 1 ; \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { \nreturn false ; \n} \npatNdxStart ++ ; \ntokNdxStart ++ ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \n{ \nint i = patNdxStart ; \nwhile ( i <= patNdxEnd ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \nif ( patNdxStart > patNdxEnd ) { \nreturn false ; \n} \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { \nreturn false ; \n} \npatNdxEnd -- ; \ntokNdxEnd -- ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \n{ \nint i = patNdxStart ; \nwhile ( i <= patNdxEnd ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \nwhile ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { \nint patIdxTmp = - 1 ; \n{ \nint i = patNdxStart + 1 ; \nwhile ( i <= patNdxEnd ) { \nif ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \ni ++ ; \n} \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart ++ ; \ncontinue ; \n} \nint patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nint strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nint ndx = - 1 ; \nstrLoop : { \nint i = 0 ; \nwhile ( i <= strLength - patLength ) { \n{ \nint j = 0 ; \nwhile ( j < patLength ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) { \n{ \nj ++ ; \ncontinue strLoop ; \n} \n} \nj ++ ; \n} \n} \nndx = tokNdxStart + i ; \nbreak ; \ni ++ ; \n} \n} \nif ( ndx == - 1 ) { \nreturn false ; \n} \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \n{ \nint i = patNdxStart ; \nwhile ( i <= patNdxEnd ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( col < width ) { \nint ofs = 0 ; \n{ \nint i = 0 ; \nwhile ( i < col ) { \nofs += cols [ i ] ; \ni ++ ; \n} \n} \nreturn ofs ; \n} \nelse if ( col == width ) return abspos . getWidth ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( row < height ) { \nint ofs = 0 ; \n{ \nint i = 0 ; \nwhile ( i < row ) { \nofs += rows [ i ] ; \ni ++ ; \n} \n} \nreturn ofs ; \n} \nelse if ( row == height ) return abspos . getHeight ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \n{ \nint i = 0 ; \nwhile ( i < points . length ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \ni ++ ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \n{ \nint i = 0 ; \nwhile ( i < points . length ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \ni ++ ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \n{ \nint i = 0 ; \nwhile ( i < points . length ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \ni ++ ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \n{ \nint i = 0 ; \nwhile ( i < points . length ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \ni ++ ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nint fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \n{ \nint i = 2 ; \nwhile ( i < 32 ) { \nif ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) { \narg += \", \" ; \n} \nswitch ( i ) { \ncase 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) { \narg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; \n} \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) { \narg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \n} \nbreak ; \n} \n} \ni = i * 2 ; \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \n} \n} \n"}
{"10207": "public class PageControlTag { \npublic int doStartTag ( ) throws JspException { \nlog . fine ( \"public int doStartTag(): called\" ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nPagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; \nlog . fine ( \"list = \" + list ) ; \nString url ; \ntry { \nurl = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new JspException ( \"Got malformed URL exception: \" , e ) ; \n} \nrenderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; \nrenderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; \nint from = list . getCurrentIndex ( ) ; \nint to = list . getCurrentIndex ( ) + maxPages ; \n{ \nint i = from ; \nwhile ( ( i < list . size ( ) ) && ( i < to ) ) { \nrenderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , \"\" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; \ni ++ ; \n} \n} \nrenderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; \nrenderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; \nrenderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; \nreturn SKIP_BODY ; \n} \n} \n"}
{"10222": "public class Decision { \npublic void initializeLookups ( DecisionTree thisNode ) { \n{ \nIterator < Tree < DecisionTreeElement > > i = thisNode . getChildIterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nDecisionTree nextChildTree = ( DecisionTree ) i . next ( ) ; \nOrdinalAttribute matchingValue = nextChildTree . getElement ( ) . getAttributeValue ( ) ; \ndecisions [ matchingValue . ordinal ( ) ] = nextChildTree ; \n} \n} \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \nreturn true ; \n} \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { \nreturn true ; \n} \nelse if ( left . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse if ( right . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse if ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \nreturn false ; \n} \nint arity = leftFunctor . getArity ( ) ; \n{ \nint i = 0 ; \nwhile ( i < arity ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \nreturn false ; \n} \ni ++ ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( cutLevelVarSlot >= 0 ) { \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \n} \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \n{ \nint i = 0 ; \nwhile ( i < expressions . length ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( expression instanceof BuiltIn ) { \nbuiltIn = ( BuiltIn ) expression ; \n} \nelse { \nbuiltIn = this ; \n} \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \ni ++ ; \n} \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \n} \n} \n"}
{"10227": "public class InstructionCompiler { \nprivate int findMaxArgumentsInClause ( Clause clause ) { \nint result = 0 ; \nFunctor head = clause . getHead ( ) ; \nif ( head != null ) { \nresult = head . getArity ( ) ; \n} \nFunctor [ ] body = clause . getBody ( ) ; \nif ( body != null ) { \n{ \nint i = 0 ; \nwhile ( i < body . length ) { \nint arity = body [ i ] . getArity ( ) ; \nresult = ( arity > result ) ? arity : result ; \ni ++ ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"10233": "public class ByteBufferUtils { \npublic static String asString ( ByteBuffer buffer , int length ) { \nchar [ ] chars = new char [ length ] ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nchars [ i ] = ( char ) buffer . get ( i ) ; \ni ++ ; \n} \n} \nreturn String . valueOf ( chars ) ; \n} \n} \n"}
{"10245": "public class ReflectionUtils { \npublic static Object callMethod ( Object o , String method , Object [ ] params ) { \nClass cls = o . getClass ( ) ; \nClass [ ] paramClasses = new Class [ params . length ] ; \n{ \nint i = 0 ; \nwhile ( i < params . length ) { \nparamClasses [ i ] = params [ i ] . getClass ( ) ; \ni ++ ; \n} \n} \ntry { \nMethod m = cls . getMethod ( method , paramClasses ) ; \nreturn m . invoke ( o , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) { \nreturn \"\" ; \n} \nelse { \nif ( delta >= 1 ) { \nindentStack . push ( delta ) ; \n} \nelse if ( delta < 0 ) { \nindentStack . pop ( ) ; \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( delta < 0 ) ? delta : 0 ; \n{ \nint i = 0 ; \nwhile ( i < traceIndent ) { \nresult . append ( \" \" ) ; \ni ++ ; \n} \n} \ntraceIndent += ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10265": "public class DefaultBuiltIn { \nprotected void allocateArgumentRegisters ( Functor expression ) { \nint reg = 0 ; \n{ \nwhile ( reg < expression . getArity ( ) ) { \nTerm term = expression . getArgument ( reg ) ; \nif ( term instanceof Functor ) { \nint allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; \nsymbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; \n} \nreg ++ ; \n} \n} \n} \n} \n"}
{"10281": "public class IterativeBoundAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \n{ \nfloat bound = startBound ; \nwhile ( ) { \nmaxBound = bound ; \ntry { \nint numStepsSoFar = initSearch . getStepsTaken ( ) ; \ninitSearch . resetEnqueuedOnceFlag ( ) ; \nSearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; \nif ( node != null ) { \nreturn node ; \n} \nelse { \nreturn null ; \n} \n} \ncatch ( MaxBoundException e ) { \ne = null ; \n} \nif ( useEpsilon ) { \nbound = bound + epsilon ; \n} \nelse { \nbound = getMinBeyondBound ( ) ; \n} \n} \n} \n} \n} \n"}
{"10287": "public class PrologParser { \npublic Term listFunctor ( ) throws SourceCodeException { \nint nilId = interner . internFunctorName ( \"nil\" , 0 ) ; \nint consId = interner . internFunctorName ( \"cons\" , 2 ) ; \nToken leftDelim = consumeToken ( LSQPAREN ) ; \nTerm [ ] args = null ; \nToken nextToken = tokenSource . peek ( ) ; \nswitch ( nextToken . kind ) { \ncase LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; \nbreak ; \ndefault : } \nTerm accumulator ; \nif ( tokenSource . peek ( ) . kind == CONS ) { \nif ( args == null ) { \nthrow new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \n} \nconsumeToken ( CONS ) ; \naccumulator = term ( ) ; \n} \nelse { \naccumulator = new Nil ( nilId , null ) ; \n} \nToken rightDelim = consumeToken ( RSQPAREN ) ; \nif ( args != null ) { \n{ \nint i = args . length - 1 ; \nwhile ( i >= 0 ) { \nTerm previousAccumulator = accumulator ; \naccumulator = new Cons ( consId , new Term [ ] { \nargs [ i ] , previousAccumulator } \n) ; \ni -- ; \n} \n} \n} \nSourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; \naccumulator . setSourceCodePosition ( position ) ; \nreturn ( Functor ) accumulator ; \n} \n} \n"}
{"10315": "public class SequentialCuckooFunction { \nprivate Entry < K > cuckoo ( Entry < K > entry ) { \nEntry < K > currentEntry = entry ; \nint hash = entry . hash1 ; \nint index = indexFor ( hash ) ; \nEntry < K > nextEntry = hashTable [ index ] ; \nint previousFlag = 0 ; \nint [ ] previousIndex = new int [ 2 ] ; \nint [ ] previousSeq = new int [ 2 ] ; \n{ \nint i = 0 ; \nwhile ( i < hashTableSize ) { \nif ( nextEntry == null ) { \nhashTable [ index ] = currentEntry ; \nreturn null ; \n} \nhashTable [ index ] = currentEntry ; \ncurrentEntry = nextEntry ; \nint firstPosition = indexFor ( currentEntry . hash1 ) ; \nhash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; \nindex = indexFor ( hash ) ; \npreviousIndex [ previousFlag ] = index ; \npreviousSeq [ previousFlag ] = nextEntry . seq ; \npreviousFlag = ( previousFlag == 1 ) ? 0 : 1 ; \nnextEntry = hashTable [ index ] ; \nif ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) { \nbreak ; \n} \ni ++ ; \n} \n} \nreturn currentEntry ; \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nint total = 0 ; \nfor ( int c : counts ) { \ntotal += c ; \n} \n{ \nint i = 0 ; \nwhile ( i < probabilities . length ) { \nif ( total > 0 ) { \nprobabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \n} \nelse { \nprobabilities [ i ] = 0.0d ; \n} \ni ++ ; \n} \n} \nreturn probabilities ; \n} \n} \n"}
{"10326": "public class SortAction { \npublic ActionForward perform ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { \nlog . fine ( \"perform: called\" ) ; \nSortForm sortForm = ( SortForm ) form ; \nHttpSession session = request . getSession ( ) ; \nServletContext application = session . getServletContext ( ) ; \nlog . fine ( \"variables in the servlet context: \" ) ; \n{ \nEnumeration e = application . getAttributeNames ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nlog . fine ( e . nextElement ( ) . toString ( ) ) ; \n} \n} \nList list = ( List ) session . getAttribute ( sortForm . getList ( ) ) ; \nComparator comparator = ( Comparator ) application . getAttribute ( sortForm . getComparator ( ) ) ; \nlog . fine ( \"comparator = \" + comparator ) ; \nSortStateBean sortStateBean = ( SortStateBean ) session . getAttribute ( sortForm . getSortState ( ) ) ; \nif ( sortStateBean == null ) { \nlog . fine ( \"There is no sort state bean\" ) ; \nsortStateBean = new SortStateBean ( ) ; \n} \nif ( ! sortStateBean . getState ( ) . equals ( SortStateBean . FORWARD ) || ! sortStateBean . getSortProperty ( ) . equals ( sortForm . getSortStateProperty ( ) ) ) { \nCollections . sort ( list , comparator ) ; \nsortStateBean . setState ( SortStateBean . FORWARD ) ; \n} \nelse { \nCollections . sort ( list , comparator ) ; \nCollections . reverse ( list ) ; \nsortStateBean . setState ( SortStateBean . REVERSE ) ; \n} \nsession . setAttribute ( sortForm . getList ( ) , list ) ; \nsortStateBean . setSortProperty ( sortForm . getSortStateProperty ( ) ) ; \nsession . setAttribute ( sortForm . getSortState ( ) , sortStateBean ) ; \nreturn ( mapping . findForward ( \"success\" ) ) ; \n} \n} \n"}
{"10330": "public class DebugTag { \npublic String getCookies ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nCookie [ ] cookies = req . getCookies ( ) ; \nif ( cookies != null ) { \n{ \nint i = 0 ; \nwhile ( i < cookies . length ) { \nCookie cooky = cookies [ i ] ; \ninfo . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; \ni ++ ; \n} \n} \n} \nreturn toHTMLTable ( \"cookies\" , info ) ; \n} \n} \n"}
{"10331": "public class DebugTag { \npublic String getParameters ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString name = ( String ) names . nextElement ( ) ; \nString [ ] values = req . getParameterValues ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \n{ \nint i = 0 ; \nwhile ( i < values . length ) { \nif ( i != 0 ) { \nsb . append ( \" | \" ) ; \n} \nsb . append ( values [ i ] ) ; \ni ++ ; \n} \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"request parameters\" , info ) ; \n} \n} \n"}
{"10338": "public class DebugTag { \nprivate String toHTMLTable ( String propName , Map values ) { \nStringBuffer tableSB = new StringBuffer ( ) ; \ntableSB . append ( \"<tr class=\\\"debug\\\"><th class=\\\"debug\\\">\" ) . append ( propName ) . append ( \"</th></tr>\" ) ; \n{ \nIterator it = values . keySet ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nObject o = it . next ( ) ; \nString key = ( String ) o ; \ntableSB . append ( \"<tr class=\\\"debug\\\"><td class=\\\"debug\\\">\" ) . append ( key ) . append ( \"</td><td>\" ) . append ( values . get ( key ) ) . append ( \"</td></tr>\" ) ; \n} \n} \nreturn tableSB . toString ( ) ; \n} \n} \n"}
{"10347": "public class AbstractHeap { \npublic < T > T [ ] toArray ( T [ ] a ) { \nint size = size ( ) ; \nif ( a . length < size ) { \na = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; \n} \nIterator < E > it = iterator ( ) ; \nObject [ ] result = a ; \n{ \nint i = 0 ; \nwhile ( i < size ) { \nresult [ i ] = it . next ( ) ; \ni ++ ; \n} \n} \nif ( a . length > size ) { \na [ size ] = null ; \n} \nreturn a ; \n} \n} \n"}
{"10358": "public class AttributeGridImpl { \nprivate void setColumnAttribute ( AttributeSet attributes , int c ) { \nif ( c >= columnAttributes . size ( ) ) { \n{ \nint i = columnAttributes . size ( ) ; \nwhile ( i <= c ) { \ncolumnAttributes . add ( null ) ; \ni ++ ; \n} \n} \n} \ncolumnAttributes . set ( c , attributes ) ; \n} \n} \n"}
{"10359": "public class AttributeGridImpl { \nprivate void setRowAttribute ( AttributeSet attributes , int r ) { \nif ( r >= rowAttributes . size ( ) ) { \n{ \nint i = rowAttributes . size ( ) ; \nwhile ( i <= r ) { \nrowAttributes . add ( null ) ; \ni ++ ; \n} \n} \n} \nrowAttributes . set ( r , attributes ) ; \n} \n} \n"}
{"10368": "public class VariableReferenceNode { \npublic String getValue ( ) { \n{ \nScopeNode scope = NodeTreeUtils . getParentScope ( this ) ; \nwhile ( scope != null ) { \nExpressionGroupNode value = scope . getVariable ( _name ) ; \nif ( value == null ) { \n{ \nscope = NodeTreeUtils . getParentScope ( scope ) ; \ncontinue ; \n} \n} \nreturn value . toString ( ) ; \nscope = NodeTreeUtils . getParentScope ( scope ) ; \n} \n} \nreturn _name ; \n} \n} \n"}
{"10389": "public class StringUtils { \npublic static String arrayToList ( String [ ] array , String delim ) { \nString result = \"\" ; \n{ \nint i = 0 ; \nwhile ( i < array . length ) { \nresult += array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10390": "public class StringUtils { \npublic static String toCamelCase ( String name ) { \nString [ ] parts = name . split ( \"_\" ) ; \nString result = parts [ 0 ] ; \n{ \nint i = 1 ; \nwhile ( i < parts . length ) { \nif ( parts [ i ] . length ( ) > 0 ) { \nresult += upperFirstChar ( parts [ i ] ) ; \n} \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; \nelse result . append ( Character . toLowerCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \n{ \nint i = 0 ; \nwhile ( i < value . length ( ) ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse if ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \ni ++ ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10396": "public class HierarchyAttribute { \npublic boolean isSubCategory ( HierarchyAttribute comp ) { \nif ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { \nreturn false ; \n} \nList < String > otherPath = comp . getPathValue ( ) ; \nList < String > path = getPathValue ( ) ; \nif ( otherPath . size ( ) <= path . size ( ) ) { \nreturn false ; \n} \nboolean subcat = true ; \n{ \nint i = 0 ; \nwhile ( i < path . size ( ) ) { \nif ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { \nsubcat = false ; \nbreak ; \n} \ni ++ ; \n} \n} \nreturn subcat ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( parentNode == null ) { \nint h = 0 ; \n{ \nint j = 0 ; \nwhile ( j < 3 ) { \n{ \nint i = 0 ; \nwhile ( i < 3 ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nint goalX = state . getGoalXForTile ( nextTile ) ; \nint goalY = state . getGoalYForTile ( nextTile ) ; \nint diffX = goalX - i ; \ndiffX = ( diffX < 0 ) ? - diffX : diffX ; \nint diffY = goalY - j ; \ndiffY = ( diffY < 0 ) ? - diffY : diffY ; \nh += diffX + diffY ; \ni ++ ; \n} \n} \nj ++ ; \n} \n} \nreturn ( float ) h ; \n} \nelse { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nint emptyX = parentState . getEmptyX ( ) ; \nint emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nint oldX = 0 ; \nint oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nint change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nint goalX = state . getGoalXForTile ( movedTile ) ; \nint newX = emptyX ; \nint oldDiffX = oldX - goalX ; \noldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; \nint newDiffX = newX - goalX ; \nnewDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nint goalY = state . getGoalYForTile ( movedTile ) ; \nint newY = emptyY ; \nint oldDiffY = oldY - goalY ; \noldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; \nint newDiffY = newY - goalY ; \nnewDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \n} \n} \n"}
{"10406": "public class HTMLFilter { \npublic void write ( String str , int off , int len ) throws IOException { \nString inputString = str . substring ( off , off + len ) ; \nStringBuffer outputString = new StringBuffer ( ) ; \n{ \nStringTokenizer tokenizer = new StringTokenizer ( inputString , \"\\n\" , true ) ; \nwhile ( tokenizer . hasMoreTokens ( ) ) { \nString nextToken = tokenizer . nextToken ( ) ; \nif ( \"\\n\" . equals ( nextToken ) ) { \noutputString . append ( \"<br>\" ) ; \n} \nelse { \noutputString . append ( nextToken ) ; \n} \n} \n} \nout . write ( outputString . toString ( ) ) ; \n} \n} \n"}
{"10448": "public class NestedMediaQueries { \n@ Override public boolean enter ( RuleSetNode ruleSetNode ) { \nScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; \nSelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; \nif ( selectorGroupNode == null ) { \nreturn true ; \n} \nList < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; \nif ( selectorNodes . size ( ) < 0 ) { \nreturn true ; \n} \nList < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; \nfor ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { \nScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; \nList < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; \nif ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { \nRuleSetNode newRuleSetNode = new RuleSetNode ( ) ; \nScopeNode newScopeNode = new ScopeNode ( ) ; \nnewRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; \nnewRuleSetNode . addChild ( newScopeNode ) ; \nNodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; \nmediaScopeNode . clearChildren ( ) ; \nmediaScopeNode . addChild ( newRuleSetNode ) ; \n} \nfor ( RuleSetNode nestedRuleSet : nestedRuleSets ) { \nList < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; \nfor ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { \nList < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; \nNodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; \nfor ( SelectorNode selectorNode : selectorNodes ) { \nfor ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; \nselectorSegmentNode . setCombinator ( \" \" ) ; \n} \n} \n{ \nint j = selectorNode . getChildren ( ) . size ( ) - 1 ; \nwhile ( j >= 0 ) { \nif ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; \nnestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; \n} \nj -- ; \n} \n} \nnestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; \nnestedSelectorGroupNode . addChild ( new SpacingNode ( \" \" ) ) ; \n} \n} \n} \nmediaScopeNode . addChild ( nestedRuleSet ) ; \n} \nif ( ruleSetNode . getParent ( ) != null ) { \nruleSetNode . getParent ( ) . addChild ( new SpacingNode ( \"\\n\" ) ) ; \nruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10457": "public class ScopeNode { \npublic ScopeNode callMixin ( String name , ArgumentsNode arguments ) { \nList < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; \nif ( argumentList . size ( ) > _parameterDefinitions . size ( ) ) { \nthrow new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; \n} \nScopeNode mixinScope = clone ( ) ; \nNodeTreeUtils . filterLineBreaks ( mixinScope ) ; \n{ \nint i = 0 ; \nwhile ( i < argumentList . size ( ) ) { \nExpressionGroupNode argument = argumentList . get ( i ) ; \nVariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; \nparameter . clearChildren ( ) ; \nparameter . addChild ( argument ) ; \ni ++ ; \n} \n} \ngetParent ( ) . setVisible ( false ) ; \nreturn mixinScope ; \n} \n} \n"}
{"10462": "public class WAMResolvingMachine { \nprotected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { \nTerm result = null ; \nint addr = deref ( start ) ; \nbyte tag = getDerefTag ( ) ; \nint val = getDerefVal ( ) ; \nswitch ( tag ) { \ncase REF : { \nVariable var = variableContext . get ( val ) ; \nif ( var == null ) { \nvar = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; \nvariableContext . put ( val , var ) ; \n} \nresult = var ; \nbreak ; \n} \ncase STR : { \nint fn = getHeap ( val ) ; \nint f = fn & 0x00ffffff ; \nFunctorName functorName = getDeinternedFunctorName ( f ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \n{ \nint i = 0 ; \nwhile ( i < arity ) { \narguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; \ni ++ ; \n} \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ncase WAMInstruction . CON : { \nint f = val & 0x3fffffff ; \nresult = new Functor ( f , null ) ; \nbreak ; \n} \ncase WAMInstruction . LIS : { \nFunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; \nint f = internFunctorName ( functorName ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \n{ \nint i = 0 ; \nwhile ( i < arity ) { \narguments [ i ] = decodeHeap ( val + i , variableContext ) ; \ni ++ ; \n} \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ndefault : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \n{ \nwhile ( currentLevel < n ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nbreak ; \n} \nelse if ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \ncurrentLevel ++ ; \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nif ( first == null ) { \nreturn null ; \n} \nelse { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \n} \nelse if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n} \n"}
{"10497": "public class ScriptGenMojo { \nprotected String appendClasspath ( String commandLine , boolean unix ) { \nString pathSeperator ; \nString seperator ; \nif ( unix ) { \npathSeperator = \"/\" ; \nseperator = \":\" ; \n} \nelse { \npathSeperator = \"\\\\\" ; \nseperator = \";\" ; \n} \n{ \nIterator i = classpathElements . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nString cpPath = ( String ) i . next ( ) ; \ncpPath = cpPath . replace ( \"/\" , pathSeperator ) ; \ncommandLine += cpPath + ( i . hasNext ( ) ? seperator : \"\" ) ; \n} \n} \nreturn commandLine ; \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \"false. \" ) ; \nreturn ; \n} \n{ \nwhile ( i . hasNext ( ) ) { \nSet < Variable > solution = i . next ( ) ; \nif ( solution . isEmpty ( ) ) { \nSystem . out . print ( \"true\" ) ; \n} \nelse { \n{ \nIterator < Variable > j = solution . iterator ( ) ; \nwhile ( j . hasNext ( ) ) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \nSystem . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; \nif ( j . hasNext ( ) ) { \nSystem . out . println ( ) ; \n} \n} \n} \n} \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \".\" ) ; \nbreak ; \n} \ntry { \nint key = consoleReader . readVirtualKey ( ) ; \nif ( key == SEMICOLON ) { \nSystem . out . println ( \" ;\" ) ; \n} \nelse { \nSystem . out . println ( ) ; \nbreak ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { \nint newStart ; \n{ \nnewStart = start ; \nwhile ( ( newStart <= end ) && ( newStart <= key ) ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \nnewStart ++ ; \n} \n} \n{ \nwhile ( newStart <= end ) { \nif ( data [ offset ( newStart ) ] != null ) { \nbreak ; \n} \nnewStart ++ ; \n} \n} \nstart = newStart ; \n} \nelse { \nint newStart ; \n{ \nnewStart = start ; \nwhile ( ( newStart <= end ) ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \nnewStart ++ ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \n} \n} \n"}
{"10519": "public class DynamicOperatorParser { \npublic Term parseOperators ( Term [ ] terms ) throws SourceCodeException { \nstack . offer ( 0 ) ; \nstate = 0 ; \nposition = 0 ; \nnextTerm = null ; \n{ \nposition = 0 ; \nwhile ( position <= terms . length ) { \nSymbol nextSymbol ; \nif ( position < terms . length ) { \nnextTerm = terms [ position ] ; \nif ( nextTerm instanceof CandidateOpSymbol ) { \nnextSymbol = Symbol . Op ; \n} \nelse { \nnextSymbol = Symbol . Term ; \n} \n} \nelse { \nnextSymbol = Symbol . Final ; \n} \nAction action = actionTable [ state ] [ nextSymbol . ordinal ( ) ] ; \naction . apply ( ) ; \n} \n} \nreturn ( Functor ) outputStack . poll ( ) ; \n} \n} \n"}
{"10523": "public class CommandLineParser { \npublic static String rightPad ( String stringToPad , String padder , int size ) { \nif ( padder . length ( ) == 0 ) { \nreturn stringToPad ; \n} \nStringBuffer strb = new StringBuffer ( stringToPad ) ; \nCharacterIterator sci = new StringCharacterIterator ( padder ) ; \nwhile ( strb . length ( ) < size ) { \n{ \nchar ch = sci . first ( ) ; \nwhile ( ch != CharacterIterator . DONE ) { \nif ( strb . length ( ) < size ) { \nstrb . append ( String . valueOf ( ch ) ) ; \n} \nch = sci . next ( ) ; \n} \n} \n} \nreturn strb . toString ( ) ; \n} \n} \n"}
{"10530": "public class CommandLineParser { \nprivate Properties takeFreeArgsAsProperties ( Properties properties , int from ) { \nProperties result = new Properties ( ) ; \n{ \nint i = from ; \nwhile ( true ) { \nString nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; \nif ( nextFreeArg == null ) { \nbreak ; \n} \nString [ ] nameValuePair = nextFreeArg . split ( \"=\" ) ; \nif ( nameValuePair . length == 2 ) { \nresult . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; \n} \ni ++ ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10533": "public class PTStemmer { \npublic Enumeration listOptions ( ) { \nVector < Option > result ; \nString desc ; \nSelectedTag tag ; \nint i ; \nresult = new Vector < Option > ( ) ; \ndesc = \"\" ; \n{ \ni = 0 ; \nwhile ( i < TAGS_STEMMERS . length ) { \ntag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; \ndesc += \"\\t\" + tag . getSelectedTag ( ) . getIDStr ( ) + \" = \" + tag . getSelectedTag ( ) . getReadable ( ) + \"\\n\" ; \ni ++ ; \n} \n} \nresult . addElement ( new Option ( \"\\tThe type of stemmer algorithm to use:\\n\" + desc + \"\\t(default: \" + new SelectedTag ( STEMMER_ORENGO , TAGS_STEMMERS ) + \")\" , \"S\" , 1 , \"-S \" + Tag . toOptionList ( TAGS_STEMMERS ) ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the named entities to ignore (optional).\\n\" + \"\\tFile format: simple text file with one entity per line.\\n\" + \"\\t(default: none)\\n\" , \"N\" , 1 , \"-N <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the stopwords (optional).\\n\" + \"\\tFile format: simple text file with one stopword per line.\\n\" + \"\\t(default: none)\\n\" , \"W\" , 1 , \"-W <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe size of the cache. Disable with 0.\\n\" + \"\\t(default: 1000)\\n\" , \"C\" , 1 , \"-C <int>\" ) ) ; \nreturn result . elements ( ) ; \n} \n} \n"}
{"10547": "public class WAMResolvingJavaMachine { \nprivate void unwindTrail ( int a1 , int a2 ) { \n{ \nint addr = a1 ; \nwhile ( addr < a2 ) { \nint tmp = data . get ( addr ) ; \ndata . put ( tmp , refTo ( tmp ) ) ; \naddr ++ ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \n{ \nint i = 1 ; \nwhile ( i <= n1 ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \ni ++ ; \n} \n} \n} \nelse { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . CON ) { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10553": "public class EightPuzzleState { \npublic static boolean isSolvable ( EightPuzzleState state ) { \nEightPuzzleState checkState ; \ntry { \ncheckState = ( EightPuzzleState ) state . clone ( ) ; \n} \ncatch ( CloneNotSupportedException e ) { \nthrow new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; \n} \nEightPuzzleState goalState = getGoalState ( ) ; \nint illegalSwaps = 0 ; \n{ \nint j = 0 ; \nwhile ( j < 3 ) { \n{ \nint i = 0 ; \nwhile ( i < 3 ) { \nchar t = goalState . getTileAt ( i , j ) ; \nillegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; \ni ++ ; \n} \n} \nj ++ ; \n} \n} \nreturn ( illegalSwaps % 2 ) == 0 ; \n} \n} \n"}
{"10556": "public class EightPuzzleState { \npublic String prettyPrint ( ) { \nString result = \"\" ; \n{ \nint j = 0 ; \nwhile ( j < 3 ) { \nresult += new String ( board [ j ] ) + \"\\n\" ; \nj ++ ; \n} \n} \nresult = result . replace ( 'E' , ' ' ) ; \nreturn result ; \n} \n} \n"}
{"10559": "public class EightPuzzleState { \nprivate static List < Character > stringToCharList ( String boardString ) { \nchar [ ] chars = new char [ 9 ] ; \nboardString . getChars ( 0 , 9 , chars , 0 ) ; \nList < Character > charList = new ArrayList < Character > ( ) ; \n{ \nint l = 0 ; \nwhile ( l < 9 ) { \ncharList . add ( chars [ l ] ) ; \nl ++ ; \n} \n} \nreturn charList ; \n} \n} \n"}
{"10560": "public class EightPuzzleState { \nprivate static EightPuzzleState charListToState ( List < Character > charList ) { \nEightPuzzleState newState = new EightPuzzleState ( ) ; \nIterator < Character > k = charList . iterator ( ) ; \n{ \nint j = 0 ; \nwhile ( j < 3 ) { \n{ \nint i = 0 ; \nwhile ( i < 3 ) { \nchar nextChar = k . next ( ) ; \nif ( nextChar == 'E' ) { \nnewState . emptyX = i ; \nnewState . emptyY = j ; \n} \nnewState . board [ j ] [ i ] = nextChar ; \ni ++ ; \n} \n} \nj ++ ; \n} \n} \nreturn newState ; \n} \n} \n"}
{"10572": "public class Sizeof { \nprivate static void runGCTillStable ( ) { \nlong usedMem1 = usedMemory ( ) ; \nlong usedMem2 = Long . MAX_VALUE ; \n{ \nint i = 0 ; \nwhile ( ( usedMem1 < usedMem2 ) && ( i < 500 ) ) { \nRUNTIME . runFinalization ( ) ; \nRUNTIME . gc ( ) ; \nThread . currentThread ( ) . yield ( ) ; \nusedMem2 = usedMem1 ; \nusedMem1 = usedMemory ( ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"10597": "public class Searches { \nprivate static < T > void findAll ( Collection < T > result , SearchMethod < T > method ) { \n{ \nIterator < T > i = allSolutions ( method ) ; \nwhile ( i . hasNext ( ) ) { \nT nextSoltn = i . next ( ) ; \nresult . add ( nextSoltn ) ; \n} \n} \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \nelse { \nif ( arguments == null ) { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \nelse if ( ! reverse ) { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \n{ \nint i = arity - 1 ; \nwhile ( i >= 0 ) { \nargList . add ( arguments [ i ] ) ; \ni -- ; \n} \n} \nreturn argList . iterator ( ) ; \n} \n} \n} \n} \n"}
{"10620": "public class Functor { \nprotected String toStringArguments ( ) { \nString result = \"\" ; \nif ( arity > 0 ) { \nresult += \"[ \" ; \n{ \nint i = 0 ; \nwhile ( i < arity ) { \nTerm nextArg = arguments [ i ] ; \nresult += ( ( nextArg != null ) ? nextArg . toString ( ) : \"<null>\" ) + ( ( i < ( arity - 1 ) ) ? \", \" : \" \" ) ; \ni ++ ; \n} \n} \nresult += \" ]\" ; \n} \nreturn result ; \n} \n} \n"}
{"10650": "public class OrFilter { \npublic void addFilter ( PacketFilter filter ) { \nif ( filter == null ) { \nthrow new IllegalArgumentException ( \"Parameter cannot be null.\" ) ; \n} \nif ( size == filters . length ) { \nPacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; \n{ \nint i = 0 ; \nwhile ( i < filters . length ) { \nnewFilters [ i ] = filters [ i ] ; \ni ++ ; \n} \n} \nfilters = newFilters ; \n} \nfilters [ size ] = filter ; \nsize ++ ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) return false ; \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( length > 0 ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \n{ \nint i = 0 ; \nwhile ( i < length ) { \nif ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; \ni ++ ; \n} \n} \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"10668": "public class TransactionalHashMap { \n@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { \nint numKeysToBeAdded = m . size ( ) ; \nif ( numKeysToBeAdded == 0 ) return ; \nif ( numKeysToBeAdded > threshold ) { \nint targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; \nif ( targetCapacity > MAXIMUM_CAPACITY ) targetCapacity = MAXIMUM_CAPACITY ; \nint newCapacity = table . length ; \nwhile ( newCapacity < targetCapacity ) newCapacity <<= 1 ; \nif ( newCapacity > table . length ) resize ( newCapacity ) ; \n} \n{ \nIterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nMap . Entry < ? extends K , ? extends V > e = i . next ( ) ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \n} \n} \n} \n"}
{"10719": "public class ObservableWriter { \nprivate void notifyListeners ( String str ) { \nWriterListener [ ] writerListeners = null ; \nsynchronized ( listeners ) { \nwriterListeners = new WriterListener [ listeners . size ( ) ] ; \nlisteners . toArray ( writerListeners ) ; \n} \n{ \nint i = 0 ; \nwhile ( i < writerListeners . length ) { \nwriterListeners [ i ] . write ( str ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) { \nname = \"\" ; \n} \nelse { \nname += \".\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \n{ \nint i = 0 ; \nwhile ( i < dirs . length ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \ni ++ ; \n} \n} \n} \n} \n"}
{"10730": "public class CF_Locator { \nprivate void includeJar ( File file ) { \nif ( file . isDirectory ( ) ) { \nreturn ; \n} \nURL jarURL = null ; \nJarFile jar = null ; \ntry { \njarURL = new URL ( \"jar:\" + new URL ( \"file:/\" + file . getCanonicalPath ( ) ) . toExternalForm ( ) + \"!/\" ) ; \nJarURLConnection conn = ( JarURLConnection ) jarURL . openConnection ( ) ; \njar = conn . getJarFile ( ) ; \n} \ncatch ( MalformedURLException ignore ) { \nreturn ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \nif ( jar == null ) { \nreturn ; \n} \ntry { \nthis . locationMap . put ( jarURL . toURI ( ) , \"\" ) ; \n} \ncatch ( URISyntaxException ignore ) { \n} \n{ \nEnumeration < JarEntry > e = jar . entries ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nJarEntry entry = e . nextElement ( ) ; \nif ( this . pkgFilter != null && entry . getName ( ) . startsWith ( this . pkgFilter ) ) { \n{ \ncontinue ; \n} \n} \nif ( entry . isDirectory ( ) ) { \nif ( entry . getName ( ) . toUpperCase ( Locale . ENGLISH ) . equals ( \"META-INF/\" ) ) { \n{ \ncontinue ; \n} \n} \ntry { \nthis . locationMap . put ( new URI ( jarURL . toExternalForm ( ) + entry . getName ( ) ) , CF_Utils . getPkgName ( entry ) ) ; \n} \ncatch ( URISyntaxException ignore ) { \n{ \ncontinue ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"10775": "public class CF { \nprotected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \nString [ ] files = directory . list ( ) ; \n{ \nint i = 0 ; \nwhile ( i < files . length ) { \nif ( files [ i ] . endsWith ( \".class\" ) ) { \nString classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; \ntry { \nClass < ? > c = Class . forName ( packageName + \".\" + classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + \".\" + classname ) ) { \nret . put ( c , location ) ; \n} \n} \ncatch ( Exception ex ) { \nerrors . add ( ex ) ; \n} \n} \ni ++ ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"10776": "public class CF { \nprotected final Map < Class < ? > , URI > searchJar ( Class < ? > clazz , URI location ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \ntry { \nJarURLConnection conn = ( JarURLConnection ) location . toURL ( ) . openConnection ( ) ; \nJarFile jarFile = conn . getJarFile ( ) ; \n{ \nEnumeration < JarEntry > e = jarFile . entries ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nJarEntry entry = e . nextElement ( ) ; \nString entryname = entry . getName ( ) ; \nif ( this . processed . contains ( entryname ) ) { \n{ \ncontinue ; \n} \n} \nthis . processed . add ( entryname ) ; \nif ( ! entry . isDirectory ( ) && entryname . endsWith ( \".class\" ) ) { \nString classname = entryname . substring ( 0 , entryname . length ( ) - 6 ) ; \nif ( classname . startsWith ( \"/\" ) ) { \nclassname = classname . substring ( 1 ) ; \n} \nclassname = classname . replace ( '/' , '.' ) ; \nif ( ! StringUtils . startsWithAny ( classname , this . excludedNames ) ) { \ntry { \nClass < ? > c = Class . forName ( classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( classname ) ) { \nret . put ( c , location ) ; \n} \n} \ncatch ( Exception exception ) { \nerrors . add ( exception ) ; \n} \ncatch ( Error error ) { \nerrors . add ( error ) ; \n} \n} \n} \n} \n} \n} \ncatch ( IOException ignore ) { \nerrors . add ( ignore ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10778": "public class HashMap3 { \npublic int size ( ) { \nint result = 0 ; \n{ \nIterator < K1 > keys1 = maps . keySet ( ) . iterator ( ) ; \nwhile ( keys1 . hasNext ( ) ) { \nMap2 < K2 , K3 , V > inner_map = maps . get ( keys1 . next ( ) ) ; \nresult += inner_map . size ( ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse if ( parts . length == 1 ) { \nfieldName = parts [ 0 ] ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \n{ \nint i = 0 ; \nwhile ( i < l ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \ni ++ ; \n} \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \n{ \nint index = FIRST_INDEX ; \nwhile ( index < NUMBER_OF_INDICES ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \nindex ++ ; \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10875": "public class TransactionalBidiTreeMap { \n@ Override public void clear ( ) { \nif ( auto_commit ) { \nmodify ( ) ; \nnodeCount = 0 ; \nrootNode [ KEY ] = null ; \nrootNode [ VALUE ] = null ; \n} \nelse { \nString thread_id = getCurrentThreadId ( ) ; \nArrayList < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( entrySet ( ) ) ; \n{ \nIterator < Entry < K , V > > i = list . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nNode < K , V > node = ( Node < K , V > ) i . next ( ) ; \nif ( node . is ( Node . ADDED , thread_id ) ) doRedBlackDelete ( node ) ; \nelse { \nnode . setStatus ( Node . DELETED , thread_id ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10879": "public class TransactionalBidiTreeMap { \npublic final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { \nK key ; \nV val ; \nint transaction_status ; \nString transaction_id ; \nnew_map . setAutoCommit ( isAutoCommit ( ) ) ; \nif ( ! isAutoCommit ( ) ) { \n{ \nIterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { \ntry { \nnew_map . put ( key , val ) ; \nnew_map . commit ( ) ; \n} \ncatch ( Exception e ) { \n} \ntry { \nif ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { \nnew_map . attach ( transaction_id ) ; \nnew_map . remove ( key ) ; \n} \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \n} \n{ \nIterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { \nnew_map . attach ( transaction_id ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \n} \n} \nelse { \n{ \nIterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n} \n} \n"}
{"10881": "public class Cache { \nprotected synchronized void cullCache ( ) { \nif ( maxCacheSize < 0 ) { \nreturn ; \n} \nif ( map . size ( ) > maxCacheSize ) { \ndeleteExpiredEntries ( ) ; \nint desiredSize = ( int ) ( maxCacheSize * .90 ) ; \n{ \nint i = map . size ( ) ; \nwhile ( i > desiredSize ) { \nif ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { \nlog . warn ( \"Error attempting to cullCache with remove(\" + lastAccessedList . getLast ( ) . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nlastAccessedList . getLast ( ) . remove ( ) ; \n} \ni -- ; \n} \n} \n} \n} \n} \n"}
{"10887": "public class IPv4Scanner { \npublic static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { \nif ( subnetBits < 1 || 32 <= subnetBits ) { \nthrow new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \n} \nlong mask = 1 ; \n{ \nint i = 0 ; \nwhile ( i < 32 ) { \nmask <<= 1 ; \nmask |= i < subnetBits ? 1 : 0 ; \ni ++ ; \n} \n} \nlong host0 = asLongAddress ( addr ) & mask ; \ntry { \nreturn asInetAddress ( host0 ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \n} \n"}
{"10924": "public class Playlist { \npublic HashMap < String , Object > export ( ) { \nHashMap < String , Object > data = new HashMap < > ( ) ; \n{ \nint i = 0 ; \nwhile ( i < queue . size ( ) ) { \ndata . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; \ni ++ ; \n} \n} \n{ \nint i = 0 ; \nwhile ( i < playbackModes . size ( ) ) { \ndata . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; \ni ++ ; \n} \n} \ndata . put ( NAME_DESCRIPTOR , name ) ; \ndata . put ( POSITION_DESCRIPTOR , position ) ; \ndata . put ( DATA_DESCRIPTOR , this . data ) ; \nreturn data ; \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nchar ch ; \nint i = 0 ; \nint last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nint len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \n{ \nwhile ( i < len ) { \nch = input [ i ] ; \nif ( ch > '>' ) { \n{ \ni ++ ; \ncontinue ; \n} \n} \nelse if ( ch == '<' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse if ( ch == '>' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse if ( ch == '&' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nif ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse if ( ch == '\"' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \ni ++ ; \n} \n} \nif ( last == 0 ) { \nreturn string ; \n} \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) { \n{ \nint i = 0 , isize = data . length ; \nwhile ( i < isize ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) { \nreturn true ; \n} \nentry = entry . next ; \n} \ni ++ ; \n} \n} \n} \nelse { \n{ \nint i = 0 , isize = data . length ; \nwhile ( i < isize ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \ni ++ ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10943": "public class AbstractHashedMap { \npublic void clear ( ) { \nmodCount ++ ; \nHashEntry [ ] data = this . data ; \n{ \nint i = data . length - 1 ; \nwhile ( i >= 0 ) { \ndata [ i ] = null ; \ni -- ; \n} \n} \nsize = 0 ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nint oldCapacity = data . length ; \nif ( newCapacity <= oldCapacity ) { \nreturn ; \n} \nif ( size == 0 ) { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \nelse { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount ++ ; \n{ \nint i = oldCapacity - 1 ; \nwhile ( i >= 0 ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nint index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \ni -- ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \n} \n} \n"}
