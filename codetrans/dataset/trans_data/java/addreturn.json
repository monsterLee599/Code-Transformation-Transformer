{"0": "public class QueueDrainObserver { \nprotected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { \nfinal Observer < ? super V > observer = downstream ; \nfinal SimplePlainQueue < U > q = queue ; \nif ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { \nif ( q . isEmpty ( ) ) { \naccept ( observer , value ) ; \nif ( leave ( - 1 ) == 0 ) { \nreturn ; \n} \n} \nelse { \nq . offer ( value ) ; \n} \n} \nelse { \nq . offer ( value ) ; \nif ( ! enter ( ) ) { \nreturn ; \n} \n} \nQueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; \nreturn ; \n} \n} \n"}
{"8": "public class RxJavaPlugins { \npublic static void reset ( ) { \nsetErrorHandler ( null ) ; \nsetScheduleHandler ( null ) ; \nsetComputationSchedulerHandler ( null ) ; \nsetInitComputationSchedulerHandler ( null ) ; \nsetIoSchedulerHandler ( null ) ; \nsetInitIoSchedulerHandler ( null ) ; \nsetSingleSchedulerHandler ( null ) ; \nsetInitSingleSchedulerHandler ( null ) ; \nsetNewThreadSchedulerHandler ( null ) ; \nsetInitNewThreadSchedulerHandler ( null ) ; \nsetOnFlowableAssembly ( null ) ; \nsetOnFlowableSubscribe ( null ) ; \nsetOnObservableAssembly ( null ) ; \nsetOnObservableSubscribe ( null ) ; \nsetOnSingleAssembly ( null ) ; \nsetOnSingleSubscribe ( null ) ; \nsetOnCompletableAssembly ( null ) ; \nsetOnCompletableSubscribe ( null ) ; \nsetOnConnectableFlowableAssembly ( null ) ; \nsetOnConnectableObservableAssembly ( null ) ; \nsetOnMaybeAssembly ( null ) ; \nsetOnMaybeSubscribe ( null ) ; \nsetOnParallelAssembly ( null ) ; \nsetFailOnNonBlockingScheduler ( false ) ; \nsetOnBeforeBlocking ( null ) ; \nreturn ; \n} \n} \n"}
{"24": "public class QueueDrainHelper { \npublic static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { \nint missed = 1 ; \nfor ( ; \n; \n) { \nfor ( ; \n; \n) { \nboolean d = qd . done ( ) ; \nT v = q . poll ( ) ; \nboolean empty = v == null ; \nif ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \nreturn ; \n} \nif ( empty ) { \nbreak ; \n} \nlong r = qd . requested ( ) ; \nif ( r != 0L ) { \nif ( qd . accept ( a , v ) ) { \nif ( r != Long . MAX_VALUE ) { \nqd . produced ( 1 ) ; \n} \n} \n} \nelse { \nq . clear ( ) ; \nif ( dispose != null ) { \ndispose . dispose ( ) ; \n} \na . onError ( new MissingBackpressureException ( \"Could not emit value due to lack of requests.\" ) ) ; \nreturn ; \n} \n} \nmissed = qd . leave ( - missed ) ; \nif ( missed == 0 ) { \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"25": "public class QueueDrainHelper { \npublic static void request ( Subscription s , int prefetch ) { \ns . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; \nreturn ; \n} \n} \n"}
{"26": "public class QueueDrainHelper { \npublic static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { \nif ( queue . isEmpty ( ) ) { \nactual . onComplete ( ) ; \nreturn ; \n} \nif ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { \nreturn ; \n} \nfor ( ; \n; \n) { \nlong r = state . get ( ) ; \nif ( ( r & COMPLETED_MASK ) != 0L ) { \nreturn ; \n} \nlong u = r | COMPLETED_MASK ; \nif ( state . compareAndSet ( r , u ) ) { \nif ( r != 0L ) { \npostCompleteDrain ( u , actual , queue , state , isCancelled ) ; \n} \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"27": "public class SinglePostCompleteSubscriber { \nprotected final void complete ( R n ) { \nlong p = produced ; \nif ( p != 0 ) { \nBackpressureHelper . produced ( this , p ) ; \n} \nfor ( ; \n; \n) { \nlong r = get ( ) ; \nif ( ( r & COMPLETE_MASK ) != 0 ) { \nonDrop ( n ) ; \nreturn ; \n} \nif ( ( r & REQUEST_MASK ) != 0 ) { \nlazySet ( COMPLETE_MASK + 1 ) ; \ndownstream . onNext ( n ) ; \ndownstream . onComplete ( ) ; \nreturn ; \n} \nvalue = n ; \nif ( compareAndSet ( 0 , COMPLETE_MASK ) ) { \nreturn ; \n} \nvalue = null ; \n} \nreturn ; \n} \n} \n"}
{"38": "public class LinkedArrayList { \npublic void add ( Object o ) { \nif ( size == 0 ) { \nhead = new Object [ capacityHint + 1 ] ; \ntail = head ; \nhead [ 0 ] = o ; \nindexInTail = 1 ; \nsize = 1 ; \n} \nelse if ( indexInTail == capacityHint ) { \nObject [ ] t = new Object [ capacityHint + 1 ] ; \nt [ 0 ] = o ; \ntail [ capacityHint ] = t ; \ntail = t ; \nindexInTail = 1 ; \nsize ++ ; \n} \nelse { \ntail [ indexInTail ] = o ; \nindexInTail ++ ; \nsize ++ ; \n} \nreturn ; \n} \n} \n"}
{"39": "public class SchedulerPoolFactory { \npublic static void shutdown ( ) { \nScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; \nif ( exec != null ) { \nexec . shutdownNow ( ) ; \n} \nPOOLS . clear ( ) ; \nreturn ; \n} \n} \n"}
{"41": "public class SubscriptionArbiter { \npublic final void setSubscription ( Subscription s ) { \nif ( cancelled ) { \ns . cancel ( ) ; \nreturn ; \n} \nObjectHelper . requireNonNull ( s , \"s is null\" ) ; \nif ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { \nSubscription a = actual ; \nif ( a != null && cancelOnReplace ) { \na . cancel ( ) ; \n} \nactual = s ; \nlong r = requested ; \nif ( decrementAndGet ( ) != 0 ) { \ndrainLoop ( ) ; \n} \nif ( r != 0L ) { \ns . request ( r ) ; \n} \nreturn ; \n} \nSubscription a = missedSubscription . getAndSet ( s ) ; \nif ( a != null && cancelOnReplace ) { \na . cancel ( ) ; \n} \ndrain ( ) ; \nreturn ; \n} \n} \n"}
{"42": "public class SerializedSubject { \nvoid emitLoop ( ) { \nfor ( ; \n; \n) { \nAppendOnlyLinkedArrayList < Object > q ; \nsynchronized ( this ) { \nq = queue ; \nif ( q == null ) { \nemitting = false ; \nreturn ; \n} \nqueue = null ; \n} \nq . forEachWhile ( this ) ; \n} \nreturn ; \n} \n} \n"}
{"46": "public class CompositeDisposable { \npublic void clear ( ) { \nif ( disposed ) { \nreturn ; \n} \nOpenHashSet < Disposable > set ; \nsynchronized ( this ) { \nif ( disposed ) { \nreturn ; \n} \nset = resources ; \nresources = null ; \n} \ndispose ( set ) ; \nreturn ; \n} \n} \n"}
{"52": "public class MulticastProcessor { \npublic void start ( ) { \nif ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { \nqueue = new SpscArrayQueue < T > ( bufferSize ) ; \n} \nreturn ; \n} \n} \n"}
{"53": "public class MulticastProcessor { \npublic void startUnbounded ( ) { \nif ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { \nqueue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; \n} \nreturn ; \n} \n} \n"}
{"56": "public class DeferredScalarDisposable { \npublic final void complete ( T value ) { \nint state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nreturn ; \n} \nObserver < ? super T > a = downstream ; \nif ( state == FUSED_EMPTY ) { \nthis . value = value ; \nlazySet ( FUSED_READY ) ; \na . onNext ( null ) ; \n} \nelse { \nlazySet ( TERMINATED ) ; \na . onNext ( value ) ; \n} \nif ( get ( ) != DISPOSED ) { \na . onComplete ( ) ; \n} \nreturn ; \n} \n} \n"}
{"57": "public class DeferredScalarDisposable { \npublic final void error ( Throwable t ) { \nint state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nRxJavaPlugins . onError ( t ) ; \nreturn ; \n} \nlazySet ( TERMINATED ) ; \ndownstream . onError ( t ) ; \nreturn ; \n} \n} \n"}
{"58": "public class DeferredScalarDisposable { \npublic final void complete ( ) { \nint state = get ( ) ; \nif ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { \nreturn ; \n} \nlazySet ( TERMINATED ) ; \ndownstream . onComplete ( ) ; \nreturn ; \n} \n} \n"}
{"63": "public class DefaultSubscriber { \nprotected final void request ( long n ) { \nSubscription s = this . upstream ; \nif ( s != null ) { \ns . request ( n ) ; \n} \nreturn ; \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) { \nreturn ; \n} \nint n = a . length ; \nint j = - 1 ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \n} \nif ( j < 0 ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) { \nb = EMPTY ; \n} \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"68": "public class NetworkBehavior { \npublic void setDelay ( long amount , TimeUnit unit ) { \nif ( amount < 0 ) { \nthrow new IllegalArgumentException ( \"Amount must be positive value.\" ) ; \n} \nthis . delayMs = unit . toMillis ( amount ) ; \nreturn ; \n} \n} \n"}
{"71": "public class DataSourcePopulator { \nprivate void createSampleData ( String username , String password ) { \nAssert . notNull ( documentDao , \"DocumentDao required\" ) ; \nAssert . hasText ( username , \"Username required\" ) ; \nAuthentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; \ntry { \nSecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; \nDirectory home = new Directory ( username , Directory . ROOT_DIRECTORY ) ; \ndocumentDao . create ( home ) ; \naddPermission ( documentDao , home , username , LEVEL_GRANT_ADMIN ) ; \naddPermission ( documentDao , home , \"ROLE_USER\" , LEVEL_GRANT_READ ) ; \ncreateFiles ( documentDao , home ) ; \nDirectory confid = new Directory ( \"confidential\" , home ) ; \ndocumentDao . create ( confid ) ; \naddPermission ( documentDao , confid , \"ROLE_USER\" , LEVEL_NEGATE_READ ) ; \ncreateFiles ( documentDao , confid ) ; \nDirectory shared = new Directory ( \"shared\" , home ) ; \ndocumentDao . create ( shared ) ; \naddPermission ( documentDao , shared , \"ROLE_USER\" , LEVEL_GRANT_READ ) ; \naddPermission ( documentDao , shared , \"ROLE_USER\" , LEVEL_GRANT_WRITE ) ; \ncreateFiles ( documentDao , shared ) ; \n} \nfinally { \nSecurityContextHolder . clearContext ( ) ; \n} \nreturn ; \n} \n} \n"}
{"76": "public class SpringSecurityCoreVersion { \nprivate static void performVersionChecks ( String minSpringVersion ) { \nif ( minSpringVersion == null ) { \nreturn ; \n} \nString springVersion = SpringVersion . getVersion ( ) ; \nString version = getVersion ( ) ; \nif ( disableChecks ( springVersion , version ) ) { \nreturn ; \n} \nlogger . info ( \"You are running with Spring Security Core \" + version ) ; \nif ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) < 0 ) { \nlogger . warn ( \"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion ) ; \n} \nreturn ; \n} \n} \n"}
{"89": "public class BasicLookupStrategy { \nprivate void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { \nAssert . notNull ( acls , \"ACLs are required\" ) ; \nAssert . notEmpty ( findNow , \"Items to find now required\" ) ; \nString sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; \nSet < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { \npublic void setValues ( PreparedStatement ps ) throws SQLException { \nint i = 0 ; \nfor ( Long toFind : findNow ) { \ni ++ ; \nps . setLong ( i , toFind ) ; \n} \nreturn ; \n} \n} \n, new ProcessResultSet ( acls , sids ) ) ; \nif ( parentsToLookup . size ( ) > 0 ) { \nlookupPrimaryKeys ( acls , parentsToLookup , sids ) ; \n} \nreturn ; \n} \n} \n"}
{"92": "public class HttpConfigurationBuilder { \nprivate void createServletApiFilter ( BeanReference authenticationManager ) { \nfinal String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\" ; \nfinal String DEF_SERVLET_API_PROVISION = \"true\" ; \nString provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; \nif ( ! StringUtils . hasText ( provideServletApi ) ) { \nprovideServletApi = DEF_SERVLET_API_PROVISION ; \n} \nif ( \"true\" . equals ( provideServletApi ) ) { \nservApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; \nservApiFilter . getPropertyValues ( ) . add ( \"authenticationManager\" , authenticationManager ) ; \n} \nreturn ; \n} \n} \n"}
{"93": "public class HttpConfigurationBuilder { \nprivate void createJaasApiFilter ( ) { \nfinal String ATT_JAAS_API_PROVISION = \"jaas-api-provision\" ; \nfinal String DEF_JAAS_API_PROVISION = \"false\" ; \nString provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; \nif ( ! StringUtils . hasText ( provideJaasApi ) ) { \nprovideJaasApi = DEF_JAAS_API_PROVISION ; \n} \nif ( \"true\" . equals ( provideJaasApi ) ) { \njaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; \n} \nreturn ; \n} \n} \n"}
{"95": "public class AbstractSecurityWebApplicationInitializer { \nprivate void insertSpringSecurityFilterChain ( ServletContext servletContext ) { \nString filterName = DEFAULT_FILTER_NAME ; \nDelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; \nString contextAttribute = getWebApplicationContextAttribute ( ) ; \nif ( contextAttribute != null ) { \nspringSecurityFilterChain . setContextAttribute ( contextAttribute ) ; \n} \nregisterFilter ( servletContext , true , filterName , springSecurityFilterChain ) ; \nreturn ; \n} \n} \n"}
{"99": "public class AbstractPreAuthenticatedProcessingFilter { \n@ Override public void afterPropertiesSet ( ) { \ntry { \nsuper . afterPropertiesSet ( ) ; \n} \ncatch ( ServletException e ) { \nthrow new RuntimeException ( e ) ; \n} \nAssert . notNull ( authenticationManager , \"An AuthenticationManager must be set\" ) ; \nreturn ; \n} \n} \n"}
{"100": "public class AbstractPreAuthenticatedProcessingFilter { \npublic void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Checking secure context token: \" + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; \n} \nif ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { \ndoAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; \n} \nchain . doFilter ( request , response ) ; \nreturn ; \n} \n} \n"}
{"102": "public class AbstractPreAuthenticatedProcessingFilter { \nprivate void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { \nAuthentication authResult ; \nObject principal = getPreAuthenticatedPrincipal ( request ) ; \nObject credentials = getPreAuthenticatedCredentials ( request ) ; \nif ( principal == null ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"No pre-authenticated principal found in request\" ) ; \n} \nreturn ; \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\" ) ; \n} \ntry { \nPreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; \nauthRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; \nauthResult = authenticationManager . authenticate ( authRequest ) ; \nsuccessfulAuthentication ( request , response , authResult ) ; \n} \ncatch ( AuthenticationException failed ) { \nunsuccessfulAuthentication ( request , response , failed ) ; \nif ( ! continueFilterChainOnUnsuccessfulAuthentication ) { \nthrow failed ; \n} \n} \nreturn ; \n} \n} \n"}
{"103": "public class OnCommittedResponseWrapper { \nprivate void checkContentLength ( long contentLengthToWrite ) { \nthis . contentWritten += contentLengthToWrite ; \nboolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; \nint bufferSize = getBufferSize ( ) ; \nboolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; \nif ( isBodyFullyWritten || requiresFlush ) { \ndoOnResponseCommitted ( ) ; \n} \nreturn ; \n} \n} \n"}
{"106": "public class AbstractAuthenticationFilterConfigurer { \nprotected final void updateAuthenticationDefaults ( ) { \nif ( loginProcessingUrl == null ) { \nloginProcessingUrl ( loginPage ) ; \n} \nif ( failureHandler == null ) { \nfailureUrl ( loginPage + \"?error\" ) ; \n} \nfinal LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; \nif ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { \nlogoutConfigurer . logoutSuccessUrl ( loginPage + \"?logout\" ) ; \n} \nreturn ; \n} \n} \n"}
{"107": "public class AbstractAuthenticationFilterConfigurer { \nprotected final void updateAccessDefaults ( B http ) { \nif ( permitAll ) { \nPermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; \n} \nreturn ; \n} \n} \n"}
{"111": "public class AbstractRememberMeServices { \nprotected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { \nString cookieValue = encodeCookie ( tokens ) ; \nCookie cookie = new Cookie ( cookieName , cookieValue ) ; \ncookie . setMaxAge ( maxAge ) ; \ncookie . setPath ( getCookiePath ( request ) ) ; \nif ( cookieDomain != null ) { \ncookie . setDomain ( cookieDomain ) ; \n} \nif ( maxAge < 1 ) { \ncookie . setVersion ( 1 ) ; \n} \nif ( useSecureCookie == null ) { \ncookie . setSecure ( request . isSecure ( ) ) ; \n} \nelse { \ncookie . setSecure ( useSecureCookie ) ; \n} \ncookie . setHttpOnly ( true ) ; \nresponse . addCookie ( cookie ) ; \nreturn ; \n} \n} \n"}
{"116": "public class SecurityContextLogoutHandler { \npublic void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { \nAssert . notNull ( request , \"HttpServletRequest required\" ) ; \nif ( invalidateHttpSession ) { \nHttpSession session = request . getSession ( false ) ; \nif ( session != null ) { \nlogger . debug ( \"Invalidating session: \" + session . getId ( ) ) ; \nsession . invalidate ( ) ; \n} \n} \nif ( clearAuthentication ) { \nSecurityContext context = SecurityContextHolder . getContext ( ) ; \ncontext . setAuthentication ( null ) ; \n} \nSecurityContextHolder . clearContext ( ) ; \nreturn ; \n} \n} \n"}
{"119": "public class ActiveDirectoryLdapAuthenticationProvider { \npublic void setContextEnvironmentProperties ( Map < String , Object > environment ) { \nAssert . notEmpty ( environment , \"environment must not be empty\" ) ; \nthis . contextEnvironmentProperties = new Hashtable < > ( environment ) ; \nreturn ; \n} \n} \n"}
{"122": "public class UserDetailsManagerConfigurer { \n@ Override protected void initUserDetailsService ( ) throws Exception { \nfor ( UserDetailsBuilder userBuilder : userBuilders ) { \ngetUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; \n} \nfor ( UserDetails userDetails : this . users ) { \ngetUserDetailsService ( ) . createUser ( userDetails ) ; \n} \nreturn ; \n} \n} \n"}
{"124": "public class DefaultServerOAuth2AuthorizationRequestResolver { \nprivate void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { \nString codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; \nattributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; \ntry { \nString codeChallenge = createCodeChallenge ( codeVerifier ) ; \nadditionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; \nadditionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , \"S256\" ) ; \n} \ncatch ( NoSuchAlgorithmException e ) { \nadditionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; \n} \nreturn ; \n} \n} \n"}
{"141": "public class MapBasedAttributes2GrantedAuthoritiesMapper { \nprivate void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { \nif ( value == null ) { \nreturn ; \n} \nif ( value instanceof Collection < ? > ) { \naddGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; \n} \nelse if ( value instanceof Object [ ] ) { \naddGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; \n} \nelse if ( value instanceof String ) { \naddGrantedAuthorityCollection ( result , ( String ) value ) ; \n} \nelse if ( value instanceof GrantedAuthority ) { \nresult . add ( ( GrantedAuthority ) value ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid object type: \" + value . getClass ( ) . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"149": "public class PersistentTokenBasedRememberMeServices { \nprotected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { \nString username = successfulAuthentication . getName ( ) ; \nlogger . debug ( \"Creating new persistent login for user \" + username ) ; \nPersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; \ntry { \ntokenRepository . createNewToken ( persistentToken ) ; \naddCookie ( persistentToken , request , response ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Failed to save persistent token \" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"152": "public class SwitchUserFilter { \npublic void setExitUserUrl ( String exitUserUrl ) { \nAssert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , \"exitUserUrl cannot be empty and must be a valid redirect URL\" ) ; \nthis . exitUserMatcher = createMatcher ( exitUserUrl ) ; \nreturn ; \n} \n} \n"}
{"173": "public class MapBasedMethodSecurityMetadataSource { \nprivate void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { \nAssert . notNull ( method , \"RegisteredMethod required\" ) ; \nAssert . notNull ( attr , \"Configuration attribute required\" ) ; \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\" ) ; \n} \nthis . methodMap . put ( method , attr ) ; \nreturn ; \n} \n} \n"}
{"177": "public class BindAuthenticator { \nprotected void handleBindException ( String userDn , String username , Throwable cause ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Failed to bind as \" + userDn + \": \" + cause ) ; \n} \nreturn ; \n} \n} \n"}
{"179": "public class SimpleUrlAuthenticationSuccessHandler { \nprotected final void clearAuthenticationAttributes ( HttpServletRequest request ) { \nHttpSession session = request . getSession ( false ) ; \nif ( session == null ) { \nreturn ; \n} \nsession . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; \nreturn ; \n} \n} \n"}
{"184": "public class Http403ForbiddenEntryPoint { \npublic void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Pre-authenticated entry point called. Rejecting access\" ) ; \n} \nresponse . sendError ( HttpServletResponse . SC_FORBIDDEN , \"Access Denied\" ) ; \nreturn ; \n} \n} \n"}
{"185": "public class DefaultFilterChainValidator { \nprivate void checkFilterStack ( List < Filter > filters ) { \ncheckForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; \ncheckForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; \ncheckForDuplicates ( SessionManagementFilter . class , filters ) ; \ncheckForDuplicates ( BasicAuthenticationFilter . class , filters ) ; \ncheckForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; \ncheckForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; \ncheckForDuplicates ( ExceptionTranslationFilter . class , filters ) ; \ncheckForDuplicates ( FilterSecurityInterceptor . class , filters ) ; \nreturn ; \n} \n} \n"}
{"191": "public class SimpleUrlAuthenticationFailureHandler { \npublic void setDefaultFailureUrl ( String defaultFailureUrl ) { \nAssert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\" ) ; \nthis . defaultFailureUrl = defaultFailureUrl ; \nreturn ; \n} \n} \n"}
{"192": "public class DefaultLogoutPageGeneratingFilter { \npublic void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { \nAssert . notNull ( resolveHiddenInputs , \"resolveHiddenInputs cannot be null\" ) ; \nthis . resolveHiddenInputs = resolveHiddenInputs ; \nreturn ; \n} \n} \n"}
{"197": "public class JdbcMutableAclService { \nprotected void createEntries ( final MutableAcl acl ) { \nif ( acl . getEntries ( ) . isEmpty ( ) ) { \nreturn ; \n} \njdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { \npublic int getBatchSize ( ) { \nreturn acl . getEntries ( ) . size ( ) ; \n} \npublic void setValues ( PreparedStatement stmt , int i ) throws SQLException { \nAccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; \nAssert . isTrue ( entry_ instanceof AccessControlEntryImpl , \"Unknown ACE class\" ) ; \nAccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; \nstmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; \nstmt . setInt ( 2 , i ) ; \nstmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; \nstmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; \nstmt . setBoolean ( 5 , entry . isGranting ( ) ) ; \nstmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; \nstmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"198": "public class JdbcMutableAclService { \nprotected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { \nLong sidId = createOrRetrieveSidPrimaryKey ( owner , true ) ; \nLong classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , true , object . getIdentifier ( ) . getClass ( ) ) ; \njdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; \nreturn ; \n} \n} \n"}
{"199": "public class JdbcMutableAclService { \nprotected void updateObjectIdentity ( MutableAcl acl ) { \nLong parentId = null ; \nif ( acl . getParentAcl ( ) != null ) { \nAssert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , \"Implementation only supports ObjectIdentityImpl\" ) ; \nObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; \nparentId = retrieveObjectIdentityPrimaryKey ( oii ) ; \n} \nAssert . notNull ( acl . getOwner ( ) , \"Owner is required in this implementation\" ) ; \nLong ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; \nint count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; \nif ( count != 1 ) { \nthrow new NotFoundException ( \"Unable to locate ACL to update\" ) ; \n} \nreturn ; \n} \n} \n"}
{"200": "public class HttpSessionRequestCache { \npublic void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { \nif ( requestMatcher . matches ( request ) ) { \nDefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; \nif ( createSessionAllowed || request . getSession ( false ) != null ) { \nrequest . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; \nlogger . debug ( \"DefaultSavedRequest added to Session: \" + savedRequest ) ; \n} \n} \nelse { \nlogger . debug ( \"Request not saved as configured RequestMatcher did not match\" ) ; \n} \nreturn ; \n} \n} \n"}
{"206": "public class XFrameOptionsHeaderWriter { \npublic void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { \nif ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { \nString allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; \nif ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { \nif ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; \n} \n} \nelse if ( allowFromValue != null ) { \nif ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + \" \" + allowFromValue ) ; \n} \n} \n} \nelse { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"209": "public class AbstractAuthenticationTargetUrlRequestHandler { \npublic void setTargetUrlParameter ( String targetUrlParameter ) { \nif ( targetUrlParameter != null ) { \nAssert . hasText ( targetUrlParameter , \"targetUrlParameter cannot be empty\" ) ; \n} \nthis . targetUrlParameter = targetUrlParameter ; \nreturn ; \n} \n} \n"}
{"213": "public class JaasAuthenticationProvider { \nprivate void configureJaasUsingLoop ( ) throws IOException { \nString loginConfigUrl = convertLoginConfigToUrl ( ) ; \nboolean alreadySet = false ; \nint n = 1 ; \nfinal String prefix = \"login.config.url.\" ; \nString existing ; \nwhile ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { \nalreadySet = existing . equals ( loginConfigUrl ) ; \nif ( alreadySet ) { \nbreak ; \n} \nn ++ ; \n} \nif ( ! alreadySet ) { \nString key = prefix + n ; \nlog . debug ( \"Setting security property [\" + key + \"] to: \" + loginConfigUrl ) ; \nSecurity . setProperty ( key , loginConfigUrl ) ; \n} \nreturn ; \n} \n} \n"}
{"216": "public class FastHttpDateFormat { \n@ SuppressWarnings ( \"unchecked\" ) private static void updateCache ( HashMap cache , Object key , Object value ) { \nif ( value == null ) { \nreturn ; \n} \nif ( cache . size ( ) > 1000 ) { \ncache . clear ( ) ; \n} \ncache . put ( key , value ) ; \nreturn ; \n} \n} \n"}
{"217": "public class UsernamePasswordAuthenticationFilter { \nprotected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { \nauthRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; \nreturn ; \n} \n} \n"}
{"220": "public class LdapUserDetailsManager { \npublic void changePassword ( final String oldPassword , final String newPassword ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nAssert . notNull ( authentication , \"No authentication object found in security context. Can't change current user's password!\" ) ; \nString username = authentication . getName ( ) ; \nlogger . debug ( \"Changing password for user '\" + username ) ; \nDistinguishedName userDn = usernameMapper . buildDn ( username ) ; \nif ( usePasswordModifyExtensionOperation ) { \nchangePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; \n} \nelse { \nchangePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; \n} \nreturn ; \n} \n} \n"}
{"222": "public class ConcurrentSessionControlAuthenticationStrategy { \nprotected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { \nif ( exceptionIfMaximumExceeded || ( sessions == null ) ) { \nthrow new SessionAuthenticationException ( messages . getMessage ( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\" , new Object [ ] { \nInteger . valueOf ( allowableSessions ) } \n, \"Maximum sessions of {0} for this principal exceeded\" ) ) ; \n} \nSessionInformation leastRecentlyUsed = null ; \nfor ( SessionInformation session : sessions ) { \nif ( ( leastRecentlyUsed == null ) || session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) { \nleastRecentlyUsed = session ; \n} \n} \nleastRecentlyUsed . expireNow ( ) ; \nreturn ; \n} \n} \n"}
{"223": "public class ProviderManager { \nprivate void copyDetails ( Authentication source , Authentication dest ) { \nif ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { \nAbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; \ntoken . setDetails ( source . getDetails ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"230": "public class RestAssured { \npublic static void filters ( List < Filter > filters ) { \nValidate . notNull ( filters , \"Filter list cannot be null\" ) ; \nRestAssured . filters . addAll ( filters ) ; \nreturn ; \n} \n} \n"}
{"231": "public class RestAssured { \npublic static void filters ( Filter filter , Filter ... additionalFilters ) { \nValidate . notNull ( filter , \"Filter cannot be null\" ) ; \nRestAssured . filters . add ( filter ) ; \nif ( additionalFilters != null ) { \nCollections . addAll ( RestAssured . filters , additionalFilters ) ; \n} \nreturn ; \n} \n} \n"}
{"235": "public class RestAssured { \npublic static void proxy ( URI uri ) { \nif ( uri == null ) { \nthrow new IllegalArgumentException ( \"Proxy URI cannot be null\" ) ; \n} \nproxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"257": "public class HTTPBuilder { \npublic void setHeaders ( Map < ? , ? > headers ) { \nthis . defaultRequestHeaders . clear ( ) ; \nif ( headers == null ) return ; \nfor ( Object key : headers . keySet ( ) ) { \nObject val = headers . get ( key ) ; \nif ( val == null ) continue ; \nthis . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"258": "public class HTTPBuilder { \npublic void setProxy ( String host , int port , String scheme ) { \ngetClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; \nreturn ; \n} \n} \n"}
{"261": "public class AuthConfig { \npublic void basic ( String host , int port , String user , String pass ) { \nbuilder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; \nreturn ; \n} \n} \n"}
{"262": "public class AuthConfig { \npublic void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { \nbuilder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; \nreturn ; \n} \n} \n"}
{"264": "public class RestAssuredMockMvc { \npublic static void reset ( ) { \nmockMvcFactory = null ; \nconfig = null ; \nbasePath = \"/\" ; \nresultHandlers . clear ( ) ; \nrequestPostProcessors . clear ( ) ; \nresponseSpecification = null ; \nrequestSpecification = null ; \nauthentication = null ; \nreturn ; \n} \n} \n"}
{"311": "public class WeakKeySet { \nprivate void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { \nsynchronized ( lock ) { \nfor ( KeyAndSource keyAndSource : keysAndSources ) { \nMultiset < Object > set = backingMap . get ( keyAndSource . key ) ; \nif ( set != null ) { \nset . remove ( keyAndSource . source ) ; \nif ( set . isEmpty ( ) ) { \nbackingMap . remove ( keyAndSource . key ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"312": "public class InjectorImpl { \nvoid index ( ) { \nfor ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { \nbindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; \n} \nreturn ; \n} \n} \n"}
{"316": "public class InjectorImpl { \nprivate void removeFailedJitBinding ( Binding < ? > binding , InjectionPoint ip ) { \nfailedJitBindings . add ( binding . getKey ( ) ) ; \njitBindings . remove ( binding . getKey ( ) ) ; \nmembersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; \nprovisionListenerStore . remove ( binding ) ; \nif ( ip != null ) { \nconstructors . remove ( ip ) ; \n} \nreturn ; \n} \n} \n"}
{"320": "public class InjectorShell { \nprivate static void bindInjector ( InjectorImpl injector ) { \nKey < Injector > key = Key . get ( Injector . class ) ; \nInjectorFactory injectorFactory = new InjectorFactory ( injector ) ; \ninjector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"321": "public class InjectorShell { \nprivate static void bindLogger ( InjectorImpl injector ) { \nKey < Logger > key = Key . get ( Logger . class ) ; \nLoggerFactory loggerFactory = new LoggerFactory ( ) ; \ninjector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"324": "public class MembersInjectorLookup { \npublic void initializeDelegate ( MembersInjector < T > delegate ) { \ncheckState ( this . delegate == null , \"delegate already initialized\" ) ; \nthis . delegate = checkNotNull ( delegate , \"delegate\" ) ; \nreturn ; \n} \n} \n"}
{"328": "public class TypeConverterBindingProcessor { \nstatic void prepareBuiltInConverters ( InjectorImpl injector ) { \nconvertToPrimitiveType ( injector , int . class , Integer . class ) ; \nconvertToPrimitiveType ( injector , long . class , Long . class ) ; \nconvertToPrimitiveType ( injector , boolean . class , Boolean . class ) ; \nconvertToPrimitiveType ( injector , byte . class , Byte . class ) ; \nconvertToPrimitiveType ( injector , short . class , Short . class ) ; \nconvertToPrimitiveType ( injector , float . class , Float . class ) ; \nconvertToPrimitiveType ( injector , double . class , Double . class ) ; \nconvertToClass ( injector , Character . class , new TypeConverter ( ) { \n@ Override public Object convert ( String value , TypeLiteral < ? > toType ) { \nvalue = value . trim ( ) ; \nif ( value . length ( ) != 1 ) { \nthrow new RuntimeException ( \"Length != 1.\" ) ; \n} \nreturn value . charAt ( 0 ) ; \n} \n@ Override public String toString ( ) { \nreturn \"TypeConverter<Character>\" ; \n} \n} \n) ; \nconvertToClasses ( injector , Matchers . subclassesOf ( Enum . class ) , new TypeConverter ( ) { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public Object convert ( String value , TypeLiteral < ? > toType ) { \nreturn Enum . valueOf ( ( Class ) toType . getRawType ( ) , value ) ; \n} \n@ Override public String toString ( ) { \nreturn \"TypeConverter<E extends Enum<E>>\" ; \n} \n} \n) ; \ninternalConvertToTypes ( injector , new AbstractMatcher < TypeLiteral < ? > > ( ) { \n@ Override public boolean matches ( TypeLiteral < ? > typeLiteral ) { \nreturn typeLiteral . getRawType ( ) == Class . class ; \n} \n@ Override public String toString ( ) { \nreturn \"Class<?>\" ; \n} \n} \n, new TypeConverter ( ) { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public Object convert ( String value , TypeLiteral < ? > toType ) { \ntry { \nreturn Class . forName ( value ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new RuntimeException ( e . getMessage ( ) ) ; \n} \n} \n@ Override public String toString ( ) { \nreturn \"TypeConverter<Class<?>>\" ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"334": "public class Initializer { \nvoid validateOustandingInjections ( Errors errors ) { \nvalidationStarted = true ; \ninitializablesCache . clear ( ) ; \nfor ( InjectableReference < ? > reference : pendingInjections ) { \ntry { \nreference . validate ( errors ) ; \n} \ncatch ( ErrorsException e ) { \nerrors . merge ( e . getErrors ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"345": "public class ProviderLookup { \npublic void initializeDelegate ( Provider < T > delegate ) { \ncheckState ( this . delegate == null , \"delegate already initialized\" ) ; \nthis . delegate = checkNotNull ( delegate , \"delegate\" ) ; \nreturn ; \n} \n} \n"}
{"346": "public class RealOptionalBinder { \nprivate void addDirectTypeBinding ( Binder binder ) { \nbinder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; \nreturn ; \n} \n} \n"}
{"360": "public class FactoryProvider2 { \npublic Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { \ncheckState ( injector != null , \"Factories.create() factories cannot be used until they're initialized by Guice.\" ) ; \nfinal Key < ? > returnType = data . returnType ; \nfinal Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; \nModule assistedModule = new AbstractModule ( ) { \n@ Override @ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) protected void configure ( ) { \nBinder binder = binder ( ) . withSource ( method ) ; \nint p = 0 ; \nif ( ! data . optimized ) { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; \n} \n} \nelse { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; \n} \n} \nConstructor constructor = data . constructor ; \nif ( constructor != null ) { \nbinder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; \n} \nreturn ; \n} \n} \n; \nInjector forCreate = injector . createChildInjector ( assistedModule ) ; \nBinding < ? > binding = forCreate . getBinding ( returnKey ) ; \nif ( data . optimized ) { \ndata . cachedBinding = binding ; \n} \nreturn binding ; \n} \n} \n"}
{"372": "public class DeferredLookups { \nvoid initialize ( Errors errors ) { \ninjector . lookups = injector ; \nnew LookupProcessor ( errors ) . process ( injector , lookups ) ; \nreturn ; \n} \n} \n"}
{"382": "public class InterceptorStackCallback { \nprivate void pruneStacktrace ( Throwable throwable ) { \nfor ( Throwable t = throwable ; \nt != null ; \nt = t . getCause ( ) ) { \nStackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; \nList < StackTraceElement > pruned = Lists . newArrayList ( ) ; \nfor ( StackTraceElement element : stackTrace ) { \nString className = element . getClassName ( ) ; \nif ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( \"$EnhancerByGuice$\" ) ) { \npruned . add ( element ) ; \n} \n} \nt . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; \n} \nreturn ; \n} \n} \n"}
{"391": "public class Manager { \npublic static void main ( String [ ] args ) throws Exception { \nif ( args . length != 1 ) { \nSystem . err . println ( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager . class . getName ( ) + \" [module class name]\" ) ; \nSystem . err . println ( \"Then run 'jconsole' to connect.\" ) ; \nSystem . exit ( 1 ) ; \n} \nModule module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; \nInjector injector = Guice . createInjector ( module ) ; \nmanage ( args [ 0 ] , injector ) ; \nSystem . out . println ( \"Press Ctrl+C to exit...\" ) ; \nThread . sleep ( Long . MAX_VALUE ) ; \nreturn ; \n} \n} \n"}
{"393": "public class InternalContext { \nvoid pushState ( com . google . inject . Key < ? > key , Object source ) { \ndoPushState ( key , source ) ; \nreturn ; \n} \n} \n"}
{"396": "public class ConnectionEventListener { \npublic void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { \nList < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; \nif ( processorList != null ) { \nfor ( ConnectionEventProcessor processor : processorList ) { \nprocessor . onEvent ( remoteAddr , conn ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"397": "public class ConnectionEventListener { \npublic void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { \nList < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; \nif ( processorList == null ) { \nthis . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; \nprocessorList = this . processors . get ( type ) ; \n} \nprocessorList . add ( processor ) ; \nreturn ; \n} \n} \n"}
{"399": "public class FutureTaskUtil { \npublic static void launderThrowable ( Throwable t ) { \nif ( t instanceof RuntimeException ) { \nthrow ( RuntimeException ) t ; \n} \nelse if ( t instanceof Error ) { \nthrow ( Error ) t ; \n} \nelse { \nthrow new IllegalStateException ( \"Not unchecked!\" , t ) ; \n} \nreturn ; \n} \n} \n"}
{"400": "public class ProcessorManager { \npublic void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { \nif ( this . cmd2processors . containsKey ( cmdCode ) ) { \nlogger . warn ( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; \n} \nthis . cmd2processors . put ( cmdCode , processor ) ; \nreturn ; \n} \n} \n"}
{"401": "public class ProcessorManager { \npublic void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { \nif ( this . defaultProcessor == null ) { \nthis . defaultProcessor = processor ; \n} \nelse { \nthrow new IllegalStateException ( \"The defaultProcessor has already been registered: \" + this . defaultProcessor . getClass ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"406": "public class DefaultConnectionManager { \n@ Override public void scan ( ) { \nif ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { \nIterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString poolKey = iter . next ( ) ; \nConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; \nif ( null != pool ) { \npool . scan ( ) ; \nif ( pool . isEmpty ( ) ) { \nif ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { \niter . remove ( ) ; \nlogger . warn ( \"Remove expired pool task of poolKey {} which is empty.\" , poolKey ) ; \n} \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"408": "public class DefaultConnectionManager { \n@ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { \nConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; \nif ( null != pool ) { \nhealIfNeed ( pool , url ) ; \n} \nelse { \nlogger . error ( \"[NOTIFYME] bug detected! pool here must not be null!\" ) ; \n} \nreturn ; \n} \n} \n"}
{"409": "public class DefaultConnectionManager { \nprivate void removeTask ( String poolKey ) { \nRunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; \nif ( null != task ) { \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; \nif ( null != pool ) { \npool . removeAllAndTryClose ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"410": "public class DefaultConnectionManager { \nprivate void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { \nString poolKey = url . getUniqueKey ( ) ; \nif ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { \nFutureTask < Integer > task = this . healTasks . get ( poolKey ) ; \nif ( null == task ) { \ntask = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; \ntask = this . healTasks . putIfAbsent ( poolKey , task ) ; \nif ( null == task ) { \ntask = this . healTasks . get ( poolKey ) ; \ntask . run ( ) ; \n} \n} \ntry { \nint numAfterHeal = task . get ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; \n} \n} \ncatch ( InterruptedException e ) { \nthis . healTasks . remove ( poolKey ) ; \nthrow e ; \n} \ncatch ( ExecutionException e ) { \nthis . healTasks . remove ( poolKey ) ; \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RemotingException ) { \nthrow ( RemotingException ) cause ; \n} \nelse { \nFutureTaskUtil . launderThrowable ( cause ) ; \n} \n} \nthis . healTasks . remove ( poolKey ) ; \n} \nreturn ; \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( url . isConnWarmup ( ) ) { \nfor ( int i = actualNum ; \ni < expectNum ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \n} \nelse { \nif ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( syncCreateNumWhenNotWarmup > 0 ) { \nfor ( int i = 0 ; \ni < syncCreateNumWhenNotWarmup ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( int i = pool . size ( ) ; \ni < url . getConnNum ( ) ; \n++ i ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \nreturn ; \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"412": "public class RpcClient { \npublic void closeConnection ( String addr ) { \nUrl url = this . addressParser . parse ( addr ) ; \nthis . connectionManager . remove ( url . getUniqueKey ( ) ) ; \nreturn ; \n} \n} \n"}
{"413": "public class Connection { \npublic void onClose ( ) { \nIterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nEntry < Integer , InvokeFuture > entry = iter . next ( ) ; \niter . remove ( ) ; \nInvokeFuture future = entry . getValue ( ) ; \nif ( future != null ) { \nfuture . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; \nfuture . cancelTimeout ( ) ; \nfuture . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"414": "public class Connection { \npublic void close ( ) { \nif ( closed . compareAndSet ( false , true ) ) { \ntry { \nif ( this . getChannel ( ) != null ) { \nthis . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture future ) throws Exception { \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"Close the connection to remote address={}, result={}, cause={}\" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; \n} \nreturn ; \n} \n} \n) ; \n} \n} \ncatch ( Exception e ) { \nlogger . warn ( \"Exception caught when closing connection {}\" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"416": "public class UserProcessorRegisterHelper { \npublic static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { \nif ( null == processor ) { \nthrow new RuntimeException ( \"User processor should not be null!\" ) ; \n} \nif ( processor instanceof MultiInterestUserProcessor ) { \nregisterUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; \n} \nelse { \nif ( StringUtils . isBlank ( processor . interest ( ) ) ) { \nthrow new RuntimeException ( \"Processor interest should not be blank!\" ) ; \n} \nUserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; \nif ( preProcessor != null ) { \nString errMsg = \"Processor with interest key [\" + processor . interest ( ) + \"] has already been registered to rpc server, can not register again!\" ; \nthrow new RuntimeException ( errMsg ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"417": "public class UserProcessorRegisterHelper { \nprivate static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { \nif ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { \nthrow new RuntimeException ( \"Processor interest should not be blank!\" ) ; \n} \nfor ( String interest : processor . multiInterest ( ) ) { \nUserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; \nif ( preProcessor != null ) { \nString errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\" ; \nthrow new RuntimeException ( errMsg ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"418": "public class RpcRequestProcessor { \nprivate void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { \nfinal int id = cmd . getId ( ) ; \nfinal byte type = cmd . getType ( ) ; \nUserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; \nif ( processor instanceof AsyncUserProcessor ) { \ntry { \nprocessor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \nelse { \ntry { \nObject responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; \n} \ncatch ( RejectedExecutionException e ) { \nlogger . warn ( \"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\" ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; \n} \ncatch ( Throwable t ) { \nString errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id ; \nlogger . error ( errMsg , t ) ; \nsendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"420": "public class RpcRequestProcessor { \nprivate void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { \nctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; \nctx . setTimeout ( cmd . getTimeout ( ) ) ; \nctx . setRpcCommandType ( cmd . getType ( ) ) ; \nctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; \nreturn ; \n} \n} \n"}
{"421": "public class RpcRequestProcessor { \nprivate void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\" , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; \n} \nString remoteAddr = \"UNKNOWN\" ; \nif ( null != ctx ) { \nChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; \nChannel channel = channelCtx . channel ( ) ; \nif ( null != channel ) { \nremoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; \n} \n} \nlogger . warn ( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\" , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; \nreturn ; \n} \n} \n"}
{"422": "public class RpcRequestProcessor { \nprivate void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Rpc request received! requestId={}, from {}\" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; \nlogger . debug ( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\" , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"423": "public class AbstractRemotingProcessor { \n@ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { \nProcessTask task = new ProcessTask ( ctx , msg ) ; \nif ( this . getExecutor ( ) != null ) { \nthis . getExecutor ( ) . execute ( task ) ; \n} \nelse { \ndefaultExecutor . execute ( task ) ; \n} \nreturn ; \n} \n} \n"}
{"424": "public class BaseRemoting { \nprotected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { \nfinal InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; \nconn . addInvokeFuture ( future ) ; \nfinal int requestId = request . getId ( ) ; \ntry { \nTimeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { \n@ Override public void run ( Timeout timeout ) throws Exception { \nInvokeFuture future = conn . removeInvokeFuture ( requestId ) ; \nif ( future != null ) { \nfuture . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; \nfuture . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \nreturn ; \n} \n} \n, timeoutMillis , TimeUnit . MILLISECONDS ) ; \nfuture . addTimeout ( timeout ) ; \nconn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture cf ) throws Exception { \nif ( ! cf . isSuccess ( ) ) { \nInvokeFuture f = conn . removeInvokeFuture ( requestId ) ; \nif ( f != null ) { \nf . cancelTimeout ( ) ; \nf . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; \nf . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \nlogger . error ( \"Invoke send failed. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; \n} \nreturn ; \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nInvokeFuture f = conn . removeInvokeFuture ( requestId ) ; \nif ( f != null ) { \nf . cancelTimeout ( ) ; \nf . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; \nf . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; \n} \nlogger . error ( \"Exception caught when sending invocation. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"425": "public class BaseRemoting { \nprotected void oneway ( final Connection conn , final RemotingCommand request ) { \ntry { \nconn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { \n@ Override public void operationComplete ( ChannelFuture f ) throws Exception { \nif ( ! f . isSuccess ( ) ) { \nlogger . error ( \"Invoke send failed. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; \n} \nreturn ; \n} \n} \n) ; \n} \ncatch ( Exception e ) { \nif ( null == conn ) { \nlogger . error ( \"Conn is null\" ) ; \n} \nelse { \nlogger . error ( \"Exception caught when sending invocation. The address is {}\" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"428": "public class ReconnectManager { \npublic void addReconnectTask ( Url url ) { \nReconnectTask task = new ReconnectTask ( ) ; \ntask . url = url ; \ntasks . add ( task ) ; \nreturn ; \n} \n} \n"}
{"429": "public class ReconnectManager { \npublic void stop ( ) { \nif ( ! this . started ) { \nreturn ; \n} \nthis . started = false ; \nhealConnectionThreads . interrupt ( ) ; \nthis . tasks . clear ( ) ; \nthis . canceled . clear ( ) ; \nreturn ; \n} \n} \n"}
{"432": "public class ScheduledDisconnectStrategy { \n@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { \ntry { \nif ( null != connPools && ! connPools . isEmpty ( ) ) { \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; \nString poolKey = entry . getKey ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nList < Connection > connections = pool . getAll ( ) ; \nMap < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; \nList < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; \nList < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; \nif ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { \nConnection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; \nfreshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \nfreshSelectConnections . put ( poolKey , freshSelectConnect ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nelse { \nif ( freshSelectConnections . containsKey ( poolKey ) ) { \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\" , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; \n} \n} \nfor ( Connection offConn : serviceOffConnections ) { \nif ( offConn . isFine ( ) ) { \noffConn . close ( ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"ScheduledDisconnectStrategy monitor error\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"433": "public class ScheduledDisconnectStrategy { \nprivate void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { \nif ( null != lastSelectConnect ) { \nif ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { \nserviceOffConnections . add ( lastSelectConnect ) ; \n} \nelse { \nThread . sleep ( RETRY_DETECT_PERIOD ) ; \nif ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { \nserviceOffConnections . add ( lastSelectConnect ) ; \n} \nelse { \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"Address={} won't close at this schedule turn\" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"435": "public class ConnectionEventHandler { \nprivate void infoLog ( String format , String addr ) { \nif ( logger . isInfoEnabled ( ) ) { \nif ( StringUtils . isNotEmpty ( addr ) ) { \nlogger . info ( format , addr ) ; \n} \nelse { \nlogger . info ( format , \"UNKNOWN-ADDR\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"446": "public class TraceLogUtil { \npublic static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { \nString sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; \nInteger sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; \nString targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; \nInteger targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; \nStringBuilder logMsg = new StringBuilder ( ) ; \nlogMsg . append ( traceId ) . append ( \",\" ) ; \nlogMsg . append ( sourceIp ) . append ( \",\" ) ; \nlogMsg . append ( sourcePort ) . append ( \",\" ) ; \nlogMsg . append ( targetIp ) . append ( \",\" ) ; \nlogMsg . append ( targetPort ) ; \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( logMsg . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"456": "public class ConnectionPool { \npublic void add ( Connection connection ) { \nmarkAccess ( ) ; \nif ( null == connection ) { \nreturn ; \n} \nboolean res = this . conns . addIfAbsent ( connection ) ; \nif ( res ) { \nconnection . increaseRef ( ) ; \n} \nreturn ; \n} \n} \n"}
{"457": "public class ConnectionPool { \npublic void removeAndTryClose ( Connection connection ) { \nif ( null == connection ) { \nreturn ; \n} \nboolean res = this . conns . remove ( connection ) ; \nif ( res ) { \nconnection . decreaseRef ( ) ; \n} \nif ( connection . noRef ( ) ) { \nconnection . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"459": "public class CustomSerializerManager { \npublic static void registerCustomSerializer ( String className , CustomSerializer serializer ) { \nCustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; \nif ( prevSerializer != null ) { \nthrow new RuntimeException ( \"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer . getClass ( ) . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"461": "public class CustomSerializerManager { \npublic static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { \nCustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; \nif ( prevSerializer != null ) { \nthrow new RuntimeException ( \"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer . getClass ( ) . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"463": "public class DefaultConnectionMonitor { \npublic void start ( ) { \nlong initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; \nlong period = ConfigManager . conn_monitor_period ( ) ; \nthis . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( \"ConnectionMonitorThread\" , true ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; \nMonitorTask monitorTask = new MonitorTask ( ) ; \nthis . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; \nreturn ; \n} \n} \n"}
{"465": "public class RpcServer { \nprivate void initWriteBufferWaterMark ( ) { \nint lowWaterMark = this . netty_buffer_low_watermark ( ) ; \nint highWaterMark = this . netty_buffer_high_watermark ( ) ; \nif ( lowWaterMark > highWaterMark ) { \nthrow new IllegalArgumentException ( String . format ( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\" , highWaterMark , lowWaterMark ) ) ; \n} \nelse { \nlogger . warn ( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\" , lowWaterMark , highWaterMark ) ; \n} \nthis . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; \nreturn ; \n} \n} \n"}
{"468": "public class CloseFrame { \npublic void setCode ( int code ) { \nthis . code = code ; \nif ( code == CloseFrame . TLS_ERROR ) { \nthis . code = CloseFrame . NOCODE ; \nthis . reason = \"\" ; \n} \nupdatePayload ( ) ; \nreturn ; \n} \n} \n"}
{"469": "public class CloseFrame { \nprivate void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { \ntry { \npayload . position ( payload . position ( ) + 2 ) ; \nreason = Charsetfunctions . stringUtf8 ( payload ) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new InvalidDataException ( CloseFrame . NO_UTF8 ) ; \n} \nfinally { \npayload . position ( mark ) ; \n} \nreturn ; \n} \n} \n"}
{"470": "public class CloseFrame { \nprivate void updatePayload ( ) { \nbyte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; \nByteBuffer buf = ByteBuffer . allocate ( 4 ) ; \nbuf . putInt ( code ) ; \nbuf . position ( 2 ) ; \nByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; \npay . put ( buf ) ; \npay . put ( by ) ; \npay . rewind ( ) ; \nsuper . setPayload ( pay ) ; \nreturn ; \n} \n} \n"}
{"472": "public class Draft_6455 { \nprivate void translateSingleFrameCheckLengthLimit ( long length ) throws LimitExceededException { \nif ( length > Integer . MAX_VALUE ) { \nlog . trace ( \"Limit exedeed: Payloadsize is to big...\" ) ; \nthrow new LimitExceededException ( \"Payloadsize is to big...\" ) ; \n} \nif ( length > maxFrameSize ) { \nlog . trace ( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize , length ) ; \nthrow new LimitExceededException ( \"Payload limit reached.\" , maxFrameSize ) ; \n} \nif ( length < 0 ) { \nlog . trace ( \"Limit underflow: Payloadsize is to little...\" ) ; \nthrow new LimitExceededException ( \"Payloadsize is to little...\" ) ; \n} \nreturn ; \n} \n} \n"}
{"473": "public class Draft_6455 { \nprivate void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { \nif ( maxpacketsize < realpacketsize ) { \nlog . trace ( \"Incomplete frame: maxpacketsize < realpacketsize\" ) ; \nthrow new IncompleteException ( realpacketsize ) ; \n} \nreturn ; \n} \n} \n"}
{"475": "public class Draft_6455 { \nprivate void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { \nif ( curop != Opcode . CONTINUOUS ) { \nprocessFrameIsNotFin ( frame ) ; \n} \nelse if ( frame . isFin ( ) ) { \nprocessFrameIsFin ( webSocketImpl , frame ) ; \n} \nelse if ( currentContinuousFrame == null ) { \nlog . error ( \"Protocol error: Continuous frame sequence was not started.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \nif ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { \nlog . error ( \"Protocol error: Payload is not UTF8\" ) ; \nthrow new InvalidDataException ( CloseFrame . NO_UTF8 ) ; \n} \nif ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) { \naddToBufferList ( frame . getPayloadData ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"476": "public class Draft_6455 { \nprivate void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata frame ) { \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \nreturn ; \n} \n} \n"}
{"477": "public class Draft_6455 { \nprivate void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException e ) { \nlog . error ( \"Runtime exception during onWebsocketMessage\" , e ) ; \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; \nreturn ; \n} \n} \n"}
{"478": "public class Draft_6455 { \nprivate void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \nreturn ; \n} \n} \n"}
{"479": "public class Draft_6455 { \nprivate void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { \nif ( currentContinuousFrame == null ) { \nlog . trace ( \"Protocol error: Previous continuous frame sequence not completed.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \naddToBufferList ( frame . getPayloadData ( ) ) ; \ncheckBufferLimit ( ) ; \nif ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { \n( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; \n( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \n} \nelse if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { \n( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; \n( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \n} \ncurrentContinuousFrame = null ; \nclearBufferList ( ) ; \nreturn ; \n} \n} \n"}
{"480": "public class Draft_6455 { \nprivate void processFrameIsNotFin ( Framedata frame ) throws InvalidDataException { \nif ( currentContinuousFrame != null ) { \nlog . trace ( \"Protocol error: Previous continuous frame sequence not completed.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Previous continuous frame sequence not completed.\" ) ; \n} \ncurrentContinuousFrame = frame ; \naddToBufferList ( frame . getPayloadData ( ) ) ; \ncheckBufferLimit ( ) ; \nreturn ; \n} \n} \n"}
{"481": "public class Draft_6455 { \nprivate void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { \nint code = CloseFrame . NOCODE ; \nString reason = \"\" ; \nif ( frame instanceof CloseFrame ) { \nCloseFrame cf = ( CloseFrame ) frame ; \ncode = cf . getCloseCode ( ) ; \nreason = cf . getMessage ( ) ; \n} \nif ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { \nwebSocketImpl . closeConnection ( code , reason , true ) ; \n} \nelse { \nif ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; \nelse webSocketImpl . flushAndClose ( code , reason , false ) ; \n} \nreturn ; \n} \n} \n"}
{"482": "public class Draft_6455 { \nprivate void checkBufferLimit ( ) throws LimitExceededException { \nlong totalSize = getByteBufferListSize ( ) ; \nif ( totalSize > maxFrameSize ) { \nclearBufferList ( ) ; \nlog . trace ( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize , totalSize ) ; \nthrow new LimitExceededException ( maxFrameSize ) ; \n} \nreturn ; \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( readyState != ReadyState . NOT_YET_CONNECTED ) { \nif ( readyState == ReadyState . OPEN ) { \ndecodeFrames ( socketBuffer ) ; \n} \n} \nelse { \nif ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( socketBuffer . hasRemaining ( ) ) { \ndecodeFrames ( socketBuffer ) ; \n} \nelse if ( tmpHandshakeBytes . hasRemaining ( ) ) { \ndecodeFrames ( tmpHandshakeBytes ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"488": "public class WebSocketImpl { \nprivate void closeConnectionDueToWrongHandshake ( InvalidDataException exception ) { \nwrite ( generateHttpResponseDueToError ( 404 ) ) ; \nflushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , false ) ; \nreturn ; \n} \n} \n"}
{"489": "public class WebSocketImpl { \nprivate void closeConnectionDueToInternalServerError ( RuntimeException exception ) { \nwrite ( generateHttpResponseDueToError ( 500 ) ) ; \nflushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , false ) ; \nreturn ; \n} \n} \n"}
{"491": "public class WebSocketImpl { \n@ Override public void send ( String text ) { \nif ( text == null ) throw new IllegalArgumentException ( \"Cannot send 'null' data to a WebSocketImpl.\" ) ; \nsend ( draft . createFrames ( text , role == Role . CLIENT ) ) ; \nreturn ; \n} \n} \n"}
{"492": "public class WebSocketClient { \nprivate void reset ( ) { \nThread current = Thread . currentThread ( ) ; \nif ( current == writeThread || current == connectReadThread ) { \nthrow new IllegalStateException ( \"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\" ) ; \n} \ntry { \ncloseBlocking ( ) ; \nif ( writeThread != null ) { \nthis . writeThread . interrupt ( ) ; \nthis . writeThread = null ; \n} \nif ( connectReadThread != null ) { \nthis . connectReadThread . interrupt ( ) ; \nthis . connectReadThread = null ; \n} \nthis . draft . reset ( ) ; \nif ( this . socket != null ) { \nthis . socket . close ( ) ; \nthis . socket = null ; \n} \n} \ncatch ( Exception e ) { \nonError ( e ) ; \nengine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; \nreturn ; \n} \nconnectLatch = new CountDownLatch ( 1 ) ; \ncloseLatch = new CountDownLatch ( 1 ) ; \nthis . engine = new WebSocketImpl ( this , this . draft ) ; \nreturn ; \n} \n} \n"}
{"493": "public class WebSocketClient { \npublic void connect ( ) { \nif ( connectReadThread != null ) throw new IllegalStateException ( \"WebSocketClient objects are not reuseable\" ) ; \nconnectReadThread = new Thread ( this ) ; \nconnectReadThread . setName ( \"WebSocketConnectReadThread-\" + connectReadThread . getId ( ) ) ; \nconnectReadThread . start ( ) ; \nreturn ; \n} \n} \n"}
{"495": "public class WebSocketClient { \nprivate void sendHandshake ( ) throws InvalidHandshakeException { \nString path ; \nString part1 = uri . getRawPath ( ) ; \nString part2 = uri . getRawQuery ( ) ; \nif ( part1 == null || part1 . length ( ) == 0 ) path = \"/\" ; \nelse path = part1 ; \nif ( part2 != null ) path += '?' + part2 ; \nint port = getPort ( ) ; \nString host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? \":\" + port : \"\" ) ; \nHandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; \nhandshake . setResourceDescriptor ( path ) ; \nhandshake . put ( \"Host\" , host ) ; \nif ( headers != null ) { \nfor ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { \nhandshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; \n} \n} \nengine . startHandshake ( handshake ) ; \nreturn ; \n} \n} \n"}
{"496": "public class AbstractWebSocket { \npublic void setConnectionLostTimeout ( int connectionLostTimeout ) { \nsynchronized ( syncConnectionLost ) { \nthis . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; \nif ( this . connectionLostTimeout <= 0 ) { \nlog . trace ( \"Connection lost timer stopped\" ) ; \ncancelConnectionLostTimer ( ) ; \nreturn ; \n} \nif ( this . websocketRunning ) { \nlog . trace ( \"Connection lost timer restarted\" ) ; \ntry { \nArrayList < WebSocket > connections = new ArrayList < WebSocket > ( getConnections ( ) ) ; \nWebSocketImpl webSocketImpl ; \nfor ( WebSocket conn : connections ) { \nif ( conn instanceof WebSocketImpl ) { \nwebSocketImpl = ( WebSocketImpl ) conn ; \nwebSocketImpl . updateLastPong ( ) ; \n} \n} \n} \ncatch ( Exception e ) { \nlog . error ( \"Exception during connection lost restart\" , e ) ; \n} \nrestartConnectionLostTimer ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"497": "public class AbstractWebSocket { \nprotected void stopConnectionLostTimer ( ) { \nsynchronized ( syncConnectionLost ) { \nif ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { \nthis . websocketRunning = false ; \nlog . trace ( \"Connection lost timer stopped\" ) ; \ncancelConnectionLostTimer ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"498": "public class AbstractWebSocket { \nprotected void startConnectionLostTimer ( ) { \nsynchronized ( syncConnectionLost ) { \nif ( this . connectionLostTimeout <= 0 ) { \nlog . trace ( \"Connection lost timer deactivated\" ) ; \nreturn ; \n} \nlog . trace ( \"Connection lost timer started\" ) ; \nthis . websocketRunning = true ; \nrestartConnectionLostTimer ( ) ; \n} \nreturn ; \n} \n} \n"}
{"499": "public class AbstractWebSocket { \nprivate void restartConnectionLostTimer ( ) { \ncancelConnectionLostTimer ( ) ; \nconnectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( \"connectionLostChecker\" ) ) ; \nRunnable connectionLostChecker = new Runnable ( ) { \nprivate ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; \n@ Override public void run ( ) { \nconnections . clear ( ) ; \ntry { \nconnections . addAll ( getConnections ( ) ) ; \nlong minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; \nfor ( WebSocket conn : connections ) { \nexecuteConnectionLostDetection ( conn , minimumPongTime ) ; \n} \n} \ncatch ( Exception e ) { \n} \nconnections . clear ( ) ; \nreturn ; \n} \n} \n; \nconnectionLostCheckerFuture = connectionLostCheckerService . scheduleAtFixedRate ( connectionLostChecker , connectionLostTimeout , connectionLostTimeout , TimeUnit . NANOSECONDS ) ; \nreturn ; \n} \n} \n"}
{"500": "public class AbstractWebSocket { \nprivate void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { \nif ( ! ( webSocket instanceof WebSocketImpl ) ) { \nreturn ; \n} \nWebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; \nif ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { \nlog . trace ( \"Closing connection due to no pong received: {}\" , webSocketImpl ) ; \nwebSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ) ; \n} \nelse { \nif ( webSocketImpl . isOpen ( ) ) { \nwebSocketImpl . sendPing ( ) ; \n} \nelse { \nlog . trace ( \"Trying to ping a non open connection: {}\" , webSocketImpl ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"501": "public class AbstractWebSocket { \nprivate void cancelConnectionLostTimer ( ) { \nif ( connectionLostCheckerService != null ) { \nconnectionLostCheckerService . shutdownNow ( ) ; \nconnectionLostCheckerService = null ; \n} \nif ( connectionLostCheckerFuture != null ) { \nconnectionLostCheckerFuture . cancel ( false ) ; \nconnectionLostCheckerFuture = null ; \n} \nreturn ; \n} \n} \n"}
{"503": "public class WebSocketAdapter { \n@ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { \nconn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; \nreturn ; \n} \n} \n"}
{"504": "public class WebSocketServer { \npublic void stop ( int timeout ) throws InterruptedException { \nif ( ! isclosed . compareAndSet ( false , true ) ) { \nreturn ; \n} \nList < WebSocket > socketsToClose ; \nsynchronized ( connections ) { \nsocketsToClose = new ArrayList < WebSocket > ( connections ) ; \n} \nfor ( WebSocket ws : socketsToClose ) { \nws . close ( CloseFrame . GOING_AWAY ) ; \n} \nwsf . close ( ) ; \nsynchronized ( this ) { \nif ( selectorthread != null && selector != null ) { \nselector . wakeup ( ) ; \nselectorthread . join ( timeout ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"506": "public class WebSocketServer { \nprivate void doAdditionalRead ( ) throws InterruptedException , IOException { \nWebSocketImpl conn ; \nwhile ( ! iqueue . isEmpty ( ) ) { \nconn = iqueue . remove ( 0 ) ; \nWrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; \nByteBuffer buf = takeBuffer ( ) ; \ntry { \nif ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; \nif ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \n} \nreturn ; \n} \n} \n"}
{"507": "public class WebSocketServer { \nprivate void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { \nif ( ! onConnect ( key ) ) { \nkey . cancel ( ) ; \nreturn ; \n} \nSocketChannel channel = server . accept ( ) ; \nif ( channel == null ) { \nreturn ; \n} \nchannel . configureBlocking ( false ) ; \nSocket socket = channel . socket ( ) ; \nsocket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; \nsocket . setKeepAlive ( true ) ; \nWebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; \nw . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; \ntry { \nw . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; \ni . remove ( ) ; \nallocateBuffers ( w ) ; \n} \ncatch ( IOException ex ) { \nif ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; \nhandleIOException ( w . getSelectionKey ( ) , null , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"509": "public class WebSocketServer { \nprivate void doWrite ( SelectionKey key ) throws IOException { \nWebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; \nif ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { \nif ( key . isValid ( ) ) { \nkey . interestOps ( SelectionKey . OP_READ ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"512": "public class WebSocketServer { \nprivate void doServerShutdown ( ) { \nstopConnectionLostTimer ( ) ; \nif ( decoders != null ) { \nfor ( WebSocketWorker w : decoders ) { \nw . interrupt ( ) ; \n} \n} \nif ( selector != null ) { \ntry { \nselector . close ( ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"IOException during selector.close\" , e ) ; \nonError ( null , e ) ; \n} \n} \nif ( server != null ) { \ntry { \nserver . close ( ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"IOException during server.close\" , e ) ; \nonError ( null , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"514": "public class WebSocketServer { \npublic void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { \nif ( data == null || clients == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nbroadcast ( ByteBuffer . wrap ( data ) , clients ) ; \nreturn ; \n} \n} \n"}
{"515": "public class WebSocketServer { \npublic void broadcast ( String text , Collection < WebSocket > clients ) { \nif ( text == null || clients == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \ndoBroadcast ( text , clients ) ; \nreturn ; \n} \n} \n"}
{"516": "public class WebSocketServer { \nprivate void doBroadcast ( Object data , Collection < WebSocket > clients ) { \nString sData = null ; \nif ( data instanceof String ) { \nsData = ( String ) data ; \n} \nByteBuffer bData = null ; \nif ( data instanceof ByteBuffer ) { \nbData = ( ByteBuffer ) data ; \n} \nif ( sData == null && bData == null ) { \nreturn ; \n} \nMap < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; \nfor ( WebSocket client : clients ) { \nif ( client != null ) { \nDraft draft = client . getDraft ( ) ; \nfillFrames ( draft , draftFrames , sData , bData ) ; \ntry { \nclient . sendFrame ( draftFrames . get ( draft ) ) ; \n} \ncatch ( WebsocketNotConnectedException e ) { \n} \n} \n} \nreturn ; \n} \n} \n"}
{"517": "public class WebSocketServer { \nprivate void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { \nif ( ! draftFrames . containsKey ( draft ) ) { \nList < Framedata > frames = null ; \nif ( sData != null ) { \nframes = draft . createFrames ( sData , false ) ; \n} \nif ( bData != null ) { \nframes = draft . createFrames ( bData , false ) ; \n} \nif ( frames != null ) { \ndraftFrames . put ( draft , frames ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"521": "public class DefaultJPAApi { \npublic void withTransaction ( Consumer < EntityManager > block ) { \nwithTransaction ( em -> { \nblock . accept ( em ) ; \nreturn null ; \n} \n) ; \nreturn ; \n} \n} \n"}
{"557": "public class DefaultHttpErrorHandler { \nprotected void logServerError ( RequestHeader request , UsefulException usefulException ) { \nlogger . error ( String . format ( \"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; \nreturn ; \n} \n} \n"}
{"599": "public class Controller { \n@ Deprecated public static void session ( String key , String value ) { \nsession ( ) . put ( key , value ) ; \nreturn ; \n} \n} \n"}
{"600": "public class Controller { \n@ Deprecated public static void flash ( String key , String value ) { \nflash ( ) . put ( key , value ) ; \nreturn ; \n} \n} \n"}
{"612": "public class Evolutions { \npublic static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { \nDatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; \nevolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; \nreturn ; \n} \n} \n"}
{"623": "public class JPAEntityManagerContext { \nvoid pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { \nDeque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; \nif ( em != null ) { \nems . push ( em ) ; \n} \nelse { \nif ( ems . isEmpty ( ) ) { \nthrow new IllegalStateException ( \"Tried to remove the EntityManager, but none was set.\" ) ; \n} \nems . pop ( ) ; \n} \nreturn ; \n} \n} \n"}
{"656": "public class ParallelSorter { \npublic void quickSort ( int index , int lo , int hi , Comparator cmp ) { \nchooseComparer ( index , cmp ) ; \nsuper . quickSort ( lo , hi - 1 ) ; \nreturn ; \n} \n} \n"}
{"657": "public class ParallelSorter { \npublic void mergeSort ( int index , int lo , int hi , Comparator cmp ) { \nchooseComparer ( index , cmp ) ; \nsuper . mergeSort ( lo , hi - 1 ) ; \nreturn ; \n} \n} \n"}
{"659": "public class CodeEmitter { \npublic void cast_numeric ( Type from , Type to ) { \nif ( from != to ) { \nif ( from == Type . DOUBLE_TYPE ) { \nif ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . D2F ) ; \n} \nelse if ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . D2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . D2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \nelse if ( from == Type . FLOAT_TYPE ) { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . F2D ) ; \n} \nelse if ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . F2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . F2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \nelse if ( from == Type . LONG_TYPE ) { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . L2D ) ; \n} \nelse if ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . L2F ) ; \n} \nelse { \nmv . visitInsn ( Constants . L2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \nelse { \nif ( to == Type . BYTE_TYPE ) { \nmv . visitInsn ( Constants . I2B ) ; \n} \nelse if ( to == Type . CHAR_TYPE ) { \nmv . visitInsn ( Constants . I2C ) ; \n} \nelse if ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . I2D ) ; \n} \nelse if ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . I2F ) ; \n} \nelse if ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . I2L ) ; \n} \nelse if ( to == Type . SHORT_TYPE ) { \nmv . visitInsn ( Constants . I2S ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"660": "public class CodeEmitter { \npublic void load_arg ( int index ) { \nload_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; \nreturn ; \n} \n} \n"}
{"661": "public class CodeEmitter { \nvoid emit_field ( int opcode , Type ctype , String name , Type ftype ) { \nmv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; \nreturn ; \n} \n} \n"}
{"662": "public class CodeEmitter { \npublic void zero_or_null ( Type type ) { \nif ( TypeUtils . isPrimitive ( type ) ) { \nswitch ( type . getSort ( ) ) { \ncase Type . DOUBLE : push ( 0d ) ; \nbreak ; \ncase Type . LONG : push ( 0L ) ; \nbreak ; \ncase Type . FLOAT : push ( 0f ) ; \nbreak ; \ncase Type . VOID : aconst_null ( ) ; \ndefault : push ( 0 ) ; \n} \n} \nelse { \naconst_null ( ) ; \n} \nreturn ; \n} \n} \n"}
{"663": "public class CodeEmitter { \npublic void unbox_or_zero ( Type type ) { \nif ( TypeUtils . isPrimitive ( type ) ) { \nif ( type != Type . VOID_TYPE ) { \nLabel nonNull = make_label ( ) ; \nLabel end = make_label ( ) ; \ndup ( ) ; \nifnonnull ( nonNull ) ; \npop ( ) ; \nzero_or_null ( type ) ; \ngoTo ( end ) ; \nmark ( nonNull ) ; \nunbox ( type ) ; \nmark ( end ) ; \n} \n} \nelse { \ncheckcast ( type ) ; \n} \nreturn ; \n} \n} \n"}
{"664": "public class EmitUtils { \npublic static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { \nType componentType = TypeUtils . getComponentType ( type ) ; \nLocal array = e . make_local ( ) ; \nLocal loopvar = e . make_local ( Type . INT_TYPE ) ; \nLabel loopbody = e . make_label ( ) ; \nLabel checkloop = e . make_label ( ) ; \ne . store_local ( array ) ; \ne . push ( 0 ) ; \ne . store_local ( loopvar ) ; \ne . goTo ( checkloop ) ; \ne . mark ( loopbody ) ; \ne . load_local ( array ) ; \ne . load_local ( loopvar ) ; \ne . array_load ( componentType ) ; \ncallback . processElement ( componentType ) ; \ne . iinc ( loopvar , 1 ) ; \ne . mark ( checkloop ) ; \ne . load_local ( loopvar ) ; \ne . load_local ( array ) ; \ne . arraylength ( ) ; \ne . if_icmp ( e . LT , loopbody ) ; \nreturn ; \n} \n} \n"}
{"665": "public class EmitUtils { \nprivate static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { \ne . dup2 ( ) ; \nLabel nonNull = e . make_label ( ) ; \nLabel oneNullHelper = e . make_label ( ) ; \nLabel end = e . make_label ( ) ; \ne . ifnonnull ( nonNull ) ; \ne . ifnonnull ( oneNullHelper ) ; \ne . pop2 ( ) ; \ne . goTo ( bothNull ) ; \ne . mark ( nonNull ) ; \ne . ifnull ( oneNullHelper ) ; \ne . goTo ( end ) ; \ne . mark ( oneNullHelper ) ; \ne . pop2 ( ) ; \ne . goTo ( oneNull ) ; \ne . mark ( end ) ; \nreturn ; \n} \n} \n"}
{"667": "public class Enhancer { \npublic static void getMethods ( Class superclass , Class [ ] interfaces , List methods ) { \ngetMethods ( superclass , interfaces , methods , null , null ) ; \nreturn ; \n} \n} \n"}
{"668": "public class Enhancer { \nprotected void filterConstructors ( Class sc , List constructors ) { \nCollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , true ) ) ; \nif ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( \"No visible constructors in \" + sc ) ; \nreturn ; \n} \n} \n"}
{"669": "public class BeanGenerator { \npublic void setSuperclass ( Class superclass ) { \nif ( superclass != null && superclass . equals ( Object . class ) ) { \nsuperclass = null ; \n} \nthis . superclass = superclass ; \nreturn ; \n} \n} \n"}
{"670": "public class FieldProviderTransformer { \nprivate void getField ( String [ ] names ) throws Exception { \nfinal CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; \ne . load_this ( ) ; \ne . load_arg ( 0 ) ; \nEmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { \npublic void processCase ( Object key , Label end ) { \nType type = ( Type ) fields . get ( key ) ; \ne . getfield ( ( String ) key ) ; \ne . box ( type ) ; \ne . return_value ( ) ; \nreturn ; \n} \npublic void processDefault ( ) { \ne . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , \"Unknown field name\" ) ; \nreturn ; \n} \n} \n) ; \ne . end_method ( ) ; \nreturn ; \n} \n} \n"}
{"671": "public class InterfaceMaker { \npublic void add ( Method method ) { \nadd ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; \nreturn ; \n} \n} \n"}
{"673": "public class AbstractClassGenerator { \npublic void setNamingPolicy ( NamingPolicy namingPolicy ) { \nif ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; \nthis . namingPolicy = namingPolicy ; \nreturn ; \n} \n} \n"}
{"701": "public class MadvocConfigurations { \nprotected void collectActionInterceptors ( ) { \nfinal Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; \ninterceptors = new ArrayList < > ( ) ; \ninterceptors . addAll ( interceptorValues ) ; \ninterceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"702": "public class MadvocConfigurations { \nprotected void collectActionFilters ( ) { \nfinal Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; \nfilters = new ArrayList < > ( ) ; \nfilters . addAll ( filterValues ) ; \nfilters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"703": "public class MadvocConfigurations { \nprotected void collectActionResults ( ) { \nfinal Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; \nresults = new ArrayList < > ( ) ; \nresults . addAll ( resultsValues ) ; \nresults . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"704": "public class MadvocConfigurations { \nprotected void collectActionRuntimes ( ) { \nactions = actionsManager . getAllActionRuntimes ( ) ; \nactions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; \nreturn ; \n} \n} \n"}
{"705": "public class BeanUtilBean { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { \nSetter setter = bp . getSetter ( isDeclared ) ; \nif ( setter != null ) { \ninvokeSetter ( setter , bp , value ) ; \nreturn ; \n} \nif ( bp . isMap ( ) ) { \n( ( Map ) bp . bean ) . put ( bp . name , value ) ; \nreturn ; \n} \nif ( isSilent ) { \nreturn ; \n} \nthrow new BeanException ( \"Simple property not found: \" + bp . name , bp ) ; \nreturn ; \n} \n} \n"}
{"709": "public class TemplateData { \npublic void setObjectReference ( final String name , final Object object ) { \nif ( objectRefs == null ) { \nobjectRefs = new HashMap < > ( ) ; \n} \nobjectRefs . put ( name , object ) ; \nreturn ; \n} \n} \n"}
{"715": "public class TemplateData { \npublic void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { \nif ( tableRefs == null ) { \ntableRefs = new HashMap < > ( ) ; \n} \nTableRefData t = new TableRefData ( ded , tableAlias ) ; \nif ( tableRefs . put ( tableReference , t ) != null ) { \nthrow new DbSqlBuilderException ( \"Duplicated table reference: \" + tableReference ) ; \n} \nreturn ; \n} \n} \n"}
{"717": "public class TemplateData { \npublic void registerHint ( final String hint ) { \nif ( hints == null ) { \nhints = new ArrayList < > ( hintCount ) ; \n} \nhints . add ( hint ) ; \nreturn ; \n} \n} \n"}
{"719": "public class RequestScope { \nprotected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; \nwhile ( attributeNames . hasMoreElements ( ) ) { \nfinal String attrName = attributeNames . nextElement ( ) ; \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( attrName ) ; \nif ( name != null ) { \nfinal Object attrValue = servletRequest . getAttribute ( attrName ) ; \ntarget . writeValue ( name , attrValue , true ) ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { \nparamValues [ j ] = null ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"725": "public class SqlType { \npublic void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { \nT t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; \nset ( st , index , t , dbSqlType ) ; \nreturn ; \n} \n} \n"}
{"737": "public class WebApp { \nprotected void configureDefaults ( ) { \nfinal ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; \nactionConfigManager . registerAnnotation ( Action . class ) ; \nactionConfigManager . registerAnnotation ( RestAction . class ) ; \nreturn ; \n} \n} \n"}
{"738": "public class WebApp { \nprotected void registerMadvocComponents ( ) { \nif ( madvocContainer == null ) { \nthrow new MadvocException ( \"Madvoc WebApp not initialized.\" ) ; \n} \nlog . debug ( \"Registering Madvoc WebApp components\" ) ; \nmadvocContainer . registerComponent ( MadvocEncoding . class ) ; \nmadvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; \nmadvocContainer . registerComponent ( ActionConfigManager . class ) ; \nmadvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; \nmadvocContainer . registerComponent ( ActionMethodParser . class ) ; \nmadvocContainer . registerComponent ( ActionPathRewriter . class ) ; \nmadvocContainer . registerComponent ( ActionsManager . class ) ; \nmadvocContainer . registerComponent ( ContextInjectorComponent . class ) ; \nmadvocContainer . registerComponent ( InterceptorsManager . class ) ; \nmadvocContainer . registerComponent ( FiltersManager . class ) ; \nmadvocContainer . registerComponent ( MadvocController . class ) ; \nmadvocContainer . registerComponent ( RootPackages . class ) ; \nmadvocContainer . registerComponent ( ResultsManager . class ) ; \nmadvocContainer . registerComponent ( ResultMapper . class ) ; \nmadvocContainer . registerComponent ( ScopeResolver . class ) ; \nmadvocContainer . registerComponent ( ScopeDataInspector . class ) ; \nmadvocContainer . registerComponent ( AsyncActionExecutor . class ) ; \nmadvocContainer . registerComponent ( FileUploader . class ) ; \nreturn ; \n} \n} \n"}
{"743": "public class ClassScanner { \nprotected void scanJarFile ( final File file ) { \nfinal ZipFile zipFile ; \ntry { \nzipFile = new ZipFile ( file ) ; \n} \ncatch ( IOException ioex ) { \nif ( ! ignoreException ) { \nthrow new FindFileException ( \"Invalid zip: \" + file . getName ( ) , ioex ) ; \n} \nreturn ; \n} \nfinal Enumeration entries = zipFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nfinal ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; \nfinal String zipEntryName = zipEntry . getName ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { \nfinal String entryName = prepareEntryName ( zipEntryName , true ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \nelse if ( includeResources ) { \nfinal String entryName = prepareEntryName ( zipEntryName , false ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nZipUtil . close ( zipFile ) ; \nthrow rex ; \n} \n} \n} \nZipUtil . close ( zipFile ) ; \nreturn ; \n} \n} \n"}
{"744": "public class ClassScanner { \nprotected void scanClassPath ( final File root ) { \nString rootPath = root . getAbsolutePath ( ) ; \nif ( ! rootPath . endsWith ( File . separator ) ) { \nrootPath += File . separatorChar ; \n} \nfinal FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; \nFile file ; \nwhile ( ( file = ff . nextFile ( ) ) != null ) { \nfinal String filePath = file . getAbsolutePath ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { \nscanClassFile ( filePath , rootPath , file , true ) ; \n} \nelse if ( includeResources ) { \nscanClassFile ( filePath , rootPath , file , false ) ; \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nthrow rex ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"747": "public class ClassScanner { \npublic void start ( ) { \nif ( detectEntriesMode ) { \nrulesEntries . detectMode ( ) ; \n} \nfilesToScan . forEach ( file -> { \nfinal String path = file . getAbsolutePath ( ) ; \nif ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { \nif ( ! acceptJar ( file ) ) { \nreturn ; \n} \nscanJarFile ( file ) ; \n} \nelse if ( file . isDirectory ( ) ) { \nscanClassPath ( file ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"751": "public class ScopeResolver { \npublic void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { \nfinal MadvocScope scope = getOrInitScope ( scopeType ) ; \nmadvocScopeConsumer . accept ( scope ) ; \nreturn ; \n} \n} \n"}
{"754": "public class CsrfShield { \nprotected static void assureSize ( final Set < Token > tokenSet ) { \nif ( tokenSet . size ( ) < maxTokensPerSession ) { \nreturn ; \n} \nlong validUntilMin = Long . MAX_VALUE ; \nToken tokenToRemove = null ; \nIterator < Token > iterator = tokenSet . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nToken token = iterator . next ( ) ; \nif ( token . isExpired ( ) ) { \niterator . remove ( ) ; \ncontinue ; \n} \nif ( token . validUntil < validUntilMin ) { \nvalidUntilMin = token . validUntil ; \ntokenToRemove = token ; \n} \n} \nif ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { \ntokenSet . remove ( tokenToRemove ) ; \n} \nreturn ; \n} \n} \n"}
{"757": "public class BeanCopy { \npublic void copy ( ) { \nbeanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( true ) ; \nvisit ( ) ; \nreturn ; \n} \n} \n"}
{"759": "public class TableChunk { \n@ Override public void init ( final TemplateData templateData ) { \nsuper . init ( templateData ) ; \nif ( entity != null ) { \nded = lookupType ( entity ) ; \n} \nelse { \nObject object = templateData . getObjectReference ( entityName ) ; \nif ( object != null ) { \nded = lookupType ( resolveClass ( object ) ) ; \n} \nelse { \nded = lookupName ( entityName ) ; \n} \n} \nString tableReference = this . tableReference ; \nif ( tableReference == null ) { \ntableReference = tableAlias ; \n} \nif ( tableReference == null ) { \ntableReference = entityName ; \n} \nif ( tableReference == null ) { \ntableReference = ded . getEntityName ( ) ; \n} \ntemplateData . registerTableReference ( tableReference , ded , tableAlias ) ; \nreturn ; \n} \n} \n"}
{"762": "public class PetiteBeans { \nprotected void registerBean ( final String name , final BeanDefinition beanDefinition ) { \nbeans . put ( name , beanDefinition ) ; \nif ( ! petiteConfig . isUseAltBeanNames ( ) ) { \nreturn ; \n} \nClass type = beanDefinition . type ( ) ; \nif ( annotationResolver . beanHasAnnotationName ( type ) ) { \nreturn ; \n} \nClass [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; \nfor ( Class anInterface : interfaces ) { \nString altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; \nif ( name . equals ( altName ) ) { \ncontinue ; \n} \nif ( beans . containsKey ( altName ) ) { \ncontinue ; \n} \nif ( beansAlt . containsKey ( altName ) ) { \nBeanDefinition existing = beansAlt . get ( altName ) ; \nif ( existing != null ) { \nbeansAlt . put ( altName , null ) ; \n} \n} \nelse { \nbeansAlt . put ( altName , beanDefinition ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"763": "public class PetiteBeans { \npublic void removeBean ( final Class type ) { \nSet < String > beanNames = new HashSet < > ( ) ; \nfor ( BeanDefinition def : beans . values ( ) ) { \nif ( def . type . equals ( type ) ) { \nbeanNames . add ( def . name ) ; \n} \n} \nfor ( String beanName : beanNames ) { \nremoveBean ( beanName ) ; \n} \nreturn ; \n} \n} \n"}
{"765": "public class PetiteBeans { \npublic void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nConstructor constructor = null ; \nif ( paramTypes == null ) { \nCtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; \nif ( ctors != null && ctors . length > 0 ) { \nif ( ctors . length > 1 ) { \nthrow new PetiteException ( ctors . length + \" suitable constructor found as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nconstructor = ctors [ 0 ] . getConstructor ( ) ; \n} \n} \nelse { \nCtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; \nif ( ctorDescriptor != null ) { \nconstructor = ctorDescriptor . getConstructor ( ) ; \n} \n} \nif ( constructor == null ) { \nthrow new PetiteException ( \"Constructor not found: \" + beanDefinition . type . getName ( ) ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; \nbeanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; \nreturn ; \n} \n} \n"}
{"766": "public class PetiteBeans { \npublic void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nPropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; \nif ( propertyDescriptor == null ) { \nthrow new PetiteException ( \"Property not found: \" + beanDefinition . type . getName ( ) + '#' + property ) ; \n} \nBeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; \nPropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; \nbeanDefinition . addPropertyInjectionPoint ( pip ) ; \nreturn ; \n} \n} \n"}
{"767": "public class PetiteBeans { \npublic void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nPropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; \nif ( propertyDescriptor == null ) { \nthrow new PetiteException ( \"Property not found: \" + beanDefinition . type . getName ( ) + '#' + property ) ; \n} \nSetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; \nbeanDefinition . addSetInjectionPoint ( sip ) ; \nreturn ; \n} \n} \n"}
{"768": "public class PetiteBeans { \npublic void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nMethod method = null ; \nif ( arguments == null ) { \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; \nif ( methods != null && methods . length > 0 ) { \nif ( methods . length > 1 ) { \nthrow new PetiteException ( methods . length + \" suitable methods found as injection points for: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nmethod = methods [ 0 ] . getMethod ( ) ; \n} \n} \nelse { \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md != null ) { \nmethod = md . getMethod ( ) ; \n} \n} \nif ( method == null ) { \nthrow new PetiteException ( \"Method not found: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; \nMethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; \nbeanDefinition . addMethodInjectionPoint ( mip ) ; \nreturn ; \n} \n} \n"}
{"769": "public class PetiteBeans { \npublic void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( initMethodNames == null ) { \ninitMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = initMethodNames . length ; \nInitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ni < initMethodNames . length ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; \n} \ninitMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; \n} \nbeanDefinition . addInitMethodPoints ( initMethodPoints ) ; \nreturn ; \n} \n} \n"}
{"770": "public class PetiteBeans { \npublic void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( destroyMethodNames == null ) { \ndestroyMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = destroyMethodNames . length ; \nDestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ni < destroyMethodNames . length ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; \n} \ndestroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; \n} \nbeanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; \nreturn ; \n} \n} \n"}
{"771": "public class PetiteBeans { \npublic void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { \nBeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; \nif ( beanDefinition == null ) { \nthrow new PetiteException ( \"Bean not found: \" + beanName ) ; \n} \nClass beanType = beanDefinition . type ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Provider method not found: \" + methodName ) ; \n} \nProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; \nproviders . put ( providerName , providerDefinition ) ; \nreturn ; \n} \n} \n"}
{"772": "public class PetiteBeans { \npublic void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nMethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Provider method not found: \" + staticMethodName ) ; \n} \nProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; \nproviders . put ( providerName , providerDefinition ) ; \nreturn ; \n} \n} \n"}
{"773": "public class PetiteBeans { \npublic void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { \nforEachBean ( bd -> { \nif ( ClassUtil . isTypeOf ( bd . type , type ) ) { \nbeanNameConsumer . accept ( bd . name ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"774": "public class PetiteBeans { \npublic void defineParameters ( final Map < ? , ? > properties ) { \nfor ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { \ndefineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"777": "public class ProxettaAsmUtil { \npublic static void pushInt ( final MethodVisitor mv , final int value ) { \nif ( value <= 5 ) { \nmv . visitInsn ( ICONST_0 + value ) ; \n} \nelse if ( value <= Byte . MAX_VALUE ) { \nmv . visitIntInsn ( BIPUSH , value ) ; \n} \nelse { \nmv . visitIntInsn ( SIPUSH , value ) ; \n} \nreturn ; \n} \n} \n"}
{"778": "public class ProxettaAsmUtil { \npublic static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { \nif ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { \nthrow new ProxettaException ( \"Invalid argument index: \" + argIndex ) ; \n} \nreturn ; \n} \n} \n"}
{"781": "public class ProxettaAsmUtil { \npublic static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nfor ( int i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \nreturn ; \n} \n} \n"}
{"782": "public class ProxettaAsmUtil { \npublic static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 0 ; \ni < methodInfo . getArgumentsCount ( ) ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \nreturn ; \n} \n} \n"}
{"783": "public class ProxettaAsmUtil { \npublic static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \nreturn ; \n} \n} \n"}
{"784": "public class ProxettaAsmUtil { \npublic static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { \nint offset = methodInfo . getArgumentOffset ( index ) ; \nint type = methodInfo . getArgument ( index ) . getOpcode ( ) ; \nswitch ( type ) { \ncase 'V' : break ; \ncase 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ILOAD , offset ) ; \nbreak ; \ncase 'J' : mv . visitVarInsn ( LLOAD , offset ) ; \nbreak ; \ncase 'F' : mv . visitVarInsn ( FLOAD , offset ) ; \nbreak ; \ncase 'D' : mv . visitVarInsn ( DLOAD , offset ) ; \nbreak ; \ndefault : mv . visitVarInsn ( ALOAD , offset ) ; \n} \nreturn ; \n} \n} \n"}
{"785": "public class ProxettaAsmUtil { \npublic static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { \nint offset = methodInfo . getArgumentOffset ( index ) ; \nint type = methodInfo . getArgument ( index ) . getOpcode ( ) ; \nswitch ( type ) { \ncase 'V' : break ; \ncase 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ISTORE , offset ) ; \nbreak ; \ncase 'J' : mv . visitVarInsn ( LSTORE , offset ) ; \nbreak ; \ncase 'F' : mv . visitVarInsn ( FSTORE , offset ) ; \nbreak ; \ncase 'D' : mv . visitVarInsn ( DSTORE , offset ) ; \nbreak ; \ndefault : mv . visitVarInsn ( ASTORE , offset ) ; \n} \nreturn ; \n} \n} \n"}
{"786": "public class ProxettaAsmUtil { \npublic static void prepareReturnValue ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { \nvarOffset += methodInfo . getAllArgumentsSize ( ) ; \nswitch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { \ncase 'V' : mv . visitInsn ( ACONST_NULL ) ; \nbreak ; \ncase 'B' : AsmUtil . valueOfByte ( mv ) ; \nbreak ; \ncase 'C' : AsmUtil . valueOfCharacter ( mv ) ; \nbreak ; \ncase 'S' : AsmUtil . valueOfShort ( mv ) ; \nbreak ; \ncase 'I' : AsmUtil . valueOfInteger ( mv ) ; \nbreak ; \ncase 'Z' : AsmUtil . valueOfBoolean ( mv ) ; \nbreak ; \ncase 'J' : AsmUtil . valueOfLong ( mv ) ; \nbreak ; \ncase 'F' : AsmUtil . valueOfFloat ( mv ) ; \nbreak ; \ncase 'D' : AsmUtil . valueOfDouble ( mv ) ; \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"788": "public class ProxettaAsmUtil { \npublic static void newArray ( final MethodVisitor mv , final Class componentType ) { \nif ( componentType == int . class ) { \nmv . visitIntInsn ( NEWARRAY , T_INT ) ; \nreturn ; \n} \nif ( componentType == long . class ) { \nmv . visitIntInsn ( NEWARRAY , T_LONG ) ; \nreturn ; \n} \nif ( componentType == float . class ) { \nmv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; \nreturn ; \n} \nif ( componentType == double . class ) { \nmv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; \nreturn ; \n} \nif ( componentType == byte . class ) { \nmv . visitIntInsn ( NEWARRAY , T_BYTE ) ; \nreturn ; \n} \nif ( componentType == short . class ) { \nmv . visitIntInsn ( NEWARRAY , T_SHORT ) ; \nreturn ; \n} \nif ( componentType == boolean . class ) { \nmv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; \nreturn ; \n} \nif ( componentType == char . class ) { \nmv . visitIntInsn ( NEWARRAY , T_CHAR ) ; \nreturn ; \n} \nmv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; \nreturn ; \n} \n} \n"}
{"789": "public class ProxettaAsmUtil { \npublic static void storeIntoArray ( final MethodVisitor mv , final Class componentType ) { \nif ( componentType == int . class ) { \nmv . visitInsn ( IASTORE ) ; \nreturn ; \n} \nif ( componentType == long . class ) { \nmv . visitInsn ( LASTORE ) ; \nreturn ; \n} \nif ( componentType == float . class ) { \nmv . visitInsn ( FASTORE ) ; \nreturn ; \n} \nif ( componentType == double . class ) { \nmv . visitInsn ( DASTORE ) ; \nreturn ; \n} \nif ( componentType == byte . class ) { \nmv . visitInsn ( BASTORE ) ; \nreturn ; \n} \nif ( componentType == short . class ) { \nmv . visitInsn ( SASTORE ) ; \nreturn ; \n} \nif ( componentType == boolean . class ) { \nmv . visitInsn ( BASTORE ) ; \nreturn ; \n} \nif ( componentType == char . class ) { \nmv . visitInsn ( CASTORE ) ; \nreturn ; \n} \nmv . visitInsn ( AASTORE ) ; \nreturn ; \n} \n} \n"}
{"793": "public class ServletUtil { \npublic static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { \nresp . setHeader ( WWW_AUTHENTICATE , \"Basic realm=\\\"\" + realm + '\\\"' ) ; \nresp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; \nreturn ; \n} \n} \n"}
{"794": "public class ServletUtil { \npublic static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { \nif ( ! file . exists ( ) ) { \nthrow new IllegalArgumentException ( \"File not found: \" + file ) ; \n} \nif ( file . length ( ) > Integer . MAX_VALUE ) { \nthrow new IllegalArgumentException ( \"File too big: \" + file ) ; \n} \nprepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; \nreturn ; \n} \n} \n"}
{"795": "public class ServletUtil { \npublic static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { \nif ( ( mimeType == null ) && ( fileName != null ) ) { \nString extension = FileNameUtil . getExtension ( fileName ) ; \nmimeType = MimeTypes . getMimeType ( extension ) ; \n} \nif ( mimeType != null ) { \nresponse . setContentType ( mimeType ) ; \n} \nif ( fileSize >= 0 ) { \nresponse . setContentLength ( fileSize ) ; \n} \nif ( fileName != null ) { \nString name = FileNameUtil . getName ( fileName ) ; \nString encodedFileName = URLCoder . encode ( name ) ; \nresponse . setHeader ( CONTENT_DISPOSITION , \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName ) ; \n} \nreturn ; \n} \n} \n"}
{"799": "public class ServletUtil { \npublic static void storeContextPath ( final PageContext pageContext , final String contextPathVariableName ) { \nString ctxPath = getContextPath ( pageContext ) ; \nHttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nrequest . setAttribute ( contextPathVariableName , ctxPath ) ; \nServletContext servletContext = pageContext . getServletContext ( ) ; \nservletContext . setAttribute ( contextPathVariableName , ctxPath ) ; \nreturn ; \n} \n} \n"}
{"800": "public class ServletUtil { \npublic static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { \nString ctxPath = getContextPath ( servletContext ) ; \nservletContext . setAttribute ( contextPathVariableName , ctxPath ) ; \nreturn ; \n} \n} \n"}
{"803": "public class ServletUtil { \npublic static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nEnumeration paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nString paramName = ( String ) paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues == null ) { \ncontinue ; \n} \nservletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \n} \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nMultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nparamNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nString paramName = ( String ) paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \nFileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nservletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \n} \nreturn ; \n} \n} \n"}
{"804": "public class TagUtil { \npublic static void invokeBody ( final JspFragment body ) throws JspException { \nif ( body == null ) { \nreturn ; \n} \ntry { \nbody . invoke ( null ) ; \n} \ncatch ( IOException ioex ) { \nthrow new JspException ( \"Tag body failed\" , ioex ) ; \n} \nreturn ; \n} \n} \n"}
{"807": "public class BeanData { \npublic void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { \nfor ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { \nif ( invocationStrategy != initMethod . invocationStrategy ) { \ncontinue ; \n} \ntry { \ninitMethod . method . invoke ( bean ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid init method: \" + initMethod , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"808": "public class BeanData { \npublic void callDestroyMethods ( ) { \nfor ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { \ntry { \ndestroyMethodPoint . method . invoke ( bean ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid destroy method: \" + destroyMethodPoint . method , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"810": "public class BeanData { \npublic void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { \nif ( beanDefinition . name == null ) { \nreturn ; \n} \nif ( implicitParamInjection ) { \nfinal int len = beanDefinition . name . length ( ) + 1 ; \nfor ( final String param : beanDefinition . params ) { \nfinal Object value = paramManager . get ( param ) ; \nfinal String destination = param . substring ( len ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , destination , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition . name , ex ) ; \n} \n} \n} \nfor ( final ValueInjectionPoint pip : beanDefinition . values ) { \nfinal String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; \ntry { \nBeanUtil . declared . setProperty ( bean , pip . property , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Unable to set value for: '\" + pip . valueTemplate + \"' to bean: \" + beanDefinition . name , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"812": "public class HeadersMultiMap { \npublic void addHeader ( final String name , final String value ) { \nList < String > valuesList = super . getAll ( name ) ; \nif ( valuesList . isEmpty ( ) ) { \nsuper . add ( name , value ) ; \nreturn ; \n} \nsuper . remove ( name ) ; \nvaluesList . add ( value ) ; \nsuper . addAll ( name , valuesList ) ; \nreturn ; \n} \n} \n"}
{"813": "public class PropsData { \nprotected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { \nString realValue = value ; \nif ( append || appendDuplicateProps ) { \nPropsEntry pv = map . get ( key ) ; \nif ( pv != null ) { \nrealValue = pv . value + APPEND_SEPARATOR + realValue ; \n} \n} \nPropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; \nif ( first == null ) { \nfirst = propsEntry ; \n} \nelse { \nlast . next = propsEntry ; \n} \nlast = propsEntry ; \nmap . put ( key , propsEntry ) ; \nreturn ; \n} \n} \n"}
{"814": "public class PropsData { \npublic void putBaseProperty ( final String key , final String value , final boolean append ) { \nput ( null , baseProperties , key , value , append ) ; \nreturn ; \n} \n} \n"}
{"815": "public class PropsData { \npublic void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { \nMap < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap < > ( ) ) ; \nput ( profile , map , key , value , append ) ; \nreturn ; \n} \n} \n"}
{"826": "public class ActionMethodParser { \nprotected void detectAndRegisterAlias ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { \nfinal String alias = parseMethodAlias ( annotationValues ) ; \nif ( alias != null ) { \nString aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; \nactionsManager . registerPathAlias ( alias , aliasPath ) ; \n} \nreturn ; \n} \n} \n"}
{"833": "public class DecoraResponseWrapper { \n@ Override protected void preResponseCommit ( ) { \nlong lastModified = lastModifiedData . getLastModified ( ) ; \nlong ifModifiedSince = request . getDateHeader ( \"If-Modified-Since\" ) ; \nif ( lastModified > - 1 && ! response . containsHeader ( \"Last-Modified\" ) ) { \nif ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { \nresponse . setDateHeader ( \"Last-Modified\" , lastModified ) ; \n} \nelse { \nresponse . reset ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"835": "public class DelegateAdviceUtil { \npublic static void injectTargetIntoProxy ( final Object proxy , final Object target ) { \nClass proxyClass = proxy . getClass ( ) ; \ntry { \nField field = proxyClass . getField ( \"$___target$0\" ) ; \nfield . set ( proxy , target ) ; \n} \ncatch ( Exception ex ) { \nthrow new ProxettaException ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nint currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \nfor ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \n-- i ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n} \nif ( bootstrapMethodCount > 0 ) { \nint bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nint bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nint currentOffset = bootstrapMethodsOffset ; \nfor ( int i = 0 ; \ni < bootstrapMethodCount ; \ni ++ ) { \nint offset = currentOffset - bootstrapMethodsOffset ; \nint bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nwhile ( numBootstrapArguments -- > 0 ) { \nint bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"847": "public class SymbolTable { \nvoid putConstantPool ( final ByteVector output ) { \noutput . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; \nreturn ; \n} \n} \n"}
{"848": "public class SymbolTable { \nvoid putBootstrapMethods ( final ByteVector output ) { \nif ( bootstrapMethods != null ) { \noutput . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; \n} \nreturn ; \n} \n} \n"}
{"852": "public class SymbolTable { \nprivate void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { \nadd ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; \nreturn ; \n} \n} \n"}
{"854": "public class SymbolTable { \nprivate void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { \nadd ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; \nreturn ; \n} \n} \n"}
{"856": "public class SymbolTable { \nprivate void addConstantLongOrDouble ( final int index , final int tag , final long value ) { \nadd ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; \nreturn ; \n} \n} \n"}
{"858": "public class SymbolTable { \nprivate void addConstantNameAndType ( final int index , final String name , final String descriptor ) { \nfinal int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nadd ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; \nreturn ; \n} \n} \n"}
{"860": "public class SymbolTable { \nprivate void addConstantUtf8 ( final int index , final String value ) { \nadd ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; \nreturn ; \n} \n} \n"}
{"862": "public class SymbolTable { \nprivate void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nadd ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \nreturn ; \n} \n} \n"}
{"866": "public class SymbolTable { \nprivate void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nint hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nadd ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \nreturn ; \n} \n} \n"}
{"868": "public class SymbolTable { \nprivate void addConstantUtf8Reference ( final int index , final int tag , final String value ) { \nadd ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; \nreturn ; \n} \n} \n"}
{"874": "public class HttpMultiMap { \n@ Override public Iterator < Map . Entry < String , V > > iterator ( ) { \nfinal MapEntry [ ] e = { \nhead . after } \n; \nreturn new Iterator < Map . Entry < String , V > > ( ) { \n@ Override public boolean hasNext ( ) { \nreturn e [ 0 ] != head ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public Map . Entry < String , V > next ( ) { \nif ( ! hasNext ( ) ) { \nthrow new NoSuchElementException ( \"No next() entry in the iteration\" ) ; \n} \nMapEntry < V > next = e [ 0 ] ; \ne [ 0 ] = e [ 0 ] . after ; \nreturn next ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"876": "public class FastCharBuffer { \nprivate void grow ( final int minCapacity ) { \nfinal int oldCapacity = buffer . length ; \nint newCapacity = oldCapacity << 1 ; \nif ( newCapacity - minCapacity < 0 ) { \nnewCapacity = minCapacity + 512 ; \n} \nbuffer = Arrays . copyOf ( buffer , newCapacity ) ; \nreturn ; \n} \n} \n"}
{"879": "public class ProxettaMethodBuilder { \n@ Override public void visitEnd ( ) { \ncreateFirstChainDelegate_Continue ( tmd ) ; \nfor ( int p = 0 ; \np < tmd . proxyData . length ; \np ++ ) { \ntmd . selectCurrentProxy ( p ) ; \ncreateProxyMethod ( tmd ) ; \n} \nreturn ; \n} \n} \n"}
{"880": "public class ProxettaMethodBuilder { \nprotected void createFirstChainDelegate_Start ( ) { \nint access = msign . getAccessFlags ( ) ; \nif ( ! wd . allowFinalMethods ) { \nif ( ( access & AsmUtil . ACC_FINAL ) != 0 ) { \nthrow new ProxettaException ( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\" ) ; \n} \n} \ntmd = new TargetMethodData ( msign , aspectList ) ; \naccess &= ~ ACC_NATIVE ; \naccess &= ~ ACC_ABSTRACT ; \nmethodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; \nreturn ; \n} \n} \n"}
{"881": "public class ProxettaMethodBuilder { \nprotected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { \nmethodVisitor . visitCode ( ) ; \nif ( tmd . msign . isStatic ) { \nloadStaticMethodArguments ( methodVisitor , tmd . msign ) ; \nmethodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; \n} \nelse { \nloadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; \nmethodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; \n} \nvisitReturn ( methodVisitor , tmd . msign , false ) ; \nmethodVisitor . visitMaxs ( 0 , 0 ) ; \nmethodVisitor . visitEnd ( ) ; \nreturn ; \n} \n} \n"}
{"884": "public class JoyContextListener { \nprivate void configureServletContext ( final ServletContext servletContext ) { \nservletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; \nif ( decoraEnabled ) { \nfinal FilterRegistration filter = servletContext . addFilter ( \"decora\" , jodd . decora . DecoraServletFilter . class ) ; \nfilter . addMappingForUrlPatterns ( null , true , contextPath ) ; \n} \nfinal FilterRegistration filter = servletContext . addFilter ( \"madvoc\" , jodd . madvoc . MadvocServletFilter . class ) ; \nfilter . addMappingForUrlPatterns ( madvocDispatcherTypes , true , contextPath ) ; \nreturn ; \n} \n} \n"}
{"890": "public class IntHashMap { \n@ Override public void putAll ( final Map t ) { \nfor ( Object o : t . entrySet ( ) ) { \nMap . Entry e = ( Map . Entry ) o ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"892": "public class Buffer { \npublic void writeTo ( final Writer writer ) throws IOException { \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] array = fastByteBuffer . toArray ( ) ; \nwriter . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \ntry { \nStreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"893": "public class Buffer { \npublic void writeTo ( final OutputStream out ) throws IOException { \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nout . write ( fastByteBuffer . toArray ( ) ) ; \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \ntry { \nStreamUtil . copy ( inputStream , out ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nwhile ( offset < bytes . length ) { \nint chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( remaining > 0 ) { \nint chunk = callbackSize - step ; \nif ( chunk > remaining ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \nreturn ; \n} \n} \n"}
{"902": "public class ReceiveMailSession { \npublic void useFolder ( final String folderName ) { \ncloseFolderIfOpened ( folder ) ; \ntry { \nthis . folderName = folderName ; \nthis . folder = getService ( ) . getFolder ( folderName ) ; \ntry { \nfolder . open ( Folder . READ_WRITE ) ; \n} \ncatch ( final MailException ignore ) { \nfolder . open ( Folder . READ_ONLY ) ; \n} \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to connect to folder: \" + folderName , msgexc ) ; \n} \nreturn ; \n} \n} \n"}
{"904": "public class ReceiveMailSession { \npublic void updateEmailFlags ( final ReceivedEmail receivedEmail ) { \nuseAndOpenFolderIfNotSet ( ) ; \ntry { \nfolder . setFlags ( new int [ ] { \nreceivedEmail . messageNumber ( ) } \n, receivedEmail . flags ( ) , true ) ; \n} \ncatch ( MessagingException mex ) { \nthrow new MailException ( \"Failed to fetch messages\" , mex ) ; \n} \nreturn ; \n} \n} \n"}
{"905": "public class ReceiveMailSession { \nprotected void closeFolderIfOpened ( final Folder folder ) { \nif ( folder != null ) { \ntry { \nfolder . close ( true ) ; \n} \ncatch ( final MessagingException ignore ) { \n} \n} \nreturn ; \n} \n} \n"}
{"909": "public class AppAction { \nprotected void addViolation ( final String name , final Object invalidValue ) { \nprepareValidator ( ) ; \nvtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; \nreturn ; \n} \n} \n"}
{"915": "public class ProxettaFactory { \nprotected void process ( ) { \nif ( targetInputStream == null ) { \nthrow new ProxettaException ( \"Target missing: \" + targetClassName ) ; \n} \nfinal ClassReader classReader ; \ntry { \nclassReader = new ClassReader ( targetInputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Error reading class input stream\" , ioex ) ; \n} \nfinal TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader ( proxetta . getClassLoader ( ) ) ; \nclassReader . accept ( targetClassInfoReader , 0 ) ; \nthis . destClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS | ClassWriter . COMPUTE_FRAMES ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"processing: \" + classReader . getClassName ( ) ) ; \n} \nWorkData wd = process ( classReader , targetClassInfoReader ) ; \nproxyApplied = wd . proxyApplied ; \nproxyClassName = wd . thisReference . replace ( '/' , '.' ) ; \nreturn ; \n} \n} \n"}
{"919": "public class ProxettaFactory { \nprotected void dumpClassInDebugFolder ( final byte [ ] bytes ) { \nFile debugFolder = proxetta . getDebugFolder ( ) ; \nif ( debugFolder == null ) { \nreturn ; \n} \nif ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { \nlog . warn ( \"Invalid debug folder: \" + debugFolder ) ; \n} \nString fileName = proxyClassName ; \nif ( fileName == null ) { \nfileName = \"proxetta-\" + System . currentTimeMillis ( ) ; \n} \nfileName += \".class\" ; \nFile file = new File ( debugFolder , fileName ) ; \ntry { \nFileUtil . writeBytes ( file , bytes ) ; \n} \ncatch ( IOException ioex ) { \nlog . warn ( \"Error writing class as \" + file , ioex ) ; \n} \nreturn ; \n} \n} \n"}
{"944": "public class Threefish { \npublic void init ( final long [ ] key , final long [ ] tweak ) { \nfinal int newNw = key . length ; \nif ( nw != newNw ) { \nnw = newNw ; \nswitch ( nw ) { \ncase WORDS_4 : pi = PI4 ; \nrpi = RPI4 ; \nr = R4 ; \nbreak ; \ncase WORDS_8 : pi = PI8 ; \nrpi = RPI8 ; \nr = R8 ; \nbreak ; \ncase WORDS_16 : pi = PI16 ; \nrpi = RPI16 ; \nr = R16 ; \nbreak ; \ndefault : throw new RuntimeException ( \"Invalid threefish key\" ) ; \n} \nthis . k = new long [ nw + 1 ] ; \nvd = new long [ nw ] ; \ned = new long [ nw ] ; \nfd = new long [ nw ] ; \nksd = new long [ nw ] ; \n} \nSystem . arraycopy ( key , 0 , this . k , 0 , key . length ) ; \nlong knw = EXTENDED_KEY_SCHEDULE_CONST ; \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) { \nknw ^= this . k [ i ] ; \n} \nthis . k [ nw ] = knw ; \nt [ 0 ] = tweak [ 0 ] ; \nt [ 1 ] = tweak [ 1 ] ; \nt [ 2 ] = t [ 0 ] ^ t [ 1 ] ; \nreturn ; \n} \n} \n"}
{"945": "public class Threefish { \nprivate void mix ( final int j , final int d ) { \ny [ 0 ] = x [ 0 ] + x [ 1 ] ; \nfinal long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; \ny [ 1 ] = ( x [ 1 ] << rotl ) | ( x [ 1 ] >>> ( Long . SIZE - rotl ) ) ; \ny [ 1 ] ^= y [ 0 ] ; \nreturn ; \n} \n} \n"}
{"946": "public class Threefish { \nprivate void demix ( final int j , final int d ) { \ny [ 1 ] ^= y [ 0 ] ; \nfinal long rotr = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; \nx [ 1 ] = ( y [ 1 ] << ( Long . SIZE - rotr ) ) | ( y [ 1 ] >>> rotr ) ; \nx [ 0 ] = y [ 0 ] - x [ 1 ] ; \nreturn ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 2 ) { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \n} \nreturn ; \n} \n} \n"}
{"948": "public class Threefish { \npublic void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { \nlong [ ] tweak = new long [ ] { \ntweak1 , tweak2 } \n; \nbyte [ ] key = new byte [ blockSize / Byte . SIZE ] ; \nbyte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; \nSystem . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; \ninit ( bytesToLongs ( key ) , tweak ) ; \nreturn ; \n} \n} \n"}
{"957": "public class ZipUtil { \npublic static void unzip ( final String zipFile , final String destDir , final String ... patterns ) throws IOException { \nunzip ( new File ( zipFile ) , new File ( destDir ) , patterns ) ; \nreturn ; \n} \n} \n"}
{"958": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { \nif ( ! file . exists ( ) ) { \nthrow new FileNotFoundException ( file . toString ( ) ) ; \n} \nif ( path == null ) { \npath = file . getName ( ) ; \n} \nwhile ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { \npath = path . substring ( 1 ) ; \n} \nboolean isDir = file . isDirectory ( ) ; \nif ( isDir ) { \nif ( ! StringUtil . endsWithChar ( path , '/' ) ) { \npath += '/' ; \n} \n} \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( file . lastModified ( ) ) ; \nif ( comment != null ) { \nzipEntry . setComment ( comment ) ; \n} \nif ( isDir ) { \nzipEntry . setSize ( 0 ) ; \nzipEntry . setCrc ( 0 ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nif ( ! isDir ) { \nInputStream is = new FileInputStream ( file ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \n} \nzos . closeEntry ( ) ; \nif ( recursive && file . isDirectory ( ) ) { \nboolean noRelativePath = StringUtil . isEmpty ( path ) ; \nfinal File [ ] children = file . listFiles ( ) ; \nif ( children != null && children . length != 0 ) { \nfor ( File child : children ) { \nString childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; \naddToZip ( zos , child , childRelativePath , comment , recursive ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"959": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { \nwhile ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { \npath = path . substring ( 1 ) ; \n} \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath = path . substring ( 0 , path . length ( ) - 1 ) ; \n} \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( System . currentTimeMillis ( ) ) ; \nif ( comment != null ) { \nzipEntry . setComment ( comment ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nInputStream is = new ByteArrayInputStream ( content ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \nzos . closeEntry ( ) ; \nreturn ; \n} \n} \n"}
{"962": "public class LocalizationUtil { \npublic static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Bundle name for this request: \" + bundleName ) ; \n} \nrequest . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; \nreturn ; \n} \n} \n"}
{"963": "public class LocalizationUtil { \npublic static void setSessionLocale ( final HttpSession session , final String localeCode ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Locale stored to session: \" + localeCode ) ; \n} \nLocale locale = Locale . forLanguageTag ( localeCode ) ; \nsession . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; \nreturn ; \n} \n} \n"}
{"979": "public class DecoraServletFilter { \n@ Override public void init ( final FilterConfig filterConfig ) throws ServletException { \nfinal String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; \nif ( decoraManagerClass != null ) { \ntry { \nfinal Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; \ndecoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Unable to load Decora manager class: \" + decoraManagerClass , ex ) ; \nthrow new ServletException ( ex ) ; \n} \n} \nelse { \ndecoraManager = createDecoraManager ( ) ; \n} \nfinal String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; \nif ( decoraParserClass != null ) { \ntry { \nfinal Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; \ndecoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Unable to load Decora parser class: \" + decoraParserClass , ex ) ; \nthrow new ServletException ( ex ) ; \n} \n} \nelse { \ndecoraParser = createDecoraParser ( ) ; \n} \nfinal String decoraCache = filterConfig . getInitParameter ( PARAM_DECORA_CACHE ) ; \nif ( decoraCache != null ) { \ncached = Converter . get ( ) . toBoolean ( decoraCache , false ) ; \n} \nreturn ; \n} \n} \n"}
{"985": "public class FindFile { \nprotected void addPath ( final File path ) { \nif ( ! path . exists ( ) ) { \nreturn ; \n} \nif ( pathList == null ) { \npathList = new LinkedList < > ( ) ; \n} \npathList . add ( path ) ; \nreturn ; \n} \n} \n"}
{"987": "public class FindFile { \nprotected void init ( ) { \nrules . detectMode ( ) ; \ntodoFiles = new LinkedList < > ( ) ; \ntodoFolders = new LinkedList < > ( ) ; \nif ( pathList == null ) { \npathList = new LinkedList < > ( ) ; \nreturn ; \n} \nif ( pathListOriginal == null ) { \npathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; \n} \nString [ ] files = new String [ pathList . size ( ) ] ; \nint index = 0 ; \nIterator < File > iterator = pathList . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nFile file = iterator . next ( ) ; \nif ( file . isFile ( ) ) { \nfiles [ index ++ ] = file . getAbsolutePath ( ) ; \niterator . remove ( ) ; \n} \n} \nif ( index != 0 ) { \nFilesIterator filesIterator = new FilesIterator ( files ) ; \ntodoFiles . add ( filesIterator ) ; \n} \nreturn ; \n} \n} \n"}
{"988": "public class FindFile { \n@ Override public Iterator < File > iterator ( ) { \nreturn new Iterator < File > ( ) { \nprivate File nextFile ; \n@ Override public boolean hasNext ( ) { \nnextFile = nextFile ( ) ; \nreturn nextFile != null ; \n} \n@ Override public File next ( ) { \nif ( nextFile == null ) { \nthrow new NoSuchElementException ( ) ; \n} \nreturn nextFile ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"991": "public class Buffer { \npublic PrintWriter getWriter ( ) { \nif ( outWriter == null ) { \nif ( outStream != null ) { \nthrow new IllegalStateException ( \"Can't call getWriter() after getOutputStream()\" ) ; \n} \nbufferedWriter = new FastCharArrayWriter ( ) ; \noutWriter = new PrintWriter ( bufferedWriter ) { \n@ Override public void close ( ) { \nreturn ; \n} \n} \n; \n} \nreturn outWriter ; \n} \n} \n"}
{"997": "public class Type { \nprivate void appendDescriptor ( final StringBuilder stringBuilder ) { \nif ( sort == OBJECT ) { \nstringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; \n} \nelse if ( sort == INTERNAL ) { \nstringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; \n} \nelse { \nstringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; \n} \nreturn ; \n} \n} \n"}
{"1000": "public class JtxTransaction { \npublic void setRollbackOnly ( final Throwable th ) { \nif ( ! isNoTransaction ( ) ) { \nif ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { \nthrow new JtxException ( \"TNo active TX that can be marked as rollback only\" ) ; \n} \n} \nrollbackCause = th ; \nstatus = STATUS_MARKED_ROLLBACK ; \nreturn ; \n} \n} \n"}
{"1001": "public class JtxTransaction { \nprotected void commitOrRollback ( boolean doCommit ) { \nif ( log . isDebugEnabled ( ) ) { \nif ( doCommit ) { \nlog . debug ( \"Commit JTX\" ) ; \n} \nelse { \nlog . debug ( \"Rollback JTX\" ) ; \n} \n} \nboolean forcedRollback = false ; \nif ( ! isNoTransaction ( ) ) { \nif ( isRollbackOnly ( ) ) { \nif ( doCommit ) { \ndoCommit = false ; \nforcedRollback = true ; \n} \n} \nelse if ( ! isActive ( ) ) { \nif ( isCompleted ( ) ) { \nthrow new JtxException ( \"TX is already completed, commit or rollback should be called once per TX\" ) ; \n} \nthrow new JtxException ( \"No active TX to \" + ( doCommit ? \"commit\" : \"rollback\" ) ) ; \n} \n} \nif ( doCommit ) { \ncommitAllResources ( ) ; \n} \nelse { \nrollbackAllResources ( forcedRollback ) ; \n} \nreturn ; \n} \n} \n"}
{"1002": "public class JtxTransaction { \nprotected void rollbackAllResources ( final boolean wasForced ) { \nstatus = STATUS_ROLLING_BACK ; \nException lastException = null ; \nIterator < JtxResource > it = resources . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nJtxResource resource = it . next ( ) ; \ntry { \nresource . rollbackTransaction ( ) ; \n} \ncatch ( Exception ex ) { \nlastException = ex ; \n} \nfinally { \nit . remove ( ) ; \n} \n} \ntxManager . removeTransaction ( this ) ; \nstatus = STATUS_ROLLEDBACK ; \nif ( lastException != null ) { \nstatus = STATUS_UNKNOWN ; \nthrow new JtxException ( \"Rollback failed: one or more TX resources couldn't rollback a TX\" , lastException ) ; \n} \nif ( wasForced ) { \nthrow new JtxException ( \"TX rolled back because it has been marked as rollback-only\" , rollbackCause ) ; \n} \nreturn ; \n} \n} \n"}
{"1004": "public class JsonWriter { \nprotected void popName ( ) { \nif ( isPushed ) { \nif ( pushedComma ) { \nwriteComma ( ) ; \n} \nString name = pushedName ; \npushedName = null ; \nisPushed = false ; \nwriteName ( name ) ; \n} \nreturn ; \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nint len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( strictStringEncoding ) { \nwrite ( \"\\\\/\" ) ; \n} \nelse { \nwrite ( c ) ; \n} \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( Character . isISOControl ( c ) ) { \nunicode ( c ) ; \n} \nelse { \nwrite ( c ) ; \n} \n} \n} \nwrite ( StringPool . QUOTE ) ; \nreturn ; \n} \n} \n"}
{"1006": "public class JsonWriter { \nprotected void unicode ( final char c ) { \nwrite ( \"\\\\u\" ) ; \nint n = c ; \nfor ( int i = 0 ; \ni < 4 ; \n++ i ) { \nint digit = ( n & 0xf000 ) >> 12 ; \nchar hex = CharUtil . int2hex ( digit ) ; \nwrite ( hex ) ; \nn <<= 4 ; \n} \nreturn ; \n} \n} \n"}
{"1007": "public class JsonWriter { \npublic void write ( final CharSequence charSequence ) { \npopName ( ) ; \ntry { \nout . append ( charSequence ) ; \n} \ncatch ( IOException ioex ) { \nthrow new JsonException ( ioex ) ; \n} \nreturn ; \n} \n} \n"}
{"1009": "public class DecoraTag { \npublic void startRegion ( final int start , final int tagLen , final int deepLevel ) { \nthis . regionStart = start + tagLen ; \nthis . regionLength = 0 ; \nthis . regionTagStart = start ; \nthis . deepLevel = deepLevel ; \nreturn ; \n} \n} \n"}
{"1011": "public class PseudoFunctionSelector { \npublic static void registerPseudoFunction ( final Class < ? extends PseudoFunction > pseudoFunctionType ) { \nPseudoFunction pseudoFunction ; \ntry { \npseudoFunction = ClassUtil . newInstance ( pseudoFunctionType ) ; \n} \ncatch ( Exception ex ) { \nthrow new CSSellyException ( ex ) ; \n} \nPSEUDO_FUNCTION_MAP . put ( pseudoFunction . getPseudoFunctionName ( ) , pseudoFunction ) ; \nreturn ; \n} \n} \n"}
{"1013": "public class ProxettaClassBuilder { \n@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \nwd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; \naccess &= ~ AsmUtil . ACC_ABSTRACT ; \nfinal int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; \nwd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; \nwd . proxyAspects = new ProxyAspectData [ aspects . length ] ; \nfor ( int i = 0 ; \ni < aspects . length ; \ni ++ ) { \nwd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; \n} \nreturn ; \n} \n} \n"}
{"1015": "public class ProxettaClassBuilder { \nprotected void makeStaticInitBlock ( ) { \nif ( wd . adviceClinits != null ) { \nMethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_STATIC , CLINIT , DESC_VOID , null , null ) ; \nmv . visitCode ( ) ; \nfor ( String name : wd . adviceClinits ) { \nmv . visitMethodInsn ( INVOKESTATIC , wd . thisReference , name , DESC_VOID , false ) ; \n} \nmv . visitInsn ( RETURN ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1016": "public class ProxettaClassBuilder { \nprotected void makeProxyConstructor ( ) { \nMethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_PRIVATE | AsmUtil . ACC_FINAL , ProxettaNames . initMethodName , DESC_VOID , null , null ) ; \nmv . visitCode ( ) ; \nif ( wd . adviceInits != null ) { \nfor ( String name : wd . adviceInits ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nmv . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , name , DESC_VOID , false ) ; \n} \n} \nmv . visitInsn ( RETURN ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \nreturn ; \n} \n} \n"}
{"1017": "public class ProxettaClassBuilder { \nprotected void processSuperMethods ( ) { \nfor ( ClassReader cr : targetClassInfo . superClassReaders ) { \ncr . accept ( new EmptyClassVisitor ( ) { \nString declaredClassName ; \n@ Override public void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \ndeclaredClassName = name ; \nreturn ; \n} \n@ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { \nif ( name . equals ( INIT ) || name . equals ( CLINIT ) ) { \nreturn null ; \n} \nMethodSignatureVisitor msign = targetClassInfo . lookupMethodSignatureVisitor ( access , name , desc , declaredClassName ) ; \nif ( msign == null ) { \nreturn null ; \n} \nreturn applyProxy ( msign ) ; \n} \n} \n, 0 ) ; \n} \nreturn ; \n} \n} \n"}
{"1022": "public class SqlTypeManager { \npublic void registerDefaults ( ) { \nregister ( Integer . class , IntegerSqlType . class ) ; \nregister ( int . class , IntegerSqlType . class ) ; \nregister ( MutableInteger . class , IntegerSqlType . class ) ; \nregister ( Float . class , FloatSqlType . class ) ; \nregister ( float . class , FloatSqlType . class ) ; \nregister ( MutableFloat . class , FloatSqlType . class ) ; \nregister ( Double . class , DoubleSqlType . class ) ; \nregister ( double . class , DoubleSqlType . class ) ; \nregister ( MutableDouble . class , DoubleSqlType . class ) ; \nregister ( Byte . class , ByteSqlType . class ) ; \nregister ( byte . class , ByteSqlType . class ) ; \nregister ( MutableByte . class , ByteSqlType . class ) ; \nregister ( Boolean . class , BooleanSqlType . class ) ; \nregister ( boolean . class , BooleanSqlType . class ) ; \nregister ( MutableBoolean . class , BooleanSqlType . class ) ; \nregister ( Long . class , LongSqlType . class ) ; \nregister ( long . class , LongSqlType . class ) ; \nregister ( MutableLong . class , LongSqlType . class ) ; \nregister ( Short . class , ShortSqlType . class ) ; \nregister ( short . class , ShortSqlType . class ) ; \nregister ( MutableShort . class , ShortSqlType . class ) ; \nregister ( Character . class , CharacterSqlType . class ) ; \nregister ( char . class , CharacterSqlType . class ) ; \nregister ( BigDecimal . class , BigDecimalSqlType . class ) ; \nregister ( BigInteger . class , BigIntegerSqlType . class ) ; \nregister ( String . class , StringSqlType . class ) ; \nregister ( LocalDateTime . class , LocalDateTimeSqlType . class ) ; \nregister ( LocalDate . class , LocalDateSqlType . class ) ; \nregister ( LocalTime . class , LocalTimeSqlType . class ) ; \nregister ( Date . class , SqlDateSqlType . class ) ; \nregister ( Timestamp . class , TimestampSqlType . class ) ; \nregister ( Time . class , TimeSqlType . class ) ; \nregister ( java . util . Date . class , DateSqlType . class ) ; \nregister ( JulianDate . class , JulianDateSqlType . class ) ; \nregister ( byte [ ] . class , ByteArraySqlType . class ) ; \nregister ( URL . class , URLSqlType . class ) ; \nregister ( Blob . class , BlobSqlType . class ) ; \nregister ( Clob . class , ClobSqlType . class ) ; \nregister ( Array . class , SqlArraySqlType . class ) ; \nregister ( Ref . class , SqlRefSqlType . class ) ; \nreturn ; \n} \n} \n"}
{"1023": "public class SqlTypeManager { \npublic void register ( final Class type , final Class < ? extends SqlType > sqlTypeClass ) { \ntypes . put ( type , lookupSqlType ( sqlTypeClass ) ) ; \nreturn ; \n} \n} \n"}
{"1031": "public class JtxTransactionManager { \nprotected void associateTransaction ( final JtxTransaction tx ) { \ntotalTransactions ++ ; \nArrayList < JtxTransaction > txList = txStack . get ( ) ; \nif ( txList == null ) { \ntxList = new ArrayList < > ( ) ; \ntxStack . set ( txList ) ; \n} \ntxList . add ( tx ) ; \nreturn ; \n} \n} \n"}
{"1032": "public class JtxTransactionManager { \nprotected void continueTx ( final JtxTransaction sourceTx , final JtxTransactionMode destMode ) { \nif ( ! validateExistingTransaction ) { \nreturn ; \n} \nJtxTransactionMode sourceMode = sourceTx . getTransactionMode ( ) ; \nJtxIsolationLevel destIsolationLevel = destMode . getIsolationLevel ( ) ; \nif ( destIsolationLevel != ISOLATION_DEFAULT ) { \nJtxIsolationLevel currentIsolationLevel = sourceMode . getIsolationLevel ( ) ; \nif ( currentIsolationLevel != destIsolationLevel ) { \nthrow new JtxException ( \"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel ) ; \n} \n} \nif ( ( ! destMode . isReadOnly ( ) ) && ( sourceMode . isReadOnly ( ) ) ) { \nthrow new JtxException ( \"Participating TX is not marked as read-only, but existing TX is\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1035": "public class Pathref { \nprotected void append ( final String methodName ) { \nif ( path . length ( ) != 0 ) { \npath += StringPool . DOT ; \n} \nif ( methodName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ) { \npath = StringUtil . substring ( path , 0 , - 1 ) ; \n} \npath += methodName ; \nreturn ; \n} \n} \n"}
{"1045": "public class PetiteContainer { \nprotected void initBeanDefinition ( final BeanDefinition def ) { \nif ( def . initMethods == null ) { \ndef . initMethods = petiteResolvers . resolveInitMethodPoint ( def . type ) ; \n} \nif ( def . destroyMethods == null ) { \ndef . destroyMethods = petiteResolvers . resolveDestroyMethodPoint ( def . type ) ; \n} \nif ( def . properties == null ) { \ndef . properties = petiteResolvers . resolvePropertyInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; \n} \nif ( def . methods == null ) { \ndef . methods = petiteResolvers . resolveMethodInjectionPoint ( def . type ) ; \n} \nif ( def . ctor == null ) { \ndef . ctor = petiteResolvers . resolveCtorInjectionPoint ( def . type ) ; \n} \nif ( def . values == null ) { \ndef . values = paramManager . resolveParamInjectionPoints ( def . type ) ; \n} \nif ( def . sets == null ) { \ndef . sets = petiteResolvers . resolveSetInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; \n} \nif ( def . params == null ) { \ndef . params = paramManager . filterParametersForBeanName ( def . name , petiteConfig . getResolveReferenceParameters ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1047": "public class PetiteContainer { \npublic void addBean ( final String name , final Object bean , WiringMode wiringMode ) { \nwiringMode = petiteConfig . resolveWiringMode ( wiringMode ) ; \nregisterPetiteBean ( bean . getClass ( ) , name , SingletonScope . class , wiringMode , false , null ) ; \nBeanDefinition def = lookupExistingBeanDefinition ( name ) ; \nregisterBeanAndWireAndInjectParamsAndInvokeInitMethods ( new BeanData ( this , def , bean ) ) ; \nreturn ; \n} \n} \n"}
{"1048": "public class PetiteContainer { \npublic void setBeanProperty ( final String name , final Object value ) { \nObject bean = null ; \nint ndx = name . length ( ) ; \nwhile ( true ) { \nndx = name . lastIndexOf ( '.' , ndx ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString beanName = name . substring ( 0 , ndx ) ; \nbean = getBean ( beanName ) ; \nif ( bean != null ) { \nbreak ; \n} \nndx -- ; \n} \nif ( bean == null ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name ) ; \n} \ntry { \nBeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"1050": "public class PetiteContainer { \npublic void shutdown ( ) { \nscopes . forEachValue ( Scope :: shutdown ) ; \nexternalsCache . clear ( ) ; \nbeans . clear ( ) ; \nbeansAlt . clear ( ) ; \nscopes . clear ( ) ; \nproviders . clear ( ) ; \nbeanCollections . clear ( ) ; \nreturn ; \n} \n} \n"}
{"1054": "public class LagartoDOMBuilderTagVisitor { \n@ Override public void end ( ) { \nif ( parentNode != rootNode ) { \nNode thisNode = parentNode ; \nwhile ( thisNode != rootNode ) { \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nif ( implRules . implicitlyCloseTagOnEOF ( thisNode . getNodeName ( ) ) ) { \nthisNode = thisNode . getParentNode ( ) ; \ncontinue ; \n} \n} \nerror ( \"Unclosed tag closed: <\" + thisNode . getNodeName ( ) + \">\" ) ; \nthisNode = thisNode . getParentNode ( ) ; \n} \n} \nif ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , true ) ; \n} \nif ( domBuilder . config . isUseFosterRules ( ) ) { \nHtmlFosterRules fosterRules = new HtmlFosterRules ( ) ; \nfosterRules . fixFosterElements ( rootNode ) ; \n} \nrootNode . end ( ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"LagartoDom tree created in \" + rootNode . getElapsedTime ( ) + \" ms\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1056": "public class LagartoDOMBuilderTagVisitor { \n@ Override public void tag ( final Tag tag ) { \nif ( ! enabled ) { \nreturn ; \n} \nTagType tagType = tag . getType ( ) ; \nElement node ; \nswitch ( tagType ) { \ncase START : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , false ) ; \n} \nnode = createElementNode ( tag ) ; \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nwhile ( true ) { \nString parentNodeName = parentNode . getNodeName ( ) ; \nif ( ! implRules . implicitlyCloseParentTagOnNewTag ( parentNodeName , node . getNodeName ( ) ) ) { \nbreak ; \n} \nparentNode = parentNode . getParentNode ( ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Implicitly closed tag <\" + node . getNodeName ( ) + \"> \" ) ; \n} \n} \n} \nparentNode . addChild ( node ) ; \nif ( ! node . isVoidElement ( ) ) { \nparentNode = node ; \n} \nbreak ; \ncase END : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , true ) ; \n} \nString tagName = tag . getName ( ) . toString ( ) ; \nNode matchingParent = findMatchingParentOpenTag ( tagName ) ; \nif ( matchingParent == parentNode ) { \nparentNode = parentNode . getParentNode ( ) ; \nbreak ; \n} \nif ( matchingParent == null ) { \nerror ( \"Orphan closed tag ignored: </\" + tagName + \"> \" + tag . getTagPosition ( ) ) ; \nbreak ; \n} \nif ( domBuilder . config . isImpliedEndTags ( ) ) { \nboolean fixed = false ; \nwhile ( implRules . implicitlyCloseParentTagOnTagEnd ( parentNode . getNodeName ( ) , tagName ) ) { \nparentNode = parentNode . getParentNode ( ) ; \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Implicitly closed tag <\" + tagName + \">\" ) ; \n} \nif ( parentNode == matchingParent ) { \nparentNode = matchingParent . parentNode ; \nfixed = true ; \nbreak ; \n} \n} \nif ( fixed ) { \nbreak ; \n} \n} \nfixUnclosedTagsUpToMatchingParent ( tag , matchingParent ) ; \nbreak ; \ncase SELF_CLOSING : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { \nremoveLastChildNodeIfEmptyText ( parentNode , false ) ; \n} \nnode = createElementNode ( tag ) ; \nparentNode . addChild ( node ) ; \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"1057": "public class LagartoDOMBuilderTagVisitor { \nprotected void removeLastChildNodeIfEmptyText ( final Node parentNode , final boolean closedTag ) { \nif ( parentNode == null ) { \nreturn ; \n} \nNode lastChild = parentNode . getLastChild ( ) ; \nif ( lastChild == null ) { \nreturn ; \n} \nif ( lastChild . getNodeType ( ) != Node . NodeType . TEXT ) { \nreturn ; \n} \nif ( closedTag ) { \nif ( parentNode . getChildNodesCount ( ) == 1 ) { \nreturn ; \n} \n} \nText text = ( Text ) lastChild ; \nif ( text . isBlank ( ) ) { \nlastChild . detachFromParent ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1061": "public class IteratorTag { \nprotected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nIterator iter = collection . iterator ( ) ; \nint i = 0 ; \nint to = calculateTo ( from , count , collection . size ( ) ) ; \nwhile ( i < to ) { \nObject item = iter . next ( ) ; \nif ( i >= from ) { \nif ( status != null ) { \niteratorStatus . next ( ! iter . hasNext ( ) ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \ni ++ ; \n} \nreturn ; \n} \n} \n"}
{"1062": "public class IteratorTag { \nprotected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nint len = array . length ; \nint to = calculateTo ( from , count , len ) ; \nint last = to - 1 ; \nfor ( int i = from ; \ni < to ; \ni ++ ) { \nObject item = array [ i ] ; \nif ( status != null ) { \niteratorStatus . next ( i == last ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \nreturn ; \n} \n} \n"}
{"1088": "public class StringUtil { \npublic static void cropAll ( final String ... strings ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni ++ ) { \nString string = strings [ i ] ; \nif ( string != null ) { \nstring = crop ( strings [ i ] ) ; \n} \nstrings [ i ] = string ; \n} \nreturn ; \n} \n} \n"}
{"1115": "public class AnnotationVisitor { \npublic void visit ( final String name , final Object value ) { \nif ( av != null ) { \nav . visit ( name , value ) ; \n} \nreturn ; \n} \n} \n"}
{"1116": "public class AnnotationVisitor { \npublic void visitEnum ( final String name , final String descriptor , final String value ) { \nif ( av != null ) { \nav . visitEnum ( name , descriptor , value ) ; \n} \nreturn ; \n} \n} \n"}
{"1123": "public class WrapperProxettaFactory { \npublic void injectTargetIntoWrapper ( final Object target , final Object wrapper ) { \nProxettaUtil . injectTargetIntoWrapper ( target , wrapper , targetFieldName ) ; \nreturn ; \n} \n} \n"}
{"1126": "public class GzipResponseStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) { \nreturn ; \n} \nif ( gzipstream != null ) { \nflushToGZip ( ) ; \ngzipstream . close ( ) ; \ngzipstream = null ; \n} \nelse { \nif ( bufferCount > 0 ) { \noutput . write ( buffer , 0 , bufferCount ) ; \nbufferCount = 0 ; \n} \n} \noutput . close ( ) ; \nclosed = true ; \nreturn ; \n} \n} \n"}
{"1127": "public class GzipResponseStream { \n@ Override public void write ( final int b ) throws IOException { \nif ( closed ) { \nthrow new IOException ( \"Cannot write to a closed output stream\" ) ; \n} \nif ( bufferCount >= buffer . length ) { \nflushToGZip ( ) ; \n} \nbuffer [ bufferCount ++ ] = ( byte ) b ; \nreturn ; \n} \n} \n"}
{"1128": "public class RemoveSessionFromUrlFilter { \n@ Override public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain chain ) throws IOException , ServletException { \nHttpServletRequest httpRequest = ( HttpServletRequest ) request ; \nHttpServletResponse httpResponse = ( HttpServletResponse ) response ; \nif ( isRequestedSessionIdFromURL ( httpRequest ) ) { \nHttpSession session = httpRequest . getSession ( false ) ; \nif ( session != null ) { \nsession . invalidate ( ) ; \n} \n} \nHttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper ( httpResponse ) { \n@ Override public String encodeRedirectUrl ( final String url ) { \nreturn url ; \n} \n@ Override public String encodeRedirectURL ( final String url ) { \nreturn url ; \n} \n@ Override public String encodeUrl ( final String url ) { \nreturn url ; \n} \n@ Override public String encodeURL ( final String url ) { \nreturn url ; \n} \n} \n; \nchain . doFilter ( request , wrappedResponse ) ; \nreturn ; \n} \n} \n"}
{"1131": "public class EmailAttachment { \npublic void writeToFile ( final File destination ) { \nInputStream input = null ; \nfinal OutputStream output ; \ntry { \ninput = getDataSource ( ) . getInputStream ( ) ; \noutput = new FileOutputStream ( destination ) ; \nStreamUtil . copy ( input , output ) ; \n} \ncatch ( final IOException ioex ) { \nthrow new MailException ( ioex ) ; \n} \nfinally { \nStreamUtil . close ( input ) ; \n} \nreturn ; \n} \n} \n"}
{"1132": "public class EmailAttachment { \npublic void writeToStream ( final OutputStream out ) { \nInputStream input = null ; \ntry { \ninput = getDataSource ( ) . getInputStream ( ) ; \nStreamUtil . copy ( input , out ) ; \n} \ncatch ( final IOException ioex ) { \nthrow new MailException ( ioex ) ; \n} \nfinally { \nStreamUtil . close ( input ) ; \n} \nreturn ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \nfor ( int i = 0 ; \ni < textLength ; \ni ++ ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) { \nif ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse { \ncontinue ; \n} \n} \nelse { \nregularChar = true ; \n} \ndest [ ndx ] = c ; \nndx ++ ; \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \nelse { \nstrippedCharsCount += textLength ; \n} \nreturn ; \n} \n} \n"}
{"1137": "public class TypeConverterManager { \npublic < T > void register ( final Class < T > type , final TypeConverter < T > typeConverter ) { \nconverters . put ( type , typeConverter ) ; \nreturn ; \n} \n} \n"}
{"1141": "public class NodeSelector { \nprotected void processSelectors ( final List < Node > results , final List < CssSelector > selectors ) { \nList < Node > selectedNodes = select ( rootNode , selectors ) ; \nfor ( Node selectedNode : selectedNodes ) { \nif ( ! results . contains ( selectedNode ) ) { \nresults . add ( selectedNode ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nwhile ( ! nodes . isEmpty ( ) ) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = childCount - 1 ; \ni >= 0 ; \ni -- ) { \nnodes . addFirst ( node . getChild ( i ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nint childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nnodes . add ( rootNode . getChild ( i ) ) ; \n} \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) { \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nwhile ( true ) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) { \nbreak ; \n} \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"1145": "public class NodeSelector { \nprotected void selectAndAdd ( final Node node , final CssSelector cssSelector , final List < Node > result ) { \nif ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) { \nreturn ; \n} \nboolean matched = cssSelector . accept ( node ) ; \nif ( matched ) { \nif ( result . contains ( node ) ) { \nreturn ; \n} \nresult . add ( node ) ; \n} \nreturn ; \n} \n} \n"}
{"1157": "public class DbEntityDescriptor { \nprivate void resolveColumnsAndProperties ( final Class type ) { \nPropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; \nList < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; \nint idcount = 0 ; \nHashSet < String > names = new HashSet < > ( allProperties . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nDbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; \nif ( dec != null ) { \nif ( ! names . add ( dec . getColumnName ( ) ) ) { \nthrow new DbOomException ( \"Duplicate column name: \" + dec . getColumnName ( ) ) ; \n} \ndecList . add ( dec ) ; \nif ( dec . isId ) { \nidcount ++ ; \n} \n} \n} \nif ( decList . isEmpty ( ) ) { \nthrow new DbOomException ( \"No column mappings in entity: \" + type ) ; \n} \ncolumnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; \nArrays . sort ( columnDescriptors ) ; \nif ( idcount > 0 ) { \nidColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; \nidcount = 0 ; \nfor ( DbEntityColumnDescriptor dec : columnDescriptors ) { \nif ( dec . isId ) { \nidColumnDescriptors [ idcount ++ ] = dec ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"1163": "public class DbEntityDescriptor { \npublic void setIdValue ( final E object , final Object value ) { \nfinal String propertyName = getIdPropertyName ( ) ; \nBeanUtil . declared . setProperty ( object , propertyName , value ) ; \nreturn ; \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( newIndex > index ) { \nfor ( int i = index ; \ni < newIndex ; \ni ++ ) { \narray [ i ] = StringPool . EMPTY ; \n} \n} \nelse if ( newIndex < index ) { \nfor ( int i = newIndex ; \ni < index ; \ni ++ ) { \narray [ i ] = null ; \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \nreturn ; \n} \n} \n"}
{"1167": "public class StringBand { \nprotected void expandCapacity ( ) { \nString [ ] newArray = new String [ array . length << 1 ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \nreturn ; \n} \n} \n"}
{"1171": "public class LoopingTagSupport { \nprotected void loopBody ( ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nif ( body == null ) { \nreturn ; \n} \nLoopIterator loopIterator = new LoopIterator ( start , end , step , modulus ) ; \nif ( status != null ) { \ngetJspContext ( ) . setAttribute ( status , loopIterator ) ; \n} \nwhile ( loopIterator . next ( ) ) { \nTagUtil . invokeBody ( body ) ; \n} \nif ( status != null ) { \ngetJspContext ( ) . removeAttribute ( status ) ; \n} \nreturn ; \n} \n} \n"}
{"1172": "public class DirWatcher { \nprotected void init ( ) { \nFile [ ] filesArray = dir . listFiles ( ) ; \nfilesCount = 0 ; \nif ( filesArray != null ) { \nfilesCount = filesArray . length ; \nfor ( File file : filesArray ) { \nif ( ! acceptFile ( file ) ) { \ncontinue ; \n} \nmap . put ( file , new MutableLong ( file . lastModified ( ) ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1175": "public class DirWatcher { \npublic void start ( final long pollingInterval ) { \nif ( timer == null ) { \nif ( ! startBlank ) { \ninit ( ) ; \n} \ntimer = new Timer ( true ) ; \ntimer . schedule ( new WatchTask ( ) , 0 , pollingInterval ) ; \n} \nreturn ; \n} \n} \n"}
{"1176": "public class DirWatcher { \nprotected void onChange ( final DirWatcherEvent . Type type , final File file ) { \nlisteners . accept ( new DirWatcherEvent ( type , file ) ) ; \nreturn ; \n} \n} \n"}
{"1177": "public class CompositeEnumeration { \npublic void add ( final Enumeration < T > enumeration ) { \nif ( allEnumerations . contains ( enumeration ) ) { \nthrow new IllegalArgumentException ( \"Duplicate enumeration\" ) ; \n} \nallEnumerations . add ( enumeration ) ; \nreturn ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; \nint mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nint attributesCount = 0 ; \nif ( constantValueIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \n++ attributesCount ; \n} \nif ( signatureIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( firstAttribute != null ) { \nattributesCount += firstAttribute . getAttributeCount ( ) ; \n} \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \n} \nif ( signatureIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nlastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nlastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nlastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nlastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( firstAttribute != null ) { \nfirstAttribute . putAttributes ( symbolTable , output ) ; \n} \nreturn ; \n} \n} \n"}
{"1181": "public class Target { \npublic void writeValue ( final InjectionPoint injectionPoint , final Object propertyValue , final boolean silent ) { \nwriteValue ( injectionPoint . targetName ( ) , propertyValue , silent ) ; \nreturn ; \n} \n} \n"}
{"1182": "public class DecoraParser { \npublic void decorate ( final Writer writer , final char [ ] pageContent , final char [ ] decoraContent ) throws IOException { \nDecoraTag [ ] decoraTags = parseDecorator ( decoraContent ) ; \nparsePage ( pageContent , decoraTags ) ; \nwriteDecoratedPage ( writer , decoraContent , pageContent , decoraTags ) ; \nreturn ; \n} \n} \n"}
{"1183": "public class DecoraParser { \nprotected void parsePage ( final char [ ] pageContent , final DecoraTag [ ] decoraTags ) { \nLagartoParser lagartoParser = new LagartoParser ( pageContent ) ; \nPageRegionExtractor writer = new PageRegionExtractor ( decoraTags ) ; \nlagartoParser . parse ( writer ) ; \nreturn ; \n} \n} \n"}
{"1184": "public class DecoraParser { \nprotected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { \nint ndx = 0 ; \nfor ( DecoraTag decoraTag : decoraTags ) { \nint decoratorLen = decoraTag . getStartIndex ( ) - ndx ; \nif ( decoratorLen <= 0 ) { \ncontinue ; \n} \nout . write ( decoratorContent , ndx , decoratorLen ) ; \nndx = decoraTag . getEndIndex ( ) ; \nint regionLen = decoraTag . getRegionLength ( ) ; \nif ( regionLen == 0 ) { \nif ( decoraTag . hasDefaultValue ( ) ) { \nout . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; \n} \n} \nelse { \nwriteRegion ( out , pageContent , decoraTag , decoraTags ) ; \n} \n} \nout . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; \nreturn ; \n} \n} \n"}
{"1185": "public class DecoraParser { \nprotected void writeRegion ( final Writer out , final char [ ] pageContent , final DecoraTag decoraTag , final DecoraTag [ ] decoraTags ) throws IOException { \nint regionStart = decoraTag . getRegionStart ( ) ; \nint regionLen = decoraTag . getRegionLength ( ) ; \nint regionEnd = regionStart + regionLen ; \nfor ( DecoraTag innerDecoraTag : decoraTags ) { \nif ( decoraTag == innerDecoraTag ) { \ncontinue ; \n} \nif ( decoraTag . isRegionUndefined ( ) ) { \ncontinue ; \n} \nif ( innerDecoraTag . isInsideOtherTagRegion ( decoraTag ) ) { \nout . write ( pageContent , regionStart , innerDecoraTag . getRegionTagStart ( ) - regionStart ) ; \nregionStart = innerDecoraTag . getRegionTagEnd ( ) ; \n} \n} \nout . write ( pageContent , regionStart , regionEnd - regionStart ) ; \nreturn ; \n} \n} \n"}
{"1186": "public class HttpTunnel { \npublic void start ( ) throws IOException { \nserverSocket = new ServerSocket ( listenPort , socketBacklog ) ; \nserverSocket . setReuseAddress ( true ) ; \nexecutorService = Executors . newFixedThreadPool ( threadPoolSize ) ; \nrunning = true ; \nwhile ( running ) { \nSocket socket = serverSocket . accept ( ) ; \nsocket . setKeepAlive ( false ) ; \nexecutorService . execute ( onSocketConnection ( socket ) ) ; \n} \nexecutorService . shutdown ( ) ; \nreturn ; \n} \n} \n"}
{"1190": "public class ColumnsSelectChunk { \n@ Override public void init ( final TemplateData templateData ) { \nsuper . init ( templateData ) ; \nif ( hint != null ) { \ntemplateData . incrementHintsCount ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1191": "public class ColumnsSelectChunk { \nprotected void appendAlias ( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { \nfinal ColumnAliasType columnAliasType = templateData . getColumnAliasType ( ) ; \nif ( columnAliasType == null || columnAliasType == ColumnAliasType . TABLE_REFERENCE ) { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String columnName = dec . getColumnNameForQuery ( ) ; \ntemplateData . registerColumnDataForTableRef ( tableRef , tableName ) ; \nquery . append ( tableRef ) . append ( columnAliasSeparator ) . append ( columnName ) ; \n} \nelse if ( columnAliasType == ColumnAliasType . COLUMN_CODE ) { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String columnName = dec . getColumnName ( ) ; \nfinal String code = templateData . registerColumnDataForColumnCode ( tableName , columnName ) ; \nquery . append ( code ) ; \n} \nelse if ( columnAliasType == ColumnAliasType . TABLE_NAME ) { \nfinal String tableName = ded . getTableNameForQuery ( ) ; \nfinal String columnName = dec . getColumnNameForQuery ( ) ; \nquery . append ( tableName ) . append ( columnAliasSeparator ) . append ( columnName ) ; \n} \nreturn ; \n} \n} \n"}
{"1192": "public class ColumnsSelectChunk { \nprotected void appendColumnName ( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { \nquery . append ( resolveTable ( tableRef , ded ) ) . append ( '.' ) . append ( dec . getColumnName ( ) ) ; \nif ( templateData . getColumnAliasType ( ) != null ) { \nquery . append ( AS ) ; \nswitch ( templateData . getColumnAliasType ( ) ) { \ncase TABLE_NAME : { \nfinal String tableName = ded . getTableNameForQuery ( ) ; \nquery . append ( tableName ) . append ( columnAliasSeparator ) . append ( dec . getColumnNameForQuery ( ) ) ; \nbreak ; \n} \ncase TABLE_REFERENCE : { \nfinal String tableName = ded . getTableName ( ) ; \ntemplateData . registerColumnDataForTableRef ( tableRef , tableName ) ; \nquery . append ( tableRef ) . append ( columnAliasSeparator ) . append ( dec . getColumnNameForQuery ( ) ) ; \nbreak ; \n} \ncase COLUMN_CODE : { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String code = templateData . registerColumnDataForColumnCode ( tableName , dec . getColumnName ( ) ) ; \nquery . append ( code ) ; \nbreak ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"1193": "public class InExRules { \nprotected void addRule ( final D ruleDefinition , final boolean include ) { \nif ( rules == null ) { \nrules = new ArrayList < > ( ) ; \n} \nif ( include ) { \nincludesCount ++ ; \n} \nelse { \nexcludesCount ++ ; \n} \nRule < R > newRule = new Rule < > ( makeRule ( ruleDefinition ) , include ) ; \nif ( rules . contains ( newRule ) ) { \nreturn ; \n} \nrules . add ( newRule ) ; \nreturn ; \n} \n} \n"}
{"1200": "public class ActionConfigManager { \npublic void bindAnnotationConfig ( final Class < ? extends Annotation > annotationType , final Class < ? extends ActionConfig > actionConfigClass ) { \nfinal ActionConfig actionConfig = registerNewActionConfiguration ( actionConfigClass ) ; \nactionConfigs . put ( annotationType , actionConfig ) ; \nfor ( final AnnotationParser annotationParser : annotationParsers ) { \nif ( annotationType . equals ( annotationParser . getAnnotationType ( ) ) ) { \nreturn ; \n} \n} \nannotationParsers = ArraysUtil . append ( annotationParsers , new AnnotationParser ( annotationType , Action . class ) ) ; \nreturn ; \n} \n} \n"}
{"1203": "public class ActionConfigManager { \npublic < T extends ActionConfig > void with ( final Class < T > actionConfigType , final Consumer < T > actionConfigConsumer ) { \nfinal T actionConfig = ( T ) lookup ( actionConfigType ) ; \nactionConfigConsumer . accept ( actionConfig ) ; \nreturn ; \n} \n} \n"}
{"1204": "public class MailSession { \nprotected static void setupSystemMailProperties ( ) { \nSystem . setProperty ( \"mail.mime.encodefilename\" , Boolean . valueOf ( Defaults . mailMimeEncodefilename ) . toString ( ) ) ; \nSystem . setProperty ( \"mail.mime.decodefilename\" , Boolean . valueOf ( Defaults . mailMimeDecodefilename ) . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"1205": "public class ValidationConstraintContext { \npublic void validateWithin ( final ValidationContext vctx , final Object value ) { \nvtor . validate ( vctx , value , name ) ; \nreturn ; \n} \n} \n"}
{"1207": "public class HtmlFosterRules { \nprotected void fixElements ( ) { \nfor ( Element fosterElement : fosterElements ) { \nElement lastTable = findLastTable ( fosterElement ) ; \nNode fosterElementParent = fosterElement . getParentNode ( ) ; \nNode [ ] fosterChilds = fosterElement . getChildNodes ( ) ; \nfor ( Node fosterChild : fosterChilds ) { \nif ( fosterChild . getNodeType ( ) == Node . NodeType . ELEMENT ) { \nif ( isOneOfTableElements ( ( Element ) fosterChild ) ) { \nfosterChild . detachFromParent ( ) ; \nfosterElementParent . insertBefore ( fosterChild , fosterElement ) ; \n} \n} \n} \nfosterElement . detachFromParent ( ) ; \nlastTable . getParentNode ( ) . insertBefore ( fosterElement , lastTable ) ; \n} \nreturn ; \n} \n} \n"}
{"1210": "public class WorkData { \npublic void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { \nint lastSlash = name . lastIndexOf ( '/' ) ; \nthis . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; \nthis . targetClassname = name . substring ( lastSlash + 1 ) ; \nthis . nextSupername = superName ; \nthis . superName = name ; \nif ( reqProxyClassName != null ) { \nif ( reqProxyClassName . startsWith ( DOT ) ) { \nname = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; \n} \nelse if ( reqProxyClassName . endsWith ( DOT ) ) { \nname = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; \n} \nelse { \nname = reqProxyClassName . replace ( '.' , '/' ) ; \n} \n} \nif ( suffix != null ) { \nname += suffix ; \n} \nthis . thisReference = name ; \nthis . superReference = this . superName ; \nreturn ; \n} \n} \n"}
{"1211": "public class WorkData { \nvoid addAdviceInitMethod ( final String name ) { \nif ( adviceInits == null ) { \nadviceInits = new ArrayList < > ( ) ; \n} \nadviceInits . add ( name ) ; \nreturn ; \n} \n} \n"}
{"1212": "public class BundleAction { \npublic void end ( ) { \nif ( newAction ) { \nbundleId = bundlesManager . registerBundle ( contextPath , actionPath , bundleId , bundleContentType , sources ) ; \n} \nreturn ; \n} \n} \n"}
{"1213": "public class PropsParser { \nprotected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { \nif ( key == null ) { \nreturn ; \n} \nString fullKey = key ; \nif ( section != null ) { \nif ( fullKey . length ( ) != 0 ) { \nfullKey = section + '.' + fullKey ; \n} \nelse { \nfullKey = section ; \n} \n} \nString v = value . toString ( ) ; \nif ( trim ) { \nif ( valueTrimLeft && valueTrimRight ) { \nv = v . trim ( ) ; \n} \nelse if ( valueTrimLeft ) { \nv = StringUtil . trimLeft ( v ) ; \n} \nelse { \nv = StringUtil . trimRight ( v ) ; \n} \n} \nif ( v . length ( ) == 0 && skipEmptyProps ) { \nreturn ; \n} \nextractProfilesAndAdd ( fullKey , v , operator ) ; \nreturn ; \n} \n} \n"}
{"1214": "public class PropsParser { \nprotected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { \nString fullKey = key ; \nint ndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \njustAdd ( fullKey , value , null , operator ) ; \nreturn ; \n} \nArrayList < String > keyProfiles = new ArrayList < > ( ) ; \nwhile ( true ) { \nndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nfinal int len = fullKey . length ( ) ; \nint ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; \nif ( ndx2 == - 1 ) { \nndx2 = len ; \n} \nfinal String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; \nkeyProfiles . add ( profile ) ; \nndx2 ++ ; \nfinal String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; \nfullKey = fullKey . substring ( 0 , ndx ) + right ; \n} \nif ( fullKey . startsWith ( StringPool . DOT ) ) { \nfullKey = fullKey . substring ( 1 ) ; \n} \njustAdd ( fullKey , value , keyProfiles , operator ) ; \nreturn ; \n} \n} \n"}
{"1215": "public class PropsParser { \nprotected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { \nif ( operator == Operator . COPY ) { \nHashMap < String , Object > target = new HashMap < > ( ) ; \nString [ ] profiles = null ; \nif ( keyProfiles != null ) { \nprofiles = keyProfiles . toArray ( new String [ 0 ] ) ; \n} \nString [ ] sources = StringUtil . splitc ( value , ',' ) ; \nfor ( String source : sources ) { \nsource = source . trim ( ) ; \nString [ ] lookupProfiles = profiles ; \nString lookupProfilesString = null ; \nint leftIndex = source . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = source . indexOf ( '>' ) ; \nlookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; \nsource = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nString [ ] wildcards = new String [ ] { \nsource + \".*\" } \n; \npropsData . extract ( target , lookupProfiles , wildcards , null ) ; \nfor ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { \nString entryKey = entry . getKey ( ) ; \nString suffix = entryKey . substring ( source . length ( ) ) ; \nString newKey = key + suffix ; \nString newValue = \"${\" + entryKey ; \nif ( lookupProfilesString != null ) { \nnewValue += \"<\" + lookupProfilesString + \">\" ; \n} \nnewValue += \"}\" ; \nif ( profiles == null ) { \npropsData . putBaseProperty ( newKey , newValue , false ) ; \n} \nelse { \nfor ( final String p : profiles ) { \npropsData . putProfileProperty ( newKey , newValue , p , false ) ; \n} \n} \n} \n} \nreturn ; \n} \nboolean append = operator == Operator . QUICK_APPEND ; \nif ( keyProfiles == null ) { \npropsData . putBaseProperty ( key , value , append ) ; \nreturn ; \n} \nfor ( final String p : keyProfiles ) { \npropsData . putProfileProperty ( key , value , p , append ) ; \n} \nreturn ; \n} \n} \n"}
{"1226": "public class Label { \nfinal void addLineNumber ( final int lineNumber ) { \nif ( this . lineNumber == 0 ) { \nthis . lineNumber = ( short ) lineNumber ; \n} \nelse { \nif ( otherLineNumbers == null ) { \notherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; \n} \nint otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; \nif ( otherLineNumberIndex >= otherLineNumbers . length ) { \nint [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; \notherLineNumbers = newLineNumbers ; \n} \notherLineNumbers [ otherLineNumberIndex ] = lineNumber ; \n} \nreturn ; \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers && lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) { \nfor ( int i = 1 ; \ni <= otherLineNumbers [ 0 ] ; \n++ i ) { \nmethodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"1228": "public class Label { \nfinal void put ( final ByteVector code , final int sourceInsnBytecodeOffset , final boolean wideReference ) { \nif ( ( flags & FLAG_RESOLVED ) == 0 ) { \nif ( wideReference ) { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_WIDE , code . length ) ; \ncode . putInt ( - 1 ) ; \n} \nelse { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_SHORT , code . length ) ; \ncode . putShort ( - 1 ) ; \n} \n} \nelse { \nif ( wideReference ) { \ncode . putInt ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \nelse { \ncode . putShort ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1229": "public class Label { \nprivate void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { \nif ( forwardReferences == null ) { \nforwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \n} \nint lastElementIndex = forwardReferences [ 0 ] ; \nif ( lastElementIndex + 2 >= forwardReferences . length ) { \nint [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; \nforwardReferences = newValues ; \n} \nforwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; \nforwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; \nforwardReferences [ 0 ] = lastElementIndex ; \nreturn ; \n} \n} \n"}
{"1231": "public class Label { \nfinal void markSubroutine ( final short subroutineId ) { \nLabel listOfBlocksToProcess = this ; \nlistOfBlocksToProcess . nextListElement = EMPTY_LIST ; \nwhile ( listOfBlocksToProcess != EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nbasicBlock . nextListElement = null ; \nif ( basicBlock . subroutineId == 0 ) { \nbasicBlock . subroutineId = subroutineId ; \nlistOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1232": "public class Label { \nfinal void addSubroutineRetSuccessors ( final Label subroutineCaller ) { \nLabel listOfProcessedBlocks = EMPTY_LIST ; \nLabel listOfBlocksToProcess = this ; \nlistOfBlocksToProcess . nextListElement = EMPTY_LIST ; \nwhile ( listOfBlocksToProcess != EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = basicBlock . nextListElement ; \nbasicBlock . nextListElement = listOfProcessedBlocks ; \nlistOfProcessedBlocks = basicBlock ; \nif ( ( basicBlock . flags & FLAG_SUBROUTINE_END ) != 0 && basicBlock . subroutineId != subroutineCaller . subroutineId ) { \nbasicBlock . outgoingEdges = new Edge ( basicBlock . outputStackSize , subroutineCaller . outgoingEdges . successor , basicBlock . outgoingEdges ) ; \n} \nlistOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; \n} \nwhile ( listOfProcessedBlocks != EMPTY_LIST ) { \nLabel newListOfProcessedBlocks = listOfProcessedBlocks . nextListElement ; \nlistOfProcessedBlocks . nextListElement = null ; \nlistOfProcessedBlocks = newListOfProcessedBlocks ; \n} \nreturn ; \n} \n} \n"}
{"1244": "public class ByteVector { \nprivate void enlarge ( final int size ) { \nint doubleCapacity = 2 * data . length ; \nint minimalCapacity = length + size ; \nbyte [ ] newData = new byte [ doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity ] ; \nSystem . arraycopy ( data , 0 , newData , 0 , length ) ; \ndata = newData ; \nreturn ; \n} \n} \n"}
{"1251": "public class GenericDao { \nprotected < E , ID > void setEntityId ( final DbEntityDescriptor < E > ded , final E entity , final ID newIdValue ) { \nded . setIdValue ( entity , newIdValue ) ; \nreturn ; \n} \n} \n"}
{"1252": "public class GenericDao { \npublic void save ( final Object entity ) { \nfinal DbQuery q = query ( dbOom . entities ( ) . insert ( entity ) ) ; \nq . autoClose ( ) . executeUpdate ( ) ; \nreturn ; \n} \n} \n"}
{"1253": "public class GenericDao { \npublic void update ( final Object entity ) { \nquery ( dbOom . entities ( ) . updateAll ( entity ) ) . autoClose ( ) . executeUpdate ( ) ; \nreturn ; \n} \n} \n"}
{"1259": "public class GenericDao { \npublic < ID > void deleteById ( final Class entityType , final ID id ) { \nquery ( dbOom . entities ( ) . deleteById ( entityType , id ) ) . autoClose ( ) . executeUpdate ( ) ; \nreturn ; \n} \n} \n"}
{"1260": "public class GenericDao { \npublic void deleteById ( final Object entity ) { \nif ( entity != null ) { \nint result = query ( dbOom . entities ( ) . deleteById ( entity ) ) . autoClose ( ) . executeUpdate ( ) ; \nif ( result != 0 ) { \nClass type = entity . getClass ( ) ; \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( type ) ; \nsetEntityId ( ded , entity , 0 ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1262": "public class GenericDao { \npublic < ID > void increaseProperty ( final Class entityType , final ID id , final String name , final Number delta ) { \nquery ( dbOom . entities ( ) . increaseColumn ( entityType , id , name , delta , true ) ) . autoClose ( ) . executeUpdate ( ) ; \nreturn ; \n} \n} \n"}
{"1263": "public class GenericDao { \npublic < ID > void decreaseProperty ( final Class entityType , final ID id , final String name , final Number delta ) { \nquery ( dbOom . entities ( ) . increaseColumn ( entityType , id , name , delta , false ) ) . autoClose ( ) . executeUpdate ( ) ; \nreturn ; \n} \n} \n"}
{"1266": "public class StringKeyedMapAdapter { \n@ Override public void clear ( ) { \nentries = null ; \nIterator < String > keys = getAttributeNames ( ) ; \nwhile ( keys . hasNext ( ) ) { \nremoveAttribute ( keys . next ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1278": "public class AutomagicMadvocConfigurator { \nprotected void registerAsConsumer ( final ClassScanner classScanner ) { \nclassScanner . registerEntryConsumer ( classPathEntry -> { \nfinal String entryName = classPathEntry . name ( ) ; \nif ( entryName . endsWith ( actionClassSuffix ) ) { \ntry { \nacceptActionClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc action, ignoring: \" + entryName ) ; \n} \n} \nelse if ( classPathEntry . isTypeSignatureInUse ( MADVOC_COMPONENT_ANNOTATION ) ) { \ntry { \nacceptMadvocComponentClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc component ignoring: {}\" + entryName ) ; \n} \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"1279": "public class AutomagicMadvocConfigurator { \nprotected void acceptMadvocComponentClass ( final Class componentClass ) { \nif ( componentClass == null ) { \nreturn ; \n} \nif ( ! checkClass ( componentClass ) ) { \nreturn ; \n} \nmadvocComponents . add ( ( ) -> madvocContainer . registerComponent ( componentClass ) ) ; \nreturn ; \n} \n} \n"}
{"1287": "public class MultipartRequest { \npublic void parseRequest ( ) throws IOException { \nif ( ServletUtil . isMultipartRequest ( request ) ) { \nparseRequestStream ( request . getInputStream ( ) , characterEncoding ) ; \n} \nelse { \nEnumeration names = request . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString paramName = ( String ) names . nextElement ( ) ; \nString [ ] values = request . getParameterValues ( paramName ) ; \nputParameters ( paramName , values ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1290": "public class BeanUtilUtil { \nprotected void arrayForcedSet ( final BeanProperty bp , Object array , final int index , Object value ) { \nClass componentType = array . getClass ( ) . getComponentType ( ) ; \narray = ensureArraySize ( bp , array , componentType , index ) ; \nvalue = convertType ( value , componentType ) ; \nArray . set ( array , index , value ) ; \nreturn ; \n} \n} \n"}
{"1293": "public class UserSession { \npublic static void stop ( final HttpServletRequest servletRequest , final HttpServletResponse servletResponse ) { \nfinal HttpSession httpSession = servletRequest . getSession ( false ) ; \nif ( httpSession != null ) { \nhttpSession . removeAttribute ( AUTH_SESSION_NAME ) ; \n} \nfinal Cookie cookie = ServletUtil . getCookie ( servletRequest , AUTH_COOKIE_NAME ) ; \nif ( cookie == null ) { \nreturn ; \n} \ncookie . setMaxAge ( 0 ) ; \ncookie . setPath ( \"/\" ) ; \nservletResponse . addCookie ( cookie ) ; \nreturn ; \n} \n} \n"}
{"1294": "public class UserSession { \npublic void start ( final HttpServletRequest httpServletRequest , final HttpServletResponse httpServletResponse ) { \nfinal HttpSession httpSession = httpServletRequest . getSession ( true ) ; \nhttpSession . setAttribute ( AUTH_SESSION_NAME , this ) ; \nfinal Cookie cookie = new Cookie ( AUTH_COOKIE_NAME , authTokenValue ) ; \ncookie . setMaxAge ( cookieMaxAge ) ; \ncookie . setPath ( \"/\" ) ; \nhttpServletResponse . addCookie ( cookie ) ; \nreturn ; \n} \n} \n"}
{"1298": "public class ValidationContext { \npublic void add ( final Check check ) { \nString name = check . getName ( ) ; \nList < Check > list = map . computeIfAbsent ( name , k -> new ArrayList < > ( ) ) ; \nlist . add ( check ) ; \nreturn ; \n} \n} \n"}
{"1300": "public class ValidationContext { \npublic void addClassChecks ( final Class target ) { \nfinal List < Check > list = cache . get ( target , ( ) -> { \nfinal List < Check > newList = new ArrayList < > ( ) ; \nfinal ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target ) ; \nfinal PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \ncollectPropertyAnnotationChecks ( newList , propertyDescriptor ) ; \n} \nreturn newList ; \n} \n) ; \naddAll ( list ) ; \nreturn ; \n} \n} \n"}
{"1301": "public class ValidationContext { \nprotected void collectPropertyAnnotationChecks ( final List < Check > annChecks , final PropertyDescriptor propertyDescriptor ) { \nFieldDescriptor fd = propertyDescriptor . getFieldDescriptor ( ) ; \nif ( fd != null ) { \nAnnotation [ ] annotations = fd . getField ( ) . getAnnotations ( ) ; \ncollectAnnotationChecks ( annChecks , propertyDescriptor . getType ( ) , propertyDescriptor . getName ( ) , annotations ) ; \n} \nMethodDescriptor md = propertyDescriptor . getReadMethodDescriptor ( ) ; \nif ( md != null ) { \nAnnotation [ ] annotations = md . getMethod ( ) . getAnnotations ( ) ; \ncollectAnnotationChecks ( annChecks , propertyDescriptor . getType ( ) , propertyDescriptor . getName ( ) , annotations ) ; \n} \nmd = propertyDescriptor . getWriteMethodDescriptor ( ) ; \nif ( md != null ) { \nAnnotation [ ] annotations = md . getMethod ( ) . getAnnotations ( ) ; \ncollectAnnotationChecks ( annChecks , propertyDescriptor . getType ( ) , propertyDescriptor . getName ( ) , annotations ) ; \n} \nreturn ; \n} \n} \n"}
{"1302": "public class ValidationContext { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) protected void collectAnnotationChecks ( final List < Check > annChecks , final Class targetType , final String targetName , final Annotation [ ] annotations ) { \nfor ( Annotation annotation : annotations ) { \nConstraint c = annotation . annotationType ( ) . getAnnotation ( Constraint . class ) ; \nClass < ? extends ValidationConstraint > constraintClass ; \nif ( c == null ) { \nString constraintClassName = annotation . annotationType ( ) . getName ( ) + \"Constraint\" ; \ntry { \nconstraintClass = ClassLoaderUtil . loadClass ( constraintClassName , this . getClass ( ) . getClassLoader ( ) ) ; \n} \ncatch ( ClassNotFoundException ingore ) { \ncontinue ; \n} \n} \nelse { \nconstraintClass = c . value ( ) ; \n} \nValidationConstraint vc ; \ntry { \nvc = newConstraint ( constraintClass , targetType ) ; \n} \ncatch ( Exception ex ) { \nthrow new VtorException ( \"Invalid constraint: \" + constraintClass . getClass ( ) . getName ( ) , ex ) ; \n} \nvc . configure ( annotation ) ; \nCheck check = new Check ( targetName , vc ) ; \ncopyDefaultCheckProperties ( check , annotation ) ; \nannChecks . add ( check ) ; \n} \nreturn ; \n} \n} \n"}
{"1303": "public class ValidationContext { \nprotected void copyDefaultCheckProperties ( final Check destCheck , final Annotation annotation ) { \nInteger severity = ( Integer ) ClassUtil . readAnnotationValue ( annotation , ANN_SEVERITY ) ; \ndestCheck . setSeverity ( severity . intValue ( ) ) ; \nString [ ] profiles = ( String [ ] ) ClassUtil . readAnnotationValue ( annotation , ANN_PROFILES ) ; \ndestCheck . setProfiles ( profiles ) ; \nString message = ( String ) ClassUtil . readAnnotationValue ( annotation , ANN_MESSAGE ) ; \ndestCheck . setMessage ( message ) ; \nreturn ; \n} \n} \n"}
{"1319": "public class JoyMadvoc { \nprotected void printRoutes ( final int width ) { \nfinal ActionsManager actionsManager = webApp . madvocContainer ( ) . lookupComponent ( ActionsManager . class ) ; \nfinal List < ActionRuntime > actions = actionsManager . getAllActionRuntimes ( ) ; \nfinal Map < String , String > aliases = actionsManager . getAllAliases ( ) ; \nif ( actions . isEmpty ( ) ) { \nreturn ; \n} \nfinal Print print = new Print ( ) ; \nprint . line ( \"Routes\" , width ) ; \nactions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { \nfinal String actionMethod = ar . getActionMethod ( ) ; \nprint . out ( Chalk256 . chalk ( ) . yellow ( ) , actionMethod == null ? \"*\" : actionMethod , 7 ) ; \nprint . space ( ) ; \nfinal String signature = ClassUtil . getShortClassName ( ProxettaUtil . resolveTargetClass ( ar . getActionClass ( ) ) , 2 ) + '#' + ar . getActionClassMethod ( ) . getName ( ) ; \nprint . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , ar . getActionPath ( ) , Chalk256 . chalk ( ) . blue ( ) , signature , width - 7 - 1 ) ; \n} \n) ; \nif ( ! aliases . isEmpty ( ) ) { \nprint . line ( \"Aliases\" , width ) ; \nactions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { \nfinal String actionPath = ar . getActionPath ( ) ; \nfor ( final Map . Entry < String , String > entry : aliases . entrySet ( ) ) { \nif ( entry . getValue ( ) . equals ( actionPath ) ) { \nprint . space ( 8 ) ; \nprint . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , entry . getValue ( ) , Chalk256 . chalk ( ) . blue ( ) , entry . getKey ( ) , width - 8 ) ; \n} \n} \n} \n) ; \n} \nprint . line ( width ) ; \nreturn ; \n} \n} \n"}
{"1324": "public class MapToBean { \nprivate void setValue ( final Object target , final PropertyDescriptor pd , Object value ) throws InvocationTargetException , IllegalAccessException { \nClass propertyType ; \nSetter setter = pd . getSetter ( true ) ; \nif ( setter != null ) { \nif ( value != null ) { \npropertyType = setter . getSetterRawType ( ) ; \nvalue = jsonParser . convertType ( value , propertyType ) ; \n} \nsetter . invokeSetter ( target , value ) ; \n} \nreturn ; \n} \n} \n"}
{"1330": "public class HttpBrowser { \nprotected void addDefaultHeaders ( final HttpRequest httpRequest ) { \nfor ( Map . Entry < String , String > entry : defaultHeaders . entries ( ) ) { \nString name = entry . getKey ( ) ; \nif ( ! httpRequest . headers . contains ( name ) ) { \nhttpRequest . headers . add ( name , entry . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1331": "public class HttpBrowser { \nprotected void readCookies ( final HttpResponse httpResponse ) { \nCookie [ ] newCookies = httpResponse . cookies ( ) ; \nfor ( Cookie cookie : newCookies ) { \ncookies . add ( cookie . getName ( ) , cookie ) ; \n} \nreturn ; \n} \n} \n"}
{"1332": "public class HttpBrowser { \nprotected void addCookies ( final HttpRequest httpRequest ) { \nList < Cookie > cookiesList = new ArrayList < > ( ) ; \nif ( ! cookies . isEmpty ( ) ) { \nfor ( Map . Entry < String , Cookie > cookieEntry : cookies ) { \ncookiesList . add ( cookieEntry . getValue ( ) ) ; \n} \nhttpRequest . cookies ( cookiesList . toArray ( new Cookie [ 0 ] ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1334": "public class SendMailSession { \nprivate void setSubject ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nif ( emailWithData . subjectEncoding ( ) != null ) { \nmsgToSet . setSubject ( emailWithData . subject ( ) , emailWithData . subjectEncoding ( ) ) ; \n} \nelse { \nmsgToSet . setSubject ( emailWithData . subject ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1335": "public class SendMailSession { \nprivate void setSentDate ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nDate date = emailWithData . sentDate ( ) ; \nif ( date == null ) { \ndate = new Date ( ) ; \n} \nmsgToSet . setSentDate ( date ) ; \nreturn ; \n} \n} \n"}
{"1336": "public class SendMailSession { \nprivate void setHeaders ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal Map < String , String > headers = emailWithData . headers ( ) ; \nif ( headers != null ) { \nfor ( final Map . Entry < String , String > entry : headers . entrySet ( ) ) { \nmsgToSet . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1337": "public class SendMailSession { \nprivate void setPeople ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nmsgToSet . setFrom ( emailWithData . from ( ) . toInternetAddress ( ) ) ; \nmsgToSet . setReplyTo ( EmailAddress . convert ( emailWithData . replyTo ( ) ) ) ; \nsetRecipients ( emailWithData , msgToSet ) ; \nreturn ; \n} \n} \n"}
{"1338": "public class SendMailSession { \nprivate void setRecipients ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal InternetAddress [ ] to = EmailAddress . convert ( emailWithData . to ( ) ) ; \nif ( to . length > 0 ) { \nmsgToSet . setRecipients ( RecipientType . TO , to ) ; \n} \nfinal InternetAddress [ ] cc = EmailAddress . convert ( emailWithData . cc ( ) ) ; \nif ( cc . length > 0 ) { \nmsgToSet . setRecipients ( RecipientType . CC , cc ) ; \n} \nfinal InternetAddress [ ] bcc = EmailAddress . convert ( emailWithData . bcc ( ) ) ; \nif ( bcc . length > 0 ) { \nmsgToSet . setRecipients ( RecipientType . BCC , bcc ) ; \n} \nreturn ; \n} \n} \n"}
{"1339": "public class SendMailSession { \nprivate void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal List < EmailMessage > messages = emailWithData . messages ( ) ; \nfinal int totalMessages = messages . size ( ) ; \nfinal List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList < > ( emailWithData . attachments ( ) ) ; \nif ( attachments . isEmpty ( ) && totalMessages == 1 ) { \nsetContent ( messages . get ( 0 ) , msgToSet ) ; \n} \nelse { \nfinal MimeMultipart multipart = new MimeMultipart ( ) ; \nfinal MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; \nmultipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; \nfor ( final EmailMessage emailMessage : messages ) { \nmsgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; \n} \naddAnyAttachments ( attachments , multipart ) ; \nmsgToSet . setContent ( multipart ) ; \n} \nreturn ; \n} \n} \n"}
{"1340": "public class SendMailSession { \nprivate void setContent ( final EmailMessage emailWithData , final Part partToSet ) throws MessagingException { \npartToSet . setContent ( emailWithData . getContent ( ) , emailWithData . getMimeType ( ) + CHARSET + emailWithData . getEncoding ( ) ) ; \nreturn ; \n} \n} \n"}
{"1343": "public class DbQueryBase { \nprotected void saveResultSet ( final ResultSet rs ) { \nif ( resultSets == null ) { \nresultSets = new HashSet < > ( ) ; \n} \nresultSets . add ( rs ) ; \nreturn ; \n} \n} \n"}
{"1346": "public class DbQueryBase { \n@ Override @ SuppressWarnings ( { \n\"ClassReferencesSubclass\" } \n) public void close ( ) { \nfinal SQLException sqlException = closeQuery ( ) ; \nconnection = null ; \nif ( this . session != null ) { \nthis . session . detachQuery ( this ) ; \n} \nif ( sqlException != null ) { \nthrow new DbSqlException ( \"Close query error\" , sqlException ) ; \n} \nreturn ; \n} \n} \n"}
{"1358": "public class SimpleLogger { \nprotected void print ( final Level level , final String message , final Throwable throwable ) { \nif ( ! isEnabled ( level ) ) { \nreturn ; \n} \nStringBuilder msg = new StringBuilder ( ) . append ( slf . getElapsedTime ( ) ) . append ( ' ' ) . append ( '[' ) . append ( level ) . append ( ']' ) . append ( ' ' ) . append ( getCallerClass ( ) ) . append ( ' ' ) . append ( '-' ) . append ( ' ' ) . append ( message ) ; \nSystem . out . println ( msg . toString ( ) ) ; \nif ( throwable != null ) { \nthrowable . printStackTrace ( System . out ) ; \n} \nreturn ; \n} \n} \n"}
{"1362": "public class JsonSerializer { \npublic void serialize ( final Object source , final Appendable target ) { \nJsonContext jsonContext = createJsonContext ( target ) ; \njsonContext . serialize ( source ) ; \nreturn ; \n} \n} \n"}
{"1365": "public class ObjectUtil { \npublic static void writeObject ( final File dest , final Object object ) throws IOException { \nFileOutputStream fos = null ; \nBufferedOutputStream bos = null ; \nObjectOutputStream oos = null ; \ntry { \nfos = new FileOutputStream ( dest ) ; \nbos = new BufferedOutputStream ( fos ) ; \noos = new ObjectOutputStream ( bos ) ; \noos . writeObject ( object ) ; \n} \nfinally { \nStreamUtil . close ( oos ) ; \nStreamUtil . close ( bos ) ; \nStreamUtil . close ( fos ) ; \n} \nreturn ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) { \nentitiesCache = new HashMap < > ( ) ; \n} \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) { \nObject object = result [ i ] ; \nif ( object == null ) { \ncontinue ; \n} \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) { \ncontinue ; \n} \nObject key ; \nif ( ded . hasIdColumn ( ) ) { \nkey = ded . getKeyValue ( object ) ; \n} \nelse { \nkey = object ; \n} \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( cachedObject == null ) { \nentitiesCache . put ( key , object ) ; \n} \nelse { \nresult [ i ] = cachedObject ; \n} \n} \nreturn ; \n} \n} \n"}
{"1376": "public class ServletDispatcherActionResult { \n@ Override protected void renderView ( final ActionRequest actionRequest , final String target ) throws Exception { \nHttpServletRequest request = actionRequest . getHttpServletRequest ( ) ; \nHttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; \nRequestDispatcher dispatcher = request . getRequestDispatcher ( target ) ; \nif ( dispatcher == null ) { \nresponse . sendError ( SC_NOT_FOUND , \"Result not found: \" + target ) ; \nreturn ; \n} \nif ( DispatcherUtil . isPageIncluded ( request , response ) ) { \ndispatcher . include ( request , response ) ; \n} \nelse { \ndispatcher . forward ( request , response ) ; \n} \nreturn ; \n} \n} \n"}
{"1380": "public class BufferResponseWrapper { \npublic void writeContentToResponse ( final char [ ] content ) throws IOException { \nif ( buffer == null ) { \nreturn ; \n} \nif ( buffer . isUsingStream ( ) ) { \nServletOutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; \nString encoding = getContentTypeEncoding ( ) ; \nif ( encoding == null ) { \noutputStream . write ( CharUtil . toByteArray ( content ) ) ; \n} \nelse { \noutputStream . write ( CharUtil . toByteArray ( content , encoding ) ) ; \n} \noutputStream . flush ( ) ; \n} \nelse { \nWriter out = getResponse ( ) . getWriter ( ) ; \nout . write ( content ) ; \nout . flush ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1381": "public class BufferResponseWrapper { \n@ Override public void setContentType ( final String type ) { \nsuper . setContentType ( type ) ; \ncontentTypeResolver = new ContentTypeHeaderResolver ( type ) ; \nif ( bufferContentType ( type , contentTypeResolver . getMimeType ( ) , contentTypeResolver . getEncoding ( ) ) ) { \nenableBuffering ( ) ; \n} \nelse { \ndisableBuffering ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1382": "public class BufferResponseWrapper { \npublic void print ( final String string ) throws IOException { \nif ( isBufferStreamBased ( ) ) { \nString encoding = getContentTypeEncoding ( ) ; \nbyte [ ] bytes ; \nif ( encoding == null ) { \nbytes = string . getBytes ( ) ; \n} \nelse { \nbytes = string . getBytes ( encoding ) ; \n} \nbuffer . getOutputStream ( ) . write ( bytes ) ; \nreturn ; \n} \nbuffer . getWriter ( ) . write ( string ) ; \nreturn ; \n} \n} \n"}
{"1390": "public class FileUtil { \nprivate static void _copyFile ( final File srcFile , final File destFile ) throws IOException { \nif ( destFile . exists ( ) ) { \nif ( destFile . isDirectory ( ) ) { \nthrow new IOException ( \"Destination '\" + destFile + \"' is a directory\" ) ; \n} \n} \nFileInputStream input = null ; \nFileOutputStream output = null ; \ntry { \ninput = new FileInputStream ( srcFile ) ; \noutput = new FileOutputStream ( destFile , false ) ; \nStreamUtil . copy ( input , output ) ; \n} \nfinally { \nStreamUtil . close ( output ) ; \nStreamUtil . close ( input ) ; \n} \nif ( srcFile . length ( ) != destFile . length ( ) ) { \nthrow new IOException ( \"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\" ) ; \n} \ndestFile . setLastModified ( srcFile . lastModified ( ) ) ; \nreturn ; \n} \n} \n"}
{"1391": "public class FileUtil { \npublic static void copyDir ( final File srcDir , final File destDir ) throws IOException { \ncheckDirCopy ( srcDir , destDir ) ; \n_copyDirectory ( srcDir , destDir ) ; \nreturn ; \n} \n} \n"}
{"1393": "public class FileUtil { \nprivate static void _moveDirectory ( final File srcDest , File destDir ) throws IOException { \nif ( destDir . exists ( ) ) { \ncheckIsDirectory ( destDir ) ; \ndestDir = file ( destDir , destDir . getName ( ) ) ; \ndestDir . mkdir ( ) ; \n} \nfinal boolean rename = srcDest . renameTo ( destDir ) ; \nif ( ! rename ) { \n_copyDirectory ( srcDest , destDir ) ; \ndeleteDir ( srcDest ) ; \n} \nreturn ; \n} \n} \n"}
{"1394": "public class FileUtil { \npublic static void cleanDir ( final File destDir ) throws IOException { \ncheckExists ( destDir ) ; \ncheckIsDirectory ( destDir ) ; \nFile [ ] files = destDir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IOException ( \"Failed to list contents of: \" + destDir ) ; \n} \nIOException exception = null ; \nfor ( File file : files ) { \ntry { \nif ( file . isDirectory ( ) ) { \ndeleteDir ( file ) ; \n} \nelse { \nfile . delete ( ) ; \n} \n} \ncatch ( IOException ioex ) { \nexception = ioex ; \ncontinue ; \n} \n} \nif ( exception != null ) { \nthrow exception ; \n} \nreturn ; \n} \n} \n"}
{"1397": "public class FileUtil { \npublic static void writeChars ( final File dest , final char [ ] data , final String encoding ) throws IOException { \noutChars ( dest , data , encoding , false ) ; \nreturn ; \n} \n} \n"}
{"1398": "public class FileUtil { \npublic static void writeString ( final File dest , final String data , final String encoding ) throws IOException { \noutString ( dest , data , encoding , false ) ; \nreturn ; \n} \n} \n"}
{"1399": "public class FileUtil { \npublic static void appendString ( final File dest , final String data , final String encoding ) throws IOException { \noutString ( dest , data , encoding , true ) ; \nreturn ; \n} \n} \n"}
{"1401": "public class FileUtil { \npublic static void writeBytes ( final File dest , final byte [ ] data , final int off , final int len ) throws IOException { \noutBytes ( dest , data , off , len , false ) ; \nreturn ; \n} \n} \n"}
{"1402": "public class FileUtil { \npublic static void appendBytes ( final File dest , final byte [ ] data , final int off , final int len ) throws IOException { \noutBytes ( dest , data , off , len , true ) ; \nreturn ; \n} \n} \n"}
{"1403": "public class FileUtil { \npublic static void copy ( final File src , final File dest ) throws IOException { \nif ( src . isDirectory ( ) ) { \ncopyDir ( src , dest ) ; \nreturn ; \n} \nif ( dest . isDirectory ( ) ) { \ncopyFileToDir ( src , dest ) ; \nreturn ; \n} \ncopyFile ( src , dest ) ; \nreturn ; \n} \n} \n"}
{"1404": "public class FileUtil { \npublic static void delete ( final File dest ) throws IOException { \nif ( dest . isDirectory ( ) ) { \ndeleteDir ( dest ) ; \nreturn ; \n} \ndeleteFile ( dest ) ; \nreturn ; \n} \n} \n"}
{"1407": "public class FileUtil { \nprivate static void checkDirCopy ( final File srcDir , final File destDir ) throws IOException { \ncheckExists ( srcDir ) ; \ncheckIsDirectory ( srcDir ) ; \nif ( equals ( srcDir , destDir ) ) { \nthrow new IOException ( \"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1408": "public class FileUtil { \nprivate static void checkFileCopy ( final File srcFile , final File destFile ) throws IOException { \ncheckExists ( srcFile ) ; \ncheckIsFile ( srcFile ) ; \nif ( equals ( srcFile , destFile ) ) { \nthrow new IOException ( \"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\" ) ; \n} \nFile destParent = destFile . getParentFile ( ) ; \nif ( destParent != null && ! destParent . exists ( ) ) { \ncheckCreateDirectory ( destParent ) ; \n} \nreturn ; \n} \n} \n"}
{"1409": "public class Cli { \npublic void printUsage ( final String commandName ) { \nfinal StringBuilder usage = new StringBuilder ( commandName ) ; \nfor ( final Option option : options ) { \nif ( option . shortName != null ) { \nusage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; \n} \nelse if ( option . longName != null ) { \nusage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; \n} \n} \nfor ( final Param param : params ) { \nusage . append ( \" \" ) . append ( param . label ) ; \n} \nSystem . out . println ( usage ) ; \nreturn ; \n} \n} \n"}
{"1412": "public class ActionsManager { \npublic void registerPathAlias ( final String alias , final String path ) { \nfinal String existing = pathAliases . put ( alias , path ) ; \nif ( existing != null ) { \nthrow new MadvocException ( \"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing ) ; \n} \nreturn ; \n} \n} \n"}
{"1420": "public class TypeJsonSerializerMap { \npublic void register ( final Class type , final TypeJsonSerializer typeJsonSerializer ) { \nmap . put ( type , typeJsonSerializer ) ; \ncache . clear ( ) ; \nreturn ; \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nwhile ( true ) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) { \nbreak ; \n} \nif ( header . isFile ) { \nString fileName = header . fileName ; \nif ( fileName . length ( ) > 0 ) { \nif ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) { \ninput . skipBytes ( 128 ) ; \n} \n} \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) { \nif ( newFile . getSize ( ) == 0 ) { \nnewFile . size = - 1 ; \n} \n} \nputFile ( header . formFieldName , newFile ) ; \n} \nelse { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nint nextByte = input . read ( ) ; \nif ( nextByte == - 1 || nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1427": "public class CharacterEncodingFilter { \n@ Override public void init ( final FilterConfig filterConfig ) { \nthis . filterConfig = filterConfig ; \nthis . encoding = filterConfig . getInitParameter ( \"encoding\" ) ; \nif ( this . encoding == null ) { \nthis . encoding = JoddCore . encoding ; \n} \nthis . ignore = Converter . get ( ) . toBooleanValue ( filterConfig . getInitParameter ( \"ignore\" ) , true ) ; \nreturn ; \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nend ++ ; \nlast = end ; \n} \nreturn ; \n} \n} \n"}
{"1437": "public class Madvoc { \npublic void configureWith ( final ServletContext servletContext ) { \nwebAppClassName = servletContext . getInitParameter ( PARAM_MADVOC_WEBAPP ) ; \nparamsFiles = Converter . get ( ) . toStringArray ( servletContext . getInitParameter ( PARAM_MADVOC_PARAMS ) ) ; \nmadvocConfiguratorClassName = servletContext . getInitParameter ( PARAM_MADVOC_CONFIGURATOR ) ; \nreturn ; \n} \n} \n"}
{"1438": "public class JsonParser { \nprotected void reset ( ) { \nthis . ndx = 0 ; \nthis . textLen = 0 ; \nthis . path = new Path ( ) ; \nthis . notFirstObject = false ; \nif ( useAltPaths ) { \npath . altPath = new Path ( ) ; \n} \nif ( classMetadataName != null ) { \nmapToBean = createMapToBean ( classMetadataName ) ; \n} \nreturn ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nelse if ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse if ( c == '{' ) { \nbracketCount ++ ; \n} \nelse if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nndx ++ ; \n} \nreturn ; \n} \n} \n"}
{"1451": "public class ProxettaWrapperClassBuilder { \nprotected void createEmptyCtor ( ) { \nfinal MethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_PUBLIC , INIT , \"()V\" , null , null ) ; \nmv . visitCode ( ) ; \nmv . visitVarInsn ( Opcodes . ALOAD , 0 ) ; \nmv . visitMethodInsn ( Opcodes . INVOKESPECIAL , AsmUtil . SIGNATURE_JAVA_LANG_OBJECT , INIT , \"()V\" , false ) ; \nmv . visitInsn ( Opcodes . RETURN ) ; \nmv . visitMaxs ( 1 , 1 ) ; \nmv . visitEnd ( ) ; \nreturn ; \n} \n} \n"}
{"1452": "public class ProxettaWrapperClassBuilder { \nprotected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { \nint access = msign . getAccessFlags ( ) ; \naccess &= ~ ACC_ABSTRACT ; \naccess &= ~ ACC_NATIVE ; \nMethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; \nmv . visitCode ( ) ; \nmv . visitVarInsn ( ALOAD , 0 ) ; \nmv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; \nloadVirtualMethodArguments ( mv , msign ) ; \nif ( wd . wrapInterface ) { \nmv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; \n} \nelse { \nmv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; \n} \nProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; \nvisitReturn ( mv , msign , true ) ; \nmv . visitMaxs ( 0 , 0 ) ; \nmv . visitEnd ( ) ; \nreturn ; \n} \n} \n"}
{"1459": "public class ReferencesResolver { \nprivate void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { \nfor ( int i = 0 ; \ni < allBeanReferences . length ; \ni ++ ) { \nBeanReferences references = allBeanReferences [ i ] ; \nallBeanReferences [ i ] = references . removeDuplicateNames ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1462": "public class StandaloneJoddJoy { \npublic void runJoy ( final Consumer < JoddJoyRuntime > consumer ) { \nfinal JoddJoy joddJoy = new JoddJoy ( ) ; \nfinal JoddJoyRuntime joyRuntime = joddJoy . startOnlyBackend ( ) ; \njoddJoy . withDb ( joyDb -> setJtxManager ( joyRuntime . getJtxManager ( ) ) ) ; \nfinal JtxTransaction tx = startRwTx ( ) ; \nfinal Print print = new Print ( ) ; \ntry { \nprint . line ( \"START\" , 80 ) ; \nprint . newLine ( ) ; \nconsumer . accept ( joyRuntime ) ; \nprint . newLine ( ) ; \nprint . line ( \"END\" , 80 ) ; \nif ( tx != null ) { \ntx . commit ( ) ; \n} \n} \ncatch ( Throwable throwable ) { \nthrowable . printStackTrace ( ) ; \nif ( tx != null ) { \ntx . rollback ( ) ; \n} \n} \njoddJoy . stop ( ) ; \nreturn ; \n} \n} \n"}
{"1467": "public class ClassUtil { \npublic static void forceAccess ( final AccessibleObject accObject ) { \ntry { \nif ( System . getSecurityManager ( ) == null ) accObject . setAccessible ( true ) ; \nelse { \nAccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { \naccObject . setAccessible ( true ) ; \nreturn null ; \n} \n) ; \n} \n} \ncatch ( SecurityException sex ) { \n} \nreturn ; \n} \n} \n"}
{"1472": "public class ThreadUtil { \npublic static void sleep ( final long ms ) { \ntry { \nThread . sleep ( ms ) ; \n} \ncatch ( InterruptedException iex ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1473": "public class ThreadUtil { \npublic static void sleep ( ) { \ntry { \nThread . sleep ( Long . MAX_VALUE ) ; \n} \ncatch ( InterruptedException iex ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1474": "public class ThreadUtil { \npublic static void wait ( final Object obj ) { \nsynchronized ( obj ) { \ntry { \nobj . wait ( ) ; \n} \ncatch ( InterruptedException inex ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1477": "public class MethodVisitor { \npublic void visitParameter ( final String name , final int access ) { \nif ( api < Opcodes . ASM5 ) { \nthrow new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \n} \nif ( mv != null ) { \nmv . visitParameter ( name , access ) ; \n} \nreturn ; \n} \n} \n"}
{"1481": "public class MethodVisitor { \npublic void visitFieldInsn ( final int opcode , final String owner , final String name , final String descriptor ) { \nif ( mv != null ) { \nmv . visitFieldInsn ( opcode , owner , name , descriptor ) ; \n} \nreturn ; \n} \n} \n"}
{"1482": "public class MethodVisitor { \npublic void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nif ( api < Opcodes . ASM5 ) { \nif ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) { \nthrow new IllegalArgumentException ( \"INVOKESPECIAL/STATIC on interfaces requires ASM5\" ) ; \n} \nvisitMethodInsn ( opcode , owner , name , descriptor ) ; \nreturn ; \n} \nif ( mv != null ) { \nmv . visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; \n} \nreturn ; \n} \n} \n"}
{"1483": "public class MethodVisitor { \npublic void visitInvokeDynamicInsn ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { \nif ( api < Opcodes . ASM5 ) { \nthrow new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \n} \nif ( mv != null ) { \nmv . visitInvokeDynamicInsn ( name , descriptor , bootstrapMethodHandle , bootstrapMethodArguments ) ; \n} \nreturn ; \n} \n} \n"}
{"1484": "public class MethodVisitor { \npublic void visitJumpInsn ( final int opcode , final Label label ) { \nif ( mv != null ) { \nmv . visitJumpInsn ( opcode , label ) ; \n} \nreturn ; \n} \n} \n"}
{"1485": "public class MethodVisitor { \npublic void visitMultiANewArrayInsn ( final String descriptor , final int numDimensions ) { \nif ( mv != null ) { \nmv . visitMultiANewArrayInsn ( descriptor , numDimensions ) ; \n} \nreturn ; \n} \n} \n"}
{"1486": "public class MethodVisitor { \npublic void visitTryCatchBlock ( final Label start , final Label end , final Label handler , final String type ) { \nif ( mv != null ) { \nmv . visitTryCatchBlock ( start , end , handler , type ) ; \n} \nreturn ; \n} \n} \n"}
{"1488": "public class PropertiesToProps { \nvoid convertToWriter ( final Writer writer , final Properties properties , final Map < String , Properties > profiles ) throws IOException { \nfinal BufferedWriter bw = getBufferedWriter ( writer ) ; \nwriteBaseAndProfileProperties ( bw , properties , profiles ) ; \nwriteProfilePropertiesThatAreNotInTheBase ( bw , properties , profiles ) ; \nbw . flush ( ) ; \nreturn ; \n} \n} \n"}
{"1489": "public class MemoryFileUpload { \n@ Override public void processStream ( ) throws IOException { \nFastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; \nsize = 0 ; \nif ( maxFileSize == - 1 ) { \nsize += input . copyAll ( out ) ; \n} \nelse { \nsize += input . copyMax ( out , maxFileSize + 1 ) ; \nif ( size > maxFileSize ) { \nfileTooBig = true ; \nvalid = false ; \ninput . skipToBoundary ( ) ; \nreturn ; \n} \n} \ndata = out . toByteArray ( ) ; \nsize = data . length ; \nvalid = true ; \nreturn ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \nreturn ; \n} \n} \n"}
{"1504": "public class MethodWriter { \nprivate void endCurrentBasicBlockWithNoSuccessor ( ) { \nif ( compute == COMPUTE_ALL_FRAMES ) { \nLabel nextBasicBlock = new Label ( ) ; \nnextBasicBlock . frame = new Frame ( nextBasicBlock ) ; \nnextBasicBlock . resolve ( code . data , code . length ) ; \nlastBasicBlock . nextBasicBlock = nextBasicBlock ; \nlastBasicBlock = nextBasicBlock ; \ncurrentBasicBlock = null ; \n} \nelse if ( compute == COMPUTE_MAX_STACK_AND_LOCAL ) { \ncurrentBasicBlock . outputStackMax = ( short ) maxRelativeStackSize ; \ncurrentBasicBlock = null ; \n} \nreturn ; \n} \n} \n"}
{"1505": "public class MethodWriter { \nfinal void collectAttributePrototypes ( final Attribute . Set attributePrototypes ) { \nattributePrototypes . addAttributes ( firstAttribute ) ; \nattributePrototypes . addAttributes ( firstCodeAttribute ) ; \nreturn ; \n} \n} \n"}
{"1506": "public class ContextInjectorComponent { \npublic void injectContext ( final Object targetObject ) { \nfinal Class targetType = targetObject . getClass ( ) ; \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopesWithCache ( targetType ) ; \nfinal Targets targets = new Targets ( targetObject , scopeData ) ; \nscopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( targets ) ) ; \nscopeResolver . forScope ( ParamsScope . class , scope -> scope . inject ( targets ) ) ; \nfinal ServletContext servletContext = madvocController . getApplicationContext ( ) ; \nif ( servletContext != null ) { \nscopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( servletContext , targets ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1507": "public class PseudoClassSelector { \npublic static void registerPseudoClass ( final Class < ? extends PseudoClass > pseudoClassType ) { \nPseudoClass pseudoClass ; \ntry { \npseudoClass = ClassUtil . newInstance ( pseudoClassType ) ; \n} \ncatch ( Exception ex ) { \nthrow new CSSellyException ( ex ) ; \n} \nPSEUDO_CLASS_MAP . put ( pseudoClass . getPseudoClassName ( ) , pseudoClass ) ; \nreturn ; \n} \n} \n"}
{"1509": "public class AsyncActionExecutor { \npublic void invoke ( final ActionRequest actionRequest ) { \nif ( executorService == null ) { \nthrow new MadvocException ( \"No action is marked as async!\" ) ; \n} \nfinal HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; \nlog . debug ( ( ) -> \"Async call to: \" + actionRequest ) ; \nfinal AsyncContext asyncContext = servletRequest . startAsync ( ) ; \nexecutorService . submit ( ( ) -> { \ntry { \nactionRequest . invoke ( ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( \"Invoking async action path failed: \" , ExceptionUtil . unwrapThrowable ( ex ) ) ; \n} \nfinally { \nasyncContext . complete ( ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"1511": "public class BeanVisitor { \npublic void visit ( ) { \nString [ ] properties = resolveProperties ( source , declared ) ; \nfor ( String name : properties ) { \nif ( name == null ) { \ncontinue ; \n} \nif ( ! rules . match ( name , blacklist ) ) { \ncontinue ; \n} \nObject value ; \nString propertyName = name ; \nif ( isSourceMap ) { \npropertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; \n} \nif ( declared ) { \nvalue = BeanUtil . declared . getProperty ( source , propertyName ) ; \n} \nelse { \nvalue = BeanUtil . pojo . getProperty ( source , propertyName ) ; \n} \nif ( value == null && ignoreNullValues ) { \ncontinue ; \n} \nif ( value instanceof String && StringUtil . isEmpty ( ( String ) value ) ) { \ncontinue ; \n} \nvisitProperty ( name , value ) ; \n} \nreturn ; \n} \n} \n"}
{"1514": "public class HtmlStaplerFilter { \nprotected void readFilterConfigParameters ( final FilterConfig filterConfig , final Object target , final String ... parameters ) { \nfor ( String parameter : parameters ) { \nString value = filterConfig . getInitParameter ( parameter ) ; \nif ( value != null ) { \nBeanUtil . declared . setProperty ( target , parameter , value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1515": "public class HtmlStaplerFilter { \nprotected void sendBundleFile ( final HttpServletResponse resp , final File bundleFile ) throws IOException { \nOutputStream out = resp . getOutputStream ( ) ; \nFileInputStream fileInputStream = new FileInputStream ( bundleFile ) ; \ntry { \nStreamUtil . copy ( fileInputStream , out ) ; \n} \nfinally { \nStreamUtil . close ( fileInputStream ) ; \n} \nreturn ; \n} \n} \n"}
{"1520": "public class HtmlStaplerBundlesManager { \nprotected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { \nfinal File bundleFile = createBundleFile ( bundleId ) ; \nif ( bundleFile . exists ( ) ) { \nreturn ; \n} \nStringBand sb = new StringBand ( sources . size ( ) * 2 ) ; \nfor ( String src : sources ) { \nif ( sb . length ( ) != 0 ) { \nsb . append ( StringPool . NEWLINE ) ; \n} \nString content ; \nif ( isExternalResource ( src ) ) { \ncontent = downloadString ( src ) ; \n} \nelse { \nif ( ! downloadLocal ) { \nString localFile = webRoot ; \nif ( src . startsWith ( contextPath + '/' ) ) { \nsrc = src . substring ( contextPath . length ( ) ) ; \n} \nif ( src . startsWith ( StringPool . SLASH ) ) { \nlocalFile += src ; \n} \nelse { \nlocalFile += '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; \n} \nint qmndx = localFile . indexOf ( '?' ) ; \nif ( qmndx != - 1 ) { \nlocalFile = localFile . substring ( 0 , qmndx ) ; \n} \ntry { \ncontent = FileUtil . readString ( localFile ) ; \n} \ncatch ( IOException ioex ) { \nif ( notFoundExceptionEnabled ) { \nthrow ioex ; \n} \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( ioex . getMessage ( ) ) ; \n} \ncontent = null ; \n} \n} \nelse { \nString localUrl = localAddressAndPort ; \nif ( src . startsWith ( StringPool . SLASH ) ) { \nlocalUrl += contextPath + src ; \n} \nelse { \nlocalUrl += contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; \n} \ncontent = downloadString ( localUrl ) ; \n} \nif ( content != null ) { \nif ( isCssResource ( src ) ) { \ncontent = fixCssRelativeUrls ( content , src ) ; \n} \n} \n} \nif ( content != null ) { \ncontent = onResourceContent ( content ) ; \nsb . append ( content ) ; \n} \n} \nFileUtil . writeString ( bundleFile , sb . toString ( ) ) ; \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"Bundle created: \" + bundleId ) ; \n} \nreturn ; \n} \n} \n"}
{"1521": "public class HtmlStaplerBundlesManager { \npublic synchronized void reset ( ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . clear ( ) ; \nmirrors . clear ( ) ; \n} \nfinal FindFile ff = new FindFile ( ) ; \nff . includeDirs ( false ) ; \nff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; \nFile f ; \nint count = 0 ; \nwhile ( ( f = ff . nextFile ( ) ) != null ) { \nf . delete ( ) ; \ncount ++ ; \n} \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"reset: \" + count + \" bundle files deleted.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1527": "public class GenericsReader { \npublic Map < String , String > parseSignatureForGenerics ( final String signature , final boolean isInterface ) { \nif ( signature == null ) { \nreturn Collections . emptyMap ( ) ; \n} \nfinal Map < String , String > genericsMap = new HashMap < > ( ) ; \nSignatureReader sr = new SignatureReader ( signature ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nTraceSignatureVisitor v = new TraceSignatureVisitor ( sb , isInterface ) { \nString genericName ; \n@ Override public void visitFormalTypeParameter ( final String name ) { \ngenericName = name ; \nsuper . visitFormalTypeParameter ( name ) ; \nreturn ; \n} \n@ Override public void visitClassType ( final String name ) { \nif ( genericName != null ) { \ngenericsMap . put ( genericName , 'L' + name + ';' ) ; \ngenericName = null ; \n} \nsuper . visitClassType ( name ) ; \nreturn ; \n} \n} \n; \nsr . accept ( v ) ; \nreturn genericsMap ; \n} \n} \n"}
{"1530": "public class DbSession { \nprotected void openConnectionForQuery ( ) { \nif ( connection == null ) { \nconnection = connectionProvider . getConnection ( ) ; \ntxActive = false ; \ntry { \nconnection . setAutoCommit ( true ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( \"Failed to open non-TX connection\" , sex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1531": "public class DbSession { \nprotected void openTx ( ) { \nif ( connection == null ) { \nconnection = connectionProvider . getConnection ( ) ; \n} \ntxActive = true ; \ntry { \nconnection . setAutoCommit ( false ) ; \nif ( txMode . getIsolation ( ) != DbTransactionMode . ISOLATION_DEFAULT ) { \nconnection . setTransactionIsolation ( txMode . getIsolation ( ) ) ; \n} \nconnection . setReadOnly ( txMode . isReadOnly ( ) ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( \"Open TX failed\" , sex ) ; \n} \nreturn ; \n} \n} \n"}
{"1532": "public class DbSession { \nprotected void closeTx ( ) { \ntxActive = false ; \ntry { \nconnection . setAutoCommit ( true ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( \"Close TX failed\" , sex ) ; \n} \nreturn ; \n} \n} \n"}
{"1533": "public class DbSession { \npublic void commitTransaction ( ) { \nlog . debug ( \"Committing transaction\" ) ; \nassertTxIsActive ( ) ; \ntry { \nconnection . commit ( ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( \"Commit TX failed\" , sex ) ; \n} \nfinally { \ncloseTx ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1534": "public class DbSession { \npublic void rollbackTransaction ( ) { \nlog . debug ( \"Rolling-back transaction\" ) ; \nassertTxIsActive ( ) ; \ntry { \nconnection . rollback ( ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( \"Rollback TX failed\" , sex ) ; \n} \nfinally { \ncloseTx ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1537": "public class PropertiesUtil { \npublic static void loadFromString ( final Properties p , final String data ) throws IOException { \ntry ( ByteArrayInputStream is = new ByteArrayInputStream ( data . getBytes ( StringPool . ISO_8859_1 ) ) ) { \np . load ( is ) ; \n} \nreturn ; \n} \n} \n"}
{"1541": "public class PropertiesUtil { \npublic static void resolveAllVariables ( final Properties prop ) { \nfor ( Object o : prop . keySet ( ) ) { \nString key = ( String ) o ; \nString value = resolveProperty ( prop , key ) ; \nprop . setProperty ( key , value ) ; \n} \nreturn ; \n} \n} \n"}
{"1545": "public class AnnotationTxAdviceManager { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { \nthis . annotations = annotations ; \nthis . annotationParsers = new AnnotationParser [ annotations . length ] ; \nfor ( int i = 0 ; \ni < annotations . length ; \ni ++ ) { \nannotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"1553": "public class Node { \npublic void detachFromParent ( ) { \nif ( parentNode == null ) { \nreturn ; \n} \nif ( parentNode . childNodes != null ) { \nparentNode . childNodes . remove ( siblingIndex ) ; \nparentNode . reindexChildren ( ) ; \n} \nparentNode = null ; \nreturn ; \n} \n} \n"}
{"1554": "public class Node { \npublic void addChild ( final Node ... nodes ) { \nif ( nodes . length == 0 ) { \nreturn ; \n} \nfor ( Node node : nodes ) { \nnode . detachFromParent ( ) ; \nnode . parentNode = this ; \ninitChildNodes ( node ) ; \nchildNodes . add ( node ) ; \n} \nreindexChildrenOnAdd ( nodes . length ) ; \nreturn ; \n} \n} \n"}
{"1555": "public class Node { \npublic void insertChild ( final Node node , final int index ) { \nnode . detachFromParent ( ) ; \nnode . parentNode = this ; \ntry { \ninitChildNodes ( node ) ; \nchildNodes . add ( index , node ) ; \n} \ncatch ( IndexOutOfBoundsException ignore ) { \nthrow new LagartoDOMException ( \"Invalid node index: \" + index ) ; \n} \nreindexChildren ( ) ; \nreturn ; \n} \n} \n"}
{"1556": "public class Node { \npublic void insertBefore ( final Node newChild , final Node refChild ) { \nint siblingIndex = refChild . getSiblingIndex ( ) ; \nrefChild . parentNode . insertChild ( newChild , siblingIndex ) ; \nreturn ; \n} \n} \n"}
{"1557": "public class Node { \npublic void insertBefore ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) { \nreturn ; \n} \nint siblingIndex = refChild . getSiblingIndex ( ) ; \nrefChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \nreturn ; \n} \n} \n"}
{"1558": "public class Node { \npublic void insertAfter ( final Node newChild , final Node refChild ) { \nint siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { \nrefChild . parentNode . addChild ( newChild ) ; \n} \nelse { \nrefChild . parentNode . insertChild ( newChild , siblingIndex ) ; \n} \nreturn ; \n} \n} \n"}
{"1559": "public class Node { \npublic void insertAfter ( final Node [ ] newChilds , final Node refChild ) { \nif ( newChilds . length == 0 ) { \nreturn ; \n} \nint siblingIndex = refChild . getSiblingIndex ( ) + 1 ; \nif ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { \nrefChild . parentNode . addChild ( newChilds ) ; \n} \nelse { \nrefChild . parentNode . insertChild ( newChilds , siblingIndex ) ; \n} \nreturn ; \n} \n} \n"}
{"1560": "public class Node { \npublic void removeAllChilds ( ) { \nList < Node > removedNodes = childNodes ; \nchildNodes = null ; \nchildElementNodes = null ; \nchildElementNodesCount = 0 ; \nif ( removedNodes != null ) { \nfor ( int i = 0 , removedNodesSize = removedNodes . size ( ) ; \ni < removedNodesSize ; \ni ++ ) { \nNode removedNode = removedNodes . get ( i ) ; \nremovedNode . detachFromParent ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1564": "public class Node { \nprotected void initChildElementNodes ( ) { \nif ( childElementNodes == null ) { \nchildElementNodes = new Element [ childElementNodesCount ] ; \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nchildElementNodes [ child . siblingElementIndex ] = ( Element ) child ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nsibling . siblingNameIndex = index ++ ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"1566": "public class Node { \nprotected void initChildNodes ( final Node newNode ) { \nif ( childNodes == null ) { \nchildNodes = new ArrayList < > ( ) ; \n} \nif ( ownerDocument != null ) { \nif ( newNode . ownerDocument != ownerDocument ) { \nchangeOwnerDocument ( newNode , ownerDocument ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1567": "public class Node { \nprotected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { \nnode . ownerDocument = ownerDocument ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = node . getChild ( i ) ; \nchangeOwnerDocument ( child , ownerDocument ) ; \n} \nreturn ; \n} \n} \n"}
{"1572": "public class Node { \nprotected void visitChildren ( final NodeVisitor nodeVisitor ) { \nif ( childNodes != null ) { \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nchildNode . visit ( nodeVisitor ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1574": "public class DecoratorTagVisitor { \nprotected void onDecoraTag ( final Tag tag ) { \nString tagName = tag . getName ( ) . toString ( ) ; \nif ( tag . getType ( ) == TagType . SELF_CLOSING ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName . substring ( 7 ) ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \ndefineDecoraTag ( ) ; \nreturn ; \n} \nif ( tag . getType ( ) == TagType . START ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName . substring ( 7 ) ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \nreturn ; \n} \ndecoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \ndecoraTagDefaultValueEnd = tag . getTagPosition ( ) ; \ndefineDecoraTag ( ) ; \nreturn ; \n} \n} \n"}
{"1575": "public class DecoratorTagVisitor { \nprotected void onIdAttrStart ( final Tag tag ) { \nString id = tag . getId ( ) . toString ( ) . substring ( 7 ) ; \nString tagName ; \nString idName ; \nint dashIndex = id . indexOf ( '-' ) ; \nif ( dashIndex == - 1 ) { \ntagName = id ; \nidName = null ; \n} \nelse { \ntagName = id . substring ( 0 , dashIndex ) ; \nidName = id . substring ( dashIndex + 1 ) ; \n} \nif ( tag . getType ( ) == TagType . SELF_CLOSING ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName ; \ndecoraIdName = idName ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \ndefineDecoraTag ( ) ; \nreturn ; \n} \nif ( tag . getType ( ) == TagType . START ) { \ncheckNestedDecoraTags ( ) ; \ndecoraTagName = tagName ; \ndecoraIdName = idName ; \ndecoraTagStart = tag . getTagPosition ( ) ; \ndecoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; \nclosingTagName = tag . getName ( ) . toString ( ) ; \nclosingTagDeepLevel = tag . getDeepLevel ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1576": "public class DecoratorTagVisitor { \nprotected void defineDecoraTag ( ) { \nDecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag ( decoraTagName , decoraIdName , decoraTagStart , decoraTagEnd ) : new DecoraTag ( decoraTagName , decoraIdName , decoraTagStart , decoraTagEnd , decoraTagDefaultValueStart , decoraTagDefaultValueEnd - decoraTagDefaultValueStart ) ; \ndecoraTags . add ( decoraTag ) ; \ndecoraTagName = null ; \ndecoraIdName = null ; \nclosingTagName = null ; \ndecoraTagDefaultValueStart = 0 ; \nreturn ; \n} \n} \n"}
{"1578": "public class RootPackages { \npublic void addRootPackage ( final String rootPackage , String mapping ) { \nif ( packages == null ) { \npackages = new String [ 0 ] ; \n} \nif ( mappings == null ) { \nmappings = new String [ 0 ] ; \n} \nif ( mapping . length ( ) > 0 ) { \nif ( ! mapping . startsWith ( StringPool . SLASH ) ) { \nmapping = StringPool . SLASH + mapping ; \n} \nif ( mapping . endsWith ( StringPool . SLASH ) ) { \nmapping = StringUtil . substring ( mapping , 0 , - 1 ) ; \n} \n} \nfor ( int i = 0 ; \ni < packages . length ; \ni ++ ) { \nif ( packages [ i ] . equals ( rootPackage ) ) { \nif ( mappings [ i ] . equals ( mapping ) ) { \nreturn ; \n} \nthrow new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; \n} \n} \npackages = ArraysUtil . append ( packages , rootPackage ) ; \nmappings = ArraysUtil . append ( mappings , mapping ) ; \nreturn ; \n} \n} \n"}
{"1579": "public class RootPackages { \npublic void addRootPackageOf ( final Class actionClass , final String mapping ) { \naddRootPackage ( actionClass . getPackage ( ) . getName ( ) , mapping ) ; \nreturn ; \n} \n} \n"}
{"1584": "public class Targets { \npublic void forEachTarget ( final Consumer < Target > targetConsumer ) { \nfor ( final Target target : targets ) { \ntargetConsumer . accept ( target ) ; \n} \nreturn ; \n} \n} \n"}
{"1585": "public class Targets { \npublic void forEachTargetAndIn ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { \nfor ( final Target target : targets ) { \nfinal ScopeData scopeData = target . scopeData ( ) ; \nif ( scopeData . in ( ) == null ) { \ncontinue ; \n} \nfor ( final InjectionPoint in : scopeData . in ( ) ) { \nif ( in . scope ( ) != scope ) { \ncontinue ; \n} \nbiConsumer . accept ( target , in ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1586": "public class Targets { \npublic void forEachTargetAndOut ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { \nfor ( final Target target : targets ) { \nfinal ScopeData scopeData = target . scopeData ( ) ; \nif ( scopeData . out ( ) == null ) { \ncontinue ; \n} \nfor ( final InjectionPoint out : scopeData . out ( ) ) { \nif ( out . scope ( ) != scope ) { \ncontinue ; \n} \nbiConsumer . accept ( target , out ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1590": "public class SessionMonitor { \n@ Override public void sessionCreated ( final HttpSessionEvent httpSessionEvent ) { \nHttpSession session = httpSessionEvent . getSession ( ) ; \nsessionMap . putIfAbsent ( session . getId ( ) , session ) ; \nfor ( HttpSessionListener listener : listeners ) { \nlistener . sessionCreated ( httpSessionEvent ) ; \n} \nreturn ; \n} \n} \n"}
{"1591": "public class SessionMonitor { \n@ Override public void sessionDestroyed ( final HttpSessionEvent httpSessionEvent ) { \nHttpSession session = httpSessionEvent . getSession ( ) ; \nsessionMap . remove ( session . getId ( ) ) ; \nfor ( HttpSessionListener listener : listeners ) { \nlistener . sessionDestroyed ( httpSessionEvent ) ; \n} \nreturn ; \n} \n} \n"}
{"1596": "public class AbstractTemplateViewActionResult { \nprotected void targetNotFound ( final ActionRequest actionRequest , final String actionAndResultPath ) throws IOException { \nfinal HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; \nif ( ! response . isCommitted ( ) ) { \nresponse . sendError ( SC_NOT_FOUND , \"Result not found: \" + actionAndResultPath ) ; \n} \nreturn ; \n} \n} \n"}
{"1610": "public class MadvocComponentLifecycle { \npublic static void invoke ( final Object listener , final Class listenerType ) { \nif ( listenerType == Init . class ) { \n( ( Init ) listener ) . init ( ) ; \nreturn ; \n} \nif ( listenerType == Start . class ) { \n( ( Start ) listener ) . start ( ) ; \nreturn ; \n} \nif ( listenerType == Ready . class ) { \n( ( Ready ) listener ) . ready ( ) ; \nreturn ; \n} \nif ( listenerType == Stop . class ) { \n( ( Stop ) listener ) . stop ( ) ; \nreturn ; \n} \nthrow new MadvocException ( \"Invalid listener\" ) ; \nreturn ; \n} \n} \n"}
{"1611": "public class Frame { \nfinal void copyFrom ( final Frame frame ) { \ninputLocals = frame . inputLocals ; \ninputStack = frame . inputStack ; \noutputStackStart = 0 ; \noutputLocals = frame . outputLocals ; \noutputStack = frame . outputStack ; \noutputStackTop = frame . outputStackTop ; \ninitializationCount = frame . initializationCount ; \ninitializations = frame . initializations ; \nreturn ; \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \nfor ( int i = 0 ; \ni < numLocal ; \n++ i ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \n} \nwhile ( inputLocalIndex < inputLocals . length ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nint numStackTop = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \n++ numStackTop ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \nreturn ; \n} \n} \n"}
{"1616": "public class Frame { \nprivate void setLocal ( final int localIndex , final int abstractType ) { \nif ( outputLocals == null ) { \noutputLocals = new int [ 10 ] ; \n} \nint outputLocalsLength = outputLocals . length ; \nif ( localIndex >= outputLocalsLength ) { \nint [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; \nSystem . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; \noutputLocals = newOutputLocals ; \n} \noutputLocals [ localIndex ] = abstractType ; \nreturn ; \n} \n} \n"}
{"1617": "public class Frame { \nprivate void push ( final int abstractType ) { \nif ( outputStack == null ) { \noutputStack = new int [ 10 ] ; \n} \nint outputStackLength = outputStack . length ; \nif ( outputStackTop >= outputStackLength ) { \nint [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; \nSystem . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; \noutputStack = newOutputStack ; \n} \noutputStack [ outputStackTop ++ ] = abstractType ; \nshort outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; \nif ( outputStackSize > owner . outputStackMax ) { \nowner . outputStackMax = outputStackSize ; \n} \nreturn ; \n} \n} \n"}
{"1618": "public class Frame { \nprivate void push ( final SymbolTable symbolTable , final String descriptor ) { \nint typeDescriptorOffset = descriptor . charAt ( 0 ) == '(' ? descriptor . indexOf ( ')' ) + 1 : 0 ; \nint abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; \nif ( abstractType != 0 ) { \npush ( abstractType ) ; \nif ( abstractType == LONG || abstractType == DOUBLE ) { \npush ( TOP ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1619": "public class Frame { \nprivate void pop ( final int elements ) { \nif ( outputStackTop >= elements ) { \noutputStackTop -= elements ; \n} \nelse { \noutputStackStart -= elements - outputStackTop ; \noutputStackTop = 0 ; \n} \nreturn ; \n} \n} \n"}
{"1620": "public class Frame { \nprivate void pop ( final String descriptor ) { \nchar firstDescriptorChar = descriptor . charAt ( 0 ) ; \nif ( firstDescriptorChar == '(' ) { \npop ( ( Type . getArgumentsAndReturnSizes ( descriptor ) >> 2 ) - 1 ) ; \n} \nelse if ( firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ) { \npop ( 2 ) ; \n} \nelse { \npop ( 1 ) ; \n} \nreturn ; \n} \n} \n"}
{"1621": "public class Frame { \nprivate void addInitializedType ( final int abstractType ) { \nif ( initializations == null ) { \ninitializations = new int [ 2 ] ; \n} \nint initializationsLength = initializations . length ; \nif ( initializationCount >= initializationsLength ) { \nint [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; \nSystem . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; \ninitializations = newInitializations ; \n} \ninitializations [ initializationCount ++ ] = abstractType ; \nreturn ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nint arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( arrayDimensions == 0 ) { \nint typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nwhile ( arrayDimensions -- > 0 ) { \ntypeDescriptor . append ( '[' ) ; \n} \nif ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { \ntypeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \n} \nelse { \nswitch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \nreturn ; \n} \n} \n"}
{"1625": "public class TimedCache { \npublic void schedulePrune ( final long delay ) { \nif ( pruneTimer != null ) { \npruneTimer . cancel ( ) ; \n} \npruneTimer = new Timer ( ) ; \npruneTimer . schedule ( new TimerTask ( ) { \n@ Override public void run ( ) { \nprune ( ) ; \nreturn ; \n} \n} \n, delay , delay ) ; \nreturn ; \n} \n} \n"}
{"1627": "public class ClassVisitor { \npublic void visitNestHost ( final String nestHost ) { \nif ( api < Opcodes . ASM7 ) { \nthrow new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; \n} \nif ( cv != null ) { \ncv . visitNestHost ( nestHost ) ; \n} \nreturn ; \n} \n} \n"}
{"1628": "public class ClassVisitor { \npublic void visitOuterClass ( final String owner , final String name , final String descriptor ) { \nif ( cv != null ) { \ncv . visitOuterClass ( owner , name , descriptor ) ; \n} \nreturn ; \n} \n} \n"}
{"1630": "public class ClassVisitor { \npublic void visitNestMember ( final String nestMember ) { \nif ( api < Opcodes . ASM7 ) { \nthrow new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; \n} \nif ( cv != null ) { \ncv . visitNestMember ( nestMember ) ; \n} \nreturn ; \n} \n} \n"}
{"1631": "public class ClassVisitor { \npublic void visitInnerClass ( final String name , final String outerName , final String innerName , final int access ) { \nif ( cv != null ) { \ncv . visitInnerClass ( name , outerName , innerName , access ) ; \n} \nreturn ; \n} \n} \n"}
{"1634": "public class DbThreadSession { \npublic static void closeThreadSession ( ) { \nDbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; \nif ( session != null ) { \nsession . closeSession ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1645": "public class LagartoHtmlRendererNodeVisitor { \nprotected void renderAttribute ( final Node node , final Attribute attribute , final Appendable appendable ) throws IOException { \nString name = resolveAttributeName ( node , attribute ) ; \nString value = attribute . getValue ( ) ; \nappendable . append ( name ) ; \nif ( value != null ) { \nappendable . append ( '=' ) ; \nappendable . append ( '\\\"' ) ; \nappendable . append ( HtmlEncoder . attributeDoubleQuoted ( value ) ) ; \nappendable . append ( '\\\"' ) ; \n} \nreturn ; \n} \n} \n"}
{"1653": "public class Props { \npublic void setValue ( final String key , final String value , final String profile ) { \nif ( profile == null ) { \ndata . putBaseProperty ( key , value , false ) ; \n} \nelse { \ndata . putProfileProperty ( key , value , profile , false ) ; \n} \ninitialized = false ; \nreturn ; \n} \n} \n"}
{"1654": "public class Props { \npublic void extractProps ( final Map target ) { \ninitialize ( ) ; \ndata . extract ( target , activeProfiles , null , null ) ; \nreturn ; \n} \n} \n"}
{"1655": "public class Props { \npublic void extractProps ( final Map target , final String ... profiles ) { \ninitialize ( ) ; \ndata . extract ( target , profiles , null , null ) ; \nreturn ; \n} \n} \n"}
{"1656": "public class Props { \npublic void extractSubProps ( final Map target , final String ... wildcardPatterns ) { \ninitialize ( ) ; \ndata . extract ( target , activeProfiles , wildcardPatterns , null ) ; \nreturn ; \n} \n} \n"}
{"1658": "public class Props { \npublic void addInnerMap ( String prefix , final Map < ? , ? > map , final String profile ) { \nif ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { \nprefix += StringPool . DOT ; \n} \nfor ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { \nString key = entry . getKey ( ) . toString ( ) ; \nkey = prefix + key ; \nsetValue ( key , entry . getValue ( ) . toString ( ) , profile ) ; \n} \nreturn ; \n} \n} \n"}
{"1659": "public class Props { \nprotected void resolveActiveProfiles ( ) { \nif ( activeProfilesProp == null ) { \nactiveProfiles = null ; \nreturn ; \n} \nfinal PropsEntry pv = data . getBaseProperty ( activeProfilesProp ) ; \nif ( pv == null ) { \nreturn ; \n} \nfinal String value = pv . getValue ( ) ; \nif ( StringUtil . isBlank ( value ) ) { \nactiveProfiles = null ; \nreturn ; \n} \nactiveProfiles = StringUtil . splitc ( value , ',' ) ; \nStringUtil . trimAll ( activeProfiles ) ; \nreturn ; \n} \n} \n"}
{"1662": "public class BeanDefinition { \nprotected void addPropertyInjectionPoint ( final PropertyInjectionPoint pip ) { \nif ( properties == null ) { \nproperties = new PropertyInjectionPoint [ 1 ] ; \nproperties [ 0 ] = pip ; \n} \nelse { \nproperties = ArraysUtil . append ( properties , pip ) ; \n} \nreturn ; \n} \n} \n"}
{"1663": "public class BeanDefinition { \nprotected void addSetInjectionPoint ( final SetInjectionPoint sip ) { \nif ( sets == null ) { \nsets = new SetInjectionPoint [ 1 ] ; \nsets [ 0 ] = sip ; \n} \nelse { \nsets = ArraysUtil . append ( sets , sip ) ; \n} \nreturn ; \n} \n} \n"}
{"1664": "public class BeanDefinition { \nprotected void addMethodInjectionPoint ( final MethodInjectionPoint mip ) { \nif ( methods == null ) { \nmethods = new MethodInjectionPoint [ 1 ] ; \nmethods [ 0 ] = mip ; \n} \nelse { \nmethods = ArraysUtil . append ( methods , mip ) ; \n} \nreturn ; \n} \n} \n"}
{"1665": "public class BeanDefinition { \nprotected void addInitMethodPoints ( final InitMethodPoint [ ] methods ) { \nif ( initMethods == null ) { \ninitMethods = methods ; \n} \nelse { \ninitMethods = ArraysUtil . join ( initMethods , methods ) ; \n} \nreturn ; \n} \n} \n"}
{"1666": "public class BeanDefinition { \nprotected void addDestroyMethodPoints ( final DestroyMethodPoint [ ] methods ) { \nif ( destroyMethods == null ) { \ndestroyMethods = methods ; \n} \nelse { \ndestroyMethods = ArraysUtil . join ( destroyMethods , methods ) ; \n} \nreturn ; \n} \n} \n"}
{"1668": "public class ProxettaUtil { \npublic static void injectTargetIntoWrapper ( final Object target , final Object wrapper ) { \ninjectTargetIntoWrapper ( target , wrapper , ProxettaNames . wrapperTargetFieldName ) ; \nreturn ; \n} \n} \n"}
{"1682": "public class StreamGobbler { \npublic void waitFor ( ) { \ntry { \nsynchronized ( lock ) { \nif ( ! end ) { \nlock . wait ( ) ; \n} \n} \n} \ncatch ( InterruptedException ignore ) { \nThread . currentThread ( ) . interrupt ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1685": "public class TypeJsonVisitor { \npublic void visit ( ) { \nClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; \nif ( classMetadataName != null ) { \nonProperty ( classMetadataName , null , false ) ; \n} \nPropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { \nGetter getter = propertyDescriptor . getGetter ( declared ) ; \nif ( getter != null ) { \nString propertyName = propertyDescriptor . getName ( ) ; \nboolean isTransient = false ; \nFieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; \nif ( fieldDescriptor != null ) { \nisTransient = Modifier . isTransient ( fieldDescriptor . getField ( ) . getModifiers ( ) ) ; \n} \nonProperty ( propertyName , propertyDescriptor , isTransient ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1687": "public class BeanProperty { \nprivate void setBean ( final Object bean ) { \nthis . bean = bean ; \nthis . cd = ( bean == null ? null : introspector . lookup ( bean . getClass ( ) ) ) ; \nthis . first = false ; \nthis . updateProperty = true ; \nreturn ; \n} \n} \n"}
{"1688": "public class BeanProperty { \npublic void updateBean ( final Object bean ) { \nthis . setBean ( bean ) ; \nif ( this . cd != null && this . cd . isSupplier ( ) ) { \nfinal Object newBean = ( ( Supplier ) this . bean ) . get ( ) ; \nsetBean ( newBean ) ; \n} \nreturn ; \n} \n} \n"}
{"1689": "public class BeanProperty { \nprivate void loadPropertyDescriptor ( ) { \nif ( updateProperty ) { \nif ( cd == null ) { \npropertyDescriptor = null ; \n} \nelse { \npropertyDescriptor = cd . getPropertyDescriptor ( name , true ) ; \n} \nupdateProperty = false ; \n} \nreturn ; \n} \n} \n"}
{"1693": "public class CompositeIterator { \npublic void add ( final Iterator < T > iterator ) { \nif ( allIterators . contains ( iterator ) ) { \nthrow new IllegalArgumentException ( \"Duplicate iterator\" ) ; \n} \nallIterators . add ( iterator ) ; \nreturn ; \n} \n} \n"}
{"1694": "public class JoddJoy { \nprivate void printLogo ( ) { \nSystem . out . println ( Chalk256 . chalk ( ) . yellow ( ) . on ( Jodd . JODD ) ) ; \nreturn ; \n} \n} \n"}
{"1695": "public class JoddJoy { \npublic void stop ( ) { \njoyProps . stop ( ) ; \ntry { \njoyDb . stop ( ) ; \njoyPetite . stop ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( log != null ) { \nlog . info ( \"Joy is down. Bye, bye!\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1704": "public class JsonParserBase { \nprotected void injectValueIntoObject ( final Object target , final PropertyDescriptor pd , final Object value ) { \nObject convertedValue = value ; \nif ( value != null ) { \nClass targetClass = pd . getType ( ) ; \nconvertedValue = convertType ( value , targetClass ) ; \n} \ntry { \nSetter setter = pd . getSetter ( true ) ; \nif ( setter != null ) { \nsetter . invokeSetter ( target , convertedValue ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow new JsonException ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"1706": "public class ModuleVisitor { \npublic void visitProvide ( final String service , final String ... providers ) { \nif ( mv != null ) { \nmv . visitProvide ( service , providers ) ; \n} \nreturn ; \n} \n} \n"}
{"1716": "public class NetUtil { \npublic static void downloadFile ( final String url , final File file ) throws IOException { \ntry ( InputStream inputStream = new URL ( url ) . openStream ( ) ; \nReadableByteChannel rbc = Channels . newChannel ( inputStream ) ; \nFileChannel fileChannel = FileChannel . open ( file . toPath ( ) , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING , StandardOpenOption . WRITE ) ) { \nfileChannel . transferFrom ( rbc , 0 , Long . MAX_VALUE ) ; \n} \nreturn ; \n} \n} \n"}
{"1717": "public class ServletConfigInterceptor { \nprotected void inject ( final ActionRequest actionRequest ) { \nfinal Targets targets = actionRequest . getTargets ( ) ; \nfinal ServletContext servletContext = actionRequest . getHttpServletRequest ( ) . getServletContext ( ) ; \nscopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( servletContext , targets ) ) ; \nscopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( actionRequest , targets ) ) ; \nreturn ; \n} \n} \n"}
{"1718": "public class ServletConfigInterceptor { \nprotected void outject ( final ActionRequest actionRequest ) { \nfinal Targets targets = actionRequest . getTargets ( ) ; \nscopeResolver . forEachScope ( madvocScope -> madvocScope . outject ( actionRequest , targets ) ) ; \nreturn ; \n} \n} \n"}
{"1724": "public class SingletonScope { \n@ Override public void shutdown ( ) { \nfor ( final BeanData beanData : instances . values ( ) ) { \nbeanData . callDestroyMethods ( ) ; \n} \ninstances . clear ( ) ; \nreturn ; \n} \n} \n"}
{"1730": "public class ParsedTag { \npublic void start ( final int startIndex ) { \nthis . tagStartIndex = startIndex ; \nthis . name = null ; \nthis . idNdx = - 1 ; \nthis . attributesCount = 0 ; \nthis . tagLength = 0 ; \nthis . modified = false ; \nthis . type = TagType . START ; \nthis . rawTag = false ; \nreturn ; \n} \n} \n"}
{"1731": "public class MadvocContainer { \npublic < T > void registerComponent ( final String name , final Class < T > component , final Consumer < T > consumer ) { \nlog . debug ( ( ) -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component . getName ( ) ) ; \nmadpc . removeBean ( name ) ; \nmadpc . registerPetiteBean ( component , name , null , null , false , consumer ) ; \nreturn ; \n} \n} \n"}
{"1732": "public class DbOomQuery { \nprotected void resolveColumnDbSqlType ( final Connection connection , final DbEntityColumnDescriptor dec ) { \nif ( dec . dbSqlType != SqlType . DB_SQLTYPE_UNKNOWN ) { \nreturn ; \n} \nResultSet rs = null ; \nDbEntityDescriptor ded = dec . getDbEntityDescriptor ( ) ; \ntry { \nDatabaseMetaData dmd = connection . getMetaData ( ) ; \nrs = dmd . getColumns ( null , ded . getSchemaName ( ) , ded . getTableName ( ) , dec . getColumnName ( ) ) ; \nif ( rs . next ( ) ) { \ndec . dbSqlType = rs . getInt ( \"DATA_TYPE\" ) ; \n} \nelse { \ndec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Column SQL type not available: \" + ded . toString ( ) + '.' + dec . getColumnName ( ) ) ; \n} \n} \n} \ncatch ( SQLException sex ) { \ndec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Column SQL type not resolved: \" + ded . toString ( ) + '.' + dec . getColumnName ( ) , sex ) ; \n} \n} \nfinally { \nDbUtil . close ( rs ) ; \n} \nreturn ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) { \nreturn ; \n} \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \nfor ( int i = 0 ; \ni < generatedColumns . length ; \ni ++ ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! keyValues . getClass ( ) . isArray ( ) ) { \nBeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < properties . length ; \ni ++ ) { \nBeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1741": "public class SqlChunk { \npublic void insertChunkAfter ( final SqlChunk previous ) { \nSqlChunk next = previous . nextChunk ; \nprevious . nextChunk = this ; \nthis . previousChunk = previous ; \nif ( next != null ) { \nnext . previousChunk = this ; \nthis . nextChunk = next ; \n} \nreturn ; \n} \n} \n"}
{"1746": "public class SqlChunk { \nprotected void appendMissingSpace ( final StringBuilder out ) { \nint len = out . length ( ) ; \nif ( len == 0 ) { \nreturn ; \n} \nlen -- ; \nif ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) { \nout . append ( ' ' ) ; \n} \nreturn ; \n} \n} \n"}
{"1752": "public class JoyPetite { \n@ Override public void start ( ) { \ninitLogger ( ) ; \nlog . info ( \"PETITE start  ----------\" ) ; \npetiteContainer = createPetiteContainer ( ) ; \nif ( externalsCache ) { \npetiteContainer . setExternalsCache ( TypeCache . createDefault ( ) ) ; \n} \nlog . info ( \"Web application? \" + isWebApplication ) ; \nif ( ! isWebApplication ) { \npetiteContainer . registerScope ( SessionScope . class , new SingletonScope ( petiteContainer ) ) ; \n} \npetiteContainer . defineParameters ( joyPropsSupplier . get ( ) . getProps ( ) ) ; \nif ( autoConfiguration ) { \nfinal AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator ( petiteContainer ) ; \nautomagicPetiteConfigurator . registerAsConsumer ( joyScannerSupplier . get ( ) . getClassScanner ( ) ) ; \n} \npetiteContainerConsumers . accept ( this . petiteContainer ) ; \nlog . info ( \"PETITE OK!\" ) ; \nreturn ; \n} \n} \n"}
{"1753": "public class JoyPetite { \n@ Override public void stop ( ) { \nif ( log != null ) { \nlog . info ( \"PETITE stop\" ) ; \n} \nif ( petiteContainer != null ) { \npetiteContainer . shutdown ( ) ; \n} \npetiteContainer = null ; \nreturn ; \n} \n} \n"}
{"1768": "public class EmailFilter { \nprotected void concat ( SearchTerm searchTerm ) { \nif ( nextIsNot ) { \nsearchTerm = new NotTerm ( searchTerm ) ; \nnextIsNot = false ; \n} \nif ( operatorAnd ) { \nand ( searchTerm ) ; \n} \nelse { \nor ( searchTerm ) ; \n} \nreturn ; \n} \n} \n"}
{"1774": "public class Vtor { \npublic void useProfile ( final String profile ) { \nif ( profile == null ) { \nreturn ; \n} \nif ( this . enabledProfiles == null ) { \nthis . enabledProfiles = new HashSet < > ( ) ; \n} \nthis . enabledProfiles . add ( profile ) ; \nreturn ; \n} \n} \n"}
{"1775": "public class Vtor { \npublic void useProfiles ( final String ... enabledProfiles ) { \nif ( enabledProfiles == null ) { \nreturn ; \n} \nif ( this . enabledProfiles == null ) { \nthis . enabledProfiles = new HashSet < > ( ) ; \n} \nCollections . addAll ( this . enabledProfiles , enabledProfiles ) ; \nreturn ; \n} \n} \n"}
{"1781": "public class JulianDate { \nprivate void set ( final int i , double f ) { \ninteger = i ; \nint fi = ( int ) f ; \nf -= fi ; \ninteger += fi ; \nif ( f < 0 ) { \nf += 1 ; \ninteger -- ; \n} \nthis . fraction = f ; \nreturn ; \n} \n} \n"}
{"1782": "public class LagartoParser { \n@ Override protected void initialize ( final char [ ] input ) { \nsuper . initialize ( input ) ; \nthis . tag = new ParsedTag ( ) ; \nthis . doctype = new ParsedDoctype ( ) ; \nthis . text = new char [ 1024 ] ; \nthis . textLen = 0 ; \nthis . parsingTime = - 1 ; \nreturn ; \n} \n} \n"}
{"1783": "public class LagartoParser { \nprotected void emitComment ( final int from , final int to ) { \nif ( config . enableConditionalComments ) { \nif ( match ( CC_IF , from ) ) { \nint endBracketNdx = find ( ']' , from + 3 , to ) ; \nCharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; \nndx = endBracketNdx + 1 ; \nchar c = input [ ndx ] ; \nif ( c != '>' ) { \nerrorInvalidToken ( ) ; \n} \nvisitor . condComment ( expression , true , true , false ) ; \nstate = DATA_STATE ; \nreturn ; \n} \nif ( to > CC_ENDIF2 . length && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { \nvisitor . condComment ( _ENDIF , false , true , true ) ; \nstate = DATA_STATE ; \nreturn ; \n} \n} \nCharSequence comment = charSequence ( from , to ) ; \nvisitor . comment ( comment ) ; \ncommentStart = - 1 ; \nreturn ; \n} \n} \n"}
{"1784": "public class LagartoParser { \nprotected void _error ( String message ) { \nif ( config . calculatePosition ) { \nPosition currentPosition = position ( ndx ) ; \nmessage = message . concat ( StringPool . SPACE ) . concat ( currentPosition . toString ( ) ) ; \n} \nelse { \nmessage = message . concat ( \" [@\" ) . concat ( Integer . toString ( ndx ) ) . concat ( StringPool . RIGHT_SQ_BRACKET ) ; \n} \nvisitor . error ( message ) ; \nreturn ; \n} \n} \n"}
{"1794": "public class ModuleWriter { \nvoid putAttributes ( final ByteVector output ) { \nint moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; \nif ( packageCount > 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; \n} \nif ( mainClassIndex > 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; \n} \nreturn ; \n} \n} \n"}
{"1797": "public class JoyDb { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public void start ( ) { \ninitLogger ( ) ; \nif ( ! databaseEnabled ) { \nlog . info ( \"DB not enabled.\" ) ; \nreturn ; \n} \nlog . info ( \"DB start ----------\" ) ; \nfinal PetiteContainer petiteContainer = joyPetiteSupplier . get ( ) . getPetiteContainer ( ) ; \nconnectionProvider = createConnectionProviderIfNotSupplied ( ) ; \npetiteContainer . addBean ( beanNamePrefix ( ) + \"pool\" , connectionProvider ) ; \nif ( connectionProvider instanceof CoreConnectionPool ) { \nfinal CoreConnectionPool pool = ( CoreConnectionPool ) connectionProvider ; \nif ( pool . getDriver ( ) == null ) { \ndatabaseEnabled = false ; \nlog . warn ( \"DB configuration not set (\" + beanNamePrefix ( ) + \"pool.*). DB will be disabled.\" ) ; \nreturn ; \n} \n} \nconnectionProvider . init ( ) ; \ncheckConnectionProvider ( ) ; \njtxManager = createJtxTransactionManager ( connectionProvider ) ; \njtxManager . setValidateExistingTransaction ( true ) ; \nfinal AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager ( new LeanJtxWorker ( jtxManager ) , jtxScopePattern ) ; \nAnnotationTxAdviceSupport . manager = annTxAdviceManager ; \njoyProxettaSupplier . get ( ) . getProxetta ( ) . withAspect ( createTxProxyAspects ( annTxAdviceManager . getAnnotations ( ) ) ) ; \nfinal DbSessionProvider sessionProvider = new DbJtxSessionProvider ( jtxManager ) ; \nfinal long startTime = System . currentTimeMillis ( ) ; \nfinal QueryMap queryMap = new DbPropsQueryMap ( ) ; \nlog . debug ( \"Queries loaded in \" + ( System . currentTimeMillis ( ) - startTime ) + \"ms.\" ) ; \nlog . debug ( \"Total queries: \" + queryMap . size ( ) ) ; \ndbOom = DbOom . create ( ) . withConnectionProvider ( connectionProvider ) . withSessionProvider ( sessionProvider ) . withQueryMap ( queryMap ) . get ( ) ; \ndbOom . connect ( ) ; \nfinal DbEntityManager dbEntityManager = dbOom . entityManager ( ) ; \ndbEntityManager . reset ( ) ; \npetiteContainer . addBean ( beanNamePrefix ( ) + \"query\" , dbOom . queryConfig ( ) ) ; \npetiteContainer . addBean ( beanNamePrefix ( ) + \"oom\" , dbOom . config ( ) ) ; \nif ( autoConfiguration ) { \nfinal AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator ( dbEntityManager , true ) ; \nautomagicDbOomConfigurator . registerAsConsumer ( joyScannerSupplier . get ( ) . getClassScanner ( ) ) ; \n} \ndbEntityManagerConsumers . accept ( dbEntityManager ) ; \nlog . info ( \"DB OK!\" ) ; \nreturn ; \n} \n} \n"}
{"1798": "public class JoyDb { \nprotected void checkConnectionProvider ( ) { \nfinal Connection connection = connectionProvider . getConnection ( ) ; \ntry { \nfinal DatabaseMetaData databaseMetaData = connection . getMetaData ( ) ; \nString name = databaseMetaData . getDatabaseProductName ( ) ; \nString version = databaseMetaData . getDatabaseProductVersion ( ) ; \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"Connected to database: \" + name + \" v\" + version ) ; \n} \n} \ncatch ( SQLException sex ) { \nlog . error ( \"DB connection failed: \" , sex ) ; \n} \nfinally { \nconnectionProvider . closeConnection ( connection ) ; \n} \nreturn ; \n} \n} \n"}
{"1800": "public class TargetClassInfoReader { \n@ Override public void visitEnd ( ) { \nif ( classAnnotations != null ) { \nannotations = classAnnotations . toArray ( new AnnotationInfo [ 0 ] ) ; \nclassAnnotations = null ; \n} \nList < String > superList = new ArrayList < > ( ) ; \nSet < String > allInterfaces = new HashSet < > ( ) ; \nif ( nextInterfaces != null ) { \nallInterfaces . addAll ( nextInterfaces ) ; \n} \nwhile ( nextSupername != null ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( nextSupername , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super class: \" + nextSupername , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperList . add ( nextSupername ) ; \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) { \nCollections . addAll ( allInterfaces , cr . getInterfaces ( ) ) ; \n} \n} \nsuperClasses = superList . toArray ( new String [ 0 ] ) ; \nSet < String > todoInterfaces = new HashSet < > ( allInterfaces ) ; \nSet < String > newCollectedInterfaces = new HashSet < > ( ) ; \nwhile ( true ) { \nfor ( String next : todoInterfaces ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( next , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super interface: \" + next , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) { \nfor ( String newInterface : cr . getInterfaces ( ) ) { \nif ( ! allInterfaces . contains ( newInterface ) && ! todoInterfaces . contains ( newInterface ) ) { \nnewCollectedInterfaces . add ( newInterface ) ; \n} \n} \n} \n} \nallInterfaces . addAll ( todoInterfaces ) ; \nif ( newCollectedInterfaces . isEmpty ( ) ) { \nbreak ; \n} \ntodoInterfaces . clear ( ) ; \ntodoInterfaces . addAll ( newCollectedInterfaces ) ; \nnewCollectedInterfaces . clear ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nfor ( int n = 0 ; \nn < name . length ( ) ; \nn ++ ) { \nchar c = name . charAt ( n ) ; \nif ( c <= 0x20 || c >= 0x7f ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \n} \nthis . name = name ; \nreturn ; \n} \n} \n"}
{"1813": "public class ShutdownAwareScope { \nprotected void destroyBean ( final BeanData beanData ) { \nif ( destroyableBeans == null ) { \nreturn ; \n} \nif ( ! isBeanDestroyable ( beanData ) ) { \nreturn ; \n} \nif ( destroyableBeans . remove ( beanData ) ) { \nbeanData . callDestroyMethods ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1814": "public class ShutdownAwareScope { \n@ Override public void shutdown ( ) { \nif ( destroyableBeans == null ) { \nreturn ; \n} \nfor ( final BeanData destroyableBean : destroyableBeans ) { \ndestroyableBean . callDestroyMethods ( ) ; \n} \ndestroyableBeans . clear ( ) ; \nreturn ; \n} \n} \n"}
{"1816": "public class ClusteredServiceContainer { \npublic static void main ( final String [ ] args ) { \nloadPropertiesFiles ( args ) ; \ntry ( ClusteredServiceContainer container = launch ( ) ) { \ncontainer . context ( ) . shutdownSignalBarrier ( ) . await ( ) ; \nSystem . out . println ( \"Shutdown ClusteredServiceContainer...\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1817": "public class RateReporter { \npublic void run ( ) { \ndo { \nLockSupport . parkNanos ( parkNs ) ; \nfinal long currentTotalMessages = totalMessages ; \nfinal long currentTotalBytes = totalBytes ; \nfinal long currentTimestamp = System . nanoTime ( ) ; \nfinal long timeSpanNs = currentTimestamp - lastTimestamp ; \nfinal double messagesPerSec = ( ( currentTotalMessages - lastTotalMessages ) * ( double ) reportIntervalNs ) / ( double ) timeSpanNs ; \nfinal double bytesPerSec = ( ( currentTotalBytes - lastTotalBytes ) * ( double ) reportIntervalNs ) / ( double ) timeSpanNs ; \nreportingFunc . onReport ( messagesPerSec , bytesPerSec , currentTotalMessages , currentTotalBytes ) ; \nlastTotalBytes = currentTotalBytes ; \nlastTotalMessages = currentTotalMessages ; \nlastTimestamp = currentTimestamp ; \n} \nwhile ( ! halt ) ; \nreturn ; \n} \n} \n"}
{"1818": "public class SamplesUtil { \n@ SuppressWarnings ( \"unused\" ) public static void printError ( final String channel , final int streamId , final int sessionId , final String message , final HeaderFlyweight cause ) { \nSystem . out . println ( message ) ; \nreturn ; \n} \n} \n"}
{"1819": "public class SamplesUtil { \npublic static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { \nSystem . out . println ( String . format ( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\" , messagesPerSec , bytesPerSec , totalMessages , totalBytes / ( 1024 * 1024 ) ) ) ; \nreturn ; \n} \n} \n"}
{"1821": "public class ReplayMerge { \npublic void close ( ) { \nfinal State state = this . state ; \nif ( State . CLOSED != state ) { \nif ( isReplayActive ) { \nisReplayActive = false ; \narchive . stopReplay ( replaySessionId ) ; \n} \nif ( State . MERGED != state ) { \nsubscription . removeDestination ( replayDestination ) ; \n} \nstate ( State . CLOSED ) ; \n} \nreturn ; \n} \n} \n"}
{"1826": "public class AeronArchive { \npublic void close ( ) { \nlock . lock ( ) ; \ntry { \nif ( ! isClosed ) { \nisClosed = true ; \narchiveProxy . closeSession ( controlSessionId ) ; \nif ( ! context . ownsAeronClient ( ) ) { \nCloseHelper . close ( controlResponsePoller . subscription ( ) ) ; \nCloseHelper . close ( archiveProxy . publication ( ) ) ; \n} \ncontext . close ( ) ; \n} \n} \nfinally { \nlock . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1828": "public class AeronArchive { \npublic void stopReplay ( final long replaySessionId ) { \nlock . lock ( ) ; \ntry { \nensureOpen ( ) ; \nfinal long correlationId = aeron . nextCorrelationId ( ) ; \nif ( ! archiveProxy . stopReplay ( replaySessionId , correlationId , controlSessionId ) ) { \nthrow new ArchiveException ( \"failed to send stop replay request\" ) ; \n} \npollForResponse ( correlationId ) ; \n} \nfinally { \nlock . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1829": "public class MultipleSubscribersWithFragmentAssembly { \npublic static void eventAvailableImage ( final Image image ) { \nfinal Subscription subscription = image . subscription ( ) ; \nSystem . out . format ( \"new image on %s streamId %x sessionId %x from %s%n\" , subscription . channel ( ) , subscription . streamId ( ) , image . sessionId ( ) , image . sourceIdentity ( ) ) ; \nreturn ; \n} \n} \n"}
{"1830": "public class MultipleSubscribersWithFragmentAssembly { \npublic static void eventUnavailableImage ( final Image image ) { \nfinal Subscription subscription = image . subscription ( ) ; \nSystem . out . format ( \"inactive image on %s streamId %d sessionId %x%n\" , subscription . channel ( ) , subscription . streamId ( ) , image . sessionId ( ) ) ; \nreturn ; \n} \n} \n"}
{"1833": "public class BufferBuilder { \npublic void limit ( final int limit ) { \nif ( limit < 0 || limit >= buffer . capacity ( ) ) { \nthrow new IllegalArgumentException ( \"limit outside range: capacity=\" + buffer . capacity ( ) + \" limit=\" + limit ) ; \n} \nthis . limit = limit ; \nreturn ; \n} \n} \n"}
{"1858": "public class PublicationImage { \nvoid addDestination ( final int transportIndex , final ReceiveDestinationUdpTransport transport ) { \nimageConnections = ArrayUtil . ensureCapacity ( imageConnections , transportIndex + 1 ) ; \nif ( transport . isMulticast ( ) ) { \nimageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . udpChannel ( ) . remoteControl ( ) ) ; \n} \nelse if ( transport . hasExplicitControl ( ) ) { \nimageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . explicitControlAddress ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1879": "public class UdpChannelTransport { \npublic void openDatagramChannel ( final AtomicCounter statusIndicator ) { \ntry { \nsendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \nreceiveDatagramChannel = sendDatagramChannel ; \nif ( udpChannel . isMulticast ( ) ) { \nif ( null != connectAddress ) { \nreceiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \n} \nreceiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; \nreceiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; \nreceiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( ) ) ; \nif ( udpChannel . isHasMulticastTtl ( ) ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , udpChannel . multicastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \nelse if ( context . socketMulticastTtl ( ) != 0 ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , context . socketMulticastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \n} \nelse { \nsendDatagramChannel . bind ( bindAddress ) ; \n} \nif ( null != connectAddress ) { \nsendDatagramChannel . connect ( connectAddress ) ; \n} \nif ( 0 != context . socketSndbufLength ( ) ) { \nsendDatagramChannel . setOption ( SO_SNDBUF , context . socketSndbufLength ( ) ) ; \n} \nif ( 0 != context . socketRcvbufLength ( ) ) { \nreceiveDatagramChannel . setOption ( SO_RCVBUF , context . socketRcvbufLength ( ) ) ; \n} \nsendDatagramChannel . configureBlocking ( false ) ; \nreceiveDatagramChannel . configureBlocking ( false ) ; \n} \ncatch ( final IOException ex ) { \nif ( null != statusIndicator ) { \nstatusIndicator . setOrdered ( ChannelEndpointStatus . ERRORED ) ; \n} \nCloseHelper . quietClose ( sendDatagramChannel ) ; \nif ( receiveDatagramChannel != sendDatagramChannel ) { \nCloseHelper . quietClose ( receiveDatagramChannel ) ; \n} \nsendDatagramChannel = null ; \nreceiveDatagramChannel = null ; \nthrow new AeronException ( \"channel error - \" + ex . getMessage ( ) + \" (at \" + ex . getStackTrace ( ) [ 0 ] . toString ( ) + \"): \" + udpChannel . originalUriString ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"1880": "public class UdpChannelTransport { \npublic void close ( ) { \nif ( ! isClosed ) { \nisClosed = true ; \ntry { \nif ( null != selectionKey ) { \nselectionKey . cancel ( ) ; \n} \nif ( null != transportPoller ) { \ntransportPoller . cancelRead ( this ) ; \ntransportPoller . selectNowWithoutProcessing ( ) ; \n} \nif ( null != sendDatagramChannel ) { \nsendDatagramChannel . close ( ) ; \n} \nif ( receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel ) { \nreceiveDatagramChannel . close ( ) ; \n} \nif ( null != transportPoller ) { \ntransportPoller . selectNowWithoutProcessing ( ) ; \n} \n} \ncatch ( final IOException ex ) { \nerrorLog . record ( ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1883": "public class RetransmitHandler { \npublic void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { \nif ( ! isInvalid ( termOffset , termLength ) ) { \nif ( null == activeRetransmitsMap . get ( termId , termOffset ) && activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { \nfinal RetransmitAction action = assignRetransmitAction ( ) ; \naction . termId = termId ; \naction . termOffset = termOffset ; \naction . length = Math . min ( length , termLength - termOffset ) ; \nfinal long delay = delayGenerator . generateDelay ( ) ; \nif ( 0 == delay ) { \nretransmitSender . resend ( termId , termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse { \naction . delay ( delay , nanoClock . nanoTime ( ) ) ; \n} \nactiveRetransmitsMap . put ( termId , termOffset , action ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1884": "public class RetransmitHandler { \npublic void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { \nif ( activeRetransmitsMap . size ( ) > 0 ) { \nfor ( final RetransmitAction action : retransmitActionPool ) { \nif ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { \nretransmitSender . resend ( action . termId , action . termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse if ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { \naction . cancel ( ) ; \nactiveRetransmitsMap . remove ( action . termId , action . termOffset ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"1891": "public class Configuration { \npublic static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { \ntry ( DatagramChannel probe = DatagramChannel . open ( ) ) { \nfinal int defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nprobe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; \nfinal int maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nif ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) { \nSystem . err . format ( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; \n} \nprobe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; \nfinal int maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; \nif ( maxSoRcvBuf < ctx . socketRcvbufLength ( ) ) { \nSystem . err . format ( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; \n} \nfinal int soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; \nif ( ctx . mtuLength ( ) > soSndBuf ) { \nthrow new ConfigurationException ( String . format ( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; \n} \nif ( ctx . initialWindowLength ( ) > maxSoRcvBuf ) { \nthrow new ConfigurationException ( \"window length greater than socket SO_RCVBUF, increase '\" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx . initialWindowLength ( ) + \", SO_RCVBUF=\" + maxSoRcvBuf ) ; \n} \n} \ncatch ( final IOException ex ) { \nthrow new AeronException ( \"probe socket: \" + ex . toString ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"1892": "public class Configuration { \npublic static void validatePageSize ( final int pageSize ) { \nif ( pageSize < PAGE_MIN_SIZE ) { \nthrow new ConfigurationException ( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize ) ; \n} \nif ( pageSize > PAGE_MAX_SIZE ) { \nthrow new ConfigurationException ( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize ) ; \n} \nif ( ! BitUtil . isPowerOfTwo ( pageSize ) ) { \nthrow new ConfigurationException ( \"page size not a power of 2: \" + pageSize ) ; \n} \nreturn ; \n} \n} \n"}
{"1893": "public class Configuration { \npublic static void validateSessionIdRange ( final int low , final int high ) { \nif ( low > high ) { \nthrow new ConfigurationException ( \"low session id value \" + low + \" must be <= high value \" + high ) ; \n} \nif ( Math . abs ( ( long ) high - low ) > Integer . MAX_VALUE ) { \nthrow new ConfigurationException ( \"reserved range to too large\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1894": "public class Configuration { \npublic static void validateUnblockTimeout ( final long publicationUnblockTimeoutNs , final long clientLivenessTimeoutNs , final long timerIntervalNs ) { \nif ( publicationUnblockTimeoutNs <= clientLivenessTimeoutNs ) { \nthrow new ConfigurationException ( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs ) ; \n} \nif ( clientLivenessTimeoutNs <= timerIntervalNs ) { \nthrow new ConfigurationException ( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs ) ; \n} \nreturn ; \n} \n} \n"}
{"1896": "public class ClusterMember { \npublic void reset ( ) { \nisBallotSent = false ; \nisLeader = false ; \nhasRequestedJoin = false ; \nhasSentTerminationAck = false ; \nvote = null ; \ncandidateTermId = Aeron . NULL_VALUE ; \nleadershipTermId = Aeron . NULL_VALUE ; \nlogPosition = NULL_POSITION ; \nreturn ; \n} \n} \n"}
{"1898": "public class ClusterMember { \npublic static void addMemberStatusPublications ( final ClusterMember [ ] members , final ClusterMember exclude , final ChannelUri channelUri , final int streamId , final Aeron aeron ) { \nfor ( final ClusterMember member : members ) { \nif ( member != exclude ) { \nchannelUri . put ( ENDPOINT_PARAM_NAME , member . memberFacingEndpoint ( ) ) ; \nmember . publication = aeron . addExclusivePublication ( channelUri . toString ( ) , streamId ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1899": "public class ClusterMember { \npublic static void closeMemberPublications ( final ClusterMember [ ] clusterMembers ) { \nfor ( final ClusterMember member : clusterMembers ) { \nCloseHelper . close ( member . publication ) ; \n} \nreturn ; \n} \n} \n"}
{"1902": "public class ClusterMember { \npublic static void resetLogPositions ( final ClusterMember [ ] clusterMembers , final long logPosition ) { \nfor ( final ClusterMember member : clusterMembers ) { \nmember . logPosition ( logPosition ) ; \n} \nreturn ; \n} \n} \n"}
{"1907": "public class ClusterMember { \npublic static void validateMemberEndpoints ( final ClusterMember member , final String memberEndpoints ) { \nfinal ClusterMember endpointMember = ClusterMember . parseEndpoints ( Aeron . NULL_VALUE , memberEndpoints ) ; \nif ( ! areSameEndpoints ( member , endpointMember ) ) { \nthrow new ClusterException ( \"clusterMembers and memberEndpoints differ: \" + member . endpointsDetail ( ) + \" != \" + memberEndpoints ) ; \n} \nreturn ; \n} \n} \n"}
{"1921": "public class FrameDescriptor { \npublic static void frameLengthOrdered ( final UnsafeBuffer buffer , final int termOffset , final int frameLength ) { \nint length = frameLength ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nlength = Integer . reverseBytes ( frameLength ) ; \n} \nbuffer . putIntOrdered ( termOffset , length ) ; \nreturn ; \n} \n} \n"}
{"1922": "public class FrameDescriptor { \npublic static void frameType ( final UnsafeBuffer buffer , final int termOffset , final int type ) { \nbuffer . putShort ( typeOffset ( termOffset ) , ( short ) type , LITTLE_ENDIAN ) ; \nreturn ; \n} \n} \n"}
{"1923": "public class FrameDescriptor { \npublic static void frameFlags ( final UnsafeBuffer buffer , final int termOffset , final byte flags ) { \nbuffer . putByte ( flagsOffset ( termOffset ) , flags ) ; \nreturn ; \n} \n} \n"}
{"1924": "public class FrameDescriptor { \npublic static void frameTermOffset ( final UnsafeBuffer buffer , final int termOffset ) { \nbuffer . putInt ( termOffsetOffset ( termOffset ) , termOffset , LITTLE_ENDIAN ) ; \nreturn ; \n} \n} \n"}
{"1925": "public class FrameDescriptor { \npublic static void frameTermId ( final UnsafeBuffer buffer , final int termOffset , final int termId ) { \nbuffer . putInt ( termIdOffset ( termOffset ) , termId , LITTLE_ENDIAN ) ; \nreturn ; \n} \n} \n"}
{"1931": "public class RecordingLog { \npublic void reload ( ) { \nentries . clear ( ) ; \nindexByLeadershipTermIdMap . clear ( ) ; \nindexByLeadershipTermIdMap . compact ( ) ; \nnextEntryIndex = 0 ; \nbyteBuffer . clear ( ) ; \ntry { \nwhile ( true ) { \nfinal int bytes = fileChannel . read ( byteBuffer ) ; \nif ( byteBuffer . remaining ( ) == 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nif ( - 1 == bytes ) { \nif ( byteBuffer . position ( ) > 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nbreak ; \n} \n} \n} \ncatch ( final IOException ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"1935": "public class RecordingLog { \npublic void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { \nfinal int size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry lastEntry = entries . get ( size - 1 ) ; \nif ( lastEntry . type != NULL_VALUE && lastEntry . leadershipTermId >= leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + lastEntry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \nindexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; \nappend ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; \nreturn ; \n} \n} \n"}
{"1936": "public class RecordingLog { \npublic void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { \nfinal int size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry entry = entries . get ( size - 1 ) ; \nif ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + entry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \nappend ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; \nreturn ; \n} \n} \n"}
{"1937": "public class RecordingLog { \npublic void commitLogPosition ( final long leadershipTermId , final long logPosition ) { \nfinal int index = getLeadershipTermEntryIndex ( leadershipTermId ) ; \ncommitEntryValue ( index , logPosition , LOG_POSITION_OFFSET ) ; \nfinal Entry entry = entries . get ( index ) ; \nentries . set ( index , new Entry ( entry . recordingId , entry . leadershipTermId , entry . termBaseLogPosition , logPosition , entry . timestamp , entry . serviceId , entry . type , entry . entryIndex ) ) ; \nreturn ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nint index = - 1 ; \nfor ( int i = 0 , size = entries . size ( ) ; \ni < size ; \ni ++ ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nindexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \n} \nbreak ; \n} \n} \nif ( - 1 == index ) { \nthrow new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \n} \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { \nthrow new ClusterException ( \"failed to write field atomically\" ) ; \n} \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"1939": "public class AeronCluster { \npublic void close ( ) { \nif ( null != publication && publication . isConnected ( ) ) { \ncloseSession ( ) ; \n} \nif ( ! ctx . ownsAeronClient ( ) ) { \nCloseHelper . close ( subscription ) ; \nCloseHelper . close ( publication ) ; \n} \nctx . close ( ) ; \nreturn ; \n} \n} \n"}
{"1944": "public class LogBufferDescriptor { \npublic static void checkTermLength ( final int termLength ) { \nif ( termLength < TERM_MIN_LENGTH ) { \nthrow new IllegalStateException ( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength ) ; \n} \nif ( termLength > TERM_MAX_LENGTH ) { \nthrow new IllegalStateException ( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength ) ; \n} \nif ( ! BitUtil . isPowerOfTwo ( termLength ) ) { \nthrow new IllegalStateException ( \"Term length not a power of 2: length=\" + termLength ) ; \n} \nreturn ; \n} \n} \n"}
{"1945": "public class LogBufferDescriptor { \npublic static void checkPageSize ( final int pageSize ) { \nif ( pageSize < PAGE_MIN_SIZE ) { \nthrow new IllegalStateException ( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize ) ; \n} \nif ( pageSize > PAGE_MAX_SIZE ) { \nthrow new IllegalStateException ( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize ) ; \n} \nif ( ! BitUtil . isPowerOfTwo ( pageSize ) ) { \nthrow new IllegalStateException ( \"Page size not a power of 2: page size=\" + pageSize ) ; \n} \nreturn ; \n} \n} \n"}
{"1949": "public class LogBufferDescriptor { \npublic static void storeDefaultFrameHeader ( final UnsafeBuffer metadataBuffer , final DirectBuffer defaultHeader ) { \nif ( defaultHeader . capacity ( ) != HEADER_LENGTH ) { \nthrow new IllegalArgumentException ( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader . capacity ( ) ) ; \n} \nmetadataBuffer . putInt ( LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET , HEADER_LENGTH ) ; \nmetadataBuffer . putBytes ( LOG_DEFAULT_FRAME_HEADER_OFFSET , defaultHeader , 0 , HEADER_LENGTH ) ; \nreturn ; \n} \n} \n"}
{"1950": "public class LogBufferDescriptor { \npublic static void applyDefaultHeader ( final UnsafeBuffer metadataBuffer , final UnsafeBuffer termBuffer , final int termOffset ) { \ntermBuffer . putBytes ( termOffset , metadataBuffer , LOG_DEFAULT_FRAME_HEADER_OFFSET , HEADER_LENGTH ) ; \nreturn ; \n} \n} \n"}
{"1952": "public class LogBufferDescriptor { \npublic static void initialiseTailWithTermId ( final UnsafeBuffer metadataBuffer , final int partitionIndex , final int termId ) { \nmetadataBuffer . putLong ( TERM_TAIL_COUNTERS_OFFSET + ( partitionIndex * SIZE_OF_LONG ) , packTail ( termId , 0 ) ) ; \nreturn ; \n} \n} \n"}
{"1964": "public class BufferClaim { \npublic final void wrap ( final AtomicBuffer buffer , final int offset , final int length ) { \nthis . buffer . wrap ( buffer , offset , length ) ; \nreturn ; \n} \n} \n"}
{"1965": "public class BufferClaim { \npublic final void commit ( ) { \nint frameLength = buffer . capacity ( ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nframeLength = Integer . reverseBytes ( frameLength ) ; \n} \nbuffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; \nreturn ; \n} \n} \n"}
{"1966": "public class BufferClaim { \npublic final void abort ( ) { \nint frameLength = buffer . capacity ( ) ; \nif ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { \nframeLength = Integer . reverseBytes ( frameLength ) ; \n} \nbuffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_PAD , LITTLE_ENDIAN ) ; \nbuffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; \nreturn ; \n} \n} \n"}
{"1967": "public class MediaDriver { \npublic static void main ( final String [ ] args ) { \nloadPropertiesFiles ( args ) ; \nfinal ShutdownSignalBarrier barrier = new ShutdownSignalBarrier ( ) ; \nfinal MediaDriver . Context ctx = new MediaDriver . Context ( ) ; \nctx . terminationHook ( barrier :: signal ) ; \ntry ( MediaDriver ignore = MediaDriver . launch ( ctx ) ) { \nbarrier . await ( ) ; \nSystem . out . println ( \"Shutdown Driver...\" ) ; \n} \nreturn ; \n} \n} \n"}
{"1968": "public class MediaDriver { \npublic void close ( ) { \nCloseHelper . close ( sharedRunner ) ; \nCloseHelper . close ( sharedNetworkRunner ) ; \nCloseHelper . close ( receiverRunner ) ; \nCloseHelper . close ( senderRunner ) ; \nCloseHelper . close ( conductorRunner ) ; \nCloseHelper . close ( sharedInvoker ) ; \nif ( ctx . useWindowsHighResTimer ( ) && SystemUtil . osName ( ) . startsWith ( \"win\" ) ) { \nif ( ! wasHighResTimerEnabled ) { \nHighResolutionTimer . disable ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"1974": "public class Context { \npublic void close ( ) { \nfinal MappedByteBuffer cncByteBuffer = this . cncByteBuffer ; \nthis . cncByteBuffer = null ; \nIoUtil . unmap ( cncByteBuffer ) ; \nsuper . close ( ) ; \nreturn ; \n} \n} \n"}
{"1975": "public class ControlResponseAdapter { \npublic static void dispatchDescriptor ( final RecordingDescriptorDecoder decoder , final RecordingDescriptorConsumer consumer ) { \nconsumer . onRecordingDescriptor ( decoder . controlSessionId ( ) , decoder . correlationId ( ) , decoder . recordingId ( ) , decoder . startTimestamp ( ) , decoder . stopTimestamp ( ) , decoder . startPosition ( ) , decoder . stopPosition ( ) , decoder . initialTermId ( ) , decoder . segmentFileLength ( ) , decoder . termBufferLength ( ) , decoder . mtuLength ( ) , decoder . sessionId ( ) , decoder . streamId ( ) , decoder . strippedChannel ( ) , decoder . originalChannel ( ) , decoder . sourceIdentity ( ) ) ; \nreturn ; \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nint nextSlabSize ; \nif ( bytesUsed == 0 ) { \nnextSlabSize = initialSlabSize ; \n} \nelse if ( bytesUsed > maxCapacityHint / 5 ) { \nnextSlabSize = maxCapacityHint / 5 ; \n} \nelse { \nnextSlabSize = bytesUsed ; \n} \nif ( nextSlabSize < minimumSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated += nextSlabSize ; \nthis . currentSlabIndex = 0 ; \nreturn ; \n} \n} \n"}
{"1977": "public class CapacityByteArrayOutputStream { \npublic void setByte ( long index , byte value ) { \ncheckArgument ( index < bytesUsed , \"Index: \" + index + \" is >= the current size of: \" + bytesUsed ) ; \nlong seen = 0 ; \nfor ( int i = 0 ; \ni < slabs . size ( ) ; \ni ++ ) { \nByteBuffer slab = slabs . get ( i ) ; \nif ( index < seen + slab . limit ( ) ) { \nslab . put ( ( int ) ( index - seen ) , value ) ; \nbreak ; \n} \nseen += slab . limit ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1978": "public class ColumnIndexBuilder { \npublic void add ( Statistics < ? > stats ) { \nif ( stats . hasNonNullValue ( ) ) { \nnullPages . add ( false ) ; \nObject min = stats . genericGetMin ( ) ; \nObject max = stats . genericGetMax ( ) ; \naddMinMax ( min , max ) ; \npageIndexes . add ( nextPageIndex ) ; \nminMaxSize += sizeOf ( min ) ; \nminMaxSize += sizeOf ( max ) ; \n} \nelse { \nnullPages . add ( true ) ; \n} \nnullCounts . add ( stats . getNumNulls ( ) ) ; \n++ nextPageIndex ; \nreturn ; \n} \n} \n"}
{"1983": "public class RunLengthBitPackingHybridEncoder { \nprivate void endPreviousBitPackedRun ( ) { \nif ( bitPackedRunHeaderPointer == - 1 ) { \nreturn ; \n} \nbyte bitPackHeader = ( byte ) ( ( bitPackedGroupCount << 1 ) | 1 ) ; \nbaos . setByte ( bitPackedRunHeaderPointer , bitPackHeader ) ; \nbitPackedRunHeaderPointer = - 1 ; \nbitPackedGroupCount = 0 ; \nreturn ; \n} \n} \n"}
{"1984": "public class ProtocolReadToWrite { \n@ Override public void readOne ( TProtocol in , TProtocol out ) throws TException { \nreadOneStruct ( in , out ) ; \nreturn ; \n} \n} \n"}
{"1991": "public class MemoryManager { \nsynchronized void addWriter ( InternalParquetRecordWriter writer , Long allocation ) { \nLong oldValue = writerList . get ( writer ) ; \nif ( oldValue == null ) { \nwriterList . put ( writer , allocation ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer ) ; \n} \nupdateAllocation ( ) ; \nreturn ; \n} \n} \n"}
{"1992": "public class MemoryManager { \nsynchronized void removeWriter ( InternalParquetRecordWriter writer ) { \nif ( writerList . containsKey ( writer ) ) { \nwriterList . remove ( writer ) ; \n} \nif ( ! writerList . isEmpty ( ) ) { \nupdateAllocation ( ) ; \n} \nreturn ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations += allocation ; \n} \nif ( totalAllocations <= totalMemoryPool ) { \nscale = 1.0 ; \n} \nelse { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nint maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) { \nthrow new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \n} \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"1994": "public class MemoryManager { \npublic void registerScaleCallBack ( String callBackName , Runnable callBack ) { \nPreconditions . checkNotNull ( callBackName , \"callBackName\" ) ; \nPreconditions . checkNotNull ( callBack , \"callBack\" ) ; \nif ( callBacks . containsKey ( callBackName ) ) { \nthrow new IllegalArgumentException ( \"The callBackName \" + callBackName + \" is duplicated and has been registered already.\" ) ; \n} \nelse { \ncallBacks . put ( callBackName , callBack ) ; \n} \nreturn ; \n} \n} \n"}
{"1995": "public class ParquetFileWriter { \npublic void start ( ) throws IOException { \nstate = state . start ( ) ; \nLOG . debug ( \"{}: start\" , out . getPos ( ) ) ; \nout . write ( MAGIC ) ; \nreturn ; \n} \n} \n"}
{"1996": "public class ParquetFileWriter { \npublic void startBlock ( long recordCount ) throws IOException { \nstate = state . startBlock ( ) ; \nLOG . debug ( \"{}: start block\" , out . getPos ( ) ) ; \nalignment . alignForRowGroup ( out ) ; \ncurrentBlock = new BlockMetaData ( ) ; \ncurrentRecordCount = recordCount ; \ncurrentColumnIndexes = new ArrayList < > ( ) ; \ncurrentOffsetIndexes = new ArrayList < > ( ) ; \nreturn ; \n} \n} \n"}
{"1997": "public class ParquetFileWriter { \npublic void startColumn ( ColumnDescriptor descriptor , long valueCount , CompressionCodecName compressionCodecName ) throws IOException { \nstate = state . startColumn ( ) ; \nencodingStatsBuilder . clear ( ) ; \ncurrentEncodings = new HashSet < Encoding > ( ) ; \ncurrentChunkPath = ColumnPath . get ( descriptor . getPath ( ) ) ; \ncurrentChunkType = descriptor . getPrimitiveType ( ) ; \ncurrentChunkCodec = compressionCodecName ; \ncurrentChunkValueCount = valueCount ; \ncurrentChunkFirstDataPage = out . getPos ( ) ; \ncompressedLength = 0 ; \nuncompressedLength = 0 ; \ncurrentStatistics = null ; \ncolumnIndexBuilder = ColumnIndexBuilder . getBuilder ( currentChunkType , columnIndexTruncateLength ) ; \noffsetIndexBuilder = OffsetIndexBuilder . getBuilder ( ) ; \nfirstPageOffset = - 1 ; \nreturn ; \n} \n} \n"}
{"1998": "public class ParquetFileWriter { \npublic void writeDictionaryPage ( DictionaryPage dictionaryPage ) throws IOException { \nstate = state . write ( ) ; \nLOG . debug ( \"{}: write dictionary page: {} values\" , out . getPos ( ) , dictionaryPage . getDictionarySize ( ) ) ; \ncurrentChunkDictionaryPageOffset = out . getPos ( ) ; \nint uncompressedSize = dictionaryPage . getUncompressedSize ( ) ; \nint compressedPageSize = ( int ) dictionaryPage . getBytes ( ) . size ( ) ; \nmetadataConverter . writeDictionaryPageHeader ( uncompressedSize , compressedPageSize , dictionaryPage . getDictionarySize ( ) , dictionaryPage . getEncoding ( ) , out ) ; \nlong headerSize = out . getPos ( ) - currentChunkDictionaryPageOffset ; \nthis . uncompressedLength += uncompressedSize + headerSize ; \nthis . compressedLength += compressedPageSize + headerSize ; \nLOG . debug ( \"{}: write dictionary page content {}\" , out . getPos ( ) , compressedPageSize ) ; \ndictionaryPage . getBytes ( ) . writeAllTo ( out ) ; \nencodingStatsBuilder . addDictEncoding ( dictionaryPage . getEncoding ( ) ) ; \ncurrentEncodings . add ( dictionaryPage . getEncoding ( ) ) ; \nreturn ; \n} \n} \n"}
{"1999": "public class ParquetFileWriter { \npublic void writeDataPage ( int valueCount , int uncompressedPageSize , BytesInput bytes , Statistics statistics , long rowCount , Encoding rlEncoding , Encoding dlEncoding , Encoding valuesEncoding ) throws IOException { \nlong beforeHeader = out . getPos ( ) ; \ninnerWriteDataPage ( valueCount , uncompressedPageSize , bytes , statistics , rlEncoding , dlEncoding , valuesEncoding ) ; \noffsetIndexBuilder . add ( ( int ) ( out . getPos ( ) - beforeHeader ) , rowCount ) ; \nreturn ; \n} \n} \n"}
{"2000": "public class ParquetFileWriter { \nvoid writeColumnChunk ( ColumnDescriptor descriptor , long valueCount , CompressionCodecName compressionCodecName , DictionaryPage dictionaryPage , BytesInput bytes , long uncompressedTotalPageSize , long compressedTotalPageSize , Statistics < ? > totalStats , ColumnIndexBuilder columnIndexBuilder , OffsetIndexBuilder offsetIndexBuilder , Set < Encoding > rlEncodings , Set < Encoding > dlEncodings , List < Encoding > dataEncodings ) throws IOException { \nstartColumn ( descriptor , valueCount , compressionCodecName ) ; \nstate = state . write ( ) ; \nif ( dictionaryPage != null ) { \nwriteDictionaryPage ( dictionaryPage ) ; \n} \nLOG . debug ( \"{}: write data pages\" , out . getPos ( ) ) ; \nlong headersSize = bytes . size ( ) - compressedTotalPageSize ; \nthis . uncompressedLength += uncompressedTotalPageSize + headersSize ; \nthis . compressedLength += compressedTotalPageSize + headersSize ; \nLOG . debug ( \"{}: write data pages content\" , out . getPos ( ) ) ; \nfirstPageOffset = out . getPos ( ) ; \nbytes . writeAllTo ( out ) ; \nencodingStatsBuilder . addDataEncodings ( dataEncodings ) ; \nif ( rlEncodings . isEmpty ( ) ) { \nencodingStatsBuilder . withV2Pages ( ) ; \n} \ncurrentEncodings . addAll ( rlEncodings ) ; \ncurrentEncodings . addAll ( dlEncodings ) ; \ncurrentEncodings . addAll ( dataEncodings ) ; \ncurrentStatistics = totalStats ; \nthis . columnIndexBuilder = columnIndexBuilder ; \nthis . offsetIndexBuilder = offsetIndexBuilder ; \nendColumn ( ) ; \nreturn ; \n} \n} \n"}
{"2001": "public class ParquetFileWriter { \npublic void endBlock ( ) throws IOException { \nstate = state . endBlock ( ) ; \nLOG . debug ( \"{}: end block\" , out . getPos ( ) ) ; \ncurrentBlock . setRowCount ( currentRecordCount ) ; \nblocks . add ( currentBlock ) ; \ncolumnIndexes . add ( currentColumnIndexes ) ; \noffsetIndexes . add ( currentOffsetIndexes ) ; \ncurrentColumnIndexes = null ; \ncurrentOffsetIndexes = null ; \ncurrentBlock = null ; \nreturn ; \n} \n} \n"}
{"2002": "public class ParquetFileWriter { \nprivate static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { \nLOG . debug ( \"Copying {} bytes at {} to {}\" , length , start , to . getPos ( ) ) ; \nfrom . seek ( start ) ; \nlong bytesCopied = 0 ; \nbyte [ ] buffer = COPY_BUFFER . get ( ) ; \nwhile ( bytesCopied < length ) { \nlong bytesLeft = length - bytesCopied ; \nint bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; \nif ( bytesRead < 0 ) { \nthrow new IllegalArgumentException ( \"Unexpected end of input file at \" + start + bytesCopied ) ; \n} \nto . write ( buffer , 0 , bytesRead ) ; \nbytesCopied += bytesRead ; \n} \nreturn ; \n} \n} \n"}
{"2003": "public class ParquetFileWriter { \npublic void end ( Map < String , String > extraMetaData ) throws IOException { \nstate = state . end ( ) ; \nserializeColumnIndexes ( columnIndexes , blocks , out ) ; \nserializeOffsetIndexes ( offsetIndexes , blocks , out ) ; \nLOG . debug ( \"{}: end\" , out . getPos ( ) ) ; \nthis . footer = new ParquetMetadata ( new FileMetaData ( schema , extraMetaData , Version . FULL_VERSION ) , blocks ) ; \nserializeFooter ( footer , out ) ; \nout . close ( ) ; \nreturn ; \n} \n} \n"}
{"2005": "public class ParquetFileWriter { \n@ Deprecated public static void writeMergedMetadataFile ( List < Path > files , Path outputPath , Configuration conf ) throws IOException { \nParquetMetadata merged = mergeMetadataFiles ( files , conf ) ; \nwriteMetadataFile ( outputPath , merged , outputPath . getFileSystem ( conf ) ) ; \nreturn ; \n} \n} \n"}
{"2006": "public class ParquetFileWriter { \n@ Deprecated public static void writeMetadataFile ( Configuration configuration , Path outputPath , List < Footer > footers ) throws IOException { \nwriteMetadataFile ( configuration , outputPath , footers , JobSummaryLevel . ALL ) ; \nreturn ; \n} \n} \n"}
{"2008": "public class ColumnReaderBase { \npublic void readValue ( ) { \ntry { \nif ( ! valueRead ) { \nbinding . read ( ) ; \nvalueRead = true ; \n} \n} \ncatch ( RuntimeException e ) { \nif ( CorruptDeltaByteArrays . requiresSequentialReads ( writerVersion , currentEncoding ) && e instanceof ArrayIndexOutOfBoundsException ) { \nthrow new ParquetDecodingException ( \"Read failure possibly due to \" + \"PARQUET-246: try setting parquet.split.files to false\" , new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ) ; \n} \nthrow new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2015": "public class ColumnWriterBase { \n@ Override public void writeNull ( int repetitionLevel , int definitionLevel ) { \nif ( DEBUG ) log ( null , repetitionLevel , definitionLevel ) ; \nrepetitionLevel ( repetitionLevel ) ; \ndefinitionLevel ( definitionLevel ) ; \nstatistics . incrementNumNulls ( ) ; \n++ valueCount ; \nreturn ; \n} \n} \n"}
{"2016": "public class ColumnWriterBase { \nvoid writePage ( ) { \nif ( valueCount == 0 ) { \nthrow new ParquetEncodingException ( \"writing empty page\" ) ; \n} \nthis . rowsWrittenSoFar += pageRowCount ; \nif ( DEBUG ) LOG . debug ( \"write page\" ) ; \ntry { \nwritePage ( pageRowCount , valueCount , statistics , repetitionLevelColumn , definitionLevelColumn , dataColumn ) ; \n} \ncatch ( IOException e ) { \nthrow new ParquetEncodingException ( \"could not write page for \" + path , e ) ; \n} \nrepetitionLevelColumn . reset ( ) ; \ndefinitionLevelColumn . reset ( ) ; \ndataColumn . reset ( ) ; \nvalueCount = 0 ; \nresetStatistics ( ) ; \npageRowCount = 0 ; \nreturn ; \n} \n} \n"}
{"2017": "public class DeltaBinaryPackingValuesReader { \n@ Override public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { \nthis . in = stream ; \nlong startPos = in . position ( ) ; \nthis . config = DeltaBinaryPackingConfig . readConfig ( in ) ; \nthis . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; \nallocateValuesBuffer ( ) ; \nbitWidths = new int [ config . miniBlockNumInABlock ] ; \nvaluesBuffer [ valuesBuffered ++ ] = BytesUtils . readZigZagVarLong ( in ) ; \nwhile ( valuesBuffered < totalValueCount ) { \nloadNewBlockToBuffer ( ) ; \n} \nupdateNextOffset ( ( int ) ( in . position ( ) - startPos ) ) ; \nreturn ; \n} \n} \n"}
{"2018": "public class DeltaBinaryPackingValuesReader { \nprivate void allocateValuesBuffer ( ) { \nint totalMiniBlockCount = ( int ) Math . ceil ( ( double ) totalValueCount / config . miniBlockSizeInValues ) ; \nvaluesBuffer = new long [ totalMiniBlockCount * config . miniBlockSizeInValues + 1 ] ; \nreturn ; \n} \n} \n"}
{"2019": "public class BufferedProtocolReadToWrite { \nprivate void checkEnum ( ThriftType expectedType , int i ) { \nif ( expectedType . getType ( ) == ThriftTypeID . ENUM ) { \nThriftType . EnumType expectedEnumType = ( ThriftType . EnumType ) expectedType ; \nif ( expectedEnumType . getEnumValueById ( i ) == null ) { \nthrow new DecodingSchemaMismatchException ( \"can not find index \" + i + \" in enum \" + expectedType ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2020": "public class DeltaBinaryPackingValuesWriterForInteger { \nprivate void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { \nfor ( int miniBlockIndex = 0 ; \nminiBlockIndex < miniBlocksToFlush ; \nminiBlockIndex ++ ) { \nint mask = 0 ; \nint miniStart = miniBlockIndex * config . miniBlockSizeInValues ; \nint miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; \nfor ( int i = miniStart ; \ni < miniEnd ; \ni ++ ) { \nmask |= deltaBlockBuffer [ i ] ; \n} \nbitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; \n} \nreturn ; \n} \n} \n"}
{"2021": "public class Exceptions { \npublic static < E extends Exception > void throwIfInstance ( Throwable t , Class < E > excClass ) throws E { \nif ( excClass . isAssignableFrom ( t . getClass ( ) ) ) { \nthrow excClass . cast ( t ) ; \n} \nreturn ; \n} \n} \n"}
{"2024": "public class Statistics { \npublic void mergeStatistics ( Statistics stats ) { \nif ( stats . isEmpty ( ) ) return ; \nif ( type . equals ( stats . type ) ) { \nincrementNumNulls ( stats . getNumNulls ( ) ) ; \nif ( stats . hasNonNullValue ( ) ) { \nmergeStatisticsMinMax ( stats ) ; \nmarkAsNotEmpty ( ) ; \n} \n} \nelse { \nthrow StatisticsClassException . create ( this , stats ) ; \n} \nreturn ; \n} \n} \n"}
{"2028": "public class GroupType { \nvoid membersDisplayString ( StringBuilder sb , String indent ) { \nfor ( Type field : fields ) { \nfield . writeToStringBuilder ( sb , indent ) ; \nif ( field . isPrimitive ( ) ) { \nsb . append ( \";\" ) ; \n} \nsb . append ( \"\\n\" ) ; \n} \nreturn ; \n} \n} \n"}
{"2030": "public class BenchmarkCounter { \npublic static void initCounterFromReporter ( Reporter reporter , Configuration configuration ) { \ncounterLoader = new MapRedCounterLoader ( reporter , configuration ) ; \nloadCounters ( ) ; \nreturn ; \n} \n} \n"}
{"2034": "public class ProtoWriteSupport { \n@ Override public void write ( T record ) { \nrecordConsumer . startMessage ( ) ; \ntry { \nmessageWriter . writeTopLevelMessage ( record ) ; \n} \ncatch ( RuntimeException e ) { \nMessage m = ( record instanceof Message . Builder ) ? ( ( Message . Builder ) record ) . build ( ) : ( Message ) record ; \nLOG . error ( \"Cannot write message \" + e . getMessage ( ) + \" : \" + m ) ; \nthrow e ; \n} \nrecordConsumer . endMessage ( ) ; \nreturn ; \n} \n} \n"}
{"2035": "public class ProtoWriteSupport { \nprivate void validatedMapping ( Descriptor descriptor , GroupType parquetSchema ) { \nList < FieldDescriptor > allFields = descriptor . getFields ( ) ; \nfor ( FieldDescriptor fieldDescriptor : allFields ) { \nString fieldName = fieldDescriptor . getName ( ) ; \nint fieldIndex = fieldDescriptor . getIndex ( ) ; \nint parquetIndex = parquetSchema . getFieldIndex ( fieldName ) ; \nif ( fieldIndex != parquetIndex ) { \nString message = \"FieldIndex mismatch name=\" + fieldName + \": \" + fieldIndex + \" != \" + parquetIndex ; \nthrow new IncompatibleSchemaModificationException ( message ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2039": "public class ProtocolEventsAmender { \nprivate void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { \nTSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; \nThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; \nint setSize = thriftSet . size ; \nfor ( int i = 0 ; \ni < setSize ; \ni ++ ) { \ncheckField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; \n} \nacceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; \nreturn ; \n} \n} \n"}
{"2041": "public class ThriftToParquetFileWriter { \n@ Override public void close ( ) throws IOException { \ntry { \nrecordWriter . close ( taskAttemptContext ) ; \n} \ncatch ( InterruptedException e ) { \nThread . interrupted ( ) ; \nthrow new IOException ( \"The thread was interrupted\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2042": "public class ExampleOutputFormat { \npublic static void setSchema ( Job job , MessageType schema ) { \nGroupWriteSupport . setSchema ( schema , ContextUtil . getConfiguration ( job ) ) ; \nreturn ; \n} \n} \n"}
{"2043": "public class ValidTypeMap { \nprivate static void add ( Class < ? > c , PrimitiveTypeName p ) { \nSet < PrimitiveTypeName > descriptors = classToParquetType . get ( c ) ; \nif ( descriptors == null ) { \ndescriptors = new HashSet < PrimitiveTypeName > ( ) ; \nclassToParquetType . put ( c , descriptors ) ; \n} \ndescriptors . add ( p ) ; \nSet < Class < ? > > classes = parquetTypeToClass . get ( p ) ; \nif ( classes == null ) { \nclasses = new HashSet < Class < ? > > ( ) ; \nparquetTypeToClass . put ( p , classes ) ; \n} \nclasses . add ( c ) ; \nreturn ; \n} \n} \n"}
{"2044": "public class ValidTypeMap { \npublic static < T extends Comparable < T > > void assertTypeValid ( Column < T > foundColumn , PrimitiveTypeName primitiveType ) { \nClass < T > foundColumnType = foundColumn . getColumnType ( ) ; \nColumnPath columnPath = foundColumn . getColumnPath ( ) ; \nSet < PrimitiveTypeName > validTypeDescriptors = classToParquetType . get ( foundColumnType ) ; \nif ( validTypeDescriptors == null ) { \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"Column \" ) . append ( columnPath . toDotString ( ) ) . append ( \" was declared as type: \" ) . append ( foundColumnType . getName ( ) ) . append ( \" which is not supported in FilterPredicates.\" ) ; \nSet < Class < ? > > supportedTypes = parquetTypeToClass . get ( primitiveType ) ; \nif ( supportedTypes != null ) { \nmessage . append ( \" Supported types for this column are: \" ) . append ( supportedTypes ) ; \n} \nelse { \nmessage . append ( \" There are no supported types for columns of \" + primitiveType ) ; \n} \nthrow new IllegalArgumentException ( message . toString ( ) ) ; \n} \nif ( ! validTypeDescriptors . contains ( primitiveType ) ) { \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"FilterPredicate column: \" ) . append ( columnPath . toDotString ( ) ) . append ( \"'s declared type (\" ) . append ( foundColumnType . getName ( ) ) . append ( \") does not match the schema found in file metadata. Column \" ) . append ( columnPath . toDotString ( ) ) . append ( \" is of type: \" ) . append ( primitiveType ) . append ( \"\\nValid types for this column are: \" ) . append ( parquetTypeToClass . get ( primitiveType ) ) ; \nthrow new IllegalArgumentException ( message . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2049": "public class ParquetMetadataConverter { \n@ Deprecated public void writeDataPageV2Header ( int uncompressedSize , int compressedSize , int valueCount , int nullCount , int rowCount , org . apache . parquet . column . statistics . Statistics statistics , org . apache . parquet . column . Encoding dataEncoding , int rlByteLength , int dlByteLength , OutputStream to ) throws IOException { \nwritePageHeader ( newDataPageV2Header ( uncompressedSize , compressedSize , valueCount , nullCount , rowCount , dataEncoding , rlByteLength , dlByteLength ) , to ) ; \nreturn ; \n} \n} \n"}
{"2050": "public class FilteredRecordReader { \nprivate void skipToMatch ( ) { \nwhile ( recordsRead < recordCount && ! recordFilter . isMatch ( ) ) { \nState currentState = getState ( 0 ) ; \ndo { \nColumnReader columnReader = currentState . column ; \nif ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) { \ncolumnReader . skip ( ) ; \n} \ncolumnReader . consume ( ) ; \nint nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; \ncurrentState = currentState . getNextState ( nextR ) ; \n} \nwhile ( currentState != null ) ; \n++ recordsRead ; \n} \nreturn ; \n} \n} \n"}
{"2051": "public class SerializationUtil { \npublic static void writeObjectToConfAsBase64 ( String key , Object obj , Configuration conf ) throws IOException { \ntry ( ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ) { \ntry ( GZIPOutputStream gos = new GZIPOutputStream ( baos ) ; \nObjectOutputStream oos = new ObjectOutputStream ( gos ) ) { \noos . writeObject ( obj ) ; \n} \nconf . set ( key , new String ( Base64 . encodeBase64 ( baos . toByteArray ( ) ) , StandardCharsets . UTF_8 ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2053": "public class LruCache { \npublic void put ( final K key , final V newValue ) { \nif ( newValue == null || ! newValue . isCurrent ( key ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because it is {}\" , key , ( newValue == null ? \"null\" : \"not current\" ) ) ; \n} \nreturn ; \n} \nV oldValue = cacheMap . get ( key ) ; \nif ( oldValue != null && oldValue . isNewerThan ( newValue ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because \" + \"existing cache entry is newer\" , key ) ; \n} \nreturn ; \n} \noldValue = cacheMap . put ( key , newValue ) ; \nif ( LOG . isDebugEnabled ( ) ) { \nif ( oldValue == null ) { \nLOG . debug ( \"Added new cache entry for '{}'\" , key ) ; \n} \nelse { \nLOG . debug ( \"Overwrote existing cache entry for '{}'\" , key ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2055": "public class AvroWriteSupport { \nprivate void writeValue ( Type type , Schema avroSchema , Object value ) { \nSchema nonNullAvroSchema = AvroSchemaConverter . getNonNull ( avroSchema ) ; \nLogicalType logicalType = nonNullAvroSchema . getLogicalType ( ) ; \nif ( logicalType != null ) { \nConversion < ? > conversion = model . getConversionByClass ( value . getClass ( ) , logicalType ) ; \nwriteValueWithoutConversion ( type , nonNullAvroSchema , convert ( nonNullAvroSchema , logicalType , conversion , value ) ) ; \n} \nelse { \nwriteValueWithoutConversion ( type , nonNullAvroSchema , value ) ; \n} \nreturn ; \n} \n} \n"}
{"2056": "public class AvroWriteSupport { \n@ SuppressWarnings ( \"unchecked\" ) private void writeValueWithoutConversion ( Type type , Schema avroSchema , Object value ) { \nswitch ( avroSchema . getType ( ) ) { \ncase BOOLEAN : recordConsumer . addBoolean ( ( Boolean ) value ) ; \nbreak ; \ncase INT : if ( value instanceof Character ) { \nrecordConsumer . addInteger ( ( Character ) value ) ; \n} \nelse { \nrecordConsumer . addInteger ( ( ( Number ) value ) . intValue ( ) ) ; \n} \nbreak ; \ncase LONG : recordConsumer . addLong ( ( ( Number ) value ) . longValue ( ) ) ; \nbreak ; \ncase FLOAT : recordConsumer . addFloat ( ( ( Number ) value ) . floatValue ( ) ) ; \nbreak ; \ncase DOUBLE : recordConsumer . addDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; \nbreak ; \ncase FIXED : recordConsumer . addBinary ( Binary . fromReusedByteArray ( ( ( GenericFixed ) value ) . bytes ( ) ) ) ; \nbreak ; \ncase BYTES : if ( value instanceof byte [ ] ) { \nrecordConsumer . addBinary ( Binary . fromReusedByteArray ( ( byte [ ] ) value ) ) ; \n} \nelse { \nrecordConsumer . addBinary ( Binary . fromReusedByteBuffer ( ( ByteBuffer ) value ) ) ; \n} \nbreak ; \ncase STRING : recordConsumer . addBinary ( fromAvroString ( value ) ) ; \nbreak ; \ncase RECORD : writeRecord ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \ncase ENUM : recordConsumer . addBinary ( Binary . fromString ( value . toString ( ) ) ) ; \nbreak ; \ncase ARRAY : listWriter . writeList ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \ncase MAP : writeMap ( type . asGroupType ( ) , avroSchema , ( Map < CharSequence , ? > ) value ) ; \nbreak ; \ncase UNION : writeUnion ( type . asGroupType ( ) , avroSchema , value ) ; \nbreak ; \n} \nreturn ; \n} \n\n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nint setOpen = 0 ; \nint curlyOpen = 0 ; \nint len = glob . length ( ) ; \nhasWildcard = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( ++ i >= len ) { \nerror ( \"Missing escaped character\" , glob , i ) ; \n} \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \ncontinue ; \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni ++ ; \nbreak ; \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \ncontinue ; \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen ++ ; \nhasWildcard = true ; \ncontinue ; \ncase ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; \ncontinue ; \ncase '}' : if ( curlyOpen > 0 ) { \ncurlyOpen -- ; \nregex . append ( \")\" ) ; \ncontinue ; \n} \nbreak ; \ncase '[' : if ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , i ) ; \n} \nsetOpen ++ ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) { \nregex . append ( BACKSLASH ) ; \n} \nbreak ; \ncase '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \ncontinue ; \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \n} \nif ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , len ) ; \n} \nif ( curlyOpen > 0 ) { \nerror ( \"Unclosed group\" , glob , len ) ; \n} \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"2058": "public class BaseCommand { \npublic void output ( String content , Logger console , String filename ) throws IOException { \nif ( filename == null || \"-\" . equals ( filename ) ) { \nconsole . info ( content ) ; \n} \nelse { \nFSDataOutputStream outgoing = create ( filename ) ; \ntry { \noutgoing . write ( content . getBytes ( StandardCharsets . UTF_8 ) ) ; \n} \nfinally { \noutgoing . close ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2069": "public class MergeCommand { \nprivate void checkParquetFiles ( List < Path > inputFiles ) throws IOException { \nif ( inputFiles == null || inputFiles . size ( ) <= 1 ) { \nthrow new IllegalArgumentException ( \"Not enough files to merge\" ) ; \n} \nfor ( Path inputFile : inputFiles ) { \nFileSystem fs = inputFile . getFileSystem ( conf ) ; \nFileStatus status = fs . getFileStatus ( inputFile ) ; \nif ( status . isDir ( ) ) { \nthrow new IllegalArgumentException ( \"Illegal parquet file: \" + inputFile . toUri ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2072": "public class Consumers { \npublic static < T extends TBase < T , ? extends TFieldIdEnum > > ListConsumer listOf ( Class < T > c , final Consumer < List < T > > consumer ) { \nclass ListConsumer implements Consumer < T > { \nList < T > list ; \n@ Override public void consume ( T t ) { \nlist . add ( t ) ; \nreturn ; \n} \n} \nfinal ListConsumer co = new ListConsumer ( ) ; \nreturn new DelegatingListElementsConsumer ( struct ( c , co ) ) { \n@ Override public void consumeList ( TProtocol protocol , EventBasedThriftReader reader , TList tList ) throws TException { \nco . list = new ArrayList < T > ( ) ; \nsuper . consumeList ( protocol , reader , tList ) ; \nconsumer . consume ( co . list ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"2073": "public class Hive010Binding { \nprivate void init ( final JobConf job ) { \nfinal String plan = HiveConf . getVar ( job , HiveConf . ConfVars . PLAN ) ; \nif ( mrwork == null && plan != null && plan . length ( ) > 0 ) { \nmrwork = Utilities . getMapRedWork ( job ) ; \npathToPartitionInfo . clear ( ) ; \nfor ( final Map . Entry < String , PartitionDesc > entry : mrwork . getPathToPartitionInfo ( ) . entrySet ( ) ) { \npathToPartitionInfo . put ( new Path ( entry . getKey ( ) ) . toUri ( ) . getPath ( ) . toString ( ) , entry . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2076": "public class EventBasedThriftReader { \npublic void readStruct ( FieldConsumer c ) throws TException { \nprotocol . readStructBegin ( ) ; \nreadStructContent ( c ) ; \nprotocol . readStructEnd ( ) ; \nreturn ; \n} \n} \n"}
{"2077": "public class EventBasedThriftReader { \npublic void readMapEntry ( byte keyType , TypedConsumer keyConsumer , byte valueType , TypedConsumer valueConsumer ) throws TException { \nkeyConsumer . read ( protocol , this , keyType ) ; \nvalueConsumer . read ( protocol , this , valueType ) ; \nreturn ; \n} \n} \n"}
{"2078": "public class ByteBasedBitPackingEncoder { \npublic void writeInt ( int value ) throws IOException { \ninput [ inputSize ] = value ; \n++ inputSize ; \nif ( inputSize == VALUES_WRITTEN_AT_A_TIME ) { \npack ( ) ; \nif ( packedPosition == slabSize ) { \nslabs . add ( BytesInput . from ( packed ) ) ; \ntotalFullSlabSize += slabSize ; \nif ( slabSize < bitWidth * MAX_SLAB_SIZE_MULT ) { \nslabSize *= 2 ; \n} \ninitPackedSlab ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2080": "public class AvroParquetOutputFormat { \npublic static void setSchema ( Job job , Schema schema ) { \nAvroWriteSupport . setSchema ( ContextUtil . getConfiguration ( job ) , schema ) ; \nreturn ; \n} \n} \n"}
{"2081": "public class MapR52StreamsValidationUtil09 { \n@ Override public void createTopicIfNotExists ( String topic , Map < String , Object > kafkaClientConfigs , String metadataBrokerList ) throws StageException { \nif ( topic . startsWith ( \"/\" ) && topic . contains ( \":\" ) ) { \nString [ ] path = topic . split ( \":\" ) ; \nif ( path . length != 2 ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_21 , topic ) ; \n} \nString streamPath = path [ 0 ] ; \nif ( ! streamCache . contains ( streamPath ) ) { \nConfiguration conf = new Configuration ( ) ; \nkafkaClientConfigs . forEach ( ( k , v ) -> { \nconf . set ( k , v . toString ( ) ) ; \n} \n) ; \nAdmin streamAdmin = null ; \ntry { \nstreamAdmin = Streams . newAdmin ( conf ) ; \nstreamAdmin . countTopics ( streamPath ) ; \nstreamCache . add ( streamPath ) ; \n} \ncatch ( TableNotFoundException e ) { \nLOG . debug ( \"Stream not found. Creating a new stream: \" + streamPath ) ; \ntry { \nstreamAdmin . createStream ( streamPath , Streams . newStreamDescriptor ( ) ) ; \nstreamCache . add ( streamPath ) ; \n} \ncatch ( IOException ioex ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_22 , streamPath , e . getMessage ( ) , e ) ; \n} \n} \ncatch ( IOException | IllegalArgumentException e ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_23 , e . getMessage ( ) , e ) ; \n} \nfinally { \nif ( streamAdmin != null ) { \nstreamAdmin . close ( ) ; \n} \n} \n} \n} \nKafkaProducer < String , String > kafkaProducer = createProducerTopicMetadataClient ( kafkaClientConfigs ) ; \nkafkaProducer . partitionsFor ( topic ) ; \nreturn ; \n} \n} \n"}
{"2089": "public class JmsTargetUpgrader { \nprivate void upgradeV1ToV2 ( List < Config > configs , Context context ) { \nList < Config > dataFormatConfigs = configs . stream ( ) . filter ( c -> c . getName ( ) . startsWith ( \"dataFormat\" ) ) . collect ( Collectors . toList ( ) ) ; \nconfigs . removeAll ( dataFormatConfigs ) ; \ndataFormatConfigs = dataFormatConfigs . stream ( ) . map ( c -> new Config ( c . getName ( ) . replace ( \"dataFormatConfig.\" , \"dataGeneratorFormatConfig.\" ) , c . getValue ( ) ) ) . collect ( Collectors . toList ( ) ) ; \ncontext . registerService ( DataFormatGeneratorService . class , dataFormatConfigs ) ; \nreturn ; \n} \n} \n"}
{"2091": "public class BaseClusterProvider { \nprivate void copyBlobstore ( List < String > blobStoreResources , File rootDataDir , File pipelineDir ) throws IOException { \nif ( blobStoreResources == null ) { \nreturn ; \n} \nFile blobstoreDir = new File ( runtimeInfo . getDataDir ( ) , BLOBSTORE_BASE_DIR ) ; \nFile stagingBlobstoreDir = new File ( rootDataDir , BLOBSTORE_BASE_DIR ) ; \nif ( ! stagingBlobstoreDir . exists ( ) ) { \nif ( ! stagingBlobstoreDir . mkdirs ( ) ) { \nthrow new RuntimeException ( \"Failed to create blobstore directory: \" + pipelineDir . getPath ( ) ) ; \n} \n} \nfor ( String blobstoreFile : blobStoreResources ) { \nFile srcFile = new File ( blobstoreDir , blobstoreFile ) ; \nif ( srcFile . exists ( ) ) { \nfinal File dstFile = new File ( stagingBlobstoreDir , srcFile . getName ( ) ) ; \nif ( srcFile . canRead ( ) ) { \ntry ( InputStream in = new FileInputStream ( ( srcFile ) ) ) { \ntry ( OutputStream out = new FileOutputStream ( ( dstFile ) ) ) { \nIOUtils . copy ( in , out ) ; \n} \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2092": "public class SQLListener { \npublic void reset ( ) { \ncolumns . clear ( ) ; \nthis . columnsExpected = null ; \ncolumnNames = null ; \ntable = null ; \nschema = null ; \ninsideStatement = false ; \nreturn ; \n} \n} \n"}
{"2095": "public class RuntimeInfo { \npublic static void storeControlHubConfigs ( RuntimeInfo runtimeInfo , Map < String , String > newConfigs ) throws IOException { \nFile configFile = new File ( runtimeInfo . getDataDir ( ) , SCH_CONF_OVERRIDE ) ; \nProperties properties = new Properties ( ) ; \nif ( configFile . exists ( ) ) { \ntry ( FileReader reader = new FileReader ( configFile ) ) { \nproperties . load ( reader ) ; \n} \n} \nfor ( Map . Entry < String , String > entry : newConfigs . entrySet ( ) ) { \nif ( entry . getValue ( ) == null ) { \nproperties . remove ( entry . getKey ( ) ) ; \n} \nelse { \nproperties . setProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \ntry ( FileWriter writer = new FileWriter ( configFile ) ) { \nproperties . store ( writer , null ) ; \n} \nreturn ; \n} \n} \n"}
{"2101": "public class PipelineConfigurationUpgrader { \nstatic private void upgradeStageIfNeeded ( StageDefinition def , StageConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { \nint fromVersion = conf . getStageVersion ( ) ; \nint toVersion = def . getVersion ( ) ; \nif ( ! needsUpgrade ( toVersion , fromVersion , IssueCreator . getStage ( conf . getInstanceName ( ) ) , issues ) ) { \nreturn ; \n} \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \ntry { \nThread . currentThread ( ) . setContextClassLoader ( def . getStageClassLoader ( ) ) ; \nLOG . warn ( \"Upgrading stage instance '{}' from version '{}' to version '{}'\" , conf . getInstanceName ( ) , fromVersion , toVersion ) ; \nUpgradeContext upgradeContext = new UpgradeContext ( def . getLibrary ( ) , def . getName ( ) , conf . getInstanceName ( ) , fromVersion , toVersion ) ; \nList < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; \nconf . setStageVersion ( def . getVersion ( ) ) ; \nconf . setConfig ( configs ) ; \nif ( ! upgradeContext . registeredServices . isEmpty ( ) ) { \nList < ServiceConfiguration > services = new ArrayList < > ( ) ; \nservices . addAll ( conf . getServices ( ) ) ; \nupgradeContext . registeredServices . forEach ( ( s , c ) -> services . add ( new ServiceConfiguration ( s , - 1 , c ) ) ) ; \nconf . setServices ( services ) ; \n} \n} \ncatch ( StageException ex ) { \nissues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; \n} \nfinally { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nreturn ; \n} \n} \n"}
{"2109": "public class ProtobufTypeUtil { \npublic static void getAllFileDescriptors ( DescriptorProtos . FileDescriptorSet set , Map < String , Set < Descriptors . FileDescriptor > > dependenciesMap , Map < String , Descriptors . FileDescriptor > fileDescriptorMap ) throws StageException { \nList < DescriptorProtos . FileDescriptorProto > fileList = set . getFileList ( ) ; \ntry { \nfor ( DescriptorProtos . FileDescriptorProto fdp : fileList ) { \nif ( ! fileDescriptorMap . containsKey ( fdp . getName ( ) ) ) { \nSet < Descriptors . FileDescriptor > dependencies = dependenciesMap . get ( fdp . getName ( ) ) ; \nif ( dependencies == null ) { \ndependencies = new LinkedHashSet < > ( ) ; \ndependenciesMap . put ( fdp . getName ( ) , dependencies ) ; \ndependencies . addAll ( getDependencies ( dependenciesMap , fileDescriptorMap , fdp , set ) ) ; \n} \nDescriptors . FileDescriptor fileDescriptor = Descriptors . FileDescriptor . buildFrom ( fdp , dependencies . toArray ( new Descriptors . FileDescriptor [ dependencies . size ( ) ] ) ) ; \nfileDescriptorMap . put ( fdp . getName ( ) , fileDescriptor ) ; \n} \n} \n} \ncatch ( Descriptors . DescriptorValidationException e ) { \nthrow new StageException ( Errors . PROTOBUF_07 , e . getDescription ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2110": "public class ProtobufTypeUtil { \npublic static void populateDefaultsAndExtensions ( Map < String , Descriptors . FileDescriptor > fileDescriptorMap , Map < String , Set < Descriptors . FieldDescriptor > > typeToExtensionMap , Map < String , Object > defaultValueMap ) { \nfor ( Descriptors . FileDescriptor f : fileDescriptorMap . values ( ) ) { \nfor ( Descriptors . FieldDescriptor fieldDescriptor : f . getExtensions ( ) ) { \nString containingType = fieldDescriptor . getContainingType ( ) . getFullName ( ) ; \nSet < Descriptors . FieldDescriptor > fieldDescriptors = typeToExtensionMap . get ( containingType ) ; \nif ( fieldDescriptors == null ) { \nfieldDescriptors = new LinkedHashSet < > ( ) ; \ntypeToExtensionMap . put ( containingType , fieldDescriptors ) ; \n} \nfieldDescriptors . add ( fieldDescriptor ) ; \nif ( fieldDescriptor . hasDefaultValue ( ) ) { \ndefaultValueMap . put ( containingType + \".\" + fieldDescriptor . getName ( ) , fieldDescriptor . getDefaultValue ( ) ) ; \n} \n} \nfor ( Descriptors . Descriptor d : f . getMessageTypes ( ) ) { \naddDefaultsAndExtensions ( typeToExtensionMap , defaultValueMap , d ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2115": "public class JerseyClientUtil { \npublic static void upgradeToJerseyConfigBean ( List < Config > configs ) { \nList < Config > configsToAdd = new ArrayList < > ( ) ; \nList < Config > configsToRemove = new ArrayList < > ( ) ; \nList < String > movedConfigs = ImmutableList . of ( \"conf.requestTimeoutMillis\" , \"conf.numThreads\" , \"conf.authType\" , \"conf.oauth\" , \"conf.basicAuth\" , \"conf.useProxy\" , \"conf.proxy\" , \"conf.sslConfig\" ) ; \nfor ( Config config : configs ) { \nif ( hasPrefixIn ( movedConfigs , config . getName ( ) ) ) { \nconfigsToRemove . add ( config ) ; \nconfigsToAdd . add ( new Config ( config . getName ( ) . replace ( \"conf.\" , \"conf.client.\" ) , config . getValue ( ) ) ) ; \n} \n} \nconfigsToAdd . add ( new Config ( \"conf.client.transferEncoding\" , RequestEntityProcessing . CHUNKED ) ) ; \nconfigs . removeAll ( configsToRemove ) ; \nconfigs . addAll ( configsToAdd ) ; \nreturn ; \n} \n} \n"}
{"2116": "public class KuduUtils { \npublic static void checkConnection ( AsyncKuduClient kuduClient , Context context , String KUDU_MASTER , final List < Stage . ConfigIssue > issues ) { \ntry { \nkuduClient . getTablesList ( ) . join ( ) ; \n} \ncatch ( Exception ex ) { \nissues . add ( context . createConfigIssue ( Groups . KUDU . name ( ) , KuduLookupConfig . CONF_PREFIX + KUDU_MASTER , Errors . KUDU_00 , ex . toString ( ) , ex ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2121": "public class ValidationUtil { \npublic static void addMissingConfigsToStage ( StageLibraryTask stageLibrary , StageConfiguration stageConf ) { \nStageDefinition stageDef = stageLibrary . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , false ) ; \nif ( stageDef != null ) { \nfor ( ConfigDefinition configDef : stageDef . getConfigDefinitions ( ) ) { \nString configName = configDef . getName ( ) ; \nConfig config = stageConf . getConfig ( configName ) ; \nif ( config == null ) { \nObject defaultValue = configDef . getDefaultValue ( ) ; \nLOG . warn ( \"Stage '{}' missing configuration '{}', adding with '{}' as default\" , stageConf . getInstanceName ( ) , configName , defaultValue ) ; \nconfig = new Config ( configName , defaultValue ) ; \nstageConf . addConfig ( config ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2123": "public class HttpProcessor { \nprivate void addResponseHeaders ( Record record , Response response ) throws StageException { \nif ( conf . headerOutputLocation == HeaderOutputLocation . NONE ) { \nreturn ; \n} \nRecord . Header header = record . getHeader ( ) ; \nif ( conf . headerOutputLocation == HeaderOutputLocation . FIELD ) { \nwriteResponseHeaderToField ( record , response ) ; \n} \nelse if ( conf . headerOutputLocation == HeaderOutputLocation . HEADER ) { \nwriteResponseHeaderToRecordHeader ( response , header ) ; \n} \nreturn ; \n} \n} \n"}
{"2124": "public class HttpProcessor { \nprivate void writeResponseHeaderToField ( Record record , Response response ) throws StageException { \nif ( record . has ( conf . headerOutputField ) ) { \nthrow new StageException ( Errors . HTTP_11 , conf . headerOutputField ) ; \n} \nMap < String , Field > headers = new HashMap < > ( response . getStringHeaders ( ) . size ( ) ) ; \nfor ( Map . Entry < String , List < String > > entry : response . getStringHeaders ( ) . entrySet ( ) ) { \nif ( ! entry . getValue ( ) . isEmpty ( ) ) { \nString firstValue = entry . getValue ( ) . get ( 0 ) ; \nheaders . put ( entry . getKey ( ) , Field . create ( firstValue ) ) ; \n} \n} \nrecord . set ( conf . headerOutputField , Field . create ( headers ) ) ; \nreturn ; \n} \n} \n"}
{"2125": "public class HttpProcessor { \nprivate void writeResponseHeaderToRecordHeader ( Response response , Record . Header header ) { \nfor ( Map . Entry < String , List < String > > entry : response . getStringHeaders ( ) . entrySet ( ) ) { \nif ( ! entry . getValue ( ) . isEmpty ( ) ) { \nString firstValue = entry . getValue ( ) . get ( 0 ) ; \nheader . setAttribute ( conf . headerAttributePrefix + entry . getKey ( ) , firstValue ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2126": "public class BlobStoreTaskImpl { \nsynchronized private void saveMetadata ( ) throws StageException { \nif ( Files . exists ( newMetadataFile ) ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0010 ) ; \n} \ntry ( OutputStream os = Files . newOutputStream ( newMetadataFile , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING ) ) { \njsonMapper . writeValue ( os , metadata ) ; \n} \ncatch ( IOException e ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0001 , e . toString ( ) , e ) ; \n} \ntry { \nif ( Files . exists ( metadataFile ) ) { \nFiles . delete ( metadataFile ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0011 , e . toString ( ) , e ) ; \n} \ntry { \nFiles . move ( newMetadataFile , metadataFile ) ; \n} \ncatch ( IOException e ) { \nthrow new StageException ( BlobStoreError . BLOB_STORE_0012 , e . toString ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2127": "public class HttpClientSource { \nprivate void configureClient ( List < ConfigIssue > issues ) throws StageException { \nclientCommon . init ( issues , getContext ( ) ) ; \nif ( issues . isEmpty ( ) ) { \nclient = clientCommon . getClient ( ) ; \nparserFactory = conf . dataFormatConfig . getParserFactory ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2129": "public class HttpClientSource { \nprivate void incrementSourceOffset ( HttpSourceOffset sourceOffset , int increment ) { \nif ( conf . pagination . mode == PaginationMode . BY_PAGE ) { \nsourceOffset . incrementStartAt ( 1 ) ; \n} \nelse if ( conf . pagination . mode == PaginationMode . BY_OFFSET ) { \nsourceOffset . incrementStartAt ( increment ) ; \n} \nreturn ; \n} \n} \n"}
{"2131": "public class HttpClientSource { \nprivate void addResponseHeaders ( Record . Header header ) { \nfinal MultivaluedMap < String , String > headers = getResponse ( ) . getStringHeaders ( ) ; \nif ( headers == null ) { \nreturn ; \n} \nfor ( Map . Entry < String , List < String > > entry : headers . entrySet ( ) ) { \nif ( ! entry . getValue ( ) . isEmpty ( ) ) { \nString firstValue = entry . getValue ( ) . get ( 0 ) ; \nheader . setAttribute ( entry . getKey ( ) , firstValue ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2140": "public class ApplicationPackage { \nstatic void removeLogicalDuplicates ( SortedSet < String > packages ) { \nIterator < String > iterator = packages . iterator ( ) ; \nif ( ! iterator . hasNext ( ) ) { \nreturn ; \n} \nString last = iterator . next ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nString current = iterator . next ( ) ; \nif ( current . startsWith ( last ) ) { \niterator . remove ( ) ; \n} \nelse { \nlast = current ; \n} \n} \nreturn ; \n} \n} \n"}
{"2141": "public class HdfsTarget { \nprotected void emptyBatch ( ) throws StageException { \nsetBatchTime ( ) ; \ntry { \nhdfsTargetConfigBean . getUGI ( ) . doAs ( new PrivilegedExceptionAction < Void > ( ) { \n@ Override public Void run ( ) throws Exception { \nhdfsTargetConfigBean . getCurrentWriters ( ) . purge ( ) ; \nif ( hdfsTargetConfigBean . getLateWriters ( ) != null ) { \nhdfsTargetConfigBean . getLateWriters ( ) . purge ( ) ; \n} \nreturn null ; \n} \n} \n) ; \n} \ncatch ( Exception ex ) { \nthrow throwStageException ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"2144": "public class ConnectionManager { \npublic void closeConnection ( ) { \nLOGGER . debug ( \"Closing connection\" ) ; \nConnection connectionToRemove = threadLocalConnection . get ( ) ; \njdbcUtil . closeQuietly ( connectionToRemove ) ; \nif ( connectionToRemove != null ) { \nsynchronized ( this ) { \nconnectionsToCloseDuringDestroy . remove ( connectionToRemove ) ; \n} \n} \nthreadLocalConnection . set ( null ) ; \nreturn ; \n} \n} \n"}
{"2151": "public class GrokDictionary { \npublic void addDictionary ( final InputStream inputStream ) { \ntry { \naddDictionaryAux ( new InputStreamReader ( inputStream , \"UTF-8\" ) ) ; \n} \ncatch ( IOException e ) { \nthrow new GrokCompilationException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"2152": "public class GrokDictionary { \npublic void addDictionary ( Reader reader ) { \ntry { \naddDictionaryAux ( reader ) ; \n} \ncatch ( IOException e ) { \nthrow new GrokCompilationException ( e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( reader ) ; \n} \nreturn ; \n} \n} \n"}
{"2158": "public class SampleTarget { \nprivate void write ( Record record ) throws OnRecordErrorException { \nif ( ! record . has ( \"/someField\" ) ) { \nthrow new OnRecordErrorException ( Errors . SAMPLE_01 , record , \"exception detail message.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"2169": "public class HiveMetastoreUtil { \npublic static void validatePartitionInformation ( TypeInfoCacheSupport . TypeInfo typeInfo , LinkedHashMap < String , String > partitionValMap , String qualifiedTableName ) throws HiveStageCheckedException { \nSet < String > partitionNamesInHive = typeInfo . getPartitionTypeInfo ( ) . keySet ( ) ; \nSet < String > partitionNames = partitionValMap . keySet ( ) ; \nif ( ! ( partitionNamesInHive . size ( ) == partitionNames . size ( ) && partitionNamesInHive . containsAll ( partitionNames ) ) ) { \nLOG . error ( Utils . format ( \"Partition mismatch. In Hive: {}, In Record : {}\" , partitionNamesInHive . size ( ) , partitionNames . size ( ) ) ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_27 , qualifiedTableName ) ; \n} \nreturn ; \n} \n} \n"}
{"2179": "public class SolrTarget { \nprivate void sendOnRecordErrorExceptionToHandler ( Record record , Errors error , StageException ex ) throws StageException { \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , error , record . getHeader ( ) . getSourceId ( ) , ex . toString ( ) , ex ) ) ; \nreturn ; \n} \n} \n"}
{"2183": "public class CouchbaseConnector { \npublic synchronized void close ( ) { \nif ( ! isClosed ) { \nif ( bucket != null ) { \nLOG . debug ( \"Closing Couchbase bucket\" ) ; \nbucket . close ( ) ; \n} \nif ( cluster != null ) { \nLOG . debug ( \"Disconnecting Couchbase cluster\" ) ; \ncluster . disconnect ( ) ; \n} \nif ( env != null ) { \nLOG . debug ( \"Shutting down Couchbase environment\" ) ; \nenv . shutdown ( ) ; \n} \nisClosed = true ; \n} \nreturn ; \n} \n} \n"}
{"2184": "public class CouchbaseConnector { \nprivate static void validateConfig ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { \nif ( config . couchbase . nodes == null ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.nodes\" , Errors . COUCHBASE_29 ) ) ; \n} \nif ( config . couchbase . kvTimeout < 0 ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.kvTimeout\" , Errors . COUCHBASE_30 ) ) ; \n} \nif ( config . couchbase . connectTimeout < 0 ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.connectTimeout\" , Errors . COUCHBASE_31 ) ) ; \n} \nif ( config . couchbase . disconnectTimeout < 0 ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.disconnectTimeout\" , Errors . COUCHBASE_32 ) ) ; \n} \nif ( config . couchbase . tls . tlsEnabled ) { \nconfig . couchbase . tls . init ( context , Groups . COUCHBASE . name ( ) , \"config.couchbase.tls.\" , issues ) ; \n} \nif ( config . credentials . version == null ) { \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.version\" , Errors . COUCHBASE_33 ) ) ; \n} \nif ( config . credentials . version == AuthenticationType . USER ) { \nif ( config . credentials . userName == null ) { \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.userName\" , Errors . COUCHBASE_34 ) ) ; \n} \nif ( config . credentials . userPassword == null ) { \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.userPassword\" , Errors . COUCHBASE_35 ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2186": "public class ConfigDefinitionExtractor { \nprivate void verifyDependencyExists ( Map < String , ConfigDefinition > definitionsMap , ConfigDefinition def , String dependsOnKey , Object contextMsg ) { \nPreconditions . checkState ( definitionsMap . containsKey ( dependsOnKey ) , Utils . format ( \"Error while processing {} ConfigDef='{}'. Dependency='{}' does not exist.\" , contextMsg , def . getName ( ) , dependsOnKey ) ) ; \nreturn ; \n} \n} \n"}
{"2192": "public class KerberosLogin { \npublic void configure ( Map < String , ? > configs , final String loginContextName ) { \nsuper . configure ( configs , loginContextName ) ; \nthis . loginContextName = loginContextName ; \nthis . ticketRenewWindowFactor = ( Double ) configs . get ( SaslConfigs . SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR ) ; \nthis . ticketRenewJitter = ( Double ) configs . get ( SaslConfigs . SASL_KERBEROS_TICKET_RENEW_JITTER ) ; \nthis . minTimeBeforeRelogin = ( Long ) configs . get ( SaslConfigs . SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN ) ; \nthis . kinitCmd = ( String ) configs . get ( SaslConfigs . SASL_KERBEROS_KINIT_CMD ) ; \nthis . serviceName = getServiceName ( configs , loginContextName ) ; \nreturn ; \n} \n} \n"}
{"2194": "public class Consumer { \npublic void commit ( String offset ) { \nbatchCommitted = true ; \nLOG . trace ( \"Last committed offset '{}', attempting to commit '{}'\" , lastCommittedOffset , offset ) ; \nUtils . checkState ( null != lastCommittedOffset , \"Last committed offset cannot be null\" ) ; \ncontrolChannel . consumerCommit ( offset ) ; \nlastCommittedOffset = offset ; \nreturn ; \n} \n} \n"}
{"2195": "public class Consumer { \npublic void error ( Throwable throwable ) { \nif ( consumerError == null ) { \nconsumerError = throwable ; \ncontrolChannel . consumerError ( throwable ) ; \n} \nreturn ; \n} \n} \n"}
{"2196": "public class ConfigInjector { \npublic void injectStage ( Object stage , StageDefinition stageDef , StageConfiguration stageConf , Map < String , Object > constants , List < Issue > issues ) { \ninjectConfigsToObject ( stage , new StageInjectorContext ( stageDef , stageConf , constants , issues ) ) ; \nreturn ; \n} \n} \n"}
{"2211": "public class RunnerPool { \npublic void returnRunner ( T runner ) throws PipelineRuntimeException { \nvalidateNotDestroyed ( ) ; \nqueue . add ( new QueueItem < > ( runner ) ) ; \nruntimeStats . setAvailableRunners ( queue . size ( ) ) ; \nhistogram . update ( queue . size ( ) ) ; \nreturn ; \n} \n} \n"}
{"2212": "public class RunnerPool { \npublic void destroy ( ) throws PipelineRuntimeException { \ndestroyed . set ( true ) ; \nif ( queue . size ( ) < runtimeStats . getTotalRunners ( ) ) { \nthrow new PipelineRuntimeException ( ContainerError . CONTAINER_0802 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2213": "public class RunnerPool { \nprivate void validateNotDestroyed ( ) throws PipelineRuntimeException { \nif ( destroyed . get ( ) ) { \nthrow new PipelineRuntimeException ( ContainerError . CONTAINER_0803 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2216": "public class JdbcMultiRowRecordWriter { \nprivate void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { \nif ( queue . isEmpty ( ) ) { \nreturn ; \n} \nint rowCount = 0 ; \nfinal Record first = queue . getFirst ( ) ; \nSortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; \nif ( columnsToParameters . isEmpty ( ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"No parameters found for record with ID {}; skipping\" , first . getHeader ( ) . getSourceId ( ) ) ; \n} \nreturn ; \n} \nString query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; \nLinkedList < Record > removed = new LinkedList < > ( ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nwhile ( ! queue . isEmpty ( ) ) { \nRecord r = queue . removeFirst ( ) ; \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \nremoved . add ( r ) ; \n++ rowCount ; \nif ( rowCount == maxRowsPerBatch ) { \nprocessBatch ( removed , errorRecords , statement , connection ) ; \nrowCount = 0 ; \nparamIdx = 1 ; \nremoved . clear ( ) ; \n} \n} \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \nif ( ! removed . isEmpty ( ) ) { \nquery = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nfor ( Record r : removed ) { \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \n} \nprocessBatch ( removed , errorRecords , statement , connection ) ; \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2217": "public class JdbcMultiRowRecordWriter { \nprivate void handleSqlException ( SQLException exception , List < Record > inputRecords , List < OnRecordErrorException > errors ) throws StageException { \nif ( jdbcUtil . isDataError ( getCustomDataSqlStateCodes ( ) , getConnectionString ( ) , exception ) ) { \nString formattedError = jdbcUtil . formatSqlException ( exception ) ; \nLOG . error ( JdbcErrors . JDBC_89 . getMessage ( ) , formattedError ) ; \nfor ( Record inputRecord : inputRecords ) { \nerrors . add ( new OnRecordErrorException ( inputRecord , JdbcErrors . JDBC_89 , formattedError ) ) ; \n} \nreturn ; \n} \nsuper . handleSqlException ( exception ) ; \nreturn ; \n} \n} \n"}
{"2225": "public class HdfsMetadataExecutor { \nprivate void ensureDirectoryExists ( FileSystem fs , Path path ) throws IOException { \nif ( ! fs . exists ( path ) ) { \nLOG . debug ( \"Creating directory: {}\" , path ) ; \nif ( ! fs . mkdirs ( path ) ) { \nthrow new IOException ( \"Can't create directory: \" + path ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2226": "public class JdbcUtil { \npublic void write ( Batch batch , SchemaTableClassifier schemaTableClassifier , LoadingCache < SchemaAndTable , JdbcRecordWriter > recordWriters , ErrorRecordHandler errorRecordHandler , boolean perRecord ) throws StageException { \nMultimap < SchemaAndTable , Record > partitions = schemaTableClassifier . classify ( batch ) ; \nfor ( SchemaAndTable key : partitions . keySet ( ) ) { \nIterator < Record > recordIterator = partitions . get ( key ) . iterator ( ) ; \nwrite ( recordIterator , key , recordWriters , errorRecordHandler , perRecord ) ; \n} \nreturn ; \n} \n} \n"}
{"2227": "public class JdbcUtil { \npublic void write ( Batch batch , ELEval tableNameEval , ELVars tableNameVars , String tableNameTemplate , LoadingCache < String , JdbcRecordWriter > recordWriters , ErrorRecordHandler errorRecordHandler , boolean perRecord ) throws StageException { \nMultimap < String , Record > partitions = ELUtils . partitionBatchByExpression ( tableNameEval , tableNameVars , tableNameTemplate , batch ) ; \nfor ( String tableName : partitions . keySet ( ) ) { \nIterator < Record > recordIterator = partitions . get ( tableName ) . iterator ( ) ; \nwrite ( recordIterator , tableName , recordWriters , errorRecordHandler , perRecord ) ; \n} \nreturn ; \n} \n} \n"}
{"2228": "public class JdbcUtil { \npublic < T > void write ( Iterator < Record > recordIterator , T key , LoadingCache < T , JdbcRecordWriter > recordWriters , ErrorRecordHandler errorRecordHandler , boolean perRecord ) throws StageException { \nfinal JdbcRecordWriter jdbcRecordWriter ; \ntry { \njdbcRecordWriter = recordWriters . getUnchecked ( key ) ; \n} \ncatch ( UncheckedExecutionException ex ) { \nfinal Throwable throwable = ex . getCause ( ) ; \nfinal ErrorCode errorCode ; \nfinal Object [ ] messageParams ; \nif ( throwable instanceof StageException ) { \nStageException stageEx = ( StageException ) ex . getCause ( ) ; \nerrorCode = stageEx . getErrorCode ( ) ; \nmessageParams = stageEx . getParams ( ) ; \n} \nelse { \nerrorCode = JdbcErrors . JDBC_301 ; \nmessageParams = new Object [ ] { \nex . getMessage ( ) , ex . getCause ( ) } \n; \n} \nwhile ( recordIterator . hasNext ( ) ) { \nRecord record = recordIterator . next ( ) ; \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , errorCode , messageParams ) ) ; \n} \nreturn ; \n} \nList < OnRecordErrorException > errors = perRecord ? jdbcRecordWriter . writePerRecord ( recordIterator ) : jdbcRecordWriter . writeBatch ( recordIterator ) ; \nfor ( OnRecordErrorException error : errors ) { \nerrorRecordHandler . onError ( error ) ; \n} \nreturn ; \n} \n} \n"}
{"2229": "public class JdbcUtil { \npublic void generateNoMoreDataEvent ( PushSource . Context context ) { \nLOG . info ( \"No More data to process, Triggered No More Data Event\" ) ; \nBatchContext batchContext = context . startBatch ( ) ; \nCommonEvents . NO_MORE_DATA . create ( context , batchContext ) . createAndSend ( ) ; \ncontext . processBatch ( batchContext ) ; \nreturn ; \n} \n} \n"}
{"2231": "public class HiveMetadataProcessor { \n@ VisibleForTesting static void updateRecordForHDFS ( Record record , boolean roll , String avroSchema , String location ) { \nif ( roll ) { \nrecord . getHeader ( ) . setAttribute ( HDFS_HEADER_ROLL , \"true\" ) ; \n} \nrecord . getHeader ( ) . setAttribute ( HDFS_HEADER_AVROSCHEMA , avroSchema ) ; \nrecord . getHeader ( ) . setAttribute ( HDFS_HEADER_TARGET_DIRECTORY , location ) ; \nLOG . trace ( \"Record {} will be stored in {} path: roll({}), avro schema: {}\" , record . getHeader ( ) . getSourceId ( ) , location , roll , avroSchema ) ; \nreturn ; \n} \n} \n"}
{"2232": "public class GroupByAggregator { \npublic void process ( String group , T value ) { \ngetData ( ) . process ( ImmutableMap . of ( group , value ) ) ; \nreturn ; \n} \n} \n"}
{"2234": "public class BootstrapMesosDriver { \npublic static void main ( String [ ] args ) throws Exception { \nBootstrapCluster . printSystemPropsEnvVariables ( ) ; \nString mesosDir = System . getenv ( \"MESOS_DIRECTORY\" ) ; \nif ( mesosDir == null ) { \nthrow new IllegalStateException ( \"Expected the env. variable MESOS_DIRECTORY to be defined\" ) ; \n} \nFile mesosHomeDir = new File ( mesosDir ) ; \nString sparkDir = System . getenv ( \"SPARK_HOME\" ) ; \nif ( sparkDir == null ) { \nthrow new IllegalStateException ( \"Expected the env. variable SPARK_HOME to be defined\" ) ; \n} \nFile sparkHomeDir = new File ( sparkDir ) ; \nint processExitValue = BootstrapCluster . findAndExtractJar ( mesosHomeDir , sparkHomeDir ) ; \nif ( processExitValue != 0 ) { \nthrow new IllegalStateException ( \"Process extracting archives from uber jar exited abnormally; check Mesos driver stdout file\" ) ; \n} \nSystem . setProperty ( \"SDC_MESOS_BASE_DIR\" , new File ( mesosHomeDir , BootstrapCluster . SDC_MESOS_BASE_DIR ) . getAbsolutePath ( ) ) ; \nfinal Class < ? > clazz = Class . forName ( \"com.streamsets.pipeline.BootstrapClusterStreaming\" ) ; \nfinal Method method = clazz . getMethod ( \"main\" , String [ ] . class ) ; \nmethod . invoke ( null , new Object [ ] { \nargs } \n) ; \nreturn ; \n} \n} \n"}
{"2235": "public class HttpClientCommon { \nprivate void configureAuthAndBuildClient ( ClientBuilder clientBuilder , List < Stage . ConfigIssue > issues ) { \nif ( jerseyClientConfig . authType == AuthenticationType . OAUTH ) { \nString consumerKey = jerseyClientConfig . oauth . resolveConsumerKey ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString consumerSecret = jerseyClientConfig . oauth . resolveConsumerSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString token = jerseyClientConfig . oauth . resolveToken ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString tokenSecret = jerseyClientConfig . oauth . resolveTokenSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) { \nauthToken = JerseyClientUtil . configureOAuth1 ( consumerKey , consumerSecret , token , tokenSecret , clientBuilder ) ; \n} \n} \nelse if ( jerseyClientConfig . authType . isOneOf ( AuthenticationType . DIGEST , AuthenticationType . BASIC , AuthenticationType . UNIVERSAL ) ) { \nString username = jerseyClientConfig . basicAuth . resolveUsername ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nString password = jerseyClientConfig . basicAuth . resolvePassword ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) { \nJerseyClientUtil . configurePasswordAuth ( jerseyClientConfig . authType , username , password , clientBuilder ) ; \n} \n} \ntry { \nbuildNewAuthenticatedClient ( issues , false ) ; \nclientInitialized = true ; \n} \ncatch ( StageException e ) { \nExceptionUtils . throwUndeclared ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"2238": "public class ScriptTypedNullObject { \npublic static void fillNullTypes ( SimpleBindings bindings ) { \nbindings . put ( \"NULL_BOOLEAN\" , NULL_BOOLEAN ) ; \nbindings . put ( \"NULL_CHAR\" , NULL_CHAR ) ; \nbindings . put ( \"NULL_BYTE\" , NULL_BYTE ) ; \nbindings . put ( \"NULL_SHORT\" , NULL_SHORT ) ; \nbindings . put ( \"NULL_INTEGER\" , NULL_INTEGER ) ; \nbindings . put ( \"NULL_LONG\" , NULL_LONG ) ; \nbindings . put ( \"NULL_FLOAT\" , NULL_FLOAT ) ; \nbindings . put ( \"NULL_DOUBLE\" , NULL_DOUBLE ) ; \nbindings . put ( \"NULL_DATE\" , NULL_DATE ) ; \nbindings . put ( \"NULL_DATETIME\" , NULL_DATETIME ) ; \nbindings . put ( \"NULL_TIME\" , NULL_TIME ) ; \nbindings . put ( \"NULL_DECIMAL\" , NULL_DECIMAL ) ; \nbindings . put ( \"NULL_BYTE_ARRAY\" , NULL_BYTE_ARRAY ) ; \nbindings . put ( \"NULL_STRING\" , NULL_STRING ) ; \nbindings . put ( \"NULL_LIST\" , NULL_LIST ) ; \nbindings . put ( \"NULL_MAP\" , NULL_MAP ) ; \nreturn ; \n} \n} \n"}
{"2249": "public class ClasspathValidatorResult { \npublic void logDetails ( ) { \nif ( isValid ( ) ) { \nreturn ; \n} \nLOG . warn ( \"Validation results for {}\" , name ) ; \nif ( ! unparseablePaths . isEmpty ( ) ) { \nLOG . warn ( \"Can't parse the following artifacts:\" ) ; \nfor ( String path : unparseablePaths ) { \nLOG . warn ( \"  {}\" , path ) ; \n} \n} \nif ( ! versionCollisions . isEmpty ( ) ) { \nLOG . warn ( \"Detected colliding dependency versions:\" ) ; \nfor ( Map . Entry < String , Map < String , List < Dependency > > > entry : versionCollisions . entrySet ( ) ) { \nLOG . warn ( \"  Dependency {} have versions: {}\" , entry . getKey ( ) , StringUtils . join ( entry . getValue ( ) . keySet ( ) , \", \" ) ) ; \nfor ( Map . Entry < String , List < Dependency > > versionEntry : entry . getValue ( ) . entrySet ( ) ) { \nLOG . warn ( \"    Version: {}\" , versionEntry . getKey ( ) ) ; \nfor ( Dependency dependency : versionEntry . getValue ( ) ) { \nLOG . warn ( \"      {}\" , dependency . getSourceName ( ) ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nint waitTime = 1000 ; \nResponse response = null ; \nwhile ( ! stop ) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! root . has ( \"error\" ) ) { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) { \nLOG . warn ( \"Response buffer full, dropped record.\" ) ; \n} \nbreak ; \n} \nelse { \nif ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) { \nwaitTime *= 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \nelse { \nthrow new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \n} \n} \nresponse . close ( ) ; \nreturn ; \n} \n} \n"}
{"2259": "public class SdcClusterOffsetHelper { \nprivate void writeOffsetsToMainOffsetFile ( Map < Integer , Long > partitionToOffsetMap ) throws IOException { \nLOG . info ( \"Saving the following offset {} to {}\" , partitionToOffsetMap , checkPointFilePath ) ; \ntry ( OutputStream os = fs . create ( checkPointMarkerFilePath , true ) ) { \n} \ntry ( OutputStream os = fs . create ( checkPointFilePath , true ) ) { \nOBJECT_MAPPER . writeValue ( os , new ClusterSourceOffsetJson ( serializeKafkaPartitionOffset ( partitionToOffsetMap ) , SDC_STREAMING_OFFSET_VERSION ) ) ; \n} \nboolean deleted = fs . delete ( checkPointMarkerFilePath , false ) ; \nLOG . warn ( \"Status {} for Deleting Marker File {}\" , deleted , checkPointMarkerFilePath ) ; \nlastOffsetStoredTime = System . currentTimeMillis ( ) ; \nreturn ; \n} \n} \n"}
{"2260": "public class GcsObjectPostProcessingHandler { \nprivate void delete ( BlobId blobId ) { \nLOG . debug ( \"Deleting object '{}'\" , String . format ( BLOB_PATH_TEMPLATE , blobId . getBucket ( ) , blobId . getName ( ) ) ) ; \nboolean deleted = storage . delete ( blobId ) ; \nif ( ! deleted ) { \nLOG . error ( \"Cannot delete object '{}'\" , String . format ( BLOB_PATH_TEMPLATE , blobId . getBucket ( ) , blobId . getName ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2261": "public class GcsObjectPostProcessingHandler { \nvoid handleError ( BlobId blobId ) { \nswitch ( gcsOriginErrorConfig . errorHandlingOption ) { \ncase NONE : break ; \ncase ARCHIVE : handleArchive ( blobId ) ; \nbreak ; \ncase DELETE : delete ( blobId ) ; \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"2262": "public class GcsObjectPostProcessingHandler { \nprivate void handleArchive ( BlobId blobId ) { \nString destinationPath = getDestinationPath ( blobId , gcsOriginErrorConfig . errorPrefix ) ; \nswitch ( gcsOriginErrorConfig . archivingOption ) { \ncase COPY_TO_BUCKET : copy ( blobId , gcsOriginErrorConfig . errorBucket , destinationPath , false ) ; \nbreak ; \ncase MOVE_TO_BUCKET : copy ( blobId , gcsOriginErrorConfig . errorBucket , destinationPath , true ) ; \nbreak ; \ncase COPY_TO_PREFIX : copy ( blobId , blobId . getBucket ( ) , destinationPath , false ) ; \nbreak ; \ncase MOVE_TO_PREFIX : copy ( blobId , blobId . getBucket ( ) , destinationPath , true ) ; \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"2264": "public class FileContext { \npublic void releaseReader ( boolean inErrorDiscardReader ) throws IOException { \nUtils . checkState ( open , \"FileContext is closed\" ) ; \nboolean hasNext ; \ntry { \nhasNext = reader != null && reader . hasNext ( ) ; \n} \ncatch ( IOException ex ) { \nIOUtils . closeQuietly ( reader ) ; \nreader = null ; \nhasNext = false ; \n} \nboolean doneWithFile = ! hasNext || inErrorDiscardReader ; \nif ( doneWithFile ) { \nIOUtils . closeQuietly ( reader ) ; \nreader = null ; \nsetStartingCurrentFileName ( currentFile ) ; \nsetStartingOffset ( Long . MAX_VALUE ) ; \nif ( currentFile == null ) { \nreturn ; \n} \nLiveFile file = currentFile . refresh ( ) ; \nif ( inErrorDiscardReader ) { \nLOG . warn ( \"Processing file '{}' produced an error, skipping '{}' post processing on that file\" , file , postProcessing ) ; \neventPublisher . publish ( new FileEvent ( file , FileEvent . Action . ERROR ) ) ; \n} \nelse { \neventPublisher . publish ( new FileEvent ( file , FileEvent . Action . END ) ) ; \nswitch ( postProcessing ) { \ncase NONE : LOG . debug ( \"File '{}' processing completed, post processing action 'NONE'\" , file ) ; \nbreak ; \ncase DELETE : if ( ! inPreviewMode ) { \ntry { \nFiles . delete ( file . getPath ( ) ) ; \nLOG . debug ( \"File '{}' processing completed, post processing action 'DELETED'\" , file ) ; \n} \ncatch ( IOException ex ) { \nthrow new IOException ( Utils . format ( \"Could not delete '{}': {}\" , file , ex . toString ( ) ) , ex ) ; \n} \n} \nbreak ; \ncase ARCHIVE : if ( ! inPreviewMode ) { \nPath fileArchive = Paths . get ( archiveDir , file . getPath ( ) . toString ( ) ) ; \nif ( fileArchive == null ) { \nthrow new IOException ( \"Could not find archive file\" ) ; \n} \ntry { \nFiles . createDirectories ( fileArchive . getParent ( ) ) ; \nFiles . move ( file . getPath ( ) , fileArchive ) ; \nLOG . debug ( \"File '{}' processing completed, post processing action 'ARCHIVED' as\" , file ) ; \n} \ncatch ( IOException ex ) { \nthrow new IOException ( Utils . format ( \"Could not archive '{}': {}\" , file , ex . toString ( ) ) , ex ) ; \n} \n} \nbreak ; \n} \n} \n} \nelse { \nsetStartingCurrentFileName ( currentFile ) ; \nsetStartingOffset ( getReader ( ) . getOffset ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2271": "public class KineticaHelper { \nprivate void getTableMetadata ( GPUdb gpudb , String tableName ) throws GPUdbException { \nKineticaTableUtils kineticaTableUtils = new KineticaTableUtils ( gpudb , tableName ) ; \ntype = kineticaTableUtils . getType ( ) ; \nreturn ; \n} \n} \n"}
{"2276": "public class MapreduceUtils { \npublic static void addJarsToJob ( Configuration conf , Class ... klasses ) { \nSet < String > additinonalJars = new HashSet < > ( ) ; \nfor ( Class klass : klasses ) { \nfinal String jar = jarForClass ( klass ) ; \nLOG . info ( \"Adding jar {} for class {}\" , jar , klass . getCanonicalName ( ) ) ; \nadditinonalJars . add ( jar ) ; \n} \nappendJars ( conf , additinonalJars ) ; \nreturn ; \n} \n} \n"}
{"2277": "public class MapreduceUtils { \npublic static void addJarsToJob ( Configuration conf , boolean allowMultiple , String ... jarPatterns ) { \nfinal ClassLoader loader = MapreduceUtils . class . getClassLoader ( ) ; \nif ( ! ( loader instanceof URLClassLoader ) ) { \nthrow new IllegalStateException ( String . format ( \"ClassLoader for %s is not an instance of URLClassLoader (it is %s), and thus this method cannot be used\" , MapreduceUtils . class . getCanonicalName ( ) , loader . getClass ( ) . getCanonicalName ( ) ) ) ; \n} \nfinal URLClassLoader urlClassLoader = ( URLClassLoader ) loader ; \naddJarsToJob ( conf , allowMultiple , urlClassLoader . getURLs ( ) , jarPatterns ) ; \nreturn ; \n} \n} \n"}
{"2281": "public class BootstrapMain { \npublic static void premain ( String args , Instrumentation instrumentation ) { \nif ( BootstrapMain . instrumentation == null ) { \nBootstrapMain . instrumentation = instrumentation ; \n} \nelse { \nthrow new IllegalStateException ( \"Premain method cannot be called twice (\" + BootstrapMain . instrumentation + \")\" ) ; \n} \nreturn ; \n} \n} \n"}
{"2286": "public class KineticaTableUtils { \nprivate void validateTableAcceptsInserts ( ) throws GPUdbException { \nfor ( String s : tableDescription ) { \nif ( s . equalsIgnoreCase ( \"COLLECTION\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Collection\" ) ; \n} \nelse if ( s . equalsIgnoreCase ( \"VIEW\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a View\" ) ; \n} \nelse if ( s . equalsIgnoreCase ( \"JOIN\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Join Table\" ) ; \n} \nelse if ( s . equalsIgnoreCase ( \"RESULT_TABLE\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Result Table\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2292": "public class AerospikeBeanConfig { \npublic void init ( Target . Context context , List < Target . ConfigIssue > issues ) { \nList < Host > hosts = getAerospikeHosts ( issues , connectionString , Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , context ) ; \nClientPolicy cp = new ClientPolicy ( ) ; \ntry { \nclient = new AerospikeClient ( cp , hosts . toArray ( new Host [ hosts . size ( ) ] ) ) ; \nint retries = 0 ; \nwhile ( ! client . isConnected ( ) && retries <= maxRetries ) { \nif ( retries > maxRetries ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \nreturn ; \n} \nretries ++ ; \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException ignored ) { \n} \n} \n} \ncatch ( AerospikeException ex ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2294": "public class JmsSourceUpgrader { \nprivate static void upgradeV5ToV6 ( List < Config > configs , Context context ) { \nList < Config > dataFormatConfigs = configs . stream ( ) . filter ( c -> c . getName ( ) . startsWith ( \"dataFormat\" ) ) . collect ( Collectors . toList ( ) ) ; \nconfigs . removeAll ( dataFormatConfigs ) ; \nif ( dataFormatConfigs . stream ( ) . noneMatch ( c -> \"dataFormatConfig.compression\" . equals ( c . getName ( ) ) ) ) { \ndataFormatConfigs . add ( new Config ( \"dataFormatConfig.compression\" , \"NONE\" ) ) ; \n} \ncontext . registerService ( DataFormatParserService . class , dataFormatConfigs ) ; \nreturn ; \n} \n} \n"}
{"2295": "public class DataStore { \npublic InputStream getInputStream ( ) throws IOException { \nacquireLock ( ) ; \ntry { \nisClosed = false ; \nforWrite = false ; \nLOG . trace ( \"Starts read '{}'\" , file ) ; \nverifyAndRecover ( ) ; \nInputStream is = new ProxyInputStream ( new FileInputStream ( file . toFile ( ) ) ) { \n@ Override public void close ( ) throws IOException { \nif ( isClosed ) { \nreturn ; \n} \ntry { \nsuper . close ( ) ; \n} \nfinally { \nrelease ( ) ; \nisClosed = true ; \nstream = null ; \n} \nLOG . trace ( \"Finishes read '{}'\" , file ) ; \nreturn ; \n} \n} \n; \nstream = is ; \nreturn is ; \n} \ncatch ( Exception ex ) { \nrelease ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2296": "public class DataStore { \npublic OutputStream getOutputStream ( ) throws IOException { \nacquireLock ( ) ; \ntry { \nisClosed = false ; \nforWrite = true ; \nLOG . trace ( \"Starts write '{}'\" , file ) ; \nverifyAndRecover ( ) ; \nif ( Files . exists ( file ) ) { \nFiles . move ( file , fileOld ) ; \nLOG . trace ( \"Starting write, move '{}' to '{}'\" , file , fileOld ) ; \n} \nOutputStream os = new ProxyOutputStream ( new FileOutputStream ( fileTmp . toFile ( ) ) ) { \n@ Override public void close ( ) throws IOException { \nif ( isClosed ) { \nreturn ; \n} \ntry { \nsuper . close ( ) ; \n} \nfinally { \nisClosed = true ; \nstream = null ; \n} \nLOG . trace ( \"Finishes write '{}'\" , file ) ; \nreturn ; \n} \n} \n; \nstream = os ; \nreturn os ; \n} \ncatch ( Exception ex ) { \nrelease ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2299": "public class ClassLoaderStageLibraryTask { \nprivate void validateAllServicesAvailable ( ) { \nList < String > missingServices = new LinkedList < > ( ) ; \nfor ( StageDefinition stage : stageList ) { \nfor ( ServiceDependencyDefinition service : stage . getServices ( ) ) { \nif ( ! serviceMap . containsKey ( service . getService ( ) ) ) { \nmissingServices . add ( Utils . format ( \"Stage {} is missing service {}\" , stage . getName ( ) , service . getService ( ) . getName ( ) ) ) ; \n} \n} \n} \nif ( ! missingServices . isEmpty ( ) ) { \nthrow new RuntimeException ( \"Missing services: \" + StringUtils . join ( missingServices , \", \" ) ) ; \n} \nList < String > unsupportedServices = new LinkedList < > ( ) ; \nfor ( ServiceDefinition serviceDefinition : serviceList ) { \nif ( ! ServiceRuntime . supports ( serviceDefinition . getProvides ( ) ) ) { \nunsupportedServices . add ( serviceDefinition . getProvides ( ) . toString ( ) ) ; \n} \n} \nif ( ! unsupportedServices . isEmpty ( ) ) { \nthrow new RuntimeException ( \"Unsupported services: \" + StringUtils . join ( unsupportedServices , \", \" ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2304": "public class Aggregators { \npublic void start ( long newDataWindowEndTimeMillis ) { \nUtils . checkState ( ! started , \"Already started\" ) ; \nUtils . checkState ( ! stopped , \"Already stopped\" ) ; \ndataProvider . start ( newDataWindowEndTimeMillis ) ; \nstarted = true ; \nreturn ; \n} \n} \n"}
{"2308": "public class LoginManager { \npublic void release ( ) { \nsynchronized ( LoginManager . class ) { \nif ( refCount == 0 ) throw new IllegalStateException ( \"release called on LoginManager with refCount == 0\" ) ; \nelse if ( refCount == 1 ) { \nCACHED_INSTANCES . remove ( loginType ) ; \nlogin . shutdown ( ) ; \n} \n-- refCount ; \n} \nreturn ; \n} \n} \n"}
{"2311": "public class ProductionPipelineRunner { \npublic void stop ( ) throws PipelineException { \nthis . stop = true ; \nif ( batchesToCapture > 0 ) { \ncancelSnapshot ( this . snapshotName ) ; \nsnapshotStore . deleteSnapshot ( pipelineName , revision , snapshotName ) ; \n} \nreturn ; \n} \n} \n"}
{"2313": "public class ProductionPipelineRunner { \nprivate void createFailureBatch ( FullPipeBatch pipeBatch ) { \nif ( ! pipelineConfigBean . shouldCreateFailureSnapshot ) { \nreturn ; \n} \ntry { \nfor ( SnapshotInfo info : snapshotStore . getSummaryForPipeline ( pipelineName , revision ) ) { \nif ( info . isFailureSnapshot ( ) ) { \nLOG . trace ( \"Skipping creation of failure snapshot as {} already exists.\" , info . getId ( ) ) ; \nreturn ; \n} \n} \nString snapshotName = \"Failure_\" + UUID . randomUUID ( ) . toString ( ) ; \nString snapshotLabel = \"Failure at \" + LocalDateTime . now ( ) . toString ( ) ; \nsnapshotStore . create ( \"\" , pipelineName , revision , snapshotName , snapshotLabel , true ) ; \nsnapshotStore . save ( pipelineName , revision , snapshotName , - 1 , ImmutableList . of ( pipeBatch . createFailureSnapshot ( ) ) ) ; \n} \ncatch ( PipelineException ex ) { \nLOG . error ( \"Can't serialize failure snapshot\" , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"2315": "public class Configuration { \npublic void set ( Map < String , String > newConfiguration ) { \nfor ( Map . Entry < String , String > entry : newConfiguration . entrySet ( ) ) { \nif ( entry . getValue ( ) == null ) { \nthis . unset ( entry . getKey ( ) ) ; \n} \nelse { \nthis . set ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff && ! partitioningTurnedOn ) { \ncontinue ; \n} \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal int newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( partitioningTurnedOff ) { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nelse if ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { \nthrow new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \n} \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \nreturn ; \n} \n} \n"}
{"2320": "public class SchAdmin { \npublic static void enableDPM ( DPMInfoJson dpmInfo , Context context ) throws IOException { \nUtils . checkNotNull ( dpmInfo , \"DPMInfo\" ) ; \nString dpmBaseURL = normalizeDpmBaseURL ( dpmInfo . getBaseURL ( ) ) ; \nString currentDPMBaseURL = context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , \"\" ) ; \nString currentAppAuthToken = context . configuration . get ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , \"\" ) . trim ( ) ; \nif ( ! currentDPMBaseURL . equals ( dpmBaseURL ) || currentAppAuthToken . length ( ) == 0 ) { \nString userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; \nString appAuthToken = null ; \nResponse response = null ; \ntry { \nMap < String , Object > newComponentJson = new HashMap < > ( ) ; \nnewComponentJson . put ( \"organization\" , dpmInfo . getOrganization ( ) ) ; \nnewComponentJson . put ( \"componentType\" , \"dc\" ) ; \nnewComponentJson . put ( \"numberOfComponents\" , 1 ) ; \nnewComponentJson . put ( \"active\" , true ) ; \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/rest/v1/organization/\" + dpmInfo . getOrganization ( ) + \"/components\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) { \nthrow new RuntimeException ( Utils . format ( \"DPM Create Application Token failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \n} \nList < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { \n} \n) ; \nif ( newComponent . size ( ) > 0 ) { \nappAuthToken = ( String ) newComponent . get ( 0 ) . get ( \"fullAuthToken\" ) ; \n} \nelse { \nthrow new RuntimeException ( \"DPM Create Application Token failed: No token data from DPM Server.\" ) ; \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \nlogout ( dpmBaseURL , userAuthToken ) ; \n} \nupdateTokenFile ( context , appAuthToken ) ; \n} \nupdateDpmProperties ( context , dpmBaseURL , dpmInfo . getLabels ( ) , true ) ; \nreturn ; \n} \n} \n"}
{"2321": "public class SchAdmin { \npublic static void disableDPM ( String username , String password , String organizationId , Context context ) throws IOException { \nString dpmBaseURL = normalizeDpmBaseURL ( context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , \"\" ) ) ; \nString userToken = retrieveUserToken ( dpmBaseURL , username , password ) ; \ntry { \ndisableDPM ( userToken , organizationId , context ) ; \n} \nfinally { \nlogout ( dpmBaseURL , userToken ) ; \n} \nreturn ; \n} \n} \n"}
{"2324": "public class SchAdmin { \nprivate static void logout ( String dpmBaseURL , String userAuthToken ) { \nResponse response = null ; \ntry { \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/_logout\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . cookie ( SSOConstants . AUTHENTICATION_COOKIE_PREFIX + \"LOGIN\" , userAuthToken ) . get ( ) ; \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2325": "public class SchAdmin { \nprivate static void updateTokenFile ( Context context , String appAuthToken ) throws IOException { \nFile tokenFile = context . tokenFilePath == null ? new File ( context . runtimeInfo . getConfigDir ( ) , APP_TOKEN_FILE ) : new File ( context . tokenFilePath ) ; \nDataStore dataStore = new DataStore ( tokenFile ) ; \ntry ( OutputStream os = dataStore . getOutputStream ( ) ) { \nIOUtils . write ( appAuthToken , os ) ; \ndataStore . commit ( os ) ; \n} \nfinally { \ndataStore . release ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2326": "public class SchAdmin { \nprivate static void updateDpmProperties ( Context context , String dpmBaseURL , List < String > labels , boolean enableSch ) { \nif ( context . skipUpdatingDpmProperties ) { \nreturn ; \n} \ntry { \nFileBasedConfigurationBuilder < PropertiesConfiguration > builder = new FileBasedConfigurationBuilder < > ( PropertiesConfiguration . class ) . configure ( new Parameters ( ) . properties ( ) . setFileName ( context . runtimeInfo . getConfigDir ( ) + \"/dpm.properties\" ) . setThrowExceptionOnMissing ( true ) . setListDelimiterHandler ( new DefaultListDelimiterHandler ( ';' ) ) . setIncludesAllowed ( false ) ) ; \nPropertiesConfiguration config = null ; \nconfig = builder . getConfiguration ( ) ; \nconfig . setProperty ( RemoteSSOService . DPM_ENABLED , Boolean . toString ( enableSch ) ) ; \nconfig . setProperty ( RemoteSSOService . DPM_BASE_URL_CONFIG , dpmBaseURL ) ; \nconfig . setProperty ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , APP_TOKEN_FILE_PROP_VAL ) ; \nif ( labels != null && labels . size ( ) > 0 ) { \nconfig . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , StringUtils . join ( labels , ',' ) ) ; \n} \nelse { \nconfig . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , \"\" ) ; \n} \nbuilder . save ( ) ; \n} \ncatch ( ConfigurationException e ) { \nthrow new RuntimeException ( Utils . format ( \"Updating dpm.properties file failed: {}\" , e . getMessage ( ) ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2331": "public class FileRefUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static synchronized void initMetricsIfNeeded ( ProtoConfigurableEntity . Context context ) { \nGauge < Map < String , Object > > gauge = context . getGauge ( fileStatisticGaugeName ( context ) ) ; \nif ( gauge == null ) { \ngauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; \nMap < String , Object > gaugeStatistics = gauge . getValue ( ) ; \ngaugeStatistics . put ( FileRefUtil . FILE , \"\" ) ; \ngaugeStatistics . put ( FileRefUtil . TRANSFER_THROUGHPUT , 0L ) ; \ngaugeStatistics . put ( FileRefUtil . SENT_BYTES , String . format ( FileRefUtil . BRACKETED_TEMPLATE , 0 , 0 ) ) ; \ngaugeStatistics . put ( FileRefUtil . REMAINING_BYTES , 0L ) ; \ngaugeStatistics . put ( FileRefUtil . COMPLETED_FILE_COUNT , 0L ) ; \n} \nMeter dataTransferMeter = context . getMeter ( FileRefUtil . TRANSFER_THROUGHPUT_METER ) ; \nif ( dataTransferMeter == null ) { \ncontext . createMeter ( FileRefUtil . TRANSFER_THROUGHPUT_METER ) ; \n} \nreturn ; \n} \n} \n"}
{"2341": "public class JMXJsonServlet { \n@ Override public void doGet ( HttpServletRequest request , HttpServletResponse response ) { \ntry { \nJsonGenerator jg = null ; \nString jsonpcb = null ; \nPrintWriter writer = null ; \ntry { \nwriter = response . getWriter ( ) ; \njsonpcb = request . getParameter ( CALLBACK_PARAM ) ; \nif ( jsonpcb != null ) { \nresponse . setContentType ( \"application/javascript; charset=utf8\" ) ; \nwriter . write ( jsonpcb + \"(\" ) ; \n} \nelse { \nresponse . setContentType ( \"application/json; charset=utf8\" ) ; \n} \njg = jsonFactory . createGenerator ( writer ) ; \njg . disable ( JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ; \njg . useDefaultPrettyPrinter ( ) ; \njg . writeStartObject ( ) ; \nString getmethod = request . getParameter ( \"get\" ) ; \nif ( getmethod != null ) { \nString [ ] splitStrings = getmethod . split ( \"\\\\:\\\\:\" ) ; \nif ( splitStrings . length != 2 ) { \njg . writeStringField ( \"result\" , \"ERROR\" ) ; \njg . writeStringField ( \"message\" , \"query format is not as expected.\" ) ; \njg . flush ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nlistBeans ( jg , new ObjectName ( splitStrings [ 0 ] ) , splitStrings [ 1 ] , response ) ; \nreturn ; \n} \nString qry = request . getParameter ( \"qry\" ) ; \nif ( qry == null ) { \nqry = \"*:*\" ; \n} \nlistBeans ( jg , new ObjectName ( qry ) , null , response ) ; \n} \nfinally { \nif ( jg != null ) { \njg . close ( ) ; \n} \nif ( jsonpcb != null ) { \nwriter . write ( \");\" ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \n} \n} \ncatch ( IOException e ) { \nresponse . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; \n} \ncatch ( MalformedObjectNameException e ) { \nresponse . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; \n} \nreturn ; \n} \n} \n"}
{"2350": "public class JdbcBaseRecordWriter { \nvoid lookupPrimaryKeys ( ) throws StageException { \nConnection connection = null ; \ntry { \nconnection = dataSource . getConnection ( ) ; \nprimaryKeyColumns = jdbcUtil . getPrimaryKeys ( connection , schema , tableName ) ; \n} \ncatch ( SQLException e ) { \nString formattedError = jdbcUtil . formatSqlException ( e ) ; \nLOG . error ( formattedError , e ) ; \nthrow new StageException ( JdbcErrors . JDBC_17 , tableName , formattedError ) ; \n} \nfinally { \nif ( connection != null ) { \ntry { \nconnection . close ( ) ; \n} \ncatch ( SQLException e ) { \nString formattedError = jdbcUtil . formatSqlException ( e ) ; \nLOG . error ( formattedError , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2351": "public class JdbcBaseRecordWriter { \nprivate void createCustomFieldMappings ( ) { \nfor ( JdbcFieldColumnParamMapping mapping : customMappings ) { \nLOG . debug ( \"Custom mapping field {} to column {}\" , mapping . field , mapping . columnName ) ; \nif ( columnsToFields . containsKey ( mapping . columnName ) ) { \nLOG . debug ( \"Mapping field {} to column {}\" , mapping . field , mapping . columnName ) ; \ncolumnsToFields . put ( mapping . columnName , mapping . field ) ; \ncolumnsToParameters . put ( mapping . columnName , mapping . paramValue ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2355": "public class JdbcBaseRecordWriter { \nvoid handleSqlException ( SQLException e ) throws StageException { \nString formattedError = jdbcUtil . formatSqlException ( e ) ; \nLOG . error ( formattedError , e ) ; \nthrow new StageException ( JdbcErrors . JDBC_14 , e . getSQLState ( ) , e . getErrorCode ( ) , e . getMessage ( ) , formattedError , e ) ; \nreturn ; \n} \n} \n"}
{"2356": "public class SourcePipe { \npublic void process ( Map < String , String > offsets , int batchSize , ReportErrorDelegate reportErrorDelegate ) throws StageException , PipelineRuntimeException { \nthis . reportErrorDelegate = reportErrorDelegate ; \ngetStage ( ) . setReportErrorDelegate ( this ) ; \ntry { \nMDC . put ( LogConstants . STAGE , getStage ( ) . getInfo ( ) . getInstanceName ( ) ) ; \ngetStage ( ) . execute ( offsets , batchSize ) ; \n} \nfinally { \nMDC . put ( LogConstants . STAGE , \"\" ) ; \n} \nreturn ; \n} \n} \n"}
{"2357": "public class SourcePipe { \npublic void prepareBatchContext ( BatchContextImpl batchContext ) { \nPipeBatch pipeBatch = batchContext . getPipeBatch ( ) ; \nBatchMakerImpl batchMaker = pipeBatch . startStage ( this ) ; \nbatchContext . setBatchMaker ( batchMaker ) ; \nbatchContext . setOriginStageName ( getStage ( ) . getInfo ( ) . getInstanceName ( ) , getStage ( ) . getInfo ( ) . getLabel ( ) ) ; \nreturn ; \n} \n} \n"}
{"2361": "public class SampleExecutor { \nprivate void execute ( Record record ) throws OnRecordErrorException { \nif ( ! record . has ( \"/someField\" ) ) { \nthrow new OnRecordErrorException ( Errors . SAMPLE_01 , record , \"exception detail message.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"2373": "public class BootstrapClusterStreaming { \npublic static void main ( String [ ] args ) throws Exception { \nSparkStreamingBinding binding = null ; \ntry { \nbinding = SparkStreamingBindingFactory . build ( BootstrapCluster . getProperties ( ) ) ; \nbinding . init ( ) ; \nBootstrapCluster . createTransformers ( binding . getStreamingContext ( ) . sparkContext ( ) , binding . getSparkSession ( ) ) ; \nbinding . startContext ( ) ; \nbinding . awaitTermination ( ) ; \n} \ncatch ( Throwable error ) { \nString msg = \"Error trying to invoke BootstrapClusterStreaming.main: \" + error ; \nSystem . err . println ( new Date ( ) + \": \" + msg ) ; \nerror . printStackTrace ( System . err ) ; \nLOG . error ( msg , error ) ; \nthrow new IllegalStateException ( msg , error ) ; \n} \nfinally { \ntry { \nif ( binding != null ) { \nbinding . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . warn ( \"Error on binding close: \" + ex , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2374": "public class PipelineConfigurationValidator { \nprivate void propagateRuntimeConfiguration ( ) { \nif ( pipelineBean == null || pipelineBean . getPipelineStageBeans ( ) == null ) { \nreturn ; \n} \nfor ( StageBean stageBean : pipelineBean . getPipelineStageBeans ( ) . getStages ( ) ) { \nfor ( ServiceDependencyDefinition serviceDependency : stageBean . getDefinition ( ) . getServices ( ) ) { \nServiceBean stageService = stageBean . getService ( serviceDependency . getService ( ) ) ; \nif ( stageService == null ) { \ncontinue ; \n} \nServiceConfiguration serviceConfiguration = stageService . getConf ( ) ; \nList < Config > configs = serviceConfiguration . getConfiguration ( ) ; \nconfigs . removeAll ( serviceDependency . getConfiguration ( ) . keySet ( ) . stream ( ) . map ( serviceConfiguration :: getConfig ) . collect ( Collectors . toList ( ) ) ) ; \nserviceDependency . getConfiguration ( ) . forEach ( ( key , value ) -> configs . add ( new Config ( key , value ) ) ) ; \nserviceConfiguration . setConfig ( configs ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2375": "public class OmnitureSource { \nprivate void validateReportDescription ( List < ConfigIssue > issues ) { \nif ( ! jsonMapper . isValidJson ( this . reportDescription ) ) { \nissues . add ( getContext ( ) . createConfigIssue ( Groups . REPORT . name ( ) , \"reportDescription\" , Errors . OMNITURE_03 ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2378": "public class BigQueryTargetUpgrader { \nprivate void upgradeV1toV2 ( List < Config > configs ) { \nconfigs . removeIf ( config -> ( config . getName ( ) . equals ( IMPLICIT_FIELD_MAPPING_CONFIG ) || config . getName ( ) . equals ( BIG_QUERY_IMPLICIT_FIELD_MAPPING_CONFIG ) ) ) ; \nconfigs . add ( new Config ( MAX_CACHE_SIZE , - 1 ) ) ; \nreturn ; \n} \n} \n"}
{"2380": "public class ControlChannel { \npublic void consumerCommit ( String offset ) { \nObject offsetValue = offset ; \nif ( offsetValue == null ) { \noffsetValue = new NullOffset ( ) ; \n} \nLOG . trace ( \"Commit Offset: '{}'\" , offsetValue ) ; \ntry { \nproducerQueue . put ( new Message ( MessageType . CONSUMER_COMMIT , offsetValue ) ) ; \n} \ncatch ( InterruptedException e ) { \nLOG . info ( \"Interrupted while queuing '{}'\" , MessageType . CONSUMER_COMMIT . name ( ) , offsetValue ) ; \nThread . currentThread ( ) . interrupt ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2382": "public class MongoDBProcessor { \nprivate void setFieldsInRecord ( Record record , Map < String , Field > fields ) { \nrecord . set ( configBean . resultField , Field . createListMap ( new LinkedHashMap < > ( fields ) ) ) ; \nreturn ; \n} \n} \n"}
{"2388": "public class WholeFileTransformerProcessor { \nprivate void validateRecord ( Record record ) throws StageException { \ntry { \nFileRefUtil . validateWholeFileRecord ( record ) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new TransformerStageCheckedException ( Errors . CONVERT_01 , e . toString ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2389": "public class WholeFileTransformerProcessor { \nprivate void handleOldTempFiles ( Path tempParquetFile ) throws IOException { \nif ( tempParquetFile == null ) { \nLOG . warn ( \"temporary parquet file is empty\" ) ; \nreturn ; \n} \nFiles . deleteIfExists ( tempParquetFile ) ; \nreturn ; \n} \n} \n"}
{"2392": "public class WholeFileTransformerProcessor { \nprivate void writeParquet ( String sourceFileName , DataFileStream < GenericRecord > fileReader , Path tempParquetFile ) throws StageException { \nlong recordCount = 0 ; \nGenericRecord avroRecord ; \nSchema schema = fileReader . getSchema ( ) ; \nLOG . debug ( \"Start reading input file : {}\" , sourceFileName ) ; \ntry { \nConfiguration jobConfiguration = new Configuration ( ) ; \nString compressionCodecName = compressionElEval . eval ( variables , jobConfig . avroParquetConfig . compressionCodec , String . class ) ; \njobConfiguration . set ( AvroParquetConstants . COMPRESSION_CODEC_NAME , compressionCodecName ) ; \njobConfiguration . setInt ( AvroParquetConstants . ROW_GROUP_SIZE , jobConfig . avroParquetConfig . rowGroupSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . PAGE_SIZE , jobConfig . avroParquetConfig . pageSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . DICTIONARY_PAGE_SIZE , jobConfig . avroParquetConfig . dictionaryPageSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . MAX_PADDING_SIZE , jobConfig . avroParquetConfig . maxPaddingSize ) ; \nParquetWriter . Builder builder = AvroToParquetConverterUtil . initializeWriter ( new org . apache . hadoop . fs . Path ( tempParquetFile . toString ( ) ) , schema , jobConfiguration ) ; \nparquetWriter = builder . build ( ) ; \nwhile ( fileReader . hasNext ( ) ) { \navroRecord = fileReader . next ( ) ; \nparquetWriter . write ( avroRecord ) ; \nrecordCount ++ ; \n} \nparquetWriter . close ( ) ; \n} \ncatch ( IOException ex ) { \nthrow new TransformerStageCheckedException ( Errors . CONVERT_08 , sourceFileName , recordCount , ex ) ; \n} \nLOG . debug ( \"Finished writing {} records to {}\" , recordCount , tempParquetFile . getFileName ( ) ) ; \nreturn ; \n} \n} \n"}
{"2402": "public class DataFormatUpgradeHelper { \npublic static void ensureAvroSchemaExists ( List < Config > configs , String prefix ) { \nOptional < Config > avroSchema = findByName ( configs , \"avroSchema\" ) ; \nif ( ! avroSchema . isPresent ( ) ) { \nconfigs . add ( new Config ( prefix + \".avroSchema\" , null ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2408": "public class HiveQueryExecutor { \npublic void executeAlterTableAddPartitionQuery ( String qualifiedTableName , LinkedHashMap < String , String > partitionNameValueMap , Map < String , HiveTypeInfo > partitionTypeMap , String partitionPath ) throws StageException { \nString sql = buildPartitionAdditionQuery ( qualifiedTableName , partitionNameValueMap , partitionTypeMap , partitionPath ) ; \nexecute ( sql ) ; \nreturn ; \n} \n} \n"}
{"2409": "public class HiveQueryExecutor { \npublic void executeAlterTableSetTblPropertiesQuery ( String qualifiedTableName , String partitionPath ) throws StageException { \nString sql = buildSetTablePropertiesQuery ( qualifiedTableName , partitionPath ) ; \nexecute ( sql ) ; \nreturn ; \n} \n} \n"}
{"2411": "public class HiveQueryExecutor { \nprivate void execute ( String query ) throws StageException { \nLOG . debug ( \"Executing SQL: {}\" , query ) ; \nTimer . Context t = updateTimer . time ( ) ; \ntry ( Statement statement = hiveConfigBean . getHiveConnection ( ) . createStatement ( ) ) { \nstatement . execute ( query ) ; \n} \ncatch ( Exception e ) { \nLOG . error ( \"Exception while processing query: {}\" , query , e ) ; \nthrow new HiveStageCheckedException ( Errors . HIVE_20 , query , e . getMessage ( ) ) ; \n} \nfinally { \nlong time = t . stop ( ) ; \nLOG . debug ( \"Query '{}' took {} nanoseconds\" , query , time ) ; \nupdateMeter . mark ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2413": "public class PipeRunner { \npublic void executeBatch ( String offsetKey , String offsetValue , long batchStartTime , ThrowingConsumer < Pipe > consumer ) throws PipelineRuntimeException , StageException { \nMDC . put ( LogConstants . RUNNER , String . valueOf ( runnerId ) ) ; \nthis . runtimeMetricGauge . put ( METRIC_BATCH_START_TIME , batchStartTime ) ; \nthis . runtimeMetricGauge . put ( METRIC_OFFSET_KEY , Optional . ofNullable ( offsetKey ) . orElse ( \"\" ) ) ; \nthis . runtimeMetricGauge . put ( METRIC_OFFSET_VALUE , Optional . ofNullable ( offsetValue ) . orElse ( \"\" ) ) ; \nthis . runtimeMetricGauge . put ( METRIC_STAGE_START_TIME , System . currentTimeMillis ( ) ) ; \ntry { \nfor ( Pipe p : pipes ) { \nString instanceName = p . getStage ( ) . getInfo ( ) . getInstanceName ( ) ; \nthis . runtimeMetricGauge . put ( METRIC_CURRENT_STAGE , instanceName ) ; \nMDC . put ( LogConstants . STAGE , instanceName ) ; \nif ( p instanceof StagePipe ) { \nthis . runtimeMetricGauge . put ( METRIC_STAGE_START_TIME , System . currentTimeMillis ( ) ) ; \n} \nacceptConsumer ( consumer , p ) ; \n} \nthis . runtimeMetricGauge . computeIfPresent ( METRIC_BATCH_COUNT , ( key , value ) -> ( ( long ) value ) + 1 ) ; \n} \nfinally { \nresetBatchSpecificMetrics ( ) ; \nMDC . put ( LogConstants . RUNNER , \"\" ) ; \nMDC . put ( LogConstants . STAGE , \"\" ) ; \n} \nreturn ; \n} \n} \n"}
{"2414": "public class PipeRunner { \npublic void forEach ( ThrowingConsumer < Pipe > consumer ) { \ntry { \nMDC . put ( LogConstants . RUNNER , String . valueOf ( runnerId ) ) ; \ntry { \nfor ( Pipe p : pipes ) { \nMDC . put ( LogConstants . STAGE , p . getStage ( ) . getInfo ( ) . getInstanceName ( ) ) ; \nacceptConsumer ( consumer , p ) ; \n} \n} \nfinally { \nMDC . put ( LogConstants . RUNNER , \"\" ) ; \nMDC . put ( LogConstants . STAGE , \"\" ) ; \n} \n} \ncatch ( PipelineException | StageException e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"2417": "public class PipeRunner { \nprivate void acceptConsumer ( ThrowingConsumer < Pipe > consumer , Pipe p ) throws PipelineRuntimeException , StageException { \ntry { \nconsumer . accept ( p ) ; \n} \ncatch ( Throwable t ) { \nString instanceName = p . getStage ( ) . getInfo ( ) . getInstanceName ( ) ; \nLOG . error ( \"Failed executing stage '{}': {}\" , instanceName , t . toString ( ) , t ) ; \nThrowables . propagateIfInstanceOf ( t , PipelineRuntimeException . class ) ; \nThrowables . propagateIfInstanceOf ( t , StageException . class ) ; \nThrowables . propagate ( t ) ; \n} \nreturn ; \n} \n} \n"}
{"2423": "public class AmazonS3Runnable { \nprivate void handleWholeFileDataFormat ( S3ObjectSummary s3ObjectSummary , String recordId ) throws StageException { \nS3Object partialS3ObjectForMetadata ; \npartialS3ObjectForMetadata = AmazonS3Util . getObjectRange ( s3Client , s3ConfigBean . s3Config . bucket , s3ObjectSummary . getKey ( ) , 1 , s3ConfigBean . sseConfig . useCustomerSSEKey , s3ConfigBean . sseConfig . customerKey , s3ConfigBean . sseConfig . customerKeyMd5 ) ; \nS3FileRef . Builder s3FileRefBuilder = new S3FileRef . Builder ( ) . s3Client ( s3Client ) . s3ObjectSummary ( s3ObjectSummary ) . useSSE ( s3ConfigBean . sseConfig . useCustomerSSEKey ) . customerKey ( s3ConfigBean . sseConfig . customerKey ) . customerKeyMd5 ( s3ConfigBean . sseConfig . customerKeyMd5 ) . bufferSize ( ( int ) dataParser . suggestedWholeFileBufferSize ( ) ) . createMetrics ( true ) . totalSizeInBytes ( s3ObjectSummary . getSize ( ) ) . rateLimit ( dataParser . wholeFileRateLimit ( ) ) ; \nif ( dataParser . isWholeFileChecksumRequired ( ) ) { \ns3FileRefBuilder . verifyChecksum ( true ) . checksumAlgorithm ( HashingUtil . HashType . MD5 ) . checksum ( partialS3ObjectForMetadata . getObjectMetadata ( ) . getETag ( ) ) ; \n} \nMap < String , Object > metadata = AmazonS3Util . getMetaData ( partialS3ObjectForMetadata ) ; \nmetadata . put ( S3Constants . BUCKET , s3ObjectSummary . getBucketName ( ) ) ; \nmetadata . put ( S3Constants . OBJECT_KEY , s3ObjectSummary . getKey ( ) ) ; \nmetadata . put ( S3Constants . OWNER , s3ObjectSummary . getOwner ( ) ) ; \nmetadata . put ( S3Constants . SIZE , s3ObjectSummary . getSize ( ) ) ; \nmetadata . put ( HeaderAttributeConstants . FILE_NAME , s3ObjectSummary . getKey ( ) ) ; \nmetadata . remove ( S3Constants . CONTENT_LENGTH ) ; \nparser = dataParser . getParser ( recordId , metadata , s3FileRefBuilder . build ( ) ) ; \nobject = partialS3ObjectForMetadata ; \nreturn ; \n} \n} \n"}
{"2426": "public class HeaderImpl { \npublic void setStageCreator ( String stateCreator ) { \nPreconditions . checkNotNull ( stateCreator , \"stateCreator cannot be null\" ) ; \nmap . put ( STAGE_CREATOR_INSTANCE_ATTR , stateCreator ) ; \nreturn ; \n} \n} \n"}
{"2427": "public class SecurityContext { \npublic synchronized void logout ( ) { \nif ( subject != null ) { \nLOG . debug ( \"Logout. Kerberos enabled '{}', Principal '{}'\" , securityConfiguration . isKerberosEnabled ( ) , subject . getPrincipals ( ) ) ; \nif ( loginContext != null ) { \ntry { \nloginContext . logout ( ) ; \n} \ncatch ( LoginException ex ) { \nLOG . warn ( \"Error while doing logout from Kerberos: {}\" , ex . toString ( ) , ex ) ; \n} \nfinally { \nloginContext = null ; \n} \n} \nsubject = null ; \n} \nreturn ; \n} \n} \n"}
{"2428": "public class SdcSecurityManager { \nprivate void setExceptions ( Configuration configuration ) { \nthis . exceptions . clear ( ) ; \nthis . stageLibExceptions . clear ( ) ; \nfor ( String path : configuration . get ( PROPERTY_EXCEPTIONS , \"\" ) . split ( \",\" ) ) { \nthis . exceptions . add ( replaceVariables ( path ) ) ; \n} \nConfiguration stageSpecific = configuration . getSubSetConfiguration ( PROPERTY_STAGE_EXCEPTIONS , true ) ; \nfor ( Map . Entry < String , String > entry : stageSpecific . getValues ( ) . entrySet ( ) ) { \nSet < String > stageExceptions = new HashSet < > ( ) ; \nfor ( String path : entry . getValue ( ) . split ( \",\" ) ) { \nstageExceptions . add ( replaceVariables ( path ) ) ; \n} \nthis . stageLibExceptions . put ( entry . getKey ( ) , stageExceptions ) ; \n} \nreturn ; \n} \n} \n"}
{"2430": "public class SdcSecurityManager { \nprivate void ensureProperPermissions ( String path ) { \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( cl instanceof ContainerClassLoader ) { \nreturn ; \n} \nif ( exceptions . contains ( path ) ) { \nreturn ; \n} \nif ( cl instanceof SDCClassLoader ) { \nString libraryName = ( ( SDCClassLoader ) cl ) . getName ( ) ; \nif ( stageLibExceptions . containsKey ( libraryName ) && stageLibExceptions . get ( libraryName ) . contains ( path ) ) { \nreturn ; \n} \n} \nthrow new SecurityException ( Utils . format ( \"Classloader {} is not allowed access to Data Collector internal directories ({}).\" , cl . toString ( ) , path ) ) ; \nreturn ; \n} \n} \n"}
{"2431": "public class BootstrapEmrBatch { \npublic static void main ( String [ ] args ) throws Exception { \nEmrBinding binding = null ; \ntry { \nbinding = new EmrBinding ( args ) ; \nbinding . init ( ) ; \nbinding . awaitTermination ( ) ; \n} \ncatch ( Exception ex ) { \nString msg = \"Error trying to invoke BootstrapEmrBatch.main: \" + ex ; \nthrow new IllegalStateException ( msg , ex ) ; \n} \nfinally { \ntry { \nif ( binding != null ) { \nbinding . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . warn ( \"Error on binding close: \" + ex , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2449": "public class NanoHTTPD { \npublic void stop ( ) { \ntry { \nsafeClose ( this . myServerSocket ) ; \nthis . asyncRunner . closeAll ( ) ; \nif ( this . myThread != null ) { \nthis . myThread . join ( ) ; \n} \n} \ncatch ( Exception e ) { \nNanoHTTPD . LOG . log ( Level . SEVERE , \"Could not stop all connections\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"2450": "public class RouterNanoHTTPD { \npublic void addMappings ( ) { \nrouter . setNotImplemented ( NotImplementedHandler . class ) ; \nrouter . setNotFoundHandler ( Error404UriHandler . class ) ; \nrouter . addRoute ( \"/\" , Integer . MAX_VALUE / 2 , IndexHandler . class ) ; \nrouter . addRoute ( \"/index.html\" , Integer . MAX_VALUE / 2 , IndexHandler . class ) ; \nreturn ; \n} \n} \n"}
{"2451": "public class Response { \npublic void send ( OutputStream outputStream ) { \nSimpleDateFormat gmtFrmt = new SimpleDateFormat ( \"E, d MMM yyyy HH:mm:ss 'GMT'\" , Locale . US ) ; \ngmtFrmt . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; \ntry { \nif ( this . status == null ) { \nthrow new Error ( \"sendResponse(): Status can't be null.\" ) ; \n} \nPrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( outputStream , new ContentType ( this . mimeType ) . getEncoding ( ) ) ) , false ) ; \npw . append ( \"HTTP/1.1 \" ) . append ( this . status . getDescription ( ) ) . append ( \" \\r\\n\" ) ; \nif ( this . mimeType != null ) { \nprintHeader ( pw , \"Content-Type\" , this . mimeType ) ; \n} \nif ( getHeader ( \"date\" ) == null ) { \nprintHeader ( pw , \"Date\" , gmtFrmt . format ( new Date ( ) ) ) ; \n} \nfor ( Entry < String , String > entry : this . header . entrySet ( ) ) { \nprintHeader ( pw , entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nfor ( String cookieHeader : this . cookieHeaders ) { \nprintHeader ( pw , \"Set-Cookie\" , cookieHeader ) ; \n} \nif ( getHeader ( \"connection\" ) == null ) { \nprintHeader ( pw , \"Connection\" , ( this . keepAlive ? \"keep-alive\" : \"close\" ) ) ; \n} \nif ( getHeader ( \"content-length\" ) != null ) { \nsetUseGzip ( false ) ; \n} \nif ( useGzipWhenAccepted ( ) ) { \nprintHeader ( pw , \"Content-Encoding\" , \"gzip\" ) ; \nsetChunkedTransfer ( true ) ; \n} \nlong pending = this . data != null ? this . contentLength : 0 ; \nif ( this . requestMethod != Method . HEAD && this . chunkedTransfer ) { \nprintHeader ( pw , \"Transfer-Encoding\" , \"chunked\" ) ; \n} \nelse if ( ! useGzipWhenAccepted ( ) ) { \npending = sendContentLengthHeaderIfNotAlreadyPresent ( pw , pending ) ; \n} \npw . append ( \"\\r\\n\" ) ; \npw . flush ( ) ; \nsendBodyWithCorrectTransferAndEncoding ( outputStream , pending ) ; \noutputStream . flush ( ) ; \nNanoHTTPD . safeClose ( this . data ) ; \n} \ncatch ( IOException ioe ) { \nNanoHTTPD . LOG . log ( Level . SEVERE , \"Could not send response to the client\" , ioe ) ; \n} \nreturn ; \n} \n} \n"}
{"2452": "public class Response { \nprivate void sendBody ( OutputStream outputStream , long pending ) throws IOException { \nlong BUFFER_SIZE = 16 * 1024 ; \nbyte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; \nboolean sendEverything = pending == - 1 ; \nwhile ( pending > 0 || sendEverything ) { \nlong bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; \nint read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; \nif ( read <= 0 ) { \nbreak ; \n} \ntry { \noutputStream . write ( buff , 0 , read ) ; \n} \ncatch ( Exception e ) { \nif ( this . data != null ) { \nthis . data . close ( ) ; \n} \n} \nif ( ! sendEverything ) { \npending -= read ; \n} \n} \nreturn ; \n} \n} \n"}
{"2455": "public class CookieHandler { \npublic void set ( String name , String value , int expires ) { \nthis . queue . add ( new Cookie ( name , value , Cookie . getHTTPTime ( expires ) ) ) ; \nreturn ; \n} \n} \n"}
{"2456": "public class CookieHandler { \npublic void unloadQueue ( Response response ) { \nfor ( Cookie cookie : this . queue ) { \nresponse . addCookieHeader ( cookie . getHTTPHeader ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2459": "public class JdbcOperationsSessionRepository { \npublic void setTableName ( String tableName ) { \nAssert . hasText ( tableName , \"Table name must not be empty\" ) ; \nthis . tableName = tableName . trim ( ) ; \nprepareQueries ( ) ; \nreturn ; \n} \n} \n"}
{"2461": "public class AbstractHttpSessionApplicationInitializer { \nprivate void insertSessionRepositoryFilter ( ServletContext servletContext ) { \nString filterName = DEFAULT_FILTER_NAME ; \nDelegatingFilterProxy springSessionRepositoryFilter = new DelegatingFilterProxy ( filterName ) ; \nString contextAttribute = getWebApplicationContextAttribute ( ) ; \nif ( contextAttribute != null ) { \nspringSessionRepositoryFilter . setContextAttribute ( contextAttribute ) ; \n} \nregisterFilter ( servletContext , true , filterName , springSessionRepositoryFilter ) ; \nreturn ; \n} \n} \n"}
{"2466": "public class JCAOrderedLastSynchronizationList { \npublic void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { \nint status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; \nswitch ( status ) { \ncase javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; \ncase Status . STATUS_MARKED_ROLLBACK : return ; \ndefault : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; \n} \nif ( synchronization . getClass ( ) . getName ( ) . startsWith ( \"org.jboss.jca\" ) ) { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \n} \njcaSyncs . add ( synchronization ) ; \n} \nelse { \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; \n} \npreJcaSyncs . add ( synchronization ) ; \n} \nreturn ; \n} \n} \n"}
{"2467": "public class JCAOrderedLastSynchronizationList { \n@ Override public void beforeCompletion ( ) { \nint lastIndexProcessed = 0 ; \nwhile ( ( lastIndexProcessed < preJcaSyncs . size ( ) ) ) { \nSynchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: \" + preJcaSync . getClass ( ) + \" HashCode: \" + preJcaSync . hashCode ( ) + \" toString: \" + preJcaSync ) ; \n} \npreJcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \nlastIndexProcessed = 0 ; \nwhile ( ( lastIndexProcessed < jcaSyncs . size ( ) ) ) { \nSynchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: \" + jcaSync . getClass ( ) + \" HashCode: \" + jcaSync . hashCode ( ) + \" toString: \" + jcaSync ) ; \n} \njcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \nreturn ; \n} \n} \n"}
{"2469": "public class KernelDeploymentModuleProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit unit = phaseContext . getDeploymentUnit ( ) ; \nfinal List < KernelDeploymentXmlDescriptor > kdXmlDescriptors = unit . getAttachment ( KernelDeploymentXmlDescriptor . ATTACHMENT_KEY ) ; \nif ( kdXmlDescriptors == null || kdXmlDescriptors . isEmpty ( ) ) return ; \nfor ( KernelDeploymentXmlDescriptor kdxd : kdXmlDescriptors ) { \nif ( kdxd . getBeanFactoriesCount ( ) > 0 ) { \nfinal ModuleSpecification moduleSpecification = unit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nModuleDependency dependency = new ModuleDependency ( moduleLoader , POJO_MODULE , false , false , false , false ) ; \nPathFilter filter = PathFilters . isChildOf ( BaseBeanFactory . class . getPackage ( ) . getName ( ) ) ; \ndependency . addImportFilter ( filter , true ) ; \ndependency . addImportFilter ( PathFilters . rejectAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( dependency ) ; \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"2472": "public class EJBReadWriteLock { \nprivate void decReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nint next ; \nassert current != null : \"can't decrease, readLockCount is not set\" ; \nnext = current . intValue ( ) - 1 ; \nif ( next == 0 ) readLockCount . remove ( ) ; \nelse readLockCount . set ( new Integer ( next ) ) ; \nreturn ; \n} \n} \n"}
{"2473": "public class EJBReadWriteLock { \nprivate void incReadLockCount ( ) { \nInteger current = readLockCount . get ( ) ; \nint next ; \nif ( current == null ) next = 1 ; \nelse next = current . intValue ( ) + 1 ; \nreadLockCount . set ( new Integer ( next ) ) ; \nreturn ; \n} \n} \n"}
{"2474": "public class BeanDeploymentModule { \npublic synchronized < S extends Service > void addService ( Class < S > clazz , S service ) { \nfor ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { \nbda . getServices ( ) . add ( clazz , service ) ; \n} \nreturn ; \n} \n} \n"}
{"2475": "public class CalendarTimer { \npublic void handleRestorationCalculation ( ) { \nif ( nextExpiration == null ) { \nreturn ; \n} \nif ( nextExpiration . getTime ( ) >= System . currentTimeMillis ( ) ) { \nreturn ; \n} \nnextExpiration = new Date ( System . currentTimeMillis ( ) - 1 ) ; \nreturn ; \n} \n} \n"}
{"2476": "public class HibernateSearchProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nif ( JPADeploymentMarker . isJPADeployment ( deploymentUnit ) ) { \naddSearchDependency ( moduleSpecification , moduleLoader , deploymentUnit ) ; \n} \nreturn ; \n} \n} \n"}
{"2477": "public class WeldDeployment { \nprivate void makeTopLevelBdasVisibleFromStaticModules ( ) { \nfor ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { \nif ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL ) || bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ) ) { \nfor ( BeanDeploymentArchiveImpl topLevelBda : rootBeanDeploymentModule . getBeanDeploymentArchives ( ) ) { \nbda . addBeanDeploymentArchive ( topLevelBda ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2479": "public class AbstractMetaDataBuilderPOJO { \nprivate void setConfigNameAndFile ( final JSEArchiveMetaData . Builder builder , final JBossWebMetaData jbossWebMD , final JBossWebservicesMetaData jbossWebservicesMD ) { \nif ( jbossWebservicesMD != null ) { \nif ( jbossWebservicesMD . getConfigName ( ) != null ) { \nfinal String configName = jbossWebservicesMD . getConfigName ( ) ; \nbuilder . setConfigName ( configName ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config name: %s\" , configName ) ; \nfinal String configFile = jbossWebservicesMD . getConfigFile ( ) ; \nbuilder . setConfigFile ( configFile ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config file: %s\" , configFile ) ; \nreturn ; \n} \n} \nfinal List < ParamValueMetaData > contextParams = jbossWebMD . getContextParams ( ) ; \nif ( contextParams != null ) { \nfor ( final ParamValueMetaData contextParam : contextParams ) { \nif ( WSConstants . JBOSSWS_CONFIG_NAME . equals ( contextParam . getParamName ( ) ) ) { \nfinal String configName = contextParam . getParamValue ( ) ; \nbuilder . setConfigName ( configName ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config name: %s\" , configName ) ; \n} \nif ( WSConstants . JBOSSWS_CONFIG_FILE . equals ( contextParam . getParamName ( ) ) ) { \nfinal String configFile = contextParam . getParamValue ( ) ; \nbuilder . setConfigFile ( configFile ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting config file: %s\" , configFile ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2483": "public class EjbInjectionSource { \nprivate void resolve ( ) { \nif ( ! resolved ) { \nsynchronized ( this ) { \nif ( ! resolved ) { \nfinal Set < ViewDescription > views = getViews ( ) ; \nfinal Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( view instanceof EJBViewDescription ) { \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) { \ncontinue ; \n} \nejbsForViewName . add ( ( EJBViewDescription ) view ) ; \n} \n} \nif ( ejbsForViewName . isEmpty ( ) ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; \n} \n} \nelse if ( ejbsForViewName . size ( ) > 1 ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; \n} \n} \nelse { \nfinal EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; \nfinal EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; \nif ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nfinal ServiceName serviceName = description . getServiceName ( ) ; \nresolvedViewName = serviceName ; \n} \nresolved = true ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) { \nthrow duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \n} \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) { \nthrow missingRequiredElement ( reader , required ) ; \n} \nreturn ; \n} \n} \n"}
{"2486": "public class TransactionSubsystem10Parser { \nstatic void parseProcessIdEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { \nif ( reader . getAttributeCount ( ) > 0 ) { \nthrow unexpectedAttribute ( reader , 0 ) ; \n} \nboolean encountered = false ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nswitch ( element ) { \ncase UUID : if ( encountered ) { \nthrow unexpectedElement ( reader ) ; \n} \nencountered = true ; \nif ( reader . getAttributeCount ( ) > 0 ) { \nthrow unexpectedAttribute ( reader , 0 ) ; \n} \ncoreEnvironmentAdd . get ( TransactionSubsystemRootResourceDefinition . PROCESS_ID_UUID . getName ( ) ) . set ( true ) ; \nrequireNoContent ( reader ) ; \nbreak ; \ncase SOCKET : { \nif ( encountered ) { \nthrow unexpectedElement ( reader ) ; \n} \nencountered = true ; \nparseSocketProcessIdElement ( reader , coreEnvironmentAdd ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! encountered ) { \nthrow missingOneOf ( reader , EnumSet . of ( Element . UUID , Element . SOCKET ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2488": "public class Operations { \npublic static void setPathAddress ( ModelNode operation , PathAddress address ) { \noperation . get ( ModelDescriptionConstants . OP_ADDR ) . set ( address . toModelNode ( ) ) ; \nreturn ; \n} \n} \n"}
{"2498": "public class InitialContext { \npublic static synchronized void addUrlContextFactory ( final String scheme , ObjectFactory factory ) { \nMap < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; \nfactories . put ( scheme , factory ) ; \nurlContextFactories = Collections . unmodifiableMap ( factories ) ; \nreturn ; \n} \n} \n"}
{"2499": "public class InitialContext { \npublic static synchronized void removeUrlContextFactory ( final String scheme , ObjectFactory factory ) { \nMap < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; \nObjectFactory f = factories . get ( scheme ) ; \nif ( f == factory ) { \nfactories . remove ( scheme ) ; \nurlContextFactories = Collections . unmodifiableMap ( factories ) ; \nreturn ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2501": "public class WebMetaDataModifier { \nvoid modify ( final Deployment dep ) { \nfinal JBossWebMetaData jbossWebMD = WSHelper . getOptionalAttachment ( dep , JBossWebMetaData . class ) ; \nif ( jbossWebMD != null ) { \nthis . configureEndpoints ( dep , jbossWebMD ) ; \nthis . modifyContextRoot ( dep , jbossWebMD ) ; \n} \nreturn ; \n} \n} \n"}
{"2502": "public class WebMetaDataModifier { \nprivate void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String transportClassName = this . getTransportClassName ( dep ) ; \nWSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; \nfinal Set < String > epNames = new HashSet < String > ( ) ; \nfor ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { \nepNames . add ( ep . getTargetBeanName ( ) ) ; \n} \nfor ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { \nfinal String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; \nif ( endpointClassName != null && endpointClassName . length ( ) > 0 ) { \nif ( epNames . contains ( endpointClassName ) ) { \nservletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; \nfinal List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; \nWebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; \nWebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; \n} \nelse if ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) { \nthrow WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2503": "public class WebMetaDataModifier { \nprivate void modifyContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String contextRoot = dep . getService ( ) . getContextRoot ( ) ; \nif ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nWSLogger . ROOT_LOGGER . tracef ( \"Setting context root: %s for deployment: %s\" , contextRoot , dep . getSimpleName ( ) ) ; \n} \njbossWebMD . setContextRoot ( contextRoot ) ; \nreturn ; \n} \n} \n"}
{"2507": "public class UndertowDeploymentProcessor { \nvoid processManagement ( final DeploymentUnit unit , JBossWebMetaData metaData ) { \nfinal DeploymentResourceSupport deploymentResourceSupport = unit . getAttachment ( Attachments . DEPLOYMENT_RESOURCE_SUPPORT ) ; \nfor ( final JBossServletMetaData servlet : metaData . getServlets ( ) ) { \ntry { \nfinal String name = servlet . getName ( ) ; \nfinal ModelNode node = deploymentResourceSupport . getDeploymentSubModel ( UndertowExtension . SUBSYSTEM_NAME , PathElement . pathElement ( \"servlet\" , name ) ) ; \nnode . get ( \"servlet-class\" ) . set ( servlet . getServletClass ( ) ) ; \nnode . get ( \"servlet-name\" ) . set ( servlet . getServletName ( ) ) ; \n} \ncatch ( Exception e ) { \ncontinue ; \n} \n} \nreturn ; \n} \n} \n"}
{"2508": "public class Injection { \n@ SuppressWarnings ( \"unchecked\" ) public void inject ( Object object , String propertyName , Object propertyValue ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { \ninject ( object , propertyName , propertyValue , null , false ) ; \nreturn ; \n} \n} \n"}
{"2512": "public class VaultTool { \nprivate void initOptions ( ) { \noptions = new Options ( ) ; \noptions . addOption ( \"k\" , KEYSTORE_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineKeyStoreURL ( ) ) ; \noptions . addOption ( \"p\" , KEYSTORE_PASSWORD_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineKeyStorePassword ( ) ) ; \noptions . addOption ( \"e\" , ENC_DIR_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineEncryptionDirectory ( ) ) ; \noptions . addOption ( \"s\" , SALT_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineSalt ( ) ) ; \noptions . addOption ( \"i\" , ITERATION_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineIterationCount ( ) ) ; \noptions . addOption ( \"v\" , ALIAS_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineVaultKeyStoreAlias ( ) ) ; \noptions . addOption ( \"b\" , VAULT_BLOCK_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineVaultBlock ( ) ) ; \noptions . addOption ( \"a\" , ATTRIBUTE_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineAttributeName ( ) ) ; \noptions . addOption ( \"t\" , CREATE_KEYSTORE_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineAutomaticallyCreateKeystore ( ) ) ; \nOptionGroup og = new OptionGroup ( ) ; \nOption x = new Option ( \"x\" , SEC_ATTR_VALUE_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineSecuredAttribute ( ) ) ; \nOption c = new Option ( \"c\" , CHECK_SEC_ATTR_EXISTS_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineCheckAttribute ( ) ) ; \nOption r = new Option ( \"r\" , REMOVE_SEC_ATTR_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineRemoveSecuredAttribute ( ) ) ; \nOption h = new Option ( \"h\" , HELP_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineHelp ( ) ) ; \nog . addOption ( x ) ; \nog . addOption ( c ) ; \nog . addOption ( r ) ; \nog . addOption ( h ) ; \nog . setRequired ( true ) ; \noptions . addOptionGroup ( og ) ; \nreturn ; \n} \n} \n"}
{"2516": "public class ResourceAdapterDeploymentRegistryImpl { \npublic void registerResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { \nif ( deployment == null ) throw new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( \"Deployment\" ) ) ; \nDEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( \"Adding deployment: %s\" , deployment ) ; \ndeployments . add ( deployment ) ; \nreturn ; \n} \n} \n"}
{"2517": "public class ResourceAdapterDeploymentRegistryImpl { \npublic void unregisterResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { \nif ( deployment == null ) throw new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( \"Deployment\" ) ) ; \nDEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( \"Removing deployment: %s\" , deployment ) ; \ndeployments . remove ( deployment ) ; \nreturn ; \n} \n} \n"}
{"2518": "public class JacORBExtension { \nprotected static void registerTransformers ( final SubsystemRegistration subsystem ) { \nChainedTransformationDescriptionBuilder chained = ResourceTransformationDescriptionBuilder . Factory . createChainedSubystemInstance ( CURRENT_MODEL_VERSION ) ; \nModelVersion MODEL_VERSION_EAP64 = ModelVersion . create ( 1 , 4 , 0 ) ; \nModelVersion MODEL_VERSION_EAP63 = ModelVersion . create ( 1 , 3 , 0 ) ; \nResourceTransformationDescriptionBuilder builder64 = chained . createBuilder ( CURRENT_MODEL_VERSION , MODEL_VERSION_EAP64 ) ; \nbuilder64 . getAttributeBuilder ( ) . addRejectCheck ( RejectAttributeChecker . DEFINED , JacORBSubsystemDefinitions . PERSISTENT_SERVER_ID ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( JacORBSubsystemDefinitions . PERSISTENT_SERVER_ID . getDefaultValue ( ) ) , JacORBSubsystemDefinitions . PERSISTENT_SERVER_ID ) . setValueConverter ( new AttributeConverter . DefaultValueAttributeConverter ( JacORBSubsystemDefinitions . INTEROP_CHUNK_RMI_VALUETYPES ) , JacORBSubsystemDefinitions . INTEROP_CHUNK_RMI_VALUETYPES ) ; \nResourceTransformationDescriptionBuilder builder63 = chained . createBuilder ( MODEL_VERSION_EAP64 , MODEL_VERSION_EAP63 ) ; \nbuilder63 . getAttributeBuilder ( ) . addRejectCheck ( RejectAttributeChecker . DEFINED , IORTransportConfigDefinition . ATTRIBUTES . toArray ( new AttributeDefinition [ 0 ] ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , IORASContextDefinition . ATTRIBUTES . toArray ( new AttributeDefinition [ 0 ] ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , IORSASContextDefinition . ATTRIBUTES . toArray ( new AttributeDefinition [ 0 ] ) ) . end ( ) . rejectChildResource ( IORSettingsDefinition . INSTANCE . getPathElement ( ) ) ; \nchained . buildAndRegister ( subsystem , new ModelVersion [ ] { \nMODEL_VERSION_EAP64 , MODEL_VERSION_EAP63 } \n) ; \nreturn ; \n} \n} \n"}
{"2519": "public class StubStrategy { \npublic void writeParams ( OutputStream out , Object [ ] params ) { \nint len = params . length ; \nif ( len != paramWriters . length ) { \nthrow IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; \n} \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject param = params [ i ] ; \nif ( param instanceof PortableRemoteObject ) { \ntry { \nparam = PortableRemoteObject . toStub ( ( Remote ) param ) ; \n} \ncatch ( NoSuchObjectException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nparamWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2522": "public class StatefulSessionSynchronizationInterceptor { \nstatic void releaseLock ( final StatefulSessionComponentInstance instance ) { \ninstance . getLock ( ) . unlock ( getLockOwner ( instance . getComponent ( ) . getTransactionSynchronizationRegistry ( ) ) ) ; \nROOT_LOGGER . tracef ( \"Released lock: %s\" , instance . getLock ( ) ) ; \nreturn ; \n} \n} \n"}
{"2523": "public class JdrZipFile { \npublic void addLog ( String content , String logName ) throws Exception { \nString name = \"sos_logs/\" + logName ; \nthis . add ( new ByteArrayInputStream ( content . getBytes ( StandardCharsets . UTF_8 ) ) , name ) ; \nreturn ; \n} \n} \n"}
{"2524": "public class JSFDependencyProcessor { \nprivate void addCDIFlag ( WarMetaData warMetaData , DeploymentUnit deploymentUnit ) { \nJBossWebMetaData webMetaData = warMetaData . getMergedJBossWebMetaData ( ) ; \nif ( webMetaData == null ) { \nwebMetaData = new JBossWebMetaData ( ) ; \nwarMetaData . setMergedJBossWebMetaData ( webMetaData ) ; \n} \nList < ParamValueMetaData > contextParams = webMetaData . getContextParams ( ) ; \nif ( contextParams == null ) { \ncontextParams = new ArrayList < ParamValueMetaData > ( ) ; \n} \nboolean isCDI = false ; \nfinal CapabilityServiceSupport support = deploymentUnit . getAttachment ( Attachments . CAPABILITY_SERVICE_SUPPORT ) ; \nif ( support . hasCapability ( WELD_CAPABILITY_NAME ) ) { \nisCDI = support . getOptionalCapabilityRuntimeAPI ( WELD_CAPABILITY_NAME , WeldCapability . class ) . get ( ) . isPartOfWeldDeployment ( deploymentUnit ) ; \n} \nParamValueMetaData param = new ParamValueMetaData ( ) ; \nparam . setParamName ( IS_CDI_PARAM ) ; \nparam . setParamValue ( Boolean . toString ( isCDI ) ) ; \ncontextParams . add ( param ) ; \nwebMetaData . setContextParams ( contextParams ) ; \nreturn ; \n} \n} \n"}
{"2526": "public class AbstractInvocationHandler { \npublic void invoke ( final Endpoint endpoint , final Invocation wsInvocation ) throws Exception { \ntry { \nif ( ! EndpointState . STARTED . equals ( endpoint . getState ( ) ) ) { \nthrow WSLogger . ROOT_LOGGER . endpointAlreadyStopped ( endpoint . getShortName ( ) ) ; \n} \nSecurityDomainContext securityDomainContext = endpoint . getSecurityDomainContext ( ) ; \nsecurityDomainContext . runAs ( ( Callable < Void > ) ( ) -> { \ninvokeInternal ( endpoint , wsInvocation ) ; \nreturn null ; \n} \n) ; \n} \ncatch ( Throwable t ) { \nhandleInvocationException ( t ) ; \n} \nfinally { \nonAfterInvocation ( wsInvocation ) ; \n} \nreturn ; \n} \n} \n"}
{"2532": "public class AbstractSecurityMetaDataAccessorEJB { \nprivate void ensureSameDomains ( final String oldSecurityDomain , final String newSecurityDomain ) { \nfinal boolean domainsDiffer = ! oldSecurityDomain . equals ( newSecurityDomain ) ; \nif ( domainsDiffer ) throw WSLogger . ROOT_LOGGER . multipleSecurityDomainsDetected ( oldSecurityDomain , newSecurityDomain ) ; \nreturn ; \n} \n} \n"}
{"2533": "public class AttributeAnalysis { \nvoid setIDLName ( String idlName ) { \nsuper . setIDLName ( idlName ) ; \nif ( idlName . charAt ( 0 ) >= 0x41 && idlName . charAt ( 0 ) <= 0x5a && ( idlName . length ( ) <= 1 || idlName . charAt ( 1 ) < 0x41 || idlName . charAt ( 1 ) > 0x5a ) ) { \nidlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; \n} \nif ( accessorAnalysis != null ) accessorAnalysis . setIDLName ( \"_get_\" + idlName ) ; \nif ( mutatorAnalysis != null ) mutatorAnalysis . setIDLName ( \"_set_\" + idlName ) ; \nreturn ; \n} \n} \n"}
{"2536": "public class IronJacamarDeploymentParsingProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ResourceRoot resourceRoot = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; \nfinal VirtualFile deploymentRoot = resourceRoot . getRoot ( ) ; \nfinal boolean resolveProperties = Util . shouldResolveJBoss ( deploymentUnit ) ; \nIronJacamarXmlDescriptor xmlDescriptor = process ( deploymentRoot , resolveProperties ) ; \nif ( xmlDescriptor != null ) { \ndeploymentUnit . putAttachment ( IronJacamarXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \n} \nreturn ; \n} \n} \n"}
{"2537": "public class RunningRequestsHttpHandler { \n@ Override public void handleRequest ( HttpServerExchange exchange ) throws Exception { \nrunningCount . increment ( ) ; \nexchange . addExchangeCompleteListener ( new ExchangeCompletionListener ( ) { \n@ Override public void exchangeEvent ( HttpServerExchange exchange , NextListener nextListener ) { \nrunningCount . decrement ( ) ; \nnextListener . proceed ( ) ; \nreturn ; \n} \n} \n) ; \nwrappedHandler . handleRequest ( exchange ) ; \nreturn ; \n} \n} \n"}
{"2547": "public class NamingUtils { \npublic static < T > NamingEnumeration < T > namingEnumeration ( final Collection < T > collection ) { \nfinal Iterator < T > iterator = collection . iterator ( ) ; \nreturn new NamingEnumeration < T > ( ) { \npublic T next ( ) { \nreturn nextElement ( ) ; \n} \npublic boolean hasMore ( ) { \nreturn hasMoreElements ( ) ; \n} \npublic void close ( ) { \nreturn ; \n} \npublic boolean hasMoreElements ( ) { \nreturn iterator . hasNext ( ) ; \n} \npublic T nextElement ( ) { \nreturn iterator . next ( ) ; \n} \n} \n; \n} \n} \n"}
{"2548": "public class NamingUtils { \npublic static void rebind ( final Context ctx , final String name , final Object value ) throws NamingException { \nfinal Name n = ctx . getNameParser ( \"\" ) . parse ( name ) ; \nrebind ( ctx , n , value ) ; \nreturn ; \n} \n} \n"}
{"2552": "public class JaxrsSpringProcessor { \nprotected synchronized VirtualFile getResteasySpringVirtualFile ( ) throws DeploymentUnitProcessingException { \nif ( resourceRoot != null ) { \nreturn resourceRoot ; \n} \ntry { \nModule module = Module . getBootModuleLoader ( ) . loadModule ( MODULE ) ; \nURL fileUrl = module . getClassLoader ( ) . getResource ( JAR_LOCATION ) ; \nif ( fileUrl == null ) { \nthrow JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; \n} \nFile dir = new File ( fileUrl . toURI ( ) ) ; \nFile file = null ; \nfor ( String jar : dir . list ( ) ) { \nif ( jar . endsWith ( \".jar\" ) ) { \nfile = new File ( dir , jar ) ; \nbreak ; \n} \n} \nif ( file == null ) { \nthrow JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; \n} \nVirtualFile vf = VFS . getChild ( file . toURI ( ) ) ; \nfinal Closeable mountHandle = VFS . mountZip ( file , vf , TempFileProviderService . provider ( ) ) ; \nService < Closeable > mountHandleService = new Service < Closeable > ( ) { \npublic void start ( StartContext startContext ) throws StartException { \nreturn ; \n} \npublic void stop ( StopContext stopContext ) { \nVFSUtils . safeClose ( mountHandle ) ; \nreturn ; \n} \npublic Closeable getValue ( ) throws IllegalStateException , IllegalArgumentException { \nreturn mountHandle ; \n} \n} \n; \nServiceBuilder < Closeable > builder = serviceTarget . addService ( ServiceName . JBOSS . append ( SERVICE_NAME ) , mountHandleService ) ; \nbuilder . setInitialMode ( ServiceController . Mode . ACTIVE ) . install ( ) ; \nresourceRoot = vf ; \nreturn resourceRoot ; \n} \ncatch ( Exception e ) { \nthrow new DeploymentUnitProcessingException ( e ) ; \n} \n} \n} \n"}
{"2556": "public class ShutDownInterceptorFactory { \npublic void shutdown ( ) { \nint value ; \nint oldValue ; \ndo { \noldValue = invocationCount ; \nvalue = SHUTDOWN_FLAG | oldValue ; \nif ( oldValue == value ) { \nreturn ; \n} \n} \nwhile ( ! updater . compareAndSet ( this , oldValue , value ) ) ; \nsynchronized ( lock ) { \nvalue = invocationCount ; \nwhile ( value != SHUTDOWN_FLAG ) { \ntry { \nlock . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \nvalue = invocationCount ; \nif ( ( value & SHUTDOWN_FLAG ) == 0 ) { \nreturn ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2573": "public class JPAInterceptorProcessor { \nprivate void registerSessionBeanInterceptors ( SessionBeanComponentDescription componentDescription , final DeploymentUnit deploymentUnit ) { \nif ( componentDescription . isStateful ( ) ) { \ncomponentDescription . getConfigurators ( ) . addFirst ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addPostConstructInterceptor ( SFSBPreCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_PRE_CREATE ) ; \nconfiguration . addPostConstructInterceptor ( SFSBCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_CREATE ) ; \nconfiguration . addPreDestroyInterceptor ( SFSBDestroyInterceptor . FACTORY , InterceptorOrder . ComponentPreDestroy . JPA_SFSB_DESTROY ) ; \nconfiguration . addComponentInterceptor ( SFSBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SFSB_INTERCEPTOR , false ) ; \nconfiguration . getInterceptorContextKeys ( ) . add ( SFSBInvocationInterceptor . CONTEXT_KEY ) ; \nreturn ; \n} \n} \n) ; \n} \nif ( ( componentDescription . isStateful ( ) || componentDescription . isStateless ( ) ) ) { \ncomponentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addComponentInterceptor ( SBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SESSION_BEAN_INTERCEPTOR , false ) ; \nreturn ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"2575": "public class WeldStartService { \n@ Override public void stop ( final StopContext context ) { \nfinal WeldBootstrapService bootstrapService = bootstrapSupplier . get ( ) ; \nif ( ! bootstrapService . isStarted ( ) ) { \nthrow WeldLogger . ROOT_LOGGER . notStarted ( \"WeldContainer\" ) ; \n} \nWeldLogger . DEPLOYMENT_LOGGER . stoppingWeldService ( bootstrapService . getDeploymentName ( ) ) ; \nClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \ntry { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; \nWeldProvider . containerShutDown ( Container . instance ( bootstrapService . getDeploymentName ( ) ) ) ; \nbootstrapService . getBootstrap ( ) . shutdown ( ) ; \n} \nfinally { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; \nModuleGroupSingletonProvider . removeClassLoader ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; \n} \nbootstrapService . setStarted ( false ) ; \nreturn ; \n} \n} \n"}
{"2583": "public class EJBSuspendHandlerService { \npublic void start ( StartContext context ) { \nfinal SuspendController suspendController = suspendControllerInjectedValue . getValue ( ) ; \nsuspendController . registerActivity ( this ) ; \nfinal LocalTransactionContext localTransactionContext = localTransactionContextInjectedValue . getValue ( ) ; \nlocalTransactionContext . registerCreationListener ( this ) ; \nreturn ; \n} \n} \n"}
{"2584": "public class EJBSuspendHandlerService { \npublic void stop ( StopContext context ) { \nfinal SuspendController suspendController = suspendControllerInjectedValue . getValue ( ) ; \nsuspendController . unRegisterActivity ( this ) ; \nfinal LocalTransactionContext localTransactionContext = localTransactionContextInjectedValue . getValue ( ) ; \nlocalTransactionContext . removeCreationListener ( this ) ; \nreturn ; \n} \n} \n"}
{"2585": "public class EJBSuspendHandlerService { \n@ Override public void suspended ( ServerActivityCallback listener ) { \nthis . suspended = true ; \nlistenerUpdater . set ( this , listener ) ; \nlocalTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; \nfinal int activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; \nif ( activeInvocationCount == 0 ) { \nif ( gracefulTxnShutdown ) { \nif ( activeTransactionCountUpdater . get ( this ) == 0 ) { \nthis . doneSuspended ( ) ; \n} \nelse { \nEjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; \n} \n} \nelse { \nthis . doneSuspended ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2586": "public class EJBSuspendHandlerService { \n@ Override public void resume ( ) { \nthis . suspended = false ; \nlocalTransactionContextInjectedValue . getValue ( ) . resumeRequests ( ) ; \nServerActivityCallback listener = listenerUpdater . get ( this ) ; \nif ( listener != null ) { \nlistenerUpdater . compareAndSet ( this , listener , null ) ; \n} \ndeploymentRepositoryInjectedValue . getValue ( ) . resume ( ) ; \nreturn ; \n} \n} \n"}
{"2587": "public class EJBSuspendHandlerService { \npublic void invocationComplete ( ) { \nint activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; \nif ( suspended && activeInvocations == 0 && ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) ) { \ndoneSuspended ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2588": "public class EJBSuspendHandlerService { \n@ Override public void transactionCreated ( AbstractTransaction transaction , CreatedBy createdBy ) { \nactiveTransactionCountUpdater . incrementAndGet ( this ) ; \ntry { \ntransaction . registerSynchronization ( this ) ; \n} \ncatch ( RollbackException | IllegalStateException e ) { \ndecrementTransactionCount ( ) ; \n} \ncatch ( SystemException e ) { \ndecrementTransactionCount ( ) ; \nEjbLogger . ROOT_LOGGER . debug ( \"Unexpected exception\" , e ) ; \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"2589": "public class BinderService { \npublic void start ( StartContext context ) throws StartException { \nfinal ServiceBasedNamingStore namingStore = namingStoreValue . getValue ( ) ; \ncontroller = context . getController ( ) ; \nnamingStore . add ( controller . getName ( ) ) ; \nROOT_LOGGER . tracef ( \"Bound resource %s into naming store %s (service name %s)\" , name , namingStore , controller . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"2590": "public class BinderService { \npublic void stop ( StopContext context ) { \nfinal ServiceBasedNamingStore namingStore = namingStoreValue . getValue ( ) ; \nnamingStore . remove ( controller . getName ( ) ) ; \nROOT_LOGGER . tracef ( \"Unbound resource %s into naming store %s (service name %s)\" , name , namingStore , context . getController ( ) . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"2600": "public class CorbaUtils { \nprivate static void initMethodHandles ( ) throws ClassNotFoundException { \ncorbaStubClass = Class . forName ( \"javax.rmi.CORBA.Stub\" ) ; \ntry { \nconnectMethod = corbaStubClass . getMethod ( \"connect\" , new Class [ ] { \norg . omg . CORBA . ORB . class } \n) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow IIOPLogger . ROOT_LOGGER . noMethodDefForStubConnect ( ) ; \n} \nClass proClass = Class . forName ( \"javax.rmi.PortableRemoteObject\" ) ; \ntry { \ntoStubMethod = proClass . getMethod ( \"toStub\" , new Class [ ] { \njava . rmi . Remote . class } \n) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow IIOPLogger . ROOT_LOGGER . noMethodDefForPortableRemoteObjectToStub ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2601": "public class NamingContext { \npublic static void setActiveNamingStore ( final NamingStore namingStore ) { \nif ( WildFlySecurityManager . isChecking ( ) ) { \nSystem . getSecurityManager ( ) . checkPermission ( SET_ACTIVE_NAMING_STORE ) ; \n} \nACTIVE_NAMING_STORE = namingStore ; \nreturn ; \n} \n} \n"}
{"2602": "public class JaxrsMethodParameterProcessor { \nprivate void validateDefaultValues ( List < ParamDetail > detailList , HashMap < String , List < Validator > > paramConverterMap ) throws DeploymentUnitProcessingException { \nfor ( ParamDetail detail : detailList ) { \nList < Validator > validators = paramConverterMap . get ( detail . parameter . getName ( ) ) ; \nif ( validators == null ) { \nvalidators = paramConverterMap . get ( Object . class . getName ( ) ) ; \n} \nboolean isCheckClazzMethods = true ; \nif ( validators != null ) { \nfor ( Validator v : validators ) { \nif ( ! v . isLazyLoad ( ) ) { \ntry { \nObject obj = v . verify ( detail ) ; \nif ( obj != null ) { \nisCheckClazzMethods = false ; \nbreak ; \n} \n} \ncatch ( Exception e ) { \nJAXRS_LOGGER . paramConverterFailed ( detail . defaultValue . value ( ) , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , v . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; \n} \n} \n} \n} \nif ( isCheckClazzMethods ) { \nClass baseType = detail . parameter ; \nMethod valueOf = null ; \ntry { \nConstructor < ? > ctor = baseType . getConstructor ( String . class ) ; \nif ( Modifier . isPublic ( ctor . getModifiers ( ) ) ) { \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignored ) { \n} \ntry { \nMethod fromValue = baseType . getDeclaredMethod ( \"fromValue\" , String . class ) ; \nif ( Modifier . isPublic ( fromValue . getModifiers ( ) ) ) { \nfor ( Annotation ann : baseType . getAnnotations ( ) ) { \nif ( ann . annotationType ( ) . getName ( ) . equals ( \"javax.xml.bind.annotation.XmlEnum\" ) ) { \nvalueOf = fromValue ; \n} \n} \nvalidateBaseType ( fromValue , detail . defaultValue . value ( ) , detail ) ; \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignoredA ) { \n} \nMethod fromString = null ; \ntry { \nfromString = baseType . getDeclaredMethod ( \"fromString\" , String . class ) ; \nif ( Modifier . isStatic ( fromString . getModifiers ( ) ) ) { \nvalidateBaseType ( fromString , detail . defaultValue . value ( ) , detail ) ; \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignoredB ) { \n} \ntry { \nvalueOf = baseType . getDeclaredMethod ( \"valueOf\" , String . class ) ; \nif ( Modifier . isStatic ( valueOf . getModifiers ( ) ) ) { \nvalidateBaseType ( valueOf , detail . defaultValue . value ( ) , detail ) ; \ncontinue ; \n} \n} \ncatch ( NoSuchMethodException ignored ) { \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2605": "public class JaxrsMethodParameterProcessor { \nprivate void validateBaseType ( Method method , String defaultValue , ParamDetail detail ) throws DeploymentUnitProcessingException { \nif ( defaultValue != null ) { \ntry { \nmethod . invoke ( method . getDeclaringClass ( ) , defaultValue ) ; \n} \ncatch ( Exception e ) { \nJAXRS_LOGGER . baseTypeMethodFailed ( defaultValue , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , method . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2608": "public class Notification { \npublic static void addCacheDependencies ( Classification cacheType , Properties properties ) { \nfor ( EventListener eventListener : eventListeners ) { \neventListener . addCacheDependencies ( cacheType , properties ) ; \n} \nreturn ; \n} \n} \n"}
{"2609": "public class DatabaseTimerPersistence { \nprivate void extractDialects ( ) { \nfor ( Object prop : sql . keySet ( ) ) { \nint dot = ( ( String ) prop ) . indexOf ( '.' ) ; \nif ( dot > 0 ) { \ndatabaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2610": "public class DatabaseTimerPersistence { \nprivate void investigateDialect ( ) { \nConnection connection = null ; \nif ( database == null ) { \ntry { \nconnection = dataSource . getConnection ( ) ; \nDatabaseMetaData metaData = connection . getMetaData ( ) ; \nString dbProduct = metaData . getDatabaseProductName ( ) ; \ndatabase = identifyDialect ( dbProduct ) ; \nif ( database == null ) { \nEjbLogger . EJB3_TIMER_LOGGER . debug ( \"Attempting to guess on driver name.\" ) ; \ndatabase = identifyDialect ( metaData . getDriverName ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nEjbLogger . EJB3_TIMER_LOGGER . debug ( \"Unable to read JDBC metadata.\" , e ) ; \n} \nfinally { \nsafeClose ( connection ) ; \n} \nif ( database == null ) { \nEjbLogger . EJB3_TIMER_LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString ( ) ) ; \n} \nelse { \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Detect database dialect as '%s'.  If this is incorrect, please specify the correct dialect using the 'database' attribute in your configuration.  Supported database dialect strings are %s\" , database , databaseDialects ) ; \n} \n} \nelse { \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Database dialect '%s' read from configuration, adjusting it to match the final database valid value.\" , database ) ; \ndatabase = identifyDialect ( database ) ; \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"New Database dialect is '%s'.\" , database ) ; \n} \nreturn ; \n} \n} \n"}
{"2612": "public class DatabaseTimerPersistence { \nprivate void checkDatabase ( ) { \nString loadTimer = sql ( LOAD_TIMER ) ; \nConnection connection = null ; \nStatement statement = null ; \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nconnection = dataSource . getConnection ( ) ; \nif ( connection . getTransactionIsolation ( ) < Connection . TRANSACTION_READ_COMMITTED ) { \nEjbLogger . EJB3_TIMER_LOGGER . wrongTransactionIsolationConfiguredForTimer ( ) ; \n} \npreparedStatement = connection . prepareStatement ( loadTimer ) ; \npreparedStatement . setString ( 1 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 2 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 3 , \"NON-EXISTENT\" ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \n} \ncatch ( SQLException e ) { \nif ( connection != null ) { \ntry { \nString createTable = sql ( CREATE_TABLE ) ; \nString [ ] statements = createTable . split ( \";\" ) ; \nfor ( final String sql : statements ) { \ntry { \nstatement = connection . createStatement ( ) ; \nstatement . executeUpdate ( sql ) ; \n} \nfinally { \nsafeClose ( statement ) ; \n} \n} \n} \ncatch ( SQLException e1 ) { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e1 ) ; \n} \n} \nelse { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e ) ; \n} \n} \nfinally { \nsafeClose ( resultSet ) ; \nsafeClose ( preparedStatement ) ; \nsafeClose ( statement ) ; \nsafeClose ( connection ) ; \n} \nreturn ; \n} \n} \n"}
{"2614": "public class DatabaseTimerPersistence { \nprivate void setNodeName ( final TimerState timerState , PreparedStatement statement , int paramIndex ) throws SQLException { \nif ( timerState == TimerState . IN_TIMEOUT || timerState == TimerState . RETRY_TIMEOUT ) { \nstatement . setString ( paramIndex , nodeName ) ; \n} \nelse { \nstatement . setNull ( paramIndex , Types . VARCHAR ) ; \n} \nreturn ; \n} \n} \n"}
{"2615": "public class WeldDeploymentMarker { \npublic static void mark ( DeploymentUnit unit ) { \nunit . putAttachment ( MARKER , Boolean . TRUE ) ; \nif ( unit . getParent ( ) != null ) { \nmark ( unit . getParent ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2617": "public class SkeletonStrategy { \npublic void writeRetval ( OutputStream out , Object retVal ) { \nretvalWriter . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( retVal ) ) ; \nreturn ; \n} \n} \n"}
{"2618": "public class SkeletonStrategy { \npublic void writeException ( OutputStream out , Throwable e ) { \nint len = excepWriters . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { \nexcepWriters [ i ] . write ( out , e ) ; \nreturn ; \n} \n} \nthrow new UnknownException ( e ) ; \nreturn ; \n} \n} \n"}
{"2620": "public class SFSBCallStack { \npublic static void beginSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = new HashMap < String , ExtendedEntityManager > ( ) ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( data . creationTimeInjectedXPCs , null ) ; \n} \nelse { \nSFSBInjectedXPCs parent = data . creationTimeInjectedXPCs ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( parent , parent . getTopLevel ( ) ) ; \n} \ndata . creationBeanNestingLevel ++ ; \nreturn ; \n} \n} \n"}
{"2621": "public class SFSBCallStack { \npublic static void endSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nno -- ; \ndata . creationBeanNestingLevel = no ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = null ; \ndata . creationTimeInjectedXPCs = null ; \n} \nelse { \ndata . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2623": "public class SFSBCallStack { \npublic static void pushCall ( Map < String , ExtendedEntityManager > entityManagers ) { \ncurrentSFSBCallStack ( ) . add ( entityManagers ) ; \nif ( entityManagers != null ) { \nfor ( ExtendedEntityManager extendedEntityManager : entityManagers . values ( ) ) { \nextendedEntityManager . internalAssociateWithJtaTx ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2626": "public class WeldDependencyProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \naddDependency ( moduleSpecification , moduleLoader , JAVAX_ENTERPRISE_API ) ; \naddDependency ( moduleSpecification , moduleLoader , JAVAX_INJECT_API ) ; \nif ( ! WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit ) ) { \nreturn ; \n} \naddDependency ( moduleSpecification , moduleLoader , JAVAX_PERSISTENCE_API_ID ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_CORE_ID ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_PROBE_ID , true ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_API_ID ) ; \naddDependency ( moduleSpecification , moduleLoader , WELD_SPI_ID ) ; \nModuleDependency weldSubsystemDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_ID , false , false , false , false ) ; \nweldSubsystemDependency . addImportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; \nweldSubsystemDependency . addImportFilter ( PathFilters . is ( \"org/jboss/as/weld/injection\" ) , true ) ; \nweldSubsystemDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; \nweldSubsystemDependency . addExportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; \nmoduleSpecification . addSystemDependency ( weldSubsystemDependency ) ; \nModuleDependency weldEjbDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_EJB_ID , true , false , false , false ) ; \nweldEjbDependency . addImportFilter ( PathFilters . is ( \"org/jboss/as/weld/ejb\" ) , true ) ; \nweldEjbDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( weldEjbDependency ) ; \nreturn ; \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \nelse if ( indent == 3 && managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \nelse if ( indent == 3 && lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2630": "public class Util { \npublic static void insertAnyPrimitive ( Any any , Object primitive ) { \nClass type = primitive . getClass ( ) ; \nif ( type == Boolean . class ) any . insert_boolean ( ( ( Boolean ) primitive ) . booleanValue ( ) ) ; \nelse if ( type == Character . class ) any . insert_wchar ( ( ( Character ) primitive ) . charValue ( ) ) ; \nelse if ( type == Byte . class ) any . insert_octet ( ( ( Byte ) primitive ) . byteValue ( ) ) ; \nelse if ( type == Short . class ) any . insert_short ( ( ( Short ) primitive ) . shortValue ( ) ) ; \nelse if ( type == Integer . class ) any . insert_long ( ( ( Integer ) primitive ) . intValue ( ) ) ; \nelse if ( type == Long . class ) any . insert_longlong ( ( ( Long ) primitive ) . longValue ( ) ) ; \nelse if ( type == Float . class ) any . insert_float ( ( ( Float ) primitive ) . floatValue ( ) ) ; \nelse if ( type == Double . class ) any . insert_double ( ( ( Double ) primitive ) . doubleValue ( ) ) ; \nelse throw IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"2643": "public class NamingEventCoordinator { \nsynchronized void addListener ( final String target , final int scope , final NamingListener namingListener ) { \nfinal TargetScope targetScope = new TargetScope ( target , scope ) ; \nListenerHolder holder = holdersByListener . get ( namingListener ) ; \nif ( holder == null ) { \nholder = new ListenerHolder ( namingListener , targetScope ) ; \nfinal Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; \nbyListenerCopy . put ( namingListener , holder ) ; \nholdersByListener = byListenerCopy ; \n} \nelse { \nholder . addTarget ( targetScope ) ; \n} \nList < ListenerHolder > holdersForTarget = holdersByTarget . get ( targetScope ) ; \nif ( holdersForTarget == null ) { \nholdersForTarget = new CopyOnWriteArrayList < ListenerHolder > ( ) ; \nfinal Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; \nbyTargetCopy . put ( targetScope , holdersForTarget ) ; \nholdersByTarget = byTargetCopy ; \n} \nholdersForTarget . add ( holder ) ; \nreturn ; \n} \n} \n"}
{"2644": "public class NamingEventCoordinator { \nsynchronized void removeListener ( final NamingListener namingListener ) { \nfinal ListenerHolder holder = holdersByListener . get ( namingListener ) ; \nif ( holder == null ) { \nreturn ; \n} \nfinal Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; \nbyListenerCopy . remove ( namingListener ) ; \nholdersByListener = byListenerCopy ; \nfinal Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; \nfor ( TargetScope targetScope : holder . targets ) { \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nholders . remove ( holder ) ; \nif ( holders . isEmpty ( ) ) { \nbyTargetCopy . remove ( targetScope ) ; \n} \n} \nholdersByTarget = byTargetCopy ; \nreturn ; \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { \nfor ( int i = 1 ; \ni < name . size ( ) ; \ni ++ ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \nreturn ; \n} \n} \n"}
{"2647": "public class ElytronSubjectFactory { \nprivate void addPrivateCredential ( final Subject subject , final Object credential ) { \nif ( ! WildFlySecurityManager . isChecking ( ) ) { \nsubject . getPrivateCredentials ( ) . add ( credential ) ; \n} \nelse { \nAccessController . doPrivileged ( ( PrivilegedAction < Void > ) ( ) -> { \nsubject . getPrivateCredentials ( ) . add ( credential ) ; \nreturn null ; \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"2649": "public class SessionBeanComponentDescription { \nprotected static void addTxManagementInterceptorForView ( ViewDescription view ) { \nview . getConfigurators ( ) . add ( new ViewConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentConfiguration componentConfiguration , ViewDescription description , ViewConfiguration configuration ) throws DeploymentUnitProcessingException { \nEJBComponentDescription ejbComponentDescription = ( EJBComponentDescription ) componentConfiguration . getComponentDescription ( ) ; \nif ( TransactionManagementType . CONTAINER . equals ( ejbComponentDescription . getTransactionManagementType ( ) ) ) { \nconfiguration . addViewInterceptor ( CMTTxInterceptor . FACTORY , InterceptorOrder . View . CMT_TRANSACTION_INTERCEPTOR ) ; \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"2650": "public class QueryName { \nprivate static void subst ( final StringBuilder stringBuilder , final String from , final String to ) { \nint begin = 0 , end = 0 ; \nwhile ( ( end = stringBuilder . indexOf ( from , end ) ) != - 1 ) { \nstringBuilder . delete ( end , end + from . length ( ) ) ; \nstringBuilder . insert ( end , to ) ; \nbegin = end + to . length ( ) ; \nend = begin ; \n} \nreturn ; \n} \n} \n"}
{"2658": "public class ViewConfiguration { \npublic void addViewInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \nfor ( Method method : proxyFactory . getCachedMethods ( ) ) { \naddViewInterceptor ( method , interceptorFactory , priority ) ; \n} \nreturn ; \n} \n} \n"}
{"2659": "public class ViewConfiguration { \npublic void addViewInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { \nOrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; \nif ( container == null ) { \nviewInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; \n} \ncontainer . add ( interceptorFactory , priority ) ; \nreturn ; \n} \n} \n"}
{"2661": "public class ViewConfiguration { \npublic void addClientInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \nfor ( Method method : proxyFactory . getCachedMethods ( ) ) { \naddClientInterceptor ( method , interceptorFactory , priority ) ; \n} \nreturn ; \n} \n} \n"}
{"2662": "public class ViewConfiguration { \npublic void addClientInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { \nOrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; \nif ( container == null ) { \nclientInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; \n} \ncontainer . add ( interceptorFactory , priority ) ; \nreturn ; \n} \n} \n"}
{"2663": "public class ViewConfiguration { \npublic < T > void putPrivateData ( final Class < T > type , T data ) { \nprivateData . put ( type , data ) ; \nreturn ; \n} \n} \n"}
{"2664": "public class EJBClientDescriptor10Parser { \nprotected static void unexpectedElement ( final XMLExtendedStreamReader reader ) throws XMLStreamException { \nthrow EeLogger . ROOT_LOGGER . unexpectedElement ( reader . getName ( ) , reader . getLocation ( ) ) ; \nreturn ; \n} \n} \n"}
{"2680": "public class NonTxEmCloser { \npublic static void popCall ( ) { \nMap < String , EntityManager > emStack = nonTxStack . pop ( ) ; \nif ( emStack != null ) { \nfor ( EntityManager entityManager : emStack . values ( ) ) { \ntry { \nif ( entityManager . isOpen ( ) ) { \nentityManager . close ( ) ; \n} \n} \ncatch ( RuntimeException safeToIgnore ) { \nif ( ROOT_LOGGER . isTraceEnabled ( ) ) { \nROOT_LOGGER . trace ( \"Could not close (non-transactional) container managed entity manager.\" + \"  This shouldn't impact application functionality (only read \" + \"operations occur in non-transactional mode)\" , safeToIgnore ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2682": "public class TransactedJMSContext { \nvoid registerCleanUpListener ( TransactionSynchronizationRegistry transactionSynchronizationRegistry , JMSContext contextInstance ) { \nObject alreadyRegistered = transactionSynchronizationRegistry . getResource ( contextInstance ) ; \nif ( alreadyRegistered == null ) { \ntransactionSynchronizationRegistry . registerInterposedSynchronization ( new AfterCompletionSynchronization ( contextInstance ) ) ; \ntransactionSynchronizationRegistry . putResource ( contextInstance , AfterCompletionSynchronization . class . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2683": "public class WarAnnotationDeploymentProcessor { \npublic void deploy ( final DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nif ( ! DeploymentTypeMarker . isType ( DeploymentType . WAR , deploymentUnit ) ) { \nreturn ; \n} \nWarMetaData warMetaData = deploymentUnit . getAttachment ( WarMetaData . ATTACHMENT_KEY ) ; \nassert warMetaData != null ; \nMap < String , WebMetaData > annotationsMetaData = warMetaData . getAnnotationsMetaData ( ) ; \nif ( annotationsMetaData == null ) { \nannotationsMetaData = new HashMap < String , WebMetaData > ( ) ; \nwarMetaData . setAnnotationsMetaData ( annotationsMetaData ) ; \n} \nMap < ResourceRoot , Index > indexes = AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit ) ; \nfor ( final Entry < ResourceRoot , Index > entry : indexes . entrySet ( ) ) { \nfinal Index jarIndex = entry . getValue ( ) ; \nannotationsMetaData . put ( entry . getKey ( ) . getRootName ( ) , processAnnotations ( jarIndex ) ) ; \n} \nMap < ModuleIdentifier , CompositeIndex > additionalModelAnnotations = deploymentUnit . getAttachment ( Attachments . ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE ) ; \nif ( additionalModelAnnotations != null ) { \nfinal List < WebMetaData > additional = new ArrayList < WebMetaData > ( ) ; \nfor ( Entry < ModuleIdentifier , CompositeIndex > entry : additionalModelAnnotations . entrySet ( ) ) { \nfor ( Index index : entry . getValue ( ) . getIndexes ( ) ) { \nadditional . add ( processAnnotations ( index ) ) ; \n} \n} \nwarMetaData . setAdditionalModuleAnnotationsMetadata ( additional ) ; \n} \nreturn ; \n} \n} \n"}
{"2689": "public class TimerImpl { \npublic void setNextTimeout ( Date next ) { \nif ( next == null ) { \nsetTimerState ( TimerState . EXPIRED , null ) ; \n} \nthis . nextExpiration = next ; \nreturn ; \n} \n} \n"}
{"2690": "public class TimerImpl { \nprotected void setTimerState ( TimerState state , Thread thread ) { \nassert ( ( state == TimerState . IN_TIMEOUT || state == TimerState . RETRY_TIMEOUT ) && thread != null ) || thread == null : \"Invalid to set timer state \" + state + \" with executing Thread \" + thread ; \nthis . timerState = state ; \nthis . executingThread = thread ; \nreturn ; \n} \n} \n"}
{"2691": "public class ResteasyDeploymentData { \npublic void merge ( final List < ResteasyDeploymentData > deploymentData ) throws DeploymentUnitProcessingException { \nfor ( ResteasyDeploymentData data : deploymentData ) { \nscannedApplicationClasses . addAll ( data . getScannedApplicationClasses ( ) ) ; \nif ( scanResources ) { \nscannedResourceClasses . addAll ( data . getScannedResourceClasses ( ) ) ; \nscannedJndiComponentResources . addAll ( data . getScannedJndiComponentResources ( ) ) ; \n} \nif ( scanProviders ) { \nscannedProviderClasses . addAll ( data . getScannedProviderClasses ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2692": "public class JavaEEDependencyProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nModuleDependency invocation = new ModuleDependency ( moduleLoader , JBOSS_INVOCATION_ID , false , false , false , false ) ; \ninvocation . addImportFilter ( PathFilters . is ( \"org/jboss/invocation/proxy/classloading\" ) , true ) ; \ninvocation . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( invocation ) ; \nModuleDependency ee = new ModuleDependency ( moduleLoader , JBOSS_AS_EE , false , false , false , false ) ; \nee . addImportFilter ( PathFilters . is ( \"org/jboss/as/ee/component/serialization\" ) , true ) ; \nee . addImportFilter ( PathFilters . is ( \"org/jboss/as/ee/concurrent\" ) , true ) ; \nee . addImportFilter ( PathFilters . is ( \"org/jboss/as/ee/concurrent/handle\" ) , true ) ; \nee . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( ee ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . create ( WILDFLY_NAMING ) , false , false , false , false ) ) ; \nfor ( final ModuleIdentifier moduleIdentifier : JAVA_EE_API_MODULES ) { \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , moduleIdentifier , true , false , true , false ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2693": "public class EJBComponentDescription { \nprotected void addRemoteTransactionsDependency ( ) { \nthis . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration componentConfiguration ) throws DeploymentUnitProcessingException { \nif ( this . hasRemoteView ( ( EJBComponentDescription ) description ) ) { \ncomponentConfiguration . getCreateDependencies ( ) . add ( ( sb , cs ) -> sb . requires ( TxnServices . JBOSS_TXN_REMOTE_TRANSACTION_SERVICE ) ) ; \n} \nreturn ; \n} \nprivate boolean hasRemoteView ( final EJBComponentDescription ejbComponentDescription ) { \nfinal Set < ViewDescription > views = ejbComponentDescription . getViews ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( ! ( view instanceof EJBViewDescription ) ) { \ncontinue ; \n} \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . REMOTE || viewType == MethodIntf . HOME ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"2696": "public class MessagingSubsystemParser { \nprotected static void checkOnlyOneOfElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { \nif ( ! seen . contains ( element1 ) && ! seen . contains ( element2 ) ) { \nthrow new XMLStreamException ( MessagingLogger . ROOT_LOGGER . required ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \nif ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { \nthrow new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2705": "public class IRObjectImpl { \npublic void shutdown ( ) { \nPOA poa = getPOA ( ) ; \ntry { \npoa . deactivate_object ( poa . reference_to_id ( getReference ( ) ) ) ; \n} \ncatch ( UserException ex ) { \nIIOPLogger . ROOT_LOGGER . warnCouldNotDeactivateIRObject ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"2710": "public class WildFlyBindingRegistry { \n@ Override public void unbind ( String name ) { \nif ( name == null || name . isEmpty ( ) ) { \nthrow MessagingLogger . ROOT_LOGGER . cannotUnbindJndiName ( ) ; \n} \nfinal ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; \nServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; \nif ( bindingService == null ) { \nROOT_LOGGER . debugf ( \"Cannot unbind %s since no binding exists with that name\" , name ) ; \nreturn ; \n} \nbindingService . setMode ( ServiceController . Mode . REMOVE ) ; \nfinal StabilityMonitor monitor = new StabilityMonitor ( ) ; \nmonitor . addController ( bindingService ) ; \ntry { \nmonitor . awaitStability ( ) ; \nROOT_LOGGER . unboundJndiName ( bindInfo . getAbsoluteJndiName ( ) ) ; \n} \ncatch ( InterruptedException e ) { \nROOT_LOGGER . failedToUnbindJndiName ( name , 5 , SECONDS . toString ( ) . toLowerCase ( Locale . US ) ) ; \n} \nfinally { \nmonitor . removeController ( bindingService ) ; \n} \nreturn ; \n} \n} \n"}
{"2712": "public class BeanUtils { \npublic static void configure ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , Module module , Object bean , boolean nullify ) throws Throwable { \nSet < PropertyConfig > properties = beanConfig . getProperties ( ) ; \nif ( properties != null ) { \nList < PropertyConfig > used = new ArrayList < PropertyConfig > ( ) ; \nfor ( PropertyConfig pc : properties ) { \ntry { \nconfigure ( beanInfo , module , bean , pc , nullify ) ; \nused . add ( pc ) ; \n} \ncatch ( Throwable t ) { \nif ( nullify == false ) { \nfor ( PropertyConfig upc : used ) { \ntry { \nconfigure ( beanInfo , module , bean , upc , true ) ; \n} \ncatch ( Throwable ignored ) { \n} \n} \nthrow new StartException ( t ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2713": "public class BeanUtils { \npublic static void dispatchLifecycleJoinpoint ( BeanInfo beanInfo , Object bean , LifecycleConfig config , String defaultMethod ) throws Throwable { \nif ( config != null && config . isIgnored ( ) ) return ; \nJoinpoint joinpoint = createJoinpoint ( beanInfo , bean , config , defaultMethod ) ; \nif ( joinpoint != null ) joinpoint . dispatch ( ) ; \nreturn ; \n} \n} \n"}
{"2718": "public class SessionBeanComponentDescriptionFactory { \n@ Override protected void processAnnotations ( final DeploymentUnit deploymentUnit , final CompositeIndex compositeIndex ) throws DeploymentUnitProcessingException { \nif ( MetadataCompleteMarker . isMetadataComplete ( deploymentUnit ) ) { \nreturn ; \n} \nfinal List < AnnotationInstance > slsbAnnotations = compositeIndex . getAnnotations ( STATELESS_ANNOTATION ) ; \nif ( ! slsbAnnotations . isEmpty ( ) ) { \nprocessSessionBeans ( deploymentUnit , slsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATELESS ) ; \n} \nfinal List < AnnotationInstance > sfsbAnnotations = compositeIndex . getAnnotations ( STATEFUL_ANNOTATION ) ; \nif ( ! sfsbAnnotations . isEmpty ( ) ) { \nprocessSessionBeans ( deploymentUnit , sfsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATEFUL ) ; \n} \nfinal List < AnnotationInstance > sbAnnotations = compositeIndex . getAnnotations ( SINGLETON_ANNOTATION ) ; \nif ( ! sbAnnotations . isEmpty ( ) ) { \nprocessSessionBeans ( deploymentUnit , sbAnnotations , SessionBeanComponentDescription . SessionBeanType . SINGLETON ) ; \n} \nreturn ; \n} \n} \n"}
{"2719": "public class PersistenceUnitParseProcessor { \nprivate void postParseSteps ( final VirtualFile persistence_xml , final PersistenceUnitMetadataHolder puHolder , final DeploymentUnit deploymentUnit ) { \nfor ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { \nList < URL > jarfilesUrls = new ArrayList < URL > ( ) ; \nif ( pu . getJarFiles ( ) != null ) { \nfor ( String jar : pu . getJarFiles ( ) ) { \njarfilesUrls . add ( getRelativeURL ( persistence_xml , jar ) ) ; \n} \n} \npu . setJarFileUrls ( jarfilesUrls ) ; \nURL url = getPersistenceUnitURL ( persistence_xml ) ; \npu . setPersistenceUnitRootUrl ( url ) ; \nString scopedPersistenceUnitName ; \nscopedPersistenceUnitName = Configuration . getScopedPersistenceUnitName ( pu ) ; \nif ( scopedPersistenceUnitName == null ) { \nscopedPersistenceUnitName = createBeanName ( deploymentUnit , pu . getPersistenceUnitName ( ) ) ; \n} \nelse { \nROOT_LOGGER . tracef ( \"persistence unit '%s' specified a custom scoped persistence unit name hint \" + \"(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments.\" , pu . getPersistenceUnitName ( ) , scopedPersistenceUnitName ) ; \nif ( scopedPersistenceUnitName . indexOf ( '/' ) != - 1 ) { \nthrow JpaLogger . ROOT_LOGGER . invalidScopedName ( scopedPersistenceUnitName , '/' ) ; \n} \n} \npu . setScopedPersistenceUnitName ( scopedPersistenceUnitName ) ; \n} \nreturn ; \n} \n} \n"}
{"2721": "public class WebMetaDataCreator { \nvoid create ( final Deployment dep ) { \nfinal DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; \nWarMetaData warMD = ASHelper . getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; \nJBossWebMetaData jbossWebMD = warMD != null ? warMD . getMergedJBossWebMetaData ( ) : null ; \nif ( warMD == null ) { \nwarMD = new WarMetaData ( ) ; \n} \nif ( jbossWebMD == null ) { \njbossWebMD = new JBossWebMetaData ( ) ; \nwarMD . setMergedJBossWebMetaData ( jbossWebMD ) ; \nunit . putAttachment ( WarMetaData . ATTACHMENT_KEY , warMD ) ; \n} \ncreateWebAppDescriptor ( dep , jbossWebMD ) ; \ncreateJBossWebAppDescriptor ( dep , jbossWebMD ) ; \ndep . addAttachment ( JBossWebMetaData . class , jbossWebMD ) ; \nreturn ; \n} \n} \n"}
{"2722": "public class WebMetaDataCreator { \nprivate void createWebAppDescriptor ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nWSLogger . ROOT_LOGGER . trace ( \"Creating web.xml descriptor\" ) ; \ncreateServlets ( dep , jbossWebMD ) ; \ncreateServletMappings ( dep , jbossWebMD ) ; \ncreateSecurityConstraints ( dep , jbossWebMD ) ; \ncreateLoginConfig ( dep , jbossWebMD ) ; \ncreateSecurityRoles ( dep , jbossWebMD ) ; \nreturn ; \n} \n} \n"}
{"2724": "public class ServiceDeploymentParsingProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; \nif ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; \nVirtualFile serviceXmlFile = null ; \nif ( deploymentRoot . isDirectory ( ) ) { \nserviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; \n} \nelse if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { \nserviceXmlFile = deploymentRoot ; \n} \nif ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; \nfinal XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; \nfinal JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; \nxmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nxmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nInputStream xmlStream = null ; \ntry { \nxmlStream = serviceXmlFile . openStream ( ) ; \nfinal XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; \nfinal ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; \nxmlMapper . parseDocument ( result , reader ) ; \nfinal JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; \nif ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \nelse throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; \n} \ncatch ( Exception e ) { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; \n} \nfinally { \nVFSUtils . safeClose ( xmlStream ) ; \n} \nreturn ; \n} \n} \n"}
{"2725": "public class DeploymentDescriptorMethodProcessor { \nprivate void handleStatelessSessionBean ( final EJBComponentDescription component , final Module module , final DeploymentReflectionIndex reflectionIndex ) throws ClassNotFoundException , DeploymentUnitProcessingException { \nfinal Class < ? > componentClass = ClassLoadingUtils . loadClass ( component . getComponentClassName ( ) , module ) ; \nfinal MethodIdentifier ejbCreateId = MethodIdentifier . getIdentifier ( void . class , \"ejbCreate\" ) ; \nfinal Method ejbCreate = ClassReflectionIndexUtil . findMethod ( reflectionIndex , componentClass , ejbCreateId ) ; \nif ( ejbCreate != null ) { \nfinal InterceptorClassDescription . Builder builder = InterceptorClassDescription . builder ( ) ; \nbuilder . setPostConstruct ( ejbCreateId ) ; \ncomponent . addInterceptorMethodOverride ( ejbCreate . getDeclaringClass ( ) . getName ( ) , builder . build ( ) ) ; \n} \nfinal MethodIdentifier ejbRemoveId = MethodIdentifier . getIdentifier ( void . class , \"ejbRemove\" ) ; \nfinal Method ejbRemove = ClassReflectionIndexUtil . findMethod ( reflectionIndex , componentClass , ejbRemoveId ) ; \nif ( ejbRemove != null ) { \nfinal InterceptorClassDescription . Builder builder = InterceptorClassDescription . builder ( ) ; \nbuilder . setPreDestroy ( ejbRemoveId ) ; \ncomponent . addInterceptorMethodOverride ( ejbRemove . getDeclaringClass ( ) . getName ( ) , builder . build ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2729": "public class PersistenceProviderResolverImpl { \npublic void clearCachedDeploymentSpecificProviders ( Set < ClassLoader > deploymentClassLoaders ) { \nsynchronized ( persistenceProviderPerClassLoader ) { \nfor ( ClassLoader deploymentClassLoader : deploymentClassLoaders ) { \npersistenceProviderPerClassLoader . remove ( deploymentClassLoader ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2730": "public class PersistenceProviderResolverImpl { \npublic void addDeploymentSpecificPersistenceProvider ( PersistenceProvider persistenceProvider , Set < ClassLoader > deploymentClassLoaders ) { \nsynchronized ( persistenceProviderPerClassLoader ) { \nfor ( ClassLoader deploymentClassLoader : deploymentClassLoaders ) { \nList < Class < ? extends PersistenceProvider > > list = persistenceProviderPerClassLoader . get ( deploymentClassLoader ) ; \nROOT_LOGGER . tracef ( \"getting persistence provider list (%s) for deployment (%s)\" , list , deploymentClassLoader ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \npersistenceProviderPerClassLoader . put ( deploymentClassLoader , list ) ; \nROOT_LOGGER . tracef ( \"saving new persistence provider list (%s) for deployment (%s)\" , list , deploymentClassLoader ) ; \n} \nlist . add ( persistenceProvider . getClass ( ) ) ; \nROOT_LOGGER . tracef ( \"added new persistence provider (%s) to provider list (%s)\" , persistenceProvider . getClass ( ) . getName ( ) , list ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2732": "public class SarModuleDependencyProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit . getAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY ) ; \nif ( serviceXmlDescriptor == null ) { \nreturn ; \n} \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_MODULES_ID , false , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_AS_SYSTEM_JMX_ID , true , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , PROPERTIES_EDITOR_MODULE_ID , false , false , true , false ) ) ; \nmoduleSpecification . addPermissionFactory ( REGISTER_PERMISSION_FACTORY ) ; \nreturn ; \n} \n} \n"}
{"2733": "public class PersistenceUnitServiceHandler { \nprivate static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { \nif ( puList . size ( ) > 0 ) { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nfinal EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; \nfinal ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; \nfinal ModuleClassLoader classLoader = module . getClassLoader ( ) ; \nfor ( PersistenceUnitMetadataHolder holder : puList ) { \nsetAnnotationIndexes ( holder , deploymentUnit ) ; \nfor ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { \nString jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; \nboolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; \nif ( deployPU ) { \nfinal PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; \nfinal PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; \nfinal PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; \nfinal boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; \nif ( startEarly ) { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; \n} \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; \n} \nelse { \nfinal boolean allowCdiBeanManagerAccess = false ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \nelse { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; \n} \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nfinal boolean allowCdiBeanManagerAccess = true ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \n} \nelse { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2734": "public class PersistenceUnitServiceHandler { \nprivate static void setAnnotationIndexes ( final PersistenceUnitMetadataHolder puHolder , DeploymentUnit deploymentUnit ) { \nfinal Map < URL , Index > annotationIndexes = new HashMap < > ( ) ; \ndo { \nfor ( ResourceRoot root : DeploymentUtils . allResourceRoots ( deploymentUnit ) ) { \nfinal Index index = root . getAttachment ( Attachments . ANNOTATION_INDEX ) ; \nif ( index != null ) { \ntry { \nROOT_LOGGER . tracef ( \"adding '%s' to annotation index map\" , root . getRoot ( ) . toURL ( ) ) ; \nannotationIndexes . put ( root . getRoot ( ) . toURL ( ) , index ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \ndeploymentUnit = deploymentUnit . getParent ( ) ; \n} \nwhile ( deploymentUnit != null ) ; \nfor ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { \npu . setAnnotationIndex ( annotationIndexes ) ; \n} \nreturn ; \n} \n} \n"}
{"2740": "public class AbstractMetaDataBuilderEJB { \nprotected void buildEnterpriseBeanMetaData ( final List < EJBMetaData > wsEjbsMD , final EJBEndpoint ejbEndpoint , final JBossWebservicesMetaData jbossWebservicesMD ) { \nfinal SLSBMetaData . Builder wsEjbMDBuilder = new SLSBMetaData . Builder ( ) ; \nwsEjbMDBuilder . setEjbName ( ejbEndpoint . getName ( ) ) ; \nwsEjbMDBuilder . setEjbClass ( ejbEndpoint . getClassName ( ) ) ; \nfinal JBossPortComponentMetaData portComponentMD = getPortComponent ( ejbEndpoint . getName ( ) , jbossWebservicesMD ) ; \nif ( portComponentMD != null ) { \nwsEjbMDBuilder . setPortComponentName ( portComponentMD . getPortComponentName ( ) ) ; \nwsEjbMDBuilder . setPortComponentURI ( portComponentMD . getPortComponentURI ( ) ) ; \n} \nfinal String authMethod = getAuthMethod ( ejbEndpoint , portComponentMD ) ; \nfinal String transportGuarantee = getTransportGuarantee ( ejbEndpoint , portComponentMD ) ; \nfinal boolean secureWsdlAccess = isSecureWsdlAccess ( ejbEndpoint , portComponentMD ) ; \nfinal String realmName = getRealmName ( ejbEndpoint , portComponentMD ) ; \nwsEjbMDBuilder . setSecurityMetaData ( new EJBSecurityMetaData ( authMethod , realmName , transportGuarantee , secureWsdlAccess ) ) ; \nwsEjbsMD . add ( wsEjbMDBuilder . build ( ) ) ; \nreturn ; \n} \n} \n"}
{"2741": "public class LogStoreParticipantRecoveryHandler { \nvoid refreshParticipant ( OperationContext context ) { \ncontext . addStep ( refreshHandler , OperationContext . Stage . MODEL , true ) ; \nreturn ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( int j = 0 ; \nj < i ; \n++ j ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \n} \nfor ( int i = 0 ; \ni < entries . size ( ) ; \n++ i ) { \nif ( ! clash [ i ] ) continue ; \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( int j = 0 ; \nj < name . length ( ) ; \n++ j ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; \nif ( noUpper ) noUpper = false ; \nelse b . append ( '_' ) ; \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2756": "public class XTSSubsystemParser { \nprivate void parseXTSEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { \nprocessAttributes ( reader , ( index , attribute ) -> { \nfinal String value = reader . getAttributeValue ( index ) ; \nswitch ( attribute ) { \ncase URL : ENVIRONMENT_URL . parseAndSetParameter ( value , subsystem , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , index ) ; \n} \n} \n) ; \nParseUtils . requireNoContent ( reader ) ; \nreturn ; \n} \n} \n"}
{"2757": "public class XTSSubsystemParser { \nprivate void parseDefaultContextPropagationElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { \nprocessAttributes ( reader , ( index , attribute ) -> { \nfinal String value = reader . getAttributeValue ( index ) ; \nswitch ( attribute ) { \ncase ENABLED : if ( value == null || ( ! value . toLowerCase ( ) . equals ( \"true\" ) && ! value . toLowerCase ( ) . equals ( \"false\" ) ) ) { \nthrow ParseUtils . invalidAttributeValue ( reader , index ) ; \n} \nDEFAULT_CONTEXT_PROPAGATION . parseAndSetParameter ( value , subsystem , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , index ) ; \n} \n} \n) ; \nParseUtils . requireNoContent ( reader ) ; \nreturn ; \n} \n} \n"}
{"2758": "public class XTSSubsystemParser { \nprivate void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nParseUtils . requireNoNamespaceAttribute ( reader , i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nattributeProcessorCallback . process ( i , attribute ) ; \n} \nreturn ; \n} \n} \n"}
{"2760": "public class ManagementHelper { \nstatic AbstractAddStepHandler createAddOperation ( final String childType , final boolean allowSibling , Collection < ? extends AttributeDefinition > attributes ) { \nreturn new ActiveMQReloadRequiredHandlers . AddStepHandler ( attributes ) { \n@ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { \nsuper . execute ( context , operation ) ; \nif ( ! allowSibling ) { \ncontext . addStep ( checkNoOtherSibling ( childType ) , MODEL ) ; \n} \nreturn ; \n} \n} \n; \n} \n} \n"}
{"2761": "public class EjbDependencyDeploymentUnitProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nDeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , JAX_RPC_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_NAMING_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_IIOP_CLIENT , false , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_SUBSYSTEM , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_EJB , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_NAMING , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_TRANSACTION , false , false , true , false ) ) ; \nif ( IIOPDeploymentMarker . isIIOPDeployment ( deploymentUnit ) ) { \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , IIOP_OPENJDK , false , false , false , false ) ) ; \n} \nif ( ! isEjbDeployment ( deploymentUnit ) && ! DeploymentTypeMarker . isType ( DeploymentType . APPLICATION_CLIENT , deploymentUnit ) ) { \nreturn ; \n} \nif ( Boolean . getBoolean ( \"org.jboss.as.ejb3.EMBEDDED\" ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . CLASSPATH , false , false , false , false ) ) ; \nreturn ; \n} \n} \n"}
{"2766": "public class WSEndpointHandlersMapping { \npublic void registerEndpointHandlers ( final String endpointClass , final Set < String > endpointHandlers ) { \nif ( ( endpointClass == null ) || ( endpointHandlers == null ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nendpointHandlersMap . put ( endpointClass , Collections . unmodifiableSet ( endpointHandlers ) ) ; \nreturn ; \n} \n} \n"}
{"2768": "public class WildFlyJobXmlResolver { \nprivate void init ( final ClassLoader classLoader ) { \nfor ( JobXmlResolver resolver : ServiceLoader . load ( JobXmlResolver . class , classLoader ) ) { \njobXmlResolvers . add ( resolver ) ; \nfor ( String jobXml : resolver . getJobXmlNames ( classLoader ) ) { \naddJob ( jobXml , resolver . resolveJobName ( jobXml , classLoader ) ) ; \n} \n} \nfor ( Map . Entry < String , VirtualFile > entry : jobXmlFiles . entrySet ( ) ) { \ntry { \nfinal Job job = JobParser . parseJob ( entry . getValue ( ) . openStream ( ) , classLoader , new XMLResolver ( ) { \n@ Override public Object resolveEntity ( final String publicID , final String systemID , final String baseURI , final String namespace ) throws XMLStreamException { \ntry { \nreturn ( jobXmlFiles . containsKey ( systemID ) ? jobXmlFiles . get ( systemID ) . openStream ( ) : null ) ; \n} \ncatch ( IOException e ) { \nthrow new XMLStreamException ( e ) ; \n} \n} \n} \n) ; \naddJob ( entry . getKey ( ) , job . getId ( ) ) ; \n} \ncatch ( XMLStreamException | IOException e ) { \nBatchLogger . LOGGER . invalidJobXmlFile ( entry . getKey ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2772": "public class CNCtx { \npublic void bind ( String name , java . lang . Object obj ) throws NamingException { \nbind ( new CompositeName ( name ) , obj ) ; \nreturn ; \n} \n} \n"}
{"2773": "public class CNCtx { \nprivate void callUnbind ( NameComponent [ ] path ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; \ntry { \n_nc . unbind ( path ) ; \n} \ncatch ( NotFound e ) { \nif ( leafNotFound ( e , path [ path . length - 1 ] ) ) { \n} \nelse { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; \n} \nreturn ; \n} \n} \n"}
{"2775": "public class CNCtx { \nprivate void callDestroy ( NamingContext nc ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( nc . toString ( ) ) ; \ntry { \nnc . destroy ( ) ; \n} \ncatch ( Exception e ) { \nthrow org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , null ) ; \n} \nreturn ; \n} \n} \n"}
{"2776": "public class CNCtx { \npublic void destroySubcontext ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nNamingContext the_nc = _nc ; \nNameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; \nif ( name . size ( ) > 0 ) { \ntry { \njavax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; \nCNCtx cnc = ( CNCtx ) ctx ; \nthe_nc = cnc . _nc ; \ncnc . close ( ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \ncatch ( CannotProceedException e ) { \njavax . naming . Context cctx = getContinuationContext ( e ) ; \ncctx . destroySubcontext ( e . getRemainingName ( ) ) ; \nreturn ; \n} \ncatch ( NameNotFoundException e ) { \nif ( e . getRootCause ( ) instanceof NotFound && leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) { \nreturn ; \n} \nthrow e ; \n} \ncatch ( NamingException e ) { \nthrow e ; \n} \n} \ncallDestroy ( the_nc ) ; \ncallUnbind ( path ) ; \nreturn ; \n} \n} \n"}
{"2782": "public class AbstractProtocolResourceDefinition { \n@ SuppressWarnings ( \"deprecation\" ) static void addTransformations ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { \nif ( JGroupsModel . VERSION_5_0_0 . requiresTransformation ( version ) ) { \nbuilder . getAttributeBuilder ( ) . setDiscard ( DiscardAttributeChecker . UNDEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . end ( ) ; \n} \nif ( JGroupsModel . VERSION_3_0_0 . requiresTransformation ( version ) ) { \nAttributeConverter typeConverter = new AttributeConverter . DefaultAttributeConverter ( ) { \n@ Override protected void convertAttribute ( PathAddress address , String name , ModelNode value , TransformationContext context ) { \nif ( ! value . isDefined ( ) ) { \nvalue . set ( address . getLastElement ( ) . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n; \nbuilder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( Attribute . MODULE . getDefinition ( ) . getDefaultValue ( ) ) , Attribute . MODULE . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . MODULE . getDefinition ( ) ) . setValueConverter ( typeConverter , DeprecatedAttribute . TYPE . getDefinition ( ) ) . end ( ) ; \nbuilder . addRawOperationTransformationOverride ( MapOperations . MAP_GET_DEFINITION . getName ( ) , new SimpleOperationTransformer ( new LegacyPropertyMapGetOperationTransformer ( ) ) ) ; \nfor ( String opName : Operations . getAllWriteAttributeOperationNames ( ) ) { \nbuilder . addOperationTransformationOverride ( opName ) . inheritResourceAttributeDefinitions ( ) . setCustomOperationTransformer ( new LegacyPropertyWriteOperationTransformer ( ) ) ; \n} \n} \nPropertyResourceDefinition . buildTransformation ( version , builder ) ; \nreturn ; \n} \n} \n"}
{"2784": "public class JNDIBasedSecurityManagement { \npublic void removeSecurityDomain ( String securityDomain ) { \nsecurityMgrMap . remove ( securityDomain ) ; \nauditMgrMap . remove ( securityDomain ) ; \nauthMgrMap . remove ( securityDomain ) ; \nauthzMgrMap . remove ( securityDomain ) ; \nidmMgrMap . remove ( securityDomain ) ; \nmappingMgrMap . remove ( securityDomain ) ; \njsseMap . remove ( securityDomain ) ; \nreturn ; \n} \n} \n"}
{"2790": "public class SecurityDomainResourceDefinition { \nprivate static void waitForService ( final ServiceController < ? > controller ) throws OperationFailedException { \nif ( controller . getState ( ) == ServiceController . State . UP ) return ; \nfinal StabilityMonitor monitor = new StabilityMonitor ( ) ; \nmonitor . addController ( controller ) ; \ntry { \nmonitor . awaitStability ( 100 , MILLISECONDS ) ; \n} \ncatch ( final InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow SecurityLogger . ROOT_LOGGER . interruptedWaitingForSecurityDomain ( controller . getName ( ) . getSimpleName ( ) ) ; \n} \nfinally { \nmonitor . removeController ( controller ) ; \n} \nif ( controller . getState ( ) != ServiceController . State . UP ) { \nthrow SecurityLogger . ROOT_LOGGER . requiredSecurityDomainServiceNotAvailable ( controller . getName ( ) . getSimpleName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2792": "public class VaultSession { \nprivate void initSecurityVault ( ) throws Exception { \ntry { \nthis . vault = SecurityVaultFactory . get ( ) ; \nthis . vault . init ( getVaultOptionsMap ( ) ) ; \nhandshake ( ) ; \n} \ncatch ( SecurityVaultException e ) { \nthrow SecurityLogger . ROOT_LOGGER . securityVaultException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"2793": "public class VaultSession { \npublic void startVaultSession ( String vaultAlias ) throws Exception { \nif ( vaultAlias == null ) { \nthrow SecurityLogger . ROOT_LOGGER . vaultAliasNotSpecified ( ) ; \n} \nthis . keystoreMaskedPassword = ( org . jboss . security . Util . isPasswordCommand ( keystorePassword ) ) ? keystorePassword : computeMaskedPassword ( ) ; \nthis . vaultAlias = vaultAlias ; \ninitSecurityVault ( ) ; \nreturn ; \n} \n} \n"}
{"2794": "public class VaultSession { \nprivate void attributeCreatedDisplay ( String vaultBlock , String attributeName ) { \nSystem . out . println ( SecurityLogger . ROOT_LOGGER . vaultAttributeCreateDisplay ( vaultBlock , attributeName , securedAttributeConfigurationString ( vaultBlock , attributeName ) ) ) ; \nreturn ; \n} \n} \n"}
{"2795": "public class VaultSession { \npublic void vaultConfigurationDisplay ( ) { \nfinal String configuration = vaultConfiguration ( ) ; \nSystem . out . println ( SecurityLogger . ROOT_LOGGER . vaultConfigurationTitle ( ) ) ; \nSystem . out . println ( \"********************************************\" ) ; \nSystem . out . println ( \"For standalone mode:\" ) ; \nSystem . out . println ( configuration ) ; \nSystem . out . println ( \"********************************************\" ) ; \nSystem . out . println ( \"For domain mode:\" ) ; \nSystem . out . println ( \"/host=the_host\" + configuration ) ; \nSystem . out . println ( \"********************************************\" ) ; \nreturn ; \n} \n} \n"}
{"2799": "public class ConstantAnalysis { \npublic void insertValue ( Any any ) { \nif ( type == String . class ) any . insert_wstring ( ( String ) value ) ; \nelse Util . insertAnyPrimitive ( any , value ) ; \nreturn ; \n} \n} \n"}
{"2803": "public class ServiceMBeanSupport { \nprivate void sendStateChangeNotification ( int oldState , int newState , String msg , Throwable t ) { \nlong now = System . currentTimeMillis ( ) ; \nAttributeChangeNotification stateChangeNotification = new AttributeChangeNotification ( this , getNextNotificationSequenceNumber ( ) , now , msg , \"State\" , \"java.lang.Integer\" , new Integer ( oldState ) , new Integer ( newState ) ) ; \nstateChangeNotification . setUserData ( t ) ; \nsendNotification ( stateChangeNotification ) ; \nreturn ; \n} \n} \n"}
{"2808": "public class ComponentDescription { \npublic void addMethodInterceptor ( MethodIdentifier method , InterceptorDescription description ) { \nList < InterceptorDescription > interceptors = methodInterceptors . get ( method ) ; \nif ( interceptors == null ) { \nmethodInterceptors . put ( method , interceptors = new ArrayList < InterceptorDescription > ( ) ) ; \n} \nfinal String name = description . getInterceptorClassName ( ) ; \ninterceptors . add ( description ) ; \nthis . allInterceptors = null ; \nreturn ; \n} \n} \n"}
{"2809": "public class ComponentDescription { \npublic void addDependency ( ServiceName serviceName ) { \nif ( serviceName == null ) { \nthrow EeLogger . ROOT_LOGGER . nullVar ( \"serviceName\" , \"component\" , componentName ) ; \n} \ndependencies . add ( serviceName ) ; \nreturn ; \n} \n} \n"}
{"2812": "public class ComponentConfiguration { \npublic void addTimeoutViewInterceptor ( final Method method , InterceptorFactory factory , int priority ) { \nOrderedItemContainer < InterceptorFactory > interceptors = timeoutInterceptors . get ( method ) ; \nif ( interceptors == null ) { \ntimeoutInterceptors . put ( method , interceptors = new OrderedItemContainer < InterceptorFactory > ( ) ) ; \n} \ninterceptors . add ( factory , priority ) ; \nreturn ; \n} \n} \n"}
{"2813": "public class ComponentConfiguration { \npublic void addAroundConstructInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \naroundConstructInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; \nreturn ; \n} \n} \n"}
{"2814": "public class ComponentConfiguration { \npublic void addPostConstructInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \npostConstructInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; \nreturn ; \n} \n} \n"}
{"2815": "public class ComponentConfiguration { \npublic void addPreDestroyInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \npreDestroyInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; \nreturn ; \n} \n} \n"}
{"2816": "public class ComponentConfiguration { \npublic void addPrePassivateInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \nprePassivateInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; \nreturn ; \n} \n} \n"}
{"2817": "public class ComponentConfiguration { \npublic void addPostActivateInterceptor ( InterceptorFactory interceptorFactory , int priority ) { \npostActivateInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; \nreturn ; \n} \n} \n"}
{"2818": "public class ComponentConfiguration { \npublic void setComponentCreateServiceFactory ( final ComponentCreateServiceFactory componentCreateServiceFactory ) { \nif ( componentCreateServiceFactory == null ) { \nthrow EeLogger . ROOT_LOGGER . nullVar ( \"componentCreateServiceFactory\" , \"component\" , getComponentName ( ) ) ; \n} \nthis . componentCreateServiceFactory = componentCreateServiceFactory ; \nreturn ; \n} \n} \n"}
{"2819": "public class PooledConnectionFactoryRemove { \nprotected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { \nif ( entries . size ( ) > 1 ) { \nfor ( int i = 1 ; \ni < entries . size ( ) ; \ni ++ ) { \nContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; \ncontext . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2820": "public class EJBClientConfiguratorService { \npublic void accept ( final EJBClientContext . Builder builder ) { \nfinal EJBTransportProvider remoteTransportProvider = this . remoteTransportProvider ; \nif ( remoteTransportProvider != null ) { \nbuilder . addTransportProvider ( remoteTransportProvider ) ; \nbuilder . addTransportProvider ( remoteHttpTransportProvider ) ; \n} \nreturn ; \n} \n} \n"}
{"2830": "public class NamingService { \npublic void start ( StartContext context ) throws StartException { \nROOT_LOGGER . startingService ( ) ; \ntry { \nNamingContext . setActiveNamingStore ( namingStore . getValue ( ) ) ; \n} \ncatch ( Throwable t ) { \nthrow new StartException ( NamingLogger . ROOT_LOGGER . failedToStart ( \"naming service\" ) , t ) ; \n} \nreturn ; \n} \n} \n"}
{"2831": "public class WeldComponentIntegrationProcessor { \nprivate void addWeldIntegration ( final Iterable < ComponentIntegrator > componentIntegrators , final ComponentInterceptorSupport componentInterceptorSupport , final ServiceTarget target , final ComponentConfiguration configuration , final ComponentDescription description , final Class < ? > componentClass , final String beanName , final ServiceName weldServiceName , final ServiceName weldStartService , final ServiceName beanManagerService , final Set < Class < ? > > interceptorClasses , final ClassLoader classLoader , final String beanDeploymentArchiveId ) { \nfinal ServiceName serviceName = configuration . getComponentDescription ( ) . getServiceName ( ) . append ( \"WeldInstantiator\" ) ; \nfinal ServiceBuilder < ? > builder = target . addService ( serviceName ) ; \nbuilder . requires ( weldStartService ) ; \nconfiguration . setInstanceFactory ( WeldManagedReferenceFactory . INSTANCE ) ; \nconfiguration . getStartDependencies ( ) . add ( new DependencyConfigurator < ComponentStartService > ( ) { \n@ Override public void configureDependency ( final ServiceBuilder < ? > serviceBuilder , ComponentStartService service ) throws DeploymentUnitProcessingException { \nserviceBuilder . requires ( serviceName ) ; \nreturn ; \n} \n} \n) ; \nboolean isComponentIntegrationPerformed = false ; \nfor ( ComponentIntegrator componentIntegrator : componentIntegrators ) { \nSupplier < ServiceName > bindingServiceNameSupplier = ( ) -> { \nif ( componentInterceptorSupport == null ) { \nthrow WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; \n} \nreturn addWeldInterceptorBindingService ( target , configuration , componentClass , beanName , weldServiceName , weldStartService , beanDeploymentArchiveId , componentInterceptorSupport ) ; \n} \n; \nDefaultInterceptorIntegrationAction integrationAction = ( bindingServiceName ) -> { \nif ( componentInterceptorSupport == null ) { \nthrow WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; \n} \naddJsr299BindingsCreateInterceptor ( configuration , description , beanName , weldServiceName , builder , bindingServiceName , componentInterceptorSupport ) ; \naddCommonLifecycleInterceptionSupport ( configuration , builder , bindingServiceName , beanManagerService , componentInterceptorSupport ) ; \nconfiguration . addComponentInterceptor ( new UserInterceptorFactory ( factory ( InterceptionType . AROUND_INVOKE , builder , bindingServiceName , componentInterceptorSupport ) , factory ( InterceptionType . AROUND_TIMEOUT , builder , bindingServiceName , componentInterceptorSupport ) ) , InterceptorOrder . Component . CDI_INTERCEPTORS , false ) ; \n} \n; \nif ( componentIntegrator . integrate ( beanManagerService , configuration , description , builder , bindingServiceNameSupplier , integrationAction , componentInterceptorSupport ) ) { \nisComponentIntegrationPerformed = true ; \nbreak ; \n} \n} \nreturn ; \n} \n\n"}
{"2833": "public class EEApplicationDescription { \npublic void addComponent ( final ComponentDescription description , final VirtualFile deploymentRoot ) { \nfor ( final ViewDescription viewDescription : description . getViews ( ) ) { \nList < ViewInformation > viewComponents = componentsByViewName . get ( viewDescription . getViewClassName ( ) ) ; \nif ( viewComponents == null ) { \nviewComponents = new ArrayList < ViewInformation > ( 1 ) ; \ncomponentsByViewName . put ( viewDescription . getViewClassName ( ) , viewComponents ) ; \n} \nviewComponents . add ( new ViewInformation ( viewDescription , deploymentRoot , description . getComponentName ( ) ) ) ; \n} \nList < Description > components = componentsByName . get ( description . getComponentName ( ) ) ; \nif ( components == null ) { \ncomponentsByName . put ( description . getComponentName ( ) , components = new ArrayList < Description > ( 1 ) ) ; \n} \ncomponents . add ( new Description ( description , deploymentRoot ) ) ; \nreturn ; \n} \n} \n"}
{"2834": "public class EEApplicationDescription { \npublic void addMessageDestination ( final String name , final String resolvedName , final VirtualFile deploymentRoot ) { \nList < MessageDestinationMapping > components = messageDestinationJndiMapping . get ( name ) ; \nif ( components == null ) { \nmessageDestinationJndiMapping . put ( name , components = new ArrayList < MessageDestinationMapping > ( 1 ) ) ; \n} \ncomponents . add ( new MessageDestinationMapping ( resolvedName , deploymentRoot ) ) ; \nreturn ; \n} \n} \n"}
{"2839": "public class MessagingTransformers { \nprivate static void buildTransformers2_1_0 ( ResourceTransformationDescriptionBuilder builder ) { \nResourceTransformationDescriptionBuilder hornetqServer = builder . addChildResource ( pathElement ( HORNETQ_SERVER ) ) ; \nResourceTransformationDescriptionBuilder addressSetting = hornetqServer . addChildResource ( AddressSettingDefinition . PATH ) ; \nrejectDefinedAttributeWithDefaultValue ( addressSetting , MAX_REDELIVERY_DELAY , REDELIVERY_MULTIPLIER ) ; \nResourceTransformationDescriptionBuilder bridge = hornetqServer . addChildResource ( BridgeDefinition . PATH ) ; \nbridge . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; \nResourceTransformationDescriptionBuilder clusterConnection = hornetqServer . addChildResource ( ClusterConnectionDefinition . PATH ) ; \nclusterConnection . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; \nResourceTransformationDescriptionBuilder connectionFactory = hornetqServer . addChildResource ( ConnectionFactoryDefinition . PATH ) ; \nconnectionFactory . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; \nResourceTransformationDescriptionBuilder pooledConnectionFactory = hornetqServer . addChildResource ( PooledConnectionFactoryDefinition . PATH ) ; \npooledConnectionFactory . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; \nreturn ; \n} \n} \n"}
{"2840": "public class MessagingTransformers { \nprivate static void rejectDefinedAttributeWithDefaultValue ( ResourceTransformationDescriptionBuilder builder , AttributeDefinition ... attrs ) { \nfor ( AttributeDefinition attr : attrs ) { \nbuilder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeValueChecker ( attr . getDefaultValue ( ) ) , attr ) . addRejectCheck ( DEFINED , attr ) ; \n} \nreturn ; \n} \n} \n"}
{"2841": "public class MessagingTransformers { \nprivate static void renameAttribute ( ResourceTransformationDescriptionBuilder builder , AttributeDefinition attribute , AttributeDefinition alias ) { \nbuilder . getAttributeBuilder ( ) . addRename ( attribute , alias . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"2842": "public class ConnectionSecurityContext { \npublic static void popIdentity ( final ContextStateCache stateCache ) { \nRemotingContext . setConnection ( stateCache . getConnection ( ) ) ; \nSecurityContextAssociation . setSecurityContext ( stateCache . getSecurityContext ( ) ) ; \nreturn ; \n} \n} \n"}
{"2843": "public class JSFModuleIdFactory { \nprivate void loadIdsManually ( ) { \nimplIds . put ( \"main\" , ModuleIdentifier . create ( IMPL_MODULE ) ) ; \napiIds . put ( \"main\" , ModuleIdentifier . create ( API_MODULE ) ) ; \ninjectionIds . put ( \"main\" , ModuleIdentifier . create ( INJECTION_MODULE ) ) ; \nallVersions . add ( \"main\" ) ; \nactiveVersions . add ( \"main\" ) ; \nreturn ; \n} \n} \n"}
{"2844": "public class JSFModuleIdFactory { \nprivate void checkVersionIntegrity ( ) { \nactiveVersions . addAll ( allVersions ) ; \nfor ( String version : allVersions ) { \nif ( ! apiIds . containsKey ( version ) ) { \nJSFLogger . ROOT_LOGGER . missingJSFModule ( version , API_MODULE ) ; \nactiveVersions . remove ( version ) ; \n} \nif ( ! implIds . containsKey ( version ) ) { \nJSFLogger . ROOT_LOGGER . missingJSFModule ( version , IMPL_MODULE ) ; \nactiveVersions . remove ( version ) ; \n} \nif ( ! injectionIds . containsKey ( version ) ) { \nJSFLogger . ROOT_LOGGER . missingJSFModule ( version , INJECTION_MODULE ) ; \nactiveVersions . remove ( version ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2847": "public class InterfaceRepository { \nprivate void addTypeCode ( Class cls , TypeCode typeCode ) throws IRConstructionException { \nif ( cls == null ) throw IIOPLogger . ROOT_LOGGER . invalidNullClass ( ) ; \nTypeCode tc = ( TypeCode ) typeCodeMap . get ( cls ) ; \nif ( tc != null ) throw IIOPLogger . ROOT_LOGGER . duplicateTypeCodeForClass ( cls . getName ( ) ) ; \ntypeCodeMap . put ( cls , typeCode ) ; \nreturn ; \n} \n} \n"}
{"2851": "public class InterfaceRepository { \nprivate void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { \nif ( cls . isPrimitive ( ) ) return ; \nif ( cls . isArray ( ) ) { \naddArray ( cls ) ; \n} \nelse if ( cls . isInterface ( ) ) { \nif ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \naddInterface ( ia ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \n} \nelse if ( Exception . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \naddException ( ea ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \nreturn ; \n} \n} \n"}
{"2857": "public class NamingStoreService { \npublic void start ( final StartContext context ) throws StartException { \nif ( store == null ) { \nfinal ServiceRegistry serviceRegistry = context . getController ( ) . getServiceContainer ( ) ; \nfinal ServiceName serviceNameBase = context . getController ( ) . getName ( ) ; \nfinal ServiceTarget serviceTarget = context . getChildTarget ( ) ; \nstore = readOnly ? new ServiceBasedNamingStore ( serviceRegistry , serviceNameBase ) : new WritableServiceBasedNamingStore ( serviceRegistry , serviceNameBase , serviceTarget ) ; \n} \nreturn ; \n} \n} \n"}
{"2858": "public class NamingStoreService { \npublic void stop ( StopContext context ) { \nif ( store != null ) { \ntry { \nstore . close ( ) ; \nstore = null ; \n} \ncatch ( NamingException e ) { \nthrow NamingLogger . ROOT_LOGGER . failedToDestroyRootContext ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2859": "public class AllowedMethodsInformation { \npublic static void checkAllowed ( final MethodType methodType ) { \nfinal InterceptorContext context = CurrentInvocationContext . get ( ) ; \nif ( context == null ) { \nreturn ; \n} \nfinal Component component = context . getPrivateData ( Component . class ) ; \nif ( ! ( component instanceof EJBComponent ) ) { \nreturn ; \n} \nfinal InvocationType invocationType = context . getPrivateData ( InvocationType . class ) ; \n( ( EJBComponent ) component ) . getAllowedMethodsInformation ( ) . realCheckPermission ( methodType , invocationType ) ; \nreturn ; \n} \n} \n"}
{"2860": "public class AllowedMethodsInformation { \nprivate void checkTransactionSync ( MethodType methodType ) { \nfinal CurrentSynchronizationCallback . CallbackType currentSync = CurrentSynchronizationCallback . get ( ) ; \nif ( currentSync != null ) { \nif ( deniedSyncMethods . contains ( new DeniedSyncMethodKey ( currentSync , methodType ) ) ) { \nthrowException ( methodType , currentSync ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2872": "public class CDIExtension { \npublic void observeResources ( @ Observes @ WithAnnotations ( { \nHealth . class } \n) ProcessAnnotatedType < ? extends HealthCheck > event ) { \nAnnotatedType < ? extends HealthCheck > annotatedType = event . getAnnotatedType ( ) ; \nClass < ? extends HealthCheck > javaClass = annotatedType . getJavaClass ( ) ; \nMicroProfileHealthLogger . LOGGER . infof ( \"Discovered health check procedure %s\" , javaClass ) ; \ndelegates . add ( annotatedType ) ; \nreturn ; \n} \n} \n"}
{"2873": "public class CDIExtension { \npublic void close ( @ Observes final BeforeShutdown bs ) { \nhealthCheckInstances . forEach ( healthCheck -> { \nhealthReporter . removeHealthCheck ( healthCheck . get ( ) ) ; \nhealthCheck . preDestroy ( ) . dispose ( ) ; \n} \n) ; \nhealthCheckInstances . clear ( ) ; \nreturn ; \n} \n} \n"}
{"2877": "public class Utils { \npublic static void skip ( InputStream is , long amount ) throws IOException { \nlong leftToSkip = amount ; \nlong amountSkipped = 0 ; \nwhile ( leftToSkip > 0 && amountSkipped >= 0 ) { \namountSkipped = is . skip ( leftToSkip ) ; \nleftToSkip -= amountSkipped ; \n} \nreturn ; \n} \n} \n"}
{"2878": "public class Messaging13SubsystemParser { \nprotected static void checkNotBothElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { \nif ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { \nthrow new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2879": "public class EEModuleDescription { \npublic void addComponent ( ComponentDescription description ) { \nfinal String componentName = description . getComponentName ( ) ; \nfinal String componentClassName = description . getComponentClassName ( ) ; \nif ( componentName == null ) { \nthrow EeLogger . ROOT_LOGGER . nullVar ( \"componentName\" , \"module\" , moduleName ) ; \n} \nif ( componentClassName == null ) { \nthrow EeLogger . ROOT_LOGGER . nullVar ( \"componentClassName\" , \"module\" , moduleName ) ; \n} \nif ( componentsByName . containsKey ( componentName ) ) { \nthrow EeLogger . ROOT_LOGGER . componentAlreadyDefined ( componentName ) ; \n} \ncomponentsByName . put ( componentName , description ) ; \nList < ComponentDescription > list = componentsByClassName . get ( componentClassName ) ; \nif ( list == null ) { \ncomponentsByClassName . put ( componentClassName , list = new ArrayList < ComponentDescription > ( 1 ) ) ; \n} \nlist . add ( description ) ; \nreturn ; \n} \n} \n"}
{"2880": "public class ModuleGroupSingletonProvider { \npublic static void addClassLoaders ( ClassLoader topLevel , Set < ClassLoader > allClassLoaders ) { \ndeploymentClassLoaders . put ( topLevel , allClassLoaders ) ; \nreturn ; \n} \n} \n"}
{"2881": "public class InMemoryNamingStore { \npublic void unbind ( final Name name ) throws NamingException { \nif ( isLastComponentEmpty ( name ) ) { \nthrow emptyNameException ( ) ; \n} \nwriteLock . lock ( ) ; \ntry { \nroot . accept ( new UnbindVisitor ( name ) ) ; \n} \nfinally { \nwriteLock . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2885": "public class ConcurrentContext { \npublic synchronized void addFactory ( ContextHandleFactory factory ) { \nfinal String factoryName = factory . getName ( ) ; \nif ( factoryMap . containsKey ( factoryName ) ) { \nthrow EeLogger . ROOT_LOGGER . factoryAlreadyExists ( this , factoryName ) ; \n} \nfactoryMap . put ( factoryName , factory ) ; \nfinal Comparator < ContextHandleFactory > comparator = new Comparator < ContextHandleFactory > ( ) { \n@ Override public int compare ( ContextHandleFactory o1 , ContextHandleFactory o2 ) { \nreturn Integer . compare ( o1 . getChainPriority ( ) , o2 . getChainPriority ( ) ) ; \n} \n} \n; \nSortedSet < ContextHandleFactory > sortedSet = new TreeSet < > ( comparator ) ; \nsortedSet . addAll ( factoryMap . values ( ) ) ; \nfactoryOrderedList = new ArrayList < > ( sortedSet ) ; \nreturn ; \n} \n} \n"}
{"2887": "public class WebMigrateOperation { \nprivate void createIoSubsystem ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , PathAddress baseAddress ) { \nResource root = context . readResourceFromRoot ( baseAddress , false ) ; \nif ( root . getChildrenNames ( SUBSYSTEM ) . contains ( IOExtension . SUBSYSTEM_NAME ) ) { \nreturn ; \n} \nPathAddress address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \naddress = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( \"worker\" , \"default\" ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \naddress = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( \"buffer-pool\" , \"default\" ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \nreturn ; \n} \n} \n"}
{"2888": "public class WebMigrateOperation { \nprivate void createWelcomeContentHandler ( Map < PathAddress , ModelNode > migrationOperations ) { \nPathAddress address = pathAddress ( pathElement ( SUBSYSTEM , UndertowExtension . SUBSYSTEM_NAME ) , pathElement ( Constants . CONFIGURATION , Constants . HANDLER ) ) ; \nmigrationOperations . put ( address , createAddOperation ( address ) ) ; \naddress = pathAddress ( pathElement ( SUBSYSTEM , UndertowExtension . SUBSYSTEM_NAME ) , pathElement ( Constants . CONFIGURATION , Constants . HANDLER ) , pathElement ( Constants . FILE , \"welcome-content\" ) ) ; \nfinal ModelNode add = createAddOperation ( address ) ; \nadd . get ( Constants . PATH ) . set ( new ModelNode ( new ValueExpression ( \"${jboss.home.dir}/welcome-content\" ) ) ) ; \nmigrationOperations . put ( address , add ) ; \nreturn ; \n} \n} \n"}
{"2890": "public class InterfaceAnalysis { \nprotected void calculateOperationAnalysisMap ( ) { \noperationAnalysisMap = new HashMap ( ) ; \nOperationAnalysis oa ; \nfor ( int i = 0 ; \ni < operations . length ; \n++ i ) { \noa = operations [ i ] ; \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \nfor ( int i = 0 ; \ni < attributes . length ; \n++ i ) { \nAttributeAnalysis attr = attributes [ i ] ; \noa = attr . getAccessorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \noa = attr . getMutatorAnalysis ( ) ; \nif ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2893": "public class EndpointPublisherImpl { \nprotected void doDeploy ( ServiceTarget target , DeploymentUnit unit ) { \nList < DeploymentAspect > aspects = getDeploymentAspects ( ) ; \nClassLoader origClassLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \nDeployment dep = null ; \ntry { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( ClassLoaderProvider . getDefaultProvider ( ) . getServerIntegrationClassLoader ( ) ) ; \ndep = unit . getAttachment ( WSAttachmentKeys . DEPLOYMENT_KEY ) ; \ndep . addAttachment ( ServiceTarget . class , target ) ; \nDeploymentAspectManager dam = new DeploymentAspectManagerImpl ( ) ; \ndam . setDeploymentAspects ( aspects ) ; \ndam . deploy ( dep ) ; \n} \nfinally { \nif ( dep != null ) { \ndep . removeAttachment ( ServiceTarget . class ) ; \n} \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( origClassLoader ) ; \n} \nreturn ; \n} \n} \n"}
{"2895": "public class EndpointPublisherImpl { \nprotected void stopWebApp ( Deployment deployment ) throws Exception { \nWebDeploymentController context ; \ntry { \ncontext = deployment . getAttachment ( WebDeploymentController . class ) ; \ncontext . stop ( ) ; \n} \ncatch ( Exception e ) { \nthrow WSLogger . ROOT_LOGGER . stopContextPhaseFailed ( e ) ; \n} \ntry { \ncontext . destroy ( ) ; \n} \ncatch ( Exception e ) { \nthrow WSLogger . ROOT_LOGGER . destroyContextPhaseFailed ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"2896": "public class WeldBootstrapService { \npublic synchronized void start ( final StartContext context ) { \nif ( started ) { \nthrow WeldLogger . ROOT_LOGGER . alreadyRunning ( \"WeldContainer\" ) ; \n} \nstarted = true ; \nWeldLogger . DEPLOYMENT_LOGGER . startingWeldService ( deploymentName ) ; \naddWeldService ( SecurityServices . class , securityServicesSupplier . get ( ) ) ; \nTransactionServices transactionServices = weldTransactionServicesSupplier != null ? weldTransactionServicesSupplier . get ( ) : null ; \nif ( transactionServices != null ) { \naddWeldService ( TransactionServices . class , transactionServices ) ; \n} \nif ( ! deployment . getServices ( ) . contains ( ExecutorServices . class ) ) { \naddWeldService ( ExecutorServices . class , executorServicesSupplier . get ( ) ) ; \n} \nModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule ( ) . getClassLoader ( ) , deployment . getSubDeploymentClassLoaders ( ) ) ; \nClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; \ntry { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule ( ) . getClassLoader ( ) ) ; \nbootstrap . startContainer ( deploymentName , environment , deployment ) ; \nWeldProvider . containerInitialized ( Container . instance ( deploymentName ) , getBeanManager ( ) , deployment ) ; \n} \nfinally { \nWildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; \n} \nweldBootstrapServiceConsumer . accept ( this ) ; \nreturn ; \n} \n} \n"}
{"2897": "public class WSEndpointConfigMapping { \npublic void registerEndpointConfig ( final String endpointClass , final EndpointConfig config ) { \nif ( ( endpointClass == null ) || ( config == null ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nendpointConfigMap . put ( endpointClass , config ) ; \nreturn ; \n} \n} \n"}
{"2898": "public class TimerTask { \nprotected void retryTimeout ( TimerImpl timer ) throws Exception { \nboolean callTimeout = false ; \ntimer . lock ( ) ; \ntry { \nif ( timer . isActive ( ) ) { \nEJB3_TIMER_LOGGER . retryingTimeout ( timer ) ; \ntimer . setTimerState ( TimerState . RETRY_TIMEOUT , Thread . currentThread ( ) ) ; \ntimerService . persistTimer ( timer , false ) ; \ncallTimeout = true ; \n} \nelse { \nEJB3_TIMER_LOGGER . timerNotActive ( timer ) ; \n} \n} \nfinally { \ntimer . unlock ( ) ; \n} \nif ( callTimeout ) { \nthis . callTimeout ( timer ) ; \n} \nreturn ; \n} \n} \n"}
{"2899": "public class TimerTask { \nprotected void postTimeoutProcessing ( TimerImpl timer ) throws InterruptedException { \ntimer . lock ( ) ; \ntry { \nTimerState timerState = timer . getState ( ) ; \nif ( timerState != TimerState . CANCELED && timerState != TimerState . EXPIRED ) { \nif ( timer . getInterval ( ) == 0 ) { \ntimerService . expireTimer ( timer ) ; \n} \nelse { \ntimer . setTimerState ( TimerState . ACTIVE , null ) ; \n} \ntimerService . persistTimer ( timer , false ) ; \n} \n} \nfinally { \ntimer . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2904": "public class MigrateOperation { \nprivate void addMessagingActiveMQExtension ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , boolean describe ) { \nResource root = context . readResourceFromRoot ( PathAddress . EMPTY_ADDRESS , false ) ; \nif ( root . getChildrenNames ( EXTENSION ) . contains ( MESSAGING_ACTIVEMQ_EXTENSION ) ) { \nreturn ; \n} \nPathAddress extensionAddress = pathAddress ( EXTENSION , MESSAGING_ACTIVEMQ_EXTENSION ) ; \nOperationEntry addEntry = context . getRootResourceRegistration ( ) . getOperationEntry ( extensionAddress , ADD ) ; \nModelNode addOperation = createAddOperation ( extensionAddress ) ; \naddOperation . get ( MODULE ) . set ( MESSAGING_ACTIVEMQ_MODULE ) ; \nif ( describe ) { \nmigrationOperations . put ( extensionAddress , addOperation ) ; \n} \nelse { \ncontext . addStep ( context . getResult ( ) . get ( extensionAddress . toString ( ) ) , addOperation , addEntry . getOperationHandler ( ) , MODEL ) ; \n} \nreturn ; \n} \n} \n"}
{"2906": "public class MigrateOperation { \nprivate void migrateGenericTransport ( ModelNode addOperation ) { \nString factoryClass = addOperation . get ( FACTORY_CLASS . getName ( ) ) . asString ( ) ; \nfinal String newFactoryClass ; \nswitch ( factoryClass ) { \ncase HORNETQ_NETTY_ACCEPTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_ACCEPTOR_FACTORY ; \nbreak ; \ncase HORNETQ_NETTY_CONNECTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_CONNECTOR_FACTORY ; \nbreak ; \ndefault : newFactoryClass = factoryClass ; \n} \naddOperation . get ( FACTORY_CLASS . getName ( ) ) . set ( newFactoryClass ) ; \nreturn ; \n} \n} \n"}
{"2909": "public class OPropertyEmbedded { \nprotected void setTypeInternal ( final OType iType ) { \ngetDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_UPDATE ) ; \nacquireSchemaWriteLock ( ) ; \ntry { \nif ( iType == globalRef . getType ( ) ) return ; \nif ( ! iType . getCastable ( ) . contains ( globalRef . getType ( ) ) ) throw new IllegalArgumentException ( \"Cannot change property type from \" + globalRef . getType ( ) + \" to \" + iType ) ; \nthis . globalRef = owner . owner . findOrCreateGlobalProperty ( this . globalRef . getName ( ) , iType ) ; \n} \nfinally { \nreleaseSchemaWriteLock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2917": "public class OLocalRecordCache { \npublic void updateRecord ( final ORecord record ) { \nif ( record . getIdentity ( ) . getClusterId ( ) != excludedCluster && record . getIdentity ( ) . isValid ( ) && ! record . isDirty ( ) && ! ORecordVersionHelper . isTombstone ( record . getVersion ( ) ) ) { \nif ( underlying . get ( record . getIdentity ( ) ) != record ) underlying . put ( record ) ; \n} \nreturn ; \n} \n} \n"}
{"2921": "public class OSelectExecutionPlanner { \nprivate static void addOrderByProjections ( QueryPlanningInfo info ) { \nif ( info . orderApplied || info . expand || info . unwind != null || info . orderBy == null || info . orderBy . getItems ( ) . size ( ) == 0 || info . projection == null || info . projection . getItems ( ) == null || ( info . projection . getItems ( ) . size ( ) == 1 && info . projection . getItems ( ) . get ( 0 ) . isAll ( ) ) ) { \nreturn ; \n} \nOOrderBy newOrderBy = info . orderBy == null ? null : info . orderBy . copy ( ) ; \nList < OProjectionItem > additionalOrderByProjections = calculateAdditionalOrderByProjections ( info . projection . getAllAliases ( ) , newOrderBy ) ; \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . orderBy = newOrderBy ; \n} \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . projectionAfterOrderBy = new OProjection ( - 1 ) ; \ninfo . projectionAfterOrderBy . setItems ( new ArrayList < > ( ) ) ; \nfor ( String alias : info . projection . getAllAliases ( ) ) { \ninfo . projectionAfterOrderBy . getItems ( ) . add ( projectionFromAlias ( new OIdentifier ( alias ) ) ) ; \n} \nfor ( OProjectionItem item : additionalOrderByProjections ) { \nif ( info . preAggregateProjection != null ) { \ninfo . preAggregateProjection . getItems ( ) . add ( item ) ; \ninfo . aggregateProjection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \ninfo . projection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \n} \nelse { \ninfo . projection . getItems ( ) . add ( item ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"2922": "public class OSelectExecutionPlanner { \nprivate static void extractSubQueries ( QueryPlanningInfo info ) { \nSubQueryCollector collector = new SubQueryCollector ( ) ; \nif ( info . perRecordLetClause != null ) { \ninfo . perRecordLetClause . extractSubQueries ( collector ) ; \n} \nint i = 0 ; \nint j = 0 ; \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) { \naddRecordLevelLet ( info , alias , query , j ++ ) ; \n} \nelse { \naddGlobalLet ( info , alias , query , i ++ ) ; \n} \n} \ncollector . reset ( ) ; \nif ( info . whereClause != null ) { \ninfo . whereClause . extractSubQueries ( collector ) ; \n} \nif ( info . projection != null ) { \ninfo . projection . extractSubQueries ( collector ) ; \n} \nif ( info . orderBy != null ) { \ninfo . orderBy . extractSubQueries ( collector ) ; \n} \nif ( info . groupBy != null ) { \ninfo . groupBy . extractSubQueries ( collector ) ; \n} \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) { \naddRecordLevelLet ( info , alias , query ) ; \n} \nelse { \naddGlobalLet ( info , alias , query ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2935": "public class OHazelcastPlugin { \nprotected void initSystemDatabase ( ) { \nfinal ODocument defaultCfg = getStorage ( OSystemDatabase . SYSTEM_DB_NAME ) . loadDatabaseConfiguration ( getDefaultDatabaseConfigFile ( ) ) ; \ndefaultCfg . field ( \"autoDeploy\" , false ) ; \nfinal OModifiableDistributedConfiguration sysCfg = new OModifiableDistributedConfiguration ( defaultCfg ) ; \nsysCfg . removeServer ( \"<NEW_NODE>\" ) ; \nmessageService . registerDatabase ( OSystemDatabase . SYSTEM_DB_NAME , sysCfg ) ; \nsysCfg . addNewNodeInServerList ( getLocalNodeName ( ) ) ; \nreturn ; \n} \n} \n"}
{"2936": "public class OHazelcastPlugin { \nprotected void loadLocalDatabases ( ) { \nfinal List < String > dbs = new ArrayList < String > ( serverInstance . getAvailableStorageNames ( ) . keySet ( ) ) ; \nCollections . sort ( dbs ) ; \nfor ( final String databaseName : dbs ) { \nif ( messageService . getDatabase ( databaseName ) == null ) { \nODistributedServerLog . info ( this , nodeName , null , DIRECTION . NONE , \"Opening database '%s'...\" , databaseName ) ; \nfinal ODistributedStorage stg = getStorage ( databaseName ) ; \nexecuteInDistributedDatabaseLock ( databaseName , 60000 , null , new OCallable < Object , OModifiableDistributedConfiguration > ( ) { \n@ Override public Object call ( OModifiableDistributedConfiguration cfg ) { \nODistributedServerLog . info ( this , nodeName , null , DIRECTION . NONE , \"Current node started as %s for database '%s'\" , cfg . getServerRole ( nodeName ) , databaseName ) ; \nfinal ODistributedDatabaseImpl ddb = messageService . registerDatabase ( databaseName , cfg ) ; \nddb . resume ( ) ; \ncfg . addNewNodeInServerList ( nodeName ) ; \nreassignClustersOwnership ( nodeName , databaseName , cfg , true ) ; \ntry { \nddb . getSyncConfiguration ( ) . setLastLSN ( nodeName , ( ( OAbstractPaginatedStorage ) stg . getUnderlying ( ) ) . getLSN ( ) , false ) ; \n} \ncatch ( IOException e ) { \nODistributedServerLog . error ( this , nodeName , null , DIRECTION . NONE , \"Error on saving distributed LSN for database '%s' (err=%s).\" , databaseName , e . getMessage ( ) ) ; \n} \nddb . setOnline ( ) ; \nreturn null ; \n} \n} \n) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2937": "public class OHazelcastPlugin { \n@ Override public void memberRemoved ( final MembershipEvent iEvent ) { \ntry { \nupdateLastClusterChange ( ) ; \nif ( iEvent . getMember ( ) == null ) return ; \nfinal String nodeLeftName = getNodeName ( iEvent . getMember ( ) ) ; \nif ( nodeLeftName == null ) return ; \nremoveServer ( nodeLeftName , true ) ; \n} \ncatch ( HazelcastInstanceNotActiveException | RetryableHazelcastException e ) { \nOLogManager . instance ( ) . error ( this , \"Hazelcast is not running\" , e ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on removing the server '%s'\" , e , getNodeName ( iEvent . getMember ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"2939": "public class OHazelcastPlugin { \nprivate void assignLockManagerFromCluster ( ) { \nString lockManagerServer = null ; \nwhile ( lockManagerServer == null ) { \nif ( activeNodes . size ( ) == 1 ) { \nlockManagerServer = nodeName ; \nif ( configurationMap . putIfAbsent ( CONFIG_LOCKMANAGER , lockManagerServer ) == null ) break ; \n} \nelse { \nlockManagerServer = ( String ) configurationMap . get ( CONFIG_LOCKMANAGER ) ; \nif ( lockManagerServer != null && lockManagerServer . equals ( nodeName ) ) { \nOLogManager . instance ( ) . info ( this , \"Found lock as current node, even if it was offline. Forcing a new election...\" ) ; \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nlockManagerServer = electNewLockManager ( ) ; \nbreak ; \n} \nif ( lockManagerServer != null ) break ; \n} \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException e ) { \nbreak ; \n} \n} \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nOLogManager . instance ( ) . info ( this , \"Distributed Lock Manager server is '%s'\" , lockManagerServer ) ; \nreturn ; \n} \n} \n"}
{"2940": "public class OMicroTransaction { \npublic void commit ( ) { \nif ( ! active ) throw error ( \"Inactive micro-transaction on commit\" ) ; \nif ( level < 1 ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; \n-- level ; \nif ( level == 0 ) { \nactive = false ; \ndoCommit ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2941": "public class OMicroTransaction { \npublic void rollback ( ) { \nif ( ! active ) throw error ( \"Inactive micro-transaction on rollback\" ) ; \nif ( level < 1 ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; \n-- level ; \nif ( level == 0 ) { \nactive = false ; \ndoRollback ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2942": "public class OMicroTransaction { \npublic void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { \nif ( oldRid . equals ( newRid ) ) return ; \nfinal List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList < > ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfor ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { \nfinal OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; \nif ( index == null ) throw new OTransactionException ( \"Cannot find index '\" + entry . getValue ( ) + \"' while committing transaction\" ) ; \nfinal Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; \nif ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) continue ; \nfinal OTransactionIndexChanges indexChanges = entry . getValue ( ) ; \nfor ( final Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; \nif ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { \nkeyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; \niterator . remove ( ) ; \n} \n} \n} \nfinal ORecordOperation rec = resolveRecordOperation ( oldRid ) ; \nif ( rec != null ) { \nupdatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; \nif ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { \nORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; \nfinal ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; \nif ( recordId == null ) { \nORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; \n} \nelse { \nrecordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; \nrecordId . setClusterId ( newRid . getClusterId ( ) ) ; \n} \nORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; \n} \n} \nfor ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; \nfinal List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; \nif ( transactionIndexOperations != null ) { \nfor ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { \nOTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; \nif ( indexEntryChanges == null ) continue ; \nfinal OTransactionIndexChangesPerKey keyChanges ; \nif ( indexOperation . key == null ) { \nkeyChanges = indexEntryChanges . nullKeyChanges ; \n} \nelse { \nkeyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; \n} \nif ( keyChanges != null ) updateChangesIdentity ( oldRid , newRid , keyChanges ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2943": "public class OMicroTransaction { \npublic void updateRecordCacheAfterRollback ( ) { \nfinal OLocalRecordCache databaseLocalCache = database . getLocalCache ( ) ; \nfor ( ORecordOperation recordOperation : recordOperations . values ( ) ) databaseLocalCache . deleteRecord ( recordOperation . getRecord ( ) . getIdentity ( ) ) ; \nreturn ; \n} \n} \n"}
{"2944": "public class OFileUtils { \npublic static void prepareForFileCreationOrReplacement ( Path path , Object requester , String operation ) throws IOException { \nif ( Files . deleteIfExists ( path ) ) OLogManager . instance ( ) . warn ( requester , \"'%s' deleted while %s\" , path , operation ) ; \nfinal Path parent = path . getParent ( ) ; \nif ( parent != null ) Files . createDirectories ( parent ) ; \nreturn ; \n} \n} \n"}
{"2945": "public class OFileUtils { \npublic static void atomicMoveWithFallback ( Path source , Path target , Object requester ) throws IOException { \ntry { \nFiles . move ( source , target , StandardCopyOption . ATOMIC_MOVE ) ; \n} \ncatch ( AtomicMoveNotSupportedException ignore ) { \nOLogManager . instance ( ) . warn ( requester , \"atomic file move is not possible, falling back to regular move (moving '%s' to '%s')\" , source , target ) ; \nFiles . move ( source , target ) ; \n} \nreturn ; \n} \n} \n"}
{"2948": "public class JPAHandler { \n@ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { \nbuilder . append ( ch , start , length ) ; \nreturn ; \n} \n} \n"}
{"2951": "public class OByteBufferUtils { \npublic static void splitShortToBuffers ( final ByteBuffer buffer , final ByteBuffer buffer1 , final short iValue ) { \nbuffer . put ( ( byte ) ( MASK & ( iValue >>> SIZE_OF_BYTE_IN_BITS ) ) ) ; \nbuffer1 . put ( ( byte ) ( MASK & iValue ) ) ; \nreturn ; \n} \n} \n"}
{"2957": "public class OFileClassic { \npublic void create ( ) throws IOException { \nacquireWriteLock ( ) ; \ntry { \nacquireExclusiveAccess ( ) ; \nopenChannel ( ) ; \ninit ( ) ; \nsetVersion ( OFileClassic . CURRENT_VERSION ) ; \nversion = OFileClassic . CURRENT_VERSION ; \ninitAllocationMode ( ) ; \n} \nfinally { \nreleaseWriteLock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2959": "public class OFileClassic { \npublic void replaceContentWith ( final Path newContentFile ) throws IOException { \nacquireWriteLock ( ) ; \ntry { \nclose ( ) ; \nFiles . copy ( newContentFile , osFile , StandardCopyOption . REPLACE_EXISTING ) ; \nopen ( ) ; \n} \nfinally { \nreleaseWriteLock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2961": "public class OStorageRemote { \npublic void endRequest ( final OChannelBinaryAsynchClient iNetwork ) throws IOException { \nif ( iNetwork == null ) return ; \niNetwork . flush ( ) ; \niNetwork . releaseWriteLock ( ) ; \nreturn ; \n} \n} \n"}
{"2966": "public class OClientConnectionManager { \npublic void kill ( final OClientConnection connection ) { \nif ( connection != null ) { \nfinal ONetworkProtocol protocol = connection . getProtocol ( ) ; \ntry { \nprotocol . interrupt ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during interruption of binary protocol\" , e ) ; \n} \ndisconnect ( connection ) ; \nprotocol . sendShutdown ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2967": "public class OClientConnectionManager { \npublic void interrupt ( final int iChannelId ) { \nfinal OClientConnection connection = connections . get ( iChannelId ) ; \nif ( connection != null ) { \nfinal ONetworkProtocol protocol = connection . getProtocol ( ) ; \nif ( protocol != null ) protocol . softShutdown ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2969": "public class OClientConnectionManager { \npublic void pushDistribCfg2Clients ( final ODocument iConfig ) { \nif ( iConfig == null ) return ; \nfinal Set < String > pushed = new HashSet < String > ( ) ; \nfor ( OClientConnection c : connections . values ( ) ) { \nif ( ! c . getData ( ) . supportsLegacyPushMessages ) continue ; \ntry { \nfinal String remoteAddress = c . getRemoteAddress ( ) ; \nif ( pushed . contains ( remoteAddress ) ) continue ; \n} \ncatch ( Exception e ) { \ncontinue ; \n} \nif ( ! ( c . getProtocol ( ) instanceof ONetworkProtocolBinary ) || c . getData ( ) . getSerializationImpl ( ) == null ) continue ; \nfinal ONetworkProtocolBinary p = ( ONetworkProtocolBinary ) c . getProtocol ( ) ; \nfinal OChannelBinary channel = p . getChannel ( ) ; \nfinal ORecordSerializer ser = ORecordSerializerFactory . instance ( ) . getFormat ( c . getData ( ) . getSerializationImpl ( ) ) ; \nif ( ser == null ) return ; \nfinal byte [ ] content = ser . toStream ( iConfig , false ) ; \ntry { \nif ( channel . tryAcquireWriteLock ( TIMEOUT_PUSH ) ) { \ntry { \nchannel . writeByte ( OChannelBinaryProtocol . PUSH_DATA ) ; \nchannel . writeInt ( Integer . MIN_VALUE ) ; \nchannel . writeByte ( OChannelBinaryProtocol . REQUEST_PUSH_DISTRIB_CONFIG ) ; \nchannel . writeBytes ( content ) ; \nchannel . flush ( ) ; \npushed . add ( c . getRemoteAddress ( ) ) ; \nOLogManager . instance ( ) . debug ( this , \"Sent updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \nfinally { \nchannel . releaseWriteLock ( ) ; \n} \n} \nelse { \nOLogManager . instance ( ) . info ( this , \"Timeout on sending updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . warn ( this , \"Cannot push cluster configuration to the client %s\" , e , c . getRemoteAddress ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2971": "public class OTransactionAbstract { \n@ Override public void close ( ) { \nfor ( Map . Entry < ORID , LockedRecordMetadata > lock : locks . entrySet ( ) ) { \ntry { \nfinal LockedRecordMetadata lockedRecordMetadata = lock . getValue ( ) ; \nif ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . EXCLUSIVE_LOCK ) ) { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseWriteLock ( lock . getKey ( ) ) ; \n} \nelse if ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . SHARED_LOCK ) ) { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseReadLock ( lock . getKey ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . debug ( this , \"Error on releasing lock against record \" + lock . getKey ( ) , e ) ; \n} \n} \nlocks . clear ( ) ; \nreturn ; \n} \n} \n"}
{"2972": "public class OSchemaProxyObject { \npublic synchronized void synchronizeSchema ( ) { \nOObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; \nCollection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; \nboolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; \nboolean reloadSchema = false ; \nfor ( Class < ? > iClass : registeredEntities ) { \nif ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) || iClass . isAnonymousClass ( ) ) return ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nfor ( Class < ? > currentClass = iClass ; \ncurrentClass != Object . class ; \n) { \nif ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) && ! currentClass . equals ( ODocument . class ) ) { \n( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; \n} \nString iClassName = currentClass . getSimpleName ( ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \nif ( database != null && ! database . isClosed ( ) && ! currentClass . equals ( Object . class ) ) { \nOClass oSuperClass ; \nOClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nelse { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nif ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { \ncurrentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; \nreloadSchema = true ; \n} \n} \n} \n} \nif ( database != null && ! database . isClosed ( ) && reloadSchema ) { \ndatabase . getMetadata ( ) . getSchema ( ) . reload ( ) ; \n} \nreturn ; \n} \n} \n"}
{"2973": "public class OAbstractProfiler { \nprotected void updateMetadata ( final String iName , final String iDescription , final METRIC_TYPE iType ) { \nif ( iDescription != null && dictionary . putIfAbsent ( iName , iDescription ) == null ) types . put ( iName , iType ) ; \nreturn ; \n} \n} \n"}
{"2978": "public class OCompressionFactory { \npublic void register ( final Class < ? extends OCompression > compression ) { \ntry { \nfinal OCompression tempInstance = compression . newInstance ( ) ; \nfinal String name = tempInstance . name ( ) ; \nif ( compressions . containsKey ( name ) ) throw new IllegalArgumentException ( \"Compression with name '\" + name + \"' was already registered\" ) ; \nif ( compressionClasses . containsKey ( tempInstance . name ( ) ) ) throw new IllegalArgumentException ( \"Compression with name '\" + name + \"' was already registered\" ) ; \ncompressionClasses . put ( name , compression ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Cannot register storage compression algorithm '%s'\" , e , compression ) ; \n} \nreturn ; \n} \n} \n"}
{"2981": "public class OMemoryStream { \npublic void move ( final int iFrom , final int iPosition ) { \nif ( iPosition == 0 ) return ; \nfinal int to = iFrom + iPosition ; \nfinal int size = iPosition > 0 ? buffer . length - to : buffer . length - iFrom ; \nSystem . arraycopy ( buffer , iFrom , buffer , to , size ) ; \nreturn ; \n} \n} \n"}
{"2982": "public class OMemoryStream { \npublic void fill ( final int iLength , final byte iFiller ) { \nassureSpaceFor ( iLength ) ; \nArrays . fill ( buffer , position , position + iLength , iFiller ) ; \nposition += iLength ; \nreturn ; \n} \n} \n"}
{"2990": "public class OMatchStatement { \nprivate void updateScheduleStartingAt ( PatternNode startNode , Set < PatternNode > visitedNodes , Set < PatternEdge > visitedEdges , Map < String , Set < String > > remainingDependencies , List < EdgeTraversal > resultingSchedule ) { \nvisitedNodes . add ( startNode ) ; \nfor ( Set < String > dependencies : remainingDependencies . values ( ) ) { \ndependencies . remove ( startNode . alias ) ; \n} \nMap < PatternEdge , Boolean > edges = new LinkedHashMap < PatternEdge , Boolean > ( ) ; \nfor ( PatternEdge outEdge : startNode . out ) { \nedges . put ( outEdge , true ) ; \n} \nfor ( PatternEdge inEdge : startNode . in ) { \nedges . put ( inEdge , false ) ; \n} \nfor ( Map . Entry < PatternEdge , Boolean > edgeData : edges . entrySet ( ) ) { \nPatternEdge edge = edgeData . getKey ( ) ; \nboolean isOutbound = edgeData . getValue ( ) ; \nPatternNode neighboringNode = isOutbound ? edge . in : edge . out ; \nif ( ! remainingDependencies . get ( neighboringNode . alias ) . isEmpty ( ) ) { \ncontinue ; \n} \nif ( visitedNodes . contains ( neighboringNode ) ) { \nif ( ! visitedEdges . contains ( edge ) ) { \nboolean traversalDirection ; \nif ( startNode . optional || edge . item . isBidirectional ( ) ) { \ntraversalDirection = ! isOutbound ; \n} \nelse { \ntraversalDirection = isOutbound ; \n} \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , traversalDirection ) ) ; \n} \n} \nelse if ( ! startNode . optional ) { \nif ( visitedEdges . contains ( edge ) ) { \nthrow new AssertionError ( \"The edge was visited, but the neighboring vertex was not: \" + edge + \" \" + neighboringNode ) ; \n} \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , isOutbound ) ) ; \nupdateScheduleStartingAt ( neighboringNode , visitedNodes , visitedEdges , remainingDependencies , resultingSchedule ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"2991": "public class OCompositeIndexDefinition { \npublic void addIndex ( final OIndexDefinition indexDefinition ) { \nindexDefinitions . add ( indexDefinition ) ; \nif ( indexDefinition instanceof OIndexDefinitionMultiValue ) { \nif ( multiValueDefinitionIndex == - 1 ) multiValueDefinitionIndex = indexDefinitions . size ( ) - 1 ; \nelse throw new OIndexException ( \"Composite key cannot contain more than one collection item\" ) ; \n} \ncollate . addCollate ( indexDefinition . getCollate ( ) ) ; \nreturn ; \n} \n} \n"}
{"3011": "public class OSystemDatabase { \npublic void createCluster ( final String className , final String clusterName ) { \nfinal ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal ODatabaseDocumentInternal sysdb = openSystemDatabase ( ) ; \ntry { \nif ( ! sysdb . existsCluster ( clusterName ) ) { \nOSchema schema = sysdb . getMetadata ( ) . getSchema ( ) ; \nOClass cls = schema . getClass ( className ) ; \nif ( cls != null ) { \ncls . addCluster ( clusterName ) ; \n} \nelse { \nOLogManager . instance ( ) . error ( this , \"createCluster() Class name %s does not exist\" , null , className ) ; \n} \n} \n} \nfinally { \nsysdb . close ( ) ; \n} \n} \nfinally { \nif ( currentDB != null ) ODatabaseRecordThreadLocal . instance ( ) . set ( currentDB ) ; \nelse ODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3012": "public class OAbstractRecordCache { \npublic void freeCluster ( final int cid ) { \nfinal Set < ORID > toRemove = new HashSet < ORID > ( underlying . size ( ) / 2 ) ; \nfinal Set < ORID > keys = new HashSet < ORID > ( underlying . keys ( ) ) ; \nfor ( final ORID id : keys ) if ( id . getClusterId ( ) == cid ) toRemove . add ( id ) ; \nfor ( final ORID ridToRemove : toRemove ) underlying . remove ( ridToRemove ) ; \nreturn ; \n} \n} \n"}
{"3013": "public class OAbstractRecordCache { \npublic void startup ( ) { \nunderlying . startup ( ) ; \nOrient . instance ( ) . getProfiler ( ) . registerHookValue ( profilerPrefix + \"current\" , \"Number of entries in cache\" , METRIC_TYPE . SIZE , new OProfilerHookValue ( ) { \npublic Object getValue ( ) { \nreturn getSize ( ) ; \n} \n} \n, profilerMetadataPrefix + \"current\" ) ; \nreturn ; \n} \n} \n"}
{"3014": "public class OAbstractRecordCache { \npublic void shutdown ( ) { \nunderlying . shutdown ( ) ; \nif ( Orient . instance ( ) . getProfiler ( ) != null ) { \nOrient . instance ( ) . getProfiler ( ) . unregisterHookValue ( profilerPrefix + \"enabled\" ) ; \nOrient . instance ( ) . getProfiler ( ) . unregisterHookValue ( profilerPrefix + \"current\" ) ; \nOrient . instance ( ) . getProfiler ( ) . unregisterHookValue ( profilerPrefix + \"max\" ) ; \n} \nreturn ; \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \nfor ( int i = 0 ; \ni < parameterItems . size ( ) ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3020": "public class FrequencySketch { \nprivate void reset ( ) { \nint count = 0 ; \nfor ( int i = 0 ; \ni < table . length ; \ni ++ ) { \ncount += Long . bitCount ( table [ i ] & ONE_MASK ) ; \ntable [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; \n} \nsize = ( size >>> 1 ) - ( count >>> 2 ) ; \nreturn ; \n} \n} \n"}
{"3028": "public class ORecordAbstract { \nprotected void removeListener ( final ORecordListener listener ) { \nif ( _listeners != null ) { \n_listeners . remove ( listener ) ; \nif ( _listeners . isEmpty ( ) ) _listeners = null ; \n} \nreturn ; \n} \n} \n"}
{"3030": "public class ODistributedMessageServiceImpl { \npublic void timeoutRequest ( final long msgId ) { \nfinal ODistributedResponseManager asynchMgr = responsesByRequestIds . remove ( msgId ) ; \nif ( asynchMgr != null ) asynchMgr . timeout ( ) ; \nreturn ; \n} \n} \n"}
{"3033": "public class ORidBag { \nprivate void replaceWithSBTree ( OBonsaiCollectionPointer pointer ) { \ndelegate . requestDelete ( ) ; \nfinal OSBTreeRidBag treeBag = new OSBTreeRidBag ( ) ; \ntreeBag . setCollectionPointer ( pointer ) ; \ntreeBag . setOwner ( delegate . getOwner ( ) ) ; \nfor ( OMultiValueChangeListener < OIdentifiable , OIdentifiable > listener : delegate . getChangeListeners ( ) ) treeBag . addChangeListener ( listener ) ; \ndelegate = treeBag ; \nreturn ; \n} \n} \n"}
{"3036": "public class ODatabasePoolAbstract { \npublic void close ( ) { \nlock ( ) ; \ntry { \nif ( this . evictionTask != null ) { \nthis . evictionTask . cancel ( ) ; \n} \nfor ( Entry < String , OReentrantResourcePool < String , DB > > pool : pools . entrySet ( ) ) { \nfor ( DB db : pool . getValue ( ) . getResources ( ) ) { \npool . getValue ( ) . close ( ) ; \ntry { \nOLogManager . instance ( ) . debug ( this , \"Closing pooled database '%s'...\" , db . getName ( ) ) ; \n( ( ODatabasePooled ) db ) . forceClose ( ) ; \nOLogManager . instance ( ) . debug ( this , \"OK\" , db . getName ( ) ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . debug ( this , \"Error: %d\" , e . toString ( ) ) ; \n} \n} \n} \n} \nfinally { \nunlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3037": "public class ODatabasePoolAbstract { \npublic void onStorageUnregistered ( final OStorage iStorage ) { \nfinal String storageURL = iStorage . getURL ( ) ; \nlock ( ) ; \ntry { \nSet < String > poolToClose = null ; \nfor ( Entry < String , OReentrantResourcePool < String , DB > > e : pools . entrySet ( ) ) { \nfinal int pos = e . getKey ( ) . indexOf ( \"@\" ) ; \nfinal String dbName = e . getKey ( ) . substring ( pos + 1 ) ; \nif ( storageURL . equals ( dbName ) ) { \nif ( poolToClose == null ) poolToClose = new HashSet < String > ( ) ; \npoolToClose . add ( e . getKey ( ) ) ; \n} \n} \nif ( poolToClose != null ) for ( String pool : poolToClose ) remove ( pool ) ; \n} \nfinally { \nunlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3049": "public class ODatabaseDocumentTxPooled { \n@ Override public void close ( ) { \nif ( isClosed ( ) ) return ; \ncheckOpenness ( ) ; \nif ( ownerPool != null && ownerPool . getConnectionsInCurrentThread ( getURL ( ) , userName ) > 1 ) { \nownerPool . release ( this ) ; \nreturn ; \n} \ntry { \ncommit ( true ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ntry { \ncallOnCloseListeners ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ngetLocalCache ( ) . clear ( ) ; \nif ( ownerPool != null ) { \nfinal ODatabaseDocumentPool localCopy = ownerPool ; \nownerPool = null ; \nlocalCopy . release ( this ) ; \n} \nODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \nreturn ; \n} \n} \n"}
{"3051": "public class OSessionStoragePerformanceStatistic { \npublic void completeComponentOperation ( ) { \nfinal Component currentComponent = componentsStack . peek ( ) ; \nif ( currentComponent == null ) return ; \ncurrentComponent . operationCount -- ; \nif ( currentComponent . operationCount == 0 ) { \nfinal String componentName = currentComponent . name ; \nPerformanceCountersHolder cHolder = countersByComponent . computeIfAbsent ( componentName , k -> currentComponent . type . newCountersHolder ( ) ) ; \ncHolder . operationsCount ++ ; \ncomponentsStack . pop ( ) ; \nmakeSnapshotIfNeeded ( - 1 ) ; \n} \nreturn ; \n} \n} \n"}
{"3052": "public class OSessionStoragePerformanceStatistic { \npublic void pushComponentCounters ( Map < String , PerformanceCountersHolder > counters ) { \nif ( snapshot == null ) return ; \nfor ( Map . Entry < String , PerformanceCountersHolder > entry : snapshot . countersByComponent . entrySet ( ) ) { \nfinal String componentName = entry . getKey ( ) ; \nPerformanceCountersHolder holder = counters . computeIfAbsent ( componentName , k -> entry . getValue ( ) . newInstance ( ) ) ; \nentry . getValue ( ) . pushData ( holder ) ; \n} \nreturn ; \n} \n} \n"}
{"3056": "public class OSessionStoragePerformanceStatistic { \npublic void pushComponentCounters ( String name , PerformanceCountersHolder holder ) { \nif ( snapshot == null ) return ; \nfinal PerformanceCountersHolder countersHolder = snapshot . countersByComponent . get ( name ) ; \nif ( countersHolder != null ) { \ncountersHolder . pushData ( holder ) ; \n} \nreturn ; \n} \n} \n"}
{"3057": "public class OSessionStoragePerformanceStatistic { \npublic void stopWriteCacheFlushTimer ( int pagesFlushed ) { \nif ( writCacheCountersHolder == null ) writCacheCountersHolder = new WritCacheCountersHolder ( ) ; \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . flushOperationsCount ++ ; \nwritCacheCountersHolder . amountOfPagesFlushed += pagesFlushed ; \nwritCacheCountersHolder . flushOperationsTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \nreturn ; \n} \n} \n"}
{"3058": "public class OSessionStoragePerformanceStatistic { \npublic void stopFuzzyCheckpointTimer ( ) { \nif ( writCacheCountersHolder == null ) writCacheCountersHolder = new WritCacheCountersHolder ( ) ; \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . fuzzyCheckpointCount ++ ; \nwritCacheCountersHolder . fuzzyCheckpointTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \nreturn ; \n} \n} \n"}
{"3059": "public class OSessionStoragePerformanceStatistic { \npublic void stopFullCheckpointTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( storageCountersHolder == null ) storageCountersHolder = new StorageCountersHolder ( ) ; \nstorageCountersHolder . fullCheckpointOperationsCount ++ ; \nstorageCountersHolder . fullCheckpointOperationsTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \nreturn ; \n} \n} \n"}
{"3060": "public class OSessionStoragePerformanceStatistic { \npublic void stopCommitTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nperformanceCountersHolder . commitTime += timeDiff ; \nperformanceCountersHolder . commitCount ++ ; \nmakeSnapshotIfNeeded ( endTs ) ; \nreturn ; \n} \n} \n"}
{"3061": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALRecordTimer ( boolean isStartRecord , boolean isStopRecord ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . logRecordCount ++ ; \nwalCountersHolder . logRecordTime += timeDiff ; \nif ( isStartRecord ) { \nwalCountersHolder . startRecordCount ++ ; \nwalCountersHolder . startRecordTime += timeDiff ; \n} \nelse if ( isStopRecord ) { \nwalCountersHolder . stopRecordCount ++ ; \nwalCountersHolder . stopRecordTime += timeDiff ; \n} \nmakeSnapshotIfNeeded ( endTs ) ; \nreturn ; \n} \n} \n"}
{"3062": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALFlushTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . flushCount ++ ; \nwalCountersHolder . flushTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \nreturn ; \n} \n} \n"}
{"3064": "public class ONodeManager { \nprotected void initReceiveMessages ( ) throws IOException { \nmessageThread = new Thread ( ( ) -> { \nwhile ( ! Thread . interrupted ( ) ) { \nreceiveMessages ( ) ; \n} \n} \n) ; \nmessageThread . setName ( \"OrientDB_DistributedDiscoveryThread\" ) ; \nmessageThread . setDaemon ( true ) ; \nmessageThread . start ( ) ; \nreturn ; \n} \n} \n"}
{"3065": "public class ONodeManager { \nprotected void initCheckDisconnect ( ) { \ndisconnectTimer = new TimerTask ( ) { \npublic void run ( ) { \ntry { \ncheckIfKnownServersAreAlive ( ) ; \nif ( running ) { \ninitCheckDisconnect ( ) ; \n} \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n; \ntaskScheduler . scheduleOnce ( disconnectTimer , discoveryPingIntervalMillis ) ; \nreturn ; \n} \n} \n"}
{"3066": "public class OrientElement { \nvoid removeRecord ( ) { \ncheckIfAttached ( ) ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nif ( checkDeletedInTx ( ) ) graph . throwRecordNotFoundException ( getIdentity ( ) , \"The graph element with id \" + getIdentity ( ) + \" not found\" ) ; \ntry { \ngetRecord ( ) . load ( ) ; \n} \ncatch ( ORecordNotFoundException e ) { \ngraph . throwRecordNotFoundException ( getIdentity ( ) , e . getMessage ( ) ) ; \n} \ngetRecord ( ) . delete ( ) ; \nreturn ; \n} \n} \n"}
{"3067": "public class OrientElement { \n@ Override public void setProperty ( final String key , final Object value ) { \nif ( checkDeletedInTx ( ) ) graph . throwRecordNotFoundException ( getIdentity ( ) , \"The graph element \" + getIdentity ( ) + \" has been deleted\" ) ; \nvalidateProperty ( this , key , value ) ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( graph != null ) graph . autoStartTransaction ( ) ; \ngetRecord ( ) . field ( key , value ) ; \nif ( graph != null ) save ( ) ; \nreturn ; \n} \n} \n"}
{"3075": "public class OTransactionRealAbstract { \npublic void addIndexEntry ( final OIndex < ? > delegate , final String iIndexName , final OTransactionIndexChanges . OPERATION iOperation , final Object key , final OIdentifiable iValue , boolean clientTrackOnly ) { \nOTransactionIndexChanges indexEntry = indexEntries . get ( iIndexName ) ; \nif ( indexEntry == null ) { \nindexEntry = new OTransactionIndexChanges ( ) ; \nindexEntries . put ( iIndexName , indexEntry ) ; \n} \nif ( iOperation == OPERATION . CLEAR ) indexEntry . setCleared ( ) ; \nelse { \nOTransactionIndexChangesPerKey changes = indexEntry . getChangesPerKey ( key ) ; \nchanges . clientTrackOnly = clientTrackOnly ; \nchanges . add ( iValue , iOperation ) ; \nif ( iValue == null ) return ; \nList < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( iValue . getIdentity ( ) ) ; \nif ( transactionIndexOperations == null ) { \ntransactionIndexOperations = new ArrayList < OTransactionRecordIndexOperation > ( ) ; \nrecordIndexOperations . put ( iValue . getIdentity ( ) . copy ( ) , transactionIndexOperations ) ; \n} \ntransactionIndexOperations . add ( new OTransactionRecordIndexOperation ( iIndexName , key , iOperation ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3080": "public class OWALSegmentCache { \nvoid writePage ( ByteBuffer page , long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache . size ( ) ) { \nif ( pageIndex < firstCachedPage + pageCache . size ( ) ) { \npageCache . set ( ( int ) ( pageIndex - firstCachedPage ) , page ) ; \n} \nelse { \npageCache . add ( page ) ; \n} \n} \nelse if ( pageCache . isEmpty ( ) ) { \npageCache . add ( page ) ; \nfirstCachedPage = pageIndex ; \n} \nlastWrittenPage = page ; \nlastWrittenPageIndex = pageIndex ; \nif ( pageCache . size ( ) * OWALPage . PAGE_SIZE >= bufferSize + OWALPage . PAGE_SIZE ) { \nflushAllBufferPagesExceptLastOne ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3082": "public class OWALSegmentCache { \nvoid truncate ( long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nflushBuffer ( ) ; \nlastWrittenPageIndex = - 1 ; \nlastWrittenPage = null ; \nsegChannel . truncate ( pageIndex * OWALPage . PAGE_SIZE ) ; \n} \nreturn ; \n} \n} \n"}
{"3083": "public class OWALSegmentCache { \npublic void open ( ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \ninitFile ( ) ; \nlong pagesCount = segChannel . size ( ) / OWALPage . PAGE_SIZE ; \nif ( segChannel . size ( ) % OWALPage . PAGE_SIZE > 0 ) { \nOLogManager . instance ( ) . error ( this , \"Last WAL page was written partially, auto fix\" , null ) ; \nsegChannel . truncate ( OWALPage . PAGE_SIZE * pagesCount ) ; \n} \nfirstCachedPage = - 1 ; \npageCache . clear ( ) ; \nlastWrittenPage = null ; \nlastWrittenPageIndex = - 1 ; \n} \nreturn ; \n} \n} \n"}
{"3109": "public class OrientBaseGraph { \npublic static void clearInitStack ( ) { \nfinal ThreadLocal < Deque < OrientBaseGraph > > is = initializationStack ; \nif ( is != null ) is . get ( ) . clear ( ) ; \nfinal ThreadLocal < OrientBaseGraph > ag = activeGraph ; \nif ( ag != null ) ag . remove ( ) ; \nreturn ; \n} \n} \n"}
{"3111": "public class OrientBaseGraph { \npublic void dropIndex ( final String indexName ) { \nmakeActive ( ) ; \nexecuteOutsideTx ( new OCallable < Object , OrientBaseGraph > ( ) { \n@ Override public Object call ( OrientBaseGraph g ) { \ntry { \nfinal OIndexManager indexManager = getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal OIndex index = indexManager . getIndex ( indexName ) ; \nODocument metadata = index . getConfiguration ( ) . field ( \"metadata\" ) ; \nString recordMapIndexName = null ; \nif ( metadata != null ) { \nrecordMapIndexName = metadata . field ( OrientIndex . CONFIG_RECORD_MAP_NAME ) ; \n} \nindexManager . dropIndex ( indexName ) ; \nif ( recordMapIndexName != null ) getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( recordMapIndexName ) ; \nsaveIndexConfiguration ( ) ; \nreturn null ; \n} \ncatch ( Exception e ) { \ng . rollback ( ) ; \nthrow new RuntimeException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n, \"drop index '\" , indexName , \"'\" ) ; \nreturn ; \n} \n} \n"}
{"3119": "public class OrientBaseGraph { \npublic void shutdown ( boolean closeDb , boolean commitTx ) { \nmakeActive ( ) ; \ntry { \nif ( ! isClosed ( ) ) { \nif ( commitTx ) { \nfinal OStorage storage = getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ; \nif ( storage instanceof OAbstractPaginatedStorage ) { \nif ( ( ( OAbstractPaginatedStorage ) storage ) . getWALInstance ( ) != null ) getDatabase ( ) . commit ( ) ; \n} \nelse { \ngetDatabase ( ) . commit ( ) ; \n} \n} \nelse if ( closeDb ) { \ngetDatabase ( ) . rollback ( ) ; \n} \n} \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow e ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow OException . wrapException ( new ODatabaseException ( \"Error during context close for db \" + url ) , e ) ; \n} \nfinally { \ntry { \nif ( closeDb ) { \ngetDatabase ( ) . close ( ) ; \nif ( getDatabase ( ) . isPooled ( ) ) { \ndatabase = null ; \n} \n} \npollGraphFromStack ( closeDb ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \n} \n} \nurl = null ; \nusername = null ; \npassword = null ; \nif ( ! closeDb ) getDatabase ( ) . activateOnCurrentThread ( ) ; \nreturn ; \n} \n} \n"}
{"3123": "public class OrientBaseGraph { \npublic void dropVertexType ( final String iTypeName ) { \nmakeActive ( ) ; \nif ( getDatabase ( ) . countClass ( iTypeName ) > 0 ) throw new OCommandExecutionException ( \"cannot drop vertex type '\" + iTypeName + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data\" ) ; \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nODatabaseDocument rawGraph = getRawGraph ( ) ; \nrawGraph . getMetadata ( ) . getSchema ( ) . dropClass ( iTypeName ) ; \nreturn null ; \n} \n} \n, \"drop vertex type '\" , iTypeName , \"'\" ) ; \nreturn ; \n} \n} \n"}
{"3127": "public class OrientBaseGraph { \npublic < T extends Element > void dropKeyIndex ( final String key , final Class < T > elementClass ) { \nmakeActive ( ) ; \nif ( elementClass == null ) throw ExceptionFactory . classForElementCannotBeNull ( ) ; \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nfinal String className = getClassName ( elementClass ) ; \ngetRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( className + \".\" + key ) ; \nreturn null ; \n} \n} \n, \"drop key index '\" , elementClass . getSimpleName ( ) , \".\" , key , \"'\" ) ; \nreturn ; \n} \n} \n"}
{"3128": "public class OrientBaseGraph { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) @ Override public < T extends Element > void createKeyIndex ( final String key , final Class < T > elementClass , final Parameter ... indexParameters ) { \nmakeActive ( ) ; \nif ( elementClass == null ) throw ExceptionFactory . classForElementCannotBeNull ( ) ; \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nString indexType = OClass . INDEX_TYPE . NOTUNIQUE . name ( ) ; \nOType keyType = OType . STRING ; \nString className = null ; \nString collate = null ; \nODocument metadata = null ; \nfinal String ancestorClassName = getClassName ( elementClass ) ; \nfor ( Parameter < ? , ? > p : indexParameters ) { \nif ( p . getKey ( ) . equals ( \"type\" ) ) indexType = p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ; \nelse if ( p . getKey ( ) . equals ( \"keytype\" ) ) keyType = OType . valueOf ( p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ) ; \nelse if ( p . getKey ( ) . equals ( \"class\" ) ) className = p . getValue ( ) . toString ( ) ; \nelse if ( p . getKey ( ) . equals ( \"collate\" ) ) collate = p . getValue ( ) . toString ( ) ; \nelse if ( p . getKey ( ) . toString ( ) . startsWith ( \"metadata.\" ) ) { \nif ( metadata == null ) metadata = new ODocument ( ) ; \nmetadata . field ( p . getKey ( ) . toString ( ) . substring ( \"metadata.\" . length ( ) ) , p . getValue ( ) ) ; \n} \n} \nif ( className == null ) className = ancestorClassName ; \nfinal ODatabaseDocument db = getRawGraph ( ) ; \nfinal OSchema schema = db . getMetadata ( ) . getSchema ( ) ; \nfinal OClass cls = schema . getOrCreateClass ( className , schema . getClass ( ancestorClassName ) ) ; \nfinal OProperty property = cls . getProperty ( key ) ; \nif ( property != null ) keyType = property . getType ( ) ; \nOPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition ( className , key , keyType ) ; \nif ( collate != null ) indexDefinition . setCollate ( collate ) ; \ndb . getMetadata ( ) . getIndexManager ( ) . createIndex ( className + \".\" + key , indexType , indexDefinition , cls . getPolymorphicClusterIds ( ) , null , metadata ) ; \nreturn null ; \n} \n} \n, \"create key index on '\" , elementClass . getSimpleName ( ) , \".\" , key , \"'\" ) ; \nreturn ; \n} \n} \n"}
{"3129": "public class OWOWCache { \n@ Override public void removeBackgroundExceptionListener ( final OBackgroundExceptionListener listener ) { \nfinal List < WeakReference < OBackgroundExceptionListener > > itemsToRemove = new ArrayList < > ( 1 ) ; \nfor ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { \nfinal OBackgroundExceptionListener l = ref . get ( ) ; \nif ( l != null && l . equals ( listener ) ) { \nitemsToRemove . add ( ref ) ; \n} \n} \nbackgroundExceptionListeners . removeAll ( itemsToRemove ) ; \nreturn ; \n} \n} \n"}
{"3130": "public class OWOWCache { \nprivate void fireBackgroundDataFlushExceptionEvent ( final Throwable e ) { \nfor ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { \nfinal OBackgroundExceptionListener listener = ref . get ( ) ; \nif ( listener != null ) { \nlistener . onException ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3131": "public class OPerformanceStatisticManager { \npublic void stopMonitoring ( ) { \nswitchLock . acquireWriteLock ( ) ; \ntry { \nenabled = false ; \nfinal PerformanceCountersHolder countersHolder = ComponentType . GENERAL . newCountersHolder ( ) ; \nfinal Map < String , PerformanceCountersHolder > componentCountersHolder = new HashMap < > ( ) ; \nWritCacheCountersHolder writCacheCountersHolder = deadThreadsStatistic . writCacheCountersHolder ; \nStorageCountersHolder storageCountersHolder = deadThreadsStatistic . storageCountersHolder ; \nWALCountersHolder walCountersHolder = deadThreadsStatistic . walCountersHolder ; \ndeadThreadsStatistic . countersHolder . pushData ( countersHolder ) ; \ncomponentCountersHolder . putAll ( deadThreadsStatistic . countersByComponents ) ; \ndeadThreadsStatistic = null ; \nfor ( OSessionStoragePerformanceStatistic statistic : statistics . values ( ) ) { \nstatistic . pushSystemCounters ( countersHolder ) ; \nstatistic . pushComponentCounters ( componentCountersHolder ) ; \nwritCacheCountersHolder = statistic . pushWriteCacheCounters ( writCacheCountersHolder ) ; \nstorageCountersHolder = statistic . pushStorageCounters ( storageCountersHolder ) ; \nwalCountersHolder = statistic . pushWALCounters ( walCountersHolder ) ; \n} \nstatistics . clear ( ) ; \npostMeasurementStatistic = new ImmutableStatistic ( countersHolder , componentCountersHolder , writCacheCountersHolder , storageCountersHolder , walCountersHolder ) ; \n} \nfinally { \nswitchLock . releaseWriteLock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3132": "public class OPerformanceStatisticManager { \npublic void registerMBean ( String storageName , int storageId ) { \nif ( mbeanIsRegistered . compareAndSet ( false , true ) ) { \ntry { \nfinal MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; \nfinal ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; \nif ( ! server . isRegistered ( mbeanName ) ) { \nserver . registerMBean ( new OPerformanceStatisticManagerMBean ( this ) , mbeanName ) ; \n} \nelse { \nmbeanIsRegistered . set ( false ) ; \nOLogManager . instance ( ) . warn ( this , \"MBean with name %s has already registered. Probably your system was not shutdown correctly\" + \" or you have several running applications which use OrientDB engine inside\" , mbeanName . getCanonicalName ( ) ) ; \n} \n} \ncatch ( MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during registration of profiler MBean\" ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3133": "public class OPerformanceStatisticManager { \npublic void unregisterMBean ( String storageName , int storageId ) { \nif ( storageName == null ) { \nOLogManager . instance ( ) . warnNoDb ( this , \"Can not unregister MBean for performance statistics, storage name is null\" ) ; \n} \nif ( mbeanIsRegistered . compareAndSet ( true , false ) ) { \ntry { \nfinal MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; \nfinal ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; \nserver . unregisterMBean ( mbeanName ) ; \n} \ncatch ( MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during unregistration of profiler MBean\" ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3135": "public class OPerformanceStatisticManager { \nprivate void fetchSystemCounters ( PerformanceCountersHolder countersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nsnapshot . performanceCountersHolder . pushData ( countersHolder ) ; \n} \nelse { \nthreadsToRemove . add ( thread ) ; \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersHolder ; \ndch . pushData ( countersHolder ) ; \n} \nreturn ; \n} \n} \n"}
{"3136": "public class OPerformanceStatisticManager { \nprivate void fetchComponentCounters ( String componentName , PerformanceCountersHolder componentCountersHolder ) { \nfinal Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; \nfinal List < Thread > threadsToRemove = new ArrayList < > ( ) ; \nfor ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { \nfinal Thread thread = entry . getKey ( ) ; \nfinal OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; \nsnapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; \n} \nfor ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { \nfinal Thread thread = pair . getFirst ( ) ; \nif ( thread . isAlive ( ) ) { \nfinal PerformanceSnapshot snapshot = pair . getSecond ( ) ; \nfinal PerformanceCountersHolder holder = snapshot . countersByComponent . get ( componentName ) ; \nif ( holder != null ) holder . pushData ( componentCountersHolder ) ; \n} \nelse { \nthreadsToRemove . add ( thread ) ; \n} \n} \nif ( ! threadsToRemove . isEmpty ( ) ) { \nupdateDeadThreadsStatistic ( threadsToRemove ) ; \n} \nfinal ImmutableStatistic ds = deadThreadsStatistic ; \nif ( ds != null ) { \nfinal PerformanceCountersHolder dch = ds . countersByComponents . get ( componentName ) ; \nif ( dch != null ) { \ndch . pushData ( componentCountersHolder ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3142": "public class OObjectDatabaseTx { \npublic void setDirty ( final Object iPojo ) { \nif ( iPojo == null ) return ; \nfinal ODocument record = getRecordByUserObject ( iPojo , false ) ; \nif ( record == null ) throw new OObjectNotManagedException ( \"The object \" + iPojo + \" is not managed by current database\" ) ; \nrecord . setDirty ( ) ; \nreturn ; \n} \n} \n"}
{"3143": "public class OObjectDatabaseTx { \npublic void unsetDirty ( final Object iPojo ) { \nif ( iPojo == null ) return ; \nfinal ODocument record = getRecordByUserObject ( iPojo , false ) ; \nif ( record == null ) return ; \nORecordInternal . unsetDirty ( record ) ; \nreturn ; \n} \n} \n"}
{"3154": "public class OScriptManager { \npublic void releaseDatabaseEngine ( final String iLanguage , final String iDatabaseName , final OPartitionedObjectPool . PoolEntry < ScriptEngine > poolEntry ) { \nfinal ODatabaseScriptManager dbManager = dbManagers . get ( iDatabaseName ) ; \nif ( dbManager != null ) { \ndbManager . releaseEngine ( iLanguage , poolEntry ) ; \n} \nreturn ; \n} \n} \n"}
{"3163": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairRecord ( final ORecordId rid ) { \nif ( ! active ) return ; \nif ( rid == null || ! rid . isPersistent ( ) ) return ; \nif ( rid . getClusterPosition ( ) < - 1 ) return ; \nrecordProcessed . incrementAndGet ( ) ; \nrecords . put ( rid , Boolean . TRUE ) ; \nreturn ; \n} \n} \n"}
{"3164": "public class OConflictResolverDatabaseRepairer { \n@ Override public void cancelRepairRecord ( final ORecordId rid ) { \nif ( ! active ) return ; \nif ( rid . getClusterPosition ( ) < - 1 ) return ; \nif ( records . remove ( rid ) != null ) recordCanceled . incrementAndGet ( ) ; \nreturn ; \n} \n} \n"}
{"3165": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairCluster ( final int clusterId ) { \nif ( ! active ) return ; \nif ( clusterId < - 1 ) return ; \nrecordProcessed . incrementAndGet ( ) ; \nclusters . put ( clusterId , Boolean . TRUE ) ; \nreturn ; \n} \n} \n"}
{"3168": "public class OEntityManager { \npublic synchronized void registerEntityClasses ( final Collection < String > iClassNames , final ClassLoader iClassLoader ) { \nOLogManager . instance ( ) . debug ( this , \"Discovering entity classes for class names: %s\" , iClassNames ) ; \ntry { \nregisterEntityClasses ( OReflectionHelper . getClassesFor ( iClassNames , iClassLoader ) ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow OException . wrapException ( new ODatabaseException ( \"Entity class cannot be found\" ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3169": "public class OEntityManager { \npublic synchronized void registerEntityClasses ( Class < ? > aClass , boolean recursive ) { \nif ( recursive ) { \nclassHandler . registerEntityClass ( aClass ) ; \nField [ ] declaredFields = aClass . getDeclaredFields ( ) ; \nfor ( Field declaredField : declaredFields ) { \nClass < ? > declaredFieldType = declaredField . getType ( ) ; \nif ( ! classHandler . containsEntityClass ( declaredFieldType ) ) { \nregisterEntityClasses ( declaredFieldType , recursive ) ; \n} \n} \n} \nelse { \nclassHandler . registerEntityClass ( aClass ) ; \n} \nreturn ; \n} \n} \n"}
{"3170": "public class OEntityManager { \npublic synchronized void setClassHandler ( final OEntityManagerClassHandler iClassHandler ) { \nIterator < Entry < String , Class < ? > > > iterator = classHandler . getClassesEntrySet ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nEntry < String , Class < ? > > entry = iterator . next ( ) ; \nboolean forceSchemaReload = ! iterator . hasNext ( ) ; \niClassHandler . registerEntityClass ( entry . getValue ( ) , forceSchemaReload ) ; \n} \nthis . classHandler = iClassHandler ; \nreturn ; \n} \n} \n"}
{"3176": "public class OMemory { \npublic static void checkCacheMemoryConfiguration ( ) { \nfinal long maxHeapSize = Runtime . getRuntime ( ) . maxMemory ( ) ; \nfinal long maxCacheSize = getMaxCacheMemorySize ( ) ; \nfinal ONative . MemoryLimitResult physicalMemory = ONative . instance ( ) . getMemoryLimit ( false ) ; \nif ( maxHeapSize != Long . MAX_VALUE && physicalMemory != null && maxHeapSize + maxCacheSize > physicalMemory . memoryLimit ) OLogManager . instance ( ) . warnNoDb ( OMemory . class , \"The sum of the configured JVM maximum heap size (\" + maxHeapSize + \" bytes) \" + \"and the OrientDB maximum cache size (\" + maxCacheSize + \" bytes) is larger than the available physical memory size \" + \"(\" + physicalMemory + \" bytes). That may cause out of memory errors, please tune the configuration up. Use the \" + \"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \" + \"lower memory requirements of the cache.\" ) ; \nreturn ; \n} \n} \n"}
{"3181": "public class OETLHandler { \npublic void executeImport ( ODocument cfg , OServer server ) { \nOETLJob job = new OETLJob ( cfg , server , new OETLListener ( ) { \n@ Override public void onEnd ( OETLJob etlJob ) { \ncurrentJob = null ; \nreturn ; \n} \n} \n) ; \njob . validate ( ) ; \ncurrentJob = job ; \npool . execute ( job ) ; \nreturn ; \n} \n} \n"}
{"3189": "public class OSymmetricKey { \npublic void saveToStream ( final OutputStream os ) { \nif ( os == null ) throw new OSecurityException ( \"OSymmetricKey.saveToStream() OutputStream is null\" ) ; \ntry { \nfinal OutputStreamWriter osw = new OutputStreamWriter ( os ) ; \ntry { \nfinal BufferedWriter writer = new BufferedWriter ( osw ) ; \ntry { \nwriter . write ( getBase64Key ( ) ) ; \n} \nfinally { \nwriter . close ( ) ; \n} \n} \nfinally { \nos . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.saveToStream() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"3190": "public class OSymmetricKey { \npublic void saveToKeystore ( final OutputStream os , final String ksPasswd , final String keyAlias , final String keyPasswd ) { \nif ( os == null ) throw new OSecurityException ( \"OSymmetricKey.saveToKeystore() OutputStream is null\" ) ; \nif ( ksPasswd == null ) throw new OSecurityException ( \"OSymmetricKey.saveToKeystore() Keystore Password is required\" ) ; \nif ( keyAlias == null ) throw new OSecurityException ( \"OSymmetricKey.saveToKeystore() Key Alias is required\" ) ; \nif ( keyPasswd == null ) throw new OSecurityException ( \"OSymmetricKey.saveToKeystore() Key Password is required\" ) ; \ntry { \nKeyStore ks = KeyStore . getInstance ( \"JCEKS\" ) ; \nchar [ ] ksPasswdCA = ksPasswd . toCharArray ( ) ; \nchar [ ] keyPasswdCA = keyPasswd . toCharArray ( ) ; \nks . load ( null , ksPasswdCA ) ; \nKeyStore . ProtectionParameter protParam = new KeyStore . PasswordProtection ( keyPasswdCA ) ; \nKeyStore . SecretKeyEntry skEntry = new KeyStore . SecretKeyEntry ( secretKey ) ; \nks . setEntry ( keyAlias , skEntry , protParam ) ; \nks . store ( os , ksPasswdCA ) ; \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.saveToKeystore() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"3202": "public class OrientTransactionalGraph { \n@ SuppressWarnings ( \"deprecation\" ) @ Override public void stopTransaction ( final Conclusion conclusion ) { \nmakeActive ( ) ; \nif ( getDatabase ( ) . isClosed ( ) || getDatabase ( ) . getTransaction ( ) instanceof OTransactionNoTx || getDatabase ( ) . getTransaction ( ) . getStatus ( ) != TXSTATUS . BEGUN ) return ; \nif ( Conclusion . SUCCESS == conclusion ) commit ( ) ; \nelse rollback ( ) ; \nreturn ; \n} \n} \n"}
{"3208": "public class OrientVertex { \n@ Override public void remove ( ) { \ncheckClass ( ) ; \nfinal OrientBaseGraph graph = checkIfAttached ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nfinal ODocument doc = getRecord ( ) ; \nif ( doc == null ) throw ExceptionFactory . vertexWithIdDoesNotExist ( this . getId ( ) ) ; \nMap < String , List < ODocument > > treeRidbagEdgesToRemove = new HashMap < String , List < ODocument > > ( ) ; \nif ( ! graph . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) { \nfor ( String fieldName : doc . fieldNames ( ) ) { \nfinal OPair < Direction , String > connection = getConnection ( Direction . BOTH , fieldName ) ; \nif ( connection == null ) continue ; \nObject fv = doc . field ( fieldName ) ; \nif ( fv instanceof ORidBag && ! ( ( ORidBag ) fv ) . isEmbedded ( ) ) { \nList < ODocument > docs = new ArrayList < ODocument > ( ) ; \nfor ( OIdentifiable id : ( ORidBag ) fv ) docs . add ( OrientBaseGraph . getDocument ( id , true ) ) ; \ntreeRidbagEdgesToRemove . put ( fieldName , docs ) ; \n} \n} \n} \nsuper . removeRecord ( ) ; \nfinal Iterator < Index < ? extends Element > > it = graph . getIndices ( ) . iterator ( ) ; \nif ( it . hasNext ( ) ) { \nfinal Set < Edge > allEdges = new HashSet < Edge > ( ) ; \nfor ( Edge e : getEdges ( Direction . BOTH ) ) allEdges . add ( e ) ; \nwhile ( it . hasNext ( ) ) { \nfinal Index < ? extends Element > index = it . next ( ) ; \nif ( Vertex . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientVertex > idx = ( OrientIndex < OrientVertex > ) index ; \nidx . removeElement ( this ) ; \n} \nif ( Edge . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientEdge > idx = ( OrientIndex < OrientEdge > ) index ; \nfor ( Edge e : allEdges ) idx . removeElement ( ( OrientEdge ) e ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < ODocument > > entry : treeRidbagEdgesToRemove . entrySet ( ) ) { \ndoc . removeField ( entry . getKey ( ) ) ; \nIterator < ODocument > iter = entry . getValue ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nODocument docEdge = iter . next ( ) ; \nOrientBaseGraph . deleteEdgeIfAny ( docEdge , false ) ; \n} \n} \ngraph . removeEdgesInternal ( this , doc , null , true , settings . isUseVertexFieldsForEdgeLabels ( ) , settings . isAutoScaleEdgeType ( ) ) ; \nreturn ; \n} \n} \n"}
{"3213": "public class ODatabaseImport { \nprivate void processBrokenRids ( Set < ORID > brokenRids ) throws IOException , ParseException { \nif ( exporterVersion >= 12 ) { \nlistener . onMessage ( \"Reading of set of RIDs of records which were detected as broken during database export\\n\" ) ; \njsonReader . readNext ( OJSONReader . BEGIN_COLLECTION ) ; \nwhile ( true ) { \njsonReader . readNext ( OJSONReader . NEXT_IN_ARRAY ) ; \nfinal ORecordId recordId = new ORecordId ( jsonReader . getValue ( ) ) ; \nbrokenRids . add ( recordId ) ; \nif ( jsonReader . lastChar ( ) == ']' ) break ; \n} \n} \nif ( migrateLinks ) { \nif ( exporterVersion >= 12 ) listener . onMessage ( brokenRids . size ( ) + \" were detected as broken during database export, links on those records will be removed from\" + \" result database\" ) ; \nmigrateLinksInImportedDocuments ( brokenRids ) ; \n} \nreturn ; \n} \n} \n"}
{"3218": "public class OCommandExecutorScript { \nprotected void waitForNextRetry ( ) { \ntry { \nThread . sleep ( new Random ( ) . nextInt ( MAX_DELAY - 1 ) + 1 ) ; \n} \ncatch ( InterruptedException e ) { \nOLogManager . instance ( ) . error ( this , \"Wait was interrupted\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3231": "public class OCommandExecutorSQLRetryAbstract { \nprotected void parseRetry ( ) throws OCommandSQLParsingException { \nretry = Integer . parseInt ( parserNextWord ( true ) ) ; \nString temp = parseOptionalWord ( true ) ; \nif ( temp . equals ( \"WAIT\" ) ) { \nwait = Integer . parseInt ( parserNextWord ( true ) ) ; \n} \nelse parserGoBack ( ) ; \nreturn ; \n} \n} \n"}
{"3233": "public class OTransactionNoTx { \npublic void deleteRecord ( final ORecord iRecord , final OPERATION_MODE iMode ) { \nif ( ! iRecord . getIdentity ( ) . isPersistent ( ) ) return ; \ntry { \ndatabase . executeDeleteRecord ( iRecord , iRecord . getVersion ( ) , true , iMode , false ) ; \n} \ncatch ( Exception e ) { \nfinal ORecordId rid = ( ORecordId ) iRecord . getIdentity ( ) ; \nif ( rid . isValid ( ) ) database . getLocalCache ( ) . freeRecord ( rid ) ; \nif ( e instanceof RuntimeException ) throw ( RuntimeException ) e ; \nthrow OException . wrapException ( new ODatabaseException ( \"Error during deletion of record\" + ( iRecord != null ? \" with rid \" + iRecord . getIdentity ( ) : \"\" ) ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3237": "public class OServerShutdownHook { \n@ Override public void run ( ) { \nif ( server != null ) if ( ! server . shutdown ( ) ) { \ntry { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \nreturn ; \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( bufpos >= tokenBegin ) { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nelse { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nwhile ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( i ++ < len ) { \nif ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; \nelse bufline [ j ] = newLine ; \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \nreturn ; \n} \n} \n"}
{"3239": "public class OBonsaiBucketAbstract { \nprotected void setBucketPointer ( int pageOffset , OBonsaiBucketPointer value ) throws IOException { \nsetLongValue ( pageOffset , value . getPageIndex ( ) ) ; \nsetIntValue ( pageOffset + OLongSerializer . LONG_SIZE , value . getPageOffset ( ) ) ; \nreturn ; \n} \n} \n"}
{"3242": "public class OAtomicOperationsManager { \npublic void acquireExclusiveLockTillOperationComplete ( OAtomicOperation operation , String lockName ) { \nif ( operation . containsInLockedObjects ( lockName ) ) { \nreturn ; \n} \nlockManager . acquireLock ( lockName , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \noperation . addLockedObject ( lockName ) ; \nreturn ; \n} \n} \n"}
{"3243": "public class O2QCache { \npublic void changeMaximumAmountOfMemory ( final long readCacheMaxMemory ) throws IllegalStateException { \nMemoryData memoryData ; \nMemoryData newMemoryData ; \nfinal int newMemorySize = normalizeMemory ( readCacheMaxMemory , pageSize ) ; \ndo { \nmemoryData = memoryDataContainer . get ( ) ; \nif ( memoryData . maxSize == newMemorySize ) { \nreturn ; \n} \nif ( ( 100 * memoryData . pinnedPages / newMemorySize ) > percentOfPinnedPages ) { \nthrow new IllegalStateException ( \"Cannot decrease amount of memory used by disk cache \" + \"because limit of pinned pages will be more than allowed limit \" + percentOfPinnedPages ) ; \n} \nnewMemoryData = new MemoryData ( newMemorySize , memoryData . pinnedPages ) ; \n} \nwhile ( ! memoryDataContainer . compareAndSet ( memoryData , newMemoryData ) ) ; \nOLogManager . instance ( ) . info ( this , \"Disk cache size was changed from \" + memoryData . maxSize + \" pages to \" + newMemorySize + \" pages\" ) ; \nreturn ; \n} \n} \n"}
{"3244": "public class OServerNetworkListener { \nprivate void listen ( final String iHostName , final String iHostPortRange , final String iProtocolName , Class < ? extends ONetworkProtocol > protocolClass ) { \nfor ( int port : getPorts ( iHostPortRange ) ) { \ninboundAddr = new InetSocketAddress ( iHostName , port ) ; \ntry { \nserverSocket = socketFactory . createServerSocket ( port , 0 , InetAddress . getByName ( iHostName ) ) ; \nif ( serverSocket . isBound ( ) ) { \nOLogManager . instance ( ) . info ( this , \"Listening $ANSI{green \" + iProtocolName + \"} connections on $ANSI{green \" + inboundAddr . getAddress ( ) . getHostAddress ( ) + \":\" + inboundAddr . getPort ( ) + \"} (protocol v.\" + protocolVersion + \", socket=\" + socketFactory . getName ( ) + \")\" ) ; \nreturn ; \n} \n} \ncatch ( BindException be ) { \nOLogManager . instance ( ) . warn ( this , \"Port %s:%d busy, trying the next available...\" , iHostName , port ) ; \n} \ncatch ( SocketException se ) { \nOLogManager . instance ( ) . error ( this , \"Unable to create socket\" , se ) ; \nthrow new RuntimeException ( se ) ; \n} \ncatch ( IOException ioe ) { \nOLogManager . instance ( ) . error ( this , \"Unable to read data from an open socket\" , ioe ) ; \nSystem . err . println ( \"Unable to read data from an open socket.\" ) ; \nthrow new RuntimeException ( ioe ) ; \n} \n} \nOLogManager . instance ( ) . error ( this , \"Unable to listen for connections using the configured ports '%s' on host '%s'\" , null , iHostPortRange , iHostName ) ; \nthrow new OSystemException ( \"Unable to listen for connections using the configured ports '%s' on host '%s'\" ) ; \nreturn ; \n} \n} \n"}
{"3245": "public class OServerNetworkListener { \nprivate void readParameters ( final OContextConfiguration iServerConfig , final OServerParameterConfiguration [ ] iParameters ) { \nconfiguration = new OContextConfiguration ( iServerConfig ) ; \nif ( iParameters != null && iParameters . length > 0 ) { \nfor ( OServerParameterConfiguration param : iParameters ) configuration . setValue ( param . name , param . value ) ; \n} \nsocketBufferSize = configuration . getValueAsInteger ( OGlobalConfiguration . NETWORK_SOCKET_BUFFER_SIZE ) ; \nreturn ; \n} \n} \n"}
{"3246": "public class OLogManager { \npublic void shutdown ( ) { \nif ( shutdownFlag . compareAndSet ( false , true ) ) { \ntry { \nif ( LogManager . getLogManager ( ) instanceof ShutdownLogManager ) ( ( ShutdownLogManager ) LogManager . getLogManager ( ) ) . shutdown ( ) ; \n} \ncatch ( NoClassDefFoundError ignore ) { \n} \n} \nreturn ; \n} \n} \n"}
{"3247": "public class OClosableLinkedContainer { \npublic void add ( K key , V item ) throws InterruptedException { \nif ( ! item . isOpen ( ) ) throw new IllegalArgumentException ( \"All passed in items should be in open state\" ) ; \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > closableEntry = new OClosableEntry < K , V > ( item ) ; \nfinal OClosableEntry < K , V > oldEntry = data . putIfAbsent ( key , closableEntry ) ; \nif ( oldEntry != null ) { \nthrow new IllegalStateException ( \"Item with key \" + key + \" already exists\" ) ; \n} \nlogAdd ( closableEntry ) ; \nreturn ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( int i = 0 ; \ni < READ_BUFFER_SIZE ; \ni ++ ) { \nbuffer [ i ] . set ( null ) ; \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn ++ ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nwhile ( true ) { \nfinal int bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) break ; \napplyRead ( entry ) ; \ncounter ++ ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \n} \nreturn ; \n} \n} \n"}
{"3254": "public class OClosableLinkedContainer { \nprivate void afterWrite ( Runnable task ) { \nstateBuffer . add ( task ) ; \ndrainStatus . lazySet ( DrainStatus . REQUIRED ) ; \ntryToDrainBuffers ( ) ; \nreturn ; \n} \n} \n"}
{"3255": "public class OClosableLinkedContainer { \nprivate void afterRead ( OClosableEntry < K , V > entry ) { \nfinal int bufferIndex = readBufferIndex ( ) ; \nfinal long writeCount = putEntryInReadBuffer ( entry , bufferIndex ) ; \ndrainReadBuffersIfNeeded ( bufferIndex , writeCount ) ; \nreturn ; \n} \n} \n"}
{"3259": "public class OObjectEnumLazyMap { \nprivate void convert ( final Object iKey ) { \nif ( converted ) return ; \nif ( super . containsKey ( iKey ) ) return ; \nObject o = underlying . get ( String . valueOf ( iKey ) ) ; \nif ( o instanceof Number ) super . put ( iKey , enumClass . getEnumConstants ( ) [ ( ( Number ) o ) . intValue ( ) ] ) ; \nelse super . put ( iKey , Enum . valueOf ( enumClass , o . toString ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"3260": "public class OObjectEnumLazyMap { \nprotected void convertAll ( ) { \nif ( converted ) return ; \nfor ( java . util . Map . Entry < Object , Object > e : underlying . entrySet ( ) ) { \nif ( e . getValue ( ) instanceof Number ) super . put ( e . getKey ( ) , enumClass . getEnumConstants ( ) [ ( ( Number ) e . getValue ( ) ) . intValue ( ) ] ) ; \nelse super . put ( e . getKey ( ) , Enum . valueOf ( enumClass , e . getValue ( ) . toString ( ) ) ) ; \n} \nconverted = true ; \nreturn ; \n} \n} \n"}
{"3262": "public class Orient { \nprivate void initShutdownQueue ( ) { \naddShutdownHandler ( new OShutdownWorkersHandler ( ) ) ; \naddShutdownHandler ( new OShutdownOrientDBInstancesHandler ( ) ) ; \naddShutdownHandler ( new OShutdownPendingThreadsHandler ( ) ) ; \naddShutdownHandler ( new OShutdownProfilerHandler ( ) ) ; \naddShutdownHandler ( new OShutdownCallListenersHandler ( ) ) ; \nreturn ; \n} \n} \n"}
{"3272": "public class OrientEdge { \n@ Override public void setProperty ( final String key , final Object value ) { \nsetCurrentGraphInThreadLocal ( ) ; \nif ( rawElement == null ) convertToDocument ( ) ; \nsuper . setProperty ( key , value ) ; \nreturn ; \n} \n} \n"}
{"3274": "public class OSBTreeBonsaiLocal { \n@ Override public void clear ( ) throws IOException { \nboolean rollback = false ; \nfinal OAtomicOperation atomicOperation = startAtomicOperation ( true ) ; \ntry { \nfinal Lock lock = FILE_LOCK_MANAGER . acquireExclusiveLock ( fileId ) ; \ntry { \nfinal Queue < OBonsaiBucketPointer > subTreesToDelete = new LinkedList < > ( ) ; \nfinal OCacheEntry cacheEntry = loadPageForWrite ( atomicOperation , fileId , rootBucketPointer . getPageIndex ( ) , false , true ) ; \ntry { \nOSBTreeBonsaiBucket < K , V > rootBucket = new OSBTreeBonsaiBucket < > ( cacheEntry , rootBucketPointer . getPageOffset ( ) , keySerializer , valueSerializer , this ) ; \naddChildrenToQueue ( subTreesToDelete , rootBucket ) ; \nrootBucket . shrink ( 0 ) ; \nrootBucket = new OSBTreeBonsaiBucket < > ( cacheEntry , rootBucketPointer . getPageOffset ( ) , true , keySerializer , valueSerializer , this ) ; \nrootBucket . setTreeSize ( 0 ) ; \n} \nfinally { \nreleasePageFromWrite ( atomicOperation , cacheEntry ) ; \n} \nrecycleSubTrees ( subTreesToDelete , atomicOperation ) ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \ncatch ( final Exception e ) { \nrollback = true ; \nthrow e ; \n} \nfinally { \nendAtomicOperation ( rollback ) ; \n} \nreturn ; \n} \n} \n"}
{"3275": "public class OSBTreeBonsaiLocal { \n@ Override public void delete ( ) throws IOException { \nboolean rollback = false ; \nfinal OAtomicOperation atomicOperation = startAtomicOperation ( false ) ; \ntry { \nfinal Lock lock = FILE_LOCK_MANAGER . acquireExclusiveLock ( fileId ) ; \ntry { \nfinal Queue < OBonsaiBucketPointer > subTreesToDelete = new LinkedList < > ( ) ; \nsubTreesToDelete . add ( rootBucketPointer ) ; \nrecycleSubTrees ( subTreesToDelete , atomicOperation ) ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \ncatch ( final Exception e ) { \nrollback = true ; \nthrow e ; \n} \nfinally { \nendAtomicOperation ( rollback ) ; \n} \nreturn ; \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( int i = 0 ; \ni < parallel - 1 ; \ni ++ ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) { \nsynchronized ( runningThreads ) { \nwhile ( runningThreads . get ( ) > 0 ) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \nreturn ; \n} \n} \n"}
{"3277": "public class OGraphBatchInsertBasic { \npublic void createVertex ( final Long v ) { \nlast = last < v ? v : last ; \nfinal List < Long > outList = out . get ( v ) ; \nif ( outList == null ) { \nout . put ( v , new ArrayList < Long > ( averageEdgeNumberPerNode <= 0 ? 4 : averageEdgeNumberPerNode ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3283": "public class ORecordInternal { \npublic static void setVersion ( final ORecord record , final int iVersion ) { \nfinal ORecordAbstract rec = ( ORecordAbstract ) record ; \nrec . setVersion ( iVersion ) ; \nreturn ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( int retry = 0 ; \nretry < 100 ; \n++ retry ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3288": "public class ORecordLazyMap { \nprivate void convertLink2Record ( final Object iKey ) { \nif ( status == MULTIVALUE_CONTENT_TYPE . ALL_RECORDS ) return ; \nfinal Object value ; \nif ( iKey instanceof ORID ) value = iKey ; \nelse value = super . get ( iKey ) ; \nif ( value != null && value instanceof ORID ) { \nfinal ORID rid = ( ORID ) value ; \nmarshalling = true ; \ntry { \ntry { \nORecord record = rid . getRecord ( ) ; \nif ( record != null ) { \nORecordInternal . unTrack ( sourceRecord , rid ) ; \nORecordInternal . track ( sourceRecord , record ) ; \n} \nsuper . put ( iKey , record ) ; \n} \ncatch ( ORecordNotFoundException ignore ) { \n} \n} \nfinally { \nmarshalling = false ; \n} \n} \nreturn ; \n} \n} \n"}
{"3289": "public class OHttpNetworkCommandManager { \npublic void registerCommand ( final OServerCommand iServerCommandInstance ) { \nfor ( String name : iServerCommandInstance . getNames ( ) ) if ( OStringSerializerHelper . contains ( name , '{' ) ) { \nrestCommands . put ( name , iServerCommandInstance ) ; \n} \nelse if ( OStringSerializerHelper . contains ( name , '*' ) ) wildcardCommands . put ( name , iServerCommandInstance ) ; \nelse exactCommands . put ( name , iServerCommandInstance ) ; \niServerCommandInstance . configure ( server ) ; \nreturn ; \n} \n} \n"}
{"3293": "public class OObjectProxyMethodHandler { \npublic void attach ( final Object self ) throws IllegalArgumentException , IllegalAccessException , NoSuchMethodException , InvocationTargetException { \nfor ( Class < ? > currentClass = self . getClass ( ) ; \ncurrentClass != Object . class ; \n) { \nif ( Proxy . class . isAssignableFrom ( currentClass ) ) { \ncurrentClass = currentClass . getSuperclass ( ) ; \ncontinue ; \n} \nfor ( Field f : currentClass . getDeclaredFields ( ) ) { \nfinal String fieldName = f . getName ( ) ; \nfinal Class < ? > declaringClass = f . getDeclaringClass ( ) ; \nif ( OObjectEntitySerializer . isTransientField ( declaringClass , fieldName ) || OObjectEntitySerializer . isVersionField ( declaringClass , fieldName ) || OObjectEntitySerializer . isIdField ( declaringClass , fieldName ) ) continue ; \nObject value = OObjectEntitySerializer . getFieldValue ( f , self ) ; \nvalue = setValue ( self , fieldName , value ) ; \nOObjectEntitySerializer . setFieldValue ( f , self , value ) ; \n} \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \n} \nreturn ; \n} \n} \n"}
{"3296": "public class OClassImpl { \npublic void truncate ( ) throws IOException { \nODatabaseDocumentInternal db = getDatabase ( ) ; \ndb . checkSecurity ( ORule . ResourceGeneric . CLASS , ORole . PERMISSION_UPDATE ) ; \nif ( isSubClassOf ( OSecurityShared . RESTRICTED_CLASSNAME ) ) { \nthrow new OSecurityException ( \"Class '\" + getName ( ) + \"' cannot be truncated because has record level security enabled (extends '\" + OSecurityShared . RESTRICTED_CLASSNAME + \"')\" ) ; \n} \nfinal OStorage storage = db . getStorage ( ) ; \nacquireSchemaReadLock ( ) ; \ntry { \nfor ( int id : clusterIds ) { \nOCluster cl = storage . getClusterById ( id ) ; \ndb . checkForClusterPermissions ( cl . getName ( ) ) ; \ncl . truncate ( ) ; \n} \nfor ( OIndex < ? > index : getClassIndexes ( ) ) index . clear ( ) ; \nSet < OIndex < ? > > superclassIndexes = new HashSet < OIndex < ? > > ( ) ; \nsuperclassIndexes . addAll ( getIndexes ( ) ) ; \nsuperclassIndexes . removeAll ( getClassIndexes ( ) ) ; \nfor ( OIndex index : superclassIndexes ) { \nindex . rebuild ( ) ; \n} \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3298": "public class OClassImpl { \nprotected void addPolymorphicClusterIds ( final OClassImpl iBaseClass ) { \nSet < Integer > clusters = new TreeSet < Integer > ( ) ; \nfor ( int clusterId : polymorphicClusterIds ) { \nclusters . add ( clusterId ) ; \n} \nfor ( int clusterId : iBaseClass . polymorphicClusterIds ) { \nif ( clusters . add ( clusterId ) ) { \ntry { \naddClusterIdToIndexes ( clusterId ) ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . warn ( this , \"Error adding clusterId '%d' to index of class '%s'\" , e , clusterId , getName ( ) ) ; \nclusters . remove ( clusterId ) ; \n} \n} \n} \npolymorphicClusterIds = new int [ clusters . size ( ) ] ; \nint i = 0 ; \nfor ( Integer cluster : clusters ) { \npolymorphicClusterIds [ i ] = cluster ; \ni ++ ; \n} \nreturn ; \n} \n} \n"}
{"3300": "public class OByteBufferPool { \npublic final void release ( OPointer pointer ) { \nif ( TRACK ) { \npointerMapping . remove ( pointer ) ; \n} \nlong poolSize = pointersPoolSize . incrementAndGet ( ) ; \nif ( poolSize > this . poolSize ) { \npointersPoolSize . decrementAndGet ( ) ; \nallocator . deallocate ( pointer ) ; \n} \nelse { \npointersPool . add ( pointer ) ; \n} \nreturn ; \n} \n} \n"}
{"3301": "public class OByteBufferPool { \npublic void checkMemoryLeaks ( ) { \nboolean detected = false ; \nif ( TRACK ) { \nfor ( Map . Entry < OPointer , PointerTracker > entry : pointerMapping . entrySet ( ) ) { \nOLogManager . instance ( ) . errorNoDb ( this , \"DIRECT-TRACK: unreleased direct memory pointer `%X` detected.\" , entry . getValue ( ) . allocation , System . identityHashCode ( entry . getKey ( ) ) ) ; \ndetected = true ; \n} \n} \nassert ! detected ; \nreturn ; \n} \n} \n"}
{"3302": "public class OByteBufferPool { \npublic void clear ( ) { \nfor ( OPointer pointer : pointersPool ) { \nallocator . deallocate ( pointer ) ; \n} \npointersPool . clear ( ) ; \npointersPoolSize . set ( 0 ) ; \nfor ( OPointer pointer : pointerMapping . keySet ( ) ) { \nallocator . deallocate ( pointer ) ; \n} \npointerMapping . clear ( ) ; \nreturn ; \n} \n} \n"}
{"3304": "public class ODistributedAbstractPlugin { \n@ Override public void onOpen ( final ODatabaseInternal iDatabase ) { \nif ( ! isRelatedToLocalServer ( iDatabase ) ) return ; \nif ( isOffline ( ) && status != NODE_STATUS . STARTING ) return ; \nfinal ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal String dbName = iDatabase . getName ( ) ; \nfinal ODistributedConfiguration cfg = getDatabaseConfiguration ( dbName ) ; \nif ( cfg == null ) return ; \n} \ncatch ( HazelcastException e ) { \nthrow OException . wrapException ( new OOfflineNodeException ( \"Hazelcast instance is not available\" ) , e ) ; \n} \ncatch ( HazelcastInstanceNotActiveException e ) { \nthrow OException . wrapException ( new OOfflineNodeException ( \"Hazelcast instance is not available\" ) , e ) ; \n} \nfinally { \nODatabaseRecordThreadLocal . instance ( ) . set ( currDb ) ; \n} \nreturn ; \n} \n} \n"}
{"3306": "public class ODistributedAbstractPlugin { \nprotected void dumpServersStatus ( ) { \nfinal ODocument cfg = getClusterConfiguration ( ) ; \nfinal String compactStatus = ODistributedOutput . getCompactServerStatus ( this , cfg ) ; \nif ( ! lastServerDump . equals ( compactStatus ) ) { \nlastServerDump = compactStatus ; \nODistributedServerLog . info ( this , getLocalNodeName ( ) , null , DIRECTION . NONE , \"Distributed servers status (*=current @=lockmgr[%s]):\\n%s\" , getLockManagerServer ( ) , ODistributedOutput . formatServerStatus ( this , cfg ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3312": "public class OCommandExecutorSQLSelect { \nprotected void reportTip ( final String iMessage ) { \nOrient . instance ( ) . getProfiler ( ) . reportTip ( iMessage ) ; \nList < String > tips = ( List < String > ) context . getVariable ( \"tips\" ) ; \nif ( tips == null ) { \ntips = new ArrayList < String > ( 3 ) ; \ncontext . setVariable ( \"tips\" , tips ) ; \n} \ntips . add ( iMessage ) ; \nreturn ; \n} \n} \n"}
{"3318": "public class OAbstractPaginatedStorage { \npublic final void handleJVMError ( final Error e ) { \nif ( jvmError . compareAndSet ( null , e ) ) { \nOLogManager . instance ( ) . errorNoDb ( this , \"JVM error was thrown\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3320": "public class OAbstractPaginatedStorage { \npublic void rollback ( final OMicroTransaction microTransaction ) { \ntry { \ncheckOpenness ( ) ; \nstateLock . acquireReadLock ( ) ; \ntry { \ntry { \ncheckOpenness ( ) ; \nif ( transaction . get ( ) == null ) { \nreturn ; \n} \nif ( transaction . get ( ) . getMicroTransaction ( ) . getId ( ) != microTransaction . getId ( ) ) { \nthrow new OStorageException ( \"Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be \" + \"rolled back.\" ) ; \n} \nmakeStorageDirty ( ) ; \nrollbackStorageTx ( ) ; \nmicroTransaction . updateRecordCacheAfterRollback ( ) ; \ntxRollback . incrementAndGet ( ) ; \n} \ncatch ( final IOException e ) { \nthrow OException . wrapException ( new OStorageException ( \"Error during micro-transaction rollback\" ) , e ) ; \n} \nfinally { \ntransaction . set ( null ) ; \n} \n} \nfinally { \nstateLock . releaseReadLock ( ) ; \n} \n} \ncatch ( final RuntimeException ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Error ee ) { \nthrow logAndPrepareForRethrow ( ee ) ; \n} \ncatch ( final Throwable t ) { \nthrow logAndPrepareForRethrow ( t ) ; \n} \nreturn ; \n} \n} \n"}
{"3332": "public class OEncryptionFactory { \npublic void register ( final OEncryption iEncryption ) { \ntry { \nfinal String name = iEncryption . name ( ) ; \nif ( instances . containsKey ( name ) ) throw new IllegalArgumentException ( \"Encryption with name '\" + name + \"' was already registered\" ) ; \nif ( classes . containsKey ( name ) ) throw new IllegalArgumentException ( \"Encryption with name '\" + name + \"' was already registered\" ) ; \ninstances . put ( name , iEncryption ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Cannot register storage encryption algorithm '%s'\" , e , iEncryption ) ; \n} \nreturn ; \n} \n} \n"}
{"3340": "public class OStorageConfigurationSegment { \nprivate void clearConfigurationFiles ( ) throws IOException { \nfinal Path file = storagePath . resolve ( NAME ) ; \nFiles . deleteIfExists ( file ) ; \nfinal Path backupFile = storagePath . resolve ( BACKUP_NAME ) ; \nFiles . deleteIfExists ( backupFile ) ; \nreturn ; \n} \n} \n"}
{"3350": "public class Arrays { \npublic static void ensureOffsetLength ( final int arrayLength , final int offset , final int length ) { \nif ( offset < 0 ) throw new ArrayIndexOutOfBoundsException ( \"Offset (\" + offset + \") is negative\" ) ; \nif ( length < 0 ) throw new IllegalArgumentException ( \"Length (\" + length + \") is negative\" ) ; \nif ( offset + length > arrayLength ) throw new ArrayIndexOutOfBoundsException ( \"Last index (\" + ( offset + length ) + \") is greater than array length (\" + arrayLength + \")\" ) ; \nreturn ; \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal int length = to - from ; \nif ( length < MERGESORT_NO_REC ) { \nfor ( int i = from ; \ni < to ; \ni ++ ) { \nfor ( int j = i ; \nj > from && ( c . compare ( j - 1 , j ) > 0 ) ; \nj -- ) { \nswapper . swap ( j , j - 1 ) ; \n} \n} \nreturn ; \n} \nint mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( c . compare ( mid - 1 , mid ) <= 0 ) return ; \ninPlaceMerge ( from , mid , to , c , swapper ) ; \nreturn ; \n} \n} \n"}
{"3352": "public class Arrays { \nprotected static void swap ( final Swapper swapper , int a , int b , final int n ) { \nfor ( int i = 0 ; \ni < n ; \ni ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; \nreturn ; \n} \n} \n"}
{"3353": "public class Arrays { \npublic static void parallelQuickSort ( final int from , final int to , final IntComparator comp , final Swapper swapper ) { \nfinal ForkJoinPool pool = new ForkJoinPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; \npool . invoke ( new ForkJoinGenericQuickSort ( from , to , comp , swapper ) ) ; \npool . shutdown ( ) ; \nreturn ; \n} \n} \n"}
{"3357": "public class InspectableFileCachedInputStream { \npublic void truncate ( final long size ) throws FileNotFoundException , IOException { \nfileChannel . truncate ( Math . max ( size , writePosition ) ) ; \nreturn ; \n} \n} \n"}
{"3358": "public class FastBufferedOutputStream { \n@ Override public void position ( final long newPosition ) throws IOException { \nflush ( ) ; \nif ( repositionableStream != null ) repositionableStream . position ( newPosition ) ; \nelse if ( fileChannel != null ) fileChannel . position ( newPosition ) ; \nelse throw new UnsupportedOperationException ( \"position() can only be called if the underlying byte stream implements the RepositionableStream interface or if the getChannel() method of the underlying byte stream exists and returns a FileChannel\" ) ; \nreturn ; \n} \n} \n"}
{"3359": "public class AbstractRefreshMetricsListener { \nprivate final void noFailRefreshEndMetricsReporting ( ConsumerRefreshMetrics refreshMetrics ) { \ntry { \nrefreshEndMetricsReporting ( refreshMetrics ) ; \n} \ncatch ( Exception e ) { \nlog . log ( Level . SEVERE , \"Encountered an exception in reporting consumer refresh metrics, ignoring exception and continuing with consumer refresh\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3360": "public class SimultaneousExecutor { \npublic void awaitSuccessfulCompletionOfCurrentTasks ( ) throws InterruptedException , ExecutionException { \nfor ( Future < ? > f : futures ) { \nf . get ( ) ; \n} \nfutures . clear ( ) ; \nreturn ; \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null || files . length <= numOfSnapshotsToKeep ) { \nreturn ; \n} \nsortByLastModified ( files ) ; \nfor ( int i = numOfSnapshotsToKeep ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) { \nlog . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3366": "public class TransitiveSetTraverser { \npublic static void removeReferencedOutsideClosure ( HollowReadStateEngine stateEngine , Map < String , BitSet > matches ) { \nList < HollowSchema > orderedSchemas = HollowSchemaSorter . dependencyOrderedSchemaList ( stateEngine ) ; \nCollections . reverse ( orderedSchemas ) ; \nfor ( HollowSchema referencedSchema : orderedSchemas ) { \nif ( matches . containsKey ( referencedSchema . getName ( ) ) ) { \nfor ( HollowSchema referencerSchema : orderedSchemas ) { \nif ( referencerSchema == referencedSchema ) break ; \nif ( matches . containsKey ( referencedSchema . getName ( ) ) && matches . get ( referencedSchema . getName ( ) ) . cardinality ( ) > 0 ) traverseReferencesOutsideClosure ( stateEngine , referencerSchema . getName ( ) , referencedSchema . getName ( ) , matches , REMOVE_REFERENCED_OUTSIDE_CLOSURE ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3367": "public class AbstractProducerMetricsListener { \n@ Override public void onAnnouncementComplete ( com . netflix . hollow . api . producer . Status status , HollowProducer . ReadState readState , long version , Duration elapsed ) { \nboolean isAnnouncementSuccess = false ; \nlong dataSizeBytes = 0l ; \nif ( status . getType ( ) == com . netflix . hollow . api . producer . Status . StatusType . SUCCESS ) { \nisAnnouncementSuccess = true ; \nlastAnnouncementSuccessTimeNanoOptional = OptionalLong . of ( System . nanoTime ( ) ) ; \n} \nHollowReadStateEngine stateEngine = readState . getStateEngine ( ) ; \ndataSizeBytes = stateEngine . calcApproxDataSize ( ) ; \nannouncementMetricsBuilder . setDataSizeBytes ( dataSizeBytes ) . setIsAnnouncementSuccess ( isAnnouncementSuccess ) . setAnnouncementDurationMillis ( elapsed . toMillis ( ) ) ; \nlastAnnouncementSuccessTimeNanoOptional . ifPresent ( announcementMetricsBuilder :: setLastAnnouncementSuccessTimeNano ) ; \nannouncementMetricsReporting ( announcementMetricsBuilder . build ( ) ) ; \nreturn ; \n} \n} \n"}
{"3368": "public class AbstractProducerMetricsListener { \n@ Override public void onCycleComplete ( com . netflix . hollow . api . producer . Status status , HollowProducer . ReadState readState , long version , Duration elapsed ) { \nboolean isCycleSuccess ; \nlong cycleEndTimeNano = System . nanoTime ( ) ; \nif ( status . getType ( ) == com . netflix . hollow . api . producer . Status . StatusType . SUCCESS ) { \nisCycleSuccess = true ; \nconsecutiveFailures = 0l ; \nlastCycleSuccessTimeNanoOptional = OptionalLong . of ( cycleEndTimeNano ) ; \n} \nelse { \nisCycleSuccess = false ; \nconsecutiveFailures ++ ; \n} \ncycleMetricsBuilder . setConsecutiveFailures ( consecutiveFailures ) . setCycleDurationMillis ( elapsed . toMillis ( ) ) . setIsCycleSuccess ( isCycleSuccess ) ; \nlastCycleSuccessTimeNanoOptional . ifPresent ( cycleMetricsBuilder :: setLastCycleSuccessTimeNano ) ; \ncycleMetricsReporting ( cycleMetricsBuilder . build ( ) ) ; \nreturn ; \n} \n} \n"}
{"3371": "public class ThreadSafeBitSet { \npublic void clearAll ( ) { \nThreadSafeBitSetSegments segments = this . segments . get ( ) ; \nfor ( int i = 0 ; \ni < segments . numSegments ( ) ; \ni ++ ) { \nAtomicLongArray segment = segments . getSegment ( i ) ; \nfor ( int j = 0 ; \nj < segment . length ( ) ; \nj ++ ) { \nsegment . set ( j , 0L ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3372": "public class SnapshotPopulatedOrdinalsReader { \npublic static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { \nint numLongs = dis . readInt ( ) ; \nint currentOrdinal = 0 ; \nfor ( int i = 0 ; \ni < numLongs ; \ni ++ ) { \nlong l = dis . readLong ( ) ; \nnotifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; \ncurrentOrdinal += 64 ; \n} \nreturn ; \n} \n} \n"}
{"3375": "public class SegmentedByteArray { \npublic void copy ( ByteData src , long srcPos , long destPos , long length ) { \nfor ( long i = 0 ; \ni < length ; \ni ++ ) { \nset ( destPos ++ , src . get ( srcPos ++ ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3378": "public class SegmentedByteArray { \npublic void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { \nint segmentLength = 1 << log2OfSegmentSize ; \nint currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; \nint segmentStartPos = ( int ) ( destPos & bitmask ) ; \nint remainingBytesInSegment = segmentLength - segmentStartPos ; \nwhile ( length > 0 ) { \nint bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; \nensureCapacity ( currentSegment ) ; \nint copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; \nsrcPos += copiedBytes ; \nlength -= copiedBytes ; \nsegmentStartPos = 0 ; \nremainingBytesInSegment = segmentLength ; \ncurrentSegment ++ ; \n} \nreturn ; \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint segment = 0 ; \nbyte scratch [ ] = new byte [ segmentSize ] ; \nwhile ( length > 0 ) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nwhile ( bytesCopied < bytesToCopy ) { \nbytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \n} \norderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; \nlength -= bytesCopied ; \n} \nreturn ; \n} \n} \n"}
{"3381": "public class SegmentedByteArray { \npublic void writeTo ( OutputStream os , long startPosition , long len ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nlong remainingBytesInCopy = len ; \nwhile ( remainingBytesInCopy > 0 ) { \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , remainingBytesInCopy ) ; \nos . write ( segments [ ( int ) ( startPosition >>> log2OfSegmentSize ) ] , ( int ) ( startPosition & bitmask ) , ( int ) bytesToCopyFromSegment ) ; \nstartPosition += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nremainingBytesInCopy -= bytesToCopyFromSegment ; \n} \nreturn ; \n} \n} \n"}
{"3382": "public class SegmentedByteArray { \nprivate void ensureCapacity ( int segmentIndex ) { \nwhile ( segmentIndex >= segments . length ) { \nsegments = Arrays . copyOf ( segments , segments . length * 3 / 2 ) ; \n} \nif ( segments [ segmentIndex ] == null ) { \nsegments [ segmentIndex ] = memoryRecycler . getByteArray ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3386": "public class HollowAPIGenerator { \npublic void generateFiles ( File directory ) throws IOException { \nif ( packageName != null && ! packageName . trim ( ) . isEmpty ( ) ) { \nString packageDir = packageName . replace ( \".\" , File . separator ) ; \nif ( ! directory . getAbsolutePath ( ) . endsWith ( packageDir ) ) { \ndirectory = new File ( directory , packageDir ) ; \n} \n} \ndirectory . mkdirs ( ) ; \nHollowAPIClassJavaGenerator apiClassGenerator = new HollowAPIClassJavaGenerator ( packageName , apiClassname , dataset , parameterizeClassNames , config ) ; \nHollowAPIFactoryJavaGenerator apiFactoryGenerator = new HollowAPIFactoryJavaGenerator ( packageName , apiClassname , dataset , config ) ; \nHollowHashIndexGenerator hashIndexGenerator = new HollowHashIndexGenerator ( packageName , apiClassname , dataset , config ) ; \ngenerateFile ( directory , apiClassGenerator ) ; \ngenerateFile ( directory , apiFactoryGenerator ) ; \ngenerateFile ( directory , hashIndexGenerator ) ; \ngenerateFilesForHollowSchemas ( directory ) ; \nreturn ; \n} \n} \n"}
{"3387": "public class HollowAPIGenerator { \nprotected void generateFilesForHollowSchemas ( File directory ) throws IOException { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nString type = schema . getName ( ) ; \nif ( config . isUseHollowPrimitiveTypes ( ) && HollowCodeGenerationUtils . isPrimitiveType ( type ) ) continue ; \ngenerateFile ( directory , getStaticAPIGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowObjectGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; \nif ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { \nHollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; \ngenerateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nif ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) { \ngenerateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \nelse if ( ( objSchema ) . getPrimaryKey ( ) != null ) { \ngenerateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; \ngenerateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3393": "public class ObjectIdentityOrdinalMap { \npublic void put ( Object obj , int ordinal ) { \nint hashCode = System . identityHashCode ( obj ) ; \nint segment = segment ( hashCode ) ; \nsegments [ segment ] . put ( obj , hashCode , ordinal ) ; \nreturn ; \n} \n} \n"}
{"3394": "public class HollowPrefixIndex { \nprivate void initialize ( ) { \nString lastRefType = this . fieldPath . getLastRefTypeInPath ( ) ; \ntotalWords = readStateEngine . getTypeState ( lastRefType ) . getPopulatedOrdinals ( ) . cardinality ( ) ; \naverageWordLen = 0 ; \ndouble avg = 0 ; \nHollowObjectTypeReadState objectTypeReadState = ( HollowObjectTypeReadState ) readStateEngine . getTypeState ( lastRefType ) ; \nBitSet keyBitSet = objectTypeReadState . getPopulatedOrdinals ( ) ; \nint ordinal = keyBitSet . nextSetBit ( 0 ) ; \nwhile ( ordinal != - 1 ) { \navg += ( ( double ) objectTypeReadState . readString ( ordinal , 0 ) . length ( ) ) / ( ( double ) objectTypeReadState . maxOrdinal ( ) ) ; \nordinal = keyBitSet . nextSetBit ( ordinal + 1 ) ; \n} \naverageWordLen = ( int ) Math . ceil ( avg ) ; \nHollowObjectTypeReadState valueState = ( HollowObjectTypeReadState ) readStateEngine . getTypeDataAccess ( type ) ; \nmaxOrdinalOfType = valueState . maxOrdinal ( ) ; \nbuild ( ) ; \nreturn ; \n} \n} \n"}
{"3397": "public class HollowFilterConfig { \npublic void addField ( String type , String objectField ) { \nObjectFilterConfig typeConfig = specifiedFieldConfigs . get ( type ) ; \nif ( typeConfig == null ) { \ntypeConfig = new ObjectFilterConfig ( ) ; \nspecifiedFieldConfigs . put ( type , typeConfig ) ; \n} \ntypeConfig . addField ( objectField ) ; \nreturn ; \n} \n} \n"}
{"3399": "public class CodeGeneratorConfig { \npublic void initWithNextMajorVersionDefaults_V3 ( ) { \nusePackageGrouping = true ; \nuseBooleanFieldErgonomics = true ; \nreservePrimaryKeyIndexForTypeWithPrimaryKey = true ; \nuseHollowPrimitiveTypes = true ; \nrestrictApiToFieldType = true ; \nuseVerboseToString = true ; \nreturn ; \n} \n} \n"}
{"3403": "public class HollowSpecificDiff { \npublic void setElementMatchPaths ( String ... paths ) { \nresetResults ( ) ; \nthis . elementPaths = paths ; \nthis . elementKeyPaths = null ; \nthis . elementNonKeyPaths = null ; \nreturn ; \n} \n} \n"}
{"3404": "public class HollowSpecificDiff { \npublic void setElementKeyPaths ( String ... paths ) { \nresetResults ( ) ; \nelementKeyPaths = new BitSet ( elementPaths . length ) ; \nfor ( int i = 0 ; \ni < paths . length ; \ni ++ ) { \nint elementPathIdx = getElementPathIdx ( paths [ i ] ) ; \nif ( elementPathIdx == - 1 ) throw new IllegalArgumentException ( \"Key path must have been specified as an element match path.  Offending path: \" + paths [ i ] ) ; \nelementKeyPaths . set ( elementPathIdx ) ; \n} \nelementNonKeyPaths = new BitSet ( elementPaths . length ) ; \nelementNonKeyPaths . set ( 0 , elementPaths . length ) ; \nelementNonKeyPaths . andNot ( elementKeyPaths ) ; \nreturn ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal int numThreads = executor . getCorePoolSize ( ) ; \nfor ( int i = 0 ; \ni < numThreads ; \ni ++ ) { \nfinal int threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nint hashedResults [ ] = new int [ 16 ] ; \nfor ( int i = threadNumber ; \ni < matcher . getMatchedOrdinals ( ) . size ( ) ; \ni += numThreads ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nint fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nint toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInFrom ( ) . size ( ) ; \ni += numThreads ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInTo ( ) . size ( ) ; \ni += numThreads ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \n} \nreturn ; \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"3406": "public class HollowIncrementalProducer { \npublic void restoreFromLastState ( ) { \nproducer . initializeDataModel ( dataModel ) ; \nlong latestAnnouncedVersion = announcementWatcher . getLatestVersion ( ) ; \nif ( latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher . NO_ANNOUNCEMENT_AVAILABLE || latestAnnouncedVersion < 0 ) { \nreturn ; \n} \nrestore ( latestAnnouncedVersion , blobRetriever ) ; \nreturn ; \n} \n} \n"}
{"3408": "public class HollowCombinerExcludePrimaryKeysCopyDirector { \npublic void excludeKey ( HollowPrimaryKeyIndex idx , Object ... key ) { \nint excludeOrdinal = idx . getMatchingOrdinal ( key ) ; \nif ( excludeOrdinal >= 0 ) { \nBitSet excludedOrdinals = this . excludedOrdinals . get ( idx . getTypeState ( ) ) ; \nif ( excludedOrdinals == null ) { \nexcludedOrdinals = new BitSet ( idx . getTypeState ( ) . maxOrdinal ( ) + 1 ) ; \nthis . excludedOrdinals . put ( idx . getTypeState ( ) , excludedOrdinals ) ; \n} \nexcludedOrdinals . set ( excludeOrdinal ) ; \n} \nreturn ; \n} \n} \n"}
{"3409": "public class HollowCombinerExcludePrimaryKeysCopyDirector { \npublic void excludeReferencedObjects ( ) { \nSet < HollowReadStateEngine > stateEngines = new HashSet < HollowReadStateEngine > ( ) ; \nfor ( Map . Entry < HollowTypeReadState , BitSet > entry : excludedOrdinals . entrySet ( ) ) stateEngines . add ( entry . getKey ( ) . getStateEngine ( ) ) ; \nfor ( HollowReadStateEngine stateEngine : stateEngines ) { \nMap < String , BitSet > typeBitSetsForStateEngine = new HashMap < String , BitSet > ( ) ; \nfor ( Map . Entry < HollowTypeReadState , BitSet > entry : excludedOrdinals . entrySet ( ) ) { \nif ( entry . getKey ( ) . getStateEngine ( ) == stateEngine ) { \nString type = entry . getKey ( ) . getSchema ( ) . getName ( ) ; \ntypeBitSetsForStateEngine . put ( type , BitSet . valueOf ( entry . getValue ( ) . toLongArray ( ) ) ) ; \n} \n} \nTransitiveSetTraverser . addTransitiveMatches ( stateEngine , typeBitSetsForStateEngine ) ; \nfor ( Map . Entry < String , BitSet > entry : typeBitSetsForStateEngine . entrySet ( ) ) excludedOrdinals . put ( stateEngine . getTypeState ( entry . getKey ( ) ) , entry . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3410": "public class HollowBlobHeaderWriter { \npublic void writeHeader ( HollowBlobHeader header , DataOutputStream dos ) throws IOException { \ndos . writeInt ( HollowBlobHeader . HOLLOW_BLOB_VERSION_HEADER ) ; \ndos . writeLong ( header . getOriginRandomizedTag ( ) ) ; \ndos . writeLong ( header . getDestinationRandomizedTag ( ) ) ; \nByteArrayOutputStream schemasStream = new ByteArrayOutputStream ( ) ; \nVarInt . writeVInt ( schemasStream , header . getSchemas ( ) . size ( ) ) ; \nfor ( HollowSchema schema : header . getSchemas ( ) ) schema . writeTo ( schemasStream ) ; \nbyte [ ] schemasData = schemasStream . toByteArray ( ) ; \nVarInt . writeVInt ( dos , schemasData . length + 1 ) ; \ndos . write ( schemasData ) ; \nVarInt . writeVInt ( dos , 0 ) ; \ndos . writeShort ( header . getHeaderTags ( ) . size ( ) ) ; \nfor ( Map . Entry < String , String > headerTag : header . getHeaderTags ( ) . entrySet ( ) ) { \ndos . writeUTF ( headerTag . getKey ( ) ) ; \ndos . writeUTF ( headerTag . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3411": "public class HollowMetrics { \nvoid calculateTypeMetrics ( HollowReadStateEngine hollowReadStateEngine ) { \nCollection < HollowTypeReadState > typeStates = hollowReadStateEngine . getTypeStates ( ) ; \nif ( typeStates == null ) return ; \ntotalHeapFootprint = 0L ; \ntotalPopulatedOrdinals = 0 ; \nfor ( HollowTypeReadState typeState : typeStates ) { \nlong heapCost = typeState . getApproximateHeapFootprintInBytes ( ) ; \ntotalHeapFootprint += heapCost ; \nint populatedOrdinals = typeState . getPopulatedOrdinals ( ) . cardinality ( ) ; \ntotalPopulatedOrdinals += populatedOrdinals ; \nString type = typeState . getSchema ( ) . getName ( ) ; \ntypeHeapFootprint . put ( type , heapCost ) ; \ntypePopulatedOrdinals . put ( type , populatedOrdinals ) ; \n} \nreturn ; \n} \n} \n"}
{"3412": "public class HollowObjectWriteRecord { \npublic void writeDataTo ( ByteDataBuffer buf ) { \nfor ( int i = 0 ; \ni < fieldData . length ; \ni ++ ) { \nwriteField ( buf , i ) ; \n} \nreturn ; \n} \n} \n"}
{"3413": "public class HollowObjectWriteRecord { \nprivate static void writeFixedLengthInt ( ByteDataBuffer fieldBuffer , int intBits ) { \nfieldBuffer . write ( ( byte ) ( intBits >>> 24 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 16 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 8 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits ) ) ; \nreturn ; \n} \n} \n"}
{"3414": "public class HollowObjectWriteRecord { \nprivate static void writeFixedLengthLong ( ByteDataBuffer fieldBuffer , long intBits ) { \nfieldBuffer . write ( ( byte ) ( intBits >>> 56 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 48 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 40 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 32 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 24 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 16 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits >>> 8 ) ) ; \nfieldBuffer . write ( ( byte ) ( intBits ) ) ; \nreturn ; \n} \n} \n"}
{"3415": "public class FreeOrdinalTracker { \npublic void returnOrdinalToPool ( int ordinal ) { \nif ( size == freeOrdinals . length ) { \nfreeOrdinals = Arrays . copyOf ( freeOrdinals , freeOrdinals . length * 3 / 2 ) ; \n} \nfreeOrdinals [ size ] = ordinal ; \nsize ++ ; \nreturn ; \n} \n} \n"}
{"3416": "public class FreeOrdinalTracker { \npublic void sort ( ) { \nArrays . sort ( freeOrdinals , 0 , size ) ; \nint midpoint = size / 2 ; \nfor ( int i = 0 ; \ni < midpoint ; \ni ++ ) { \nint temp = freeOrdinals [ i ] ; \nfreeOrdinals [ i ] = freeOrdinals [ size - i - 1 ] ; \nfreeOrdinals [ size - i - 1 ] = temp ; \n} \nreturn ; \n} \n} \n"}
{"3419": "public class FixedLengthMultipleOccurrenceElementArray { \nprivate void resizeStorage ( ) { \nint currentElementsPerNode = maxElementsPerNode ; \nint newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; \nif ( newElementsPerNode <= currentElementsPerNode ) { \nthrow new IllegalStateException ( \"cannot resize fixed length array from \" + currentElementsPerNode + \" to \" + newElementsPerNode ) ; \n} \nFixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; \nLongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { \nlong currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; \nlong newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; \nfor ( int offset = 0 ; \noffset < currentElementsPerNode ; \noffset ++ ) { \nlong element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; \nif ( element == NO_ELEMENT ) { \nbreak ; \n} \nnewStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; \n} \n} \n) ; \nstorage . destroy ( memoryRecycler ) ; \nstorage = newStorage ; \nmaxElementsPerNode = newElementsPerNode ; \nreturn ; \n} \n} \n"}
{"3421": "public class ByteArrayOrdinalMap { \npublic void prepareForWrite ( ) { \nint maxOrdinal = 0 ; \nAtomicLongArray pao = pointersAndOrdinals ; \nfor ( int i = 0 ; \ni < pao . length ( ) ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \nif ( ordinal > maxOrdinal ) { \nmaxOrdinal = ordinal ; \n} \n} \n} \nlong [ ] pbo = new long [ maxOrdinal + 1 ] ; \nArrays . fill ( pbo , - 1 ) ; \nfor ( int i = 0 ; \ni < pao . length ( ) ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \npbo [ ordinal ] = key & POINTER_MASK ; \n} \n} \npointersByOrdinal = pbo ; \nreturn ; \n} \n} \n"}
{"3423": "public class ByteArrayOrdinalMap { \nprivate void growKeyArray ( ) { \nint newSize = pointersAndOrdinals . length ( ) << 1 ; \nif ( newSize < 0 ) { \nthrow new IllegalStateException ( \"New size computed to grow the underlying array for the map is negative. \" + \"This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. \" + \"Current array size :\" + pointersAndOrdinals . length ( ) + \" and size to grow :\" + newSize ) ; \n} \ngrowKeyArray ( newSize ) ; \nreturn ; \n} \n} \n"}
{"3431": "public class HollowBlobWriter { \npublic void writeSnapshot ( OutputStream os ) throws IOException { \nstateEngine . prepareForWrite ( ) ; \nDataOutputStream dos = new DataOutputStream ( os ) ; \nwriteHeader ( dos , stateEngine . getSchemas ( ) , false ) ; \nVarInt . writeVInt ( dos , stateEngine . getOrderedTypeStates ( ) . size ( ) ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"write-snapshot\" ) ; \nfor ( final HollowTypeWriteState typeState : stateEngine . getOrderedTypeStates ( ) ) { \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \ntypeState . calculateSnapshot ( ) ; \nreturn ; \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nfor ( HollowTypeWriteState typeState : stateEngine . getOrderedTypeStates ( ) ) { \nHollowSchema schema = typeState . getSchema ( ) ; \nschema . writeTo ( dos ) ; \nwriteNumShards ( dos , typeState . getNumShards ( ) ) ; \ntypeState . writeSnapshot ( dos ) ; \n} \nos . flush ( ) ; \nreturn ; \n} \n} \n"}
{"3432": "public class HollowBlobWriter { \npublic void writeDelta ( OutputStream os ) throws IOException { \nstateEngine . prepareForWrite ( ) ; \nif ( stateEngine . isRestored ( ) ) stateEngine . ensureAllNecessaryStatesRestored ( ) ; \nList < HollowSchema > changedTypes = changedTypes ( ) ; \nDataOutputStream dos = new DataOutputStream ( os ) ; \nwriteHeader ( dos , changedTypes , false ) ; \nVarInt . writeVInt ( dos , changedTypes . size ( ) ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"write-delta\" ) ; \nfor ( final HollowTypeWriteState typeState : stateEngine . getOrderedTypeStates ( ) ) { \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nif ( typeState . hasChangedSinceLastCycle ( ) ) typeState . calculateDelta ( ) ; \nreturn ; \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nfor ( HollowTypeWriteState typeState : stateEngine . getOrderedTypeStates ( ) ) { \nif ( typeState . hasChangedSinceLastCycle ( ) ) { \nHollowSchema schema = typeState . getSchema ( ) ; \nschema . writeTo ( dos ) ; \nwriteNumShards ( dos , typeState . getNumShards ( ) ) ; \ntypeState . writeDelta ( dos ) ; \n} \n} \nos . flush ( ) ; \nreturn ; \n} \n} \n"}
{"3433": "public class HollowConsumerJavaFileGenerator { \nprivate void addToSetIfNotPrimitiveOrCollection ( Set < String > schemaNameSet , String ... schemaNames ) { \nfor ( String schemaName : schemaNames ) { \nif ( ! HollowCodeGenerationUtils . isCollectionType ( schemaName , dataset ) && ! HollowCodeGenerationUtils . isPrimitiveType ( schemaName ) ) { \nschemaNameSet . add ( schemaName ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3435": "public class HollowHashIndex { \nprivate void reindexHashIndex ( ) { \nHollowHashIndexBuilder builder = new HollowHashIndexBuilder ( stateEngine , type , selectField , matchFields ) ; \nbuilder . buildIndex ( ) ; \nthis . hashStateVolatile = new HollowHashIndexState ( builder ) ; \nreturn ; \n} \n} \n"}
{"3437": "public class HollowAnnouncementWatcher { \npublic void triggerAsyncRefreshWithRandomDelay ( int maxDelayMillis ) { \nRandom rand = new Random ( ) ; \nint delayMillis = maxDelayMillis > 0 ? rand . nextInt ( maxDelayMillis ) : 0 ; \ntriggerAsyncRefreshWithDelay ( delayMillis ) ; \nreturn ; \n} \n} \n"}
{"3438": "public class HollowAnnouncementWatcher { \npublic void triggerAsyncRefreshWithDelay ( int delayMillis ) { \nfinal HollowClient client = this . client ; \nfinal long targetBeginTime = System . currentTimeMillis ( ) + delayMillis ; \nrefreshExecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \ntry { \nlong delay = targetBeginTime - System . currentTimeMillis ( ) ; \nif ( delay > 0 ) Thread . sleep ( delay ) ; \nclient . triggerRefresh ( ) ; \n} \ncatch ( Throwable th ) { \nlog . log ( Level . SEVERE , \"Async refresh failed\" , th ) ; \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3440": "public class HollowDiff { \npublic void calculateDiffs ( ) { \nlong startTime = System . currentTimeMillis ( ) ; \nprepareForDiffCalculation ( ) ; \nlong endTime = System . currentTimeMillis ( ) ; \nlog . info ( \"PREPARED IN \" + ( endTime - startTime ) + \"ms\" ) ; \nfor ( HollowTypeDiff typeDiff : typeDiffs . values ( ) ) { \ntypeDiff . calculateDiffs ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3441": "public class VarInt { \npublic static void writeVLong ( OutputStream out , long value ) throws IOException { \nif ( value < 0 ) out . write ( ( byte ) 0x81 ) ; \nif ( value > 0xFFFFFFFFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 56 ) & 0x7FL ) ) ) ; \nif ( value > 0x1FFFFFFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 49 ) & 0x7FL ) ) ) ; \nif ( value > 0x3FFFFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 42 ) & 0x7FL ) ) ) ; \nif ( value > 0x7FFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 35 ) & 0x7FL ) ) ) ; \nif ( value > 0xFFFFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) & 0x7FL ) ) ) ; \nif ( value > 0x1FFFFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7FL ) ) ) ; \nif ( value > 0x3FFFL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7FL ) ) ) ; \nif ( value > 0x7FL || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7FL ) ) ) ; \nout . write ( ( byte ) ( value & 0x7FL ) ) ; \nreturn ; \n} \n} \n"}
{"3442": "public class VarInt { \npublic static void writeVInt ( OutputStream out , int value ) throws IOException { \nif ( value > 0x0FFFFFFF || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nif ( value > 0x1FFFFF || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nif ( value > 0x3FFF || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nif ( value > 0x7F || value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \nout . write ( ( byte ) ( value & 0x7F ) ) ; \nreturn ; \n} \n} \n"}
{"3446": "public class PullToRefreshBase { \nprotected final void addViewInternal ( View child , int index , ViewGroup . LayoutParams params ) { \nsuper . addView ( child , index , params ) ; \nreturn ; \n} \n} \n"}
{"3447": "public class PullToRefreshBase { \nprotected final void refreshLoadingViewsSize ( ) { \nfinal int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * 1.2f ) ; \nint pLeft = getPaddingLeft ( ) ; \nint pTop = getPaddingTop ( ) ; \nint pRight = getPaddingRight ( ) ; \nint pBottom = getPaddingBottom ( ) ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { \nmHeaderLayout . setWidth ( maximumPullScroll ) ; \npLeft = - maximumPullScroll ; \n} \nelse { \npLeft = 0 ; \n} \nif ( mMode . showFooterLoadingLayout ( ) ) { \nmFooterLayout . setWidth ( maximumPullScroll ) ; \npRight = - maximumPullScroll ; \n} \nelse { \npRight = 0 ; \n} \nbreak ; \ncase VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { \nmHeaderLayout . setHeight ( maximumPullScroll ) ; \npTop = - maximumPullScroll ; \n} \nelse { \npTop = 0 ; \n} \nif ( mMode . showFooterLoadingLayout ( ) ) { \nmFooterLayout . setHeight ( maximumPullScroll ) ; \npBottom = - maximumPullScroll ; \n} \nelse { \npBottom = 0 ; \n} \nbreak ; \n} \nif ( DEBUG ) { \nLog . d ( LOG_TAG , String . format ( \"Setting Padding. L: %d, T: %d, R: %d, B: %d\" , pLeft , pTop , pRight , pBottom ) ) ; \n} \nsetPadding ( pLeft , pTop , pRight , pBottom ) ; \nreturn ; \n} \n} \n"}
{"3448": "public class PullToRefreshBase { \nprotected void updateUIForMode ( ) { \nfinal LinearLayout . LayoutParams lp = getLoadingLayoutLayoutParams ( ) ; \nif ( this == mHeaderLayout . getParent ( ) ) { \nremoveView ( mHeaderLayout ) ; \n} \nif ( mMode . showHeaderLoadingLayout ( ) ) { \naddViewInternal ( mHeaderLayout , 0 , lp ) ; \n} \nif ( this == mFooterLayout . getParent ( ) ) { \nremoveView ( mFooterLayout ) ; \n} \nif ( mMode . showFooterLoadingLayout ( ) ) { \naddViewInternal ( mFooterLayout , lp ) ; \n} \nrefreshLoadingViewsSize ( ) ; \nmCurrentMode = ( mMode != Mode . BOTH ) ? mMode : Mode . PULL_FROM_START ; \nreturn ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal int newScrollValue ; \nfinal int itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 && ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { \nsetState ( State . PULL_TO_REFRESH ) ; \n} \nelse if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { \nsetState ( State . RELEASE_TO_REFRESH ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal int deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { \nfinal int newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) { \nLog . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \n} \nif ( newScrollValue < ( 0 - fuzzyThreshold ) ) { \nif ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \n} \nelse if ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) { \nif ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \n} \nelse if ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) { \nview . setState ( State . RESET ) ; \n} \n} \nelse if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) { \nview . setState ( State . RESET ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3464": "public class Auditor { \npublic void registerRule ( Auditable rule ) { \n_lock . writeLock ( ) . lock ( ) ; \ntry { \n_auditMap . put ( rule . getName ( ) , new HashMap < > ( ) ) ; \n} \nfinally { \n_lock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3465": "public class Auditor { \npublic void updateRuleStatus ( Auditable rule , RuleStatus status ) { \n_lock . readLock ( ) . lock ( ) ; \ntry { \nif ( _auditMap . containsKey ( rule . getName ( ) ) ) { \n_lock . readLock ( ) . unlock ( ) ; \n_lock . writeLock ( ) . lock ( ) ; \ntry { \n_auditMap . get ( rule . getName ( ) ) . put ( Thread . currentThread ( ) . getId ( ) , status ) ; \n_lock . readLock ( ) . lock ( ) ; \n} \nfinally { \n_lock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \nfinally { \n_lock . readLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3470": "public class Result { \npublic void reset ( ) { \n_lock . readLock ( ) . lock ( ) ; \ntry { \nif ( _defaultValue == null ) { \nreturn ; \n} \n} \nfinally { \n_lock . readLock ( ) . unlock ( ) ; \n} \nsetValue ( _defaultValue ) ; \nreturn ; \n} \n} \n"}
{"3478": "public class DefaultServiceEnricher { \nprivate void addPortIfNotNull ( List < ServicePort > ret , ServicePort port ) { \nif ( port != null ) { \nret . add ( port ) ; \n} \nreturn ; \n} \n} \n"}
{"3480": "public class DefaultServiceEnricher { \nprivate void addMissingServiceParts ( ServiceBuilder service , Service defaultService ) { \nif ( ! service . hasSpec ( ) ) { \nservice . withNewSpecLike ( defaultService . getSpec ( ) ) . endSpec ( ) ; \nreturn ; \n} \nList < ServicePort > ports = service . buildSpec ( ) . getPorts ( ) ; \nif ( ports == null || ports . isEmpty ( ) ) { \nservice . editSpec ( ) . withPorts ( defaultService . getSpec ( ) . getPorts ( ) ) . endSpec ( ) ; \nreturn ; \n} \nservice . editSpec ( ) . withPorts ( addMissingDefaultPorts ( ports , defaultService ) ) . endSpec ( ) ; \nreturn ; \n} \n} \n"}
{"3481": "public class ImageStreamService { \npublic void appendImageStreamResource ( ImageName imageName , File target ) throws MojoExecutionException { \nString tag = StringUtils . isBlank ( imageName . getTag ( ) ) ? \"latest\" : imageName . getTag ( ) ; \ntry { \nImageStream is = new ImageStreamBuilder ( ) . withNewMetadata ( ) . withName ( imageName . getSimpleName ( ) ) . endMetadata ( ) . withNewSpec ( ) . addNewTag ( ) . withName ( tag ) . withNewFrom ( ) . withKind ( \"ImageStreamImage\" ) . endFrom ( ) . endTag ( ) . endSpec ( ) . build ( ) ; \ncreateOrUpdateImageStreamTag ( client , imageName , is ) ; \nappendImageStreamToFile ( is , target ) ; \nlog . info ( \"ImageStream %s written to %s\" , imageName . getSimpleName ( ) , target ) ; \n} \ncatch ( KubernetesClientException e ) { \nKubernetesResourceUtil . handleKubernetesClientException ( e , this . log ) ; \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( String . format ( \"Cannot write ImageStream descriptor for %s to %s : %s\" , imageName . getFullName ( ) , target . getAbsoluteFile ( ) , e . getMessage ( ) ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3485": "public class MapUtil { \npublic static void putIfAbsent ( Map < String , String > map , String name , String value ) { \nif ( ! map . containsKey ( name ) ) { \nmap . put ( name , value ) ; \n} \nreturn ; \n} \n} \n"}
{"3486": "public class MapUtil { \npublic static void mergeIfAbsent ( Map < String , String > map , Map < String , String > toMerge ) { \nfor ( Map . Entry < String , String > entry : toMerge . entrySet ( ) ) { \nputIfAbsent ( map , entry . getKey ( ) , entry . getValue ( ) ) ; \n; \n} \nreturn ; \n} \n} \n"}
{"3488": "public class MapUtil { \npublic static void putAllIfNotNull ( Map < String , String > ret , Map < String , String > toPut ) { \nif ( toPut != null ) { \nret . putAll ( toPut ) ; \n} \nreturn ; \n} \n} \n"}
{"3489": "public class OpenshiftBuildService { \nprivate void waitUntilPodIsReady ( String podName , int nAwaitTimeout , final Logger log ) throws InterruptedException { \nfinal CountDownLatch readyLatch = new CountDownLatch ( 1 ) ; \ntry ( Watch watch = client . pods ( ) . withName ( podName ) . watch ( new Watcher < Pod > ( ) { \n@ Override public void eventReceived ( Action action , Pod aPod ) { \nif ( KubernetesHelper . isPodReady ( aPod ) ) { \nreadyLatch . countDown ( ) ; \n} \nreturn ; \n} \n@ Override public void onClose ( KubernetesClientException e ) { \nreturn ; \n} \n} \n) ) { \nreadyLatch . await ( nAwaitTimeout , TimeUnit . SECONDS ) ; \n} \ncatch ( KubernetesClientException | InterruptedException e ) { \nlog . error ( \"Could not watch pod\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3495": "public class RouteEnricher { \nprivate boolean hasRoute ( final KubernetesListBuilder listBuilder , final String name ) { \nfinal AtomicBoolean answer = new AtomicBoolean ( false ) ; \nlistBuilder . accept ( new TypedVisitor < RouteBuilder > ( ) { \n@ Override public void visit ( RouteBuilder builder ) { \nObjectMeta metadata = builder . getMetadata ( ) ; \nif ( metadata != null && name . equals ( metadata . getName ( ) ) ) { \nanswer . set ( true ) ; \n} \nreturn ; \n} \n} \n) ; \nreturn answer . get ( ) ; \n} \n} \n"}
{"3503": "public class AbstractPortsExtractor { \nprivate void addPortIfValid ( Map < String , Integer > map , String key , String port ) { \nif ( StringUtils . isNotBlank ( port ) ) { \nString t = port . trim ( ) ; \nif ( t . matches ( NUMBER_REGEX ) ) { \nmap . put ( key , Integer . parseInt ( t ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3507": "public class IoUtil { \npublic static void download ( Logger log , URL downloadUrl , File target ) throws MojoExecutionException { \nlog . progressStart ( ) ; \ntry { \nOkHttpClient client = new OkHttpClient . Builder ( ) . readTimeout ( 30 , TimeUnit . MINUTES ) . build ( ) ; \nRequest request = new Request . Builder ( ) . url ( downloadUrl ) . build ( ) ; \nResponse response = client . newCall ( request ) . execute ( ) ; \ntry ( OutputStream out = new FileOutputStream ( target ) ; \nInputStream im = response . body ( ) . byteStream ( ) ) { \nlong length = response . body ( ) . contentLength ( ) ; \nInputStream in = response . body ( ) . byteStream ( ) ; \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong readBytes = 0 ; \nwhile ( true ) { \nint len = in . read ( buffer ) ; \nreadBytes += len ; \nlog . progressUpdate ( target . getName ( ) , \"Downloading\" , getProgressBar ( readBytes , length ) ) ; \nif ( len <= 0 ) { \nout . flush ( ) ; \nbreak ; \n} \nout . write ( buffer , 0 , len ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Failed to download URL \" + downloadUrl + \" to  \" + target + \": \" + e , e ) ; \n} \nfinally { \nlog . progressFinished ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3520": "public class ApplyService { \npublic void installTemplate ( Template entity , String sourceName ) { \nOpenShiftClient openShiftClient = getOpenShiftClient ( ) ; \nif ( openShiftClient == null ) { \nreturn ; \n} \nif ( ! isProcessTemplatesLocally ( ) ) { \nString namespace = getNamespace ( ) ; \nString id = getName ( entity ) ; \nObjects . requireNonNull ( id , \"No name for \" + entity + \" \" + sourceName ) ; \nTemplate old = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; \nif ( isRunning ( old ) ) { \nif ( UserConfigurationCompare . configEqual ( entity , old ) ) { \nlog . info ( \"Template has not changed so not doing anything\" ) ; \n} \nelse { \nboolean recreateMode = isRecreateMode ( ) ; \nrecreateMode = true ; \nif ( recreateMode ) { \nopenShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . delete ( ) ; \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \nelse { \nlog . info ( \"Updating a Template from \" + sourceName ) ; \ntry { \nObject answer = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . replace ( entity ) ; \nlog . info ( \"Updated Template: \" + answer ) ; \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to update Template from \" + sourceName + \". \" + e + \". \" + entity , e ) ; \n} \n} \n} \n} \nelse { \nif ( ! isAllowCreate ( ) ) { \nlog . warn ( \"Creation disabled so not creating a Template from \" + sourceName + \" namespace \" + namespace + \" name \" + getName ( entity ) ) ; \n} \nelse { \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3526": "public class ApplyService { \nprotected void onApplyError ( String message , Exception e ) { \nlog . error ( message , e ) ; \nthrow new RuntimeException ( message , e ) ; \nreturn ; \n} \n} \n"}
{"3527": "public class DefaultNamespaceEnricher { \n@ Override public void create ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nfinal String name = config . getNamespace ( ) ; \nif ( name == null || name . isEmpty ( ) ) { \nreturn ; \n} \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { \nString type = getConfig ( Config . type ) ; \nif ( \"project\" . equalsIgnoreCase ( type ) || \"namespace\" . equalsIgnoreCase ( type ) ) { \nif ( platformMode == PlatformMode . kubernetes ) { \nlog . info ( \"Adding a default Namespace:\" + config . getNamespace ( ) ) ; \nNamespace namespace = handlerHub . getNamespaceHandler ( ) . getNamespace ( config . getNamespace ( ) ) ; \nbuilder . addToNamespaceItems ( namespace ) ; \n} \nelse { \nlog . info ( \"Adding a default Project\" + config . getNamespace ( ) ) ; \nProject project = handlerHub . getProjectHandler ( ) . getProject ( config . getNamespace ( ) ) ; \nbuilder . addToProjectItems ( project ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3528": "public class DefaultNamespaceEnricher { \n@ Override public void enrich ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nbuilder . accept ( new TypedVisitor < ObjectMetaBuilder > ( ) { \nprivate String getNamespaceName ( ) { \nString name = null ; \nif ( config . getNamespace ( ) != null && ! config . getNamespace ( ) . isEmpty ( ) ) { \nname = config . getNamespace ( ) ; \n} \nname = builder . getItems ( ) . stream ( ) . filter ( item -> Arrays . asList ( NAMESPACE_KINDS ) . contains ( item . getKind ( ) ) ) . findFirst ( ) . get ( ) . getMetadata ( ) . getName ( ) ; \nreturn name ; \n} \n@ Override public void visit ( ObjectMetaBuilder metaBuilder ) { \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { \nreturn ; \n} \nString name = getNamespaceName ( ) ; \nif ( name == null || name . isEmpty ( ) ) { \nreturn ; \n} \nmetaBuilder . withNamespace ( name ) . build ( ) ; \nreturn ; \n} \n} \n) ; \nbuilder . accept ( new TypedVisitor < NamespaceBuilder > ( ) { \n@ Override public void visit ( NamespaceBuilder builder ) { \nbuilder . withNewStatus ( \"active\" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; \nreturn ; \n} \n} \n) ; \nbuilder . accept ( new TypedVisitor < ProjectBuilder > ( ) { \n@ Override public void visit ( ProjectBuilder builder ) { \nbuilder . withNewStatus ( \"active\" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3533": "public class ApplyMojo { \nprotected void disableOpenShiftFeatures ( ApplyService applyService ) { \nthis . processTemplatesLocally = true ; \napplyService . setSupportOAuthClients ( false ) ; \napplyService . setProcessTemplatesLocally ( true ) ; \nreturn ; \n} \n} \n"}
{"3541": "public class IconEnricher { \nprivate void copyAppConfigFiles ( File appBuildDir , File appConfigDir ) throws IOException { \nFile [ ] files = appConfigDir . listFiles ( ) ; \nif ( files != null ) { \nappBuildDir . mkdirs ( ) ; \nfor ( File file : files ) { \nFile outFile = new File ( appBuildDir , file . getName ( ) ) ; \nif ( file . isDirectory ( ) ) { \ncopyAppConfigFiles ( outFile , file ) ; \n} \nelse { \nFiles . copy ( file , outFile ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3545": "public class EnricherManager { \nprivate void enrich ( PlatformMode platformMode , final ProcessorConfig enricherConfig , final KubernetesListBuilder builder , final List < Enricher > enricherList ) { \nloop ( enricherConfig , enricher -> { \nenricher . enrich ( platformMode , builder ) ; \nreturn null ; \n} \n) ; \nreturn ; \n} \n} \n"}
{"3554": "public class BaseGenerator { \nprotected void addFrom ( BuildImageConfiguration . Builder builder ) { \nString fromMode = getConfigWithFallback ( Config . fromMode , \"fabric8.generator.fromMode\" , getFromModeDefault ( context . getRuntimeMode ( ) ) ) ; \nString from = getConfigWithFallback ( Config . from , \"fabric8.generator.from\" , null ) ; \nif ( \"docker\" . equalsIgnoreCase ( fromMode ) ) { \nString fromImage = from ; \nif ( fromImage == null ) { \nfromImage = fromSelector != null ? fromSelector . getFrom ( ) : null ; \n} \nbuilder . from ( fromImage ) ; \nlog . info ( \"Using Docker image %s as base / builder\" , fromImage ) ; \n} \nelse if ( \"istag\" . equalsIgnoreCase ( fromMode ) ) { \nMap < String , String > fromExt = new HashMap < > ( ) ; \nif ( from != null ) { \nImageName iName = new ImageName ( from ) ; \nString tag = iName . getTag ( ) ; \nif ( StringUtils . isBlank ( tag ) ) { \ntag = \"latest\" ; \n} \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) , iName . getSimpleName ( ) + \":\" + tag ) ; \nif ( iName . getUser ( ) != null ) { \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) , iName . getUser ( ) ) ; \n} \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . kind . key ( ) , \"ImageStreamTag\" ) ; \n} \nelse { \nfromExt = fromSelector != null ? fromSelector . getImageStreamTagFromExt ( ) : null ; \n} \nif ( fromExt != null ) { \nString namespace = fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) ) ; \nif ( namespace != null ) { \nlog . info ( \"Using ImageStreamTag '%s' from namespace '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) , namespace ) ; \n} \nelse { \nlog . info ( \"Using ImageStreamTag '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) ) ; \n} \nbuilder . fromExt ( fromExt ) ; \n} \n} \nelse { \nthrow new IllegalArgumentException ( String . format ( \"Invalid 'fromMode' in generator configuration for '%s'\" , getName ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3565": "public class AmericanExpress { \npublic static void getRewardsBalance ( final BraintreeFragment fragment , final String nonce , final String currencyIsoCode ) { \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nString getRewardsBalanceUrl = Uri . parse ( AMEX_REWARDS_BALANCE_PATH ) . buildUpon ( ) . appendQueryParameter ( \"paymentMethodNonce\" , nonce ) . appendQueryParameter ( \"currencyIsoCode\" , currencyIsoCode ) . build ( ) . toString ( ) ; \nfragment . sendAnalyticsEvent ( \"amex.rewards-balance.start\" ) ; \nfragment . getHttpClient ( ) . get ( getRewardsBalanceUrl , new HttpResponseCallback ( ) { \n@ Override public void success ( String responseBody ) { \nfragment . sendAnalyticsEvent ( \"amex.rewards-balance.success\" ) ; \ntry { \nfragment . postAmericanExpressCallback ( AmericanExpressRewardsBalance . fromJson ( responseBody ) ) ; \n} \ncatch ( JSONException e ) { \nfragment . sendAnalyticsEvent ( \"amex.rewards-balance.parse.failed\" ) ; \nfragment . postCallback ( e ) ; \n} \nreturn ; \n} \n@ Override public void failure ( Exception exception ) { \nfragment . postCallback ( exception ) ; \nfragment . sendAnalyticsEvent ( \"amex.rewards-balance.error\" ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3567": "public class BraintreeHttpClient { \n@ Override public void get ( String path , HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nUri uri ; \nif ( path . startsWith ( \"http\" ) ) { \nuri = Uri . parse ( path ) ; \n} \nelse { \nuri = Uri . parse ( mBaseUrl + path ) ; \n} \nif ( mAuthorization instanceof ClientToken ) { \nuri = uri . buildUpon ( ) . appendQueryParameter ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . build ( ) ; \n} \nsuper . get ( uri . toString ( ) , callback ) ; \nreturn ; \n} \n} \n"}
{"3568": "public class BraintreeHttpClient { \n@ Override public void post ( String path , String data , HttpResponseCallback callback ) { \ntry { \nif ( mAuthorization instanceof ClientToken ) { \ndata = new JSONObject ( data ) . put ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . toString ( ) ; \n} \nsuper . post ( path , data , callback ) ; \n} \ncatch ( JSONException e ) { \npostCallbackOnMainThread ( callback , e ) ; \n} \nreturn ; \n} \n} \n"}
{"3570": "public class DataCollector { \npublic static void collectDeviceData ( BraintreeFragment fragment , BraintreeResponseListener < String > listener ) { \ncollectDeviceData ( fragment , null , listener ) ; \nreturn ; \n} \n} \n"}
{"3571": "public class DataCollector { \npublic static void collectDeviceData ( final BraintreeFragment fragment , final String merchantId , final BraintreeResponseListener < String > listener ) { \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nfinal JSONObject deviceData = new JSONObject ( ) ; \ntry { \nString clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; \nif ( ! TextUtils . isEmpty ( clientMetadataId ) ) { \ndeviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; \n} \n} \ncatch ( JSONException ignored ) { \n} \nif ( configuration . getKount ( ) . isEnabled ( ) ) { \nfinal String id ; \nif ( merchantId != null ) { \nid = merchantId ; \n} \nelse { \nid = configuration . getKount ( ) . getKountMerchantId ( ) ; \n} \ntry { \nfinal String deviceSessionId = UUIDHelper . getFormattedUUID ( ) ; \nstartDeviceCollector ( fragment , id , deviceSessionId , new BraintreeResponseListener < String > ( ) { \n@ Override public void onResponse ( String sessionId ) { \ntry { \ndeviceData . put ( DEVICE_SESSION_ID_KEY , deviceSessionId ) ; \ndeviceData . put ( FRAUD_MERCHANT_ID_KEY , id ) ; \n} \ncatch ( JSONException ignored ) { \n} \nlistener . onResponse ( deviceData . toString ( ) ) ; \nreturn ; \n} \n} \n) ; \n} \ncatch ( ClassNotFoundException | NoClassDefFoundError | NumberFormatException ignored ) { \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \n} \nelse { \nlistener . onResponse ( deviceData . toString ( ) ) ; \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3572": "public class DataCollector { \npublic static void collectPayPalDeviceData ( final BraintreeFragment fragment , final BraintreeResponseListener < String > listener ) { \nfinal JSONObject deviceData = new JSONObject ( ) ; \ntry { \nString clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; \nif ( ! TextUtils . isEmpty ( clientMetadataId ) ) { \ndeviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; \n} \n} \ncatch ( JSONException ignored ) { \n} \nlistener . onResponse ( deviceData . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"3579": "public class HttpClient { \npublic void get ( final String path , final HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nfinal String url ; \nif ( path . startsWith ( \"http\" ) ) { \nurl = path ; \n} \nelse { \nurl = mBaseUrl + path ; \n} \nmThreadPool . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \nHttpURLConnection connection = null ; \ntry { \nconnection = init ( url ) ; \nconnection . setRequestMethod ( METHOD_GET ) ; \npostCallbackOnMainThread ( callback , parseResponse ( connection ) ) ; \n} \ncatch ( Exception e ) { \npostCallbackOnMainThread ( callback , e ) ; \n} \nfinally { \nif ( connection != null ) { \nconnection . disconnect ( ) ; \n} \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3580": "public class HttpClient { \npublic void post ( final String path , final String data , final HttpResponseCallback callback ) { \nif ( path == null ) { \npostCallbackOnMainThread ( callback , new IllegalArgumentException ( \"Path cannot be null\" ) ) ; \nreturn ; \n} \nmThreadPool . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \npostCallbackOnMainThread ( callback , post ( path , data ) ) ; \n} \ncatch ( Exception e ) { \npostCallbackOnMainThread ( callback , e ) ; \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3582": "public class LocalPayment { \npublic static void startPayment ( final BraintreeFragment fragment , final LocalPaymentRequest request , final BraintreeResponseListener < LocalPaymentRequest > listener ) { \nif ( request == null ) { \nfragment . postCallback ( new BraintreeException ( \"A LocalPaymentRequest is required.\" ) ) ; \nreturn ; \n} \nelse if ( request . getApprovalUrl ( ) != null || request . getPaymentId ( ) != null ) { \nfragment . postCallback ( new BraintreeException ( \"LocalPaymentRequest is invalid, \" + \"appovalUrl and paymentId should not be set.\" ) ) ; \nreturn ; \n} \nelse if ( request . getPaymentType ( ) == null || request . getAmount ( ) == null ) { \nfragment . postCallback ( new BraintreeException ( \"LocalPaymentRequest is invalid, \" + \"paymentType and amount are required.\" ) ) ; \nreturn ; \n} \nelse if ( listener == null ) { \nfragment . postCallback ( new BraintreeException ( \"BraintreeResponseListener<LocalPaymentRequest> \" + \"is required.\" ) ) ; \nreturn ; \n} \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nif ( ! configuration . getPayPal ( ) . isEnabled ( ) ) { \nfragment . postCallback ( new ConfigurationException ( \"Local payments are not enabled for this merchant.\" ) ) ; \nreturn ; \n} \nsMerchantAccountId = request . getMerchantAccountId ( ) ; \nsPaymentType = request . getPaymentType ( ) ; \nString returnUrl = fragment . getReturnUrlScheme ( ) + \"://\" + LOCAL_PAYMENT_SUCCESSS ; \nString cancel = fragment . getReturnUrlScheme ( ) + \"://\" + LOCAL_PAYMENT_CANCEL ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.start-payment.selected\" ) ; \nfragment . getHttpClient ( ) . post ( \"/v1/paypal_hermes/create_payment_resource\" , request . build ( returnUrl , cancel ) , new HttpResponseCallback ( ) { \n@ Override public void success ( String responseBody ) { \ntry { \nJSONObject responseJson = new JSONObject ( responseBody ) ; \nrequest . approvalUrl ( responseJson . getJSONObject ( \"paymentResource\" ) . getString ( \"redirectUrl\" ) ) ; \nrequest . paymentId ( responseJson . getJSONObject ( \"paymentResource\" ) . getString ( \"paymentToken\" ) ) ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.create.succeeded\" ) ; \nlistener . onResponse ( request ) ; \n} \ncatch ( JSONException jsonException ) { \nfailure ( jsonException ) ; \n} \nreturn ; \n} \n@ Override public void failure ( Exception exception ) { \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.webswitch.initiate.failed\" ) ; \nfragment . postCallback ( exception ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"3583": "public class LocalPayment { \npublic static void approvePayment ( BraintreeFragment fragment , LocalPaymentRequest request ) { \nfragment . browserSwitch ( BraintreeRequestCodes . LOCAL_PAYMENT , request . getApprovalUrl ( ) ) ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.webswitch.initiate.succeeded\" ) ; \nreturn ; \n} \n} \n"}
{"3584": "public class BraintreeFragment { \npublic < T extends BraintreeListener > void addListener ( T listener ) { \nif ( listener instanceof ConfigurationListener ) { \nmConfigurationListener = ( ConfigurationListener ) listener ; \n} \nif ( listener instanceof BraintreeCancelListener ) { \nmCancelListener = ( BraintreeCancelListener ) listener ; \n} \nif ( listener instanceof PaymentMethodNoncesUpdatedListener ) { \nmPaymentMethodNoncesUpdatedListener = ( PaymentMethodNoncesUpdatedListener ) listener ; \n} \nif ( listener instanceof PaymentMethodNonceCreatedListener ) { \nmPaymentMethodNonceCreatedListener = ( PaymentMethodNonceCreatedListener ) listener ; \n} \nif ( listener instanceof PaymentMethodNonceDeletedListener ) { \nmPaymentMethodNonceDeletedListener = ( PaymentMethodNonceDeletedListener ) listener ; \n} \nif ( listener instanceof BraintreePaymentResultListener ) { \nmBraintreePaymentResultListener = ( BraintreePaymentResultListener ) listener ; \n} \nif ( listener instanceof BraintreeErrorListener ) { \nmErrorListener = ( BraintreeErrorListener ) listener ; \n} \nif ( listener instanceof UnionPayListener ) { \nmUnionPayListener = ( UnionPayListener ) listener ; \n} \nif ( listener instanceof AmericanExpressListener ) { \nmAmericanExpressListener = ( AmericanExpressListener ) listener ; \n} \nflushCallbacks ( ) ; \nreturn ; \n} \n} \n"}
{"3585": "public class BraintreeFragment { \npublic < T extends BraintreeListener > void removeListener ( T listener ) { \nif ( listener instanceof ConfigurationListener ) { \nmConfigurationListener = null ; \n} \nif ( listener instanceof BraintreeCancelListener ) { \nmCancelListener = null ; \n} \nif ( listener instanceof PaymentMethodNoncesUpdatedListener ) { \nmPaymentMethodNoncesUpdatedListener = null ; \n} \nif ( listener instanceof PaymentMethodNonceCreatedListener ) { \nmPaymentMethodNonceCreatedListener = null ; \n} \nif ( listener instanceof PaymentMethodNonceDeletedListener ) { \nmPaymentMethodNonceDeletedListener = null ; \n} \nif ( listener instanceof BraintreePaymentResultListener ) { \nmBraintreePaymentResultListener = null ; \n} \nif ( listener instanceof BraintreeErrorListener ) { \nmErrorListener = null ; \n} \nif ( listener instanceof UnionPayListener ) { \nmUnionPayListener = null ; \n} \nif ( listener instanceof AmericanExpressListener ) { \nmAmericanExpressListener = null ; \n} \nreturn ; \n} \n} \n"}
{"3586": "public class PayPal { \npublic static void requestBillingAgreement ( BraintreeFragment fragment , PayPalRequest request , PayPalApprovalHandler handler ) { \nif ( request . getAmount ( ) == null ) { \nfragment . sendAnalyticsEvent ( \"paypal.billing-agreement.selected\" ) ; \nif ( request . shouldOfferCredit ( ) ) { \nfragment . sendAnalyticsEvent ( \"paypal.billing-agreement.credit.offered\" ) ; \n} \nrequestOneTimePayment ( fragment , request , true , handler ) ; \n} \nelse { \nfragment . postCallback ( new BraintreeException ( \"There must be no amount specified for the Billing Agreement flow\" ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3587": "public class PayPal { \nprotected static void onActivityResult ( final BraintreeFragment fragment , int resultCode , Intent data ) { \nRequest request = getPersistedRequest ( fragment . getApplicationContext ( ) ) ; \nString paymentType = paymentTypeForRequest ( request ) ; \nString switchType = switchTypeForIntent ( data ) ; \nString eventPrefix = paymentType + \".\" + switchType ; \nif ( resultCode == AppCompatActivity . RESULT_OK && data != null && request != null ) { \nResult result = PayPalOneTouchCore . parseResponse ( fragment . getApplicationContext ( ) , request , data ) ; \nswitch ( result . getResultType ( ) ) { \ncase Error : fragment . postCallback ( new BrowserSwitchException ( result . getError ( ) . getMessage ( ) ) ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".failed\" ) ; \nbreak ; \ncase Cancel : fragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".canceled\" ) ; \nbreak ; \ncase Success : onSuccess ( fragment , data , request , result ) ; \nfragment . sendAnalyticsEvent ( eventPrefix + \".succeeded\" ) ; \nbreak ; \n} \n} \nelse { \nfragment . sendAnalyticsEvent ( eventPrefix + \".canceled\" ) ; \nif ( resultCode != AppCompatActivity . RESULT_CANCELED ) { \nfragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3589": "public class OpenKoreanTextProcessorJava { \npublic static void addNounsToDictionary ( List < String > words ) { \nOpenKoreanTextProcessor . addNounsToDictionary ( JavaConverters . asScalaBufferConverter ( words ) . asScala ( ) ) ; \nreturn ; \n} \n} \n"}
{"3590": "public class OpenKoreanTextProcessorJava { \npublic static void removeWordFromDictionary ( KoreanPosJava pos , List < String > words ) { \nOpenKoreanTextProcessor . removeWordsFromDictionary ( KoreanPos . withName ( pos . toString ( ) ) , JavaConverters . asScalaBufferConverter ( words ) . asScala ( ) ) ; \nreturn ; \n} \n} \n"}
{"3596": "public class H264Utils { \npublic static void joinNALUnitsToBuffer ( List < ByteBuffer > nalUnits , ByteBuffer out ) { \nfor ( ByteBuffer nal : nalUnits ) { \nout . putInt ( 1 ) ; \nout . put ( nal . duplicate ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nsum += taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \nreturn ; \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nint rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( symbol == cm . getMps ( ) ) { \nrange -= rangeLps ; \noffset += rangeLps ; \nif ( range < 0x8000 ) { \nwhile ( range < 0x8000 ) renormalize ( ) ; \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \nelse { \nrange = rangeLps ; \nwhile ( range < 0x8000 ) renormalize ( ) ; \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \nreturn ; \n} \n} \n"}
{"3623": "public class SliceHeaderReader { \nprivate static void readDecoderPicMarking ( NALUnit nalUnit , SliceHeader sh , BitReader _in ) { \nif ( nalUnit . type == NALUnitType . IDR_SLICE ) { \nboolean noOutputOfPriorPicsFlag = readBool ( _in , \"SH: no_output_of_prior_pics_flag\" ) ; \nboolean longTermReferenceFlag = readBool ( _in , \"SH: long_term_reference_flag\" ) ; \nsh . refPicMarkingIDR = new RefPicMarkingIDR ( noOutputOfPriorPicsFlag , longTermReferenceFlag ) ; \n} \nelse { \nboolean adaptiveRefPicMarkingModeFlag = readBool ( _in , \"SH: adaptive_ref_pic_marking_mode_flag\" ) ; \nif ( adaptiveRefPicMarkingModeFlag ) { \nArrayList < Instruction > mmops = new ArrayList < Instruction > ( ) ; \nint memoryManagementControlOperation ; \ndo { \nmemoryManagementControlOperation = readUEtrace ( _in , \"SH: memory_management_control_operation\" ) ; \nInstruction instr = null ; \nswitch ( memoryManagementControlOperation ) { \ncase 1 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_SHORT , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , 0 ) ; \nbreak ; \ncase 2 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_LONG , readUEtrace ( _in , \"SH: long_term_pic_num\" ) , 0 ) ; \nbreak ; \ncase 3 : instr = new RefPicMarking . Instruction ( InstrType . CONVERT_INTO_LONG , readUEtrace ( _in , \"SH: difference_of_pic_nums_minus1\" ) + 1 , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) ) ; \nbreak ; \ncase 4 : instr = new RefPicMarking . Instruction ( InstrType . TRUNK_LONG , readUEtrace ( _in , \"SH: max_long_term_frame_idx_plus1\" ) - 1 , 0 ) ; \nbreak ; \ncase 5 : instr = new RefPicMarking . Instruction ( InstrType . CLEAR , 0 , 0 ) ; \nbreak ; \ncase 6 : instr = new RefPicMarking . Instruction ( InstrType . MARK_LONG , readUEtrace ( _in , \"SH: long_term_frame_idx\" ) , 0 ) ; \nbreak ; \n} \nif ( instr != null ) mmops . add ( instr ) ; \n} \nwhile ( memoryManagementControlOperation != 0 ) ; \nsh . refPicMarkingNonIDR = new RefPicMarking ( mmops . toArray ( new Instruction [ ] { \n} \n) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3625": "public class Decoder { \npublic void decodeFrame ( byte [ ] frame , SampleBuffer buffer ) throws AACException { \nif ( frame != null ) _in . setData ( frame ) ; \nLogger . debug ( \"bits left \" + _in . getBitsLeft ( ) ) ; \ntry { \ndecode ( buffer ) ; \n} \ncatch ( AACException e ) { \nif ( ! e . isEndOfStream ( ) ) throw e ; \nelse Logger . warn ( \"unexpected end of frame\" ) ; \n} \nreturn ; \n} \n} \n"}
{"3626": "public class SampleBuffer { \npublic void setBigEndian ( boolean bigEndian ) { \nif ( bigEndian != this . bigEndian ) { \nbyte tmp ; \nfor ( int i = 0 ; \ni < data . length ; \ni += 2 ) { \ntmp = data [ i ] ; \ndata [ i ] = data [ i + 1 ] ; \ndata [ i + 1 ] = tmp ; \n} \nthis . bigEndian = bigEndian ; \n} \nreturn ; \n} \n} \n"}
{"3627": "public class MBDeblocker { \npublic void deblockMBP ( EncodedMB cur , EncodedMB left , EncodedMB top ) { \nint [ ] [ ] vertStrength = new int [ 4 ] [ 4 ] ; \nint [ ] [ ] horizStrength = new int [ 4 ] [ 4 ] ; \ncalcStrengthForBlocks ( cur , left , vertStrength , LOOKUP_IDX_P_V , LOOKUP_IDX_Q_V ) ; \ncalcStrengthForBlocks ( cur , top , horizStrength , LOOKUP_IDX_P_H , LOOKUP_IDX_Q_H ) ; \ndeblockMBGeneric ( cur , left , top , vertStrength , horizStrength ) ; \nreturn ; \n} \n} \n"}
{"3628": "public class SequenceEncoder { \npublic void encodeNativeFrame ( Picture pic ) throws IOException { \nif ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( \"The input images is expected in RGB color.\" ) ; \nColorSpace sinkColor = sink . getInputColor ( ) ; \nLoanerPicture toEncode ; \nif ( sinkColor != null ) { \ntoEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; \ntransform . transform ( pic , toEncode . getPicture ( ) ) ; \n} \nelse { \ntoEncode = new LoanerPicture ( pic , 0 ) ; \n} \nPacket pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; \nsink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; \nif ( sinkColor != null ) pixelStore . putBack ( toEncode ) ; \ntimestamp += fps . getDen ( ) ; \nframeNo ++ ; \nreturn ; \n} \n} \n"}
{"3631": "public class FLVWriter { \npublic void addPacket ( FLVTag pkt ) throws IOException { \nif ( ! writePacket ( writeBuf , pkt ) ) { \nwriteBuf . flip ( ) ; \nstartOfLastPacket -= out . write ( writeBuf ) ; \nwriteBuf . clear ( ) ; \nif ( ! writePacket ( writeBuf , pkt ) ) throw new RuntimeException ( \"Unexpected\" ) ; \n} \nreturn ; \n} \n} \n"}
{"3637": "public class MPEGPredDbl { \n@ Override public void predictPlane ( byte [ ] ref , int refX , int refY , int refW , int refH , int refVertStep , int refVertOff , int [ ] tgt , int tgtY , int tgtW , int tgtH , int tgtVertStep ) { \nsuper . predictPlane ( ref , refX << 1 , refY << 1 , refW , refH , refVertStep , refVertOff , tgt , tgtY , tgtW << 2 , tgtH << 2 , tgtVertStep ) ; \nreturn ; \n} \n} \n"}
{"3638": "public class SparseIDCT { \npublic static final void start ( int [ ] block , int dc ) { \ndc <<= DC_SHIFT ; \nfor ( int i = 0 ; \ni < 64 ; \ni += 4 ) { \nblock [ i + 0 ] = dc ; \nblock [ i + 1 ] = dc ; \nblock [ i + 2 ] = dc ; \nblock [ i + 3 ] = dc ; \n} \nreturn ; \n} \n} \n"}
{"3639": "public class SparseIDCT { \npublic static final void coeff ( int [ ] block , int ind , int level ) { \nfor ( int i = 0 ; \ni < 64 ; \ni += 4 ) { \nblock [ i ] += COEFF [ ind ] [ i ] * level ; \nblock [ i + 1 ] += COEFF [ ind ] [ i + 1 ] * level ; \nblock [ i + 2 ] += COEFF [ ind ] [ i + 2 ] * level ; \nblock [ i + 3 ] += COEFF [ ind ] [ i + 3 ] * level ; \n} \nreturn ; \n} \n} \n"}
{"3640": "public class SparseIDCT { \npublic static final void finish ( int block [ ] ) { \nfor ( int i = 0 ; \ni < 64 ; \ni += 4 ) { \nblock [ i ] = div ( block [ i ] ) ; \nblock [ i + 1 ] = div ( block [ i + 1 ] ) ; \nblock [ i + 2 ] = div ( block [ i + 2 ] ) ; \nblock [ i + 3 ] = div ( block [ i + 3 ] ) ; \n} \nreturn ; \n} \n} \n"}
{"3641": "public class BitsBuffer { \npublic void concatBits ( BitsBuffer a ) { \nif ( a . len == 0 ) return ; \nint al = a . bufa ; \nint ah = a . bufb ; \nint bl , bh ; \nif ( len > 32 ) { \nbl = bufa ; \nbh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; \nah = al << ( len - 32 ) ; \nal = 0 ; \n} \nelse { \nbl = bufa & ( ( 1 << ( len ) ) - 1 ) ; \nbh = 0 ; \nah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; \nal = al << len ; \n} \nbufa = bl | al ; \nbufb = bh | ah ; \nlen += a . len ; \nreturn ; \n} \n} \n"}
{"3649": "public class AudioUtil { \npublic static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16BE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16LE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24LE ( buf , floatBuf ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3650": "public class AudioUtil { \npublic static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16BE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16LE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24LE ( buf , floatBuf ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \nfor ( int i = 0 ; \ni < ins . length ; \ni ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; \nfor ( int frames = 0 ; \nframes < max && outb . remaining ( ) >= bytesPerFrame ; \nframes ++ ) { \nfor ( int j = 0 ; \nj < ins . length ; \nj ++ ) { \nif ( ins [ j ] . remaining ( ) < bytesPerSample ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) outb . put ( ( byte ) 0 ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \noutb . put ( ins [ j ] . get ( ) ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * outs . length ; \nwhile ( inb . remaining ( ) >= bytesPerFrame ) { \nfor ( int j = 0 ; \nj < outs . length ; \nj ++ ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni ++ ) { \nouts [ j ] . put ( inb . get ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3665": "public class JNIMemoryManager { \nvoid gcInternal ( ) { \nJNIReference ref = null ; \nwhile ( ( ref = ( JNIReference ) mRefQueue . poll ( ) ) != null ) { \nref . delete ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3666": "public class JNIMemoryManager { \nfinal public void flush ( ) { \nblockingLock ( ) ; \ntry { \nint numSurvivors = sweepAndCollect ( ) ; \nfor ( int i = 0 ; \ni < numSurvivors ; \ni ++ ) { \nfinal JNIReference ref = mValidReferences [ i ] ; \nif ( ref != null ) ref . delete ( ) ; \n} \nsweepAndCollect ( ) ; \nmValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; \nmNextAvailableReferenceSlot = 0 ; \nmMaxValidReference = mMinimumReferencesToCache ; \n} \nfinally { \nblockingUnlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3667": "public class JNILibrary { \n@ SuppressWarnings ( \"deprecation\" ) public static void load ( String appname , JNILibrary library ) { \nsynchronized ( mLock ) { \ndeleteTemporaryFiles ( ) ; \ntry { \nlibrary . load ( appname ) ; \n} \ncatch ( UnsatisfiedLinkError e ) { \nJNILibraryLoader . loadLibrary ( library . getName ( ) , library . getVersion ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3669": "public class JNILibrary { \nprivate static void deleteTemporaryFiles ( ) { \nfinal File dir = getTmpDir ( ) ; \nfinal FilenameFilter filter = new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( HUMBLE_TEMP_EXTENSION ) ; \n} \n} \n; \nfinal File markers [ ] = dir . listFiles ( filter ) ; \nfor ( File marker : markers ) { \nfinal String markerName = marker . getName ( ) ; \nfinal String libName = markerName . substring ( 0 , markerName . length ( ) - HUMBLE_TEMP_EXTENSION . length ( ) ) ; \nfinal File lib = new File ( marker . getParentFile ( ) , libName ) ; \nif ( ! lib . exists ( ) || lib . delete ( ) ) marker . delete ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \nreturn ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) { \nstream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \n} \nelse { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nint numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \nfor ( int i = 0 ; \ni < numSettings ; \ni ++ ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = ( value & flagMask ) > 0 ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \nreturn ; \n} \n} \n"}
{"3688": "public class Coder { \npublic void setFlag ( Coder . Flag flag , boolean value ) { \nVideoJNI . Coder_setFlag ( swigCPtr , this , flag . swigValue ( ) , value ) ; \nreturn ; \n} \n} \n"}
{"3689": "public class Coder { \npublic void setFlag2 ( Coder . Flag2 flag , boolean value ) { \nVideoJNI . Coder_setFlag2 ( swigCPtr , this , flag . swigValue ( ) , value ) ; \nreturn ; \n} \n} \n"}
{"3698": "public class AMediaPictureConverter { \nprotected void validateImage ( BufferedImage image ) { \nif ( image == null ) throw new IllegalArgumentException ( \"The passed image is NULL.\" ) ; \nif ( image . getType ( ) != getImageType ( ) ) throw new IllegalArgumentException ( \"The passed image is of type #\" + image . getType ( ) + \" but is required to be of BufferedImage type #\" + getImageType ( ) + \".\" ) ; \nreturn ; \n} \n} \n"}
{"3699": "public class AMediaPictureConverter { \nprotected void validatePicture ( MediaPicture picture ) { \nif ( picture == null ) throw new IllegalArgumentException ( \"The picture is NULL.\" ) ; \nif ( ! picture . isComplete ( ) ) throw new IllegalArgumentException ( \"The picture is not complete.\" ) ; \nPixelFormat . Type type = picture . getFormat ( ) ; \nif ( ( type != getPictureType ( ) ) && ( willResample ( ) && type != mToImageResampler . getOutputFormat ( ) ) ) throw new IllegalArgumentException ( \"Picture is of type: \" + type + \", but must be \" + getPictureType ( ) + ( willResample ( ) ? \" or \" + mToImageResampler . getOutputFormat ( ) : \"\" ) + \".\" ) ; \nreturn ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \nreturn ; \n} \n} \n"}
{"3707": "public class JNILibraryLoader { \nsynchronized void loadLibrary0 ( String aLibraryName , Long aMajorVersion ) { \nif ( alreadyLoadedLibrary ( aLibraryName , aMajorVersion ) ) return ; \nList < String > libCandidates = getLibraryCandidates ( aLibraryName , aMajorVersion ) ; \nif ( libCandidates != null && libCandidates . size ( ) > 0 && ! loadCandidateLibrary ( aLibraryName , aMajorVersion , libCandidates ) ) { \ntry { \nSystem . loadLibrary ( aLibraryName ) ; \n} \ncatch ( UnsatisfiedLinkError e ) { \nlog . error ( \"Could not load library: {}; version: {}.\" , aLibraryName , aMajorVersion == null ? \"\" : aMajorVersion ) ; \nthrow e ; \n} \nsetLoadedLibrary ( aLibraryName , aMajorVersion ) ; \n} \nlog . trace ( \"Successfully Loaded library: {}; Version: {}\" , aLibraryName , aMajorVersion ) ; \nreturn ; \n} \n} \n"}
{"3708": "public class JNILibraryLoader { \nvoid setLoadedLibrary ( String aLibraryName , Long aMajorVersion ) { \nSet < Long > foundVersions = mLoadedLibraries . get ( aLibraryName ) ; \nif ( foundVersions == null ) { \nfoundVersions = new HashSet < Long > ( ) ; \nmLoadedLibraries . put ( aLibraryName , foundVersions ) ; \n} \nfoundVersions . add ( aMajorVersion ) ; \nreturn ; \n} \n} \n"}
{"3710": "public class JNILibraryLoader { \nprivate void initializeSearchPaths ( ) { \nString pathVar = null ; \nif ( mJavaPropPaths == null ) { \npathVar = System . getProperty ( \"java.library.path\" , \"\" ) ; \nlog . trace ( \"property java.library.path: {}\" , pathVar ) ; \nmJavaPropPaths = getEntitiesFromPath ( pathVar ) ; \n} \nif ( mJavaEnvPaths == null ) { \nString envVar = getSystemRuntimeLibraryPathVar ( ) ; \npathVar = System . getenv ( envVar ) ; \nlog . trace ( \"OS environment runtime shared library path ({}): {}\" , envVar , pathVar ) ; \nmJavaEnvPaths = getEntitiesFromPath ( pathVar ) ; \n} \nreturn ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nelse { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( int i = 0 ; \ni < duration / framerate . getDouble ( ) ; \ni ++ ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \nreturn ; \n} \n} \n"}
{"3713": "public class JNIReference { \npublic void delete ( ) { \nfinal long swigPtr = mSwigCPtr . getAndSet ( 0 ) ; \nif ( swigPtr != 0 ) { \nif ( mJavaRefCount . decrementAndGet ( ) == 0 ) { \nFerryJNI . RefCounted_release ( swigPtr , null ) ; \n} \nmMemAllocator = null ; \n} \nreturn ; \n} \n} \n"}
{"3727": "public class FSTBytezEncoder { \npublic void writePrimitiveArray ( Object array , int off , int len ) throws IOException { \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \nif ( componentType == byte . class ) { \nwriteRawBytes ( ( byte [ ] ) array , off , len ) ; \n} \nelse if ( componentType == char . class ) { \nwriteFCharArr ( ( char [ ] ) array , off , len ) ; \n} \nelse if ( componentType == short . class ) { \nwriteFShortArr ( ( short [ ] ) array , off , len ) ; \n} \nelse if ( componentType == int . class ) { \nwriteFIntArr ( ( int [ ] ) array , off , len ) ; \n} \nelse if ( componentType == double . class ) { \nwriteFDoubleArr ( ( double [ ] ) array , off , len ) ; \n} \nelse if ( componentType == float . class ) { \nwriteFFloatArr ( ( float [ ] ) array , off , len ) ; \n} \nelse if ( componentType == long . class ) { \nwriteFLongArr ( ( long [ ] ) array , off , len ) ; \n} \nelse if ( componentType == boolean . class ) { \nwriteFBooleanArr ( ( boolean [ ] ) array , off , len ) ; \n} \nelse { \nthrow new RuntimeException ( \"expected primitive array\" ) ; \n} \nreturn ; \n} \n} \n"}
{"3728": "public class FSTBytezEncoder { \n@ Override public void flush ( ) throws IOException { \nif ( outStream != null ) outStream . write ( getBuffer ( ) , 0 , ( int ) pos ) ; \npos = 0 ; \nreturn ; \n} \n} \n"}
{"3732": "public class MMFBytez { \npublic void _setMMFData ( File file , FileChannel fileChannel , Cleaner cleaner ) { \nthis . file = file ; \nthis . fileChannel = fileChannel ; \nthis . cleaner = cleaner ; \nreturn ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( required <= memory . length ( ) ) return ; \nmutationCount ++ ; \nSystem . out . println ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \ni < max + 2 ; \ni ++ ) { \nf . write ( toWrite ) ; \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . println ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3735": "public class FSTBinaryOffheapMap { \npublic void removeBinary ( ByteSource key ) { \ncheckThread ( ) ; \nif ( key . length ( ) != keyLen ) throw new RuntimeException ( \"key must have length \" + keyLen ) ; \nmutationCount ++ ; \nlong rem = index . get ( key ) ; \nif ( rem != 0 ) { \nindex . remove ( key ) ; \ndecElems ( ) ; \nremoveEntry ( rem ) ; \n} \nreturn ; \n} \n} \n"}
{"3736": "public class FSTStreamEncoder { \nvoid writeStringAsc ( String name ) throws IOException { \nint len = name . length ( ) ; \nif ( len >= 127 ) { \nthrow new RuntimeException ( \"Ascii String too long\" ) ; \n} \nwriteFByte ( ( byte ) len ) ; \nbuffout . ensureFree ( len ) ; \nif ( ascStringCache == null || ascStringCache . length < len ) ascStringCache = new byte [ len ] ; \nname . getBytes ( 0 , len , ascStringCache , 0 ) ; \nwriteRawBytes ( ascStringCache , 0 , len ) ; \nreturn ; \n} \n} \n"}
{"3737": "public class FSTStreamEncoder { \n@ Override public void setOutstream ( OutputStream outstream ) { \nif ( buffout == null ) { \nbuffout = ( FSTOutputStream ) conf . getCachedObject ( FSTOutputStream . class ) ; \nif ( buffout == null ) buffout = new FSTOutputStream ( 1000 , outstream ) ; \nelse buffout . reset ( ) ; \n} \nif ( outstream == null ) buffout . setOutstream ( buffout ) ; \nelse buffout . setOutstream ( outstream ) ; \nreturn ; \n} \n} \n"}
{"3741": "public class FSTConfiguration { \npublic void clearCaches ( ) { \ntry { \nFSTInputStream . cachedBuffer . set ( null ) ; \nwhile ( ! cacheLock . compareAndSet ( false , true ) ) { \n} \ncachedObjects . clear ( ) ; \n} \nfinally { \ncacheLock . set ( false ) ; \n} \nreturn ; \n} \n} \n"}
{"3748": "public class MBOut { \npublic void writeInt ( byte type , long data ) { \nif ( ! MinBin . isPrimitive ( type ) || MinBin . isArray ( type ) ) throw new RuntimeException ( \"illegal type code\" ) ; \nwriteOut ( type ) ; \nwriteRawInt ( type , data ) ; \nreturn ; \n} \n} \n"}
{"3749": "public class MBOut { \nprotected void writeRawInt ( byte type , long data ) { \nint numBytes = MinBin . extractNumBytes ( type ) ; \nfor ( int i = 0 ; \ni < numBytes ; \ni ++ ) { \nwriteOut ( ( byte ) ( data & 0xff ) ) ; \ndata = data >>> 8 ; \n} \nreturn ; \n} \n} \n"}
{"3750": "public class MBOut { \npublic void writeIntPacked ( long data ) { \nif ( data <= Byte . MAX_VALUE && data >= Byte . MIN_VALUE ) writeInt ( MinBin . INT_8 , data ) ; \nelse if ( data <= Short . MAX_VALUE && data >= Short . MIN_VALUE ) writeInt ( MinBin . INT_16 , data ) ; \nelse if ( data <= Integer . MAX_VALUE && data >= Integer . MIN_VALUE ) writeInt ( MinBin . INT_32 , data ) ; \nelse if ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_64 , data ) ; \nreturn ; \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse if ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse if ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nif ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3752": "public class MBOut { \npublic void writeRaw ( byte [ ] bufferedName , int i , int length ) { \nif ( pos + length >= bytez . length - 1 ) { \nresize ( ) ; \n} \nSystem . arraycopy ( bufferedName , i , bytez , pos , length ) ; \npos += length ; \nreturn ; \n} \n} \n"}
{"3754": "public class FSTObjectOutput { \nprotected void objectWillBeWritten ( Object obj , int streamPosition ) { \nif ( listener != null ) { \nlistener . objectWillBeWritten ( obj , streamPosition ) ; \n} \nreturn ; \n} \n} \n"}
{"3755": "public class FSTObjectOutput { \nprotected void objectHasBeenWritten ( Object obj , int oldStreamPosition , int streamPosition ) { \nif ( listener != null ) { \nlistener . objectHasBeenWritten ( obj , oldStreamPosition , streamPosition ) ; \n} \nreturn ; \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) { \nif ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse writeObjectWithContext ( referencee , toWrite , null ) ; \n} \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( subArr == null ) { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"3758": "public class StructString { \npublic void setString ( String s ) { \nif ( s == null ) { \nsetLen ( 0 ) ; \nreturn ; \n} \nif ( s . length ( ) > charsLen ( ) ) { \nthrow new RuntimeException ( \"String length exceeds buffer size. String len \" + s . length ( ) + \" charsLen:\" + charsLen ( ) ) ; \n} \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchars ( i , s . charAt ( i ) ) ; \n} \nlen = s . length ( ) ; \nreturn ; \n} \n} \n"}
{"3759": "public class FSTMinBinEncoder { \n@ Override public void writePrimitiveArray ( Object array , int start , int length ) throws IOException { \nout . writeArray ( array , start , length ) ; \nreturn ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nint sumLen = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni ++ ) { \nsumLen += changeLength [ i ] ; \n} \nsnapshot = new byte [ sumLen ] ; \nint targetIdx = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni ++ ) { \nint changeOffset = changeOffsets [ i ] ; \nint len = changeLength [ i ] ; \nfor ( int ii = 0 ; \nii < len ; \nii ++ ) { \nsnapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; \n} \n} \nrebase ( originBase ) ; \nreturn ; \n} \n} \n"}
{"3767": "public class BinaryQueue { \npublic void back ( int len ) { \nif ( pollIndex >= len ) pollIndex -= len ; \nelse pollIndex = pollIndex + capacity ( ) - len ; \nreturn ; \n} \n} \n"}
{"3768": "public class HproseTcpServer { \npublic void setThreadPoolEnabled ( boolean value ) { \nif ( value && ( threadPool == null ) ) { \nthreadPool = Executors . newCachedThreadPool ( ) ; \n} \nthreadPoolEnabled = value ; \nreturn ; \n} \n} \n"}
{"3769": "public class EmbeddedCassandraServerHelper { \npublic static void startEmbeddedCassandra ( File file , String tmpDir , long timeout ) throws IOException , ConfigurationException { \nif ( cassandraDaemon != null ) { \nreturn ; \n} \ncheckConfigNameForRestart ( file . getAbsolutePath ( ) ) ; \nlog . debug ( \"Starting cassandra...\" ) ; \nlog . debug ( \"Initialization needed\" ) ; \nSystem . setProperty ( \"cassandra.config\" , \"file:\" + file . getAbsolutePath ( ) ) ; \nSystem . setProperty ( \"cassandra-foreground\" , \"true\" ) ; \nSystem . setProperty ( \"cassandra.native.epoll.enabled\" , \"false\" ) ; \nSystem . setProperty ( \"cassandra.unsafesystem\" , \"true\" ) ; \nif ( System . getProperty ( \"log4j.configuration\" ) == null ) { \ncopy ( DEFAULT_LOG4J_CONFIG_FILE , tmpDir ) ; \nSystem . setProperty ( \"log4j.configuration\" , \"file:\" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE ) ; \n} \nDatabaseDescriptor . daemonInitialization ( ) ; \ncleanupAndLeaveDirs ( ) ; \nfinal CountDownLatch startupLatch = new CountDownLatch ( 1 ) ; \nExecutorService executor = Executors . newSingleThreadExecutor ( ) ; \nexecutor . execute ( ( ) -> { \ncassandraDaemon = new CassandraDaemon ( ) ; \ncassandraDaemon . activate ( ) ; \nstartupLatch . countDown ( ) ; \n} \n) ; \ntry { \nif ( ! startupLatch . await ( timeout , MILLISECONDS ) ) { \nlog . error ( \"Cassandra daemon did not start after \" + timeout + \" ms. Consider increasing the timeout\" ) ; \nthrow new AssertionError ( \"Cassandra daemon did not start within timeout\" ) ; \n} \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ( ) -> { \nif ( session != null ) session . close ( ) ; \nif ( cluster != null ) cluster . close ( ) ; \n} \n) ) ; \n} \ncatch ( InterruptedException e ) { \nlog . error ( \"Interrupted waiting for Cassandra daemon to start:\" , e ) ; \nthrow new AssertionError ( e ) ; \n} \nfinally { \nexecutor . shutdown ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3770": "public class EmbeddedCassandraServerHelper { \npublic static void cleanDataEmbeddedCassandra ( String keyspace , String ... excludedTables ) { \nif ( session != null ) { \ncleanDataWithNativeDriver ( keyspace , excludedTables ) ; \n} \nreturn ; \n} \n} \n"}
{"3772": "public class ReflectionUtils { \npublic static void printThreadInfo ( PrintWriter stream , String title ) { \nfinal int STACK_DEPTH = 20 ; \nboolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; \nlong [ ] threadIds = threadBean . getAllThreadIds ( ) ; \nstream . println ( \"Process Thread Dump: \" + title ) ; \nstream . println ( threadIds . length + \" active threads\" ) ; \nfor ( long tid : threadIds ) { \nThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; \nif ( info == null ) { \nstream . println ( \"  Inactive\" ) ; \ncontinue ; \n} \nstream . println ( \"Thread \" + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + \":\" ) ; \nThread . State state = info . getThreadState ( ) ; \nstream . println ( \"  State: \" + state ) ; \nstream . println ( \"  Blocked count: \" + info . getBlockedCount ( ) ) ; \nstream . println ( \"  Waited count: \" + info . getWaitedCount ( ) ) ; \nif ( contention ) { \nstream . println ( \"  Blocked time: \" + info . getBlockedTime ( ) ) ; \nstream . println ( \"  Waited time: \" + info . getWaitedTime ( ) ) ; \n} \nif ( state == Thread . State . WAITING ) { \nstream . println ( \"  Waiting on \" + info . getLockName ( ) ) ; \n} \nelse if ( state == Thread . State . BLOCKED ) { \nstream . println ( \"  Blocked on \" + info . getLockName ( ) ) ; \nstream . println ( \"  Blocked by \" + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; \n} \nstream . println ( \"  Stack:\" ) ; \nfor ( StackTraceElement frame : info . getStackTrace ( ) ) { \nstream . println ( \"    \" + frame . toString ( ) ) ; \n} \n} \nstream . flush ( ) ; \nreturn ; \n} \n} \n"}
{"3778": "public class BooleanIndexing { \npublic static boolean and ( final INDArray n , final Condition cond ) { \nif ( cond instanceof BaseCondition ) { \nlong val = ( long ) Nd4j . getExecutioner ( ) . exec ( new MatchCondition ( n , cond ) , Integer . MAX_VALUE ) . getDouble ( 0 ) ; \nif ( val == n . lengthLong ( ) ) return true ; \nelse return false ; \n} \nelse { \nboolean ret = true ; \nfinal AtomicBoolean a = new AtomicBoolean ( ret ) ; \nShape . iterate ( n , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( a . get ( ) ) a . compareAndSet ( true , a . get ( ) && cond . apply ( n . getDouble ( coord [ 0 ] ) ) ) ; \nreturn ; \n} \n} \n) ; \nreturn a . get ( ) ; \n} \n} \n} \n"}
{"3781": "public class BooleanIndexing { \npublic static void applyWhere ( final INDArray to , final Condition condition , final Number number ) { \nif ( condition instanceof BaseCondition ) { \nNd4j . getExecutioner ( ) . exec ( new CompareAndSet ( to , number . doubleValue ( ) , condition ) ) ; \n} \nelse { \nfinal double value = number . doubleValue ( ) ; \nfinal Function < Number , Number > dynamic = new Function < Number , Number > ( ) { \n@ Override public Number apply ( Number number ) { \nreturn value ; \n} \n} \n; \nShape . iterate ( to , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( condition . apply ( to . getDouble ( coord [ 0 ] ) ) ) to . putScalar ( coord [ 0 ] , dynamic . apply ( to . getDouble ( coord [ 0 ] ) ) . doubleValue ( ) ) ; \nreturn ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"3786": "public class AtomicThrowable { \npublic void set ( Throwable t ) { \ntry { \nlock . writeLock ( ) . lock ( ) ; \nthis . t = t ; \n} \nfinally { \nlock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3787": "public class AtomicThrowable { \npublic void setIfFirst ( Throwable t ) { \ntry { \nlock . writeLock ( ) . lock ( ) ; \nif ( this . t == null ) this . t = t ; \n} \nfinally { \nlock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3791": "public class VoidParameterServer { \npublic void shutdown ( ) { \nif ( initLocker . get ( ) && shutdownLocker . compareAndSet ( false , true ) ) { \nlog . info ( \"Shutting down transport...\" ) ; \ntransport . shutdown ( ) ; \nexecutor . shutdown ( ) ; \n} \nreturn ; \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) { \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \n} \nelse { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( int i = 1 ; \ni < arrs . length ; \ni ++ ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \nreturn ; \n} \n} \n"}
{"3798": "public class BaseNDArrayFactory { \n@ Override public void setDType ( DataBuffer . Type dtype ) { \nassert dtype == DataBuffer . Type . DOUBLE || dtype == DataBuffer . Type . FLOAT || dtype == DataBuffer . Type . INT : \"Invalid opType passed, must be float or double\" ; \nreturn ; \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \nfor ( int i = 0 ; \ni < getFeatures ( ) . length ( ) ; \ni ++ ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( curr > cutoff ) getFeatures ( ) . putScalar ( i , 1 ) ; \nelse getFeatures ( ) . putScalar ( i , 0 ) ; \n} \nreturn ; \n} \n} \n"}
{"3841": "public class NioUtil { \npublic static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { \nByteBuffer fromView = from ; \nByteBuffer toView = to ; \nfromView . order ( ByteOrder . nativeOrder ( ) ) ; \ntoView . order ( ByteOrder . nativeOrder ( ) ) ; \nswitch ( bufferType ) { \ncase INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; \nIntBuffer toInt = toView . asIntBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nint put = fromInt . get ( fromOffset + i * fromStride ) ; \ntoInt . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; \nFloatBuffer toFloat = toView . asFloatBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nfloat put = fromFloat . get ( fromOffset + i * fromStride ) ; \ntoFloat . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; \nDoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \ntoDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; \n} \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Only floats and double supported\" ) ; \n} \nreturn ; \n} \n} \n"}
{"3856": "public class CpuLapack { \n@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { \nINDArray tau = Nd4j . create ( N ) ; \nint status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sgeqrf\" , status ) ; \n} \nif ( R != null ) { \nR . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; \nINDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; \nfor ( int i = 1 ; \ni < Math . min ( A . rows ( ) , A . columns ( ) ) ; \ni ++ ) { \nix [ 0 ] = NDArrayIndex . point ( i ) ; \nix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; \nR . put ( ix , 0 ) ; \n} \n} \nstatus = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sorgqr\" , status ) ; \n} \nreturn ; \n} \n} \n"}
{"3859": "public class BaseNDArrayProxy { \nprotected void read ( ObjectInputStream s ) throws IOException , ClassNotFoundException { \ndata = Nd4j . createBuffer ( length , false ) ; \ndata . read ( s ) ; \nreturn ; \n} \n} \n"}
{"3860": "public class AsynchronousFlowController { \nprotected void sweepTail ( ) { \nInteger deviceId = allocator . getDeviceId ( ) ; \nint cnt = 0 ; \nlong lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; \nfor ( int l = 0 ; \nl < configuration . getCommandLanesNumber ( ) ; \nl ++ ) { \nQueue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; \nif ( queue . size ( ) >= MAX_EXECUTION_QUEUE || laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null && ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt ++ ; \n} \n} \n} \ndeviceClocks . get ( deviceId ) . incrementAndGet ( ) ; \nreturn ; \n} \n} \n"}
{"3864": "public class RRWLock { \n@ Override public void attachObject ( Object object ) { \nif ( ! objectLocks . containsKey ( object ) ) objectLocks . put ( object , new ReentrantReadWriteLock ( ) ) ; \nreturn ; \n} \n} \n"}
{"3867": "public class CudaGridExecutioner { \n@ Override public void flushQueueBlocking ( ) { \nflushQueue ( ) ; \n( ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ) . syncOldStream ( ) ; \n( ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ) . syncSpecialStream ( ) ; \nreturn ; \n} \n} \n"}
{"3870": "public class CudaAffinityManager { \n@ Override public void attachThreadToDevice ( long threadId , Integer deviceId ) { \nList < Integer > devices = new ArrayList < > ( CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) ) ; \nlogger . debug ( \"Manually mapping thread [{}] to device [{}], out of [{}] devices...\" , threadId , deviceId , devices . size ( ) ) ; \naffinityMap . put ( threadId , deviceId ) ; \nreturn ; \n} \n} \n"}
{"3874": "public class Nd4jKafkaProducer { \npublic void publish ( INDArray arr ) { \nif ( producerTemplate == null ) producerTemplate = camelContext . createProducerTemplate ( ) ; \nproducerTemplate . sendBody ( \"direct:start\" , arr ) ; \nreturn ; \n} \n} \n"}
{"3875": "public class InstrumentationApplication { \npublic void start ( ) { \ntry { \nInputStream is = new ClassPathResource ( resourcePath , InstrumentationApplication . class . getClassLoader ( ) ) . getInputStream ( ) ; \nFile tmpConfig = new File ( resourcePath ) ; \nif ( ! tmpConfig . getParentFile ( ) . exists ( ) ) tmpConfig . getParentFile ( ) . mkdirs ( ) ; \nBufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( tmpConfig ) ) ; \nIOUtils . copy ( is , bos ) ; \nbos . flush ( ) ; \nrun ( new String [ ] { \n\"server\" , tmpConfig . getAbsolutePath ( ) } \n) ; \ntmpConfig . deleteOnExit ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"3877": "public class DefaultOpExecutioner { \nprotected void interceptIntDataType ( Op op ) { \nif ( op . x ( ) != null && op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) throw new ND4JIllegalStateException ( \"Op.X contains INT data. Operations on INT dataType are not supported yet\" ) ; \nif ( op . z ( ) != null && op . z ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) throw new ND4JIllegalStateException ( \"Op.Z contains INT data. Operations on INT dataType are not supported yet\" ) ; \nif ( op . y ( ) != null && op . y ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) throw new ND4JIllegalStateException ( \"Op.Y contains INT data. Operations on INT dataType are not supported yet.\" ) ; \nreturn ; \n} \n} \n"}
{"3879": "public class DistributedAssignMessage { \n@ Override public void processMessage ( ) { \nif ( payload != null ) { \nif ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) storage . getArray ( key ) . assign ( payload ) ; \nelse storage . setArray ( key , payload ) ; \n} \nelse { \nif ( index >= 0 ) { \nif ( storage . getArray ( key ) == null ) throw new RuntimeException ( \"Init wasn't called before for key [\" + key + \"]\" ) ; \nstorage . getArray ( key ) . getRow ( index ) . assign ( value ) ; \n} \nelse storage . getArray ( key ) . assign ( value ) ; \n} \nreturn ; \n} \n} \n"}
{"3882": "public class OpProfiler { \npublic void reset ( ) { \ninvocationsCount . set ( 0 ) ; \nclassAggergator . reset ( ) ; \nlongAggergator . reset ( ) ; \nclassCounter . reset ( ) ; \nopCounter . reset ( ) ; \nclassPairsCounter . reset ( ) ; \nopPairsCounter . reset ( ) ; \nmatchingCounter . reset ( ) ; \nmatchingCounterDetailed . reset ( ) ; \nmatchingCounterInverted . reset ( ) ; \nmethodsAggregator . reset ( ) ; \nscalarAggregator . reset ( ) ; \nnonEwsAggregator . reset ( ) ; \nstridedAggregator . reset ( ) ; \ntadNonEwsAggregator . reset ( ) ; \ntadStridedAggregator . reset ( ) ; \nmixedOrderAggregator . reset ( ) ; \nblasAggregator . reset ( ) ; \nblasOrderCounter . reset ( ) ; \norderCounter . reset ( ) ; \nlisteners . clear ( ) ; \nreturn ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( int i = 0 ; \ni < numDevices ; \ni ++ ) { \nif ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { \nset ( i , array ) ; \n} \nelse { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3894": "public class DistributedVectorMessage { \n@ Override public void processMessage ( ) { \nVectorAggregation aggregation = new VectorAggregation ( rowIndex , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , storage . getArray ( key ) . getRow ( rowIndex ) . dup ( ) ) ; \naggregation . setOriginatorId ( this . getOriginatorId ( ) ) ; \ntransport . sendMessage ( aggregation ) ; \nreturn ; \n} \n} \n"}
{"3915": "public class SameDiff { \npublic void putFunctionForId ( String id , DifferentialFunction function ) { \nif ( functionInstancesById . containsKey ( id ) ) { \nthrow new ND4JIllegalStateException ( \"Function by id already exists!\" ) ; \n} \nelse if ( function instanceof SDVariable ) { \nthrow new ND4JIllegalStateException ( \"Function must not be a variable!\" ) ; \n} \nfunctionInstancesById . put ( id , function ) ; \nreturn ; \n} \n} \n"}
{"3917": "public class SameDiff { \npublic void updateArrayForVarName ( String varName , INDArray arr ) { \nif ( ! variableNameToArr . containsKey ( varName ) ) { \nthrow new ND4JIllegalStateException ( \"Array for \" + varName + \" does not exist. Please use putArrayForVertexId instead.\" ) ; \n} \nvariableNameToArr . put ( varName , arr ) ; \nreverseArrayLookup . put ( arr , getVariable ( varName ) ) ; \nreturn ; \n} \n} \n"}
{"3918": "public class SameDiff { \npublic void putShapeForVarName ( String varName , long [ ] shape ) { \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Shape must not be null!\" ) ; \n} \nif ( variableNameToShape . containsKey ( varName ) ) { \nthrow new ND4JIllegalStateException ( \"Shape for \" + varName + \" already exists!\" ) ; \n} \nfor ( int i = 0 ; \ni < shape . length ; \ni ++ ) { \nif ( shape [ i ] < 1 ) { \naddAsPlaceHolder ( varName ) ; \nplaceHolderOriginalShapes . put ( varName , shape ) ; \nreturn ; \n} \n} \nvariableNameToShape . put ( varName , shape ) ; \nreturn ; \n} \n} \n"}
{"3919": "public class SameDiff { \npublic void associateArrayWithVariable ( INDArray arr , SDVariable variable ) { \nif ( variable == null ) { \nthrow new ND4JIllegalArgumentException ( \"Variable must not be null!\" ) ; \n} \nif ( arr == null ) { \nthrow new ND4JIllegalArgumentException ( \"Array must not be null\" ) ; \n} \nreverseArrayLookup . put ( arr , variable ) ; \nvariableNameToArr . put ( variable . getVarName ( ) , arr ) ; \nif ( ! shapeAlreadyExistsForVarName ( variable . getVarName ( ) ) ) putShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \nelse { \nupdateShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3921": "public class SameDiff { \npublic void addPropertyForFunction ( DifferentialFunction functionFor , String propertyName , INDArray property ) { \naddPropertyForFunction ( functionFor , propertyName , ( Object ) property ) ; \nreturn ; \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \n} \nif ( varNames == null ) throw new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \nfor ( int i = 0 ; \ni < varNames . length ; \ni ++ ) { \nif ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \n} \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \nreturn ; \n} \n} \n"}
{"3923": "public class SameDiff { \npublic void addArgsFor ( String [ ] variables , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nfor ( val varName : variables ) { \nif ( isPlaceHolder ( varName ) ) { \nplaceHolderFunctions . add ( function . getOwnName ( ) ) ; \n} \n} \nincomingArgs . put ( variables , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , variables ) ; \nfor ( val variableName : variables ) { \nList < DifferentialFunction > funcs = functionsArgsFor . get ( variableName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionsArgsFor . put ( variableName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \nreturn ; \n} \n} \n"}
{"3929": "public class SameDiff { \npublic void removeArgFromFunction ( String varName , DifferentialFunction function ) { \nval args = function . args ( ) ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . getVarName ( ) . equals ( varName ) ) { \nval reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nincomingArgs . remove ( reverseArgs ) ; \nincomingArgsReverse . remove ( function . getOwnName ( ) ) ; \nval newArgs = new ArrayList < String > ( args . length - 1 ) ; \nfor ( int arg = 0 ; \narg < args . length ; \narg ++ ) { \nif ( ! reverseArgs [ arg ] . equals ( varName ) ) { \nnewArgs . add ( reverseArgs [ arg ] ) ; \n} \n} \nval newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; \nincomingArgs . put ( newArgsArr , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"3930": "public class SameDiff { \npublic void setGradientForVariableName ( String variableName , SDVariable variable ) { \nif ( variable == null ) { \nthrow new ND4JIllegalStateException ( \"Unable to set null gradient for variable name \" + variableName ) ; \n} \ngradients . put ( variableName , variable ) ; \nreturn ; \n} \n} \n"}
{"3938": "public class SameDiff { \npublic void addAsPlaceHolder ( String varName ) { \nplaceHolderVarNames . add ( varName ) ; \nif ( getVariable ( varName ) != null && getVariable ( varName ) . getShape ( ) != null ) { \nplaceHolderOriginalShapes . put ( varName , getVariable ( varName ) . getShape ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3944": "public class BasicWorkspaceManager { \n@ Override public void destroyAllWorkspacesForCurrentThread ( ) { \nensureThreadExistense ( ) ; \nList < MemoryWorkspace > workspaces = new ArrayList < > ( ) ; \nworkspaces . addAll ( backingMap . get ( ) . values ( ) ) ; \nfor ( MemoryWorkspace workspace : workspaces ) { \ndestroyWorkspace ( workspace ) ; \n} \nSystem . gc ( ) ; \nreturn ; \n} \n} \n"}
{"3945": "public class BasicWorkspaceManager { \npublic synchronized void printAllocationStatisticsForCurrentThread ( ) { \nensureThreadExistense ( ) ; \nMap < String , MemoryWorkspace > map = backingMap . get ( ) ; \nlog . info ( \"Workspace statistics: ---------------------------------\" ) ; \nlog . info ( \"Number of workspaces in current thread: {}\" , map . size ( ) ) ; \nlog . info ( \"Workspace name: Allocated / external (spilled) / external (pinned)\" ) ; \nfor ( String key : map . keySet ( ) ) { \nlong current = ( ( Nd4jWorkspace ) map . get ( key ) ) . getCurrentSize ( ) ; \nlong spilled = ( ( Nd4jWorkspace ) map . get ( key ) ) . getSpilledSize ( ) ; \nlong pinned = ( ( Nd4jWorkspace ) map . get ( key ) ) . getPinnedSize ( ) ; \nlog . info ( String . format ( \"%-26s %8s / %8s / %8s (%11d / %11d / %11d)\" , ( key + \":\" ) , StringUtils . TraditionalBinaryPrefix . long2String ( current , \"\" , 2 ) , StringUtils . TraditionalBinaryPrefix . long2String ( spilled , \"\" , 2 ) , StringUtils . TraditionalBinaryPrefix . long2String ( pinned , \"\" , 2 ) , current , spilled , pinned ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3946": "public class BaseLevel2 { \n@ Override public void trmv ( char order , char Uplo , char TransA , char Diag , INDArray A , INDArray X ) { \nif ( Nd4j . getExecutioner ( ) . getProfilingMode ( ) == OpExecutioner . ProfilingMode . ALL ) OpProfiler . getInstance ( ) . processBlasCall ( false , A , X ) ; \nif ( A . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nDefaultOpExecutioner . validateDataType ( DataBuffer . Type . DOUBLE , A , X ) ; \ndtrmv ( order , Uplo , TransA , Diag , ( int ) X . length ( ) , A , ( int ) A . size ( 0 ) , X , X . majorStride ( ) ) ; \n} \nelse { \nDefaultOpExecutioner . validateDataType ( DataBuffer . Type . FLOAT , A , X ) ; \nstrmv ( order , Uplo , TransA , Diag , ( int ) X . length ( ) , A , ( int ) A . size ( 0 ) , X , X . majorStride ( ) ) ; \n} \nOpExecutionerUtil . checkForAny ( X ) ; \nreturn ; \n} \n} \n"}
{"3951": "public class NativeOpExecutioner { \nprivate void invoke ( ScalarOp op , int [ ] dimension ) { \ndimension = Shape . normalizeAxis ( op . x ( ) . rank ( ) , dimension ) ; \nPair < DataBuffer , DataBuffer > tadBuffers = tadManager . getTADOnlyShapeInfo ( op . x ( ) , dimension ) ; \nPointer hostTadShapeInfo = tadBuffers . getFirst ( ) . addressPointer ( ) ; \nPointer hostTadOffsets = tadBuffers . getSecond ( ) . addressPointer ( ) ; \nPointer devTadShapeInfoZ = null ; \nPointer devTadOffsetsZ = null ; \nPair < DataBuffer , DataBuffer > tadBuffersZ = tadManager . getTADOnlyShapeInfo ( op . z ( ) , dimension ) ; \ndevTadShapeInfoZ = tadBuffersZ . getFirst ( ) . addressPointer ( ) ; \ndevTadOffsetsZ = tadBuffersZ . getSecond ( ) . addressPointer ( ) ; \nif ( extraz . get ( ) == null ) extraz . set ( new PointerPointer ( 32 ) ) ; \nPointerPointer dummy = extraz . get ( ) . put ( hostTadShapeInfo , hostTadOffsets , devTadShapeInfoZ , devTadOffsetsZ ) ; \nif ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) { \nloop . execScalarFloat ( dummy , op . opNum ( ) , ( FloatPointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( FloatPointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \nelse if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nloop . execScalarDouble ( dummy , op . opNum ( ) , ( DoublePointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( DoublePointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \nreturn ; \n} \n} \n"}
{"3952": "public class WorkspaceUtils { \npublic static void assertNoWorkspacesOpen ( String msg ) throws ND4JWorkspaceException { \nif ( Nd4j . getWorkspaceManager ( ) . anyWorkspaceActiveForCurrentThread ( ) ) { \nList < MemoryWorkspace > l = Nd4j . getWorkspaceManager ( ) . getAllWorkspacesForCurrentThread ( ) ; \nList < String > workspaces = new ArrayList < > ( l . size ( ) ) ; \nfor ( MemoryWorkspace ws : l ) { \nif ( ws . isScopeActive ( ) ) { \nworkspaces . add ( ws . getId ( ) ) ; \n} \n} \nthrow new ND4JWorkspaceException ( msg + \" - Open/active workspaces: \" + workspaces ) ; \n} \nreturn ; \n} \n} \n"}
{"3954": "public class AtomicState { \npublic void requestTick ( long time , TimeUnit timeUnit ) { \nlong timeframeMs = TimeUnit . MILLISECONDS . convert ( time , timeUnit ) ; \nlong currentTime = System . currentTimeMillis ( ) ; \nboolean isWaiting = false ; \ntry { \nwhile ( isToeScheduled . get ( ) || isToeWaiting . get ( ) || getCurrentState ( ) == AccessState . TOE ) { \nif ( ! isWaiting ) { \nisWaiting = true ; \nwaitingTicks . incrementAndGet ( ) ; \n} \nThread . sleep ( 50 ) ; \n} \ncurrentState . set ( AccessState . TICK . ordinal ( ) ) ; \nwaitingTicks . decrementAndGet ( ) ; \ntickRequests . incrementAndGet ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"3956": "public class AtomicState { \npublic void releaseToe ( ) { \nif ( getCurrentState ( ) == AccessState . TOE ) { \nif ( 1 > 0 ) { \nif ( toeRequests . decrementAndGet ( ) == 0 ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \ncurrentState . set ( AccessState . TACK . ordinal ( ) ) ; \n} \n} \nelse throw new IllegalStateException ( \"releaseToe() is called from different thread.\" ) ; \n} \nelse throw new IllegalStateException ( \"Object is NOT in Toe state!\" ) ; \nreturn ; \n} \n} \n"}
{"3959": "public class VectorAggregation { \n@ Override public void processMessage ( ) { \nif ( clipboard . isTracking ( this . originatorId , this . getTaskId ( ) ) ) { \nclipboard . pin ( this ) ; \nif ( clipboard . isReady ( this . originatorId , taskId ) ) { \nVoidAggregation aggregation = clipboard . unpin ( this . originatorId , taskId ) ; \nif ( aggregation == null ) return ; \nVectorCompleteMessage msg = new VectorCompleteMessage ( taskId , aggregation . getAccumulatedResult ( ) ) ; \nmsg . setOriginatorId ( aggregation . getOriginatorId ( ) ) ; \ntransport . sendMessage ( msg ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"3960": "public class BaseDataFetcher { \nprotected void initializeCurrFromList ( List < DataSet > examples ) { \nif ( examples . isEmpty ( ) ) log . warn ( \"Warning: empty dataset from the fetcher\" ) ; \nINDArray inputs = createInputMatrix ( examples . size ( ) ) ; \nINDArray labels = createOutputMatrix ( examples . size ( ) ) ; \nfor ( int i = 0 ; \ni < examples . size ( ) ; \ni ++ ) { \ninputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; \nlabels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; \n} \ncurr = new DataSet ( inputs , labels ) ; \nreturn ; \n} \n} \n"}
{"3961": "public class AtomicAllocator { \nprotected void initHostCollectors ( ) { \nfor ( int i = 0 ; \ni < configuration . getNumberOfGcThreads ( ) ; \ni ++ ) { \nReferenceQueue < BaseDataBuffer > queue = new ReferenceQueue < > ( ) ; \nUnifiedGarbageCollectorThread uThread = new UnifiedGarbageCollectorThread ( i , queue ) ; \nNd4j . getAffinityManager ( ) . attachThreadToDevice ( uThread , getDeviceId ( ) ) ; \nqueueMap . put ( i , queue ) ; \nuThread . start ( ) ; \ncollectorsUnified . put ( i , uThread ) ; \n} \nreturn ; \n} \n} \n"}
{"3963": "public class AtomicAllocator { \n@ Override public void synchronizeHostData ( DataBuffer buffer ) { \nif ( buffer . isConstant ( ) ) { \nreturn ; \n} \nif ( memoryHandler . isDeviceDependant ( ) ) { \nAllocationPoint point = getAllocationPoint ( buffer . getTrackingPoint ( ) ) ; \nif ( point == null ) throw new RuntimeException ( \"AllocationPoint is NULL\" ) ; \nmemoryHandler . synchronizeThreadDevice ( Thread . currentThread ( ) . getId ( ) , memoryHandler . getDeviceId ( ) , point ) ; \n} \nreturn ; \n} \n} \n"}
{"3964": "public class AdaGradUpdater { \n@ Override public void applyUpdater ( INDArray gradient , int iteration , int epoch ) { \nif ( historicalGradient == null ) throw new IllegalStateException ( \"Updater has not been initialized with view state\" ) ; \ndouble learningRate = config . getLearningRate ( iteration , epoch ) ; \ndouble epsilon = config . getEpsilon ( ) ; \nhistoricalGradient . addi ( gradient . mul ( gradient ) ) ; \nINDArray sqrtHistory = sqrt ( historicalGradient . dup ( gradientReshapeOrder ) , false ) . addi ( epsilon ) ; \ngradient . muli ( sqrtHistory . rdivi ( learningRate ) ) ; \nreturn ; \n} \n} \n"}
{"3965": "public class GridFlowController { \n@ Override public void synchronizeToHost ( AllocationPoint point ) { \nif ( ! point . isConstant ( ) && point . isEnqueued ( ) ) { \nwaitTillFinished ( point ) ; \n} \nsuper . synchronizeToHost ( point ) ; \nreturn ; \n} \n} \n"}
{"3974": "public class BaseLoader { \n@ Override public void save ( IComplexNDArray save , String id ) throws IOException , SQLException { \ndoSave ( save , id ) ; \nreturn ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \ni < linear . length ( ) ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"3991": "public class BaseLevel1 { \n@ Override public void copy ( IComplexNDArray x , IComplexNDArray y ) { \nif ( x . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) zcopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; \nelse ccopy ( x . length ( ) , x , BlasBufferUtil . getBlasStride ( x ) , y , BlasBufferUtil . getBlasStride ( y ) ) ; \nreturn ; \n} \n} \n"}
{"3992": "public class BaseLevel1 { \n@ Override public void scal ( long N , IComplexNumber alpha , IComplexNDArray X ) { \nif ( X . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) zscal ( N , alpha . asDouble ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; \nelse cscal ( N , alpha . asFloat ( ) , X , BlasBufferUtil . getBlasStride ( X ) ) ; \nreturn ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( negSamples > 0 ) { \nint negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nint resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nint e = 0 ; \nfor ( ; \ne < codes . length ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nfor ( ; \ne < resultLength ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \nelse if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \nreturn ; \n} \n} \n"}
{"4031": "public class Round { \npublic void execute ( ) { \nif ( needsExecution ( ) ) { \nlog . trace ( \"Executing round: {}\" , pending ) ; \nResult < Map < com . google . cloud . datastore . Key , Entity > > fetched = fetchPending ( ) ; \ntranslated = loadEngine . translate ( fetched ) ; \nif ( loadEngine . ofy . getTransaction ( ) != null && depth > 0 ) translated . now ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4033": "public class ClassTranslator { \nprivate void addIndexedDiscriminators ( final Class < ? > clazz ) { \nif ( clazz == Object . class ) return ; \nthis . addIndexedDiscriminators ( clazz . getSuperclass ( ) ) ; \nfinal Subclass sub = clazz . getAnnotation ( Subclass . class ) ; \nif ( sub != null && sub . index ( ) ) { \nfinal String disc = ( sub . name ( ) . length ( ) > 0 ) ? sub . name ( ) : clazz . getSimpleName ( ) ; \nthis . indexedDiscriminators . add ( StringValue . of ( disc ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4034": "public class ClassTranslator { \npublic void registerSubclass ( ClassTranslator < ? extends P > translator ) { \nbyDiscriminator . put ( translator . getDiscriminator ( ) , translator ) ; \nSubclass sub = translator . getDeclaredClass ( ) . getAnnotation ( Subclass . class ) ; \nfor ( String alsoLoad : sub . alsoLoad ( ) ) byDiscriminator . put ( alsoLoad , translator ) ; \nbyClass . put ( translator . getDeclaredClass ( ) , translator ) ; \nreturn ; \n} \n} \n"}
{"4041": "public class EntityMemcache { \npublic void putAll ( final Collection < Bucket > updates ) { \nfinal Set < Key > good = this . cachePutIfUntouched ( updates ) ; \nif ( good . size ( ) == updates . size ( ) ) return ; \nfinal List < Key > bad = updates . stream ( ) . map ( Bucket :: getKey ) . filter ( key -> ! good . contains ( key ) ) . collect ( Collectors . toList ( ) ) ; \nif ( ! bad . isEmpty ( ) ) { \nfinal Map < Key , Object > cached = this . cacheGetAll ( bad ) ; \ncached . values ( ) . removeIf ( Objects :: isNull ) ; \nthis . empty ( cached . keySet ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4042": "public class EntityMemcache { \npublic void empty ( final Iterable < Key > keys ) { \nfinal Map < Key , Object > updates = new HashMap < > ( ) ; \nfor ( final Key key : keys ) if ( cacheControl . isCacheable ( key ) ) updates . put ( key , null ) ; \nthis . memcacheWithRetry . putAll ( updates ) ; \nreturn ; \n} \n} \n"}
{"4046": "public class KeyMetadata { \nprivate void findKeyFields ( Class < ? > inspect , CreateContext ctx , Path path ) { \nif ( inspect == Object . class ) return ; \nfindKeyFields ( inspect . getSuperclass ( ) , ctx , path ) ; \nfor ( Field field : inspect . getDeclaredFields ( ) ) { \nif ( field . getAnnotation ( Id . class ) != null ) { \nif ( this . idMeta != null ) throw new IllegalStateException ( \"Multiple @Id fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ( field . getType ( ) != Long . class ) && ( field . getType ( ) != long . class ) && ( field . getType ( ) != String . class ) ) throw new IllegalStateException ( \"@Id field '\" + field . getName ( ) + \"' in \" + inspect . getName ( ) + \" must be of type Long, long, or String\" ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . idMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \nelse if ( field . getAnnotation ( Parent . class ) != null ) { \nif ( this . parentMeta != null ) throw new IllegalStateException ( \"Multiple @Parent fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ! isAllowedParentFieldType ( field . getType ( ) ) ) throw new IllegalStateException ( \"@Parent fields must be Ref<?>, Key<?>, or datastore Key. Illegal parent: \" + field ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . parentMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4047": "public class KeyMetadata { \n@ SuppressWarnings ( \"unchecked\" ) public < K extends IncompleteKey > void setKey ( final FullEntity . Builder < K > container , final P pojo ) { \nfinal IncompleteKey rawKey = getIncompleteKey ( pojo ) ; \nif ( ! ( rawKey instanceof com . google . cloud . datastore . Key ) ) { \nPreconditions . checkState ( isIdNumeric ( ) , \"Cannot save an entity with a null String @Id: %s\" , pojo ) ; \n} \ncontainer . setKey ( ( K ) rawKey ) ; \nreturn ; \n} \n} \n"}
{"4048": "public class KeyMetadata { \npublic void setLongId ( P pojo , Long id ) { \nif ( ! clazz . isAssignableFrom ( pojo . getClass ( ) ) ) throw new IllegalArgumentException ( \"Trying to use metadata for \" + clazz . getName ( ) + \" to set key of \" + pojo . getClass ( ) . getName ( ) ) ; \nthis . idMeta . getProperty ( ) . set ( pojo , id ) ; \nreturn ; \n} \n} \n"}
{"4050": "public class ClassTranslatorFactory { \nprivate void registerSubclass ( final ClassTranslator < P > translator , final TypeKey < ? super P > superclassTypeKey , final CreateContext ctx , final Path path ) { \nif ( superclassTypeKey . getTypeAsClass ( ) == Object . class ) return ; \n@ SuppressWarnings ( \"unchecked\" ) final ClassTranslator < ? super P > superTranslator = create ( ( TypeKey ) superclassTypeKey , ctx , path ) ; \nsuperTranslator . registerSubclass ( translator ) ; \nregisterSubclass ( translator , new TypeKey < > ( superclassTypeKey . getTypeAsClass ( ) . getSuperclass ( ) ) , ctx , path ) ; \nreturn ; \n} \n} \n"}
{"4054": "public class Session { \npublic void addAll ( final Session other ) { \nif ( log . isTraceEnabled ( ) ) log . trace ( \"Adding all values to session: {}\" , other . map . keySet ( ) ) ; \nmap . putAll ( other . map ) ; \nreturn ; \n} \n} \n"}
{"4056": "public class LoadEngine { \npublic void execute ( ) { \nif ( round . needsExecution ( ) ) { \nRound old = round ; \nround = old . next ( ) ; \nold . execute ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4057": "public class LoadEngine { \npublic Result < Map < Key < ? > , Object > > translate ( final Result < Map < com . google . cloud . datastore . Key , Entity > > raw ) { \nreturn new ResultCache < Map < Key < ? > , Object > > ( ) { \nprivate LoadContext ctx ; \n@ Override public Map < Key < ? > , Object > nowUncached ( ) { \nfinal Map < Key < ? > , Object > result = new HashMap < > ( raw . now ( ) . size ( ) * 2 ) ; \nctx = new LoadContext ( LoadEngine . this ) ; \nfor ( final Entity ent : raw . now ( ) . values ( ) ) { \nfinal Key < ? > key = Key . create ( ent . getKey ( ) ) ; \nfinal Object entity = load ( ent , ctx ) ; \nresult . put ( key , entity ) ; \n} \nreturn result ; \n} \n@ Override protected void postExecuteHook ( ) { \nctx . done ( ) ; \nctx = null ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"4073": "public class ObjectifyFactory { \npublic void close ( final Objectify ofy ) { \nfinal Deque < Objectify > stack = stacks . get ( ) ; \nif ( stack . isEmpty ( ) ) throw new IllegalStateException ( \"You have already destroyed the Objectify context.\" ) ; \nfinal Objectify popped = stack . removeLast ( ) ; \nassert popped == ofy : \"Mismatched objectify instances; somehow the stack was corrupted\" ; \nreturn ; \n} \n} \n"}
{"4074": "public class Values { \npublic static void homogenizeIndexes ( final List < Value < ? > > list ) { \nif ( isIndexHomogeneous ( list ) ) return ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni ++ ) { \nfinal Value < ? > value = list . get ( i ) ; \nif ( value . excludeFromIndexes ( ) ) list . set ( i , index ( value , true ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4080": "public class LoadContext { \npublic void done ( ) { \nengine . execute ( ) ; \nwhile ( deferred != null ) { \nfinal List < Runnable > runme = deferred ; \ndeferred = null ; \nfor ( final Runnable run : runme ) { \nlog . trace ( \"Executing {}\" , run ) ; \nrun . run ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4083": "public class FutureHelper { \npublic static void unwrapAndThrow ( Throwable ex ) { \nif ( ex instanceof RuntimeException ) throw ( RuntimeException ) ex ; \nelse if ( ex instanceof Error ) throw ( Error ) ex ; \nelse if ( ex instanceof ExecutionException ) unwrapAndThrow ( ex . getCause ( ) ) ; \nelse throw new UndeclaredThrowableException ( ex ) ; \nreturn ; \n} \n} \n"}
{"4087": "public class PropertyPopulator { \n@ Override public void load ( final FullEntity < ? > container , final LoadContext ctx , final Path containerPath , final P intoPojo ) { \ntry { \nif ( translator instanceof Recycles ) ctx . recycle ( property . get ( intoPojo ) ) ; \nfinal Value < D > value = ( translator instanceof Synthetic ) ? null : getPropertyFromContainer ( container , containerPath ) ; \nsetValue ( intoPojo , value , ctx , containerPath ) ; \n} \ncatch ( SkipException ex ) { \n} \nreturn ; \n} \n} \n"}
{"4089": "public class PropertyPopulator { \npublic void setValue ( final Object pojo , final Value < D > value , final LoadContext ctx , final Path containerPath ) throws SkipException { \nfinal Path propertyPath = containerPath . extend ( property . getName ( ) ) ; \nfinal P loaded = translator . load ( value , ctx , propertyPath ) ; \nsetOnPojo ( pojo , loaded , ctx , propertyPath ) ; \nreturn ; \n} \n} \n"}
{"4090": "public class PropertyPopulator { \n@ Override public void save ( final P onPojo , boolean index , final SaveContext ctx , final Path containerPath , final FullEntity . Builder < ? > into ) { \nif ( property . isSaved ( onPojo ) ) { \nfinal Boolean propertyIndexInstruction = property . getIndexInstruction ( onPojo ) ; \nif ( propertyIndexInstruction != null ) index = propertyIndexInstruction ; \n@ SuppressWarnings ( \"unchecked\" ) final P value = ( P ) property . get ( onPojo ) ; \ntry { \nfinal Path propPath = containerPath . extend ( property . getName ( ) ) ; \nfinal Value < D > propValue = translator . save ( value , index , ctx , propPath ) ; \ninto . set ( property . getName ( ) , propValue ) ; \n} \ncatch ( SkipException ex ) { \n} \n} \nreturn ; \n} \n} \n"}
{"4092": "public class AbstractOpenRtbJsonWriter { \n@ SuppressWarnings ( \"unchecked\" ) protected final < EM extends ExtendableMessage < EM > > void writeExtensions ( EM msg , JsonGenerator gen ) throws IOException { \nboolean openExt = false ; \nfor ( Map . Entry < FieldDescriptor , Object > field : msg . getAllFields ( ) . entrySet ( ) ) { \nFieldDescriptor fd = field . getKey ( ) ; \nif ( fd . isExtension ( ) ) { \nif ( fd . isRepeated ( ) ) { \nList < Object > extValue = ( List < Object > ) field . getValue ( ) ; \nif ( ! extValue . isEmpty ( ) ) { \nOpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . get ( 0 ) . getClass ( ) , fd . getName ( ) ) ; \nif ( extWriter != null ) { \nopenExt = openExt ( gen , openExt ) ; \nextWriter . writeRepeated ( extValue , gen ) ; \n} \n} \n} \nelse { \nObject extValue = field . getValue ( ) ; \nOpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . getClass ( ) , fd . getName ( ) ) ; \nif ( extWriter != null ) { \nopenExt = openExt ( gen , openExt ) ; \nextWriter . writeSingle ( extValue , gen ) ; \n} \n} \n} \n} \nif ( openExt ) { \ngen . writeEndObject ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4094": "public class AbstractOpenRtbJsonWriter { \nprotected final void writeContentCategories ( String fieldName , List < String > cats , JsonGenerator gen ) throws IOException { \nif ( ! cats . isEmpty ( ) ) { \ngen . writeArrayFieldStart ( fieldName ) ; \nfor ( String cat : cats ) { \nwriteContentCategory ( cat , gen ) ; \n} \ngen . writeEndArray ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4101": "public class AbstractOpenRtbJsonReader { \nprotected final < EB extends ExtendableBuilder < ? , EB > > void readExtensions ( EB msg , JsonParser par ) throws IOException { \n@ SuppressWarnings ( \"unchecked\" ) Set < OpenRtbJsonExtReader < EB > > extReaders = factory . getReaders ( ( Class < EB > ) msg . getClass ( ) ) ; \nif ( extReaders . isEmpty ( ) ) { \npar . skipChildren ( ) ; \nreturn ; \n} \nstartObject ( par ) ; \nJsonToken tokLast = par . getCurrentToken ( ) ; \nJsonLocation locLast = par . getCurrentLocation ( ) ; \nwhile ( true ) { \nboolean extRead = false ; \nfor ( OpenRtbJsonExtReader < EB > extReader : extReaders ) { \nif ( extReader . filter ( par ) ) { \nextReader . read ( msg , par ) ; \nJsonToken tokNew = par . getCurrentToken ( ) ; \nJsonLocation locNew = par . getCurrentLocation ( ) ; \nboolean advanced = tokNew != tokLast || ! locNew . equals ( locLast ) ; \nextRead |= advanced ; \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nelse if ( advanced && par . getCurrentToken ( ) != JsonToken . FIELD_NAME ) { \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \nelse { \ntokLast = tokNew ; \nlocLast = locNew ; \n} \n} \n} \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nif ( ! extRead ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Extension field not consumed by any reader, skipping: {} @{}:{}\" , par . getCurrentName ( ) , locLast . getLineNr ( ) , locLast . getCharOffset ( ) ) ; \n} \npar . nextToken ( ) ; \npar . skipChildren ( ) ; \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4105": "public class OpenRtbSnippetProcessor { \npublic void process ( SnippetProcessorContext bidCtx ) { \nfor ( SeatBid . Builder seat : bidCtx . response ( ) . getSeatbidBuilderList ( ) ) { \nfor ( Bid . Builder bid : seat . getBidBuilderList ( ) ) { \nbidCtx . setBid ( bid ) ; \nprocessFields ( bidCtx ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4106": "public class OpenRtbSnippetProcessor { \nprotected void processFields ( SnippetProcessorContext bidCtx ) { \nBid . Builder bid = bidCtx . getBid ( ) ; \nif ( extendedFields ) { \nif ( bid . hasAdid ( ) ) { \nbid . setAdid ( process ( bidCtx , bid . getAdid ( ) ) ) ; \n} \nbid . setId ( process ( bidCtx , bid . getId ( ) ) ) ; \n} \nif ( bid . hasAdm ( ) ) { \nbid . setAdm ( process ( bidCtx , bid . getAdm ( ) ) ) ; \n} \nif ( extendedFields ) { \nif ( bid . hasBurl ( ) ) { \nbid . setBurl ( process ( bidCtx , bid . getBurl ( ) ) ) ; \n} \nif ( bid . hasCid ( ) ) { \nbid . setCid ( process ( bidCtx , bid . getCid ( ) ) ) ; \n} \nif ( bid . hasCrid ( ) ) { \nbid . setCrid ( process ( bidCtx , bid . getCrid ( ) ) ) ; \n} \nif ( bid . hasDealid ( ) ) { \nbid . setDealid ( process ( bidCtx , bid . getDealid ( ) ) ) ; \n} \nbid . setImpid ( process ( bidCtx , bid . getImpid ( ) ) ) ; \nif ( bid . hasIurl ( ) ) { \nbid . setIurl ( process ( bidCtx , bid . getIurl ( ) ) ) ; \n} \nif ( bid . hasLurl ( ) ) { \nbid . setIurl ( process ( bidCtx , bid . getLurl ( ) ) ) ; \n} \nif ( bid . hasNurl ( ) ) { \nbid . setNurl ( process ( bidCtx , bid . getNurl ( ) ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4110": "public class OpenRtbJsonUtils { \npublic static void startObject ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nif ( token == JsonToken . START_OBJECT ) { \npar . nextToken ( ) ; \n} \nelse { \nthrow new JsonParseException ( par , \"Expected start of object\" ) ; \n} \nreturn ; \n} \n} \n"}
{"4111": "public class OpenRtbJsonUtils { \npublic static void startArray ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null || token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nif ( token == JsonToken . START_ARRAY ) { \npar . nextToken ( ) ; \n} \nelse { \nthrow new JsonParseException ( par , \"Expected start of array\" ) ; \n} \nreturn ; \n} \n} \n"}
{"4113": "public class OpenRtbJsonUtils { \npublic static void writeIntBoolField ( String fieldName , boolean data , JsonGenerator gen ) throws IOException { \ngen . writeNumberField ( fieldName , data ? 1 : 0 ) ; \nreturn ; \n} \n} \n"}
{"4114": "public class OpenRtbJsonUtils { \npublic static void writeStrings ( String fieldName , List < String > data , JsonGenerator gen ) throws IOException { \nif ( ! data . isEmpty ( ) ) { \ngen . writeArrayFieldStart ( fieldName ) ; \nfor ( String d : data ) { \ngen . writeString ( d ) ; \n} \ngen . writeEndArray ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4115": "public class OpenRtbJsonUtils { \npublic static void writeInts ( String fieldName , List < Integer > data , JsonGenerator gen ) throws IOException { \nif ( ! data . isEmpty ( ) ) { \ngen . writeArrayFieldStart ( fieldName ) ; \nfor ( Integer d : data ) { \ngen . writeNumber ( d ) ; \n} \ngen . writeEndArray ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4116": "public class OpenRtbJsonUtils { \npublic static void writeLongs ( String fieldName , List < Long > data , JsonGenerator gen ) throws IOException { \nif ( ! data . isEmpty ( ) ) { \ngen . writeArrayFieldStart ( fieldName ) ; \nfor ( long d : data ) { \nwriteLong ( d , gen ) ; \n} \ngen . writeEndArray ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4117": "public class OpenRtbJsonUtils { \npublic static void writeEnums ( String fieldName , List < ? extends ProtocolMessageEnum > enums , JsonGenerator gen ) throws IOException { \nif ( ! enums . isEmpty ( ) ) { \ngen . writeArrayFieldStart ( fieldName ) ; \nfor ( ProtocolMessageEnum e : enums ) { \nwriteEnum ( e , gen ) ; \n} \ngen . writeEndArray ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4130": "public class MemorySpout { \npublic static void add ( String url , Metadata md , Date nextFetch ) { \nLOG . debug ( \"Adding {} with md {} and nextFetch {}\" , url , md , nextFetch ) ; \nScheduledURL tuple = new ScheduledURL ( url , md , nextFetch ) ; \nsynchronized ( queue ) { \nqueue . add ( tuple ) ; \n} \nreturn ; \n} \n} \n"}
{"4136": "public class Metadata { \npublic void setValue ( String key , String value ) { \nmd . put ( key , new String [ ] { \nvalue } \n) ; \nreturn ; \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) return ; \nint numNodes = nodes . getLength ( ) ; \nfor ( int i = 0 ; \ni < numNodes ; \ni ++ ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \nfor ( int att = 0 ; \natt < attrs . getLength ( ) ; \natt ++ ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \ncontinue ; \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \ncontinue ; \n} \n} \nif ( isRobots && content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"4143": "public class AbstractStatusUpdaterBolt { \nprotected final void ack ( Tuple t , String url ) { \nif ( useCache ) { \ncache . put ( url , \"\" ) ; \n} \n_collector . ack ( t ) ; \nreturn ; \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( null != currentNode ) { \ncurrentNode . appendChild ( newNode ) ; \n} \nelse if ( null != m_docFrag ) { \nm_docFrag . appendChild ( newNode ) ; \n} \nelse { \nboolean ok = true ; \nshort type = newNode . getNodeType ( ) ; \nif ( type == Node . TEXT_NODE ) { \nString data = newNode . getNodeValue ( ) ; \nif ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { \nthrow new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \n} \nok = false ; \n} \nelse if ( type == Node . ELEMENT_NODE ) { \nif ( m_doc . getDocumentElement ( ) != null ) { \nthrow new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \n} \n} \nif ( ok ) { \nm_doc . appendChild ( newNode ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4154": "public class DOMBuilder { \n@ Override public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { \nif ( isOutsideDocElem ( ) ) { \nreturn ; \n} \nString s = new String ( ch , start , length ) ; \nappend ( m_doc . createTextNode ( s ) ) ; \nreturn ; \n} \n} \n"}
{"4155": "public class DOMBuilder { \n@ Override public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { \nappend ( m_doc . createProcessingInstruction ( target , data ) ) ; \nreturn ; \n} \n} \n"}
{"4156": "public class DOMBuilder { \n@ Override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { \nif ( ch == null || start < 0 || length >= ( ch . length - start ) || length < 0 ) { \nreturn ; \n} \nappend ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; \nreturn ; \n} \n} \n"}
{"4157": "public class DOMBuilder { \npublic void cdata ( char ch [ ] , int start , int length ) { \nif ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) { \nreturn ; \n} \nString s = new String ( ch , start , length ) ; \nNode n = m_currentNode . getLastChild ( ) ; \nif ( n instanceof CDATASection ) { \n( ( CDATASection ) n ) . appendData ( s ) ; \n} \nelse if ( n instanceof Comment ) { \n( ( Comment ) n ) . appendData ( s ) ; \n} \nreturn ; \n} \n} \n"}
{"4158": "public class DOMBuilder { \n@ Override public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { \nreturn ; \n} \n} \n"}
{"4159": "public class DOMBuilder { \n@ Override public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { \nreturn ; \n} \n} \n"}
{"4164": "public class WheelView { \npublic void setWheelItemCount ( int count ) { \nmItemCount = count ; \nmItemAngle = calculateItemAngle ( count ) ; \nif ( mWheelBounds != null ) { \ninvalidate ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4166": "public class WheelView { \npublic void setEmptyItemDrawable ( Drawable drawable ) { \nmEmptyItemDrawable = drawable ; \nEMPTY_CACHE_ITEM . mDrawable = drawable ; \nif ( mWheelBounds != null ) { \ninvalidate ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4167": "public class WheelView { \npublic void setAngle ( float angle ) { \nmAngle = angle ; \nupdateSelectedPosition ( ) ; \nif ( mOnAngleChangeListener != null ) { \nmOnAngleChangeListener . onWheelAngleChange ( mAngle ) ; \n} \ninvalidate ( ) ; \nreturn ; \n} \n} \n"}
{"4168": "public class WheelView { \nprivate void updateSelectedPosition ( ) { \nint position = ( int ) ( ( - mAngle + - 0.5 * Math . signum ( mAngle ) * mItemAngle ) / mItemAngle ) ; \nsetSelectedPosition ( position ) ; \nreturn ; \n} \n} \n"}
{"4169": "public class WheelView { \npublic void invalidateWheelItemDrawable ( int position ) { \nint adapterPos = rawPositionToAdapterPosition ( position ) ; \nif ( isEmptyItemPosition ( adapterPos ) ) return ; \nCacheItem cacheItem = mItemCacheArray [ adapterPos ] ; \nif ( cacheItem != null ) cacheItem . mDirty = true ; \ninvalidate ( ) ; \nreturn ; \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( vel > 0f ) { \nmAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity < 0f ) mAngularVelocity = 0f ; \n} \nelse if ( vel < 0f ) { \nmAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity > 0f ) mAngularVelocity = 0f ; \n} \nif ( mAngularVelocity != 0f ) { \naddAngle ( mAngularVelocity * deltaTime ) ; \n} \nelse { \nmRequiresUpdate = false ; \n} \nreturn ; \n} \n} \n"}
{"4174": "public class CoverallsReportMojo { \nprotected void writeCoveralls ( final JsonWriter writer , final SourceCallback sourceCallback , final List < CoverageParser > parsers ) throws ProcessingException , IOException { \ntry { \ngetLog ( ) . info ( \"Writing Coveralls data to \" + writer . getCoverallsFile ( ) . getAbsolutePath ( ) + \"...\" ) ; \nlong now = System . currentTimeMillis ( ) ; \nsourceCallback . onBegin ( ) ; \nfor ( CoverageParser parser : parsers ) { \ngetLog ( ) . info ( \"Processing coverage report from \" + parser . getCoverageFile ( ) . getAbsolutePath ( ) ) ; \nparser . parse ( sourceCallback ) ; \n} \nsourceCallback . onComplete ( ) ; \nlong duration = System . currentTimeMillis ( ) - now ; \ngetLog ( ) . info ( \"Successfully wrote Coveralls data in \" + duration + \"ms\" ) ; \n} \nfinally { \nwriter . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4176": "public class ArrayChar { \npublic void setString ( String val ) { \nint rank = getRank ( ) ; \nif ( rank != 1 ) throw new IllegalArgumentException ( \"ArayChar.setString rank must be 1\" ) ; \nint arrayLen = indexCalc . getShape ( 0 ) ; \nint strLen = Math . min ( val . length ( ) , arrayLen ) ; \nfor ( int k = 0 ; \nk < strLen ; \nk ++ ) storage [ k ] = val . charAt ( k ) ; \nchar c = 0 ; \nfor ( int k = strLen ; \nk < arrayLen ; \nk ++ ) storage [ k ] = c ; \nreturn ; \n} \n} \n"}
{"4182": "public class IndependentWindow { \npublic void show ( ) { \nsetState ( Frame . NORMAL ) ; \nsuper . toFront ( ) ; \nSwingUtilities . invokeLater ( new Runnable ( ) { \npublic void run ( ) { \nIndependentWindow . super . show ( ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"4183": "public class IndependentWindow { \npublic void showIfNotIconified ( ) { \nif ( getState ( ) == Frame . ICONIFIED ) return ; \nSwingUtilities . invokeLater ( new Runnable ( ) { \npublic void run ( ) { \nIndependentWindow . super . show ( ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"4185": "public class Grib1RecordScanner { \npublic static void main ( String [ ] args ) throws IOException { \nint count = 0 ; \nString file = ( args . length > 0 ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib1/ECMWF.hybrid.grib1\" ; \nRandomAccessFile raf = new RandomAccessFile ( file , \"r\" ) ; \nSystem . out . printf ( \"Read %s%n\" , raf . getLocation ( ) ) ; \nGrib1RecordScanner scan = new Grib1RecordScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nscan . next ( ) ; \ncount ++ ; \n} \nraf . close ( ) ; \nSystem . out . printf ( \"count=%d%n\" , count ) ; \nreturn ; \n} \n} \n"}
{"4191": "public class DateRange { \npublic void extend ( DateRange dr ) { \nboolean localEmpty = isEmpty ; \nif ( localEmpty || dr . getStart ( ) . before ( getStart ( ) ) ) setStart ( dr . getStart ( ) ) ; \nif ( localEmpty || getEnd ( ) . before ( dr . getEnd ( ) ) ) setEnd ( dr . getEnd ( ) ) ; \nreturn ; \n} \n} \n"}
{"4192": "public class DateRange { \npublic void extend ( Date d ) { \nif ( d . before ( getStart ( ) . getDate ( ) ) ) setStart ( new DateType ( false , d ) ) ; \nif ( getEnd ( ) . before ( d ) ) setEnd ( new DateType ( false , d ) ) ; \nreturn ; \n} \n} \n"}
{"4193": "public class DateRange { \npublic void setStart ( DateType start ) { \nthis . start = start ; \nuseStart = true ; \nif ( useEnd ) { \nthis . isMoving = this . start . isPresent ( ) || this . end . isPresent ( ) ; \nuseDuration = false ; \nrecalcDuration ( ) ; \n} \nelse { \nthis . isMoving = this . start . isPresent ( ) ; \nthis . end = this . start . add ( duration ) ; \n} \ncheckIfEmpty ( ) ; \nreturn ; \n} \n} \n"}
{"4194": "public class DateRange { \npublic void setEnd ( DateType end ) { \nthis . end = end ; \nuseEnd = true ; \nif ( useStart ) { \nthis . isMoving = this . start . isPresent ( ) || this . end . isPresent ( ) ; \nuseDuration = false ; \nrecalcDuration ( ) ; \n} \nelse { \nthis . isMoving = this . end . isPresent ( ) ; \nthis . start = this . end . subtract ( duration ) ; \n} \ncheckIfEmpty ( ) ; \nreturn ; \n} \n} \n"}
{"4195": "public class DateRange { \npublic void setDuration ( TimeDuration duration ) { \nthis . duration = duration ; \nuseDuration = true ; \nif ( useStart ) { \nthis . isMoving = this . start . isPresent ( ) ; \nthis . end = this . start . add ( duration ) ; \nuseEnd = false ; \n} \nelse { \nthis . isMoving = this . end . isPresent ( ) ; \nthis . start = this . end . subtract ( duration ) ; \n} \ncheckIfEmpty ( ) ; \nreturn ; \n} \n} \n"}
{"4196": "public class DateRange { \nprivate void recalcDuration ( ) { \nlong min = getStart ( ) . getDate ( ) . getTime ( ) ; \nlong max = getEnd ( ) . getDate ( ) . getTime ( ) ; \ndouble secs = .001 * ( max - min ) ; \nif ( secs < 0 ) secs = 0 ; \nif ( duration == null ) { \ntry { \nduration = new TimeDuration ( chooseResolution ( secs ) ) ; \n} \ncatch ( ParseException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( resolution == null ) { \nduration . setValueInSeconds ( secs ) ; \n} \nelse { \ndouble resSecs = resolution . getValueInSeconds ( ) ; \ndouble closest = Math . round ( secs / resSecs ) ; \nsecs = closest * resSecs ; \nduration . setValueInSeconds ( secs ) ; \n} \nhashCode = 0 ; \nreturn ; \n} \n} \n"}
{"4197": "public class GridUI { \npublic void addMapBean ( MapBean mb ) { \nmapBeanMenu . addAction ( mb . getActionDesc ( ) , mb . getIcon ( ) , mb . getAction ( ) ) ; \nif ( mapBeanCount == 0 ) { \nsetMapRenderer ( mb . getRenderer ( ) ) ; \n} \nmapBeanCount ++ ; \nmb . addPropertyChangeListener ( new PropertyChangeListener ( ) { \npublic void propertyChange ( java . beans . PropertyChangeEvent e ) { \nif ( e . getPropertyName ( ) . equals ( \"Renderer\" ) ) { \nsetMapRenderer ( ( Renderer ) e . getNewValue ( ) ) ; \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"4198": "public class CELexer { \npublic void yyerror ( String s ) { \nSystem . err . println ( \"CEParserImpl.yyerror: \" + s + \"; parse failed at char: \" + charno + \"; near: \" ) ; \nString context = getInput ( ) ; \nint show = ( context . length ( ) < CONTEXTLEN ? context . length ( ) : CONTEXTLEN ) ; \nSystem . err . println ( context . substring ( context . length ( ) - show ) + \"^\" ) ; \nnew Exception ( ) . printStackTrace ( System . err ) ; \nreturn ; \n} \n} \n"}
{"4203": "public class RangeDateSelector { \nprivate void synchUI ( boolean slidersOK ) { \neventOK = false ; \nif ( slidersOK ) minSlider . setValue ( scale . world2slider ( dateRange . getStart ( ) ) ) ; \nminField . setValue ( dateRange . getStart ( ) ) ; \nif ( maxField != null ) { \nif ( slidersOK ) maxSlider . setValue ( scale . world2slider ( dateRange . getEnd ( ) ) ) ; \nmaxField . setValue ( dateRange . getEnd ( ) ) ; \n} \nif ( durationField != null ) durationField . setValue ( dateRange . getDuration ( ) ) ; \neventOK = true ; \nreturn ; \n} \n} \n"}
{"4205": "public class CatalogWatcher { \npublic void register ( Path dir ) throws IOException { \nif ( ! enable ) return ; \nWatchKey key = dir . register ( watcher , ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY ) ; \nif ( trace ) { \nPath prev = keys . get ( key ) ; \nif ( prev == null ) { \nSystem . out . format ( \"CatalogWatcher register: %s%n\" , dir ) ; \n} \nelse { \nif ( ! dir . equals ( prev ) ) { \nSystem . out . format ( \"update: %s -> %s%n\" , prev , dir ) ; \n} \n} \n} \nkeys . put ( key , dir ) ; \nreturn ; \n} \n} \n"}
{"4206": "public class CatalogWatcher { \npublic void processEvents ( ) { \nif ( ! enable ) return ; \nfor ( ; \n; \n) { \nWatchKey key ; \ntry { \nkey = watcher . take ( ) ; \n} \ncatch ( InterruptedException x ) { \nreturn ; \n} \nPath dir = keys . get ( key ) ; \nif ( dir == null ) { \nSystem . err . println ( \"WatchKey not recognized!!\" ) ; \ncontinue ; \n} \nfor ( WatchEvent < ? > event : key . pollEvents ( ) ) { \nWatchEvent . Kind kind = event . kind ( ) ; \nif ( kind == OVERFLOW ) { \ncontinue ; \n} \nWatchEvent < Path > ev = cast ( event ) ; \nPath name = ev . context ( ) ; \nPath child = dir . resolve ( name ) ; \nSystem . out . format ( \"%s: %s%n\" , event . kind ( ) . name ( ) , child ) ; \nif ( recursive && ( kind == ENTRY_CREATE ) ) { \ntry { \nif ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) { \nregisterAll ( child ) ; \n} \n} \ncatch ( IOException x ) { \n} \n} \n} \nboolean valid = key . reset ( ) ; \nif ( ! valid ) { \nkeys . remove ( key ) ; \nif ( keys . isEmpty ( ) ) { \nbreak ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4217": "public class CatalogManager { \nprivate void addGlobalServices ( CatalogBuilder cat ) { \nSet < String > allServiceNames = new HashSet < > ( ) ; \nfindServices ( cat . getDatasets ( ) , allServiceNames ) ; \nif ( ! allServiceNames . isEmpty ( ) ) { \nList < Service > servicesMissing = new ArrayList < > ( ) ; \nfor ( String name : allServiceNames ) { \nif ( cat . hasServiceInDataset ( name ) ) continue ; \nService s = globalServices . findGlobalService ( name ) ; \nif ( s != null ) servicesMissing . add ( s ) ; \n} \nservicesMissing . forEach ( cat :: addService ) ; \n} \nfor ( DatasetBuilder node : cat . getDatasets ( ) ) { \nString sname = ( String ) node . getFldOrInherited ( Dataset . ServiceName ) ; \nString urlPath = ( String ) node . get ( Dataset . UrlPath ) ; \nString ftypeS = ( String ) node . getFldOrInherited ( Dataset . FeatureType ) ; \nif ( sname == null && urlPath != null && ftypeS != null ) { \nService s = globalServices . getStandardServices ( ftypeS ) ; \nif ( s != null ) { \nnode . put ( Dataset . ServiceName , s . getName ( ) ) ; \ncat . addService ( s ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4218": "public class HttpClientManager { \nstatic public void init ( CredentialsProvider provider , String userAgent ) { \nif ( provider != null ) try { \nHTTPSession . setGlobalCredentialsProvider ( provider ) ; \n} \ncatch ( HTTPException e ) { \nthrow new IllegalArgumentException ( e ) ; \n} \nif ( userAgent != null ) HTTPSession . setGlobalUserAgent ( userAgent + \"/NetcdfJava/HttpClient\" ) ; \nelse HTTPSession . setGlobalUserAgent ( \"NetcdfJava/HttpClient\" ) ; \nreturn ; \n} \n} \n"}
{"4234": "public class N3iosp { \n@ Override public void openForWriting ( ucar . unidata . io . RandomAccessFile raf , ucar . nc2 . NetcdfFile ncfile , ucar . nc2 . util . CancelTask cancelTask ) throws IOException { \nopen ( raf , ncfile , cancelTask ) ; \nreturn ; \n} \n} \n"}
{"4237": "public class N3iosp { \nprotected void fillNonRecordVariables ( ) throws IOException { \nfor ( Variable v : ncfile . getVariables ( ) ) { \nif ( v . isUnlimited ( ) ) continue ; \ntry { \nwriteData ( v , v . getShapeAsSection ( ) , makeConstantArray ( v ) ) ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4241": "public class FunctionLibrary { \npublic void add ( ServerSideFunction function ) { \nif ( function instanceof BoolFunction ) { \nboolFunctions . put ( function . getName ( ) , function ) ; \n} \nif ( function instanceof BTFunction ) { \nbtFunctions . put ( function . getName ( ) , function ) ; \n} \nreturn ; \n} \n} \n"}
{"4244": "public class FunctionLibrary { \nprotected void loadNewFunction ( String name ) { \ntry { \nString fullName = prefix + name ; \nClass value = Class . forName ( fullName ) ; \nif ( ( ServerSideFunction . class ) . isAssignableFrom ( value ) ) { \nadd ( ( ServerSideFunction ) value . newInstance ( ) ) ; \nreturn ; \n} \n} \ncatch ( ClassNotFoundException e ) { \n} \ncatch ( IllegalAccessException e ) { \n} \ncatch ( InstantiationException e ) { \n} \nreturn ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \nreturn ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \nreturn ; \n} \n} \n"}
{"4255": "public class FmrcCollectionTable { \npublic void save ( ) { \ncollectionNameTable . saveState ( false ) ; \ndataTable . saveState ( false ) ; \nprefs . putBeanObject ( \"InfoWindowBounds\" , infoWindow . getBounds ( ) ) ; \nprefs . putInt ( \"splitPos\" , split . getDividerLocation ( ) ) ; \nreturn ; \n} \n} \n"}
{"4257": "public class SerialWriter { \npublic void writeCount ( long count ) throws IOException { \ncountbuffer . clear ( ) ; \ncountbuffer . putLong ( count ) ; \nbyte [ ] countbuf = countbuffer . array ( ) ; \nint len = countbuffer . position ( ) ; \nwriteBytes ( countbuf , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"count: %d%n\" , count ) ; \n} \nreturn ; \n} \n} \n"}
{"4258": "public class SerialWriter { \npublic void writeAtomicArray ( DapType daptype , Object values ) throws IOException { \nassert values != null && values . getClass ( ) . isArray ( ) ; \nByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; \nbyte [ ] bytes = buf . array ( ) ; \nint len = buf . position ( ) ; \nwriteBytes ( bytes , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"%s: \" , daptype . getShortName ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nint x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; \nSystem . err . printf ( \"%02x\" , ( int ) ( x & 0xff ) ) ; \n} \nSystem . err . println ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nSystem . err . printf ( \"%02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nSystem . err . printf ( \" %02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( \"\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \nreturn ; \n} \n} \n"}
{"4261": "public class SimpleGeomController { \nvoid finishInit ( ) { \nnp = ui . panz ; \nvertPanel = ui . vertPanel ; \ndataValueLabel = ui . dataValueLabel ; \nposLabel = ui . positionLabel ; \nproject = ( ProjectionImpl ) store . getBean ( LastProjectionName , null ) ; \nif ( project != null ) setProjection ( project ) ; \nProjectionRect ma = ( ProjectionRect ) store . getBean ( LastMapAreaName , null ) ; \nif ( ma != null ) np . setMapArea ( ma ) ; \nmakeEventManagement ( ) ; \nreturn ; \n} \n} \n"}
{"4266": "public class McIDASGridReader { \nprivate void swapGridHeader ( int [ ] gh ) { \nMcIDASUtil . flip ( gh , 0 , 5 ) ; \nMcIDASUtil . flip ( gh , 7 , 7 ) ; \nMcIDASUtil . flip ( gh , 9 , 10 ) ; \nMcIDASUtil . flip ( gh , 12 , 14 ) ; \nMcIDASUtil . flip ( gh , 32 , 51 ) ; \nreturn ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . println ( \"found \" + grids . size ( ) + \" grids\" ) ; \nint num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nSystem . out . println ( grids . get ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4269": "public class WFSGetCapabilitiesWriter { \nprivate void writeAConstraint ( String name , boolean isImplemented ) { \nString defValue ; \nif ( isImplemented ) defValue = \"TRUE\" ; \nelse defValue = \"FALSE\" ; \nfileOutput += \"<ows:Constraint name=\\\"\" + name + \"\\\"> \" + \"<ows:NoValues/> \" + \"<ows:DefaultValue>\" + defValue + \"</ows:DefaultValue> \" + \"</ows:Constraint>\" ; \nreturn ; \n} \n} \n"}
{"4270": "public class WFSGetCapabilitiesWriter { \nprivate void writeHeadersAndSS ( ) { \nfileOutput += \"<wfs:WFS_Capabilities xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:ows=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ows/1.1\\\" xmlns:wfs=\\\"http://opengis.net/wfs/2.0\" ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\">\" ; \nwriteServiceInfo ( ) ; \nreturn ; \n} \n} \n"}
{"4271": "public class WFSGetCapabilitiesWriter { \npublic void writeOperations ( ) { \nfileOutput += \"<ows:OperationsMetadata> \" ; \nfor ( WFSRequestType rt : operationList ) { \nwriteAOperation ( rt ) ; \n} \nfileOutput += \"<ows:Parameter name=\\\"AcceptVersions\\\"> \" + \"<ows:AllowedValues> \" + \"<ows:Value>2.0.0</ows:Value>\" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nfileOutput += \"<ows:Parameter name=\\\"AcceptFormats\\\">\" + \"<ows:AllowedValues> \" + \"<ows:Value>text/xml</ows:Value>\" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nfileOutput += \"<ows:Parameter name=\\\"Sections\\\"> \" + \"<ows:AllowedValues> \" + \"<ows:Value>ServiceIdentification</ows:Value> \" + \"<ows:Value>ServiceProvider</ows:Value> \" + \"<ows:Value>OperationsMetadata</ows:Value> \" + \"<ows:Value>FeatureTypeList</ows:Value> \" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nfileOutput += \"<ows:Parameter name=\\\"version\\\"> \" + \"<ows:AllowedValues> \" + \"<ows:Value>2.0.0</ows:Value>\" + \"</ows:AllowedValues>\" + \"</ows:Parameter>\" ; \nwriteAConstraint ( \"ImplementsBasicWFS\" , true ) ; \nwriteAConstraint ( \"ImplementsTransactionalWFS\" , false ) ; \nwriteAConstraint ( \"ImplementsLockingWFS\" , false ) ; \nwriteAConstraint ( \"KVPEncoding\" , false ) ; \nwriteAConstraint ( \"XMLEncoding\" , true ) ; \nwriteAConstraint ( \"SOAPEncoding\" , false ) ; \nwriteAConstraint ( \"ImplementsInheritance\" , false ) ; \nwriteAConstraint ( \"ImplementsRemoteResolve\" , false ) ; \nwriteAConstraint ( \"ImplementsResultPaging\" , false ) ; \nwriteAConstraint ( \"ImplementsStandardJoins\" , false ) ; \nwriteAConstraint ( \"ImplementsSpatialJoins\" , false ) ; \nwriteAConstraint ( \"ImplementsTemporalJoins\" , false ) ; \nwriteAConstraint ( \"ImplementsFeatureVersioning\" , false ) ; \nwriteAConstraint ( \"ManageStoredQueries\" , false ) ; \nwriteAConstraint ( \"PagingIsTransactionSafe\" , false ) ; \nwriteAConstraint ( \"QueryExpressions\" , false ) ; \nfileOutput += \"</ows:OperationsMetadata>\" ; \nreturn ; \n} \n} \n"}
{"4272": "public class LogReader { \npublic void readAll ( File dir , FileFilter ff , Closure closure , LogFilter logf , Stats stat ) throws IOException { \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nSystem . out . printf ( \"Dir has no files= %s%n\" , dir ) ; \nreturn ; \n} \nList < File > list = Arrays . asList ( files ) ; \nCollections . sort ( list ) ; \nfor ( File f : list ) { \nif ( ( ff != null ) && ! ff . accept ( f ) ) continue ; \nif ( f . isDirectory ( ) ) readAll ( f , ff , closure , logf , stat ) ; \nelse scanLogFile ( f , closure , logf , stat ) ; \n} \nreturn ; \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nwhile ( ( maxLines < 0 ) || ( count < maxLines ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal ++ ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) continue ; \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \nreturn ; \n} \n} \n"}
{"4281": "public class GempakGridReader { \npublic void printGrids ( ) { \nList < GridRecord > gridList = gridIndex . getGridRecords ( ) ; \nif ( gridList == null ) return ; \nSystem . out . println ( \"  NUM       TIME1              TIME2           LEVL1 LEVL2  VCORD PARM\" ) ; \nfor ( GridRecord aGridList : gridList ) { \nSystem . out . println ( aGridList ) ; \n} \nreturn ; \n} \n} \n"}
{"4282": "public class GempakGridReader { \nprivate void getNextByte ( ) throws IOException { \nif ( ! needToSwap ) { \nbitBuf = rf . read ( ) ; \n} \nelse { \nif ( next == 3 ) { \nbitBuf = ch3 ; \n} \nelse if ( next == 2 ) { \nbitBuf = ch2 ; \n} \nelse if ( next == 1 ) { \nbitBuf = ch1 ; \n} \nelse { \nch1 = rf . read ( ) ; \nch2 = rf . read ( ) ; \nch3 = rf . read ( ) ; \nch4 = rf . read ( ) ; \nbitBuf = ch4 ; \nnext = 4 ; \n} \nnext -- ; \n} \nreturn ; \n} \n} \n"}
{"4290": "public class DownloadController { \npublic void setup ( HttpServletRequest req , HttpServletResponse resp ) throws SendError { \nthis . req = req ; \nthis . res = resp ; \nif ( ! once ) doonce ( req ) ; \ntry { \nthis . params = new DownloadParameters ( req ) ; \n} \ncatch ( IOException ioe ) { \nthrow new SendError ( res . SC_BAD_REQUEST , ioe ) ; \n} \nreturn ; \n} \n} \n"}
{"4312": "public class NcMLGWriter { \npublic void writeXML ( NetcdfDataset ncd , OutputStream os , boolean showCoords , String uri ) throws IOException { \nXMLOutputter fmt = new XMLOutputter ( Format . getPrettyFormat ( ) ) ; \nfmt . output ( makeDocument ( ncd , showCoords , uri ) , os ) ; \nreturn ; \n} \n} \n"}
{"4333": "public class GridServiceProvider { \nstatic public void setDebugFlags ( ucar . nc2 . util . DebugFlags debugFlag ) { \ndebugOpen = debugFlag . isSet ( \"Grid/open\" ) ; \ndebugMissing = debugFlag . isSet ( \"Grid/missing\" ) ; \ndebugMissingDetails = debugFlag . isSet ( \"Grid/missingDetails\" ) ; \ndebugProj = debugFlag . isSet ( \"Grid/projection\" ) ; \ndebugVert = debugFlag . isSet ( \"Grid/vertical\" ) ; \ndebugTiming = debugFlag . isSet ( \"Grid/timing\" ) ; \nreturn ; \n} \n} \n"}
{"4334": "public class GridServiceProvider { \nstatic public void setExtendIndex ( boolean b ) { \nindexFileModeOnOpen = b ? IndexExtendMode . extendwrite : IndexExtendMode . readonly ; \nindexFileModeOnSync = b ? IndexExtendMode . extendwrite : IndexExtendMode . readonly ; \nreturn ; \n} \n} \n"}
{"4335": "public class GridServiceProvider { \nprivate void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nGridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; \nint nx = hsys . getNx ( ) ; \nGridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; \nif ( record == null ) { \nAttribute att = v2 . findAttribute ( \"missing_value\" ) ; \nfloat missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; \nint xyCount = yRange . length ( ) * xRange . length ( ) ; \nfor ( int j = 0 ; \nj < xyCount ; \nj ++ ) { \nii . setFloatNext ( missing_value ) ; \n} \nreturn ; \n} \nfloat [ ] data = _readData ( record ) ; \nif ( data == null ) { \n_readData ( record ) ; \nreturn ; \n} \nfor ( int y : yRange ) { \nfor ( int x : xRange ) { \nint index = y * nx + x ; \nii . setFloatNext ( data [ index ] ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \nfor ( int i = 0 ; \ni < nelems ; \ni ++ ) { \nsequenceOffset [ i ] = total ; \ntotal += sequenceLen [ i ] ; \n} \nsdata = new StructureData [ nelems ] ; \nfor ( int i = 0 ; \ni < nelems ; \ni ++ ) sdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \nreturn ; \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( tabStop > len ) { \nsbuff . setLength ( tabStop ) ; \nfor ( int i = len ; \ni < tabStop ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \n} \nelse if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \nreturn ; \n} \n} \n"}
{"4344": "public class Format { \nprivate static void show ( double d , int sigfig ) { \nSystem . out . println ( \"Format.d(\" + d + \",\" + sigfig + \") == \" + Format . d ( d , sigfig ) ) ; \nreturn ; \n} \n} \n"}
{"4345": "public class Format { \nprivate static void show2 ( double d , int dec_places ) { \nSystem . out . println ( \"Format.dfrac(\" + d + \",\" + dec_places + \") == \" + Format . dfrac ( d , dec_places ) ) ; \nreturn ; \n} \n} \n"}
{"4351": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { \nint savepos = buf0 . position ( ) ; \nint limit0 = buf0 . limit ( ) ; \nint skipcount = 0 ; \nif ( limit0 > MAXLIMIT ) limit0 = MAXLIMIT ; \nif ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; \nif ( skipdmr ) { \nByteOrder saveorder = buf0 . order ( ) ; \nbuf0 . order ( ByteOrder . BIG_ENDIAN ) ; \nskipcount = buf0 . getInt ( ) ; \nbuf0 . order ( saveorder ) ; \nskipcount &= 0xFFFFFF ; \nskipcount += 4 ; \n} \nbyte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . position ( savepos + skipcount ) ; \nbuf0 . get ( bytes , 0 , limit0 - skipcount ) ; \nbuf0 . position ( savepos ) ; \nSystem . err . println ( \"order=\" + buf0 . order ( ) ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \ndumpbytes ( buf ) ; \nreturn ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4361": "public class AttributeContainerHelper { \n@ Override public void addAll ( Iterable < Attribute > atts ) { \nfor ( Attribute att : atts ) addAttribute ( att ) ; \nreturn ; \n} \n} \n"}
{"4365": "public class ActionCoordinator { \npublic void addActionSourceListener ( ActionSourceListener l ) { \nif ( ! eventType . equals ( l . getEventTypeName ( ) ) ) throw new IllegalArgumentException ( \"ActionCoordinator: tried to add ActionSourceListener for wrong kind of Action \" + eventType + \" != \" + l . getEventTypeName ( ) ) ; \nlm . addListener ( l ) ; \nl . addActionValueListener ( this ) ; \nreturn ; \n} \n} \n"}
{"4374": "public class GridHorizCoordSys { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile ) { \nif ( isLatLon ) { \nncfile . addDimension ( g , new Dimension ( \"lat\" , gds . getInt ( GridDefRecord . NY ) , true ) ) ; \nncfile . addDimension ( g , new Dimension ( \"lon\" , gds . getInt ( GridDefRecord . NX ) , true ) ) ; \n} \nelse { \nncfile . addDimension ( g , new Dimension ( \"y\" , gds . getInt ( GridDefRecord . NY ) , true ) ) ; \nncfile . addDimension ( g , new Dimension ( \"x\" , gds . getInt ( GridDefRecord . NX ) , true ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4377": "public class GridHorizCoordSys { \nprivate void addGDSparams ( Variable v ) { \nList < String > keyList = new ArrayList < > ( gds . getKeys ( ) ) ; \nCollections . sort ( keyList ) ; \nString pre = getGDSprefix ( ) ; \nfor ( String key : keyList ) { \nString name = pre + \"_param_\" + key ; \nString vals = gds . getParam ( key ) ; \ntry { \nint vali = Integer . parseInt ( vals ) ; \nif ( key . equals ( GridDefRecord . VECTOR_COMPONENT_FLAG ) ) { \nString cf = GridCF . VectorComponentFlag . of ( vali ) ; \nv . addAttribute ( new Attribute ( name , cf ) ) ; \n} \nelse { \nv . addAttribute ( new Attribute ( name , vali ) ) ; \n} \n} \ncatch ( Exception e ) { \ntry { \ndouble vald = Double . parseDouble ( vals ) ; \nv . addAttribute ( new Attribute ( name , vald ) ) ; \n} \ncatch ( Exception e2 ) { \nv . addAttribute ( new Attribute ( name , vals ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4378": "public class GridHorizCoordSys { \nprivate void addCoordSystemVariable ( NetcdfFile ncfile , String name , String dims ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , new char [ ] { \n'0' } \n) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( isLatLon ( ) ) v . addAttribute ( new Attribute ( _Coordinate . Transforms , \"\" ) ) ; \nelse v . addAttribute ( new Attribute ( _Coordinate . Transforms , getGridName ( ) ) ) ; \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \nreturn ; \n} \n} \n"}
{"4379": "public class GridHorizCoordSys { \nprivate void makeLC ( ) { \nproj = new LambertConformal ( gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LOV ) , gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) ) ; \nLatLonPointImpl startLL = new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nif ( GridServiceProvider . debugProj ) { \nSystem . out . println ( \"GridHorizCoordSys.makeLC start at latlon \" + startLL ) ; \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeLC end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + getNx ( ) * getDxInKm ( ) ; \ndouble endy = starty + getNy ( ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"lambert_conformal_conic\" ) ) ; \nif ( gds . getDouble ( GridDefRecord . LATIN1 ) == gds . getDouble ( GridDefRecord . LATIN2 ) ) { \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \nelse { \ndouble [ ] data = new double [ ] { \ngds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) } \n; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Array . factory ( DataType . DOUBLE , new int [ ] { \n2 } \n, data ) ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_CENTRAL_MERIDIAN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \nreturn ; \n} \n} \n"}
{"4380": "public class GridHorizCoordSys { \nprivate void makePS ( ) { \nString nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; \ndouble latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( \"true\" ) ) ? 90.0 : - 90.0 ; \ndouble scale ; \ndouble lad = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( lad ) ) { \nscale = .933 ; \n} \nelse { \nscale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; \n} \nproj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nif ( GridServiceProvider . debugProj ) { \nSystem . out . printf ( \"starting proj coord %s lat/lon %s%n\" , start , proj . projToLatLon ( start ) ) ; \nSystem . out . println ( \"   should be LA1=\" + gds . getDouble ( GridDefRecord . LA1 ) + \" l)1=\" + gds . getDouble ( GridDefRecord . LO1 ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"polar_stereographic\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; \nreturn ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo2 < Lo1 ) Lo2 += 360 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMercator: end at latlon= \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   start at proj coord \" + new ProjectionPointImpl ( startx , starty ) ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \nreturn ; \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nint ny = gds . getInt ( GridDefRecord . NY ) ; \nint x_off = gds . getInt ( GridDefRecord . XP ) ; \nint y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( dy < 2100 ) { \ndx = 1207 ; \ndy = 1203 ; \n} \nelse { \ndx = 3622 ; \ndy = 3610 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \nreturn ; \n} \n} \n"}
{"4383": "public class GridHorizCoordSys { \nprivate void setDxDy ( double startx , double starty , ProjectionImpl proj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nif ( Double . isNaN ( Lo2 ) || Double . isNaN ( La2 ) ) { \nreturn ; \n} \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nProjectionPointImpl end = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \ndouble dx = Math . abs ( end . getX ( ) - startx ) / ( gds . getInt ( GridDefRecord . NX ) - 1 ) ; \ndouble dy = Math . abs ( end . getY ( ) - starty ) / ( gds . getInt ( GridDefRecord . NY ) - 1 ) ; \ngds . addParam ( GridDefRecord . DX , String . valueOf ( dx ) ) ; \ngds . addParam ( GridDefRecord . DY , String . valueOf ( dy ) ) ; \ngds . addParam ( GridDefRecord . GRID_UNITS , \"km\" ) ; \nreturn ; \n} \n} \n"}
{"4389": "public class DummySink { \npublic void write ( byte [ ] b , int off , int len ) throws IOException { \ncount += len ; \nsuper . write ( b , off , len ) ; \nreturn ; \n} \n} \n"}
{"4390": "public class BaseType { \n@ Override public void setClearName ( String clearname ) { \nsuper . setClearName ( clearname ) ; \nif ( _attr != null ) _attr . setClearName ( clearname ) ; \nif ( _attrTbl != null ) _attrTbl . setClearName ( clearname ) ; \nreturn ; \n} \n} \n"}
{"4397": "public class AWIPSConvention { \nprivate void createNewVariables ( NetcdfDataset ds , Variable ncVar , List < Dimension > newDims , Dimension levelDim ) throws InvalidRangeException { \nList < Dimension > dims = ncVar . getDimensions ( ) ; \nint newDimIndex = dims . indexOf ( levelDim ) ; \nint [ ] origin = new int [ ncVar . getRank ( ) ] ; \nint [ ] shape = ncVar . getShape ( ) ; \nint count = 0 ; \nfor ( Dimension dim : newDims ) { \nString name = ncVar . getShortName ( ) + \"-\" + dim . getShortName ( ) ; \norigin [ newDimIndex ] = count ; \nshape [ newDimIndex ] = dim . getLength ( ) ; \nVariable varNew = ncVar . section ( new Section ( origin , shape ) ) ; \nvarNew . setName ( name ) ; \nvarNew . setDimension ( newDimIndex , dim ) ; \nString long_name = ds . findAttValueIgnoreCase ( ncVar , CDM . LONG_NAME , ncVar . getShortName ( ) ) ; \nlong_name = long_name + \"-\" + dim . getShortName ( ) ; \nds . addVariableAttribute ( varNew , new Attribute ( CDM . LONG_NAME , long_name ) ) ; \nds . addVariable ( null , varNew ) ; \nparseInfo . format ( \"Created New Variable as section = \" ) ; \nvarNew . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \ncount += dim . getLength ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4400": "public class GribToNetcdfWriter { \npublic static void main ( String [ ] args ) { \nString fileIn = ( args . length > 0 ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib2/LMPEF_CLM_050518_1200.grb\" ; \nString fileOut = ( args . length > 1 ) ? args [ 1 ] : \"C:/tmp/ds.mint.bi\" ; \ntry ( GribToNetcdfWriter writer = new GribToNetcdfWriter ( fileIn , fileOut ) ) { \nwriter . write ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4403": "public class NetcdfDataset { \npublic void clearCoordinateSystems ( ) { \ncoordSys = new ArrayList < > ( ) ; \ncoordAxes = new ArrayList < > ( ) ; \ncoordTransforms = new ArrayList < > ( ) ; \nfor ( Variable v : getVariables ( ) ) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nve . clearCoordinateSystems ( ) ; \n} \nenhanceMode . remove ( Enhance . CoordSystems ) ; \nreturn ; \n} \n} \n"}
{"4409": "public class NetcdfDataset { \npublic void setValues ( Variable v , int npts , double start , double incr ) { \nif ( npts != v . getSize ( ) ) throw new IllegalArgumentException ( \"bad npts = \" + npts + \" should be \" + v . getSize ( ) ) ; \nArray data = Array . makeArray ( v . getDataType ( ) , npts , start , incr ) ; \nif ( v . getRank ( ) != 1 ) data = data . reshape ( v . getShape ( ) ) ; \nv . setCachedData ( data , true ) ; \nreturn ; \n} \n} \n"}
{"4410": "public class NetcdfDataset { \npublic void setValues ( Variable v , List < String > values ) throws IllegalArgumentException { \nArray data = Array . makeArray ( v . getDataType ( ) , values ) ; \nif ( data . getSize ( ) != v . getSize ( ) ) throw new IllegalArgumentException ( \"Incorrect number of values specified for the Variable \" + v . getFullName ( ) + \" needed= \" + v . getSize ( ) + \" given=\" + data . getSize ( ) ) ; \nif ( v . getRank ( ) != 1 ) data = data . reshape ( v . getShape ( ) ) ; \nv . setCachedData ( data , true ) ; \nreturn ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) return ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nd [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \n} \nreturn ; \n} \n} \n"}
{"4416": "public class ThreddsMetadata { \npublic void add ( ThreddsMetadata tmd , boolean includeInherited ) { \ncreators . addAll ( tmd . getCreators ( ) ) ; \ncontributors . addAll ( tmd . getContributors ( ) ) ; \ndates . addAll ( tmd . getDates ( ) ) ; \ndocs . addAll ( tmd . getDocumentation ( ) ) ; \nkeywords . addAll ( tmd . getKeywords ( ) ) ; \nprojects . addAll ( tmd . getProjects ( ) ) ; \nproperties . addAll ( tmd . getProperties ( ) ) ; \npublishers . addAll ( tmd . getPublishers ( ) ) ; \nvariables . addAll ( tmd . getVariables ( ) ) ; \nif ( includeInherited ) metadata . addAll ( tmd . getMetadata ( ) ) ; \nelse { \nfor ( InvMetadata mdata : tmd . getMetadata ( ) ) { \nif ( ! mdata . isInherited ( ) ) metadata . add ( mdata ) ; \n} \n} \nif ( gc == null ) gc = tmd . getGeospatialCoverage ( ) ; \nif ( timeCoverage == null ) timeCoverage = tmd . getTimeCoverage ( ) ; \nif ( serviceName == null ) serviceName = tmd . getServiceName ( ) ; \nif ( dataType == null ) dataType = tmd . getDataType ( ) ; \nif ( dataSize == 0.0 ) dataSize = tmd . getDataSize ( ) ; \nif ( dataFormat == null ) dataFormat = tmd . getDataFormatType ( ) ; \nif ( authorityName == null ) authorityName = tmd . getAuthority ( ) ; \nif ( variableMapLink == null ) variableMapLink = tmd . getVariableMap ( ) ; \nreturn ; \n} \n} \n"}
{"4417": "public class ThreddsMetadata { \npublic void addDocumentation ( String type , String content ) { \nif ( content == null ) { \nremoveDocumentation ( type ) ; \nreturn ; \n} \ncontent = content . trim ( ) ; \nfor ( InvDocumentation doc : getDocumentation ( ) ) { \nString dtype = doc . getType ( ) ; \nif ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) { \ndoc . setInlineContent ( content ) ; \nreturn ; \n} \n} \nif ( content . length ( ) > 0 ) addDocumentation ( new InvDocumentation ( null , null , null , type , content ) ) ; \nreturn ; \n} \n} \n"}
{"4418": "public class ThreddsMetadata { \npublic void removeDocumentation ( String type ) { \nIterator iter = docs . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDocumentation doc = ( InvDocumentation ) iter . next ( ) ; \nString dtype = doc . getType ( ) ; \nif ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) iter . remove ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4421": "public class CollectionManagerCatalog { \n@ Override public void getDataset ( Dataset ds , Object context ) { \nif ( ds . hasAccess ( ) ) { \nDataFactory tdataFactory = new DataFactory ( ) ; \nAccess access = tdataFactory . chooseDatasetAccess ( ds . getAccess ( ) ) ; \nif ( access == null ) throw new IllegalStateException ( ) ; \nMFileRemote mfile = new MFileRemote ( access ) ; \nif ( mfile . getPath ( ) . endsWith ( \".xml\" ) ) return ; \nmfiles . add ( mfile ) ; \nif ( debug ) System . out . format ( \"add %s %n\" , mfile . getPath ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4424": "public class CoordSysBuilder { \n@ Override public void buildCoordinateSystems ( NetcdfDataset ncDataset ) { \nparseInfo . format ( \"Parsing with Convention = %s%n\" , conventionName ) ; \naddVariables ( ncDataset , ncDataset . getVariables ( ) , varList ) ; \nfindCoordinateAxes ( ncDataset ) ; \nfindCoordinateSystems ( ncDataset ) ; \nfindCoordinateTransforms ( ncDataset ) ; \nmakeCoordinateAxes ( ncDataset ) ; \nmakeCoordinateSystems ( ncDataset ) ; \nassignCoordinateSystemsExplicit ( ncDataset ) ; \nmakeCoordinateSystemsImplicit ( ncDataset ) ; \nif ( useMaximalCoordSys ) makeCoordinateSystemsMaximal ( ncDataset ) ; \nmakeCoordinateTransforms ( ncDataset ) ; \nassignCoordinateTransforms ( ncDataset ) ; \nif ( debug ) System . out . println ( \"parseInfo = \\n\" + parseInfo . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"4425": "public class CoordSysBuilder { \nprotected void findCoordinateAxes ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordAxes != null ) findCoordinateAxes ( vp , vp . coordAxes ) ; \nif ( vp . coordinates != null ) findCoordinateAxes ( vp , vp . coordinates ) ; \n} \nreturn ; \n} \n} \n"}
{"4426": "public class CoordSysBuilder { \nprotected void findCoordinateSystems ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordSys != null ) { \nStringTokenizer stoker = new StringTokenizer ( vp . coordSys ) ; \nwhile ( stoker . hasMoreTokens ( ) ) { \nString vname = stoker . nextToken ( ) ; \nVarProcess ap = findVarProcess ( vname , vp ) ; \nif ( ap != null ) { \nif ( ! ap . isCoordinateSystem ) parseInfo . format ( \" CoordinateSystem = %s added; referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nap . isCoordinateSystem = true ; \n} \nelse { \nparseInfo . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \nuserAdvice . format ( \"***Cant find coordSystem %s referenced from var= %s%n\" , vname , vp . v . getFullName ( ) ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4427": "public class CoordSysBuilder { \nprotected void makeCoordinateSystems ( NetcdfDataset ncDataset ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . isCoordinateSystem ) { \nvp . makeCoordinateSystem ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4428": "public class CoordSysBuilder { \nprotected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { \nboolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; \nfor ( VarProcess vp : varList ) { \nVariableEnhanced ve = ( VariableEnhanced ) vp . v ; \nif ( vp . hasCoordinateSystem ( ) || ! vp . isData ( ) ) continue ; \nList < CoordinateAxis > axisList = new ArrayList < > ( ) ; \nList < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; \nfor ( CoordinateAxis axis : axes ) { \nif ( isCoordinateAxisForVariable ( axis , ve ) ) axisList . add ( axis ) ; \n} \nif ( axisList . size ( ) < 2 ) continue ; \nString csName = CoordinateSystem . makeName ( axisList ) ; \nCoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; \nboolean okToBuild = false ; \nif ( requireCompleteCoordSys ) { \nif ( cs != null ) { \nokToBuild = cs . isComplete ( ve ) ; \n} \n} \nelse { \nokToBuild = true ; \n} \nif ( cs != null && okToBuild ) { \nve . addCoordinateSystem ( cs ) ; \nparseInfo . format ( \" assigned maximal CoordSystem '%s' for var= %s%n\" , cs . getName ( ) , ve . getFullName ( ) ) ; \n} \nelse { \nCoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; \nif ( requireCompleteCoordSys ) { \nokToBuild = csnew . isComplete ( ve ) ; \n} \nif ( okToBuild ) { \ncsnew . setImplicit ( true ) ; \nve . addCoordinateSystem ( csnew ) ; \nncDataset . addCoordinateSystem ( csnew ) ; \nparseInfo . format ( \" created maximal CoordSystem '%s' for var= %s%n\" , csnew . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4430": "public class CoordSysBuilder { \nprotected void addCoordinateVariable ( Dimension dim , VarProcess vp ) { \nList < VarProcess > list = coordVarMap . get ( dim ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \ncoordVarMap . put ( dim , list ) ; \n} \nif ( ! list . contains ( vp ) ) list . add ( vp ) ; \nreturn ; \n} \n} \n"}
{"4431": "public class InvCatalogImpl { \npublic void subset ( InvDataset ds ) { \nInvDatasetImpl dataset = ( InvDatasetImpl ) ds ; \ndataset . transferMetadata ( dataset , true ) ; \ntopDataset = dataset ; \ndatasets . clear ( ) ; \ndatasets . add ( topDataset ) ; \ndataset . dataType = dataset . getDataType ( ) ; \ndataset . setCatalog ( this ) ; \ndataset . parent = null ; \nList < InvService > services = new ArrayList < InvService > ( dataset . getServicesLocal ( ) ) ; \nfindServices ( services , dataset ) ; \ndataset . setServicesLocal ( services ) ; \nfinish ( ) ; \nreturn ; \n} \n} \n"}
{"4432": "public class InvCatalogImpl { \npublic void filter ( DatasetFilter filter ) { \nmark ( filter , topDataset ) ; \ndelete ( topDataset ) ; \nthis . filter = filter ; \nreturn ; \n} \n} \n"}
{"4434": "public class InvCatalogImpl { \nprivate void delete ( InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return ; \n} \nIterator iter = ds . getDatasets ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDatasetImpl nested = ( InvDatasetImpl ) iter . next ( ) ; \nif ( nested . getMark ( ) ) { \niter . remove ( ) ; \nif ( debugFilter ) System . out . println ( \" remove \" + nested . getName ( ) ) ; \n} \nelse delete ( nested ) ; \n} \nreturn ; \n} \n} \n"}
{"4435": "public class LoadCommon { \npublic void initOnce ( HttpServletRequest req ) throws SendError { \nif ( once ) return ; \nonce = true ; \nlog . info ( getClass ( ) . getName ( ) + \" GET initialization\" ) ; \nif ( this . tdsContext == null ) throw new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , \"Cannot find TDS Context\" ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( req . getServerName ( ) ) ; \nint port = req . getServerPort ( ) ; \nif ( port > 0 ) { \nbuf . append ( \":\" ) ; \nbuf . append ( port ) ; \n} \nthis . server = buf . toString ( ) ; \nString tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; \nthis . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \ntmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; \nthis . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \nif ( this . threddsname == null ) this . threddsname = DEFAULTSERVLETNAME ; \nFile updir = tdsContext . getUploadDir ( ) ; \nif ( updir == null ) { \nlog . warn ( \"No tds.upload.dir specified\" ) ; \nthis . uploaddir = null ; \n} \nelse this . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; \nFile downdir = tdsContext . getDownloadDir ( ) ; \nif ( downdir == null ) { \nlog . warn ( \"No tds.download.dir specified\" ) ; \nthis . downloaddir = null ; \n} \nelse this . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; \nreturn ; \n} \n} \n"}
{"4437": "public class StandardPrefixDB { \nprivate void add ( final String name , final String symbol , final double definition ) throws PrefixExistsException { \naddName ( name , definition ) ; \naddSymbol ( symbol , definition ) ; \nreturn ; \n} \n} \n"}
{"4441": "public class Dap4ParserImpl { \nvoid passReserved ( XMLAttributeMap map , DapNode node ) throws ParseException { \ntry { \nDapAttribute attr = null ; \nfor ( Map . Entry < String , SaxEvent > entry : map . entrySet ( ) ) { \nSaxEvent event = entry . getValue ( ) ; \nString key = entry . getKey ( ) ; \nString value = event . value ; \nif ( isReserved ( key ) ) node . addXMLAttribute ( key , value ) ; \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \nreturn ; \n} \n} \n"}
{"4444": "public class DSPRegistry { \nsynchronized public void register ( String className , boolean last ) throws DapException { \ntry { \nClass < ? extends DSP > klass = ( Class < ? extends DSP > ) loader . loadClass ( className ) ; \nregister ( klass , last ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new DapException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"4445": "public class DSPRegistry { \nsynchronized public void register ( Class < ? extends DSP > klass , boolean last ) { \nif ( registered ( klass ) ) return ; \nif ( last ) registry . add ( new Registration ( klass ) ) ; \nelse registry . add ( 0 , new Registration ( klass ) ) ; \nreturn ; \n} \n} \n"}
{"4447": "public class DSPRegistry { \nsynchronized public void unregister ( Class < ? extends DSP > klass ) { \nfor ( int i = 0 ; \ni < registry . size ( ) ; \ni ++ ) { \nif ( registry . get ( i ) . dspclass == klass ) { \nregistry . remove ( i ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) return ; \nif ( this . ce == null ) this . visiblenodes = nodelist ; \nelse { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \nfor ( int i = 0 ; \ni < nodelist . size ( ) ; \ni ++ ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) visiblenodes . add ( node ) ; \n} \n} \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \nreturn ; \n} \n} \n"}
{"4453": "public class DapDataset { \npublic void sort ( ) { \nList < DapNode > sorted = new ArrayList < DapNode > ( ) ; \nsortR ( this , sorted ) ; \nfor ( int i = 0 ; \ni < sorted . size ( ) ; \ni ++ ) { \nsorted . get ( i ) . setIndex ( i ) ; \n} \nthis . nodelist = sorted ; \nreturn ; \n} \n} \n"}
{"4470": "public class PopupMenu { \npublic void addAction ( String menuName , Action act ) { \nact . putValue ( Action . NAME , menuName ) ; \nsuper . add ( act ) ; \nreturn ; \n} \n} \n"}
{"4472": "public class ProjectionManager { \npublic static void main ( String [ ] args ) { \nProjectionManager d = new ProjectionManager ( null , null ) ; \nd . setVisible ( ) ; \nreturn ; \n} \n} \n"}
{"4474": "public class PictureCache { \npublic static synchronized void add ( URL url , SourcePicture sp ) { \nTools . log ( \"PictureCache.add: \" + url . toString ( ) ) ; \nif ( sp . getSourceBufferedImage ( ) == null ) { \nTools . log ( \"PictureCache.add: invoked with a null picture! Not cached!\" ) ; \nreturn ; \n} \nif ( ( maxCache < 1 ) ) { \nTools . log ( \"PictureCache.add: cache is diabled. Not adding picture.\" ) ; \nreturn ; \n} \nif ( isInCache ( url ) ) { \nTools . log ( \"Picture \" + url . toString ( ) + \" is already in the cache. Not adding again.\" ) ; \nreturn ; \n} \nif ( pictureCache . size ( ) >= maxCache ) removeLeastPopular ( ) ; \nif ( pictureCache . size ( ) < maxCache ) pictureCache . put ( url . toString ( ) , sp ) ; \nreturn ; \n} \n} \n"}
{"4475": "public class PictureCache { \npublic static synchronized void reportCache ( ) { \nTools . log ( \"   PictureCache.reportCache: cache contains: \" + Integer . toString ( pictureCache . size ( ) ) + \" max: \" + Integer . toString ( maxCache ) ) ; \nEnumeration e = pictureCache . keys ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nTools . log ( \"   Cache contains: \" + ( ( String ) e . nextElement ( ) ) ) ; \n} \nTools . log ( \"  End of cache contents\" ) ; \nreturn ; \n} \n} \n"}
{"4476": "public class PictureCache { \npublic static void stopBackgroundLoading ( ) { \nEnumeration e = cacheLoadsInProgress . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \n( ( SourcePicture ) e . nextElement ( ) ) . stopLoading ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4484": "public class NexradStationDB { \nprivate static void readStationTable ( ) throws IOException { \nstationTableHash = new HashMap < String , Station > ( ) ; \nClassLoader cl = Level2VolumeScan . class . getClassLoader ( ) ; \nInputStream is = cl . getResourceAsStream ( \"resources/nj22/tables/nexrad.tbl\" ) ; \nList < TableParser . Record > recs = TableParser . readTable ( is , \"3,15,46, 54,60d,67d,73d\" , 50000 ) ; \nfor ( TableParser . Record record : recs ) { \nStation s = new Station ( ) ; \ns . id = \"K\" + record . get ( 0 ) ; \ns . name = record . get ( 2 ) + \" \" + record . get ( 3 ) ; \ns . lat = ( Double ) record . get ( 4 ) * .01 ; \ns . lon = ( Double ) record . get ( 5 ) * .01 ; \ns . elev = ( Double ) record . get ( 6 ) ; \nstationTableHash . put ( s . id , s ) ; \nif ( showStations ) System . out . println ( \" station= \" + s ) ; \n} \nreturn ; \n} \n} \n"}
{"4486": "public class TypedDatasetImpl { \nprotected void removeDataVariable ( String varName ) { \nIterator iter = dataVariables . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nVariableSimpleIF v = ( VariableSimpleIF ) iter . next ( ) ; \nif ( v . getShortName ( ) . equals ( varName ) ) iter . remove ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4489": "public class ColorScale { \npublic void setNumColors ( int n ) { \nif ( n != ncolors ) { \ncolors = new Color [ n ] ; \nint prevn = Math . min ( ncolors , n ) ; \nSystem . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; \nfor ( int i = ncolors ; \ni < n ; \ni ++ ) colors [ i ] = Color . white ; \nuseColors = colors ; \nncolors = n ; \nedge = new double [ ncolors ] ; \nhist = new int [ ncolors + 1 ] ; \n} \nreturn ; \n} \n} \n"}
{"4492": "public class GridIndex { \npublic void finish ( ) { \nif ( gcs . size ( ) == 1 ) return ; \nif ( gcs . size ( ) == 2 ) { \nList hcs = getHorizCoordSys ( ) ; \nGridDefRecord . compare ( ( GridDefRecord ) hcs . get ( 0 ) , ( GridDefRecord ) hcs . get ( 1 ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4498": "public class CatGenConfigMetadataFactory { \npublic void addMetadataContent ( org . jdom2 . Element mdataJdomElement , Object contentObject ) { \nArrayList catGenConfigList = ( ArrayList ) contentObject ; \nIterator iter = catGenConfigList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCatalogGenConfig cgc = ( CatalogGenConfig ) iter . next ( ) ; \nmdataJdomElement . addContent ( createCatGenConfigElement ( cgc ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4511": "public class Debug { \nstatic public void constructMenu ( JMenu topMenu ) { \nif ( debug ) System . out . println ( \"Debug.constructMenu \" ) ; \nif ( topMenu . getItemCount ( ) > 0 ) topMenu . removeAll ( ) ; \ntry { \naddToMenu ( topMenu , store ) ; \n} \ncatch ( BackingStoreException e ) { \n} \ntopMenu . revalidate ( ) ; \nreturn ; \n} \n} \n"}
{"4512": "public class Debug { \nstatic private void addToMenu ( JMenu menu , Preferences prefs ) throws BackingStoreException { \nif ( debug ) System . out . println ( \" addMenu \" + prefs . name ( ) ) ; \nString [ ] keys = prefs . keys ( ) ; \nfor ( String key : keys ) { \nboolean bval = prefs . getBoolean ( key , false ) ; \nString fullname = prefs . absolutePath ( ) + \"/\" + key ; \nmenu . add ( new DebugMenuItem ( fullname , key , bval ) ) ; \nif ( debug ) System . out . println ( \"   leaf= <\" + key + \"><\" + fullname + \">\" ) ; \n} \nString [ ] kidName = prefs . childrenNames ( ) ; \nfor ( String aKidName : kidName ) { \nPreferences pkid = prefs . node ( aKidName ) ; \nJMenu subMenu = new JMenu ( pkid . name ( ) ) ; \nmenu . add ( subMenu ) ; \naddToMenu ( subMenu , pkid ) ; \n} \nreturn ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) { \nthrow new IOException ( \"Unable to open \" + tbl ) ; \n} \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) { \ncontinue ; \n} \nif ( tline . startsWith ( \"!\" ) ) { \ncontinue ; \n} \nString [ ] words = new String [ indices . length ] ; \nfor ( int idx = 0 ; \nidx < indices . length ; \nidx ++ ) { \nif ( indices [ idx ] >= tline . length ( ) ) { \ncontinue ; \n} \nif ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) { \nwords [ idx ] = line . substring ( indices [ idx ] ) ; \n} \nelse { \nwords [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \n} \nwords [ idx ] = words [ idx ] . trim ( ) ; \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) { \nif ( p . getName ( ) . contains ( \"(\" ) ) { \ntemplateParamMap . put ( p . getName ( ) , p ) ; \n} \nelse { \nparamMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4519": "public class RecordDatasetHelper { \npublic void setStationInfo ( String stnIdVName , String stnDescVName ) { \nthis . stnIdVName = stnIdVName ; \nthis . stnDescVName = stnDescVName ; \nVariable stationVar = ncfile . findVariable ( stnIdVName ) ; \nstationIdType = stationVar . getDataType ( ) ; \nreturn ; \n} \n} \n"}
{"4521": "public class Field { \nstatic private void showFormatInfo ( JFormattedTextField tf ) { \nJFormattedTextField . AbstractFormatter ff = tf . getFormatter ( ) ; \nSystem . out . println ( \"AbstractFormatter  \" + ff . getClass ( ) . getName ( ) ) ; \nif ( ff instanceof NumberFormatter ) { \nNumberFormatter nf = ( NumberFormatter ) ff ; \nFormat f = nf . getFormat ( ) ; \nSystem . out . println ( \" Format  = \" + f . getClass ( ) . getName ( ) ) ; \nif ( f instanceof NumberFormat ) { \nNumberFormat nfat = ( NumberFormat ) f ; \nSystem . out . println ( \" getMinimumIntegerDigits=\" + nfat . getMinimumIntegerDigits ( ) ) ; \nSystem . out . println ( \" getMaximumIntegerDigits=\" + nfat . getMaximumIntegerDigits ( ) ) ; \nSystem . out . println ( \" getMinimumFractionDigits=\" + nfat . getMinimumFractionDigits ( ) ) ; \nSystem . out . println ( \" getMaximumFractionDigits=\" + nfat . getMaximumFractionDigits ( ) ) ; \n} \nif ( f instanceof DecimalFormat ) { \nDecimalFormat df = ( DecimalFormat ) f ; \nSystem . out . println ( \" Pattern  = \" + df . toPattern ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4523": "public class NCdumpPanel { \npublic void setNetcdfFile ( NetcdfFile ncf ) { \nthis . ncfile = ncf ; \nthis . filename = ncf . getLocation ( ) ; \nfinal GetDataRunnable runner = new GetDataRunnable ( ) { \npublic void run ( Object o ) throws IOException { \nfinal StringWriter sw = new StringWriter ( 50000 ) ; \nNCdumpW . print ( ncfile , command , sw , task ) ; \nresult = sw . toString ( ) ; \nreturn ; \n} \n} \n; \ntask = new GetDataTask ( runner , filename , null ) ; \nstopButton . startProgressMonitorTask ( task ) ; \nreturn ; \n} \n} \n"}
{"4524": "public class DODSNetcdfFile { \nstatic public void setDebugFlags ( ucar . nc2 . util . DebugFlags debugFlag ) { \ndebugCE = debugFlag . isSet ( \"DODS/constraintExpression\" ) ; \ndebugServerCall = debugFlag . isSet ( \"DODS/serverCall\" ) ; \ndebugOpenResult = debugFlag . isSet ( \"DODS/debugOpenResult\" ) ; \ndebugDataResult = debugFlag . isSet ( \"DODS/debugDataResult\" ) ; \ndebugCharArray = debugFlag . isSet ( \"DODS/charArray\" ) ; \ndebugConstruct = debugFlag . isSet ( \"DODS/constructNetcdf\" ) ; \ndebugPreload = debugFlag . isSet ( \"DODS/preload\" ) ; \ndebugTime = debugFlag . isSet ( \"DODS/timeCalls\" ) ; \nshowNCfile = debugFlag . isSet ( \"DODS/showNCfile\" ) ; \ndebugAttributes = debugFlag . isSet ( \"DODS/attributes\" ) ; \ndebugCached = debugFlag . isSet ( \"DODS/cache\" ) ; \nreturn ; \n} \n} \n"}
{"4548": "public class GridEnsembleCoord { \npublic void addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nncfile . addDimension ( g , new Dimension ( getName ( ) , getNEnsembles ( ) , true ) ) ; \nreturn ; \n} \n} \n"}
{"4551": "public class Aggregation { \npublic void addExplicitDataset ( String cacheName , String location , String id , String ncoordS , String coordValueS , String sectionSpec , ucar . nc2 . util . cache . FileFactory reader ) { \nDataset nested = makeDataset ( cacheName , location , id , ncoordS , coordValueS , sectionSpec , null , reader ) ; \nexplicitDatasets . add ( nested ) ; \nreturn ; \n} \n} \n"}
{"4552": "public class Aggregation { \npublic void addDatasetScan ( Element crawlableDatasetElement , String dirName , String suffix , String regexpPatternString , String dateFormatMark , Set < NetcdfDataset . Enhance > enhanceMode , String subdirs , String olderThan ) { \ndatasetManager . addDirectoryScan ( dirName , suffix , regexpPatternString , subdirs , olderThan , enhanceMode ) ; \nthis . dateFormatMark = dateFormatMark ; \nif ( dateFormatMark != null ) { \nisDate = true ; \nif ( type == Type . joinExisting ) type = Type . joinExistingOne ; \nDateExtractor dateExtractor = new DateExtractorFromName ( dateFormatMark , true ) ; \ndatasetManager . setDateExtractor ( dateExtractor ) ; \n} \nreturn ; \n} \n} \n"}
{"4553": "public class Aggregation { \npublic void finish ( CancelTask cancelTask ) throws IOException { \ndatasetManager . scan ( true ) ; \ncacheDirty = true ; \nmakeDatasets ( cancelTask ) ; \nbuildNetcdfDataset ( cancelTask ) ; \nreturn ; \n} \n} \n"}
{"4554": "public class Aggregation { \nprotected void makeDatasets ( CancelTask cancelTask ) throws IOException { \ndatasets = new ArrayList < > ( ) ; \nfor ( MFile cd : datasetManager . getFilesSorted ( ) ) { \ndatasets . add ( makeDataset ( cd ) ) ; \n} \nCollections . sort ( datasets ) ; \nfor ( Aggregation . Dataset dataset : explicitDatasets ) { \ndatasets . add ( dataset ) ; \n} \nfor ( Iterator < Dataset > datasetsIter = datasets . iterator ( ) ; \ndatasetsIter . hasNext ( ) ; \n) { \nDataset dataset = datasetsIter . next ( ) ; \nPath datasetPath ; \nif ( dataset . getMFile ( ) instanceof MFileOS ) { \ndatasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; \n} \nelse if ( dataset . getMFile ( ) instanceof MFileOS7 ) { \ndatasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; \n} \nelse { \ncontinue ; \n} \nif ( ! Files . isReadable ( datasetPath ) ) { \nlogger . warn ( \"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath ) ; \ndatasetsIter . remove ( ) ; \n} \n} \nSet < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; \nfor ( Aggregation . Dataset dataset : datasets ) { \nif ( dset . contains ( dataset . cacheLocation ) ) logger . warn ( \"Duplicate dataset in aggregation = \" + dataset . cacheLocation ) ; \ndset . add ( dataset . cacheLocation ) ; \n} \nif ( datasets . size ( ) == 0 ) { \nthrow new IllegalStateException ( \"There are no datasets in the aggregation \" + datasetManager ) ; \n} \nreturn ; \n} \n} \n"}
{"4557": "public class DatasetTrackerInMem { \nvoid putResourceControl ( Dataset ds ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"putResourceControl \" + ds . getRestrictAccess ( ) + \" for \" + ds . getName ( ) ) ; \nresourceControlHash . put ( ds . getUrlPath ( ) , ds . getRestrictAccess ( ) ) ; \nhasResourceControl = true ; \nreturn ; \n} \n} \n"}
{"4558": "public class CFLine { \npublic void addPoint ( double x , double y ) { \nPoint ptPrev = null ; \nif ( points . size ( ) > 0 ) { \nptPrev = points . get ( points . size ( ) - 1 ) ; \n} \nthis . points . add ( new CFPoint ( x , y , ptPrev , null , null ) ) ; \nreturn ; \n} \n} \n"}
{"4563": "public class SortingStationPointFeatureCache { \npublic void addAll ( FeatureDatasetPoint fdPoint ) throws IOException { \ntry ( PointFeatureIterator pointFeatIter = new FlattenedDatasetPointCollection ( fdPoint ) . getPointFeatureIterator ( ) ) { \nwhile ( pointFeatIter . hasNext ( ) ) { \nStationPointFeature pointFeat = ( StationPointFeature ) pointFeatIter . next ( ) ; \nadd ( pointFeat ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4564": "public class CEEvaluator { \npublic void parseConstraint ( ReqState rs ) throws ParseException , opendap . dap . DAP2Exception , NoSuchVariableException , NoSuchFunctionException , InvalidOperatorException , InvalidParameterException , SBHException , WrongTypeException { \nparseConstraint ( rs . getConstraintExpression ( ) , rs . getRequestURL ( ) . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"4566": "public class CEEvaluator { \npublic void printConstraint ( PrintWriter pw ) { \nEnumeration ec = getClauses ( ) ; \nboolean first = true ; \nwhile ( ec . hasMoreElements ( ) ) { \nClause cl = ( Clause ) ec . nextElement ( ) ; \nif ( ! first ) pw . print ( \" & \" ) ; \ncl . printConstraint ( pw ) ; \nfirst = false ; \n} \npw . flush ( ) ; \nreturn ; \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) { \nreturn ; \n} \nIterator < Element > iter = values . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) { \niter . remove ( ) ; \n} \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) { \ndim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \n} \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) { \nlog . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4573": "public class ProjectionParamPanel { \npublic void setProjection ( ProjectionManager . ProjectionClass pc ) { \nremoveAll ( ) ; \nfor ( ProjectionManager . ProjectionParam pp : pc . paramList ) { \nJPanel thisPanel = new JPanel ( ) ; \nthisPanel . add ( new JLabel ( pp . name + \": \" ) ) ; \nJTextField tf = new JTextField ( ) ; \npp . setTextField ( tf ) ; \ntf . setColumns ( 12 ) ; \nthisPanel . add ( tf ) ; \nadd ( thisPanel ) ; \n} \nrevalidate ( ) ; \nreturn ; \n} \n} \n"}
{"4574": "public class LayoutM { \npublic void addLayoutComponent ( Component comp , Object constraint ) { \nif ( debug ) System . out . println ( name + \" addLayoutComponent= \" + comp . getClass ( ) . getName ( ) + \" \" + comp . hashCode ( ) + \" \" + constraint ) ; \nif ( ! ( constraint instanceof Constraint ) ) throw new IllegalArgumentException ( \"MySpringLayout must be Constraint\" ) ; \nconstraintMap . put ( comp , constraint ) ; \nglobalBounds = null ; \nreturn ; \n} \n} \n"}
{"4575": "public class LayoutM { \npublic void invalidateLayout ( Container target ) { \nif ( debug ) System . out . println ( name + \" invalidateLayout \" ) ; \nglobalBounds = null ; \nreturn ; \n} \n} \n"}
{"4576": "public class LayoutM { \npublic void removeLayoutComponent ( Component comp ) { \nif ( debug ) System . out . println ( \"removeLayoutComponent\" ) ; \nconstraintMap . remove ( comp ) ; \nglobalBounds = null ; \nreturn ; \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . println ( name + \" layoutContainer \" ) ; \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4581": "public class URLDumpPane { \nprivate void openURL ( String urlString , Command command ) { \ntry { \nURL u = new URL ( urlString ) ; \ncurrentConnection = ( HttpURLConnection ) u . openConnection ( ) ; \ncurrentConnection . setRequestMethod ( command . toString ( ) ) ; \ncurrentConnection . setAllowUserInteraction ( true ) ; \nclear ( ) ; \nappendLine ( command + \" request for \" + urlString ) ; \nMap < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; \nfor ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { \nappend ( \" \" + ent . getKey ( ) + \": \" ) ; \nfor ( String v : ent . getValue ( ) ) append ( v + \" \" ) ; \nappendLine ( \"\" ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"getFollowRedirects=\" + HttpURLConnection . getFollowRedirects ( ) ) ; \nappendLine ( \"getInstanceFollowRedirects=\" + currentConnection . getInstanceFollowRedirects ( ) ) ; \nappendLine ( \"AllowUserInteraction=\" + currentConnection . getAllowUserInteraction ( ) ) ; \nappendLine ( \"\" ) ; \nint code = currentConnection . getResponseCode ( ) ; \nString response = currentConnection . getResponseMessage ( ) ; \nappendLine ( \" HTTP/1.x \" + code + \" \" + response ) ; \nappendLine ( \" content-length: \" + currentConnection . getContentLength ( ) ) ; \nappendLine ( \" content-encoding: \" + currentConnection . getContentEncoding ( ) ) ; \nappendLine ( \" content-type: \" + currentConnection . getContentType ( ) ) ; \nappendLine ( \"\\nHeaders: \" ) ; \nfor ( int j = 1 ; \ntrue ; \nj ++ ) { \nString header = currentConnection . getHeaderField ( j ) ; \nString key = currentConnection . getHeaderFieldKey ( j ) ; \nif ( header == null || key == null ) break ; \nappendLine ( \" \" + key + \": \" + header ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"contents:\" ) ; \njava . io . InputStream is = currentConnection . getInputStream ( ) ; \nByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; \nIO . copy ( is , bout ) ; \nis . close ( ) ; \nappend ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; \nappendLine ( \"end contents\" ) ; \n} \ncatch ( MalformedURLException e ) { \nappend ( urlString + \" is not a parseable URL\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4587": "public class CoordinateTime2DUnionizer { \nvoid setRuntimeCoords ( CoordinateRuntime runtimes ) { \nfor ( int idx = 0 ; \nidx < runtimes . getSize ( ) ; \nidx ++ ) { \nCalendarDate cd = runtimes . getRuntimeDate ( idx ) ; \nlong runtime = runtimes . getRuntime ( idx ) ; \nCoordinateTimeAbstract time = timeMap . get ( runtime ) ; \nif ( time == null ) { \ntime = isTimeInterval ? new CoordinateTimeIntv ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) : new CoordinateTime ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) ; \ntimeMap . put ( runtime , time ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nwhile ( iterOne . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nint ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nwhile ( iter . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nint dcount = 0 ; \nint scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) dvals [ dcount ++ ] = data . nextDouble ( ) ; \n} \nelse if ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount ++ ] = data . getString ( ) ; \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \nreturn ; \n} \n} \n"}
{"4608": "public class GempakStationFileIOSP { \nprotected void addGlobalAttributes ( ) { \nncfile . addAttribute ( null , new Attribute ( CDM . CONVENTIONS , getConventions ( ) ) ) ; \nString fileType = \"GEMPAK \" + gemreader . getFileType ( ) ; \nncfile . addAttribute ( null , new Attribute ( \"file_format\" , fileType ) ) ; \nncfile . addAttribute ( null , new Attribute ( \"history\" , \"Direct read of \" + fileType + \" into NetCDF-Java API\" ) ) ; \nncfile . addAttribute ( null , new Attribute ( CF . FEATURE_TYPE , getCFFeatureType ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"4613": "public class CeParser { \nprivate void yy_reduce_print ( int yyrule , YYStack yystack ) { \nif ( yydebug == 0 ) return ; \nint yylno = yyrline_ [ yyrule ] ; \nint yynrhs = yyr2_ [ yyrule ] ; \nyycdebug ( \"Reducing stack by rule \" + ( yyrule - 1 ) + \" (line \" + yylno + \"), \" ) ; \nfor ( int yyi = 0 ; \nyyi < yynrhs ; \nyyi ++ ) yy_symbol_print ( \"   $\" + ( yyi + 1 ) + \" =\" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; \nreturn ; \n} \n} \n"}
{"4620": "public class DatasetConstructor { \nstatic private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { \nboolean unlimitedOK = true ; \ntransferGroupAttributes ( src , targetGroup ) ; \nfor ( Dimension d : src . getDimensions ( ) ) { \nif ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { \nDimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; \ntargetGroup . addDimension ( newd ) ; \n} \n} \nfor ( Variable v : src . getVariables ( ) ) { \nVariable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; \nVariableEnhanced targetVe = ( VariableEnhanced ) targetV ; \nboolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; \nif ( replace || ( null == targetV ) ) { \nif ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) { \nv = new StructureDS ( targetGroup , ( Structure ) v ) ; \n} \nelse if ( ! ( v instanceof VariableDS ) ) { \nv = new VariableDS ( targetGroup , v , false ) ; \n} \nif ( null != targetV ) targetGroup . remove ( targetV ) ; \ntargetGroup . addVariable ( v ) ; \nv . resetDimensions ( ) ; \n} \nelse if ( ! targetV . hasCachedData ( ) && ( targetVe . getOriginalVariable ( ) == null ) ) { \ntargetVe . setOriginalVariable ( v ) ; \n} \n} \nfor ( Group srcNested : src . getGroups ( ) ) { \nGroup nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; \nif ( null == nested ) { \nnested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; \ntargetGroup . addGroup ( nested ) ; \n} \ntransferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; \n} \nreturn ; \n} \n} \n"}
{"4622": "public class IgraPor { \n@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { \nsuper . open ( raff , ncfile , cancelTask ) ; \nint pos = location . lastIndexOf ( \".\" ) ; \nString ext = location . substring ( pos ) ; \nFile file = new File ( location ) ; \nFile stnFile = getStnFile ( location ) ; \nif ( stnFile == null ) throw new FileNotFoundException ( \"Station File does not exist=\" + location ) ; \nif ( ext . equals ( IDX_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \n} \nelse if ( ext . equals ( DAT_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \ndataRaf = raff ; \nString name = file . getName ( ) ; \nstationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; \n} \nelse { \nstnRaf = raff ; \ndataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; \n} \nNcmlConstructor ncmlc = new NcmlConstructor ( ) ; \nif ( ! ncmlc . populateFromResource ( \"resources/nj22/iosp/igra-por.ncml\" , ncfile ) ) { \nthrow new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; \n} \nncfile . finish ( ) ; \nstnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , \"station\" ) ; \nseriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , \"station.time_series\" ) ; \nprofileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , \"station.time_series.levels\" ) ; \nStructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; \nStructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; \nstn_fldno = f . fldno ; \nreturn ; \n} \n} \n"}
{"4626": "public class DurationField { \nprotected void setEditValue ( Object value ) { \nif ( value == null ) tf . setText ( \"\" ) ; \nelse tf . setText ( value . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \nelse if ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) { \ncontinue ; \n} \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \nif ( debugAttributes ) System . out . println ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4644": "public class Variable { \npublic void setEnumTypedef ( EnumTypedef enumTypedef ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( ! dataType . isEnum ( ) ) throw new UnsupportedOperationException ( \"Can only call Variable.setEnumTypedef() on enum types\" ) ; \nthis . enumTypedef = enumTypedef ; \nreturn ; \n} \n} \n"}
{"4651": "public class Variable { \npublic void setDataType ( DataType dataType ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nthis . dataType = dataType ; \nthis . elementSize = getDataType ( ) . getSize ( ) ; \nreturn ; \n} \n} \n"}
{"4652": "public class Variable { \npublic void setDimensions ( List < Dimension > dims ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nthis . dimensions = ( dims == null ) ? new ArrayList < > ( ) : new ArrayList < > ( dims ) ; \nresetShape ( ) ; \nreturn ; \n} \n} \n"}
{"4653": "public class Variable { \npublic void resetShape ( ) { \nthis . shape = new int [ dimensions . size ( ) ] ; \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension dim = dimensions . get ( i ) ; \nshape [ i ] = dim . getLength ( ) ; \nif ( dim . isVariableLength ( ) ) { \nisVariableLength = true ; \n} \n} \nthis . shapeAsSection = null ; \nreturn ; \n} \n} \n"}
{"4654": "public class Variable { \npublic void setDimensions ( String dimString ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \ntry { \nsetDimensions ( Dimension . makeDimensionsList ( getParentGroup ( ) , dimString ) ) ; \nresetShape ( ) ; \n} \ncatch ( IllegalStateException e ) { \nthrow new IllegalArgumentException ( \"Variable \" + getFullName ( ) + \" setDimensions = '\" + dimString + \"' FAILED: \" + e . getMessage ( ) + \" file = \" + getDatasetLocation ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4655": "public class Variable { \npublic void resetDimensions ( ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nArrayList < Dimension > newDimensions = new ArrayList < > ( ) ; \nfor ( Dimension dim : dimensions ) { \nif ( dim . isShared ( ) ) { \nDimension newD = getParentGroup ( ) . findDimension ( dim . getShortName ( ) ) ; \nif ( newD == null ) throw new IllegalArgumentException ( \"Variable \" + getFullName ( ) + \" resetDimensions  FAILED, dim doesnt exist in parent group=\" + dim ) ; \nnewDimensions . add ( newD ) ; \n} \nelse { \nnewDimensions . add ( dim ) ; \n} \n} \nthis . dimensions = newDimensions ; \nresetShape ( ) ; \nreturn ; \n} \n} \n"}
{"4656": "public class Variable { \npublic void setDimension ( int idx , Dimension dim ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \ndimensions . set ( idx , dim ) ; \nresetShape ( ) ; \nreturn ; \n} \n} \n"}
{"4657": "public class Variable { \npublic void setCachedData ( Array cacheData , boolean isMetadata ) { \nif ( ( cacheData != null ) && ( cacheData . getElementType ( ) != getDataType ( ) . getPrimitiveClassType ( ) ) ) throw new IllegalArgumentException ( \"setCachedData type=\" + cacheData . getElementType ( ) + \" incompatible with variable type=\" + getDataType ( ) ) ; \nthis . cache . data = cacheData ; \nthis . isMetadata = isMetadata ; \nthis . cache . cachingSet = true ; \nthis . cache . isCaching = true ; \nreturn ; \n} \n} \n"}
{"4659": "public class AbstractRadialAdapter { \nprotected void setBoundingBox ( ) { \nLatLonRect largestBB = null ; \nfor ( Object o : csHash . values ( ) ) { \nRadialCoordSys sys = ( RadialCoordSys ) o ; \nsys . setOrigin ( origin ) ; \nLatLonRect bb = sys . getBoundingBox ( ) ; \nif ( largestBB == null ) largestBB = bb ; \nelse if ( bb != null ) largestBB . extend ( bb ) ; \n} \nboundingBox = largestBB ; \nreturn ; \n} \n} \n"}
{"4660": "public class FmrInv { \nvoid finish ( ) { \ngridList = new ArrayList < > ( uvHash . values ( ) ) ; \nCollections . sort ( gridList ) ; \nfor ( GridVariable grid : gridList ) { \ngrid . finish ( ) ; \n} \nint seqno = 0 ; \nfor ( TimeCoord tc : timeCoords ) tc . setId ( seqno ++ ) ; \nHashMap < String , List < VertCoord > > map = new HashMap < > ( ) ; \nfor ( VertCoord vc : vertCoords ) { \nList < VertCoord > list = map . get ( vc . getName ( ) ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \nmap . put ( vc . getName ( ) , list ) ; \n} \nlist . add ( vc ) ; \n} \nfor ( List < VertCoord > list : map . values ( ) ) { \nif ( list . size ( ) > 0 ) { \nint count = 0 ; \nfor ( VertCoord vc : list ) { \nif ( count > 0 ) vc . setName ( vc . getName ( ) + count ) ; \ncount ++ ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4664": "public class CDMDSP { \npublic void buildDMR ( ) throws DapException { \nif ( getDMR ( ) != null ) return ; \ntry { \nif ( DUMPCDL ) { \nSystem . out . println ( \"writecdl:\" ) ; \nthis . ncdfile . writeCDL ( System . out , false ) ; \nSystem . out . flush ( ) ; \n} \nString name = this . ncdfile . getLocation ( ) ; \nname = DapUtil . canonicalpath ( name ) ; \nint index = name . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) name = name . substring ( index + 1 , name . length ( ) ) ; \nsetDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; \nrecordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; \ngetDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; \nfillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . sort ( ) ; \nprocessmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . finish ( ) ; \n} \ncatch ( DapException e ) { \nsetDMR ( null ) ; \nthrow new DapException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) { \nbuildseqtype ( cdmvar ) ; \n} \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4666": "public class CDMDSP { \nprotected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { \nif ( cdmdims == null || cdmdims . size ( ) == 0 ) return ; \nfor ( Dimension cdmdim : cdmdims ) { \nDapDimension dapdim = null ; \nif ( cdmdim . isShared ( ) ) { \nDimension declareddim = finddimdecl ( cdmdim ) ; \nif ( declareddim == null ) throw new DapException ( \"Unprocessed cdm dimension: \" + cdmdim ) ; \ndapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; \nassert dapdim != null ; \n} \nelse if ( cdmdim . isVariableLength ( ) ) { \ncontinue ; \n} \nelse { \ndapdim = builddim ( cdmdim ) ; \n} \nassert ( dapdim != null ) : \"Internal error\" ; \ndapvar . addDimension ( dapdim ) ; \n} \nreturn ; \n} \n} \n"}
{"4670": "public class BufrDataProcess { \nprivate void processBufrMessageAsDataset ( MessageScanner scan , Message m , Counter counter ) throws Exception { \nbyte [ ] mbytes = scan . getMessageBytes ( m ) ; \nNetcdfFile ncfile = NetcdfFile . openInMemory ( \"test\" , mbytes , \"ucar.nc2.iosp.bufr.BufrIosp\" ) ; \nSequence obs = ( Sequence ) ncfile . findVariable ( BufrIosp2 . obsRecord ) ; \nStructureDataIterator sdataIter = obs . getStructureIterator ( - 1 ) ; \nprocessSequence ( obs , sdataIter , counter ) ; \nreturn ; \n} \n} \n"}
{"4671": "public class CdmValidatorController { \npublic void doPost ( HttpServletRequest req , HttpServletResponse res ) throws ServletException , IOException { \nlog . info ( \"doPost(): \" + UsageLog . setupRequestContext ( req ) ) ; \nboolean isMultipart = ServletFileUpload . isMultipartContent ( req ) ; \nif ( ! isMultipart ) { \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nServletFileUpload upload = new ServletFileUpload ( this . cdmValidatorContext . getFileuploadFileItemFactory ( ) ) ; \nupload . setSizeMax ( this . cdmValidatorContext . getMaxFileUploadSize ( ) ) ; \nList < FileItem > fileItems ; \ntry { \nfileItems = ( List < FileItem > ) upload . parseRequest ( req ) ; \n} \ncatch ( FileUploadException e ) { \nlog . info ( \"doPost(): Validator FileUploadException\" , e ) ; \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nif ( ! res . isCommitted ( ) ) res . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; \nreturn ; \n} \nString username = null ; \nboolean wantXml = false ; \nfor ( FileItem item : fileItems ) { \nif ( item . isFormField ( ) ) { \nif ( \"username\" . equals ( item . getFieldName ( ) ) ) username = item . getString ( ) ; \nif ( \"xml\" . equals ( item . getFieldName ( ) ) ) wantXml = item . getString ( ) . equals ( \"true\" ) ; \n} \n} \nfor ( FileItem item : fileItems ) { \nif ( ! item . isFormField ( ) ) { \ntry { \nprocessUploadedFile ( req , res , ( DiskFileItem ) item , username , wantXml ) ; \nreturn ; \n} \ncatch ( Exception e ) { \nlog . info ( \"doPost(): Validator processUploadedFile\" , e ) ; \nlog . info ( \"doPost(): \" + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; \nres . sendError ( HttpServletResponse . SC_BAD_REQUEST , e . getMessage ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4676": "public class Navigation { \npublic void pan ( double deltax , double deltay ) { \nzoom . push ( ) ; \npix_x0 -= deltax ; \npix_y0 -= deltay ; \nfireMapAreaEvent ( ) ; \nreturn ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) System . out . println ( \"zoom \" + startx + \" \" + starty + \" \" + width + \" \" + height + \" \" ) ; \nif ( ( width < 5 ) || ( height < 5 ) ) return ; \nzoom . push ( ) ; \npix_x0 -= startx + width / 2 - pwidth / 2 ; \npix_y0 -= starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \nreturn ; \n} \n} \n"}
{"4678": "public class Navigation { \nprivate void recalcFromBoundingBox ( ) { \nif ( debugRecalc ) { \nSystem . out . println ( \"Navigation recalcFromBoundingBox= \" + bb ) ; \nSystem . out . println ( \"  \" + pwidth + \" \" + pheight ) ; \n} \ndouble pixx_per_wx = ( bb . getWidth ( ) == 0.0 ) ? 1 : pwidth / bb . getWidth ( ) ; \ndouble pixy_per_wy = ( bb . getHeight ( ) == 0.0 ) ? 1 : pheight / bb . getHeight ( ) ; \npix_per_world = Math . min ( pixx_per_wx , pixy_per_wy ) ; \ndouble wx0 = bb . getX ( ) + bb . getWidth ( ) / 2 ; \ndouble wy0 = bb . getY ( ) + bb . getHeight ( ) / 2 ; \npix_x0 = pwidth / 2 - pix_per_world * wx0 ; \npix_y0 = pheight / 2 + pix_per_world * wy0 ; \nif ( debugRecalc ) { \nSystem . out . println ( \"Navigation recalcFromBoundingBox done= \" + pix_per_world + \" \" + pix_x0 + \" \" + pix_y0 ) ; \nSystem . out . println ( \"  \" + pwidth + \" \" + pheight + \" \" + bb ) ; \n} \nreturn ; \n} \n} \n"}
{"4679": "public class ListenerManager { \npublic synchronized void addListener ( Object l ) { \nif ( ! listeners . contains ( l ) ) { \nlisteners . add ( l ) ; \nhasListeners = true ; \n} \nelse logger . warn ( \"ListenerManager.addListener already has Listener \" + l ) ; \nreturn ; \n} \n} \n"}
{"4680": "public class ListenerManager { \npublic synchronized void removeListener ( Object l ) { \nif ( listeners . contains ( l ) ) { \nlisteners . remove ( l ) ; \nhasListeners = ( listeners . size ( ) > 0 ) ; \n} \nelse logger . warn ( \"ListenerManager.removeListener couldnt find Listener \" + l ) ; \nreturn ; \n} \n} \n"}
{"4681": "public class ListenerManager { \npublic synchronized void sendEvent ( java . util . EventObject event ) { \nif ( ! hasListeners || ! enabled ) return ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject client = iter . next ( ) ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException e ) { \nlogger . error ( \"ListenerManager IllegalAccessException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \nlogger . error ( \"ListenerManager IllegalArgumentException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new RuntimeException ( e . getCause ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4682": "public class ListenerManager { \npublic synchronized void sendEventExcludeSource ( java . util . EventObject event ) { \nif ( ! hasListeners || ! enabled ) return ; \nObject source = event . getSource ( ) ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject client = iter . next ( ) ; \nif ( client == source ) continue ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException | InvocationTargetException | IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \nif ( e . getCause ( ) != null ) e . getCause ( ) . printStackTrace ( ) ; \nlogger . error ( \"ListenerManager calling \" + method + \" threw exception \" , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4687": "public class NCdumpW { \nstatic public void printStructureData ( PrintWriter out , StructureData sdata ) throws IOException { \nprintStructureData ( out , sdata , new Indent ( 2 ) , null ) ; \nout . flush ( ) ; \nreturn ; \n} \n} \n"}
{"4688": "public class NCdumpW { \nstatic public void printArrayPlain ( Array ma , PrintWriter out ) { \nma . resetLocalIterator ( ) ; \nwhile ( ma . hasNext ( ) ) { \nout . print ( ma . next ( ) ) ; \nout . print ( ' ' ) ; \n} \nreturn ; \n} \n} \n"}
{"4689": "public class NCdumpW { \nstatic public void printArray ( Array array , PrintWriter pw ) { \nprintArray ( array , null , null , pw , new Indent ( 2 ) , null , true ) ; \nreturn ; \n} \n} \n"}
{"4690": "public class NCdumpW { \nstatic public void writeNcML ( NetcdfFile ncfile , Writer writer , WantValues showValues , String url ) throws IOException { \nPreconditions . checkNotNull ( ncfile ) ; \nPreconditions . checkNotNull ( writer ) ; \nPreconditions . checkNotNull ( showValues ) ; \nPredicate < Variable > writeVarsPred ; \nswitch ( showValues ) { \ncase none : writeVarsPred = NcMLWriter . writeNoVariablesPredicate ; \nbreak ; \ncase coordsOnly : writeVarsPred = NcMLWriter . writeCoordinateVariablesPredicate ; \nbreak ; \ncase all : writeVarsPred = NcMLWriter . writeAllVariablesPredicate ; \nbreak ; \ndefault : String message = String . format ( \"CAN'T HAPPEN: showValues (%s) != null and checked all possible enum values.\" , showValues ) ; \nthrow new AssertionError ( message ) ; \n} \nNcMLWriter ncmlWriter = new NcMLWriter ( ) ; \nncmlWriter . setWriteVariablesPredicate ( writeVarsPred ) ; \nElement netcdfElement = ncmlWriter . makeNetcdfElement ( ncfile , url ) ; \nncmlWriter . writeToWriter ( netcdfElement , writer ) ; \nreturn ; \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( int i = 0 ; \ni < m . groupCount ( ) ; \ni ++ ) { \nSystem . out . println ( \" \" + i + \" \" + m . group ( i ) ) ; \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \nreturn ; \n} \n} \n"}
{"4698": "public class BitReader { \npublic void setBitOffset ( int bitOffset ) throws IOException { \nif ( bitOffset % 8 == 0 ) { \nraf . seek ( startPos + bitOffset / 8 ) ; \nbitPos = 0 ; \nbitBuf = 0 ; \n} \nelse { \nraf . seek ( startPos + bitOffset / 8 ) ; \nbitPos = 8 - ( bitOffset % 8 ) ; \nbitBuf = ( byte ) raf . read ( ) ; \nbitBuf &= 0xff >> ( 8 - bitPos ) ; \n} \nreturn ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"4709": "public class DMSPHeader { \nprivate void handleSatelliteInformation ( ) { \nspacecraftIdAtt = new Attribute ( this . spacecraftIdAttName , headerInfo . get ( HeaderInfoTitle . SPACECRAFT_ID . toString ( ) ) ) ; \nnoradIdAtt = new Attribute ( this . noradIdAttName , headerInfo . get ( HeaderInfoTitle . NORAD_ID . toString ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"4710": "public class DMSPHeader { \nprivate void handleSensorInformation ( ) { \nnumSamplesPerBand = Integer . parseInt ( headerInfo . get ( HeaderInfoTitle . SAMPLES_PER_BAND . toString ( ) ) ) ; \nnumSamplesPerBandDim = new Dimension ( this . numSamplesPerBandDimName , numSamplesPerBand ) ; \nnominalResolutionAtt = new Attribute ( nominalResolutionAttName , headerInfo . get ( HeaderInfoTitle . NOMINAL_RESOLUTION . toString ( ) ) ) ; \nbandsPerScanlineAtt = new Attribute ( bandsPerScanlineAttName , Integer . valueOf ( headerInfo . get ( HeaderInfoTitle . BANDS_PER_SCANLINE . toString ( ) ) ) ) ; \nbytesPerSampleAtt = new Attribute ( bytesPerSampleAttName , Integer . valueOf ( headerInfo . get ( HeaderInfoTitle . BYTES_PER_SAMPLE . toString ( ) ) ) ) ; \nbyteOffsetBand1Att = new Attribute ( byteOffsetBand1AttName , Integer . valueOf ( headerInfo . get ( HeaderInfoTitle . BYTE_OFFSET_BAND_1 . toString ( ) ) ) ) ; \nbyteOffsetBand2Att = new Attribute ( byteOffsetBand2AttName , Integer . valueOf ( headerInfo . get ( HeaderInfoTitle . BYTE_OFFSET_BAND_2 . toString ( ) ) ) ) ; \nband1Att = new Attribute ( band1AttName , headerInfo . get ( HeaderInfoTitle . BAND_1 . toString ( ) ) ) ; \nband2Att = new Attribute ( band2AttName , headerInfo . get ( HeaderInfoTitle . BAND_2 . toString ( ) ) ) ; \nbandOrganizationAtt = new Attribute ( bandOrganizationAttName , headerInfo . get ( HeaderInfoTitle . ORGANIZATION . toString ( ) ) ) ; \nthermalOffsetAtt = new Attribute ( thermalOffsetAttName , headerInfo . get ( HeaderInfoTitle . THERMAL_OFFSET . toString ( ) ) ) ; \nthermalScaleAtt = new Attribute ( thermalScaleAttName , headerInfo . get ( HeaderInfoTitle . THERMAL_SCALE . toString ( ) ) ) ; \npercentDaylightAtt = new Attribute ( percentDaylightAttName , Double . valueOf ( headerInfo . get ( HeaderInfoTitle . PERCENT_DAYLIGHT . toString ( ) ) ) ) ; \npercentFullMoonAtt = new Attribute ( percentFullMoonAttName , Double . valueOf ( headerInfo . get ( HeaderInfoTitle . PERCENT_FULL_MOON . toString ( ) ) ) ) ; \npercentTerminatorEvidentAtt = new Attribute ( percentTerminatorEvidentAttName , Double . valueOf ( headerInfo . get ( HeaderInfoTitle . PERCENT_TERMINATOR_EVIDENT . toString ( ) ) ) ) ; \nreturn ; \n} \n} \n"}
{"4718": "public class AbstractLightningIOSP { \nprotected void addLightningGlobalAttributes ( NetcdfFile ncfile ) { \nncfile . addAttribute ( null , new Attribute ( CF . FEATURE_TYPE , CF . FeatureType . point . toString ( ) ) ) ; \nncfile . addAttribute ( null , new Attribute ( CDM . HISTORY , \"Read directly by Netcdf Java IOSP\" ) ) ; \nreturn ; \n} \n} \n"}
{"4730": "public class WFSDescribeFeatureTypeWriter { \npublic void startXML ( ) { \nfileOutput += \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" ; \nfileOutput += \"<schema \" + \"xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" \" + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\" \" + \"xmlns=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" \" + \"targetNamespace=\\\"\" + server + \"\\\" elementFormDefault=\\\"qualified\\\" \" + \"version=\\\"0.1\\\">\" ; \nfileOutput += \"<xsd:import namespace=\\\"http://www.opengis.net/gml\\\" \" + \"schemaLocation=\\\"http://schemas.opengis.net/gml/2.1.2/feature.xsd\\\"/>\" ; \nreturn ; \n} \n} \n"}
{"4731": "public class WFSDescribeFeatureTypeWriter { \npublic void writeFeatures ( ) { \nfor ( WFSFeature feat : featureList ) { \nfileOutput += \"<xsd:complexType name=\\\"\" + feat . getTitle ( ) + \"\\\">\" ; \nfileOutput += \"<xsd:complexContent>\" ; \nfileOutput += \"<xsd:extension base=\\\"gml:\" + feat . getType ( ) + \"\\\">\" ; \nfileOutput += \"<xsd:sequence>\" ; \nfor ( WFSFeatureAttribute attribute : feat . getAttributes ( ) ) { \nfileOutput += \"<xsd:element name =\\\"\" + attribute . getName ( ) + \"\\\" type=\\\"\" + attribute . getType ( ) + \"\\\"/>\" ; \n} \nfileOutput += \"</xsd:sequence>\" ; \nfileOutput += \"</xsd:extension>\" ; \nfileOutput += \"</xsd:complexContent>\" ; \nfileOutput += \"</xsd:complexType>\" ; \nfileOutput += \"<xsd:element name =\\\"\" + feat . getName ( ) + \"\\\" type=\\\"tds:\" + feat . getTitle ( ) + \"\\\"/>\" ; \n} \nreturn ; \n} \n} \n"}
{"4732": "public class GridCoordSys { \nvoid addLevels ( List < GridRecord > records ) { \nfor ( GridRecord record : records ) { \nDouble d = new Double ( record . getLevel1 ( ) ) ; \nif ( ! levels . contains ( d ) ) { \nlevels . add ( d ) ; \n} \nif ( dontUseVertical && ( levels . size ( ) > 1 ) ) { \nif ( GridServiceProvider . debugVert ) { \nSystem . out . println ( \"GribCoordSys: unused level coordinate has > 1 levels = \" + verticalName + \" \" + record . getLevelType1 ( ) + \" \" + levels . size ( ) ) ; \n} \n} \n} \nCollections . sort ( levels ) ; \nif ( positive . equals ( \"down\" ) ) { \nCollections . reverse ( levels ) ; \n} \nreturn ; \n} \n} \n"}
{"4733": "public class GridCoordSys { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nint nlevs = levels . size ( ) ; \nncfile . addDimension ( g , new Dimension ( verticalName , nlevs , true ) ) ; \nreturn ; \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( hcs . isLatLon ( ) ) { \ndims = dims + \" lat lon\" ; \n} \nelse { \ndims = dims + \" y x\" ; \n} \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) { \naxisType = AxisType . Pressure ; \n} \nelse if ( SimpleUnit . isCompatible ( \"m\" , units ) ) { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . GeoZ ; \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4735": "public class GridCoordSys { \nvoid findCoordinateTransform ( Group g , String nameStartsWith , int levelType ) { \nList < Variable > vars = g . getVariables ( ) ; \nfor ( Variable v : vars ) { \nif ( v . getShortName ( ) . equals ( nameStartsWith ) ) { \nAttribute att = v . findAttribute ( \"grid_level_type\" ) ; \nif ( ( att == null ) || ( att . getNumericValue ( ) . intValue ( ) != levelType ) ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( _Coordinate . TransformType , \"Vertical\" ) ) ; \nv . addAttribute ( new Attribute ( \"transform_name\" , \"Existing3DField\" ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4737": "public class DiskCache2 { \nstatic public void exit ( ) { \nif ( timer != null ) { \ntimer . cancel ( ) ; \nSystem . out . printf ( \"DiskCache2.exit()%n\" ) ; \n} \ntimer = null ; \nreturn ; \n} \n} \n"}
{"4740": "public class DiskCache2 { \npublic void showCache ( PrintStream pw ) { \npw . println ( \"Cache files\" ) ; \npw . println ( \"Size   LastModified       Filename\" ) ; \nFile dir = new File ( root ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) for ( File file : files ) { \nString org = null ; \ntry { \norg = URLDecoder . decode ( file . getName ( ) , \"UTF8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \npw . println ( \" \" + file . length ( ) + \" \" + new Date ( file . lastModified ( ) ) + \" \" + org ) ; \n} \nreturn ; \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \n} \nif ( ! isRoot && ( files . length == 0 ) ) { \nlong duration = now - dir . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \nreturn ; \n} \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) { \ncleanCache ( file , sbuff , false ) ; \n} \nelse { \nlong duration = now - file . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"4744": "public class Bearing { \npublic static void main ( String [ ] args ) { \nLatLonPointImpl pt1 = new LatLonPointImpl ( 40 , - 105 ) ; \nLatLonPointImpl pt2 = new LatLonPointImpl ( 37.4 , - 118.4 ) ; \nBearing b = calculateBearing ( pt1 , pt2 , null ) ; \nSystem . out . println ( \"Bearing from \" + pt1 + \" to \" + pt2 + \" = \\n\\t\" + b ) ; \nLatLonPointImpl pt3 = new LatLonPointImpl ( ) ; \npt3 = findPoint ( pt1 , b . getAngle ( ) , b . getDistance ( ) , pt3 ) ; \nSystem . out . println ( \"using first point, angle and distance, found second point at \" + pt3 ) ; \npt3 = findPoint ( pt2 , b . getBackAzimuth ( ) , b . getDistance ( ) , pt3 ) ; \nSystem . out . println ( \"using second point, backazimuth and distance, found first point at \" + pt3 ) ; \nreturn ; \n} \n} \n"}
{"4748": "public class SourcePicture { \npublic void loadPictureInThread ( URL imageUrl , int priority , double rotation ) { \nif ( pictureStatusCode == LOADING ) { \nstopLoadingExcept ( imageUrl ) ; \n} \nthis . imageUrl = imageUrl ; \nthis . rotation = rotation ; \nLoadThread t = new LoadThread ( this ) ; \nt . setPriority ( priority ) ; \nt . start ( ) ; \nreturn ; \n} \n} \n"}
{"4749": "public class SourcePicture { \npublic void loadPicture ( URL imageUrl , double rotation ) { \nif ( pictureStatusCode == LOADING ) { \nstopLoadingExcept ( imageUrl ) ; \n} \nthis . imageUrl = imageUrl ; \nthis . rotation = rotation ; \nloadPicture ( ) ; \nreturn ; \n} \n} \n"}
{"4750": "public class SourcePicture { \npublic void loadPicture ( ) { \nTools . log ( \"SourcePicture.loadPicture: \" + imageUrl . toString ( ) + \" loaded into SourcePicture object: \" + Integer . toString ( this . hashCode ( ) ) ) ; \nsetStatus ( LOADING , \"Loading: \" + imageUrl . toString ( ) ) ; \nabortFlag = false ; \ntry { \nImageInputStream iis = ImageIO . createImageInputStream ( imageUrl . openStream ( ) ) ; \nIterator i = ImageIO . getImageReaders ( iis ) ; \nif ( ! i . hasNext ( ) ) { \nthrow new IOException ( \"No Readers Available!\" ) ; \n} \nreader = ( ImageReader ) i . next ( ) ; \nreader . addIIOReadProgressListener ( imageProgressListener ) ; \nreader . setInput ( iis ) ; \nsourcePictureBufferedImage = null ; \nsourcePictureBufferedImage = reader . read ( 0 ) ; \niis . close ( ) ; \nreader . removeIIOReadProgressListener ( imageProgressListener ) ; \nreader . dispose ( ) ; \nif ( ! abortFlag ) { \nif ( rotation != 0 ) { \nsetStatus ( ROTATING , \"Rotating: \" + imageUrl . toString ( ) ) ; \nint xRot = sourcePictureBufferedImage . getWidth ( ) / 2 ; \nint yRot = sourcePictureBufferedImage . getHeight ( ) / 2 ; \nAffineTransform rotateAf = AffineTransform . getRotateInstance ( Math . toRadians ( rotation ) , xRot , yRot ) ; \nAffineTransformOp op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nRectangle2D newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \ndouble minX = newBounds . getMinX ( ) ; \ndouble minY = newBounds . getMinY ( ) ; \nAffineTransform translateAf = AffineTransform . getTranslateInstance ( minX * ( - 1 ) , minY * ( - 1 ) ) ; \nrotateAf . preConcatenate ( translateAf ) ; \nop = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; \nnewBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; \nBufferedImage targetImage = new BufferedImage ( ( int ) newBounds . getWidth ( ) , ( int ) newBounds . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nsourcePictureBufferedImage = op . filter ( sourcePictureBufferedImage , targetImage ) ; \n} \nsetStatus ( READY , \"Loaded: \" + imageUrl . toString ( ) ) ; \nPictureCache . add ( imageUrl , ( SourcePicture ) this . clone ( ) ) ; \n} \nelse { \nsetStatus ( ERROR , \"Aborted: \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \n} \ncatch ( IOException e ) { \nsetStatus ( ERROR , \"Error while reading \" + imageUrl . toString ( ) ) ; \nsourcePictureBufferedImage = null ; \n} \nreturn ; \n} \n} \n"}
{"4751": "public class SourcePicture { \npublic void stopLoading ( ) { \nif ( imageUrl == null ) return ; \nTools . log ( \"SourcePicture.stopLoading: called on \" + imageUrl ) ; \nif ( pictureStatusCode == LOADING ) { \nreader . abort ( ) ; \nabortFlag = true ; \n} \nreturn ; \n} \n} \n"}
{"4754": "public class SourcePicture { \npublic void setSourceBufferedImage ( BufferedImage img , String statusMessage ) { \nsourcePictureBufferedImage = img ; \nsetStatus ( READY , statusMessage ) ; \nreturn ; \n} \n} \n"}
{"4757": "public class DataDescriptor { \nstatic public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { \nif ( fromList . size ( ) != toList . size ( ) ) throw new IllegalArgumentException ( \"list sizes dont match \" + fromList . size ( ) + \" != \" + toList . size ( ) ) ; \nfor ( int i = 0 ; \ni < fromList . size ( ) ; \ni ++ ) { \nDataDescriptor from = fromList . get ( i ) ; \nDataDescriptor to = toList . get ( i ) ; \nto . refersTo = from . refersTo ; \nto . name = from . name ; \nif ( from . getSubKeys ( ) != null ) transferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) { \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nelse System . out . println ( ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"4771": "public class DapNode { \npublic synchronized void removeAttribute ( DapAttribute attr ) throws DapException { \nif ( this . attributes == null ) return ; \nString name = attr . getShortName ( ) ; \nif ( this . attributes . containsKey ( name ) ) this . attributes . remove ( name ) ; \nreturn ; \n} \n} \n"}
{"4779": "public class D4DSP { \nprotected void build ( DapDataset dmr , byte [ ] serialdata , ByteOrder order ) throws DapException { \nsetDMR ( dmr ) ; \nthis . databuffer = ByteBuffer . wrap ( serialdata ) . order ( order ) ; \nD4DataCompiler compiler = new D4DataCompiler ( this , getChecksumMode ( ) , getOrder ( ) , this . databuffer ) ; \ncompiler . compile ( ) ; \nreturn ; \n} \n} \n"}
{"4780": "public class PreferencesExt { \npublic void putBeanCollection ( String key , Collection newValue ) { \nObject oldValue = getBean ( key , null ) ; \nif ( ( oldValue == null ) || ! oldValue . equals ( newValue ) ) keyValues . put ( key , new Bean . Collection ( newValue ) ) ; \nreturn ; \n} \n} \n"}
{"4785": "public class DSPPrinter { \nprotected void printCompoundInstance ( DataCursor datav ) throws DapException { \nDapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; \nswitch ( datav . getScheme ( ) ) { \ncase STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; \nfor ( int f = 0 ; \nf < dfields . size ( ) ; \nf ++ ) { \nDapVariable field = dfields . get ( f ) ; \nList < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; \nDataCursor fdata = datav . readField ( f ) ; \nprintVariable ( fdata , fieldslices ) ; \n} \nbreak ; \ncase SEQUENCE : DapSequence dseq = ( DapSequence ) dstruct ; \nlong count = datav . getRecordCount ( ) ; \nfor ( long r = 0 ; \nr < count ; \nr ++ ) { \nDataCursor dr = datav . readRecord ( r ) ; \nprinter . marginPrint ( \"[\" ) ; \nprinter . eol ( ) ; \nprinter . indent ( ) ; \nprintCompoundInstance ( dr ) ; \nprinter . outdent ( ) ; \nprinter . marginPrint ( \"]\" ) ; \n} \nbreak ; \ndefault : throw new DapException ( \"Unexpected data cursor scheme:\" + datav . getScheme ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4787": "public class NcMLWriter { \npublic void writeToFile ( Element elem , File outFile ) throws IOException { \ntry ( OutputStream outStream = new BufferedOutputStream ( new FileOutputStream ( outFile , false ) ) ) { \nwriteToStream ( elem , outStream ) ; \n} \nreturn ; \n} \n} \n"}
{"4788": "public class NcMLWriter { \npublic void writeToStream ( Element elem , OutputStream outStream ) throws IOException { \ntry ( Writer writer = new BufferedWriter ( new OutputStreamWriter ( new BufferedOutputStream ( outStream ) , xmlFormat . getEncoding ( ) ) ) ) { \nwriteToWriter ( elem , writer ) ; \n} \nreturn ; \n} \n} \n"}
{"4789": "public class NcMLWriter { \npublic void writeToWriter ( Element elem , Writer writer ) throws IOException { \nxmlOutputter . setFormat ( xmlFormat ) ; \nelem . detach ( ) ; \nxmlOutputter . output ( new Document ( elem ) , writer ) ; \nreturn ; \n} \n} \n"}
{"4803": "public class DataFactory { \npublic static void annotate ( Dataset ds , NetcdfDataset ncDataset ) { \nncDataset . setTitle ( ds . getName ( ) ) ; \nncDataset . setId ( ds . getId ( ) ) ; \nfor ( Property p : ds . getProperties ( ) ) { \nString name = p . getName ( ) ; \nif ( null == ncDataset . findGlobalAttribute ( name ) ) { \nncDataset . addAttribute ( null , new Attribute ( name , p . getValue ( ) ) ) ; \n} \n} \nncDataset . finish ( ) ; \nreturn ; \n} \n} \n"}
{"4809": "public class InvMetadata { \npublic void finish ( ) { \nif ( init ) return ; \ninit = true ; \nif ( xlinkHref == null ) return ; \nxlinkHref = xlinkHref . trim ( ) ; \ntry { \nthis . xlinkUri = dataset . getParentCatalog ( ) . resolveUri ( xlinkHref ) ; \n} \ncatch ( java . net . URISyntaxException e ) { \nlog . append ( \" ** Error: Bad URL in metadata href = \" ) . append ( xlinkHref ) . append ( \"\\n\" ) ; \nreturn ; \n} \ntry { \nif ( converter == null ) { \nlog . append ( \"  **InvMetadata on = (\" ) . append ( this ) . append ( \"): has no converter\\n\" ) ; \nreturn ; \n} \ncontentObject = converter . readMetadataContentFromURL ( dataset , xlinkUri ) ; \nif ( isThreddsMetadata ) tm = ( ThreddsMetadata ) contentObject ; \n} \ncatch ( java . io . IOException e ) { \nlog . append ( \"  **InvMetadata on = (\" ) . append ( xlinkUri ) . append ( \"): Exception (\" ) . append ( e . getMessage ( ) ) . append ( \")\\n\" ) ; \n} \nreturn ; \n} \n} \n"}
{"4813": "public class DMRPrinter { \nvoid printXMLAttributes ( DapNode node , CEConstraint ce , int flags ) throws IOException { \nif ( ( flags & PERLINE ) != 0 ) printer . indent ( 2 ) ; \nString name = node . getShortName ( ) ; \nif ( name != null && ( flags & NONAME ) == 0 ) { \nname = node . getShortName ( ) ; \nprintXMLAttribute ( \"name\" , name , flags ) ; \n} \nswitch ( node . getSort ( ) ) { \ncase DATASET : DapDataset dataset = ( DapDataset ) node ; \nprintXMLAttribute ( \"dapVersion\" , dataset . getDapVersion ( ) , flags ) ; \nprintXMLAttribute ( \"dmrVersion\" , dataset . getDMRVersion ( ) , flags ) ; \nprintXMLAttribute ( \"xmlns\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nprintXMLAttribute ( \"xmlns:dap\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nbreak ; \ncase DIMENSION : DapDimension orig = ( DapDimension ) node ; \nif ( orig . isShared ( ) ) { \nDapDimension actual = this . ce . getRedefDim ( orig ) ; \nif ( actual == null ) actual = orig ; \nlong size = actual . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , flags ) ; \n} \nbreak ; \ncase ENUMERATION : printXMLAttribute ( \"basetype\" , ( ( DapEnumeration ) node ) . getBaseType ( ) . getTypeName ( ) , flags ) ; \nbreak ; \ncase VARIABLE : DapVariable var = ( DapVariable ) node ; \nDapType basetype = var . getBaseType ( ) ; \nif ( basetype . isEnumType ( ) ) { \nprintXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \n} \nbreak ; \ncase ATTRIBUTE : DapAttribute attr = ( DapAttribute ) node ; \nbasetype = attr . getBaseType ( ) ; \nprintXMLAttribute ( \"type\" , basetype . getTypeName ( ) , flags ) ; \nif ( attr . getBaseType ( ) . isEnumType ( ) ) { \nprintXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \n} \nbreak ; \ndefault : break ; \n} \nif ( ! this . testing ) printReserved ( node ) ; \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . outdent ( 2 ) ; \n} \nreturn ; \n} \n} \n"}
{"4814": "public class DMRPrinter { \nprotected void printXMLAttribute ( String name , String value , int flags ) throws DapException { \nif ( name == null ) return ; \nif ( ( flags & NONNIL ) == 0 && ( value == null || value . length ( ) == 0 ) ) return ; \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . eol ( ) ; \nprinter . margin ( ) ; \n} \nprinter . print ( \" \" + name + \"=\" ) ; \nprinter . print ( \"\\\"\" ) ; \nif ( value != null ) { \nif ( ( flags & XMLESCAPED ) == 0 ) value = Escape . entityEscape ( value , \"\\\"\" ) ; \nprinter . print ( value ) ; \n} \nprinter . print ( \"\\\"\" ) ; \nreturn ; \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( int i = 0 ; \ni < var . getRank ( ) ; \ni ++ ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . println ( \"/>\" ) ; \n} \nreturn ; \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( ( dirBlock == null ) || ( ad == null ) ) { \nreturn ; \n} \nfor ( int i = 1 ; \ni < 14 ; \ni ++ ) { \nif ( i == 7 ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4819": "public class AreaReader { \nprivate void setNavBlockAttributes ( Variable v ) { \nif ( ( navBlock == null ) || ( ad == null ) ) { \nreturn ; \n} \nv . addAttribute ( new Attribute ( \"navigation_type\" , McIDASUtil . intBitsToString ( navBlock [ 0 ] ) ) ) ; \nreturn ; \n} \n} \n"}
{"4821": "public class AreaReader { \nprivate void setCalTypeAttributes ( Variable image , int calType ) { \nString longName = \"image values\" ; \nswitch ( calType ) { \ncase Calibrator . CAL_ALB : longName = \"albedo\" ; \nbreak ; \ncase Calibrator . CAL_BRIT : longName = \"brightness values\" ; \nbreak ; \ncase Calibrator . CAL_TEMP : longName = \"temperature\" ; \nbreak ; \ncase Calibrator . CAL_RAD : longName = \"pixel radiance values\" ; \nbreak ; \ncase Calibrator . CAL_RAW : longName = \"raw image values\" ; \nbreak ; \ndefault : break ; \n} \nimage . addAttribute ( new Attribute ( \"long_name\" , longName ) ) ; \nif ( calUnit != null ) { \nimage . addAttribute ( new Attribute ( CDM . UNITS , calUnit ) ) ; \n} \nif ( calScale != 1.f ) { \nimage . addAttribute ( new Attribute ( \"scale_factor\" , calScale ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4822": "public class CoordSysEvaluator { \nstatic public void findCoords ( TableConfig nt , NetcdfDataset ds , Predicate p ) { \nnt . lat = findCoordShortNameByType ( ds , AxisType . Lat , p ) ; \nnt . lon = findCoordShortNameByType ( ds , AxisType . Lon , p ) ; \nnt . time = findCoordShortNameByType ( ds , AxisType . Time , p ) ; \nnt . elev = findCoordShortNameByType ( ds , AxisType . Height , p ) ; \nif ( nt . elev == null ) nt . elev = findCoordShortNameByType ( ds , AxisType . Pressure , p ) ; \nreturn ; \n} \n} \n"}
{"4830": "public class DSequence { \nprivate void oldDeserialize ( DataInputStream source , ServerVersion sv , StatusUI statusUI ) throws IOException , DataReadException { \ntry { \nfor ( ; \n; \n) { \ndeserializeSingle ( source , sv , statusUI ) ; \n} \n} \ncatch ( EOFException e ) { \n} \nreturn ; \n} \n} \n"}
{"4832": "public class DSequence { \nprotected void writeMarker ( DataOutputStream sink , byte marker ) throws IOException { \nsink . writeByte ( marker ) ; \nsink . writeByte ( ( byte ) 0 ) ; \nsink . writeByte ( ( byte ) 0 ) ; \nsink . writeByte ( ( byte ) 0 ) ; \nreturn ; \n} \n} \n"}
{"4833": "public class SaxEventHandler { \n@ Override public void fatalError ( SAXParseException e ) throws SAXException { \nthrow new SAXParseException ( String . format ( \"Sax fatal error: %s; %s%n\" , e , report ( this . locator ) ) , this . locator ) ; \nreturn ; \n} \n} \n"}
{"4835": "public class MultipleAxisChart { \npublic static void main ( String [ ] args ) { \nTimeSeries dataset1 = createDataset ( \"Series 1\" , 100.0 , new Minute ( ) , 200 ) ; \nMultipleAxisChart demo = new MultipleAxisChart ( \"Multiple Axis Demo 1\" , \"Time of Day\" , \"Primary Range Axis\" , dataset1 ) ; \nTimeSeries dataset2 = createDataset ( \"Series 2\" , 1000.0 , new Minute ( ) , 170 ) ; \ndemo . addSeries ( \"Range Axis 2\" , dataset2 ) ; \nTimeSeries dataset3 = createDataset ( \"Series 3\" , 10000.0 , new Minute ( ) , 170 ) ; \ndemo . addSeries ( \"Range Axis 3\" , dataset3 ) ; \nTimeSeries dataset4 = createDataset ( \"Series 4\" , 25.0 , new Minute ( ) , 200 ) ; \ndemo . addSeries ( \"Range Axis 4\" , dataset4 ) ; \ndemo . finish ( new java . awt . Dimension ( 600 , 270 ) ) ; \nJFrame frame = new JFrame ( \"Demovabulous \" ) ; \nframe . getContentPane ( ) . add ( demo , BorderLayout . CENTER ) ; \nframe . setSize ( 640 , 480 ) ; \nframe . setVisible ( true ) ; \nframe . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; \nreturn ; \n} \n} \n"}
{"4838": "public class StationRegionDateChooser { \npublic void setStations ( java . util . List stns ) { \nstnRender . setStations ( stns ) ; \nredraw ( true ) ; \nreturn ; \n} \n} \n"}
{"4839": "public class StationRegionDateChooser { \npublic void setSelectedStation ( String id ) { \nstnRender . setSelectedStation ( id ) ; \nselectedStation = stnRender . getSelectedStation ( ) ; \nassert selectedStation != null ; \nnp . setLatLonCenterMapArea ( selectedStation . getLatitude ( ) , selectedStation . getLongitude ( ) ) ; \nredraw ( ) ; \nreturn ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \nfor ( int i = 0 ; \ni < renderers . size ( ) ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \nreturn ; \n} \n} \n"}
{"4841": "public class ProjectionRect { \nprivate void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { \ndouble x = s . readDouble ( ) ; \ndouble y = s . readDouble ( ) ; \ndouble w = s . readDouble ( ) ; \ndouble h = s . readDouble ( ) ; \nsetRect ( x , y , w , h ) ; \nreturn ; \n} \n} \n"}
{"4842": "public class ProjectionRect { \nprivate void writeObject ( ObjectOutputStream s ) throws IOException { \ns . writeDouble ( getX ( ) ) ; \ns . writeDouble ( getY ( ) ) ; \ns . writeDouble ( getWidth ( ) ) ; \ns . writeDouble ( getHeight ( ) ) ; \nreturn ; \n} \n} \n"}
{"4843": "public class UnitDBImpl { \npublic void add ( final UnitDBImpl that ) throws UnitExistsException { \nunitSet . addAll ( that . unitSet ) ; \nnameMap . putAll ( that . nameMap ) ; \nsymbolMap . putAll ( that . symbolMap ) ; \nreturn ; \n} \n} \n"}
{"4844": "public class UnitDBImpl { \npublic void addUnit ( final Unit unit ) throws UnitExistsException , NameException { \nif ( unit . getName ( ) == null ) { \nthrow new NameException ( \"Unit name can't be null\" ) ; \n} \naddByName ( unit . getName ( ) , unit ) ; \naddByName ( unit . getPlural ( ) , unit ) ; \naddBySymbol ( unit . getSymbol ( ) , unit ) ; \nunitSet . add ( unit ) ; \nreturn ; \n} \n} \n"}
{"4845": "public class UnitDBImpl { \npublic final void addSymbol ( final String symbol , final String name ) throws NoSuchUnitException , UnitExistsException { \naddAlias ( null , name , symbol , null ) ; \nreturn ; \n} \n} \n"}
{"4847": "public class UnitDBImpl { \nprivate final void addByName ( final String name , final Unit newUnit ) throws UnitExistsException { \nif ( name != null ) { \naddUnique ( nameMap , canonicalize ( name ) , newUnit ) ; \n} \nreturn ; \n} \n} \n"}
{"4848": "public class UnitDBImpl { \nprivate final void addBySymbol ( final String symbol , final Unit newUnit ) throws UnitExistsException { \nif ( symbol != null ) { \naddUnique ( symbolMap , symbol , newUnit ) ; \n} \nreturn ; \n} \n} \n"}
{"4849": "public class UnitDBImpl { \nprivate static final void addUnique ( final Map < String , Unit > map , final String key , final Unit newUnit ) throws UnitExistsException { \nfinal Unit oldUnit = map . put ( key , newUnit ) ; \nif ( oldUnit != null && ! oldUnit . equals ( newUnit ) ) { \nthrow new UnitExistsException ( oldUnit , newUnit ) ; \n} \nreturn ; \n} \n} \n"}
{"4850": "public class PLAF { \npublic void addToMenu ( final JMenu menu ) { \nfinal UIManager . LookAndFeelInfo [ ] plafInfo = UIManager . getInstalledLookAndFeels ( ) ; \nfor ( UIManager . LookAndFeelInfo aPlafInfo : plafInfo ) { \naddToMenu ( aPlafInfo . getName ( ) , aPlafInfo . getClassName ( ) , menu ) ; \n} \nfinal LookAndFeel current = UIManager . getLookAndFeel ( ) ; \nSystem . out . printf ( \"current L&F=%s%n\" , current . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"4853": "public class NcSDStructure { \npublic void serialize ( String dataset , DataOutputStream sink , CEEvaluator ce , Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nif ( org == null ) { \nsuper . serialize ( dataset , sink , ce , specialO ) ; \nreturn ; \n} \njava . util . Enumeration vars = org . getVariables ( ) ; \nStructureMembers sm = sdata . getStructureMembers ( ) ; \nint count = 0 ; \nwhile ( vars . hasMoreElements ( ) ) { \nHasNetcdfVariable sm_org = ( HasNetcdfVariable ) vars . nextElement ( ) ; \nboolean isProjected = ( ( ServerMethods ) sm_org ) . isProject ( ) ; \nif ( isProjected ) { \nStructureMembers . Member m = sm . getMember ( count ) ; \nsm_org . serialize ( sink , sdata , m ) ; \n} \ncount ++ ; \n} \nreturn ; \n} \n} \n"}
{"4859": "public class ThreddsDataFactory { \npublic static void annotate ( InvDataset ds , NetcdfDataset ncDataset ) { \nncDataset . setTitle ( ds . getName ( ) ) ; \nncDataset . setId ( ds . getID ( ) ) ; \nfor ( InvProperty p : ds . getProperties ( ) ) { \nString name = p . getName ( ) ; \nif ( null == ncDataset . findGlobalAttribute ( name ) ) { \nncDataset . addAttribute ( null , new Attribute ( name , p . getValue ( ) ) ) ; \n} \n} \nncDataset . finish ( ) ; \nreturn ; \n} \n} \n"}
{"4861": "public class VariableIndexPartitioned { \nvoid addPartition ( int partno , int groupno , int varno , int ndups , int nrecords , int nmissing , GribCollectionMutable . VariableIndex vi ) { \nif ( partList == null ) partList = new ArrayList < > ( nparts ) ; \npartList . add ( new PartitionForVariable2D ( partno , groupno , varno ) ) ; \nthis . ndups += ndups ; \nthis . nrecords += nrecords ; \nthis . nmissing += nmissing ; \nreturn ; \n} \n} \n"}
{"4867": "public class PicturePane { \npublic void setPicture ( URL filenameURL , String legendParam , double rotation ) { \nlegend = legendParam ; \ncenterWhenScaled = true ; \nsclPic . setScaleSize ( getSize ( ) ) ; \nsclPic . stopLoadingExcept ( filenameURL ) ; \nsclPic . loadAndScalePictureInThread ( filenameURL , Thread . MAX_PRIORITY , rotation ) ; \nreturn ; \n} \n} \n"}
{"4868": "public class PicturePane { \npublic void setBufferedImage ( BufferedImage img , String statusMessage ) { \nlegend = statusMessage ; \ncenterWhenScaled = true ; \nDimension dim = getSize ( ) ; \nsclPic . setScaleSize ( dim ) ; \nSourcePicture source = new SourcePicture ( ) ; \nsource . setSourceBufferedImage ( img , statusMessage ) ; \nsclPic . setSourcePicture ( source ) ; \nif ( ! scaleToFit ) sclPic . setScaleFactor ( 1.0 ) ; \nsclPic . scalePicture ( ) ; \nrepaint ( ) ; \nreturn ; \n} \n} \n"}
{"4869": "public class PicturePane { \npublic void zoomToFit ( ) { \nsclPic . setScaleSize ( getSize ( ) ) ; \nif ( sclPic . getStatusCode ( ) == sclPic . LOADED || sclPic . getStatusCode ( ) == sclPic . READY ) { \nsclPic . createScaledPictureInThread ( Thread . MAX_PRIORITY ) ; \n} \nreturn ; \n} \n} \n"}
{"4870": "public class PicturePane { \npublic void paintComponent ( Graphics g ) { \nint WindowWidth = getSize ( ) . width ; \nint WindowHeight = getSize ( ) . height ; \nTools . log ( \"paintComponent called\" ) ; \nif ( Dragging == false ) { \nsetCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; \n} \nif ( sclPic . getScaledPicture ( ) != null ) { \nGraphics2D g2d = ( Graphics2D ) g ; \nint X_Offset = ( int ) ( ( double ) ( WindowWidth / 2 ) - ( focusPoint . x * sclPic . getScaleFactor ( ) ) ) ; \nint Y_Offset = ( int ) ( ( double ) ( WindowHeight / 2 ) - ( focusPoint . y * sclPic . getScaleFactor ( ) ) ) ; \nRectangle clipBounds = g2d . getClipBounds ( ) ; \ng2d . setColor ( Color . black ) ; \ng2d . fillRect ( clipBounds . x , clipBounds . y , clipBounds . width , clipBounds . height ) ; \ng2d . drawRenderedImage ( sclPic . getScaledPicture ( ) , AffineTransform . getTranslateInstance ( X_Offset , Y_Offset ) ) ; \nif ( showInfo ) { \ng2d . setColor ( Color . white ) ; \ng2d . drawString ( legend , infoPoint . x , infoPoint . y ) ; \ng2d . drawString ( \"Size: \" + Integer . toString ( sclPic . getOriginalWidth ( ) ) + \" x \" + Integer . toString ( sclPic . getOriginalHeight ( ) ) + \" Offset: \" + X_Offset + \" x \" + Y_Offset + \" Mid: \" + Integer . toString ( focusPoint . x ) + \" x \" + Integer . toString ( focusPoint . y ) + \" Scale: \" + twoDecimalFormatter . format ( sclPic . getScaleFactor ( ) ) , infoPoint . x , infoPoint . y + lineSpacing ) ; \n} \n} \nelse { \ng . setClip ( 0 , 0 , WindowWidth , WindowHeight ) ; \ng . setColor ( Color . black ) ; \ng . fillRect ( 0 , 0 , WindowWidth , WindowHeight ) ; \n} \nif ( Dragging == false ) { \nsetCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4879": "public class DataDDS { \npublic void readData ( InputStream is , StatusUI statusUI ) throws IOException , EOFException , DAP2Exception { \nBufferedInputStream bufferedIS = new BufferedInputStream ( is ) ; \nDataInputStream dataIS = new DataInputStream ( bufferedIS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nif ( statusUI != null && statusUI . userCancelled ( ) ) throw new DataReadException ( \"User cancelled\" ) ; \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . deserialize ( dataIS , ver , statusUI ) ; \n} \nif ( statusUI != null ) statusUI . finished ( ) ; \nreturn ; \n} \n} \n"}
{"4880": "public class DataDDS { \npublic final void externalize ( OutputStream os , boolean compress , boolean headers ) throws IOException { \nif ( headers ) { \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os , Util . UTF8 ) ) ; \npw . println ( \"HTTP/1.0 200 OK\" ) ; \npw . println ( \"XDAP: \" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"XDODS-Server: DODS/\" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; \npw . println ( \"Content-type: application/octet-stream\" ) ; \npw . println ( \"Content-Description: dods-data\" ) ; \nif ( compress ) { \npw . println ( \"Content-Encoding: deflate\" ) ; \n} \npw . println ( ) ; \npw . flush ( ) ; \n} \nOutputStream bufferedOS ; \nif ( compress ) { \nbufferedOS = new BufferedOutputStream ( new DeflaterOutputStream ( os ) ) ; \n} \nelse { \nbufferedOS = new BufferedOutputStream ( os ) ; \n} \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bufferedOS , Util . UTF8 ) ) ; \nprint ( pw ) ; \npw . flush ( ) ; \nbufferedOS . write ( \"\\nData:\\n\" . getBytes ( CDM . utf8Charset ) ) ; \nbufferedOS . flush ( ) ; \nDataOutputStream dataOS = new DataOutputStream ( bufferedOS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . externalize ( dataOS ) ; \n} \ndataOS . close ( ) ; \nreturn ; \n} \n} \n"}
{"4885": "public class SpatialGrid { \npublic void setGrid ( Rectangle2D bbox , double width , double height ) { \noffsetX = bbox . getX ( ) ; \noffsetY = bbox . getY ( ) ; \ncountX = Math . min ( nx , ( int ) ( bbox . getWidth ( ) / ( scaleOverlap * width ) ) ) ; \ncountY = Math . min ( ny , ( int ) ( bbox . getHeight ( ) / ( scaleOverlap * height ) ) ) ; \ngridWidth = bbox . getWidth ( ) / countX ; \ngridHeight = bbox . getHeight ( ) / countY ; \nif ( debug ) System . out . println ( \"SpatialGrid size \" + gridWidth + \" \" + gridHeight + \" = \" + countX + \" by \" + countY + \" scaleOverlap= \" + scaleOverlap ) ; \nreturn ; \n} \n} \n"}
{"4886": "public class SpatialGrid { \npublic void setOverlap ( int overlap ) { \ndouble dover = Math . max ( 0.0 , Math . min ( .01 * overlap , .50 ) ) ; \nscaleOverlap = 1.0 - dover ; \nreturn ; \n} \n} \n"}
{"4887": "public class SpatialGrid { \npublic void clear ( ) { \nfor ( int y = 0 ; \ny < countY ; \ny ++ ) for ( int x = 0 ; \nx < countX ; \nx ++ ) gridArray [ y ] [ x ] . used = false ; \nreturn ; \n} \n} \n"}
{"4916": "public class RecordDatasetHelper { \npublic void setStationInfo ( String stnIdVName , String stnDescVName , String stnIndexVName , StationHelper stationHelper ) { \nthis . stnIdVName = stnIdVName ; \nthis . stnDescVName = stnDescVName ; \nthis . stnIndexVName = stnIndexVName ; \nthis . stationHelper = stationHelper ; \nif ( stnIdVName != null ) { \nVariable stationVar = ncfile . findVariable ( stnIdVName ) ; \nstationIdType = stationVar . getDataType ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4917": "public class RecordDatasetHelper { \npublic void setShortNames ( String latVName , String lonVName , String altVName , String obsTimeVName , String nomTimeVName ) { \nthis . latVName = latVName ; \nthis . lonVName = lonVName ; \nthis . zcoordVName = altVName ; \nthis . obsTimeVName = obsTimeVName ; \nthis . nomTimeVName = nomTimeVName ; \nreturn ; \n} \n} \n"}
{"4919": "public class DapGroup { \npublic void addDecl ( DapNode newdecl ) throws DapException { \nDapSort newsort = newdecl . getSort ( ) ; \nString newname = newdecl . getShortName ( ) ; \nboolean suppress = false ; \nif ( newsort != DapSort . DIMENSION || newname != null ) { \nfor ( DapNode decl : decls ) { \nif ( newsort == decl . getSort ( ) && newname . equals ( decl . getShortName ( ) ) ) throw new DapException ( \"DapGroup: attempt to add duplicate decl: \" + newname ) ; \n} \n} \nelse { \nDapDimension anon = ( DapDimension ) newdecl ; \nassert ( newsort == DapSort . DIMENSION && newname == null ) ; \nboolean found = false ; \nfor ( DapDimension dim : dimensions ) { \nif ( ! dim . isShared ( ) && dim . getSize ( ) == anon . getSize ( ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found && ! isTopLevel ( ) ) getDataset ( ) . addDecl ( anon ) ; \nsuppress = found || ! isTopLevel ( ) ; \n} \nif ( ! suppress ) { \ndecls . add ( newdecl ) ; \nnewdecl . setParent ( this ) ; \n} \nswitch ( newdecl . getSort ( ) ) { \ncase ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : super . addAttribute ( ( DapAttribute ) newdecl ) ; \nbreak ; \ncase DIMENSION : if ( ! suppress ) dimensions . add ( ( DapDimension ) newdecl ) ; \nbreak ; \ncase ENUMERATION : enums . add ( ( DapEnumeration ) newdecl ) ; \nbreak ; \ncase ATOMICTYPE : break ; \ncase STRUCTURE : case SEQUENCE : compounds . add ( ( DapStructure ) newdecl ) ; \nbreak ; \ncase VARIABLE : variables . add ( ( DapVariable ) newdecl ) ; \nbreak ; \ncase GROUP : case DATASET : if ( this != ( DapGroup ) newdecl ) groups . add ( ( DapGroup ) newdecl ) ; \nbreak ; \ndefault : throw new ClassCastException ( newdecl . getShortName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4920": "public class DapGroup { \nvoid updateGroups ( List < DapGroup > groups ) { \nassert ( groups . size ( ) == this . groups . size ( ) ) : \"Update groups: not same size\" ; \nfor ( DapGroup g : groups ) { \nif ( ! this . groups . contains ( g ) ) assert ( false ) : \"Update groups: attempt to add new group\" ; \n} \nreturn ; \n} \n} \n"}
{"4926": "public class HTTPSession { \nstatic synchronized protected void setDefaults ( Map < Prop , Object > props ) { \nif ( false ) { \nprops . put ( Prop . HANDLE_AUTHENTICATION , Boolean . TRUE ) ; \n} \nprops . put ( Prop . HANDLE_REDIRECTS , Boolean . TRUE ) ; \nprops . put ( Prop . ALLOW_CIRCULAR_REDIRECTS , Boolean . TRUE ) ; \nprops . put ( Prop . MAX_REDIRECTS , ( Integer ) DFALTREDIRECTS ) ; \nprops . put ( Prop . SO_TIMEOUT , ( Integer ) DFALTSOTIMEOUT ) ; \nprops . put ( Prop . CONN_TIMEOUT , ( Integer ) DFALTCONNTIMEOUT ) ; \nprops . put ( Prop . CONN_REQ_TIMEOUT , ( Integer ) DFALTCONNREQTIMEOUT ) ; \nprops . put ( Prop . USER_AGENT , DFALTUSERAGENT ) ; \nreturn ; \n} \n} \n"}
{"4930": "public class HTTPSession { \nsynchronized public void close ( ) { \nif ( this . closed ) return ; \nclosed = true ; \nfor ( HTTPMethod m : this . methods ) { \nm . close ( ) ; \n} \nmethods . clear ( ) ; \nreturn ; \n} \n} \n"}
{"4931": "public class HTTPSession { \nsynchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { \ncb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; \nAuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; \nCredentialsProvider cp = null ; \nif ( bestMatch != null ) { \ncp = localcreds . get ( bestMatch ) ; \n} \nelse { \nbestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; \nif ( bestMatch != null ) { \nHTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; \ncp = factory . getProvider ( bestMatch ) ; \n} \n} \nCredentials proxycreds = null ; \nAuthScope proxyscope = null ; \nString user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; \nString pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; \nHttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; \nHttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; \nif ( user != null && ( httpproxy != null || httpsproxy != null ) ) { \nif ( httpproxy != null ) proxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; \nelse proxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; \nproxycreds = new UsernamePasswordCredentials ( user , pwd ) ; \n} \nif ( cp == null && proxycreds != null && proxyscope != null ) { \ncp = new BasicCredentialsProvider ( ) ; \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nelse if ( cp != null && proxycreds != null && proxyscope != null ) { \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nif ( cp != null ) this . sessioncontext . setCredentialsProvider ( cp ) ; \nreturn ; \n} \n} \n"}
{"4932": "public class HTTPSession { \nstatic protected synchronized void track ( HTTPSession session ) { \nif ( ! TESTING ) throw new UnsupportedOperationException ( ) ; \nif ( sessionList == null ) sessionList = new ConcurrentSkipListSet < HTTPSession > ( ) ; \nsessionList . add ( session ) ; \nreturn ; \n} \n} \n"}
{"4933": "public class HTTPSession { \n@ Deprecated static public void setGlobalCredentialsProvider ( AuthScope scope , CredentialsProvider provider ) throws HTTPException { \nsetGlobalCredentialsProvider ( provider , scope ) ; \nreturn ; \n} \n} \n"}
{"4934": "public class TextGetPutPane { \nvoid validate ( String urlString ) { \nif ( urlString == null ) return ; \nURI uri ; \ntry { \nuri = new URI ( urlString ) ; \n} \ncatch ( URISyntaxException e ) { \njavax . swing . JOptionPane . showMessageDialog ( null , \"URISyntaxException on URL (\" + urlString + \") \" + e . getMessage ( ) + \"\\n\" ) ; \nreturn ; \n} \nString contents = getText ( ) ; \nByteArrayInputStream is = new ByteArrayInputStream ( contents . getBytes ( CDM . utf8Charset ) ) ; \ntry { \nCatalogBuilder catFactory = new CatalogBuilder ( ) ; \nCatalog cat = catFactory . buildFromLocation ( urlString , null ) ; \nboolean isValid = ! catFactory . hasFatalError ( ) ; \njavax . swing . JOptionPane . showMessageDialog ( this , \"Catalog Validation = \" + isValid + \"\\n\" + catFactory . getErrorMessage ( ) ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"4945": "public class Index { \npublic void setDim ( int dim , int value ) { \nif ( value < 0 || value >= shape [ dim ] ) throw new ArrayIndexOutOfBoundsException ( ) ; \nif ( shape [ dim ] >= 0 ) current [ dim ] = value ; \nreturn ; \n} \n} \n"}
{"4957": "public class IndentWriter { \npublic void indent ( int n ) { \ndepth += n ; \nif ( depth < 0 ) depth = 0 ; \nelse if ( depth > MAXDEPTH ) depth = MAXDEPTH ; \nreturn ; \n} \n} \n"}
{"4958": "public class IndentWriter { \npublic void setIndent ( int n ) { \ndepth = n ; \nif ( depth < 0 ) depth = 0 ; \nelse if ( depth > MAXDEPTH ) depth = MAXDEPTH ; \nreturn ; \n} \n} \n"}
{"4960": "public class MFileCollectionManager { \npublic void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { \nCompositeMFileFilter filters = new CompositeMFileFilter ( ) ; \nif ( null != regexpPatternString ) filters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; \nelse if ( suffix != null ) filters . addIncludeFilter ( new WildcardMatchOnPath ( \"*\" + suffix + \"$\" ) ) ; \nif ( olderS != null ) { \ntry { \nTimeDuration tu = new TimeDuration ( olderS ) ; \nfilters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( collectionName + \": Invalid time unit for olderThan = {}\" , olderS ) ; \n} \n} \nboolean wantSubdirs = true ; \nif ( ( subdirsS != null ) && subdirsS . equalsIgnoreCase ( \"false\" ) ) wantSubdirs = false ; \nCollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; \nStringBuilder sb = new StringBuilder ( dirName ) ; \nif ( wantSubdirs ) sb . append ( \"**/\" ) ; \nif ( null != regexpPatternString ) sb . append ( regexpPatternString ) ; \nelse if ( suffix != null ) sb . append ( suffix ) ; \nelse sb . append ( \"noFilter\" ) ; \ncollectionName = sb . toString ( ) ; \nscanList . add ( mc ) ; \nreturn ; \n} \n} \n"}
{"4963": "public class FileWriter2 { \npublic static void setDebugFlags ( ucar . nc2 . util . DebugFlags debugFlags ) { \ndebug = debugFlags . isSet ( \"ncfileWriter2/debug\" ) ; \ndebugWrite = debugFlags . isSet ( \"ncfileWriter2/debugWrite\" ) ; \ndebugChunk = debugFlags . isSet ( \"ncfileWriter2/debugChunk\" ) ; \nreturn ; \n} \n} \n"}
{"4966": "public class MarshallingUtil { \npublic static void validate ( XmlObject doc , boolean strict ) throws XmlException { \nSet < XmlError > validationErrors = new HashSet < > ( ) ; \nXmlOptions validationOptions = new XmlOptions ( ) ; \nvalidationOptions . setErrorListener ( validationErrors ) ; \nfinal boolean isValid = doc . validate ( validationOptions ) ; \nif ( ! isValid && ! strict ) { \nvalidationErrors = filterToOnlySerious ( validationErrors ) ; \n} \nif ( ! validationErrors . isEmpty ( ) ) { \nthrow new XmlException ( createErrorMessage ( validationErrors ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4968": "public class StructureDS { \npublic void setOriginalVariable ( ucar . nc2 . Variable orgVar ) { \nif ( ! ( orgVar instanceof Structure ) ) throw new IllegalArgumentException ( \"StructureDS must wrap a Structure; name=\" + orgVar . getFullName ( ) ) ; \nthis . orgVar = ( Structure ) orgVar ; \nreturn ; \n} \n} \n"}
{"4973": "public class StructureDS { \nprivate void convertMemberInfo ( StructureMembers wrapperSm ) { \nfor ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { \nVariable v = findVariable ( m . getName ( ) ) ; \nif ( ( v == null ) && ( orgVar != null ) ) v = ( Variable ) findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v != null ) { \nm . setVariableInfo ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) ) ; \n} \nif ( v instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v ; \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"4976": "public class StructureDS { \npublic void enhance ( Set < NetcdfDataset . Enhance > mode ) { \nfor ( Variable v : getVariables ( ) ) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nve . enhance ( mode ) ; \n} \nreturn ; \n} \n} \n"}
{"4981": "public class GempakSoundingIOSP { \nprivate void addVerticalCoordAttribute ( Variable v ) { \nGempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; \nint vertType = gsfr . getVerticalCoordinate ( ) ; \nString pName = v . getFullName ( ) ; \nif ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) { \nif ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \nelse if ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( \"HGHT\" ) || pName . equals ( \"MHGT\" ) || pName . equals ( \"DHGT\" ) ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; \n} \n} \nelse if ( pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"4982": "public class InvCatalogFactory { \npublic void readXMLasynch ( String uriString , CatalogSetCallback callback ) { \nInvCatalogImpl cat = readXML ( uriString ) ; \ncallback . setCatalog ( cat ) ; \nreturn ; \n} \n} \n"}
{"4985": "public class InvCatalogFactory { \npublic void writeXML ( InvCatalogImpl catalog , OutputStream os , boolean raw ) throws IOException { \nInvCatalogConvertIF converter = this . getCatalogConverter ( XMLEntityResolver . CATALOG_NAMESPACE_10 ) ; \nconverter . writeXML ( catalog , os , raw ) ; \nreturn ; \n} \n} \n"}
{"4998": "public class DOM4Parser { \nprotected void parseresponse ( Node root ) throws ParseException { \nString elemname = root . getNodeName ( ) ; \nif ( elemname . equalsIgnoreCase ( \"Error\" ) ) { \nparseerror ( root ) ; \n} \nelse if ( elemname . equalsIgnoreCase ( \"Dataset\" ) ) { \nparsedataset ( root ) ; \n} \nelse throw new ParseException ( \"Unexpected response root: \" + elemname ) ; \nreturn ; \n} \n} \n"}
{"4999": "public class DOM4Parser { \nprotected void passReserved ( Node node , DapNode dap ) throws ParseException { \ntry { \nNamedNodeMap attrs = node . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrs . getLength ( ) ; \ni ++ ) { \nNode n = attrs . item ( i ) ; \nString key = n . getNodeName ( ) ; \nString value = n . getNodeValue ( ) ; \nif ( isReserved ( key ) ) dap . addXMLAttribute ( key , value ) ; \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \nreturn ; \n} \n} \n"}
{"5002": "public class ArrayStructureMA { \npublic void setMemberArray ( String memberName , Array data ) { \nStructureMembers . Member m = members . findMember ( memberName ) ; \nm . setDataArray ( data ) ; \nreturn ; \n} \n} \n"}
{"5006": "public class CECompiler { \nprotected void compileAST ( CEAST ast ) throws DapException { \nswitch ( ast . sort ) { \ncase CONSTRAINT : for ( CEAST clause : ast . clauses ) { \ncompileAST ( clause ) ; \n} \nthis . ce . expand ( ) ; \nthis . ce . finish ( ) ; \nbreak ; \ncase PROJECTION : scopestack . clear ( ) ; \ncompileAST ( ast . tree ) ; \nbreak ; \ncase SEGMENT : compilesegment ( ast ) ; \nbreak ; \ncase SELECTION : scopestack . clear ( ) ; \ncompileselection ( ast ) ; \nbreak ; \ncase DEFINE : dimredef ( ast ) ; \nbreak ; \ndefault : assert false : \"uknown CEAST node type\" ; \n} \nreturn ; \n} \n} \n"}
{"5007": "public class CECompiler { \npublic void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { \nif ( expr == null ) return ; \nif ( expr . sort == CEAST . Sort . SEGMENT ) { \nif ( expr . subnodes != null ) throw new DapException ( \"compilefilter: Non-simple segment:\" + expr . name ) ; \nDapVariable field = seq . findByName ( expr . name ) ; \nif ( field == null ) throw new DapException ( \"compilefilter: Unknown filter variable:\" + expr . name ) ; \nexpr . field = field ; \n} \nelse if ( expr . sort == CEAST . Sort . EXPR ) { \nif ( expr . lhs != null ) compilefilter ( var , seq , expr . lhs ) ; \nif ( expr . rhs != null ) compilefilter ( var , seq , expr . rhs ) ; \nif ( expr . lhs != null && expr . rhs != null ) { \nboolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; \nboolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; \nif ( rightvar && ! leftvar ) { \nCEAST tmp = expr . lhs ; \nexpr . lhs = expr . rhs ; \nexpr . rhs = tmp ; \nswitch ( expr . op ) { \ncase LT : expr . op = CEAST . Operator . GT ; \nbreak ; \ncase LE : expr . op = CEAST . Operator . GE ; \nbreak ; \ncase GT : expr . op = CEAST . Operator . LT ; \nbreak ; \ncase GE : expr . op = CEAST . Operator . LE ; \nbreak ; \ndefault : break ; \n} \n} \n} \n} \nelse if ( expr . sort == CEAST . Sort . CONSTANT ) { \nreturn ; \n} \nelse throw new DapException ( \"compilefilter: Unexpected node type:\" + expr . sort ) ; \nreturn ; \n} \n} \n"}
{"5008": "public class CECompiler { \nprotected void dimredef ( CEAST node ) throws DapException { \nDapDimension dim = ( DapDimension ) dataset . findByFQN ( node . name , DapSort . DIMENSION ) ; \nif ( dim == null ) throw new DapException ( \"Constraint dim redef: no dimension name: \" + node . name ) ; \nSlice slice = node . slice ; \nslice . finish ( ) ; \nce . addRedef ( dim , slice ) ; \nreturn ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) { \nif ( d1 > d2 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \nelse { \nif ( lon > upperRight . getLongitude ( ) ) { \nif ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse if ( lon < lowerLeft . getLongitude ( ) ) { \nif ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \nreturn ; \n} \n} \n"}
{"5012": "public class LatLonRect { \npublic void extend ( LatLonRect r ) { \nPreconditions . checkNotNull ( r ) ; \ndouble latMin = r . getLatMin ( ) ; \ndouble latMax = r . getLatMax ( ) ; \nif ( latMax > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( latMax ) ; \n} \nif ( latMin < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( latMin ) ; \n} \nif ( allLongitude ) return ; \ndouble lonMin = getLonMin ( ) ; \ndouble lonMax = getLonMax ( ) ; \ndouble nlonMin = LatLonPointImpl . lonNormal ( r . getLonMin ( ) , lonMin ) ; \ndouble nlonMax = nlonMin + r . getWidth ( ) ; \nlonMin = Math . min ( lonMin , nlonMin ) ; \nlonMax = Math . max ( lonMax , nlonMax ) ; \nwidth = lonMax - lonMin ; \nallLongitude = width >= 360.0 ; \nif ( allLongitude ) { \nwidth = 360.0 ; \nlonMin = - 180.0 ; \n} \nelse { \nlonMin = LatLonPointImpl . lonNormal ( lonMin ) ; \n} \nlowerLeft . setLongitude ( lonMin ) ; \nupperRight . setLongitude ( lonMin + width ) ; \nlon0 = lonMin + width / 2 ; \ncrossDateline = lowerLeft . getLongitude ( ) > upperRight . getLongitude ( ) ; \nreturn ; \n} \n} \n"}
{"5018": "public class MAMath { \npublic static void copy ( Array result , Array a ) throws IllegalArgumentException { \nClass classType = a . getElementType ( ) ; \nif ( classType == double . class ) { \ncopyDouble ( result , a ) ; \n} \nelse if ( classType == float . class ) { \ncopyFloat ( result , a ) ; \n} \nelse if ( classType == long . class ) { \ncopyLong ( result , a ) ; \n} \nelse if ( classType == int . class ) { \ncopyInt ( result , a ) ; \n} \nelse if ( classType == short . class ) { \ncopyShort ( result , a ) ; \n} \nelse if ( classType == char . class ) { \ncopyChar ( result , a ) ; \n} \nelse if ( classType == byte . class ) { \ncopyByte ( result , a ) ; \n} \nelse if ( classType == boolean . class ) { \ncopyBoolean ( result , a ) ; \n} \nelse copyObject ( result , a ) ; \nreturn ; \n} \n} \n"}
{"5019": "public class MAMath { \npublic static void copyBoolean ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) throw new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nwhile ( iterA . hasNext ( ) ) iterR . setBooleanNext ( iterA . getBooleanNext ( ) ) ; \nreturn ; \n} \n} \n"}
{"5020": "public class MAMath { \npublic static void copyObject ( Array result , Array a ) throws IllegalArgumentException { \nif ( ! conformable ( a , result ) ) throw new IllegalArgumentException ( \"copy arrays are not conformable\" ) ; \nIndexIterator iterA = a . getIndexIterator ( ) ; \nIndexIterator iterR = result . getIndexIterator ( ) ; \nwhile ( iterA . hasNext ( ) ) { \niterR . setObjectNext ( iterA . getObjectNext ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5022": "public class MAMath { \npublic static void setDouble ( Array result , double val ) { \nIndexIterator iter = result . getIndexIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \niter . setDoubleNext ( val ) ; \n} \nreturn ; \n} \n} \n"}
{"5037": "public class D4DataCompiler { \npublic void compile ( ) throws DapException { \nassert ( this . dataset != null && this . databuffer != null ) ; \nfor ( DapVariable vv : this . dataset . getTopVariables ( ) ) { \nD4Cursor data = compileVar ( vv , null ) ; \nthis . dsp . addVariableData ( vv , data ) ; \n} \nreturn ; \n} \n} \n"}
{"5045": "public class PrefPanel { \npublic void setFieldValue ( String name , Object value ) { \nField fld = getField ( name ) ; \nif ( fld == null ) throw new IllegalArgumentException ( \"no field named \" + name ) ; \nfld . setValue ( value ) ; \nreturn ; \n} \n} \n"}
{"5055": "public class PrefPanel { \npublic void addHeading ( String heading , int row ) { \nlayoutComponents . add ( new LayoutComponent ( heading , 0 , row , null ) ) ; \nreturn ; \n} \n} \n"}
{"5056": "public class PrefPanel { \npublic void addComponent ( Component comp , int col , int row , String constraint ) { \nlayoutComponents . add ( new LayoutComponent ( comp , col , row , constraint ) ) ; \nreturn ; \n} \n} \n"}
{"5057": "public class PrefPanel { \npublic void addEmptyRow ( int row , int size ) { \nlayoutComponents . add ( new LayoutComponent ( null , size , row , null ) ) ; \nreturn ; \n} \n} \n"}
{"5068": "public class Grib1ParamTables { \npublic static void addParameterTable ( int center , int subcenter , int tableVersion , String tableFilename ) { \nGrib1ParamTableReader table = new Grib1ParamTableReader ( center , subcenter , tableVersion , tableFilename ) ; \nsynchronized ( lock ) { \nstandardLookup . tables . add ( standardTablesStart , table ) ; \nstandardTablesStart ++ ; \n} \nreturn ; \n} \n} \n"}
{"5071": "public class Vis5DIosp { \nprivate static void initUnitTable ( ) { \nunitTable = new Hashtable < > ( ) ; \nunitTable . put ( \"t\" , \"K\" ) ; \nunitTable . put ( \"td\" , \"K\" ) ; \nunitTable . put ( \"thte\" , \"K\" ) ; \nunitTable . put ( \"u\" , \"m/s\" ) ; \nunitTable . put ( \"v\" , \"m/s\" ) ; \nunitTable . put ( \"w\" , \"m/s\" ) ; \nunitTable . put ( \"p\" , \"hPa\" ) ; \nunitTable . put ( \"mmsl\" , \"hPa\" ) ; \nunitTable . put ( \"rh\" , \"%\" ) ; \nunitTable . put ( \"rhfz\" , \"%\" ) ; \nunitTable . put ( \"zagl\" , \"m\" ) ; \nreturn ; \n} \n} \n"}
{"5078": "public class StandardUnitDB { \nprivate void aa ( final String alias , final String name ) throws UnitExistsException , NoSuchUnitException , UnitParseException , SpecificationException , UnitDBException , PrefixDBException , OperationException , NameException , UnitSystemException { \naa ( alias , name , null ) ; \nreturn ; \n} \n} \n"}
{"5079": "public class StandardUnitDB { \nprivate void as ( final String symbol , final String name ) throws UnitExistsException , NoSuchUnitException , UnitParseException , SpecificationException , UnitDBException , PrefixDBException , OperationException , NameException , UnitSystemException { \naddSymbol ( symbol , name ) ; \nreturn ; \n} \n} \n"}
{"5081": "public class StructureTable { \npublic void setStructureData ( List < StructureData > structureData ) throws IOException { \ndataModel = new StructureDataModel ( structureData ) ; \ninitTable ( dataModel ) ; \nreturn ; \n} \n} \n"}
{"5082": "public class StructureTable { \npublic void setPointFeatureData ( List < PointFeature > obsData ) throws IOException { \ndataModel = new PointFeatureDataModel ( obsData ) ; \ninitTable ( dataModel ) ; \nreturn ; \n} \n} \n"}
{"5083": "public class GisFeatureRenderer { \npublic void draw ( java . awt . Graphics2D g , AffineTransform pixelAT ) { \ng . setColor ( color ) ; \ng . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; \ng . setStroke ( new java . awt . BasicStroke ( 0.0f ) ) ; \nRectangle2D clipRect = ( Rectangle2D ) g . getClip ( ) ; \nIterator siter = getShapes ( g , pixelAT ) ; \nwhile ( siter . hasNext ( ) ) { \nShape s = ( Shape ) siter . next ( ) ; \nRectangle2D shapeBounds = s . getBounds2D ( ) ; \nif ( shapeBounds . intersects ( clipRect ) ) g . draw ( s ) ; \n} \nreturn ; \n} \n} \n"}
{"5085": "public class BufrSplitter { \npublic void processStream ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = processBuffer ( b , is ) ; \nif ( b . done ) break ; \n} \nreturn ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead ++ ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \n} \nbytesRemaining = bytesRead ; \nreturn ; \n} \n} \n"}
{"5090": "public class GridVertCoord { \nvoid addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( ! isVertDimensionUsed ( ) ) return ; \nint nlevs = levels . size ( ) ; \nif ( coordValues != null ) nlevs = coordValues . length ; \nncfile . addDimension ( g , new Dimension ( getVariableName ( ) , nlevs , true ) ) ; \nreturn ; \n} \n} \n"}
{"5093": "public class NOWRadiosp { \npublic void open ( ucar . unidata . io . RandomAccessFile raf , ucar . nc2 . NetcdfFile file , ucar . nc2 . util . CancelTask cancelTask ) throws IOException { \nsuper . open ( raf , ncfile , cancelTask ) ; \nheaderParser = new NOWRadheader ( ) ; \ntry { \nheaderParser . read ( this . raf , ncfile ) ; \n} \ncatch ( Exception e ) { \n} \npcode = 0 ; \nncfile . finish ( ) ; \nreturn ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; \nddsvars . add ( v ) ; \nboolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) continue ; \nList < Dimension > dimset = v . getDimensions ( ) ; \nint rank = dimset . size ( ) ; \nfor ( int i = 0 ; \nisgridarray && i < rank ; \ni ++ ) { \nDimension dim = dimset . get ( i ) ; \nif ( dim . getShortName ( ) == null ) isgridarray = false ; \nelse { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) isgridarray = false ; \n} \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nreturn ; \n} \n} \n"}
{"5098": "public class NavigatedPanel { \nvoid fireMapAreaEvent ( ) { \nif ( debugZoom ) System . out . println ( \"NP.fireMapAreaEvent \" ) ; \nif ( project . isLatLon ( ) ) { \nLatLonProjection llproj = ( LatLonProjection ) project ; \nProjectionRect box = getMapArea ( ) ; \ndouble center = llproj . getCenterLon ( ) ; \ndouble lonBeg = LatLonPointImpl . lonNormal ( box . getMinX ( ) , center ) ; \ndouble lonEnd = lonBeg + box . getMaxX ( ) - box . getMinX ( ) ; \nboolean showShift = Debug . isSet ( \"projection/LatLonShift\" ) || debugNewProjection ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: min,max = \" + box . getMinX ( ) + \" \" + box . getMaxX ( ) + \" beg,end= \" + lonBeg + \" \" + lonEnd + \" center = \" + center ) ; \nif ( ( lonBeg < center - 180 ) || ( lonEnd > center + 180 ) ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: shift center to \" + wx0 + \"->\" + newWx0 ) ; \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \n} \nlmMapArea . sendEvent ( new NewMapAreaEvent ( this , getMapArea ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"5099": "public class NavigatedPanel { \npublic void setMapArea ( ProjectionRect ma ) { \nif ( debugBB ) System . out . println ( \"NP.setMapArea \" + ma ) ; \nnavigate . setMapArea ( ma ) ; \nreturn ; \n} \n} \n"}
{"5100": "public class NavigatedPanel { \npublic void setMapArea ( LatLonRect llbb ) { \nif ( debugBB ) System . out . println ( \"NP.setMapArea (ll) \" + llbb ) ; \nnavigate . setMapArea ( project . latLonToProjBB ( llbb ) ) ; \nreturn ; \n} \n} \n"}
{"5101": "public class NavigatedPanel { \npublic void setLatLonCenterMapArea ( double lat , double lon ) { \nProjectionPoint center = project . latLonToProj ( lat , lon ) ; \nProjectionRect ma = getMapArea ( ) ; \nma . setX ( center . getX ( ) - ma . getWidth ( ) / 2 ) ; \nma . setY ( center . getY ( ) - ma . getHeight ( ) / 2 ) ; \nsetMapArea ( ma ) ; \nreturn ; \n} \n} \n"}
{"5102": "public class NavigatedPanel { \npublic void setProjectionImpl ( ProjectionImpl p ) { \nif ( geoSelection != null ) { \nLatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; \nsetGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; \n} \nproject = p ; \nnavigate . setMapArea ( project . getDefaultMapArea ( ) ) ; \nif ( Debug . isSet ( \"projection/set\" ) || debugNewProjection ) System . out . println ( \"projection/set NP=\" + project ) ; \nif ( hasReference ) { \nrefWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5103": "public class NavigatedPanel { \npublic void addActionsToMenu ( JMenu menu ) { \nBAMutil . addActionToMenu ( menu , zoomIn ) ; \nBAMutil . addActionToMenu ( menu , zoomOut ) ; \nBAMutil . addActionToMenu ( menu , zoomBack ) ; \nBAMutil . addActionToMenu ( menu , zoomDefault ) ; \nmenu . addSeparator ( ) ; \nBAMutil . addActionToMenu ( menu , moveUp ) ; \nBAMutil . addActionToMenu ( menu , moveDown ) ; \nBAMutil . addActionToMenu ( menu , moveRight ) ; \nBAMutil . addActionToMenu ( menu , moveLeft ) ; \nmenu . addSeparator ( ) ; \nBAMutil . addActionToMenu ( menu , setReferenceAction ) ; \nreturn ; \n} \n} \n"}
{"5104": "public class NavigatedPanel { \nprivate void redrawLater ( int delay ) { \nboolean already = ( redrawTimer != null ) && ( redrawTimer . isRunning ( ) ) ; \nif ( debugThread ) System . out . println ( \"redrawLater isRunning= \" + already ) ; \nif ( already ) return ; \nif ( redrawTimer == null ) { \nredrawTimer = new javax . swing . Timer ( 0 , new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent e ) { \ndrawG ( ) ; \nredrawTimer . stop ( ) ; \nreturn ; \n} \n} \n) ; \n} \nredrawTimer . setDelay ( delay ) ; \nredrawTimer . start ( ) ; \nreturn ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) System . out . println ( \"NavigatedPanel newScreenSize old= \" + myBounds ) ; \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) System . out . println ( \"  newBounds = \" + b ) ; \nif ( ( b . width > 0 ) && ( b . height > 0 ) ) { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse { \nbImage = null ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \nreturn ; \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) { \nreturn ; \n} \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nwhile ( vp . isMemberOfStructure ( ) ) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nwhile ( gp . getParentGroup ( ) != null ) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \nfor ( int i = 1 ; \ni < gchain . size ( ) ; \ni ++ ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \nfor ( int i = 1 ; \ni < vchain . size ( ) ; \ni ++ ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \nreturn ; \n} \n} \n"}
{"5114": "public class GradsDataDescriptorFile { \nprivate void swapByteOrder ( ) { \nString arch = System . getProperty ( \"os.arch\" ) ; \nif ( arch . equals ( \"x86\" ) || arch . equals ( \"arm\" ) || arch . equals ( \"x86_64\" ) || arch . equals ( \"amd64\" ) || arch . equals ( \"alpha\" ) ) { \nbigEndian = true ; \n} \nelse { \nbigEndian = false ; \n} \nreturn ; \n} \n} \n"}
{"5120": "public class GradsDataDescriptorFile { \nprivate void addChsub ( Chsub sub ) { \nif ( chsubs == null ) { \nchsubs = new ArrayList < > ( ) ; \n} \nchsubs . add ( sub ) ; \nreturn ; \n} \n} \n"}
{"5132": "public class Nidsheader { \nvoid addVariable ( String pName , String longName , NetcdfFile nc , ArrayList dims , String coordinates , DataType dtype , String ut , long hoff , long hedsiz , boolean isZ , int nlevel , int [ ] levels , int iscale ) { \nVariable v = new Variable ( nc , null , null , pName ) ; \nv . setDataType ( dtype ) ; \nv . setDimensions ( dims ) ; \nncfile . addVariable ( null , v ) ; \nv . addAttribute ( new Attribute ( CDM . LONG_NAME , longName ) ) ; \nv . addAttribute ( new Attribute ( CDM . UNITS , ut ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , coordinates ) ) ; \nv . setSPobject ( new Vinfo ( numX , numX0 , numY , numY0 , hoff , hedsiz , isR , isZ , null , levels , iscale , nlevel ) ) ; \nreturn ; \n} \n} \n"}
{"5133": "public class Nidsheader { \nvoid addParameter ( String pName , String longName , NetcdfFile nc , ArrayList dims , Attribute att , DataType dtype , String ut , long hoff , long doff , boolean isZ , int y0 ) { \nString vName = pName ; \nVariable vVar = new Variable ( nc , null , null , vName ) ; \nvVar . setDataType ( dtype ) ; \nif ( dims != null ) vVar . setDimensions ( dims ) ; \nelse vVar . setDimensions ( \"\" ) ; \nif ( att != null ) vVar . addAttribute ( att ) ; \nvVar . addAttribute ( new Attribute ( CDM . UNITS , ut ) ) ; \nvVar . addAttribute ( new Attribute ( CDM . LONG_NAME , longName ) ) ; \nnc . addVariable ( null , vVar ) ; \nvVar . setSPobject ( new Vinfo ( numX , numX0 , numY , y0 , hoff , doff , isR , isZ , null , null , 0 , 0 ) ) ; \nreturn ; \n} \n} \n"}
{"5138": "public class DapController { \nprotected void doDMR ( DapRequest drq , DapContext cxt ) throws IOException { \nString realpath = getResourcePath ( drq , drq . getDatasetPath ( ) ) ; \nDSP dsp = DapCache . open ( realpath , cxt ) ; \nDapDataset dmr = dsp . getDMR ( ) ; \nByteOrder order = ( ByteOrder ) cxt . get ( Dap4Util . DAP4ENDIANTAG ) ; \nsetEndianness ( dmr , order ) ; \nCEConstraint ce = null ; \nString sce = drq . queryLookup ( DapProtocol . CONSTRAINTTAG ) ; \nce = CEConstraint . compile ( sce , dmr ) ; \nsetConstraint ( dmr , ce ) ; \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter pw = new PrintWriter ( sw ) ; \nDMRPrinter dapprinter = new DMRPrinter ( dmr , ce , pw , drq . getFormat ( ) ) ; \nif ( cxt . get ( Dap4Util . DAP4TESTTAG ) != null ) dapprinter . testprint ( ) ; \nelse dapprinter . print ( ) ; \npw . close ( ) ; \nsw . close ( ) ; \nString sdmr = sw . toString ( ) ; \nif ( DEBUG ) System . err . println ( \"Sending: DMR:\\n\" + sdmr ) ; \naddCommonHeaders ( drq ) ; \nOutputStream out = drq . getOutputStream ( ) ; \nChunkWriter cw = new ChunkWriter ( out , RequestMode . DMR , order ) ; \ncw . cacheDMR ( sdmr ) ; \ncw . close ( ) ; \nreturn ; \n} \n} \n"}
{"5140": "public class DapController { \nprotected void senderror ( DapRequest drq , int httpcode , Throwable t ) throws IOException { \nif ( httpcode == 0 ) httpcode = HttpServletResponse . SC_BAD_REQUEST ; \nErrorResponse err = new ErrorResponse ( ) ; \nerr . setCode ( httpcode ) ; \nif ( t == null ) { \nerr . setMessage ( \"Servlet error: \" + drq . getURL ( ) ) ; \n} \nelse { \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter p = new PrintWriter ( sw ) ; \nt . printStackTrace ( p ) ; \np . close ( ) ; \nsw . close ( ) ; \nerr . setMessage ( sw . toString ( ) ) ; \n} \nerr . setContext ( drq . getURL ( ) ) ; \nString errormsg = err . buildXML ( ) ; \ndrq . getResponse ( ) . sendError ( httpcode , errormsg ) ; \nreturn ; \n} \n} \n"}
{"5142": "public class Rubberband { \npublic void stretch ( Point p ) { \nlastPt . x = stretchedPt . x ; \nlastPt . y = stretchedPt . y ; \nstretchedPt . x = p . x ; \nstretchedPt . y = p . y ; \nGraphics2D g = ( Graphics2D ) component . getGraphics ( ) ; \nif ( g != null ) { \ntry { \ng . setXORMode ( component . getBackground ( ) ) ; \nif ( firstStretch == true ) firstStretch = false ; \nelse drawLast ( g ) ; \ndrawNext ( g ) ; \n} \nfinally { \ng . dispose ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5146": "public class Table { \nprotected void replaceDataVars ( StructureMembers sm ) { \nfor ( StructureMembers . Member m : sm . getMembers ( ) ) { \nVariableSimpleIF org = this . cols . get ( m . getName ( ) ) ; \nint rank = org . getRank ( ) ; \nList < Dimension > orgDims = org . getDimensions ( ) ; \nint n = m . getShape ( ) . length ; \nList < Dimension > dims = orgDims . subList ( rank - n , rank ) ; \nVariableSimpleImpl result = new VariableSimpleImpl ( org . getShortName ( ) , org . getDescription ( ) , org . getUnitsString ( ) , org . getDataType ( ) , dims ) ; \nfor ( Attribute att : org . getAttributes ( ) ) result . add ( att ) ; \nthis . cols . put ( m . getName ( ) , result ) ; \n} \nreturn ; \n} \n} \n"}
{"5147": "public class ErddapMath2 { \npublic static void ensureArraySizeOkay ( long tSize , String attributeTo ) { \nif ( tSize >= Integer . MAX_VALUE ) throw new RuntimeException ( memoryTooMuchData + \"  \" + MessageFormat . format ( memoryArraySize , \"\" + tSize , \"\" + Integer . MAX_VALUE ) + ( attributeTo == null || attributeTo . length ( ) == 0 ? \"\" : \" (\" + attributeTo + \")\" ) ) ; \nreturn ; \n} \n} \n"}
{"5167": "public class LuceneIndexer { \npublic static void main1 ( String [ ] args ) { \nif ( INDEX_DIR . exists ( ) ) { \nSystem . out . println ( \"Cannot save index to '\" + INDEX_DIR + \"' directory, please delete it first\" ) ; \nSystem . exit ( 1 ) ; \n} \nLuceneIndexer indexer = new LuceneIndexer ( ) ; \nDate start = new Date ( ) ; \ntry { \nIndexWriter writer = new IndexWriter ( INDEX_DIR , new StandardAnalyzer ( ) , true ) ; \nSystem . out . println ( \"Indexing to directory '\" + INDEX_DIR + \"'...\" ) ; \nindexer . indexDocs ( writer , DOC_DIR ) ; \nSystem . out . println ( \"Optimizing...\" ) ; \nwriter . optimize ( ) ; \nwriter . close ( ) ; \nDate end = new Date ( ) ; \nSystem . out . println ( end . getTime ( ) - start . getTime ( ) + \" total milliseconds\" ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \" caught a \" + e . getClass ( ) + \"\\n with message: \" + e . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5171": "public class AreaServiceProvider { \npublic void reacquire ( ) throws IOException { \ntry { \nareaReader . af = new AreaFile ( location ) ; \n} \ncatch ( Throwable e ) { \nthrow new IOException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"5175": "public class BaseTypePrimitiveVector { \npublic final void setValue ( int i , BaseType newVal ) { \nvals [ i ] = newVal ; \nBaseType parent = ( BaseType ) getTemplate ( ) . getParent ( ) ; \nvals [ i ] . setParent ( parent ) ; \nreturn ; \n} \n} \n"}
{"5176": "public class EnhancementsImpl { \npublic void addCoordinateSystem ( CoordinateSystem cs ) { \nif ( cs == null ) throw new RuntimeException ( \"Attempted to add null CoordinateSystem to var \" + forVar . getFullName ( ) ) ; \nif ( coordSys == null ) coordSys = new ArrayList < > ( 5 ) ; \ncoordSys . add ( cs ) ; \nreturn ; \n} \n} \n"}
{"5177": "public class EnhancementsImpl { \npublic void setUnitsString ( String units ) { \nthis . units = units ; \nforVar . addAttribute ( new Attribute ( CDM . UNITS , units ) ) ; \nreturn ; \n} \n} \n"}
{"5179": "public class ConfigCatalogInitialization { \npublic synchronized void init ( ReadMode readMode , PreferencesExt prefs ) { \nif ( readMode == null ) readMode = defaultReadMode ; \nthis . prefs = prefs ; \ntrackerNumber = prefs . getLong ( \"trackerNumber\" , 1 ) ; \nnumberCatalogs = prefs . getInt ( \"numberCatalogs\" , 10 ) ; \nnextCatId = prefs . getLong ( \"nextCatId\" , 1 ) ; \nmakeDebugActions ( ) ; \nthis . contentRootPath = this . tdsContext . getThreddsDirectory ( ) ; \nthis . contextPath = tdsContext . getContextPath ( ) ; \nreread ( readMode , true ) ; \nreturn ; \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; \nif ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) exceedLimit = true ; \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( idMap . contains ( id ) ) { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \nelse { \nidMap . add ( id ) ; \n} \n} \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nelse if ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = dirPath + href ; \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5182": "public class ConfigCatalogInitialization { \nprivate void readCatsInDirectory ( ReadMode readMode , String dirPath , Path directory ) throws IOException { \nif ( exceedLimit ) return ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( directory , \"*.xml\" ) ) { \nfor ( Path p : ds ) { \nif ( ! Files . isDirectory ( p ) ) { \nString filename = p . getFileName ( ) . toString ( ) ; \nString path = dirPath . length ( ) == 0 ? filename : dirPath + \"/\" + filename ; \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \n} \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( directory ) ) { \nfor ( Path dir : ds ) { \nif ( Files . isDirectory ( dir ) ) { \nString dirPathChild = dirPath + \"/\" + dir . getFileName ( ) . toString ( ) ; \nreadCatsInDirectory ( readMode , dirPathChild , dir ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5188": "public class CatalogTreeView { \npublic void setSelectedDataset ( Dataset ds ) { \nif ( ds == null ) return ; \nTreePath path = makePath ( ds ) ; \nif ( path == null ) return ; \ntree . setSelectionPath ( path ) ; \ntree . scrollPathToVisible ( path ) ; \nreturn ; \n} \n} \n"}
{"5190": "public class CatalogTreeView { \npublic void openAll ( boolean includeCatref ) { \nif ( catalog == null ) return ; \nopen ( ( InvCatalogTreeNode ) model . getRoot ( ) , includeCatref ) ; \ntree . repaint ( ) ; \nreturn ; \n} \n} \n"}
{"5191": "public class CatalogTreeView { \npublic void setCatalog ( String location ) { \nCatalogBuilder builder = new CatalogBuilder ( ) ; \ntry { \nCatalog cat = builder . buildFromLocation ( location , null ) ; \nsetCatalog ( cat ) ; \n} \ncatch ( Exception ioe ) { \nJOptionPane . showMessageDialog ( this , \"Error opening catalog location \" + location + \" err=\" + builder . getErrorMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5192": "public class CatalogTreeView { \npublic void setCatalog ( Catalog catalog ) { \nif ( catalog == null ) return ; \nString catalogName = catalog . getBaseURI ( ) . toString ( ) ; \nthis . catalog = catalog ; \nsetCatalogURL ( catalogName ) ; \nmodel = new InvCatalogTreeModel ( catalog ) ; \ntree . setModel ( model ) ; \nif ( debugTree ) { \nSystem . out . println ( \"*** catalog/showJTree =\" ) ; \nshowNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; \nSystem . out . println ( \"*** \" ) ; \n} \nint pos = catalogName . indexOf ( '#' ) ; \nif ( pos >= 0 ) { \nString id = catalogName . substring ( pos + 1 ) ; \nDataset dataset = catalog . findDatasetByID ( id ) ; \nif ( dataset != null ) { \nsetSelectedDataset ( dataset ) ; \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Selection\" , null , dataset ) ) ; \n} \n} \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Catalog\" , null , catalogName ) ) ; \nreturn ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse if ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5197": "public class Grib { \npublic static void setDebugFlags ( ucar . nc2 . util . DebugFlags debugFlag ) { \ndebugRead = debugFlag . isSet ( \"Grib/showRead\" ) ; \ndebugIndexOnly = debugFlag . isSet ( \"Grib/indexOnly\" ) ; \ndebugIndexOnlyShow = debugFlag . isSet ( \"Grib/indexOnlyShow\" ) ; \ndebugGbxIndexOnly = debugFlag . isSet ( \"Grib/debugGbxIndexOnly\" ) ; \nreturn ; \n} \n} \n"}
{"5198": "public class StructureMembers { \npublic void addMember ( Member m ) { \nmembers . add ( m ) ; \nif ( memberHash != null ) memberHash . put ( m . getName ( ) , m ) ; \nreturn ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \ni < ncols ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \nreturn ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \nreturn ; \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \nreturn ; \n} \n} \n"}
{"5221": "public class DIFWriter { \npublic void doOneDataset ( InvDataset ds ) { \nif ( debug ) System . out . println ( \"doDataset \" + ds . getName ( ) ) ; \nif ( isDatasetUseable ( ds , messBuffer ) ) { \nString id = StringUtil2 . replace ( ds . getID ( ) , \"/\" , \"-\" ) ; \nString fileOutName = fileDir + \"/\" + id + \".dif.xml\" ; \ntry { \nOutputStream out = new BufferedOutputStream ( new FileOutputStream ( fileOutName ) ) ; \nwriteOneEntry ( ds , out , messBuffer ) ; \nout . close ( ) ; \nmessBuffer . append ( \" OK on Write\\n\" ) ; \n} \ncatch ( IOException ioe ) { \nmessBuffer . append ( \"DIFWriter failed on write \" + ioe . getMessage ( ) + \"\\n\" ) ; \nlog . error ( \"DIFWriter failed on write \" + ioe . getMessage ( ) , ioe ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5224": "public class DatasetBuilder { \npublic void transferMetadata ( DatasetNode from , boolean parentsAlso ) { \nif ( parentsAlso ) { \nThreddsMetadata inherit = getInheritableMetadata ( ) ; \ninheritMetadata ( from , inherit . getFlds ( ) ) ; \n} \nfor ( Map . Entry < String , Object > entry : from . getFldIterator ( ) ) { \nif ( parentsAlso && entry . getKey ( ) . equals ( Dataset . ThreddsMetadataInheritable ) ) continue ; \nif ( Dataset . listFlds . contains ( entry . getKey ( ) ) ) addToNewList ( flds , entry . getKey ( ) , entry . getValue ( ) ) ; \nelse flds . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nThreddsMetadata tmiOld = ( ThreddsMetadata ) get ( Dataset . ThreddsMetadataInheritable ) ; \nif ( tmiOld != null && tmiOld . isImmutable ( ) ) { \nThreddsMetadata tmiNew = new ThreddsMetadata ( tmiOld ) ; \nflds . put ( Dataset . ThreddsMetadataInheritable , tmiNew ) ; \n} \nreturn ; \n} \n} \n"}
{"5226": "public class GridVariable { \nvoid addProduct ( GridRecord record ) { \nrecords . add ( record ) ; \nif ( firstRecord == null ) { \nfirstRecord = record ; \n} \nreturn ; \n} \n} \n"}
{"5227": "public class GridVariable { \npublic void showMissing ( Formatter f ) { \nint count = 0 , total = 0 ; \nf . format ( \"  %s%n\" , name ) ; \nfor ( int j = 0 ; \nj < nlevels ; \nj ++ ) { \nf . format ( \"   \" ) ; \nfor ( int i = 0 ; \ni < ntimes ; \ni ++ ) { \nboolean missing = recordTracker [ i * nlevels + j ] == null ; \nf . format ( \"%s\" , missing ? \"-\" : \"X\" ) ; \nif ( missing ) count ++ ; \ntotal ++ ; \n} \nf . format ( \"%n\" ) ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn ; \n} \n} \n"}
{"5235": "public class AbstractDSP { \nprotected void processAttributes ( DapDataset dataset ) throws DapException { \nList < DapNode > nodes = dataset . getNodeList ( ) ; \nfor ( DapNode node : nodes ) { \nswitch ( node . getSort ( ) ) { \ncase GROUP : case DATASET : case VARIABLE : Map < String , DapAttribute > attrs = node . getAttributes ( ) ; \nif ( attrs . size ( ) > 0 ) { \nList < DapAttribute > suppressed = new ArrayList < > ( ) ; \nfor ( DapAttribute dattr : attrs . values ( ) ) { \nif ( suppress ( dattr . getShortName ( ) ) ) suppressed . add ( dattr ) ; \n} \nfor ( DapAttribute dattr : suppressed ) { \nnode . removeAttribute ( dattr ) ; \n} \n} \nbreak ; \ndefault : break ; \n} \n} \ngetEndianAttribute ( dataset ) ; \nreturn ; \n} \n} \n"}
{"5236": "public class CoordinatePartitionUnionizer { \npublic void addCoords ( List < Coordinate > coords , PartitionCollectionMutable . Partition part ) { \nCoordinate runtime = null ; \nfor ( Coordinate coord : coords ) { \nswitch ( coord . getType ( ) ) { \ncase runtime : CoordinateRuntime rtime = ( CoordinateRuntime ) coord ; \nif ( runtimeBuilder == null ) runtimeBuilder = new CoordinateRuntime . Builder2 ( rtime . getTimeUnits ( ) ) ; \nruntimeBuilder . addAll ( coord ) ; \nruntime = coord ; \nif ( debugPartitionErrors && ! duplicateRuntimeMessage && part != null ) testDuplicateRuntime ( rtime , part ) ; \nbreak ; \ncase time : CoordinateTime time = ( CoordinateTime ) coord ; \nif ( timeBuilder == null ) timeBuilder = new CoordinateTime . Builder2 ( coord . getCode ( ) , time . getTimeUnit ( ) , time . getRefDate ( ) ) ; \ntimeBuilder . addAll ( coord ) ; \nbreak ; \ncase timeIntv : CoordinateTimeIntv timeIntv = ( CoordinateTimeIntv ) coord ; \nif ( timeIntvBuilder == null ) timeIntvBuilder = new CoordinateTimeIntv . Builder2 ( null , coord . getCode ( ) , timeIntv . getTimeUnit ( ) , timeIntv . getRefDate ( ) ) ; \ntimeIntvBuilder . addAll ( intervalFilter ( ( CoordinateTimeIntv ) coord ) ) ; \nbreak ; \ncase time2D : CoordinateTime2D time2D = ( CoordinateTime2D ) coord ; \nif ( time2DBuilder == null ) time2DBuilder = new CoordinateTime2DUnionizer ( time2D . isTimeInterval ( ) , time2D . getTimeUnit ( ) , coord . getCode ( ) , false , logger ) ; \ntime2DBuilder . addAll ( time2D ) ; \nCoordinateRuntime runtimeFrom2D = time2D . getRuntimeCoordinate ( ) ; \nif ( ! runtimeFrom2D . equals ( runtime ) ) logger . warn ( \"HEY CoordinateUnionizer runtimes not equal\" ) ; \nbreak ; \ncase ens : if ( ensBuilder == null ) ensBuilder = new CoordinateEns . Builder2 ( coord . getCode ( ) ) ; \nensBuilder . addAll ( coord ) ; \nbreak ; \ncase vert : CoordinateVert vertCoord = ( CoordinateVert ) coord ; \nif ( vertBuilder == null ) vertBuilder = new CoordinateVert . Builder2 ( coord . getCode ( ) , vertCoord . getVertUnit ( ) ) ; \nvertBuilder . addAll ( coord ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < nlats ; \ni ++ ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( int i = 0 ; \ni < nyRaw ; \ni ++ ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) { \nuseIndex ++ ; \n} \nelse { \nuseIndex -- ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \nreturn ; \n} \n} \n"}
{"5241": "public class HTTPMethod { \npublic synchronized void close ( ) { \nif ( closed ) return ; \nclosed = true ; \nif ( methodstream != null ) { \ntry { \nthis . methodstream . close ( ) ; \n} \ncatch ( IOException ioe ) { \n} \nthis . methodstream = null ; \n} \nif ( this . lastresponse != null ) { \nif ( false ) { \ntry { \ntry { \nEntityUtils . consume ( this . lastresponse . getEntity ( ) ) ; \n} \nfinally { \nHttpClientUtils . closeQuietly ( this . lastresponse ) ; \n} \n} \ncatch ( IOException ignore ) { \n} \n} \nelse HttpClientUtils . closeQuietly ( this . lastresponse ) ; \nthis . lastresponse = null ; \n} \nif ( session != null ) { \nsession . removeMethod ( this ) ; \nif ( localsession ) { \nsession . close ( ) ; \nsession = null ; \n} \n} \nthis . lastrequest = null ; \nreturn ; \n} \n} \n"}
{"5245": "public class CBZip2InputStream { \npublic void setStream ( InputStream zStream ) { \nlast = 0 ; \norigPtr = 0 ; \nblockSize100k = 0 ; \nblockRandomised = false ; \nbsBuff = 0 ; \nbsLive = 0 ; \nmCrc = new CRC ( ) ; \nnInUse = 0 ; \nbsStream = null ; \nstreamEnd = false ; \ncurrentChar = - 1 ; \ncurrentState = START_BLOCK_STATE ; \nstoredBlockCRC = storedCombinedCRC = 0 ; \ncomputedBlockCRC = computedCombinedCRC = 0 ; \ni2 = count = chPrev = ch2 = 0 ; \ni = tPos = 0 ; \nrNToGo = 0 ; \nrTPos = 0 ; \nj2 = 0 ; \nz = 0 ; \nbsSetStream ( zStream ) ; \ninitialize ( ) ; \nif ( ! streamEnd ) { \ninitBlock ( ) ; \nsetupBlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( pm . isCanceled ( ) ) { \ntask . cancel ( ) ; \n} \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \nreturn ; \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \nreturn ; \n} \n} \n"}
{"5253": "public class GribCollectionMutable { \nvoid copyInfo ( GribCollectionMutable from ) { \nthis . center = from . center ; \nthis . subcenter = from . subcenter ; \nthis . master = from . master ; \nthis . local = from . local ; \nthis . genProcessType = from . genProcessType ; \nthis . genProcessId = from . genProcessId ; \nthis . backProcessId = from . backProcessId ; \nreturn ; \n} \n} \n"}
{"5255": "public class GribCollectionMutable { \nvoid setIndexRaf ( RandomAccessFile indexRaf ) { \nthis . indexRaf = indexRaf ; \nif ( indexRaf != null ) { \nthis . indexFilename = indexRaf . getLocation ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5257": "public class GribCollectionMutable { \npublic void close ( ) throws java . io . IOException { \nif ( indexRaf != null ) { \nindexRaf . close ( ) ; \nindexRaf = null ; \n} \nreturn ; \n} \n} \n"}
{"5263": "public class NetcdfFileWriteable { \npublic void addVariableAttribute ( String varName , String attName , String value ) { \naddVariableAttribute ( varName , new Attribute ( attName , value ) ) ; \nreturn ; \n} \n} \n"}
{"5264": "public class NetcdfFileWriteable { \npublic void addVariableAttribute ( String varName , String attName , Array value ) { \nAttribute att = new Attribute ( attName , value ) ; \naddVariableAttribute ( varName , att ) ; \nreturn ; \n} \n} \n"}
{"5267": "public class GempakSurfaceFileReader { \nprotected void makeFileSubType ( ) { \nKey key = findKey ( GempakStation . SLAT ) ; \nif ( key == null ) throw new IllegalStateException ( \"File does not have key=\" + GempakStation . SLAT ) ; \nString latType = key . type ; \nKey dateKey = findKey ( DATE ) ; \nif ( dateKey != null && ! dateKey . type . equals ( latType ) ) { \nif ( latType . equals ( ROW ) ) { \nsubType = CLIMATE ; \n} \nelse { \nsubType = STANDARD ; \n} \n} \nelse { \nsubType = SHIP ; \n} \nreturn ; \n} \n} \n"}
{"5268": "public class WFSGetFeatureWriter { \nprivate void writeHeadersAndBB ( ) { \nfileOutput += \"<wfs:FeatureCollection xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" + namespace + \" \" + server + \"?request=DescribeFeatureType\" + WFSXMLHelper . AMPERSAND + \"service=wfs\" + WFSXMLHelper . AMPERSAND + \"version=2.0.0\" + WFSXMLHelper . AMPERSAND + \"typename=\" + WFSController . TDSNAMESPACE + \"%3A\" + ftName ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml/3.2\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:wfs=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/wfs/2.0\" ) + \" xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\" numberMatched=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \" numberReturned=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \">\" ; \ndouble [ ] boundLower ; \ndouble [ ] boundUpper ; \nif ( geometries . isEmpty ( ) ) { \nboundLower = new double [ 2 ] ; \nboundUpper = new double [ 2 ] ; \nboundLower [ 0 ] = - 180 ; \nboundLower [ 1 ] = - 90 ; \nboundUpper [ 0 ] = 180 ; \nboundUpper [ 1 ] = 90 ; \n} \nelse { \nboundLower = geometries . get ( 0 ) . getBBLower ( ) ; \nboundUpper = geometries . get ( 0 ) . getBBUpper ( ) ; \n} \nfor ( SimpleGeometry item : geometries ) { \ndouble [ ] low = item . getBBLower ( ) ; \nif ( boundLower [ 0 ] > low [ 0 ] ) boundLower [ 0 ] = low [ 0 ] ; \nif ( boundLower [ 1 ] > low [ 1 ] ) boundLower [ 1 ] = low [ 1 ] ; \ndouble [ ] upper = item . getBBUpper ( ) ; \nif ( boundUpper [ 0 ] < upper [ 0 ] ) boundUpper [ 0 ] = upper [ 0 ] ; \nif ( boundUpper [ 1 ] < upper [ 1 ] ) boundUpper [ 1 ] = upper [ 1 ] ; \nboundLower [ 0 ] -= 10 ; \nboundLower [ 1 ] -= 10 ; \nboundUpper [ 0 ] += 10 ; \nboundUpper [ 1 ] += 10 ; \n} \nfileOutput += \"<wfs:boundedBy>\" + \"<wfs:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<wfs:lowerCorner>\" + boundLower [ 0 ] + \" \" + boundLower [ 1 ] + \"</wfs:lowerCorner>\" + \"<wfs:upperCorner>\" + boundUpper [ 0 ] + \" \" + boundUpper [ 1 ] + \"</wfs:upperCorner>\" + \"</wfs:Envelope>\" + \"</wfs:boundedBy>\" ; \nreturn ; \n} \n} \n"}
{"5269": "public class WFSGetFeatureWriter { \npublic void writeMembers ( ) { \nint index = 1 ; \nGMLFeatureWriter writer = new GMLFeatureWriter ( ) ; \nfor ( SimpleGeometry geometryItem : geometries ) { \ndouble [ ] lowerCorner = geometryItem . getBBLower ( ) ; \ndouble [ ] upperCorner = geometryItem . getBBUpper ( ) ; \nfileOutput += \"<wfs:member>\" + \"<\" + WFSController . TDSNAMESPACE + \":\" + ftName + \" gml:id=\\\"\" + ftName + \".\" + index + \"\\\">\" + \"<gml:boundedBy>\" + \"<gml:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<gml:lowerCorner>\" + lowerCorner [ 0 ] + \" \" + lowerCorner [ 1 ] + \"</gml:lowerCorner>\" + \"<gml:upperCorner>\" + upperCorner [ 0 ] + \" \" + upperCorner [ 1 ] + \"</gml:upperCorner>\" + \"</gml:Envelope>\" + \"</gml:boundedBy>\" + \"<\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" ; \nfileOutput += writer . writeFeature ( geometryItem ) ; \nfileOutput += \"</\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" + \"</\" + WFSController . TDSNAMESPACE + \":\" + ftName + \">\" + \"</wfs:member>\" ; \nindex ++ ; \n} \nreturn ; \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to write DSR twice\" ) ; \nif ( dsr == null ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \nint len = dsr . length ( ) ; \nwhile ( len > 0 ) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' && c != '\\n' ) break ; \nlen -- ; \n} \nif ( dsr . length ( ) == 0 ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \nreturn ; \n} \n} \n"}
{"5273": "public class ChunkWriter { \nvoid sendDXR ( byte [ ] dxr8 ) throws IOException { \nif ( dxr8 == null || dxr8 . length == 0 ) return ; \nif ( mode == RequestMode . DMR || mode == RequestMode . DSR ) { \nstate = State . END ; \n} \nelse { \nint flags = DapUtil . CHUNK_DATA ; \nif ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; \nchunkheader ( dxr8 . length , flags , this . header ) ; \noutput . write ( DapUtil . extract ( this . header ) ) ; \nstate = State . DATA ; \n} \noutput . write ( dxr8 ) ; \noutput . flush ( ) ; \nreturn ; \n} \n} \n"}
{"5274": "public class ChunkWriter { \npublic void writeError ( int httpcode , String msg , String cxt , String other ) throws IOException { \ndmr8 = null ; \nErrorResponse response = new ErrorResponse ( httpcode , msg , cxt , other ) ; \nString errorbody = response . buildXML ( ) ; \nbyte [ ] errbody8 = DapUtil . extract ( DapUtil . UTF8 . encode ( errorbody ) ) ; \nif ( mode == RequestMode . DMR ) { \nsendDXR ( errbody8 ) ; \n} \nelse { \nchunk . clear ( ) ; \nint flags = DapUtil . CHUNK_ERROR | DapUtil . CHUNK_END ; \nchunkheader ( errbody8 . length , flags , header ) ; \noutput . write ( DapUtil . extract ( header ) ) ; \noutput . write ( errbody8 ) ; \noutput . flush ( ) ; \n} \nstate = State . ERROR ; \nreturn ; \n} \n} \n"}
{"5275": "public class ChunkWriter { \npublic void close ( ) throws IOException { \nif ( closed ) return ; \nclosed = true ; \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \nif ( mode == RequestMode . DMR ) return ; \nif ( chunk == null || chunk . position ( ) == 0 ) return ; \nverifystate ( ) ; \nstate = State . DATA ; \nint flags = DapUtil . CHUNK_END ; \nwriteChunk ( flags ) ; \nstate = State . END ; \nthis . output . flush ( ) ; \nif ( this . saveoutput != null ) { \nthis . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5276": "public class ChunkWriter { \n@ Override public void flush ( ) throws IOException { \nif ( mode == RequestMode . DMR ) return ; \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \nreturn ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \nfor ( long tnum = trackerNumber - 1 ; \ntnum > 0 ; \ntnum -- ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) break ; \nif ( oldDatabaseFile . delete ( ) ) { \ncatalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \nelse { \ncatalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5286": "public class NavigationBlock { \npublic void setValues ( float [ ] values ) { \nvals = values ; \nproj = GempakUtil . ST_ITOC ( Float . floatToIntBits ( vals [ 1 ] ) ) . trim ( ) ; \naddParam ( PROJ , proj ) ; \naddParam ( GDS_KEY , this . toString ( ) ) ; \nsetParams ( ) ; \nreturn ; \n} \n} \n"}
{"5289": "public class NcssGridController { \n@ RequestMapping ( \"**/datasetBoundaries.xml\" ) public void getDatasetBoundaries ( NcssParamsBean params , HttpServletRequest req , HttpServletResponse res ) throws IOException , UnsupportedResponseFormatException { \nSupportedFormat format = SupportedOperation . DATASET_BOUNDARIES_REQUEST . getSupportedFormat ( params . getAccept ( ) ) ; \nswitch ( format ) { \ncase WKT : getDatasetBoundariesWKT ( req , res ) ; \nbreak ; \ncase JSON : getDatasetBoundariesGeoJSON ( req , res ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( String . format ( \"Expected %s or %s, but got %s\" , SupportedFormat . WKT , SupportedFormat . JSON , format ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5290": "public class NcssGridController { \nprivate void checkRequestedVars ( CoverageCollection gcd , NcssGridParamsBean params ) throws VariableNotContainedInDatasetException { \nif ( params . getVar ( ) . get ( 0 ) . equalsIgnoreCase ( \"all\" ) ) { \nparams . setVar ( getAllGridNames ( gcd ) ) ; \nreturn ; \n} \nfor ( String gridName : params . getVar ( ) ) { \nCoverage grid = gcd . findCoverage ( gridName ) ; \nif ( grid == null ) throw new VariableNotContainedInDatasetException ( \"Variable: \" + gridName + \" is not contained in the requested dataset\" ) ; \n} \nreturn ; \n} \n} \n"}
{"5293": "public class GridIndexToNC { \nprivate void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { \nGridVertCoord gvcs0 = null ; \nint maxLevels = 0 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs . getNLevels ( ) > maxLevels ) { \ngvcs0 = gvcs ; \nmaxLevels = gvcs . getNLevels ( ) ; \n} \n} \nint seqno = 1 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs != gvcs0 ) { \ngvcs . setSequence ( seqno ++ ) ; \n} \ngvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; \n} \nreturn ; \n} \n} \n"}
{"5296": "public class InvDatasetImpl { \nprivate void transferInheritable2PublicMetadata ( InvDatasetImpl parent ) { \nif ( parent == null ) return ; \nlogger . debug ( \" inheritFromParent= \" + parent . getID ( ) ) ; \ntransfer2PublicMetadata ( parent . getLocalMetadataInheritable ( ) , true ) ; \ntransferInheritable2PublicMetadata ( ( InvDatasetImpl ) parent . getParent ( ) ) ; \nreturn ; \n} \n} \n"}
{"5297": "public class InvDatasetImpl { \npublic void transferMetadata ( InvDatasetImpl fromDs , boolean copyInheritedMetadataFromParents ) { \nif ( fromDs == null ) return ; \nlogger . debug ( \" transferMetadata= \" + fromDs . getName ( ) ) ; \nif ( this != fromDs ) getLocalMetadata ( ) . add ( fromDs . getLocalMetadata ( ) , false ) ; \ntransferInheritableMetadata ( fromDs , getLocalMetadataInheritable ( ) , copyInheritedMetadataFromParents ) ; \nsetResourceControl ( fromDs . getRestrictAccess ( ) ) ; \nreturn ; \n} \n} \n"}
{"5298": "public class InvDatasetImpl { \nprivate void transferInheritableMetadata ( InvDatasetImpl fromDs , ThreddsMetadata target , boolean copyInheritedMetadataFromParents ) { \nif ( fromDs == null ) return ; \nlogger . debug ( \" transferInheritedMetadata= \" + fromDs . getName ( ) ) ; \ntarget . add ( fromDs . getLocalMetadataInheritable ( ) , true ) ; \nif ( copyInheritedMetadataFromParents ) transferInheritableMetadata ( ( InvDatasetImpl ) fromDs . getParent ( ) , target , true ) ; \nreturn ; \n} \n} \n"}
{"5299": "public class InvDatasetImpl { \npublic void setContributors ( List < ThreddsMetadata . Contributor > a ) { \nList < ThreddsMetadata . Contributor > dest = tm . getContributors ( ) ; \nfor ( ThreddsMetadata . Contributor item : a ) { \nif ( ! dest . contains ( item ) ) dest . add ( item ) ; \n} \nhashCode = 0 ; \nreturn ; \n} \n} \n"}
{"5300": "public class InvDatasetImpl { \npublic void addDataset ( int index , InvDatasetImpl ds ) { \nif ( ds == null ) return ; \nds . setParent ( this ) ; \ndatasets . add ( index , ds ) ; \nhashCode = 0 ; \nreturn ; \n} \n} \n"}
{"5303": "public class InvDatasetImpl { \npublic void addService ( InvService service ) { \nservicesLocal . add ( service ) ; \nservices . add ( service ) ; \nfor ( InvService nested : service . getServices ( ) ) { \nservices . add ( nested ) ; \n} \nhashCode = 0 ; \nreturn ; \n} \n} \n"}
{"5304": "public class InvDatasetImpl { \npublic void removeService ( InvService service ) { \nservicesLocal . remove ( service ) ; \nservices . remove ( service ) ; \nfor ( InvService nested : service . getServices ( ) ) { \nservices . remove ( nested ) ; \n} \nreturn ; \n} \n} \n"}
{"5305": "public class InvDatasetImpl { \npublic void setServicesLocal ( java . util . List < InvService > s ) { \nthis . services = new ArrayList < > ( ) ; \nthis . servicesLocal = new ArrayList < > ( ) ; \nfor ( InvService elem : s ) { \naddService ( elem ) ; \n} \nhashCode = 0 ; \nreturn ; \n} \n} \n"}
{"5311": "public class WFSController { \nprivate void getCapabilities ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs ) { \nWFSGetCapabilitiesWriter gcdw = new WFSGetCapabilitiesWriter ( out , WFSController . constructServerPath ( hsreq ) ) ; \ngcdw . startXML ( ) ; \ngcdw . addOperation ( WFSRequestType . GetCapabilities ) ; \ngcdw . addOperation ( WFSRequestType . DescribeFeatureType ) ; \ngcdw . addOperation ( WFSRequestType . GetFeature ) ; \ngcdw . writeOperations ( ) ; \nList < String > seriesNames = sgcs . getGeometrySeriesNames ( ) ; \nfor ( String name : seriesNames ) { \ngcdw . addFeature ( new WFSFeature ( TDSNAMESPACE + \":\" + name , name ) ) ; \n} \ngcdw . writeFeatureTypes ( ) ; \ngcdw . finishXML ( ) ; \nreturn ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nwhile ( paramNamesE . hasMoreElements ( ) ) paramNames . add ( paramNamesE . nextElement ( ) ) ; \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( hsreq . getServletPath ( ) . length ( ) > 4 ) { \ndatasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \n} \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( actualPath != null ) dataset = NetcdfDataset . openDataset ( actualPath ) ; \nelse return ; \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) { \nrequest = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) { \nversion = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) { \nservice = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) || paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( paramError == null ) { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nelse { \nparamError . write ( hsres ) ; \nreturn ; \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \nreturn ; \n} \n} \n"}
{"5318": "public class Generator { \npublic void dataset ( DapDataset dmr ) throws DapException { \nfor ( DapVariable var : this . dmr . getTopVariables ( ) ) { \nif ( ! this . ce . references ( var ) ) continue ; \nvariable ( var ) ; \n} \nreturn ; \n} \n} \n"}
{"5319": "public class ServletUtil { \npublic static void returnFile ( HttpServlet servlet , String contentPath , String path , HttpServletRequest req , HttpServletResponse res , String contentType ) throws IOException { \nString filename = ServletUtil . formFilename ( contentPath , path ) ; \nlog . debug ( \"returnFile(): returning file <\" + filename + \">.\" ) ; \nif ( filename == null ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \nreturn ; \n} \nif ( filename . contains ( \"..\" ) ) { \nres . sendError ( HttpServletResponse . SC_FORBIDDEN ) ; \nreturn ; \n} \nString upper = filename . toUpperCase ( ) ; \nif ( upper . contains ( \"WEB-INF\" ) || upper . contains ( \"META-INF\" ) ) { \nres . sendError ( HttpServletResponse . SC_FORBIDDEN ) ; \nreturn ; \n} \nreturnFile ( servlet , req , res , new File ( filename ) , contentType ) ; \nreturn ; \n} \n} \n"}
{"5320": "public class ServletUtil { \npublic static void returnString ( String contents , HttpServletResponse res ) throws IOException { \ntry { \nServletOutputStream out = res . getOutputStream ( ) ; \nIO . copy ( new ByteArrayInputStream ( contents . getBytes ( CDM . utf8Charset ) ) , out ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \" IOException sending string: \" , e ) ; \nres . sendError ( HttpServletResponse . SC_NOT_FOUND , \"Problem sending string: \" + e . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5326": "public class CatalogChooser { \npublic void save ( ) { \nif ( catListBox != null ) catListBox . save ( ) ; \nif ( prefs != null ) { \nif ( fileChooser != null ) fileChooser . save ( ) ; \nif ( catgenFileChooser != null ) catgenFileChooser . save ( ) ; \nprefs . putInt ( HDIVIDER , split . getDividerLocation ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5328": "public class BitCounterUncompressed { \npublic void setBitOffset ( DataDescriptor dkey ) { \nif ( bitPosition == null ) bitPosition = new HashMap < DataDescriptor , Integer > ( 2 * parent . getSubKeys ( ) . size ( ) ) ; \nbitPosition . put ( dkey , bitOffset ) ; \nbitOffset += dkey . getBitWidth ( ) ; \nreturn ; \n} \n} \n"}
{"5331": "public class TextHistoryPane { \npublic void appendLine ( String line ) { \nif ( count >= nlines ) { \ntry { \nint remove = Math . max ( removeIncr , count - nlines ) ; \nint offset = ta . getLineEndOffset ( remove ) ; \nta . replaceRange ( \"\" , 0 , offset ) ; \n} \ncatch ( Exception e ) { \nlog . error ( \"Problem in TextHistoryPane\" , e ) ; \n} \ncount = nlines - removeIncr ; \n} \nta . append ( line ) ; \nta . append ( \"\\n\" ) ; \ncount ++ ; \nta . setCaretPosition ( ta . getText ( ) . length ( ) ) ; \nreturn ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) return ; \nfor ( int i = 0 ; \ni < getItemCount ( ) ; \ni ++ ) { \nif ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \n} \n"}
{"5342": "public class OptSwitch { \npublic void SetHasValue ( int type ) { \nthis . type = type ; \nif ( debug ) { \nSystem . out . println ( \"sw = \" + ( char ) sw + \"; type = \" + type + \"; set = \" + set + \"; val = \" + val ) ; \n} \nreturn ; \n} \n} \n"}
{"5347": "public class IO { \nstatic public void writeContents ( String contents , OutputStream os ) throws IOException { \nByteArrayInputStream bin = new ByteArrayInputStream ( contents . getBytes ( CDM . utf8Charset ) ) ; \nIO . copy ( bin , os ) ; \nreturn ; \n} \n} \n"}
{"5348": "public class IO { \nstatic public void copyFileB ( File fileIn , OutputStream out , int bufferSize ) throws IOException { \ntry ( FileInputStream fin = new FileInputStream ( fileIn ) ) { \nInputStream in = new BufferedInputStream ( fin ) ; \nIO . copyB ( in , out , bufferSize ) ; \n} \nreturn ; \n} \n} \n"}
{"5350": "public class IO { \nstatic public void copyDirTree ( String fromDirName , String toDirName ) throws IOException { \nFile fromDir = new File ( fromDirName ) ; \nFile toDir = new File ( toDirName ) ; \nif ( ! fromDir . exists ( ) ) return ; \nif ( ! toDir . exists ( ) ) { \nif ( ! toDir . mkdirs ( ) ) { \nthrow new IOException ( \"Could not create directory: \" + toDir ) ; \n} \n} \nFile [ ] files = fromDir . listFiles ( ) ; \nif ( files != null ) for ( File f : files ) { \nif ( f . isDirectory ( ) ) copyDirTree ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \nelse copyFile ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + \"/\" + f . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5353": "public class IO { \nstatic public void writeToFile ( String contents , File file ) throws IOException { \ntry ( FileOutputStream fout = new FileOutputStream ( file ) ) { \nOutputStreamWriter fw = new OutputStreamWriter ( fout , CDM . utf8Charset ) ; \nUnsynchronizedBufferedWriter writer = new UnsynchronizedBufferedWriter ( fw ) ; \nwriter . write ( contents ) ; \nwriter . flush ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5354": "public class IO { \nstatic public void writeToFile ( String contents , String fileOutName ) throws IOException { \nwriteToFile ( contents , new File ( fileOutName ) ) ; \nreturn ; \n} \n} \n"}
{"5356": "public class DTSServlet { \npublic void parseExceptionHandler ( ParseException pe , HttpServletResponse response ) { \nif ( Debug . isSet ( \"showException\" ) ) { \nlog . error ( pe . toString ( ) ) ; \nprintThrowable ( pe ) ; \n} \ntry { \nBufferedOutputStream eOut = new BufferedOutputStream ( response . getOutputStream ( ) ) ; \nresponse . setHeader ( \"Content-Description\" , \"dods-error\" ) ; \nresponse . setHeader ( \"Content-Encoding\" , \"\" ) ; \nString msg = pe . getMessage ( ) . replace ( '\\\"' , '\\'' ) ; \nDAP2Exception de2 = new DAP2Exception ( opendap . dap . DAP2Exception . CANNOT_READ_FILE , msg ) ; \nde2 . print ( eOut ) ; \n} \ncatch ( IOException ioe ) { \nlog . error ( \"Cannot respond to client! IO Error: \" + ioe . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5357": "public class DTSServlet { \npublic void dap2ExceptionHandler ( DAP2Exception de , HttpServletResponse response ) { \nif ( Debug . isSet ( \"showException\" ) ) { \nlog . error ( de . toString ( ) ) ; \nde . printStackTrace ( ) ; \nprintDODSException ( de ) ; \n} \nswitch ( de . getErrorCode ( ) ) { \ncase DAP2Exception . NO_SUCH_FILE : case DAP2Exception . CANNOT_READ_FILE : response . setStatus ( HttpStatus . SC_NOT_FOUND ) ; \nbreak ; \ncase DAP2Exception . NO_AUTHORIZATION : response . setStatus ( HttpStatus . SC_UNAUTHORIZED ) ; \nbreak ; \ncase DAP2Exception . NO_SUCH_VARIABLE : case DAP2Exception . MALFORMED_EXPR : case DAP2Exception . UNKNOWN_ERROR : default : response . setStatus ( HttpStatus . SC_BAD_REQUEST ) ; \nbreak ; \n} \ntry { \nBufferedOutputStream eOut = new BufferedOutputStream ( response . getOutputStream ( ) ) ; \nresponse . setHeader ( \"Content-Description\" , \"dods-error\" ) ; \nresponse . setHeader ( \"Content-Encoding\" , \"\" ) ; \nde . print ( eOut ) ; \n} \ncatch ( IOException ioe ) { \nlog . error ( \"Cannot respond to client! IO Error: \" + ioe . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5358": "public class DTSServlet { \npublic void badURL ( HttpServletRequest request , HttpServletResponse response ) throws Exception { \nif ( Debug . isSet ( \"showResponse\" ) ) { \nlog . debug ( \"Sending Bad URL Page.\" ) ; \n} \nresponse . setContentType ( \"text/html\" ) ; \nresponse . setHeader ( \"XDODS-Server\" , getServerVersion ( ) ) ; \nresponse . setHeader ( \"Content-Description\" , \"dods-error\" ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( response . getOutputStream ( ) , Util . UTF8 ) ) ; \nprintBadURLPage ( pw ) ; \nprintHelpPage ( pw ) ; \npw . flush ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_OK ) ; \nreturn ; \n} \n} \n"}
{"5359": "public class DTSServlet { \npublic void doGetCatalog ( ReqState rs ) throws Exception { \nrs . getResponse ( ) . setHeader ( \"XDODS-Server\" , getServerVersion ( ) ) ; \nrs . getResponse ( ) . setContentType ( \"text/xml\" ) ; \nrs . getResponse ( ) . setHeader ( \"Content-Description\" , \"dods-catalog\" ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( rs . getResponse ( ) . getOutputStream ( ) , Util . UTF8 ) ) ; \nprintCatalog ( rs , pw ) ; \npw . flush ( ) ; \nrs . getResponse ( ) . setStatus ( HttpServletResponse . SC_OK ) ; \nreturn ; \n} \n} \n"}
{"5360": "public class DTSServlet { \nprotected void printCatalog ( ReqState rs , PrintWriter os ) throws IOException { \nos . println ( \"Catalog not available for this server\" ) ; \nos . println ( \"Server version = \" + getServerVersion ( ) ) ; \nreturn ; \n} \n} \n"}
{"5361": "public class DTSServlet { \nprotected void printStatus ( PrintWriter os ) { \nos . println ( \"<h2>Server version = \" + getServerVersion ( ) + \"</h2>\" ) ; \nos . println ( \"<h2>Number of Requests Received = \" + HitCounter + \"</h2>\" ) ; \nif ( track ) { \nint n = prArr . size ( ) ; \nint pending = 0 ; \nStringBuilder preqs = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nReqState rs = ( ReqState ) prArr . get ( i ) ; \nRequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; \nif ( ! reqD . done ) { \npreqs . append ( \"<pre>-----------------------\\n\" ) ; \npreqs . append ( \"Request[\" ) ; \npreqs . append ( reqD . reqno ) ; \npreqs . append ( \"](\" ) ; \npreqs . append ( reqD . threadDesc ) ; \npreqs . append ( \") is pending.\\n\" ) ; \npreqs . append ( rs . toString ( ) ) ; \npreqs . append ( \"</pre>\" ) ; \npending ++ ; \n} \n} \nos . println ( \"<h2>\" + pending + \" Pending Request(s)</h2>\" ) ; \nos . println ( preqs . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5362": "public class DTSServlet { \nprivate void printBadURLPage ( PrintWriter pw ) { \npw . println ( \"<h3>Error in URL</h3>\" ) ; \npw . println ( \"The URL extension did not match any that are known by this\" ) ; \npw . println ( \"server. Below is a list of the five extensions that are be recognized by\" ) ; \npw . println ( \"all OPeNDAP servers. If you think that the server is broken (that the URL you\" ) ; \npw . println ( \"submitted should have worked), then please contact the\" ) ; \npw . println ( \"OPeNDAP user support coordinator at: \" ) ; \npw . println ( \"<a href=\\\"mailto:support@unidata.ucar.edu\\\">support@unidata.ucar.edu</a><p>\" ) ; \nreturn ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nwhile ( i < sb . length ( ) ) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \n} \nif ( ok ) i ++ ; \n} \nreturn ; \n} \n} \n"}
{"5385": "public class StringUtil2 { \nstatic public void unreplace ( StringBuilder sb , String out , char in ) { \nint pos ; \nwhile ( 0 <= ( pos = sb . indexOf ( out ) ) ) { \nsb . setCharAt ( pos , in ) ; \nsb . delete ( pos + 1 , pos + out . length ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \nfor ( int i = 0 ; \ni < sb . length ( ) ; \ni ++ ) { \nint c = sb . charAt ( i ) ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5387": "public class StringUtil2 { \nstatic public void substitute ( StringBuilder sbuff , String match , String subst ) { \nint pos , fromIndex = 0 ; \nint substLen = subst . length ( ) ; \nint matchLen = match . length ( ) ; \nwhile ( 0 <= ( pos = sbuff . indexOf ( match , fromIndex ) ) ) { \nsbuff . replace ( pos , pos + matchLen , subst ) ; \nfromIndex = pos + substLen ; \n} \nreturn ; \n} \n} \n"}
{"5389": "public class InvDatasetFeatureCollection { \n@ Subscribe public void processEvent ( CollectionUpdateEvent event ) { \nif ( ! config . collectionName . equals ( event . getCollectionName ( ) ) ) return ; \ntry { \nupdate ( event . getType ( ) ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"Error processing event\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"5391": "public class InvDatasetFeatureCollection { \nprotected void update ( CollectionUpdateType force ) throws IOException { \nState localState ; \nsynchronized ( lock ) { \nif ( first ) { \nstate = checkState ( ) ; \nstate . lastInvChange = System . currentTimeMillis ( ) ; \nreturn ; \n} \nlocalState = state . copy ( ) ; \n} \nupdateCollection ( localState , force ) ; \nlocalState . lastInvChange = System . currentTimeMillis ( ) ; \nsynchronized ( lock ) { \nstate = localState ; \n} \nreturn ; \n} \n} \n"}
{"5392": "public class Grib2ReportPanel { \nprivate void doUniqueTemplates ( Formatter f , MCollection dcm , boolean useIndex ) throws IOException { \nf . format ( \"Show Unique GDS and PDS templates%n\" ) ; \nMap < Integer , FileList > gdsSet = new HashMap < > ( ) ; \nMap < Integer , FileList > pdsSet = new HashMap < > ( ) ; \nMap < Integer , FileList > drsSet = new HashMap < > ( ) ; \nfor ( MFile mfile : dcm . getFilesSorted ( ) ) { \nf . format ( \" %s%n\" , mfile . getPath ( ) ) ; \ndoUniqueTemplates ( mfile , gdsSet , pdsSet , drsSet , f ) ; \n} \nList < FileList > sorted = new ArrayList < > ( gdsSet . values ( ) ) ; \nCollections . sort ( sorted ) ; \nfor ( FileList gdsl : sorted ) { \nf . format ( \"%nGDS %s template= %d %n\" , gdsl . name , gdsl . template ) ; \nfor ( FileCount fc : gdsl . fileList ) { \nf . format ( \"  %5d %s %n\" , fc . countRecords , fc . f . getPath ( ) ) ; \n} \n} \nList < FileList > sortedPds = new ArrayList < > ( pdsSet . values ( ) ) ; \nCollections . sort ( sortedPds ) ; \nfor ( FileList pdsl : sortedPds ) { \nf . format ( \"%n===================================================%n\" ) ; \nf . format ( \"%nPDS %s template= %d %n\" , pdsl . name , pdsl . template ) ; \nfor ( FileCount fc : pdsl . fileList ) { \nf . format ( \"  %5d %s %n\" , fc . countRecords , fc . f . getPath ( ) ) ; \n} \n} \nList < FileList > sortedDrs = new ArrayList < > ( drsSet . values ( ) ) ; \nCollections . sort ( sortedDrs ) ; \nfor ( FileList pdsl : sortedDrs ) { \nf . format ( \"%n===================================================%n\" ) ; \nf . format ( \"%nDRS %s template= %d %n\" , pdsl . name , pdsl . template ) ; \nfor ( FileCount fc : pdsl . fileList ) { \nf . format ( \"  %5d %s %n\" , fc . countRecords , fc . f . getPath ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5394": "public class InvCatalogRef { \npublic void release ( ) { \ndatasets = new java . util . ArrayList < > ( ) ; \nproxy = null ; \nuseProxy = false ; \ninit = false ; \nreturn ; \n} \n} \n"}
{"5404": "public class TableAnalyzer { \nprivate void analyze ( FeatureType wantFeatureType ) throws IOException { \nboolean structAdded = ( Boolean ) ds . sendIospMessage ( NetcdfFile . IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \nif ( tc == null ) { \nmakeTablesDefault ( structAdded ) ; \nmakeNestedTables ( ) ; \n} \nelse { \nconfigResult = tc . getConfig ( wantFeatureType , ds , errlog ) ; \nif ( configResult != null ) addTableRecurse ( configResult ) ; \nelse { \nmakeTablesDefault ( structAdded ) ; \nmakeNestedTables ( ) ; \n} \n} \nfor ( TableConfig config : tableSet ) { \nif ( config . children == null ) { \nNestedTable flatTable = new NestedTable ( ds , config , errlog ) ; \nleaves . add ( flatTable ) ; \n} \n} \nif ( PointDatasetStandardFactory . showTables ) getDetailInfo ( new Formatter ( System . out ) ) ; \nreturn ; \n} \n} \n"}
{"5410": "public class CSMConvention { \nprotected void findCoordinateAxes ( NetcdfDataset ds ) { \nfor ( VarProcess vp : varList ) { \nif ( vp . coordAxes == null ) { \nString coordsString = ds . findAttValueIgnoreCase ( vp . v , CF . COORDINATES , null ) ; \nif ( coordsString != null ) { \nvp . coordinates = coordsString ; \n} \n} \n} \nsuper . findCoordinateAxes ( ds ) ; \nreturn ; \n} \n} \n"}
{"5414": "public class Group { \npublic void setParentGroup ( Group parent ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nsuper . setParentGroup ( parent == null ? ncfile . getRootGroup ( ) : parent ) ; \nreturn ; \n} \n} \n"}
{"5415": "public class Group { \npublic void addDimension ( Dimension dim ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( ! dim . isShared ( ) ) { \nthrow new IllegalArgumentException ( \"Dimensions added to a group must be shared.\" ) ; \n} \nif ( findDimensionLocal ( dim . getShortName ( ) ) != null ) throw new IllegalArgumentException ( \"Dimension name (\" + dim . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \ndimensions . add ( dim ) ; \ndim . setGroup ( this ) ; \nreturn ; \n} \n} \n"}
{"5417": "public class Group { \npublic void addGroup ( Group g ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( findGroup ( g . getShortName ( ) ) != null ) throw new IllegalArgumentException ( \"Group name (\" + g . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \ngroups . add ( g ) ; \ng . setParentGroup ( this ) ; \nreturn ; \n} \n} \n"}
{"5418": "public class Group { \npublic void addEnumeration ( EnumTypedef e ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( e == null ) return ; \ne . setParentGroup ( this ) ; \nenumTypedefs . add ( e ) ; \nreturn ; \n} \n} \n"}
{"5419": "public class Group { \npublic void addVariable ( Variable v ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( v == null ) return ; \nif ( findVariable ( v . getShortName ( ) ) != null ) { \nthrow new IllegalArgumentException ( \"Variable name (\" + v . getShortName ( ) + \") must be unique within Group \" + getShortName ( ) ) ; \n} \nvariables . add ( v ) ; \nv . setParentGroup ( this ) ; \nreturn ; \n} \n} \n"}
{"5423": "public class DDS { \npublic void printDAS ( PrintWriter pw ) { \nDAS myDAS = null ; \ntry { \nmyDAS = this . getDAS ( ) ; \nmyDAS . print ( pw ) ; \n} \ncatch ( DASException dasE ) { \npw . println ( \"\\n\\nCould not get a DAS object to print!\\n\" + \"DDS.getDAS() threw an Exception. Message: \\n\" + dasE . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5425": "public class GeotiffWriter { \npublic void writeGrid ( GridDataset dataset , GridDatatype grid , Array data , boolean greyScale ) throws IOException { \nGridCoordSystem gcs = grid . getCoordinateSystem ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) { \nthrow new IllegalArgumentException ( \"Must have 1D x and y axes for \" + grid . getFullName ( ) ) ; \n} \nCoordinateAxis1D xaxis = ( CoordinateAxis1D ) gcs . getXHorizAxis ( ) ; \nCoordinateAxis1D yaxis = ( CoordinateAxis1D ) gcs . getYHorizAxis ( ) ; \ndouble scaler = ( xaxis . getUnitsString ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge ( 0 ) * scaler ; \ndouble xInc = xaxis . getIncrement ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getIncrement ( ) ) * scaler ; \nif ( yaxis . getCoordValue ( 0 ) < yaxis . getCoordValue ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdge ( ( int ) yaxis . getSize ( ) ) * scaler ; \n} \nif ( ! xaxis . isRegular ( ) || ! yaxis . isRegular ( ) ) { \nthrow new IllegalArgumentException ( \"Must be evenly spaced grid = \" + grid . getFullName ( ) ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nwriteGrid ( grid , data , greyScale , xStart , yStart , xInc , yInc , pageNumber ) ; \npageNumber ++ ; \nreturn ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nint nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( greyScale ) { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nint height = data . getShape ( ) [ 0 ] ; \nint width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber ++ ; \nreturn ; \n} \n} \n"}
{"5430": "public class WFSExceptionWriter { \npublic void write ( HttpServletResponse hsr ) throws IOException { \nPrintWriter xmlResponse = hsr . getWriter ( ) ; \nxmlResponse . append ( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" ) ; \nxmlResponse . append ( \"<ows:ExceptionReport xml:lang=\\\"en-US\\\" xsi:schemaLocation=\\\"http://www.opengis.net/ows/1.1\" + \" http://schemas.opengis.net/ows/1.1.0/owsExceptionReport.xsd\\\" version=\\\"2.0.0\\\" xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\">\" ) ; \nxmlResponse . append ( \"<ows:Exception \" ) ; \nif ( locator != null ) xmlResponse . append ( \"locator=\\\"\" + locator + \"\\\" \" ) ; \nxmlResponse . append ( \"exceptionCode=\\\"\" + ExceptionCode + \"\\\">\" ) ; \nxmlResponse . append ( \"<ows:ExceptionText>\" + text + \"</ows:ExceptionText>\" ) ; \nxmlResponse . append ( \"</ows:Exception>\" ) ; \nxmlResponse . append ( \"</ows:ExceptionReport>\" ) ; \nreturn ; \n} \n} \n"}
{"5440": "public class RC { \nstatic synchronized public void add ( String key , String value , String url ) { \nif ( key == null ) return ; \nif ( ! initialized ) RC . initialize ( ) ; \nTriple t = new Triple ( key , value , url ) ; \ndfaltRC . insert ( t ) ; \nsetWellKnown ( ) ; \nreturn ; \n} \n} \n"}
{"5442": "public class RC { \nstatic void setWellKnown ( ) { \nif ( dfaltRC . triplestore . size ( ) == 0 ) return ; \nfor ( String key : dfaltRC . keySet ( ) ) { \nTriple triple = dfaltRC . lookup ( key ) ; \nif ( triple . url == null ) { \nRC . set ( key , triple . value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5447": "public class GisFeatureRendererMulti { \npublic void setProjection ( ProjectionImpl project ) { \ndisplayProject = project ; \nif ( featSetList == null ) return ; \nIterator iter = featSetList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nFeatureSet fs = ( FeatureSet ) iter . next ( ) ; \nfs . newProjection = true ; \n} \nreturn ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) return false ; \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) System . out . println ( \" task.cancel\" ) ; \nreturn ; \n} \nelse { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) System . out . println ( \" stop count=\" + count ) ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nbusy = false ; \n} \nreturn ; \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5453": "public class EnsCoord { \nstatic public void normalize ( EnsCoord result , List < EnsCoord > ecList ) { \nList < EnsCoord > extra = new ArrayList < > ( ) ; \nfor ( EnsCoord ec : ecList ) { \nif ( ! result . equalsData ( ec ) ) { \nextra . add ( ec ) ; \n} \n} \nif ( extra . size ( ) == 0 ) return ; \nfor ( EnsCoord ec : extra ) { \nif ( ec . getNEnsembles ( ) < result . getNEnsembles ( ) ) continue ; \nresult = ec ; \n} \nreturn ; \n} \n} \n"}
{"5454": "public class ArrayStructure { \npublic void setObject ( int index , Object value ) { \nif ( sdata == null ) sdata = new StructureData [ nelems ] ; \nsdata [ index ] = ( StructureData ) value ; \nreturn ; \n} \n} \n"}
{"5456": "public class ArrayStructure { \nprotected void copyStructures ( int recnum , StructureMembers . Member m , IndexIterator result ) { \nArray data = getArray ( recnum , m ) ; \nIndexIterator dataIter = data . getIndexIterator ( ) ; \nwhile ( dataIter . hasNext ( ) ) result . setObjectNext ( dataIter . getObjectNext ( ) ) ; \nreturn ; \n} \n} \n"}
{"5474": "public class CEConstraint { \nprotected void computeenums ( ) { \nfor ( int i = 0 ; \ni < variables . size ( ) ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nif ( var . getSort ( ) != DapSort . VARIABLE ) continue ; \nDapType daptype = var . getBaseType ( ) ; \nif ( ! daptype . isEnumType ( ) ) continue ; \nif ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) this . enums . add ( ( DapEnumeration ) daptype ) ; \n} \nreturn ; \n} \n} \n"}
{"5475": "public class CEConstraint { \nprotected void computegroups ( ) { \nfor ( int i = 0 ; \ni < variables . size ( ) ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nList < DapGroup > path = var . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapDimension dim : this . dimrefs ) { \nif ( ! dim . isShared ( ) ) continue ; \nList < DapGroup > path = dim . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapEnumeration en : this . enums ) { \nList < DapGroup > path = en . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5478": "public class ThreddsUI { \nprivate void makeActionsSystem ( ) { \nAbstractAction clearDebugFlagsAction = new AbstractAction ( ) { \npublic void actionPerformed ( ActionEvent e ) { \nreturn ; \n} \n} \n; \nBAMutil . setActionProperties ( clearDebugFlagsAction , null , \"Clear Debug Flags\" , false , 'D' , - 1 ) ; \nreturn ; \n} \n} \n"}
{"5480": "public class GempakFileReader { \nvoid setByteOrder ( ) { \nString arch = System . getProperty ( \"os.arch\" ) ; \nif ( arch . equals ( \"x86\" ) || arch . equals ( \"arm\" ) || arch . equals ( \"x86_64\" ) || arch . equals ( \"amd64\" ) || arch . equals ( \"alpha\" ) ) { \nMTMACH = RandomAccessFile . LITTLE_ENDIAN ; \n} \nelse { \nMTMACH = RandomAccessFile . BIG_ENDIAN ; \n} \nreturn ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < parts . size ( ) ; \ni ++ ) { \nSystem . out . println ( \"\\nParts[\" + i + \"]:\" ) ; \nSystem . out . println ( parts . get ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5490": "public class N3channelWriter { \npublic static void writeToChannel ( NetcdfFile ncfile , WritableByteChannel wbc ) throws IOException , InvalidRangeException { \nDataOutputStream stream = new DataOutputStream ( new BufferedOutputStream ( Channels . newOutputStream ( wbc ) , 8000 ) ) ; \nN3channelWriter writer = new N3channelWriter ( ncfile ) ; \nint numrec = ncfile . getUnlimitedDimension ( ) == null ? 0 : ncfile . getUnlimitedDimension ( ) . getLength ( ) ; \nwriter . writeHeader ( stream , numrec ) ; \nstream . flush ( ) ; \nwriter . writeDataAll ( wbc ) ; \nreturn ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse if ( type . equals ( \"Alias\" ) ) { \n} \nelse if ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) System . out . println ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) System . out . println ( \"Parsing new BaseType element. Parse level: \" + parseLevel ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) { \nparseGrid ( e , indent ) ; \n} \nelse { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse if ( bt instanceof DArray ) { \nif ( _Debug ) System . out . println ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \nparseLevel -- ; \nreturn ; \n} \n} \n"}
{"5492": "public class DDSXMLParser { \nprivate void parseGrid ( Element gridElement , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nDGrid myGrid = ( DGrid ) parentDC ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Grid Element: \" + gridElement ) ; \nSystem . out . println ( \"Grid Elements: \" ) ; \nfor ( Element element : gridElement . getChildren ( ) ) System . out . println ( element ) ; \n} \nString eName = \"Array\" ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Array element.\" ) ; \nSystem . out . println ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" ) ; \n} \nElement arrayElement = gridElement . getChild ( eName , opendapNameSpace ) ; \nif ( _Debug ) System . out . println ( \"Got Array element: \" + arrayElement ) ; \nDArray gridArray = ( DArray ) newBaseType ( arrayElement ) ; \nparseArray ( arrayElement , gridArray , indent + \"    \" ) ; \nmyGrid . addVariable ( gridArray , DGrid . ARRAY ) ; \neName = \"Map\" ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Map elements.\" ) ; \nSystem . out . println ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" ) ; \n} \nList < Element > mapElements = gridElement . getChildren ( \"Map\" , opendapNameSpace ) ; \nif ( mapElements . size ( ) != gridArray . numDimensions ( ) ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"The number of Map arrays must \" + \"equal the number of dimensions \" + \"of the data array.\" ) ; \nfor ( Element mapElement : mapElements ) { \nDArray thisMap = ( DArray ) newBaseType ( mapElement ) ; \nparseArray ( mapElement , thisMap , indent + \"    \" ) ; \nif ( thisMap . numDimensions ( ) != 1 ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"Maps may have only one dimension.\" ) ; \nmyGrid . addVariable ( thisMap , DGrid . MAPS ) ; \n} \nparseLevel -- ; \nreturn ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel ++ ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) System . out . println ( indent + \"Parsing Aliases: \" ) ; \nif ( _Debug ) System . out . println ( subIndent + \"currentBT: \" + currentBT . getTypeName ( ) + \" \" + currentBT . getClearName ( ) ) ; \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) { \nSystem . out . println ( subIndent + \"The name '\" + name + \"' is aliased to dds attribute: '\" + attributeName + \"'\" ) ; \n} \nif ( currentAT == null ) currentBT . addAttributeAlias ( name , attributeName ) ; \nelse currentAT . addAlias ( name , attributeName ) ; \n} \nparseLevel -- ; \nreturn ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni ++ ) { \nSystem . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \n} \nSystem . out . println ( \"Methods:\" ) ; \nfor ( int i = 0 ; \ni < m . length ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( int j = 0 ; \nj < excepts . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . println ( \"\" ) ; \n} \nSystem . out . println ( \"******************\" ) ; \nreturn ; \n} \n} \n"}
{"5505": "public class AccessLogTable { \nprivate void showTimeSeriesAll ( java . util . List < LogReader . Log > logs ) { \nTimeSeries bytesSentData = new TimeSeries ( \"Bytes Sent\" , Minute . class ) ; \nTimeSeries timeTookData = new TimeSeries ( \"Average Latency\" , Minute . class ) ; \nTimeSeries nreqData = new TimeSeries ( \"Number of Requests\" , Minute . class ) ; \nString intervalS = \"5 minute\" ; \nlong period = 1000 * 60 * 5 ; \ntry { \nTimeDuration tu = new TimeDuration ( intervalS ) ; \nperiod = ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"Illegal Time interval=%s %n\" , intervalS ) ; \n} \nlong current = 0 ; \nlong bytes = 0 ; \nlong timeTook = 0 ; \nlong total_count = 0 ; \nlong count = 0 ; \nfor ( LogReader . Log log : logs ) { \nlong msecs = log . date ; \nif ( msecs - current > period ) { \nif ( current > 0 ) { \ntotal_count += count ; \naddPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \n} \nbytes = 0 ; \ncount = 0 ; \ntimeTook = 0 ; \ncurrent = msecs ; \n} \nbytes += log . getBytes ( ) ; \ntimeTook += log . getMsecs ( ) ; \ncount ++ ; \n} \nif ( count > 0 ) addPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \ntotal_count += count ; \nSystem . out . printf ( \"showTimeSeriesAll: total_count = %d logs = %d%n\" , total_count , logs . size ( ) ) ; \nMultipleAxisChart mc = new MultipleAxisChart ( \"Access Logs\" , intervalS + \" average\" , \"Mbytes Sent\" , bytesSentData ) ; \nmc . addSeries ( \"Number of Requests\" , nreqData ) ; \nmc . addSeries ( \"Average Latency (secs)\" , timeTookData ) ; \nmc . finish ( new java . awt . Dimension ( 1000 , 1000 ) ) ; \ntimeSeriesPanel . removeAll ( ) ; \ntimeSeriesPanel . add ( mc ) ; \nreturn ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5510": "public class Attribute { \nprivate void setStringValue ( String val ) { \nif ( val == null ) throw new IllegalArgumentException ( \"Attribute value cannot be null\" ) ; \nint len = val . length ( ) ; \nwhile ( ( len > 0 ) && ( val . charAt ( len - 1 ) == 0 ) ) len -- ; \nif ( len != val . length ( ) ) val = val . substring ( 0 , len ) ; \nthis . svalue = val ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \nreturn ; \n} \n} \n"}
{"5512": "public class Attribute { \npublic void setValues ( Array arr ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( arr == null ) { \ndataType = DataType . STRING ; \nreturn ; \n} \nif ( arr . getElementType ( ) == char . class ) { \nArrayChar carr = ( ArrayChar ) arr ; \nif ( carr . getRank ( ) == 1 ) { \nsvalue = carr . getString ( ) ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \narr = carr . make1DStringArray ( ) ; \n} \nif ( arr . getElementType ( ) == ByteBuffer . class ) { \nint totalLen = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \ntotalLen += bb . limit ( ) ; \n} \nbyte [ ] ba = new byte [ totalLen ] ; \nint pos = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \nSystem . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; \npos += bb . limit ( ) ; \n} \narr = Array . factory ( DataType . BYTE , new int [ ] { \ntotalLen } \n, ba ) ; \n} \nif ( DataType . getType ( arr ) == DataType . OBJECT ) throw new IllegalArgumentException ( \"Cant set Attribute with type \" + arr . getElementType ( ) ) ; \nif ( arr . getRank ( ) > 1 ) arr = arr . reshape ( new int [ ] { \n( int ) arr . getSize ( ) } \n) ; \nthis . values = arr ; \nthis . nelems = ( int ) arr . getSize ( ) ; \nthis . dataType = DataType . getType ( arr ) ; \nreturn ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) throw new IllegalStateException ( \"Scan already underway.\" ) ; \nif ( state >= 2 ) throw new IllegalStateException ( \"Scan has already been generated.\" ) ; \nstate = 1 ; \nif ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) sorter . sort ( crDsList ) ; \nfor ( int i = 0 ; \ni < crDsList . size ( ) ; \ni ++ ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( curCrDs . isCollection ( ) ) catRefInfo . add ( dsInfo ) ; \nelse atomicDsInfo . add ( dsInfo ) ; \ntopInvDs . addDataset ( curInvDs ) ; \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( atomicDsInfo . size ( ) > 0 ) { \nboolean anyProxiesAdded = false ; \nfor ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nint index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \nif ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \nreturn ; \n} \n} \n"}
{"5515": "public class MessageWriter { \nvoid scheduleWrite ( Message m ) { \nq . add ( m ) ; \nif ( ! isScheduled . getAndSet ( true ) ) { \nexecutor . submit ( this ) ; \n} \nreturn ; \n} \n} \n"}
{"5516": "public class ToolsUI { \nprivate void setThreddsDatatype ( thredds . client . catalog . Dataset invDataset , String wants ) { \nif ( invDataset == null ) return ; \nboolean wantsViewer = wants . equals ( \"File\" ) ; \nboolean wantsCoordSys = wants . equals ( \"CoordSys\" ) ; \ntry { \nif ( wantsViewer ) { \nopenNetcdfFile ( threddsDataFactory . openDataset ( invDataset , true , null , null ) ) ; \nreturn ; \n} \nif ( wantsCoordSys ) { \nNetcdfDataset ncd = threddsDataFactory . openDataset ( invDataset , true , null , null ) ; \nncd . enhance ( ) ; \nopenCoordSystems ( ncd ) ; \nreturn ; \n} \nDataFactory . Result threddsData = threddsDataFactory . openFeatureDataset ( invDataset , null ) ; \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( null , \"Failed to open err=\" + threddsData . errLog ) ; \nreturn ; \n} \njumptoThreddsDatatype ( threddsData ) ; \n} \ncatch ( IOException ioe ) { \nJOptionPane . showMessageDialog ( null , \"Error on setThreddsDatatype = \" + ioe . getMessage ( ) ) ; \nioe . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5517": "public class ToolsUI { \nprivate void jumptoThreddsDatatype ( thredds . client . catalog . Access invAccess ) { \nif ( invAccess == null ) { \nreturn ; \n} \nthredds . client . catalog . Service s = invAccess . getService ( ) ; \nif ( s . getType ( ) == ServiceType . HTTPServer ) { \ndownloadFile ( invAccess . getStandardUrlName ( ) ) ; \nreturn ; \n} \nif ( s . getType ( ) == ServiceType . WMS ) { \nopenWMSDataset ( invAccess . getStandardUrlName ( ) ) ; \nreturn ; \n} \nif ( s . getType ( ) == ServiceType . CdmrFeature ) { \nopenCoverageDataset ( invAccess . getWrappedUrlName ( ) ) ; \nreturn ; \n} \nthredds . client . catalog . Dataset ds = invAccess . getDataset ( ) ; \nif ( ds . getFeatureType ( ) == null ) { \ntry { \nopenNetcdfFile ( threddsDataFactory . openDataset ( invAccess , true , null , null ) ) ; \n} \ncatch ( IOException ioe ) { \nJOptionPane . showMessageDialog ( null , \"Error on setThreddsDatatype = \" + ioe . getMessage ( ) ) ; \n} \nreturn ; \n} \nDataFactory . Result threddsData = null ; \ntry { \nthreddsData = threddsDataFactory . openFeatureDataset ( invAccess , null ) ; \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( null , \"Failed to open err=\" + threddsData . errLog ) ; \nreturn ; \n} \njumptoThreddsDatatype ( threddsData ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nJOptionPane . showMessageDialog ( null , \"Error on setThreddsDatatype = \" + ioe . getMessage ( ) ) ; \nif ( threddsData != null ) { \ntry { \nthreddsData . close ( ) ; \n} \ncatch ( IOException ioe2 ) { \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5518": "public class ToolsUI { \nprivate void jumptoThreddsDatatype ( DataFactory . Result threddsData ) { \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( this , \"Cant open dataset=\" + threddsData . errLog ) ; \ntry { \nthreddsData . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \nif ( threddsData . featureType . isCoverageFeatureType ( ) ) { \nif ( threddsData . featureDataset instanceof FeatureDatasetCoverage ) { \nmakeComponent ( ftTabPane , \"Coverages\" ) ; \ncoveragePanel . setDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( coveragePanel ) ; \n} \nelse if ( threddsData . featureDataset instanceof GridDataset ) { \nmakeComponent ( ftTabPane , \"Grids\" ) ; \ngridPanel . setDataset ( ( GridDataset ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( gridPanel ) ; \n} \n} \nelse if ( threddsData . featureType == FeatureType . IMAGE ) { \nmakeComponent ( ftTabPane , \"Images\" ) ; \nimagePanel . setImageLocation ( threddsData . imageURL ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( imagePanel ) ; \n} \nelse if ( threddsData . featureType == FeatureType . RADIAL ) { \nmakeComponent ( ftTabPane , \"Radial\" ) ; \nradialPanel . setDataset ( ( RadialDatasetSweep ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( radialPanel ) ; \n} \nelse if ( threddsData . featureType . isPointFeatureType ( ) ) { \nmakeComponent ( ftTabPane , \"PointFeature\" ) ; \npointFeaturePanel . setPointFeatureDataset ( ( PointDatasetImpl ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( pointFeaturePanel ) ; \n} \nelse if ( threddsData . featureType == FeatureType . STATION_RADIAL ) { \nmakeComponent ( ftTabPane , \"StationRadial\" ) ; \nstationRadialPanel . setStationRadialDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( stationRadialPanel ) ; \n} \nreturn ; \n} \n} \n"}
{"5519": "public class ToolsUI { \nprivate static void setDataset ( ) { \nSwingUtilities . invokeLater ( ( ) -> { \nint pos = wantDataset . indexOf ( '#' ) ; \nif ( pos > 0 ) { \nfinal String catName = wantDataset . substring ( 0 , pos ) ; \nif ( catName . endsWith ( \".xml\" ) ) { \nui . makeComponent ( null , \"THREDDS\" ) ; \nui . threddsUI . setDataset ( wantDataset ) ; \nui . tabbedPane . setSelectedComponent ( ui . threddsUI ) ; \n} \nreturn ; \n} \nui . openNetcdfFile ( wantDataset ) ; \n} \n) ; \nreturn ; \n} \n} \n"}
{"5520": "public class ToolsUI { \nprivate static void prepareGui ( ) { \nfinal String osName = System . getProperty ( \"os.name\" ) . toLowerCase ( ) ; \nfinal boolean isMacOs = osName . startsWith ( \"mac os x\" ) ; \nif ( isMacOs ) { \nSystem . setProperty ( \"apple.laf.useScreenMenuBar\" , \"true\" ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { \n@ Override public void run ( ) { \ndoSavePrefsAndUI ( ) ; \nreturn ; \n} \n} \n) ; \n} \nelse { \ntry { \nfor ( UIManager . LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { \nif ( \"Nimbus\" . equals ( info . getName ( ) ) ) { \nUIManager . setLookAndFeel ( info . getClassName ( ) ) ; \nbreak ; \n} \n} \n} \ncatch ( Exception exc ) { \nlog . warn ( \"Unable to apply Nimbus look-and-feel due to {}\" , exc . toString ( ) ) ; \nif ( log . isTraceEnabled ( ) ) { \nexc . printStackTrace ( ) ; \n} \n} \n} \nBAMutil . setResourcePath ( \"/resources/nj22/ui/icons/\" ) ; \nSwingUtilities . invokeLater ( ( ) -> { \nfinal Toolkit tk = Toolkit . getDefaultToolkit ( ) ; \nfinal Font f = new Font ( \"SansSerif\" , Font . PLAIN , 12 ) ; \n@ SuppressWarnings ( \"deprecation\" ) final FontMetrics fm = tk . getFontMetrics ( f ) ; \n} \n) ; \nreturn ; \n} \n} \n"}
{"5521": "public class ToolsUI { \nprivate static void createToolsFrame ( ) { \nframe = new JFrame ( \"NetCDF (\" + DIALOG_VERSION + \") Tools\" ) ; \nui = new ToolsUI ( prefs , frame ) ; \nframe . setIconImage ( BAMutil . getImage ( \"netcdfUI\" ) ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \n@ Override public void windowActivated ( final WindowEvent e ) { \nToolsSplashScreen . getSharedInstance ( ) . setVisible ( false ) ; \nreturn ; \n} \n@ Override public void windowClosing ( final WindowEvent e ) { \nif ( ! done ) { \nexit ( ) ; \n} \nreturn ; \n} \n} \n) ; \nframe . getContentPane ( ) . add ( ui ) ; \nfinal Rectangle have = frame . getGraphicsConfiguration ( ) . getBounds ( ) ; \nfinal Rectangle def = new Rectangle ( 50 , 50 , 800 , 800 ) ; \nRectangle want = ( Rectangle ) prefs . getBean ( FRAME_SIZE , def ) ; \nif ( want . getX ( ) > have . getWidth ( ) - 25 ) { \nwant = def ; \n} \nframe . setBounds ( want ) ; \nframe . pack ( ) ; \nframe . setBounds ( want ) ; \nif ( wantDataset != null ) { \nsetDataset ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5538": "public class BeanTable { \npublic void setSelectedBean ( Object bean ) { \nif ( bean == null ) return ; \nint modelRowIndex = beans . indexOf ( bean ) ; \nint viewRowIndex = jtable . convertRowIndexToView ( modelRowIndex ) ; \nif ( viewRowIndex >= 0 ) jtable . getSelectionModel ( ) . setSelectionInterval ( viewRowIndex , viewRowIndex ) ; \nmakeRowVisible ( viewRowIndex ) ; \nreturn ; \n} \n} \n"}
{"5539": "public class BeanTable { \nprotected void restoreState ( ) { \nif ( store == null ) { \nreturn ; \n} \nArrayList propColObjs = ( ArrayList ) store . getBean ( \"propertyCol\" , new ArrayList ( ) ) ; \nHidableTableColumnModel tableColumnModel = ( HidableTableColumnModel ) jtable . getColumnModel ( ) ; \nint newViewIndex = 0 ; \nfor ( Object propColObj : propColObjs ) { \nPropertyCol propCol = ( PropertyCol ) propColObj ; \ntry { \nint currentViewIndex = tableColumnModel . getColumnIndex ( propCol . getName ( ) ) ; \nTableColumn column = tableColumnModel . getColumn ( currentViewIndex ) ; \ncolumn . setPreferredWidth ( propCol . getWidth ( ) ) ; \ntableColumnModel . moveColumn ( currentViewIndex , newViewIndex ) ; \nassert tableColumnModel . getColumn ( newViewIndex ) == column : \"tableColumn wasn't successfully moved.\" ; \ntableColumnModel . setColumnVisible ( column , propCol . isVisible ( ) ) ; \nif ( propCol . isVisible ( ) ) { \n++ newViewIndex ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nlogger . debug ( String . format ( \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\" , propCol . getName ( ) ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5541": "public class HTTPMethodStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) return ; \nclosed = true ; \ntry { \nconsume ( ) ; \n} \nfinally { \nsuper . close ( ) ; \n} \nif ( method != null ) method . close ( ) ; \nreturn ; \n} \n} \n"}
{"5545": "public class NestedTable { \nprivate void addDataVariables ( List < VariableSimpleIF > list , Table t ) { \nif ( t . parent != null ) addDataVariables ( list , t . parent ) ; \nfor ( VariableSimpleIF col : t . cols . values ( ) ) { \nif ( t . nondataVars . contains ( col . getFullName ( ) ) ) continue ; \nif ( t . nondataVars . contains ( col . getShortName ( ) ) ) continue ; \nlist . add ( col ) ; \n} \nreturn ; \n} \n} \n"}
{"5546": "public class NestedTable { \nvoid addParentJoin ( Cursor cursor ) throws IOException { \nint level = cursor . currentIndex ; \nTable t = getTable ( level ) ; \nif ( t . extraJoins != null ) { \nList < StructureData > sdata = new ArrayList < > ( 3 ) ; \nsdata . add ( cursor . tableData [ level ] ) ; \nfor ( Join j : t . extraJoins ) { \nsdata . add ( j . getJoinData ( cursor ) ) ; \n} \ncursor . tableData [ level ] = StructureDataFactory . make ( sdata . toArray ( new StructureData [ sdata . size ( ) ] ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5564": "public class CatalogCrawler { \npublic void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nboolean isDataScan = ds . findProperty ( \"DatasetScan\" ) != null ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nif ( ! isCatRef || isDataScan ) listen . getDataset ( ds , context ) ; \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( ! isDataScan ) { \nlisten . getDataset ( catref . getProxyDataset ( ) , context ) ; \n} \n} \nfor ( InvDataset dds : dlist ) { \ncrawlDataset ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( isCatRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse if ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5568": "public class RandomAccessFile { \nstatic public void setDebugLeaks ( boolean b ) { \nif ( b ) { \ncount_openFiles . set ( 0 ) ; \nmaxOpenFiles . set ( 0 ) ; \nallFiles = new HashSet < > ( 1000 ) ; \n} \ndebugLeaks = b ; \nreturn ; \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( cacheState > 0 ) { \nif ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) System . out . println ( \"  close \" + location ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) { \nfile . setLength ( minLength ) ; \n} \nfile . close ( ) ; \nfile = null ; \nreturn ; \n} \n} \n"}
{"5571": "public class RandomAccessFile { \npublic void seek ( long pos ) throws IOException { \nif ( pos < 0 ) throw new java . io . IOException ( \"Negative seek offset\" ) ; \nif ( ( pos >= bufferStart ) && ( pos < dataEnd ) ) { \nfilePosition = pos ; \nreturn ; \n} \nreadBuffer ( pos ) ; \nreturn ; \n} \n} \n"}
{"5572": "public class RandomAccessFile { \npublic void flush ( ) throws IOException { \nif ( bufferModified ) { \nfile . seek ( bufferStart ) ; \nfile . write ( buffer , 0 , dataSize ) ; \nbufferModified = false ; \n} \nreturn ; \n} \n} \n"}
{"5574": "public class RandomAccessFile { \npublic final void readShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = readShort ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5576": "public class RandomAccessFile { \npublic final void readInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = readInt ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5577": "public class RandomAccessFile { \npublic final void readLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = readLong ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5578": "public class RandomAccessFile { \npublic final void readFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5579": "public class RandomAccessFile { \npublic final void readDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \npa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5582": "public class RandomAccessFile { \npublic final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteBoolean ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5583": "public class RandomAccessFile { \npublic final void writeShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteShort ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5584": "public class RandomAccessFile { \npublic final void writeChar ( char [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteChar ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5585": "public class RandomAccessFile { \npublic final void writeInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteInt ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5586": "public class RandomAccessFile { \npublic final void writeLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteLong ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5587": "public class RandomAccessFile { \npublic final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteFloat ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5588": "public class RandomAccessFile { \npublic final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nwriteDouble ( pa [ start + i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5589": "public class RandomAccessFile { \npublic final void writeBytes ( String s ) throws IOException { \nint len = s . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nwrite ( ( byte ) s . charAt ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5590": "public class RandomAccessFile { \npublic final void writeBytes ( char b [ ] , int off , int len ) throws IOException { \nfor ( int i = off ; \ni < len ; \ni ++ ) { \nwrite ( ( byte ) b [ i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"5592": "public class Selector { \npublic void appendQuery ( StringBuffer sbuff , ArrayList values ) { \nif ( template != null ) appendQueryFromTemplate ( sbuff , values ) ; \nelse appendQueryFromParamValue ( sbuff , values ) ; \nreturn ; \n} \n} \n"}
{"5597": "public class DirectoryBuilder { \nprivate void scanForChildren ( ) { \nif ( debug ) System . out . printf ( \"DirectoryBuilder.scanForChildren on %s \" , dir ) ; \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( dir ) ) { \nfor ( Path p : ds ) { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) { \nchildren . add ( new DirectoryBuilder ( topCollectionName , p , attr , suffix ) ) ; \nif ( debug && ( ++ count % 10 == 0 ) ) System . out . printf ( \"%d \" , count ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nif ( debug ) System . out . printf ( \"done=%d%n\" , count ) ; \nchildrenConstructed = true ; \nreturn ; \n} \n} \n"}
{"5601": "public class FileCache { \nprivate void remove ( CacheElement . CacheFile want ) { \nwant . remove ( ) ; \nfiles . remove ( want . ncfile ) ; \ntry { \nwant . ncfile . setFileCache ( null ) ; \nwant . ncfile . close ( ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"close failed on \" + want . ncfile . getLocation ( ) , e ) ; \n} \nwant . ncfile = null ; \nreturn ; \n} \n} \n"}
{"5602": "public class FileCache { \n@ Override public void eject ( Object hashKey ) { \nif ( disabled . get ( ) ) return ; \nCacheElement wantCacheElem = cache . get ( hashKey ) ; \nif ( wantCacheElem == null ) return ; \nsynchronized ( wantCacheElem ) { \nfor ( CacheElement . CacheFile want : wantCacheElem . list ) { \nfiles . remove ( want . ncfile ) ; \ntry { \nwant . ncfile . setFileCache ( null ) ; \nwant . ncfile . close ( ) ; \nlog . debug ( \"close \" + want . ncfile . getLocation ( ) ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"close failed on \" + want . ncfile . getLocation ( ) , e ) ; \n} \nwant . ncfile = null ; \nif ( debugPrint ) System . out . println ( \"  FileCache \" + name + \" eject \" + hashKey ) ; \n} \nwantCacheElem . list . clear ( ) ; \n} \ncache . remove ( hashKey ) ; \nreturn ; \n} \n} \n"}
{"5606": "public class FileCacheARC { \npublic synchronized void clearCache ( boolean force ) { \nList < CacheElement . CacheFile > deleteList = new ArrayList < > ( 2 * cache . size ( ) ) ; \nif ( force ) { \ncache . clear ( ) ; \ndeleteList . addAll ( files . values ( ) ) ; \nfiles . clear ( ) ; \n} \nelse { \nIterator < CacheElement . CacheFile > iter = files . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCacheElement . CacheFile file = iter . next ( ) ; \nif ( file . isLocked . compareAndSet ( false , true ) ) { \nfile . remove ( ) ; \ndeleteList . add ( file ) ; \niter . remove ( ) ; \n} \n} \nfor ( CacheElement elem : cache . values ( ) ) { \nif ( elem . list . size ( ) == 0 ) cache . remove ( elem . hashKey ) ; \n} \n} \nfor ( CacheElement . CacheFile file : deleteList ) { \nif ( force && file . isLocked . get ( ) ) cacheLog . warn ( \"FileCacheARC \" + name + \" force close locked file= \" + file ) ; \nif ( file . ncfile == null ) continue ; \ntry { \nfile . ncfile . setFileCache ( null ) ; \nfile . ncfile . close ( ) ; \nfile . ncfile = null ; \n} \ncatch ( IOException e ) { \nlog . error ( \"FileCacheARC \" + name + \" close failed on \" + file ) ; \n} \n} \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList . size ( ) + \" left=\" + files . size ( ) ) ; \nreturn ; \n} \n} \n"}
{"5607": "public class GridCoordSys { \nvoid makeVerticalTransform ( GridDataset gds , Formatter parseInfo ) { \nif ( vt != null ) return ; \nif ( vCT == null ) return ; \nvt = vCT . makeVerticalTransform ( gds . getNetcdfDataset ( ) , timeDim ) ; \nif ( vt == null ) { \nif ( parseInfo != null ) parseInfo . format ( \"  - ERR can't make VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \nelse { \nif ( parseInfo != null ) parseInfo . format ( \"  - VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5616": "public class DirectoryCollection { \npublic void iterateOverMFileCollection ( Visitor visit ) throws IOException { \nif ( debug ) System . out . printf ( \" iterateOverMFileCollection %s \" , collectionDir ) ; \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( collectionDir , new MyStreamFilter ( ) ) ) { \nfor ( Path p : ds ) { \ntry { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( ! attr . isDirectory ( ) ) visit . consume ( new MFileOS7 ( p ) ) ; \nif ( debug ) System . out . printf ( \"%d \" , count ++ ) ; \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Failed to read attributes from file found in Files.newDirectoryStream \" , ioe ) ; \n} \n} \n} \nif ( debug ) System . out . printf ( \"%d%n\" , count ) ; \nreturn ; \n} \n} \n"}
{"5617": "public class TdsDownloader { \npublic void getRemoteFiles ( final CancelTask _cancel ) { \nthis . cancel = _cancel ; \nString urls = config . getServerPrefix ( ) + \"/thredds/admin/log/\" + type + \"/\" ; \nta . append ( String . format ( \"Download URL = %s%n\" , urls ) ) ; \nString contents = null ; \ntry ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { \nint statusCode = method . execute ( ) ; \nif ( statusCode == 200 ) contents = method . getResponseAsString ( ) ; \nif ( ( contents == null ) || ( contents . length ( ) == 0 ) ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s%n%n\" , urls ) ) ; \nreturn ; \n} \nelse { \nta . append ( String . format ( \"Logs at URL = %s%n%s%n\" , urls , contents ) ) ; \n} \n} \ncatch ( Throwable t ) { \nta . append ( String . format ( \"Failed to get logs at URL = %s error = %s%n%n\" , urls , t . getMessage ( ) ) ) ; \nt . printStackTrace ( ) ; \nreturn ; \n} \nfinal String list = contents ; \nSwingWorker worker = new SwingWorker < String , Void > ( ) { \n@ Override protected String doInBackground ( ) throws Exception { \ntry { \nta . append ( String . format ( \"Local log files stored in = %s%n%n\" , localDir ) ) ; \nString [ ] lines = list . split ( \"\\n\" ) ; \nfor ( String line : lines ) { \nnew RemoteLog ( line . trim ( ) ) ; \nif ( cancel . isCancel ( ) ) { \nbreak ; \n} \n} \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \n} \nreturn null ; \n} \npublic void done ( ) { \nif ( cancel . isCancel ( ) ) ta . append ( String . format ( \"Download was cancelled for %s%n\" , type ) ) ; \nelse ta . append ( String . format ( \"Download complete for %s%n\" , type ) ) ; \nreturn ; \n} \n} \n; \nworker . execute ( ) ; \nreturn ; \n} \n} \n"}
{"5627": "public class GempakGridServiceProvider { \nprivate void initTables ( ) { \ntry { \nGempakGridParameterTable . addParameters ( \"resources/nj22/tables/gempak/wmogrib3.tbl\" ) ; \nGempakGridParameterTable . addParameters ( \"resources/nj22/tables/gempak/ncepgrib2.tbl\" ) ; \n} \ncatch ( Exception e ) { \nSystem . out . println ( \"unable to init tables\" ) ; \n} \nreturn ; \n} \n} \n"}
{"5640": "public class NetcdfFileWriter { \npublic void abort ( ) throws java . io . IOException { \nif ( spiw != null ) { \nspiw . close ( ) ; \nspiw = null ; \n} \nreturn ; \n} \n} \n"}
{"5641": "public class Bean { \npublic void writeProperties ( PrintWriter out ) throws IOException { \nif ( p == null ) p = BeanParser . getParser ( o . getClass ( ) ) ; \np . writeProperties ( o , out ) ; \nreturn ; \n} \n} \n"}
{"5649": "public class MetadataManager { \nstatic synchronized public void closeAll ( ) { \nList < MetadataManager > closeDatabases = new ArrayList < > ( openDatabases ) ; \nfor ( MetadataManager mm : closeDatabases ) { \nif ( debug ) System . out . println ( \"  close database \" + mm . collectionName ) ; \nmm . close ( ) ; \n} \nopenDatabases = new ArrayList < > ( ) ; \nif ( myEnv != null ) { \ntry { \nmyEnv . close ( ) ; \nmyEnv = null ; \nlogger . info ( \"closed bdb caching\" ) ; \n} \ncatch ( DatabaseException dbe ) { \nlogger . error ( \"Error closing bdb: \" , dbe ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5650": "public class MetadataManager { \nprivate synchronized void openDatabase ( ) { \nif ( database != null ) return ; \nDatabaseConfig dbConfig = new DatabaseConfig ( ) ; \ndbConfig . setReadOnly ( readOnly ) ; \ndbConfig . setAllowCreate ( ! readOnly ) ; \nif ( ! readOnly ) dbConfig . setDeferredWrite ( true ) ; \ndatabase = myEnv . openDatabase ( null , collectionName , dbConfig ) ; \nopenDatabases . add ( this ) ; \nreturn ; \n} \n} \n"}
{"5652": "public class ErddapStringArray { \npublic void ensureCapacity ( long minCapacity ) { \nif ( array . length < minCapacity ) { \nErddapMath2 . ensureArraySizeOkay ( minCapacity , \"StringArray\" ) ; \nint newCapacity = ( int ) Math . min ( Integer . MAX_VALUE - 1 , array . length + ( long ) array . length ) ; \nif ( newCapacity < minCapacity ) newCapacity = ( int ) minCapacity ; \nString [ ] newArray = new String [ newCapacity ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , size ) ; \narray = newArray ; \n} \nreturn ; \n} \n} \n"}
{"5660": "public class EcmwfLocalConcepts { \nprivate void parseLocalConcept ( String filename , String conceptName ) throws IOException { \ntry ( InputStream is = new FileInputStream ( filename ) ) { \naddLocalConcept ( is , conceptName ) ; \n} \nreturn ; \n} \n} \n"}
{"5661": "public class EcmwfLocalConcepts { \nprivate void addLocalConcept ( InputStream is , String conceptName ) throws IOException { \ntry ( BufferedReader br = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ) { \nString line = br . readLine ( ) ; \nwhile ( ! line . startsWith ( \"#\" ) ) line = br . readLine ( ) ; \nwhile ( true ) { \nHashMap < String , String > items = new HashMap < > ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nif ( ( line . length ( ) == 0 ) || line . startsWith ( \"#\" ) ) continue ; \nline = cleanLine ( line ) ; \nif ( line . contains ( \"{\" ) ) { \nString paramName = line . split ( \"=\" ) [ 0 ] . trim ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nline = cleanLine ( line ) ; \nwhile ( line . contains ( \"=\" ) ) { \nString [ ] kvp = line . split ( \"=\" ) ; \nitems . put ( kvp [ 0 ] . trim ( ) , kvp [ 1 ] . trim ( ) ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nline = cleanLine ( line ) ; \n} \nString tableVersion = items . get ( TABLE_VERSION_ID ) ; \nString parameterNumber = items . get ( PARAM_NUM_ID ) ; \nstoreConcept ( tableVersion , parameterNumber , conceptName , paramName ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5663": "public class EcmwfLocalConcepts { \nprivate void storeConcept ( String tableVersion , String parameterNumber , String key , String value ) { \nHashMap < String , HashMap < String , String > > tmpTable ; \nif ( localConcepts . containsKey ( tableVersion ) ) { \ntmpTable = localConcepts . get ( tableVersion ) ; \nif ( tmpTable . containsKey ( parameterNumber ) ) { \nHashMap < String , String > tmpParam = tmpTable . get ( parameterNumber ) ; \nif ( ! tmpParam . containsKey ( key ) ) { \ntmpParam . put ( key , value ) ; \n} \nelse { \nSystem . out . println ( \"already has key value pair: \" + key + \":\" + value ) ; \n} \n} \nelse { \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \n} \nelse { \ntmpTable = new HashMap < > ( ) ; \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \nlocalConcepts . put ( tableVersion , tmpTable ) ; \nreturn ; \n} \n} \n"}
{"5664": "public class EcmwfLocalConcepts { \nprivate void writeGrib1Tables ( ) throws IOException { \nSimpleDateFormat dateFormat = new SimpleDateFormat ( \"yyyy-MM-dd'T'HH:mm:ssz\" ) ; \nCalendar cal = Calendar . getInstance ( ) ; \nString writeDate = dateFormat . format ( cal . getTime ( ) ) ; \nString grib1Info ; \nList < String > tableNums = new ArrayList < > ( ) ; \nHashMap < String , String > paramInfo ; \nPath dir = Paths . get ( ecmwfLocalConceptsLoc . replace ( \"sources/\" , \"resources/resources/grib1/\" ) ) ; \nfor ( String tableNum : localConcepts . keySet ( ) ) { \ntableNums . add ( tableNum ) ; \nString fileName = \"2.98.\" + tableNum + \".table\" ; \nSystem . out . println ( \"Writing: \" + fileName ) ; \nPath newFile = dir . resolve ( fileName ) ; \nFiles . deleteIfExists ( newFile ) ; \nFiles . createFile ( newFile ) ; \ntry ( BufferedWriter writer = Files . newBufferedWriter ( newFile , ENCODING ) ) { \nwriter . write ( \"# Generated by \" + this . getClass ( ) . getCanonicalName ( ) + \" on \" + writeDate ) ; \nwriter . newLine ( ) ; \nfor ( String paramNum : localConcepts . get ( tableNum ) . keySet ( ) ) { \nparamInfo = localConcepts . get ( tableNum ) . get ( paramNum ) ; \nString shortName = paramInfo . get ( SHORTNAME_ID ) ; \nString description = paramInfo . get ( DESCRIPTION_ID ) ; \nString units = paramInfo . get ( UNIT_ID ) ; \ngrib1Info = paramNum + \" \" + shortName + \" [\" + description + \"] (\" + units + \")\" ; \nwriter . write ( grib1Info ) ; \nwriter . newLine ( ) ; \n} \n} \n} \nwriteLookupTableFile ( tableNums , dir , writeDate ) ; \nreturn ; \n} \n} \n"}
{"5665": "public class EcmwfLocalConcepts { \nprivate void writeLookupTableFile ( List < String > tableNums , Path dir , String writeDate ) throws IOException { \nSystem . out . println ( \"Writing: lookupTables.txt\" ) ; \nCollections . sort ( tableNums ) ; \nPath lookupTableReg = dir . resolve ( \"lookupTables.txt\" ) ; \nFiles . deleteIfExists ( lookupTableReg ) ; \nFiles . createFile ( lookupTableReg ) ; \ntry ( BufferedWriter writer = Files . newBufferedWriter ( lookupTableReg , ENCODING ) ) { \nwriter . write ( \"# Generated by \" + this . getClass ( ) . getCanonicalName ( ) + \" on \" + writeDate ) ; \nwriter . newLine ( ) ; \nfor ( String tn : tableNums ) { \nString tableName = \"2.98.\" + tn + \".table\" ; \nString reg = \"98:\\t-1:\\t\" + tn + \":\\t\" + tableName ; \nwriter . write ( reg ) ; \nwriter . newLine ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5666": "public class EcmwfLocalConcepts { \nprivate void showLocalConcepts ( ) { \nfor ( String tableNum : localConcepts . keySet ( ) ) { \nfor ( String paramNum : localConcepts . get ( tableNum ) . keySet ( ) ) { \nfor ( String key : localConcepts . get ( tableNum ) . get ( paramNum ) . keySet ( ) ) { \nSystem . out . println ( key + \":\" + localConcepts . get ( tableNum ) . get ( paramNum ) . get ( key ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5667": "public class EcmwfLocalConcepts { \npublic static void main ( String [ ] args ) { \nEcmwfLocalConcepts ec = new EcmwfLocalConcepts ( ) ; \ntry { \nec . writeGrib1Tables ( ) ; \nSystem . out . println ( \"Finished!\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; \nif ( this . isFlatten ( ) ) { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < datasetContainer . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs . addDataset ( curDs ) ; \n} \nelse { \nnamedDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( int i = 0 ; \ni < namedDs . getDatasets ( ) . size ( ) ; \ni ++ ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \nreturn ; \n} \n} \n"}
{"5673": "public class DatasetSource { \nprivate void nameDatasetTree ( InvDatasetImpl dataset ) { \nif ( dataset . getName ( ) . equals ( \"\" ) || ! dataset . hasAccess ( ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \n} \n} \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < dataset . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; \nlogger . debug ( \"nameDatasetTree(): recurse to name child dataset ({})\" , curDs . getUrlPath ( ) ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"5674": "public class ScalablePicture { \npublic void loadPictureImd ( URL imageUrl , double rotation ) { \nTools . log ( \"loadPictureImd invoked with URL: \" + imageUrl . toString ( ) ) ; \nif ( sourcePicture != null ) sourcePicture . removeListener ( this ) ; \nsourcePicture = new SourcePicture ( ) ; \nsourcePicture . addListener ( this ) ; \nsetStatus ( LOADING , \"Loading: \" + imageUrl . toString ( ) ) ; \nscaleAfterLoad = true ; \nsourcePicture . loadPicture ( imageUrl , rotation ) ; \nreturn ; \n} \n} \n"}
{"5675": "public class ScalablePicture { \npublic void stopLoadingExcept ( URL url ) { \nif ( sourcePicture != null ) { \nboolean isCurrentlyLoading = sourcePicture . stopLoadingExcept ( url ) ; \nif ( ! isCurrentlyLoading ) { \n} \nPictureCache . stopBackgroundLoadingExcept ( url ) ; \n} \nreturn ; \n} \n} \n"}
{"5676": "public class ScalablePicture { \npublic void sourceStatusChange ( int statusCode , String statusMessage , SourcePicture sp ) { \nswitch ( statusCode ) { \ncase SourcePicture . UNINITIALISED : Tools . log ( \"ScalablePicture.sourceStatusChange: pictureStatus was: UNINITIALISED message: \" + statusMessage ) ; \nsetStatus ( UNINITIALISED , statusMessage ) ; \nbreak ; \ncase SourcePicture . ERROR : Tools . log ( \"ScalablePicture.sourceStatusChange: pictureStatus was: ERROR message: \" + statusMessage ) ; \nsetStatus ( ERROR , statusMessage ) ; \nsourcePicture . removeListener ( this ) ; \nbreak ; \ncase SourcePicture . LOADING : Tools . log ( \"ScalablePicture.sourceStatusChange: pictureStatus was: LOADING message: \" + statusMessage ) ; \nsetStatus ( LOADING , statusMessage ) ; \nbreak ; \ncase SourcePicture . ROTATING : Tools . log ( \"ScalablePicture.sourceStatusChange: pictureStatus was: ROTATING message: \" + statusMessage ) ; \nsetStatus ( LOADING , statusMessage ) ; \nbreak ; \ncase SourcePicture . READY : Tools . log ( \"ScalablePicture.sourceStatusChange: pictureStatus was: READY message: \" + statusMessage ) ; \nsetStatus ( LOADED , statusMessage ) ; \nsourcePicture . removeListener ( this ) ; \nif ( scaleAfterLoad ) { \ncreateScaledPictureInThread ( Thread . MAX_PRIORITY ) ; \nscaleAfterLoad = false ; \n} \nbreak ; \ndefault : Tools . log ( \"ScalablePicture.sourceStatusChange: Don't recognize this status: \" + statusMessage ) ; \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"5677": "public class ScalablePicture { \npublic void sourceLoadProgressNotification ( int statusCode , int percentage ) { \nEnumeration e = scalablePictureStatusListeners . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \n( ( ScalablePictureListener ) e . nextElement ( ) ) . sourceLoadProgressNotification ( statusCode , percentage ) ; \n} \nreturn ; \n} \n} \n"}
{"5678": "public class ScalablePicture { \npublic void createScaledPictureInThread ( int priority ) { \nsetStatus ( SCALING , \"Scaling picture.\" ) ; \nScaleThread t = new ScaleThread ( this ) ; \nt . setPriority ( priority ) ; \nt . start ( ) ; \nreturn ; \n} \n} \n"}
{"5685": "public class DiskCache { \nstatic public void setRootDirectory ( String cacheDir ) { \nif ( ! cacheDir . endsWith ( \"/\" ) ) cacheDir = cacheDir + \"/\" ; \nroot = StringUtil2 . replace ( cacheDir , '\\\\' , \"/\" ) ; \nmakeRootDirectory ( ) ; \nreturn ; \n} \n} \n"}
{"5686": "public class DiskCache { \nstatic public void makeRootDirectory ( ) { \nFile dir = new File ( root ) ; \nif ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) throw new IllegalStateException ( \"DiskCache.setRootDirectory(): could not create root directory <\" + root + \">.\" ) ; \ncheckExist = true ; \nreturn ; \n} \n} \n"}
{"5688": "public class DiskCache { \nstatic public void cleanCache ( Date cutoff , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"CleanCache files before \" ) . append ( cutoff ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nFile [ ] children = dir . listFiles ( ) ; \nif ( children == null ) return ; \nfor ( File file : children ) { \nDate lastMod = new Date ( file . lastModified ( ) ) ; \nif ( lastMod . before ( cutoff ) ) { \nboolean ret = file . delete ( ) ; \nif ( sbuff != null ) { \nsbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( lastMod ) . append ( \")\\n\" ) ; \nif ( ! ret ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( file . length ( ) + total > maxBytes ) { \ntotal_delete += file . length ( ) ; \nif ( sbuff != null ) sbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \nif ( ! file . delete ( ) && sbuff != null ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \nelse { \ntotal += file . length ( ) ; \n} \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \nreturn ; \n} \n} \n"}
{"5694": "public class CoordinateAxis { \npublic void getInfo ( Formatter buf ) { \nbuf . format ( \"%-30s\" , getNameAndDimensions ( ) ) ; \nbuf . format ( \"%-20s\" , getUnitsString ( ) ) ; \nif ( axisType != null ) { \nbuf . format ( \"%-10s\" , axisType . toString ( ) ) ; \n} \nbuf . format ( \"%s\" , getDescription ( ) ) ; \nreturn ; \n} \n} \n"}
{"5696": "public class JTableSorted { \npublic void setList ( ArrayList rowList ) { \nthis . list = rowList ; \nif ( list . size ( ) > 0 ) jtable . setRowSelectionInterval ( 0 , 0 ) ; \nelse jtable . clearSelection ( ) ; \nmodel . sort ( ) ; \njtable . revalidate ( ) ; \nreturn ; \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) return ; \nint curr = jtable . getSelectedRow ( ) ; \nif ( increment && ( curr < list . size ( ) - 1 ) ) setSelected ( curr + 1 ) ; \nelse if ( ! increment && ( curr > 0 ) ) setSelected ( curr - 1 ) ; \nreturn ; \n} \n} \n"}
{"5700": "public class VertScaleSlider { \nprivate void setSelectedIndex ( int idx ) { \nif ( zAxis == null ) return ; \neventOK = false ; \ncurrentIdx = idx ; \nslider . setValue ( world2slider ( zAxis . getCoordValue ( currentIdx ) ) ) ; \neventOK = true ; \nreturn ; \n} \n} \n"}
{"5701": "public class Util { \nstatic private void quickSort ( String a [ ] , int lo0 , int hi0 ) { \nint lo = lo0 ; \nint hi = hi0 ; \nString mid ; \nif ( hi0 > lo0 ) { \nmid = a [ ( lo0 + hi0 ) / 2 ] ; \nwhile ( lo <= hi ) { \nwhile ( ( lo < hi0 ) && ( a [ lo ] . compareTo ( mid ) < 0 ) ) ++ lo ; \nwhile ( ( hi > lo0 ) && ( a [ hi ] . compareTo ( mid ) > 0 ) ) -- hi ; \nif ( lo <= hi ) { \nswap ( a , lo , hi ) ; \n++ lo ; \n-- hi ; \n} \n} \nif ( lo0 < hi ) quickSort ( a , lo0 , hi ) ; \nif ( lo < hi0 ) quickSort ( a , lo , hi0 ) ; \n} \nreturn ; \n} \n} \n"}
{"5702": "public class Util { \nstatic private void swap ( String a [ ] , int i , int j ) { \nString T ; \nT = a [ i ] ; \na [ i ] = a [ j ] ; \na [ j ] = T ; \nreturn ; \n} \n} \n"}
{"5709": "public class XMLStore { \npublic void save ( ) throws java . io . IOException { \nif ( prefsFile == null ) throw new UnsupportedOperationException ( \"XMLStore is read-only\" ) ; \nFile prefTemp ; \nString parentFilename = prefsFile . getParent ( ) ; \nif ( parentFilename == null ) { \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" ) ; \n} \nelse { \nFile parentFile = new File ( parentFilename ) ; \nprefTemp = File . createTempFile ( \"pref\" , \".xml\" , parentFile ) ; \n} \nprefTemp . deleteOnExit ( ) ; \nFileOutputStream fos = new FileOutputStream ( prefTemp , false ) ; \nsave ( fos ) ; \nfos . close ( ) ; \nPath xmlBackup = Paths . get ( prefsFile . getAbsolutePath ( ) + \".bak\" ) ; \nPath prefsPath = prefsFile . toPath ( ) ; \nif ( Files . exists ( prefsPath ) ) Files . move ( prefsPath , xmlBackup , StandardCopyOption . REPLACE_EXISTING ) ; \nFiles . move ( prefTemp . toPath ( ) , prefsFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; \nreturn ; \n} \n} \n"}
{"5710": "public class XMLStore { \npublic void save ( OutputStream out ) throws java . io . IOException { \noutputExceptionMessage = null ; \nOutputMunger bos = new OutputMunger ( out ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bos , CDM . utf8Charset ) ) ; \nXMLEncoder beanEncoder = new XMLEncoder ( bos ) ; \nbeanEncoder . setExceptionListener ( new ExceptionListener ( ) { \npublic void exceptionThrown ( Exception exception ) { \nSystem . out . println ( \"XMLStore.save() got Exception: abort saving the preferences!\" ) ; \nexception . printStackTrace ( ) ; \noutputExceptionMessage = exception . getMessage ( ) ; \nreturn ; \n} \n} \n) ; \npw . printf ( \"<?xml version='1.0' encoding='UTF-8'?>%n\" ) ; \npw . printf ( \"<preferences EXTERNAL_XML_VERSION='1.0'>%n\" ) ; \nif ( ! rootPrefs . isUserNode ( ) ) pw . printf ( \"  <root type='system'>%n\" ) ; \nelse pw . printf ( \"  <root type='user'>%n\" ) ; \nIndent indent = new Indent ( 2 ) ; \nindent . incr ( ) ; \nwriteXmlNode ( bos , pw , rootPrefs , beanEncoder , indent ) ; \nif ( outputExceptionMessage != null ) throw new IOException ( outputExceptionMessage ) ; \npw . printf ( \"  </root>%n\" ) ; \npw . printf ( \"</preferences>%n\" ) ; \npw . flush ( ) ; \nreturn ; \n} \n} \n"}
{"5711": "public class DapSerializer { \nprotected void writeAtomicVariable ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapType basetype = template . getBaseType ( ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nif ( slices == null ) throw new DapException ( \"Unknown variable: \" + template . getFQN ( ) ) ; \nObject values = data . read ( slices ) ; \ndst . writeAtomicArray ( basetype , values ) ; \nreturn ; \n} \n} \n"}
{"5712": "public class DapSerializer { \nprotected void writeStructure ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nwhile ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteStructure1 ( instance [ 0 ] , dst ) ; \n} \nreturn ; \n} \n} \n"}
{"5713": "public class DapSerializer { \nprotected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { \nassert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; \nDapVariable template = ( DapVariable ) instance . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) instance . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \nreturn ; \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5715": "public class DapSerializer { \nprotected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) record . getTemplate ( ) ; \nDapSequence seq = ( DapSequence ) template . getBaseType ( ) ; \nList < DapVariable > fields = seq . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) record . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \nreturn ; \n} \n} \n"}
{"5723": "public class CFGridWriter { \nstatic public void makeFile ( String location , ucar . nc2 . dt . GridDataset gds , List < String > gridList , LatLonRect llbb , CalendarDateRange range ) throws IOException , InvalidRangeException { \nCFGridWriter writer = new CFGridWriter ( ) ; \nwriter . makeFile ( location , gds , gridList , llbb , range , false , 1 , 1 , 1 ) ; \nreturn ; \n} \n} \n"}
{"5725": "public class CFGridWriter { \npublic void makeFile ( String location , ucar . nc2 . dt . GridDataset gds , List < String > gridList , LatLonRect llbb , CalendarDateRange range , boolean addLatLon , int horizStride , int stride_z , int stride_time ) throws IOException , InvalidRangeException { \nmakeFile ( location , gds , gridList , llbb , horizStride , null , range , stride_time , addLatLon , NetcdfFileWriter . Version . netcdf3 ) ; \nreturn ; \n} \n} \n"}
{"5726": "public class StationRenderer { \npublic void setStations ( java . util . List < ucar . unidata . geoloc . Station > stns ) { \nstations = new ArrayList < StationUI > ( stns . size ( ) ) ; \nstationHash . clear ( ) ; \nfor ( int i = 0 ; \ni < stns . size ( ) ; \ni ++ ) { \nucar . unidata . geoloc . Station s = ( ucar . unidata . geoloc . Station ) stns . get ( i ) ; \nStationUI sui = new StationUI ( s ) ; \nstations . add ( sui ) ; \nstationHash . put ( s . getName ( ) , sui ) ; \n} \nposWasCalc = false ; \ncalcWorldPos ( ) ; \nreturn ; \n} \n} \n"}
{"5727": "public class StationRenderer { \npublic void setSelectedStation ( String name ) { \nStationUI sui = ( StationUI ) stationHash . get ( name ) ; \nif ( sui != null ) { \nsetSelectedStation ( sui ) ; \n} \nreturn ; \n} \n} \n"}
{"5736": "public class Ray { \npublic void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { \nlong offset = rayOffset ; \noffset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; \nraf . seek ( offset ) ; \nbyte [ ] b2 = new byte [ 2 ] ; \nint dataCount = getGateCount ( abbrev ) ; \nbyte [ ] data = new byte [ dataCount * 2 ] ; \nraf . readFully ( data ) ; \nfor ( int gateIdx : gateRange ) { \nif ( gateIdx >= dataCount ) ii . setShortNext ( uf_header2 . missing ) ; \nelse { \nb2 [ 0 ] = data [ gateIdx * 2 ] ; \nb2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; \nshort value = getShort ( b2 , 0 ) ; \nii . setShortNext ( value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5739": "public class MAVector { \npublic void normalize ( ) { \ndouble norm = norm ( ) ; \nif ( norm <= 0.0 ) return ; \nfor ( int k = 0 ; \nk < nelems ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsetDouble ( k , val / norm ) ; \n} \nreturn ; \n} \n} \n"}
{"5740": "public class CatalogBuilder { \nprivate void setServices ( Iterable < DatasetBuilder > dsIter ) { \nfor ( DatasetBuilder dsb : dsIter ) { \nfor ( Service s : dsb . getServices ( ) ) { \naddService ( s ) ; \n} \nsetServices ( dsb . getDatasets ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5743": "public class PrefixDBImpl { \npublic void addName ( final String name , final double value ) throws PrefixExistsException { \nfinal Prefix prefix = new PrefixName ( name , value ) ; \nnameSet . add ( prefix ) ; \nreturn ; \n} \n} \n"}
{"5744": "public class PrefixDBImpl { \npublic void addSymbol ( final String symbol , final double value ) throws PrefixExistsException { \nfinal Prefix prefix = new PrefixSymbol ( symbol , value ) ; \nsymbolSet . add ( prefix ) ; \nvalueMap . put ( new Double ( value ) , prefix ) ; \nreturn ; \n} \n} \n"}
{"5753": "public class CFPolygon { \npublic void setNext ( Polygon next ) { \nif ( next instanceof CFPolygon ) { \nsetNext ( ( CFPolygon ) next ) ; \n} \nelse this . next = next ; \nreturn ; \n} \n} \n"}
{"5754": "public class CFPolygon { \npublic void setPrev ( Polygon prev ) { \nif ( prev instanceof CFPolygon ) { \nsetPrev ( ( CFPolygon ) prev ) ; \n} \nelse this . prev = prev ; \nreturn ; \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nint row ; \nif ( 0 <= ( row = model . search ( proj ) ) ) { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection found = \" + row ) ; \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \nelse { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection not found = \" + row ) ; \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5758": "public class NetcdfFile { \nstatic public void registerIOProvider ( String className ) throws IllegalAccessException , InstantiationException , ClassNotFoundException { \nClass ioClass = NetcdfFile . class . getClassLoader ( ) . loadClass ( className ) ; \nregisterIOProvider ( ioClass ) ; \nreturn ; \n} \n} \n"}
{"5759": "public class NetcdfFile { \nstatic public void registerIOProvider ( Class iospClass , boolean last ) throws IllegalAccessException , InstantiationException { \nIOServiceProvider spi ; \nspi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nif ( userLoads && ! last ) registeredProviders . add ( 0 , spi ) ; \nelse registeredProviders . add ( spi ) ; \nreturn ; \n} \n} \n"}
{"5760": "public class NetcdfFile { \nstatic public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { \niospDeRegister ( iospClass ) ; \nint pos = - 1 ; \nfor ( int i = 0 ; \ni < registeredProviders . size ( ) ; \ni ++ ) { \nIOServiceProvider candidate = registeredProviders . get ( i ) ; \nif ( candidate . getClass ( ) == target ) { \nif ( pos < i ) pos = i ; \nbreak ; \n} \n} \nif ( pos < 0 ) pos = 0 ; \nIOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nregisteredProviders . add ( pos , spi ) ; \nreturn ; \n} \n} \n"}
{"5770": "public class NetcdfFile { \npublic void writeCDL ( OutputStream out , boolean strict ) { \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( out , CDM . utf8Charset ) ) ; \ntoStringStart ( pw , strict ) ; \ntoStringEnd ( pw ) ; \npw . flush ( ) ; \nreturn ; \n} \n} \n"}
{"5771": "public class NetcdfFile { \npublic void writeCDL ( PrintWriter pw , boolean strict ) { \ntoStringStart ( pw , strict ) ; \ntoStringEnd ( pw ) ; \npw . flush ( ) ; \nreturn ; \n} \n} \n"}
{"5772": "public class NetcdfFile { \nprotected void writeCDL ( Formatter f , Indent indent , boolean strict ) { \ntoStringStart ( f , indent , strict ) ; \nf . format ( \"%s}%n\" , indent ) ; \nreturn ; \n} \n} \n"}
{"5784": "public class NetcdfFile { \npublic void finish ( ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nvariables = new ArrayList < > ( ) ; \ndimensions = new ArrayList < > ( ) ; \ngattributes = new ArrayList < > ( ) ; \nfinishGroup ( rootGroup ) ; \nreturn ; \n} \n} \n"}
{"5794": "public class Attribute { \npublic void appendValue ( String value , boolean check ) throws NoSuchAttributeException , AttributeBadValueException { \ncheckVectorUsage ( ) ; \nif ( check ) value = forceValue ( type , value ) ; \n( ( Vector ) attr ) . addElement ( value ) ; \nreturn ; \n} \n} \n"}
{"5795": "public class Attribute { \nprivate static void dispatchCheckValue ( int type , String value ) throws AttributeBadValueException { \nswitch ( type ) { \ncase BYTE : if ( ! checkByte ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not a Byte value.\" ) ; \nbreak ; \ncase INT16 : if ( ! checkShort ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not an Int16 value.\" ) ; \nbreak ; \ncase UINT16 : if ( ! checkUShort ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not an UInt16 value.\" ) ; \nbreak ; \ncase INT32 : if ( ! checkInt ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not an Int32 value.\" ) ; \nbreak ; \ncase UINT32 : if ( ! checkUInt ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not an UInt32 value.\" ) ; \nbreak ; \ncase FLOAT32 : if ( ! checkFloat ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not a Float32 value.\" ) ; \nbreak ; \ncase FLOAT64 : if ( ! checkDouble ( value ) ) throw new AttributeBadValueException ( \"`\" + value + \"' is not a Float64 value.\" ) ; \nbreak ; \ndefault : } \nreturn ; \n} \n} \n"}
{"5812": "public class MessageBroker { \npublic void process ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = process ( b , is ) ; \nif ( b . done ) break ; \n} \nreturn ; \n} \n} \n"}
{"5815": "public class Ceparse { \nvoid markStackedVariables ( Stack s ) { \nStack bts = new Stack ( ) ; \nwhile ( ! s . empty ( ) ) { \nbts . push ( s . pop ( ) ) ; \n} \nwhile ( bts . size ( ) > 1 ) { \nServerMethods ct = ( ServerMethods ) bts . pop ( ) ; \nct . setProject ( true , false ) ; \n} \nServerMethods bt = ( ServerMethods ) bts . pop ( ) ; \nbt . setProject ( true , true ) ; \nreturn ; \n} \n} \n"}
{"5831": "public class Structure { \npublic void setMemberVariables ( List < Variable > vars ) { \nif ( isImmutable ( ) ) throw new IllegalStateException ( \"Cant modify\" ) ; \nmembers = new ArrayList < > ( ) ; \nmemberHash = new HashMap < > ( 2 * vars . size ( ) ) ; \nfor ( Variable v : vars ) { \naddMemberVariable ( v ) ; \n} \nreturn ; \n} \n} \n"}
{"5832": "public class Structure { \n@ Override public void setParentGroup ( Group group ) { \nif ( isImmutable ( ) ) throw new IllegalStateException ( \"Cant modify\" ) ; \nsuper . setParentGroup ( group ) ; \nif ( members != null ) { \nfor ( Variable v : members ) { \nv . setParentGroup ( group ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5833": "public class Structure { \npublic void calcElementSize ( ) { \nint total = 0 ; \nfor ( Variable v : members ) { \ntotal += v . getElementSize ( ) * v . getSize ( ) ; \n} \nelementSize = total ; \nreturn ; \n} \n} \n"}
{"5839": "public class ProjectionImpl { \nprotected void addParameter ( String name , String value ) { \natts . add ( new Parameter ( name , value ) ) ; \nreturn ; \n} \n} \n"}
{"5845": "public class CoverageRenderer { \nprivate void setColorScaleParams ( ) { \nif ( dataMinMaxType == ColorScale . MinMaxType . hold && ! isNewField ) return ; \nisNewField = false ; \nGeoReferencedArray dataArr = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; \nif ( dataArr != null ) { \nMAMath . MinMax minmax = MAMath . getMinMaxSkipMissingData ( dataArr . getData ( ) , dataState . grid ) ; \ncolorScale . setMinMax ( minmax . min , minmax . max ) ; \ncolorScale . setGeoGrid ( dataState . grid ) ; \n} \nreturn ; \n} \n} \n"}
{"5846": "public class CoverageRenderer { \npublic void renderPlanView ( java . awt . Graphics2D g , AffineTransform dFromN ) { \nif ( ( dataState . grid == null ) || ( colorScale == null ) || ( drawProjection == null ) ) return ; \nif ( ! drawGrid && ! drawContours ) return ; \ng . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; \ndataH = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; \nif ( dataH == null ) return ; \nsetColorScaleParams ( ) ; \nif ( drawGrid ) drawGridHoriz ( g , dataH ) ; \nif ( drawGridLines ) drawGridLines ( g , dataH ) ; \nif ( drawBB ) drawGridBB ( g , this . dataState . coverageDataset . getLatlonBoundingBox ( ) ) ; \nreturn ; \n} \n} \n"}
{"5849": "public class TableAligner { \npublic static void installInAllColumns ( JTable table , int alignment ) { \nfor ( int colViewIndex = 0 ; \ncolViewIndex < table . getColumnCount ( ) ; \n++ colViewIndex ) { \ninstallInOneColumn ( table , colViewIndex , alignment ) ; \n} \nreturn ; \n} \n} \n"}
{"5857": "public class FluentLoggerFactory { \nprotected synchronized void purgeLogger ( FluentLogger logger ) { \nIterator < Entry < FluentLogger , String > > it = loggers . entrySet ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nif ( it . next ( ) . getKey ( ) == logger ) { \nit . remove ( ) ; \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"5861": "public class GifHeaderParser { \nprivate void readGraphicControlExt ( ) { \nread ( ) ; \nint packed = read ( ) ; \nheader . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; \nif ( header . currentFrame . dispose == 0 ) { \nheader . currentFrame . dispose = 1 ; \n} \nheader . currentFrame . transparency = ( packed & 1 ) != 0 ; \nint delayInHundredthsOfASecond = readShort ( ) ; \nif ( delayInHundredthsOfASecond < MIN_FRAME_DELAY ) { \ndelayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; \n} \nheader . currentFrame . delay = delayInHundredthsOfASecond * 10 ; \nheader . currentFrame . transIndex = read ( ) ; \nread ( ) ; \nreturn ; \n} \n} \n"}
{"5864": "public class ListTransformation { \nprivate void initListEvents ( ) { \nthis . listChangeListener = new ListChangeListener < SourceType > ( ) { \n@ Override public void onChanged ( Change < ? extends SourceType > listEvent ) { \nList < TargetType > deleteStaging = new ArrayList < > ( ) ; \nwhile ( listEvent . next ( ) ) { \nif ( listEvent . wasUpdated ( ) ) { \nprocessUpdateEvent ( listEvent ) ; \n} \nelse if ( listEvent . wasReplaced ( ) ) { \nprocessReplaceEvent ( listEvent , deleteStaging ) ; \n} \nelse if ( listEvent . wasAdded ( ) ) { \nprocessAddEvent ( listEvent ) ; \n} \nelse if ( listEvent . wasRemoved ( ) ) { \nprocessRemoveEvent ( listEvent , deleteStaging ) ; \n} \n} \nprocessStagingLists ( deleteStaging ) ; \nreturn ; \n} \n} \n; \nmodelListProperty ( ) . addListener ( new WeakListChangeListener < > ( listChangeListener ) ) ; \nreturn ; \n} \n} \n"}
{"5866": "public class CompositeValidationStatus { \nvoid addMessage ( Validator validator , List < ? extends ValidationMessage > messages ) { \nif ( messages . isEmpty ( ) ) { \nreturn ; \n} \nfinal int validatorHash = System . identityHashCode ( validator ) ; \nif ( ! validatorToMessagesMap . containsKey ( validatorHash ) ) { \nvalidatorToMessagesMap . put ( validatorHash , new ArrayList < > ( ) ) ; \n} \nfinal List < Integer > messageHashesOfThisValidator = validatorToMessagesMap . get ( validatorHash ) ; \nmessages . stream ( ) . map ( System :: identityHashCode ) . forEach ( messageHashesOfThisValidator :: add ) ; \ngetMessagesInternal ( ) . addAll ( messages ) ; \nreturn ; \n} \n} \n"}
{"5867": "public class PersonWelcomeViewModel { \npublic void setPersonId ( int personId ) { \nperson = repository . getPersonById ( personId ) ; \nStringBinding salutationBinding = Bindings . when ( person . genderProperty ( ) . isEqualTo ( Gender . NOT_SPECIFIED ) ) . then ( \"Herr/Frau/* \" ) . otherwise ( Bindings . when ( person . genderProperty ( ) . isEqualTo ( Gender . MALE ) ) . then ( \"Herr \" ) . otherwise ( \"Frau \" ) ) ; \nwelcomeString . unbind ( ) ; \nwelcomeString . bind ( Bindings . concat ( \"Willkommen \" , salutationBinding , person . firstNameProperty ( ) , \" \" , person . lastNameProperty ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"5868": "public class ViewLoaderReflectionUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < V extends View < ? extends VM > , VM extends ViewModel > void createAndInjectViewModel ( final V view , Consumer < ViewModel > newVmConsumer ) { \nfinal Class < ? > viewModelType = TypeResolver . resolveRawArgument ( View . class , view . getClass ( ) ) ; \nif ( viewModelType == ViewModel . class ) { \nfinal List < Field > viewModelFields = ViewLoaderReflectionUtils . getViewModelFields ( view . getClass ( ) ) ; \nif ( ! viewModelFields . isEmpty ( ) ) { \nthrow new RuntimeException ( \"The given view of type <\" + view . getClass ( ) + \"> has no generic viewModel type declared but tries to inject a viewModel.\" ) ; \n} \nreturn ; \n} \nif ( viewModelType == TypeResolver . Unknown . class ) { \nreturn ; \n} \nfinal Optional < Field > fieldOptional = getViewModelField ( view . getClass ( ) , viewModelType ) ; \nif ( fieldOptional . isPresent ( ) ) { \nField field = fieldOptional . get ( ) ; \nReflectionUtils . accessMember ( field , ( ) -> { \nObject existingViewModel = field . get ( view ) ; \nif ( existingViewModel == null ) { \nfinal Object newViewModel = DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; \nfield . set ( view , newViewModel ) ; \nnewVmConsumer . accept ( ( ViewModel ) newViewModel ) ; \n} \n} \n, \"Can't inject ViewModel of type <\" + viewModelType + \"> into the view <\" + view + \">\" ) ; \n} \nreturn ; \n} \n} \n"}
{"5870": "public class DataFxCountrySelector { \nvoid loadCountries ( ) { \nInputStream iso3166Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_LOCATION ) ; \nif ( iso3166Resource == null ) { \nthrow new IllegalStateException ( \"Can't find the list of countries! Expected location was:\" + ISO_3166_LOCATION ) ; \n} \nXmlConverter < Country > countryConverter = new XmlConverter < > ( \"iso_3166_entry\" , Country . class ) ; \ntry { \nDataReader < Country > dataSource = new InputStreamSource < > ( iso3166Resource , countryConverter ) ; \nListDataProvider < Country > listDataProvider = new ListDataProvider < > ( dataSource ) ; \nlistDataProvider . setResultObservableList ( countries ) ; \nWorker < ObservableList < Country > > worker = listDataProvider . retrieve ( ) ; \nworker . stateProperty ( ) . addListener ( obs -> { \nif ( worker . getState ( ) == Worker . State . SUCCEEDED ) { \nloadSubdivisions ( ) ; \n} \n} \n) ; \n} \ncatch ( IOException e ) { \nLOG . error ( \"A problem was detected while loading the XML file with the available countries.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"5871": "public class DataFxCountrySelector { \nvoid loadSubdivisions ( ) { \nInputStream iso3166_2Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_2_LOCATION ) ; \nif ( iso3166_2Resource == null ) { \nthrow new IllegalStateException ( \"Can't find the list of subdivisions! Expected location was:\" + ISO_3166_2_LOCATION ) ; \n} \nXmlConverter < ISO3166_2_CountryEntity > converter = new XmlConverter < > ( \"iso_3166_country\" , ISO3166_2_CountryEntity . class ) ; \nObservableList < ISO3166_2_CountryEntity > subdivisionsEntities = FXCollections . observableArrayList ( ) ; \ntry { \nDataReader < ISO3166_2_CountryEntity > dataSource = new InputStreamSource < > ( iso3166_2Resource , converter ) ; \nListDataProvider < ISO3166_2_CountryEntity > listDataProvider = new ListDataProvider < > ( dataSource ) ; \nlistDataProvider . setResultObservableList ( subdivisionsEntities ) ; \nWorker < ObservableList < ISO3166_2_CountryEntity > > worker = listDataProvider . retrieve ( ) ; \nworker . stateProperty ( ) . addListener ( obs -> { \nif ( worker . getState ( ) == Worker . State . SUCCEEDED ) { \nsubdivisionsEntities . forEach ( entity -> { \nif ( entity . subsets != null && ! entity . subsets . isEmpty ( ) ) { \nCountry country = findCountryByCode ( entity . code ) ; \nif ( ! countryCodeSubdivisionMap . containsKey ( country ) ) { \ncountryCodeSubdivisionMap . put ( country , new ArrayList < > ( ) ) ; \n} \nList < Subdivision > subdivisionList = countryCodeSubdivisionMap . get ( country ) ; \nentity . subsets . forEach ( subset -> { \nsubset . entryList . forEach ( entry -> { \nsubdivisionList . add ( new Subdivision ( entry . name , entry . code , country ) ) ; \n} \n) ; \n} \n) ; \nString subdivisionName = entity . subsets . stream ( ) . map ( subset -> subset . subdivisionType ) . collect ( Collectors . joining ( \"/\" ) ) ; \ncountryCodeSubdivisionNameMap . put ( country , subdivisionName ) ; \n} \n} \n) ; \ninProgress . set ( false ) ; \n} \n} \n) ; \n} \ncatch ( IOException e ) { \nLOG . error ( \"A problem was detected while loading the XML file with the available subdivisions.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"5876": "public class ListenerManager { \nprivate < T , U > void clearMap ( Map < T , Set < U > > map , BiConsumer < T , U > consumer ) { \nfor ( T observable : map . keySet ( ) ) { \nfor ( U listener : map . get ( observable ) ) { \nconsumer . accept ( observable , listener ) ; \n} \n} \nmap . clear ( ) ; \nreturn ; \n} \n} \n"}
{"5877": "public class SelectableItemList { \nprivate void createIndexEvents ( ) { \nselectionModel . selectedIndexProperty ( ) . addListener ( ( bean , oldVal , newVal ) -> { \nint index = newVal . intValue ( ) ; \nListType item = index == - 1 ? null : modelListProperty ( ) . get ( index ) ; \nselectedItem . set ( item ) ; \n} \n) ; \nselectedItem . addListener ( ( observable , oldVal , newVal ) -> { \nif ( newVal == null ) { \nselectionModel . select ( - 1 ) ; \nselectedItem . set ( null ) ; \n} \nelse { \nint index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; \nif ( index != - 1 ) { \nselectionModel . select ( index ) ; \n} \nelse { \nselectedItem . set ( oldVal ) ; \n} \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"5884": "public class CoverageDataPng { \npublic static void validateImageType ( PngReader reader ) { \nif ( reader == null ) { \nthrow new GeoPackageException ( \"The image is null\" ) ; \n} \nif ( reader . imgInfo . channels != 1 || reader . imgInfo . bitDepth != 16 ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single channel 16 bit unsigned short, channels: \" + reader . imgInfo . channels + \", bits: \" + reader . imgInfo . bitDepth ) ; \n} \nreturn ; \n} \n} \n"}
{"5886": "public class TileRow { \npublic void setTileData ( Bitmap bitmap , CompressFormat format , int quality ) throws IOException { \nbyte [ ] tileData = BitmapConverter . toBytes ( bitmap , format , quality ) ; \nsetTileData ( tileData ) ; \nreturn ; \n} \n} \n"}
{"5893": "public class GeoPackageCursorFactory { \npublic void registerTable ( String tableName , GeoPackageCursorWrapper cursorWrapper ) { \ntableCursors . remove ( tableName ) ; \ntableCursors . put ( tableName , cursorWrapper ) ; \nString quotedTableName = CoreSQLUtils . quoteWrap ( tableName ) ; \ntableCursors . put ( quotedTableName , cursorWrapper ) ; \nint spacePosition = tableName . indexOf ( ' ' ) ; \nif ( spacePosition > 0 ) { \ntableCursors . put ( tableName . substring ( 0 , spacePosition ) , cursorWrapper ) ; \ntableCursors . put ( quotedTableName . substring ( 0 , quotedTableName . indexOf ( ' ' ) ) , cursorWrapper ) ; \n} \nreturn ; \n} \n} \n"}
{"5904": "public class Icons { \npublic void setIcon ( IconRow iconRow , GeometryType geometryType ) { \nif ( geometryType != null ) { \nif ( iconRow != null ) { \nicons . put ( geometryType , iconRow ) ; \n} \nelse { \nicons . remove ( geometryType ) ; \n} \n} \nelse { \ndefaultIcon = iconRow ; \n} \nreturn ; \n} \n} \n"}
{"5909": "public class TableMetadataDataSource { \npublic void create ( TableMetadata metadata ) { \nContentValues values = new ContentValues ( ) ; \nvalues . put ( TableMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; \nvalues . put ( TableMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; \nvalues . put ( TableMetadata . COLUMN_LAST_INDEXED , metadata . getLastIndexed ( ) ) ; \nlong insertId = db . insert ( TableMetadata . TABLE_NAME , null , values ) ; \nif ( insertId == - 1 ) { \nthrow new GeoPackageException ( \"Failed to insert table metadata. GeoPackage Id: \" + metadata . getGeoPackageId ( ) + \", Table Name: \" + metadata . getTableName ( ) + \", Last Indexed: \" + metadata . getLastIndexed ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5927": "public class MediaRow { \npublic void setData ( Bitmap bitmap , Bitmap . CompressFormat format ) throws IOException { \nsetData ( bitmap , format , 100 ) ; \nreturn ; \n} \n} \n"}
{"5928": "public class MediaRow { \npublic void setData ( Bitmap bitmap , Bitmap . CompressFormat format , int quality ) throws IOException { \nsetData ( BitmapConverter . toBytes ( bitmap , format , quality ) ) ; \nreturn ; \n} \n} \n"}
{"5929": "public class TileGenerator { \npublic void setBitmapCompressionConfig ( Config config ) { \nif ( options == null ) { \noptions = new Options ( ) ; \n} \noptions . inPreferredConfig = config ; \nreturn ; \n} \n} \n"}
{"5931": "public class TileGenerator { \nprivate void adjustBounds ( BoundingBox boundingBox , int zoom ) { \nif ( googleTiles ) { \nadjustGoogleBounds ( ) ; \n} \nelse if ( projection . isUnit ( Units . DEGREES ) ) { \nadjustGeoPackageBoundsWGS84 ( boundingBox , zoom ) ; \n} \nelse { \nadjustGeoPackageBounds ( boundingBox , zoom ) ; \n} \nreturn ; \n} \n} \n"}
{"5932": "public class TileGenerator { \nprivate void adjustGoogleBounds ( ) { \nBoundingBox standardWgs84Box = new BoundingBox ( - ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH , ProjectionConstants . WEB_MERCATOR_MIN_LAT_RANGE , ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH , ProjectionConstants . WEB_MERCATOR_MAX_LAT_RANGE ) ; \nProjectionTransform wgs84ToWebMercatorTransform = ProjectionFactory . getProjection ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \ntileGridBoundingBox = standardWgs84Box . transform ( wgs84ToWebMercatorTransform ) ; \nreturn ; \n} \n} \n"}
{"5933": "public class TileGenerator { \nprivate void adjustGeoPackageBoundsWGS84 ( BoundingBox boundingBox , int zoom ) { \nTileGrid tileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( boundingBox , zoom ) ; \ntileGridBoundingBox = TileBoundingBoxUtils . getWGS84BoundingBox ( tileGrid , zoom ) ; \nmatrixWidth = tileGrid . getMaxX ( ) + 1 - tileGrid . getMinX ( ) ; \nmatrixHeight = tileGrid . getMaxY ( ) + 1 - tileGrid . getMinY ( ) ; \nreturn ; \n} \n} \n"}
{"5934": "public class TileGenerator { \nprivate void adjustGeoPackageBounds ( BoundingBox requestWebMercatorBoundingBox , int zoom ) { \nTileGrid tileGrid = TileBoundingBoxUtils . getTileGrid ( requestWebMercatorBoundingBox , zoom ) ; \ntileGridBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( tileGrid , zoom ) ; \nmatrixWidth = tileGrid . getMaxX ( ) + 1 - tileGrid . getMinX ( ) ; \nmatrixHeight = tileGrid . getMaxY ( ) + 1 - tileGrid . getMinY ( ) ; \nreturn ; \n} \n} \n"}
{"5947": "public class CoverageDataTiff { \npublic static void validateImageType ( FileDirectory directory ) { \nif ( directory == null ) { \nthrow new GeoPackageException ( \"The image is null\" ) ; \n} \nint samplesPerPixel = directory . getSamplesPerPixel ( ) ; \nInteger bitsPerSample = null ; \nif ( directory . getBitsPerSample ( ) != null && ! directory . getBitsPerSample ( ) . isEmpty ( ) ) { \nbitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; \n} \nInteger sampleFormat = null ; \nif ( directory . getSampleFormat ( ) != null && ! directory . getSampleFormat ( ) . isEmpty ( ) ) { \nsampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; \n} \nif ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null || sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: \" + samplesPerPixel + \", Bits Per Sample: \" + bitsPerSample + \", Sample Format: \" + sampleFormat ) ; \n} \nreturn ; \n} \n} \n"}
{"5949": "public class CoverageDataTiff { \npublic void setPixelValue ( CoverageDataTiffImage image , int x , int y , float pixelValue ) { \nimage . getRasters ( ) . setFirstPixelSample ( x , y , pixelValue ) ; \nreturn ; \n} \n} \n"}
{"5958": "public class GeoPackageManagerImpl { \nprivate void createAndCloseGeoPackage ( GeoPackageDatabase db ) { \nGeoPackageConnection connection = new GeoPackageConnection ( db ) ; \nconnection . setApplicationId ( ) ; \nconnection . setUserVersion ( ) ; \nGeoPackageTableCreator tableCreator = new GeoPackageTableCreator ( connection ) ; \ntableCreator . createRequired ( ) ; \nconnection . close ( ) ; \nreturn ; \n} \n} \n"}
{"5960": "public class GeoPackageManagerImpl { \nprivate void validateDatabaseAndCloseOnError ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity ) { \nvalidateDatabase ( sqliteDatabase , validateHeader , validateIntegrity , false , true ) ; \nreturn ; \n} \n} \n"}
{"5961": "public class GeoPackageManagerImpl { \nprivate void validateDatabaseAndClose ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity ) { \nvalidateDatabase ( sqliteDatabase , validateHeader , validateIntegrity , true , true ) ; \nreturn ; \n} \n} \n"}
{"5962": "public class GeoPackageManagerImpl { \nprivate void validateDatabase ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity , boolean close , boolean closeOnError ) { \ntry { \nif ( validateHeader ) { \nvalidateDatabaseHeader ( sqliteDatabase ) ; \n} \nif ( validateIntegrity ) { \nvalidateDatabaseIntegrity ( sqliteDatabase ) ; \n} \n} \ncatch ( Exception e ) { \nif ( closeOnError ) { \nsqliteDatabase . close ( ) ; \n} \nthrow e ; \n} \nif ( close ) { \nsqliteDatabase . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"5963": "public class GeoPackageManagerImpl { \nprivate void validateDatabaseHeader ( SQLiteDatabase sqliteDatabase ) { \nboolean validHeader = isDatabaseHeaderValid ( sqliteDatabase ) ; \nif ( ! validHeader ) { \nthrow new GeoPackageException ( \"GeoPackage SQLite header is not valid: \" + sqliteDatabase . getPath ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"5965": "public class GeoPackageManagerImpl { \nprivate void addInternalDatabases ( Collection < String > databases ) { \nString [ ] databaseArray = context . databaseList ( ) ; \nfor ( String database : databaseArray ) { \nif ( ! isTemporary ( database ) && ! database . equalsIgnoreCase ( GeoPackageMetadataDb . DATABASE_NAME ) ) { \ndatabases . add ( database ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5966": "public class GeoPackageManagerImpl { \nprivate void addExternalDatabases ( Collection < String > databases ) { \nList < GeoPackageMetadata > externalGeoPackages = getExternalGeoPackages ( ) ; \nfor ( GeoPackageMetadata external : externalGeoPackages ) { \nif ( new File ( external . getExternalPath ( ) ) . exists ( ) ) { \ndatabases . add ( external . getName ( ) ) ; \n} \nelse { \ndelete ( external . getName ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5967": "public class GeoPackageManagerImpl { \nprivate boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { \ntry { \nif ( exists ( database ) ) { \nif ( override ) { \nif ( ! delete ( database ) ) { \nthrow new GeoPackageException ( \"Failed to delete existing database: \" + database ) ; \n} \n} \nelse { \nthrow new GeoPackageException ( \"GeoPackage database already exists: \" + database ) ; \n} \n} \nFile newDbFile = context . getDatabasePath ( database ) ; \ntry { \nSQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; \ndb . close ( ) ; \nGeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; \n} \ncatch ( IOException e ) { \nthrow new GeoPackageException ( \"Failed to import GeoPackage database: \" + database , e ) ; \n} \n} \nfinally { \nGeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; \n} \nif ( progress == null || progress . isActive ( ) ) { \ntry { \nSQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { \n@ Override public void onCorruption ( SQLiteDatabase dbObj ) { \nreturn ; \n} \n} \n) ; \nvalidateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; \nGeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; \nmetadataDb . open ( ) ; \ntry { \nGeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; \nGeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; \nmetadata . setName ( database ) ; \ndataSource . create ( metadata ) ; \n} \nfinally { \nmetadataDb . close ( ) ; \n} \n} \ncatch ( Exception e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file\" , e ) ; \n} \nGeoPackage geoPackage = open ( database , false ) ; \nif ( geoPackage != null ) { \ntry { \nif ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \n} \ncatch ( SQLException e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Could not verify existence of required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \nfinally { \ngeoPackage . close ( ) ; \n} \n} \nelse { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Unable to open GeoPackage database. Database: \" + database ) ; \n} \n} \nreturn exists ( database ) ; \n} \n} \n"}
{"5987": "public class UserCustomDao { \npublic void registerCursorWrapper ( GeoPackage geoPackage ) { \ngeoPackage . registerCursorWrapper ( getTableName ( ) , new GeoPackageCursorWrapper ( ) { \n@ Override public Cursor wrapCursor ( Cursor cursor ) { \nreturn new UserCustomCursor ( getTable ( ) , cursor ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"5993": "public class FeatureTiles { \npublic void calculateDrawOverlap ( ) { \nif ( pointIcon != null ) { \nheightOverlap = this . density * pointIcon . getHeight ( ) ; \nwidthOverlap = this . density * pointIcon . getWidth ( ) ; \n} \nelse { \nheightOverlap = this . density * pointRadius ; \nwidthOverlap = this . density * pointRadius ; \n} \nfloat linePaintHalfStroke = this . density * lineStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , linePaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , linePaintHalfStroke ) ; \nfloat polygonPaintHalfStroke = this . density * polygonStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , polygonPaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , polygonPaintHalfStroke ) ; \nif ( featureTableStyles != null && featureTableStyles . has ( ) ) { \nSet < Long > styleRowIds = new HashSet < > ( ) ; \nList < Long > tableStyleIds = featureTableStyles . getAllTableStyleIds ( ) ; \nif ( tableStyleIds != null ) { \nstyleRowIds . addAll ( tableStyleIds ) ; \n} \nList < Long > styleIds = featureTableStyles . getAllStyleIds ( ) ; \nif ( styleIds != null ) { \nstyleRowIds . addAll ( styleIds ) ; \n} \nStyleDao styleDao = featureTableStyles . getStyleDao ( ) ; \nfor ( long styleRowId : styleRowIds ) { \nStyleRow styleRow = styleDao . getRow ( styleDao . queryForIdRow ( styleRowId ) ) ; \nfloat styleHalfWidth = this . density * ( float ) ( styleRow . getWidthOrDefault ( ) / 2.0f ) ; \nwidthOverlap = Math . max ( widthOverlap , styleHalfWidth ) ; \nheightOverlap = Math . max ( heightOverlap , styleHalfWidth ) ; \n} \nSet < Long > iconRowIds = new HashSet < > ( ) ; \nList < Long > tableIconIds = featureTableStyles . getAllTableIconIds ( ) ; \nif ( tableIconIds != null ) { \niconRowIds . addAll ( tableIconIds ) ; \n} \nList < Long > iconIds = featureTableStyles . getAllIconIds ( ) ; \nif ( iconIds != null ) { \niconRowIds . addAll ( iconIds ) ; \n} \nIconDao iconDao = featureTableStyles . getIconDao ( ) ; \nfor ( long iconRowId : iconRowIds ) { \nIconRow iconRow = iconDao . getRow ( iconDao . queryForIdRow ( iconRowId ) ) ; \ndouble [ ] iconDimensions = iconRow . getDerivedDimensions ( ) ; \nfloat iconWidth = this . density * ( float ) Math . ceil ( iconDimensions [ 0 ] ) ; \nfloat iconHeight = this . density * ( float ) Math . ceil ( iconDimensions [ 1 ] ) ; \nwidthOverlap = Math . max ( widthOverlap , iconWidth ) ; \nheightOverlap = Math . max ( heightOverlap , iconHeight ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5994": "public class FeatureTiles { \npublic void setDensity ( float density ) { \nthis . density = density ; \nlinePaint . setStrokeWidth ( this . density * lineStrokeWidth ) ; \npolygonPaint . setStrokeWidth ( this . density * polygonStrokeWidth ) ; \nfeaturePaintCache . clear ( ) ; \nreturn ; \n} \n} \n"}
{"5995": "public class FeatureTiles { \npublic void setLinePaint ( Paint linePaint ) { \nif ( linePaint == null ) { \nthrow new AssertionError ( \"Line Paint can not be null\" ) ; \n} \nthis . linePaint = linePaint ; \nsetLineStrokeWidth ( linePaint . getStrokeWidth ( ) ) ; \nreturn ; \n} \n} \n"}
{"5996": "public class FeatureTiles { \npublic void setPolygonPaint ( Paint polygonPaint ) { \nif ( polygonPaint == null ) { \nthrow new AssertionError ( \"Polygon Paint can not be null\" ) ; \n} \nthis . polygonPaint = polygonPaint ; \nsetPolygonStrokeWidth ( polygonPaint . getStrokeWidth ( ) ) ; \nreturn ; \n} \n} \n"}
{"6018": "public class FeatureTileCanvas { \npublic void recycle ( ) { \nfor ( int layer = 0 ; \nlayer < 4 ; \nlayer ++ ) { \nBitmap bitmap = layeredBitmap [ layer ] ; \nif ( bitmap != null ) { \nbitmap . recycle ( ) ; \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \nreturn ; \n} \n} \n"}
{"6021": "public class FeatureTileCanvas { \nprivate void createBitmapAndCanvas ( int layer ) { \nlayeredBitmap [ layer ] = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; \nlayeredCanvas [ layer ] = new Canvas ( layeredBitmap [ layer ] ) ; \nreturn ; \n} \n} \n"}
{"6036": "public class FeatureStyleExtension { \npublic void setTableFeatureStyles ( String featureTable , FeatureStyles featureStyles ) { \nif ( featureStyles != null ) { \nsetTableStyles ( featureTable , featureStyles . getStyles ( ) ) ; \nsetTableIcons ( featureTable , featureStyles . getIcons ( ) ) ; \n} \nelse { \ndeleteTableFeatureStyles ( featureTable ) ; \n} \nreturn ; \n} \n} \n"}
{"6037": "public class FeatureStyleExtension { \npublic void setTableStyles ( String featureTable , Styles styles ) { \ndeleteTableStyles ( featureTable ) ; \nif ( styles != null ) { \nif ( styles . getDefault ( ) != null ) { \nsetTableStyleDefault ( featureTable , styles . getDefault ( ) ) ; \n} \nfor ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { \nsetTableStyle ( featureTable , style . getKey ( ) , style . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6038": "public class FeatureStyleExtension { \npublic void setTableIcons ( String featureTable , Icons icons ) { \ndeleteTableIcons ( featureTable ) ; \nif ( icons != null ) { \nif ( icons . getDefault ( ) != null ) { \nsetTableIconDefault ( featureTable , icons . getDefault ( ) ) ; \n} \nfor ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { \nsetTableIcon ( featureTable , icon . getKey ( ) , icon . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6039": "public class FeatureStyleExtension { \npublic void setFeatureStyles ( FeatureRow featureRow , FeatureStyles featureStyles ) { \nsetFeatureStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , featureStyles ) ; \nreturn ; \n} \n} \n"}
{"6040": "public class FeatureStyleExtension { \npublic void setFeatureStyles ( String featureTable , long featureId , FeatureStyles featureStyles ) { \nif ( featureStyles != null ) { \nsetStyles ( featureTable , featureId , featureStyles . getStyles ( ) ) ; \nsetIcons ( featureTable , featureId , featureStyles . getIcons ( ) ) ; \n} \nelse { \ndeleteStyles ( featureTable , featureId ) ; \ndeleteIcons ( featureTable , featureId ) ; \n} \nreturn ; \n} \n} \n"}
{"6041": "public class FeatureStyleExtension { \npublic void setStyles ( FeatureRow featureRow , Styles styles ) { \nsetStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , styles ) ; \nreturn ; \n} \n} \n"}
{"6042": "public class FeatureStyleExtension { \npublic void setStyles ( String featureTable , long featureId , Styles styles ) { \ndeleteStyles ( featureTable , featureId ) ; \nif ( styles != null ) { \nif ( styles . getDefault ( ) != null ) { \nsetStyleDefault ( featureTable , featureId , styles . getDefault ( ) ) ; \n} \nfor ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { \nsetStyle ( featureTable , featureId , style . getKey ( ) , style . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6043": "public class FeatureStyleExtension { \npublic void setStyle ( FeatureRow featureRow , StyleRow style ) { \nsetStyle ( featureRow , featureRow . getGeometryType ( ) , style ) ; \nreturn ; \n} \n} \n"}
{"6044": "public class FeatureStyleExtension { \npublic void setStyleDefault ( FeatureRow featureRow , StyleRow style ) { \nsetStyle ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , null , style ) ; \nreturn ; \n} \n} \n"}
{"6045": "public class FeatureStyleExtension { \npublic void setStyleDefault ( String featureTable , long featureId , StyleRow style ) { \nsetStyle ( featureTable , featureId , null , style ) ; \nreturn ; \n} \n} \n"}
{"6046": "public class FeatureStyleExtension { \npublic void setIcons ( FeatureRow featureRow , Icons icons ) { \nsetIcons ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , icons ) ; \nreturn ; \n} \n} \n"}
{"6047": "public class FeatureStyleExtension { \npublic void setIcons ( String featureTable , long featureId , Icons icons ) { \ndeleteIcons ( featureTable , featureId ) ; \nif ( icons != null ) { \nif ( icons . getDefault ( ) != null ) { \nsetIconDefault ( featureTable , featureId , icons . getDefault ( ) ) ; \n} \nfor ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { \nsetIcon ( featureTable , featureId , icon . getKey ( ) , icon . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6048": "public class FeatureStyleExtension { \npublic void setIcon ( FeatureRow featureRow , IconRow icon ) { \nsetIcon ( featureRow , featureRow . getGeometryType ( ) , icon ) ; \nreturn ; \n} \n} \n"}
{"6049": "public class FeatureStyleExtension { \npublic void setIconDefault ( FeatureRow featureRow , IconRow icon ) { \nsetIcon ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , null , icon ) ; \nreturn ; \n} \n} \n"}
{"6050": "public class FeatureStyleExtension { \npublic void setIconDefault ( String featureTable , long featureId , IconRow icon ) { \nsetIcon ( featureTable , featureId , null , icon ) ; \nreturn ; \n} \n} \n"}
{"6053": "public class FeatureStyleExtension { \nprivate void insertStyleMapping ( StyleMappingDao mappingDao , long baseId , long relatedId , GeometryType geometryType ) { \nStyleMappingRow row = mappingDao . newRow ( ) ; \nrow . setBaseId ( baseId ) ; \nrow . setRelatedId ( relatedId ) ; \nrow . setGeometryType ( geometryType ) ; \nmappingDao . insert ( row ) ; \nreturn ; \n} \n} \n"}
{"6054": "public class FeatureStyleExtension { \npublic void deleteTableStyle ( String featureTable , GeometryType geometryType ) { \ndeleteTableMapping ( getTableStyleMappingDao ( featureTable ) , featureTable , geometryType ) ; \nreturn ; \n} \n} \n"}
{"6055": "public class FeatureStyleExtension { \npublic void deleteTableIcon ( String featureTable , GeometryType geometryType ) { \ndeleteTableMapping ( getTableIconMappingDao ( featureTable ) , featureTable , geometryType ) ; \nreturn ; \n} \n} \n"}
{"6056": "public class FeatureStyleExtension { \nprivate void deleteTableMappings ( StyleMappingDao mappingDao , String featureTable ) { \nif ( mappingDao != null ) { \nLong featureContentsId = contentsId . getId ( featureTable ) ; \nif ( featureContentsId != null ) { \nmappingDao . deleteByBaseId ( featureContentsId ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6057": "public class FeatureStyleExtension { \nprivate void deleteTableMapping ( StyleMappingDao mappingDao , String featureTable , GeometryType geometryType ) { \nif ( mappingDao != null ) { \nLong featureContentsId = contentsId . getId ( featureTable ) ; \nif ( featureContentsId != null ) { \nmappingDao . deleteByBaseId ( featureContentsId , geometryType ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6058": "public class FeatureStyleExtension { \nprivate void deleteMapping ( StyleMappingDao mappingDao , long featureId , GeometryType geometryType ) { \nif ( mappingDao != null ) { \nmappingDao . deleteByBaseId ( featureId , geometryType ) ; \n} \nreturn ; \n} \n} \n"}
{"6064": "public class CoverageDataPngImage { \npublic void flushStream ( ) { \nif ( outputStream != null ) { \nif ( imageBytes == null ) { \nimageBytes = outputStream . toByteArray ( ) ; \n} \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \nLog . w ( CoverageDataPngImage . class . getSimpleName ( ) , \"Failed to close output stream\" , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6066": "public class CoverageDataPngImage { \nprivate void readPixels ( ) { \nif ( reader != null ) { \npixels = new int [ reader . imgInfo . rows ] [ reader . imgInfo . cols ] ; \nint rowCount = 0 ; \nwhile ( reader . hasMoreRows ( ) ) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] columnValues = new int [ reader . imgInfo . cols ] ; \nSystem . arraycopy ( row . getScanline ( ) , 0 , columnValues , 0 , columnValues . length ) ; \npixels [ rowCount ++ ] = columnValues ; \n} \nreader . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( points . size ( ) >= 2 ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( i == 0 ) { \npath . moveTo ( x , y ) ; \n} \nelse { \npath . lineTo ( x , y ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6071": "public class DefaultFeatureTiles { \nprivate void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { \nList < LineString > rings = polygon . getRings ( ) ; \nif ( ! rings . isEmpty ( ) ) { \nLineString polygonLineString = rings . get ( 0 ) ; \nList < Point > polygonPoints = polygonLineString . getPoints ( ) ; \nif ( polygonPoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; \nfor ( int i = 1 ; \ni < rings . size ( ) ; \ni ++ ) { \nLineString holeLineString = rings . get ( i ) ; \nList < Point > holePoints = holeLineString . getPoints ( ) ; \nif ( holePoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6074": "public class FeatureCacheTables { \npublic void clearAndResize ( int maxCacheSize ) { \nsetMaxCacheSize ( maxCacheSize ) ; \nfor ( FeatureCache cache : tableCache . values ( ) ) { \ncache . clearAndResize ( maxCacheSize ) ; \n} \nreturn ; \n} \n} \n"}
{"6078": "public class IconRow { \npublic void setWidth ( Double width ) { \nif ( width != null && width < 0.0 ) { \nthrow new GeoPackageException ( \"Width must be greater than or equal to 0.0, invalid value: \" + width ) ; \n} \nsetValue ( getWidthColumnIndex ( ) , width ) ; \nreturn ; \n} \n} \n"}
{"6079": "public class IconRow { \npublic void setHeight ( Double height ) { \nif ( height != null && height < 0.0 ) { \nthrow new GeoPackageException ( \"Height must be greater than or equal to 0.0, invalid value: \" + height ) ; \n} \nsetValue ( getHeightColumnIndex ( ) , height ) ; \nreturn ; \n} \n} \n"}
{"6082": "public class UserInvalidCursor { \nprivate void readBlobValue ( UserRow row , UserColumn column ) { \nByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; \ntry { \nbyte [ ] blobChunk = new byte [ ] { \n0 } \n; \nfor ( int i = 1 ; \nblobChunk . length > 0 ; \ni += CHUNK_SIZE ) { \nif ( i > 1 ) { \nbyteStream . write ( blobChunk ) ; \n} \nblobChunk = new byte [ ] { \n} \n; \nString query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; \nCursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; \ntry { \nif ( blobCursor . moveToNext ( ) ) { \nblobChunk = blobCursor . getBlob ( 0 ) ; \n} \n} \nfinally { \nblobCursor . close ( ) ; \n} \n} \nbyte [ ] blob = byteStream . toByteArray ( ) ; \nrow . setValue ( column . getIndex ( ) , blob ) ; \n} \ncatch ( IOException e ) { \nLog . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( byteStream ) ; \n} \nreturn ; \n} \n} \n"}
{"6088": "public class FeatureIndexManager { \npublic void setProgress ( GeoPackageProgress progress ) { \nfeatureTableIndex . setProgress ( progress ) ; \nfeatureIndexer . setProgress ( progress ) ; \nrTreeIndexTableDao . setProgress ( progress ) ; \nreturn ; \n} \n} \n"}
{"6105": "public class StyleMappingRow { \npublic void setGeometryType ( GeometryType geometryType ) { \nString geometryTypeName = null ; \nif ( geometryType != null ) { \ngeometryTypeName = geometryType . getName ( ) ; \n} \nsetValue ( getGeometryTypeNameColumnIndex ( ) , geometryTypeName ) ; \nreturn ; \n} \n} \n"}
{"6113": "public class FeatureIndexer { \nprivate void updateLastIndexed ( GeoPackageMetadataDb db , long geoPackageId ) { \nlong indexedTime = ( new Date ( ) ) . getTime ( ) ; \nTableMetadataDataSource ds = new TableMetadataDataSource ( db ) ; \nif ( ! ds . updateLastIndexed ( geoPackageId , featureDao . getTableName ( ) , indexedTime ) ) { \nthrow new GeoPackageException ( \"Failed to update last indexed time. Table: GeoPackage Id: \" + geoPackageId + \", Table: \" + featureDao . getTableName ( ) + \", Last Indexed: \" + indexedTime ) ; \n} \nreturn ; \n} \n} \n"}
{"6138": "public class GeoPackageMetadataDataSource { \npublic void create ( GeoPackageMetadata metadata ) { \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeoPackageMetadata . COLUMN_NAME , metadata . getName ( ) ) ; \nvalues . put ( GeoPackageMetadata . COLUMN_EXTERNAL_PATH , metadata . getExternalPath ( ) ) ; \nlong insertId = db . insert ( GeoPackageMetadata . TABLE_NAME , null , values ) ; \nif ( insertId == - 1 ) { \nthrow new GeoPackageException ( \"Failed to insert GeoPackage metadata. Name: \" + metadata . getName ( ) + \", External Path: \" + metadata . getExternalPath ( ) ) ; \n} \nmetadata . setId ( insertId ) ; \nreturn ; \n} \n} \n"}
{"6153": "public class ParallaxContainer { \nprivate void addParallaxView ( View view , int pageIndex ) { \nif ( view instanceof ViewGroup ) { \nViewGroup viewGroup = ( ViewGroup ) view ; \nfor ( int i = 0 , childCount = viewGroup . getChildCount ( ) ; \ni < childCount ; \ni ++ ) { \naddParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; \n} \n} \nParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; \nif ( tag != null ) { \ntag . index = pageIndex ; \nparallaxViews . add ( view ) ; \n} \nreturn ; \n} \n} \n"}
{"6156": "public class SMTPAppender { \nprotected void subAppend ( CyclicBuffer < ILoggingEvent > cb , ILoggingEvent event ) { \nif ( includeCallerData ) { \nevent . getCallerData ( ) ; \n} \nevent . prepareForDeferredProcessing ( ) ; \ncb . add ( event ) ; \nreturn ; \n} \n} \n"}
{"6159": "public class ContextInitializer { \npublic void autoConfig ( ) throws JoranException { \nStatusListenerConfigHelper . installIfAsked ( loggerContext ) ; \nnew AndroidContextUtil ( ) . setupProperties ( loggerContext ) ; \nboolean verbose = true ; \nboolean configured = false ; \nJoranConfigurator configurator = new JoranConfigurator ( ) ; \nconfigurator . setContext ( loggerContext ) ; \nif ( ! configured ) { \nURL url = findConfigFileFromSystemProperties ( verbose ) ; \nif ( url != null ) { \nconfigurator . doConfigure ( url ) ; \nconfigured = true ; \n} \n} \nif ( ! configured ) { \nURL assetsConfigUrl = findConfigFileURLFromAssets ( verbose ) ; \nif ( assetsConfigUrl != null ) { \nconfigurator . doConfigure ( assetsConfigUrl ) ; \nconfigured = true ; \n} \n} \nreturn ; \n} \n} \n"}
{"6160": "public class ContextInitializer { \nprivate void statusOnResourceSearch ( String resourceName , ClassLoader classLoader , String path ) { \nStatusManager sm = loggerContext . getStatusManager ( ) ; \nif ( path == null ) { \nsm . add ( new InfoStatus ( \"Could NOT find resource [\" + resourceName + \"]\" , loggerContext ) ) ; \n} \nelse { \nsm . add ( new InfoStatus ( \"Found resource [\" + resourceName + \"] at [\" + path + \"]\" , loggerContext ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6163": "public class ConverterUtil { \npublic static < E > void startConverters ( Converter < E > head ) { \nConverter < E > c = head ; \nwhile ( c != null ) { \nif ( c instanceof CompositeConverter ) { \nCompositeConverter < E > cc = ( CompositeConverter < E > ) c ; \nConverter < E > childConverter = cc . childConverter ; \nstartConverters ( childConverter ) ; \ncc . start ( ) ; \n} \nelse if ( c instanceof DynamicConverter ) { \nDynamicConverter < E > dc = ( DynamicConverter < E > ) c ; \ndc . start ( ) ; \n} \nc = c . getNext ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6164": "public class RollingFileAppender { \n@ Override protected void subAppend ( E event ) { \nsynchronized ( triggeringPolicy ) { \nif ( triggeringPolicy . isTriggeringEvent ( currentlyActiveFile , event ) ) { \nrollover ( ) ; \n} \n} \nsuper . subAppend ( event ) ; \nreturn ; \n} \n} \n"}
{"6165": "public class InterpretationContext { \npublic void addSubstitutionProperty ( String key , String value ) { \nif ( key == null || value == null ) { \nreturn ; \n} \nvalue = value . trim ( ) ; \npropertiesMap . put ( key , value ) ; \nreturn ; \n} \n} \n"}
{"6170": "public class AlmostAsIsEscapeUtil { \npublic void escape ( String escapeChars , StringBuffer buf , char next , int pointer ) { \nsuper . escape ( \"\" + CoreConstants . PERCENT_CHAR + CoreConstants . RIGHT_PARENTHESIS_CHAR , buf , next , pointer ) ; \nreturn ; \n} \n} \n"}
{"6172": "public class AbstractEventEvaluatorAction { \npublic void begin ( InterpretationContext ec , String name , Attributes attributes ) { \ninError = false ; \nevaluator = null ; \nString className = attributes . getValue ( CLASS_ATTRIBUTE ) ; \nif ( OptionHelper . isEmpty ( className ) ) { \nclassName = defaultClassName ( ) ; \naddInfo ( \"Assuming default evaluator class [\" + className + \"]\" ) ; \n} \nif ( OptionHelper . isEmpty ( className ) ) { \nclassName = defaultClassName ( ) ; \ninError = true ; \naddError ( \"Mandatory \\\"\" + CLASS_ATTRIBUTE + \"\\\" attribute not set for <evaluator>\" ) ; \nreturn ; \n} \nString evaluatorName = attributes . getValue ( Action . NAME_ATTRIBUTE ) ; \nif ( OptionHelper . isEmpty ( evaluatorName ) ) { \ninError = true ; \naddError ( \"Mandatory \\\"\" + NAME_ATTRIBUTE + \"\\\" attribute not set for <evaluator>\" ) ; \nreturn ; \n} \ntry { \nevaluator = ( EventEvaluator < ? > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . boolex . EventEvaluator . class , context ) ; \nevaluator . setContext ( this . context ) ; \nevaluator . setName ( evaluatorName ) ; \nec . pushObject ( evaluator ) ; \naddInfo ( \"Adding evaluator named [\" + evaluatorName + \"] to the object stack\" ) ; \n} \ncatch ( Exception oops ) { \ninError = true ; \naddError ( \"Could not create evaluator of type \" + className + \"].\" , oops ) ; \n} \nreturn ; \n} \n} \n"}
{"6173": "public class AbstractEventEvaluatorAction { \n@ SuppressWarnings ( \"unchecked\" ) public void end ( InterpretationContext ec , String e ) { \nif ( inError ) { \nreturn ; \n} \nif ( evaluator instanceof LifeCycle ) { \n( ( LifeCycle ) evaluator ) . start ( ) ; \naddInfo ( \"Starting evaluator named [\" + evaluator . getName ( ) + \"]\" ) ; \n} \nObject o = ec . peekObject ( ) ; \nif ( o != evaluator ) { \naddWarn ( \"The object on the top the of the stack is not the evaluator pushed earlier.\" ) ; \n} \nelse { \nec . popObject ( ) ; \ntry { \nMap < String , EventEvaluator < ? > > evaluatorMap = ( Map < String , EventEvaluator < ? > > ) context . getObject ( CoreConstants . EVALUATOR_MAP ) ; \nif ( evaluatorMap == null ) { \naddError ( \"Could not find EvaluatorMap\" ) ; \n} \nelse { \nevaluatorMap . put ( evaluator . getName ( ) , evaluator ) ; \n} \n} \ncatch ( Exception ex ) { \naddError ( \"Could not set evaluator named [\" + evaluator + \"].\" , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6174": "public class ContextSelectorStaticBinder { \npublic void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { \nif ( this . key == null ) { \nthis . key = key ; \n} \nelse if ( this . key != key ) { \nthrow new IllegalAccessException ( \"Only certain classes can access this method.\" ) ; \n} \nString contextSelectorStr = OptionHelper . getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; \nif ( contextSelectorStr == null ) { \ncontextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; \n} \nelse if ( contextSelectorStr . equals ( \"JNDI\" ) ) { \nthrow new RuntimeException ( \"JNDI not supported\" ) ; \n} \nelse { \ncontextSelector = dynamicalContextSelector ( defaultLoggerContext , contextSelectorStr ) ; \n} \nreturn ; \n} \n} \n"}
{"6176": "public class AndroidContextUtil { \npublic void setupProperties ( LoggerContext context ) { \nProperties props = new Properties ( ) ; \nprops . setProperty ( CoreConstants . DATA_DIR_KEY , getFilesDirectoryPath ( ) ) ; \nfinal String extDir = getMountedExternalStorageDirectoryPath ( ) ; \nif ( extDir != null ) { \nprops . setProperty ( CoreConstants . EXT_DIR_KEY , extDir ) ; \n} \nprops . setProperty ( CoreConstants . PACKAGE_NAME_KEY , getPackageName ( ) ) ; \nprops . setProperty ( CoreConstants . VERSION_CODE_KEY , getVersionCode ( ) ) ; \nprops . setProperty ( CoreConstants . VERSION_NAME_KEY , getVersionName ( ) ) ; \ncontext . putProperties ( props ) ; \nreturn ; \n} \n} \n"}
{"6182": "public class ReconfigureOnChangeFilter { \nprivate void updateMaskIfNecessary ( long now ) { \nfinal long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; \nlastMaskCheck = now ; \nif ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) { \nmask = ( mask << 1 ) | 1 ; \n} \nelse if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { \nmask = mask >>> 2 ; \n} \nreturn ; \n} \n} \n"}
{"6190": "public class ShutdownHookBase { \nprotected void stop ( ) { \naddInfo ( \"Logback context being closed via shutdown hook\" ) ; \nContext hookContext = getContext ( ) ; \nif ( hookContext instanceof ContextBase ) { \nContextBase context = ( ContextBase ) hookContext ; \ncontext . stop ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6191": "public class StatusPrinter { \npublic static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) { \nprint ( sm , threshold ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6192": "public class StatusPrinter { \npublic static void printIfErrorsOccured ( Context context ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) { \nprint ( sm ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6193": "public class StatusPrinter { \npublic static void print ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \nelse { \nprint ( sm , threshold ) ; \n} \nreturn ; \n} \n} \n"}
{"6194": "public class SyslogAppender { \nprivate void handleThrowableFirstLine ( OutputStream sw , IThrowableProxy tp , String stackTracePrefix , boolean isRootException ) throws IOException { \nStringBuilder sb = new StringBuilder ( ) . append ( stackTracePrefix ) ; \nif ( ! isRootException ) { \nsb . append ( CoreConstants . CAUSED_BY ) ; \n} \nsb . append ( tp . getClassName ( ) ) . append ( \": \" ) . append ( tp . getMessage ( ) ) ; \nsw . write ( sb . toString ( ) . getBytes ( ) ) ; \nsw . flush ( ) ; \nreturn ; \n} \n} \n"}
{"6196": "public class AbstractComponentTracker { \npublic void endOfLife ( String key ) { \nEntry < C > entry = liveMap . remove ( key ) ; \nif ( entry == null ) return ; \nlingerersMap . put ( key , entry ) ; \nreturn ; \n} \n} \n"}
{"6198": "public class RenameUtil { \npublic void rename ( String src , String target ) throws RolloverFailure { \nif ( src . equals ( target ) ) { \naddWarn ( \"Source and target files are the same [\" + src + \"]. Skipping.\" ) ; \nreturn ; \n} \nFile srcFile = new File ( src ) ; \nif ( srcFile . exists ( ) ) { \nFile targetFile = new File ( target ) ; \ncreateMissingTargetDirsIfNecessary ( targetFile ) ; \naddInfo ( \"Renaming file [\" + srcFile + \"] to [\" + targetFile + \"]\" ) ; \nboolean result = srcFile . renameTo ( targetFile ) ; \nif ( ! result ) { \naddWarn ( \"Failed to rename file [\" + srcFile + \"] as [\" + targetFile + \"].\" ) ; \nBoolean areOnDifferentVolumes = areOnDifferentVolumes ( srcFile , targetFile ) ; \nif ( Boolean . TRUE . equals ( areOnDifferentVolumes ) ) { \naddWarn ( \"Detected different file systems for source [\" + src + \"] and target [\" + target + \"]. Attempting rename by copying.\" ) ; \nrenameByCopying ( src , target ) ; \nreturn ; \n} \nelse { \naddWarn ( \"Please consider leaving the [file] option of \" + RollingFileAppender . class . getSimpleName ( ) + \" empty.\" ) ; \naddWarn ( \"See also \" + RENAMING_ERROR_URL ) ; \n} \n} \n} \nelse { \nthrow new RolloverFailure ( \"File [\" + src + \"] does not exist.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6202": "public class LoggingEvent { \npublic void setMDCPropertyMap ( Map < String , String > map ) { \nif ( mdcPropertyMap != null ) { \nthrow new IllegalStateException ( \"The MDCPropertyMap has been already set for this event.\" ) ; \n} \nthis . mdcPropertyMap = map ; \nreturn ; \n} \n} \n"}
{"6206": "public class BasicStatusManager { \npublic void add ( Status newStatus ) { \nfireStatusAddEvent ( newStatus ) ; \ncount ++ ; \nif ( newStatus . getLevel ( ) > level ) { \nlevel = newStatus . getLevel ( ) ; \n} \nsynchronized ( statusListLock ) { \nif ( statusList . size ( ) < MAX_HEADER_COUNT ) { \nstatusList . add ( newStatus ) ; \n} \nelse { \ntailBuffer . add ( newStatus ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6210": "public class SystemPropertiesProxy { \npublic void setClassLoader ( ClassLoader cl ) throws ClassNotFoundException , SecurityException , NoSuchMethodException { \nif ( cl == null ) cl = this . getClass ( ) . getClassLoader ( ) ; \nSystemProperties = cl . loadClass ( \"android.os.SystemProperties\" ) ; \ngetString = SystemProperties . getMethod ( \"get\" , new Class [ ] { \nString . class , String . class } \n) ; \ngetBoolean = SystemProperties . getMethod ( \"getBoolean\" , new Class [ ] { \nString . class , boolean . class } \n) ; \nreturn ; \n} \n} \n"}
{"6216": "public class OutputStreamAppender { \npublic void start ( ) { \nint errors = 0 ; \nif ( this . encoder == null ) { \naddStatus ( new ErrorStatus ( \"No encoder set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors ++ ; \n} \nif ( this . outputStream == null ) { \naddStatus ( new ErrorStatus ( \"No output stream set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors ++ ; \n} \nif ( errors == 0 ) { \nsuper . start ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6217": "public class StatusListenerConfigHelper { \nstatic public void addOnConsoleListenerInstance ( Context context , OnConsoleStatusListener onConsoleStatusListener ) { \nonConsoleStatusListener . setContext ( context ) ; \nboolean effectivelyAdded = context . getStatusManager ( ) . add ( onConsoleStatusListener ) ; \nif ( effectivelyAdded ) { \nonConsoleStatusListener . start ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6218": "public class DefinePropertyAction { \npublic void end ( InterpretationContext ec , String name ) { \nif ( inError ) { \nreturn ; \n} \nObject o = ec . peekObject ( ) ; \nif ( o != definer ) { \naddWarn ( \"The object at the of the stack is not the property definer for property named [\" + propertyName + \"] pushed earlier.\" ) ; \n} \nelse { \naddInfo ( \"Popping property definer for property named [\" + propertyName + \"] from the object stack\" ) ; \nec . popObject ( ) ; \nString propertyValue = definer . getPropertyValue ( ) ; \nif ( propertyValue != null ) { \nActionUtil . setProperty ( ec , propertyName , propertyValue , scope ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6221": "public class ShutdownHookAction { \n@ Override public void begin ( InterpretationContext ic , String name , Attributes attributes ) throws ActionException { \nhook = null ; \ninError = false ; \nString className = attributes . getValue ( CLASS_ATTRIBUTE ) ; \nif ( OptionHelper . isEmpty ( className ) ) { \nclassName = DefaultShutdownHook . class . getName ( ) ; \naddInfo ( \"Assuming className [\" + className + \"]\" ) ; \n} \ntry { \naddInfo ( \"About to instantiate shutdown hook of type [\" + className + \"]\" ) ; \nhook = ( ShutdownHookBase ) OptionHelper . instantiateByClassName ( className , ShutdownHookBase . class , context ) ; \nhook . setContext ( context ) ; \nic . pushObject ( hook ) ; \n} \ncatch ( Exception e ) { \ninError = true ; \naddError ( \"Could not create a shutdown hook of type [\" + className + \"].\" , e ) ; \nthrow new ActionException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"6222": "public class ShutdownHookAction { \n@ Override public void end ( InterpretationContext ic , String name ) throws ActionException { \nif ( inError ) { \nreturn ; \n} \nObject o = ic . peekObject ( ) ; \nif ( o != hook ) { \naddWarn ( \"The object at the of the stack is not the hook pushed earlier.\" ) ; \n} \nelse { \nic . popObject ( ) ; \nThread hookThread = new Thread ( hook , \"Logback shutdown hook [\" + context . getName ( ) + \"]\" ) ; \naddInfo ( \"Registering shutdown hook with JVM runtime\" ) ; \ncontext . putObject ( CoreConstants . SHUTDOWN_HOOK_THREAD , hookThread ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( hookThread ) ; \n} \nreturn ; \n} \n} \n"}
{"6227": "public class ActionUtil { \nstatic public void setProperties ( InterpretationContext ic , Properties props , Scope scope ) { \nswitch ( scope ) { \ncase LOCAL : ic . addSubstitutionProperties ( props ) ; \nbreak ; \ncase CONTEXT : ContextUtil cu = new ContextUtil ( ic . getContext ( ) ) ; \ncu . addProperties ( props ) ; \nbreak ; \ncase SYSTEM : OptionHelper . setSystemProperties ( ic , props ) ; \n} \nreturn ; \n} \n} \n"}
{"6228": "public class AppenderAttachableImpl { \npublic void addAppender ( Appender < E > newAppender ) { \nif ( newAppender == null ) { \nthrow new IllegalArgumentException ( \"Null argument disallowed\" ) ; \n} \nappenderList . addIfAbsent ( newAppender ) ; \nreturn ; \n} \n} \n"}
{"6231": "public class Logger { \nprivate synchronized void handleParentLevelChange ( int newParentLevelInt ) { \nif ( level == null ) { \neffectiveLevelInt = newParentLevelInt ; \nif ( childrenList != null ) { \nint len = childrenList . size ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nLogger child = ( Logger ) childrenList . get ( i ) ; \nchild . handleParentLevelChange ( newParentLevelInt ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6232": "public class Logger { \npublic void callAppenders ( ILoggingEvent event ) { \nint writes = 0 ; \nfor ( Logger l = this ; \nl != null ; \nl = l . parent ) { \nwrites += l . appendLoopOnAppenders ( event ) ; \nif ( ! l . additive ) { \nbreak ; \n} \n} \nif ( writes == 0 ) { \nloggerContext . noAppenderDefinedWarning ( this ) ; \n} \nreturn ; \n} \n} \n"}
{"6236": "public class Logger { \npublic void log ( org . slf4j . event . LoggingEvent slf4jEvent ) { \nLevel level = Level . fromLocationAwareLoggerInteger ( slf4jEvent . getLevel ( ) . toInt ( ) ) ; \nfilterAndLog_0_Or3Plus ( FQCN , slf4jEvent . getMarker ( ) , level , slf4jEvent . getMessage ( ) , slf4jEvent . getArgumentArray ( ) , slf4jEvent . getThrowable ( ) ) ; \nreturn ; \n} \n} \n"}
{"6246": "public class LogcatAppender { \n@ Override public void start ( ) { \nif ( ( this . encoder == null ) || ( this . encoder . getLayout ( ) == null ) ) { \naddError ( \"No layout set for the appender named [\" + name + \"].\" ) ; \nreturn ; \n} \nif ( this . tagEncoder != null ) { \nfinal Layout < ? > layout = this . tagEncoder . getLayout ( ) ; \nif ( layout == null ) { \naddError ( \"No tag layout set for the appender named [\" + name + \"].\" ) ; \nreturn ; \n} \nif ( layout instanceof PatternLayout ) { \nString pattern = this . tagEncoder . getPattern ( ) ; \nif ( ! pattern . contains ( \"%nopex\" ) ) { \nthis . tagEncoder . stop ( ) ; \nthis . tagEncoder . setPattern ( pattern + \"%nopex\" ) ; \nthis . tagEncoder . start ( ) ; \n} \nPatternLayout tagLayout = ( PatternLayout ) layout ; \ntagLayout . setPostCompileProcessor ( null ) ; \n} \n} \nsuper . start ( ) ; \nreturn ; \n} \n} \n"}
{"6248": "public class PropertyAction { \npublic void begin ( InterpretationContext ec , String localName , Attributes attributes ) { \nif ( \"substitutionProperty\" . equals ( localName ) ) { \naddWarn ( \"[substitutionProperty] element has been deprecated. Please use the [property] element instead.\" ) ; \n} \nString name = attributes . getValue ( NAME_ATTRIBUTE ) ; \nString value = attributes . getValue ( VALUE_ATTRIBUTE ) ; \nString scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; \nScope scope = ActionUtil . stringToScope ( scopeStr ) ; \nif ( checkFileAttributeSanity ( attributes ) ) { \nString file = attributes . getValue ( FILE_ATTRIBUTE ) ; \nfile = ec . subst ( file ) ; \ntry { \nFileInputStream istream = new FileInputStream ( file ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( FileNotFoundException e ) { \naddError ( \"Could not find properties file [\" + file + \"].\" ) ; \n} \ncatch ( IOException e1 ) { \naddError ( \"Could not read properties file [\" + file + \"].\" , e1 ) ; \n} \n} \nelse if ( checkResourceAttributeSanity ( attributes ) ) { \nString resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; \nresource = ec . subst ( resource ) ; \nURL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; \nif ( resourceURL == null ) { \naddError ( \"Could not find resource [\" + resource + \"].\" ) ; \n} \nelse { \ntry { \nInputStream istream = resourceURL . openStream ( ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( IOException e ) { \naddError ( \"Could not read resource file [\" + resource + \"].\" , e ) ; \n} \n} \n} \nelse if ( checkValueNameAttributesSanity ( attributes ) ) { \nvalue = RegularEscapeUtil . basicEscape ( value ) ; \nvalue = value . trim ( ) ; \nvalue = ec . subst ( value ) ; \nActionUtil . setProperty ( ec , name , value , scope ) ; \n} \nelse { \naddError ( INVALID_ATTRIBUTES ) ; \n} \nreturn ; \n} \n} \n"}
{"6253": "public class SMTPAppenderBase { \npublic void start ( ) { \nif ( cbTracker == null ) { \ncbTracker = new CyclicBufferTracker < E > ( ) ; \n} \nsession = buildSessionFromProperties ( ) ; \nif ( session == null ) { \naddError ( \"Failed to obtain javax.mail.Session. Cannot start.\" ) ; \nreturn ; \n} \nsubjectLayout = makeSubjectLayout ( subjectStr ) ; \nstarted = true ; \nreturn ; \n} \n} \n"}
{"6254": "public class SMTPAppenderBase { \nprotected void append ( E eventObject ) { \nif ( ! checkEntryConditions ( ) ) { \nreturn ; \n} \nString key = discriminator . getDiscriminatingValue ( eventObject ) ; \nlong now = System . currentTimeMillis ( ) ; \nfinal CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; \nsubAppend ( cb , eventObject ) ; \ntry { \nif ( eventEvaluator . evaluate ( eventObject ) ) { \nCyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; \ncb . clear ( ) ; \nif ( asynchronousSending ) { \nSenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; \ncontext . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; \n} \nelse { \nsendBuffer ( cbClone , eventObject ) ; \n} \n} \n} \ncatch ( EvaluationException ex ) { \nerrorCount ++ ; \nif ( errorCount < CoreConstants . MAX_ERROR_COUNT ) { \naddError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; \n} \n} \nif ( eventMarksEndOfLife ( eventObject ) ) { \ncbTracker . endOfLife ( key ) ; \n} \ncbTracker . removeStaleComponents ( now ) ; \nif ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { \naddInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; \nlastTrackerStatusPrint = now ; \nif ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) { \ndelayBetweenStatusMessages *= 4 ; \n} \n} \nreturn ; \n} \n} \n"}
{"6255": "public class SMTPAppenderBase { \nprotected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { \ntry { \nMimeBodyPart part = new MimeBodyPart ( ) ; \nStringBuffer sbuf = new StringBuffer ( ) ; \nString header = layout . getFileHeader ( ) ; \nif ( header != null ) { \nsbuf . append ( header ) ; \n} \nString presentationHeader = layout . getPresentationHeader ( ) ; \nif ( presentationHeader != null ) { \nsbuf . append ( presentationHeader ) ; \n} \nfillBuffer ( cb , sbuf ) ; \nString presentationFooter = layout . getPresentationFooter ( ) ; \nif ( presentationFooter != null ) { \nsbuf . append ( presentationFooter ) ; \n} \nString footer = layout . getFileFooter ( ) ; \nif ( footer != null ) { \nsbuf . append ( footer ) ; \n} \nString subjectStr = \"Undefined subject\" ; \nif ( subjectLayout != null ) { \nsubjectStr = subjectLayout . doLayout ( lastEventObject ) ; \nint newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\\n' ) : - 1 ; \nif ( newLinePos > - 1 ) { \nsubjectStr = subjectStr . substring ( 0 , newLinePos ) ; \n} \n} \nMimeMessage mimeMsg = new MimeMessage ( session ) ; \nif ( from != null ) { \nmimeMsg . setFrom ( getAddress ( from ) ) ; \n} \nelse { \nmimeMsg . setFrom ( ) ; \n} \nmimeMsg . setSubject ( subjectStr , charsetEncoding ) ; \nList < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; \nif ( destinationAddresses . isEmpty ( ) ) { \naddInfo ( \"Empty destination address. Aborting email transmission\" ) ; \nreturn ; \n} \nInternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; \nmimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; \nString contentType = layout . getContentType ( ) ; \nif ( ContentTypeUtil . isTextual ( contentType ) ) { \npart . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; \n} \nelse { \npart . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; \n} \nMultipart mp = new MimeMultipart ( ) ; \nmp . addBodyPart ( part ) ; \nmimeMsg . setContent ( mp ) ; \nupdateMimeMsg ( mimeMsg , cb , lastEventObject ) ; \nmimeMsg . setSentDate ( new Date ( ) ) ; \naddInfo ( \"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays . toString ( toAddressArray ) ) ; \nTransport . send ( mimeMsg ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Error occurred while sending e-mail notification.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"6256": "public class DynamicThresholdFilter { \npublic void addMDCValueLevelPair ( MDCValueLevelPair mdcValueLevelPair ) { \nif ( valueLevelMap . containsKey ( mdcValueLevelPair . getValue ( ) ) ) { \naddError ( mdcValueLevelPair . getValue ( ) + \" has been already set\" ) ; \n} \nelse { \nvalueLevelMap . put ( mdcValueLevelPair . getValue ( ) , mdcValueLevelPair . getLevel ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6259": "public class RollingPolicyBase { \nprotected void determineCompressionMode ( ) { \nif ( fileNamePatternStr . endsWith ( \".gz\" ) ) { \naddInfo ( \"Will use gz compression\" ) ; \ncompressionMode = CompressionMode . GZ ; \n} \nelse if ( fileNamePatternStr . endsWith ( \".zip\" ) ) { \naddInfo ( \"Will use zip compression\" ) ; \ncompressionMode = CompressionMode . ZIP ; \n} \nelse { \naddInfo ( \"No compression will be used\" ) ; \ncompressionMode = CompressionMode . NONE ; \n} \nreturn ; \n} \n} \n"}
{"6260": "public class GenericConfigurator { \npublic final void doConfigure ( URL url ) throws JoranException { \nInputStream in = null ; \ntry { \ninformContextOfURLUsedForConfiguration ( getContext ( ) , url ) ; \nURLConnection urlConnection = url . openConnection ( ) ; \nurlConnection . setUseCaches ( false ) ; \nin = urlConnection . getInputStream ( ) ; \ndoConfigure ( in , url . toExternalForm ( ) ) ; \n} \ncatch ( IOException ioe ) { \nString errMsg = \"Could not open URL [\" + url + \"].\" ; \naddError ( errMsg , ioe ) ; \nthrow new JoranException ( errMsg , ioe ) ; \n} \nfinally { \nCloseUtil . closeQuietly ( in ) ; \n} \nreturn ; \n} \n} \n"}
{"6261": "public class GenericConfigurator { \npublic final void doConfigure ( File file ) throws JoranException { \nFileInputStream fis = null ; \ntry { \nURL url = file . toURI ( ) . toURL ( ) ; \ninformContextOfURLUsedForConfiguration ( getContext ( ) , url ) ; \nfis = new FileInputStream ( file ) ; \ndoConfigure ( fis , url . toExternalForm ( ) ) ; \n} \ncatch ( IOException ioe ) { \nString errMsg = \"Could not open [\" + file . getPath ( ) + \"].\" ; \naddError ( errMsg , ioe ) ; \nthrow new JoranException ( errMsg , ioe ) ; \n} \nfinally { \nCloseUtil . closeQuietly ( fis ) ; \n} \nreturn ; \n} \n} \n"}
{"6262": "public class GenericConfigurator { \npublic final void doConfigure ( InputStream inputStream ) throws JoranException { \ntry { \ndoConfigure ( new InputSource ( inputStream ) ) ; \n} \nfinally { \ntry { \ninputStream . close ( ) ; \n} \ncatch ( IOException ioe ) { \nString errMsg = \"Could not close the stream\" ; \naddError ( errMsg , ioe ) ; \nthrow new JoranException ( errMsg , ioe ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6263": "public class GenericConfigurator { \nprotected void buildInterpreter ( ) { \nRuleStore rs = new SimpleRuleStore ( context ) ; \naddInstanceRules ( rs ) ; \nthis . interpreter = new Interpreter ( context , rs , initialElementPath ( ) ) ; \nInterpretationContext interpretationContext = interpreter . getInterpretationContext ( ) ; \ninterpretationContext . setContext ( context ) ; \naddImplicitRules ( interpreter ) ; \naddDefaultNestedComponentRegistryRules ( interpretationContext . getDefaultNestedComponentRegistry ( ) ) ; \nreturn ; \n} \n} \n"}
{"6264": "public class GenericConfigurator { \nprivate final void doConfigure ( final InputSource inputSource ) throws JoranException { \nlong threshold = System . currentTimeMillis ( ) ; \nSaxEventRecorder recorder = new SaxEventRecorder ( context ) ; \nrecorder . recordEvents ( inputSource ) ; \ndoConfigure ( recorder . getSaxEventList ( ) ) ; \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . noXMLParsingErrorsOccurred ( threshold ) ) { \naddInfo ( \"Registering current configuration as safe fallback point\" ) ; \nregisterSafeConfiguration ( recorder . getSaxEventList ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6265": "public class GenericConfigurator { \npublic void doConfigure ( final List < SaxEvent > eventList ) throws JoranException { \nbuildInterpreter ( ) ; \nsynchronized ( context . getConfigurationLock ( ) ) { \ninterpreter . getEventPlayer ( ) . play ( eventList ) ; \n} \nreturn ; \n} \n} \n"}
{"6267": "public class ContextBase { \npublic void setName ( String name ) throws IllegalStateException { \nif ( name != null && name . equals ( this . name ) ) { \nreturn ; \n} \nif ( this . name == null || CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) { \nthis . name = name ; \n} \nelse { \nthrow new IllegalStateException ( \"Context has been already given a name\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6270": "public class HTMLLayoutBase { \n@ Override public void start ( ) { \nint errorCount = 0 ; \ntry { \nParser < E > p = new Parser < E > ( pattern ) ; \np . setContext ( getContext ( ) ) ; \nNode t = p . parse ( ) ; \nthis . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; \nConverterUtil . startConverters ( this . head ) ; \n} \ncatch ( ScanException ex ) { \naddError ( \"Incorrect pattern found\" , ex ) ; \nerrorCount ++ ; \n} \nif ( errorCount == 0 ) { \nsuper . started = true ; \n} \nreturn ; \n} \n} \n"}
{"6274": "public class AppenderAction { \n@ SuppressWarnings ( \"unchecked\" ) public void begin ( InterpretationContext ec , String localName , Attributes attributes ) throws ActionException { \nappender = null ; \ninError = false ; \nString className = attributes . getValue ( CLASS_ATTRIBUTE ) ; \nif ( OptionHelper . isEmpty ( className ) ) { \naddError ( \"Missing class name for appender. Near [\" + localName + \"] line \" + getLineNumber ( ec ) ) ; \ninError = true ; \nreturn ; \n} \ntry { \naddInfo ( \"About to instantiate appender of type [\" + className + \"]\" ) ; \nwarnDeprecated ( className ) ; \nappender = ( Appender < E > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . Appender . class , context ) ; \nappender . setContext ( context ) ; \nString appenderName = ec . subst ( attributes . getValue ( NAME_ATTRIBUTE ) ) ; \nif ( OptionHelper . isEmpty ( appenderName ) ) { \naddWarn ( \"No appender name given for appender of type \" + className + \"].\" ) ; \n} \nelse { \nappender . setName ( appenderName ) ; \naddInfo ( \"Naming appender as [\" + appenderName + \"]\" ) ; \n} \nHashMap < String , Appender < E > > appenderBag = ( HashMap < String , Appender < E > > ) ec . getObjectMap ( ) . get ( ActionConst . APPENDER_BAG ) ; \nappenderBag . put ( appenderName , appender ) ; \nec . pushObject ( appender ) ; \n} \ncatch ( Exception oops ) { \ninError = true ; \naddError ( \"Could not create an Appender of type [\" + className + \"].\" , oops ) ; \nthrow new ActionException ( oops ) ; \n} \nreturn ; \n} \n} \n"}
{"6275": "public class AppenderAction { \npublic void end ( InterpretationContext ec , String name ) { \nif ( inError ) { \nreturn ; \n} \nif ( appender instanceof LifeCycle ) { \n( ( LifeCycle ) appender ) . start ( ) ; \n} \nObject o = ec . peekObject ( ) ; \nif ( o != appender ) { \naddWarn ( \"The object at the of the stack is not the appender named [\" + appender . getName ( ) + \"] pushed earlier.\" ) ; \n} \nelse { \nec . popObject ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6277": "public class ConcurrentServerRunner { \nprivate void addClient ( T client ) { \nclientsLock . lock ( ) ; \ntry { \nclients . add ( client ) ; \n} \nfinally { \nclientsLock . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6278": "public class ConcurrentServerRunner { \nprivate void removeClient ( T client ) { \nclientsLock . lock ( ) ; \ntry { \nclients . remove ( client ) ; \n} \nfinally { \nclientsLock . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6283": "public class StaticLoggerBinder { \nvoid init ( ) { \ntry { \ntry { \nnew ContextInitializer ( defaultLoggerContext ) . autoConfig ( ) ; \n} \ncatch ( JoranException je ) { \nUtil . report ( \"Failed to auto configure default logger context\" , je ) ; \n} \nif ( ! StatusUtil . contextHasStatusListener ( defaultLoggerContext ) ) { \nStatusPrinter . printInCaseOfErrorsOrWarnings ( defaultLoggerContext ) ; \n} \ncontextSelectorBinder . init ( defaultLoggerContext , KEY ) ; \ninitialized = true ; \n} \ncatch ( Exception t ) { \nUtil . report ( \"Failed to instantiate [\" + LoggerContext . class . getName ( ) + \"]\" , t ) ; \n} \nreturn ; \n} \n} \n"}
{"6285": "public class OnPrintStreamStatusListenerBase { \nprivate void retrospectivePrint ( ) { \nif ( context == null ) return ; \nlong now = System . currentTimeMillis ( ) ; \nStatusManager sm = context . getStatusManager ( ) ; \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nfor ( Status status : statusList ) { \nlong timestampOfStatusMesage = status . getDate ( ) ; \nif ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) { \nprint ( status ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6288": "public class SQLiteAppender { \nprivate void clearExpiredLogs ( SQLiteDatabase db ) { \nif ( lastCheckExpired ( this . maxHistory , this . lastCleanupTime ) ) { \nthis . lastCleanupTime = this . clock . currentTimeMillis ( ) ; \nthis . getLogCleaner ( ) . performLogCleanup ( db , this . maxHistory ) ; \n} \nreturn ; \n} \n} \n"}
{"6291": "public class SQLiteAppender { \nprivate void secondarySubAppend ( ILoggingEvent event , long eventId ) throws SQLException { \nMap < String , String > mergedMap = mergePropertyMaps ( event ) ; \ninsertProperties ( mergedMap , eventId ) ; \nif ( event . getThrowableProxy ( ) != null ) { \ninsertThrowable ( event . getThrowableProxy ( ) , eventId ) ; \n} \nreturn ; \n} \n} \n"}
{"6292": "public class SQLiteAppender { \nprivate void bindLoggingEvent ( SQLiteStatement stmt , ILoggingEvent event ) throws SQLException { \nstmt . bindLong ( TIMESTMP_INDEX , event . getTimeStamp ( ) ) ; \nstmt . bindString ( FORMATTED_MESSAGE_INDEX , event . getFormattedMessage ( ) ) ; \nstmt . bindString ( LOGGER_NAME_INDEX , event . getLoggerName ( ) ) ; \nstmt . bindString ( LEVEL_STRING_INDEX , event . getLevel ( ) . toString ( ) ) ; \nstmt . bindString ( THREAD_NAME_INDEX , event . getThreadName ( ) ) ; \nstmt . bindLong ( REFERENCE_FLAG_INDEX , computeReferenceMask ( event ) ) ; \nreturn ; \n} \n} \n"}
{"6296": "public class SQLiteAppender { \nprivate void insertException ( SQLiteStatement stmt , String txt , short i , long eventId ) throws SQLException { \nstmt . bindLong ( 1 , eventId ) ; \nstmt . bindLong ( 2 , i ) ; \nstmt . bindString ( 3 , txt ) ; \nstmt . executeInsert ( ) ; \nreturn ; \n} \n} \n"}
{"6299": "public class PropertySetter { \npublic void setProperty ( String name , String value ) { \nif ( value == null ) { \nreturn ; \n} \nname = Introspector . decapitalize ( name ) ; \nPropertyDescriptor prop = getPropertyDescriptor ( name ) ; \nif ( prop == null ) { \naddWarn ( \"No such property [\" + name + \"] in \" + objClass . getName ( ) + \".\" ) ; \n} \nelse { \ntry { \nsetProperty ( prop , name , value ) ; \n} \ncatch ( PropertySetterException ex ) { \naddWarn ( \"Failed to set property [\" + name + \"] to value \\\"\" + value + \"\\\". \" , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6302": "public class IncludeAction { \n@ Override protected void processInclude ( InterpretationContext ic , URL url ) throws JoranException { \nInputStream in = openURL ( url ) ; \ntry { \nif ( in != null ) { \nConfigurationWatchListUtil . addToWatchList ( getContext ( ) , url ) ; \nSaxEventRecorder recorder = createRecorder ( in , url ) ; \nrecorder . setContext ( getContext ( ) ) ; \nrecorder . recordEvents ( in ) ; \ntrimHeadAndTail ( recorder ) ; \nic . getJoranInterpreter ( ) . getEventPlayer ( ) . addEventsDynamically ( recorder . getSaxEventList ( ) , this . eventOffset ) ; \n} \n} \ncatch ( JoranException e ) { \noptionalWarning ( \"Failed processing [\" + url . toString ( ) + \"]\" , e ) ; \n} \nfinally { \nclose ( in ) ; \n} \nreturn ; \n} \n} \n"}
{"6304": "public class IncludeAction { \nprivate void trimHeadAndTail ( SaxEventRecorder recorder ) { \nList < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; \nif ( saxEventList . size ( ) == 0 ) { \nreturn ; \n} \nboolean includedTagFound = false ; \nboolean configTagFound = false ; \nSaxEvent first = saxEventList . get ( 0 ) ; \nif ( first != null ) { \nString elemName = getEventName ( first ) ; \nincludedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; \nconfigTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; \n} \nif ( includedTagFound || configTagFound ) { \nsaxEventList . remove ( 0 ) ; \nfinal int listSize = saxEventList . size ( ) ; \nif ( listSize == 0 ) { \nreturn ; \n} \nfinal int lastIndex = listSize - 1 ; \nSaxEvent last = saxEventList . get ( lastIndex ) ; \nif ( last != null ) { \nString elemName = getEventName ( last ) ; \nif ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) { \nsaxEventList . remove ( lastIndex ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6307": "public class PlacesClient { \nprivate void setDefaultHosts ( ) { \nList < String > fallbackHosts = Arrays . asList ( \"places-1.algolianet.com\" , \"places-2.algolianet.com\" , \"places-3.algolianet.com\" ) ; \nCollections . shuffle ( fallbackHosts ) ; \nList < String > hosts = new ArrayList < > ( fallbackHosts . size ( ) + 1 ) ; \nhosts . add ( \"places-dsn.algolia.net\" ) ; \nhosts . addAll ( fallbackHosts ) ; \nString [ ] hostsArray = hosts . toArray ( new String [ hosts . size ( ) ] ) ; \nsetReadHosts ( hostsArray ) ; \nsetWriteHosts ( hostsArray ) ; \nreturn ; \n} \n} \n"}
{"6308": "public class MirroredIndex { \nprivate synchronized void ensureLocalIndex ( ) { \nif ( localIndex == null ) { \nlocalIndex = new LocalIndex ( getClient ( ) . getRootDataDir ( ) . getAbsolutePath ( ) , getClient ( ) . getApplicationID ( ) , getRawIndexName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6309": "public class MirroredIndex { \npublic void sync ( ) { \nif ( getDataSelectionQueries ( ) . length == 0 ) { \nthrow new IllegalStateException ( \"Cannot sync with empty data selection queries\" ) ; \n} \nsynchronized ( this ) { \nif ( syncing ) return ; \nsyncing = true ; \n} \ngetClient ( ) . localBuildExecutorService . submit ( new Runnable ( ) { \n@ Override public void run ( ) { \n_sync ( ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6310": "public class MirroredIndex { \npublic void syncIfNeeded ( ) { \nlong currentDate = System . currentTimeMillis ( ) ; \nif ( currentDate - mirrorSettings . getLastSyncDate ( ) . getTime ( ) > delayBetweenSyncs || mirrorSettings . getQueriesModificationDate ( ) . compareTo ( mirrorSettings . getLastSyncDate ( ) ) > 0 ) { \nsync ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6315": "public class AbstractClient { \nprivate static void consumeQuietly ( final HttpURLConnection connection ) { \ntry { \nint read = 0 ; \nwhile ( read != - 1 ) { \nread = connection . getInputStream ( ) . read ( ) ; \n} \nconnection . getInputStream ( ) . close ( ) ; \nread = 0 ; \nwhile ( read != - 1 ) { \nread = connection . getErrorStream ( ) . read ( ) ; \n} \nconnection . getErrorStream ( ) . close ( ) ; \nconnection . disconnect ( ) ; \n} \ncatch ( IOException e ) { \n} \nreturn ; \n} \n} \n"}
{"6318": "public class BrowseIterator { \npublic void start ( ) { \nif ( started ) { \nthrow new IllegalStateException ( ) ; \n} \nstarted = true ; \nrequest = index . browseAsync ( query , requestOptions , completionHandler ) ; \nreturn ; \n} \n} \n"}
{"6321": "public class ThreadSpawner { \npublic void awaitCompletion ( ) { \nfor ( Thread thread : threads ) { \ntry { \nthread . join ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow rethrow ( e ) ; \n} \n} \nif ( caughtException != null ) { \nthrow rethrow ( caughtException ) ; \n} \nreturn ; \n} \n} \n"}
{"6323": "public class ExceptionReporter { \npublic static void report ( String testId , Throwable cause ) { \nif ( cause == null ) { \nLOGGER . fatal ( \"Can't call report with a null exception\" ) ; \nreturn ; \n} \nlong exceptionCount = FAILURE_ID . incrementAndGet ( ) ; \nif ( exceptionCount > MAX_EXCEPTION_COUNT ) { \nLOGGER . warn ( \"Exception #\" + exceptionCount + \" detected. The maximum number of exceptions has been exceeded, so it\" + \" won't be reported to the Agent.\" , cause ) ; \nreturn ; \n} \nLOGGER . warn ( \"Exception #\" + exceptionCount + \" detected\" , cause ) ; \nString targetFileName = exceptionCount + \".exception\" ; \nFile dir = getUserDir ( ) ; \nFile tmpFile = new File ( dir , targetFileName + \".tmp\" ) ; \ntry { \nif ( ! tmpFile . createNewFile ( ) ) { \nthrow new IOException ( \"Could not create tmp file: \" + tmpFile . getAbsolutePath ( ) ) ; \n} \n} \ncatch ( IOException e ) { \nLOGGER . fatal ( \"Could not report exception; this means that this exception is not visible to the coordinator\" , e ) ; \nreturn ; \n} \nwriteText ( testId + NEW_LINE + throwableToString ( cause ) , tmpFile ) ; \nFile file = new File ( dir , targetFileName ) ; \nLOGGER . info ( file . getAbsolutePath ( ) ) ; \nrename ( tmpFile , file ) ; \nreturn ; \n} \n} \n"}
{"6324": "public class FileUtils { \npublic static void copyDirectory ( File src , File target ) { \ncheckNotNull ( src , \"src can't be null\" ) ; \ncheckNotNull ( target , \"target can't be null\" ) ; \nFile [ ] files = src . listFiles ( ) ; \nif ( files == null ) { \nreturn ; \n} \nfor ( File srcFile : files ) { \nif ( srcFile . isDirectory ( ) ) { \nFile targetChild = new File ( target , srcFile . getName ( ) ) ; \nensureExistingDirectory ( targetChild ) ; \ncopyDirectory ( srcFile , targetChild ) ; \n} \nelse { \ncopyFileToDirectory ( srcFile , target ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6331": "public class JsonProtocol { \nprotected void readJsonSyntaxChar ( byte [ ] b ) throws IOException { \nbyte ch = reader . read ( ) ; \nif ( ch != b [ 0 ] ) { \nthrow new ProtocolException ( \"Unexpected character:\" + ( char ) ch ) ; \n} \nreturn ; \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( ( b [ i ] & 0x00FF ) >= 0x30 ) { \nif ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse if ( tmpbuf [ 0 ] > 1 ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \n} \ntransport . write ( QUOTE ) ; \nreturn ; \n} \n} \n"}
{"6334": "public class JsonProtocol { \nprivate void writeJsonInteger ( long num ) throws IOException { \ncontext . write ( ) ; \nString str = Long . toString ( num ) ; \nboolean escapeNum = context . escapeNum ( ) ; \nif ( escapeNum ) { \ntransport . write ( QUOTE ) ; \n} \ntry { \nbyte [ ] buf = str . getBytes ( \"UTF-8\" ) ; \ntransport . write ( buf ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \nif ( escapeNum ) { \ntransport . write ( QUOTE ) ; \n} \nreturn ; \n} \n} \n"}
{"6335": "public class JsonProtocol { \nprivate void writeJsonDouble ( double num ) throws IOException { \ncontext . write ( ) ; \nString str = Double . toString ( num ) ; \nboolean special = false ; \nswitch ( str . charAt ( 0 ) ) { \ncase 'N' : case 'I' : special = true ; \nbreak ; \ncase '-' : if ( str . charAt ( 1 ) == 'I' ) { \nspecial = true ; \n} \nbreak ; \ndefault : break ; \n} \nboolean escapeNum = special || context . escapeNum ( ) ; \nif ( escapeNum ) { \ntransport . write ( QUOTE ) ; \n} \ntry { \nbyte [ ] b = str . getBytes ( \"UTF-8\" ) ; \ntransport . write ( b , 0 , b . length ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \nif ( escapeNum ) { \ntransport . write ( QUOTE ) ; \n} \nreturn ; \n} \n} \n"}
{"6343": "public class AsyncClientBase { \nprotected void enqueue ( MethodCall < ? > methodCall ) { \nif ( ! running . get ( ) ) { \nthrow new IllegalStateException ( \"Cannot write to a closed service client\" ) ; \n} \nif ( ! pendingCalls . offer ( methodCall ) ) { \nthrow new IllegalStateException ( \"Call queue is full\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6345": "public class PlatformUtils { \npublic static void updateDecoration ( ) { \nfinal IWorkbench workbench = Activator . getDefault ( ) . getWorkbench ( ) ; \nworkbench . getDisplay ( ) . syncExec ( new Runnable ( ) { \npublic void run ( ) { \nIDecoratorManager manager = workbench . getDecoratorManager ( ) ; \nmanager . update ( GuvnorDecorator . DECORATOR_ID ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6346": "public class PlatformUtils { \npublic static void refreshRepositoryView ( ) { \nIWorkbenchWindow activeWindow = Activator . getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; \nif ( activeWindow == null ) { \nreturn ; \n} \nIWorkbenchPage page = activeWindow . getActivePage ( ) ; \nif ( page == null ) { \nreturn ; \n} \nRepositoryView view = ( RepositoryView ) page . findView ( IGuvnorConstants . REPVIEW_ID ) ; \nif ( view != null ) { \nview . refresh ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6348": "public class PlatformUtils { \npublic static void openEditor ( String contents , String name ) { \nIWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; \nIStorage storage = new StringStorage ( contents , name ) ; \nIStorageEditorInput input = new StringInput ( storage ) ; \nIWorkbenchPage page = window . getActivePage ( ) ; \nIEditorDescriptor desc = PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . getDefaultEditor ( name ) ; \nString editorId = desc != null ? desc . getId ( ) : \"org.eclipse.ui.DefaultTextEditor\" ; \ntry { \nif ( page != null ) { \npage . openEditor ( input , editorId ) ; \n} \n} \ncatch ( Exception e ) { \nActivator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; \n} \nreturn ; \n} \n} \n"}
{"6349": "public class PlatformUtils { \npublic static void reportAuthenticationFailure ( ) { \nDisplay display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; \ndisplay . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \nDisplay display = Display . getCurrent ( ) ; \nShell shell = display . getActiveShell ( ) ; \nMessageDialog . openError ( shell , Messages . getString ( \"login.failure.dialog.caption\" ) , Messages . getString ( \"login.failure.dialog.message\" ) ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6351": "public class KieNavigatorView { \nprivate Control createDefaultPage ( FormToolkit kit ) { \nForm form = kit . createForm ( book ) ; \nComposite body = form . getBody ( ) ; \nGridLayout layout = new GridLayout ( 2 , false ) ; \nbody . setLayout ( layout ) ; \nLink hlink = new Link ( body , SWT . NONE ) ; \nhlink . setText ( \"<a>Use the Servers View to create a new server...</a>\" ) ; \nhlink . setBackground ( book . getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ; \nGridData gd = new GridData ( SWT . LEFT , SWT . FILL , true , false ) ; \nhlink . setLayoutData ( gd ) ; \nhlink . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \nViewUtils . showServersView ( ) ; \nreturn ; \n} \n} \n) ; \nfinal CommonViewer commonViewer = this . getCommonViewer ( ) ; \nif ( commonViewer != null ) { \nICommonViewerSite commonViewerSite = CommonViewerSiteFactory . createCommonViewerSite ( this . getViewSite ( ) ) ; \nif ( commonViewerSite != null ) { \nfinal NavigatorActionService actionService = new NavigatorActionService ( commonViewerSite , commonViewer , commonViewer . getNavigatorContentService ( ) ) ; \nMenuManager menuManager = new MenuManager ( \"#PopupMenu\" ) ; \nmenuManager . addMenuListener ( new IMenuListener ( ) { \npublic void menuAboutToShow ( IMenuManager mgr ) { \nISelection selection = commonViewer . getSelection ( ) ; \nactionService . setContext ( new ActionContext ( selection ) ) ; \nactionService . fillContextMenu ( mgr ) ; \nreturn ; \n} \n} \n) ; \nMenu menu = menuManager . createContextMenu ( body ) ; \nbody . setMenu ( menu ) ; \nhlink . setMenu ( menu ) ; \n} \nelse { \n} \n} \nelse { \n} \nreturn form ; \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) return ; \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal int SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nint size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) { \ntreeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \nreturn ; \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6353": "public class PropertyBehavior { \npublic void setIsKeepAllAlive ( boolean isKeepAllAlive ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyKeepAllAlive = false ; \nif ( isDAVElement ( child , \"keepalive\" ) ) isAlreadyKeepAllAlive = \"*\" . equals ( getFirstText ( child ) ) ; \nif ( isKeepAllAlive ) { \nif ( ! isAlreadyKeepAllAlive ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"keepalive\" , \"*\" ) ; \n} \n} \nelse if ( isAlreadyKeepAllAlive ) root . removeChild ( child ) ; \nreturn ; \n} \n} \n"}
{"6354": "public class PropertyBehavior { \npublic void setIsOmit ( boolean isOmit ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyOmit = isDAVElement ( child , \"omit\" ) ; \nif ( isOmit ) { \nif ( ! isAlreadyOmit ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"omit\" ) ; \n} \n} \nelse if ( isAlreadyOmit ) root . removeChild ( child ) ; \nreturn ; \n} \n} \n"}
{"6356": "public class ConditionTerm { \npublic void addConditionFactor ( ConditionFactor factor ) throws WebDAVException { \nif ( conditionFactors . contains ( factor ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseDuplicateEntry\" ) ) ; \nconditionFactors . addElement ( factor ) ; \nreturn ; \n} \n} \n"}
{"6360": "public class DSLAdapter { \nprivate void loadConfig ( IFile input ) { \nIResource res = findDSLResource ( input , dslConfigName ) ; \nif ( res instanceof IFile ) { \nIFile dslConf = ( IFile ) res ; \nif ( dslConf . exists ( ) ) { \nInputStream stream = null ; \ntry { \nstream = dslConf . getContents ( ) ; \nreadConfig ( stream ) ; \nvalid = true ; \n} \ncatch ( Exception e ) { \nthrow new IllegalStateException ( \"Unable to open DSL config file. (Exception: \" + e . getMessage ( ) + \")\" ) ; \n} \nfinally { \ncloseStream ( stream ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6361": "public class DSLAdapter { \nvoid readConfig ( InputStream stream ) throws IOException , CoreException { \nDSLTokenizedMappingFile file = new DSLTokenizedMappingFile ( ) ; \nfile . parseAndLoad ( new InputStreamReader ( stream ) ) ; \nDSLMapping grammar = file . getMapping ( ) ; \nList < DSLMappingEntry > conditions = grammar . getEntries ( DSLMappingEntry . CONDITION ) ; \nList < DSLMappingEntry > consequences = grammar . getEntries ( DSLMappingEntry . CONSEQUENCE ) ; \nconditionProposals = buildProposals ( conditions ) ; \nconsequenceProposals = buildProposals ( consequences ) ; \ndslTree . buildTree ( grammar ) ; \nreturn ; \n} \n} \n"}
{"6364": "public class HrefSet { \npublic void addHref ( String href ) { \nString encodedHref = encodeHref ( href ) ; \nif ( isDuplicate ( encodedHref ) ) return ; \nappendChild ( root , \"href\" , encodedHref ) ; \nreturn ; \n} \n} \n"}
{"6365": "public class HrefSet { \npublic void insertHrefBefore ( String newHref , String refHref ) { \nString refHrefEncoded = encodeHref ( refHref ) ; \nString newHrefEncoded = encodeHref ( newHref ) ; \nif ( isDuplicate ( newHrefEncoded ) ) return ; \nElement child = getFirstChild ( root , \"href\" ) ; \nwhile ( child != null ) { \nif ( refHrefEncoded . equals ( getFirstText ( child ) ) ) { \ninsertBefore ( child , \"href\" , newHrefEncoded ) ; \nreturn ; \n} \nchild = getNextSibling ( child , \"href\" ) ; \n} \nAssert . isTrue ( false , Policy . bind ( \"assert.noHrefRef\" ) ) ; \nreturn ; \n} \n} \n"}
{"6366": "public class HrefSet { \npublic void removeHref ( String href ) { \nString encodedHref = encodeHref ( href ) ; \nElement child = getFirstChild ( root , \"href\" ) ; \nwhile ( child != null ) { \nif ( encodedHref . equals ( getFirstText ( child ) ) ) { \nroot . removeChild ( child ) ; \nreturn ; \n} \nchild = getNextSibling ( child , \"href\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6374": "public class RequestInputStream { \npublic void reset ( ) throws IOException { \nif ( file == null ) { \n( ( ByteArrayInputStream ) is ) . reset ( ) ; \n} \nelse { \nif ( fos != null ) { \nwhile ( skip ( 4096 ) > 0 ) ; \nfos . close ( ) ; \nfos = null ; \nif ( length == - 1 ) { \nlength = totalBytesRead ; \n} \n} \nis . close ( ) ; \nis = new FileInputStream ( file ) ; \n} \ntotalBytesRead = 0 ; \nreturn ; \n} \n} \n"}
{"6375": "public class AbstractRuleEditor { \nprotected void createActions ( ) { \nsuper . createActions ( ) ; \nIAction a = new TextOperationAction ( RuleEditorMessages . getResourceBundle ( ) , \"ContentAssistProposal.\" , this , ISourceViewer . CONTENTASSIST_PROPOSALS ) ; \na . setActionDefinitionId ( ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ) ; \nsetAction ( \"ContentAssistProposal\" , a ) ; \na = new TextOperationAction ( RuleEditorMessages . getResourceBundle ( ) , \"ContentAssistTip.\" , this , ISourceViewer . CONTENTASSIST_CONTEXT_INFORMATION ) ; \na . setActionDefinitionId ( ITextEditorActionDefinitionIds . CONTENT_ASSIST_CONTEXT_INFORMATION ) ; \nsetAction ( \"ContentAssistTip\" , a ) ; \na = new ToggleBreakpointAction ( getSite ( ) . getPart ( ) , null , getVerticalRuler ( ) ) ; \nsetAction ( ITextEditorActionConstants . RULER_DOUBLE_CLICK , a ) ; \nreturn ; \n} \n} \n"}
{"6376": "public class GraphicalVertex { \npublic void addConnection ( Connection conn ) { \nif ( conn == null || conn . getSource ( ) == conn . getTarget ( ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( conn . getSource ( ) == this ) { \nsourceConnections . add ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse if ( conn . getTarget ( ) == this ) { \ntargetConnections . add ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \nreturn ; \n} \n} \n"}
{"6378": "public class GraphicalVertex { \npublic void removeConnection ( Connection conn ) { \nif ( conn == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( conn . getSource ( ) == this ) { \nsourceConnections . remove ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse if ( conn . getTarget ( ) == this ) { \ntargetConnections . remove ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \nreturn ; \n} \n} \n"}
{"6379": "public class GraphicalVertex { \npublic void setLocation ( Point newLocation ) { \nif ( newLocation == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nlocation . setLocation ( newLocation ) ; \nfirePropertyChange ( LOCATION_PROP , null , location ) ; \nreturn ; \n} \n} \n"}
{"6380": "public class GraphicalVertex { \npublic void setPropertyValue ( Object propertyId , Object value ) { \nif ( XPOS_PROP . equals ( propertyId ) ) { \nint x = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( x , location . y ) ) ; \n} \nelse if ( YPOS_PROP . equals ( propertyId ) ) { \nint y = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( location . x , y ) ) ; \n} \nelse if ( HEIGHT_PROP . equals ( propertyId ) ) { \nint height = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( size . width , height ) ) ; \n} \nelse if ( WIDTH_PROP . equals ( propertyId ) ) { \nint width = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( width , size . height ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6381": "public class GraphicalVertex { \npublic void setSize ( Dimension newSize ) { \nif ( newSize != null ) { \nsize . setSize ( newSize ) ; \nfirePropertyChange ( SIZE_PROP , null , size ) ; \n} \nreturn ; \n} \n} \n"}
{"6386": "public class DroolsEclipsePlugin { \npublic void start ( BundleContext context ) throws Exception { \nsuper . start ( context ) ; \nIPreferenceStore preferenceStore = getPreferenceStore ( ) ; \nuseCachePreference = preferenceStore . getBoolean ( IDroolsConstants . CACHE_PARSED_RULES ) ; \npreferenceStore . addPropertyChangeListener ( new IPropertyChangeListener ( ) { \npublic void propertyChange ( PropertyChangeEvent event ) { \nif ( IDroolsConstants . CACHE_PARSED_RULES . equals ( event . getProperty ( ) ) ) { \nuseCachePreference = ( ( Boolean ) event . getNewValue ( ) ) . booleanValue ( ) ; \nif ( ! useCachePreference ) { \nclearCache ( ) ; \n} \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6387": "public class DroolsEclipsePlugin { \npublic void stop ( BundleContext context ) throws Exception { \nsuper . stop ( context ) ; \nplugin = null ; \nresourceBundle = null ; \nparsedRules = null ; \ncompiledRules = null ; \nprocessInfos = null ; \nprocessInfosById = null ; \nfor ( Color color : colors . values ( ) ) { \ncolor . dispose ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \nfor ( int i = 0 ; \ni < patterns . length ; \ni ++ ) { \nif ( setDateTime ( date , patterns [ i ] ) ) break ; \n} \nreturn ; \n} \n} \n"}
{"6394": "public class Activator { \npublic static void logError ( final String message , final Throwable thr ) { \ngetDefault ( ) . getLog ( ) . log ( error ( message , thr ) ) ; \nreturn ; \n} \n} \n"}
{"6395": "public class FieldEditorPropertyPage { \nprotected void addField ( FieldEditor editor ) { \nif ( fields == null ) { \nfields = new ArrayList < FieldEditor > ( ) ; \n} \nString name = editor . getPreferenceName ( ) ; \neditor . setPreferenceName ( getPreferenceName ( name ) ) ; \nfields . add ( editor ) ; \nreturn ; \n} \n} \n"}
{"6396": "public class FieldEditorPropertyPage { \nprotected void adjustGridLayout ( ) { \nint numColumns = calcNumberOfColumns ( ) ; \n( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; \nif ( fields != null ) { \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nFieldEditor fieldEditor = fields . get ( i ) ; \nfieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6397": "public class FieldEditorPropertyPage { \nprotected void applyFont ( ) { \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nwhile ( e . hasNext ( ) ) { \nFieldEditor pe = e . next ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6399": "public class FieldEditorPropertyPage { \nprotected void initialize ( ) { \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nwhile ( e . hasNext ( ) ) { \nFieldEditor pe = e . next ( ) ; \npe . setPage ( this ) ; \npe . setPropertyChangeListener ( this ) ; \npe . setPreferenceStore ( getPreferenceStore ( ) ) ; \npe . load ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6400": "public class JsonPreferenceStore { \npublic void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { \nPropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; \nObject [ ] listeners = fListeners . getListeners ( ) ; \nfor ( int i = 0 ; \ni < listeners . length ; \ni ++ ) ( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; \nreturn ; \n} \n} \n"}
{"6401": "public class DRLRuleEditorActionContributor { \npublic void setActiveEditor ( IEditorPart part ) { \nsuper . setActiveEditor ( part ) ; \nif ( part instanceof DRLRuleEditor2 ) { \nDRLRuleEditor2 p = ( DRLRuleEditor2 ) part ; \np . setZoomComboContributionItem ( zitem ) ; \np . setZoomInAction ( zoomIn ) ; \np . setZoomOutAction ( zoomOut ) ; \n} \nreturn ; \n} \n} \n"}
{"6402": "public class DRLRuleEditorActionContributor { \npublic void contributeToToolBar ( IToolBarManager toolBarManager ) { \nsuper . contributeToToolBar ( toolBarManager ) ; \ntoolBarManager . add ( new Separator ( ) ) ; \nString [ ] zoomStrings = new String [ ] { \nZoomManager . FIT_ALL , ZoomManager . FIT_HEIGHT , ZoomManager . FIT_WIDTH } \n; \nzitem = new ZoomComboContributionItem ( getPage ( ) , zoomStrings ) ; \nzitem . setZoomManager ( null ) ; \nzitem . setVisible ( false ) ; \nzoomIn = new ZoomInAction2 ( ) ; \nzoomIn . setEnabled ( false ) ; \nzoomOut = new ZoomOutAction2 ( ) ; \nzoomOut . setEnabled ( false ) ; \ntoolBarManager . add ( zitem ) ; \ntoolBarManager . add ( zoomIn ) ; \ntoolBarManager . add ( zoomOut ) ; \nreturn ; \n} \n} \n"}
{"6403": "public class CompletionContext { \nprivate void determineDialect ( String backText ) { \ndialect = null ; \nboolean mvel = MVEL_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nboolean java = JAVA_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nif ( mvel ) { \ndialect = MVEL_DIALECT ; \n} \nelse if ( java ) { \ndialect = JAVA_DIALECT ; \n} \nreturn ; \n} \n} \n"}
{"6405": "public class DSLEditor { \npublic void doSave ( IProgressMonitor monitor ) { \nFileEditorInput input = ( FileEditorInput ) getEditorInput ( ) ; \nFile outputFile = input . getFile ( ) . getLocation ( ) . toFile ( ) ; \nsaveFile ( monitor , outputFile , input ) ; \nreturn ; \n} \n} \n"}
{"6406": "public class DSLEditor { \nprivate void createTableListeners ( ) { \ntable . addSelectionListener ( new SelectionListener ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \npopulate ( ) ; \nreturn ; \n} \npublic void widgetDefaultSelected ( SelectionEvent e ) { \npopulate ( ) ; \nreturn ; \n} \nprivate void populate ( ) { \nDSLMappingEntry selected = getCurrentSelected ( ) ; \nexprText . setText ( selected . getMappingKey ( ) ) ; \nmappingText . setText ( selected . getMappingValue ( ) ) ; \nobjText . setText ( selected . getMetaData ( ) . getMetaData ( ) == null ? \"\" : selected . getMetaData ( ) . getMetaData ( ) ) ; \nreturn ; \n} \n} \n) ; \ntable . addMouseListener ( new MouseListener ( ) { \npublic void mouseDoubleClick ( MouseEvent e ) { \nshowEditPopup ( ) ; \nreturn ; \n} \npublic void mouseDown ( MouseEvent e ) { \nreturn ; \n} \npublic void mouseUp ( MouseEvent e ) { \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6407": "public class DSLEditor { \nprivate void createTable ( Composite parent ) { \nint style = SWT . MULTI | SWT . BORDER | SWT . H_SCROLL | SWT . V_SCROLL | SWT . FULL_SELECTION | SWT . HIDE_SELECTION ; \ntable = new Table ( parent , style ) ; \nGridData gridData = new GridData ( GridData . FILL_BOTH ) ; \ngridData . grabExcessVerticalSpace = true ; \ngridData . horizontalSpan = 3 ; \ntable . setLayoutData ( gridData ) ; \ntable . setLinesVisible ( true ) ; \ntable . setHeaderVisible ( true ) ; \nTableColumn column ; \ncolumn = new TableColumn ( table , SWT . LEFT , 0 ) ; \ncolumn . setText ( \"Language Expression\" ) ; \ncolumn . setWidth ( 350 ) ; \ncolumn . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \ntableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . EXPRESSION ) ) ; \nreturn ; \n} \n} \n) ; \ncolumn = new TableColumn ( table , SWT . LEFT , 1 ) ; \ncolumn . setText ( \"Rule Language Mapping\" ) ; \ncolumn . setWidth ( 200 ) ; \ncolumn . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \ntableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . MAPPING ) ) ; \nreturn ; \n} \n} \n) ; \ncolumn = new TableColumn ( table , SWT . LEFT , 2 ) ; \ncolumn . setText ( \"Object\" ) ; \ncolumn . setWidth ( 80 ) ; \ncolumn = new TableColumn ( table , SWT . LEFT , 3 ) ; \ncolumn . setText ( \"Scope\" ) ; \ncolumn . setWidth ( 80 ) ; \ncolumn . addSelectionListener ( new SelectionAdapter ( ) { \npublic void widgetSelected ( SelectionEvent e ) { \ntableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . SCOPE ) ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6408": "public class URLTable { \npublic void put ( String url , Object value ) throws MalformedURLException { \nAssert . isNotNull ( url ) ; \nAssert . isNotNull ( value ) ; \nput ( new URL ( url ) , value ) ; \nreturn ; \n} \n} \n"}
{"6409": "public class URLTable { \nprivate void put ( URLKey url , Object value ) { \nAssert . isNotNull ( url ) ; \nAssert . isNotNull ( value ) ; \nif ( table . get ( url ) != null ) table . remove ( url ) ; \ntable . put ( url , value ) ; \nreturn ; \n} \n} \n"}
{"6412": "public class DroolsElement { \nvoid setFile ( IFile file , int offset , int length ) { \nthis . file = file ; \nthis . offset = offset ; \nthis . length = length ; \nreturn ; \n} \n} \n"}
{"6413": "public class Precondition { \npublic void addCondition ( Condition condition ) throws WebDAVException { \nEnumeration conditions = getConditions ( ) ; \nif ( condition . getResourceURI ( ) != null ) { \nwhile ( conditions . hasMoreElements ( ) ) { \nCondition existingCondition = ( Condition ) conditions . nextElement ( ) ; \nif ( existingCondition . getResourceURI ( ) != null && existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMultipleSpecification\" , condition . getResourceURI ( ) ) ) ; \n} \n} \nthis . conditions . addElement ( condition ) ; \nreturn ; \n} \n} \n"}
{"6414": "public class Precondition { \npublic void addStateTokenCondition ( String resourceURI , String stateToken ) throws WebDAVException { \nCondition condition = new Condition ( resourceURI ) ; \nConditionTerm term = new ConditionTerm ( ) ; \nterm . addConditionFactor ( new StateToken ( stateToken ) ) ; \ncondition . addConditionTerm ( term ) ; \naddCondition ( condition ) ; \nreturn ; \n} \n} \n"}
{"6424": "public class NewJBPMProjectWizard { \nprivate void createProcess ( IJavaProject project , IProgressMonitor monitor , String exampleType ) throws CoreException , IOException { \nString fileName = \"org/jbpm/eclipse/wizard/project/\" + exampleType + \".bpmn.template\" ; \nIFolder folder = null ; \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/com/sample\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \nIFile file = folder . getFile ( \"sample.bpmn\" ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \nif ( ! file . exists ( ) ) { \nfile . create ( inputstream , true , monitor ) ; \n} \nelse { \nfile . setContents ( inputstream , true , false , monitor ) ; \n} \nfileName = \"org/jbpm/eclipse/wizard/project/ProcessMain-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \nfileName += \".v5.template\" ; \n} \nelse { \nfileName += \".template\" ; \n} \nfolder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; \npackageFragment . createCompilationUnit ( \"ProcessMain.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \nif ( \"advanced\" . equals ( exampleType ) ) { \nfolder = project . getProject ( ) . getFolder ( \"src/main/resources/META-INF\" ) ; \nFileUtils . createFolder ( folder , monitor ) ; \ninputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( \"org/jbpm/eclipse/wizard/project/ProcessLauncher-advanced-persistence.xml.template\" ) ; \nfile = folder . getFile ( \"persistence.xml\" ) ; \nif ( ! file . exists ( ) ) { \nfile . create ( inputstream , true , monitor ) ; \n} \nelse { \nfile . setContents ( inputstream , true , false , monitor ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6425": "public class NewJBPMProjectWizard { \nprivate void createProcessSampleJUnit ( IJavaProject project , String exampleType , IProgressMonitor monitor ) throws JavaModelException , IOException { \nString s = \"org/jbpm/eclipse/wizard/project/ProcessJUnit-\" + exampleType + \".java\" ; \nIRuntime runtime = startPage . getRuntime ( ) ; \nif ( runtime . getVersion ( ) . getMajor ( ) == 5 ) { \ns += \".v5.template\" ; \n} \nelse { \ns += \".template\" ; \n} \nIFolder folder = project . getProject ( ) . getFolder ( \"src/main/java\" ) ; \nIPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; \nIPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( \"com.sample\" , true , monitor ) ; \nInputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( s ) ; \npackageFragment . createCompilationUnit ( \"ProcessTest.java\" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; \nreturn ; \n} \n} \n"}
{"6427": "public class ReteooVisitor { \npublic void visitRete ( final Rete rete ) { \nthis . rootVertex = ( ReteVertex ) this . visitedNodes . get ( dotId ( rete ) ) ; \nif ( this . rootVertex == null ) { \nthis . rootVertex = new ReteVertex ( rete ) ; \nthis . visitedNodes . put ( dotId ( rete ) , this . rootVertex ) ; \n} \nthis . graph . addChild ( this . rootVertex ) ; \nthis . parentVertex = this . rootVertex ; \nfor ( EntryPointNode node : rete . getEntryPointNodes ( ) . values ( ) ) { \nvisit ( node ) ; \n} \nreturn ; \n} \n} \n"}
{"6428": "public class ReteooVisitor { \nprivate void visitNode ( final Object node ) { \nObject realNode = node ; \nif ( node instanceof ObjectHashMap . ObjectEntry ) { \nObjectHashMap . ObjectEntry entry = ( ObjectHashMap . ObjectEntry ) node ; \nrealNode = entry . getValue ( ) ; \n} \nvisit ( realNode ) ; \nreturn ; \n} \n} \n"}
{"6437": "public class DRLRuleEditor2 { \nprotected void addPages ( ) { \ntry { \ntextEditor = new DRLRuleEditor ( ) { \npublic void close ( boolean save ) { \nsuper . close ( save ) ; \nDRLRuleEditor2 . this . close ( save ) ; \nreturn ; \n} \nprotected void setPartName ( String partName ) { \nsuper . setPartName ( partName ) ; \nDRLRuleEditor2 . this . setPartName ( partName ) ; \nreturn ; \n} \n} \n; \nreteViewer = new ReteViewer ( textEditor ) ; \nint text = addPage ( textEditor , getEditorInput ( ) ) ; \nint rete = addPage ( reteViewer , getEditorInput ( ) ) ; \nsetPageText ( text , \"Text Editor\" ) ; \nsetPageText ( rete , \"Rete Tree\" ) ; \ntextEditor . getDocumentProvider ( ) . getDocument ( getEditorInput ( ) ) . addDocumentListener ( new IDocumentListener ( ) { \npublic void documentAboutToBeChanged ( DocumentEvent event ) { \nreturn ; \n} \npublic void documentChanged ( DocumentEvent event ) { \nreteViewer . fireDocumentChanged ( ) ; \nreturn ; \n} \n} \n) ; \n} \ncatch ( PartInitException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"6440": "public class KieServiceDelegate { \npublic String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { \nfinal AtomicReference < String > ar = new AtomicReference < String > ( ) ; \nIWorkbench wb = PlatformUI . getWorkbench ( ) ; \nIProgressService ps = wb . getProgressService ( ) ; \ntry { \nps . busyCursorWhile ( new IRunnableWithProgress ( ) { \npublic void run ( IProgressMonitor pm ) throws InterruptedException { \npm . beginTask ( \"Waiting for Job \" + jobId + \":\\n\\n\" + title , STATUS_REQUEST_TIMEOUT ) ; \npm . subTask ( title ) ; \nlong startTime = System . currentTimeMillis ( ) ; \nlong stopTime = startTime ; \ndo { \ntry { \nThread . sleep ( STATUS_REQUEST_DELAY ) ; \nString response = httpGet ( \"jobs/\" + jobId ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nString result = jo . get ( \"result\" ) . asString ( ) ; \nif ( \"null\" . equals ( result ) ) { \nif ( ! \"SUCCESS\" . equals ( status ) ) result = null ; \n} \nif ( status != null && result != null ) ar . set ( status + \":\" + result ) ; \nstopTime = System . currentTimeMillis ( ) ; \npm . worked ( STATUS_REQUEST_DELAY ) ; \nActivator . println ( \"status=\" + status ) ; \nActivator . println ( \"result=\" + result ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nif ( pm . isCanceled ( ) ) throw new InterruptedException ( \"Operation canceled\" ) ; \n} \nwhile ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; \npm . done ( ) ; \nActivator . println ( \"\\n----------------------------------\\n\" + \"Job \" + jobId + \"\\n\" + title + \"\\ncompleted in \" + ( stopTime - startTime ) / 1000.0 + \" sec\\n\" + \"Status: \" + ar . get ( ) + \"\\n----------------------------------\\n\" ) ; \nreturn ; \n} \n} \n) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \nreturn ar . get ( ) ; \n} \n} \n"}
{"6441": "public class PullOperationUI { \n@ SuppressWarnings ( \"restriction\" ) public void execute ( IProgressMonitor monitor ) { \ntry { \npullOperation . execute ( monitor ) ; \nresults . putAll ( pullOperation . getResults ( ) ) ; \n} \ncatch ( CoreException e ) { \nif ( e . getStatus ( ) . getSeverity ( ) == IStatus . CANCEL ) results . putAll ( pullOperation . getResults ( ) ) ; \nelse repoNode . handleException ( ( Throwable ) e ) ; \n} \nreturn ; \n} \n} \n"}
{"6442": "public class PullOperationUI { \nprivate void handlePullResults ( final Map < Repository , Object > resultsMap ) { \nif ( tasksToWaitFor . decrementAndGet ( ) == 0 && ! results . isEmpty ( ) ) showResults ( ) ; \nreturn ; \n} \n} \n"}
{"6445": "public class AbstractCompletionProcessor { \nprotected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { \nif ( prefix != null && prefix . trim ( ) . length ( ) > 0 ) { \nIterator < ICompletionProposal > iterator = props . iterator ( ) ; \nString prefixLc = prefix . toLowerCase ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nICompletionProposal item = iterator . next ( ) ; \nString content = item . getDisplayString ( ) . toLowerCase ( ) ; \nif ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) { \niterator . remove ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6448": "public class VertexFigure { \npublic void paint ( Graphics g ) { \ng . setAntialias ( SWT . ON ) ; \nRectangle r = getBounds ( ) . getCopy ( ) ; \ng . translate ( r . getLocation ( ) ) ; \ng . setBackgroundColor ( backgroundColor ) ; \ng . setForegroundColor ( borderColor ) ; \ng . fillArc ( 0 , 0 , 15 , 15 , 0 , 360 ) ; \ng . drawArc ( 0 , 0 , 14 , 14 , 0 , 360 ) ; \nsuper . paint ( g ) ; \nreturn ; \n} \n} \n"}
{"6451": "public class DroolsPluginImages { \npublic final static void declareRegistryImage ( String key , String path ) { \nImageDescriptor desc = ImageDescriptor . getMissingImageDescriptor ( ) ; \ntry { \ndesc = ImageDescriptor . createFromURL ( makeIconFileURL ( path ) ) ; \n} \ncatch ( MalformedURLException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nimageRegistry . put ( key , desc ) ; \nreturn ; \n} \n} \n"}
{"6452": "public class RowList { \npublic void add ( final int depth , final BaseVertex vertex ) { \nif ( this . rows . size ( ) < ( depth + 1 ) ) { \nfinal int addRows = depth - this . rows . size ( ) + 1 ; \nfor ( int i = 0 ; \ni < addRows ; \n++ i ) { \nthis . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; \n} \n} \n( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; \nreturn ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \n++ i ) { \nSystem . err . println ( i + \": \" + get ( i ) . getVertices ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6456": "public class RowList { \npublic void optimize ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \n++ i ) { \nget ( i ) . optimize ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6458": "public class ReteViewer { \nprotected void initializeGraphicalViewer ( ) { \nZoomManager zoomManager = rootEditPart . getZoomManager ( ) ; \nList < String > zoomLevels = new ArrayList < String > ( 3 ) ; \nzoomLevels . add ( ZoomManager . FIT_ALL ) ; \nzoomLevels . add ( ZoomManager . FIT_HEIGHT ) ; \nzoomLevels . add ( ZoomManager . FIT_WIDTH ) ; \nzoomManager . setZoomLevelContributions ( zoomLevels ) ; \ngetGraphicalViewer ( ) . setProperty ( MouseWheelHandler . KeyGenerator . getKey ( SWT . MOD1 ) , MouseWheelZoomHandler . SINGLETON ) ; \nreturn ; \n} \n} \n"}
{"6459": "public class ReteViewer { \npublic void drawGraph ( ReteGraph newGraph ) { \nLayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; \nif ( getGraphicalViewer ( ) . getContents ( ) == null ) { \ngetGraphicalViewer ( ) . setContents ( getModel ( ) ) ; \n} \nfinal boolean isNewDiagram = newGraph != null && newGraph != diagram ; \nif ( isNewDiagram ) { \ndiagram . removeAll ( ) ; \n} \nConnectionRouter router ; \nif ( ( isNewDiagram && newGraph . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) || ( ! isNewDiagram && getModel ( ) . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) ) { \nrouter = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; \n} \nelse { \nrouter = ConnectionRouter . NULL ; \n} \nconnLayer . setConnectionRouter ( router ) ; \nif ( newGraph != null && newGraph != diagram ) { \ndiagram . addAll ( newGraph . getChildren ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6461": "public class BaselineControl { \npublic void setHref ( String href ) { \nAssert . isNotNull ( href ) ; \nsetChild ( root , \"href\" , encodeHref ( href ) , childNames , true ) ; \nreturn ; \n} \n} \n"}
{"6463": "public class AbstractResourceHandle { \npublic void copy ( ILocator destination , String depth , boolean overwrite , Collection propertyNames ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setDepth ( depth ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( propertyNames == null ) propertyBehavior . setIsKeepAllAlive ( true ) ; \nelse { \nIterator namesItr = propertyNames . iterator ( ) ; \nwhile ( namesItr . hasNext ( ) ) { \nQualifiedName name = ( QualifiedName ) namesItr . next ( ) ; \nString nameURI = name . getQualifier ( ) + \"/\" + name . getLocalName ( ) ; \npropertyBehavior . addProperty ( nameURI ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . copy ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6464": "public class AbstractResourceHandle { \nprotected void examineMultiStatusResponse ( IResponse response ) throws DAVException { \nif ( response . getStatusCode ( ) != IResponse . SC_MULTI_STATUS ) return ; \nif ( ! response . hasDocumentBody ( ) ) throw new DAVException ( Policy . bind ( \"exception.responseMustHaveDocBody\" ) ) ; \nElement documentElement ; \ntry { \ndocumentElement = response . getDocumentBody ( ) . getDocumentElement ( ) ; \nif ( documentElement == null ) throw new DAVException ( Policy . bind ( \"exception.invalidDoc\" ) ) ; \n} \ncatch ( IOException exception ) { \nthrow new SystemException ( exception ) ; \n} \ntry { \nMultiStatus multistatus = new MultiStatus ( documentElement ) ; \nEnumeration responseEnum = multistatus . getResponses ( ) ; \nwhile ( responseEnum . hasMoreElements ( ) ) { \nResponseBody responseBody = ( ResponseBody ) responseEnum . nextElement ( ) ; \nEnumeration propstatEnum = responseBody . getPropStats ( ) ; \nwhile ( propstatEnum . hasMoreElements ( ) ) { \nPropStat propstat = ( PropStat ) propstatEnum . nextElement ( ) ; \nexamineStatusCode ( propstat . getStatusCode ( ) , propstat . getResponseDescription ( ) ) ; \n} \n} \n} \ncatch ( MalformedElementException e ) { \nthrow new SystemException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"6471": "public class AbstractResourceHandle { \npublic void move ( ILocator destination , boolean overwrite , Enumeration names ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setOverwrite ( overwrite ) ; \nDocument document = newDocument ( ) ; \nPropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; \nif ( names == null ) { \npropertyBehavior . setIsKeepAllAlive ( true ) ; \n} \nelse { \nwhile ( names . hasMoreElements ( ) ) { \nObject obj = names . nextElement ( ) ; \nAssert . isTrue ( obj instanceof QualifiedName , Policy . bind ( \"assert.propNameMustBeEnumOverQual\" ) ) ; \npropertyBehavior . addProperty ( ( ( QualifiedName ) obj ) . getLocalName ( ) ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . move ( locator , destination , context , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6473": "public class AbstractResourceHandle { \npublic void refreshLock ( LockToken lockToken , int timeout ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setTimeout ( timeout ) ; \ncontext . setLockToken ( lockToken . getToken ( ) ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . lock ( locator , context , null ) ; \nexamineResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6474": "public class AbstractResourceHandle { \npublic void removeProperties ( Collection propertyNames ) throws DAVException { \nAssert . isNotNull ( propertyNames ) ; \nif ( propertyNames . isEmpty ( ) ) return ; \nDocument document = newDocument ( ) ; \nPropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; \nProp prop = propertyUpdate . addRemove ( ) ; \nIterator namesItr = propertyNames . iterator ( ) ; \nwhile ( namesItr . hasNext ( ) ) prop . addPropertyName ( ( QualifiedName ) namesItr . next ( ) ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . proppatch ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6475": "public class AbstractResourceHandle { \npublic void removeProperty ( QualifiedName propertyName ) throws DAVException { \nCollection propertyNames = new Vector ( 1 ) ; \npropertyNames . add ( propertyName ) ; \nremoveProperties ( propertyNames ) ; \nreturn ; \n} \n} \n"}
{"6476": "public class AbstractResourceHandle { \npublic void setContent ( String contentType , InputStream input ) throws DAVException { \nIResponse response = null ; \ntry { \nIContext context = newContext ( ) ; \ncontext . setContentType ( contentType ) ; \nresponse = davClient . put ( locator , context , input ) ; \nexamineResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6477": "public class AbstractResourceHandle { \npublic void setProperties ( Collection properties ) throws DAVException { \nAssert . isNotNull ( properties ) ; \nif ( properties . isEmpty ( ) ) return ; \nDocument document = newDocument ( ) ; \nPropertyUpdate propertyUpdate = PropertyUpdate . create ( document ) ; \nProp prop = propertyUpdate . addSet ( ) ; \nIterator propertiesItr = properties . iterator ( ) ; \nwhile ( propertiesItr . hasNext ( ) ) { \nElement element = ( Element ) propertiesItr . next ( ) ; \ntry { \nprop . addProperty ( element ) ; \n} \ncatch ( MalformedElementException exception ) { \nthrow new SystemException ( exception ) ; \n} \n} \nIResponse response = null ; \ntry { \nresponse = davClient . proppatch ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6478": "public class AbstractResourceHandle { \npublic void setProperty ( Element property ) throws DAVException { \nCollection properties = new Vector ( 1 ) ; \nproperties . add ( property ) ; \nsetProperties ( properties ) ; \nreturn ; \n} \n} \n"}
{"6479": "public class AbstractResourceHandle { \npublic void unlock ( LockToken token ) throws DAVException { \nIContext context = newContext ( ) ; \ncontext . setLockToken ( \"<\" + token . getToken ( ) + \">\" ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . unlock ( locator , context ) ; \nexamineResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6480": "public class AbstractResourceHandle { \npublic void update ( ILocator version ) throws DAVException { \nDocument document = newDocument ( ) ; \nUpdate . createVersion ( document , version . getResourceURL ( ) ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . update ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6481": "public class AbstractResourceHandle { \npublic void versionControl ( ) throws DAVException { \nIResponse response = null ; \ntry { \nresponse = davClient . versionControl ( locator , newContext ( ) , null ) ; \nexamineResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6482": "public class AbstractResourceHandle { \npublic void delete ( boolean mustExist ) throws DAVException { \nIResponse response = null ; \ntry { \nresponse = davClient . delete ( locator , newContext ( ) ) ; \nif ( ! mustExist && ( response . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) ) return ; \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException exception ) { \nthrow new SystemException ( exception ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6483": "public class AbstractResourceHandle { \nprotected void examineStatusCode ( int code , String message ) throws WebDAVException { \nif ( code >= 300 && code <= 399 ) throw new RedirectionException ( code , message ) ; \nif ( code >= 400 && code <= 499 ) throw new ClientException ( code , message ) ; \nif ( code >= 500 && code <= 599 ) throw new ServerException ( code , message ) ; \nreturn ; \n} \n} \n"}
{"6485": "public class Request { \npublic void write ( OutputStream os ) throws IOException { \nif ( requestBodyWriter == null ) { \nif ( inputRead ) { \nis . reset ( ) ; \ninputRead = false ; \n} \nsuper . write ( os ) ; \n} \nelse { \nrequestBodyWriter . writeRequestBody ( os ) ; \n} \nreturn ; \n} \n} \n"}
{"6488": "public class PropFind { \npublic void setIsAllProp ( boolean isAllProp ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyAllProp = isDAVElement ( child , \"allprop\" ) ; \nif ( isAllProp ) { \nif ( ! isAlreadyAllProp ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"allprop\" ) ; \n} \n} \nelse if ( isAlreadyAllProp ) root . removeChild ( child ) ; \nreturn ; \n} \n} \n"}
{"6489": "public class PropFind { \npublic void setIsPropName ( boolean isPropName ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyPropName = isDAVElement ( child , \"propname\" ) ; \nif ( isPropName ) { \nif ( ! isAlreadyPropName ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"propname\" ) ; \n} \n} \nelse if ( isAlreadyPropName ) root . removeChild ( child ) ; \nreturn ; \n} \n} \n"}
{"6492": "public class RuleContentOutlinePage { \npublic void update ( ) { \nTreeViewer viewer = getTreeViewer ( ) ; \nif ( viewer != null ) { \nControl control = viewer . getControl ( ) ; \nif ( control != null && ! control . isDisposed ( ) ) { \ninitRules ( ) ; \npopulatePackageTreeNode ( ) ; \nviewer . refresh ( ) ; \ncontrol . setRedraw ( false ) ; \nviewer . expandToLevel ( 2 ) ; \ncontrol . setRedraw ( true ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nint bytesRead = 0 ; \nint totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nwhile ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { \nif ( contentLength == - 1 ) { \nbytesRead = is . read ( buffer ) ; \n} \nelse { \nbytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \n} \nif ( bytesRead == - 1 ) { \nif ( contentLength >= 0 ) { \nthrow new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \n} \n} \nelse { \ntotalBytesRead += bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \nreturn ; \n} \n} \n"}
{"6494": "public class DroolsThread { \npublic synchronized void stepOver ( ) throws DebugException { \nif ( ! ( getTopStackFrame ( ) instanceof MVELStackFrame ) ) { \nsuper . stepOver ( ) ; \nreturn ; \n} \nMVELStackFrame mvelStack = ( MVELStackFrame ) getTopStackFrame ( ) ; \nif ( ! canStepOver ( ) || ! mvelStack . canStepOver ( ) ) { \nreturn ; \n} \nif ( ! setRemoteOnBreakReturn ( Debugger . STEP ) ) { \nreturn ; \n} \nsetRunning ( true ) ; \npreserveStackFrames ( ) ; \nfireEvent ( new DebugEvent ( this , DebugEvent . RESUME , DebugEvent . STEP_OVER ) ) ; \ntry { \ngetUnderlyingThread ( ) . resume ( ) ; \n} \ncatch ( RuntimeException e ) { \ntargetRequestFailed ( MessageFormat . format ( JDIDebugModelMessages . JDIThread_exception_stepping , e . toString ( ) ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"6495": "public class DroolsBuilder { \nprotected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { \nfor ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nObject error = iter . next ( ) ; \nif ( error instanceof ParserError ) { \nParserError err = ( ParserError ) error ; \nmarkers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; \n} \nelse if ( error instanceof KnowledgeBuilderResult ) { \nKnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; \nint [ ] errorLines = res . getLines ( ) ; \nmarkers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; \n} \nelse if ( error instanceof ExpanderException ) { \nExpanderException exc = ( ExpanderException ) error ; \nmarkers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; \n} \nelse { \nmarkers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6496": "public class Parser { \npublic void skipWhiteSpace ( ) { \nwhile ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) ++ pos ; \nreturn ; \n} \n} \n"}
{"6498": "public class GuvnorMetadataUtils { \npublic static void commitFileChanges ( IFile selectedFile ) { \ntry { \nGuvnorMetadataProps props = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; \nIWebDavClient client = WebDavServerCache . getWebDavClient ( props . getRepository ( ) ) ; \nif ( client == null ) { \nclient = WebDavClientFactory . createClient ( new URL ( props . getRepository ( ) ) ) ; \nWebDavServerCache . cacheWebDavClient ( props . getRepository ( ) , client ) ; \n} \nResourceProperties remoteProps = null ; \ntry { \nremoteProps = client . queryProperties ( props . getFullpath ( ) ) ; \n} \ncatch ( WebDavException wde ) { \nif ( wde . getErrorCode ( ) != IResponse . SC_UNAUTHORIZED ) { \nthrow wde ; \n} \nboolean retry = PlatformUtils . getInstance ( ) . authenticateForServer ( props . getRepository ( ) , client ) ; \nif ( retry ) { \nremoteProps = client . queryProperties ( props . getFullpath ( ) ) ; \n} \n} \nif ( remoteProps == null ) { \nthrow new Exception ( \"Could not retrieve server version of \" + props . getFullpath ( ) ) ; \n} \nboolean proceed = true ; \nif ( ! props . getRevision ( ) . equals ( remoteProps . getRevision ( ) ) ) { \nString msg = MessageFormat . format ( Messages . getString ( \"overwrite.confirmation\" ) , new Object [ ] { \nselectedFile . getName ( ) , remoteProps . getRevision ( ) , props . getRevision ( ) } \n) ; \nDisplay display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; \nproceed = MessageDialog . openQuestion ( display . getActiveShell ( ) , Messages . getString ( \"overwrite.confirmation.caption\" ) , msg ) ; \n} \nif ( proceed ) { \nclient . putResource ( props . getFullpath ( ) , selectedFile . getContents ( ) ) ; \nGuvnorMetadataUtils . markCurrentGuvnorResource ( selectedFile ) ; \nResourceProperties resProps = client . queryProperties ( props . getFullpath ( ) ) ; \nGuvnorMetadataProps mdProps = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; \nmdProps . setVersion ( resProps . getLastModifiedDate ( ) ) ; \nmdProps . setRevision ( resProps . getRevision ( ) ) ; \nGuvnorMetadataUtils . setGuvnorMetadataProps ( selectedFile . getFullPath ( ) , mdProps ) ; \n} \n} \ncatch ( Exception e ) { \nActivator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; \n} \nreturn ; \n} \n} \n"}
{"6505": "public class Context { \npublic void put ( String key , String value ) { \nContextKey ckey = new ContextKey ( key ) ; \nif ( ( value == null ) || ( value . length ( ) == 0 ) ) properties . remove ( ckey ) ; \nelse properties . put ( ckey , value ) ; \nreturn ; \n} \n} \n"}
{"6506": "public class Context { \npublic void setTimeout ( int value ) { \nif ( value == - 1 ) put ( TIMEOUT , \"\" ) ; \nelse put ( TIMEOUT , ( value == - 2 ) ? DEPTH_INFINITY : \"Second-\" + Integer . toString ( value ) ) ; \nreturn ; \n} \n} \n"}
{"6508": "public class DSLTree { \nprotected void parseFile ( BufferedReader reader ) { \nString line = null ; \ntry { \nwhile ( ( line = reader . readLine ( ) ) != null ) { \nSection section = getSection ( line ) ; \nString nl = stripHeadingAndCode ( line ) ; \nString objname = this . getObjMetadata ( nl ) ; \nnl = this . stripObjMetadata ( nl ) ; \naddEntry ( section , nl , objname ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6511": "public class DSLTree { \npublic void addTokens ( String [ ] tokens , Node rootNode ) { \nNode thenode = rootNode ; \nfor ( int i = 0 ; \ni < tokens . length ; \ni ++ ) { \nNode newnode = thenode . addToken ( tokens [ i ] ) ; \nthenode = newnode ; \n} \nreturn ; \n} \n} \n"}
{"6514": "public class DSLTree { \npublic void addChildToList ( Node n , String prefix , ArrayList < String > list ) { \nif ( n . getChildren ( ) . size ( ) > 0 ) { \nfor ( Node child : n . getChildren ( ) ) { \nif ( prefix != null && \"-\" . equals ( child . getToken ( ) ) ) { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \nreturn ; \n} \nString text = ( prefix == null ? \"\" : prefix + \" \" ) + child . getToken ( ) ; \naddChildToList ( child , text , list ) ; \n} \n} \nelse { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6515": "public class DSLTree { \npublic void printTree ( ) { \nSystem . out . println ( \"ROOT\" ) ; \nfor ( Node n : rootCond . getChildren ( ) ) { \nprintNode ( n ) ; \n} \nreturn ; \n} \n} \n"}
{"6516": "public class DSLTree { \nprotected void printNode ( Node n ) { \nprintTabs ( n . getDepth ( ) ) ; \nSystem . out . println ( \"- \\\"\" + n . getToken ( ) + \"\\\"\" ) ; \nfor ( Node c : n . getChildren ( ) ) { \nprintNode ( c ) ; \n} \nreturn ; \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \nfor ( int idx = 0 ; \nidx < count ; \nidx ++ ) { \nSystem . out . print ( tab ) ; \n} \nreturn ; \n} \n} \n"}
{"6521": "public class HttpConnection { \npublic void setRequestHeaderField ( String fieldName , String fieldValue ) { \nAssert . isNotNull ( fieldName ) ; \nAssert . isNotNull ( fieldValue ) ; \nendRequest ( ) ; \nrequestHeader . addField ( fieldName , fieldValue ) ; \nreturn ; \n} \n} \n"}
{"6522": "public class NewDroolsProjectWizard { \nprivate void createRuleSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse if ( version . getMajor ( ) == 5 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse if ( version . getMajor ( ) >= 6 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template\" , \"DroolsTest.java\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6523": "public class NewDroolsProjectWizard { \nprivate void createRule ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nif ( startPage . getRuntime ( ) . getVersion ( ) . getMajor ( ) >= 6 ) { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/rules\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/resources/com/sample/rules\" , \"Sample.drl\" ) ; \n} \nelse { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/rules\" , \"Sample.drl\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6524": "public class NewDroolsProjectWizard { \nprivate void createRuleFlow ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rfm.template\" , \"src/main/rules\" , \"ruleflow.rfm\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.drl.template\" , \"src/main/rules\" , \"ruleflow.drl\" ) ; \n} \nelse if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \n} \nelse if ( version . getMajor ( ) == 5 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/rules\" , \"sample.bpmn\" ) ; \n} \nelse { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/process\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/resources/com/sample/process\" , \"sample.bpmn\" ) ; \n} \nreturn ; \n} \n} \n"}
{"6525": "public class NewDroolsProjectWizard { \nprivate void createRuleFlowSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nString s ; \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ns = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample_4.java.template\" ; \n} \nelse if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) { \ns = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample.java.template\" ; \n} \nelse if ( version . getMajor ( ) == 5 ) { \ns = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_5.java.template\" ; \n} \nelse { \ns = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_6.java.template\" ; \n} \ncreateProjectJavaFile ( project , s , \"ProcessTest.java\" ) ; \nreturn ; \n} \n} \n"}
{"6527": "public class GenericModelEditor { \npublic void createImage ( OutputStream stream , int format ) { \nSWTGraphics g = null ; \nGC gc = null ; \nImage image = null ; \nLayerManager layerManager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nIFigure figure = layerManager . getLayer ( LayerConstants . PRINTABLE_LAYERS ) ; \nRectangle r = figure . getBounds ( ) ; \ntry { \nimage = new Image ( Display . getDefault ( ) , r . width , r . height ) ; \ngc = new GC ( image ) ; \ng = new SWTGraphics ( gc ) ; \ng . translate ( r . x * - 1 , r . y * - 1 ) ; \nfigure . paint ( g ) ; \nImageLoader imageLoader = new ImageLoader ( ) ; \nimageLoader . data = new ImageData [ ] { \nimage . getImageData ( ) } \n; \nimageLoader . save ( stream , format ) ; \n} \ncatch ( Throwable t ) { \nDroolsEclipsePlugin . log ( t ) ; \n} \nfinally { \nif ( g != null ) { \ng . dispose ( ) ; \n} \nif ( gc != null ) { \ngc . dispose ( ) ; \n} \nif ( image != null ) { \nimage . dispose ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6531": "public class WebDavClient { \nprivate void addGuvnorResourceProperties ( ResourceProperties props , String filename , String resource ) throws Exception { \nif ( props == null ) { \nreturn ; \n} \nIResponse response = null ; \ntry { \nString path = resource . substring ( 0 , resource . lastIndexOf ( '/' ) ) ; \nString apiVer = changeToAPICall ( path ) ; \nProperties guvProps = new Properties ( ) ; \nresponse = getResourceInputStream ( apiVer ) ; \nguvProps . load ( response . getInputStream ( ) ) ; \nString val = guvProps . getProperty ( filename ) ; \nif ( val != null ) { \nStringTokenizer tokens = new StringTokenizer ( val , \",\" ) ; \nif ( tokens . hasMoreElements ( ) ) { \nprops . setLastModifiedDate ( tokens . nextToken ( ) ) ; \n} \nif ( tokens . hasMoreElements ( ) ) { \nprops . setRevision ( tokens . nextToken ( ) ) ; \n} \n} \nelse { \nException nfe = new Exception ( \"Failed to get Guvnor properties for \" + filename ) ; \nActivator . getDefault ( ) . writeLog ( IStatus . WARNING , nfe . getMessage ( ) , nfe ) ; \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6532": "public class CollectionHandle { \npublic void baselineControl ( ILocator baseline ) throws DAVException { \nAssert . isNotNull ( baseline ) ; \nDocument document = newDocument ( ) ; \nElement root = ElementEditor . create ( document , \"baseline-control\" ) ; \nElementEditor . addChild ( root , \"baseline\" , baseline . getResourceURL ( ) , new String [ ] { \n\"baseline\" } \n, true ) ; \nIResponse response = null ; \ntry { \nresponse = davClient . baselineControl ( locator , newContext ( ) , document ) ; \nexamineResponse ( response ) ; \n} \ncatch ( IOException e ) { \nthrow new SystemException ( e ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \nreturn ; \n} \n} \n"}
{"6533": "public class CollectionHandle { \npublic void bind ( String member , ILocator source ) throws DAVException { \nbind ( member , source , false ) ; \nreturn ; \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nint v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nint v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v1OutDegree < v2OutDegree ) { \nreturn 1 ; \n} \nif ( v1OutDegree > v2OutDegree ) { \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \nfor ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nvertexIter . hasNext ( ) ; \n) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( front ) { \noptimized . addFirst ( vertex ) ; \n} \nelse { \noptimized . addLast ( vertex ) ; \n} \nfront = ! front ; \n} \nthis . vertices = optimized ; \nreturn ; \n} \n} \n"}
{"6536": "public class ExportImageDialog { \nprivate void initializeControls ( ) { \nif ( originalFile != null ) { \nresourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; \nString fileName = originalFile . getName ( ) ; \nint index = fileName . lastIndexOf ( \".\" ) ; \nif ( index != - 1 ) { \nfileName = fileName . substring ( 0 , index ) ; \n} \nfileName += \"-image.png\" ; \nresourceGroup . setResource ( fileName ) ; \n} \nelse if ( originalName != null ) { \nresourceGroup . setResource ( originalName ) ; \n} \nsetDialogComplete ( validatePage ( ) ) ; \nreturn ; \n} \n} \n"}
{"6543": "public class YubikeyToUserMapImpl { \nprivate void add_yubikey_to_user ( String publicId , String username , String filename ) { \ntry { \nFile file = new File ( filename ) ; \nFileWriter writer = new FileWriter ( file , true ) ; \nwriter . write ( \"yk.\" + publicId + \".user = \" + username + System . getProperty ( \"line.separator\" ) ) ; \nwriter . close ( ) ; \n} \ncatch ( IOException ex ) { \nlog . error ( \"Failed appending entry to file {}\" , filename , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"6545": "public class MultiValuePasswordCallback { \npublic void clearPassword ( ) { \nfor ( char pw [ ] : this . secrets ) { \nfor ( int i = 0 ; \ni < pw . length ; \ni ++ ) { \npw [ i ] = 0 ; \n} \n} \nthis . secrets = new ArrayList < char [ ] > ( ) ; \nreturn ; \n} \n} \n"}
{"6550": "public class OgnlRuntime { \npublic static void clearCache ( ) { \n_methodParameterTypesCache . clear ( ) ; \n_ctorParameterTypesCache . clear ( ) ; \n_propertyDescriptorCache . clear ( ) ; \n_constructorCache . clear ( ) ; \n_staticMethodCache . clear ( ) ; \n_instanceMethodCache . clear ( ) ; \n_invokePermissionCache . clear ( ) ; \n_fieldCache . clear ( ) ; \n_superclasses . clear ( ) ; \n_declaredMethods [ 0 ] . clear ( ) ; \n_declaredMethods [ 1 ] . clear ( ) ; \n_methodAccessCache . clear ( ) ; \n_methodPermCache . clear ( ) ; \nreturn ; \n} \n} \n"}
{"6563": "public class OgnlParser { \nfinal public void projection ( ) throws ParseException { \nASTProject jjtn000 = new ASTProject ( JJTPROJECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse { \njjtree . popNode ( ) ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6564": "public class OgnlParser { \nfinal public void selectAll ( ) throws ParseException { \nASTSelect jjtn000 = new ASTSelect ( JJTSELECT ) ; \nboolean jjtc000 = true ; \njjtree . openNodeScope ( jjtn000 ) ; \ntry { \njj_consume_token ( 54 ) ; \njj_consume_token ( 3 ) ; \nexpression ( ) ; \njj_consume_token ( 55 ) ; \n} \ncatch ( Throwable jjte000 ) { \nif ( jjtc000 ) { \njjtree . clearNodeScope ( jjtn000 ) ; \njjtc000 = false ; \n} \nelse { \njjtree . popNode ( ) ; \n} \nif ( jjte000 instanceof RuntimeException ) { \n{ \nif ( true ) throw ( RuntimeException ) jjte000 ; \n} \n} \nif ( jjte000 instanceof ParseException ) { \n{ \nif ( true ) throw ( ParseException ) jjte000 ; \n} \n} \n{ \nif ( true ) throw ( Error ) jjte000 ; \n} \n} \nfinally { \nif ( jjtc000 ) { \njjtree . closeNodeScope ( jjtn000 , true ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse ++ newSize ; \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \nfor ( int k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \n++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n} \nelse newChildren [ j ++ ] = c ; \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \nreturn ; \n} \n} \n"}
{"6580": "public class Evaluation { \npublic void init ( SimpleNode node , Object source , boolean setOperation ) { \nthis . node = node ; \nthis . source = source ; \nthis . setOperation = setOperation ; \nresult = null ; \nexception = null ; \nparent = null ; \nnext = null ; \nprevious = null ; \nfirstChild = null ; \nlastChild = null ; \nreturn ; \n} \n} \n"}
{"6582": "public class Ognl { \npublic static void setRoot ( Map context , Object root ) { \ncontext . put ( OgnlContext . ROOT_CONTEXT_KEY , root ) ; \nreturn ; \n} \n} \n"}
{"6584": "public class Ognl { \npublic static void setValue ( ExpressionAccessor expression , OgnlContext context , Object root , Object value ) { \nexpression . set ( context , root , value ) ; \nreturn ; \n} \n} \n"}
{"6585": "public class Ognl { \npublic static void setValue ( Object tree , Object root , Object value ) throws OgnlException { \nsetValue ( tree , createDefaultContext ( root ) , root , value ) ; \nreturn ; \n} \n} \n"}
{"6588": "public class AbstractPlay2StartServerMojo { \nprotected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { \nlong endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; \nboolean started = false ; \nURL connectUrl = new URL ( rootUrl ) ; \nint verifyWaitDelay = 1000 ; \nwhile ( ! started ) { \nif ( startTimeout > 0 && endTimeMillis - System . currentTimeMillis ( ) < 0L ) { \nif ( spawned ) { \nInternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; \ninternalStop . project = project ; \ntry { \ninternalStop . execute ( ) ; \n} \ncatch ( MojoExecutionException e ) { \n} \ncatch ( MojoFailureException e ) { \n} \n} \nthrow new MojoExecutionException ( String . format ( \"Failed to start Play! server in %d ms\" , Integer . valueOf ( startTimeout ) ) ) ; \n} \nBuildException runnerException = runner . getException ( ) ; \nif ( runnerException != null ) { \nthrow new MojoExecutionException ( \"Play! server start exception\" , runnerException ) ; \n} \ntry { \nURLConnection conn = connectUrl . openConnection ( ) ; \nif ( startTimeout > 0 ) { \nint connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; \nif ( connectTimeOut > 0 ) { \nconn . setConnectTimeout ( connectTimeOut ) ; \n} \n} \nconnectUrl . openConnection ( ) . getContent ( ) ; \nstarted = true ; \n} \ncatch ( Exception e ) { \n} \nif ( ! started ) { \nlong sleepTime = verifyWaitDelay ; \nif ( startTimeout > 0 ) { \nsleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; \n} \nif ( sleepTime > 0 ) { \ntry { \nThread . sleep ( sleepTime ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new MojoExecutionException ( \"?\" , e ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6592": "public class AbstractArchivingMojo { \nprotected void checkArchiverForProblems ( Archiver archiver ) { \nfor ( ResourceIterator iter = archiver . getResources ( ) ; \niter . hasNext ( ) ; \n) { \niter . next ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6595": "public class AbstractAntJavaBasedPlay2Mojo { \nprotected void addSystemProperty ( Java java , String propertyName , String propertyValue ) { \nEnvironment . Variable sysPropPlayHome = new Environment . Variable ( ) ; \nsysPropPlayHome . setKey ( propertyName ) ; \nsysPropPlayHome . setValue ( propertyValue ) ; \njava . addSysproperty ( sysPropPlayHome ) ; \nreturn ; \n} \n} \n"}
{"6596": "public class AbstractAntJavaBasedPlay2Mojo { \nprotected void addSystemProperty ( Java java , String propertyName , File propertyValue ) { \nEnvironment . Variable sysPropPlayHome = new Environment . Variable ( ) ; \nsysPropPlayHome . setKey ( propertyName ) ; \nsysPropPlayHome . setFile ( propertyValue ) ; \njava . addSysproperty ( sysPropPlayHome ) ; \nreturn ; \n} \n} \n"}
{"6597": "public class DirectoryChooserFragment { \nprivate void openNewFolderDialog ( ) { \n@ SuppressLint ( \"InflateParams\" ) final View dialogView = getActivity ( ) . getLayoutInflater ( ) . inflate ( R . layout . dialog_new_folder , null ) ; \nfinal TextView msgView = ( TextView ) dialogView . findViewById ( R . id . msgText ) ; \nfinal EditText editText = ( EditText ) dialogView . findViewById ( R . id . editText ) ; \neditText . setText ( mNewDirectoryName ) ; \nmsgView . setText ( getString ( R . string . create_folder_msg , mNewDirectoryName ) ) ; \nfinal AlertDialog alertDialog = new AlertDialog . Builder ( getActivity ( ) ) . setTitle ( R . string . create_folder_label ) . setView ( dialogView ) . setNegativeButton ( R . string . cancel_label , new DialogInterface . OnClickListener ( ) { \n@ Override public void onClick ( final DialogInterface dialog , final int which ) { \ndialog . dismiss ( ) ; \nreturn ; \n} \n} \n) . setPositiveButton ( R . string . confirm_label , new DialogInterface . OnClickListener ( ) { \n@ Override public void onClick ( final DialogInterface dialog , final int which ) { \ndialog . dismiss ( ) ; \nmNewDirectoryName = editText . getText ( ) . toString ( ) ; \nfinal int msg = createFolder ( ) ; \nToast . makeText ( getActivity ( ) , msg , Toast . LENGTH_SHORT ) . show ( ) ; \nreturn ; \n} \n} \n) . show ( ) ; \nalertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( editText . getText ( ) . length ( ) != 0 ) ; \neditText . addTextChangedListener ( new TextWatcher ( ) { \n@ Override public void beforeTextChanged ( final CharSequence charSequence , final int i , final int i2 , final int i3 ) { \nreturn ; \n} \n@ Override public void onTextChanged ( final CharSequence charSequence , final int i , final int i2 , final int i3 ) { \nfinal boolean textNotEmpty = charSequence . length ( ) != 0 ; \nalertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( textNotEmpty ) ; \nmsgView . setText ( getString ( R . string . create_folder_msg , charSequence . toString ( ) ) ) ; \nreturn ; \n} \n@ Override public void afterTextChanged ( final Editable editable ) { \nreturn ; \n} \n} \n) ; \neditText . setVisibility ( mConfig . allowNewDirectoryNameModification ( ) ? View . VISIBLE : View . GONE ) ; \nreturn ; \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nelse if ( ! dir . isDirectory ( ) ) { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories ++ ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( int i = 0 , counter = 0 ; \ni < numDirectories ; \ncounter ++ ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \n} \nrefreshButtonState ( ) ; \nreturn ; \n} \n} \n"}
{"6599": "public class DirectoryChooserFragment { \nprivate void refreshButtonState ( ) { \nfinal Activity activity = getActivity ( ) ; \nif ( activity != null && mSelectedDir != null ) { \nmBtnConfirm . setEnabled ( isValidFile ( mSelectedDir ) ) ; \ngetActivity ( ) . invalidateOptionsMenu ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6600": "public class DirectoryChooserFragment { \nprivate FileObserver createFileObserver ( final String path ) { \nreturn new FileObserver ( path , FileObserver . CREATE | FileObserver . DELETE | FileObserver . MOVED_FROM | FileObserver . MOVED_TO ) { \n@ Override public void onEvent ( final int event , final String path ) { \ndebug ( \"FileObserver received event %d\" , event ) ; \nfinal Activity activity = getActivity ( ) ; \nif ( activity != null ) { \nactivity . runOnUiThread ( new Runnable ( ) { \n@ Override public void run ( ) { \nrefreshDirectory ( ) ; \nreturn ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n; \n} \n} \n"}
{"6601": "public class DirectoryChooserFragment { \nprivate void returnSelectedFolder ( ) { \nif ( mSelectedDir != null ) { \ndebug ( \"Returning %s as result\" , mSelectedDir . getAbsolutePath ( ) ) ; \nmListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { \n@ Override public void apply ( final OnFragmentInteractionListener f ) { \nf . onSelectDirectory ( mSelectedDir . getAbsolutePath ( ) ) ; \nreturn ; \n} \n} \n) ; \n} \nelse { \nmListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { \n@ Override public void apply ( final OnFragmentInteractionListener f ) { \nf . onCancelChooser ( ) ; \nreturn ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"6604": "public class MonitoredActivity { \npublic void startBackgroundJob ( int msgId , Runnable runnable ) { \nProgressDialog dialog = ProgressDialog . show ( this , null , getString ( msgId ) , true , false ) ; \nJob < Object > managedJob = new Job < Object > ( runnable , dialog ) ; \nmanagedJob . runBackgroundJob ( ) ; \nreturn ; \n} \n} \n"}
{"6605": "public class ConverterHtmlToSpanned { \nprivate void startList ( boolean isOrderedList , Attributes attributes ) { \nboolean isIndentation = isIndentation ( attributes ) ; \nParagraphType newType = isIndentation && isOrderedList ? ParagraphType . INDENTATION_OL : isIndentation && ! isOrderedList ? ParagraphType . INDENTATION_UL : isOrderedList ? ParagraphType . NUMBERING : ParagraphType . BULLET ; \nAccumulatedParagraphStyle currentStyle = mParagraphStyles . isEmpty ( ) ? null : mParagraphStyles . peek ( ) ; \nif ( currentStyle == null ) { \nAccumulatedParagraphStyle newStyle = new AccumulatedParagraphStyle ( newType , 1 , 1 ) ; \nmParagraphStyles . push ( newStyle ) ; \n} \nelse if ( currentStyle . getType ( ) == newType ) { \ncurrentStyle . setAbsoluteIndent ( currentStyle . getAbsoluteIndent ( ) + 1 ) ; \ncurrentStyle . setRelativeIndent ( currentStyle . getRelativeIndent ( ) + 1 ) ; \n} \nelse { \nAccumulatedParagraphStyle newStyle = new AccumulatedParagraphStyle ( newType , currentStyle . getAbsoluteIndent ( ) + 1 , 1 ) ; \nmParagraphStyles . push ( newStyle ) ; \n} \nreturn ; \n} \n} \n"}
{"6606": "public class ConverterHtmlToSpanned { \nprivate void endList ( boolean orderedList ) { \nif ( ! mParagraphStyles . isEmpty ( ) ) { \nAccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; \nParagraphType type = style . getType ( ) ; \nif ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { \nint indent = style . getRelativeIndent ( ) ; \nif ( indent > 1 ) { \nstyle . setRelativeIndent ( indent - 1 ) ; \nstyle . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; \n} \nelse { \nmParagraphStyles . pop ( ) ; \n} \n} \nelse { \nmParagraphStyles . pop ( ) ; \nendList ( orderedList ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6607": "public class HighlightView { \nvoid handleMotion ( int edge , float dx , float dy ) { \nRect r = computeLayout ( ) ; \nif ( edge == GROW_NONE ) { \nreturn ; \n} \nelse if ( edge == MOVE ) { \nmoveBy ( dx * ( mCropRect . width ( ) / r . width ( ) ) , dy * ( mCropRect . height ( ) / r . height ( ) ) ) ; \n} \nelse { \nif ( ( ( GROW_LEFT_EDGE | GROW_RIGHT_EDGE ) & edge ) == 0 ) { \ndx = 0 ; \n} \nif ( ( ( GROW_TOP_EDGE | GROW_BOTTOM_EDGE ) & edge ) == 0 ) { \ndy = 0 ; \n} \nfloat xDelta = dx * ( mCropRect . width ( ) / r . width ( ) ) ; \nfloat yDelta = dy * ( mCropRect . height ( ) / r . height ( ) ) ; \ngrowBy ( ( ( ( edge & GROW_LEFT_EDGE ) != 0 ) ? - 1 : 1 ) * xDelta , ( ( ( edge & GROW_TOP_EDGE ) != 0 ) ? - 1 : 1 ) * yDelta ) ; \n} \nreturn ; \n} \n} \n"}
{"6610": "public class RTEditText { \nvoid register ( RTEditTextListener listener , RTMediaFactory < RTImage , RTAudio , RTVideo > mediaFactory ) { \nmListener = listener ; \nmMediaFactory = mediaFactory ; \nreturn ; \n} \n} \n"}
{"6611": "public class RTEditText { \nprivate void addSpanWatcher ( ) { \nSpannable spannable = getText ( ) ; \nif ( spannable . getSpans ( 0 , spannable . length ( ) , getClass ( ) ) != null ) { \nspannable . setSpan ( this , 0 , spannable . length ( ) , Spanned . SPAN_INCLUSIVE_INCLUSIVE ) ; \n} \nreturn ; \n} \n} \n"}
{"6615": "public class ConverterSpannedToHtml { \nprivate void withinParagraph ( final Spanned text , int start , int end ) { \nSortedSet < CharacterStyle > sortedSpans = new TreeSet < > ( ( s1 , s2 ) -> { \nint start1 = text . getSpanStart ( s1 ) ; \nint start2 = text . getSpanStart ( s2 ) ; \nif ( start1 != start2 ) return start1 - start2 ; \nint end1 = text . getSpanEnd ( s1 ) ; \nint end2 = text . getSpanEnd ( s2 ) ; \nif ( end1 != end2 ) return end2 - end1 ; \nreturn s1 . getClass ( ) . getName ( ) . compareTo ( s2 . getClass ( ) . getName ( ) ) ; \n} \n) ; \nList < CharacterStyle > spanList = Arrays . asList ( text . getSpans ( start , end , CharacterStyle . class ) ) ; \nsortedSpans . addAll ( spanList ) ; \nconvertText ( text , start , end , sortedSpans ) ; \nreturn ; \n} \n} \n"}
{"6620": "public class ElementType { \npublic void setAttribute ( AttributesImpl atts , String name , String type , String value ) { \nif ( name . equals ( \"xmlns\" ) || name . startsWith ( \"xmlns:\" ) ) { \nreturn ; \n} \n; \nString namespace = namespace ( name , true ) ; \nString localName = localName ( name ) ; \nint i = atts . getIndex ( name ) ; \nif ( i == - 1 ) { \nname = name . intern ( ) ; \nif ( type == null ) type = \"CDATA\" ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . addAttribute ( namespace , localName , name , type , value ) ; \n} \nelse { \nif ( type == null ) type = atts . getType ( i ) ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . setAttribute ( i , namespace , localName , name , type , value ) ; \n} \nreturn ; \n} \n} \n"}
{"6621": "public class ElementType { \npublic void setAttribute ( String name , String type , String value ) { \nsetAttribute ( theAtts , name , type , value ) ; \nreturn ; \n} \n} \n"}
{"6624": "public class ByteArrayOutputStream { \nprivate void needNewBuffer ( int newcount ) { \nif ( currentBufferIndex < buffers . size ( ) - 1 ) { \nfilledBufferSum += currentBuffer . length ; \ncurrentBufferIndex ++ ; \ncurrentBuffer = buffers . get ( currentBufferIndex ) ; \n} \nelse { \nint newBufferSize ; \nif ( currentBuffer == null ) { \nnewBufferSize = newcount ; \nfilledBufferSum = 0 ; \n} \nelse { \nnewBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; \nfilledBufferSum += currentBuffer . length ; \n} \ncurrentBufferIndex ++ ; \ncurrentBuffer = new byte [ newBufferSize ] ; \nbuffers . add ( currentBuffer ) ; \n} \nreturn ; \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nelse if ( len == 0 ) { \nreturn ; \n} \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nwhile ( remaining > 0 ) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \nreturn ; \n} \n} \n"}
{"6626": "public class ByteArrayOutputStream { \n@ Override public synchronized void write ( int b ) { \nint inBufferPos = count - filledBufferSum ; \nif ( inBufferPos == currentBuffer . length ) { \nneedNewBuffer ( count + 1 ) ; \ninBufferPos = 0 ; \n} \ncurrentBuffer [ inBufferPos ] = ( byte ) b ; \ncount ++ ; \nreturn ; \n} \n} \n"}
{"6628": "public class ByteArrayOutputStream { \npublic synchronized void writeTo ( OutputStream out ) throws IOException { \nint remaining = count ; \nfor ( byte [ ] buf : buffers ) { \nint c = Math . min ( buf . length , remaining ) ; \nout . write ( buf , 0 , c ) ; \nremaining -= c ; \nif ( remaining == 0 ) { \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) { \nif ( size <= 0 ) { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \nelse { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \nfor ( int pos = 0 ; \npos < mFontSizeAdapter . getCount ( ) ; \npos ++ ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6632": "public class CropImageView { \nprivate void recomputeFocus ( MotionEvent event ) { \nfor ( int i = 0 ; \ni < mHighlightViews . size ( ) ; \ni ++ ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nhv . setFocus ( false ) ; \nhv . invalidate ( ) ; \n} \nfor ( int i = 0 ; \ni < mHighlightViews . size ( ) ; \ni ++ ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nint edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; \nif ( edge != HighlightView . GROW_NONE ) { \nif ( ! hv . hasFocus ( ) ) { \nhv . setFocus ( true ) ; \nhv . invalidate ( ) ; \n} \nbreak ; \n} \n} \ninvalidate ( ) ; \nreturn ; \n} \n} \n"}
{"6633": "public class CropImageView { \nprivate void ensureVisible ( HighlightView hv ) { \nRect r = hv . mDrawRect ; \nint panDeltaX1 = Math . max ( 0 , mLeft - r . left ) ; \nint panDeltaX2 = Math . min ( 0 , mRight - r . right ) ; \nint panDeltaY1 = Math . max ( 0 , mTop - r . top ) ; \nint panDeltaY2 = Math . min ( 0 , mBottom - r . bottom ) ; \nint panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2 ; \nint panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2 ; \nif ( panDeltaX != 0 || panDeltaY != 0 ) { \npanBy ( panDeltaX , panDeltaY ) ; \n} \nreturn ; \n} \n} \n"}
{"6634": "public class CropImageView { \nprivate void centerBasedOnHighlightView ( HighlightView hv ) { \nRect drawRect = hv . mDrawRect ; \nfloat width = drawRect . width ( ) ; \nfloat height = drawRect . height ( ) ; \nfloat thisWidth = getWidth ( ) ; \nfloat thisHeight = getHeight ( ) ; \nfloat z1 = thisWidth / width * .8F ; \nfloat z2 = thisHeight / height * .8F ; \nfloat zoom = Math . min ( z1 , z2 ) ; \nzoom = zoom * this . getScale ( ) ; \nzoom = Math . max ( 1F , zoom ) ; \nif ( ( Math . abs ( zoom - getScale ( ) ) / zoom ) > .1 ) { \nfloat [ ] coordinates = new float [ ] { \nhv . mCropRect . centerX ( ) , hv . mCropRect . centerY ( ) } \n; \ngetImageMatrix ( ) . mapPoints ( coordinates ) ; \nzoomTo ( zoom , coordinates [ 0 ] , coordinates [ 1 ] , 300F ) ; \n} \nensureVisible ( hv ) ; \nreturn ; \n} \n} \n"}
{"6635": "public class HTMLScanner { \npublic void resetDocumentLocator ( String publicid , String systemid ) { \nthePublicid = publicid ; \ntheSystemid = systemid ; \ntheLastLine = theLastColumn = theCurrentLine = theCurrentColumn = 0 ; \nreturn ; \n} \n} \n"}
{"6637": "public class Schema { \n@ SuppressLint ( \"DefaultLocale\" ) public void elementType ( String name , int model , int memberOf , int flags ) { \nElementType e = new ElementType ( name , model , memberOf , flags , this ) ; \ntheElementTypes . put ( name . toLowerCase ( ) , e ) ; \nif ( memberOf == M_ROOT ) theRoot = e ; \nreturn ; \n} \n} \n"}
{"6638": "public class Schema { \npublic void attribute ( String elemName , String attrName , String type , String value ) { \nElementType e = getElementType ( elemName ) ; \nif ( e == null ) { \nthrow new Error ( \"Attribute \" + attrName + \" specified for unknown element type \" + elemName ) ; \n} \ne . setAttribute ( attrName , type , value ) ; \nreturn ; \n} \n} \n"}
{"6639": "public class Schema { \npublic void parent ( String name , String parentName ) { \nElementType child = getElementType ( name ) ; \nElementType parent = getElementType ( parentName ) ; \nif ( child == null ) { \nthrow new Error ( \"No child \" + name + \" for parent \" + parentName ) ; \n} \nif ( parent == null ) { \nthrow new Error ( \"No parent \" + parentName + \" for child \" + name ) ; \n} \nchild . setParent ( parent ) ; \nreturn ; \n} \n} \n"}
{"6642": "public class Effects { \npublic static void cleanupParagraphs ( RTEditText editor , Effect ... exclude ) { \ncleanupParagraphs ( editor , Effects . ALIGNMENT , exclude ) ; \ncleanupParagraphs ( editor , Effects . INDENTATION , exclude ) ; \ncleanupParagraphs ( editor , Effects . BULLET , exclude ) ; \ncleanupParagraphs ( editor , Effects . NUMBER , exclude ) ; \nreturn ; \n} \n} \n"}
{"6643": "public class CharacterEffect { \npublic void applyToSelection ( RTEditText editor , V value ) { \nSelection selection = getSelection ( editor ) ; \nint flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nSpannable str = editor . getText ( ) ; \nfor ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { \nboolean sameSpan = span . getValue ( ) . equals ( value ) ; \nint spanStart = str . getSpanStart ( span ) ; \nif ( spanStart < selection . start ( ) ) { \nif ( sameSpan ) { \nflags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nselection . offset ( selection . start ( ) - spanStart , 0 ) ; \n} \nelse { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; \n} \n} \nint spanEnd = str . getSpanEnd ( span ) ; \nif ( spanEnd > selection . end ( ) ) { \nif ( sameSpan ) { \nselection . offset ( 0 , spanEnd - selection . end ( ) ) ; \n} \nelse { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; \n} \n} \nstr . removeSpan ( span ) ; \n} \nif ( value != null ) { \nRTSpan < V > newSpan = newSpan ( value ) ; \nif ( newSpan != null ) { \nstr . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6645": "public class RTOperationManager { \nsynchronized void executed ( RTEditText editor , Operation op ) { \nStack < Operation > undoStack = getUndoStack ( editor ) ; \nStack < Operation > redoStack = getRedoStack ( editor ) ; \nwhile ( ! undoStack . empty ( ) && op . canMerge ( undoStack . peek ( ) ) ) { \nOperation previousOp = undoStack . pop ( ) ; \nop . merge ( previousOp ) ; \n} \npush ( op , undoStack ) ; \nredoStack . clear ( ) ; \nreturn ; \n} \n} \n"}
{"6646": "public class RTOperationManager { \nsynchronized void redo ( RTEditText editor ) { \nStack < Operation > redoStack = getRedoStack ( editor ) ; \nif ( ! redoStack . empty ( ) ) { \nStack < Operation > undoStack = getUndoStack ( editor ) ; \nOperation op = redoStack . pop ( ) ; \npush ( op , undoStack ) ; \nop . redo ( editor ) ; \nwhile ( ! redoStack . empty ( ) && op . canMerge ( redoStack . peek ( ) ) ) { \nop = redoStack . pop ( ) ; \npush ( op , undoStack ) ; \nop . redo ( editor ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6649": "public class BitmapManager { \nprivate synchronized void setDecodingOptions ( Thread t , BitmapFactory . Options options ) { \ngetOrCreateThreadStatus ( t ) . mOptions = options ; \nreturn ; \n} \n} \n"}
{"6655": "public class Parser { \nprivate void setup ( ) { \nif ( theSchema == null ) theSchema = new HTMLSchema ( ) ; \nif ( theScanner == null ) theScanner = new HTMLScanner ( ) ; \nif ( theAutoDetector == null ) { \ntheAutoDetector = new AutoDetector ( ) { \npublic Reader autoDetectingReader ( InputStream i ) { \nreturn new InputStreamReader ( i ) ; \n} \n} \n; \n} \ntheStack = new Element ( theSchema . getElementType ( \"<root>\" ) , defaultAttributes ) ; \nthePCDATA = new Element ( theSchema . getElementType ( \"<pcdata>\" ) , defaultAttributes ) ; \ntheNewElement = null ; \ntheAttributeName = null ; \nthePITarget = null ; \ntheSaved = null ; \ntheEntity = 0 ; \nvirginStack = true ; \ntheDoctypeName = theDoctypePublicId = theDoctypeSystemId = null ; \nreturn ; \n} \n} \n"}
{"6658": "public class Parser { \n@ Override public void adup ( char [ ] buff , int offset , int length ) throws SAXException { \nif ( theNewElement != null && theAttributeName != null ) { \ntheNewElement . setAttribute ( theAttributeName , null , theAttributeName ) ; \ntheAttributeName = null ; \n} \nreturn ; \n} \n} \n"}
{"6661": "public class Parser { \nprivate void restart ( Element e ) throws SAXException { \nwhile ( theSaved != null && theStack . canContain ( theSaved ) && ( e == null || theSaved . canContain ( e ) ) ) { \nElement next = theSaved . next ( ) ; \npush ( theSaved ) ; \ntheSaved = next ; \n} \nreturn ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) return ; \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) namespace = localName = \"\" ; \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) { \ntheContentHandler . endPrefixMapping ( prefix ) ; \n} \nAttributes atts = theStack . atts ( ) ; \nfor ( int i = atts . getLength ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) { \ntheContentHandler . endPrefixMapping ( attPrefix ) ; \n} \n} \ntheStack = theStack . next ( ) ; \nreturn ; \n} \n} \n"}
{"6663": "public class Parser { \nprivate void restartablyPop ( ) throws SAXException { \nElement popped = theStack ; \npop ( ) ; \nif ( restartElements && ( popped . flags ( ) & Schema . F_RESTART ) != 0 ) { \npopped . anonymize ( ) ; \npopped . setNext ( theSaved ) ; \ntheSaved = popped ; \n} \nreturn ; \n} \n} \n"}
{"6668": "public class Parser { \nprivate void rectify ( Element e ) throws SAXException { \nElement sp ; \nwhile ( true ) { \nfor ( sp = theStack ; \nsp != null ; \nsp = sp . next ( ) ) { \nif ( sp . canContain ( e ) ) break ; \n} \nif ( sp != null ) break ; \nElementType parentType = e . parent ( ) ; \nif ( parentType == null ) break ; \nElement parent = new Element ( parentType , defaultAttributes ) ; \nparent . setNext ( e ) ; \ne = parent ; \n} \nif ( sp == null ) return ; \nwhile ( theStack != sp ) { \nif ( theStack == null || theStack . next ( ) == null || theStack . next ( ) . next ( ) == null ) break ; \nrestartablyPop ( ) ; \n} \nwhile ( e != null ) { \nElement nexte = e . next ( ) ; \nif ( ! e . name ( ) . equals ( \"<pcdata>\" ) ) push ( e ) ; \ne = nexte ; \nrestart ( e ) ; \n} \ntheNewElement = null ; \nreturn ; \n} \n} \n"}
{"6670": "public class RTManager { \npublic void onSaveInstanceState ( Bundle outState ) { \noutState . putString ( \"mToolbarVisibility\" , mToolbarVisibility . name ( ) ) ; \noutState . putBoolean ( \"mToolbarIsVisible\" , mToolbarIsVisible ) ; \noutState . putInt ( \"mActiveEditor\" , mActiveEditor ) ; \nif ( mLinkSelection != null ) { \noutState . putSerializable ( \"mLinkSelection\" , mLinkSelection ) ; \n} \nreturn ; \n} \n} \n"}
{"6671": "public class RTManager { \npublic void onDestroy ( boolean isSaved ) { \nEventBus . getDefault ( ) . unregister ( this ) ; \nfor ( RTEditText editor : mEditors . values ( ) ) { \neditor . unregister ( ) ; \neditor . onDestroy ( isSaved ) ; \n} \nmEditors . clear ( ) ; \nfor ( RTToolbar toolbar : mToolbars . values ( ) ) { \ntoolbar . removeToolbarListener ( ) ; \n} \nmToolbars . clear ( ) ; \nmRTApi = null ; \nreturn ; \n} \n} \n"}
{"6672": "public class RTManager { \n@ Subscribe ( sticky = true , threadMode = ThreadMode . MAIN ) public void onEventMainThread ( MediaEvent event ) { \nRTEditText editor = mEditors . get ( mActiveEditor ) ; \nRTMedia media = event . getMedia ( ) ; \nif ( editor != null && media instanceof RTImage ) { \ninsertImage ( editor , ( RTImage ) media ) ; \nEventBus . getDefault ( ) . removeStickyEvent ( event ) ; \nmActiveEditor = Integer . MAX_VALUE ; \n} \nreturn ; \n} \n} \n"}
{"6673": "public class RTManager { \n@ Subscribe ( threadMode = ThreadMode . MAIN ) public void onEventMainThread ( LinkEvent event ) { \nfinal String fragmentTag = event . getFragmentTag ( ) ; \nmRTApi . removeFragment ( fragmentTag ) ; \nif ( ! event . wasCancelled ( ) && ID_01_LINK_FRAGMENT . equals ( fragmentTag ) ) { \nRTEditText editor = getActiveEditor ( ) ; \nif ( editor != null ) { \nLink link = event . getLink ( ) ; \nString url = null ; \nif ( link != null && link . isValid ( ) ) { \nSelection selection = mLinkSelection != null && mLinkSelection . end ( ) <= editor . length ( ) ? mLinkSelection : new Selection ( editor ) ; \nString linkText = link . getLinkText ( ) ; \nEditable str = editor . getText ( ) ; \nstr . replace ( selection . start ( ) , selection . end ( ) , linkText ) ; \neditor . setSelection ( selection . start ( ) , selection . start ( ) + linkText . length ( ) ) ; \nurl = link . getUrl ( ) ; \n} \neditor . applyEffect ( Effects . LINK , url ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6674": "public class ImageViewTouchBase { \nprivate void getProperBaseMatrix ( RotateBitmap bitmap , Matrix matrix ) { \nfloat viewWidth = getWidth ( ) ; \nfloat viewHeight = getHeight ( ) ; \nfloat w = bitmap . getWidth ( ) ; \nfloat h = bitmap . getHeight ( ) ; \nmatrix . reset ( ) ; \nfloat widthScale = Math . min ( viewWidth / w , 2.0f ) ; \nfloat heightScale = Math . min ( viewHeight / h , 2.0f ) ; \nfloat scale = Math . min ( widthScale , heightScale ) ; \nmatrix . postConcat ( bitmap . getRotateMatrix ( ) ) ; \nmatrix . postScale ( scale , scale ) ; \nmatrix . postTranslate ( ( viewWidth - w * scale ) / 2F , ( viewHeight - h * scale ) / 2F ) ; \nreturn ; \n} \n} \n"}
{"6677": "public class ParagraphEffect { \nprotected void findSpans2Remove ( Spannable str , Paragraph paragraph , ParagraphSpanProcessor < V > spanProcessor ) { \nList < RTSpan < V > > spans = getSpans ( str , paragraph , SpanCollectMode . EXACT ) ; \nspanProcessor . removeSpans ( spans , paragraph ) ; \nreturn ; \n} \n} \n"}
{"6682": "public class HTMLWriter { \npublic void setOutput ( Writer writer ) { \nif ( writer == null ) { \noutput = new OutputStreamWriter ( System . out ) ; \n} \nelse { \noutput = writer ; \n} \nreturn ; \n} \n} \n"}
{"6683": "public class HTMLWriter { \nprivate void write ( char c ) throws SAXException { \ntry { \noutput . write ( c ) ; \n} \ncatch ( IOException e ) { \nthrow new SAXException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"6684": "public class HTMLWriter { \nprivate void write ( String s ) throws SAXException { \ntry { \noutput . write ( s ) ; \n} \ncatch ( IOException e ) { \nthrow new SAXException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"6686": "public class HTMLWriter { \nprivate void writeEscUTF16 ( String s , int start , int length , boolean isAttVal ) throws SAXException { \nString subString = s . substring ( start , start + length ) ; \nwrite ( StringEscapeUtils . escapeHtml4 ( subString ) ) ; \nreturn ; \n} \n} \n"}
{"6687": "public class HTMLWriter { \n@ SuppressWarnings ( \"unchecked\" ) private void writeNSDecls ( ) throws SAXException { \nEnumeration < String > prefixes = ( Enumeration < String > ) nsSupport . getDeclaredPrefixes ( ) ; \nwhile ( prefixes . hasMoreElements ( ) ) { \nString prefix = ( String ) prefixes . nextElement ( ) ; \nString uri = nsSupport . getURI ( prefix ) ; \nif ( uri == null ) { \nuri = \"\" ; \n} \nwrite ( ' ' ) ; \nif ( \"\" . equals ( prefix ) ) { \nwrite ( \"xmlns=\\\"\" ) ; \n} \nelse { \nwrite ( \"xmlns:\" ) ; \nwrite ( prefix ) ; \nwrite ( \"=\\\"\" ) ; \n} \nwriteEscUTF16 ( uri , 0 , uri . length ( ) , true ) ; \nwrite ( '\\\"' ) ; \n} \nreturn ; \n} \n} \n"}
{"6688": "public class HTMLWriter { \nprivate void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { \nString prefix = doPrefix ( uri , qName , isElement ) ; \nif ( prefix != null && ! \"\" . equals ( prefix ) ) { \nwrite ( prefix ) ; \nwrite ( ':' ) ; \n} \nif ( localName != null && ! \"\" . equals ( localName ) ) { \nwrite ( localName ) ; \n} \nelse { \nint i = qName . indexOf ( ':' ) ; \nwrite ( qName . substring ( i + 1 , qName . length ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6689": "public class AwsKinesisUtils { \nprivate static void createStreamIfNotExists ( AmazonKinesis kinesis , String streamName , int shardCount ) { \nperformAmazonActionWithRetry ( \"createStream\" , ( ) -> { \nDescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; \ntry { \nkinesis . describeStream ( describeStreamRequest ) ; \n} \ncatch ( ResourceNotFoundException e ) { \nkinesis . createStream ( streamName , shardCount ) ; \n} \nreturn null ; \n} \n, DEFAULT_RETRY_COUNT , DEFAULT_RETRY_DURATION_IN_MILLIS ) ; \nreturn ; \n} \n} \n"}
{"6690": "public class AwsKinesisUtils { \nprivate static void waitStreamActivation ( AmazonKinesis consumer , String streamName , long streamCreationTimeoutMillis ) { \nDescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; \nDescribeStreamResult describeStreamResult = null ; \nString streamStatus = null ; \nlong endTime = System . currentTimeMillis ( ) + streamCreationTimeoutMillis ; \ndo { \ntry { \ndescribeStreamResult = consumer . describeStream ( describeStreamRequest ) ; \nstreamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; \nif ( ACTIVE_STREAM_STATUS . equals ( streamStatus ) ) { \nbreak ; \n} \nThread . sleep ( 100 ) ; \n} \ncatch ( ResourceNotFoundException | LimitExceededException ignored ) { \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new AwsKinesisException ( \"Thread interrupted while waiting for stream activation\" , args -> args . add ( \"streamName\" , streamName ) , e ) ; \n} \n} \nwhile ( System . currentTimeMillis ( ) < endTime ) ; \nif ( describeStreamResult == null || streamStatus == null || ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) { \nthrow new AwsKinesisException ( \"Stream never went active\" , args -> args . add ( \"streamName\" , streamName ) . add ( \"streamCreationTimeoutMillis\" , streamCreationTimeoutMillis ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6691": "public class IronMigration { \nprivate static void completeStoreSnapshotWithMissingInstanceSnapshots ( Path targetStoresPath ) { \nString transactionIdRegexAlone = \"\\\"transactionId\\\"\\\\s*:\\\\s*\\\\d+\\\\s*,\" ; \nString transactionIdRegexReplace = \"(.*\\\"transactionId\\\"\\\\s*:\\\\s*)\\\\d+(\\\\s*,.*)\" ; \nPattern transactionIdPattern = compile ( transactionIdRegexAlone ) ; \nSet < File > previousSnapshots = new HashSet < > ( ) ; \nArrays . stream ( targetStoresPath . resolve ( SNAPSHOT_DIRECTORY_NAME ) . toFile ( ) . listFiles ( ) ) . sorted ( ) . forEach ( snapshot -> { \nSet < String > snapshotNames = Arrays . stream ( snapshot . listFiles ( ) ) . map ( File :: getName ) . collect ( toSet ( ) ) ; \npreviousSnapshots . stream ( ) . filter ( previousSnapshot -> ! snapshotNames . contains ( previousSnapshot . getName ( ) ) ) . forEach ( previousSnapshot -> { \ntry { \nPath targetPath = snapshot . toPath ( ) . resolve ( previousSnapshot . getName ( ) ) ; \nPath sourcePath = previousSnapshot . toPath ( ) ; \nlong count = countTransactionId ( transactionIdPattern , sourcePath ) ; \nif ( count != 1L ) { \nthrow new StoreException ( \"transactionId not found once\" , args -> args . add ( \"found count\" , count ) ) ; \n} \nBigInteger newTransactionId = new BigInteger ( snapshot . getName ( ) ) ; \nreplaceTransactionIdValue ( transactionIdRegexReplace , sourcePath , targetPath , newTransactionId . toString ( ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UncheckedIOException ( e ) ; \n} \n} \n) ; \npreviousSnapshots . clear ( ) ; \npreviousSnapshots . addAll ( Arrays . stream ( snapshot . listFiles ( ) ) . collect ( toSet ( ) ) ) ; \n} \n) ; \nreturn ; \n} \n} \n"}
{"6698": "public class DefaultWildcardStreamLocator { \nvoid triggerWildcardExpander ( final Collection < File > allFiles , final WildcardContext wildcardContext ) throws IOException { \nLOG . debug ( \"wildcard resources: {}\" , allFiles ) ; \nif ( allFiles . isEmpty ( ) ) { \nfinal String message = String . format ( \"No resource found for wildcard: %s\" , wildcardContext . getWildcard ( ) ) ; \nLOG . warn ( message ) ; \nthrow new IOException ( message ) ; \n} \nif ( wildcardExpanderHandler != null ) { \ntry { \nwildcardExpanderHandler . apply ( allFiles ) ; \n} \ncatch ( final IOException e ) { \nthrow e ; \n} \ncatch ( final Exception e ) { \nLOG . debug ( \"wildcard expanding error. Reporting original exception\" , e ) ; \nthrow new IOException ( \"Exception during expanding wildcard: \" + e . getMessage ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6702": "public class ConfigurableWroManagerFactory { \nprivate void updatePropertiesWithConfiguration ( final Properties props , final String key ) { \nfinal FilterConfig filterConfig = Context . get ( ) . getFilterConfig ( ) ; \nfinal String valuesAsString = filterConfig . getInitParameter ( key ) ; \nif ( valuesAsString != null ) { \nprops . setProperty ( key , valuesAsString ) ; \n} \nelse { \nfinal String value = getConfigProperties ( ) . getProperty ( key ) ; \nif ( value != null ) { \nprops . setProperty ( key , value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6707": "public class WroConfiguration { \nprivate void reloadCacheWithNewValue ( final Long newValue ) { \nfinal long newValueAsPrimitive = newValue == null ? getCacheUpdatePeriod ( ) : newValue ; \nLOG . debug ( \"invoking {} listeners\" , cacheUpdatePeriodListeners . size ( ) ) ; \nfor ( final PropertyChangeListener listener : cacheUpdatePeriodListeners ) { \nfinal PropertyChangeEvent event = new PropertyChangeEvent ( this , \"cache\" , getCacheUpdatePeriod ( ) , newValueAsPrimitive ) ; \nlistener . propertyChange ( event ) ; \n} \nreturn ; \n} \n} \n"}
{"6708": "public class WroConfiguration { \nprivate void reloadModelWithNewValue ( final Long newValue ) { \nfinal long newValueAsPrimitive = newValue == null ? getModelUpdatePeriod ( ) : newValue ; \nfor ( final PropertyChangeListener listener : modelUpdatePeriodListeners ) { \nfinal PropertyChangeEvent event = new PropertyChangeEvent ( this , \"model\" , getModelUpdatePeriod ( ) , newValueAsPrimitive ) ; \nlistener . propertyChange ( event ) ; \n} \nreturn ; \n} \n} \n"}
{"6711": "public class RedirectedStreamServletResponseWrapper { \nprivate void onError ( final int sc , final String msg ) { \nLOG . debug ( \"Error detected with code: {} and message: {}\" , sc , msg ) ; \nfinal OutputStream emptyStream = new ByteArrayOutputStream ( ) ; \nprintWriter = new PrintWriter ( emptyStream ) ; \nservletOutputStream = new DelegatingServletOutputStream ( emptyStream ) ; \nreturn ; \n} \n} \n"}
{"6712": "public class RedirectedStreamServletResponseWrapper { \n@ Override public void sendRedirect ( final String location ) throws IOException { \ntry { \nLOG . debug ( \"redirecting to: {}\" , location ) ; \nfinal InputStream is = externalResourceLocator . locate ( location ) ; \nIOUtils . copy ( is , servletOutputStream ) ; \nis . close ( ) ; \nservletOutputStream . close ( ) ; \n} \ncatch ( final IOException e ) { \nLOG . warn ( \"{}: Invalid response for location: {}\" , e . getClass ( ) . getName ( ) , location ) ; \nthrow e ; \n} \nreturn ; \n} \n} \n"}
{"6713": "public class WildcardExpanderModelTransformer { \nprivate void processResource ( final Group group , final Resource resource ) { \nfinal UriLocator uriLocator = locatorFactory . getInstance ( resource . getUri ( ) ) ; \nif ( uriLocator instanceof WildcardUriLocatorSupport ) { \nfinal WildcardStreamLocator wildcardStreamLocator = ( ( WildcardUriLocatorSupport ) uriLocator ) . getWildcardStreamLocator ( ) ; \nif ( wildcardStreamLocator . hasWildcard ( resource . getUri ( ) ) && wildcardStreamLocator instanceof WildcardExpanderHandlerAware ) { \nfinal WildcardExpanderHandlerAware expandedHandler = ( WildcardExpanderHandlerAware ) wildcardStreamLocator ; \nLOG . debug ( \"Expanding resource: {}\" , resource . getUri ( ) ) ; \nfinal String baseNameFolder = computeBaseNameFolder ( resource , uriLocator , expandedHandler ) ; \nLOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; \nexpandedHandler . setWildcardExpanderHandler ( createExpanderHandler ( group , resource , baseNameFolder ) ) ; \ntry { \nuriLocator . locate ( resource . getUri ( ) ) ; \n} \ncatch ( final IOException e ) { \nLOG . debug ( \"[FAIL] problem while trying to expand wildcard for the following resource uri: {}\" , resource . getUri ( ) ) ; \n} \nfinally { \nexpandedHandler . setWildcardExpanderHandler ( null ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6717": "public class WroFilter { \nprivate void registerChangeListeners ( ) { \nwroConfiguration . registerCacheUpdatePeriodChangeListener ( new PropertyChangeListener ( ) { \npublic void propertyChange ( final PropertyChangeEvent event ) { \nheadersConfigurer = newResponseHeadersConfigurer ( ) ; \nwroManagerFactory . onCachePeriodChanged ( valueAsLong ( event . getNewValue ( ) ) ) ; \nreturn ; \n} \n} \n) ; \nwroConfiguration . registerModelUpdatePeriodChangeListener ( new PropertyChangeListener ( ) { \npublic void propertyChange ( final PropertyChangeEvent event ) { \nheadersConfigurer = newResponseHeadersConfigurer ( ) ; \nwroManagerFactory . onModelPeriodChanged ( valueAsLong ( event . getNewValue ( ) ) ) ; \nreturn ; \n} \n} \n) ; \nLOG . debug ( \"Cache & Model change listeners were registered\" ) ; \nreturn ; \n} \n} \n"}
{"6718": "public class WroFilter { \nprivate void processRequest ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { \nsetResponseHeaders ( response ) ; \nwroManagerFactory . create ( ) . process ( ) ; \nreturn ; \n} \n} \n"}
{"6719": "public class WroFilter { \npublic final void setConfiguration ( final WroConfiguration config ) { \nnotNull ( config ) ; \nwroConfigurationFactory = new ObjectFactory < WroConfiguration > ( ) { \npublic WroConfiguration create ( ) { \nreturn config ; \n} \n} \n; \nreturn ; \n} \n} \n"}
{"6720": "public class WroModel { \nprivate void identifyDuplicateGroupNames ( final Collection < Group > groups ) { \nLOG . debug ( \"identifyDuplicateGroupNames\" ) ; \nfinal List < String > groupNames = new ArrayList < String > ( ) ; \nfor ( final Group group : groups ) { \nif ( groupNames . contains ( group . getName ( ) ) ) { \nthrow new WroRuntimeException ( \"Duplicate group name detected: \" + group . getName ( ) ) ; \n} \ngroupNames . add ( group . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6721": "public class WroModel { \npublic void merge ( final WroModel importedModel ) { \nValidate . notNull ( importedModel , \"imported model cannot be null!\" ) ; \nLOG . debug ( \"merging importedModel: {}\" , importedModel ) ; \nfor ( final String groupName : new WroModelInspector ( importedModel ) . getGroupNames ( ) ) { \nif ( new WroModelInspector ( this ) . getGroupNames ( ) . contains ( groupName ) ) { \nthrow new WroRuntimeException ( \"Duplicate group name detected: \" + groupName ) ; \n} \nfinal Group importedGroup = new WroModelInspector ( importedModel ) . getGroupByName ( groupName ) ; \naddGroup ( importedGroup ) ; \n} \nreturn ; \n} \n} \n"}
{"6724": "public class GroupsProcessor { \nprivate synchronized ProcessorDecorator decorateProcessor ( final ResourcePostProcessor processor , final boolean minimize ) { \nfinal ProcessorDecorator decorated = new DefaultProcessorDecorator ( processor , minimize ) { \n@ Override public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { \ntry { \ncallbackRegistry . onBeforePostProcess ( ) ; \nsuper . process ( resource , reader , writer ) ; \n} \nfinally { \ncallbackRegistry . onAfterPostProcess ( ) ; \n} \nreturn ; \n} \n} \n; \ninjector . inject ( decorated ) ; \nreturn decorated ; \n} \n} \n"}
{"6725": "public class AbstractProcessorsFilter { \nprivate void doProcess ( final String requestUri , final Reader reader , final Writer writer ) throws IOException { \nReader input = reader ; \nWriter output = null ; \nLOG . debug ( \"processing resource: {}\" , requestUri ) ; \ntry { \nfinal StopWatch stopWatch = new StopWatch ( ) ; \nfinal Injector injector = InjectorBuilder . create ( new BaseWroManagerFactory ( ) ) . build ( ) ; \nfinal List < ResourcePreProcessor > processors = getProcessorsList ( ) ; \nif ( processors == null || processors . isEmpty ( ) ) { \nIOUtils . copy ( reader , writer ) ; \n} \nelse { \nfor ( final ResourcePreProcessor processor : processors ) { \nstopWatch . start ( \"Using \" + processor . getClass ( ) . getSimpleName ( ) ) ; \ninjector . inject ( processor ) ; \noutput = new StringWriter ( ) ; \nLOG . debug ( \"Using {} processor\" , processor ) ; \nprocessor . process ( createResource ( requestUri ) , input , output ) ; \ninput = new StringReader ( output . toString ( ) ) ; \nstopWatch . stop ( ) ; \n} \nLOG . debug ( stopWatch . prettyPrint ( ) ) ; \nif ( output != null ) { \nwriter . write ( output . toString ( ) ) ; \n} \n} \n} \nfinally { \nreader . close ( ) ; \nwriter . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6728": "public class RegexpProperties { \nprivate void parseProperties ( final String propertiesAsString ) { \nfinal String [ ] propertyEntries = propertiesAsString . split ( \"\\\\r?\\\\n\" ) ; \nfor ( final String entry : propertyEntries ) { \nreadPropertyEntry ( entry ) ; \n} \nreturn ; \n} \n} \n"}
{"6730": "public class AbstractWro4jMojo { \nprivate void persistResourceFingerprints ( final List < String > groupNames ) { \nfinal WroModelInspector modelInspector = new WroModelInspector ( getModel ( ) ) ; \nfor ( final String groupName : groupNames ) { \nfinal Group group = modelInspector . getGroupByName ( groupName ) ; \nif ( group != null ) { \nfor ( final Resource resource : group . getResources ( ) ) { \ngetResourceChangeHandler ( ) . remember ( resource ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6732": "public class AbstractWro4jMojo { \nprotected final void extendPluginClasspath ( ) throws MojoExecutionException { \nfinal List < String > classpathElements = new ArrayList < String > ( ) ; \ntry { \nclasspathElements . addAll ( mavenProject . getRuntimeClasspathElements ( ) ) ; \n} \ncatch ( final DependencyResolutionRequiredException e ) { \nthrow new MojoExecutionException ( \"Could not get compile classpath elements\" , e ) ; \n} \nfinal ClassLoader classLoader = createClassLoader ( classpathElements ) ; \nThread . currentThread ( ) . setContextClassLoader ( classLoader ) ; \nreturn ; \n} \n} \n"}
{"6741": "public class PreProcessorExecutor { \nprivate synchronized ResourcePreProcessor decoratePreProcessor ( final ResourcePreProcessor processor , final ProcessingCriteria criteria ) { \nfinal ResourcePreProcessor decorated = new DefaultProcessorDecorator ( processor , criteria ) { \n@ Override public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { \ntry { \ncallbackRegistry . onBeforePreProcess ( ) ; \nsuper . process ( resource , reader , writer ) ; \n} \nfinally { \ncallbackRegistry . onAfterPreProcess ( ) ; \n} \nreturn ; \n} \n} \n; \ninjector . inject ( decorated ) ; \nreturn decorated ; \n} \n} \n"}
{"6742": "public class BuildContextHolder { \npublic void persist ( ) { \nOutputStream os = null ; \ntry { \nos = new FileOutputStream ( fallbackStorageFile ) ; \nfallbackStorage . store ( os , \"Generated\" ) ; \nLOG . debug ( \"fallback storage written to {}\" , fallbackStorageFile ) ; \n} \ncatch ( final IOException e ) { \nLOG . warn ( \"Cannot persist fallback storage: {}.\" , fallbackStorageFile , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( os ) ; \n} \nreturn ; \n} \n} \n"}
{"6747": "public class ResourceBundleProcessor { \npublic void serveProcessedBundle ( ) throws IOException { \nfinal WroConfiguration configuration = context . getConfig ( ) ; \nfinal HttpServletRequest request = context . getRequest ( ) ; \nfinal HttpServletResponse response = context . getResponse ( ) ; \nOutputStream os = null ; \ntry { \nfinal CacheKey cacheKey = getSafeCacheKey ( request ) ; \ninitAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; \nfinal CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; \nfinal String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; \nfinal String etagValue = String . format ( \"\\\"%s\\\"\" , cacheValue . getHash ( ) ) ; \nif ( etagValue != null && etagValue . equals ( ifNoneMatch ) ) { \nLOG . debug ( \"ETag hash detected: {}. Sending {} status code\" , etagValue , HttpServletResponse . SC_NOT_MODIFIED ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \nreturn ; \n} \nresponse . setContentType ( cacheKey . getType ( ) . getContentType ( ) + \"; charset=\" + configuration . getEncoding ( ) ) ; \nresponse . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; \nos = response . getOutputStream ( ) ; \nif ( cacheValue . getRawContent ( ) != null ) { \nif ( isGzipAllowed ( ) ) { \nresponse . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nresponse . setHeader ( \"Vary\" , \"Accept-Encoding\" ) ; \nIOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; \n} \nelse { \nresponse . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; \nIOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; \n} \n} \n} \nfinally { \nif ( os != null ) { \nIOUtils . closeQuietly ( os ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6748": "public class ResourceBundleProcessor { \nprivate void initAggregatedFolderPath ( final HttpServletRequest request , final ResourceType type ) { \nif ( ResourceType . CSS == type && context . getAggregatedFolderPath ( ) == null ) { \nfinal String requestUri = request . getRequestURI ( ) ; \nfinal String cssFolder = StringUtils . removeEnd ( requestUri , FilenameUtils . getName ( requestUri ) ) ; \nfinal String aggregatedFolder = StringUtils . removeStart ( cssFolder , request . getContextPath ( ) ) ; \nLOG . debug ( \"set aggregatedFolderPath: {}\" , aggregatedFolder ) ; \nContext . get ( ) . setAggregatedFolderPath ( aggregatedFolder ) ; \n} \nreturn ; \n} \n} \n"}
{"6752": "public class ProcessorDecorator { \nprivate static ResourcePreProcessor toPreProcessor ( final ResourcePostProcessor postProcessor ) { \nreturn new AbstractProcessorDecoratorSupport < ResourcePostProcessor > ( postProcessor ) { \npublic void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { \npostProcessor . process ( reader , writer ) ; \nreturn ; \n} \n@ Override protected boolean isMinimizeInternal ( ) { \nreturn isMinimizeForProcessor ( postProcessor ) ; \n} \n@ Override protected SupportedResourceType getSupportedResourceTypeInternal ( ) { \nreturn getSupportedResourceTypeForProcessor ( postProcessor ) ; \n} \n@ Override public String toString ( ) { \nreturn postProcessor . toString ( ) ; \n} \n} \n; \n} \n} \n"}
{"6754": "public class GzipFilter { \nprivate void doGzipResponse ( final HttpServletRequest req , final HttpServletResponse response , final FilterChain chain ) throws IOException , ServletException { \nLOG . debug ( \"Applying gzip on resource: \" + req . getRequestURI ( ) ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nfinal CountingOutputStream countingStream = new CountingOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( baos ) ) ) ; \nfinal HttpServletResponseWrapper wrappedResponse = new RedirectedStreamServletResponseWrapper ( countingStream , response ) ; \nchain . doFilter ( req , wrappedResponse ) ; \ncountingStream . close ( ) ; \nresponse . setContentLength ( countingStream . getCount ( ) ) ; \nif ( countingStream . getCount ( ) > 0 ) { \nIOUtils . write ( baos . toByteArray ( ) , response . getOutputStream ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6758": "public class ResourceChangeHandler { \npublic void remember ( final Resource resource ) { \nfinal WroManager manager = getManagerFactory ( ) . create ( ) ; \nfinal HashStrategy hashStrategy = manager . getHashStrategy ( ) ; \nfinal UriLocatorFactory locatorFactory = manager . getUriLocatorFactory ( ) ; \nif ( rememberedSet . contains ( resource . getUri ( ) ) ) { \ngetLog ( ) . debug ( \"Resource with uri '\" + resource . getUri ( ) + \"' has already been updated in this run.\" ) ; \n} \nelse { \ntry { \nfinal String fingerprint = hashStrategy . getHash ( locatorFactory . locate ( resource . getUri ( ) ) ) ; \ngetBuildContextHolder ( ) . setValue ( resource . getUri ( ) , fingerprint ) ; \nrememberedSet . add ( resource . getUri ( ) ) ; \ngetLog ( ) . debug ( \"Persist fingerprint for resource '\" + resource . getUri ( ) + \"' : \" + fingerprint ) ; \nif ( resource . getType ( ) == ResourceType . CSS ) { \nfinal Reader reader = new InputStreamReader ( locatorFactory . locate ( resource . getUri ( ) ) ) ; \ngetLog ( ) . debug ( \"Check @import directive from \" + resource ) ; \npersistFingerprintsForCssImports ( resource , reader ) ; \n} \n} \ncatch ( final IOException e ) { \ngetLog ( ) . debug ( \"could not check fingerprint of resource: \" + resource ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6759": "public class ResourceChangeHandler { \nprivate void forEachCssImportApply ( final Function < String , ChangeStatus > func , final Resource resource , final Reader reader ) throws IOException { \nfinal ResourcePreProcessor processor = createCssImportProcessor ( func ) ; \nInjectorBuilder . create ( getManagerFactory ( ) ) . build ( ) . inject ( processor ) ; \nprocessor . process ( resource , reader , new StringWriter ( ) ) ; \nreturn ; \n} \n} \n"}
{"6769": "public class WroManager { \npublic final void process ( ) throws IOException { \nfinal WroConfiguration config = Context . get ( ) . getConfig ( ) ; \ncacheSchedulerHelper . scheduleWithPeriod ( config . getCacheUpdatePeriod ( ) ) ; \nmodelSchedulerHelper . scheduleWithPeriod ( config . getModelUpdatePeriod ( ) ) ; \nresourceBundleProcessor . serveProcessedBundle ( ) ; \nreturn ; \n} \n} \n"}
{"6774": "public class Wro4jMojo { \nprivate void processGroup ( final String group , final File parentFoder ) throws Exception { \nByteArrayOutputStream resultOutputStream = null ; \nInputStream resultInputStream = null ; \ntry { \ngetLog ( ) . info ( \"processing group: \" + group ) ; \nfinal HttpServletRequest request = Mockito . mock ( HttpServletRequest . class ) ; \nMockito . when ( request . getContextPath ( ) ) . thenReturn ( normalizeContextPath ( contextPath ) ) ; \nMockito . when ( request . getRequestURI ( ) ) . thenReturn ( group ) ; \nfinal HttpServletResponse response = Mockito . mock ( HttpServletResponse . class ) ; \nresultOutputStream = new ByteArrayOutputStream ( ) ; \nMockito . when ( response . getOutputStream ( ) ) . thenReturn ( new DelegatingServletOutputStream ( resultOutputStream ) ) ; \nfinal WroConfiguration config = Context . get ( ) . getConfig ( ) ; \nconfig . setIgnoreEmptyGroup ( true ) ; \nContext . set ( Context . webContext ( request , response , Mockito . mock ( FilterConfig . class ) ) , config ) ; \nContext . get ( ) . setAggregatedFolderPath ( getAggregatedPathResolver ( ) . resolve ( ) ) ; \ngetManagerFactory ( ) . create ( ) . process ( ) ; \nresultInputStream = new UnclosableBufferedInputStream ( resultOutputStream . toByteArray ( ) ) ; \nfinal File destinationFile = new File ( parentFoder , rename ( group , resultInputStream ) ) ; \nfinal File parentFolder = destinationFile . getParentFile ( ) ; \nif ( ! parentFolder . exists ( ) ) { \nparentFolder . mkdirs ( ) ; \n} \ndestinationFile . createNewFile ( ) ; \nresultInputStream . reset ( ) ; \ngetLog ( ) . debug ( \"Created file: \" + destinationFile . getName ( ) ) ; \nfinal OutputStream fos = new FileOutputStream ( destinationFile ) ; \nIOUtils . copy ( resultInputStream , fos ) ; \nfos . close ( ) ; \nif ( destinationFile . length ( ) == 0 ) { \ngetLog ( ) . debug ( \"No content found for group: \" + group ) ; \ndestinationFile . delete ( ) ; \n} \nelse { \ngetLog ( ) . info ( \"file size: \" + destinationFile . getName ( ) + \" -> \" + destinationFile . length ( ) + \" bytes\" ) ; \ngetLog ( ) . info ( destinationFile . getAbsolutePath ( ) + \" (\" + destinationFile . length ( ) + \" bytes\" + \")\" ) ; \n} \n} \nfinally { \nif ( getBuildContext ( ) != null ) { \ngetBuildContext ( ) . refresh ( parentFoder ) ; \n} \nif ( resultOutputStream != null ) { \nresultOutputStream . close ( ) ; \n} \nif ( resultInputStream != null ) { \nresultInputStream . close ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6784": "public class RubySassEngine { \npublic void addRequire ( final String require ) { \nif ( require != null && require . trim ( ) . length ( ) > 0 ) { \nrequires . add ( require . trim ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6786": "public class ProgressIndicator { \npublic void logSummary ( ) { \nfinal String message = totalFoundErrors == 0 ? \"No lint errors found.\" : String . format ( \"Found %s errors in %s files.\" , totalFoundErrors , totalResourcesWithErrors ) ; \nlog . info ( \"----------------------------------------\" ) ; \nlog . info ( String . format ( \"Total resources: %s\" , totalResources ) ) ; \nlog . info ( message ) ; \nlog . info ( \"----------------------------------------\\n\" ) ; \nreturn ; \n} \n} \n"}
{"6787": "public class ProgressIndicator { \npublic synchronized void onProcessingResource ( final Resource resource ) { \ntotalResources ++ ; \nlog . debug ( \"processing resource: \" + resource . getUri ( ) ) ; \nif ( isLogRequired ( ) ) { \nlog . info ( \"Processed until now: \" + getTotalResources ( ) + \". Last processed: \" + resource . getUri ( ) ) ; \nupdateLastInvocation ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6793": "public class ResponseHeadersConfigurer { \nprivate void parseHeader ( final String header ) { \nLOG . debug ( \"parseHeader: {}\" , header ) ; \nfinal String headerName = header . substring ( 0 , header . indexOf ( \":\" ) ) ; \nif ( ! headersMap . containsKey ( headerName ) ) { \nfinal String value = header . substring ( header . indexOf ( \":\" ) + 1 ) ; \nheadersMap . put ( headerName , StringUtils . trim ( value ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6794": "public class ResponseHeadersConfigurer { \nprivate static void addNoCacheHeaders ( final Map < String , String > map ) { \nmap . put ( HttpHeader . PRAGMA . toString ( ) , \"no-cache\" ) ; \nmap . put ( HttpHeader . CACHE_CONTROL . toString ( ) , \"no-cache\" ) ; \nmap . put ( HttpHeader . EXPIRES . toString ( ) , \"0\" ) ; \nreturn ; \n} \n} \n"}
{"6799": "public class WroUtil { \npublic static void safeCopy ( final Reader reader , final Writer writer ) throws IOException { \ntry { \nIOUtils . copy ( reader , writer ) ; \n} \nfinally { \nIOUtils . closeQuietly ( reader ) ; \nIOUtils . closeQuietly ( writer ) ; \n} \nreturn ; \n} \n} \n"}
{"6802": "public class ServletContextAttributeHelper { \nfinal void setAttribute ( final Attribute attribute , final Object object ) { \nValidate . notNull ( attribute ) ; \nLOG . debug ( \"setting attribute: {} with value: {}\" , attribute , object ) ; \nValidate . isTrue ( attribute . isValid ( object ) , object + \" is not of valid subType for attribute: \" + attribute ) ; \nservletContext . setAttribute ( getAttributeName ( attribute ) , object ) ; \nreturn ; \n} \n} \n"}
{"6804": "public class DataUriGenerator { \nprivate void generateDataURI ( final byte [ ] bytes , final Writer out , final String mimeType ) throws IOException { \nfinal StringBuffer buffer = new StringBuffer ( ) ; \nbuffer . append ( DATA_URI_PREFIX ) ; \nbuffer . append ( mimeType ) ; \nbuffer . append ( \";base64,\" ) ; \nbuffer . append ( Base64 . encodeBytes ( bytes ) ) ; \nout . write ( buffer . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"6805": "public class Context { \npublic static void set ( final Context context , final WroConfiguration config ) { \nnotNull ( context ) ; \nnotNull ( config ) ; \ncontext . setConfig ( config ) ; \nfinal String correlationId = generateCorrelationId ( ) ; \nCORRELATION_ID . set ( correlationId ) ; \nCONTEXT_MAP . put ( correlationId , context ) ; \nreturn ; \n} \n} \n"}
{"6806": "public class Context { \npublic static void unset ( ) { \nfinal String correlationId = CORRELATION_ID . get ( ) ; \nif ( correlationId != null ) { \nCONTEXT_MAP . remove ( correlationId ) ; \n} \nCORRELATION_ID . remove ( ) ; \nreturn ; \n} \n} \n"}
{"6807": "public class ResourceWatcher { \npublic void check ( final CacheKey cacheKey , final Callback callback ) { \nnotNull ( cacheKey ) ; \nLOG . debug ( \"started\" ) ; \nfinal StopWatch watch = new StopWatch ( ) ; \nwatch . start ( \"detect changes\" ) ; \ntry { \nfinal Group group = new WroModelInspector ( modelFactory . create ( ) ) . getGroupByName ( cacheKey . getGroupName ( ) ) ; \nif ( isGroupChanged ( group . collectResourcesOfType ( cacheKey . getType ( ) ) , callback ) ) { \ncallback . onGroupChanged ( cacheKey ) ; \ncacheStrategy . put ( cacheKey , null ) ; \n} \nresourceChangeDetector . reset ( ) ; \n} \ncatch ( final Exception e ) { \nonException ( e ) ; \n} \nfinally { \nwatch . stop ( ) ; \nLOG . debug ( \"resource watcher info: {}\" , watch . prettyPrint ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6808": "public class ResourceWatcher { \nprotected void onException ( final Exception e ) { \nLOG . info ( \"Could not check for resource changes because: {}\" , e . getMessage ( ) ) ; \nLOG . debug ( \"[FAIL] detecting resource change \" , e ) ; \nreturn ; \n} \n} \n"}
{"6809": "public class ResourceWatcher { \nprivate void checkResourceChange ( final Resource resource , final Group group , final Callback callback , final AtomicBoolean isChanged ) throws Exception { \nif ( isChanged ( resource , group . getName ( ) ) ) { \nisChanged . compareAndSet ( false , true ) ; \ncallback . onResourceChanged ( resource ) ; \nlifecycleCallback . onResourceChanged ( resource ) ; \n} \nreturn ; \n} \n} \n"}
{"6810": "public class ResourceChangeInfo { \npublic void updateHashForGroup ( final String hash , final String groupName ) { \nnotNull ( groupName ) ; \nthis . currentHash = hash ; \nif ( isChangedHash ( ) ) { \nLOG . debug ( \"Group {} has changed\" , groupName ) ; \ngroups . clear ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6814": "public class XmlModelFactory { \nprivate void processGroups ( final Document document ) { \nfinal NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; \nfor ( int i = 0 ; \ni < groupNodeList . getLength ( ) ; \ni ++ ) { \nfinal Element groupElement = ( Element ) groupNodeList . item ( i ) ; \nfinal String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; \nallGroupElements . put ( name , groupElement ) ; \n} \nreturn ; \n} \n} \n"}
{"6817": "public class XmlModelFactory { \nprivate void parseResource ( final Element resourceElement , final Collection < Resource > resources ) { \nfinal String tagName = resourceElement . getTagName ( ) ; \nfinal String uri = resourceElement . getTextContent ( ) ; \nif ( TAG_GROUP_REF . equals ( tagName ) ) { \nresources . addAll ( getResourcesForGroup ( uri ) ) ; \n} \nif ( getResourceType ( resourceElement ) != null ) { \nfinal Resource resource = createResource ( resourceElement ) ; \nLOG . debug ( \"\\t\\tadding resource: {}\" , resource ) ; \nresources . add ( resource ) ; \n} \nreturn ; \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( threadId != 0 ) { \ntimerLabel = name + \" (thread \" + threadId + \")\" ; \n} \nelse if ( threadCount > 1 ) { \ntimerLabel = name + \" (over \" + threadCount + \" threads)\" ; \n} \nelse { \ntimerLabel = name ; \n} \nif ( todoFlags == RECORD_NONE ) { \nLoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \n} \nelse { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"CPU\" ; \nvalues += totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nelse { \nseparator = \"\" ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += separator + \"Wall\" ; \nvalues += separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU avg\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall avg\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( threadCount > 1 ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU per thread\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall per thread\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nif ( isRunning ) { \nlogger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6823": "public class ClassExpressionSaturationFactory { \npublic void printStatistics ( ) { \nruleApplicationFactory_ . getSaturationStatistics ( ) . print ( LOGGER_ ) ; \nif ( LOGGER_ . isDebugEnabled ( ) ) { \nif ( aggregatedStats_ . jobsSubmittedNo > 0 ) LOGGER_ . debug ( \"Saturation Jobs Submitted=Done+Processed: {}={}+{}\" , aggregatedStats_ . jobsSubmittedNo , aggregatedStats_ . jobsAlreadyDoneNo , aggregatedStats_ . jobsProcessedNo ) ; \nLOGGER_ . debug ( \"Locks: \" + aggregatedStats_ . locks ) ; \n} \nreturn ; \n} \n} \n"}
{"6824": "public class ClassExpressionSaturationFactory { \nprivate void wakeUpWorkers ( ) { \nif ( ! workersWaiting_ ) { \nreturn ; \n} \nstopWorkersLock_ . lock ( ) ; \ntry { \nworkersWaiting_ = false ; \nthereAreContextsToProcess_ . signalAll ( ) ; \n} \nfinally { \nstopWorkersLock_ . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6825": "public class ClassExpressionSaturationFactory { \nprivate void updateProcessedCounters ( int snapshotFinishedWorkers ) { \nif ( isInterrupted ( ) ) { \nwakeUpWorkers ( ) ; \nreturn ; \n} \nif ( countStartedWorkers_ . get ( ) > snapshotFinishedWorkers ) { \nreturn ; \n} \nint snapshotCountJobsSubmitted = countJobsSubmittedUpper_ . get ( ) ; \nint snapshotCountContextNonSaturated = saturationState_ . getContextMarkNonSaturatedCount ( ) ; \nint snapshotCountStartedWorkers = countStartedWorkers_ . get ( ) ; \nif ( snapshotCountStartedWorkers > snapshotFinishedWorkers ) { \nreturn ; \n} \nif ( updateIfSmaller ( countContextsSaturatedLower_ , snapshotCountContextNonSaturated ) ) { \nwakeUpWorkers ( ) ; \n} \nupdateIfSmaller ( countJobsProcessedLower_ , snapshotCountJobsSubmitted ) ; \nreturn ; \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nint snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nfor ( ; \n; \n) { \nint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) { \nreturn ; \n} \nint updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { \nbreak ; \n} \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \nfor ( ; \n; \n) { \nint snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsFinished >= snapshotJobsProcessed ) { \nbreak ; \n} \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { \ncontinue ; \n} \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) { \nLOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \n} \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo ++ ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \nreturn ; \n} \n} \n"}
{"6829": "public class ObjectPropertyTaxonomyComputationFactory { \nprivate void instertIntoTaxonomy ( final IndexedObjectProperty property ) { \nfinal Map < IndexedObjectProperty , ElkObjectProperty > equivalent = collectEquivalent ( property ) ; \nif ( equivalent == null ) { \nreturn ; \n} \nfinal Map < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > subEquivalent = new ArrayHashMap < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > ( ) ; \nfinal Set < IndexedObjectProperty > indirect = new ArrayHashSet < IndexedObjectProperty > ( ) ; \nfor ( final IndexedObjectProperty subProperty : property . getSaturated ( ) . getSubProperties ( ) ) { \nif ( equivalent . containsKey ( subProperty ) ) { \ncontinue ; \n} \nfinal Map < IndexedObjectProperty , ElkObjectProperty > subEq = collectEquivalent ( subProperty ) ; \nsubEquivalent . put ( subProperty , subEq . values ( ) ) ; \nfor ( final IndexedObjectProperty subSubProperty : subProperty . getSaturated ( ) . getSubProperties ( ) ) { \nif ( ! subEq . containsKey ( subSubProperty ) ) { \nindirect . add ( subSubProperty ) ; \n} \n} \n} \nif ( subEquivalent . isEmpty ( ) && ( indexedBottomProperty_ == null || ! equivalent . containsKey ( indexedBottomProperty_ ) ) ) { \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , defaultDirectSubproperties_ ) ) ; \nreturn ; \n} \nfinal Collection < Collection < ? extends ElkObjectProperty > > direct = Operations . map ( subEquivalent . entrySet ( ) , new Operations . Transformation < Map . Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > , Collection < ? extends ElkObjectProperty > > ( ) { \n@ Override public Collection < ? extends ElkObjectProperty > transform ( final Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > element ) { \nif ( indirect . contains ( element . getKey ( ) ) ) { \nreturn null ; \n} \nelse { \nreturn element . getValue ( ) ; \n} \n} \n} \n) ; \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , direct ) ) ; \nreturn ; \n} \n} \n"}
{"6830": "public class AbstractReasonerState { \npublic synchronized void ensureLoading ( ) throws ElkException { \nif ( ! isLoadingFinished ( ) ) { \nif ( isIncrementalMode ( ) ) { \nif ( ! stageManager . incrementalAdditionStage . isCompleted ( ) ) { \ncomplete ( stageManager . incrementalAdditionStage ) ; \n} \n} \nelse { \nif ( ! stageManager . contextInitializationStage . isCompleted ( ) ) { \ncomplete ( stageManager . contextInitializationStage ) ; \n} \n} \nLOGGER_ . trace ( \"Reset axiom loading\" ) ; \nstageManager . inputLoadingStage . invalidateRecursive ( ) ; \nstageManager . contextInitializationStage . invalidateRecursive ( ) ; \nstageManager . incrementalCompletionStage . invalidateRecursive ( ) ; \n} \ncomplete ( stageManager . inputLoadingStage ) ; \nreturn ; \n} \n} \n"}
{"6831": "public class AbstractReasonerState { \nprivate void restoreSaturation ( ) throws ElkException { \nensureLoading ( ) ; \nfinal boolean changed ; \nif ( isIncrementalMode ( ) ) { \nchanged = ! stageManager . incrementalTaxonomyCleaningStage . isCompleted ( ) ; \ncomplete ( stageManager . incrementalTaxonomyCleaningStage ) ; \n} \nelse { \nchanged = ! stageManager . contextInitializationStage . isCompleted ( ) ; \ncomplete ( stageManager . contextInitializationStage ) ; \n} \nif ( changed ) { \nstageManager . consistencyCheckingStage . invalidateRecursive ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6837": "public class AbstractReasonerStage { \npublic void invalidateRecursive ( ) { \nQueue < AbstractReasonerStage > toInvalidate_ = new LinkedList < AbstractReasonerStage > ( ) ; \ntoInvalidate_ . add ( this ) ; \nAbstractReasonerStage next ; \nwhile ( ( next = toInvalidate_ . poll ( ) ) != null ) { \nif ( next . invalidate ( ) ) { \nfor ( AbstractReasonerStage postStage : next . postStages_ ) { \ntoInvalidate_ . add ( postStage ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6841": "public class LinearProbing { \nstatic < E > void remove ( E [ ] d , int pos ) { \nfor ( ; \n; \n) { \nint next = getMovedPosition ( d , pos ) ; \nE moved = d [ pos ] = d [ next ] ; \nif ( moved == null ) return ; \npos = next ; \n} \nreturn ; \n} \n} \n"}
{"6842": "public class LinearProbing { \nstatic < K , V > void remove ( K [ ] k , V [ ] v , int pos ) { \nfor ( ; \n; \n) { \nint next = getMovedPosition ( k , pos ) ; \nK moved = k [ pos ] = k [ next ] ; \nv [ pos ] = v [ next ] ; \nif ( moved == null ) return ; \npos = next ; \n} \nreturn ; \n} \n} \n"}
{"6846": "public class CachedIndexedComplexClassExpressionImpl { \npublic final void checkOccurrenceNumbers ( ) { \nif ( LOGGER_ . isTraceEnabled ( ) ) LOGGER_ . trace ( toString ( ) + \" occurences: \" + printOccurrenceNumbers ( ) ) ; \nif ( positiveOccurrenceNo < 0 || negativeOccurrenceNo < 0 ) throw new ElkUnexpectedIndexingException ( toString ( ) + \" has a negative occurrence: \" + printOccurrenceNumbers ( ) ) ; \nreturn ; \n} \n} \n"}
{"6847": "public class ClassConclusionTimer { \npublic synchronized void add ( ClassConclusionTimer timer ) { \nthis . timeComposedSubsumers += timer . timeComposedSubsumers ; \nthis . timeDecomposedSubsumers += timer . timeDecomposedSubsumers ; \nthis . timeBackwardLinks += timer . timeBackwardLinks ; \nthis . timeForwardLinks += timer . timeForwardLinks ; \nthis . timeContradictions += timer . timeContradictions ; \nthis . timePropagations += timer . timePropagations ; \nthis . timeDisjointSubsumers += timer . timeDisjointSubsumers ; \nthis . timeContextInitializations += timer . timeContextInitializations ; \nthis . timeSubContextInitializations += timer . timeSubContextInitializations ; \nreturn ; \n} \n} \n"}
{"6848": "public class RuleApplicationTimer { \npublic synchronized void add ( RuleApplicationTimer timer ) { \ntimeOwlThingContextInitRule += timer . timeOwlThingContextInitRule ; \ntimeRootContextInitializationRule += timer . timeRootContextInitializationRule ; \ntimeDisjointSubsumerFromMemberRule += timer . timeDisjointSubsumerFromMemberRule ; \ntimeContradictionFromNegationRule += timer . timeContradictionFromNegationRule ; \ntimeObjectIntersectionFromFirstConjunctRule += timer . timeObjectIntersectionFromFirstConjunctRule ; \ntimeObjectIntersectionFromSecondConjunctRule += timer . timeObjectIntersectionFromSecondConjunctRule ; \ntimeSuperClassFromSubClassRule += timer . timeSuperClassFromSubClassRule ; \ntimePropagationFromExistentialFillerRule += timer . timePropagationFromExistentialFillerRule ; \ntimeObjectUnionFromDisjunctRule += timer . timeObjectUnionFromDisjunctRule ; \ntimeBackwardLinkChainFromBackwardLinkRule += timer . timeBackwardLinkChainFromBackwardLinkRule ; \ntimeReflexiveBackwardLinkCompositionRule += timer . timeReflexiveBackwardLinkCompositionRule ; \ntimeNonReflexiveBackwardLinkCompositionRule += timer . timeNonReflexiveBackwardLinkCompositionRule ; \ntimeSubsumerBackwardLinkRule += timer . timeSubsumerBackwardLinkRule ; \ntimeContradictionOverBackwardLinkRule += timer . timeContradictionOverBackwardLinkRule ; \ntimeContradictionPropagationRule += timer . timeContradictionPropagationRule ; \ntimeContradictionCompositionRule += timer . timeContradictionCompositionRule ; \ntimeIndexedObjectIntersectionOfDecomposition += timer . timeIndexedObjectIntersectionOfDecomposition ; \ntimeIndexedObjectSomeValuesFromDecomposition += timer . timeIndexedObjectSomeValuesFromDecomposition ; \ntimeIndexedObjectComplementOfDecomposition += timer . timeIndexedObjectComplementOfDecomposition ; \ntimeIndexedObjectHasSelfDecomposition += timer . timeIndexedObjectHasSelfDecomposition ; \ntimeContradictionFromOwlNothingRule += timer . timeContradictionFromOwlNothingRule ; \ntimeSubsumerPropagationRule += timer . timeSubsumerPropagationRule ; \ntimePropagationInitializationRule += timer . timePropagationInitializationRule ; \ntimeBackwardLinkFromForwardLinkRule += timer . timeBackwardLinkFromForwardLinkRule ; \ntimeComposedFromDecomposedSubsumerRule += timer . timeComposedFromDecomposedSubsumerRule ; \ntimeIndexedClassDecompositionRule += timer . timeIndexedClassDecompositionRule ; \ntimeIndexedClassFromDefinitionRule += timer . timeIndexedClassFromDefinitionRule ; \ntimeEquivalentClassFirstFromSecondRule += timer . timeEquivalentClassFirstFromSecondRule ; \ntimeEquivalentClassSecondFromFirstRule += timer . timeEquivalentClassSecondFromFirstRule ; \nreturn ; \n} \n} \n"}
{"6851": "public class ArrayHashMap { \nprivate void enlarge ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( \"Map cannot grow beyond capacity: \" + LinearProbing . MAXIMUM_CAPACITY ) ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity << 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \ni < oldCapacity ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \nreturn ; \n} \n} \n"}
{"6852": "public class ArrayHashMap { \nprivate void shrink ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity <= LinearProbing . DEFAULT_INITIAL_CAPACITY ) return ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity >> 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \ni < oldCapacity ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \nreturn ; \n} \n} \n"}
{"6853": "public class ConfigurationFactory { \npublic void saveConfiguration ( File configOnDisk , BaseConfiguration config ) throws ConfigurationException , IOException { \nInputStream stream = null ; \nBaseConfiguration loadedConfig = null ; \nProperties diskProps = new Properties ( ) ; \ntry { \nstream = new FileInputStream ( configOnDisk ) ; \nloadedConfig = getConfiguration ( stream , \"\" , config . getClass ( ) ) ; \ncopyParameters ( loadedConfig , diskProps ) ; \n} \ncatch ( Throwable e ) { \nLOGGER_ . info ( \"Overwriting configuration since it can't be loaded (perhaps doesn't exist?)\" ) ; \n} \nfinally { \nIOUtils . closeQuietly ( stream ) ; \n} \ncopyParameters ( config , diskProps ) ; \nsaveProperties ( diskProps , configOnDisk ) ; \nreturn ; \n} \n} \n"}
{"6854": "public class OreTaxonomyPrinter { \nprotected static void printDeclarations ( Taxonomy < ElkClass > classTaxonomy , ElkObject . Factory objectFactory , Appendable writer ) throws IOException { \nList < ElkClass > classes = new ArrayList < ElkClass > ( classTaxonomy . getNodes ( ) . size ( ) * 2 ) ; \nfor ( TaxonomyNode < ElkClass > classNode : classTaxonomy . getNodes ( ) ) { \nfor ( ElkClass clazz : classNode ) { \nif ( ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_THING ) && ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_NOTHING ) ) { \nclasses . add ( clazz ) ; \n} \n} \n} \nCollections . sort ( classes , CLASS_COMPARATOR ) ; \nfor ( ElkClass clazz : classes ) { \nElkDeclarationAxiom decl = objectFactory . getDeclarationAxiom ( clazz ) ; \nOwlFunctionalStylePrinter . append ( writer , decl , true ) ; \nwriter . append ( '\\n' ) ; \n} \nreturn ; \n} \n} \n"}
{"6856": "public class EntryCollection { \n@ Override public void clear ( ) { \nmodCount ++ ; \nE [ ] tab = buckets ; \nfor ( int i = 0 ; \ni < tab . length ; \ni ++ ) tab [ i ] = null ; \nsize = 0 ; \nreturn ; \n} \n} \n"}
{"6861": "public class TaxonomyPrinter { \nprotected static < T extends ElkEntity > void processTaxomomy ( final Taxonomy < T > taxonomy , final Appendable writer ) throws IOException { \nfinal ElkObject . Factory factory = new ElkObjectEntityRecyclingFactory ( ) ; \nfinal List < T > members = new ArrayList < T > ( taxonomy . getNodes ( ) . size ( ) * 2 ) ; \nfor ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { \nfor ( final T member : node ) { \nif ( ! member . getIri ( ) . equals ( taxonomy . getTopNode ( ) . getCanonicalMember ( ) . getIri ( ) ) && ! member . getIri ( ) . equals ( taxonomy . getBottomNode ( ) . getCanonicalMember ( ) . getIri ( ) ) ) { \nmembers . add ( member ) ; \n} \n} \n} \nCollections . sort ( members , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nprintDeclarations ( members , factory , writer ) ; \nfinal TreeSet < T > canonicalMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfor ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { \ncanonicalMembers . add ( node . getCanonicalMember ( ) ) ; \n} \nfor ( final T canonicalMember : canonicalMembers ) { \nfinal TaxonomyNode < T > node = taxonomy . getNode ( canonicalMember ) ; \nfinal ArrayList < T > orderedEquivalentMembers = new ArrayList < T > ( node . size ( ) ) ; \nfor ( final T member : node ) { \norderedEquivalentMembers . add ( member ) ; \n} \nCollections . sort ( orderedEquivalentMembers , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfinal TreeSet < T > orderedSuperMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfor ( final TaxonomyNode < T > superNode : node . getDirectSuperNodes ( ) ) { \norderedSuperMembers . add ( superNode . getCanonicalMember ( ) ) ; \n} \nprintMemberAxioms ( canonicalMember , orderedEquivalentMembers , orderedSuperMembers , taxonomy , factory , writer ) ; \n} \nreturn ; \n} \n} \n"}
{"6863": "public class OwlFunctionalStylePrinter { \npublic static void append ( Appendable appender , ElkObject elkObject ) throws IOException { \nappend ( appender , elkObject , false ) ; \nreturn ; \n} \n} \n"}
{"6865": "public class IndividualNode { \n@ Override public synchronized void addDirectTypeNode ( final UTN typeNode ) { \nLOGGER_ . trace ( \"{}: new direct type-node {}\" , this , typeNode ) ; \ndirectTypeNodes_ . add ( typeNode ) ; \nreturn ; \n} \n} \n"}
{"6866": "public class AbstractMatch { \nprotected static void checkChainMatch ( final ElkSubObjectPropertyExpression fullChain , final int startPos ) { \nfullChain . accept ( new ElkSubObjectPropertyExpressionVisitor < Void > ( ) { \nvoid fail ( ) { \nthrow new IllegalArgumentException ( fullChain + \", \" + startPos ) ; \nreturn ; \n} \nVoid defaultVisit ( ElkObjectPropertyExpression expression ) { \nif ( startPos != 0 ) { \nfail ( ) ; \n} \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectPropertyChain expression ) { \nif ( startPos < 0 || startPos >= expression . getObjectPropertyExpressions ( ) . size ( ) ) fail ( ) ; \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectInverseOf expression ) { \nreturn defaultVisit ( expression ) ; \n} \n@ Override public Void visit ( ElkObjectProperty expression ) { \nreturn defaultVisit ( expression ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"6867": "public class Operations { \npublic static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition , final int size ) { \nreturn new Set < T > ( ) { \n@ Override public int size ( ) { \nreturn size ; \n} \n@ Override public boolean isEmpty ( ) { \nreturn size == 0 ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public boolean contains ( Object o ) { \nif ( ! input . contains ( o ) ) return false ; \nT elem = null ; \ntry { \nelem = ( T ) o ; \n} \ncatch ( ClassCastException cce ) { \nreturn false ; \n} \nreturn condition . holds ( elem ) ; \n} \n@ Override public Iterator < T > iterator ( ) { \nreturn filter ( input , condition ) . iterator ( ) ; \n} \n@ Override public Object [ ] toArray ( ) { \nObject [ ] result = new Object [ size ] ; \nint i = 0 ; \nfor ( Object o : filter ( input , condition ) ) { \nresult [ i ++ ] = o ; \n} \nreturn result ; \n} \n@ Override public < S > S [ ] toArray ( S [ ] a ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean add ( T e ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean containsAll ( Collection < ? > c ) { \nfor ( Object o : c ) { \nif ( contains ( o ) ) return false ; \n} \nreturn true ; \n} \n@ Override public boolean addAll ( Collection < ? extends T > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean retainAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public void clear ( ) { \nthrow new UnsupportedOperationException ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"6871": "public class ClassConclusionCounter { \npublic synchronized void add ( ClassConclusionCounter counter ) { \nthis . countSubClassInclusionDecomposed += counter . countSubClassInclusionDecomposed ; \nthis . countSubClassInclusionComposed += counter . countSubClassInclusionComposed ; \nthis . countBackwardLink += counter . countBackwardLink ; \nthis . countForwardLink += counter . countForwardLink ; \nthis . countContradiction += counter . countContradiction ; \nthis . countPropagation += counter . countPropagation ; \nthis . countDisjointSubsumer += counter . countDisjointSubsumer ; \nthis . countContextInitialization += counter . countContextInitialization ; \nthis . countSubContextInitialization += counter . countSubContextInitialization ; \nreturn ; \n} \n} \n"}
{"6872": "public class Statistics { \npublic static void logMemoryUsage ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nRuntime runtime = Runtime . getRuntime ( ) ; \nLoggerWrap . log ( logger , priority , \"Memory (MB) Used/Total/Max: \" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / megaBytes + \"/\" + runtime . totalMemory ( ) / megaBytes + \"/\" + runtime . maxMemory ( ) / megaBytes ) ; \n} \nreturn ; \n} \n} \n"}
{"6873": "public class Reasoner { \npublic synchronized void setConfigurationOptions ( ReasonerConfiguration config ) { \nthis . workerNo_ = config . getParameterAsInt ( ReasonerConfiguration . NUM_OF_WORKING_THREADS ) ; \nsetAllowIncrementalMode ( config . getParameterAsBoolean ( ReasonerConfiguration . INCREMENTAL_MODE_ALLOWED ) ) ; \nreturn ; \n} \n} \n"}
{"6875": "public class StatisticsPrinter { \npublic void printHeader ( ) { \nprintSeparator ( ) ; \naddPadding ( ' ' , headerParams_ ) ; \nlogger_ . debug ( String . format ( headerFormat_ , headerParams_ ) ) ; \nprintSeparator ( ) ; \nreturn ; \n} \n} \n"}
{"6876": "public class StatisticsPrinter { \npublic void print ( Object ... values ) { \naddPadding ( '.' , values ) ; \nlogger_ . debug ( String . format ( valuesFormat_ , values ) ) ; \nreturn ; \n} \n} \n"}
{"6878": "public class RuleCounter { \npublic synchronized void add ( RuleCounter counter ) { \ncountOwlThingContextInitRule += counter . countOwlThingContextInitRule ; \ncountRootContextInitializationRule += counter . countRootContextInitializationRule ; \ncountDisjointSubsumerFromMemberRule += counter . countDisjointSubsumerFromMemberRule ; \ncountContradictionFromNegationRule += counter . countContradictionFromNegationRule ; \ncountObjectIntersectionFromFirstConjunctRule += counter . countObjectIntersectionFromFirstConjunctRule ; \ncountObjectIntersectionFromSecondConjunctRule += counter . countObjectIntersectionFromSecondConjunctRule ; \ncountSuperClassFromSubClassRule += counter . countSuperClassFromSubClassRule ; \ncountPropagationFromExistentialFillerRule += counter . countPropagationFromExistentialFillerRule ; \ncountObjectUnionFromDisjunctRule += counter . countObjectUnionFromDisjunctRule ; \ncountBackwardLinkChainFromBackwardLinkRule += counter . countBackwardLinkChainFromBackwardLinkRule ; \ncountSubsumerBackwardLinkRule += counter . countSubsumerBackwardLinkRule ; \ncountContradictionOverBackwardLinkRule += counter . countContradictionOverBackwardLinkRule ; \ncountContradictionPropagationRule += counter . countContradictionPropagationRule ; \ncountContradictionCompositionRule += counter . countContradictionCompositionRule ; \ncountNonReflexiveBackwardLinkCompositionRule += counter . countNonReflexiveBackwardLinkCompositionRule ; \ncountIndexedObjectIntersectionOfDecomposition += counter . countIndexedObjectIntersectionOfDecomposition ; \ncountIndexedObjectSomeValuesFromDecomposition += counter . countIndexedObjectSomeValuesFromDecomposition ; \ncountIndexedObjectComplementOfDecomposition += counter . countIndexedObjectComplementOfDecomposition ; \ncountIndexedObjectHasSelfDecomposition += counter . countIndexedObjectHasSelfDecomposition ; \ncountContradictionFromOwlNothingRule += counter . countContradictionFromOwlNothingRule ; \ncountSubsumerPropagationRule += counter . countSubsumerPropagationRule ; \ncountReflexiveBackwardLinkCompositionRule += counter . countReflexiveBackwardLinkCompositionRule ; \ncountPropagationInitializationRule += counter . countPropagationInitializationRule ; \ncountBackwardLinkFromForwardLinkRule += counter . countBackwardLinkFromForwardLinkRule ; \ncountComposedFromDecomposedSubsumerRule += counter . countComposedFromDecomposedSubsumerRule ; \ncountIndexedClassDecompositionRule += counter . countIndexedClassDecompositionRule ; \ncountIndexedClassFromDefinitionRule += counter . countIndexedClassFromDefinitionRule ; \ncountEquivalentClassFirstFromSecondRule += counter . countEquivalentClassFirstFromSecondRule ; \ncountEquivalentClassSecondFromFirstRule += counter . countEquivalentClassSecondFromFirstRule ; \nreturn ; \n} \n} \n"}
{"6879": "public class XhtmlResourceMessageConverter { \nprivate void writeResource ( XhtmlWriter writer , Object object ) { \nif ( object == null ) { \nreturn ; \n} \ntry { \nif ( object instanceof Resource ) { \nResource < ? > resource = ( Resource < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriteResource ( writer , resource . getContent ( ) ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse if ( object instanceof Resources ) { \nResources < ? > resources = ( Resources < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriter . beginUnorderedList ( ) ; \nCollection < ? > content = resources . getContent ( ) ; \nwriteResource ( writer , content ) ; \nwriter . endUnorderedList ( ) ; \nwriter . writeLinks ( resources . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse if ( object instanceof ResourceSupport ) { \nResourceSupport resource = ( ResourceSupport ) object ; \nwriter . beginListItem ( ) ; \nwriteObject ( writer , resource ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse if ( object instanceof Collection ) { \nCollection < ? > collection = ( Collection < ? > ) object ; \nfor ( Object item : collection ) { \nwriteResource ( writer , item ) ; \n} \n} \nelse { \nwriteObject ( writer , object ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( \"failed to transform object \" + object , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"6884": "public class Affordance { \npublic void addRel ( String rel ) { \nAssert . hasLength ( rel ) ; \nlinkParams . add ( REL . paramName , rel ) ; \nreturn ; \n} \n} \n"}
{"6885": "public class Affordance { \npublic void setType ( String mediaType ) { \nif ( mediaType != null ) linkParams . set ( TYPE . paramName , mediaType ) ; \nelse linkParams . remove ( TYPE . paramName ) ; \nreturn ; \n} \n} \n"}
{"6886": "public class Affordance { \npublic void addHreflang ( String hreflang ) { \nAssert . hasLength ( hreflang ) ; \nlinkParams . add ( HREFLANG . paramName , hreflang ) ; \nreturn ; \n} \n} \n"}
{"6887": "public class Affordance { \npublic void addRev ( String rev ) { \nAssert . hasLength ( rev ) ; \nlinkParams . add ( REV . paramName , rev ) ; \nreturn ; \n} \n} \n"}
{"6888": "public class Affordance { \npublic void addLinkParam ( String paramName , String ... values ) { \nAssert . notEmpty ( values ) ; \nfor ( String value : values ) { \nAssert . hasLength ( value ) ; \nlinkParams . add ( paramName , value ) ; \n} \nreturn ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( possibleValues . length > 0 ) { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \nelse { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \nfor ( int i = 0 ; \ni < items ; \ni ++ ) { \nObject value ; \nif ( i < callValues . length ) { \nvalue = callValues [ i ] ; \n} \nelse { \nvalue = null ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \nreturn ; \n} \n} \n"}
{"6904": "public class XhtmlWriter { \nprivate void inputButton ( Type type , String value ) throws IOException { \nwrite ( \"<input type=\\\"\" ) ; \nwrite ( type . toString ( ) ) ; \nwrite ( \"\\\" \" ) ; \nwrite ( \"value\" ) ; \nwrite ( \"=\" ) ; \nquote ( ) ; \nwrite ( value ) ; \nquote ( ) ; \nwrite ( \"/>\" ) ; \nreturn ; \n} \n} \n"}
{"6905": "public class XhtmlWriter { \nprivate void appendInputOrSelect ( ActionInputParameter parentInputParameter , String paramName , ActionInputParameter childInputParameter , Object [ ] possibleValues ) throws IOException { \nif ( possibleValues . length > 0 ) { \nif ( childInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( paramName , possibleValues , childInputParameter ) ; \n} \nelse { \nappendSelectOne ( paramName , possibleValues , childInputParameter ) ; \n} \n} \nelse { \nappendInput ( paramName , childInputParameter , childInputParameter . getValue ( ) , parentInputParameter . isReadOnly ( paramName ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6911": "public class AbstractUberNode { \n@ Override public Iterator < UberNode > iterator ( ) { \nreturn new Iterator < UberNode > ( ) { \nint index = 0 ; \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( \"removing from uber node is not supported\" ) ; \nreturn ; \n} \n@ Override public UberNode next ( ) { \nindex = findNextChildWithData ( ) ; \nreturn data . get ( index ++ ) ; \n} \n@ Override public boolean hasNext ( ) { \nreturn findNextChildWithData ( ) != - 1 ; \n} \nprivate int findNextChildWithData ( ) { \nfor ( int i = index ; \ni < data . size ( ) ; \ni ++ ) { \nif ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n; \n} \n} \n"}
{"6938": "public class SleeTransactionImpl { \nprivate void suspendIfAssoaciatedWithThread ( ) throws SystemException { \nfinal SleeTransaction currentThreadTransaction = transactionManager . getSleeTransaction ( ) ; \nif ( currentThreadTransaction != null && currentThreadTransaction . equals ( this ) ) { \ntransactionManager . getRealTransactionManager ( ) . suspend ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6939": "public class SleeTransactionImpl { \nprivate void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { \ntry { \nint status = transaction . getStatus ( ) ; \nif ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) ) { \nthrow new IllegalStateException ( \"There is no active tx, tx is in state: \" + status ) ; \n} \nsuspendIfAssoaciatedWithThread ( ) ; \n} \ncatch ( SystemException e ) { \nthrow new IllegalStateException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"6941": "public class ConcreteClassGeneratorUtils { \nstatic private void validateDirectory ( File aDirectory ) throws FileNotFoundException { \nif ( aDirectory == null ) { \nthrow new IllegalArgumentException ( \"Directory should not be null.\" ) ; \n} \nif ( ! aDirectory . exists ( ) ) { \nthrow new FileNotFoundException ( \"Directory does not exist: \" + aDirectory ) ; \n} \nif ( ! aDirectory . isDirectory ( ) ) { \nthrow new IllegalArgumentException ( \"Is not a directory: \" + aDirectory ) ; \n} \nif ( ! aDirectory . canRead ( ) ) { \nthrow new IllegalArgumentException ( \"Directory cannot be read: \" + aDirectory ) ; \n} \nreturn ; \n} \n} \n"}
{"6942": "public class ConcreteClassGeneratorUtils { \npublic static void createInheritanceLink ( CtClass concreteClass , CtClass superClass ) { \nif ( superClass == null ) return ; \ntry { \nconcreteClass . setSuperclass ( superClass ) ; \nlogger . trace ( concreteClass . getName ( ) + \" Inheritance link with \" + superClass . getName ( ) + \" class created\" ) ; \n} \ncatch ( CannotCompileException cce ) { \ncce . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6943": "public class ConcreteClassGeneratorUtils { \npublic static void copyMethods ( CtClass source , CtClass destination , CtClass [ ] exceptions ) { \ncopyMethods ( source . getDeclaredMethods ( ) , destination , exceptions ) ; \nreturn ; \n} \n} \n"}
{"6944": "public class ConcreteClassGeneratorUtils { \npublic static void copyMethods ( CtMethod [ ] methods , CtClass destination , CtClass [ ] exceptions ) { \nCtMethod methodCopy = null ; \nfor ( CtMethod method : methods ) { \ntry { \nmethodCopy = new CtMethod ( method , destination , null ) ; \nif ( exceptions != null ) { \ntry { \nmethodCopy . setExceptionTypes ( exceptions ) ; \n} \ncatch ( NotFoundException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \ndestination . addMethod ( methodCopy ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6946": "public class SbbEntityFactoryImpl { \nprivate void removeSbbEntityWithCurrentClassLoader ( final SbbEntity sbbEntity ) { \nsbbEntity . remove ( ) ; \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nfinal SbbEntityID sbbEntityID = sbbEntity . getSbbEntityId ( ) ; \ntxContext . getData ( ) . remove ( sbbEntityID ) ; \nif ( sbbEntityID . isRootSbbEntity ( ) ) { \nTransactionalAction txAction = new TransactionalAction ( ) { \n@ Override public void execute ( ) { \nlockFacility . remove ( sbbEntityID ) ; \nreturn ; \n} \n} \n; \ntxContext . getAfterCommitActions ( ) . add ( txAction ) ; \n} \nreturn ; \n} \n} \n"}
{"6949": "public class ServiceManagementImpl { \npublic void installService ( final ServiceComponent serviceComponent ) throws Exception { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Installing Service \" + serviceComponent ) ; \n} \nfinal ServiceUsageMBean serviceUsageMBean = sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nserviceUsageMBean . remove ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n; \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \naction = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nreturn ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nNotificationSourceWrapperImpl sbbMNotificationSource = new NotificationSourceWrapperImpl ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nserviceComponent . getAlarmNotificationSources ( ) . putIfAbsent ( sbbID , sbbMNotificationSource ) ; \n} \nsleeContainer . getSbbManagement ( ) . serviceInstall ( serviceComponent ) ; \nreturn ; \n} \n} \n"}
{"6950": "public class ServiceManagementImpl { \npublic void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; \n} \nif ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { \nfor ( int i = 0 ; \ni < 15 ; \ni ++ ) { \ntry { \nThread . sleep ( 1000 ) ; \nlogger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nbreak ; \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \nif ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nthrow new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; \n} \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; \n} \nServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; \nif ( serviceUsageMBean != null ) { \nserviceUsageMBean . remove ( ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nsleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nreturn ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nsleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; \nreturn ; \n} \n} \n"}
{"6953": "public class ServiceUsageMBeanImpl { \npublic synchronized void resetAllUsageParameters ( ) throws ManagementException { \ntry { \nfor ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { \nusageMBeanImpl . resetAllUsageParameters ( ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"6957": "public class AbstractOperation { \npublic void displayResult ( ) { \nif ( ! context . isQuiet ( ) ) { \nString resultText = prepareResultText ( ) ; \nPrintWriter out = context . getWriter ( ) ; \nout . println ( resultText ) ; \nout . flush ( ) ; \n} \nreturn ; \n} \n} \n"}
{"6959": "public class SleeEndpointFireEventNotTransactedExecutor { \nvoid execute ( final ActivityHandle realHandle , final ActivityHandle refHandle , final FireableEventType eventType , final Object event , final Address address , final ReceivableService receivableService , final int eventFlags ) throws ActivityIsEndingException , FireEventException , SLEEException , UnrecognizedActivityHandleException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \ntry { \nsleeEndpoint . _fireEvent ( realHandle , refHandle , eventType , event , address , receivableService , eventFlags , tx ) ; \n} \nfinally { \nif ( tx != null ) { \nsuper . resumeTransaction ( tx ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6960": "public class ActivityContextNamingFacilityCacheData { \npublic void bindName ( Object ach , String name ) throws NameAlreadyBoundException { \nfinal Node node = getNode ( ) ; \nif ( node . hasChild ( name ) ) { \nthrow new NameAlreadyBoundException ( \"name already bound\" ) ; \n} \nelse { \nnode . addChild ( Fqn . fromElements ( name ) ) . put ( CACHE_NODE_MAP_KEY , ach ) ; \n} \nreturn ; \n} \n} \n"}
{"6966": "public class DeployableUnitJarComponentBuilder { \nprivate void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { \nJarInputStream jarIs = null ; \ntry { \njarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; \nfor ( JarEntry entry = jarIs . getNextJarEntry ( ) ; \njarIs . available ( ) > 0 && entry != null ; \nentry = jarIs . getNextJarEntry ( ) ) { \nlogger . trace ( \"jar entry = \" + entry . getName ( ) ) ; \nif ( entry . isDirectory ( ) ) { \nFile dir = new File ( dstDir , entry . getName ( ) ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \nelse { \nFile file = new File ( dstDir , entry . getName ( ) ) ; \nFile dir = file . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \npipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; \n} \nfinally { \nif ( jarIs != null ) { \ntry { \njarIs . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close jar input stream\" , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6967": "public class DeployableUnitJarComponentBuilder { \nprivate void pipeStream ( InputStream is , OutputStream os ) throws IOException { \nsynchronized ( buffer ) { \ntry { \nfor ( int bytesRead = is . read ( buffer ) ; \nbytesRead != - 1 ; \nbytesRead = is . read ( buffer ) ) os . write ( buffer , 0 , bytesRead ) ; \nis . close ( ) ; \nos . close ( ) ; \n} \ncatch ( IOException ioe ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \ntry { \nos . close ( ) ; \n} \ncatch ( Exception ioexc ) { \n} \nthrow ioe ; \n} \n} \nreturn ; \n} \n} \n"}
{"6977": "public class ActivityContextCacheData { \npublic void nameBound ( String name ) { \nfinal Node node = getNamesBoundNode ( true ) ; \nif ( ! node . hasChild ( name ) ) { \nnode . addChild ( Fqn . fromElements ( name ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6981": "public class ActivityContextCacheData { \n@ SuppressWarnings ( \"unchecked\" ) public void setCmpAttribute ( String attrName , Object attrValue ) { \nfinal Node node = getCmpAttributesNode ( true ) ; \nNode cmpNode = node . getChild ( attrName ) ; \nif ( cmpNode == null ) { \ncmpNode = node . addChild ( Fqn . fromElements ( attrName ) ) ; \n} \ncmpNode . put ( CMP_ATTRIBUTES_NODE_MAP_KEY , attrValue ) ; \nreturn ; \n} \n} \n"}
{"6985": "public class UsageMBeanImpl { \npublic void sendUsageNotification ( long value , long seqno , String usageParameterSetName , String usageParameterName , boolean isCounter ) { \nUsageNotificationManagerMBeanImpl notificationManager = parent . getUsageNotificationManagerMBean ( notificationSource ) ; \nif ( notificationManager == null || notificationManager . getNotificationsEnabled ( usageParameterName ) ) { \nUsageNotification notification = createUsageNotification ( value , seqno , usageParameterSetName , usageParameterName , isCounter ) ; \nfor ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { \nif ( triplet . notificationFilter == null || triplet . notificationFilter . isNotificationEnabled ( notification ) ) { \ntriplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"6987": "public class DeploymentManager { \npublic void updateDeployedComponents ( ) { \ntry { \nComponentRepository componentRepository = sleeContainerDeployer . getSleeContainer ( ) . getComponentRepository ( ) ; \nConcurrentLinkedQueue < String > newDeployedComponents = new ConcurrentLinkedQueue < String > ( ) ; \nfor ( ComponentID componentID : componentRepository . getProfileSpecificationIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nfor ( ComponentID componentID : componentRepository . getEventComponentIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nfor ( ComponentID componentID : componentRepository . getResourceAdaptorTypeIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nfor ( ComponentID componentID : componentRepository . getResourceAdaptorIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nfor ( ComponentID componentID : componentRepository . getSbbIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nfor ( ComponentID componentID : componentRepository . getServiceIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nfor ( ComponentID componentID : componentRepository . getLibraryIDs ( ) ) { \nnewDeployedComponents . add ( componentID . toString ( ) ) ; \n} \nResourceManagement resourceManagement = sleeContainerDeployer . getSleeContainer ( ) . getResourceManagement ( ) ; \nString [ ] entityNames = resourceManagement . getResourceAdaptorEntities ( ) ; \nfor ( String entityName : entityNames ) { \nnewDeployedComponents . addAll ( Arrays . asList ( resourceManagement . getLinkNames ( entityName ) ) ) ; \n} \ndeployedComponents = newDeployedComponents ; \n} \ncatch ( Exception e ) { \nlogger . warn ( \"Failure while updating deployed components.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"6988": "public class DeploymentManager { \npublic void installDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( du . isReadyToInstall ( true ) ) { \nsciAction ( du . getInstallActions ( ) , du ) ; \ndu . setInstalled ( true ) ; \ndeployedDUs . add ( du ) ; \nupdateDeployedComponents ( ) ; \nIterator < DeployableUnit > duIt = waitingForInstallDUs . iterator ( ) ; \nwhile ( duIt . hasNext ( ) ) { \nDeployableUnit waitingDU = duIt . next ( ) ; \nif ( waitingDU . isReadyToInstall ( false ) ) { \nsciAction ( waitingDU . getInstallActions ( ) , waitingDU ) ; \nwaitingDU . setInstalled ( true ) ; \ndeployedDUs . add ( waitingDU ) ; \nupdateDeployedComponents ( ) ; \nwaitingForInstallDUs . remove ( waitingDU ) ; \nduIt = waitingForInstallDUs . iterator ( ) ; \n} \n} \n} \nelse { \nlogger . warn ( \"Unable to INSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependencies to be resolved.\" ) ; \nwaitingForInstallDUs . add ( du ) ; \n} \nreturn ; \n} \n} \n"}
{"6989": "public class DeploymentManager { \npublic void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( ! du . isInstalled ( ) ) { \nif ( waitingForInstallDUs . remove ( du ) ) { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" wasn't deployed. Removing from waiting list.\" ) ; \n} \n} \nelse if ( ! du . areComponentsStillPresent ( ) ) { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" components already removed. Removing DU info.\" ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse if ( du . isReadyToUninstall ( ) ) { \nsciAction ( du . getUninstallActions ( ) , du ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse { \nif ( ! waitingForUninstallDUs . contains ( du ) ) { \nwaitingForUninstallDUs . add ( du ) ; \nlogger . warn ( \"Unable to UNINSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependents to be removed.\" ) ; \n} \nthrow new DependencyException ( \"Unable to undeploy \" + du . getDeploymentInfoShortName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"6990": "public class DeploymentManager { \nprivate void processInternalUndeploy ( DeployableUnit du ) throws Exception { \ndu . setInstalled ( false ) ; \nwaitingForUninstallDUs . remove ( du ) ; \nupdateDeployedComponents ( ) ; \nIterator < DeployableUnit > duIt = waitingForUninstallDUs . iterator ( ) ; \nwhile ( duIt . hasNext ( ) ) { \nDeployableUnit waitingDU = duIt . next ( ) ; \nif ( waitingDU . isReadyToUninstall ( ) ) { \nsleeContainerDeployer . getSleeSubDeployer ( ) . stop ( waitingDU . getURL ( ) , waitingDU . getDeploymentInfoShortName ( ) ) ; \nwaitingForUninstallDUs . remove ( waitingDU ) ; \nduIt = waitingForUninstallDUs . iterator ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"6999": "public class ProfileTableImpl { \npublic void remove ( boolean isUninstall ) throws SLEEException { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"removeProfileTable: removing profileTable=\" + profileTableName ) ; \n} \nfor ( ProfileID profileID : getProfiles ( ) ) { \nthis . removeProfile ( profileID . getProfileName ( ) , false , isUninstall ) ; \n} \nif ( getDefaultProfileEntity ( ) != null ) { \nthis . removeProfile ( null , false , false ) ; \n} \nTransactionalAction commitAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \ntraceMBeanImpl . deregisterNotificationSource ( new ProfileTableNotification ( profileTableName ) ) ; \ncloseUncommittedProfileMBeans ( ) ; \nreturn ; \n} \n} \n; \nsleeContainer . getTransactionManager ( ) . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( commitAction ) ; \nif ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { \nendActivity ( ) ; \n} \nunregisterUsageMBean ( ) ; \nprofileManagement . getObjectPoolManagement ( ) . removeObjectPool ( this , sleeContainer . getTransactionManager ( ) ) ; \nreturn ; \n} \n} \n"}
{"7000": "public class ResourceAdaptorEntityImpl { \npublic void updateConfigurationProperties ( ConfigProperties properties ) throws InvalidConfigurationException , InvalidStateException { \nif ( ! component . getDescriptor ( ) . getSupportsActiveReconfiguration ( ) && ( sleeContainer . getSleeState ( ) != SleeState . STOPPED ) && ( state == ResourceAdaptorEntityState . ACTIVE || state == ResourceAdaptorEntityState . STOPPING ) ) { \nthrow new InvalidStateException ( \"the value of the supports-active-reconfiguration attribute of the resource-adaptor-class element in the deployment descriptor of the Resource Adaptor of the resource adaptor entity is False and the resource adaptor entity is in the Active or Stopping state and the SLEE is in the Starting, Running, or Stopping state\" ) ; \n} \nelse { \nobject . raConfigurationUpdate ( properties ) ; \n} \nreturn ; \n} \n} \n"}
{"7001": "public class ResourceAdaptorEntityImpl { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public void sleeRunning ( ) throws InvalidStateException { \nif ( this . state . isActive ( ) ) { \nif ( setFTContext ) { \nsetFTContext = false ; \nif ( object . isFaultTolerant ( ) ) { \ntry { \nthis . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; \nobject . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity \" + name , t ) ; \n} \n} \n} \ntry { \nobject . raActive ( ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking raActive() for entity \" + name , t ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7002": "public class ResourceAdaptorEntityImpl { \npublic void sleeStopping ( ) throws InvalidStateException , TransactionRequiredLocalException { \nif ( state != null && state . isActive ( ) ) { \ntry { \nobject . raStopping ( ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception from RA object\" , t ) ; \n} \nscheduleAllActivitiesEnd ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7003": "public class ResourceAdaptorEntityImpl { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public void activate ( ) throws InvalidStateException { \nif ( ! this . state . isInactive ( ) ) { \nthrow new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \n} \nthis . state = ResourceAdaptorEntityState . ACTIVE ; \nif ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { \nif ( setFTContext ) { \nsetFTContext = false ; \nif ( object . isFaultTolerant ( ) ) { \ntry { \nthis . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; \nobject . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity \" + name , t ) ; \n} \n} \n} \ntry { \nobject . raActive ( ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception invoking raActive() for entity \" + name , t ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7004": "public class ResourceAdaptorEntityImpl { \npublic void deactivate ( ) throws InvalidStateException , TransactionRequiredLocalException { \nif ( ! this . state . isActive ( ) ) { \nthrow new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \n} \nthis . state = ResourceAdaptorEntityState . STOPPING ; \nif ( object . getState ( ) == ResourceAdaptorObjectState . ACTIVE ) { \nobject . raStopping ( ) ; \n} \nTimerTask t = new TimerTask ( ) { \n@ Override public void run ( ) { \ntry { \ncancel ( ) ; \nif ( state == ResourceAdaptorEntityState . STOPPING ) { \nif ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { \nscheduleAllActivitiesEnd ( ) ; \n} \nelse { \nallActivitiesEnded ( ) ; \n} \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n; \nresourceAdaptorContext . getTimer ( ) . schedule ( t , 500 ) ; \nreturn ; \n} \n} \n"}
{"7005": "public class ResourceAdaptorEntityImpl { \nprivate void scheduleAllActivitiesEnd ( ) throws TransactionRequiredLocalException { \nboolean skipActivityEnding = ! sleeContainer . getCluster ( ) . isSingleMember ( ) ; \nif ( ! skipActivityEnding && hasActivities ( ) ) { \nlogger . info ( \"RA entity \" + name + \" activities end scheduled.\" ) ; \ntimerTask = new EndAllActivitiesRAEntityTimerTask ( this , sleeContainer ) ; \n} \nelse { \nallActivitiesEnded ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7006": "public class ResourceAdaptorEntityImpl { \npublic void remove ( ) throws InvalidStateException { \nif ( ! this . state . isInactive ( ) ) { \nthrow new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; \n} \nobject . raUnconfigure ( ) ; \nif ( object . isFaultTolerant ( ) ) { \nobject . unsetFaultTolerantResourceAdaptorContext ( ) ; \nftResourceAdaptorContext . shutdown ( ) ; \n} \nobject . unsetResourceAdaptorContext ( ) ; \nthis . sleeContainer . getTraceManagement ( ) . deregisterNotificationSource ( this . getNotificationSource ( ) ) ; \nstate = null ; \nreturn ; \n} \n} \n"}
{"7008": "public class ResourceAdaptorEntityImpl { \npublic void serviceActive ( ServiceID serviceID ) { \ntry { \nReceivableService receivableService = resourceAdaptorContext . getServiceLookupFacility ( ) . getReceivableService ( serviceID ) ; \nif ( receivableService . getReceivableEvents ( ) . length > 0 ) { \nobject . serviceActive ( receivableService ) ; \n} \n} \ncatch ( Throwable e ) { \nlogger . warn ( \"invocation resulted in unchecked exception\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7010": "public class ResourceAdaptorEntityImpl { \npublic void activityEnded ( final ActivityHandle handle , int activityFlags ) { \nlogger . trace ( \"activityEnded( handle = \" + handle + \" )\" ) ; \nActivityHandle ah = null ; \nif ( handle instanceof ActivityHandleReference ) { \nah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; \n} \nelse { \nah = handle ; \n} \nif ( ah != null && ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) { \nobject . activityEnded ( ah ) ; \n} \nif ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { \nsynchronized ( this ) { \nif ( ! hasActivities ( ) ) { \nif ( timerTask != null ) { \ntimerTask . cancel ( ) ; \n} \nallActivitiesEnded ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7011": "public class ResourceAdaptorObjectImpl { \npublic void raConfigurationUpdate ( ConfigProperties properties ) throws InvalidConfigurationException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raConfigurationUpdate( properties = \" + properties + \" )\" ) ; \n} \nverifyConfigProperties ( properties ) ; \nobject . raConfigurationUpdate ( configProperties ) ; \nreturn ; \n} \n} \n"}
{"7012": "public class ResourceAdaptorObjectImpl { \nprivate void verifyConfigProperties ( ConfigProperties newProperties ) throws InvalidConfigurationException { \nif ( doTraceLogs ) { \nlogger . trace ( \"verifyConfigProperties( newProperties = \" + newProperties + \" )\" ) ; \n} \nfor ( ConfigProperties . Property configProperty : configProperties . getProperties ( ) ) { \nif ( newProperties . getProperty ( configProperty . getName ( ) ) == null ) { \nnewProperties . addProperty ( configProperty ) ; \n} \n} \nfor ( ConfigProperties . Property entityProperty : newProperties . getProperties ( ) ) { \nif ( entityProperty . getValue ( ) == null ) { \nthrow new InvalidConfigurationException ( \"the property \" + entityProperty . getName ( ) + \" has null value\" ) ; \n} \n} \nobject . raVerifyConfiguration ( newProperties ) ; \nconfigProperties = newProperties ; \nreturn ; \n} \n} \n"}
{"7013": "public class ResourceAdaptorObjectImpl { \npublic void raStopping ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raStopping()\" ) ; \n} \nif ( state == ResourceAdaptorObjectState . ACTIVE ) { \nstate = ResourceAdaptorObjectState . STOPPING ; \nobject . raStopping ( ) ; \n} \nelse { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nreturn ; \n} \n} \n"}
{"7014": "public class ResourceAdaptorObjectImpl { \npublic void raInactive ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raInactive()\" ) ; \n} \nif ( state == ResourceAdaptorObjectState . STOPPING ) { \nstate = ResourceAdaptorObjectState . INACTIVE ; \nobject . raInactive ( ) ; \n} \nelse { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nreturn ; \n} \n} \n"}
{"7015": "public class ResourceAdaptorObjectImpl { \npublic void raUnconfigure ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"raUnconfigure()\" ) ; \n} \nif ( state == ResourceAdaptorObjectState . INACTIVE ) { \nstate = ResourceAdaptorObjectState . UNCONFIGURED ; \nobject . raUnconfigure ( ) ; \n} \nelse { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nreturn ; \n} \n} \n"}
{"7016": "public class ResourceAdaptorObjectImpl { \npublic void unsetResourceAdaptorContext ( ) throws InvalidStateException { \nif ( doTraceLogs ) { \nlogger . trace ( \"unsetResourceAdaptorContext()\" ) ; \n} \nif ( state == ResourceAdaptorObjectState . UNCONFIGURED ) { \nobject . unsetResourceAdaptorContext ( ) ; \nstate = null ; \n} \nelse { \nthrow new InvalidStateException ( \"ra object is in state \" + state ) ; \n} \nreturn ; \n} \n} \n"}
{"7017": "public class ResourceAdaptorObjectImpl { \n@ SuppressWarnings ( \"unchecked\" ) public void unsetFaultTolerantResourceAdaptorContext ( ) throws IllegalArgumentException { \nif ( doTraceLogs ) { \nlogger . trace ( \"unsetFaultTolerantResourceAdaptorContext()\" ) ; \n} \nif ( isFaultTolerant ( ) ) { \n( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) . unsetFaultTolerantResourceAdaptorContext ( ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"RA Object is not fault tolerant!\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7018": "public class ProfileSpecificationComponentImpl { \nprivate void buildProfileAttributeMap ( ) throws DeploymentException { \nHashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; \nClass < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; \nString attributeGetterMethodPrefix = \"get\" ; \nfor ( Method method : cmpInterface . getMethods ( ) ) { \nif ( ! method . getDeclaringClass ( ) . equals ( Object . class ) && method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { \nString attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; \nswitch ( attributeName . length ( ) ) { \ncase 0 : throw new DeploymentException ( \"the profile cmp interface class has an invalid attribute getter method name > \" + method . getName ( ) ) ; \ncase 1 : attributeName = attributeName . toLowerCase ( ) ; \nbreak ; \ndefault : attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; \nbreak ; \n} \nProfileAttributeImpl profileAttribute = null ; \ntry { \nprofileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; \n} \ncatch ( Throwable e ) { \nthrow new DeploymentException ( \"Invalid profile cmp interface attribute getter method definition ( name = \" + attributeName + \" , type = \" + method . getReturnType ( ) + \" )\" , e ) ; \n} \nif ( isSlee11 ( ) ) { \nfor ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { \nif ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setUnique ( cmpField . isUnique ( ) ) ; \n} \n} \n} \nelse { \nfor ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { \nif ( profileIndex . getName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setIndex ( true ) ; \nprofileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; \n} \n} \n} \nmap . put ( attributeName , profileAttribute ) ; \n} \n} \nprofileAttributeMap = Collections . unmodifiableMap ( map ) ; \nreturn ; \n} \n} \n"}
{"7019": "public class EventContextSuspensionHandler { \nprivate void resume ( ) { \nRunnable runnable = new Runnable ( ) { \npublic void run ( ) { \nif ( scheduledFuture == null ) { \nreturn ; \n} \nscheduledFuture . cancel ( false ) ; \nscheduledFuture = null ; \nfor ( EventContext ec : barriedEvents ) { \nec . getLocalActivityContext ( ) . getExecutorService ( ) . routeEvent ( ec ) ; \n} \nbarriedEvents = null ; \nevent . getLocalActivityContext ( ) . getEventQueueManager ( ) . removeBarrier ( transaction ) ; \nsuspended = false ; \nevent . getLocalActivityContext ( ) . getCurrentEventRoutingTask ( ) . run ( ) ; \nreturn ; \n} \n} \n; \nevent . getLocalActivityContext ( ) . getExecutorService ( ) . execute ( runnable ) ; \nreturn ; \n} \n} \n"}
{"7021": "public class AbstractUsageMBeanImplParent { \npublic void remove ( ) { \nLogger logger = getLogger ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Closing \" + toString ( ) ) ; \n} \nfinal MBeanServer mbeanServer = sleeContainer . getMBeanServer ( ) ; \ntry { \nmbeanServer . unregisterMBean ( getObjectName ( ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"failed to remove \" + toString ( ) , e ) ; \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Removing all named usage parameters of \" + toString ( ) ) ; \n} \nfor ( String name : usageMBeans . keySet ( ) ) { \ntry { \n_removeUsageParameterSet ( name , false ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \ntry { \nremoveUsageParameterSet ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7024": "public class SbbAbstractMethodHandler { \npublic static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address ) { \nfireEvent ( sbbEntity , eventTypeID , eventObject , aci , address , null ) ; \nreturn ; \n} \n} \n"}
{"7025": "public class SbbAbstractMethodHandler { \npublic static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address , ServiceID serviceID ) { \nif ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) { \nthrow new SLEEException ( \"congestion control refused event\" ) ; \n} \nif ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null || sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( \"SbbObject not assigned!\" ) ; \nif ( eventObject == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The event ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \nif ( aci == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The activity ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \nfinal SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; \ntxManager . mandateTransaction ( ) ; \nActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) . getActivityContext ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"invoke(): firing event on \" + ac ) ; \n} \nif ( ac . isEnding ( ) ) { \nthrow new IllegalStateException ( \"activity context \" + ac . getActivityContextHandle ( ) + \" is ending\" ) ; \n} \nfinal EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; \nif ( transactionData != null ) { \nfinal EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; \nif ( eventBeingDelivered != null && eventBeingDelivered . getEvent ( ) == eventObject ) { \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; \nreturn ; \n} \n} \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; \nreturn ; \n} \n} \n"}
{"7030": "public class ProfileObjectPoolManagement { \npublic void createObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Creating Pool for \" + profileTable ) ; \n} \ncreateObjectPool ( profileTable ) ; \nif ( sleeTransactionManager != null ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Due to tx rollback, removing pool for \" + profileTable ) ; \n} \ntry { \nremoveObjectPool ( profileTable ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to remove table's \" + profileTable + \" object pool\" , e ) ; \n} \nreturn ; \n} \n} \n; \nsleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; \n} \nreturn ; \n} \n} \n"}
{"7031": "public class ProfileObjectPoolManagement { \npublic void removeObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Removing Pool for \" + profileTable ) ; \n} \nremoveObjectPool ( profileTable ) ; \nreturn ; \n} \n} \n; \nif ( sleeTransactionManager != null ) { \nsleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action ) ; \n} \nelse { \naction . execute ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \nreturn ; \n} \n} \n"}
{"7038": "public class SLEESubDeployer { \npublic void start ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method start called for \" + du . getUrl ( ) + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \ntry { \nDeployableUnit realDU = deployableUnits . get ( du . getFileName ( ) ) ; \nif ( realDU != null ) { \nwhile ( isInUndeployList ( du . getFileName ( ) ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \nsleeContainerDeployer . getDeploymentManager ( ) . installDeployableUnit ( realDU ) ; \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7039": "public class SLEESubDeployer { \npublic void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"stop( deployableUnitURL = : \" + deployableUnitURL + \" )\" ) ; \n} \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nDeployableUnit realDU = null ; \nString fileName = du . getFileName ( ) ; \nif ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Got DU: \" + realDU . getDeploymentInfoShortName ( ) ) ; \n} \nif ( ! isInUndeployList ( fileName ) ) { \naddToUndeployList ( fileName ) ; \n} \ntry { \nsleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; \ndeployableUnits . remove ( fileName ) ; \nremoveFromUndeployList ( fileName ) ; \n} \ncatch ( DependencyException e ) { \n} \ncatch ( Exception e ) { \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof InvalidStateException ) { \nlogger . warn ( cause . getLocalizedMessage ( ) + \"... WAITING ...\" ) ; \n} \nelse if ( e instanceof DeploymentException ) { \nthrow new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; \n} \nelse { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7041": "public class TransactionContextImpl { \nprotected void executeAfterCommitActions ( ) { \nif ( afterCommitActions != null ) { \nif ( trace ) { \nlogger . trace ( \"Executing after commit actions\" ) ; \n} \nexecuteActions ( afterCommitActions , trace ) ; \nafterCommitActions = null ; \n} \nreturn ; \n} \n} \n"}
{"7042": "public class TransactionContextImpl { \nprotected void executeAfterCommitPriorityActions ( ) { \nif ( afterCommitPriorityActions != null ) { \nif ( trace ) { \nlogger . trace ( \"Executing after commit priority actions\" ) ; \n} \nexecuteActions ( afterCommitPriorityActions , trace ) ; \nafterCommitPriorityActions = null ; \n} \nreturn ; \n} \n} \n"}
{"7043": "public class TransactionContextImpl { \nprotected void executeAfterRollbackActions ( ) { \nif ( afterRollbackActions != null ) { \nif ( trace ) { \nlogger . trace ( \"Executing rollback actions\" ) ; \n} \nexecuteActions ( afterRollbackActions , trace ) ; \nafterRollbackActions = null ; \n} \nreturn ; \n} \n} \n"}
{"7044": "public class TransactionContextImpl { \nprotected void executeBeforeCommitActions ( ) { \nif ( beforeCommitActions != null ) { \nif ( trace ) { \nlogger . trace ( \"Executing before commit actions\" ) ; \n} \nexecuteActions ( beforeCommitActions , trace ) ; \nbeforeCommitActions = null ; \n} \nreturn ; \n} \n} \n"}
{"7045": "public class TransactionContextImpl { \nprotected void executeBeforeCommitPriorityActions ( ) { \nif ( beforeCommitPriorityActions != null ) { \nif ( trace ) { \nlogger . trace ( \"Executing before commit priority actions\" ) ; \n} \nexecuteActions ( beforeCommitPriorityActions , trace ) ; \nbeforeCommitPriorityActions = null ; \n} \nreturn ; \n} \n} \n"}
{"7048": "public class FaultTolerantResourceAdaptorContextImpl { \npublic void removeReplicateData ( ) { \nif ( replicatedDataWithFailover != null ) { \nreplicatedDataWithFailover . remove ( ) ; \nreplicatedDataWithFailover = null ; \n} \nif ( replicatedData != null ) { \nreplicatedData . remove ( ) ; \nreplicatedData = null ; \n} \nreturn ; \n} \n} \n"}
{"7049": "public class SleePropertyEditorRegistrator { \npublic void register ( ) { \nPropertyEditorManager . registerEditor ( ComponentID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( EventTypeID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( LibraryID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ProfileSpecificationID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ResourceAdaptorID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ResourceAdaptorTypeID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( SbbID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ServiceID . class , ComponentIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ComponentID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( EventTypeID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( LibraryID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ProfileSpecificationID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ResourceAdaptorID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ResourceAdaptorTypeID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( SbbID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ServiceID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( DeployableUnitID . class , DeployableUnitIDPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( Level . class , LevelPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( TraceLevel . class , TraceLevelPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ConfigProperties . class , ConfigPropertiesPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( NotificationSource . class , NotificationSourcePropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( Object . class , ObjectPropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ServiceState . class , ServiceStatePropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( ResourceAdaptorEntityState . class , ResourceAdaptorEntityStatePropertyEditor . class ) ; \nPropertyEditorManager . registerEditor ( Address . class , AddressPropertyEditor . class ) ; \nreturn ; \n} \n} \n"}
{"7050": "public class SleeComponentWithUsageParametersClassCodeGenerator { \npublic void process ( SleeComponentWithUsageParametersInterface component ) throws DeploymentException { \nClassPool classPool = component . getClassPool ( ) ; \nString deploymentDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nClass < ? > usageParametersInterface = component . getUsageParametersInterface ( ) ; \nif ( usageParametersInterface != null ) { \ntry { \ncomponent . setUsageParametersConcreteClass ( new ConcreteUsageParameterClassGenerator ( usageParametersInterface . getName ( ) , deploymentDir , classPool ) . generateConcreteUsageParameterClass ( ) ) ; \nif ( LOGGER . isDebugEnabled ( ) ) { \nLOGGER . debug ( \"Generated usage parameter impl class for \" + component ) ; \n} \nnew ConcreteUsageParameterMBeanGenerator ( component ) . generateConcreteUsageParameterMBean ( ) ; \nif ( LOGGER . isDebugEnabled ( ) ) { \nLOGGER . debug ( \"Generated usage mbean (interface and impl) for \" + component ) ; \n} \n} \ncatch ( DeploymentException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nthrow new DeploymentException ( \"Failed to generate \" + component + \" usage parameter class\" , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7052": "public class SbbObjectPoolManagementImpl { \npublic void createObjectPool ( final ServiceID serviceID , final SbbComponent sbbComponent , final SleeTransactionManager sleeTransactionManager ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Creating Pool for  \" + serviceID + \" and \" + sbbComponent ) ; \n} \ncreateObjectPool ( serviceID , sbbComponent ) ; \nif ( sleeTransactionManager != null && sleeTransactionManager . getTransactionContext ( ) != null ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Due to tx rollback, removing pool for \" + serviceID + \" and \" + sbbComponent ) ; \n} \ntry { \nremoveObjectPool ( serviceID , sbbComponent . getSbbID ( ) ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to remove \" + serviceID + \" and \" + sbbComponent + \" object pool\" , e ) ; \n} \nreturn ; \n} \n} \n; \nsleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; \n} \nreturn ; \n} \n} \n"}
{"7053": "public class SleeEndpointEndActivityNotTransactedExecutor { \nvoid execute ( final ActivityHandle handle ) throws UnrecognizedActivityHandleException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \ntry { \nsleeEndpoint . _endActivity ( handle , tx ) ; \n} \nfinally { \nif ( tx != null ) { \nsuper . resumeTransaction ( tx ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7054": "public class SleeEndpointImpl { \nActivityContextHandle _startActivity ( ActivityHandle handle , int activityFlags , final SleeTransaction barrierTx ) { \nActivityContext ac = null ; \nif ( raEntity . getHandleReferenceFactory ( ) != null && ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) { \nfinal ActivityHandleReference reference = raEntity . getHandleReferenceFactory ( ) . createActivityHandleReference ( handle ) ; \ntry { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , reference ) , activityFlags ) ; \n} \ncatch ( ActivityAlreadyExistsException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nraEntity . getHandleReferenceFactory ( ) . removeActivityHandleReference ( reference ) ; \nthrow e ; \n} \n} \nelse { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) , activityFlags ) ; \n} \nif ( barrierTx != null && ac != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \nreturn ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nreturn ac . getActivityContextHandle ( ) ; \n} \n} \n"}
{"7055": "public class SleeEndpointImpl { \nvoid _endActivity ( ActivityHandle handle , final SleeTransaction barrierTx ) throws UnrecognizedActivityHandleException { \nfinal ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; \nfinal ActivityContext ac = acFactory . getActivityContext ( ach ) ; \nif ( ac != null ) { \nif ( barrierTx != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \nreturn ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nac . endActivity ( ) ; \n} \nelse { \nthrow new UnrecognizedActivityHandleException ( handle . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7056": "public class SleeEndpointImpl { \nprivate void checkFireEventPreconditions ( ActivityHandle handle , FireableEventType eventType , Object event ) throws NullPointerException , IllegalEventException , IllegalStateException { \nif ( event == null ) throw new NullPointerException ( \"event is null\" ) ; \nif ( handle == null ) throw new NullPointerException ( \"handle is null\" ) ; \nif ( eventType == null ) { \nthrow new NullPointerException ( \"eventType is null\" ) ; \n} \nfinal EventTypeComponent eventTypeComponent = componentRepository . getComponentByID ( eventType . getEventType ( ) ) ; \nif ( eventTypeComponent == null ) { \nthrow new IllegalEventException ( \"event type not installed (more on SLEE 1.1 specs 15.14.8)\" ) ; \n} \nif ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) { \nthrow new IllegalEventException ( \"the class of the event object fired is not assignable to the event class of the event type (more on SLEE 1.1 specs 15.14.8) \" ) ; \n} \nif ( eventType . getClass ( ) != FireableEventTypeImpl . class ) { \nthrow new IllegalEventException ( \"unknown implementation of FireableEventType\" ) ; \n} \nif ( raEntity . getAllowedEventTypes ( ) != null && ! raEntity . getAllowedEventTypes ( ) . contains ( eventType . getEventType ( ) ) ) { \nthrow new IllegalEventException ( \"Resource Adaptor configured to not ignore ra type event checking and the event \" + eventType . getEventType ( ) + \" does not belongs to any of the ra types implemented by the resource adaptor\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7057": "public class SleeEndpointImpl { \nvoid _fireEvent ( ActivityHandle realHandle , ActivityHandle refHandle , FireableEventType eventType , Object event , Address address , ReceivableService receivableService , int eventFlags , final SleeTransaction barrierTx ) throws ActivityIsEndingException , SLEEException { \nfinal ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , refHandle ) ; \nfinal ActivityContext ac = acFactory . getActivityContext ( ach ) ; \nif ( ac == null ) { \nthrow new UnrecognizedActivityHandleException ( \"Unable to fire \" + eventType . getEventType ( ) + \" on activity handle \" + realHandle + \" , the handle is not mapped to an activity context\" ) ; \n} \nelse { \nif ( barrierTx != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \nreturn ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal EventProcessingCallbacks callbacks = new EventProcessingCallbacks ( realHandle , eventType , event , address , receivableService , eventFlags , raEntity ) ; \nfinal EventProcessingSucceedCallback succeedCallback = EventFlags . hasRequestProcessingSuccessfulCallback ( eventFlags ) ? callbacks : null ; \nfinal EventProcessingFailedCallback failedCallback = EventFlags . hasRequestProcessingFailedCallback ( eventFlags ) ? callbacks : null ; \nfinal EventUnreferencedCallback unreferencedCallback = EventFlags . hasRequestEventReferenceReleasedCallback ( eventFlags ) ? callbacks : null ; \nac . fireEvent ( eventType . getEventType ( ) , event , address , receivableService == null ? null : receivableService . getService ( ) , succeedCallback , failedCallback , unreferencedCallback ) ; \n} \nreturn ; \n} \n} \n"}
{"7059": "public class AccessorOperation { \nprotected void makeGetter ( ) { \nif ( fieldClass . equals ( boolean . class ) || fieldClass . equals ( Boolean . class ) ) { \nsuper . operationName = \"is\" + this . beanFieldName ; \n} \nelse { \nsuper . operationName = \"get\" + this . beanFieldName ; \n} \nreturn ; \n} \n} \n"}
{"7061": "public class ProfileID { \npublic final void setProfileID ( String profileTableName , String profileName ) throws NullPointerException , IllegalArgumentException { \nif ( profileTableName == null ) throw new NullPointerException ( \"profileTableName is null\" ) ; \nif ( profileName == null ) throw new NullPointerException ( \"profileName is null\" ) ; \nif ( profileTableName . indexOf ( '/' ) >= 0 ) throw new IllegalArgumentException ( \"profileTableName cannot contain the '/' character\" ) ; \nthis . profileTableName = profileTableName ; \nthis . profileName = profileName ; \nthis . address = null ; \nreturn ; \n} \n} \n"}
{"7068": "public class ClassPool { \npublic void clean ( ) { \nfor ( ClassPath classPath : classPaths ) { \nclassPool . removeClassPath ( classPath ) ; \n} \nfor ( String classMade : classesMade ) { \ntry { \nclassPool . get ( classMade ) . detach ( ) ; \n} \ncatch ( NotFoundException e ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Failed to detach class \" + classMade + \" from class pool\" , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7069": "public class ProfileCallRecorderTransactionData { \n@ SuppressWarnings ( \"unchecked\" ) public static void addProfileCall ( ProfileObjectImpl po ) throws SLEEException { \nSleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; \ntry { \nif ( sleeTransactionManager . getTransaction ( ) == null ) { \nreturn ; \n} \n} \ncatch ( SystemException se ) { \nthrow new SLEEException ( \"Unable to verify SLEE Transaction.\" , se ) ; \n} \nString key = makeKey ( po ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Recording call to profile. Key[\" + key + \"]\" ) ; \n} \nfinal TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; \nProfileCallRecorderTransactionData data = ( ProfileCallRecorderTransactionData ) txContext . getData ( ) . get ( TRANSACTION_CONTEXT_KEY ) ; \nif ( data == null ) { \ndata = new ProfileCallRecorderTransactionData ( ) ; \ntxContext . getData ( ) . put ( TRANSACTION_CONTEXT_KEY , data ) ; \n} \nif ( ! po . isProfileReentrant ( ) ) { \nif ( data . invokedProfiles . contains ( key ) && data . invokedProfiles . getLast ( ) . compareTo ( key ) != 0 ) { \nthrow new SLEEException ( \"Detected loopback call. Call sequence: \" + data . invokedProfiles ) ; \n} \ndata . invokedProfiles . add ( key ) ; \ndata . invokedProfileTablesNames . add ( po . getProfileTable ( ) . getProfileTableName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7071": "public class ProfileTableTransactionView { \npublic static void passivateProfileObjectOnTxEnd ( SleeTransactionManager txManager , final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { \nTransactionalAction afterRollbackAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nprofileObject . invalidateObject ( ) ; \npool . returnObject ( profileObject ) ; \nreturn ; \n} \n} \n; \nTransactionalAction beforeCommitAction = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( profileObject . getState ( ) == ProfileObjectState . READY ) { \nif ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) { \nprofileObject . fireAddOrUpdatedEventIfNeeded ( ) ; \nprofileObject . profilePassivate ( ) ; \n} \nelse { \nprofileObject . profileRemove ( true , false ) ; \n} \npool . returnObject ( profileObject ) ; \n} \nreturn ; \n} \n} \n; \nfinal TransactionContext txContext = txManager . getTransactionContext ( ) ; \ntxContext . getAfterRollbackActions ( ) . add ( afterRollbackAction ) ; \ntxContext . getBeforeCommitActions ( ) . add ( beforeCommitAction ) ; \nreturn ; \n} \n} \n"}
{"7072": "public class ComponentIDArrayPropertyEditor { \npublic void setAsText ( String text ) { \nif ( text == null || text . equals ( \"\" ) ) { \nsuper . setValue ( new ComponentID [ 0 ] ) ; \n} \nelse { \njava . util . ArrayList results = new java . util . ArrayList ( ) ; \njava . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; \nComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; \nwhile ( st . hasMoreTokens ( ) ) { \ncidPropEditor . setAsText ( st . nextToken ( ) ) ; \nif ( st . hasMoreTokens ( ) ) { \nst . nextToken ( ) ; \n} \nresults . add ( cidPropEditor . getValue ( ) ) ; \n} \nComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; \nresults . toArray ( cid ) ; \nthis . setValue ( cid ) ; \n} \nreturn ; \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) return ; \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) { \nconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \n} \nelse if ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) { \nconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \n} \nelse { \nthrow new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \n} \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7075": "public class ActivityContextImpl { \npublic void setDataAttribute ( String key , Object newValue ) { \ncacheData . setCmpAttribute ( key , newValue ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Activity context with handle \" + getActivityContextHandle ( ) + \" set cmp attribute named \" + key + \" to value \" + newValue ) ; \n} \nreturn ; \n} \n} \n"}
{"7076": "public class ActivityContextImpl { \npublic void addNameBinding ( String aciName ) { \ncacheData . nameBound ( aciName ) ; \nif ( acReferencesHandler != null ) { \nacReferencesHandler . nameReferenceCreated ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7077": "public class ActivityContextImpl { \nprivate void removeNamingBindings ( ) { \nActivityContextNamingFacility acf = sleeContainer . getActivityContextNamingFacility ( ) ; \nfor ( Object obj : cacheData . getNamesBoundCopy ( ) ) { \nString aciName = ( String ) obj ; \ntry { \nacf . removeName ( aciName ) ; \n} \ncatch ( Exception e ) { \nlogger . warn ( \"failed to unbind name: \" + aciName + \" from ac:\" + getActivityContextHandle ( ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7080": "public class ActivityContextImpl { \nprivate void removeFromTimers ( ) { \nTimerFacility timerFacility = sleeContainer . getTimerFacility ( ) ; \nfor ( Object obj : cacheData . getAttachedTimers ( ) ) { \ntimerFacility . cancelTimer ( ( TimerID ) obj , false ) ; \n} \nreturn ; \n} \n} \n"}
{"7082": "public class ActivityContextImpl { \npublic void detachSbbEntity ( SbbEntityID sbbEntityId ) throws javax . slee . TransactionRequiredLocalException { \nboolean detached = cacheData . detachSbbEntity ( sbbEntityId ) ; \nif ( detached && acReferencesHandler != null && ! isEnding ( ) ) { \nacReferencesHandler . sbbeReferenceRemoved ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Detached sbb entity \" + sbbEntityId + \" from AC with handle \" + getActivityContextHandle ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7084": "public class ActivityContextImpl { \npublic void endActivity ( ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Ending activity context with handle \" + getActivityContextHandle ( ) ) ; \n} \nif ( cacheData . setEnding ( true ) ) { \nfireEvent ( sleeContainer . getEventContextFactory ( ) . createActivityEndEventContext ( this , new ActivityEndEventUnreferencedCallback ( getActivityContextHandle ( ) , factory ) ) , sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7085": "public class DeployableUnit { \npublic void addComponent ( DeployableComponent dc ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Adding Component \" + dc . getComponentKey ( ) ) ; \ncomponents . add ( dc ) ; \ncomponentIDs . add ( dc . getComponentKey ( ) ) ; \ndependencies . addAll ( dc . getDependencies ( ) ) ; \ninstallActions . addAll ( dc . getInstallActions ( ) ) ; \nCollection < ManagementAction > postInstallActionsStrings = postInstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( postInstallActionsStrings != null && ! postInstallActionsStrings . isEmpty ( ) ) { \ninstallActions . addAll ( postInstallActionsStrings ) ; \n} \nCollection < ManagementAction > preUninstallActionsStrings = preUninstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( preUninstallActionsStrings != null ) uninstallActions . addAll ( preUninstallActionsStrings ) ; \nuninstallActions . addAll ( dc . getUninstallActions ( ) ) ; \nreturn ; \n} \n} \n"}
{"7092": "public class AbstractProfileMBeanImpl { \npublic static void close ( String profileTableName , String profileName ) { \nfinal ObjectName objectName = getObjectName ( profileTableName , profileName ) ; \nif ( sleeContainer . getMBeanServer ( ) . isRegistered ( objectName ) ) { \nRunnable r = new Runnable ( ) { \npublic void run ( ) { \ntry { \nsleeContainer . getMBeanServer ( ) . invoke ( objectName , \"close\" , new Object [ ] { \n} \n, new String [ ] { \n} \n) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n; \nThread t = new Thread ( r ) ; \nt . start ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7094": "public class AbstractProfileMBeanImpl { \nprivate void writeMode ( ) throws SLEEException , ManagementException { \nif ( ! isProfileWriteable ( ) ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Changing state to read-write, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \nProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; \nprofileObject . getProfileEntity ( ) . setReadOnly ( false ) ; \nstate = State . write ; \n} \nelse { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Already in write state, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7095": "public class AbstractProfileMBeanImpl { \nprotected void beforeSetCmpField ( ) throws ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"beforeSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \n} \nif ( isProfileWriteable ( ) ) { \ntry { \nsleeContainer . getTransactionManager ( ) . resume ( transaction ) ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \n} \nelse { \nthrow new InvalidStateException ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7096": "public class AbstractProfileMBeanImpl { \nprotected void afterSetCmpField ( ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"afterSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \n} \ntry { \nsleeContainer . getTransactionManager ( ) . suspend ( ) ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7098": "public class AbstractProfileMBeanImpl { \nprotected void afterGetCmpField ( boolean activatedTransaction ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"afterGetCmpField( activatedTransaction = \" + activatedTransaction + \" ) on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \n} \nafterNonSetCmpField ( activatedTransaction ) ; \nreturn ; \n} \n} \n"}
{"7100": "public class AbstractProfileMBeanImpl { \nprotected void afterManagementMethodInvocation ( boolean activatedTransaction ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"afterManagementMethodInvocation( activatedTransaction = \" + activatedTransaction + \" ) on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; \n} \nafterNonSetCmpField ( activatedTransaction ) ; \njndiManagement . popJndiContext ( ) ; \nreturn ; \n} \n} \n"}
{"7101": "public class DeployableUnitImpl { \nprivate void deletePath ( File path ) { \nif ( path . isDirectory ( ) ) { \nFile [ ] files = path . listFiles ( ) ; \nif ( files != null ) { \nfor ( File file : files ) { \ndeletePath ( file ) ; \n} \n} \n} \npath . delete ( ) ; \nreturn ; \n} \n} \n"}
{"7102": "public class ConcreteSbbGenerator { \nprotected void createDefaultConstructor ( ) throws DeploymentException { \nCtConstructor defaultConstructor = new CtConstructor ( null , sbbConcreteClass ) ; \nString constructorBody = \"{ }\" ; \ntry { \ndefaultConstructor . setBody ( constructorBody ) ; \nsbbConcreteClass . addConstructor ( defaultConstructor ) ; \nlogger . trace ( \"DefaultConstructor created\" ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new DeploymentException ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7103": "public class ConcreteSbbGenerator { \nprivate void createDefaultUsageParameterGetter ( CtClass sbbConcrete ) throws DeploymentException { \nString methodName = \"getDefaultSbbUsageParameterSet\" ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{ return ($r)\" + SbbAbstractMethodHandler . class . getName ( ) + \".getDefaultSbbUsageParameterSet(sbbEntity); }\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( CannotCompileException cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , cce ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7104": "public class ConcreteSbbGenerator { \nprivate void createSbbEntityGetterAndSetter ( CtClass sbbConcrete ) throws DeploymentException { \ntry { \nCtMethod getSbbEntity = CtNewMethod . make ( \"public \" + SbbEntity . class . getName ( ) + \" getSbbEntity() { return this.sbbEntity; }\" , sbbConcrete ) ; \ngetSbbEntity . setModifiers ( Modifier . PUBLIC ) ; \nsbbConcrete . addMethod ( getSbbEntity ) ; \nCtMethod setSbbEntity = CtNewMethod . make ( \"public void setSbbEntity ( \" + SbbEntity . class . getName ( ) + \" sbbEntity )\" + \"{\" + \"this.sbbEntity = sbbEntity;\" + \"}\" , sbbConcrete ) ; \nsetSbbEntity . setModifiers ( Modifier . PUBLIC ) ; \nsbbConcrete . addMethod ( setSbbEntity ) ; \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( int i = 0 ; \ni < method . getParameterTypes ( ) . length ; \ni ++ ) { \nconcreteMethodBody += \",$\" + ( i + 1 ) ; \n} \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7106": "public class ConcreteSbbGenerator { \nprotected void createGetSbbActivityContextInterfaceMethod ( CtClass activityContextInterface , Class < ? > concreteActivityContextInterfaceClass ) throws DeploymentException { \nString methodToAdd = \"public \" + activityContextInterface . getName ( ) + \" asSbbActivityContextInterface(javax.slee.ActivityContextInterface aci) {\" + \"if(aci==null)\" + \"     throw new \" + IllegalStateException . class . getName ( ) + \"(\\\"Passed argument can not be of null value.\\\");\" + \" if(sbbEntity == null || sbbEntity.getSbbObject().getState() != \" + SbbObjectState . class . getName ( ) + \".READY) { throw new \" + IllegalStateException . class . getName ( ) + \"(\\\"Cannot call asSbbActivityContextInterface\\\"); } \" + \"else if ( aci instanceof \" + concreteActivityContextInterfaceClass . getName ( ) + \") return aci;\" + \"else return  new \" + concreteActivityContextInterfaceClass . getName ( ) + \" ( (\" + ActivityContextInterface . class . getName ( ) + \") $1, \" + \"sbbEntity.getSbbComponent());\" + \"}\" ; \nCtMethod methodTest ; \ntry { \nmethodTest = CtNewMethod . make ( methodToAdd , sbbConcreteClass ) ; \nsbbConcreteClass . addMethod ( methodTest ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method \" + methodToAdd + \" added\" ) ; \n} \n} \ncatch ( CannotCompileException e ) { \nthrow new DeploymentException ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7107": "public class CompositeQueryExpression { \nprotected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { \nif ( expr == null ) throw new NullPointerException ( \"expr is null\" ) ; \nif ( expr instanceof CompositeQueryExpression ) { \n( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; \n} \nelse if ( expr instanceof Not ) { \n( ( Not ) expr ) . checkForCycles ( this ) ; \n} \nexprs . add ( expr ) ; \nreturn ; \n} \n} \n"}
{"7108": "public class NonSerializableFactory { \npublic static synchronized void bind ( String key , Object target ) throws NameAlreadyBoundException { \nif ( wrapperMap . containsKey ( key ) == true ) throw new NameAlreadyBoundException ( key + \" already exists in the NonSerializableFactory map\" ) ; \nwrapperMap . put ( key , target ) ; \nreturn ; \n} \n} \n"}
{"7109": "public class NonSerializableFactory { \npublic static synchronized void rebind ( Name name , Object target ) throws NamingException { \nrebind ( name , target , false ) ; \nreturn ; \n} \n} \n"}
{"7111": "public class SbbLocalObjectInterceptor { \npublic void invokeAndReturnvoid ( SbbConcrete proxy , String methodName , Object [ ] args , Class < ? > [ ] argTypes ) throws Exception { \ninvokeAndReturnObject ( proxy , methodName , args , argTypes ) ; \nreturn ; \n} \n} \n"}
{"7113": "public class SbbActivityContextInterfaceImpl { \npublic void setFieldValue ( String fieldName , Object value ) { \nString realFieldName = getRealFieldName ( fieldName ) ; \naciImpl . getActivityContext ( ) . setDataAttribute ( realFieldName , value ) ; \nreturn ; \n} \n} \n"}
{"7115": "public class ProfileObjectImpl { \npublic void setProfileContext ( ProfileContextImpl profileContext ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[setProfileContext] \" + this ) ; \n} \nif ( profileContext == null ) { \nthrow new NullPointerException ( \"Passed context must not be null.\" ) ; \n} \nif ( state != ProfileObjectState . DOES_NOT_EXIST ) { \nthrow new IllegalStateException ( \"Wrong state: \" + this . state + \",on profile set context operation, for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ) ; \n} \nthis . profileContext = profileContext ; \nthis . profileContext . setProfileObject ( this ) ; \nif ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \ntry { \nif ( isSlee11 ) { \ntry { \nprofileConcrete . setProfileContext ( profileContext ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \n} \ncatch ( Exception e ) { \nif ( logger . isDebugEnabled ( ) ) logger . debug ( \"Exception encountered while setting profile context for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) , e ) ; \n} \n} \nfinally { \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \n} \n} \nstate = ProfileObjectState . POOLED ; \nreturn ; \n} \n} \n"}
{"7116": "public class ProfileObjectImpl { \nprivate void profileInitialize ( String profileName ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[profileInitialize] \" + this + \" , profileName = \" + profileName ) ; \n} \nif ( this . state != ProfileObjectState . POOLED ) { \nthrow new SLEEException ( this . toString ( ) ) ; \n} \nif ( profileName == null ) { \nprofileEntity = profileEntityFramework . getProfileEntityFactory ( ) . newInstance ( profileTable . getProfileTableName ( ) , null ) ; \nthis . state = ProfileObjectState . PROFILE_INITIALIZATION ; \nif ( profileConcreteClassInfo . isInvokeProfileInitialize ( ) ) { \ntry { \nprofileConcrete . profileInitialize ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \n} \nelse { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Copying state from default profile on object \" + this ) ; \n} \nprofileEntity = cloneEntity ( profileTable . getDefaultProfileEntity ( ) ) ; \nprofileEntity . setProfileName ( profileName ) ; \n} \nprofileEntity . create ( ) ; \nprofileEntity . setDirty ( true ) ; \nreturn ; \n} \n} \n"}
{"7117": "public class ProfileObjectImpl { \npublic void unsetProfileContext ( ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[unsetProfileContext] \" + this ) ; \n} \nif ( state == ProfileObjectState . POOLED && profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nif ( isSlee11 ) { \ntry { \nprofileConcrete . unsetProfileContext ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \nprofileContext . setProfileObject ( null ) ; \nstate = ProfileObjectState . DOES_NOT_EXIST ; \n} \nfinally { \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7119": "public class ProfileObjectImpl { \npublic void fireAddOrUpdatedEventIfNeeded ( ) { \nif ( state == ProfileObjectState . READY ) { \nif ( profileEntity . isDirty ( ) ) { \nif ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { \nActivityContext ac = profileTable . getActivityContext ( ) ; \nAbstractProfileEvent event = null ; \nif ( profileEntity . isCreate ( ) ) { \nif ( persisted ) { \nevent = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; \npersisted = false ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"firing profile added event for profile named \" + profileEntity ) ; \n} \n} \nelse { \nreturn ; \n} \n} \nelse { \nevent = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"firing profile updated event for profile named \" + profileEntity ) ; \n} \n} \nac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7122": "public class ClassGeneratorUtils { \npublic static void createInheritanceLink ( CtClass concreteClass , String superClassName ) { \nif ( superClassName != null && superClassName . length ( ) >= 0 ) { \ntry { \nconcreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; \n} \ncatch ( CannotCompileException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( NotFoundException e ) { \ne . printStackTrace ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7123": "public class ClassGeneratorUtils { \npublic static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) { \nif ( toAnnotate instanceof CtClass ) { \nCtClass classToAnnotate = ( CtClass ) toAnnotate ; \nClassFile cf = classToAnnotate . getClassFile ( ) ; \nConstPool cp = cf . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \ncf . addAttribute ( attr ) ; \n} \nelse if ( toAnnotate instanceof CtMethod ) { \nCtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; \nMethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; \nConstPool cp = mi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \nmi . addAttribute ( attr ) ; \n} \nelse if ( toAnnotate instanceof CtField ) { \nCtField fieldToAnnotate = ( CtField ) toAnnotate ; \nFieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; \nConstPool cp = fi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \nfi . addAttribute ( attr ) ; \n} \nelse { \nthrow new UnsupportedOperationException ( \"Unknown object type: \" + toAnnotate . getClass ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7124": "public class ClassGeneratorUtils { \nprivate static void addMemberValuesToAnnotation ( Annotation annotation , ConstPool cp , LinkedHashMap < String , Object > memberValues ) { \nfor ( String mvName : memberValues . keySet ( ) ) { \nObject mvValue = memberValues . get ( mvName ) ; \nMemberValue mv = getMemberValue ( mvValue , cp ) ; \nannotation . addMemberValue ( mvName , mv ) ; \n} \nreturn ; \n} \n} \n"}
{"7127": "public class AbstractSleeComponent { \npublic void setDeployableUnit ( DeployableUnit deployableUnit ) throws AlreadyDeployedException { \nif ( this . deployableUnit != null ) { \nthrow new IllegalStateException ( \"deployable unit already set. du = \" + this . deployableUnit ) ; \n} \nthis . deployableUnit = deployableUnit ; \nif ( ! addToDeployableUnit ( ) ) { \nthrow new AlreadyDeployedException ( \"unable to install du having multiple components with id \" + getComponentID ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7128": "public class AbstractSleeComponent { \npublic void undeployed ( ) { \nclassLoader = null ; \nif ( classLoaderDomain != null ) { \nclassLoaderDomain . clear ( ) ; \nclassLoaderDomain = null ; \n} \nif ( classPool != null ) { \nclassPool . clean ( ) ; \nclassPool = null ; \n} \nif ( permissions != null ) { \npermissions . clear ( ) ; \npermissions = null ; \n} \nreturn ; \n} \n} \n"}
{"7129": "public class SleeEndpointStartActivityNotTransactedExecutor { \nvoid execute ( final ActivityHandle handle , final int activityFlags , boolean suspendActivity ) throws SLEEException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \nActivityContextHandle ach = null ; \ntry { \nach = sleeEndpoint . _startActivity ( handle , activityFlags , suspendActivity ? tx : null ) ; \n} \nfinally { \nif ( tx != null ) { \nsuper . resumeTransaction ( tx ) ; \nif ( ach != null && ActivityFlags . hasRequestSleeActivityGCCallback ( activityFlags ) ) { \nacFactory . getActivityContext ( ach ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7135": "public class DeployableUnitBuilderImpl { \nprivate void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { \nfor ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { \nif ( componentID instanceof EventTypeID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse if ( componentID instanceof LibraryID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse if ( componentID instanceof ProfileSpecificationID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse if ( componentID instanceof ResourceAdaptorID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse if ( componentID instanceof ResourceAdaptorTypeID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse if ( componentID instanceof SbbID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse if ( componentID instanceof ServiceID ) { \nthrow new SLEEException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on a service component \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7138": "public class SleeManagementMBeanImpl { \npublic void start ( ) throws InvalidStateException , ManagementException { \ntry { \nfinal SleeStateChangeRequest startingRequest = new SleeStateChangeRequest ( ) { \n@ Override public void stateChanged ( SleeState oldState ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( generateMessageWithLogo ( \"starting\" ) ) ; \n} \nnotifyStateChange ( oldState , getNewState ( ) ) ; \nreturn ; \n} \n@ Override public void requestCompleted ( ) { \nfinal SleeStateChangeRequest runningRequest = new SleeStateChangeRequest ( ) { \nprivate SleeState oldState ; \n@ Override public void stateChanged ( SleeState oldState ) { \nlogger . info ( generateMessageWithLogo ( \"started\" ) ) ; \nthis . oldState = oldState ; \nreturn ; \n} \n@ Override public void requestCompleted ( ) { \nnotifyStateChange ( oldState , getNewState ( ) ) ; \nreturn ; \n} \n@ Override public boolean isBlockingRequest ( ) { \nreturn true ; \n} \n@ Override public SleeState getNewState ( ) { \nreturn SleeState . RUNNING ; \n} \n} \n; \ntry { \nsleeContainer . setSleeState ( runningRequest ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to set container in RUNNING state\" , e ) ; \ntry { \nstop ( false ) ; \n} \ncatch ( Throwable f ) { \nlogger . error ( \"Failed to set container in STOPPED state, after failure to set in RUNNING state\" , e ) ; \n} \n} \nreturn ; \n} \n@ Override public boolean isBlockingRequest ( ) { \nreturn true ; \n} \n@ Override public SleeState getNewState ( ) { \nreturn SleeState . STARTING ; \n} \n} \n; \nsleeContainer . setSleeState ( startingRequest ) ; \n} \ncatch ( InvalidStateException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nthrow new ManagementException ( ex . getMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"7141": "public class ProfileLocalObjectImpl { \nprotected void checkTransaction ( ) throws IllegalStateException { \ntry { \nif ( ! sleeContainer . getTransactionManager ( ) . getTransaction ( ) . equals ( this . transaction ) ) { \nthrow new IllegalStateException ( ) ; \n} \n} \ncatch ( SystemException e ) { \nthrow new IllegalStateException ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7146": "public class LogManagementMBeanUtils { \npublic void resetLoggerLevels ( ) throws ManagementConsoleException { \ntry { \nthis . mbeanServer . invoke ( logMgmtMBeanName , \"resetLoggerLevels\" , null , null ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nthrow new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7147": "public class LogManagementMBeanUtils { \npublic void clearLoggers ( String name ) throws ManagementConsoleException { \ntry { \nthis . mbeanServer . invoke ( logMgmtMBeanName , \"clearLoggers\" , new Object [ ] { \nname } \n, new String [ ] { \n\"java.lang.String\" } \n) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nthrow new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7149": "public class LogManagementMBeanUtils { \npublic void addSocketHandler ( String loggerName , Level handlerLevel , String handlerName , String formaterClassName , String filterClassName , String host , int port ) throws ManagementConsoleException { \ntry { \nthis . mbeanServer . invoke ( logMgmtMBeanName , \"addSocketHandler\" , new Object [ ] { \nloggerName , handlerLevel , handlerName , formaterClassName , filterClassName , host , port } \n, new String [ ] { \n\"java.lang.String\" , \"java.util.logging.Level\" , \"java.lang.String\" , \"java.lang.String\" , \"java.lang.String\" , \"java.lang.String\" , \"int\" } \n) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nthrow new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7152": "public class TracerImpl { \nvoid syncLevelWithLog4j ( ) { \nLevel log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; \nif ( level == null ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \nelse { \nif ( tracerToLog4JLevel ( level ) != log4jLevel ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \n} \nif ( parent == null && level == null ) { \nlogger . setLevel ( Level . INFO ) ; \nlevel = TraceLevel . INFO ; \n} \nresetCacheFlags ( false ) ; \nreturn ; \n} \n} \n"}
{"7153": "public class TracerImpl { \nprivate void assignLog4JLevel ( Level log4jLevel ) { \nif ( log4jLevel == null ) { \nreturn ; \n} \nif ( log4jLevel == Level . DEBUG ) { \nlevel = TraceLevel . FINE ; \n} \nelse if ( log4jLevel == Level . INFO ) { \nlevel = TraceLevel . INFO ; \n} \nelse if ( log4jLevel == Level . WARN ) { \nlevel = TraceLevel . WARNING ; \n} \nelse if ( log4jLevel == Level . ERROR ) { \nlevel = TraceLevel . SEVERE ; \n} \nelse if ( log4jLevel == Level . TRACE ) { \nlevel = TraceLevel . FINEST ; \n} \nelse if ( log4jLevel == Level . OFF ) { \nlevel = TraceLevel . OFF ; \n} \nreturn ; \n} \n} \n"}
{"7154": "public class TracerImpl { \nvoid resetCacheFlags ( boolean resetChilds ) { \nif ( isTraceable ( TraceLevel . FINEST ) ) { \nfinestEnabled = true ; \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfinestEnabled = false ; \nif ( isTraceable ( TraceLevel . FINER ) ) { \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfinerEnabled = false ; \nif ( isTraceable ( TraceLevel . FINE ) ) { \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfineEnabled = false ; \nif ( isTraceable ( TraceLevel . CONFIG ) ) { \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nif ( isTraceable ( TraceLevel . INFO ) ) { \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \ninfoEnabled = false ; \nif ( isTraceable ( TraceLevel . WARNING ) ) { \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nwarningEnabled = false ; \nif ( isTraceable ( TraceLevel . SEVERE ) ) { \nsevereEnabled = true ; \n} \nelse { \nsevereEnabled = false ; \n} \n} \n} \n} \n} \n} \n} \nif ( resetChilds ) { \nfor ( TracerImpl child : childs ) { \nif ( child . level == null ) { \nchild . resetCacheFlags ( true ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7155": "public class TracerImpl { \nvoid sendNotification ( javax . slee . facilities . TraceLevel level , String message , Throwable t ) { \nif ( ! isTraceable ( level ) ) { \nreturn ; \n} \ntraceMBean . sendNotification ( new TraceNotification ( notificationSource . getNotificationSource ( ) . getTraceNotificationType ( ) , traceMBean , notificationSource . getNotificationSource ( ) , getTracerName ( ) , level , message , t , notificationSource . getNextSequence ( ) , System . currentTimeMillis ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"7156": "public class TracerImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { \nif ( tracerName . equals ( \"\" ) ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . equals ( token ) && token . equals ( \".\" ) ) { \nthrow new InvalidArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nlastToken = token ; \n} \nif ( lastToken . equals ( \".\" ) ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7157": "public class VendorExtensionUtils { \npublic static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { \nout . defaultWriteObject ( ) ; \nif ( vendorData != null ) { \nout . writeBoolean ( true ) ; \nout . writeObject ( new MarshalledObject ( vendorData ) ) ; \n} \nelse out . writeBoolean ( false ) ; \nreturn ; \n} \n} \n"}
{"7159": "public class URLClassLoaderDomainImpl { \npublic void addDirectDependency ( URLClassLoaderDomainImpl domain ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + \" adding domain \" + domain + \" to direct dependencies\" ) ; \ndirectDependencies . add ( domain ) ; \nreturn ; \n} \n} \n"}
{"7164": "public class ProfileProvisioningMBeanImpl { \nprivate AbstractProfileMBeanImpl createAndRegisterProfileMBean ( String profileName , ProfileTableImpl profileTable ) throws ManagementException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"createAndRegisterProfileMBean( profileTable = \" + profileTable + \" , profileName = \" + profileName + \" )\" ) ; \n} \ntry { \nProfileSpecificationComponent component = profileTable . getProfileSpecificationComponent ( ) ; \nConstructor < ? > constructor = component . getProfileMBeanConcreteImplClass ( ) . getConstructor ( Class . class , String . class , ProfileTableImpl . class ) ; \nfinal AbstractProfileMBeanImpl profileMBean = ( AbstractProfileMBeanImpl ) constructor . newInstance ( component . getProfileMBeanConcreteInterfaceClass ( ) , profileName , profileTable ) ; \nprofileMBean . register ( ) ; \nTransactionalAction rollbackAction = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nprofileMBean . unregister ( ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n; \nsleeTransactionManagement . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( rollbackAction ) ; \nreturn profileMBean ; \n} \ncatch ( Throwable e ) { \nthrow new ManagementException ( e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"7165": "public class SleeEndpointOperationNotTransactedExecutor { \nvoid resumeTransaction ( SleeTransaction transaction ) throws SLEEException { \nif ( transaction != null ) { \ntry { \ntxManager . resume ( transaction ) ; \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7168": "public class SleeContainer { \npublic void initSlee ( ) throws InvalidStateException { \nif ( sleeState != null ) { \nthrow new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; \n} \nbeforeModulesInitialization ( ) ; \nfor ( Iterator < SleeContainerModule > i = modules . iterator ( ) ; \ni . hasNext ( ) ; \n) { \ni . next ( ) . sleeInitialization ( ) ; \n} \nafterModulesInitialization ( ) ; \nsleeState = SleeState . STOPPED ; \nreturn ; \n} \n} \n"}
{"7169": "public class SleeContainer { \npublic void shutdownSlee ( ) throws InvalidStateException { \nif ( sleeState != SleeState . STOPPED ) { \nthrow new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; \n} \nbeforeModulesShutdown ( ) ; \nfor ( Iterator < SleeContainerModule > i = modules . descendingIterator ( ) ; \ni . hasNext ( ) ; \n) { \ni . next ( ) . sleeShutdown ( ) ; \n} \nafterModulesShutdown ( ) ; \nsleeState = null ; \nreturn ; \n} \n} \n"}
{"7170": "public class SleeContainer { \nprivate void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { \nif ( oldState == SleeState . STOPPED ) { \nif ( newState == SleeState . STARTING ) { \nreturn ; \n} \n} \nelse if ( oldState == SleeState . STARTING ) { \nif ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse if ( oldState == SleeState . RUNNING ) { \nif ( newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse if ( oldState == SleeState . STOPPING ) { \nif ( newState == SleeState . STOPPED ) { \nreturn ; \n} \n} \nthrow new InvalidStateException ( \"illegal slee state transition: \" + oldState + \" -> \" + newState ) ; \nreturn ; \n} \n} \n"}
{"7171": "public class ConcreteProfileGenerator { \nprivate void generateNamedUsageParameterGetter ( CtClass profileConcreteClass ) { \nString methodName = \"getUsageParameterSet\" ; \nfor ( CtMethod ctMethod : profileConcreteClass . getMethods ( ) ) { \nif ( ctMethod . getName ( ) . equals ( methodName ) ) { \ntry { \nCtMethod ctMethodCopy = CtNewMethod . copy ( ctMethod , profileConcreteClass , null ) ; \nString methodBody = \"{ return ($r)\" + ClassGeneratorUtils . MANAGEMENT_HANDLER + \".getUsageParameterSet(profileObject,$1); }\" ; \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Implemented method \" + methodName + \" , body = \" + methodBody ) ; \nctMethodCopy . setBody ( methodBody ) ; \nprofileConcreteClass . addMethod ( ctMethodCopy ) ; \n} \ncatch ( CannotCompileException e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7180": "public class Resource { \npublic void setViewingHints ( List < ViewingHint > viewingHints ) throws IllegalArgumentException { \nfor ( ViewingHint hint : viewingHints ) { \nboolean supportsHint = ( hint . getType ( ) == ViewingHint . Type . OTHER || this . getSupportedViewingHintTypes ( ) . contains ( hint . getType ( ) ) ) ; \nif ( ! supportsHint ) { \nthrow new IllegalArgumentException ( String . format ( \"Resources of type '%s' do not support the '%s' viewing hint.\" , this . getType ( ) , hint . toString ( ) ) ) ; \n} \n} \nthis . viewingHints = viewingHints ; \nreturn ; \n} \n} \n"}
{"7182": "public class Resource { \npublic void setRenderings ( List < OtherContent > renderings ) throws IllegalArgumentException { \nrenderings . forEach ( this :: verifyRendering ) ; \nthis . renderings = renderings ; \nreturn ; \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) { \nbridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \n} \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nwhile ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) { \ntry { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \nfor ( int i = 0 ; \ni < devices . length ; \ni ++ ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \nreturn ; \n} \n} \n"}
{"7192": "public class AbstractDevice { \npublic void cleanTemp ( ) { \nCommandLine dumpcommand = adbCommand ( \"shell\" , \"rm\" , \"-r\" , \"/data/local/tmp/local/tmp/dump.xml\" ) ; \nexecuteCommandQuietly ( dumpcommand ) ; \ntry { \nThread . sleep ( 1000 ) ; \n} \ncatch ( InterruptedException ie ) { \nthrow new RuntimeException ( ie ) ; \n} \nCommandLine qiancommand = adbCommand ( \"shell\" , \"rm\" , \"-r\" , \"/data/local/tmp/local/tmp/qian.xml\" ) ; \nString output = executeCommandQuietly ( qiancommand ) ; \nlog . debug ( \"Delete file qian.xml: {}\" , output ) ; \ntry { \nThread . sleep ( 1000 ) ; \n} \ncatch ( InterruptedException ie ) { \nthrow new RuntimeException ( ie ) ; \n} \nCommandLine command = adbCommand ( \"shell\" , \"rm\" , \"-r\" , \"/data/local/tmp/uidump.xml\" ) ; \nexecuteCommandQuietly ( command ) ; \ntry { \nThread . sleep ( 1000 ) ; \n} \ncatch ( InterruptedException ie ) { \nthrow new RuntimeException ( ie ) ; \n} \nreturn ; \n} \n} \n"}
{"7200": "public class ExceptionCollector { \nfinal void addException ( SQLException exception ) { \nif ( ! ( exception instanceof SQLTimeoutException ) && ! ( exception instanceof SQLTransactionRollbackException ) ) { \ngetOrInit ( ) . offer ( exception ) ; \n} \nreturn ; \n} \n} \n"}
{"7201": "public class ClhmStatementCache { \n@ Override public void close ( ) { \nif ( closed . getAndSet ( true ) ) { \nreturn ; \n} \nfor ( Map . Entry < StatementMethod , StatementHolder > entry : statementCache . entrySet ( ) ) { \nStatementHolder value = entry . getValue ( ) ; \nstatementCache . remove ( entry . getKey ( ) , value ) ; \nquietClose ( value . rawStatement ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7203": "public class Barbershop { \nvoid writeToFiler ( Filer filer ) throws IOException { \nClassName targetClassName = ClassName . get ( classPackage , targetClass ) ; \nTypeSpec . Builder barberShop = TypeSpec . classBuilder ( className ) . addModifiers ( Modifier . PUBLIC ) . addTypeVariable ( TypeVariableName . get ( \"T\" , targetClassName ) ) . addMethod ( generateStyleMethod ( ) ) . addMethod ( generateCheckParentMethod ( ) ) ; \nif ( parentBarbershop == null ) { \nbarberShop . addSuperinterface ( ParameterizedTypeName . get ( ClassName . get ( Barber . IBarbershop . class ) , TypeVariableName . get ( \"T\" ) ) ) ; \nbarberShop . addField ( FieldSpec . builder ( WeakHashSet . class , \"lastStyledTargets\" , Modifier . PROTECTED ) . initializer ( \"new $T()\" , WeakHashSet . class ) . build ( ) ) ; \n} \nelse { \nbarberShop . superclass ( ParameterizedTypeName . get ( ClassName . bestGuess ( parentBarbershop ) , TypeVariableName . get ( \"T\" ) ) ) ; \n} \nJavaFile javaFile = JavaFile . builder ( classPackage , barberShop . build ( ) ) . build ( ) ; \njavaFile . writeTo ( filer ) ; \nreturn ; \n} \n} \n"}
{"7204": "public class TrieWriter { \npublic void writeBitVector01Divider ( BitVector01Divider divider ) throws IOException { \ndos . writeBoolean ( divider . isFirst ( ) ) ; \ndos . writeBoolean ( divider . isZeroCounting ( ) ) ; \nreturn ; \n} \n} \n"}
{"7205": "public class BitVectorUtil { \npublic static void appendBitStrings ( BitVector bv , String [ ] bs ) { \nfor ( String s : bs ) { \nif ( s . length ( ) != 8 ) throw new RuntimeException ( \"The length of bit string must be 8  while \" + s . length ( ) ) ; \nfor ( char c : s . toCharArray ( ) ) { \nif ( c == '0' ) bv . append0 ( ) ; \nelse if ( c == '1' ) bv . append1 ( ) ; \nelse throw new RuntimeException ( \"invalid char '\" + c + \"' for bit string.\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7206": "public class BitVector01Divider { \npublic void readFrom ( InputStream is ) throws IOException { \nDataInputStream dis = new DataInputStream ( is ) ; \nfirst = dis . readBoolean ( ) ; \nzeroCounting = dis . readBoolean ( ) ; \nreturn ; \n} \n} \n"}
{"7209": "public class ExtentCucumberFormatter { \nprivate static synchronized void setKlovReport ( ) { \nif ( extentReports == null ) { \nreturn ; \n} \nExtentProperties extentProperties = ExtentProperties . INSTANCE ; \nif ( klovReporter != null ) { \nreturn ; \n} \nif ( extentProperties . getKlovServerUrl ( ) != null ) { \nString hostname = extentProperties . getMongodbHost ( ) ; \nint port = extentProperties . getMongodbPort ( ) ; \nString database = extentProperties . getMongodbDatabase ( ) ; \nString username = extentProperties . getMongodbUsername ( ) ; \nString password = extentProperties . getMongodbPassword ( ) ; \ntry { \nklovReporter = new KlovReporter ( ) ; \nif ( username != null && password != null ) { \nMongoClientURI uri = new MongoClientURI ( \"mongodb://\" + username + \":\" + password + \"@\" + hostname + \":\" + port + \"/?authSource=\" + database ) ; \nklovReporter . initMongoDbConnection ( uri ) ; \n} \nelse { \nklovReporter . initMongoDbConnection ( hostname , port ) ; \n} \nklovReporter . setProjectName ( extentProperties . getKlovProjectName ( ) ) ; \nklovReporter . setReportName ( extentProperties . getKlovReportName ( ) ) ; \nklovReporter . setKlovUrl ( extentProperties . getKlovServerUrl ( ) ) ; \nextentReports . attachReporter ( klovReporter ) ; \n} \ncatch ( Exception ex ) { \nklovReporter = null ; \nthrow new IllegalArgumentException ( \"Error setting up Klov Reporter\" , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7210": "public class Reporter { \npublic static void addScreenCaptureFromPath ( String imagePath , String title ) throws IOException { \ngetCurrentStep ( ) . addScreenCaptureFromPath ( imagePath , title ) ; \nreturn ; \n} \n} \n"}
{"7211": "public class Reporter { \npublic static void setSystemInfo ( String key , String value ) { \nif ( systemInfoKeyMap . isEmpty ( ) || ! systemInfoKeyMap . containsKey ( key ) ) { \nsystemInfoKeyMap . put ( key , false ) ; \n} \nif ( systemInfoKeyMap . get ( key ) ) { \nreturn ; \n} \ngetExtentReport ( ) . setSystemInfo ( key , value ) ; \nsystemInfoKeyMap . put ( key , true ) ; \nreturn ; \n} \n} \n"}
{"7212": "public class Selector { \npublic static Selector select ( final String propName ) { \nreturn new Selector ( propName , propName ) { \n@ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { \ngetPropertyValueAndPutIntoRow ( row , item , fields ) ; \nreturn ; \n} \n@ Override public void handleStart ( Collection < ? > results ) { \nreturn ; \n} \n@ Override public void handleComplete ( List < Map < String , Object > > rows ) { \nreturn ; \n} \n} \n; \n} \n} \n"}
{"7213": "public class Selector { \npublic static Selector selectAs ( final String propName , final String alias , final Function transform ) { \nreturn new Selector ( propName , alias ) { \n@ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { \nif ( ! path && fields != null ) { \nrow . put ( this . name , transform . apply ( fields . get ( this . name ) . getValue ( item ) ) ) ; \n} \nelse { \nrow . put ( alias , transform . apply ( BeanUtils . atIndex ( item , propName ) ) ) ; \n} \nreturn ; \n} \n@ Override public void handleStart ( Collection < ? > results ) { \nreturn ; \n} \n@ Override public void handleComplete ( List < Map < String , Object > > rows ) { \nreturn ; \n} \n} \n; \n} \n} \n"}
{"7228": "public class RecursiveDescentPropertyValidator { \nprivate void applyValidationMetaDataPropertiesToValidator ( ValidatorMetaData metaData , FieldValidator validator ) { \nMap < String , Object > properties = metaData . getProperties ( ) ; \nifPropertyBlankRemove ( properties , \"detailMessage\" ) ; \nifPropertyBlankRemove ( properties , \"summaryMessage\" ) ; \nBeanUtils . copyProperties ( validator , properties ) ; \nreturn ; \n} \n} \n"}
{"7229": "public class RecursiveDescentPropertyValidator { \nprivate void ifPropertyBlankRemove ( Map < String , Object > properties , String property ) { \nObject object = properties . get ( property ) ; \nif ( object == null ) { \nproperties . remove ( property ) ; \n} \nelse if ( object instanceof String ) { \nString string = ( String ) object ; \nif ( \"\" . equals ( string . trim ( ) ) ) { \nproperties . remove ( property ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7230": "public class AsyncFileWriterDataStore { \n@ Override public void tick ( long time ) { \nthis . time . set ( time ) ; \napproxTime . set ( Dates . utcNow ( ) ) ; \nreturn ; \n} \n} \n"}
{"7235": "public class LevelDBKeyValueStore { \n@ Override public void putAll ( Map < byte [ ] , byte [ ] > values ) { \nWriteBatch batch = database . createWriteBatch ( ) ; \ntry { \nfor ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { \nbatch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nif ( putAllWriteCount . addAndGet ( values . size ( ) ) > 10_000 ) { \nputAllWriteCount . set ( 0 ) ; \ndatabase . write ( batch , flush ) ; \n} \nelse { \ndatabase . write ( batch , writeOptions ) ; \n} \n} \nfinally { \ncloseBatch ( batch ) ; \n} \nreturn ; \n} \n} \n"}
{"7236": "public class LevelDBKeyValueStore { \n@ Override public void removeAll ( Iterable < byte [ ] > keys ) { \nWriteBatch batch = database . createWriteBatch ( ) ; \ntry { \nfor ( byte [ ] key : keys ) { \nbatch . delete ( key ) ; \n} \ndatabase . write ( batch ) ; \n} \nfinally { \ncloseBatch ( batch ) ; \n} \nreturn ; \n} \n} \n"}
{"7237": "public class LevelDBKeyValueStore { \n@ Override public KeyValueIterable < byte [ ] , byte [ ] > search ( byte [ ] startKey ) { \nfinal DBIterator iterator = database . iterator ( ) ; \niterator . seek ( startKey ) ; \nreturn new KeyValueIterable < byte [ ] , byte [ ] > ( ) { \n@ Override public void close ( ) { \ncloseIterator ( iterator ) ; \nreturn ; \n} \n@ Override public Iterator < Entry < byte [ ] , byte [ ] > > iterator ( ) { \nreturn new Iterator < Entry < byte [ ] , byte [ ] > > ( ) { \n@ Override public boolean hasNext ( ) { \nreturn iterator . hasNext ( ) ; \n} \n@ Override public Entry < byte [ ] , byte [ ] > next ( ) { \nMap . Entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; \nreturn new Entry < > ( next . getKey ( ) , next . getValue ( ) ) ; \n} \n@ Override public void remove ( ) { \niterator . remove ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"7239": "public class LevelDBKeyValueStore { \n@ Override public void close ( ) { \ntry { \nflush ( ) ; \ndatabase . close ( ) ; \n} \ncatch ( Exception e ) { \nExceptions . handle ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"7259": "public class MapperSimple { \nprivate void processArrayOfMaps ( Object newInstance , FieldAccess field , Map < String , Object > [ ] maps ) { \nList < Map < String , Object > > list = Lists . list ( maps ) ; \nhandleCollectionOfMaps ( newInstance , field , list ) ; \nreturn ; \n} \n} \n"}
{"7260": "public class MapperSimple { \n@ SuppressWarnings ( \"unchecked\" ) private void handleCollectionOfMaps ( Object newInstance , FieldAccess field , Collection < Map < String , Object > > collectionOfMaps ) { \nCollection < Object > newCollection = Conversions . createCollection ( field . type ( ) , collectionOfMaps . size ( ) ) ; \nClass < ? > componentClass = field . getComponentClass ( ) ; \nif ( componentClass != null ) { \nfor ( Map < String , Object > mapComponent : collectionOfMaps ) { \nnewCollection . add ( fromMap ( mapComponent , componentClass ) ) ; \n} \nfield . setObject ( newInstance , newCollection ) ; \n} \nreturn ; \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( int index = 0 ; \nindex < chars . length ; \nindex ++ ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nbuffer . append ( cchar ) ; \n} \nreturn ; \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 && ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasNumber = false ; \n} \nreturn ; \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \nreturn ; \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 && ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasUpperCase = false ; \n} \nreturn ; \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7266": "public class BaseDataStore { \nprivate void processReadQueue ( ) throws InterruptedException { \nReadStatus readStatus = new ReadStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( request != null ) { \nreadStatus . tracker . addCall ( request , outputDataQueue ) ; \nreadOperationsBatch . add ( request ) ; \nif ( readOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { \nbreak ; \n} \nrequest = readOperationsQueue . poll ( ) ; \n} \nif ( readOperationsBatch . size ( ) > 0 ) { \ntry { \nrecievedReadBatch ( new ArrayList < > ( readOperationsBatch ) ) ; \n} \nfinally { \nreadOperationsBatch . clear ( ) ; \n} \n} \nelse { \nflushReadsIfNeeded ( ) ; \n} \nif ( readStatus . readBatchSize . size ( ) > 1_000 ) { \nStatCount count ; \nfinal long now = Timer . timer ( ) . time ( ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME USER  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME CPU  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.max\" , readStatus . readBatchSize . max ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.min\" , readStatus . readBatchSize . min ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.median\" , readStatus . readBatchSize . median ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.mean\" , readStatus . readBatchSize . mean ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.standardDeviation\" , readStatus . readBatchSize . standardDeviation ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.variance\" , readStatus . readBatchSize . variance ( ) ) ; \noutputDataQueue . put ( count ) ; \nreadStatus . readBatchSize . clear ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7267": "public class BaseDataStore { \nprivate void processWriteQueue ( ) throws InterruptedException { \nWriteStatus status = new WriteStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( operation != null ) { \nstatus . tracker . addCall ( operation , outputDataQueue ) ; \nwriteOperationsBatch . add ( operation ) ; \nif ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { \nbreak ; \n} \noperation = writeOperationsQueue . poll ( ) ; \n} \nif ( writeOperationsBatch . size ( ) > 0 ) { \ntry { \nstatus . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; \nrecievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; \n} \nfinally { \nwriteOperationsBatch . clear ( ) ; \n} \n} \nelse { \nflushWritesIfNeeded ( ) ; \n} \nif ( status . writeBatchSize . size ( ) > 1000 ) { \nstatus . sendBatchSize ( source , outputDataQueue ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7268": "public class BaseDataStore { \npublic void start ( ) { \nscheduledExecutorService = Executors . newScheduledThreadPool ( 2 , new ThreadFactory ( ) { \n@ Override public Thread newThread ( Runnable runnable ) { \nThread thread = new Thread ( runnable ) ; \nthread . setName ( \" DataQueue Process \" + source ) ; \nreturn thread ; \n} \n} \n) ; \nfuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nif ( stop . get ( ) ) { \nreturn ; \n} \ntry { \nprocessWriteQueue ( ) ; \n} \ncatch ( InterruptedException ex ) { \n} \ncatch ( Exception ex ) { \nlogger . fatal ( ex ) ; \n} \nreturn ; \n} \n} \n, 0 , dataStoreConfig . threadErrorResumeTimeMS ( ) , TimeUnit . MILLISECONDS ) ; \nfuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nif ( stop . get ( ) ) { \nreturn ; \n} \ntry { \nprocessReadQueue ( ) ; \n} \ncatch ( InterruptedException ex ) { \n} \ncatch ( Exception ex ) { \nlogger . fatal ( ex , \"Problem with base data store running scheduled job\" ) ; \n} \nreturn ; \n} \n} \n, 0 , dataStoreConfig . threadErrorResumeTimeMS ( ) , TimeUnit . MILLISECONDS ) ; \nreturn ; \n} \n} \n"}
{"7284": "public class Sort { \npublic void sort ( List list , Map < String , FieldAccess > fields ) { \nCollections . sort ( list , this . comparator ( fields ) ) ; \nreturn ; \n} \n} \n"}
{"7292": "public class SortingInternal { \npublic static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending ) { \nsort ( list , sortBy , fields , ascending , false ) ; \nreturn ; \n} \n} \n"}
{"7293": "public class SortingInternal { \npublic static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending , boolean nullsFirst ) { \ntry { \nif ( list == null || list . size ( ) == 0 ) { \nreturn ; \n} \nObject o = list . get ( 0 ) ; \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \ncatch ( Exception ex ) { \nExceptions . handle ( ex , \"list\" , list , \"\\nsortBy\" , sortBy , \"fields\" , fields , \"ascending\" , ascending , \"nullFirst\" , nullsFirst ) ; \n} \nreturn ; \n} \n} \n"}
{"7294": "public class MapperComplex { \nprivate void setFieldValueFromMap ( final Object parentObject , final FieldAccess field , final Map mapInner ) { \nClass < ? > fieldClassType = field . type ( ) ; \nObject value = null ; \nif ( ! Typ . isMap ( fieldClassType ) ) { \nif ( ! fieldClassType . isInterface ( ) && ! Typ . isAbstract ( fieldClassType ) ) { \nvalue = fromMap ( mapInner , field . type ( ) ) ; \n} \nelse { \nObject oClassName = mapInner . get ( \"class\" ) ; \nif ( oClassName != null ) { \nvalue = fromMap ( mapInner , Reflection . loadClass ( oClassName . toString ( ) ) ) ; \n} \nelse { \nvalue = null ; \n} \n} \n} \nelse if ( Typ . isMap ( fieldClassType ) ) { \nClass keyType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 0 ] ; \nClass valueType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 1 ] ; \nSet < Map . Entry > set = mapInner . entrySet ( ) ; \nMap newMap = new LinkedHashMap ( ) ; \nfor ( Map . Entry entry : set ) { \nObject evalue = entry . getValue ( ) ; \nObject key = entry . getKey ( ) ; \nif ( evalue instanceof ValueContainer ) { \nevalue = ( ( ValueContainer ) evalue ) . toValue ( ) ; \n} \nkey = Conversions . coerce ( keyType , key ) ; \nevalue = Conversions . coerce ( valueType , evalue ) ; \nnewMap . put ( key , evalue ) ; \n} \nvalue = newMap ; \n} \nfield . setValue ( parentObject , value ) ; \nreturn ; \n} \n} \n"}
{"7296": "public class BaseVersionedMySQLSupport { \nprotected void createLoadAllVersionDataSQL ( String table ) { \nCharBuf buf = CharBuf . create ( 100 ) ; \nbuf . add ( \"select kv_key, 1, version, update_timestamp, create_timestamp from `\" ) ; \nbuf . add ( table ) ; \nbuf . add ( \"` where kv_key in (\" ) ; \nbuf . multiply ( \"?,\" , this . loadKeyCount ) ; \nbuf . removeLastChar ( ) ; \nbuf . add ( \");\" ) ; \nthis . loadAllVersionDataByKeysSQL = buf . toString ( ) ; \nreturn ; \n} \n} \n"}
{"7305": "public class Sorting { \npublic static void sort ( List list , Sort ... sorts ) { \nSort . sorts ( sorts ) . sort ( list ) ; \nreturn ; \n} \n} \n"}
{"7306": "public class Sorting { \npublic static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( list == null || list . size ( ) == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nIterator iterator = list . iterator ( ) ; \nObject object = iterator . next ( ) ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nwhile ( iterator . hasNext ( ) ) { \nobject = iterator . next ( ) ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nfor ( int index = 1 ; \nindex < array . length ; \nindex ++ ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7316": "public class FastConcurrentReadLruLfuFifoCache { \nprivate final void evictIfNeeded ( ) { \nif ( list . size ( ) > evictSize ) { \nfinal List < CacheEntry < KEY , VALUE > > killList = list . sortAndReturnPurgeList ( 0.1f ) ; \nfor ( CacheEntry < KEY , VALUE > cacheEntry : killList ) { \nmap . remove ( cacheEntry . key ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7317": "public class LongRangeValidator { \nprivate void dynamicallyInitIfNeeded ( Object value ) { \nif ( ! isInitialized ( ) ) { \nif ( value instanceof Integer ) { \ninit ( new Integer ( min . intValue ( ) ) , new Integer ( max . intValue ( ) ) ) ; \n} \nelse if ( value instanceof Byte ) { \ninit ( new Byte ( min . byteValue ( ) ) , new Byte ( max . byteValue ( ) ) ) ; \n} \nelse if ( value instanceof Short ) { \ninit ( new Short ( min . shortValue ( ) ) , new Short ( max . shortValue ( ) ) ) ; \n} \nelse { \ninit ( min , max ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7320": "public class CollectorManager { \nprivate void manageInputWriterChannel ( ) throws InterruptedException { \ntry { \nByteBuffer dataToWriteToFile ; \ndataToWriteToFile = inputChannel . poll ( ) ; \nif ( dataToWriteToFile == null ) { \nqueueEmptyMaybeFlush ( ) ; \ndataToWriteToFile = inputChannel . poll ( ) ; \n} \nif ( dataToWriteToFile == null ) { \ndataToWriteToFile = waitForNextDataToWrite ( ) ; \n} \nif ( dataToWriteToFile != null ) { \nwriter . nextBufferToWrite ( dataToWriteToFile ) ; \nif ( RECYCLE_BUFFER ) { \nrecycleChannel . offer ( dataToWriteToFile ) ; \n} \n} \n} \ncatch ( InterruptedException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nex . printStackTrace ( ) ; \nex . printStackTrace ( System . err ) ; \n} \nreturn ; \n} \n} \n"}
{"7321": "public class CollectorManager { \nprivate void queueEmptyMaybeFlush ( ) { \nif ( PERIODIC_FORCE_FLUSH ) { \nlong currentTime = time . get ( ) ; \nif ( ( currentTime - lastFlushTime ) > FORCE_FLUSH_AFTER_THIS_MANY_MILI_SECONDS ) { \nif ( writer . syncToDisk ( ) ) { \nthis . numberOfFlushesTotal . incrementAndGet ( ) ; \n} \nlastFlushTime = time . get ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7322": "public class CollectorManager { \nprivate void startMonitor ( ) { \nfinal ScheduledExecutorService monitor = Executors . newScheduledThreadPool ( 2 , new ThreadFactory ( ) { \n@ Override public Thread newThread ( Runnable runnable ) { \nThread thread = new Thread ( runnable ) ; \nthread . setPriority ( Thread . NORM_PRIORITY + 1 ) ; \nreturn thread ; \n} \n} \n) ; \nmonitorFuture = monitor . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nmonitor ( ) ; \nreturn ; \n} \n} \n, MONITOR_INTERVAL_SECONDS , MONITOR_INTERVAL_SECONDS , TimeUnit . SECONDS ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { \n@ Override public void run ( ) { \nSystem . err . println ( \"shutting down....\" ) ; \nmonitor ( ) ; \nreturn ; \n} \n} \n) ) ; \nreturn ; \n} \n} \n"}
{"7323": "public class CollectorManager { \npublic void start ( final TimeAware receiver ) { \nwriterFuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nprocessWrites ( ) ; \nreturn ; \n} \n} \n, 0 , 500 , TimeUnit . MILLISECONDS ) ; \nstartMonitor ( ) ; \ntickTock = this . scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nlong time = System . nanoTime ( ) / 1_000_000 ; \nif ( receiver != null ) { \nreceiver . tick ( time ) ; \n} \ntick ( time ) ; \nreturn ; \n} \n} \n, 0 , 20 , TimeUnit . MILLISECONDS ) ; \nreturn ; \n} \n} \n"}
{"7326": "public class FilterDefault { \nprivate void doFilterGroup ( Group group , ResultSetInternal results ) { \nif ( group . getGrouping ( ) == Grouping . OR ) { \nor ( group . getExpressions ( ) , fields , results ) ; \n} \nelse { \nResultSetInternal resultsForAnd = new ResultSetImpl ( fields ) ; \nand ( group . getExpressions ( ) , fields , resultsForAnd ) ; \nresults . addResults ( resultsForAnd . asList ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7327": "public class BatchFileWriter { \npublic void tick ( long time ) { \nthis . time . set ( time ) ; \nlong startTime = fileStartTime . get ( ) ; \nlong duration = time - startTime ; \nif ( duration > FILE_TIMEOUT_MILISECONDS ) { \nfileTimeOut . set ( true ) ; \n} \nreturn ; \n} \n} \n"}
{"7329": "public class BatchFileWriter { \nprivate void cleanupOutputStream ( ) { \nif ( outputStream != null ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \nreturn ; \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal int size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred += size ; \nbytesTransferred += size ; \nbytesSinceLastFlush += size ; \nbuffersSent ++ ; \n} \nif ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \nreturn ; \n} \n} \n"}
{"7331": "public class BatchFileWriter { \nprivate void write ( final ByteBuffer bufferOut ) throws InterruptedException { \ninitOutputStream ( ) ; \ntry { \nif ( outputStream != null ) { \noutputStream . write ( bufferOut ) ; \n} \nelse { \nerror . set ( true ) ; \n} \nif ( bytesSinceLastFlush > FLUSH_EVERY_N_BYTES ) { \nsyncToDisk ( ) ; \nbytesSinceLastFlush = 0 ; \n} \n} \ncatch ( ClosedByInterruptException cbie ) { \nthrow new InterruptedException ( \"File closed by interruption\" ) ; \n} \ncatch ( Exception e ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \ne . printStackTrace ( System . err ) ; \ndiagnose ( ) ; \nExceptions . handle ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"7332": "public class BatchFileWriter { \nprivate void initOutputStream ( ) { \nlong time = this . time . get ( ) ; \nif ( error . get ( ) || this . totalBytesTransferred == 0 ) { \ncleanupOutputStream ( ) ; \nerror . set ( false ) ; \ntime = System . nanoTime ( ) / 1_000_000 ; \n} \nif ( outputStream != null ) { \nreturn ; \n} \nfileName = LogFilesConfig . getLogFileName ( FORMAT_PATTERN , outputDirPath ( ) , numFiles , time , SERVER_NAME ) ; \ntry { \nfileTimeOut . set ( false ) ; \noutputStream = streamCreator ( ) ; \nfileStartTime . set ( time ) ; \nbytesTransferred = 0 ; \nbytesSinceLastFlush = 0 ; \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \nExceptions . handle ( ex ) ; \n} \nfinally { \nnumFiles ++ ; \n} \nreturn ; \n} \n} \n"}
{"7333": "public class BaseStringStringKeyValueStore { \npublic void putAll ( Map < K , V > values ) { \nSet < Map . Entry < K , V > > entries = values . entrySet ( ) ; \nMap < String , String > map = new HashMap < > ( values . size ( ) ) ; \nfor ( Map . Entry < K , V > entry : entries ) { \nmap . put ( toKeyString ( entry . getKey ( ) ) , toValueString ( entry . getValue ( ) ) ) ; \n} \nstore . putAll ( map ) ; \nreturn ; \n} \n} \n"}
{"7352": "public class BeanUtils { \npublic static void injectIntoProperty ( Object object , String path , Object value ) { \nString [ ] properties = propertyPathAsStringArray ( path ) ; \nsetPropertyValue ( object , value , properties ) ; \nreturn ; \n} \n} \n"}
{"7353": "public class BeanUtils { \npublic static void idx ( Class < ? > cls , String path , Object value ) { \nString [ ] properties = propertyPathAsStringArray ( path ) ; \nsetPropertyValue ( cls , value , properties ) ; \nreturn ; \n} \n} \n"}
{"7357": "public class MessageSpecification { \npublic void init ( ) { \nif ( name == null && parent == null ) { \nthis . setDetailMessage ( \"{\" + this . getClass ( ) . getName ( ) + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + this . getClass ( ) . getName ( ) + SUMMARY_KEY + \"}\" ) ; \n} \nelse if ( name != null && parent == null ) { \nthis . setDetailMessage ( \"{\" + \"message.\" + getName ( ) + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + \"message.\" + getName ( ) + SUMMARY_KEY + \"}\" ) ; \n} \nelse if ( parent != null ) { \nthis . setDetailMessage ( \"{\" + \"message.\" + parent + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + \"message.\" + parent + SUMMARY_KEY + \"}\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! request . getMethod ( ) . equals ( \"GET\" ) ) { \nhttpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \n} \nelse { \nhttpClientRequest . end ( ) ; \n} \nreturn ; \n} \n} \n; \nif ( closed . get ( ) ) { \nthis . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nint retry = 0 ; \nwhile ( closed . get ( ) ) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) { \nbreak ; \n} \nretry ++ ; \nif ( retry > 10 ) { \nbreak ; \n} \nif ( retry % 3 == 0 ) { \nconnect ( ) ; \n} \n} \nif ( ! closed . get ( ) ) { \nrunnable . run ( ) ; \n} \nelse { \nresponseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \nreturn ; \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \n} \nelse { \nrunnable . run ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7364": "public class CouchDbContext { \npublic void deleteDB ( String dbName , String confirm ) { \nassertNotEmpty ( dbName , \"dbName\" ) ; \nif ( ! \"delete database\" . equals ( confirm ) ) throw new IllegalArgumentException ( \"Invalid confirm!\" ) ; \ndbc . delete ( buildUri ( dbc . getBaseUri ( ) ) . path ( dbName ) . build ( ) ) ; \nreturn ; \n} \n} \n"}
{"7365": "public class CouchDbContext { \npublic void createDB ( String dbName ) { \nassertNotEmpty ( dbName , \"dbName\" ) ; \nInputStream getresp = null ; \nHttpResponse putresp = null ; \nfinal URI uri = buildUri ( dbc . getBaseUri ( ) ) . path ( dbName ) . build ( ) ; \ntry { \ngetresp = dbc . get ( uri ) ; \n} \ncatch ( NoDocumentException e ) { \nfinal HttpPut put = new HttpPut ( uri ) ; \nputresp = dbc . executeRequest ( put ) ; \nlog . info ( String . format ( \"Created Database: '%s'\" , dbName ) ) ; \n} \nfinally { \nclose ( getresp ) ; \nclose ( putresp ) ; \n} \nreturn ; \n} \n} \n"}
{"7371": "public class CouchDbDesign { \npublic void synchronizeAllWithDb ( ) { \nList < DesignDocument > documents = getAllFromDesk ( ) ; \nfor ( DesignDocument dd : documents ) { \nsynchronizeWithDb ( dd ) ; \n} \nreturn ; \n} \n} \n"}
{"7387": "public class CouchDbClientBase { \nvoid validate ( HttpResponse response ) throws IOException { \nfinal int code = response . getStatusLine ( ) . getStatusCode ( ) ; \nif ( code == 200 || code == 201 || code == 202 ) { \nreturn ; \n} \nString reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; \nswitch ( code ) { \ncase HttpStatus . SC_NOT_FOUND : { \nthrow new NoDocumentException ( reason ) ; \n} \ncase HttpStatus . SC_CONFLICT : { \nthrow new DocumentConflictException ( reason ) ; \n} \ndefault : { \nthrow new CouchDbException ( reason += EntityUtils . toString ( response . getEntity ( ) ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7388": "public class CouchDbClientBase { \nprivate void setEntity ( HttpEntityEnclosingRequestBase httpRequest , String json ) { \nStringEntity entity = new StringEntity ( json , \"UTF-8\" ) ; \nentity . setContentType ( \"application/json\" ) ; \nhttpRequest . setEntity ( entity ) ; \nreturn ; \n} \n} \n"}
{"7389": "public class Document { \npublic void addAttachment ( String name , Attachment attachment ) { \nif ( attachments == null ) attachments = new HashMap < String , Attachment > ( ) ; \nattachments . put ( name , attachment ) ; \nreturn ; \n} \n} \n"}
{"7393": "public class LockManager { \npublic void shutdown ( ) { \ntry { \nlocksExecutor . shutdown ( ) ; \nlocksExecutor . awaitTermination ( 5 , TimeUnit . SECONDS ) ; \nCountDownLatch latch = new CountDownLatch ( 1 ) ; \nactiveLocksLock . writeLock ( ) . lock ( ) ; \nObservable . from ( activeLocks . entrySet ( ) ) . map ( Map . Entry :: getValue ) . flatMap ( lock -> releaseLock ( lock . getName ( ) , lock . getValue ( ) ) . map ( released -> new Lock ( lock . getName ( ) , lock . getValue ( ) , lock . getExpiration ( ) , lock . getRenewalRate ( ) , ! released ) ) ) . subscribe ( lock -> { \nif ( lock . isLocked ( ) ) { \nlogger . infof ( \"Failed to release lock %s\" , lock . getName ( ) ) ; \n} \n} \n, t -> { \nlogger . info ( \"There was an error while releasing locks\" , t ) ; \nlatch . countDown ( ) ; \n} \n, latch :: countDown ) ; \nlatch . await ( ) ; \nlogger . info ( \"Shutdown complete\" ) ; \n} \ncatch ( InterruptedException e ) { \nlogger . debug ( \"Shutdown was interrupted. Some locks may not have been released but they will still expire.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7394": "public class ObservableServlet { \npublic static Observable < Void > write ( final Observable < byte [ ] > data , final ServletOutputStream out ) { \nreturn Observable . create ( new Observable . OnSubscribe < Void > ( ) { \n@ Override public void call ( Subscriber < ? super Void > subscriber ) { \nObservable < Void > events = create ( out ) . onBackpressureBuffer ( ) ; \nObservable < Void > writeobs = Observable . zip ( data , events , ( b , aVoid ) -> { \ntry { \nout . write ( b ) ; \n} \ncatch ( IOException ioe ) { \nExceptions . propagate ( ioe ) ; \n} \nreturn null ; \n} \n) ; \nwriteobs . subscribe ( subscriber ) ; \nreturn ; \n} \n} \n) ; \n} \n} \n"}
{"7396": "public class MetricsServiceImpl { \npublic void verifyAndCreateTempTables ( ) { \nZonedDateTime currentBlock = ZonedDateTime . ofInstant ( Instant . ofEpochMilli ( DateTimeService . now . get ( ) . getMillis ( ) ) , UTC ) . with ( DateTimeService . startOfPreviousEvenHour ( ) ) ; \nZonedDateTime lastStartupBlock = currentBlock . plus ( 6 , ChronoUnit . HOURS ) ; \nverifyAndCreateTempTables ( currentBlock , lastStartupBlock ) . await ( ) ; \nreturn ; \n} \n} \n"}
{"7399": "public class TokenAuthenticator { \nprivate void sendAuthenticationRequest ( HttpServerExchange serverExchange , PooledConnection connection ) { \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nString verb = getVerb ( serverExchange ) ; \nString resource ; \nif ( ! isQuery ( serverExchange ) ) { \nif ( USER_WRITE_ACCESS . equalsIgnoreCase ( \"true\" ) ) { \nresource = RESOURCE ; \n} \nelse { \nresource = resourceName ; \n} \n} \nelse { \nresource = RESOURCE ; \n} \ncontext . subjectAccessReview = generateSubjectAccessReview ( context . tenant , verb , resource ) ; \nClientRequest request = buildClientRequest ( context ) ; \ncontext . clientRequestStarting ( ) ; \nconnection . sendRequest ( request , new RequestReadyCallback ( serverExchange , connection ) ) ; \nreturn ; \n} \n} \n"}
{"7402": "public class TokenAuthenticator { \nprivate void onRequestResult ( HttpServerExchange serverExchange , PooledConnection connection , boolean allowed ) { \nconnectionPools . get ( serverExchange . getIoThread ( ) ) . release ( connection ) ; \nAuthContext context = serverExchange . removeAttachment ( AUTH_CONTEXT_KEY ) ; \napiLatency . update ( context . getClientResponseTime ( ) , NANOSECONDS ) ; \nauthLatency . update ( context . getLatency ( ) , NANOSECONDS ) ; \nif ( allowed ) { \nserverExchange . dispatch ( containerHandler ) ; \n} \nelse { \nendExchange ( serverExchange , FORBIDDEN ) ; \n} \nreturn ; \n} \n} \n"}
{"7403": "public class TokenAuthenticator { \nprivate void onRequestFailure ( HttpServerExchange serverExchange , PooledConnection connection , IOException e , boolean retry ) { \nlog . debug ( \"Client request failure\" , e ) ; \nIoUtils . safeClose ( connection ) ; \nConnectionPool connectionPool = connectionPools . get ( serverExchange . getIoThread ( ) ) ; \nconnectionPool . release ( connection ) ; \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nif ( context . retries < MAX_RETRY && retry ) { \ncontext . retries ++ ; \nPooledConnectionWaiter waiter = createWaiter ( serverExchange ) ; \nif ( ! connectionPool . offer ( waiter ) ) { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , TOO_MANY_PENDING_REQUESTS ) ; \n} \n} \nelse { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , CLIENT_REQUEST_FAILURE ) ; \n} \nreturn ; \n} \n} \n"}
{"7404": "public class ConfigurationService { \npublic void init ( RxSession session ) { \nthis . session = session ; \nfindConfigurationGroup = session . getSession ( ) . prepare ( \"SELECT name, value FROM sys_config WHERE config_id = ?\" ) . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; \nfindConfigurationValue = session . getSession ( ) . prepare ( \"SELECT value FROM sys_config WHERE config_id = ? AND name= ?\" ) . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; \nupdateConfigurationValue = session . getSession ( ) . prepare ( \"INSERT INTO sys_config (config_id, name, value) VALUES (?, ?, ?)\" ) . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; \ndeleteConfigurationValue = session . getSession ( ) . prepare ( \"DELETE FROM sys_config WHERE config_id =? and name = ?\" ) . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; \ndeleteConfiguration = session . getSession ( ) . prepare ( \"DELETE FROM sys_config WHERE config_id = ?\" ) . setConsistencyLevel ( ConsistencyLevel . LOCAL_QUORUM ) ; \nreturn ; \n} \n} \n"}
{"7407": "public class Utils { \npublic static void endExchange ( HttpServerExchange exchange , int statusCode , String reasonPhrase ) { \nexchange . setStatusCode ( statusCode ) ; \nif ( reasonPhrase != null ) { \nexchange . setReasonPhrase ( reasonPhrase ) ; \n} \nexchange . endExchange ( ) ; \nreturn ; \n} \n} \n"}
{"7411": "public class DefaultRocketMqProducer { \npublic void sendOneWayMsg ( Message msg ) { \ntry { \nproducer . sendOneway ( msg ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"send msg error\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7414": "public class Config { \npublic void setValue ( String property , Value value ) { \nthis . valueByProperty . put ( property . toLowerCase ( ) , value ) ; \nreturn ; \n} \n} \n"}
{"7416": "public class ZipBuilder { \npublic void replace ( File file , boolean preserveExternalFileName , String text ) { \nString path = entries . containsKey ( file ) ? entries . remove ( file ) : zipPathFor ( file , preserveExternalFileName ) ; \nentries . put ( text , path ) ; \nreturn ; \n} \n} \n"}
{"7425": "public class StringTemplate { \nprotected < S > void registerAdaptor ( STGroup group , Class < S > type , ModelAdaptor adaptor ) { \ngroup . registerModelAdaptor ( type , adaptor ) ; \nreturn ; \n} \n} \n"}
{"7426": "public class StringTemplate { \nprotected < S > void registerRenderer ( STGroup group , Class < S > type , AttributeRenderer attributeRenderer ) { \ngroup . registerRenderer ( type , attributeRenderer ) ; \nreturn ; \n} \n} \n"}
{"7428": "public class BatchSipAssembler { \npublic synchronized void add ( D domainObject ) throws IOException { \nif ( shouldStartNewSip ( domainObject ) ) { \nstartSip ( ) ; \n} \nassembler . add ( domainObject ) ; \nreturn ; \n} \n} \n"}
{"7429": "public class ConfigurationObject { \npublic void setProperty ( String name , Object value ) { \nproperties . put ( name , toJsonValue ( value ) ) ; \nreturn ; \n} \n} \n"}
{"7430": "public class ConfigurationObject { \npublic void addChildObject ( String collection , ConfigurationObject childObject ) { \nchildObjects . computeIfAbsent ( collection , ignored -> new ArrayList < > ( ) ) . add ( childObject ) ; \nreturn ; \n} \n} \n"}
{"7432": "public class IOStreams { \npublic static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { \nbyte [ ] buffer = new byte [ bufferSize ] ; \nint numRead = Objects . requireNonNull ( in , \"Missing input\" ) . read ( buffer ) ; \nif ( numRead == 0 ) { \nthrow new IllegalArgumentException ( \"Missing content\" ) ; \n} \nObjects . requireNonNull ( out , \"Missing output\" ) ; \nwhile ( numRead > 0 ) { \nout . write ( buffer , 0 , numRead ) ; \nhashAssembler . add ( buffer , numRead ) ; \nnumRead = in . read ( buffer ) ; \n} \nreturn ; \n} \n} \n"}
{"7439": "public class XmlUtil { \npublic static void validate ( InputStream xml , InputStream xmlSchema , String humanFriendlyDocumentType ) throws IOException { \ntry { \nnewXmlSchemaValidator ( xmlSchema ) . validate ( new StreamSource ( Objects . requireNonNull ( xml ) ) ) ; \n} \ncatch ( SAXException e ) { \nthrow new ValidationException ( \"Invalid \" + humanFriendlyDocumentType , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7440": "public class FileArchiver { \npublic static void main ( String [ ] args ) { \ntry { \nArguments arguments = new Arguments ( args ) ; \nFile root = new File ( arguments . next ( \"content\" ) ) ; \nif ( ! root . isDirectory ( ) ) { \nroot = new File ( \".\" ) ; \n} \nString rootPath = root . getCanonicalPath ( ) ; \nString sip = arguments . next ( \"build/files.zip\" ) ; \nnew FileArchiver ( ) . run ( rootPath , sip ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( System . out ) ; \nSystem . exit ( 1 ) ; \n} \nreturn ; \n} \n} \n"}
{"7445": "public class RequestHandler { \npublic void setSignature ( String accessKey , String signature , String gmtTime ) throws QSException { \nbuilder . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , gmtTime ) ; \nsetSignature ( accessKey , signature ) ; \nreturn ; \n} \n} \n"}
{"7447": "public class UploadManager { \nprivate void sign ( RequestHandler requestHandler ) throws QSException { \nif ( callBack != null ) { \nString signed = callBack . onSignature ( requestHandler . getStringToSignature ( ) ) ; \nif ( ! QSStringUtil . isEmpty ( signed ) ) requestHandler . setSignature ( callBack . onAccessKey ( ) , signed ) ; \nString correctTime = callBack . onCorrectTime ( requestHandler . getStringToSignature ( ) ) ; \nif ( correctTime != null && correctTime . trim ( ) . length ( ) > 0 ) requestHandler . getBuilder ( ) . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , correctTime ) ; \n} \nreturn ; \n} \n} \n"}
{"7448": "public class UploadManager { \nprivate void setData ( String objectKey , Recorder recorder ) { \nif ( recorder == null ) return ; \nString upload = new Gson ( ) . toJson ( uploadModel ) ; \nrecorder . set ( objectKey , upload . getBytes ( ) ) ; \nreturn ; \n} \n} \n"}
{"7449": "public class UploadManager { \nprivate void completeMultiUpload ( String objectKey , String fileName , String eTag , String uploadID , long length ) throws QSException { \nCompleteMultipartUploadInput completeMultipartUploadInput = new CompleteMultipartUploadInput ( uploadID , partCounts , 0 ) ; \ncompleteMultipartUploadInput . setContentLength ( length ) ; \nif ( ! QSStringUtil . isEmpty ( fileName ) ) { \ntry { \nString keyName = QSStringUtil . percentEncode ( fileName , \"UTF-8\" ) ; \ncompleteMultipartUploadInput . setContentDisposition ( String . format ( \"attachment; filename=\\\"%s\\\"; filename*=utf-8''%s\" , keyName , keyName ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \n} \nif ( ! QSStringUtil . isEmpty ( eTag ) ) { \ncompleteMultipartUploadInput . setETag ( eTag ) ; \n} \nRequestHandler requestHandler = bucket . completeMultipartUploadRequest ( objectKey , completeMultipartUploadInput ) ; \nsign ( requestHandler ) ; \nBucket . CompleteMultipartUploadOutput send = ( Bucket . CompleteMultipartUploadOutput ) requestHandler . send ( ) ; \nif ( send . getStatueCode ( ) == 200 || send . getStatueCode ( ) == 201 ) { \nuploadModel . setUploadComplete ( true ) ; \nsetData ( objectKey , recorder ) ; \n} \nif ( callBack != null ) callBack . onAPIResponse ( objectKey , send ) ; \nreturn ; \n} \n} \n"}
{"7450": "public class FavoriteAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nfinal String notificationId = entry . getId ( ) ; \nfinal Set < String > favoriteNotices = this . getFavoriteNotices ( req ) ; \nif ( favoriteNotices . contains ( notificationId ) ) { \nfavoriteNotices . remove ( notificationId ) ; \n} \nelse { \nfavoriteNotices . add ( notificationId ) ; \n} \nsetFavoriteNotices ( req , favoriteNotices ) ; \nreturn ; \n} \n} \n"}
{"7451": "public class JpaNotificationService { \npublic void addEntryState ( PortletRequest req , String entryId , NotificationState state ) { \nif ( usernameFinder . isAuthenticated ( req ) ) { \nfinal String username = usernameFinder . findUsername ( req ) ; \nString idStr = entryId . replaceAll ( ID_PREFIX , \"\" ) ; \nJpaEntry jpaEntry = notificationDao . getEntry ( Long . parseLong ( idStr ) ) ; \nif ( jpaEntry != null ) { \nJpaEvent event = new JpaEvent ( ) ; \nevent . setEntry ( jpaEntry ) ; \nevent . setState ( state ) ; \nevent . setTimestamp ( new Timestamp ( new Date ( ) . getTime ( ) ) ) ; \nevent . setUsername ( username ) ; \nnotificationDao . createOrUpdateEvent ( event ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"JpaEntry not found\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7462": "public class NotificationResponse { \nprivate void addCategories ( List < NotificationCategory > newCategories ) { \nif ( newCategories == null ) { \nreturn ; \n} \nnewCategories = newCategories . parallelStream ( ) . map ( NotificationCategory :: cloneNoExceptions ) . collect ( Collectors . toList ( ) ) ; \nMap < String , NotificationCategory > catsByName = this . categories . parallelStream ( ) . collect ( toMap ( c -> c . getTitle ( ) . toLowerCase ( ) , c -> c ) ) ; \nMap < Boolean , List < NotificationCategory > > matchingNewCats = newCategories . stream ( ) . collect ( partitioningBy ( c -> catsByName . containsKey ( c . getTitle ( ) . toLowerCase ( ) ) ) ) ; \nmatchingNewCats . get ( Boolean . TRUE ) . stream ( ) . forEachOrdered ( c -> catsByName . get ( c . getTitle ( ) . toLowerCase ( ) ) . addEntries ( c . getEntries ( ) ) ) ; \nthis . categories . addAll ( matchingNewCats . get ( Boolean . FALSE ) ) ; \nreturn ; \n} \n} \n"}
{"7467": "public class SSPTaskNotificationService { \nprivate void attachActions ( PortletRequest request , NotificationEntry entry ) { \nPortletPreferences prefs = request . getPreferences ( ) ; \nString stringVal = prefs . getValue ( SSP_NOTIFICATIONS_ENABLE_MARK_COMPLETED , \"false\" ) ; \nboolean enableMarkCompleted = ( \"true\" . equalsIgnoreCase ( stringVal ) ) ; \nList < NotificationAction > actions = new ArrayList < > ( ) ; \nif ( enableMarkCompleted ) { \nMarkTaskCompletedAction action = new MarkTaskCompletedAction ( entry . getId ( ) ) ; \nactions . add ( action ) ; \n} \nentry . setAvailableActions ( actions ) ; \nreturn ; \n} \n} \n"}
{"7471": "public class ReadAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nfinal String notificationId = entry . getId ( ) ; \nfinal Set < String > readNotices = this . getReadNotices ( req ) ; \nif ( readNotices . contains ( notificationId ) ) { \nreadNotices . remove ( notificationId ) ; \n} \nelse { \nreadNotices . add ( notificationId ) ; \n} \nsetReadNotices ( req , readNotices ) ; \nreturn ; \n} \n} \n"}
{"7475": "public class HideAction { \n@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { \nfinal NotificationEntry entry = getTarget ( ) ; \nif ( ! isEntrySnoozed ( entry , req ) ) { \nhide ( entry , req ) ; \n} \nelse { \nunhide ( entry , req ) ; \n} \nreturn ; \n} \n} \n"}
{"7477": "public class UtilTrig_F64 { \npublic static void normalize ( GeoTuple3D_F64 p ) { \ndouble n = p . norm ( ) ; \np . x /= n ; \np . y /= n ; \np . z /= n ; \nreturn ; \n} \n} \n"}
{"7479": "public class DistancePointTriangle3D_F64 { \npublic void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { \nGeometryMath_F64 . sub ( B , P , D ) ; \na = E0 . dot ( E0 ) ; \nb = E0 . dot ( E1 ) ; \nc = E1 . dot ( E1 ) ; \nd = E0 . dot ( D ) ; \ne = E1 . dot ( D ) ; \ndouble det = a * c - b * b ; \ns = b * e - c * d ; \nt = b * d - a * e ; \nif ( s + t <= det ) { \nif ( s < 0 ) { \nif ( t < 0 ) { \nregion4 ( ) ; \n} \nelse { \nregion3 ( ) ; \n} \n} \nelse if ( t < 0 ) { \nregion5 ( ) ; \n} \nelse { \nregion0 ( det ) ; \n} \n} \nelse { \nif ( s < 0 ) { \nregion2 ( ) ; \n} \nelse if ( t < 0 ) { \nregion6 ( ) ; \n} \nelse { \nregion1 ( ) ; \n} \n} \nclosestPt . x = B . x + s * E0 . x + t * E1 . x ; \nclosestPt . y = B . y + s * E0 . y + t * E1 . y ; \nclosestPt . z = B . z + s * E0 . z + t * E1 . z ; \nreturn ; \n} \n} \n"}
{"7481": "public class Se3_F64 { \npublic void set ( Se3_F64 se ) { \nR . set ( se . getR ( ) ) ; \nT . set ( se . getT ( ) ) ; \nreturn ; \n} \n} \n"}
{"7482": "public class Se3_F64 { \npublic void set ( double x , double y , double z , EulerType type , double rotA , double rotB , double rotC ) { \nT . set ( x , y , z ) ; \nConvertRotation3D_F64 . eulerToMatrix ( type , rotA , rotB , rotC , R ) ; \nreturn ; \n} \n} \n"}
{"7483": "public class UtilPolygons2D_F64 { \npublic static void convert ( Rectangle2D_F64 input , Polygon2D_F64 output ) { \nif ( output . size ( ) != 4 ) throw new IllegalArgumentException ( \"polygon of order 4 expected\" ) ; \noutput . get ( 0 ) . set ( input . p0 . x , input . p0 . y ) ; \noutput . get ( 1 ) . set ( input . p1 . x , input . p0 . y ) ; \noutput . get ( 2 ) . set ( input . p1 . x , input . p1 . y ) ; \noutput . get ( 3 ) . set ( input . p0 . x , input . p1 . y ) ; \nreturn ; \n} \n} \n"}
{"7484": "public class UtilPolygons2D_F64 { \npublic static void convert ( Polygon2D_F64 input , Quadrilateral_F64 output ) { \nif ( input . size ( ) != 4 ) throw new IllegalArgumentException ( \"Expected 4-sided polygon as input\" ) ; \noutput . a . set ( input . get ( 0 ) ) ; \noutput . b . set ( input . get ( 1 ) ) ; \noutput . c . set ( input . get ( 2 ) ) ; \noutput . d . set ( input . get ( 3 ) ) ; \nreturn ; \n} \n} \n"}
{"7485": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Quadrilateral_F64 quad , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . x = Math . min ( quad . a . x , quad . b . x ) ; \nrectangle . p0 . x = Math . min ( rectangle . p0 . x , quad . c . x ) ; \nrectangle . p0 . x = Math . min ( rectangle . p0 . x , quad . d . x ) ; \nrectangle . p0 . y = Math . min ( quad . a . y , quad . b . y ) ; \nrectangle . p0 . y = Math . min ( rectangle . p0 . y , quad . c . y ) ; \nrectangle . p0 . y = Math . min ( rectangle . p0 . y , quad . d . y ) ; \nrectangle . p1 . x = Math . max ( quad . a . x , quad . b . x ) ; \nrectangle . p1 . x = Math . max ( rectangle . p1 . x , quad . c . x ) ; \nrectangle . p1 . x = Math . max ( rectangle . p1 . x , quad . d . x ) ; \nrectangle . p1 . y = Math . max ( quad . a . y , quad . b . y ) ; \nrectangle . p1 . y = Math . max ( rectangle . p1 . y , quad . c . y ) ; \nrectangle . p1 . y = Math . max ( rectangle . p1 . y , quad . d . y ) ; \nreturn ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( int i = 0 ; \ni < polygon . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( p . x < rectangle . p0 . x ) { \nrectangle . p0 . x = p . x ; \n} \nelse if ( p . x > rectangle . p1 . x ) { \nrectangle . p1 . x = p . x ; \n} \nif ( p . y < rectangle . p0 . y ) { \nrectangle . p0 . y = p . y ; \n} \nelse if ( p . y > rectangle . p1 . y ) { \nrectangle . p1 . y = p . y ; \n} \n} \nreturn ; \n} \n} \n"}
{"7488": "public class UtilPolygons2D_F64 { \npublic static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { \naverage . setIdx ( 0 , 0 ) ; \nfor ( int i = 0 ; \ni < input . size ( ) ; \ni ++ ) { \nPoint2D_F64 v = input . vertexes . data [ i ] ; \naverage . x += v . x ; \naverage . y += v . y ; \n} \naverage . x /= input . size ( ) ; \naverage . y /= input . size ( ) ; \nreturn ; \n} \n} \n"}
{"7489": "public class UtilPolygons2D_F64 { \npublic static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { \nPoint2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \narray [ i ] = points . get ( i ) ; \n} \nAndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; \nandrew . process ( array , array . length , hull ) ; \nreturn ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( int i = 0 ; \ni < polygon . vertexes . size ( ) ; \n) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( angle <= tol ) { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) i = polygon . vertexes . size ( ) - 1 ; \n} \nelse { \ni ++ ; \n} \n} \nreturn ; \n} \n} \n"}
{"7505": "public class ConvertRotation3D_F64 { \npublic static void setRotX ( double ang , DMatrixRMaj R ) { \ndouble c = Math . cos ( ang ) ; \ndouble s = Math . sin ( ang ) ; \nR . set ( 0 , 0 , 1 ) ; \nR . set ( 1 , 1 , c ) ; \nR . set ( 1 , 2 , - s ) ; \nR . set ( 2 , 1 , s ) ; \nR . set ( 2 , 2 , c ) ; \nreturn ; \n} \n} \n"}
{"7508": "public class ConvertRotation3D_F64 { \npublic static void setRotZ ( double ang , DMatrixRMaj r ) { \ndouble c = Math . cos ( ang ) ; \ndouble s = Math . sin ( ang ) ; \nr . set ( 0 , 0 , c ) ; \nr . set ( 0 , 1 , - s ) ; \nr . set ( 1 , 0 , s ) ; \nr . set ( 1 , 1 , c ) ; \nr . set ( 2 , 2 , 1 ) ; \nreturn ; \n} \n} \n"}
{"7511": "public class LineParametric2D_F64 { \npublic void setAngle ( double angle ) { \nslope . set ( Math . cos ( angle ) , Math . sin ( angle ) ) ; \nreturn ; \n} \n} \n"}
{"7513": "public class InterpolateLinearSe3_F64 { \npublic void setTransforms ( Se3_F64 initial , Se3_F64 end ) { \nthis . initial . set ( initial ) ; \ntranslation . x = end . T . x - initial . T . x ; \ntranslation . y = end . T . y - initial . T . y ; \ntranslation . z = end . T . z - initial . T . z ; \nCommonOps_DDRM . multTransA ( initial . getR ( ) , end . getR ( ) , R ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( R , rotation ) ; \nrotMagnitude = rotation . theta ; \nreturn ; \n} \n} \n"}
{"7514": "public class InterpolateLinearSe3_F64 { \npublic void interpolate ( double where , Se3_F64 output ) { \nrotation . setTheta ( where * rotMagnitude ) ; \nConvertRotation3D_F64 . rodriguesToMatrix ( rotation , R ) ; \noutput . T . x = initial . T . x + where * translation . x ; \noutput . T . y = initial . T . y + where * translation . y ; \noutput . T . z = initial . T . z + where * translation . z ; \nCommonOps_DDRM . mult ( initial . R , R , output . R ) ; \nreturn ; \n} \n} \n"}
{"7523": "public class GeometryMath_F64 { \npublic static void divide ( GeoTuple3D_F64 p , double v ) { \np . x /= v ; \np . y /= v ; \np . z /= v ; \nreturn ; \n} \n} \n"}
{"7525": "public class GeometryMath_F64 { \npublic static void toTuple3D ( DMatrixRMaj in , GeoTuple3D_F64 out ) { \nout . x = ( double ) in . get ( 0 ) ; \nout . y = ( double ) in . get ( 1 ) ; \nout . z = ( double ) in . get ( 2 ) ; \nreturn ; \n} \n} \n"}
{"7526": "public class Rodrigues_F64 { \npublic void setParamVector ( double x , double y , double z ) { \ndouble ax = Math . abs ( x ) ; \ndouble ay = Math . abs ( y ) ; \ndouble az = Math . abs ( z ) ; \ndouble max = Math . max ( ax , ay ) ; \nmax = Math . max ( max , az ) ; \nif ( max == 0 ) { \ntheta = 0 ; \nunitAxisRotation . set ( 1 , 0 , 0 ) ; \n} \nelse { \nx /= max ; \ny /= max ; \nz /= max ; \ntheta = Math . sqrt ( x * x + y * y + z * z ) ; \nunitAxisRotation . x = x / theta ; \nunitAxisRotation . y = y / theta ; \nunitAxisRotation . z = z / theta ; \ntheta *= max ; \n} \nreturn ; \n} \n} \n"}
{"7531": "public class InterpolateLinearSe2_F64 { \npublic static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { \ndouble w0 = 1.0 - where ; \noutput . T . x = a . T . x * w0 + b . T . x * where ; \noutput . T . y = a . T . y * w0 + b . T . y * where ; \ndouble yaw0 = a . getYaw ( ) ; \ndouble yaw1 = b . getYaw ( ) ; \ndouble cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; \ndouble ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; \ndouble yaw ; \nif ( cw > ccw ) { \nyaw = yaw0 + ccw * where ; \n} \nelse { \nyaw = yaw0 - cw * where ; \n} \noutput . setYaw ( yaw ) ; \nreturn ; \n} \n} \n"}
{"7532": "public class MotionSe3PointCrossCovariance_F64 { \nprivate void extractQuaternionFromQ ( SimpleMatrix q ) { \nSimpleEVD < SimpleMatrix > evd = q . eig ( ) ; \nint indexMax = evd . getIndexMax ( ) ; \nSimpleMatrix v_max = evd . getEigenVector ( indexMax ) ; \nquat . w = ( double ) v_max . get ( 0 ) ; \nquat . x = ( double ) v_max . get ( 1 ) ; \nquat . y = ( double ) v_max . get ( 2 ) ; \nquat . z = ( double ) v_max . get ( 3 ) ; \nquat . normalize ( ) ; \nConvertRotation3D_F64 . quaternionToMatrix ( quat , motion . getR ( ) ) ; \nreturn ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nhull . get ( i ) . set ( input [ i ] ) ; \n} \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nint minSize = work . size + 2 ; \nfor ( int i = length - 1 ; \ni >= 0 ; \ni -- ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \nfor ( int i = 0 ; \ni < work . size ( ) ; \ni ++ ) { \nhull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7534": "public class SpecialEuclideanOps_F64 { \npublic static void setToNoMotion ( Se3_F64 se ) { \nCommonOps_DDRM . setIdentity ( se . getR ( ) ) ; \nse . getT ( ) . set ( 0 , 0 , 0 ) ; \nreturn ; \n} \n} \n"}
{"7548": "public class SePointOps_F64 { \npublic static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { \ndouble tranX = se . getX ( ) ; \ndouble tranY = se . getY ( ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nPoint2D_F64 pt = points [ i ] ; \ndouble x = pt . x ; \ndouble y = pt . y ; \npt . x = tranX + x * c - y * s ; \npt . y = tranY + x * s + y * c ; \n} \nreturn ; \n} \n} \n"}
{"7563": "public class UtilPlane3D_F64 { \npublic static void point2Dto3D ( Point3D_F64 origin , Vector3D_F64 axisX , Vector3D_F64 axisY , Point2D_F64 A , Point3D_F64 output ) { \noutput . x = origin . x + axisX . x * A . x + axisY . y * A . y ; \noutput . y = origin . y + axisX . y * A . x + axisY . y * A . y ; \noutput . z = origin . z + axisX . z * A . x + axisY . y * A . y ; \nreturn ; \n} \n} \n"}
{"7578": "public class RectangleLength2D_F64 { \npublic void set ( RectangleLength2D_I32 r ) { \nthis . x0 = r . x0 ; \nthis . y0 = r . y0 ; \nthis . width = r . width ; \nthis . height = r . height ; \nreturn ; \n} \n} \n"}
{"7599": "public class InvertibleTransformSequence { \npublic void addTransform ( boolean forward , T tran ) { \npath . add ( new Node < T > ( tran , forward ) ) ; \nreturn ; \n} \n} \n"}
{"7606": "public class UtilVector3D_F64 { \npublic static void normalize ( Vector3D_F64 v ) { \ndouble a = v . norm ( ) ; \nv . x /= a ; \nv . y /= a ; \nv . z /= a ; \nreturn ; \n} \n} \n"}
{"7610": "public class ClosestPointEllipseAngle_F64 { \npublic void setEllipse ( EllipseRotated_F64 ellipse ) { \nthis . ellipse = ellipse ; \nce = Math . cos ( ellipse . phi ) ; \nse = Math . sin ( ellipse . phi ) ; \nreturn ; \n} \n} \n"}
{"7611": "public class Quaternion_F64 { \npublic void normalize ( ) { \ndouble n = Math . sqrt ( w * w + x * x + y * y + z * z ) ; \nw /= n ; \nx /= n ; \ny /= n ; \nz /= n ; \nreturn ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \nreturn ; \n} \n} \n"}
{"7619": "public class GeoTuple4D_F64 { \npublic void timesIP ( double scalar ) { \nx *= scalar ; \ny *= scalar ; \nz *= scalar ; \nw *= scalar ; \nreturn ; \n} \n} \n"}
{"7628": "public class CachingJwtAuthenticator { \npublic void invalidateAll ( Iterable < JwtContext > credentials ) { \ncredentials . forEach ( context -> cache . invalidate ( context . getJwt ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"7629": "public class CachingJwtAuthenticator { \npublic void invalidateAll ( Predicate < ? super JwtContext > predicate ) { \ncache . asMap ( ) . entrySet ( ) . stream ( ) . map ( entry -> entry . getValue ( ) . getKey ( ) ) . filter ( predicate :: test ) . map ( JwtContext :: getJwt ) . forEach ( cache :: invalidate ) ; \nreturn ; \n} \n} \n"}
{"7650": "public class RecursiveSquare { \nprivate static void moveBackToCenter ( double length ) { \nTortoise . setPenUp ( ) ; \nTortoise . turn ( 90 ) ; \nTortoise . move ( length / 2 ) ; \nTortoise . turn ( 90 ) ; \nTortoise . move ( length / 2 ) ; \nTortoise . turn ( 180 ) ; \nTortoise . setPenDown ( ) ; \nreturn ; \n} \n} \n"}
{"7654": "public class TortoiseUtils { \npublic static void verify ( ) { \ntry { \nApprovals . verify ( TURTLE . getImage ( ) ) ; \n} \ncatch ( Exception e ) { \nthrow ObjectUtils . throwAsError ( e ) ; \n} \nfinally { \nTortoiseUtils . resetTurtle ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7657": "public class StdOut { \npublic static void printf ( String format , Object ... args ) { \nout . printf ( LOCALE , format , args ) ; \nout . flush ( ) ; \nreturn ; \n} \n} \n"}
{"7658": "public class StdOut { \npublic static void printf ( Locale locale , String format , Object ... args ) { \nout . printf ( locale , format , args ) ; \nout . flush ( ) ; \nreturn ; \n} \n} \n"}
{"7659": "public class WhichFish { \npublic static void makeAFishyDecision ( int numberOfFish ) { \nswitch ( numberOfFish ) { \ncase - 1 : String image = \"../TeachingKidsProgramming.Source.Java/src/main/resources/icons/thumb-up.png\" ; \nImageIcon icon = new ImageIcon ( image ) ; \nFancyMessageBox . showMesage ( \"Had a Fish\" , \"Not hungry anymore...\" , icon ) ; \nbreak ; \ncase 0 : String image0 = \"../TeachingKidsProgramming.Source.Java/src/main/resources/icons/information.png\" ; \nImageIcon icon0 = new ImageIcon ( image0 ) ; \nFancyMessageBox . showMesage ( \"No Fish\" , \"Still hungry\" , icon0 ) ; \nbreak ; \ncase 1 : String image1 = \"../TeachingKidsProgramming.Source.Java/src/main/resources/icons/star.png\" ; \nImageIcon icon1 = new ImageIcon ( image1 ) ; \nFancyMessageBox . showMesage ( \"One Fish\" , \"This one has a little star\" , icon1 ) ; \nbreak ; \ncase 2 : String image2 = \"../TeachingKidsProgramming.Source.Java/src/main/resources/icons/github.png\" ; \nImageIcon icon2 = new ImageIcon ( image2 ) ; \nFancyMessageBox . showMesage ( \"Two Fish\" , \"Funny things are everywhere\" , icon2 ) ; \nbreak ; \ndefault : String image4 = \"../TeachingKidsProgramming.Source.Java/src/main/resources/icons/hint.png\" ; \nImageIcon icon4 = new ImageIcon ( image4 ) ; \nFancyMessageBox . showMesage ( \"Vegetaraian meal\" , \"Fish are icky\" , icon4 ) ; \nbreak ; \n} \nreturn ; \n} \n} \n"}
{"7660": "public class MySystem { \npublic synchronized static void variable ( String name , Object value ) { \nif ( ! variable ) { \nreturn ; \n} \nSystem . out . println ( timeStamp ( ) + \"*=> \" + name + \" = '\" + ( value == null ? null : value . toString ( ) ) + \"'\" ) ; \nreturn ; \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nint N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . println ( \"seed = \" + StdRandom . getSeed ( ) ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . println ( ) ; \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . println ( ) ; \nreturn ; \n} \n} \n"}
{"7671": "public class TokenBasedAuthResponseFilter { \n@ Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { \nString authToken = extractAuthTokenFromCookieList ( requestContext . getHeaders ( ) . getFirst ( \"Cookie\" ) ) ; \nif ( authToken != null && authToken . length ( ) != 0 ) { \ntry { \nBasicToken token = new BasicToken ( authToken ) ; \nif ( token . isExpired ( ) ) { \nLOGGER . debug ( \"ExpireDate : \" + token . getExpirationDate ( ) . toString ( ) ) ; \nLOGGER . debug ( \"Now: \" + DateTime . now ( ) . toDate ( ) . toString ( ) ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , getTokenSentence ( null ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \nresponseContext . setEntity ( \"Token expired. Please login again.\" ) ; \nLOGGER . info ( \"Token expired. Please login again.\" ) ; \n} \nelse { \ntoken . setExpiration ( token . getMaxAge ( ) ) ; \nif ( ! logoutPath . equals ( requestContext . getUriInfo ( ) . getPath ( ) ) ) { \nString cookie = getTokenSentence ( token ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , cookie ) ; \n} \n} \n} \ncatch ( Exception e ) { \nLOGGER . error ( \"Token re-creation failed\" , e . getMessage ( ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7673": "public class JerseyUtil { \npublic static void registerGuiceBound ( Injector injector , final JerseyEnvironment environment ) { \nwhile ( injector != null ) { \nfor ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { \nType type = key . getTypeLiteral ( ) . getType ( ) ; \nif ( type instanceof Class ) { \nClass < ? > c = ( Class ) type ; \nif ( isProviderClass ( c ) ) { \nlogger . info ( \"Registering {} as a provider class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse if ( isRootResourceClass ( c ) ) { \nif ( Resource . isAcceptable ( c ) ) { \nlogger . info ( \"Registering {} as a root resource class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse { \nlogger . warn ( \"Class {} was not registered as a resource. Bind a concrete implementation instead.\" , c . getName ( ) ) ; \n} \n} \n} \n} \ninjector = injector . getParent ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7674": "public class TokenAuthenticator { \nprivate void getAllRolePermissions ( RoleEntry parent , Set < PermissionEntry > rolePermissions ) { \nrolePermissions . addAll ( permissionStore . findByRoleId ( parent . getId ( ) ) ) ; \nSet < RoleGroupEntry > roleGroupEntries = ( Set < RoleGroupEntry > ) roleGroupStore . findByGroupId ( parent . getId ( ) ) ; \nfor ( RoleGroupEntry entry : roleGroupEntries ) { \nOptional < RoleEntry > role = ( Optional < RoleEntry > ) roleStore . findByRoleId ( entry . getRoleId ( ) ) ; \ngetAllRolePermissions ( role . get ( ) , rolePermissions ) ; \n} \nreturn ; \n} \n} \n"}
{"7678": "public class JobInfoProvider { \nprivate static void setCountIntervalValues ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nSimpleScheduleBuilder builderSc = SimpleScheduleBuilder . simpleSchedule ( ) ; \nif ( dto . getRepeatCount ( ) != 0 ) builderSc . withRepeatCount ( dto . getRepeatCount ( ) ) ; \nif ( dto . getRepeatInterval ( ) > 0 ) builderSc . withIntervalInMilliseconds ( dto . getRepeatInterval ( ) ) ; \nbuilder . withSchedule ( builderSc ) ; \nreturn ; \n} \n} \n"}
{"7679": "public class JobInfoProvider { \nprivate static void setStartEndTime ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nif ( dto . getStartTime ( ) > - 1 ) builder . startAt ( new Date ( dto . getStartTime ( ) ) ) ; \nelse builder . startNow ( ) ; \nif ( dto . getEndTime ( ) > - 1 ) builder . endAt ( new Date ( dto . getEndTime ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"7681": "public class BufferedStreamingOutput { \n@ Override public void write ( OutputStream output ) throws IOException , WebApplicationException { \nwhile ( bufferedInputStream . available ( ) > buffer . length ) { \nbufferedInputStream . read ( buffer ) ; \noutput . write ( buffer ) ; \n} \nbuffer = new byte [ bufferedInputStream . available ( ) ] ; \nbufferedInputStream . read ( buffer ) ; \noutput . write ( buffer ) ; \nbufferedInputStream . close ( ) ; \nreturn ; \n} \n} \n"}
{"7682": "public class QuartzBundle { \nprivate void initializeScheduler ( Properties properties ) throws SchedulerException { \nSchedulerFactory factory = new StdSchedulerFactory ( properties ) ; \nScheduler scheduler = factory . getScheduler ( ) ; \nscheduler . start ( ) ; \nJobManager . initialize ( scheduler ) ; \nreturn ; \n} \n} \n"}
{"7686": "public class BasicToken { \npublic static void configure ( TokenBasedAuthConfiguration configuration ) { \nencryptor . setPoolSize ( configuration . getPoolSize ( ) ) ; \nif ( configuration . getServerPassword ( ) . equals ( \"auto\" ) ) { \nencryptor . setPassword ( UUID . randomUUID ( ) . toString ( ) ) ; \n} \nelse { \nencryptor . setPassword ( configuration . getServerPassword ( ) ) ; \n} \nencryptor . setAlgorithm ( configuration . getAlgorithm ( ) ) ; \nencryptor . initialize ( ) ; \nBasicToken . defaultMaxAge = configuration . getMaxage ( ) ; \ncache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( defaultMaxAge , TimeUnit . SECONDS ) . expireAfterWrite ( defaultMaxAge , TimeUnit . SECONDS ) . build ( ) ; \nreturn ; \n} \n} \n"}
{"7687": "public class BasicToken { \nprivate void generateAttributesHash ( Map < String , String > attributes ) { \nStringBuilder attr = new StringBuilder ( ) ; \nattr . append ( attributes . get ( \"userAgent\" ) ) ; \nattributesHash = Hashing . sha256 ( ) . hashString ( attr . toString ( ) , StandardCharsets . UTF_8 ) . toString ( ) ; \nresetTokenString ( ) ; \nreturn ; \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \nfor ( int i = 0 ; \ni < item . getReceivers ( ) . size ( ) ; \ni ++ ) { \nto [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \n} \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) { \nfor ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) { \nentry . setValue ( value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7691": "public class AbstractAuthResource { \npublic void changePassword ( T user , String currentPassword , String newPassword , String newPassword2 ) throws AuthenticationException { \nverifyPassword ( user , currentPassword ) ; \nif ( ! newPassword . equals ( newPassword2 ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": New password and re-type password must be same\" ) ; \n} \nelse if ( newPassword . equals ( currentPassword ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": New password and old password must be different\" ) ; \n} \nverifyPasswordStrength ( currentPassword , newPassword , user ) ; \nOptional < ? extends UserEntry > optional = userStore . changePassword ( user . getUsername ( ) , newPassword ) ; \nif ( ! optional . isPresent ( ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": Can't update UserEntry Password\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7694": "public class AbstractAuthResource { \npublic void verifyAccountNameStrength ( String accountName ) throws AuthenticationException { \nMatcher matcher = PATTERN . matcher ( accountName ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new AuthenticationException ( accountName + \" is not a valid email\" ) ; \n} \nreturn ; \n} \n} \n"}
{"7695": "public class AbstractAuthResource { \npublic void verifyPasswordStrength ( String oldPassword , String newPassword , T user ) throws AuthenticationException { \nList < Rule > rules = getPasswordRules ( ) ; \nPasswordValidator validator = new PasswordValidator ( rules ) ; \nPasswordData passwordData = new PasswordData ( new Password ( newPassword ) ) ; \nRuleResult result = validator . validate ( passwordData ) ; \nif ( ! result . isValid ( ) ) { \nStringBuilder messages = new StringBuilder ( ) ; \nfor ( String msg : validator . getMessages ( result ) ) { \nmessages . append ( msg ) . append ( \"\\n\" ) ; \n} \nthrow new AuthenticationException ( messages . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7697": "public class Transaction { \nprivate void success ( ) { \norg . hibernate . Transaction txn = session . getTransaction ( ) ; \nif ( txn != null && txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) { \ntxn . commit ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7698": "public class Transaction { \nprivate void error ( ) { \norg . hibernate . Transaction txn = session . getTransaction ( ) ; \nif ( txn != null && txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) { \ntxn . rollback ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7699": "public class Transaction { \nprivate void start ( ) { \ntry { \nbefore ( ) ; \ntransactionWrapper . wrap ( ) ; \nsuccess ( ) ; \n} \ncatch ( Exception e ) { \nerror ( ) ; \nif ( exceptionHandler != null ) { \nexceptionHandler . onException ( e ) ; \n} \nelse { \nthrow e ; \n} \n} \nfinally { \nfinish ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7720": "public class XFiles { \npublic static void mv ( File src , File dst ) throws IOException { \nParameters . checkNotNull ( dst ) ; \nif ( ! src . equals ( dst ) ) { \ncp ( src , dst ) ; \ntry { \nrm ( src ) ; \n} \ncatch ( IOException e ) { \nrm ( dst ) ; \nthrow new IOException ( \"Can't move \" + src , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7721": "public class XFiles { \npublic static void touch ( File ... files ) throws IOException { \nlong now = System . currentTimeMillis ( ) ; \nfor ( File f : files ) { \nif ( ! f . createNewFile ( ) && ! f . setLastModified ( now ) ) { \nthrow new IOException ( \"Failed to touch \" + f ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nint len = BLOCK_LENGTH - bufferLen ; \nif ( len < 9 ) { \nlen += BLOCK_LENGTH ; \n} \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \nfor ( int i = 1 ; \ni < len - 8 ; \ni ++ ) { \nbuf [ i ] = ( byte ) 0x00 ; \n} \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \nreturn ; \n} \n} \n"}
{"7737": "public class Parameters { \npublic static void checkCondition ( boolean condition , String msg , Object ... args ) { \nif ( ! condition ) { \nthrow new IllegalArgumentException ( format ( msg , args ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7756": "public class Application { \nprivate void updateDB ( ) throws SQLException , LiquibaseException { \nSystem . out . println ( \"About to perform DB update.\" ) ; \ntry ( BasicDataSource dataSource = new BasicDataSource ( ) ) { \ndataSource . setUrl ( fullConnectionString ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \ntry ( java . sql . Connection c = dataSource . getConnection ( ) ) { \nDatabase database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; \nLiquibase liquibase = null ; \nClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; \ntry { \nif ( accessor . getResourcesAsStream ( \"changelog-master.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog-master.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse if ( accessor . getResourcesAsStream ( \"changelog.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse { \nString errorMessage = \"No liquibase changelog-master.xml or changelog.xml could be located\" ; \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; \nthrow new RuntimeException ( errorMessage ) ; \n} \n} \ncatch ( final IOException ioe ) { \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; \n} \nliquibase . getLog ( ) . setLogLevel ( logLevel ) ; \nliquibase . update ( new Contexts ( ) ) ; \nSystem . out . println ( \"DB update finished.\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7775": "public class Runtime { \nprivate void subset ( RuntimeSubexpression sub , int begin , int end ) { \nint n = sub . number ; \nassert n > 0 ; \nwhile ( match . size ( ) < ( n + 1 ) ) { \nmatch . add ( null ) ; \n} \nmatch . set ( n , new RegMatch ( begin , end ) ) ; \nreturn ; \n} \n} \n"}
{"7778": "public class Compiler { \nprivate void cloneouts ( Nfa nfa , State old , State from , State to , int type ) { \nArc a ; \nassert old != from ; \nfor ( a = old . outs ; \na != null ; \na = a . outchain ) { \nnfa . newarc ( type , a . co , from , to ) ; \n} \nreturn ; \n} \n} \n"}
{"7779": "public class Compiler { \nprivate void optst ( Subre t ) { \nif ( t == null ) { \nreturn ; \n} \nif ( t . left != null ) { \noptst ( t . left ) ; \n} \nif ( t . right != null ) { \noptst ( t . right ) ; \n} \nreturn ; \n} \n} \n"}
{"7780": "public class Compiler { \nprivate void markst ( Subre t ) { \nassert t != null ; \nt . flags |= Subre . INUSE ; \nif ( t . left != null ) { \nmarkst ( t . left ) ; \n} \nif ( t . right != null ) { \nmarkst ( t . right ) ; \n} \nreturn ; \n} \n} \n"}
{"7783": "public class Compiler { \nprivate void deltraverse ( Nfa nfa , State leftend , State s ) { \nArc a ; \nState to ; \nif ( s . nouts == 0 ) { \nreturn ; \n} \nif ( s . tmp != null ) { \nreturn ; \n} \ns . tmp = s ; \nwhile ( ( a = s . outs ) != null ) { \nto = a . to ; \ndeltraverse ( nfa , leftend , to ) ; \nassert to . nouts == 0 || to . tmp != null ; \nnfa . freearc ( a ) ; \nif ( to . nins == 0 && to . tmp == null ) { \nassert to . nouts == 0 ; \nnfa . freestate ( to ) ; \n} \n} \nassert s . no != State . FREESTATE ; \nassert s == leftend || s . nins != 0 ; \nassert s . nouts == 0 ; \ns . tmp = null ; \nreturn ; \n} \n} \n"}
{"7784": "public class Compiler { \nprivate void nonword ( int dir , State lp , State rp ) { \nint anchor = ( dir == AHEAD ) ? '$' : '^' ; \nassert dir == AHEAD || dir == BEHIND ; \nnfa . newarc ( anchor , ( short ) 1 , lp , rp ) ; \nnfa . newarc ( anchor , ( short ) 0 , lp , rp ) ; \ncm . colorcomplement ( nfa , dir , wordchrs , lp , rp ) ; \nreturn ; \n} \n} \n"}
{"7785": "public class Compiler { \nprivate void word ( int dir , State lp , State rp ) { \nassert dir == AHEAD || dir == BEHIND ; \ncloneouts ( nfa , wordchrs , lp , rp , dir ) ; \nreturn ; \n} \n} \n"}
{"7787": "public class Compiler { \nprivate void bracket ( State lp , State rp ) throws RegexException { \nassert see ( '[' ) ; \nlex . next ( ) ; \nwhile ( ! see ( ']' ) && ! see ( EOS ) ) { \nbrackpart ( lp , rp ) ; \n} \nassert see ( ']' ) ; \ncm . okcolors ( nfa ) ; \nreturn ; \n} \n} \n"}
{"7790": "public class Compiler { \nprivate void onechr ( int c , State lp , State rp ) throws RegexException { \nif ( 0 == ( cflags & Flags . REG_ICASE ) ) { \nnfa . newarc ( PLAIN , cm . subcolor ( c ) , lp , rp ) ; \nreturn ; \n} \ndovec ( Locale . allcases ( c ) , lp , rp ) ; \nreturn ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nint rangeCount = set . getRangeCount ( ) ; \nfor ( int rx = 0 ; \nrx < rangeCount ; \nrx ++ ) { \nint rangeStart = set . getRangeStart ( rx ) ; \nint rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) { \nLOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \n} \nif ( rangeStart == rangeEnd ) { \nnfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \n} \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \n} \nreturn ; \n} \n} \n"}
{"7794": "public class ColorMap { \nvoid subrange ( int from , int to , State lp , State rp ) throws RegexException { \nMap < Range < Integer > , Short > curColors = map . subRangeMap ( Range . closed ( from , to ) ) . asMapOfRanges ( ) ; \nList < Range < Integer > > ranges = Lists . newArrayList ( curColors . keySet ( ) ) ; \nfor ( Range < Integer > rangeToProcess : ranges ) { \nint start = rangeToProcess . lowerEndpoint ( ) ; \nif ( rangeToProcess . lowerBoundType ( ) == BoundType . OPEN ) { \nstart ++ ; \n} \nint end = rangeToProcess . upperEndpoint ( ) ; \nif ( rangeToProcess . upperBoundType ( ) == BoundType . CLOSED ) { \nend ++ ; \n} \nshort color = subcolor ( start , end - start ) ; \ncompiler . getNfa ( ) . newarc ( Compiler . PLAIN , color , lp , rp ) ; \n} \nreturn ; \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7796": "public class ColorMap { \nvoid colorchain ( Arc a ) { \nColorDesc cd = colorDescs . get ( a . co ) ; \na . colorchain = cd . arcs ; \ncd . arcs = a ; \nreturn ; \n} \n} \n"}
{"7797": "public class ColorMap { \nvoid uncolorchain ( Arc a ) { \nColorDesc cd = colorDescs . get ( a . co ) ; \nArc aa ; \naa = cd . arcs ; \nif ( aa == a ) { \ncd . arcs = a . colorchain ; \n} \nelse { \nfor ( ; \naa != null && aa . colorchain != a ; \naa = aa . colorchain ) { \n} \nassert aa != null ; \naa . colorchain = a . colorchain ; \n} \na . colorchain = null ; \nreturn ; \n} \n} \n"}
{"7798": "public class ColorMap { \nvoid dumpcolors ( ) { \nfor ( int co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \nColorDesc cd = colorDescs . get ( co ) ; \nif ( cd != null ) { \ndumpcolor ( co , cd ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7799": "public class Lex { \nvoid lexstart ( ) throws RegexException { \nprefixes ( ) ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nassert 0 == ( v . cflags & ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ) ; \nintocon ( L_Q ) ; \n} \nelse if ( 0 != ( v . cflags & Flags . REG_EXTENDED ) ) { \nassert 0 == ( v . cflags & Flags . REG_QUOTE ) ; \nintocon ( L_ERE ) ; \n} \nelse { \nassert 0 == ( v . cflags & ( Flags . REG_QUOTE | Flags . REG_ADVF ) ) ; \nintocon ( L_BRE ) ; \n} \nv . nexttype = Compiler . EMPTY ; \nnext ( ) ; \nreturn ; \n} \n} \n"}
{"7800": "public class Lex { \nvoid prefixes ( ) throws RegexException { \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nreturn ; \n} \nif ( have ( 4 ) && next3 ( '*' , '*' , '*' ) ) { \nswitch ( charAtNowPlus ( 3 ) ) { \ncase '?' : throw new RegexException ( \"REG_BADPAT\" ) ; \ncase '=' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \nv . now += 4 ; \nreturn ; \ncase ':' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_ADVANCED ; \nv . now += 4 ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADRPT\" ) ; \n} \n} \nif ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) { \nreturn ; \n} \nif ( have ( 3 ) && next2 ( '(' , '?' ) && iscalpha ( charAtNowPlus ( 2 ) ) ) { \nv . note ( Flags . REG_UNONPOSIX ) ; \nv . now += 2 ; \nfor ( ; \n! ateos ( ) && iscalpha ( charAtNow ( ) ) ; \nv . now ++ ) { \nswitch ( charAtNow ( ) ) { \ncase 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'c' : v . cflags &= ~ Flags . REG_ICASE ; \nbreak ; \ncase 'e' : v . cflags |= Flags . REG_EXTENDED ; \nv . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'i' : v . cflags |= Flags . REG_ICASE ; \nbreak ; \ncase 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; \nbreak ; \ncase 'p' : v . cflags |= Flags . REG_NLSTOP ; \nv . cflags &= ~ Flags . REG_NLANCH ; \nbreak ; \ncase 'q' : v . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ Flags . REG_ADVANCED ; \nbreak ; \ncase 's' : v . cflags &= ~ Flags . REG_NEWLINE ; \nbreak ; \ncase 't' : v . cflags &= ~ Flags . REG_EXPANDED ; \nbreak ; \ncase 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; \nv . cflags |= Flags . REG_NLANCH ; \nbreak ; \ncase 'x' : v . cflags |= Flags . REG_EXPANDED ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADOPT\" ) ; \n} \n} \nif ( ! next1 ( ')' ) ) { \nthrow new RegexException ( \"REG_BADOPT\" ) ; \n} \nv . now ++ ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nv . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7801": "public class Lex { \nvoid lexnest ( char [ ] interpolated ) { \nassert v . savepattern == null ; \nv . savepattern = v . pattern ; \nv . savenow = v . now ; \nv . savestop = v . stop ; \nv . savenow = v . now ; \nv . pattern = interpolated ; \nv . now = 0 ; \nv . stop = v . pattern . length ; \nreturn ; \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nint p ; \nint q ; \nlong tmp ; \nif ( last - first <= 1 ) { \nreturn ; \n} \nfor ( p = first ; \np <= last ; \np ++ ) { \nfor ( q = p ; \nq <= last ; \nq ++ ) { \nshort pco = Cnfa . carcColor ( arcs [ p ] ) ; \nshort qco = Cnfa . carcColor ( arcs [ q ] ) ; \nint pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nint qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( pco > qco || ( pco == qco && pto > qto ) ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7810": "public class Nfa { \nvoid moveouts ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nwhile ( ( a = old . outs ) != null ) { \ncparc ( a , newState , a . to ) ; \nfreearc ( a ) ; \n} \nreturn ; \n} \n} \n"}
{"7811": "public class Nfa { \nvoid moveins ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nwhile ( ( a = old . ins ) != null ) { \ncparc ( a , a . from , newState ) ; \nfreearc ( a ) ; \n} \nassert old . nins == 0 ; \nassert old . ins == null ; \nreturn ; \n} \n} \n"}
{"7812": "public class Nfa { \nvoid copyins ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nfor ( a = old . ins ; \na != null ; \na = a . inchain ) { \ncparc ( a , a . from , newState ) ; \n} \nreturn ; \n} \n} \n"}
{"7813": "public class Nfa { \nvoid copyouts ( State old , State newState ) { \nArc a ; \nassert old != newState ; \nfor ( a = old . outs ; \na != null ; \na = a . outchain ) { \ncparc ( a , newState , a . to ) ; \n} \nreturn ; \n} \n} \n"}
{"7814": "public class Nfa { \nvoid dropstate ( State s ) { \nArc a ; \nwhile ( ( a = s . ins ) != null ) { \nfreearc ( a ) ; \n} \nwhile ( ( a = s . outs ) != null ) { \nfreearc ( a ) ; \n} \nfreestate ( s ) ; \nreturn ; \n} \n} \n"}
{"7815": "public class Nfa { \nvoid freestate ( State s ) { \nassert s != null ; \nassert s . nins == 0 ; \nassert s . nouts == 0 ; \nif ( s . next != null ) { \ns . next . prev = s . prev ; \n} \nelse { \nassert s == slast ; \nslast = s . prev ; \n} \nif ( s . prev != null ) { \ns . prev . next = s . next ; \n} \nelse { \nassert s == states ; \nstates = s . next ; \n} \nreturn ; \n} \n} \n"}
{"7816": "public class Nfa { \nvoid cparc ( Arc oa , State from , State to ) { \nnewarc ( oa . type , oa . co , from , to ) ; \nreturn ; \n} \n} \n"}
{"7817": "public class Nfa { \nvoid duptraverse ( State s , State stmp ) { \nArc a ; \nif ( s . tmp != null ) { \nreturn ; \n} \ns . tmp = ( stmp == null ) ? newstate ( ) : stmp ; \nif ( s . tmp == null ) { \nreturn ; \n} \nfor ( a = s . outs ; \na != null ; \na = a . outchain ) { \nduptraverse ( a . to , null ) ; \nassert a . to . tmp != null ; \ncparc ( a , s . tmp , a . to . tmp ) ; \n} \nreturn ; \n} \n} \n"}
{"7818": "public class Nfa { \nvoid specialcolors ( ) { \nif ( parent == null ) { \nbos [ 0 ] = cm . pseudocolor ( ) ; \nbos [ 1 ] = cm . pseudocolor ( ) ; \neos [ 0 ] = cm . pseudocolor ( ) ; \neos [ 1 ] = cm . pseudocolor ( ) ; \n} \nelse { \nassert parent . bos [ 0 ] != Constants . COLORLESS ; \nbos [ 0 ] = parent . bos [ 0 ] ; \nassert parent . bos [ 1 ] != Constants . COLORLESS ; \nbos [ 1 ] = parent . bos [ 1 ] ; \nassert parent . eos [ 0 ] != Constants . COLORLESS ; \neos [ 0 ] = parent . eos [ 0 ] ; \nassert parent . eos [ 1 ] != Constants . COLORLESS ; \neos [ 1 ] = parent . eos [ 1 ] ; \n} \nreturn ; \n} \n} \n"}
{"7819": "public class Nfa { \nvoid dumpnfa ( ) { \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) { \nreturn ; \n} \nLOG . debug ( \"dump nfa\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"pre %d, post %d init %d final %d\" , pre . no , post . no , init . no , finalState . no ) ) ; \nif ( bos [ 0 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", bos [%d]\" , bos [ 0 ] ) ) ; \n} \nif ( bos [ 1 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", bol [%d]\" , bos [ 1 ] ) ) ; \n} \nif ( eos [ 0 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", eos [%d]\" , eos [ 0 ] ) ) ; \n} \nif ( eos [ 1 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", eol [%d]\" , eos [ 1 ] ) ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \nfor ( State s = states ; \ns != null ; \ns = s . next ) { \ndumpstate ( s ) ; \n} \nif ( parent == null ) { \ncm . dumpcolors ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7820": "public class Nfa { \nvoid dumpstate ( State s ) { \nArc a ; \nif ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) { \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"State %d%s%c\" , s . no , ( s . tmp != null ) ? \"T\" : \"\" , ( s . flag != 0 ) ? ( char ) s . flag : '.' ) ) ; \nif ( s . prev != null && s . prev . next != s ) { \nsb . append ( String . format ( \"\\tstate chain bad\" ) ) ; \n} \nif ( s . nouts == 0 ) { \nsb . append ( \"\\tno out arcs\" ) ; \n} \nelse { \ndumparcs ( s , sb ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \nfor ( a = s . ins ; \na != null ; \na = a . inchain ) { \nif ( a . to != s ) { \nLOG . debug ( String . format ( \"\\tlink from %d to %d on %d's in-chain\" , a . from . no , a . to . no , s . no ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7821": "public class Nfa { \nvoid dumparcs ( State s , StringBuilder sb ) { \nint pos ; \nassert s . nouts > 0 ; \npos = dumprarcs ( s . outs , s , 1 , sb ) ; \nif ( pos != 1 ) { \n} \nreturn ; \n} \n} \n"}
{"7823": "public class Nfa { \nvoid dumparc ( Arc a , State s , StringBuilder sb ) { \nsb . append ( \"\\t\" ) ; \nswitch ( a . type ) { \ncase Compiler . PLAIN : sb . append ( String . format ( \"[%d]\" , a . co ) ) ; \nbreak ; \ncase Compiler . AHEAD : sb . append ( String . format ( \">%d>\" , a . co ) ) ; \nbreak ; \ncase Compiler . BEHIND : sb . append ( String . format ( \"<%d<\" , a . co ) ) ; \nbreak ; \ncase Compiler . LACON : sb . append ( String . format ( \":%d:\" , a . co ) ) ; \nbreak ; \ncase '^' : case '$' : sb . append ( String . format ( \"%c%d\" , ( char ) a . type , a . co ) ) ; \nbreak ; \ncase Compiler . EMPTY : break ; \ndefault : sb . append ( String . format ( \"0x%x/0%d\" , a . type , a . co ) ) ; \nbreak ; \n} \nif ( a . from != s ) { \nsb . append ( String . format ( \"?%d?\" , a . from . no ) ) ; \n} \nsb . append ( \"->\" ) ; \nif ( a . to == null ) { \nsb . append ( \"null\" ) ; \nArc aa ; \nfor ( aa = a . to . ins ; \naa != null ; \naa = aa . inchain ) { \nif ( aa == a ) { \nbreak ; \n} \n} \nif ( aa == null ) { \nLOG . debug ( \"?!?\" ) ; \n} \n} \nelse { \nsb . append ( String . format ( \"%d\" , a . to . no ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7827": "public class Nfa { \nvoid cleanup ( ) { \nState s ; \nState nexts ; \nint n ; \nmarkreachable ( pre , null , pre ) ; \nmarkcanreach ( post , pre , post ) ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nif ( s . tmp != post && 0 == s . flag ) { \ndropstate ( s ) ; \n} \n} \nassert post . nins == 0 || post . tmp == post ; \ncleartraverse ( pre ) ; \nassert post . nins == 0 || post . tmp == null ; \nn = 0 ; \nfor ( s = states ; \ns != null ; \ns = s . next ) { \ns . no = n ++ ; \n} \nnstates = n ; \nreturn ; \n} \n} \n"}
{"7828": "public class Nfa { \nvoid markreachable ( State s , State okay , State mark ) { \nArc a ; \nif ( s . tmp != okay ) { \nreturn ; \n} \ns . tmp = mark ; \nfor ( a = s . outs ; \na != null ; \na = a . outchain ) { \nmarkreachable ( a . to , okay , mark ) ; \n} \nreturn ; \n} \n} \n"}
{"7829": "public class Nfa { \nvoid markcanreach ( State s , State okay , State mark ) { \nArc a ; \nif ( s . tmp != okay ) { \nreturn ; \n} \ns . tmp = mark ; \nfor ( a = s . ins ; \na != null ; \na = a . inchain ) { \nmarkcanreach ( a . from , okay , mark ) ; \n} \nreturn ; \n} \n} \n"}
{"7830": "public class Nfa { \nvoid fixempties ( ) { \nState s ; \nState nexts ; \nArc a ; \nArc nexta ; \nboolean progress ; \ndo { \nprogress = false ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nfor ( a = s . outs ; \na != null ; \na = nexta ) { \nnexta = a . outchain ; \nif ( a . type == Compiler . EMPTY && unempty ( a ) ) { \nprogress = true ; \n} \nassert nexta == null || s . no != State . FREESTATE ; \n} \n} \nif ( progress ) { \ndumpnfa ( ) ; \n} \n} \nwhile ( progress ) ; \nreturn ; \n} \n} \n"}
{"7836": "public class Main { \npublic void run ( String [ ] args ) throws CliExecutionException { \nOptions options = gatherOptions ( taskFactory ) ; \nCommandLine commandLine = getCommandLine ( args , options ) ; \ninterpretCommandLine ( commandLine , options , taskFactory ) ; \nreturn ; \n} \n} \n"}
{"7838": "public class Main { \n@ SuppressWarnings ( \"static-access\" ) private void gatherStandardOptions ( final Options options ) { \noptions . addOption ( OptionBuilder . withArgName ( \"p\" ) . withDescription ( \"Path to property file; default is jqassistant.properties in the class path\" ) . withLongOpt ( \"properties\" ) . hasArg ( ) . create ( \"p\" ) ) ; \noptions . addOption ( new Option ( \"help\" , \"print this message\" ) ) ; \nreturn ; \n} \n} \n"}
{"7839": "public class Main { \nprivate void gatherTasksOptions ( TaskFactory taskFactory , Options options ) { \nfor ( Task task : taskFactory . getTasks ( ) ) { \nfor ( Option option : task . getOptions ( ) ) { \noptions . addOption ( option ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7841": "public class Main { \nprivate void interpretCommandLine ( CommandLine commandLine , Options options , TaskFactory taskFactory ) throws CliExecutionException { \nif ( commandLine . hasOption ( OPTION_HELP ) ) { \nprintUsage ( options , null ) ; \nSystem . exit ( 1 ) ; \n} \nList < String > taskNames = commandLine . getArgList ( ) ; \nif ( taskNames . isEmpty ( ) ) { \nprintUsage ( options , \"A task must be specified, i.e. one  of \" + gatherTaskNames ( taskFactory ) ) ; \nSystem . exit ( 1 ) ; \n} \nList < Task > tasks = new ArrayList < > ( ) ; \nfor ( String taskName : taskNames ) { \nTask task = taskFactory . fromName ( taskName ) ; \nif ( task == null ) { \nprintUsage ( options , \"Unknown task \" + taskName ) ; \n} \ntasks . add ( task ) ; \n} \nMap < String , Object > properties = readProperties ( commandLine ) ; \nPluginRepository pluginRepository = getPluginRepository ( ) ; \ntry { \nexecuteTasks ( tasks , options , commandLine , pluginRepository , properties ) ; \n} \ncatch ( PluginRepositoryException e ) { \nthrow new CliExecutionException ( \"Unexpected plugin repository problem while executing tasks.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"7843": "public class Main { \nprivate void executeTask ( Task task , Options option , CommandLine commandLine , PluginRepository pluginRepository , Map < String , Object > properties ) throws CliExecutionException { \ntry { \ntask . withStandardOptions ( commandLine ) ; \ntask . withOptions ( commandLine ) ; \n} \ncatch ( CliConfigurationException e ) { \nprintUsage ( option , e . getMessage ( ) ) ; \nSystem . exit ( 1 ) ; \n} \ntask . initialize ( pluginRepository , properties ) ; \ntask . run ( ) ; \nreturn ; \n} \n} \n"}
{"7845": "public class Main { \nprivate void printUsage ( final Options options , final String errorMessage ) { \nif ( errorMessage != null ) { \nSystem . out . println ( \"Error: \" + errorMessage ) ; \n} \nfinal HelpFormatter formatter = new HelpFormatter ( ) ; \nformatter . printHelp ( Main . class . getCanonicalName ( ) + \" <task> [options]\" , options ) ; \nSystem . out . println ( \"Tasks are: \" + gatherTaskNames ( taskFactory ) ) ; \nSystem . out . println ( \"Example: \" + Main . class . getCanonicalName ( ) + \" scan -f java:classpath::target/classes java:classpath::target/test-classes\" ) ; \nreturn ; \n} \n} \n"}
{"7862": "public class JspServletWrapper { \npublic void setServletClassLastModifiedTime ( long lastModified ) { \nif ( this . servletClassLastModifiedTime < lastModified ) { \nsynchronized ( this ) { \nif ( this . servletClassLastModifiedTime < lastModified ) { \nthis . servletClassLastModifiedTime = lastModified ; \nreload = true ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7867": "public class ProtectedFunctionMapper { \npublic void mapFunction ( String fnQName , final Class < ? > c , final String methodName , final Class < ? > [ ] args ) { \njava . lang . reflect . Method method ; \nif ( SecurityUtil . isPackageProtectionEnabled ( ) ) { \ntry { \nmethod = AccessController . doPrivileged ( new PrivilegedExceptionAction < Method > ( ) { \npublic Method run ( ) throws Exception { \nreturn c . getDeclaredMethod ( methodName , args ) ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException ex ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + ex . getException ( ) . getMessage ( ) ) ; \n} \n} \nelse { \ntry { \nmethod = c . getDeclaredMethod ( methodName , args ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new RuntimeException ( \"Invalid function mapping - no such method: \" + e . getMessage ( ) ) ; \n} \n} \nthis . fnmap . put ( fnQName , method ) ; \nreturn ; \n} \n} \n"}
{"7870": "public class XMLString { \npublic void setValues ( char [ ] ch , int offset , int length ) { \nthis . ch = ch ; \nthis . offset = offset ; \nthis . length = length ; \nreturn ; \n} \n} \n"}
{"7885": "public class RpmBuilder { \nprivate void fillRequirements ( ) throws IOException { \nthis . requirements . add ( new Dependency ( \"rpmlib(CompressedFileNames)\" , \"3.0.4-1\" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; \nif ( ! this . options . getFileDigestAlgorithm ( ) . equals ( DigestAlgorithm . MD5 ) ) { \nthis . requirements . add ( new Dependency ( \"rpmlib(FileDigests)\" , \"4.6.0-1\" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; \n} \nthis . requirements . add ( new Dependency ( \"rpmlib(PayloadFilesHavePrefix)\" , \"4.0-1\" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; \nthis . options . getPayloadCoding ( ) . createProvider ( ) . fillRequirements ( this . requirements :: add ) ; \nreturn ; \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) { \nreturn ; \n} \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nwhile ( list . hasNext ( ) ) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) { \nthis . tlibversion = element . getBody ( ) ; \n} \nelse if ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) { \nthis . jspversion = element . getBody ( ) ; \n} \nelse if ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) { \nerr . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) { \nerr . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \nreturn ; \n} \n} \n"}
{"7890": "public class ChannelController { \nprivate static void validateChannelName ( final String name , final ValidationContext ctx ) { \nif ( name == null || name . isEmpty ( ) ) { \nreturn ; \n} \nfinal Matcher m = ChannelService . NAME_PATTERN . matcher ( name ) ; \nif ( ! m . matches ( ) ) { \nctx . error ( \"names\" , String . format ( \"The channel name '%s' must match the pattern '%s'\" , name , ChannelService . NAME_PATTERN . pattern ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7891": "public class SeekableXZInputStream { \npublic void seekToBlock ( int blockNumber ) throws IOException { \nif ( in == null ) throw new XZIOException ( \"Stream closed\" ) ; \nif ( blockNumber < 0 || blockNumber >= blockCount ) throw new XZIOException ( \"Invalid XZ Block number: \" + blockNumber ) ; \nseekPos = getBlockPos ( blockNumber ) ; \nseekNeeded = true ; \nreturn ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( pos < 0 || pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nIndexDecoder index ; \nfor ( int i = 0 ; \n; \n++ i ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) break ; \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert info . uncompressedSize > 0 ; \nassert pos >= info . uncompressedOffset ; \nassert pos < info . uncompressedOffset + info . uncompressedSize ; \nreturn ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \n-- optPrev ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; \nelse opts [ optCur ] . state . updateLiteral ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nint back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nif ( back < REPS ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \nfor ( rep = 1 ; \nrep <= back ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \nfor ( ; \nrep < REPS ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nint curByte = lz . getByte ( 0 ) ; \nint matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nint literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( literalPrice < opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { \nint shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( shortRepPrice <= opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \nif ( ! nextIsByte && matchByte != curByte && avail > MATCH_LEN_MIN ) { \nint lenLimit = Math . min ( niceLen , avail - 1 ) ; \nint len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( len >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + 1 ) & posMask ; \nint price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nint i = optCur + 1 + len ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nwhile ( matches . len [ matches . count ] < avail ) ++ matches . count ; \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) return ; \nwhile ( optEnd < optCur + matches . len [ matches . count - 1 ] ) opts [ ++ optEnd ] . reset ( ) ; \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nwhile ( startLen > matches . len [ match ] ) ++ match ; \nfor ( int len = startLen ; \n; \n++ len ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) continue ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( ++ match == matches . count ) break ; \n} \nreturn ; \n} \n} \n"}
{"7898": "public class UTF8Reader { \nprivate void expectedByte ( int position , int count ) throws UTFDataFormatException { \nthrow new UTFDataFormatException ( Localizer . getMessage ( \"jsp.error.xml.expectedByte\" , Integer . toString ( position ) , Integer . toString ( count ) ) ) ; \nreturn ; \n} \n} \n"}
{"7899": "public class UTF8Reader { \nprivate void invalidByte ( int position , int count , int c ) throws UTFDataFormatException { \nthrow new UTFDataFormatException ( Localizer . getMessage ( \"jsp.error.xml.invalidByte\" , Integer . toString ( position ) , Integer . toString ( count ) ) ) ; \nreturn ; \n} \n} \n"}
{"7900": "public class TldScanner { \nprivate void scanTlds ( ) throws JasperException { \nmappings = new HashMap < String , String [ ] > ( ) ; \njarTldCacheLocal . putAll ( jarTldCache ) ; \ntry { \nprocessWebDotXml ( ) ; \nscanJars ( ) ; \nprocessTldsInFileSystem ( \"/WEB-INF/\" ) ; \n} \ncatch ( JasperException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( Localizer . getMessage ( \"jsp.error.internal.tldinit\" ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"7902": "public class JspRuntimeContext { \npublic void addWrapper ( String jspUri , JspServletWrapper jsw ) { \njsps . remove ( jspUri ) ; \njsps . put ( jspUri , jsw ) ; \nreturn ; \n} \n} \n"}
{"7904": "public class JspRuntimeContext { \npublic void setBytecode ( String name , byte [ ] bytecode ) { \nif ( bytecode == null ) { \nbytecodes . remove ( name ) ; \nbytecodeBirthTimes . remove ( name ) ; \nreturn ; \n} \nbytecodes . put ( name , bytecode ) ; \nbytecodeBirthTimes . put ( name , Long . valueOf ( System . currentTimeMillis ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"7906": "public class JspRuntimeContext { \npublic void saveBytecode ( String className , String classFileName ) { \nbyte [ ] bytecode = getBytecode ( className ) ; \nif ( bytecode != null ) { \ntry { \nFileOutputStream fos = new FileOutputStream ( classFileName ) ; \nfos . write ( bytecode ) ; \nfos . close ( ) ; \n} \ncatch ( IOException ex ) { \ncontext . log ( \"Error in saving bytecode for \" + className + \" to \" + classFileName , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7907": "public class JspRuntimeContext { \nprivate void checkCompile ( ) { \nfor ( JspServletWrapper jsw : jsps . values ( ) ) { \nif ( jsw . isTagFile ( ) ) { \ncontinue ; \n} \nJspCompilationContext ctxt = jsw . getJspEngineContext ( ) ; \nsynchronized ( jsw ) { \ntry { \nctxt . compile ( ) ; \n} \ncatch ( FileNotFoundException ex ) { \nctxt . incrementRemoved ( ) ; \n} \ncatch ( Throwable t ) { \njsw . getServletContext ( ) . log ( Localizer . getMessage ( \"jsp.error.background.compile\" ) , t ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7908": "public class JspRuntimeContext { \nprivate void initClassPath ( ) { \nStringBuilder cpath = new StringBuilder ( ) ; \nString sep = System . getProperty ( \"path.separator\" ) ; \ncpath . append ( options . getScratchDir ( ) + sep ) ; \nString cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; \nif ( cp == null || cp . equals ( \"\" ) ) { \ncp = options . getClassPath ( ) ; \n} \nif ( cp != null ) { \nclasspath = cpath . toString ( ) + cp ; \n} \nif ( classpath != null ) { \ntry { \nclasspath = URLDecoder . decode ( classpath , \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nif ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , \"Exception decoding classpath : \" + classpath , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7909": "public class JspRuntimeContext { \nprotected void threadStart ( ) { \nif ( thread != null ) { \nreturn ; \n} \nthreadDone = false ; \nthread = new Thread ( this , threadName ) ; \nthread . setDaemon ( true ) ; \nthread . start ( ) ; \nreturn ; \n} \n} \n"}
{"7910": "public class JspRuntimeContext { \nprotected void threadStop ( ) { \nif ( thread == null ) { \nreturn ; \n} \nthreadDone = true ; \nthread . interrupt ( ) ; \ntry { \nthread . join ( ) ; \n} \ncatch ( InterruptedException e ) { \n; \n} \nthread = null ; \nreturn ; \n} \n} \n"}
{"7911": "public class JspRuntimeContext { \npublic void run ( ) { \nwhile ( ! threadDone ) { \nthreadSleep ( ) ; \ntry { \ncheckCompile ( ) ; \n} \ncatch ( Throwable t ) { \nt . printStackTrace ( ) ; \nlog . log ( Level . SEVERE , Localizer . getMessage ( \"jsp.error.recompile\" ) , t ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7914": "public class ChannelServiceImpl { \nprivate void updateDeployGroupCache ( final ChannelServiceAccess model ) { \nthis . deployKeysMap . clear ( ) ; \nfor ( final Map . Entry < String , Set < String > > entry : model . getDeployGroupMap ( ) . entrySet ( ) ) { \nfinal String channelId = entry . getKey ( ) ; \nfinal List < DeployGroup > groups = entry . getValue ( ) . stream ( ) . map ( groupId -> model . getDeployGroup ( groupId ) ) . collect ( Collectors . toList ( ) ) ; \nthis . deployKeysMap . putAll ( channelId , groups ) ; \n} \nreturn ; \n} \n} \n"}
{"7920": "public class Parser { \nprivate void addInclude ( Node parent , List files ) throws JasperException { \nif ( files != null ) { \nIterator iter = files . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString file = ( String ) iter . next ( ) ; \nAttributesImpl attrs = new AttributesImpl ( ) ; \nattrs . addAttribute ( \"\" , \"file\" , \"file\" , \"CDATA\" , file ) ; \nNode includeNode = new Node . IncludeDirective ( attrs , reader . mark ( ) , parent ) ; \nprocessIncludeDirective ( file , includeNode ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7922": "public class TreeNode { \npublic void addAttribute ( String name , String value ) { \nif ( attributes == null ) attributes = new HashMap < String , String > ( ) ; \nattributes . put ( name , value ) ; \nreturn ; \n} \n} \n"}
{"7923": "public class TreeNode { \npublic void addChild ( TreeNode node ) { \nif ( children == null ) children = new ArrayList < TreeNode > ( ) ; \nchildren . add ( node ) ; \nreturn ; \n} \n} \n"}
{"7929": "public class SystemLogHandler { \npublic static void setThread ( ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \ndata . set ( baos ) ; \nstreams . set ( new PrintStream ( baos ) ) ; \nreturn ; \n} \n} \n"}
{"7932": "public class RepoBuilder { \nprotected static void writeOptional ( final StringWriter writer , final String fieldName , final String value ) { \nif ( value != null ) { \nwrite ( writer , fieldName , value ) ; \n} \nreturn ; \n} \n} \n"}
{"7933": "public class RepoBuilder { \nprotected static void write ( final StringWriter writer , final String fieldName , final String value ) { \nwriter . write ( fieldName + \": \" + value + \"\\n\" ) ; \nreturn ; \n} \n} \n"}
{"7936": "public class BodyContentImpl { \npublic void writeOut ( Writer out ) throws IOException { \nif ( writer == null ) { \nout . write ( cb , 0 , nextChar ) ; \n} \nreturn ; \n} \n} \n"}
{"7937": "public class BodyContentImpl { \nvoid setWriter ( Writer writer ) { \nthis . writer = writer ; \nif ( writer != null ) { \nif ( bufferSize != 0 ) { \nbufferSizeSave = bufferSize ; \nbufferSize = 0 ; \n} \n} \nelse { \nbufferSize = bufferSizeSave ; \nclearBody ( ) ; \n} \nreturn ; \n} \n} \n"}
{"7938": "public class BodyContentImpl { \nprivate void reAllocBuff ( int len ) { \nif ( bufferSize + len <= cb . length ) { \nbufferSize = cb . length ; \nreturn ; \n} \nif ( len < cb . length ) { \nlen = cb . length ; \n} \nbufferSize = cb . length + len ; \nchar [ ] tmp = new char [ bufferSize ] ; \nSystem . arraycopy ( cb , 0 , tmp , 0 , cb . length ) ; \ncb = tmp ; \ntmp = null ; \nreturn ; \n} \n} \n"}
{"7939": "public class ELFunctionMapper { \npublic static void map ( Compiler compiler , Node . Nodes page ) throws JasperException { \nELFunctionMapper map = new ELFunctionMapper ( ) ; \nmap . ds = new StringBuilder ( ) ; \nmap . ss = new StringBuilder ( ) ; \npage . visit ( map . new ELFunctionVisitor ( ) ) ; \nString ds = map . ds . toString ( ) ; \nif ( ds . length ( ) > 0 ) { \nNode root = page . getRoot ( ) ; \nnew Node . Declaration ( map . ss . toString ( ) , null , root ) ; \nnew Node . Declaration ( \"static {\\n\" + ds + \"}\\n\" , null , root ) ; \n} \nreturn ; \n} \n} \n"}
{"7941": "public class StorageManager { \npublic StorageRegistration registerModel ( final long lockPriority , final MetaKey key , final StorageModelProvider < ? , ? > storageProvider ) throws ModelInitializationException { \nthis . modelLock . writeLock ( ) . lock ( ) ; \ntry { \ntestClosed ( ) ; \nif ( this . modelKeyMap . containsKey ( key ) ) { \nthrow new IllegalArgumentException ( String . format ( \"A provider for '%s' is already registered\" , key ) ) ; \n} \ntry { \nstorageProvider . start ( this . context ) ; \n} \ncatch ( final Exception e ) { \nthrow new ModelInitializationException ( \"Failed to start model provider: \" + key , e ) ; \n} \nfinal long id = this . counter ++ ; \nfinal Entry entry = new Entry ( id , lockPriority , key , storageProvider ) ; \nthis . modelIdMap . put ( id , entry ) ; \nthis . modelKeyMap . put ( key , entry ) ; \nreturn new StorageRegistration ( ) { \n@ Override public void unregister ( ) { \nunregisterModel ( id ) ; \nreturn ; \n} \n} \n; \n} \nfinally { \nthis . modelLock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"7945": "public class UrlSetWriter { \npublic void finish ( ) throws IOException { \nif ( ! this . finished ) { \nthis . finished = true ; \nwriteEnd ( ) ; \n} \ntry { \nthis . out . close ( ) ; \n} \ncatch ( final XMLStreamException e ) { \nthrow new IOException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"7951": "public class LZMAOutputStream { \npublic void finish ( ) throws IOException { \nif ( ! finished ) { \nif ( exception != null ) throw exception ; \ntry { \nif ( expectedUncompressedSize != - 1 && expectedUncompressedSize != currentUncompressedSize ) throw new XZIOException ( \"Expected uncompressed size (\" + expectedUncompressedSize + \") doesn't equal \" + \"the number of bytes written to the stream (\" + currentUncompressedSize + \")\" ) ; \nlz . setFinishing ( ) ; \nlzma . encodeForLZMA1 ( ) ; \nif ( useEndMarker ) lzma . encodeLZMA1EndMarker ( ) ; \nrc . finish ( ) ; \n} \ncatch ( IOException e ) { \nexception = e ; \nthrow e ; \n} \nfinished = true ; \nlzma . putArraysToCache ( arrayCache ) ; \nlzma = null ; \nlz = null ; \n} \nreturn ; \n} \n} \n"}
{"7958": "public class TagFileProcessor { \npublic void removeProtoTypeFiles ( String classFileName ) { \nIterator < Compiler > iter = tempVector . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCompiler c = iter . next ( ) ; \nif ( classFileName == null ) { \nc . removeGeneratedClassFiles ( ) ; \n} \nelse if ( classFileName . equals ( c . getCompilationContext ( ) . getClassFileName ( ) ) ) { \nc . removeGeneratedClassFiles ( ) ; \ntempVector . remove ( c ) ; \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"7959": "public class JspC { \npublic static void main ( String arg [ ] ) { \nif ( arg . length == 0 ) { \nSystem . out . println ( Localizer . getMessage ( \"jspc.usage\" ) ) ; \n} \nelse { \nJspC jspc = new JspC ( ) ; \ntry { \njspc . setArgs ( arg ) ; \nif ( jspc . helpNeeded ) { \nSystem . out . println ( Localizer . getMessage ( \"jspc.usage\" ) ) ; \n} \nelse { \njspc . execute ( ) ; \n} \n} \ncatch ( JasperException je ) { \nSystem . err . println ( je ) ; \nif ( jspc . getDieLevel ( ) != NO_DIE_LEVEL ) { \nSystem . exit ( jspc . getDieLevel ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7960": "public class JspC { \npublic void setUriroot ( String s ) { \nuriRoot = s ; \nif ( s != null ) { \ntry { \nuriRoot = new File ( s ) . getCanonicalPath ( ) ; \n} \ncatch ( Exception ex ) { \nuriRoot = s ; \n} \n} \nreturn ; \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && i < files . length ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"7962": "public class JspC { \nprivate void locateUriRoot ( File f ) { \nString tUriBase = uriBase ; \nif ( tUriBase == null ) { \ntUriBase = \"/\" ; \n} \ntry { \nif ( f . exists ( ) ) { \nf = new File ( f . getCanonicalPath ( ) ) ; \nwhile ( f != null ) { \nFile g = new File ( f , \"WEB-INF\" ) ; \nif ( g . exists ( ) && g . isDirectory ( ) ) { \nuriRoot = f . getCanonicalPath ( ) ; \nuriBase = tUriBase ; \nif ( log . isLoggable ( Level . INFO ) ) { \nlog . info ( Localizer . getMessage ( \"jspc.implicit.uriRoot\" , uriRoot ) ) ; \n} \nbreak ; \n} \nif ( f . exists ( ) && f . isDirectory ( ) ) { \ntUriBase = \"/\" + f . getName ( ) + \"/\" + tUriBase ; \n} \nString fParent = f . getParent ( ) ; \nif ( fParent == null ) { \nbreak ; \n} \nelse { \nf = new File ( fParent ) ; \n} \n} \nif ( uriRoot != null ) { \nFile froot = new File ( uriRoot ) ; \nuriRoot = froot . getCanonicalPath ( ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \n} \nreturn ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nelse { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \ni < CACHED_SCHEMA_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nelse { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \ni < CACHED_DTD_RESOURCE_PATHS . length ; \ni ++ ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7979": "public class BindingManager { \nprivate static void mergeErrors ( final BindingResult bindingResult , final BindingResult result ) { \nif ( bindingResult == null ) { \nreturn ; \n} \nresult . addErrors ( bindingResult . getLocalErrors ( ) ) ; \nfor ( final Map . Entry < String , BindingResult > child : bindingResult . getChildren ( ) . entrySet ( ) ) { \nmergeErrors ( child . getValue ( ) , result . getChildOrAdd ( child . getKey ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"7980": "public class BindingManager { \nprivate void initializeBinder ( final Binder binder ) { \nfor ( final Method m : binder . getClass ( ) . getMethods ( ) ) { \nif ( ! m . isAnnotationPresent ( Binder . Initializer . class ) ) { \ncontinue ; \n} \nfinal Call call = bind ( m , binder ) ; \ntry { \ncall . invoke ( ) ; \n} \ncatch ( final Exception e ) { \nthrow new RuntimeException ( String . format ( \"Failed to initialze binder: %s # %s\" , binder , m ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7983": "public class TagPluginManager { \nprivate void invokePlugin ( Node . CustomTag n ) { \nTagPlugin tagPlugin = tagPlugins . get ( n . getTagHandlerClass ( ) . getName ( ) ) ; \nif ( tagPlugin == null ) { \nreturn ; \n} \nTagPluginContext tagPluginContext = new TagPluginContextImpl ( n , pageInfo ) ; \nn . setTagPluginContext ( tagPluginContext ) ; \ntagPlugin . doTag ( tagPluginContext ) ; \nreturn ; \n} \n} \n"}
{"7989": "public class Mark { \npublic void pushStream ( char [ ] inStream , int inFileid , String name , String inBaseDir , String inEncoding ) { \nincludeStack . push ( new IncludeState ( cursor , line , col , fileid , fileName , baseDir , encoding , stream ) ) ; \ncursor = 0 ; \nline = 1 ; \ncol = 1 ; \nfileid = inFileid ; \nfileName = name ; \nbaseDir = inBaseDir ; \nencoding = inEncoding ; \nstream = inStream ; \nreturn ; \n} \n} \n"}
{"7991": "public class XMLEncodingDetector { \nprivate void scanXMLDecl ( ) throws IOException , JasperException { \nif ( skipString ( \"<?xml\" ) ) { \nfMarkupDepth ++ ; \nif ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . clear ( ) ; \nfStringBuffer . append ( \"xml\" ) ; \nwhile ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . append ( ( char ) scanChar ( ) ) ; \n} \nString target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; \nscanPIData ( target , fString ) ; \n} \nelse { \nscanXMLDeclOrTextDecl ( false ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"7992": "public class XMLEncodingDetector { \nprivate void reportFatalError ( String msgId , String arg ) throws JasperException { \nerr . jspError ( msgId , arg ) ; \nreturn ; \n} \n} \n"}
{"7997": "public class JspCServletContext { \npublic void log ( String message , Throwable exception ) { \nmyLogWriter . println ( message ) ; \nexception . printStackTrace ( myLogWriter ) ; \nreturn ; \n} \n} \n"}
{"7998": "public class JspCServletContext { \npublic void addFilter ( String filterName , String description , String className , Map < String , String > initParameters ) { \nreturn ; \nreturn ; \n} \n} \n"}
{"8001": "public class LZEncoder { \npublic void setPresetDict ( int dictSize , byte [ ] presetDict ) { \nassert ! isStarted ( ) ; \nassert writePos == 0 ; \nif ( presetDict != null ) { \nint copySize = Math . min ( presetDict . length , dictSize ) ; \nint offset = presetDict . length - copySize ; \nSystem . arraycopy ( presetDict , offset , buf , 0 , copySize ) ; \nwritePos += copySize ; \nskip ( copySize ) ; \n} \nreturn ; \n} \n} \n"}
{"8002": "public class LZEncoder { \nprivate void moveWindow ( ) { \nint moveOffset = ( readPos + 1 - keepSizeBefore ) & ~ 15 ; \nint moveSize = writePos - moveOffset ; \nSystem . arraycopy ( buf , moveOffset , buf , 0 , moveSize ) ; \nreadPos -= moveOffset ; \nreadLimit -= moveOffset ; \nwritePos -= moveOffset ; \nreturn ; \n} \n} \n"}
{"8004": "public class LZEncoder { \nprivate void processPendingBytes ( ) { \nif ( pendingSize > 0 && readPos < readLimit ) { \nreadPos -= pendingSize ; \nint oldPendingSize = pendingSize ; \npendingSize = 0 ; \nskip ( oldPendingSize ) ; \nassert pendingSize < oldPendingSize ; \n} \nreturn ; \n} \n} \n"}
{"8009": "public class JspWriterImpl { \nvoid recycle ( ) { \nflushed = false ; \nclosed = false ; \nout = null ; \nbyteOut = null ; \nreleaseCharBuffer ( ) ; \nresponse = null ; \nreturn ; \n} \n} \n"}
{"8010": "public class JspWriterImpl { \nprotected final void flushBuffer ( ) throws IOException { \nif ( bufferSize == 0 ) return ; \nflushed = true ; \nensureOpen ( ) ; \nif ( buf . pos == buf . offset ) return ; \ninitOut ( ) ; \nout . write ( buf . buf , buf . offset , buf . pos - buf . offset ) ; \nbuf . pos = buf . offset ; \nreturn ; \n} \n} \n"}
{"8011": "public class JspWriterImpl { \npublic final void clear ( ) throws IOException { \nif ( ( bufferSize == 0 ) && ( out != null ) ) throw new IllegalStateException ( getLocalizeMessage ( \"jsp.error.ise_on_clear\" ) ) ; \nif ( flushed ) throw new IOException ( getLocalizeMessage ( \"jsp.error.attempt_to_clear_flushed_buffer\" ) ) ; \nensureOpen ( ) ; \nif ( buf != null ) buf . pos = buf . offset ; \nreturn ; \n} \n} \n"}
{"8012": "public class JspWriterImpl { \npublic void flush ( ) throws IOException { \nflushBuffer ( ) ; \nif ( out != null ) { \nout . flush ( ) ; \n} \nelse { \nresponse . setCharacterEncoding ( response . getCharacterEncoding ( ) ) ; \nresponse . flushBuffer ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8013": "public class JspWriterImpl { \npublic void close ( ) throws IOException { \nif ( response == null || closed ) return ; \nflush ( ) ; \nif ( out != null ) out . close ( ) ; \nout = null ; \nbyteOut = null ; \nclosed = true ; \nreturn ; \n} \n} \n"}
{"8014": "public class JspWriterImpl { \npublic void write ( boolean bytesOK , byte buf [ ] , String str ) throws IOException { \nensureOpen ( ) ; \nif ( bufferSize == 0 && bytesOK ) { \ninitByteOut ( ) ; \nif ( implementsByteWriter ) { \nwrite ( buf , 0 , buf . length ) ; \nreturn ; \n} \n} \nwrite ( str ) ; \nreturn ; \n} \n} \n"}
{"8015": "public class JspWriterImpl { \nprivate void allocateCharBuffer ( ) { \nif ( bufferSize == 0 ) return ; \nif ( bufferSize > MAX_BUFFER_SIZE ) { \nbuf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; \n} \nelse { \nbuf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; \n} \nreturn ; \n} \n} \n"}
{"8016": "public class DefaultErrorHandler { \npublic void javacError ( String errorReport , Exception exception ) throws JasperException { \nthrow new JasperException ( Localizer . getMessage ( \"jsp.error.unable.compile\" ) , exception ) ; \nreturn ; \n} \n} \n"}
{"8018": "public class Compiler { \nprivate void generateClass ( ) throws FileNotFoundException , JasperException , Exception { \nlong t1 = 0 ; \nif ( log . isLoggable ( Level . FINE ) ) { \nt1 = System . currentTimeMillis ( ) ; \n} \nString javaFileName = ctxt . getServletJavaFileName ( ) ; \nsetJavaCompilerOptions ( ) ; \nJavacErrorDetail [ ] javacErrors = javaCompiler . compile ( ctxt . getFullClassName ( ) , pageNodes ) ; \nif ( javacErrors != null ) { \njavaCompiler . doJavaFile ( true ) ; \nlog . severe ( \"Error compiling file: \" + javaFileName ) ; \nerrDispatcher . javacError ( javacErrors ) ; \n} \nif ( log . isLoggable ( Level . FINE ) ) { \nlong t2 = System . currentTimeMillis ( ) ; \nlog . fine ( \"Compiled \" + javaFileName + \" \" + ( t2 - t1 ) + \"ms\" ) ; \n} \njavaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \nif ( ! ctxt . isPrototypeMode ( ) && ! options . isSmapSuppressed ( ) ) { \nsmapUtil . installSmap ( ) ; \n} \nif ( jsw != null && jsw . getServletClassLastModifiedTime ( ) <= 0 ) { \njsw . setServletClassLastModifiedTime ( javaCompiler . getClassLastModified ( ) ) ; \n} \nif ( options . getSaveBytecode ( ) ) { \njavaCompiler . saveClassFile ( ctxt . getFullClassName ( ) , ctxt . getClassFileName ( ) ) ; \n} \nctxt . getRuntimeContext ( ) . adjustBytecodeTime ( ctxt . getFullClassName ( ) , jspModTime ) ; \nreturn ; \n} \n} \n"}
{"8019": "public class Compiler { \npublic void compile ( boolean compileClass ) throws FileNotFoundException , JasperException , Exception { \ntry { \nctxt . makeOutputDir ( ctxt . getOutputDir ( ) ) ; \nif ( errDispatcher == null ) { \nerrDispatcher = new ErrorDispatcher ( jspcMode ) ; \n} \ngenerateJava ( ) ; \nif ( compileClass ) { \ngenerateClass ( ) ; \n} \nelse { \njavaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \n} \n} \nfinally { \nif ( tfp != null ) { \ntfp . removeProtoTypeFiles ( null ) ; \n} \njavaCompiler . release ( ) ; \ntfp = null ; \nerrDispatcher = null ; \nif ( ! jspcMode ) { \npageInfo = null ; \n} \npageNodes = null ; \nif ( ctxt . getWriter ( ) != null ) { \nctxt . getWriter ( ) . close ( ) ; \nctxt . setWriter ( null ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8020": "public class Compiler { \npublic void removeGeneratedFiles ( ) { \ntry { \nString classFileName = ctxt . getClassFileName ( ) ; \nif ( classFileName != null ) { \nFile classFile = new File ( classFileName ) ; \nif ( log . isLoggable ( Level . FINE ) ) log . fine ( \"Deleting \" + classFile ) ; \nclassFile . delete ( ) ; \n} \n} \ncatch ( Exception e ) { \n} \ntry { \nString javaFileName = ctxt . getServletJavaFileName ( ) ; \nif ( javaFileName != null ) { \nFile javaFile = new File ( javaFileName ) ; \nif ( log . isLoggable ( Level . FINE ) ) log . fine ( \"Deleting \" + javaFile ) ; \njavaFile . delete ( ) ; \n} \n} \ncatch ( Exception e ) { \n} \nreturn ; \n} \n} \n"}
{"8021": "public class Compiler { \nprivate void initJavaCompiler ( ) throws JasperException { \nboolean disablejsr199 = Boolean . TRUE . toString ( ) . equals ( System . getProperty ( \"org.apache.jasper.compiler.disablejsr199\" ) ) ; \nDouble version = Double . valueOf ( System . getProperty ( \"java.specification.version\" ) ) ; \nif ( ! disablejsr199 && ( version >= 1.6 || getClassFor ( \"javax.tools.Tool\" ) != null ) ) { \njavaCompiler = new Jsr199JavaCompiler ( ) ; \n} \nelse { \nClass c = getClassFor ( \"org.eclipse.jdt.internal.compiler.Compiler\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.JDTJavaCompiler\" ) ; \nif ( c != null ) { \ntry { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \n} \nif ( javaCompiler == null ) { \nClass c = getClassFor ( \"org.apache.tools.ant.taskdefs.Javac\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.AntJavaCompiler\" ) ; \nif ( c != null ) { \ntry { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \n} \nif ( javaCompiler == null ) { \nerrDispatcher . jspError ( \"jsp.error.nojavac\" ) ; \n} \njavaCompiler . init ( ctxt , errDispatcher , jspcMode ) ; \nreturn ; \n} \n} \n"}
{"8024": "public class Generator { \nprivate void generateDeclarations ( Node . Nodes page ) throws JasperException { \nclass DeclarationVisitor extends Node . Visitor { \nprivate boolean getServletInfoGenerated = false ; \npublic void visit ( Node . PageDirective n ) throws JasperException { \nif ( getServletInfoGenerated ) { \nreturn ; \n} \nString info = n . getAttributeValue ( \"info\" ) ; \nif ( info == null ) return ; \ngetServletInfoGenerated = true ; \nout . printil ( \"public String getServletInfo() {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return \" ) ; \nout . print ( quote ( info ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nreturn ; \n} \npublic void visit ( Node . Declaration n ) throws JasperException { \nn . setBeginJavaLine ( out . getJavaLine ( ) ) ; \nout . printMultiLn ( n . getText ( ) ) ; \nout . println ( ) ; \nn . setEndJavaLine ( out . getJavaLine ( ) ) ; \nreturn ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( n . useTagPlugin ( ) ) { \nif ( n . getAtSTag ( ) != null ) { \nn . getAtSTag ( ) . visit ( this ) ; \n} \nvisitBody ( n ) ; \nif ( n . getAtETag ( ) != null ) { \nn . getAtETag ( ) . visit ( this ) ; \n} \n} \nelse { \nvisitBody ( n ) ; \n} \nreturn ; \n} \n} \nout . println ( ) ; \npage . visit ( new DeclarationVisitor ( ) ) ; \nreturn ; \n} \n} \n"}
{"8025": "public class Generator { \nprivate void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { \nclass TagHandlerPoolVisitor extends Node . Visitor { \nprivate Set < String > names = new HashSet < String > ( ) ; \nTagHandlerPoolVisitor ( Set < String > v ) { \nnames = v ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! n . implementsSimpleTag ( ) ) { \nString name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; \nn . setTagHandlerPoolName ( name ) ; \nif ( ! names . contains ( name ) ) { \nnames . add ( name ) ; \n} \n} \nvisitBody ( n ) ; \nreturn ; \n} \nprivate String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { \nString poolName = null ; \npoolName = \"_jspx_tagPool_\" + prefix + \"_\" + shortName ; \nif ( attrs != null ) { \nString [ ] attrNames = new String [ attrs . getLength ( ) ] ; \nfor ( int i = 0 ; \ni < attrNames . length ; \ni ++ ) { \nattrNames [ i ] = attrs . getQName ( i ) ; \n} \nArrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; \nfor ( int i = 0 ; \ni < attrNames . length ; \ni ++ ) { \npoolName = poolName + \"_\" + attrNames [ i ] ; \n} \n} \nif ( hasEmptyBody ) { \npoolName = poolName + \"_nobody\" ; \n} \nreturn JspUtil . makeXmlJavaIdentifier ( poolName ) ; \n} \n} \npage . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; \nreturn ; \n} \n} \n"}
{"8026": "public class Generator { \nprivate void generateXmlProlog ( Node . Nodes page ) { \nString omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; \nif ( ( omitXmlDecl != null && ! JspUtil . booleanValue ( omitXmlDecl ) ) || ( omitXmlDecl == null && page . getRoot ( ) . isXmlSyntax ( ) && ! pageInfo . hasJspRoot ( ) && ! ctxt . isTagFile ( ) ) ) { \nString cType = pageInfo . getContentType ( ) ; \nString charSet = cType . substring ( cType . indexOf ( \"charset=\" ) + 8 ) ; \nout . printil ( \"out.write(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"\" + charSet + \"\\\\\\\"?>\\\\n\\\");\" ) ; \n} \nString doctypeName = pageInfo . getDoctypeName ( ) ; \nif ( doctypeName != null ) { \nString doctypePublic = pageInfo . getDoctypePublic ( ) ; \nString doctypeSystem = pageInfo . getDoctypeSystem ( ) ; \nout . printin ( \"out.write(\\\"<!DOCTYPE \" ) ; \nout . print ( doctypeName ) ; \nif ( doctypePublic == null ) { \nout . print ( \" SYSTEM \\\\\\\"\" ) ; \n} \nelse { \nout . print ( \" PUBLIC \\\\\\\"\" ) ; \nout . print ( doctypePublic ) ; \nout . print ( \"\\\\\\\" \\\\\\\"\" ) ; \n} \nout . print ( doctypeSystem ) ; \nout . println ( \"\\\\\\\">\\\\n\\\");\" ) ; \n} \nreturn ; \n} \n} \n"}
{"8027": "public class Generator { \nprivate void genCommonPostamble ( ) { \nfor ( int i = 0 ; \ni < methodsBuffered . size ( ) ; \ni ++ ) { \nGenBuffer methodBuffer = methodsBuffered . get ( i ) ; \nmethodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( methodBuffer . toString ( ) ) ; \n} \nif ( fragmentHelperClass . isUsed ( ) ) { \nfragmentHelperClass . generatePostamble ( ) ; \nfragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( fragmentHelperClass . toString ( ) ) ; \n} \nif ( arrayBuffer != null ) { \nout . printMultiLn ( arrayBuffer . toString ( ) ) ; \n} \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nreturn ; \n} \n} \n"}
{"8028": "public class Generator { \nprivate void generatePostamble ( Node . Nodes page ) { \nout . popIndent ( ) ; \nout . printil ( \"} catch (Throwable t) {\" ) ; \nout . pushIndent ( ) ; \nout . printil ( \"if (!(t instanceof SkipPageException)){\" ) ; \nout . pushIndent ( ) ; \nout . printil ( \"out = _jspx_out;\" ) ; \nout . printil ( \"if (out != null && out.getBufferSize() != 0)\" ) ; \nout . pushIndent ( ) ; \nout . printil ( \"out.clearBuffer();\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);\" ) ; \nout . printil ( \"else throw new ServletException(t);\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"} finally {\" ) ; \nout . pushIndent ( ) ; \nout . printil ( \"_jspxFactory.releasePageContext(_jspx_page_context);\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \ngenCommonPostamble ( ) ; \nreturn ; \n} \n} \n"}
{"8029": "public class Generator { \npublic static void generate ( ServletWriter out , Compiler compiler , Node . Nodes page ) throws JasperException { \nGenerator gen = new Generator ( out , compiler ) ; \nif ( gen . isPoolingEnabled ) { \ngen . compileTagHandlerPoolList ( page ) ; \n} \nif ( gen . ctxt . isTagFile ( ) ) { \nJasperTagInfo tagInfo = ( JasperTagInfo ) gen . ctxt . getTagInfo ( ) ; \ngen . generateTagHandlerPreamble ( tagInfo , page ) ; \nif ( gen . ctxt . isPrototypeMode ( ) ) { \nreturn ; \n} \ngen . generateXmlProlog ( page ) ; \ngen . fragmentHelperClass . generatePreamble ( ) ; \npage . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; \ngen . generateTagHandlerPostamble ( tagInfo ) ; \n} \nelse { \ngen . generatePreamble ( page ) ; \ngen . generateXmlProlog ( page ) ; \ngen . fragmentHelperClass . generatePreamble ( ) ; \npage . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; \ngen . generatePostamble ( page ) ; \n} \nreturn ; \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \n} \nout . println ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8031": "public class TransferServiceImpl { \nprivate Map < MetaKey , String > readProperties ( final InputStream stream ) throws IOException { \ntry { \nfinal Document doc = this . xmlToolsFactory . newDocumentBuilder ( ) . parse ( new FilterInputStream ( stream ) { \n@ Override public void close ( ) { \nreturn ; \n} \n} \n) ; \nfinal Element root = doc . getDocumentElement ( ) ; \nif ( ! \"properties\" . equals ( root . getNodeName ( ) ) ) { \nthrow new IllegalStateException ( String . format ( \"Root element must be of type '%s'\" , \"properties\" ) ) ; \n} \nfinal Map < MetaKey , String > result = new HashMap < > ( ) ; \nfor ( final Element ele : XmlHelper . iterElement ( root , \"property\" ) ) { \nfinal String namespace = ele . getAttribute ( \"namespace\" ) ; \nfinal String key = ele . getAttribute ( \"key\" ) ; \nfinal String value = ele . getTextContent ( ) ; \nif ( namespace . isEmpty ( ) || key . isEmpty ( ) ) { \ncontinue ; \n} \nresult . put ( new MetaKey ( namespace , key ) , value ) ; \n} \nreturn result ; \n} \ncatch ( final Exception e ) { \nthrow new IOException ( \"Failed to read properties\" , e ) ; \n} \n} \n} \n"}
{"8032": "public class TransferServiceImpl { \nprivate void exportChannel ( final By by , final OutputStream stream ) throws IOException { \nfinal ZipOutputStream zos = new ZipOutputStream ( stream ) ; \ninitExportFile ( zos ) ; \nthis . channelService . accessRun ( by , ReadableChannel . class , channel -> { \nputDataEntry ( zos , \"names\" , makeNames ( channel . getId ( ) ) ) ; \nputDataEntry ( zos , \"description\" , channel . getId ( ) . getDescription ( ) ) ; \nputDirEntry ( zos , \"artifacts\" ) ; \nputProperties ( zos , \"properties.xml\" , channel . getContext ( ) . getProvidedMetaData ( ) ) ; \nputAspects ( zos , channel . getContext ( ) . getAspectStates ( ) . keySet ( ) ) ; \nputArtifacts ( zos , \"artifacts/\" , channel , channel . getArtifacts ( ) , true ) ; \n} \n) ; \nthis . channelService . accessRun ( by , TriggeredChannel . class , channel -> { \nputTriggers ( zos , channel ) ; \n} \n) ; \nzos . finish ( ) ; \nreturn ; \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( int i = 0 ; \ni < errors . length ; \ni ++ ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) for ( int i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) writer . print ( chars [ i ++ ] ) ; \n} \nreturn ; \n} \n} \n"}
{"8039": "public class ServletWriter { \npublic void printin ( String s ) { \nwriter . print ( SPACES . substring ( 0 , indent ) ) ; \nwriter . print ( s ) ; \nreturn ; \n} \n} \n"}
{"8040": "public class ServletWriter { \npublic void printil ( String s ) { \njavaLine ++ ; \nwriter . print ( SPACES . substring ( 0 , indent ) ) ; \nwriter . println ( s ) ; \nreturn ; \n} \n} \n"}
{"8041": "public class ServletWriter { \npublic void printMultiLn ( String s ) { \nint index = 0 ; \nwhile ( ( index = s . indexOf ( '\\n' , index ) ) > - 1 ) { \njavaLine ++ ; \nindex ++ ; \n} \nwriter . print ( s ) ; \nreturn ; \n} \n} \n"}
{"8043": "public class JspUtil { \npublic static void checkScope ( String scope , Node n , ErrorDispatcher err ) throws JasperException { \nif ( scope != null && ! scope . equals ( \"page\" ) && ! scope . equals ( \"request\" ) && ! scope . equals ( \"session\" ) && ! scope . equals ( \"application\" ) ) { \nerr . jspError ( n , \"jsp.error.invalid.scope\" , scope ) ; \n} \nreturn ; \n} \n} \n"}
{"8045": "public class JspUtil { \npublic static void validateExpressions ( Mark where , String expressions , FunctionMapper functionMapper , ErrorDispatcher err ) throws JasperException { \ntry { \nELContextImpl elContext = new ELContextImpl ( null ) ; \nelContext . setFunctionMapper ( functionMapper ) ; \ngetExpressionFactory ( ) . createValueExpression ( elContext , expressions , Object . class ) ; \n} \ncatch ( ELException e ) { \nerr . jspError ( where , \"jsp.error.invalid.expression\" , expressions , e . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8052": "public class InstallableUnit { \nprivate static void addProperty ( final Map < String , String > props , final String key , final String value ) { \nif ( value == null ) { \nreturn ; \n} \nprops . put ( key , value ) ; \nreturn ; \n} \n} \n"}
{"8055": "public class DatabaseUserService { \n@ Override public void run ( ) throws Exception { \nthis . storageManager . modifyRun ( MODEL_KEY , UserWriteModel . class , users -> { \nfinal Date timeout = new Date ( System . currentTimeMillis ( ) - getTimeout ( ) ) ; \nfinal Collection < UserEntity > updates = new LinkedList < > ( ) ; \nfinal Collection < String > removals = new LinkedList < > ( ) ; \nfor ( final UserEntity user : users . asCollection ( ) ) { \nif ( user . getEmailTokenDate ( ) == null || user . getEmailTokenDate ( ) . after ( timeout ) ) { \ncontinue ; \n} \nif ( user . isEmailVerified ( ) ) { \nuser . setEmailToken ( null ) ; \nuser . setEmailTokenDate ( null ) ; \nuser . setEmailTokenSalt ( null ) ; \nupdates . add ( user ) ; \n} \nelse { \nremovals . add ( user . getId ( ) ) ; \n} \n} \nupdates . forEach ( users :: putUser ) ; \nremovals . forEach ( users :: removeUser ) ; \n} \n) ; \nreturn ; \n} \n} \n"}
{"8061": "public class StringMetadataSerDes { \nprivate static void writeToOutputStream ( Object obj , CodedOutputStream out ) throws IOException { \nout . writeRawByte ( STRING ) ; \nout . writeStringNoTag ( ( String ) obj ) ; \nreturn ; \n} \n} \n"}
{"8063": "public class DLocatorIO { \nprivate void createPreparedStatements ( ) { \nSelect . Where select = QueryBuilder . select ( ) . all ( ) . from ( CassandraModel . CF_METRICS_LOCATOR_NAME ) . where ( eq ( KEY , bindMarker ( ) ) ) ; \ngetValue = DatastaxIO . getSession ( ) . prepare ( select ) ; \nInsert insert = QueryBuilder . insertInto ( CassandraModel . CF_METRICS_LOCATOR_NAME ) . using ( ttl ( TenantTtlProvider . LOCATOR_TTL ) ) . value ( KEY , bindMarker ( ) ) . value ( COLUMN1 , bindMarker ( ) ) . value ( VALUE , bindMarker ( ) ) ; \nputValue = DatastaxIO . getSession ( ) . prepare ( insert ) . setConsistencyLevel ( ConsistencyLevel . LOCAL_ONE ) ; \nreturn ; \n} \n} \n"}
{"8064": "public class Tracker { \npublic void trackDelayedMetricsTenant ( String tenantid , final List < Metric > delayedMetrics ) { \nif ( isTrackingDelayedMetrics ) { \nString logMessage = String . format ( \"[TRACKER][DELAYED METRIC] Tenant sending delayed metrics %s\" , tenantid ) ; \nlog . info ( logMessage ) ; \ndouble delayedMinutes ; \nlong nowMillis = System . currentTimeMillis ( ) ; \nfor ( Metric metric : delayedMetrics ) { \ndelayedMinutes = ( double ) ( nowMillis - metric . getCollectionTime ( ) ) / 1000 / 60 ; \nlogMessage = String . format ( \"[TRACKER][DELAYED METRIC] %s has collectionTime %s which is delayed by %.2f minutes\" , metric . getLocator ( ) . toString ( ) , dateFormatter . format ( new Date ( metric . getCollectionTime ( ) ) ) , delayedMinutes ) ; \nlog . info ( logMessage ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8065": "public class Tracker { \npublic void trackDelayedAggregatedMetricsTenant ( String tenantId , long collectionTimeMs , long delayTimeMs , List < String > delayedMetricNames ) { \nif ( isTrackingDelayedMetrics ) { \nString logMessage = String . format ( \"[TRACKER][DELAYED METRIC] Tenant sending delayed metrics %s\" , tenantId ) ; \nlog . info ( logMessage ) ; \ndouble delayMin = delayTimeMs / 1000 / 60 ; \nlogMessage = String . format ( \"[TRACKER][DELAYED METRIC] %s have collectionTime %s which is delayed by %.2f minutes\" , StringUtils . join ( delayedMetricNames , \",\" ) , dateFormatter . format ( new Date ( collectionTimeMs ) ) , delayMin ) ; \nlog . info ( logMessage ) ; \n} \nreturn ; \n} \n} \n"}
{"8067": "public class AbstractSerDes { \nprotected void putUnversionedDoubleOrLong ( Number number , CodedOutputStream out ) throws IOException { \nif ( number instanceof Double ) { \nout . writeRawByte ( Constants . B_DOUBLE ) ; \nout . writeDoubleNoTag ( number . doubleValue ( ) ) ; \n} \nelse { \nout . writeRawByte ( Constants . B_I64 ) ; \nout . writeRawVarint64 ( number . longValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8069": "public class CloudFilesPublisher { \nprivate void createContainer ( ) { \nString containerName = CONTAINER_DATE_FORMAT . format ( new Date ( ) ) ; \nblobStore . createContainerInLocation ( null , containerName ) ; \nlastContainerCreated = containerName ; \nreturn ; \n} \n} \n"}
{"8070": "public class ScheduleContext { \nvoid scheduleEligibleSlots ( long maxAgeMillis , long rollupDelayForMetricsWithShortDelay , long rollupWaitForMetricsWithLongDelay ) { \nlong now = scheduleTime ; \nArrayList < Integer > shardKeys = new ArrayList < Integer > ( shardStateManager . getManagedShards ( ) ) ; \nCollections . shuffle ( shardKeys ) ; \nfor ( int shard : shardKeys ) { \nfor ( Granularity g : Granularity . rollupGranularities ( ) ) { \nsynchronized ( scheduledSlots ) { \nsynchronized ( runningSlots ) { \nList < Integer > slotsToWorkOn = shardStateManager . getSlotStateManager ( shard , g ) . getSlotsEligibleForRollup ( now , maxAgeMillis , rollupDelayForMetricsWithShortDelay , rollupWaitForMetricsWithLongDelay ) ; \nif ( slotsToWorkOn . size ( ) == 0 ) { \ncontinue ; \n} \nif ( ! canWorkOnShard ( shard ) ) { \ncontinue ; \n} \nfor ( Integer slot : slotsToWorkOn ) { \nSlotKey slotKey = SlotKey . of ( g , slot , shard ) ; \nif ( areChildKeysOrSelfKeyScheduledOrRunning ( slotKey ) ) { \ncontinue ; \n} \nSlotKey key = SlotKey . of ( g , slot , shard ) ; \nscheduledSlots . add ( key ) ; \norderedScheduledSlots . add ( key ) ; \nrecentlyScheduledShards . put ( shard , scheduleTime ) ; \n} \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8071": "public class ScheduleContext { \nvoid clearFromRunning ( SlotKey slotKey ) { \nsynchronized ( runningSlots ) { \nrunningSlots . remove ( slotKey ) ; \nUpdateStamp stamp = shardStateManager . getUpdateStamp ( slotKey ) ; \nshardStateManager . setAllCoarserSlotsDirtyForSlot ( slotKey ) ; \nlong currentTimeInMillis = clock . now ( ) . getMillis ( ) ; \nstamp . setLastRollupTimestamp ( currentTimeInMillis ) ; \nlog . debug ( \"SlotKey {} is marked in memory with last rollup time as {}\" , slotKey , currentTimeInMillis ) ; \nif ( stamp . getState ( ) == UpdateStamp . State . Running ) { \nstamp . setState ( UpdateStamp . State . Rolled ) ; \nstamp . setDirty ( true ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8073": "public class Emitter { \npublic Emitter once ( final String event , final Listener < T > fn ) { \nListener on = new Listener < T > ( ) { \n@ Override public void call ( T ... args ) { \nEmitter . this . off ( event , this ) ; \nfn . call ( args ) ; \nreturn ; \n} \n} \n; \nthis . onceCallbacks . put ( fn , on ) ; \nthis . on ( event , on ) ; \nreturn this ; \n} \n} \n"}
{"8078": "public class RollupFile { \npublic void append ( RollupEvent rollup ) throws IOException { \nensureOpen ( ) ; \noutputStream . write ( serializer . toBytes ( rollup ) ) ; \noutputStream . write ( '\\n' ) ; \noutputStream . flush ( ) ; \nreturn ; \n} \n} \n"}
{"8080": "public class HttpMetricsIngestionServer { \npublic void startServer ( ) throws InterruptedException { \nRouteMatcher router = new RouteMatcher ( ) ; \nrouter . get ( \"/v1.0\" , new DefaultHandler ( ) ) ; \nrouter . post ( \"/v1.0/multitenant/experimental/metrics\" , new HttpMultitenantMetricsIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . post ( \"/v1.0/:tenantId/experimental/metrics\" , new HttpMetricsIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . post ( \"/v1.0/:tenantId/experimental/metrics/statsd\" , new HttpAggregatedIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . get ( \"/v2.0\" , new DefaultHandler ( ) ) ; \nrouter . post ( \"/v2.0/:tenantId/ingest/multi\" , new HttpMultitenantMetricsIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . post ( \"/v2.0/:tenantId/ingest\" , new HttpMetricsIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . post ( \"/v2.0/:tenantId/ingest/aggregated\" , new HttpAggregatedIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . post ( \"/v2.0/:tenantId/ingest/aggregated/multi\" , new HttpAggregatedMultiIngestionHandler ( processor , timeout , ENABLE_PER_TENANT_METRICS ) ) ; \nrouter . post ( \"/v2.0/:tenantId/events\" , getHttpEventsIngestionHandler ( ) ) ; \nfinal RouteMatcher finalRouter = router ; \nlog . info ( \"Starting metrics listener HTTP server on port {}\" , httpIngestPort ) ; \nServerBootstrap server = new ServerBootstrap ( ) ; \nserver . group ( acceptorGroup , workerGroup ) . channel ( NioServerSocketChannel . class ) . childHandler ( new ChannelInitializer < SocketChannel > ( ) { \n@ Override public void initChannel ( SocketChannel channel ) throws Exception { \nsetupPipeline ( channel , finalRouter ) ; \nreturn ; \n} \n} \n) ; \nChannel channel = server . bind ( new InetSocketAddress ( httpIngestHost , httpIngestPort ) ) . sync ( ) . channel ( ) ; \nallOpenChannels . add ( channel ) ; \nlog . info ( \"Registering tracker service\" ) ; \nTracker . getInstance ( ) . register ( ) ; \nlog . info ( \"Token search improvements enabled: \" + EXP_TOKEN_SEARCH_IMPROVEMENTS ) ; \nreturn ; \n} \n} \n"}
{"8087": "public class ZKShardLockManager { \nprivate void registerMetrics ( final ObjectName nameObj , MetricRegistry reg ) { \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Lock Disinterested Time Millis\" ) , new JmxAttributeGauge ( nameObj , \"LockDisinterestedTimeMillis\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Min Lock Hold Time Millis\" ) , new JmxAttributeGauge ( nameObj , \"MinLockHoldTimeMillis\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Seconds Since Last Scavenge\" ) , new JmxAttributeGauge ( nameObj , \"SecondsSinceLastScavenge\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Zk Connection Status\" ) , new JmxAttributeGauge ( nameObj , \"ZkConnectionStatus\" ) { \n@ Override public Object getValue ( ) { \nObject val = super . getValue ( ) ; \nif ( val . equals ( \"connected\" ) ) { \nreturn 1 ; \n} \nreturn 0 ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Held Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getHeldShards ( ) . size ( ) ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Unheld Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getUnheldShards ( ) . size ( ) ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Error Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getErrorShards ( ) . size ( ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"8089": "public class MetricIndexData { \npublic void add ( String metricIndex , long docCount ) { \nfinal String [ ] tokens = metricIndex . split ( METRIC_TOKEN_SEPARATOR_REGEX ) ; \nswitch ( tokens . length - baseLevel ) { \ncase 1 : if ( baseLevel > 0 ) { \nmetricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) ) ; \n} \nelse { \nmetricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . indexOf ( \".\" ) ) ) ; \n} \naddChildrenDocCount ( metricNameBaseLevelMap , metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) , docCount ) ; \nbreak ; \ncase 0 : setActualDocCount ( metricNameBaseLevelMap , metricIndex , docCount ) ; \nbreak ; \ndefault : break ; \n} \nreturn ; \n} \n} \n"}
{"8095": "public class RollupService { \npublic synchronized void setServerTime ( long millis ) { \nlog . info ( \"Manually setting server time to {}  {}\" , millis , new java . util . Date ( millis ) ) ; \ncontext . setCurrentTimeMillis ( millis ) ; \nreturn ; \n} \n} \n"}
{"8098": "public class CassandraModel { \npublic static Iterable < MetricColumnFamily > getMetricColumnFamilies ( ) { \nreturn new Iterable < MetricColumnFamily > ( ) { \n@ Override public Iterator < MetricColumnFamily > iterator ( ) { \nreturn new Iterator < MetricColumnFamily > ( ) { \nprivate int pos = 0 ; \n@ Override public boolean hasNext ( ) { \nreturn pos < METRIC_COLUMN_FAMILES . length ; \n} \n@ Override public MetricColumnFamily next ( ) { \nreturn METRIC_COLUMN_FAMILES [ pos ++ ] ; \n} \n@ Override public void remove ( ) { \nthrow new NoSuchMethodError ( \"Not implemented\" ) ; \nreturn ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"8099": "public class APreaggregatedMetricsRW { \n@ Override public void insertMetrics ( Collection < IMetric > metrics ) throws IOException { \ninsertMetrics ( metrics , Granularity . FULL ) ; \nreturn ; \n} \n} \n"}
{"8100": "public class APreaggregatedMetricsRW { \n@ Override public void insertMetrics ( Collection < IMetric > metrics , Granularity granularity ) throws IOException { \ntry { \nAstyanaxWriter . getInstance ( ) . insertMetrics ( metrics , CassandraModel . getPreaggregatedColumnFamily ( granularity ) , isRecordingDelayedMetrics , clock ) ; \n} \ncatch ( ConnectionException ex ) { \nthrow new IOException ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8104": "public class StorageManager { \npublic synchronized void start ( ) { \nif ( uploaderThread != null ) { \nthrow new RuntimeException ( \"StorageManager is already started\" ) ; \n} \nfileUploader = new DoneFileUploader ( ) ; \nuploaderThread = new Thread ( fileUploader , \"StorageManager uploader\" ) ; \nuploaderThread . start ( ) ; \nreturn ; \n} \n} \n"}
{"8105": "public class StorageManager { \npublic synchronized void stop ( ) throws IOException { \nif ( uploaderThread == null ) { \nthrow new RuntimeException ( \"Not running\" ) ; \n} \nuploaderThread . interrupt ( ) ; \nuploaderThread = null ; \nfileUploader . shutdown ( ) ; \nreturn ; \n} \n} \n"}
{"8110": "public class LocatorCache { \npublic synchronized void setDelayedLocatorForASlotCurrent ( int slot , Locator locator ) { \ninsertedDelayedLocators . put ( getLocatorSlotKey ( slot , locator ) , Boolean . TRUE ) ; \nreturn ; \n} \n} \n"}
{"8113": "public class AstyanaxWriter { \npublic void insertFull ( Collection < ? extends IMetric > metrics , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { \nTimer . Context ctx = Instrumentation . getWriteTimerContext ( CassandraModel . CF_METRICS_FULL_NAME ) ; \ntry { \nMutationBatch mutationBatch = keyspace . prepareMutationBatch ( ) ; \nfor ( IMetric metric : metrics ) { \nfinal Locator locator = metric . getLocator ( ) ; \nif ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { \nif ( mutationBatch != null ) insertLocator ( locator , mutationBatch ) ; \nLocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; \n} \nif ( isRecordingDelayedMetrics ) { \nif ( mutationBatch != null ) { \ninsertLocatorIfDelayed ( metric , mutationBatch , clock ) ; \n} \n} \ninsertMetric ( metric , mutationBatch ) ; \nInstrumentation . markFullResMetricWritten ( ) ; \n} \ntry { \nmutationBatch . execute ( ) ; \n} \ncatch ( ConnectionException e ) { \nInstrumentation . markWriteError ( e ) ; \nlog . error ( \"Connection exception during insertFull\" , e ) ; \nthrow e ; \n} \n} \nfinally { \nctx . stop ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8114": "public class AstyanaxWriter { \npublic void insertMetrics ( Collection < IMetric > metrics , ColumnFamily cf , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { \nTimer . Context ctx = Instrumentation . getWriteTimerContext ( cf . getName ( ) ) ; \nMultimap < Locator , IMetric > map = asMultimap ( metrics ) ; \nMutationBatch batch = keyspace . prepareMutationBatch ( ) ; \ntry { \nfor ( Locator locator : map . keySet ( ) ) { \nColumnListMutation < Long > mutation = batch . withRow ( cf , locator ) ; \nfor ( IMetric metric : map . get ( locator ) ) { \nmutation . putColumn ( metric . getCollectionTime ( ) , metric . getMetricValue ( ) , ( AbstractSerializer ) ( Serializers . serializerFor ( metric . getMetricValue ( ) . getClass ( ) ) ) , metric . getTtlInSeconds ( ) ) ; \nif ( cf . getName ( ) . equals ( CassandraModel . CF_METRICS_PREAGGREGATED_FULL_NAME ) ) { \nInstrumentation . markFullResPreaggregatedMetricWritten ( ) ; \n} \nif ( isRecordingDelayedMetrics ) { \ninsertLocatorIfDelayed ( metric , batch , clock ) ; \n} \n} \nif ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { \ninsertLocator ( locator , batch ) ; \nLocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; \n} \n} \ntry { \nbatch . execute ( ) ; \n} \ncatch ( ConnectionException e ) { \nInstrumentation . markWriteError ( e ) ; \nlog . error ( \"Connection exception persisting data\" , e ) ; \nthrow e ; \n} \n} \nfinally { \nctx . stop ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8121": "public class ElasticIO { \npublic void insertDiscovery ( List < IMetric > batch ) throws IOException { \nbatchHistogram . update ( batch . size ( ) ) ; \nif ( batch . size ( ) == 0 ) { \nlog . debug ( \"ElasticIO: batch size for insertDiscovery is zero, so skip calling Elasticsearch ingest.\" ) ; \nreturn ; \n} \nTimer . Context ctx = writeTimer . time ( ) ; \ntry { \nfor ( Object obj : batch ) { \nif ( ! ( obj instanceof IMetric ) ) { \nclassCastExceptionMeter . mark ( ) ; \ncontinue ; \n} \n} \nelasticsearchRestHelper . indexMetrics ( batch ) ; \n} \nfinally { \nctx . stop ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) return ; \nif ( fileManager == null ) return ; \nif ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nwhile ( downloadDir . listFiles ( ) . length != 0 ) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( downloadLock . tryLock ( ) ) { \ntry { \nif ( fileManager . hasNewFiles ( ) ) { \nfileManager . downloadNewFiles ( downloadDir ) ; \n} \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors += 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) { \ntry { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \n} \nelse { \nlog . debug ( \"Download in progress\" ) ; \n} \nreturn ; \n} \n} \n"}
{"8126": "public class EmbeddedRabbitMq { \npublic void start ( ) throws ErlangVersionException , DownloadException , ExtractionException , StartupException { \nif ( rabbitMqProcess != null ) { \nthrow new IllegalStateException ( \"Start shouldn't be called more than once unless stop() has been called before.\" ) ; \n} \ncheck ( ) ; \ndownload ( ) ; \nextract ( ) ; \nrun ( ) ; \nreturn ; \n} \n} \n"}
{"8127": "public class EmbeddedRabbitMq { \npublic void stop ( ) throws ShutDownException { \nif ( rabbitMqProcess == null ) { \nthrow new IllegalStateException ( \"Stop shouldn't be called unless 'start()' was successful.\" ) ; \n} \nnew ShutdownHelper ( config , rabbitMqProcess ) . run ( ) ; \nrabbitMqProcess = null ; \nreturn ; \n} \n} \n"}
{"8129": "public class PnSignalingParams { \npublic void addIceServers ( List < PeerConnection . IceServer > iceServers ) { \nif ( this . iceServers != null ) { \niceServers . addAll ( this . iceServers ) ; \n} \nthis . iceServers = iceServers ; \nreturn ; \n} \n} \n"}
{"8130": "public class PnSignalingParams { \npublic void addIceServers ( PeerConnection . IceServer iceServers ) { \nif ( this . iceServers == null ) { \nthis . iceServers = new ArrayList < PeerConnection . IceServer > ( ) ; \n} \nthis . iceServers . add ( 0 , iceServers ) ; \nreturn ; \n} \n} \n"}
{"8131": "public class PnRTCClient { \npublic void transmit ( String userId , JSONObject message ) { \nJSONObject usrMsgJson = new JSONObject ( ) ; \ntry { \nusrMsgJson . put ( PnRTCMessage . JSON_USERMSG , message ) ; \nthis . pcClient . transmitMessage ( userId , usrMsgJson ) ; \n} \ncatch ( JSONException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8132": "public class PnRTCClient { \npublic void transmitAll ( JSONObject message ) { \nList < PnPeer > peerList = this . pcClient . getPeers ( ) ; \nfor ( PnPeer p : peerList ) { \ntransmit ( p . getId ( ) , message ) ; \n} \nreturn ; \n} \n} \n"}
{"8136": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setApiSuchfelder ( JAXBElement < ApiSuchfelderTyp > value ) { \nthis . apiSuchfelder = value ; \nreturn ; \n} \n} \n"}
{"8145": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setRegion ( java . lang . String value ) { \nthis . region = value ; \nreturn ; \n} \n} \n"}
{"8146": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setArea ( java . lang . String value ) { \nthis . area = value ; \nreturn ; \n} \n} \n"}
{"8147": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAddress ( java . lang . String value ) { \nthis . address = value ; \nreturn ; \n} \n} \n"}
{"8148": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setDescription ( java . lang . String value ) { \nthis . description = value ; \nreturn ; \n} \n} \n"}
{"8149": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setRentCollectionPeriod ( OverseasRentalAdType . RentPeriod value ) { \nthis . rentCollectionPeriod = value ; \nreturn ; \n} \n} \n"}
{"8150": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setFurnished ( OverseasRentalAdType . Furnished value ) { \nthis . furnished = value ; \nreturn ; \n} \n} \n"}
{"8151": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPhone1 ( java . lang . String value ) { \nthis . phone1 = value ; \nreturn ; \n} \n} \n"}
{"8152": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPhone2 ( java . lang . String value ) { \nthis . phone2 = value ; \nreturn ; \n} \n} \n"}
{"8153": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setContactName ( java . lang . String value ) { \nthis . contactName = value ; \nreturn ; \n} \n} \n"}
{"8154": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPhoneInfo ( java . lang . String value ) { \nthis . phoneInfo = value ; \nreturn ; \n} \n} \n"}
{"8155": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMainEmail ( java . lang . String value ) { \nthis . mainEmail = value ; \nreturn ; \n} \n} \n"}
{"8156": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCcEmail ( java . lang . String value ) { \nthis . ccEmail = value ; \nreturn ; \n} \n} \n"}
{"8157": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setExternalId ( java . lang . String value ) { \nthis . externalId = value ; \nreturn ; \n} \n} \n"}
{"8158": "public class OverseasRentalAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAgentId ( java . lang . String value ) { \nthis . agentId = value ; \nreturn ; \n} \n} \n"}
{"8159": "public class Energiepass { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setEpart ( Energiepass . Epart value ) { \nthis . epart = value ; \nreturn ; \n} \n} \n"}
{"8160": "public class Energiepass { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setJahrgang ( Energiepass . Jahrgang value ) { \nthis . jahrgang = value ; \nreturn ; \n} \n} \n"}
{"8161": "public class Energiepass { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGebaeudeart ( Energiepass . Gebaeudeart value ) { \nthis . gebaeudeart = value ; \nreturn ; \n} \n} \n"}
{"8162": "public class BueroPraxen { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBueroTyp ( BueroPraxen . BueroTyp value ) { \nthis . bueroTyp = value ; \nreturn ; \n} \n} \n"}
{"8164": "public class LageGebiet { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGebiete ( LageGebiet . Gebiete value ) { \nthis . gebiete = value ; \nreturn ; \n} \n} \n"}
{"8165": "public class Anhang { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGruppe ( Anhang . Gruppe value ) { \nthis . gruppe = value ; \nreturn ; \n} \n} \n"}
{"8166": "public class Root { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T01:43:04+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAgent ( Root . Agent value ) { \nthis . agent = value ; \nreturn ; \n} \n} \n"}
{"8168": "public class Verkaufstatus { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setStand ( Verkaufstatus . Stand value ) { \nthis . stand = value ; \nreturn ; \n} \n} \n"}
{"8170": "public class PreisZeiteinheit { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setZeiteinheit ( PreisZeiteinheit . Zeiteinheit value ) { \nthis . zeiteinheit = value ; \nreturn ; \n} \n} \n"}
{"8179": "public class Uebertragung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setUmfang ( Uebertragung . Umfang value ) { \nthis . umfang = value ; \nreturn ; \n} \n} \n"}
{"8180": "public class Wohnung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setWohnungtyp ( Wohnung . Wohnungtyp value ) { \nthis . wohnungtyp = value ; \nreturn ; \n} \n} \n"}
{"8188": "public class BusinessElement { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCategory ( BusinessElement . BusinessElementCategory value ) { \nthis . category = value ; \nreturn ; \n} \n} \n"}
{"8190": "public class Aktion { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAktionart ( Aktion . AktionArt value ) { \nthis . aktionart = value ; \nreturn ; \n} \n} \n"}
{"8191": "public class Container { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:02+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setRealestateitems ( Container . Realestateitems value ) { \nthis . realestateitems = value ; \nreturn ; \n} \n} \n"}
{"8192": "public class VermarktungGrundstueckWohnenMieteTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPacht ( JAXBElement < VermarktungGrundstueckWohnenMieteTyp . Pacht > value ) { \nthis . pacht = value ; \nreturn ; \n} \n} \n"}
{"8193": "public class OpenImmo_1_2_7 { \n@ Override public void downgradeToPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_6 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . removeMultipleEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove odd <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeObjektTextElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove unsupported <objekt_text> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeSummemietenettoElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <summemietenetto> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeBefeuerungElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <befeuerung> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeAnhangElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <anhang> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeAktionElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <aktion> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8194": "public class OpenImmo_1_2_7 { \n@ Override public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_7 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . upgradeSummemietenettoElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <summemietenetto> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8197": "public class Ausblick { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBlick ( Ausblick . Blick value ) { \nthis . blick = value ; \nreturn ; \n} \n} \n"}
{"8198": "public class WazTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPauschalmiete ( WazTyp . Pauschalmiete value ) { \nthis . pauschalmiete = value ; \nreturn ; \n} \n} \n"}
{"8199": "public class WazTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMonatsmiete ( WazTyp . Monatsmiete value ) { \nthis . monatsmiete = value ; \nreturn ; \n} \n} \n"}
{"8201": "public class EinzelhandelTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setLastenaufzug ( JAXBElement < HebeanlageTyp > value ) { \nthis . lastenaufzug = value ; \nreturn ; \n} \n} \n"}
{"8202": "public class Zustand { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setZustandArt ( Zustand . ZustandArt value ) { \nthis . zustandArt = value ; \nreturn ; \n} \n} \n"}
{"8205": "public class CsvRecord { \npublic void dump ( Writer writer , String lineSeparator ) throws IOException { \nfor ( int i = 0 ; \ni < this . getRecordLenth ( ) ; \ni ++ ) { \nStringBuilder txt = new StringBuilder ( ) ; \ntry ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { \nfor ( String line : IOUtils . readLines ( reader ) ) { \nif ( txt . length ( ) > 0 ) txt . append ( lineSeparator ) ; \ntxt . append ( line ) ; \n} \n} \nwriter . write ( i + \":\" + txt . toString ( ) ) ; \nwriter . write ( System . lineSeparator ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8208": "public class CsvRecord { \nprotected final void set ( int pos , String value ) { \nvalue = StringUtils . trimToNull ( value ) ; \nif ( value != null ) this . values . put ( pos , value ) ; \nelse if ( this . values . containsKey ( pos ) ) this . values . remove ( pos ) ; \nreturn ; \n} \n} \n"}
{"8209": "public class Check { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCtype ( Check . Ctype value ) { \nthis . ctype = value ; \nreturn ; \n} \n} \n"}
{"8210": "public class Haus { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setHaustyp ( Haus . Haustyp value ) { \nthis . haustyp = value ; \nreturn ; \n} \n} \n"}
{"8212": "public class Unterkellert { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setKeller ( Unterkellert . Keller value ) { \nthis . keller = value ; \nreturn ; \n} \n} \n"}
{"8213": "public class Grundstueck { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGrundstTyp ( Grundstueck . GrundstTyp value ) { \nthis . grundstTyp = value ; \nreturn ; \n} \n} \n"}
{"8214": "public class Geschlecht { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGeschlAttr ( Geschlecht . GeschlAttr value ) { \nthis . geschlAttr = value ; \nreturn ; \n} \n} \n"}
{"8215": "public class HallenLagerProd { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setHallenTyp ( HallenLagerProd . HallenTyp value ) { \nthis . hallenTyp = value ; \nreturn ; \n} \n} \n"}
{"8218": "public class OpenImmo_1_2_3 { \n@ Override public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_3 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . upgradeSonstigeElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <sonstige> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeZinshausRenditeobjektElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <zinshaus_renditeobjekt> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8221": "public class Uebertragung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setArt ( Uebertragung . Art value ) { \nthis . art = value ; \nreturn ; \n} \n} \n"}
{"8222": "public class Uebertragung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setModus ( Uebertragung . Modus value ) { \nthis . modus = value ; \nreturn ; \n} \n} \n"}
{"8225": "public class Einzelhandel { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setHandelTyp ( Einzelhandel . HandelTyp value ) { \nthis . handelTyp = value ; \nreturn ; \n} \n} \n"}
{"8226": "public class OpenImmo_1_2_6 { \n@ Override public void downgradeToPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_5 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . removePreiseChildElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove unsupported children of <preise> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeKaufpreisElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <kaufpreis> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeZwangsversteigerungElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove unsupported <zwangsversteigerung> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeFlaechenChildElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove unsupported children of <flaechen> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeBauzoneElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove unsupported <bauzone> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeBodenElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <boden> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeEnergietypElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <energietyp> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeAusblickElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <ausblick> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeBueroPraxenElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <buero_praxen> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8227": "public class ApiSuchfelderTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setApiSuchfeld1 ( JAXBElement < String > value ) { \nthis . apiSuchfeld1 = value ; \nreturn ; \n} \n} \n"}
{"8228": "public class ApiSuchfelderTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setApiSuchfeld2 ( JAXBElement < String > value ) { \nthis . apiSuchfeld2 = value ; \nreturn ; \n} \n} \n"}
{"8229": "public class ApiSuchfelderTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setApiSuchfeld3 ( JAXBElement < String > value ) { \nthis . apiSuchfeld3 = value ; \nreturn ; \n} \n} \n"}
{"8231": "public class DistanzenSport { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setDistanzZuSport ( DistanzenSport . DistanzZuSport value ) { \nthis . distanzZuSport = value ; \nreturn ; \n} \n} \n"}
{"8239": "public class ProvisionTeilen { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setWert ( ProvisionTeilen . Wert value ) { \nthis . wert = value ; \nreturn ; \n} \n} \n"}
{"8240": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAckerland ( JAXBElement < Object > value ) { \nthis . ackerland = value ; \nreturn ; \n} \n} \n"}
{"8241": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBauerwartungsland ( JAXBElement < Object > value ) { \nthis . bauerwartungsland = value ; \nreturn ; \n} \n} \n"}
{"8242": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBootsstaende ( JAXBElement < Object > value ) { \nthis . bootsstaende = value ; \nreturn ; \n} \n} \n"}
{"8243": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBuero ( JAXBElement < Object > value ) { \nthis . buero = value ; \nreturn ; \n} \n} \n"}
{"8244": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCamping ( JAXBElement < Object > value ) { \nthis . camping = value ; \nreturn ; \n} \n} \n"}
{"8245": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setDoppelhaus ( JAXBElement < Object > value ) { \nthis . doppelhaus = value ; \nreturn ; \n} \n} \n"}
{"8246": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setEinfamilienhaus ( JAXBElement < Object > value ) { \nthis . einfamilienhaus = value ; \nreturn ; \n} \n} \n"}
{"8247": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setEinzelhandelGross ( JAXBElement < Object > value ) { \nthis . einzelhandelGross = value ; \nreturn ; \n} \n} \n"}
{"8248": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setEinzelhandelKlein ( JAXBElement < Object > value ) { \nthis . einzelhandelKlein = value ; \nreturn ; \n} \n} \n"}
{"8249": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGaragen ( JAXBElement < Object > value ) { \nthis . garagen = value ; \nreturn ; \n} \n} \n"}
{"8250": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGarten ( JAXBElement < Object > value ) { \nthis . garten = value ; \nreturn ; \n} \n} \n"}
{"8251": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGastronomie ( JAXBElement < Object > value ) { \nthis . gastronomie = value ; \nreturn ; \n} \n} \n"}
{"8252": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGewerbe ( JAXBElement < Object > value ) { \nthis . gewerbe = value ; \nreturn ; \n} \n} \n"}
{"8253": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setHotel ( JAXBElement < Object > value ) { \nthis . hotel = value ; \nreturn ; \n} \n} \n"}
{"8254": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setIndustrie ( JAXBElement < Object > value ) { \nthis . industrie = value ; \nreturn ; \n} \n} \n"}
{"8255": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setKeineBebauung ( JAXBElement < Object > value ) { \nthis . keineBebauung = value ; \nreturn ; \n} \n} \n"}
{"8256": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setKleingewerbe ( JAXBElement < Object > value ) { \nthis . kleingewerbe = value ; \nreturn ; \n} \n} \n"}
{"8257": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setLager ( JAXBElement < Object > value ) { \nthis . lager = value ; \nreturn ; \n} \n} \n"}
{"8258": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMehrfamilienhaus ( JAXBElement < Object > value ) { \nthis . mehrfamilienhaus = value ; \nreturn ; \n} \n} \n"}
{"8259": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setObstpflanzung ( JAXBElement < Object > value ) { \nthis . obstpflanzung = value ; \nreturn ; \n} \n} \n"}
{"8260": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setParkhaus ( JAXBElement < Object > value ) { \nthis . parkhaus = value ; \nreturn ; \n} \n} \n"}
{"8261": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setProduktion ( JAXBElement < Object > value ) { \nthis . produktion = value ; \nreturn ; \n} \n} \n"}
{"8262": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setReihenhaus ( JAXBElement < Object > value ) { \nthis . reihenhaus = value ; \nreturn ; \n} \n} \n"}
{"8263": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setStellplaetze ( JAXBElement < Object > value ) { \nthis . stellplaetze = value ; \nreturn ; \n} \n} \n"}
{"8264": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setVilla ( JAXBElement < Object > value ) { \nthis . villa = value ; \nreturn ; \n} \n} \n"}
{"8265": "public class GrundstueckEmpfohleneNutzung { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setWald ( JAXBElement < Object > value ) { \nthis . wald = value ; \nreturn ; \n} \n} \n"}
{"8266": "public class ImmobilienTransferTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAnbieter ( ImmobilienTransferTyp . Anbieter value ) { \nthis . anbieter = value ; \nreturn ; \n} \n} \n"}
{"8275": "public class MaxMietdauer { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMaxDauer ( MaxMietdauer . MaxDauer value ) { \nthis . maxDauer = value ; \nreturn ; \n} \n} \n"}
{"8277": "public class Zimmer { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setZimmertyp ( Zimmer . Zimmertyp value ) { \nthis . zimmertyp = value ; \nreturn ; \n} \n} \n"}
{"8278": "public class OpenImmo_1_2_5 { \n@ Override @ SuppressWarnings ( \"Duplicates\" ) public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_5 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8279": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setKeineAngabe ( JAXBElement < Object > value ) { \nthis . keineAngabe = value ; \nreturn ; \n} \n} \n"}
{"8280": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setErdwaerme ( JAXBElement < Object > value ) { \nthis . erdwaerme = value ; \nreturn ; \n} \n} \n"}
{"8281": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setSolarheizung ( JAXBElement < Object > value ) { \nthis . solarheizung = value ; \nreturn ; \n} \n} \n"}
{"8282": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPelletheizung ( JAXBElement < Object > value ) { \nthis . pelletheizung = value ; \nreturn ; \n} \n} \n"}
{"8283": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGas ( JAXBElement < Object > value ) { \nthis . gas = value ; \nreturn ; \n} \n} \n"}
{"8284": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setOel ( JAXBElement < Object > value ) { \nthis . oel = value ; \nreturn ; \n} \n} \n"}
{"8285": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setFernwaerme ( JAXBElement < Object > value ) { \nthis . fernwaerme = value ; \nreturn ; \n} \n} \n"}
{"8286": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setStrom ( JAXBElement < Object > value ) { \nthis . strom = value ; \nreturn ; \n} \n} \n"}
{"8287": "public class BefeuerungsArtTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setKohle ( JAXBElement < Object > value ) { \nthis . kohle = value ; \nreturn ; \n} \n} \n"}
{"8292": "public class WIS { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:55:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBENUTZER ( WIS . BENUTZER value ) { \nthis . benutzer = value ; \nreturn ; \n} \n} \n"}
{"8293": "public class WIS { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:55:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setOBJEKTE ( WIS . OBJEKTE value ) { \nthis . objekte = value ; \nreturn ; \n} \n} \n"}
{"8295": "public class Moebliert { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMoeb ( Moebliert . Moeb value ) { \nthis . moeb = value ; \nreturn ; \n} \n} \n"}
{"8297": "public class LocationStructure { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setSubAdministrativeArea ( LocationStructure . SubAdministrativeArea value ) { \nthis . subAdministrativeArea = value ; \nreturn ; \n} \n} \n"}
{"8298": "public class LocationStructure { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCity ( LocationStructure . City value ) { \nthis . city = value ; \nreturn ; \n} \n} \n"}
{"8299": "public class LocationStructure { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setLocality ( LocationStructure . Locality value ) { \nthis . locality = value ; \nreturn ; \n} \n} \n"}
{"8300": "public class OpenImmo_1_2_1 { \n@ Override public void downgradeToPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_0 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . removeObjektartZusatzElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove <objektart_zusatz> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeHausElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <haus> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \ntry { \nthis . downgradeXmlNamespace ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade the XML namespace!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8301": "public class OpenImmo_1_2_1 { \n@ Override @ SuppressWarnings ( \"Duplicates\" ) public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_1 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <energiepass> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \ntry { \nthis . upgradeXmlNamespace ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade the XML namespace!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8302": "public class LandUndForstwirtschaft { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setLandTyp ( LandUndForstwirtschaft . LandTyp value ) { \nthis . landTyp = value ; \nreturn ; \n} \n} \n"}
{"8304": "public class OpenImmo_1_2_0 { \n@ Override public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_0 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . upgradeMieteinnahmenElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <mieteinnahmen_ist> and <mieteinnahmen_soll> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8306": "public class Gastgewerbe { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setGastgewTyp ( Gastgewerbe . GastgewTyp value ) { \nthis . gastgewTyp = value ; \nreturn ; \n} \n} \n"}
{"8307": "public class StpSonstige { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPlatzart ( StpSonstige . Platzart value ) { \nthis . platzart = value ; \nreturn ; \n} \n} \n"}
{"8311": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPriceType ( OverseasSaleAdType . PriceType value ) { \nthis . priceType = value ; \nreturn ; \n} \n} \n"}
{"8312": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setNewDevelopmentAvailability ( java . lang . String value ) { \nthis . newDevelopmentAvailability = value ; \nreturn ; \n} \n} \n"}
{"8313": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setDirections ( java . lang . String value ) { \nthis . directions = value ; \nreturn ; \n} \n} \n"}
{"8314": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCo2Rating ( java . lang . String value ) { \nthis . co2Rating = value ; \nreturn ; \n} \n} \n"}
{"8315": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setEnergyRating ( java . lang . String value ) { \nthis . energyRating = value ; \nreturn ; \n} \n} \n"}
{"8316": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setViewingDetails ( java . lang . String value ) { \nthis . viewingDetails = value ; \nreturn ; \n} \n} \n"}
{"8317": "public class OverseasSaleAdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPropertyStatus ( OverseasSaleAdType . PropertyStatus value ) { \nthis . propertyStatus = value ; \nreturn ; \n} \n} \n"}
{"8318": "public class AdType { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:55:25+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setPictures ( AdType . Pictures value ) { \nthis . pictures = value ; \nreturn ; \n} \n} \n"}
{"8319": "public class BebaubarNach { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setBebaubarAttr ( BebaubarNach . BebaubarAttr value ) { \nthis . bebaubarAttr = value ; \nreturn ; \n} \n} \n"}
{"8320": "public class OpenImmo_1_2_4 { \n@ Override public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { \ndoc . setDocumentVersion ( OpenImmoVersion . V1_2_4 ) ; \nif ( doc instanceof OpenImmoTransferDocument ) { \ntry { \nthis . upgradeAnzahlBalkonTerrassenElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <anzahl_balkon_terrassen> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeAnhangElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <anhang> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeSonstigeElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <sonstige> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8321": "public class Parken { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setParkenTyp ( Parken . ParkenTyp value ) { \nthis . parkenTyp = value ; \nreturn ; \n} \n} \n"}
{"8322": "public class Alter { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setAlterAttr ( Alter . AlterAttr value ) { \nthis . alterAttr = value ; \nreturn ; \n} \n} \n"}
{"8323": "public class FreizeitimmobilieGewerblich { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setFreizeitTyp ( FreizeitimmobilieGewerblich . FreizeitTyp value ) { \nthis . freizeitTyp = value ; \nreturn ; \n} \n} \n"}
{"8324": "public class TelSonstige { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setTelefonart ( TelSonstige . Telefonart value ) { \nthis . telefonart = value ; \nreturn ; \n} \n} \n"}
{"8325": "public class EmailSonstige { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setEmailart ( EmailSonstige . Emailart value ) { \nthis . emailart = value ; \nreturn ; \n} \n} \n"}
{"8326": "public class Daft { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setOverseasSales ( Daft . OverseasSales value ) { \nthis . overseasSales = value ; \nreturn ; \n} \n} \n"}
{"8327": "public class Daft { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:41:42+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setOverseasRental ( Daft . OverseasRental value ) { \nthis . overseasRental = value ; \nreturn ; \n} \n} \n"}
{"8330": "public class VermarktungGrundstueckGewerbeTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setErbpacht ( JAXBElement < VermarktungGrundstueckGewerbeTyp . Erbpacht > value ) { \nthis . erbpacht = value ; \nreturn ; \n} \n} \n"}
{"8333": "public class MinMietdauer { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMinDauer ( MinMietdauer . MinDauer value ) { \nthis . minDauer = value ; \nreturn ; \n} \n} \n"}
{"8334": "public class ZinshausRenditeobjekt { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setZinsTyp ( ZinshausRenditeobjekt . ZinsTyp value ) { \nthis . zinsTyp = value ; \nreturn ; \n} \n} \n"}
{"8336": "public class Feed { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setMetadata ( Feed . Metadata value ) { \nthis . metadata = value ; \nreturn ; \n} \n} \n"}
{"8337": "public class Feed { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setProjects ( Feed . Projects value ) { \nthis . projects = value ; \nreturn ; \n} \n} \n"}
{"8338": "public class Feed { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:48:12+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setProperties ( Feed . Properties value ) { \nthis . properties = value ; \nreturn ; \n} \n} \n"}
{"8339": "public class Kyero_3 { \n@ Override public void downgradeToPreviousVersion ( KyeroDocument doc ) { \ndoc . setDocumentVersion ( KyeroVersion . V2_1 ) ; \ntry { \nthis . downgradeNewBuildElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <new_build> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeTypeElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <type> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . downgradeUrlElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't downgrade <url> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeLocationElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove <location> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeEnergyRatingElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove <energy_rating> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeNotesElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove <notes> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . removeUnsupportedLanguageElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove unsupported translation elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8340": "public class Kyero_3 { \n@ Override public void upgradeFromPreviousVersion ( KyeroDocument doc ) { \ndoc . setDocumentVersion ( KyeroVersion . V3 ) ; \ntry { \nthis . removeCustomElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't remove <custom> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeNewBuildElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <new_build> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeTypeElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <type> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeCurrencyElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <currency> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \ntry { \nthis . upgradeUrlElements ( doc . getDocument ( ) ) ; \n} \ncatch ( Exception ex ) { \nLOGGER . error ( \"Can't upgrade <url> elements!\" ) ; \nLOGGER . error ( \"> \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8345": "public class Sonstige { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:50:55+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setSonstigeTyp ( Sonstige . SonstigeTyp value ) { \nthis . sonstigeTyp = value ; \nreturn ; \n} \n} \n"}
{"8346": "public class Distanzen { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setDistanzZu ( Distanzen . DistanzZu value ) { \nthis . distanzZu = value ; \nreturn ; \n} \n} \n"}
{"8350": "public class SimpleNamespaceContext { \npublic void setBindings ( Map < String , String > bindings ) { \nfor ( Map . Entry < String , String > entry : bindings . entrySet ( ) ) { \nbindNamespaceUri ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8351": "public class SimpleNamespaceContext { \npublic void bindNamespaceUri ( String prefix , String namespaceUri ) { \nAssert . notNull ( prefix , \"No prefix given\" ) ; \nAssert . notNull ( namespaceUri , \"No namespaceUri given\" ) ; \nif ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) { \ndefaultNamespaceUri = namespaceUri ; \n} \nelse { \nprefixToNamespaceUri . put ( prefix , namespaceUri ) ; \ngetPrefixesInternal ( namespaceUri ) . add ( prefix ) ; \n} \nreturn ; \n} \n} \n"}
{"8352": "public class SimpleNamespaceContext { \npublic void removeBinding ( String prefix ) { \nif ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) { \ndefaultNamespaceUri = \"\" ; \n} \nelse { \nString namespaceUri = prefixToNamespaceUri . remove ( prefix ) ; \nList < String > prefixes = getPrefixesInternal ( namespaceUri ) ; \nprefixes . remove ( prefix ) ; \n} \nreturn ; \n} \n} \n"}
{"8357": "public class Log4jConfigurer { \npublic static void initLogging ( String location ) throws FileNotFoundException { \nString resolvedLocation = SystemPropertyUtils . resolvePlaceholders ( location ) ; \nURL url = ResourceUtils . getURL ( resolvedLocation ) ; \nif ( resolvedLocation . toLowerCase ( ) . endsWith ( XML_FILE_EXTENSION ) ) { \nDOMConfigurator . configure ( url ) ; \n} \nelse { \nPropertyConfigurator . configure ( url ) ; \n} \nreturn ; \n} \n} \n"}
{"8358": "public class AbstractStaxContentHandler { \n@ Override public final void startPrefixMapping ( String prefix , String uri ) { \nnamespaceContext . bindNamespaceUri ( prefix , uri ) ; \nnamespaceContextChanged = true ; \nreturn ; \n} \n} \n"}
{"8359": "public class CompositeIterator { \npublic void add ( Iterator < E > iterator ) { \nAssert . state ( ! inUse , \"You can no longer add iterator to a composite iterator that's already in use\" ) ; \nif ( iterators . contains ( iterator ) ) { \nthrow new IllegalArgumentException ( \"You cannot add the same iterator twice\" ) ; \n} \niterators . add ( iterator ) ; \nreturn ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \nreturn ; \n} \n} \n"}
{"8368": "public class ConcurrencyThrottleSupport { \nprotected void afterAccess ( ) { \nif ( this . concurrencyLimit >= 0 ) { \nsynchronized ( this . monitor ) { \nthis . concurrencyCount -- ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Returning from throttle at concurrency count \" + this . concurrencyCount ) ; \n} \nthis . monitor . notify ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8369": "public class MethodInvoker { \npublic void setTargetObject ( Object targetObject ) { \nthis . targetObject = targetObject ; \nif ( targetObject != null ) { \nthis . targetClass = targetObject . getClass ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nint lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) { \nthrow new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \n} \nif ( targetMethod == null ) { \nthrow new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \n} \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \nfor ( int i = 0 ; \ni < arguments . length ; \n++ i ) { \nargTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \n} \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) { \nthrow ex ; \n} \n} \nreturn ; \n} \n} \n"}
{"8381": "public class WeakReferenceMonitor { \npublic static void monitor ( Object handle , ReleaseListener listener ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Monitoring handle [\" + handle + \"] with release listener [\" + listener + \"]\" ) ; \n} \nWeakReference < Object > weakRef = new WeakReference < Object > ( handle , handleQueue ) ; \naddEntry ( weakRef , listener ) ; \nreturn ; \n} \n} \n"}
{"8382": "public class WeakReferenceMonitor { \nprivate static void addEntry ( Reference < ? > ref , ReleaseListener entry ) { \nsynchronized ( WeakReferenceMonitor . class ) { \ntrackedEntries . put ( ref , entry ) ; \nif ( monitoringThread == null ) { \nmonitoringThread = new Thread ( new MonitoringProcess ( ) , WeakReferenceMonitor . class . getName ( ) ) ; \nmonitoringThread . setDaemon ( true ) ; \nmonitoringThread . start ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8385": "public class AbstractStaxXMLReader { \nprotected void startPrefixMapping ( String prefix , String namespace ) throws SAXException { \nif ( getContentHandler ( ) != null ) { \nif ( prefix == null ) { \nprefix = \"\" ; \n} \nif ( ! StringUtils . hasLength ( namespace ) ) { \nreturn ; \n} \nif ( ! namespace . equals ( namespaces . get ( prefix ) ) ) { \ngetContentHandler ( ) . startPrefixMapping ( prefix , namespace ) ; \nnamespaces . put ( prefix , namespace ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8386": "public class AbstractStaxXMLReader { \nprotected void endPrefixMapping ( String prefix ) throws SAXException { \nif ( getContentHandler ( ) != null ) { \nif ( namespaces . containsKey ( prefix ) ) { \ngetContentHandler ( ) . endPrefixMapping ( prefix ) ; \nnamespaces . remove ( prefix ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8387": "public class ListenableFutureCallbackRegistry { \n@ SuppressWarnings ( \"unchecked\" ) public void addCallback ( ListenableFutureCallback < ? super T > callback ) { \nAssert . notNull ( callback , \"'callback' must not be null\" ) ; \nsynchronized ( mutex ) { \nswitch ( state ) { \ncase NEW : callbacks . add ( callback ) ; \nbreak ; \ncase SUCCESS : callback . onSuccess ( ( T ) result ) ; \nbreak ; \ncase FAILURE : callback . onFailure ( ( Throwable ) result ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( this . values != null ) { \nlayouts = new BoringLayout [ this . values . length ] ; \nfor ( int i = 0 ; \ni < layouts . length ; \ni ++ ) { \nlayouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \n} \n} \nelse { \nlayouts = new BoringLayout [ 0 ] ; \n} \nif ( getWidth ( ) > 0 ) { \nstartMarqueeIfNeeded ( ) ; \n} \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8392": "public class HorizontalPicker { \nprivate void setTextSize ( float size ) { \nif ( size != textPaint . getTextSize ( ) ) { \ntextPaint . setTextSize ( size ) ; \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8398": "public class RemoteServer { \npublic static void main ( String [ ] args ) throws Exception { \nconfigureLogging ( ) ; \nCommandLineHelper helper = new CommandLineHelper ( args ) ; \nif ( helper . getHelpRequested ( ) ) { \nSystem . out . print ( helper . getUsage ( ) ) ; \nSystem . exit ( 0 ) ; \n} \nRemoteServer remoteServer = new RemoteServer ( ) ; \nString error = helper . getError ( ) ; \nif ( error == null ) { \ntry { \nfor ( String path : helper . getLibraryMap ( ) . keySet ( ) ) remoteServer . putLibrary ( path , helper . getLibraryMap ( ) . get ( path ) ) ; \n} \ncatch ( IllegalPathException e ) { \nerror = e . getMessage ( ) ; \n} \n} \nif ( error != null ) { \nSystem . out . println ( \"Error: \" + error ) ; \nSystem . out . println ( ) ; \nSystem . out . println ( helper . getUsage ( ) ) ; \nSystem . exit ( 1 ) ; \n} \nremoteServer . setPort ( helper . getPort ( ) ) ; \nremoteServer . setAllowStop ( helper . getAllowStop ( ) ) ; \nremoteServer . setHost ( helper . getHost ( ) ) ; \nremoteServer . start ( ) ; \nreturn ; \n} \n} \n"}
{"8399": "public class RemoteServer { \npublic void stop ( int timeoutMS ) throws Exception { \nlog . info ( \"Robot Framework remote server stopping\" ) ; \nif ( timeoutMS > 0 ) { \nserver . setGracefulShutdown ( timeoutMS ) ; \nThread stopper = new Thread ( ) { \n@ Override public void run ( ) { \ntry { \nserver . stop ( ) ; \n} \ncatch ( Throwable e ) { \nlog . error ( String . format ( \"Failed to stop the server: %s\" , e . getMessage ( ) ) , e ) ; \n} \nreturn ; \n} \n} \n; \nstopper . start ( ) ; \n} \nelse { \nserver . stop ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8400": "public class RemoteServer { \npublic void start ( ) throws Exception { \nlog . info ( \"Robot Framework remote server starting\" ) ; \nserver . start ( ) ; \nlog . info ( String . format ( \"Robot Framework remote server started on port %d.\" , getLocalPort ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"8412": "public class MdPageGeneratorMojo { \n@ Override public void execute ( ) throws MojoExecutionException { \nif ( applyFiltering ) { \nperformMavenPropertyFiltering ( new File ( inputDirectory ) , filteredOutputDirectory , getInputEncoding ( ) ) ; \ninputDirectory = filteredOutputDirectory . getAbsolutePath ( ) ; \n} \ngetLog ( ) . info ( \"Pre-processing markdown files from input directory: \" + inputDirectory ) ; \npreprocessMarkdownFiles ( new File ( inputDirectory ) ) ; \nif ( ! markdownDTOs . isEmpty ( ) ) { \ngetLog ( ) . info ( \"Process Pegdown extension options\" ) ; \nint options = getPegdownExtensions ( pegdownExtensions ) ; \nfinal Map < String , Attributes > attributesMap = processAttributes ( attributes ) ; \ngetLog ( ) . info ( \"Parse Markdown to HTML\" ) ; \nprocessMarkdown ( markdownDTOs , options , attributesMap ) ; \n} \nif ( StringUtils . isNotEmpty ( copyDirectories ) ) { \ngetLog ( ) . info ( \"Copy files from directories\" ) ; \nfor ( String dir : copyDirectories . split ( \",\" ) ) { \nfor ( Entry < String , String > copyAction : getFoldersToCopy ( inputDirectory , outputDirectory , dir ) . entrySet ( ) ) { \ncopyFiles ( copyAction . getKey ( ) , copyAction . getValue ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8419": "public class MdPageGeneratorMojo { \nprivate void copyFiles ( String fromDir , String toDir ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"fromDir=\" + fromDir + \"; toDir=\" + toDir ) ; \ntry { \nFile fromDirFile = new File ( fromDir ) ; \nif ( fromDirFile . exists ( ) ) { \nIterator < File > files = FileUtils . iterateFiles ( new File ( fromDir ) , null , false ) ; \nwhile ( files . hasNext ( ) ) { \nFile file = files . next ( ) ; \nif ( file . exists ( ) ) { \nFileUtils . copyFileToDirectory ( file , new File ( toDir ) ) ; \n} \nelse { \ngetLog ( ) . error ( \"File '\" + file . getAbsolutePath ( ) + \"' does not exist. Skipping copy\" ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to copy file \" + e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8422": "public class CrossfadeDrawerLayout { \npublic void fadeUp ( int duration ) { \nmContainer . clearAnimation ( ) ; \nResizeWidthAnimation anim = new ResizeWidthAnimation ( mContainer , mMaxWidth , new ApplyTransformationListener ( ) { \n@ Override public void applyTransformation ( int width ) { \noverlapViews ( width ) ; \nreturn ; \n} \n} \n) ; \nanim . setDuration ( duration ) ; \nmContainer . startAnimation ( anim ) ; \nreturn ; \n} \n} \n"}
{"8423": "public class CrossfadeDrawerLayout { \npublic void fadeDown ( int duration ) { \nmContainer . clearAnimation ( ) ; \nResizeWidthAnimation anim = new ResizeWidthAnimation ( mContainer , mMinWidth , new ApplyTransformationListener ( ) { \n@ Override public void applyTransformation ( int width ) { \noverlapViews ( width ) ; \nreturn ; \n} \n} \n) ; \nanim . setDuration ( duration ) ; \nmContainer . startAnimation ( anim ) ; \nreturn ; \n} \n} \n"}
{"8425": "public class CrossfadeDrawerLayout { \nprivate void overlapViews ( int width ) { \nif ( width == mWidth ) { \nreturn ; \n} \nmWidth = width ; \nfloat percentage = calculatePercentage ( width ) ; \nfloat alpha = percentage / 100 ; \nmSmallView . setAlpha ( 1 ) ; \nmSmallView . setClickable ( false ) ; \nmLargeView . bringToFront ( ) ; \nmLargeView . setAlpha ( alpha ) ; \nmLargeView . setClickable ( true ) ; \nmLargeView . setVisibility ( alpha > 0.01f ? View . VISIBLE : View . GONE ) ; \nif ( mCrossfadeListener != null ) { \nmCrossfadeListener . onCrossfade ( mContainer , calculatePercentage ( width ) , width ) ; \n} \nreturn ; \n} \n} \n"}
{"8427": "public class UseActivityInterceptor { \n@ SuppressWarnings ( \"unchecked\" ) private void launchActivity ( ) { \nif ( activity != null && ActivityRunMode . SPECIFICATION . equals ( activityRunMode ) ) return ; \nString targetPackage = instrumentation . getTargetContext ( ) . getPackageName ( ) ; \nIntent intent = getLaunchIntent ( targetPackage , activityClass , bundleCreator ) ; \nactivity = instrumentation . startActivitySync ( intent ) ; \ninstrumentation . waitForIdleSync ( ) ; \nreturn ; \n} \n} \n"}
{"8440": "public class MarkLogicDatasetGraph { \npublic void addPermissions ( Node graphName , GraphPermissions permissions ) { \ncheckIsOpen ( ) ; \nclient . mergeGraphPermissions ( graphName . getURI ( ) , permissions ) ; \nreturn ; \n} \n} \n"}
{"8441": "public class MarkLogicDatasetGraph { \npublic void writePermissions ( Node graphName , GraphPermissions permissions ) { \ncheckIsOpen ( ) ; \nclient . writeGraphPermissions ( graphName . getURI ( ) , permissions ) ; \nreturn ; \n} \n} \n"}
{"8443": "public class JenaDatabaseClient { \npublic void close ( ) { \nif ( writeBuffer != null ) { \nwriteBuffer . cancel ( ) ; \n} \nif ( timer != null ) { \ntimer . cancel ( ) ; \n} \nclient = null ; \nreturn ; \n} \n} \n"}
{"8455": "public class Args { \npublic static void usage ( PrintStream errStream , Object target ) { \nClass < ? > clazz ; \nif ( target instanceof Class ) { \nclazz = ( Class ) target ; \n} \nelse { \nclazz = target . getClass ( ) ; \n} \nerrStream . println ( \"Usage: \" + clazz . getName ( ) ) ; \nfor ( Class < ? > currentClazz = clazz ; \ncurrentClazz != null ; \ncurrentClazz = currentClazz . getSuperclass ( ) ) { \nfor ( Field field : currentClazz . getDeclaredFields ( ) ) { \nfieldUsage ( errStream , target , field ) ; \n} \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \npropertyUsage ( errStream , target , pd ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \nreturn ; \n} \n} \n"}
{"8457": "public class PropertiesArgs { \npublic static void parse ( Object target , Properties arguments ) { \nClass clazz ; \nif ( target instanceof Class ) { \nclazz = ( Class ) target ; \n} \nelse { \nclazz = target . getClass ( ) ; \n} \nfor ( Field field : clazz . getDeclaredFields ( ) ) { \nprocessField ( target , field , arguments ) ; \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \nprocessProperty ( target , pd , arguments ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \nreturn ; \n} \n} \n"}
{"8458": "public class Slides { \nstatic public void execute ( URL url ) throws SlideExecutionException { \ncheckNotNull ( url ) ; \nScreenRegion screenRegion = new DesktopScreenRegion ( ) ; \nContext context = new Context ( screenRegion ) ; \nexecute ( url , context ) ; \nreturn ; \n} \n} \n"}
{"8459": "public class Slides { \nstatic public void execute ( File file ) throws SlideExecutionException { \ncheckNotNull ( file ) ; \ntry { \nexecute ( file . toURI ( ) . toURL ( ) ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new SlideExecutionException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"8471": "public class Logger { \npublic void trace ( @ Nullable final String message ) { \nlog ( LogLevel . TRACE , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8472": "public class Logger { \npublic void trace ( @ Nullable final String event , @ Nullable final String message ) { \nlog ( LogLevel . TRACE , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8473": "public class Logger { \npublic void debug ( @ Nullable final String message ) { \nlog ( LogLevel . DEBUG , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8474": "public class Logger { \npublic void debug ( @ Nullable final String event , @ Nullable final String message ) { \nlog ( LogLevel . DEBUG , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8475": "public class Logger { \npublic void info ( @ Nullable final String message ) { \nlog ( LogLevel . INFO , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8476": "public class Logger { \npublic void info ( @ Nullable final String event , @ Nullable final String message ) { \nlog ( LogLevel . INFO , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8477": "public class Logger { \npublic void info ( @ Nullable final String event , @ Nullable final String message , @ Nullable final String dataKey1 , @ Nullable final String dataKey2 , @ Nullable final Object dataValue1 , @ Nullable final Object dataValue2 ) { \ninfo ( event , message , dataKey1 , dataKey2 , dataValue1 , dataValue2 , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8478": "public class Logger { \npublic void warn ( @ Nullable final String message ) { \nlog ( LogLevel . WARN , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8479": "public class Logger { \npublic void warn ( @ Nullable final String event , @ Nullable final String message ) { \nlog ( LogLevel . WARN , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8480": "public class Logger { \npublic void error ( @ Nullable final String message ) { \nlog ( LogLevel . ERROR , DEFAULT_EVENT , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8481": "public class Logger { \npublic void error ( @ Nullable final String event , @ Nullable final String message ) { \nlog ( LogLevel . ERROR , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; \nreturn ; \n} \n} \n"}
{"8482": "public class LogBuilderAspect { \n@ Before ( \"call(* com.arpnetworking.steno.LogBuilder.log())\" ) public void addToContextLineAndMethod ( final JoinPoint joinPoint ) { \nfinal SourceLocation sourceLocation = joinPoint . getSourceLocation ( ) ; \nfinal LogBuilder targetLogBuilder = ( LogBuilder ) joinPoint . getTarget ( ) ; \ntargetLogBuilder . addContext ( \"line\" , String . valueOf ( sourceLocation . getLine ( ) ) ) ; \ntargetLogBuilder . addContext ( \"file\" , sourceLocation . getFileName ( ) ) ; \ntargetLogBuilder . addContext ( \"class\" , sourceLocation . getWithinType ( ) ) ; \nreturn ; \n} \n} \n"}
{"8483": "public class StenoSerializationHelper { \npublic static void startStenoWrapper ( final ILoggingEvent event , final String eventName , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper ) throws IOException { \nfinal StenoSerializationHelper . StenoLevel level = StenoSerializationHelper . StenoLevel . findByLogbackLevel ( event . getLevel ( ) ) ; \njsonGenerator . writeStartObject ( ) ; \njsonGenerator . writeObjectField ( \"time\" , ISO_DATE_TIME_FORMATTER . format ( Instant . ofEpochMilli ( event . getTimeStamp ( ) ) ) ) ; \njsonGenerator . writeObjectField ( \"name\" , eventName ) ; \njsonGenerator . writeObjectField ( \"level\" , level . name ( ) ) ; \nreturn ; \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal int contextValuesLength = values == null ? 0 : values . size ( ) ; \nfor ( int i = 0 ; \ni < keys . size ( ) ; \n++ i ) { \nfinal String key = keys . get ( i ) ; \nif ( i >= contextValuesLength ) { \njsonGenerator . writeObjectField ( key , null ) ; \n} \nelse { \nfinal Object value = values . get ( i ) ; \nif ( isSimpleType ( value ) ) { \njsonGenerator . writeObjectField ( key , value ) ; \n} \nelse { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8485": "public class StenoSerializationHelper { \npublic static void serializeThrowable ( final IThrowableProxy throwableProxy , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper ) throws IOException { \njsonGenerator . writeStringField ( \"type\" , throwableProxy . getClassName ( ) ) ; \njsonGenerator . writeStringField ( \"message\" , throwableProxy . getMessage ( ) ) ; \njsonGenerator . writeArrayFieldStart ( \"backtrace\" ) ; \nfor ( final StackTraceElementProxy ste : throwableProxy . getStackTraceElementProxyArray ( ) ) { \njsonGenerator . writeString ( ste . toString ( ) ) ; \n} \njsonGenerator . writeEndArray ( ) ; \njsonGenerator . writeObjectFieldStart ( \"data\" ) ; \nif ( throwableProxy instanceof ThrowableProxy ) { \nfinal JsonNode jsonNode = objectMapper . valueToTree ( ( ( ThrowableProxy ) throwableProxy ) . getThrowable ( ) ) ; \nfor ( final Iterator < Map . Entry < String , JsonNode > > iterator = jsonNode . fields ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal Map . Entry < String , JsonNode > field = iterator . next ( ) ; \njsonGenerator . writeFieldName ( field . getKey ( ) ) ; \nobjectMapper . writeValue ( jsonGenerator , field . getValue ( ) ) ; \n} \n} \nif ( throwableProxy . getSuppressed ( ) != null && throwableProxy . getSuppressed ( ) . length > 0 ) { \njsonGenerator . writeArrayFieldStart ( \"suppressed\" ) ; \nfor ( final IThrowableProxy suppressed : throwableProxy . getSuppressed ( ) ) { \njsonGenerator . writeStartObject ( ) ; \nserializeThrowable ( suppressed , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndArray ( ) ; \n} \nif ( throwableProxy . getCause ( ) != null ) { \njsonGenerator . writeObjectFieldStart ( \"cause\" ) ; \nserializeThrowable ( throwableProxy . getCause ( ) , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndObject ( ) ; \nreturn ; \n} \n} \n"}
{"8488": "public class SafeSerializationHelper { \npublic static void safeEncodeValue ( final StringBuilder encoder , @ Nullable final Object value ) { \nif ( value == null ) { \nencoder . append ( \"null\" ) ; \n} \nelse if ( value instanceof Map ) { \nsafeEncodeMap ( encoder , ( Map < ? , ? > ) value ) ; \n} \nelse if ( value instanceof List ) { \nsafeEncodeList ( encoder , ( List < ? > ) value ) ; \n} \nelse if ( value . getClass ( ) . isArray ( ) ) { \nsafeEncodeArray ( encoder , value ) ; \n} \nelse if ( value instanceof LogValueMapFactory . LogValueMap ) { \nsafeEncodeLogValueMap ( encoder , ( LogValueMapFactory . LogValueMap ) value ) ; \n} \nelse if ( value instanceof Throwable ) { \nsafeEncodeThrowable ( encoder , ( Throwable ) value ) ; \n} \nelse if ( StenoSerializationHelper . isSimpleType ( value ) ) { \nif ( value instanceof Boolean ) { \nencoder . append ( BooleanNode . valueOf ( ( Boolean ) value ) . toString ( ) ) ; \n} \nelse if ( value instanceof Double ) { \nencoder . append ( DoubleNode . valueOf ( ( Double ) value ) . toString ( ) ) ; \n} \nelse if ( value instanceof Float ) { \nencoder . append ( FloatNode . valueOf ( ( Float ) value ) . toString ( ) ) ; \n} \nelse if ( value instanceof Long ) { \nencoder . append ( LongNode . valueOf ( ( Long ) value ) . toString ( ) ) ; \n} \nelse if ( value instanceof Integer ) { \nencoder . append ( IntNode . valueOf ( ( Integer ) value ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( new TextNode ( value . toString ( ) ) . toString ( ) ) ; \n} \n} \nelse { \nsafeEncodeValue ( encoder , LogReferenceOnly . of ( value ) . toLogValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8489": "public class BeejuJUnitRule { \npublic void createDatabase ( String databaseName ) throws TException { \nHiveMetaStoreClient client = new HiveMetaStoreClient ( conf ( ) ) ; \nString databaseFolder = new File ( temporaryFolder . getRoot ( ) , databaseName ) . toURI ( ) . toString ( ) ; \ntry { \nclient . createDatabase ( new Database ( databaseName , null , databaseFolder , null ) ) ; \n} \nfinally { \nclient . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8490": "public class AbsObjectPool { \nprotected void checkMappings ( int arrayPosition ) { \nfinal int index = positions . indexOfValue ( arrayPosition ) ; \nif ( index >= 0 ) { \npositions . removeAt ( index ) ; \n} \nreturn ; \n} \n} \n"}
{"8492": "public class SaveAttrsUtility { \npublic static void saveDataToObjectInContext ( final Map < String , Object > context , final String saveAttr , final String strValue , final ExpressionEngine engine ) { \nint index = saveAttr . lastIndexOf ( '.' ) ; \nif ( index > 0 ) { \nString strObject = saveAttr . substring ( 0 , index ) ; \nString strMethod = saveAttr . substring ( index + 1 ) ; \nstrObject = TieConstants . METHOD_PREFIX + strObject + TieConstants . METHOD_END ; \nObject object = CommandUtility . evaluate ( strObject , context , engine ) ; \nCellControlsUtility . setObjectProperty ( object , strMethod , strValue , true ) ; \n} \nreturn ; \n} \n} \n"}
{"8493": "public class SaveAttrsUtility { \npublic static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { \nif ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) { \nreturn ; \n} \nint ipos = fullSaveAttr . indexOf ( '=' ) ; \nif ( ipos > 0 ) { \nString columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; \nString saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; \nCell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; \nif ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) { \nCommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8497": "public class SaveAttrsUtility { \npublic static void setSaveObjectsInHiddenColumn ( final Row row , final String saveAttr ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \ncell . setCellValue ( saveAttr ) ; \nreturn ; \n} \n} \n"}
{"8498": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { \nfor ( Row row : sheet ) { \nint rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) { \nsetSaveAttrsForRow ( row , saveCommentsMap ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8499": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForRow ( final Row row , final Map < String , String > saveCommentsMap ) { \nStringBuilder saveAttr = new StringBuilder ( ) ; \nfor ( Cell cell : row ) { \nString sAttr = parseSaveAttr ( cell , saveCommentsMap ) ; \nif ( ! sAttr . isEmpty ( ) ) { \nsaveAttr . append ( sAttr ) ; \n} \n} \nif ( saveAttr . length ( ) > 0 ) { \nSaveAttrsUtility . setSaveObjectsInHiddenColumn ( row , saveAttr . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8502": "public class ConfigBuildRef { \npublic final void putShiftAttrs ( final String fullName , final ConfigRangeAttrs attrs , final RowsMapping unitRowsMapping ) { \nattrs . setUnitRowsMapping ( unitRowsMapping ) ; \nthis . shiftMap . put ( fullName , attrs ) ; \nreturn ; \n} \n} \n"}
{"8503": "public class TieWebSheetBean { \npublic void setWb ( final Workbook pWb ) { \nthis . getSerialWb ( ) . setWb ( pWb ) ; \nthis . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) pWb ) ; \nreturn ; \n} \n} \n"}
{"8506": "public class TieWebSheetBean { \npublic void reCalcMaxColCounts ( ) { \nif ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { \nthis . maxColCounts = 0 ; \nreturn ; \n} \nint maxColumns = 0 ; \nfor ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { \nint counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; \nif ( maxColumns < counts ) { \nmaxColumns = counts ; \n} \n} \nthis . maxColCounts = maxColumns ; \nreturn ; \n} \n} \n"}
{"8510": "public class TieWebSheetBean { \npublic void doExport ( ) { \ntry { \nString fileName = this . getExportFileName ( ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nthis . getWb ( ) . write ( out ) ; \nInputStream stream = new BufferedInputStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; \nexportFile = new DefaultStreamedContent ( stream , \"application/force-download\" , fileName ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error in export file : \" + e . getLocalizedMessage ( ) , e ) ; \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"8511": "public class TieWebSheetBean { \npublic void doSave ( ) { \nthis . setSubmitMde ( false ) ; \nif ( ! this . getHelper ( ) . getValidationHandler ( ) . preValidation ( ) ) { \nLOG . fine ( \"Validation failded before saving\" ) ; \nreturn ; \n} \nprocessSave ( ) ; \nthis . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( RequestContext . getCurrentInstance ( ) , false ) ; \nreturn ; \n} \n} \n"}
{"8512": "public class TieWebSheetBean { \npublic void doSubmit ( ) { \nthis . setSubmitMde ( true ) ; \nif ( ! this . getHelper ( ) . getValidationHandler ( ) . preValidation ( ) ) { \nLOG . fine ( \"Validation failed before saving\" ) ; \nreturn ; \n} \nprocessSubmit ( ) ; \nthis . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( RequestContext . getCurrentInstance ( ) , false ) ; \nthis . setSubmitMde ( false ) ; \nreturn ; \n} \n} \n"}
{"8513": "public class TieWebSheetBean { \npublic void populateComponent ( final ComponentSystemEvent event ) { \nUIComponent component = event . getComponent ( ) ; \nint [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( component ) ; \nint row = rowcol [ 0 ] ; \nint col = rowcol [ 1 ] ; \nFacesCell fcell = CellUtility . getFacesCellFromBodyRow ( row , col , this . getBodyRows ( ) , this . getCurrent ( ) . getCurrentTopRow ( ) , this . getCurrent ( ) . getCurrentLeftColumn ( ) ) ; \nCellControlsUtility . populateAttributes ( component , fcell , this . getCellDefaultControl ( ) ) ; \nreturn ; \n} \n} \n"}
{"8515": "public class TieWebSheetBean { \nprivate void readObject ( final java . io . ObjectInputStream in ) throws IOException { \ntry { \nin . defaultReadObject ( ) ; \nrecover ( ) ; \n} \ncatch ( EncryptedDocumentException | ClassNotFoundException e ) { \nLOG . log ( Level . SEVERE , \" error in readObject of serialWorkbook : \" + e . getLocalizedMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \nreturn ; \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nint originFirstRow = areaPtg . getFirstRow ( ) ; \nint originLastRow = areaPtg . getLastRow ( ) ; \nint unitSize = 2 ; \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nint shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nif ( i < ( rowList . size ( ) - 1 ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \nreturn ; \n} \n} \n"}
{"8541": "public class CellControlsUtility { \npublic static void populateAttributes ( final UIComponent component , final FacesCell fcell , final Map < String , Map < String , String > > defaultControlMap ) { \nList < CellFormAttributes > inputAttrs = fcell . getInputAttrs ( ) ; \nString cname = findComponentNameFromClass ( component ) ; \nif ( cname == null ) { \nreturn ; \n} \nMap < String , String > defaultMap = defaultControlMap . get ( cname ) ; \nif ( defaultMap == null ) { \ndefaultMap = new HashMap < > ( ) ; \ndefaultControlMap . put ( cname , defaultMap ) ; \n} \nfor ( Map . Entry < String , String > entry : defaultMap . entrySet ( ) ) { \nsetObjectProperty ( component , entry . getKey ( ) , entry . getValue ( ) , true ) ; \n} \nfor ( CellFormAttributes attr : inputAttrs ) { \nString propertyName = attr . getType ( ) ; \nString propertyValue = attr . getValue ( ) ; \nif ( ! defaultMap . containsKey ( propertyName ) ) { \nString defaultValue = getObjectPropertyValue ( component , propertyName , true ) ; \ndefaultMap . put ( propertyName , defaultValue ) ; \n} \nsetObjectProperty ( component , propertyName , propertyValue , true ) ; \n} \nreturn ; \n} \n} \n"}
{"8543": "public class CellControlsUtility { \npublic static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { \ntry { \nString methodName = \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; \nAttributesType parameterType = matchParaMeterOfMethod ( obj , methodName ) ; \nif ( parameterType != null ) { \nMethod method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { \nparameterType . clazz } \n) ; \nmethod . invoke ( obj , convertToObject ( parameterType , propertyValue ) ) ; \n} \n} \ncatch ( Exception e ) { \nString msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; \nif ( ignoreNonExisting ) { \nLOG . log ( Level . FINE , msg , e ) ; \n} \nelse { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8545": "public class CellControlsUtility { \npublic static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { \nint rowIndex = originRowIndex ; \nif ( rowIndex < 0 ) { \nrowIndex = poiCell . getRowIndex ( ) ; \n} \nString skey = poiCell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; \nMap < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( \"$$\" ) ; \nif ( commentMap != null ) { \nString comment = commentMap . get ( skey ) ; \nif ( comment != null ) { \nCommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; \n} \n} \nString widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; \nif ( widgetType != null ) { \nfcell . setControl ( widgetType . toLowerCase ( ) ) ; \nfcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; \nfcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; \nfcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8547": "public class PicturesHelper { \npublic final void setupFacesCellPictureCharts ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { \nif ( parent . getPicturesMap ( ) != null ) { \nsetupFacesCellPicture ( sheet1 , fcell , cell , fId ) ; \n} \nif ( parent . getCharsData ( ) . getChartsMap ( ) != null ) { \nsetupFacesCellCharts ( sheet1 , fcell , cell , fId ) ; \n} \nreturn ; \n} \n} \n"}
{"8548": "public class PicturesHelper { \nprivate void setupFacesCellCharts ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { \ntry { \nString chartId = parent . getCharsData ( ) . getChartPositionMap ( ) . get ( fId ) ; \nif ( chartId != null ) { \nBufferedImage img = parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ; \nif ( img != null ) { \nfcell . setContainChart ( true ) ; \nfcell . setChartId ( chartId ) ; \nfcell . setChartStyle ( PicturesUtility . generateChartStyle ( sheet1 , fcell , cell , chartId , parent . getCharsData ( ) . getChartAnchorsMap ( ) ) ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"setupFacesCell Charts error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8549": "public class PicturesHelper { \nprivate void setupFacesCellPicture ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { \ntry { \nPicture pic = parent . getPicturesMap ( ) . get ( fId ) ; \nif ( pic != null ) { \nfcell . setContainPic ( true ) ; \nfcell . setPictureId ( fId ) ; \nfcell . setPictureStyle ( PicturesUtility . generatePictureStyle ( sheet1 , fcell , cell , pic ) ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"setupFacesCell Picture error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8550": "public class ChartHelper { \nprivate void initChartsMap ( final Workbook wb ) { \ntry { \nif ( wb instanceof XSSFWorkbook ) { \ninitXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"getChartsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8552": "public class ChartHelper { \npublic final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { \nif ( chart != null && style != null ) { \nBasicStroke stroke = ChartUtility . toStroke ( style ) ; \nPlot plot = chart . getPlot ( ) ; \nif ( plot instanceof CategoryPlot ) { \nCategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; \nCategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; \ntry { \ncir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse if ( plot instanceof XYPlot ) { \nXYPlot xyPlot = chart . getXYPlot ( ) ; \nXYItemRenderer xyir = xyPlot . getRenderer ( ) ; \ntry { \nxyir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse { \nLOG . log ( Level . FINE , \"setSeriesColor() unsupported plot: {}\" , plot . toString ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8554": "public class ChartHelper { \nprivate void setupBarStyle ( final JFreeChart chart , final ChartData chartData ) { \nsetupStyle ( chart , chartData ) ; \nCategoryPlot plot = ( CategoryPlot ) chart . getPlot ( ) ; \nBarRenderer renderer = ( BarRenderer ) plot . getRenderer ( ) ; \nrenderer . setBarPainter ( new StandardBarPainter ( ) ) ; \nrenderer . setItemMargin ( TieConstants . DEFAULT_BAR_STYLE_ITEM_MARGIN ) ; \nplot . setForegroundAlpha ( TieConstants . DEFAULT_BARSTYLE_FOREGROUND_ALPHA ) ; \nreturn ; \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { \nfor ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8557": "public class ChartHelper { \nprivate void initAnchorsMap ( final Workbook wb , final ChartsData chartsData ) { \ntry { \nif ( wb instanceof XSSFWorkbook ) { \nChartUtility . initXSSFAnchorsMap ( ( XSSFWorkbook ) wb , chartsData ) ; \n} \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Web Form getAnchorsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8558": "public class ChartHelper { \nprivate void generateSingleXSSFChart ( final XSSFChart chart , final String chartId , final XSSFSheet sheet , final Map < String , ClientAnchor > anchorMap , final Map < String , BufferedImage > chartMap , final Map < String , ChartData > chartDataMap ) { \nClientAnchor anchor ; \ntry { \nanchor = anchorMap . get ( chartId ) ; \nif ( anchor != null ) { \nChartData chartData = ChartUtility . initChartDataFromXSSFChart ( chartId , chart , ( XSSFWorkbook ) parent . getWb ( ) ) ; \nchartDataMap . put ( chartId , chartData ) ; \nJFreeChart jchart = createChart ( chartData ) ; \nif ( jchart != null ) { \nAnchorSize anchorSize = PicturesUtility . getAnchorSize ( sheet , null , null , anchor ) ; \nBufferedImage img = jchart . createBufferedImage ( anchorSize . getWidth ( ) , anchorSize . getHeight ( ) ) ; \nchartMap . put ( chartId , img ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"generate chart for \" + chartId + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8561": "public class ConfigurationUtility { \npublic static void reBuildUpperLevelFormula ( final ConfigBuildRef configBuildRef , final String actionFullName ) { \nMap < Cell , String > cachedMap = configBuildRef . getCachedCells ( ) ; \nMap < String , List < RowsMapping > > rowsMap = new HashMap < > ( ) ; \nfor ( Map . Entry < Cell , String > entry : cachedMap . entrySet ( ) ) { \nCell cell = entry . getKey ( ) ; \nString originFormula = entry . getValue ( ) ; \nif ( originFormula != null ) { \nsetupUpperLevelFormula ( cell , originFormula , actionFullName , rowsMap , configBuildRef ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8562": "public class ConfigurationUtility { \nprivate static void setupUpperLevelFormula ( final Cell cell , final String originFormula , final String actionFullName , final Map < String , List < RowsMapping > > rowsMap , final ConfigBuildRef configBuildRef ) { \nString fullName = getFullNameFromRow ( cell . getRow ( ) ) ; \nif ( actionFullName . startsWith ( fullName + \":\" ) ) { \nList < RowsMapping > currentRowsMappingList = rowsMap . get ( fullName ) ; \nif ( currentRowsMappingList == null ) { \ncurrentRowsMappingList = gatherRowsMappingByFullName ( configBuildRef , fullName ) ; \nrowsMap . put ( fullName , currentRowsMappingList ) ; \n} \nShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef ( configBuildRef . getWatchList ( ) , currentRowsMappingList ) ; \nshiftFormulaRef . setFormulaChanged ( 0 ) ; \nbuildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , originFormula ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { \nconfigBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8563": "public class ConfigurationUtility { \npublic static void buildCellFormulaForShiftedRows ( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final Cell cell , final String originFormula ) { \nif ( ( shiftFormulaRef . getWatchList ( ) != null ) && ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { \nPtg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; \nPtg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { \ncell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8565": "public class ConfigurationUtility { \npublic static void changeIndexNumberInShiftMap ( final Map < String , ConfigRangeAttrs > shiftMap , final Map < String , String > changeMap ) { \nfor ( Map . Entry < String , String > entry : changeMap . entrySet ( ) ) { \nString key = entry . getKey ( ) ; \nString newKey = entry . getValue ( ) ; \nConfigRangeAttrs attrs = shiftMap . get ( key ) ; \nif ( attrs != null ) { \nshiftMap . remove ( key ) ; \nshiftMap . put ( newKey , attrs ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < ( parts . length - 1 ) ; \ni ++ ) { \nif ( i == 0 ) { \nfname . append ( parts [ i ] ) ; \n} \nelse { \nfname . append ( \":\" ) . append ( parts [ i ] ) ; \n} \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \n} \nreturn ; \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nfor ( int i = startRowIndex ; \ni <= sheet . getLastRowNum ( ) ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { \nint sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nint sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( sufindex > 0 ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nint increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) { \nchangeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \n} \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \nelse { \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"8568": "public class ConfigurationUtility { \npublic static void setFullNameInHiddenColumn ( final Row row , final String fullName ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \ncell . setCellValue ( fullName ) ; \nreturn ; \n} \n} \n"}
{"8570": "public class ConfigurationUtility { \npublic static void setOriginalRowNumInHiddenColumn ( final Row row , final int rowNum ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \ncell . setCellValue ( Integer . toString ( rowNum ) ) ; \ncell . setCellType ( CellType . STRING ) ; \nreturn ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \nfor ( int col = caddress . getFirstColumn ( ) ; \ncol <= caddress . getLastColumn ( ) ; \ncol ++ ) { \nfor ( int row = caddress . getFirstRow ( ) ; \nrow <= caddress . getLastRow ( ) ; \nrow ++ ) { \nif ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { \ncontinue ; \n} \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8581": "public class ConfigurationUtility { \npublic static void buildSheetCommentFromAlias ( Sheet sheet , List < TieCommandAlias > tieCommandAliasList ) { \nif ( ( tieCommandAliasList == null ) || ( tieCommandAliasList . isEmpty ( ) ) ) { \nreturn ; \n} \nfor ( Row row : sheet ) { \nfor ( Cell cell : row ) { \nbuildCellCommentFromalias ( tieCommandAliasList , cell ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8582": "public class ConfigurationUtility { \nprivate static void buildCellCommentFromalias ( List < TieCommandAlias > tieCommandAliasList , Cell cell ) { \nString value = CellUtility . getCellValueWithoutFormat ( cell ) ; \nif ( ( value != null ) && ( ! value . isEmpty ( ) ) ) { \nfor ( TieCommandAlias alias : tieCommandAliasList ) { \nMatcher matcher = alias . getPattern ( ) . matcher ( value ) ; \nif ( matcher . find ( ) ) { \nCellUtility . createOrInsertComment ( cell , alias . getCommand ( ) ) ; \nif ( alias . isRemove ( ) ) { \nCellUtility . setCellValue ( cell , ParserUtility . removeCharsFromString ( value , matcher . start ( ) , matcher . end ( ) ) ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8587": "public class ConfigurationHandler { \npublic final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { \nif ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) { \nreturn ; \n} \ncheckAndRepairLastRow ( sheet ) ; \nint sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; \nList < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; \nboolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; \nList < String > formList = new ArrayList < > ( ) ; \nbuildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; \nmatchParentCommand ( commandList ) ; \nmatchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; \ninitTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; \nreturn ; \n} \n} \n"}
{"8588": "public class ConfigurationHandler { \nprivate final void checkAndRepairLastRow ( final Sheet sheet ) { \nRow lastrow = sheet . getRow ( sheet . getLastRowNum ( ) ) ; \nif ( lastrow != null ) { \nfor ( Cell cell : lastrow ) { \nif ( ( cell . getCellTypeEnum ( ) != CellType . _NONE ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { \nreturn ; \n} \n} \nsheet . removeRow ( lastrow ) ; \n} \nreturn ; \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nint matchIndex = - 1 ; \nConfigRange matchRange = null ; \nfor ( int j = 0 ; \nj < commandList . size ( ) ; \nj ++ ) { \nif ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \n} \nif ( matchIndex >= 0 ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \nreturn ; \n} \n} \n"}
{"8592": "public class ConfigurationHandler { \nprivate void matchCommandToSheetConfigForm ( final Map < String , SheetConfiguration > sheetConfigMap , final List < String > formList , final ConfigCommand command ) { \nfor ( String formname : formList ) { \nSheetConfiguration sheetConfig = sheetConfigMap . get ( formname ) ; \nif ( WebSheetUtility . insideRange ( command . getConfigRange ( ) , sheetConfig . getFormCommand ( ) . getConfigRange ( ) ) ) { \nsheetConfig . getFormCommand ( ) . getConfigRange ( ) . addCommand ( command ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"8593": "public class ConfigurationHandler { \nprivate void copyTemplateForTieCommands ( final Sheet sheet ) { \nif ( parent . isSkipConfiguration ( ) ) { \nreturn ; \n} \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( wb . getSheet ( copyName ) == null ) { \nSheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; \nint sheetIndex = wb . getSheetIndex ( newSheet ) ; \nwb . setSheetName ( sheetIndex , copyName ) ; \nwb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; \n} \nreturn ; \n} \n} \n"}
{"8595": "public class ConfigurationHandler { \nprivate void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { \nif ( ParserUtility . isWidgetMethodString ( line ) ) { \nParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; \n} \nelse if ( ParserUtility . isValidateMethodString ( line ) ) { \nParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; \n} \nelse { \nmoveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; \n} \nreturn ; \n} \n} \n"}
{"8596": "public class ConfigurationHandler { \nprivate void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { \nint nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; \nif ( nameEndIndex < 0 ) { \nString errMsg = \"Failed to parse command line [\" + line + \"]. Expected '\" + TieConstants . ATTR_PREFIX + \"' symbol.\" ; \nLOG . severe ( errMsg ) ; \nthrow new IllegalStateException ( errMsg ) ; \n} \nString commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; \nMap < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; \nConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; \nif ( configCommand != null ) { \ncList . add ( configCommand ) ; \n} \nreturn ; \n} \n} \n"}
{"8597": "public class ConfigurationHandler { \nprivate void moveCommentToMap ( final Cell cell , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { \nString cellKey = cell . getSheet ( ) . getSheetName ( ) + \"!$\" + cell . getColumnIndex ( ) + \"$\" + cell . getRowIndex ( ) ; \nParserUtility . parseCommentToMap ( cellKey , newComment , sheetCommentMap , normalComment ) ; \nreturn ; \n} \n} \n"}
{"8601": "public class ConfigurationHandler { \nprivate void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { \nString tempStr ; \nif ( fcommand . calcFooterLength ( ) == 0 ) { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; \n} \nelse { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + fcommand . calcBodyLength ( ) ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; \n} \nsheetConfig . setFormFooterRange ( tempStr ) ; \nsheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; \nreturn ; \n} \n} \n"}
{"8602": "public class ConfigurationHandler { \nprivate void setBodyOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int lastRow , final int rightCol ) { \nString tempStr ; \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + 1 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , lastRow + 1 ) ; \nsheetConfig . setFormBodyRange ( tempStr ) ; \nsheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; \nsheetConfig . setFormBodyType ( TieConstants . FORM_TYPE_FREE ) ; \nsheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; \nreturn ; \n} \n} \n"}
{"8603": "public class ConfigurationHandler { \nprivate void setHeaderOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { \nString tempStr ; \nif ( fcommand . calcHeaderLength ( ) == 0 ) { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; \n} \nelse { \ntempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + 1 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; \n} \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \nreturn ; \n} \n} \n"}
{"8605": "public class CommandUtility { \nprivate static void removeRangesFromShiftMap ( final NavigableMap < String , ConfigRangeAttrs > shiftMap , final List < String > removeFullNameList ) { \nfor ( String fname : removeFullNameList ) { \nshiftMap . remove ( fname ) ; \n} \nreturn ; \n} \n} \n"}
{"8609": "public class CommandUtility { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) private static void deleteObjectInContext ( final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { \nif ( ! ( lastCollection instanceof List ) ) { \nthrow new EvaluationException ( eachCommand . getVar ( ) + TieConstants . EACH_COMMAND_INVALID_MSG ) ; \n} \nList collectionList = ( List ) lastCollection ; \ncollectionList . remove ( lastCollectionIndex ) ; \ndataContext . remove ( eachCommand . getVar ( ) ) ; \nreturn ; \n} \n} \n"}
{"8611": "public class CommandUtility { \npublic static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nindexMap . put ( command . getCommandName ( ) , command ) ; \ncommand . getConfigRange ( ) . indexCommandRange ( indexMap ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nint srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nint srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { \ncopyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \n} \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( index > 0 ) { \nCellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \n} \nfor ( int rowIndex = srcStartRow ; \nrowIndex <= srcEndRow ; \nrowIndex ++ ) { \nif ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { \nunitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8614": "public class CommandUtility { \npublic static void evaluateNormalCells ( final Cell cell , final String strValue , final Map < String , Object > context , final ExpressionEngine engine ) { \nif ( strValue . contains ( TieConstants . METHOD_PREFIX ) ) { \nObject evaluationResult = evaluate ( strValue , context , engine ) ; \nif ( evaluationResult == null ) { \nevaluationResult = \"\" ; \n} \nCellUtility . setCellValue ( cell , evaluationResult . toString ( ) ) ; \ncreateTieCell ( cell , context , engine ) ; \n} \nreturn ; \n} \n} \n"}
{"8615": "public class CommandUtility { \nprivate static void evaluateUserFormula ( final Cell cell , final String strValue ) { \nString formulaStr = strValue . substring ( 2 , strValue . length ( ) - 1 ) ; \nif ( ( formulaStr != null ) && ( ! formulaStr . isEmpty ( ) ) ) { \ncell . setCellFormula ( formulaStr ) ; \n} \nreturn ; \n} \n} \n"}
{"8617": "public class CommandUtility { \npublic static void createCellComment ( final Cell cell , final String newComment , final Map < Cell , String > finalCommentMap ) { \nif ( newComment != null ) { \nfinalCommentMap . put ( cell , newComment ) ; \n} \nreturn ; \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \nfor ( int irow = rowIndexStart ; \nirow <= rowIndexEnd ; \nirow ++ ) { \nremoveCachedCellForRow ( sheet , irow , cachedMap ) ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { \nreturn ; \n} \nint lastRowNum = sheet . getLastRowNum ( ) ; \nif ( rowIndexEnd < lastRowNum ) { \nsheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \n} \nif ( rowIndexEnd == lastRowNum ) { \nfor ( int i = rowIndexEnd ; \ni >= rowIndexStart ; \ni -- ) { \nremoveSingleRowInSheet ( sheet , rowIndexStart ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8620": "public class CommandUtility { \nprivate static void removeSingleRowInSheet ( final Sheet sheet , final int rowIndexStart ) { \nRow removingRow = sheet . getRow ( rowIndexStart ) ; \nif ( removingRow != null ) { \nsheet . removeRow ( removingRow ) ; \n} \nreturn ; \n} \n} \n"}
{"8621": "public class CommandUtility { \nprivate static void removeCachedCellForRow ( final Sheet sheet , final int rowIndexStart , final Map < Cell , String > cachedMap ) { \nRow removingRow = sheet . getRow ( rowIndexStart ) ; \nif ( removingRow != null ) { \nfor ( Cell cell : removingRow ) { \ncachedMap . remove ( cell ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { \nreturn ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nfor ( int rowIndex = rowIndexEnd ; \nrowIndex >= rowIndexStart ; \nrowIndex -- ) { \nbodyRows . remove ( rowIndex - top ) ; \n} \nfor ( int irow = rowIndexStart - top ; \nirow < bodyRows . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \n} \nreturn ; \n} \n} \n"}
{"8631": "public class CellUtility { \nprivate static void setCellValueString ( final Cell c , final String value ) { \nc . setCellType ( CellType . STRING ) ; \nc . setCellValue ( value ) ; \nreturn ; \n} \n} \n"}
{"8632": "public class CellUtility { \nprivate static void setCellValueBoolean ( final Cell c , final String value ) { \nif ( \"Y\" . equalsIgnoreCase ( value ) || \"Yes\" . equalsIgnoreCase ( value ) || \"True\" . equalsIgnoreCase ( value ) ) { \nc . setCellValue ( true ) ; \n} \nelse { \nc . setCellValue ( false ) ; \n} \nreturn ; \n} \n} \n"}
{"8633": "public class CellUtility { \nprivate static void setCellValueDate ( final Cell c , final String value ) { \nString date = WebSheetUtility . parseDate ( value ) ; \nsetCellValueString ( c , date ) ; \nreturn ; \n} \n} \n"}
{"8634": "public class CellUtility { \nprivate static void setCellValueNumber ( final Cell c , final String value ) { \ndouble val = Double . parseDouble ( value . replace ( Character . toString ( ',' ) , \"\" ) ) ; \nc . setCellType ( CellType . NUMERIC ) ; \nc . setCellValue ( val ) ; \nreturn ; \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nint length = srcRowEnd - srcRowStart + 1 ; \nif ( length <= 0 ) { \nreturn ; \n} \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \ncopySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \n} \nfor ( int i = 0 ; \ni < srcSheet . getNumMergedRegions ( ) ; \ni ++ ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { \nint targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nint targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8636": "public class CellUtility { \nprivate static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { \nRow newRow = destSheet . getRow ( destinationRowNum ) ; \nRow sourceRow = srcSheet . getRow ( sourceRowNum ) ; \nif ( newRow == null ) { \nnewRow = destSheet . createRow ( destinationRowNum ) ; \n} \nnewRow . setHeight ( sourceRow . getHeight ( ) ) ; \nfor ( int i = 0 ; \ni < sourceRow . getLastCellNum ( ) ; \ni ++ ) { \ncopyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; \n} \nif ( setHiddenColumn ) { \nConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"8638": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static void copyCellSetValue ( final Cell sourceCell , final Cell newCell , final boolean checkLock ) { \nCellStyle newCellStyle = newCell . getCellStyle ( ) ; \nString name = sourceCell . getCellTypeEnum ( ) . toString ( ) ; \nCellValueType e = Enum . valueOf ( CellValueType . class , name ) ; \ne . setCellValue ( newCell , sourceCell , checkLock , newCellStyle ) ; \nreturn ; \n} \n} \n"}
{"8639": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static void copyCellSetStyle ( final Sheet destSheet , final Cell sourceCell , final Cell newCell ) { \nCellStyle newCellStyle = getCellStyleFromSourceCell ( destSheet , sourceCell ) ; \nnewCell . setCellStyle ( newCellStyle ) ; \nif ( sourceCell . getHyperlink ( ) != null ) { \nnewCell . setHyperlink ( sourceCell . getHyperlink ( ) ) ; \n} \nnewCell . setCellType ( sourceCell . getCellTypeEnum ( ) ) ; \nreturn ; \n} \n} \n"}
{"8640": "public class CellUtility { \npublic static void cloneComment ( final Cell sourceCell , final Cell newCell ) { \nXSSFSheet sheet = ( XSSFSheet ) newCell . getSheet ( ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nXSSFComment sourceComment = ( XSSFComment ) sourceCell . getCellComment ( ) ; \nClientAnchor anchor = createCommentAnchor ( newCell , factory ) ; \nComment comment = drawing . createCellComment ( anchor ) ; \nRichTextString str = factory . createRichTextString ( sourceComment . getString ( ) . toString ( ) ) ; \ncomment . setString ( str ) ; \ncomment . setAuthor ( sourceComment . getAuthor ( ) ) ; \nnewCell . setCellComment ( comment ) ; \ncomment . setColumn ( newCell . getColumnIndex ( ) ) ; \ncomment . setRow ( newCell . getRowIndex ( ) ) ; \nmatchCommentSettings ( newCell , sourceCell ) ; \nreturn ; \n} \n} \n"}
{"8642": "public class CellUtility { \npublic static void createOrInsertComment ( final Cell cell , final String commentStr ) { \nXSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nComment comment = cell . getCellComment ( ) ; \nString originStr = \"\" ; \nif ( comment == null ) { \nClientAnchor anchor = createCommentAnchor ( cell , factory ) ; \ncomment = drawing . createCellComment ( anchor ) ; \n} \nelse { \noriginStr = comment . getString ( ) . getString ( ) + \"\\n\" ; \n} \noriginStr += commentStr ; \nRichTextString str = factory . createRichTextString ( originStr ) ; \ncomment . setString ( str ) ; \ncomment . setAuthor ( \"\" ) ; \ncell . setCellComment ( comment ) ; \ncomment . setColumn ( cell . getColumnIndex ( ) ) ; \ncomment . setRow ( cell . getRowIndex ( ) ) ; \nreturn ; \n} \n} \n"}
{"8643": "public class CellUtility { \nprivate static void matchCommentSettings ( final Cell newCell , final Cell sourceCell ) { \ntry { \nXSSFVMLDrawing sourceVml = getVmlDrawingFromCell ( sourceCell ) ; \nXSSFVMLDrawing targetVml = getVmlDrawingFromCell ( newCell ) ; \nCTShape sourceCtShape = getCtShapeFromVml ( sourceCell , sourceVml ) ; \nCTShape targetCtShape = getCtShapeFromVml ( newCell , targetVml ) ; \ntargetCtShape . setType ( sourceCtShape . getType ( ) ) ; \nCTClientData sourceClientData = sourceCtShape . getClientDataArray ( 0 ) ; \nCTClientData targetClientData = targetCtShape . getClientDataArray ( 0 ) ; \nString [ ] anchorArray = sourceClientData . getAnchorList ( ) . get ( 0 ) . split ( \",\" ) ; \nint shiftRows = newCell . getRowIndex ( ) - sourceCell . getRowIndex ( ) ; \nanchorArray [ 2 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 2 ] . trim ( ) ) + shiftRows ) ; \nanchorArray [ 6 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 6 ] . trim ( ) ) + shiftRows ) ; \ntargetClientData . getAnchorList ( ) . set ( 0 , FacesUtility . strJoin ( anchorArray , \",\" ) ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"matchCommentSettings error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8647": "public class CellUtility { \npublic static void convertCell ( final SheetConfiguration sheetConfig , final FacesCell fcell , final Cell poiCell , final Map < String , CellRangeAddress > cellRangeMap , final int originRowIndex , final CellAttributesMap cellAttributesMap , final String saveAttrs ) { \nCellRangeAddress caddress ; \nString key = getCellIndexNumberKey ( poiCell ) ; \ncaddress = cellRangeMap . get ( key ) ; \nif ( caddress != null ) { \nfcell . setColspan ( caddress . getLastColumn ( ) - caddress . getFirstColumn ( ) + 1 ) ; \nfcell . setRowspan ( caddress . getLastRow ( ) - caddress . getFirstRow ( ) + 1 ) ; \n} \nCellControlsUtility . setupControlAttributes ( originRowIndex , fcell , poiCell , sheetConfig , cellAttributesMap ) ; \nfcell . setHasSaveAttr ( SaveAttrsUtility . isHasSaveAttr ( poiCell , saveAttrs ) ) ; \nreturn ; \n} \n} \n"}
{"8658": "public class SerialRow { \nprivate void writeObject ( final java . io . ObjectOutputStream out ) throws IOException { \nthis . rowIndex = this . getRow ( ) . getRowNum ( ) ; \nout . defaultWriteObject ( ) ; \nreturn ; \n} \n} \n"}
{"8659": "public class RowsMapping { \npublic final void removeRow ( final Integer sourceRowNum , final Row targetRow ) { \nList < SerialRow > mapRowList = rowsMap . get ( sourceRowNum ) ; \nif ( mapRowList != null ) { \nmapRowList . remove ( new SerialRow ( targetRow , - 1 ) ) ; \nrowsMap . put ( sourceRowNum , mapRowList ) ; \n} \nreturn ; \n} \n} \n"}
{"8660": "public class RowsMapping { \npublic final void mergeMap ( final RowsMapping addMap ) { \nMap < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; \nfor ( Map . Entry < Integer , List < SerialRow > > entry : map . entrySet ( ) ) { \nList < SerialRow > entryRowList = entry . getValue ( ) ; \nif ( ( entryRowList != null ) && ( ! entryRowList . isEmpty ( ) ) ) { \nfor ( SerialRow row : entryRowList ) { \nthis . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8661": "public class RowsMapping { \npublic final void recover ( final Sheet sheet ) { \nfor ( Map . Entry < Integer , List < SerialRow > > entry : this . getRowsMap ( ) . entrySet ( ) ) { \nList < SerialRow > listRow = entry . getValue ( ) ; \nfor ( SerialRow serialRow : listRow ) { \nserialRow . recover ( sheet ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8665": "public class ChartUtility { \npublic static void setUpChartData ( final ChartData chartData , final CTChart ctChart , final ThemesTable themeTable , final ChartObject ctObj ) { \nObject chartObj = null ; \n@ SuppressWarnings ( \"rawtypes\" ) List plotCharts = ctObj . getChartListFromCtChart ( ctChart ) ; \nif ( plotCharts != null && ( ! plotCharts . isEmpty ( ) ) ) { \nchartObj = plotCharts . get ( 0 ) ; \n} \nif ( chartObj != null ) { \n@ SuppressWarnings ( \"rawtypes\" ) List bsers = ctObj . getSerListFromCtObjChart ( chartObj ) ; \nif ( ! AppUtils . emptyList ( bsers ) ) { \nchartData . buildCategoryList ( ctObj . getCtAxDataSourceFromSerList ( bsers ) ) ; \nchartData . buildSeriesList ( bsers , themeTable , ctObj ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8666": "public class ChartUtility { \npublic static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { \nMap < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; \nMap < String , String > positionMap = charsData . getChartPositionMap ( ) ; \nanchortMap . clear ( ) ; \npositionMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \ninitXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8667": "public class ChartUtility { \nprivate static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nCTDrawing ctDrawing = drawing . getCTDrawing ( ) ; \nif ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { \nreturn ; \n} \nList < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; \nfor ( int j = 0 ; \nj < alist . size ( ) ; \nj ++ ) { \nCTTwoCellAnchor ctanchor = alist . get ( j ) ; \nString singleChartId = getAnchorAssociateChartId ( ctanchor ) ; \nif ( singleChartId != null ) { \nString chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; \nint dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; \nint dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; \nint dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; \nint dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; \nint col1 = ctanchor . getFrom ( ) . getCol ( ) ; \nint row1 = ctanchor . getFrom ( ) . getRow ( ) ; \nint col2 = ctanchor . getTo ( ) . getCol ( ) ; \nint row2 = ctanchor . getTo ( ) . getRow ( ) ; \nanchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; \npositionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8671": "public class CellHelper { \npublic final void saveDataInContext ( final Cell poiCell , final String strValue ) { \nString saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , this ) ; \nif ( saveAttr != null ) { \nSaveAttrsUtility . saveDataToObjectInContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , strValue , parent . getExpEngine ( ) ) ; \nparent . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( RequestContext . getCurrentInstance ( ) , true ) ; \n} \nreturn ; \n} \n} \n"}
{"8672": "public class CellHelper { \npublic final void reCalc ( ) { \nparent . getFormulaEvaluator ( ) . clearAllCachedResultValues ( ) ; \ntry { \nparent . getFormulaEvaluator ( ) . evaluateAll ( ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \" recalc formula error : \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) { \nreturn ; \n} \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nint listSize = list . size ( ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ( ! stopSkip ) && ( i < listSize ) ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) { \nskip = true ; \n} \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \n} \nif ( stopSkip ) { \nparent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"8679": "public class ConfigRange { \npublic final void shiftRowRef ( final Sheet sheet , final int shiftnum ) { \ntry { \nthis . setFirstRowRef ( sheet . getRow ( attrs . getFirstRowAddr ( ) . getRow ( ) + shiftnum ) . getCell ( attrs . getFirstRowAddr ( ) . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) , false ) ; \nthis . setLastRowPlusRef ( sheet , attrs . getLastRowPlusAddr ( ) . getColumn ( ) , attrs . getLastRowPlusAddr ( ) . getRow ( ) + shiftnum - 1 , false ) ; \nif ( commandList != null ) { \nfor ( ConfigCommand command : commandList ) { \ncommand . shiftRowRef ( sheet , shiftnum ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"shiftRowRef error =\" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8680": "public class ConfigRange { \npublic final void setFirstRowRef ( final Cell pFirstRowRef , final boolean alsoCreateAddr ) { \nthis . attrs . setFirstRowRef ( pFirstRowRef ) ; \nif ( alsoCreateAddr ) { \nthis . setFirstRowAddr ( new SerialCellAddress ( pFirstRowRef ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8681": "public class ConfigRange { \npublic final void setLastRowPlusRef ( final Sheet sheet , final int rightCol , final int lastRow , final boolean alsoSetAddr ) { \nif ( ( lastRow >= 0 ) && ( sheet != null ) && ( rightCol >= 0 ) ) { \nRow row = sheet . getRow ( lastRow + 1 ) ; \nif ( row == null ) { \nrow = sheet . createRow ( lastRow + 1 ) ; \n} \nCell cell = row . getCell ( rightCol ) ; \nif ( cell == null ) { \ncell = row . getCell ( rightCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nthis . attrs . setLastCellCreated ( true ) ; \n} \nelse { \nthis . attrs . setLastCellCreated ( false ) ; \n} \nthis . attrs . setLastRowPlusRef ( cell ) ; \nif ( alsoSetAddr ) { \nthis . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; \n} \n} \nelse { \nthis . attrs . setLastRowPlusRef ( null ) ; \nif ( alsoSetAddr ) { \nthis . attrs . setLastRowPlusAddr ( null ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8682": "public class ConfigRange { \nprivate void buildCellsForRow ( final Row row , final String fullName , final Map < String , Object > context , final ConfigBuildRef configBuildRef , ShiftFormulaRef shiftFormulaRef ) { \nif ( ( row == null ) || ! ConfigurationUtility . isStaticRowRef ( this , row ) ) { \nreturn ; \n} \nfor ( Cell cell : row ) { \nbuildSingleCell ( cell , context , configBuildRef , shiftFormulaRef ) ; \n} \nConfigurationUtility . setFullNameInHiddenColumn ( row , fullName ) ; \nreturn ; \n} \n} \n"}
{"8683": "public class ConfigRange { \nprivate void buildSingleCell ( final Cell cell , final Map < String , Object > context , final ConfigBuildRef configBuildRef , final ShiftFormulaRef shiftFormulaRef ) { \ntry { \nCommandUtility . evaluate ( context , cell , configBuildRef . getEngine ( ) ) ; \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nString originFormula = cell . getCellFormula ( ) ; \nshiftFormulaRef . setFormulaChanged ( 0 ) ; \nConfigurationUtility . buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , cell . getCellFormula ( ) ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { \nconfigBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"build cell ( row = \" + cell . getRowIndex ( ) + \" column = \" + cell . getColumnIndex ( ) + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8684": "public class SerialDataContext { \nprivate void readObject ( final java . io . ObjectInputStream in ) throws IOException { \ntry { \nin . defaultReadObject ( ) ; \nGson objGson = new GsonBuilder ( ) . setPrettyPrinting ( ) . create ( ) ; \nType listType = new TypeToken < Map < String , Object > > ( ) { \n} \n. getType ( ) ; \nthis . dataContext = objGson . fromJson ( mapToJson , listType ) ; \n} \ncatch ( EncryptedDocumentException | ClassNotFoundException e ) { \nLOG . log ( Level . SEVERE , \" error in readObject of serialWorkbook : \" + e . getLocalizedMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8685": "public class ChartData { \npublic final void buildCategoryList ( final CTAxDataSource ctAxDs ) { \nList < ParsedCell > cells = new ArrayList < > ( ) ; \ntry { \nString fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow ++ ) { \nfor ( int col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol ++ ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; \n} \nthis . setCategoryList ( cells ) ; \nreturn ; \n} \n} \n"}
{"8686": "public class ChartData { \n@ SuppressWarnings ( \"rawtypes\" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < ChartSeries > lseriesList = new ArrayList < > ( ) ; \ntry { \nfor ( int index = 0 ; \nindex < bsers . size ( ) ; \nindex ++ ) { \nObject ctObjSer = bsers . get ( index ) ; \nChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; \nlseriesList . add ( ctSer ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildSerialList\" , ex ) ; \n} \nthis . setSeriesList ( lseriesList ) ; \nreturn ; \n} \n} \n"}
{"8690": "public class SheetConfiguration { \npublic final void setCommandIndexMap ( final Map < String , Command > pcommandIndexMap ) { \nif ( pcommandIndexMap instanceof HashMap ) { \nthis . commandIndexMap = ( HashMap < String , Command > ) pcommandIndexMap ; \n} \nelse { \nthis . commandIndexMap = new HashMap < > ( ) ; \nthis . commandIndexMap . putAll ( pcommandIndexMap ) ; \n} \nreturn ; \n} \n} \n"}
{"8691": "public class PicturesUtility { \npublic static void getPictruesMap ( final Workbook wb , final Map < String , Picture > picMap ) { \nif ( wb instanceof XSSFWorkbook ) { \ngetXSSFPictruesMap ( ( XSSFWorkbook ) wb , picMap ) ; \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"8692": "public class PicturesUtility { \nprivate static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { \npicMap . clear ( ) ; \nList < XSSFPictureData > pictures = wb . getAllPictures ( ) ; \nif ( pictures . isEmpty ( ) ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nfor ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { \ntry { \nindexPictureInMap ( picMap , sheet , dr ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \nreturn ; \nreturn ; \n} \n} \n"}
{"8693": "public class PicturesUtility { \nprivate static void indexPictureInMap ( final Map < String , Picture > picMap , final XSSFSheet sheet , final POIXMLDocumentPart dr ) { \nif ( dr instanceof XSSFDrawing ) { \nXSSFDrawing drawing = ( XSSFDrawing ) dr ; \nList < XSSFShape > shapes = drawing . getShapes ( ) ; \nfor ( XSSFShape shape : shapes ) { \nif ( shape instanceof XSSFPicture ) { \nXSSFPicture pic = ( XSSFPicture ) shape ; \nXSSFClientAnchor anchor = pic . getPreferredSize ( ) ; \nCTMarker ctMarker = anchor . getFrom ( ) ; \nString picIndex = WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , ctMarker . getRow ( ) , ctMarker . getCol ( ) ) ; \npicMap . put ( picIndex , pic ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8699": "public class SerialCell { \npublic final void recover ( final Sheet sheet ) { \nif ( this . cellAddr != null ) { \nthis . setCell ( sheet . getRow ( this . cellAddr . getRow ( ) ) . getCell ( this . cellAddr . getColumn ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8709": "public class CellStyleUtility { \npublic static void setupCellStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nif ( ( cellStyle != null ) && ( ! cellStyle . getLocked ( ) ) ) { \nif ( fcell . getInputType ( ) . isEmpty ( ) ) { \nfcell . setInputType ( CellStyleUtility . getInputTypeFromCellType ( poiCell ) ) ; \n} \nif ( fcell . getControl ( ) . isEmpty ( ) && ( ! fcell . getInputType ( ) . isEmpty ( ) ) ) { \nfcell . setControl ( \"text\" ) ; \n} \nsetInputStyleBaseOnInputType ( fcell , poiCell ) ; \n} \nString webStyle = getCellStyle ( wb , poiCell , fcell . getInputType ( ) ) + getCellFontStyle ( wb , poiCell ) + getRowStyle ( wb , poiCell , fcell . getInputType ( ) , rowHeight , fcell . getRowspan ( ) ) ; \nfcell . setStyle ( webStyle ) ; \nfcell . setColumnStyle ( getColumnStyle ( wb , fcell , poiCell , rowHeight ) ) ; \nreturn ; \n} \n} \n"}
{"8723": "public class TieWebSheetView { \npublic void setTieCommandAliasList ( String aliasListJson ) { \nGson gson = new Gson ( ) ; \nType aliasListType = new TypeToken < ArrayList < TieCommandAlias > > ( ) { \n} \n. getType ( ) ; \nthis . tieCommandAliasList = gson . fromJson ( aliasListJson , aliasListType ) ; \nreturn ; \n} \n} \n"}
{"8725": "public class FormCommand { \nprivate void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { \nString formula = cell . getCellFormula ( ) ; \nPtg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; \nfor ( int k = 0 ; \nk < ptgs . length ; \nk ++ ) { \nObject ptg = ptgs [ k ] ; \nint areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( areaInt >= 0 ) { \naddToWatchList ( areaInt , lastStaticRow , watchList ) ; \n} \n} \ncell . setCellType ( CellType . STRING ) ; \ncell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; \nreturn ; \n} \n} \n"}
{"8726": "public class FormCommand { \nprivate void addToWatchList ( final int addRow , final int lastStaticRow , final List < Integer > watchList ) { \nif ( ( addRow > lastStaticRow ) && ! ( watchList . contains ( addRow ) ) ) { \nwatchList . add ( addRow ) ; \n} \nreturn ; \n} \n} \n"}
{"8728": "public class ParserUtility { \npublic static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { \nreturn ; \n} \nint widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; \nint elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; \nif ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) { \nreturn ; \n} \nString type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) { \nreturn ; \n} \nString key = getAttributeKeyInMapByCell ( cell ) ; \ncellAttributesMap . getCellInputType ( ) . put ( key , type ) ; \nList < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; \nif ( inputs == null ) { \ninputs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; \n} \nparseInputAttributes ( inputs , values ) ; \nparseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; \nreturn ; \n} \n} \n"}
{"8730": "public class ParserUtility { \npublic static void parseValidateAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { \nreturn ; \n} \nif ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ) { \nreturn ; \n} \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) { \nreturn ; \n} \nString key = getAttributeKeyInMapByCell ( cell ) ; \nList < CellFormAttributes > attrs = cellAttributesMap . getCellValidateAttributes ( ) . get ( key ) ; \nif ( attrs == null ) { \nattrs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellValidateAttributes ( ) . put ( key , attrs ) ; \n} \nparseValidateAttributes ( attrs , values ) ; \nreturn ; \n} \n} \n"}
{"8733": "public class ParserUtility { \npublic static void parseInputAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { \nclist . clear ( ) ; \nif ( controlAttrs != null ) { \nString [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; \nfor ( String cattr : cattrs ) { \nString [ ] details = splitByEualSign ( cattr ) ; \nif ( details . length > 1 ) { \nCellFormAttributes attr = new CellFormAttributes ( ) ; \nattr . setType ( details [ 0 ] . trim ( ) ) ; \nattr . setValue ( details [ 1 ] . replaceAll ( \"\\\"\" , \"\" ) ) ; \nclist . add ( attr ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8734": "public class ParserUtility { \npublic static void parseValidateAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { \nif ( controlAttrs == null ) { \nreturn ; \n} \nString [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; \nCellFormAttributes attr = new CellFormAttributes ( ) ; \nfor ( String cattr : cattrs ) { \nextractValidationAttributes ( attr , cattr ) ; \n} \nif ( ( attr . getValue ( ) != null ) && ( ! attr . getValue ( ) . isEmpty ( ) ) ) { \nclist . add ( attr ) ; \n} \nreturn ; \n} \n} \n"}
{"8736": "public class ParserUtility { \npublic static void parseSpecialAttributes ( final String key , final String type , final List < CellFormAttributes > inputs , final CellAttributesMap cellAttributesMap ) { \nSpecialAttributes sAttr = new SpecialAttributes ( ) ; \nfor ( CellFormAttributes attr : inputs ) { \ngatherSpecialAttributes ( type , sAttr , attr ) ; \n} \nif ( sAttr . selectLabels != null ) { \nprocessSelectItemAttributes ( key , cellAttributesMap , sAttr ) ; \n} \nif ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) { \nprocessCalendarAttributes ( key , cellAttributesMap , sAttr ) ; \n} \nreturn ; \n} \n} \n"}
{"8737": "public class ParserUtility { \nprivate static void processCalendarAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \ncellAttributesMap . getCellDatePattern ( ) . put ( key , sAttr . defaultDatePattern ) ; \nreturn ; \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) { \nsmap = new LinkedHashMap < > ( ) ; \n} \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) { \nsmap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \n} \nfor ( int i = 0 ; \ni < sAttr . selectLabels . length ; \ni ++ ) { \nsmap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \n} \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \nreturn ; \n} \n} \n"}
{"8739": "public class ParserUtility { \nprivate static void gatherSpecialAttributes ( final String type , final SpecialAttributes sAttr , final CellFormAttributes attr ) { \nString attrKey = attr . getType ( ) ; \nif ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_LABELS ) ) { \nsAttr . selectLabels = attr . getValue ( ) . split ( \";\" ) ; \n} \nif ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_VALUES ) ) { \nsAttr . selectValues = attr . getValue ( ) . split ( \";\" ) ; \n} \nif ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_LABEL ) ) { \nsAttr . defaultSelectLabel = attr . getValue ( ) ; \n} \nif ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_VALUE ) ) { \nsAttr . defaultSelectValue = attr . getValue ( ) ; \n} \nif ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) && attrKey . equalsIgnoreCase ( TieConstants . WIDGET_ATTR_PATTERN ) ) { \nsAttr . defaultDatePattern = attr . getValue ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8740": "public class ParserUtility { \npublic static void parseCommentToMap ( final String cellKey , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { \nif ( ( newComment != null ) && ( ! newComment . trim ( ) . isEmpty ( ) ) ) { \nString commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; \nif ( ! normalComment ) { \ncommentKey = newComment . substring ( 0 , newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; \n} \nMap < String , String > map = sheetCommentMap . get ( commentKey ) ; \nif ( map == null ) { \nmap = new HashMap < > ( ) ; \n} \nmap . put ( cellKey , newComment ) ; \nsheetCommentMap . put ( commentKey , map ) ; \n} \nreturn ; \n} \n} \n"}
{"8751": "public class WebSheetUtility { \npublic static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { \ntry { \nMethod method = obj . getClass ( ) . getMethod ( \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) , new Class [ ] { \nString . class } \n) ; \nmethod . invoke ( obj , propertyValue ) ; \n} \ncatch ( Exception e ) { \nString msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; \nif ( ignoreNonExisting ) { \nLOG . info ( msg ) ; \n} \nelse { \nLOG . warning ( msg ) ; \nthrow new IllegalArgumentException ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8754": "public class WebSheetUtility { \npublic static void clearHiddenColumns ( final Sheet sheet ) { \nfor ( Row row : sheet ) { \nif ( row . getLastCellNum ( ) > TieConstants . MAX_COLUMNS_IN_SHEET ) { \ndeleteHiddenColumnsInRow ( row ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8755": "public class WebSheetUtility { \nprivate static void deleteHiddenColumnsInRow ( final Row row ) { \ndeleteCellFromRow ( row , TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; \ndeleteCellFromRow ( row , TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN ) ; \ndeleteCellFromRow ( row , TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; \nreturn ; \n} \n} \n"}
{"8756": "public class WebSheetUtility { \nprivate static void deleteCellFromRow ( final Row row , final int cellNum ) { \nCell cell = row . getCell ( cellNum ) ; \nif ( cell != null ) { \nrow . removeCell ( cell ) ; \n} \nreturn ; \n} \n} \n"}
{"8757": "public class PostConstructApplicationEventListener { \n@ Override public final void processEvent ( final SystemEvent event ) { \nLOGGER . log ( Level . INFO , \"Running on TieFaces {0}\" , AppUtils . getBuildVersion ( ) ) ; \nreturn ; \n} \n} \n"}
{"8758": "public class ValidationHandler { \nprivate void refreshAfterStatusChanged ( final boolean oldStatus , final boolean newStatus , final int formRow , final int formCol , final FacesCell cell , final boolean updateGui ) { \nif ( ! newStatus ) { \ncell . setErrormsg ( \"\" ) ; \n} \ncell . setInvalid ( newStatus ) ; \nif ( updateGui && ( oldStatus != newStatus ) && ( parent . getWebFormClientId ( ) != null ) ) { \nRequestContext . getCurrentInstance ( ) . update ( parent . getWebFormClientId ( ) + \":\" + ( formRow ) + \":group\" + ( formCol ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8768": "public class ValidationHandler { \nprivate void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { \nUIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; \nif ( s == null ) { \nreturn ; \n} \nDataTable webDataTable = ( DataTable ) s ; \nint first = webDataTable . getFirst ( ) ; \nint rowsToRender = webDataTable . getRowsToRender ( ) ; \nint rowCounts = webDataTable . getRowCount ( ) ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nfor ( int i = first ; \ni <= ( first + rowsToRender ) ; \ni ++ ) { \nif ( i < rowCounts ) { \nrefreshCachedCellsInRow ( tblName , top , left , i ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8769": "public class ValidationHandler { \nprivate void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { \nFacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; \nint isize = dataRow . getCells ( ) . size ( ) ; \nfor ( int index = 0 ; \nindex < isize ; \nindex ++ ) { \nFacesCell fcell = dataRow . getCells ( ) . get ( index ) ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; \nif ( poiCell != null ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8770": "public class ValidationHandler { \npublic void setSubmitModeInView ( final Boolean fullflag ) { \nif ( FacesContext . getCurrentInstance ( ) != null ) { \nMap < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; \nif ( viewMap != null ) { \nBoolean flag = ( Boolean ) viewMap . get ( TieConstants . SUBMITMODE ) ; \nif ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) { \nviewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8772": "public class CellAttributesMap { \npublic final void clear ( ) { \nif ( this . templateCommentMap != null ) { \nthis . templateCommentMap . clear ( ) ; \n} \nif ( this . cellDatePattern != null ) { \nthis . cellDatePattern . clear ( ) ; \n} \nif ( this . cellInputAttributes != null ) { \nthis . cellInputAttributes . clear ( ) ; \n} \nif ( this . cellInputType != null ) { \nthis . cellInputType . clear ( ) ; \n} \nif ( this . cellSelectItemsAttributes != null ) { \nthis . cellSelectItemsAttributes . clear ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nint bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nint left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nint totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) { \nparent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \n} \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( top < 0 ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \nfor ( int i = top ; \ni <= bottom ; \ni ++ ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \n} \nparent . setShowLineNumber ( false ) ; \n} \nreturn ; \n} \n} \n"}
{"8775": "public class WebSheetLoader { \nprivate void fillToMaxColumns ( final List < HeaderCell > headercells ) { \nif ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { \nint fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; \nfor ( int s = 0 ; \ns < fills ; \ns ++ ) { \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8780": "public class WebSheetLoader { \nprivate void clearWorkbook ( ) { \nparent . setFormulaEvaluator ( null ) ; \nparent . setDataFormatter ( null ) ; \nparent . setSheetConfigMap ( null ) ; \nparent . setTabs ( null ) ; \nparent . getSerialDataContext ( ) . setDataContext ( null ) ; \nparent . setPicturesMap ( null ) ; \nparent . setHeaderRows ( null ) ; \nparent . setBodyRows ( null ) ; \nparent . setWb ( null ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nparent . getCharsData ( ) . getChartsMap ( ) . clear ( ) ; \nparent . getCharsData ( ) . getChartDataMap ( ) . clear ( ) ; \nparent . getCharsData ( ) . getChartAnchorsMap ( ) . clear ( ) ; \nparent . getCharsData ( ) . getChartPositionMap ( ) . clear ( ) ; \nparent . getCellAttributesMap ( ) . clear ( ) ; \nreturn ; \n} \n} \n"}
{"8781": "public class WebSheetLoader { \nprivate void initTabs ( ) { \nparent . setTabs ( new ArrayList < TabModel > ( ) ) ; \nif ( parent . getSheetConfigMap ( ) != null ) { \nfor ( String key : parent . getSheetConfigMap ( ) . keySet ( ) ) { \nparent . getTabs ( ) . add ( new TabModel ( \"form_\" + key , key , \"form\" ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8782": "public class WebSheetLoader { \nprivate void loadData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nif ( parent . isAdvancedContext ( ) ) { \nparent . getSerialDataContext ( ) . getDataContext ( ) . put ( \"tiecells\" , new HashMap < String , TieCell > ( ) ) ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nList < RowsMapping > currentRowsMappingList = null ; \nConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; \nint length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , currentRowsMappingList ) ; \nsheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; \nsheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; \nsheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; \nsheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; \nsheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; \nsheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; \nsheetConfig . setBodyPopulated ( true ) ; \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \nreturn ; \n} \n} \n"}
{"8783": "public class WebSheetLoader { \npublic void refreshData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nfor ( int irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; \nirow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ; \nirow ++ ) { \nrefreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; \n} \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \nreturn ; \n} \n} \n"}
{"8784": "public class WebSheetLoader { \nprivate void refreshDataForRow ( Row row ) { \nif ( row == null ) { \nreturn ; \n} \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nif ( saveAttrList != null ) { \nString [ ] saveAttrs = saveAttrList . split ( \",\" ) ; \nfor ( String fullSaveAttr : saveAttrs ) { \nrefreshDataForCell ( row , fullSaveAttr ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8785": "public class WebSheetLoader { \nprivate void refreshDataForCell ( Row row , String fullSaveAttr ) { \nif ( fullSaveAttr != null ) { \ntry { \nString fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; \nif ( fullName != null ) { \nparent . getCellHelper ( ) . restoreDataContext ( fullName ) ; \nSaveAttrsUtility . refreshSheetRowFromContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , fullSaveAttr , row , parent . getExpEngine ( ) ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"refreshDataForCell with fullAaveAttr =\" + fullSaveAttr + \" error = \" + ex . getMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8787": "public class WebSheetLoader { \npublic final void loadWorkSheet ( final String tabName ) { \nprepareWorkShee ( tabName ) ; \nparent . getValidationHandler ( ) . validateCurrentPage ( ) ; \ncreateDynamicColumns ( tabName ) ; \nsetDataTablePage ( 0 ) ; \nparent . getCurrent ( ) . setCurrentDataContextName ( null ) ; \nsaveObjs ( ) ; \nif ( ( RequestContext . getCurrentInstance ( ) != null ) && ( parent . getClientId ( ) != null ) ) { \nRequestContext . getCurrentInstance ( ) . update ( parent . getClientId ( ) + \":websheettab\" ) ; \n} \nreturn ; \n} \n} \n"}
{"8788": "public class WebSheetLoader { \npublic final void prepareWorkShee ( final String tabName ) { \nint tabIndex = findTabIndexWithName ( tabName ) ; \nif ( parent . getWebFormTabView ( ) != null ) { \nparent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; \n} \nparent . getCurrent ( ) . setCurrentTabName ( tabName ) ; \nString sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nparent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; \nparent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; \nloadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; \nloadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; \nreturn ; \n} \n} \n"}
{"8789": "public class WebSheetLoader { \nprivate void setDataTablePage ( final int first ) { \nif ( parent . getWebFormClientId ( ) != null ) { \nfinal DataTable d = ( DataTable ) FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . findComponent ( parent . getWebFormClientId ( ) ) ; \nif ( d != null ) { \nd . setFirst ( first ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8790": "public class WebSheetLoader { \nprivate void saveObjs ( ) { \ntry { \nif ( FacesContext . getCurrentInstance ( ) != null ) { \nMap < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; \nviewMap . put ( \"currentTabName\" , parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nviewMap . put ( TieConstants . SUBMITMODE , parent . getSubmitMode ( ) ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"saveobjs in viewMap error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8791": "public class WebSheetLoader { \nprivate void setupRowInfo ( final FacesRow facesRow , final Sheet sheet1 , final Row row , final int rowIndex , final boolean allowAdd ) { \nfacesRow . setAllowAdd ( allowAdd ) ; \nif ( row != null ) { \nfacesRow . setRendered ( ! row . getZeroHeight ( ) ) ; \nfacesRow . setRowheight ( row . getHeight ( ) ) ; \nint rowNum = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nfacesRow . setOriginRowIndex ( rowNum ) ; \n} \nelse { \nfacesRow . setRendered ( true ) ; \nfacesRow . setRowheight ( sheet1 . getDefaultRowHeight ( ) ) ; \nfacesRow . setOriginRowIndex ( rowIndex ) ; \n} \nreturn ; \n} \n} \n"}
{"8792": "public class WebSheetLoader { \nprivate void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nclearCache ( ) ; \nfor ( int i = top ; \ni <= bottom ; \ni ++ ) { \nparent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nsheetConfig . setBodyPopulated ( true ) ; \nparent . getCurrent ( ) . setCurrentTopRow ( top ) ; \nparent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; \nreturn ; \n} \n} \n"}
{"8794": "public class WebSheetLoader { \npublic final void refreshCachedCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) && ( tblName != null ) ) { \ntry { \nprocessRefreshCell ( tblName , i , index , cell , fcell ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"refresh Cached Cell error : \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8795": "public class WebSheetLoader { \nprivate void processRefreshCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { \nString newValue = CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) ; \nif ( parent . getCachedCells ( ) . isValueChanged ( cell , newValue ) ) { \nif ( fcell . isHasSaveAttr ( ) ) { \nparent . getCellHelper ( ) . saveDataInContext ( cell , newValue ) ; \n} \nRequestContext . getCurrentInstance ( ) . update ( tblName + \":\" + i + \":cocalc\" + index ) ; \nparent . getCachedCells ( ) . put ( cell , CellType . FORMULA ) ; \n} \nreturn ; \n} \n} \n"}
{"8796": "public class WebSheetLoader { \nprivate void createDynamicColumns ( final String tabName ) { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nparent . getColumns ( ) . clear ( ) ; \nfor ( int i = left ; \ni <= right ; \ni ++ ) { \nparent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8797": "public class WebSheetLoader { \npublic final void addRepeatRow ( final int rowIndex ) { \ntry { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nSheet sheet = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; \nConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , sheet , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; \nconfigBuildRef . setAddMode ( true ) ; \nconfigBuildRef . setCollectionObjNameMap ( sheetConfig . getCollectionObjNameMap ( ) ) ; \nconfigBuildRef . setCommandIndexMap ( sheetConfig . getCommandIndexMap ( ) ) ; \nconfigBuildRef . setShiftMap ( sheetConfig . getShiftMap ( ) ) ; \nconfigBuildRef . setWatchList ( sheetConfig . getWatchList ( ) ) ; \nint length = CommandUtility . addRow ( configBuildRef , rowIndex , parent . getSerialDataContext ( ) . getDataContext ( ) ) ; \nrefreshBodyRowsInRange ( configBuildRef . getInsertPosition ( ) , length , sheet , sheetConfig ) ; \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \ncatch ( AddRowException e ) { \nFacesContext . getCurrentInstance ( ) . addMessage ( null , new FacesMessage ( FacesMessage . SEVERITY_ERROR , \"Add Row Error\" , e . getMessage ( ) ) ) ; \nLOG . log ( Level . SEVERE , \"Add row error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Add row error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"8798": "public class WebSheetLoader { \nprivate void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nfor ( int irow = insertPosition ; \nirow < ( insertPosition + length ) ; \nirow ++ ) { \nparent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nfor ( int irow = insertPosition + length - top ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; \n} \nreturn ; \n} \n} \n"}
{"8799": "public class WebSheetLoader { \npublic void setUnsavedStatus ( final RequestContext requestContext , final Boolean statusFlag ) { \nif ( requestContext != null ) { \nLOG . log ( Level . FINE , \"run setUnsavedState( {} )\" , statusFlag . toString ( ) ) ; \nrequestContext . execute ( \"setUnsavedState(\" + statusFlag . toString ( ) + \")\" ) ; \n} \nreturn ; \n} \n} \n"}
{"8802": "public class BinaryData { \nprotected static void writeInputStreamToOutput ( final Context context , final InputStream source , final OutputStream output ) throws IOException { \nBuffersPool pool = BeansManager . get ( context ) . getContainer ( ) . getBean ( BuffersPool . class ) ; \nIoUtils . transfer ( source , output , pool ) ; \nreturn ; \n} \n} \n"}
{"8803": "public class CacheEntry { \nprotected static void writeLong ( final Writer writer , final long value ) throws IOException { \nwriter . write ( new StringBuilder ( ) . append ( value ) . append ( '\\n' ) . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"8804": "public class CacheEntry { \nprotected final void writeString ( final Writer writer , final String line ) throws IOException { \nif ( line != null ) { \nwriter . write ( line + '\\n' ) ; \n} \nelse { \nwriter . write ( '\\n' ) ; \n} \nreturn ; \n} \n} \n"}
{"8805": "public class BaseRequestBuilder { \nprotected void setConvertedTrafficStatsTag ( final String tag ) { \nresult . statsTag = Utils . getTrafficStatsTag ( tag ) ; \nif ( config . isDebugRest ( ) ) { \nLog . d ( TAG , \"TrafficStats tag <\" + tag + \">=\" + Integer . toHexString ( result . statsTag ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8806": "public class BaseRequestBuilder { \nprotected void addBitmap ( final String name , final Bitmap bitmap , final String fileName ) { \nfinal BitmapBinaryData bdata = new BitmapBinaryData ( ) ; \nbdata . setName ( name ) ; \nbdata . setContentName ( fileName ) ; \nbdata . setBitmap ( bitmap ) ; \nresult . addBinaryData ( bdata ) ; \nreturn ; \n} \n} \n"}
{"8807": "public class BaseRequestBuilder { \nprotected void addFileDescriptor ( final String name , final AssetFileDescriptor fd , final String contentType , final String fileName ) { \nfinal AssetFdBinaryData bdata = new AssetFdBinaryData ( ) ; \nbdata . setFileDescriptor ( fileName , fd ) ; \nbdata . setName ( name ) ; \nbdata . setContentType ( contentType ) ; \nresult . addBinaryData ( bdata ) ; \nreturn ; \n} \n} \n"}
{"8810": "public class BaseRequestBuilder { \npublic void clear ( ) { \nfinal RequestDescription result = this . result ; \nresult . simpleParameters . children . clear ( ) ; \nresult . clearBinaryData ( ) ; \nresult . contentType = null ; \nresult . clearHeaders ( ) ; \nreturn ; \n} \n} \n"}
{"8811": "public class StreamingPlaybackController { \nprotected void callPlay ( final Uri uri , final int volume , final Bundle params ) { \nplaying = true ; \npaused = false ; \ncontext . startService ( createPlayIntent ( ) . setData ( uri ) . putExtra ( StreamingPlaybackService . EXTRA_VOLUME , volume ) . putExtra ( StreamingPlaybackService . EXTRA_TRACK_INFO , params ) ) ; \nbind ( ) ; \nonPlayingChanged ( ) ; \npreparing = true ; \nonPreparingChanged ( ) ; \nreturn ; \n} \n} \n"}
{"8812": "public class StreamingPlaybackController { \nprotected void callStop ( ) { \nplaying = false ; \npaused = false ; \ncontext . startService ( createStopIntent ( ) ) ; \nonPlayingChanged ( ) ; \npreparing = false ; \nonPreparingChanged ( ) ; \nreturn ; \n} \n} \n"}
{"8813": "public class StreamingPlaybackController { \nprotected final void bind ( ) { \nif ( bindRequested ) { \nreturn ; \n} \nfinal boolean result = context . bindService ( createBindIntent ( ) , serviceConnection , 0 ) ; \nif ( DEBUG ) { \nLog . v ( TAG , \"Bind to streaming service: \" + result ) ; \n} \nbindRequested = result ; \nonBind ( result ) ; \nreturn ; \n} \n} \n"}
{"8814": "public class StreamingPlaybackController { \nprotected final void unbind ( ) { \nif ( streamingPlayback != null ) { \ndropListener ( ) ; \n} \ntry { \ncontext . unbindService ( serviceConnection ) ; \n} \ncatch ( final RuntimeException e ) { \nif ( DEBUG ) { \nLog . w ( TAG , \"Cannot unbind radio\" , e ) ; \n} \n} \nbindRequested = false ; \nreturn ; \n} \n} \n"}
{"8815": "public class StreamingPlaybackController { \nprotected final void dropListener ( ) { \nif ( DEBUG ) { \nLog . v ( TAG , \"Drop listener\" ) ; \n} \nif ( streamingPlayback != null ) { \ntry { \nstreamingPlayback . removeListener ( ) ; \n} \ncatch ( final RemoteException e ) { \nLog . e ( TAG , \"Cannot remove listener\" , e ) ; \n} \nbindRequested = false ; \n} \nreturn ; \n} \n} \n"}
{"8816": "public class ImageRequest { \npublic void storeToDisk ( ) throws IOException { \nif ( manager . isPresentOnDisk ( url ) ) { \nreturn ; \n} \nif ( ! hasAllowedSize ( ) ) { \nIoUtils . consumeStream ( getRemoteInputStream ( ) , manager . getBuffersPool ( ) ) ; \nreturn ; \n} \nImageResult result = decodeStream ( getRemoteInputStream ( ) , true ) ; \nif ( result . getType ( ) == ImageSourceType . NETWORK && result . getBitmap ( ) != null ) { \nwriteBitmapToDisk ( result . getBitmap ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8819": "public class StringPart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendData(OutputStream)\" ) ; \n} \nout . write ( getContent ( ) ) ; \nreturn ; \n} \n} \n"}
{"8821": "public class PoolableBufferedInputStream { \n@ Override public void close ( ) throws IOException { \nfinal byte [ ] localBuf = buf ; \nbuf = null ; \nfinal InputStream localIn = in ; \nin = null ; \npool . release ( localBuf ) ; \nif ( localIn != null ) { \nlocalIn . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8823": "public class PoolableBufferedInputStream { \n@ Override public synchronized void reset ( ) throws IOException { \nif ( buf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nif ( - 1 == markpos ) { \nthrow new IOException ( \"Mark has been invalidated.\" ) ; \n} \npos = markpos ; \nreturn ; \n} \n} \n"}
{"8824": "public class Part { \nprotected void sendStart ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendStart(OutputStream out)\" ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( getPartBoundary ( ) ) ; \nout . write ( CRLF_BYTES ) ; \nreturn ; \n} \n} \n"}
{"8825": "public class Part { \nprotected void sendDispositionHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendDispositionHeader(OutputStream out)\" ) ; \n} \nout . write ( CONTENT_DISPOSITION_BYTES ) ; \nout . write ( QUOTE_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( getName ( ) ) ) ; \nout . write ( QUOTE_BYTES ) ; \nreturn ; \n} \n} \n"}
{"8826": "public class Part { \nprotected void sendContentTypeHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendContentTypeHeader(OutputStream out)\" ) ; \n} \nfinal String contentType = getContentType ( ) ; \nif ( contentType != null ) { \nout . write ( CRLF_BYTES ) ; \nout . write ( CONTENT_TYPE_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( contentType ) ) ; \nfinal String charSet = getCharSet ( ) ; \nif ( charSet != null ) { \nout . write ( CHARSET_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( charSet ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8827": "public class Part { \nprotected void sendTransferEncodingHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendTransferEncodingHeader(OutputStream out)\" ) ; \n} \nfinal String transferEncoding = getTransferEncoding ( ) ; \nif ( transferEncoding != null ) { \nout . write ( CRLF_BYTES ) ; \nout . write ( CONTENT_TRANSFER_ENCODING_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( transferEncoding ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8828": "public class Part { \nprotected void sendEndOfHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendEndOfHeader(OutputStream out)\" ) ; \n} \nout . write ( CRLF_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \nreturn ; \n} \n} \n"}
{"8829": "public class Part { \nprotected void sendEnd ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendEnd(OutputStream out)\" ) ; \n} \nout . write ( CRLF_BYTES ) ; \nreturn ; \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nif ( partBoundary == null || partBoundary . length == 0 ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \nreturn ; \n} \n} \n"}
{"8833": "public class WebsockifyProxyHandler { \nprivate void sendNotModified ( ChannelHandlerContext ctx ) { \nHttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , HttpResponseStatus . NOT_MODIFIED ) ; \nsetDateHeader ( response ) ; \nctx . getChannel ( ) . write ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; \nreturn ; \n} \n} \n"}
{"8834": "public class WebsockifyProxyHandler { \nprivate void setDateHeader ( HttpResponse response ) { \nSimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; \ndateFormatter . setTimeZone ( TimeZone . getTimeZone ( HTTP_DATE_GMT_TIMEZONE ) ) ; \nCalendar time = new GregorianCalendar ( ) ; \nresponse . setHeader ( HttpHeaders . Names . DATE , dateFormatter . format ( time . getTime ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"8835": "public class WebsockifyProxyHandler { \nprivate void setDateAndCacheHeaders ( HttpResponse response , File fileToCache ) { \nSimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; \ndateFormatter . setTimeZone ( TimeZone . getTimeZone ( HTTP_DATE_GMT_TIMEZONE ) ) ; \nCalendar time = new GregorianCalendar ( ) ; \nresponse . setHeader ( HttpHeaders . Names . DATE , dateFormatter . format ( time . getTime ( ) ) ) ; \ntime . add ( Calendar . SECOND , HTTP_CACHE_SECONDS ) ; \nresponse . setHeader ( HttpHeaders . Names . EXPIRES , dateFormatter . format ( time . getTime ( ) ) ) ; \nresponse . setHeader ( HttpHeaders . Names . CACHE_CONTROL , \"private, max-age=\" + HTTP_CACHE_SECONDS ) ; \nresponse . setHeader ( HttpHeaders . Names . LAST_MODIFIED , dateFormatter . format ( new Date ( fileToCache . lastModified ( ) ) ) ) ; \nreturn ; \n} \n} \n"}
{"8836": "public class WebsockifyProxyHandler { \nprivate void setContentTypeHeader ( HttpResponse response , File file ) { \nMimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap ( ) ; \nresponse . setHeader ( HttpHeaders . Names . CONTENT_TYPE , mimeTypesMap . getContentType ( file . getPath ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"8837": "public class WebsockifyProxyHandler { \nstatic void closeOnFlush ( Channel ch ) { \nif ( ch . isConnected ( ) ) { \nch . write ( ChannelBuffers . EMPTY_BUFFER ) . addListener ( ChannelFutureListener . CLOSE ) ; \n} \nreturn ; \n} \n} \n"}
{"8838": "public class FilePart { \n@ Override protected void sendDispositionHeader ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( \"FilePart\" , \"enter sendDispositionHeader(OutputStream out)\" ) ; \n} \nsuper . sendDispositionHeader ( out ) ; \nfinal String filename = this . source . getFileName ( ) ; \nif ( filename != null ) { \nout . write ( FILE_NAME_BYTES ) ; \nout . write ( QUOTE_BYTES ) ; \nout . write ( EncodingUtils . getAsciiBytes ( filename ) ) ; \nout . write ( QUOTE_BYTES ) ; \n} \nreturn ; \n} \n} \n"}
{"8839": "public class FilePart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendData(OutputStream out)\" ) ; \n} \nif ( lengthOfData ( ) == 0 ) { \nif ( DEBUG ) { \nLog . d ( TAG , \"No data to send.\" ) ; \n} \nreturn ; \n} \nfinal int size = 4096 ; \nfinal byte [ ] tmp = new byte [ size ] ; \nfinal InputStream instream = source . createInputStream ( ) ; \ntry { \nint len ; \nwhile ( ( len = instream . read ( tmp ) ) >= 0 ) { \nout . write ( tmp , 0 , len ) ; \n} \n} \nfinally { \ninstream . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8840": "public class BaseFileResponseCache { \nprotected void install ( final int version ) throws IOException { \nif ( buffersPool == null ) { \nthrow new IllegalStateException ( \"Buffers pool is not resolved\" ) ; \n} \ndiskCache = DiskLruCache . open ( ensureWorkingDirectory ( ) , version , ENTRIES_COUNT , getMaxSize ( ) ) ; \nonCacheInstalled ( ) ; \nreturn ; \n} \n} \n"}
{"8843": "public class BaseFileResponseCache { \nprivate InputStream newBodyInputStream ( final DiskLruCache . Snapshot snapshot ) { \nreturn new FilterInputStream ( snapshot . getInputStream ( ENTRY_BODY ) ) { \n@ Override public void close ( ) throws IOException { \nsnapshot . close ( ) ; \nsuper . close ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"8844": "public class BufferBitmapDecorator { \nprotected void reset ( final int width , final int height ) { \nBitmap bitmap = this . bitmap ; \nif ( bitmap != null ) { \nbitmap . recycle ( ) ; \n} \nbitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; \nthis . bitmap = bitmap ; \nthis . bitmapCanvas = new Canvas ( bitmap ) ; \nreturn ; \n} \n} \n"}
{"8846": "public class WebsockifySslContext { \npublic static void validateKeystore ( String keystore , String password , String keyPassword ) throws KeyManagementException , UnrecoverableKeyException , IOException , NoSuchAlgorithmException , CertificateException , KeyStoreException { \ngetSSLContext ( keystore , password , keyPassword ) ; \nreturn ; \n} \n} \n"}
{"8848": "public class LocationBinder { \npublic void stopListening ( ) { \nif ( locationManager == null ) { \nreturn ; \n} \nif ( DEBUG ) { \nLog . d ( TAG , \"Stop location listening...\" ) ; \n} \nif ( listener != null ) { \nlistener . onLocationStop ( ) ; \n} \nmyHandler . removeMessages ( MSG_STOP_FINE_PROVIDER ) ; \nlocationManager . removeUpdates ( coarseListener ) ; \nlocationManager . removeUpdates ( fineListener ) ; \nlocationManager = null ; \nreturn ; \n} \n} \n"}
{"8850": "public class RequestMethod { \nprotected void disconnect ( final URLConnection connection ) { \nfinal URLConnection http = UrlConnectionWrapper . unwrap ( connection ) ; \nif ( http instanceof HttpURLConnection ) { \n( ( HttpURLConnection ) http ) . disconnect ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8851": "public class ApplicationServiceSupport { \npublic void bind ( ) { \nif ( serviceObject != null ) { \nreturn ; \n} \nfinal Context context = contextRef . get ( ) ; \nif ( context == null ) { \nreturn ; \n} \nfinal Intent intent = new Intent ( context , GoroService . class ) ; \nintent . setAction ( getInterfaceClass ( ) . getName ( ) ) ; \nif ( DEBUG_CALLS ) { \nLog . v ( TAG , \"Attempt to bind to service \" + this + \"/\" + context , new RuntimeException ( ) ) ; \n} \ncontext . startService ( intent ) ; \nfinal boolean bindResult = context . bindService ( intent , this , 0 ) ; \nif ( DEBUG ) { \nLog . v ( TAG , \"Binded to service: \" + bindResult + \", \" + context + \", interface: \" + getInterfaceClass ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8852": "public class ApplicationServiceSupport { \npublic void unbind ( ) { \nif ( serviceObject == null ) { \nreturn ; \n} \nserviceObject = null ; \nfinal Context context = contextRef . get ( ) ; \nif ( DEBUG ) { \nLog . v ( TAG , \"Unbind \" + context + \" from \" + getInterfaceClass ( ) ) ; \n} \nif ( context == null ) { \nreturn ; \n} \ntry { \ncontext . unbindService ( this ) ; \n} \ncatch ( final Exception e ) { \nif ( DEBUG ) { \nLog . e ( TAG , \"Cannot unbind from application service\" , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8853": "public class ViewImageConsumer { \npublic void notifyAboutViewChanges ( ) { \nfinal T view = this . view ; \nif ( view != null && view instanceof ImagesLoadListenerProvider ) { \nthis . listener = ( ( ImagesLoadListenerProvider ) view ) . getImagesLoadListener ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8854": "public class DirectProxyHandler { \n@ Override public void channelOpen ( final ChannelHandlerContext ctx , final ChannelStateEvent e ) throws Exception { \ntry { \nensureTargetConnection ( e . getChannel ( ) , false , null ) ; \n} \ncatch ( Exception ex ) { \ne . getChannel ( ) . close ( ) ; \nex . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8856": "public class RequestBuilderLoader { \n@ Override protected void onReset ( ) { \nif ( DEBUG ) { \nLog . v ( TAG , \"onReset \" + this ) ; \n} \nsuper . onReset ( ) ; \nonStopLoading ( ) ; \nif ( receivedResponse != null ) { \nonReleaseData ( receivedResponse ) ; \nreceivedResponse = null ; \n} \nreturn ; \n} \n} \n"}
{"8857": "public class RequestBuilderLoader { \nvoid waitForLoader ( final long time ) { \ntry { \ndone . await ( time , TimeUnit . MILLISECONDS ) ; \n} \ncatch ( final InterruptedException e ) { \nLog . e ( TAG , \"waitForLoader() ininterrupted\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8858": "public class GUIUtils { \npublic static void setTextOrHide ( final TextView view , final CharSequence text , final int hvisibility ) { \nif ( TextUtils . isEmpty ( text ) ) { \nview . setVisibility ( hvisibility ) ; \n} \nelse { \nview . setText ( text ) ; \nview . setVisibility ( View . VISIBLE ) ; \n} \nreturn ; \n} \n} \n"}
{"8859": "public class GUIUtils { \npublic static void hideSoftInput ( final View textView ) { \ntry { \nfinal InputMethodManager imm = ( InputMethodManager ) textView . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; \nimm . hideSoftInputFromWindow ( textView . getWindowToken ( ) , 0 ) ; \n} \ncatch ( final Exception e ) { \nLog . w ( TAG , \"Ignore exception\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8860": "public class GUIUtils { \npublic static void showSoftInput ( final View textView ) { \ntry { \nfinal InputMethodManager imm = ( InputMethodManager ) textView . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; \nimm . showSoftInput ( textView , InputMethodManager . SHOW_FORCED ) ; \n} \ncatch ( final Exception e ) { \nLog . w ( TAG , \"Ignore exception\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8861": "public class GUIUtils { \npublic static void toggleSoftInput ( final View textView ) { \ntry { \nfinal InputMethodManager imm = ( InputMethodManager ) textView . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; \nimm . toggleSoftInputFromWindow ( textView . getWindowToken ( ) , 0 , 0 ) ; \n} \ncatch ( final Exception e ) { \nLog . w ( TAG , \"Ignore exception\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"8863": "public class PortUnificationHandler { \n@ Override public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { \ncancelDirectConnectionTimer ( ) ; \nLogger . getLogger ( PortUnificationHandler . class . getName ( ) ) . severe ( \"Exception on connection to \" + ctx . getChannel ( ) . getRemoteAddress ( ) + \": \" + e . getCause ( ) . getMessage ( ) ) ; \nreturn ; \n} \n} \n"}
{"8865": "public class ImagesManager { \npublic void populateImage ( final View view , final String url ) { \nfinal Object tag = view . getTag ( ) ; \nImageConsumer consumer = null ; \nif ( tag == null ) { \nconsumer = createImageConsumer ( view ) ; \nview . setTag ( consumer ) ; \n} \nelse { \nif ( ! ( tag instanceof ImageConsumer ) ) { \nthrow new IllegalStateException ( \"View already has a tag \" + tag + \". Cannot store consumer\" ) ; \n} \nconsumer = ( ImageConsumer ) tag ; \n} \npopulateImage ( consumer , url ) ; \nreturn ; \n} \n} \n"}
{"8866": "public class ImagesManager { \npublic void cancelImageLoading ( final View view ) { \ncheckThread ( ) ; \nfinal Object tag = view . getTag ( ) ; \nif ( tag != null && tag instanceof ImageConsumer ) { \ncancelImageLoading ( ( ImageConsumer ) tag ) ; \n} \nreturn ; \n} \n} \n"}
{"8868": "public class ImagesManager { \nprotected final void setResultImage ( final ImageConsumer consumer , final ImageResult result , final boolean animate ) { \ndecorateResult ( consumer , result ) ; \nconsumer . setImage ( createDrawable ( result . getBitmap ( ) ) , animate ) ; \nconsumer . reset ( ) ; \nreturn ; \n} \n} \n"}
{"8869": "public class ImagesManager { \nprivate void setLoadingImage ( final ImageConsumer consumer ) { \nif ( ! consumer . skipLoadingImage ( ) ) { \nDrawable d = getLoadingDrawable ( consumer ) ; \nif ( ! consumer . hasUndefinedSize ( ) || ( d . getIntrinsicWidth ( ) != 0 && d . getIntrinsicHeight ( ) != 0 ) ) { \nconsumer . setLoadingImage ( d ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8870": "public class ImagesManager { \nprivate void startImageLoaderTask ( final ImageConsumer consumer , final ImageRequest request ) { \nfinal String key = request . getKey ( ) ; \nif ( debug ) { \nLog . d ( TAG , \"Key \" + key ) ; \n} \nImageLoader loader = currentLoads . get ( key ) ; \nif ( loader != null ) { \nfinal boolean added = loader . addTarget ( consumer ) ; \nif ( ! added ) { \nloader = null ; \n} \n} \nif ( loader == null ) { \nif ( debug ) { \nLog . d ( TAG , \"Start a new task\" ) ; \n} \nloader = new ImageLoader ( request , this ) ; \nif ( ! loader . addTarget ( consumer ) ) { \nthrow new IllegalStateException ( \"Cannot add target to the new loader\" ) ; \n} \ncurrentLoads . put ( key , loader ) ; \nif ( debug ) { \nLog . d ( TAG , \"Current loaders count: \" + currentLoads . size ( ) ) ; \n} \nfinal Executor executor = getImageTaskExecutor ( ) ; \nexecutor . execute ( loader . future ) ; \n} \nelse if ( debug ) { \nLog . d ( TAG , \"Joined to the existing task \" + key ) ; \n} \nreturn ; \n} \n} \n"}
{"8871": "public class ImagesManager { \nprotected void memCacheImage ( final String url , final Bitmap bitmap ) { \nif ( debug ) { \nLog . d ( TAG , \"Memcache for \" + url ) ; \n} \nmemCache . putElement ( url , bitmap ) ; \nreturn ; \n} \n} \n"}
{"8872": "public class BuffersPool { \npublic void release ( final byte [ ] buffer ) { \nif ( buffer == null ) { \nreturn ; \n} \nfinal int capacity = buffer . length ; \nif ( capacity == 0 ) { \nreturn ; \n} \nsynchronized ( lock ) { \nList < Object > bList = buffers . get ( capacity ) ; \nif ( bList == null ) { \nbList = new LinkedList < Object > ( ) ; \nbuffers . put ( capacity , bList ) ; \n} \nbList . add ( buffer ) ; \nusedBuffersCount -- ; \n} \nreturn ; \n} \n} \n"}
{"8873": "public class RequestDescription { \nprotected void onURLConnectionPrepared ( final Context context , final URLConnection urlConnection ) { \nif ( contentType != null ) { \nurlConnection . addRequestProperty ( \"Content-Type\" , contentType ) ; \n} \nif ( contentLanguage != null ) { \nurlConnection . addRequestProperty ( \"Accept-Language\" , contentLanguage ) ; \n} \nurlConnection . addRequestProperty ( \"Accept-Encoding\" , IoUtils . ENCODING_GZIP ) ; \nurlConnection . addRequestProperty ( \"User-Agent\" , buildUserAgent ( context ) ) ; \nif ( headers != null ) { \nfor ( String name : headers . keySet ( ) ) { \nurlConnection . addRequestProperty ( name , headers . getString ( name ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8875": "public class CacheControlUrlConnection { \nprivate void connectWithWorkaround ( ) throws IOException { \nif ( Build . VERSION . SDK_INT > Build . VERSION_CODES . GINGERBREAD_MR1 ) { \nsuper . connect ( ) ; \nreturn ; \n} \nURLConnection coreConnection = UrlConnectionWrapper . unwrap ( getCore ( ) ) ; \nif ( coreConnection instanceof HttpsURLConnection ) { \ntry { \nsuper . connect ( ) ; \n} \ncatch ( NullPointerException e ) { \n} \n} \nelse { \nsuper . connect ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8880": "public class JCublas { \nprivate static void checkResultBLAS ( ) { \nif ( exceptionsEnabled ) { \nlastResult = cublasGetErrorNative ( ) ; \nif ( lastResult != cublasStatus . CUBLAS_STATUS_SUCCESS ) { \nthrow new CudaException ( cublasStatus . stringFor ( lastResult ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8881": "public class Statistics { \npublic void addLexeme ( int lexemeId ) { \nint count = 1 ; \nif ( lexemeFrequency . get ( lexemeId ) != null ) count = lexemeFrequency . get ( lexemeId ) + 1 ; \nlexemeFrequency . put ( lexemeId , count ) ; \nreturn ; \n} \n} \n"}
{"8882": "public class Statistics { \npublic void addEnding ( int endingId ) { \nint count = 1 ; \nif ( endingFrequency . get ( endingId ) != null ) count = endingFrequency . get ( endingId ) + 1 ; \nendingFrequency . put ( endingId , count ) ; \nreturn ; \n} \n} \n"}
{"8884": "public class Wordform { \npublic void longDescription ( PrintStream out ) { \nout . println ( this . token + \":\" ) ; \nfor ( String s : this . attributes . keySet ( ) ) { \nout . println ( s + \"\\t\" + attributes . get ( s ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8885": "public class MarkupConverter { \nprivate static void verifyAndSetKamolsAttribute ( AttributeValues avs , StringBuilder tag , int index , char tagValue , String attribute , String attributeValue ) { \nif ( avs . isMatchingStrong ( attribute , attributeValue ) ) tag . setCharAt ( index , tagValue ) ; \nreturn ; \n} \n} \n"}
{"8887": "public class MarkupConverter { \nprivate static void verifyAndSetAVSAttribute ( String tag , FeatureStructure avs , int index , char tagValue , String attribute , String attributeValue ) { \nif ( index >= tag . length ( ) ) return ; \nif ( tag . charAt ( index ) == tagValue ) avs . addAttribute ( attribute , attributeValue ) ; \nreturn ; \n} \n} \n"}
{"8894": "public class ReportAppD { \npublic void perform ( List < AppInfo > apps , MetricDataRequest . TimeParams timeParams ) { \nList < SignalFxProtocolBuffers . DataPoint > dataPoints = new LinkedList < > ( ) ; \nfor ( AppInfo app : apps ) { \ndataRequest . setAppName ( app . name ) ; \nfor ( MetricInfo metricInfo : app . metrics ) { \ndataRequest . setTimeParams ( timeParams ) ; \ndataRequest . setMetricPath ( metricInfo . metricPathQuery ) ; \nList < MetricData > metricDataList ; \ntry { \nmetricDataList = dataRequest . get ( ) ; \n} \ncatch ( RequestException e ) { \nlog . error ( \"Metric query failure for \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \ncounterAppDRequestFailure . inc ( ) ; \ncontinue ; \n} \ncatch ( UnauthorizedException e ) { \nlog . error ( \"AppDynamics authentication failed\" ) ; \nreturn ; \n} \nif ( metricDataList != null && metricDataList . size ( ) > 0 ) { \nfor ( MetricData metricData : metricDataList ) { \nMetricTimeSeries mts = metricInfo . getMetricTimeSeries ( metricData . metricPath ) ; \nList < SignalFxProtocolBuffers . DataPoint > mtsDataPoints = processor . process ( mts , metricData . metricValues ) ; \ndataPoints . addAll ( mtsDataPoints ) ; \nif ( ! mtsDataPoints . isEmpty ( ) ) { \ncounterMtsReported . inc ( ) ; \n} \nelse { \ncounterMtsEmpty . inc ( ) ; \n} \n} \n} \nelse { \nlog . warn ( \"No metric found for query \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \n} \n} \n} \nif ( ! dataPoints . isEmpty ( ) ) { \ntry { \nreporter . report ( dataPoints ) ; \ncounterDataPointsReported . inc ( dataPoints . size ( ) ) ; \n} \ncatch ( Reporter . ReportException e ) { \nlog . error ( \"There were errors reporting metric\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8904": "public class Genericode10Helper { \npublic static void getAllKeyIDs ( @ Nonnull final ColumnSet aColumnSet , @ Nonnull final Collection < String > aTarget ) { \nCollectionHelper . findAll ( aColumnSet . getKeyChoice ( ) , o -> o instanceof Key , o -> aTarget . add ( ( ( Key ) o ) . getId ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) { \nreturn ; \n} \nelse { \ntry { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) { \ntimeSentMap . put ( instanceName , actualTimeSent ) ; \n} \n} \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \n} \n} \ncatch ( JSONException je ) { \n} \n} \nreturn ; \n} \n} \n"}
{"8924": "public class LogPersister { \nstatic public void setContext ( final Context context ) { \nif ( null == LogPersister . context ) { \nLogManager . getLogManager ( ) . getLogger ( \"\" ) . addHandler ( julHandler ) ; \njava . util . logging . Logger . getLogger ( \"\" ) . setLevel ( Level . ALL ) ; \nLogPersister . context = context ; \nif ( fileLoggerInstance == null || fileLoggerInstance instanceof FileLogger ) { \nFileLogger . setContext ( context ) ; \nfileLoggerInstance = FileLogger . getInstance ( ) ; \n} \nSharedPreferences prefs = LogPersister . context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nif ( null != level ) { \nsetLevelSync ( level ) ; \n} \nelse { \nsetLevelSync ( Logger . LEVEL . fromString ( prefs . getString ( SHARED_PREF_KEY_level , getLevelDefault ( ) . toString ( ) ) ) ) ; \n} \nif ( null != logFileMaxSize ) { \nsetMaxLogStoreSize ( logFileMaxSize ) ; \n} \nelse { \nsetMaxLogStoreSize ( prefs . getInt ( SHARED_PREF_KEY_logFileMaxSize , DEFAULT_logFileMaxSize ) ) ; \n} \nif ( null != capture ) { \nsetCaptureSync ( capture ) ; \n} \nelse { \nsetCaptureSync ( prefs . getBoolean ( SHARED_PREF_KEY_logPersistence , DEFAULT_capture ) ) ; \n} \nuncaughtExceptionHandler = new UncaughtExceptionHandler ( ) ; \nThread . setDefaultUncaughtExceptionHandler ( uncaughtExceptionHandler ) ; \n} \nreturn ; \n} \n} \n"}
{"8927": "public class LogPersister { \nstatic public void setMaxLogStoreSize ( final int bytes ) { \nif ( bytes >= 10000 ) { \nlogFileMaxSize = bytes ; \n} \nif ( null != context ) { \nSharedPreferences prefs = context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nprefs . edit ( ) . putInt ( SHARED_PREF_KEY_logFileMaxSize , logFileMaxSize ) . commit ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8931": "public class BMSAnalytics { \npublic static void logLocation ( ) { \nif ( ! BMSAnalytics . collectLocation ) { \nlogger . error ( \"You must enable collectLocation before location can be logged\" ) ; \nreturn ; \n} \nif ( ! locationService . getInitLocationRequests ( ) ) { \nlogger . error ( \"locationService  Initialization has failed\" ) ; \nreturn ; \n} \nJSONObject metadata = new JSONObject ( ) ; \nString hashedUserID = UUID . nameUUIDFromBytes ( DEFAULT_USER_ID . getBytes ( ) ) . toString ( ) ; \ntry { \nmetadata . put ( CATEGORY , LOG_LOCATION_KEY ) ; \nmetadata . put ( LATITUDE_KEY , locationService . getLatitude ( ) ) ; \nmetadata . put ( LONGITUDE_KEY , locationService . getLongitude ( ) ) ; \nmetadata . put ( TIMESTAMP_KEY , ( new Date ( ) ) . getTime ( ) ) ; \nmetadata . put ( APP_SESSION_ID_KEY , MFPAnalyticsActivityLifecycleListener . getAppSessionID ( ) ) ; \nmetadata . put ( USER_ID_KEY , hashedUserID ) ; \n} \ncatch ( JSONException e ) { \nlogger . debug ( \"JSONException encountered logging change in user context: \" + e . getMessage ( ) ) ; \n} \nlog ( metadata ) ; \nreturn ; \n} \n} \n"}
{"8932": "public class BMSAnalytics { \nprivate static void setUserIdentity ( final String user , boolean isInitialCtx ) { \nif ( ! isInitialCtx && ! BMSAnalytics . hasUserContext ) { \nlogger . error ( \"Cannot set user identity with anonymous user collection enabled.\" ) ; \nreturn ; \n} \nJSONObject metadata = new JSONObject ( ) ; \nDEFAULT_USER_ID = user ; \nString hashedUserID = UUID . nameUUIDFromBytes ( user . getBytes ( ) ) . toString ( ) ; \ntry { \nif ( isInitialCtx ) { \nmetadata . put ( CATEGORY , INITIAL_CTX_CATEGORY ) ; \n} \nelse { \nmetadata . put ( CATEGORY , USER_SWITCH_CATEGORY ) ; \n} \nif ( BMSAnalytics . collectLocation ) { \nif ( locationService . getInitLocationRequests ( ) ) { \nmetadata . put ( LONGITUDE_KEY , locationService . getLongitude ( ) ) ; \nmetadata . put ( LATITUDE_KEY , locationService . getLatitude ( ) ) ; \n} \n} \nmetadata . put ( TIMESTAMP_KEY , ( new Date ( ) ) . getTime ( ) ) ; \nmetadata . put ( APP_SESSION_ID_KEY , MFPAnalyticsActivityLifecycleListener . getAppSessionID ( ) ) ; \nmetadata . put ( USER_ID_KEY , hashedUserID ) ; \n} \ncatch ( JSONException e ) { \nlogger . debug ( \"JSONException encountered logging change in user context: \" + e . getMessage ( ) ) ; \n} \nMFPInAppFeedBackListner . setUserIdentity ( user ) ; \nlog ( metadata ) ; \nreturn ; \n} \n} \n"}
{"8934": "public class MFPAnalyticsLocationListener { \nprotected void startLocationUpdates ( ) { \nif ( ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_FINE_LOCATION ) != PackageManager . PERMISSION_GRANTED && ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_COARSE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { \nreturn ; \n} \nLocationServices . FusedLocationApi . requestLocationUpdates ( mGoogleApiClient , mLocationRequest , this ) ; \nreturn ; \n} \n} \n"}
{"8935": "public class ObjectSizing { \npublic void sizeRegion ( Region < ? , ? > region , int numEntries ) { \nif ( region == null ) { \nthrow new IllegalArgumentException ( \"Region is null.\" ) ; \n} \nif ( region instanceof PartitionedRegion ) { \nsizePartitionedRegion ( region , numEntries ) ; \n} \nelse { \nsizeReplicatedOrLocalRegion ( region , numEntries ) ; \n} \nreturn ; \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nint regionSize = primaryDataSet . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = primaryDataSet . size ( ) ; \n} \nelse if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nint count = 0 ; \nfor ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \nreturn ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nint regionSize = entries . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = entries . size ( ) ; \n} \nelse if ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \nint count = 0 ; \nfor ( Iterator < ? > i = entries . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \nreturn ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nif ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \n} \nstream . println ( \"]\" ) ; \nreturn ; \n} \n} \n"}
{"8950": "public class GemFireIO { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > void flatten ( Collection < Object > input , Collection < Object > flattenOutput ) throws Exception { \nif ( input == null || input . isEmpty ( ) || flattenOutput == null ) return ; \nfor ( Object inputObj : input ) { \nif ( inputObj instanceof Exception ) throw ( Exception ) inputObj ; \nif ( inputObj == null ) continue ; \nif ( inputObj instanceof Collection ) flatten ( ( Collection < Object > ) inputObj , flattenOutput ) ; \nelse flattenOutput . add ( inputObj ) ; \n} \nreturn ; \n} \n} \n"}
{"8956": "public class ReadExportFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \nResultSender < Object > sender = functionContext . getResultSender ( ) ; \nCache cache = CacheFactory . getAnyInstance ( ) ; \nLogger logWriter = LogManager . getLogger ( getClass ( ) ) ; \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null || args . length != 2 ) throw new FunctionException ( \"Required array args: [region,extension]\" ) ; \nString extensionArg = args [ 0 ] ; \nif ( extensionArg == null || extensionArg . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"File extension required\" ) ; \n} \nExportFileType extension = ExportFileType . valueOf ( extensionArg ) ; \nString regionName = args [ 1 ] ; \nRegion < Object , Object > region = cache . getRegion ( regionName ) ; \nif ( region == null ) { \nsender . lastResult ( null ) ; \nreturn ; \n} \nFile file = new File ( new StringBuilder ( directoryPath ) . append ( \"/\" ) . append ( regionName ) . append ( \".\" ) . append ( extensionArg ) . toString ( ) ) ; \nString serverName = cache . getDistributedSystem ( ) . getDistributedMember ( ) . getName ( ) ; \nswitch ( extension ) { \ncase gfd : new GfdExportFunction ( ) . exportRegion ( region ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Unsupported extension file type:\" + extension ) ; \n} \nSerializable content = readContent ( file , extension , logWriter ) ; \nSerializable [ ] arrayResults = { \nserverName , content , file . getAbsolutePath ( ) } \n; \nsender . lastResult ( arrayResults ) ; \n} \ncatch ( Exception e ) { \nString stackTrace = Debugger . stackTrace ( e ) ; \nlogWriter . error ( stackTrace ) ; \nthrow new FunctionException ( stackTrace ) ; \n} \nreturn ; \n} \n} \n"}
{"8958": "public class LuceneSearchFunction { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) @ Override public void execute ( FunctionContext functionContext ) { \nCache cache = CacheFactory . getAnyInstance ( ) ; \ntry { \nif ( ! ( functionContext instanceof RegionFunctionContext ) ) { \nthrow new FunctionException ( \"Execute on a region\" ) ; \n} \nObject args = functionContext . getArguments ( ) ; \nif ( args == null ) throw new FunctionException ( \"arguments is required\" ) ; \nTextPageCriteria criteria = null ; \nif ( args instanceof PdxInstance ) { \nPdxInstance pdxInstance = ( PdxInstance ) args ; \ntry { \ncriteria = ( TextPageCriteria ) ( pdxInstance . getObject ( ) ) ; \n} \ncatch ( PdxSerializationException e ) { \nthrow new FunctionException ( e . getMessage ( ) + \" JSON:\" + JSONFormatter . toJSON ( pdxInstance ) ) ; \n} \n} \nelse { \ncriteria = ( TextPageCriteria ) args ; \n} \nRegion < String , Collection < Object > > pagingRegion = cache . getRegion ( criteria . getPageRegionName ( ) ) ; \nRegion < ? , ? > region = cache . getRegion ( criteria . getRegionName ( ) ) ; \nGeodePagination pagination = new GeodePagination ( ) ; \nTextPolicySearchStrategy geodeSearch = new TextPolicySearchStrategy ( cache ) ; \ngeodeSearch . saveSearchResultsWithPageKeys ( criteria , criteria . getQuery ( ) , null , ( Region < String , Collection < Object > > ) pagingRegion ) ; \nCollection < Object > collection = pagination . readResultsByPageValues ( criteria . getId ( ) , criteria . getSortField ( ) , criteria . isSortDescending ( ) , criteria . getBeginIndex ( ) , ( Region < Object , Object > ) region , ( Region ) pagingRegion ) ; \nif ( collection == null ) { \nfunctionContext . getResultSender ( ) . lastResult ( null ) ; \nreturn ; \n} \nPagingCollection < Object > pageCollection = new PagingCollection < Object > ( collection , criteria ) ; \nfunctionContext . getResultSender ( ) . lastResult ( pageCollection ) ; \n} \ncatch ( RuntimeException e ) { \nLogger logger = LogManager . getLogger ( LuceneSearchFunction . class ) ; \nlogger . error ( Debugger . stackTrace ( e ) ) ; \nthrow e ; \n} \nreturn ; \n} \n} \n"}
{"8960": "public class GeodeClient { \nprotected static void constructSecurity ( Properties props ) throws IOException { \nprops . setProperty ( \"security-client-auth-init\" , GeodeConfigAuthInitialize . class . getName ( ) + \".create\" ) ; \nFile sslFile = saveEnvFile ( GeodeConfigConstants . SSL_KEYSTORE_CLASSPATH_FILE_PROP ) ; \nSystem . out . println ( \"sslFile:\" + sslFile ) ; \nFile sslTrustStoreFile = saveEnvFile ( GeodeConfigConstants . SSL_TRUSTSTORE_CLASSPATH_FILE_PROP ) ; \nString sslTrustStoreFilePath = \"\" ; \nif ( sslTrustStoreFile != null ) sslTrustStoreFilePath = sslTrustStoreFile . getAbsolutePath ( ) ; \nprops . setProperty ( \"ssl-keystore\" , ( sslFile != null ) ? sslFile . getAbsolutePath ( ) : \"\" ) ; \nprops . setProperty ( \"ssl-keystore-password\" , Config . getPropertyEnv ( \"ssl-keystore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore\" , sslTrustStoreFilePath ) ; \nprops . setProperty ( \"ssl-protocols\" , Config . getPropertyEnv ( \"ssl-protocols\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore-password\" , Config . getPropertyEnv ( \"ssl-truststore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-keystore-type\" , Config . getPropertyEnv ( \"ssl-keystore-type\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-ciphers\" , Config . getPropertyEnv ( \"ssl-ciphers\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-require-authentication\" , Config . getPropertyEnv ( \"ssl-require-authentication\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-enabled-components\" , Config . getPropertyEnv ( \"ssl-enabled-components\" , \"\" ) ) ; \nreturn ; \n} \n} \n"}
{"8963": "public class RegionDiffDirector { \npublic void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) { \nif ( sourceChecksumMap == null ) { \nif ( targetMap != null && ! targetMap . isEmpty ( ) ) { \nthis . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; \n} \nreturn ; \n} \nif ( targetMap == null ) { \nthis . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; \nreturn ; \n} \nBigInteger targetBi = null ; \nBigInteger sourceBi = null ; \nfor ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) { \ntargetBi = targetMap . get ( entrySource . getKey ( ) ) ; \nsourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; \nif ( targetBi == null ) { \nkeysMissingOnTarget . add ( entrySource . getKey ( ) ) ; \n} \nelse if ( ! targetBi . equals ( sourceBi ) ) { \nkeysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; \n} \n} \nSet < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; \nfor ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) { \nif ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) { \nkeysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nint typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \nfor ( int i = 0 ; \ni < this . resourceTypeTable . length ; \ni ++ ) { \nif ( this . resourceTypeTable [ i ] != null ) { \nif ( this . resourceTypeTable [ i ] . close ( ) ) { \nthis . resourceTypeTable [ i ] = null ; \n} \nelse { \ntypeCount ++ ; \n} \n} \n} \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount ++ ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nint instCount = 0 ; \nfor ( int i = 0 ; \ni < this . resourceInstTable . length ; \ni ++ ) { \nif ( this . resourceInstTable [ i ] != null ) { \nif ( this . resourceInstTable [ i ] . close ( ) ) { \nthis . resourceInstTable [ i ] = null ; \n} \nelse { \ninstCount ++ ; \n} \n} \n} \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount ++ ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \nreturn ; \n} \n} \n"}
{"8966": "public class GfStatsReader { \npublic static void toCvsFiles ( File directory ) throws IOException { \nSet < File > statsFiles = IO . listFileRecursive ( directory , \"*.gfs\" ) ; \nif ( statsFiles == null || statsFiles . isEmpty ( ) ) return ; \nfor ( File archiveFile : statsFiles ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8967": "public class GfStatsReader { \npublic static void main ( String [ ] args ) { \nFile archiveFile , csvFile ; \nif ( args . length < 1 ) { \nSystem . err . println ( \"Usage: java \" + GfStatsReader . class . getName ( ) + \" archiveFile [csvFile [statName ]*]\" ) ; \nreturn ; \n} \ntry { \narchiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; \nif ( archiveFile . isDirectory ( ) ) { \ntoCvsFiles ( archiveFile ) ; \nreturn ; \n} \nif ( args . length < 2 ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \nreturn ; \n} \nString typeName = args [ 1 ] ; \ncsvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; \nGenericCsvStatsVisitor visitor = null ; \nif ( args . length > 3 ) { \nString [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; \n} \nelse visitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; \nSystem . out . println ( \"accepting\" ) ; \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"8970": "public class GemFireMgmt { \npublic static void shutDownMember ( String name ) { \ntry { \nObjectName serverName = new ObjectName ( \"GemFire:type=Member,member=\" + name ) ; \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nMemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; \nbean . shutDownMember ( ) ; \nSystem . out . println ( \"Waiting for member:\" + name + \"  to shutdown\" ) ; \nwhile ( GemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ) { \nThread . sleep ( shutDownDelay ) ; \n} \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to shutdown member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \ncatch ( Exception e ) { \nSystem . out . println ( e . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8972": "public class GemFireMgmt { \npublic static void shutDownRedundancyZone ( String redundancyZone ) { \nif ( redundancyZone == null || redundancyZone . length ( ) == 0 ) throw new IllegalArgumentException ( \"redundancyZone required\" ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp exp = Query . eq ( Query . attr ( \"RedundancyZone\" ) , Query . value ( redundancyZone ) ) ; \nCollection < ObjectName > memberObjectNames = SingletonGemFireJmx . getJmx ( ) . searchObjectNames ( objectNamePattern , exp ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nGemFireMgmt . shutDownMember ( objectName . getKeyProperty ( \"member\" ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8977": "public class GetEntriesChecksumFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null || args . length == 0 ) throw new IllegalArgumentException ( \"region argument required\" ) ; \nString regionName = args [ 0 ] ; \nif ( regionName == null || regionName . length ( ) == 0 ) throw new IllegalArgumentException ( \"region name argument required\" ) ; \nRegion < Serializable , Object > region = CacheFactory . getAnyInstance ( ) . getRegion ( regionName ) ; \nif ( region == null ) throw new IllegalArgumentException ( \"region:\" + regionName + \" not found\" ) ; \nfunctionContext . getResultSender ( ) . lastResult ( buildCheckSumMap ( region ) ) ; \n} \ncatch ( Exception e ) { \nString stack = Debugger . stackTrace ( e ) ; \nLogManager . getLogger ( getClass ( ) ) . error ( stack ) ; \nthrow new FunctionException ( stack ) ; \n} \nreturn ; \n} \n} \n"}
{"8984": "public class ShillelaghProcessor { \nprivate void checkForTableId ( TableObject tableObject , Element element ) { \nId idAnnotation = element . getAnnotation ( Id . class ) ; \nif ( idAnnotation != null ) { \nif ( element . asType ( ) . getKind ( ) != TypeKind . LONG && ! ( \"java.lang.Long\" . equals ( element . asType ( ) . toString ( ) ) ) ) { \nlogger . e ( \"@Id must be on a long\" ) ; \n} \nString columnName = Strings . isBlank ( idAnnotation . name ( ) ) ? element . getSimpleName ( ) . toString ( ) : idAnnotation . name ( ) ; \nfinal TableColumn idColumn = new TableColumn ( columnName , element . getSimpleName ( ) . toString ( ) , element . asType ( ) . toString ( ) , SqliteType . INTEGER ) ; \ntableObject . setIdColumn ( idColumn ) ; \n} \nreturn ; \n} \n} \n"}
{"8985": "public class ShillelaghProcessor { \nprivate void checkForFields ( TableObject tableObject , Element columnElement ) { \nColumn columnAnnotation = columnElement . getAnnotation ( Column . class ) ; \nif ( columnAnnotation == null ) return ; \nfinal Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; \nfinal String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; \nTableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; \nif ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { \nString columnType = columnElement . asType ( ) . toString ( ) ; \nlogger . d ( \"Column Element Type: \" + columnType ) ; \nif ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( \"java.lang.Byte[]\" ) && ! columnType . startsWith ( \"java.util.Map\" ) && ! columnType . startsWith ( \"java.util.List\" ) ) { \nlogger . e ( String . format ( \"%s in %s is not Serializable and will not be able to be converted to a byte array\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \n} \nelse if ( tableColumn . isOneToMany ( ) ) { \nTypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; \nif ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) { \nlogger . e ( \"One to many relationship in class %s where %s is not annotated with @Table\" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; \n} \noneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; \nTypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; \ntableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; \n} \nelse if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { \n@ SuppressWarnings ( \"ConstantConditions\" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; \nif ( annotation == null ) { \nlogger . e ( String . format ( \"%s in %s needs to be marked as a blob or should be \" + \"annotated with @Table\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \ntableColumn . setOneToOne ( true ) ; \n} \ntableObject . addColumn ( tableColumn ) ; \nreturn ; \n} \n} \n"}
{"8988": "public class TableObject { \nvoid brewJava ( Writer writer ) throws IOException { \nlogger . d ( \"brewJava\" ) ; \nJavaWriter javaWriter = new JavaWriter ( writer ) ; \njavaWriter . setCompressingTypes ( false ) ; \njavaWriter . emitSingleLineComment ( \"Generated code from Shillelagh. Do not modify!\" ) . emitPackage ( classPackage ) . emitImports ( \"android.content.ContentValues\" , \"android.database.Cursor\" , \"android.database.DatabaseUtils\" , \"android.database.sqlite.SQLiteDatabase\" ) . emitImports ( ShillelaghUtil . class , ByteArrayInputStream . class , ByteArrayOutputStream . class , IOException . class , ObjectInputStream . class , ObjectOutputStream . class , LinkedList . class , Date . class , List . class ) . beginType ( className , \"class\" , EnumSet . of ( PUBLIC , FINAL ) ) ; \nif ( this . isChildTable ) { \nemitParentInsert ( javaWriter ) ; \nemitSelectAll ( javaWriter ) ; \n} \nemitInsert ( javaWriter ) ; \nemitOneToOneInsert ( javaWriter ) ; \nemitGetId ( javaWriter ) ; \nemitCreateTable ( javaWriter ) ; \nemitDropTable ( javaWriter ) ; \nemitUpdate ( javaWriter ) ; \nemitUpdateColumnId ( javaWriter ) ; \nemitDeleteWithId ( javaWriter ) ; \nemitDeleteWithObject ( javaWriter ) ; \nemitMapCursorToObject ( javaWriter ) ; \nemitSingleMap ( javaWriter ) ; \nemitSelectById ( javaWriter ) ; \njavaWriter . endType ( ) ; \nreturn ; \n} \n} \n"}
{"8989": "public class TableObject { \nprivate void emitGetId ( JavaWriter javaWriter ) throws IOException { \nlogger . d ( \"emitGetId\" ) ; \njavaWriter . beginMethod ( \"long\" , GET_ID_FUNCTION , EnumSet . of ( PUBLIC , STATIC ) , getTargetClass ( ) , \"value\" ) . emitStatement ( \"return value.%s\" , idColumn . getMemberName ( ) ) . endMethod ( ) ; \nreturn ; \n} \n} \n"}
{"8991": "public class Builder { \nfinal void checkColumnName ( String columnName ) { \ntry { \ntableObject . getDeclaredField ( columnName ) ; \n} \ncatch ( NoSuchFieldException e ) { \nthrow new RuntimeException ( String . format ( \"%s isEqualTo not a field found in %s\" , columnName , tableObject ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8998": "public class ShillelaghLogger { \nvoid n ( String message , Object ... args ) { \nmessenger . printMessage ( NOTE , formatString ( message , args ) ) ; \nreturn ; \n} \n} \n"}
{"8999": "public class ShillelaghLogger { \nvoid e ( String message , Object ... args ) { \nmessenger . printMessage ( ERROR , formatString ( message , args ) ) ; \nreturn ; \n} \n} \n"}
{"9002": "public class SldEditorWidgetViewImpl { \npublic VLayout createSldEditorLayout ( ) { \nfinal VLayout vLayout = new VLayout ( ) ; \ntoolStrip = new ToolStrip ( ) ; \ntoolStrip . setWidth100 ( ) ; \ncodeMirrorPanel = new CodeMirrorPanel ( ) ; \nWidgetCanvas canvas = new WidgetCanvas ( codeMirrorPanel ) ; \ncanvas . setWidth100 ( ) ; \ncanvas . setHeight100 ( ) ; \nvLayout . addMember ( toolStrip ) ; \nvLayout . addMember ( canvas ) ; \nToolStripButton saveButton = new ToolStripButton ( ) ; \nsaveButton . setIcon ( \"[ISOMORPHIC]/\" + \"icons/silk/disk.png\" ) ; \nsaveButton . setTitle ( msg . saveButtonTitle ( ) ) ; \nsaveButton . setTooltip ( msg . saveButtonTooltip ( ) ) ; \nsaveButton . addClickHandler ( new ClickHandler ( ) { \n@ Override public void onClick ( ClickEvent clickEvent ) { \npresenter . onSaveButton ( ) ; \nreturn ; \n} \n} \n) ; \nToolStripButton cancelButton = new ToolStripButton ( ) ; \ncancelButton . setIcon ( \"[ISOMORPHIC]/\" + \"icons/silk/cancel.png\" ) ; \ncancelButton . setTitle ( msg . cancelButtonTitle ( ) ) ; \ncancelButton . addClickHandler ( new ClickHandler ( ) { \n@ Override public void onClick ( ClickEvent clickEvent ) { \npresenter . onCancelButton ( ) ; \nreturn ; \n} \n} \n) ; \nToolStripButton validateButton = new ToolStripButton ( ) ; \nvalidateButton . setIcon ( \"[ISOMORPHIC]/\" + \"icons/silk/tick.png\" ) ; \nvalidateButton . setTitle ( msg . validateButtonTitle ( ) ) ; \nvalidateButton . setTooltip ( msg . validateButtonTooltip ( ) ) ; \nvalidateButton . addClickHandler ( new ClickHandler ( ) { \n@ Override public void onClick ( ClickEvent clickEvent ) { \npresenter . onValidateButton ( ) ; \nreturn ; \n} \n} \n) ; \nToolStripButton formatBtn = new ToolStripButton ( ) ; \nformatBtn . setIcon ( \"[ISOMORPHIC]/\" + \"icons/silk/text_align_left.png\" ) ; \nformatBtn . setTitle ( msg . formatButtonTitle ( ) ) ; \nformatBtn . setTooltip ( msg . formatButtonTooltip ( ) ) ; \nformatBtn . addClickHandler ( new ClickHandler ( ) { \npublic void onClick ( ClickEvent event ) { \npresenter . onFormatButton ( ) ; \nreturn ; \n} \n} \n) ; \nselectTemplate = new SelectItem ( ) ; \nselectTemplate . setTitle ( msg . templateSelectTitle ( ) ) ; \nselectTemplate . setTooltip ( msg . templateSelectTooltip ( ) ) ; \nselectTemplate . setWidth ( 200 ) ; \nselectTemplate . addChangeHandler ( new ChangeHandler ( ) { \n@ Override public void onChange ( ChangeEvent changeEvent ) { \npresenter . onTemplateSelect ( ( String ) changeEvent . getValue ( ) ) ; \nreturn ; \n} \n} \n) ; \ntoolStrip . addFormItem ( selectTemplate ) ; \ntoolStrip . addButton ( saveButton ) ; \ntoolStrip . addButton ( validateButton ) ; \ntoolStrip . addButton ( formatBtn ) ; \ntoolStrip . addFill ( ) ; \ntoolStrip . addButton ( cancelButton ) ; \nreturn vLayout ; \n} \n} \n"}
{"9005": "public class ColumnVector { \nprotected void set ( final float values [ ] ) { \nthis . m_nRows = values . length ; \nthis . m_nCols = 1 ; \nthis . m_aValues = new float [ m_nRows ] [ 1 ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nthis . m_aValues [ r ] [ 0 ] = values [ r ] ; \n} \nreturn ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( ++ group == 10 ) { \nSystem . out . println ( ) ; \nif ( ++ line == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \nSystem . out . println ( piString . substring ( index ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9016": "public class Buckets { \npublic void setLimits ( final float rMin , final float rMax ) { \nthis . m_fMin = rMin ; \nthis . m_fMax = rMax ; \nthis . m_fWidth = ( rMax - rMin ) / m_n ; \nreturn ; \n} \n} \n"}
{"9017": "public class Buckets { \npublic void put ( final float r ) { \nif ( ( r < m_fMin ) || ( r > m_fMax ) ) return ; \nfinal int i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; \n++ m_aCounters [ i ] ; \nreturn ; \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nj < length ; \n++ j ) System . out . print ( \"*\" ) ; \nSystem . out . println ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9023": "public class RowVector { \nprivate void _set ( final Matrix m ) { \nm_nRows = 1 ; \nm_nCols = m . m_nCols ; \nm_aValues = m . m_aValues ; \nreturn ; \n} \n} \n"}
{"9026": "public class Matrix { \nprotected void set ( final float values [ ] [ ] ) { \nm_nRows = values . length ; \nm_nCols = values [ 0 ] . length ; \nm_aValues = values ; \nfor ( int r = 1 ; \nr < m_nRows ; \n++ r ) { \nm_nCols = Math . min ( m_nCols , values [ r ] . length ) ; \n} \nreturn ; \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nar . print ( m_aValues [ r ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9033": "public class SldEditorToolBarButton { \npublic void setResource ( ImageResource imageResource ) { \nImage img = new Image ( imageResource ) ; \nDOM . insertChild ( getElement ( ) , img . getElement ( ) , 0 ) ; \nreturn ; \n} \n} \n"}
{"9034": "public class RegressionLine { \nprivate void _validateCoefficients ( ) { \nif ( m_bCoefsValid ) return ; \nif ( m_nDataPoints >= 2 ) { \nfinal float xBar = ( float ) m_dSumX / m_nDataPoints ; \nfinal float yBar = ( float ) m_dSumY / m_nDataPoints ; \nm_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; \nm_fA0 = yBar - m_fA1 * xBar ; \n} \nelse { \nm_fA0 = m_fA1 = Float . NaN ; \n} \nm_bCoefsValid = true ; \nreturn ; \n} \n} \n"}
{"9035": "public class FixedPointRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXn = m_fXn ; \nm_fXn = m_fGn ; \nm_fGn = m_aFunction . at ( m_fXn ) ; \nreturn ; \n} \n} \n"}
{"9036": "public class SldModelImpl { \npublic void clear ( ) { \nrawSld = new RawSld ( ) ; \ndirty = false ; \nvalid = false ; \ntemplate = null ; \nsldDescriptor = null ; \nreturn ; \n} \n} \n"}
{"9039": "public class InMemorySldServiceImpl { \npublic void validate ( StyledLayerDescriptorInfo sld ) throws SldException { \ntry { \nparseSldI ( sld ) ; \n} \ncatch ( JiBXException e ) { \nthrow new SldException ( \"Validation error\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"9042": "public class SquareMatrix { \nprivate void _set ( final Matrix m ) { \nthis . m_nRows = this . m_nCols = Math . min ( m . m_nRows , m . m_nCols ) ; \nthis . m_aValues = m . m_aValues ; \nreturn ; \n} \n} \n"}
{"9043": "public class SquareMatrix { \n@ Override protected void set ( final float values [ ] [ ] ) { \nsuper . set ( values ) ; \nm_nRows = m_nCols = Math . min ( m_nRows , m_nCols ) ; \nreturn ; \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \nfor ( int rPivot = 0 ; \nrPivot < m_nRows - 1 ; \n++ rPivot ) { \nfloat largestScaledElmt = 0 ; \nint rLargest = 0 ; \nfor ( int r = rPivot ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( largestScaledElmt < scaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n} \nif ( largestScaledElmt == 0 ) { \nthrow new MatrixException ( MatrixException . SINGULAR ) ; \n} \nif ( rLargest != rPivot ) { \nfinal int temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \n++ m_nExchangeCount ; \n} \nfinal int prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \nfor ( int r = rPivot + 1 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) { \nfor ( int c = rPivot + 1 ; \nc < m_nCols ; \n++ c ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt -= multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( largestX < absX ) largestX = absX ; \n} \nif ( largestX == 0 ) return ; \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \nfor ( int iter = 0 ; \niter < MAX_ITER ; \n++ iter ) { \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \ndouble dot = 0 ; \nfor ( int c = 0 ; \nc < m_nRows ; \n++ c ) { \nfinal double elmt = at ( r , c ) ; \ndot += elmt * x . at ( c ) ; \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( largestDiff < diff ) largestDiff = diff ; \n} \nif ( largestDiff < largestX * TOLERANCE ) return ; \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \nreturn ; \n} \n} \n"}
{"9053": "public class IdentityMatrix { \npublic static void convert ( final SquareMatrix sm ) { \nfor ( int r = 0 ; \nr < sm . m_nRows ; \n++ r ) { \nfor ( int c = 0 ; \nc < sm . m_nCols ; \n++ c ) { \nsm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; \n} \n} \nreturn ; \n} \n} \n"}
{"9055": "public class RegulaFalsiRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nif ( m_fFalse < 0 ) { \nm_fXNeg = m_fXFalse ; \nm_fNeg = m_fFalse ; \n} \nelse { \nm_fXPos = m_fXFalse ; \nm_fPos = m_fFalse ; \n} \nreturn ; \n} \n} \n"}
{"9056": "public class RegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nreturn ; \n} \n} \n"}
{"9057": "public class RegulaFalsiRootFinder { \n@ Override protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException { \nif ( EqualsHelper . equals ( m_fXFalse , m_fPrevXFalse ) ) { \nthrow new AbstractRootFinder . PositionUnchangedException ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9058": "public class ImprovedRegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fPrevFFalse = m_fFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nm_bDecreasePos = m_bDecreaseNeg = false ; \nif ( Float . isNaN ( m_fPrevFFalse ) || ( m_fPrevFFalse * m_fFalse > 0 ) ) { \nif ( m_fFalse < 0 ) m_bDecreasePos = true ; \nelse m_bDecreaseNeg = true ; \n} \nreturn ; \n} \n} \n"}
{"9059": "public class AbstractRootFinder { \npublic void checkInterval ( final float x1 , final float x2 ) throws InvalidIntervalException { \nfinal float y1 = m_aFunction . at ( x1 ) ; \nfinal float y2 = m_aFunction . at ( x2 ) ; \nif ( y1 * y2 > 0 ) throw new InvalidIntervalException ( ) ; \nreturn ; \n} \n} \n"}
{"9060": "public class KahanSummation { \npublic void add ( final float addend ) { \nm_fCorrectedAddend = addend + m_fCorrection ; \nfinal float tempSum = m_fSum + m_fCorrectedAddend ; \nm_fCorrection = m_fCorrectedAddend - ( tempSum - m_fSum ) ; \nm_fSum = tempSum ; \nreturn ; \n} \n} \n"}
{"9063": "public class SecantRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nm_fXnm1 = m_fXn ; \nm_fXn = m_fXnp1 ; \nm_fFnm1 = m_fFn ; \nm_fFn = m_fFnp1 ; \nreturn ; \n} \n} \n"}
{"9066": "public class IEEE754 { \nprivate void _decompose ( final char [ ] bits , final int bias , final int reserved , final int signIndex , final int signSize , final int exponentIndex , final int exponentSize , final int fractionIndex , final int fractionSize ) { \nthis . m_nBias = bias ; \nm_sSignBit = new String ( bits , signIndex , signSize ) ; \nm_sExponentBits = new String ( bits , exponentIndex , exponentSize ) ; \nm_sFractionBits = new String ( bits , fractionIndex , fractionSize ) ; \ntry { \nm_nBiased = Integer . parseInt ( m_sExponentBits , 2 ) ; \nm_nFraction = Long . parseLong ( m_sFractionBits , 2 ) ; \n} \ncatch ( final NumberFormatException ex ) { \n} \nm_bIsZero = ( m_nBiased == 0 ) && ( m_nFraction == 0 ) ; \nm_bIsDenormalized = ( m_nBiased == 0 ) && ( m_nFraction != 0 ) ; \nm_bIsReserved = ( m_nBiased == reserved ) ; \nm_sImpliedBit = m_bIsDenormalized || m_bIsZero || m_bIsReserved ? \"0\" : \"1\" ; \nreturn ; \n} \n} \n"}
{"9067": "public class IEEE754 { \npublic void print ( @ Nonnull final PrintStream aPW ) { \naPW . println ( \"------------------------------\" ) ; \nif ( isDouble ( ) ) aPW . println ( \"double value = \" + doubleValue ( ) ) ; \nelse aPW . println ( \"float value = \" + floatValue ( ) ) ; \naPW . print ( \"sign=\" + signBit ( ) ) ; \naPW . print ( \", exponent=\" + exponentBits ( ) + \" (biased=\" + biasedExponent ( ) ) ; \nif ( isZero ( ) ) aPW . println ( \", zero)\" ) ; \nelse if ( isExponentReserved ( ) ) aPW . println ( \", reserved)\" ) ; \nelse if ( isDenormalized ( ) ) aPW . println ( \", denormalized, use \" + unbiasedExponent ( ) + \")\" ) ; \nelse aPW . println ( \", normalized, unbiased=\" + unbiasedExponent ( ) + \")\" ) ; \naPW . println ( \"significand=\" + significandBits ( ) ) ; \nreturn ; \n} \n} \n"}
{"9068": "public class IEEE754 { \npublic static void validateFloatBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( ( biased < 0 ) || ( biased > IEEE754Constants . FLOAT_EXPONENT_RESERVED ) ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . FLOAT_EXPONENT_RESERVED + \".\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9069": "public class IEEE754 { \npublic static void validateFloatUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( ( unbiased < - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . FLOAT_EXPONENT_BIAS ) ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . FLOAT_EXPONENT_BIAS + \".\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9070": "public class IEEE754 { \npublic static void validateDoubleBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( ( biased < 0 ) || ( biased > IEEE754Constants . DOUBLE_EXPONENT_RESERVED ) ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . DOUBLE_EXPONENT_RESERVED + \".\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9071": "public class IEEE754 { \npublic static void validateDoubleUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( ( unbiased < - IEEE754Constants . DOUBLE_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . DOUBLE_EXPONENT_BIAS ) ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . DOUBLE_EXPONENT_BIAS + \".\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9078": "public class BisectionRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nif ( m_fMid < 0 ) { \nm_fXNeg = m_fXMid ; \nm_fNeg = m_fMid ; \n} \nelse { \nm_fXPos = m_fXMid ; \nm_fPos = m_fMid ; \n} \nreturn ; \n} \n} \n"}
{"9079": "public class BisectionRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXMid = m_fXMid ; \nm_fXMid = ( m_fXNeg + m_fXPos ) / 2 ; \nm_fMid = m_aFunction . at ( m_fXMid ) ; \nreturn ; \n} \n} \n"}
{"9080": "public class BisectionRootFinder { \n@ Override protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException { \nif ( EqualsHelper . equals ( m_fXMid , m_fPrevXMid ) ) { \nthrow new AbstractRootFinder . PositionUnchangedException ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9081": "public class JavaFXExtension { \npublic static void setJavaFxApplication ( final CdiApplication javaFxApplication ) { \nfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; \nPlatform . runLater ( ( ) -> { \nJAVA_FX_APPLICATION . set ( javaFxApplication ) ; \nlatch . countDown ( ) ; \n} \n) ; \nif ( ! Platform . isFxApplicationThread ( ) ) { \ntry { \nlatch . await ( ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9082": "public class Calabash { \npublic void setConfiguration ( File configFile ) { \nif ( configFile == null ) nextConfig = null ; \nelse try { \nXProcConfiguration config = new XProcConfiguration ( \"he\" , false ) ; \nnextConfig = config . getProcessor ( ) . newDocumentBuilder ( ) . build ( new SAXSource ( new InputSource ( new FileReader ( configFile ) ) ) ) ; \n} \ncatch ( FileNotFoundException e ) { \nthrow new IllegalArgumentException ( \"Config file does not exist\" , e ) ; \n} \ncatch ( SaxonApiException e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9083": "public class Calabash { \npublic void setDefaultConfiguration ( Reader defaultConfig ) { \nXProcConfiguration config = new XProcConfiguration ( \"he\" , false ) ; \ntry { \nnextDefaultConfig = config . getProcessor ( ) . newDocumentBuilder ( ) . build ( new SAXSource ( new InputSource ( defaultConfig ) ) ) ; \n} \ncatch ( SaxonApiException e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9084": "public class CdiFXMLLoaderFactory { \nstatic void initializeFXMLLoader ( final FXMLLoader fxmlLoader , final Class < ? > targetClass , final String location , final String resources , final String charset ) { \ncheckAndSetLocation ( fxmlLoader , targetClass , location ) ; \nif ( charset != null && ! charset . equals ( CHARSET_UNSPECIFIED ) ) { \nfxmlLoader . setCharset ( Charset . forName ( charset ) ) ; \n} \nif ( resources != null && ! resources . equals ( RESOURCES_UNSPECIFIED ) ) { \nfxmlLoader . setResources ( ResourceBundle . getBundle ( resources ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9100": "public class Field { \n@ Override @ XmlTransient public void populateFromElasticSearchJson ( JSONObject jsonObjectParam , List < Field > formFieldsParam ) throws JSONException { \nthrow new FluidElasticSearchException ( \"Method not implemented. Make use of 'populateFromElasticSearchJson(JSONObject jsonObjectParam)' method.\" ) ; \nreturn ; \n} \n} \n"}
{"9110": "public class ABaseESUtil { \n@ Override public void closeConnection ( ) { \nCloseConnectionRunnable closeConnectionRunnable = new CloseConnectionRunnable ( this ) ; \nThread closeConnThread = new Thread ( closeConnectionRunnable , \"Close ABaseES Connection\" ) ; \ncloseConnThread . start ( ) ; \nreturn ; \n} \n} \n"}
{"9111": "public class AGenericListMessageHandler { \n@ Override public void handleMessage ( Object objectToProcess ) { \nif ( objectToProcess instanceof Error ) { \nError fluidError = ( ( Error ) objectToProcess ) ; \nthis . errors . add ( fluidError ) ; \nif ( this . messageReceivedCallback != null ) { \nthis . messageReceivedCallback . errorMessageReceived ( fluidError ) ; \n} \nif ( this . completableFuture != null ) { \nthis . completableFuture . completeExceptionally ( new FluidClientException ( fluidError . getErrorMessage ( ) , fluidError . getErrorCode ( ) ) ) ; \n} \n} \nelse { \nJSONObject jsonObject = ( JSONObject ) objectToProcess ; \nif ( this . compressedResponse ) { \nCompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; \nbyte [ ] compressedJsonList = UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; \nbyte [ ] uncompressedJson = null ; \ntry { \nuncompressedJson = this . uncompress ( compressedJsonList ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidClientException ( \"I/O issue with uncompress. \" + eParam . getMessage ( ) , eParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \njsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; \n} \nT messageForm = this . getNewInstanceBy ( jsonObject ) ; \nthis . returnValue . add ( messageForm ) ; \nif ( this . completableFuture != null ) { \nString echo = messageForm . getEcho ( ) ; \nif ( echo != null && ! echo . trim ( ) . isEmpty ( ) ) { \nthis . expectedEchoMessagesBeforeComplete . remove ( echo ) ; \n} \nif ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) { \nthis . completableFuture . complete ( this . returnValue ) ; \n} \n} \nif ( this . messageReceivedCallback != null ) { \nthis . messageReceivedCallback . messageReceived ( messageForm ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9112": "public class AGenericListMessageHandler { \n@ Override public void connectionClosed ( ) { \nthis . isConnectionClosed = true ; \nif ( this . completableFuture != null ) { \nif ( this . getErrors ( ) . isEmpty ( ) ) { \nthis . completableFuture . complete ( this . returnValue ) ; \n} \nelse { \nError firstFluidError = this . getErrors ( ) . get ( 0 ) ; \nthis . completableFuture . completeExceptionally ( new FluidClientException ( firstFluidError . getErrorMessage ( ) , firstFluidError . getErrorCode ( ) ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9133": "public class CacheUtil { \npublic void shutdown ( ) { \nif ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) { \ntry { \nthis . memcachedClient . shutdown ( ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidCacheException ( \"Unable to create shutdown MemCache client. \" + eParam . getMessage ( ) , eParam ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9180": "public class ABaseClientWebSocket { \n@ Override public void closeAndClean ( ) { \nCloseConnectionRunnable closeConnectionRunnable = new CloseConnectionRunnable ( this ) ; \nThread closeConnThread = new Thread ( closeConnectionRunnable , \"Close ABaseClientWebSocket Connection\" ) ; \ncloseConnThread . start ( ) ; \nreturn ; \n} \n} \n"}
{"9192": "public class ABaseSQLUtil { \npublic void closeConnection ( ) { \nif ( this . connection == null ) { \nreturn ; \n} \ntry { \nif ( this . connection . isClosed ( ) ) { \nreturn ; \n} \nthis . connection . close ( ) ; \n} \ncatch ( SQLException sqlExcept ) { \nthrow new FluidSQLException ( sqlExcept ) ; \n} \nreturn ; \n} \n} \n"}
{"9195": "public class WebSocketClient { \n@ OnClose public void onClose ( Session userSessionParam , CloseReason reasonParam ) { \nthis . userSession = null ; \nif ( this . messageHandlers != null ) { \nthis . messageHandlers . values ( ) . forEach ( handle -> { \nhandle . connectionClosed ( ) ; \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"9196": "public class WebSocketClient { \n@ OnMessage public void onMessage ( String messageParam ) { \nboolean handlerFoundForMsg = false ; \nfor ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { \nObject qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; \nif ( qualifyObj instanceof Error ) { \nhandler . handleMessage ( qualifyObj ) ; \n} \nelse if ( qualifyObj instanceof JSONObject ) { \nhandler . handleMessage ( qualifyObj ) ; \nhandlerFoundForMsg = true ; \nbreak ; \n} \n} \nif ( ! handlerFoundForMsg ) { \nthrow new FluidClientException ( \"No handler found for message;\\n\" + messageParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nreturn ; \n} \n} \n"}
{"9197": "public class WebSocketClient { \npublic void sendMessage ( ABaseFluidJSONObject aBaseFluidJSONObjectParam ) { \nif ( aBaseFluidJSONObjectParam == null ) { \nthrow new FluidClientException ( \"No JSON Object to send.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nelse { \nthis . sendMessage ( aBaseFluidJSONObjectParam . toJsonObject ( ) . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9198": "public class WebSocketClient { \npublic void sendMessage ( String messageToSendParam ) { \nif ( this . userSession == null ) { \nthrow new FluidClientException ( \"User Session is not set. Check if connection is open.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nRemoteEndpoint . Async asyncRemote = null ; \nif ( ( asyncRemote = this . userSession . getAsyncRemote ( ) ) == null ) { \nthrow new FluidClientException ( \"Remote Session is not set. Check if connection is open.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nasyncRemote . sendText ( messageToSendParam ) ; \nreturn ; \n} \n} \n"}
{"9199": "public class WebSocketClient { \npublic void closeSession ( ) { \nif ( this . userSession == null ) { \nreturn ; \n} \ntry { \nthis . userSession . close ( ) ; \n} \ncatch ( IOException e ) { \nthrow new FluidClientException ( \"Unable to close session. \" + e . getMessage ( ) , e , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nreturn ; \n} \n} \n"}
{"9220": "public class XsdParserJar { \nprivate void parseJarFile ( InputStream inputStream ) { \ntry { \nNode schemaNode = getSchemaNode ( inputStream ) ; \nif ( isXsdSchema ( schemaNode ) ) { \nXsdSchema . parse ( this , schemaNode ) ; \n} \nelse { \nthrow new ParsingException ( \"The top level element of a XSD file should be the xsd:schema node.\" ) ; \n} \n} \ncatch ( SAXException | IOException | ParserConfigurationException e ) { \nLogger . getAnonymousLogger ( ) . log ( Level . SEVERE , \"Exception while parsing.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"9221": "public class XsdParserJar { \nprivate void setClassLoader ( String jarPath ) { \nif ( ! jarPath . endsWith ( \".jar\" ) ) { \nthrow new ParsingException ( \"The jarPath received doesn't represent a jar file.\" ) ; \n} \nClassLoader originalCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nURL url = originalCl . getResource ( jarPath ) ; \nif ( url == null ) { \ntry { \nurl = new URL ( \"file:/\" + jarPath ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new ParsingException ( \"Invalid jar name.\" ) ; \n} \n} \nClassLoader urlCl = URLClassLoader . newInstance ( new URL [ ] { \nurl } \n, originalCl ) ; \nThread . currentThread ( ) . setContextClassLoader ( urlCl ) ; \nclassLoader = urlCl ; \nreturn ; \n} \n} \n"}
{"9222": "public class XsdGroup { \nprivate void rule2 ( ) { \nif ( ! ( parent instanceof XsdSchema ) && name != null ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + NAME_TAG + \" should only be used when the parent of the \" + XSD_TAG + \" is the \" + XsdSchema . XSD_TAG + \" element.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9223": "public class XsdGroup { \nprivate void rule3 ( ) { \nif ( parent instanceof XsdSchema && name == null ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + NAME_TAG + \" should is required the parent of the \" + XSD_TAG + \" is the \" + XsdSchema . XSD_TAG + \" element.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9224": "public class XsdAttribute { \nprivate void rule3 ( ) { \nif ( attributesMap . containsKey ( REF_TAG ) && ( simpleType != null || form != null || type != null ) ) { \nthrow new ParsingException ( XSD_TAG + \" element: If \" + REF_TAG + \" attribute is present, simpleType element, form attribute and type attribute cannot be present at the same time.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9226": "public class XsdElement { \nprivate void rule7 ( ) { \nif ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + FORM_TAG + \" attribute can only be present when the parent of the \" + xsdElementIsXsdSchema ) ; \n} \nreturn ; \n} \n} \n"}
{"9227": "public class XsdElement { \nprivate void rule3 ( ) { \nif ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + REF_TAG + \" attribute cannot be present when the parent of the \" + xsdElementIsXsdSchema ) ; \n} \nreturn ; \n} \n} \n"}
{"9241": "public class Range { \npublic void setBounds ( double currentLower , double currentUpper , double newLower , double newUpper ) { \nif ( currentLower == currentUpper ) { \nthrow new IllegalArgumentException ( \"currentLower must not equal currentUpper. Both are \" + currentUpper ) ; \n} \nif ( newLower == newUpper ) { \nthrow new IllegalArgumentException ( \"newLowerBound must not equal newUpperBound. Both are \" + newUpper ) ; \n} \ncurrentLowerBound = currentLower ; \ncurrentUpperBound = currentUpper ; \nnewLowerBound = newLower ; \nnewUpperBound = newUpper ; \nrecalculateScaleBias ( ) ; \nreturn ; \n} \n} \n"}
{"9242": "public class PluginEventsProcessor { \nprotected void doProcess ( final CloudTrailEvent event ) { \nfor ( final FullstopPlugin plugin : getPluginsForEvent ( event ) ) { \ndoProcess ( event , plugin ) ; \n} \nreturn ; \n} \n} \n"}
{"9243": "public class PluginEventsProcessor { \nprotected void doProcess ( final CloudTrailEvent event , final FullstopPlugin plugin ) { \ntry { \nplugin . processEvent ( event ) ; \n} \ncatch ( HystrixRuntimeException | HttpServerErrorException e ) { \nlog . warn ( e . getMessage ( ) , e ) ; \n} \ncatch ( final Exception e ) { \nlog . error ( e . getMessage ( ) , e ) ; \n} \nreturn ; \n} \n} \n"}
{"9249": "public class RestoreContext { \npublic void restore ( ) { \nfor ( String propertyName : propertyNames ) { \nif ( restoreProperties . containsKey ( propertyName ) ) { \nSystem . setProperty ( propertyName , restoreProperties . get ( propertyName ) ) ; \n} \nelse { \nSystem . clearProperty ( propertyName ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9255": "public class SoftSet { \nprivate void processQueue ( ) { \nComparableSoftReference cr ; \nwhile ( ( cr = ( ComparableSoftReference ) gcqueue . poll ( ) ) != null ) { \nmap . remove ( cr . getKey ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9259": "public class NestedRuntimeException { \npublic void printStackTrace ( final PrintStream stream ) { \nif ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) { \nsuper . printStackTrace ( stream ) ; \n} \nNestedThrowable . Util . print ( nested , stream ) ; \nreturn ; \n} \n} \n"}
{"9260": "public class NestedRuntimeException { \npublic void printStackTrace ( final PrintWriter writer ) { \nif ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) { \nsuper . printStackTrace ( writer ) ; \n} \nNestedThrowable . Util . print ( nested , writer ) ; \nreturn ; \n} \n} \n"}
{"9262": "public class BasicTaskWrapper { \npublic void run ( ) { \nthis . runThread = Thread . currentThread ( ) ; \nlong runTime = getElapsedTime ( ) ; \nif ( startTimeout > 0l && runTime >= startTimeout ) { \ntaskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; \nreturn ; \n} \nboolean stopped = false ; \nsynchronized ( stateLock ) { \nif ( state == TASK_STOPPED ) { \nstopped = true ; \n} \nelse { \nstate = TASK_STARTED ; \ntaskStarted ( ) ; \nif ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; \n} \n} \nif ( stopped ) { \ntaskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; \nreturn ; \n} \nThrowable throwable = null ; \ntry { \ntask . execute ( ) ; \n} \ncatch ( Throwable t ) { \nthrowable = t ; \n} \ntaskCompleted ( throwable ) ; \nsynchronized ( stateLock ) { \nstate = TASK_COMPLETED ; \nif ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9263": "public class BasicTaskWrapper { \nprotected void setTask ( Task task ) { \nif ( task == null ) throw new IllegalArgumentException ( \"Null task\" ) ; \nthis . task = task ; \nthis . taskString = task . toString ( ) ; \nthis . startTime = System . currentTimeMillis ( ) ; \nthis . waitType = task . getWaitType ( ) ; \nthis . priority = task . getPriority ( ) ; \nthis . startTimeout = task . getStartTimeout ( ) ; \nthis . completionTimeout = task . getCompletionTimeout ( ) ; \nreturn ; \n} \n} \n"}
{"9270": "public class WorkerQueue { \nprotected void putJobImpl ( Executable job ) { \nJobItem posted = new JobItem ( job ) ; \nif ( m_currentJob == null ) { \nm_currentJob = posted ; \nnotifyAll ( ) ; \n} \nelse { \nJobItem item = m_currentJob ; \nwhile ( item . m_next != null ) { \nitem = item . m_next ; \n} \nitem . m_next = posted ; \n} \nreturn ; \n} \n} \n"}
{"9273": "public class Catalog { \npublic void setupReaders ( ) { \nSAXParserFactory spf = SAXParserFactory . newInstance ( ) ; \nspf . setNamespaceAware ( true ) ; \nspf . setValidating ( false ) ; \nSAXCatalogReader saxReader = new SAXCatalogReader ( spf ) ; \nsaxReader . setCatalogParser ( null , \"XMLCatalog\" , \"org.apache.xml.resolver.readers.XCatalogReader\" ) ; \nsaxReader . setCatalogParser ( OASISXMLCatalogReader . namespaceName , \"catalog\" , \"org.apache.xml.resolver.readers.OASISXMLCatalogReader\" ) ; \naddReader ( \"application/xml\" , saxReader ) ; \nTR9401CatalogReader textReader = new TR9401CatalogReader ( ) ; \naddReader ( \"text/plain\" , textReader ) ; \nreturn ; \n} \n} \n"}
{"9274": "public class Catalog { \npublic void addReader ( String mimeType , CatalogReader reader ) { \nif ( readerMap . containsKey ( mimeType ) ) { \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nreaderArr . set ( pos . intValue ( ) , reader ) ; \n} \nelse { \nreaderArr . add ( reader ) ; \nInteger pos = new Integer ( readerArr . size ( ) - 1 ) ; \nreaderMap . put ( mimeType , pos ) ; \n} \nreturn ; \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \nfor ( int count = 0 ; \ncount < readerMap . size ( ) ; \ncount ++ ) { \nmapArr . add ( null ) ; \n} \nEnumeration enumt = readerMap . keys ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \nfor ( int count = 0 ; \ncount < mapArr . size ( ) ; \ncount ++ ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9277": "public class Catalog { \npublic void loadSystemCatalogs ( ) throws MalformedURLException , IOException { \nVector catalogs = catalogManager . getCatalogFiles ( ) ; \nif ( catalogs != null ) { \nfor ( int count = 0 ; \ncount < catalogs . size ( ) ; \ncount ++ ) { \ncatalogFiles . addElement ( catalogs . elementAt ( count ) ) ; \n} \n} \nif ( catalogFiles . size ( ) > 0 ) { \nString catfile = ( String ) catalogFiles . lastElement ( ) ; \ncatalogFiles . removeElement ( catfile ) ; \nparseCatalog ( catfile ) ; \n} \nreturn ; \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \nreturn ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \nreturn ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( ! parsed ) { \nif ( notFound ) { \ncatalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9281": "public class Catalog { \npublic void unknownEntry ( Vector strings ) { \nif ( strings != null && strings . size ( ) > 0 ) { \nString keyword = ( String ) strings . elementAt ( 0 ) ; \ncatalogManager . debug . message ( 2 , \"Unrecognized token parsing catalog\" , keyword ) ; \n} \nreturn ; \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nint pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nwhile ( local . hasMoreElements ( ) ) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) { \nreturn ; \n} \nif ( dp . length ( ) > partial . length ( ) ) { \npos ++ ; \n} \nif ( dp . length ( ) < partial . length ( ) ) { \nbreak ; \n} \n} \nif ( localDelegate . size ( ) == 0 ) { \nlocalDelegate . addElement ( entry ) ; \n} \nelse { \nlocalDelegate . insertElementAt ( entry , pos ) ; \n} \nreturn ; \n} \n} \n"}
{"9293": "public class ThrowableHandler { \nprotected static void fireOnThrowable ( int type , Throwable t ) { \nObject [ ] list = listeners . toArray ( ) ; \nfor ( int i = 0 ; \ni < list . length ; \ni ++ ) { \n( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; \n} \nreturn ; \n} \n} \n"}
{"9294": "public class ThrowableHandler { \npublic static void add ( int type , Throwable t ) { \nif ( t == null ) return ; \ntry { \nfireOnThrowable ( type , t ) ; \n} \ncatch ( Throwable bad ) { \nSystem . err . println ( \"Unable to handle throwable: \" + t + \" because of:\" ) ; \nbad . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9300": "public class CachedList { \nprivate void maintain ( ) { \nSoftObject obj ; \nint count = 0 ; \nwhile ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { \ncount ++ ; \nlist . remove ( obj ) ; \n} \nif ( count != 0 ) { \nSystem . err . println ( \"vm reclaimed \" + count + \" objects\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9305": "public class ContextClassLoaderSwitcher { \npublic void setContextClassLoader ( final Thread thread , final ClassLoader cl ) { \nAccessController . doPrivileged ( new PrivilegedAction ( ) { \npublic Object run ( ) { \nthread . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"9306": "public class TimeoutPriorityQueueImpl { \nprivate void swap ( int a , int b ) { \nTimeoutExtImpl temp = queue [ a ] ; \nqueue [ a ] = queue [ b ] ; \nqueue [ a ] . index = a ; \nqueue [ b ] = temp ; \nqueue [ b ] . index = b ; \nreturn ; \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \nfor ( int i = 0 ; \ni < PROTOCOLS . length ; \ni ++ ) { \ntry { \nURL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9312": "public class URLStreamHandlerFactory { \nprivate synchronized void checkHandlerPkgs ( ) { \nString handlerPkgsProp = System . getProperty ( \"java.protocol.handler.pkgs\" ) ; \nif ( handlerPkgsProp != null && handlerPkgsProp . equals ( lastHandlerPkgs ) == false ) { \nStringTokenizer tokeninzer = new StringTokenizer ( handlerPkgsProp , \"|\" ) ; \nArrayList < String > tmp = new ArrayList < String > ( ) ; \nwhile ( tokeninzer . hasMoreTokens ( ) ) { \nString pkg = tokeninzer . nextToken ( ) . intern ( ) ; \nif ( tmp . contains ( pkg ) == false ) tmp . add ( pkg ) ; \n} \nif ( tmp . contains ( PACKAGE_PREFIX ) == false ) tmp . add ( PACKAGE_PREFIX ) ; \nhandlerPkgs = new String [ tmp . size ( ) ] ; \ntmp . toArray ( handlerPkgs ) ; \nlastHandlerPkgs = handlerPkgsProp ; \n} \nreturn ; \n} \n} \n"}
{"9315": "public class LongCounter { \npublic static LongCounter makeSynchronized ( final LongCounter counter ) { \nreturn new Wrapper ( counter ) { \nprivate static final long serialVersionUID = 8903330696503363758L ; \npublic synchronized long increment ( ) { \nreturn this . counter . increment ( ) ; \n} \npublic synchronized long decrement ( ) { \nreturn this . counter . decrement ( ) ; \n} \npublic synchronized long getCount ( ) { \nreturn this . counter . getCount ( ) ; \n} \npublic synchronized void reset ( ) { \nthis . counter . reset ( ) ; \nreturn ; \n} \npublic synchronized int hashCode ( ) { \nreturn this . counter . hashCode ( ) ; \n} \npublic synchronized boolean equals ( final Object obj ) { \nreturn this . counter . equals ( obj ) ; \n} \npublic synchronized String toString ( ) { \nreturn this . counter . toString ( ) ; \n} \npublic synchronized Object clone ( ) { \nreturn this . counter . clone ( ) ; \n} \n} \n; \n} \n} \n"}
{"9316": "public class LongCounter { \npublic static LongCounter makeDirectional ( final LongCounter counter , final boolean increasing ) { \nLongCounter temp ; \nif ( increasing ) { \ntemp = new Wrapper ( counter ) { \nprivate static final long serialVersionUID = - 8902748795144754375L ; \npublic long decrement ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \npublic void reset ( ) { \nthrow new UnsupportedOperationException ( ) ; \nreturn ; \n} \n} \n; \n} \nelse { \ntemp = new Wrapper ( counter ) { \nprivate static final long serialVersionUID = 2584758778978644599L ; \npublic long increment ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \nreturn temp ; \n} \n} \n"}
{"9318": "public class NotifyingBufferedOutputStream { \npublic void checkNotification ( int result ) { \nchunk += result ; \nif ( chunk >= chunkSize ) { \nif ( listener != null ) listener . onStreamNotification ( this , chunk ) ; \nchunk = 0 ; \n} \nreturn ; \n} \n} \n"}
{"9319": "public class NonSerializableFactory { \npublic static synchronized void rebind ( Name name , Object target , boolean createSubcontexts ) throws NamingException { \nString key = name . toString ( ) ; \nInitialContext ctx = new InitialContext ( ) ; \nif ( createSubcontexts == true && name . size ( ) > 1 ) { \nint size = name . size ( ) - 1 ; \nUtil . createSubcontext ( ctx , name . getPrefix ( size ) ) ; \n} \nrebind ( ctx , key , target ) ; \nreturn ; \n} \n} \n"}
{"9324": "public class Strings { \npublic static final void defaultToString ( JBossStringBuilder buffer , Object object ) { \nif ( object == null ) buffer . append ( \"null\" ) ; \nelse { \nbuffer . append ( object . getClass ( ) . getName ( ) ) ; \nbuffer . append ( '@' ) ; \nbuffer . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9326": "public class TimedCachePolicy { \npublic void create ( ) { \nif ( threadSafe ) entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \nelse entryMap = new HashMap ( ) ; \nnow = System . currentTimeMillis ( ) ; \nreturn ; \n} \n} \n"}
{"9329": "public class TimedCachePolicy { \npublic void remove ( Object key ) { \nTimedEntry entry = ( TimedEntry ) entryMap . remove ( key ) ; \nif ( entry != null ) entry . destroy ( ) ; \nreturn ; \n} \n} \n"}
{"9330": "public class TimedCachePolicy { \npublic void flush ( ) { \nMap tmpMap = null ; \nsynchronized ( this ) { \ntmpMap = entryMap ; \nif ( threadSafe ) entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; \nelse entryMap = new HashMap ( ) ; \n} \nIterator iter = tmpMap . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nTimedEntry entry = ( TimedEntry ) iter . next ( ) ; \nentry . destroy ( ) ; \n} \ntmpMap . clear ( ) ; \nreturn ; \n} \n} \n"}
{"9332": "public class TimedCachePolicy { \npublic synchronized void setResolution ( int resolution ) { \nif ( resolution <= 0 ) resolution = 60 ; \nif ( resolution != this . resolution ) { \nthis . resolution = resolution ; \ntheTimer . cancel ( ) ; \ntheTimer = new ResolutionTimer ( ) ; \nresolutionTimer . scheduleAtFixedRate ( theTimer , 0 , 1000 * resolution ) ; \n} \nreturn ; \n} \n} \n"}
{"9340": "public class BasicThreadPool { \npublic void setMaximumQueueSize ( int size ) { \nArrayList tmp = new ArrayList ( ) ; \nqueue . drainTo ( tmp ) ; \nqueue = new LinkedBlockingQueue ( size ) ; \nqueue . addAll ( tmp ) ; \nThreadFactory tf = executor . getThreadFactory ( ) ; \nRejectedExecutionHandler handler = executor . getRejectedExecutionHandler ( ) ; \nlong keepAlive = executor . getKeepAliveTime ( TimeUnit . SECONDS ) ; \nint cs = executor . getCorePoolSize ( ) ; \nint mcs = executor . getMaximumPoolSize ( ) ; \nexecutor = new ThreadPoolExecutor ( cs , mcs , keepAlive , TimeUnit . SECONDS , queue ) ; \nexecutor . setThreadFactory ( tf ) ; \nexecutor . setRejectedExecutionHandler ( handler ) ; \nreturn ; \n} \n} \n"}
{"9341": "public class BasicThreadPool { \npublic void setBlockingMode ( String name ) { \nblockingMode = BlockingMode . toBlockingMode ( name ) ; \nif ( blockingMode == null ) blockingMode = BlockingMode . ABORT ; \nreturn ; \n} \n} \n"}
{"9342": "public class BasicThreadPool { \npublic void setBlockingModeString ( String name ) { \nblockingMode = BlockingMode . toBlockingMode ( name ) ; \nif ( blockingMode == null ) blockingMode = BlockingMode . ABORT ; \nreturn ; \n} \n} \n"}
{"9343": "public class BasicThreadPool { \nprotected void execute ( TaskWrapper wrapper ) { \nif ( trace ) log . trace ( \"execute, wrapper=\" + wrapper ) ; \ntry { \nexecutor . execute ( wrapper ) ; \n} \ncatch ( Throwable t ) { \nwrapper . rejectTask ( new ThreadPoolFullException ( \"Error scheduling work: \" + wrapper , t ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9355": "public class SAXCatalogReader { \npublic void readCatalog ( Catalog catalog , String fileUrl ) throws MalformedURLException , IOException , CatalogException { \nURL url = null ; \ntry { \nurl = new URL ( fileUrl ) ; \n} \ncatch ( MalformedURLException e ) { \nurl = new URL ( \"file:///\" + fileUrl ) ; \n} \ndebug = catalog . getCatalogManager ( ) . debug ; \ntry { \nURLConnection urlCon = url . openConnection ( ) ; \nreadCatalog ( catalog , urlCon . getInputStream ( ) ) ; \n} \ncatch ( FileNotFoundException e ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Failed to load catalog, file not found\" , url . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9356": "public class SAXCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nif ( parserFactory == null && parserClass == null ) { \ndebug . message ( 1 , \"Cannot read SAX catalog without a parser\" ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ndebug = catalog . getCatalogManager ( ) . debug ; \nEntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; \nthis . catalog = catalog ; \ntry { \nif ( parserFactory != null ) { \nSAXParser parser = parserFactory . newSAXParser ( ) ; \nSAXParserHandler spHandler = new SAXParserHandler ( ) ; \nspHandler . setContentHandler ( this ) ; \nif ( bResolver != null ) { \nspHandler . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) , spHandler ) ; \n} \nelse { \nParser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; \nparser . setDocumentHandler ( this ) ; \nif ( bResolver != null ) { \nparser . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) ) ; \n} \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \ncatch ( SAXException se ) { \nException e = se . getException ( ) ; \nUnknownHostException uhe = new UnknownHostException ( ) ; \nFileNotFoundException fnfe = new FileNotFoundException ( ) ; \nif ( e != null ) { \nif ( e . getClass ( ) == uhe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \nelse if ( e . getClass ( ) == fnfe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \n} \nthrow new CatalogException ( se ) ; \n} \nreturn ; \n} \n} \n"}
{"9357": "public class FileURLConnection { \npublic void connect ( ) throws IOException { \nif ( connected ) return ; \nif ( ! file . exists ( ) ) { \nthrow new FileNotFoundException ( file . getPath ( ) ) ; \n} \nconnected = true ; \nreturn ; \n} \n} \n"}
{"9360": "public class Node { \nvoid helpDelete ( Node < K , V > b , Node < K , V > f ) { \nif ( f == next && this == b . next ) { \nif ( f == null || f . value != f ) appendMarker ( f ) ; \nelse b . casNext ( this , f . next ) ; \n} \nreturn ; \n} \n} \n"}
{"9365": "public class JBossObject { \npublic static void list ( JBossStringBuilder buffer , Collection objects ) { \nif ( objects == null ) return ; \nbuffer . append ( '[' ) ; \nif ( objects . isEmpty ( ) == false ) { \nfor ( Iterator i = objects . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nObject object = i . next ( ) ; \nif ( object instanceof JBossObject ) ( ( JBossObject ) object ) . toShortString ( buffer ) ; \nelse buffer . append ( object . toString ( ) ) ; \nif ( i . hasNext ( ) ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( ']' ) ; \nreturn ; \n} \n} \n"}
{"9373": "public class PropertyMap { \nprivate void init ( ) { \nunboundListeners = Collections . synchronizedList ( new ArrayList ( ) ) ; \nboundListeners = Collections . synchronizedMap ( new HashMap ( ) ) ; \njndiMap = new HashMap ( ) ; \nPrivilegedAction action = new PrivilegedAction ( ) { \npublic Object run ( ) { \nObject value = System . getProperty ( Context . PROVIDER_URL ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( Context . PROVIDER_URL , value ) ; \nvalue = System . getProperty ( Context . INITIAL_CONTEXT_FACTORY ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( Context . INITIAL_CONTEXT_FACTORY , value ) ; \nvalue = System . getProperty ( Context . OBJECT_FACTORIES ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( Context . OBJECT_FACTORIES , value ) ; \nvalue = System . getProperty ( Context . URL_PKG_PREFIXES ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( Context . URL_PKG_PREFIXES , value ) ; \nvalue = System . getProperty ( Context . STATE_FACTORIES ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( Context . STATE_FACTORIES , value ) ; \nvalue = System . getProperty ( Context . DNS_URL ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( Context . DNS_URL , value ) ; \nvalue = System . getProperty ( LdapContext . CONTROL_FACTORIES ) ; \nif ( value == null ) value = NULL_VALUE ; \njndiMap . put ( LdapContext . CONTROL_FACTORIES , value ) ; \nreturn null ; \n} \n} \n; \nAccessController . doPrivileged ( action ) ; \nreturn ; \n} \n} \n"}
{"9374": "public class PropertyMap { \nprivate void updateJndiCache ( String name , String value ) { \nif ( name == null ) return ; \nboolean isJndiProperty = name . equals ( Context . PROVIDER_URL ) || name . equals ( Context . INITIAL_CONTEXT_FACTORY ) || name . equals ( Context . OBJECT_FACTORIES ) || name . equals ( Context . URL_PKG_PREFIXES ) || name . equals ( Context . STATE_FACTORIES ) || name . equals ( Context . DNS_URL ) || name . equals ( LdapContext . CONTROL_FACTORIES ) ; \nif ( isJndiProperty == true ) jndiMap . put ( name , value ) ; \nreturn ; \n} \n} \n"}
{"9378": "public class PropertyMap { \nprivate void firePropertyAdded ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyAdded ( event ) ; \n} \nreturn ; \n} \n} \n"}
{"9379": "public class PropertyMap { \nprivate void firePropertyRemoved ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyRemoved ( event ) ; \n} \nreturn ; \n} \n} \n"}
{"9380": "public class PropertyMap { \nprivate void firePropertyChanged ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyChanged ( event ) ; \n} \nreturn ; \n} \n} \n"}
{"9381": "public class PropertyMap { \nprotected void firePropertyChanged ( PropertyEvent event ) { \nif ( boundListeners != null ) { \nList list = ( List ) boundListeners . get ( event . getPropertyName ( ) ) ; \nif ( list != null ) { \nfirePropertyChanged ( list , event ) ; \n} \n} \nfirePropertyChanged ( unboundListeners , event ) ; \nreturn ; \n} \n} \n"}
{"9383": "public class PropertyMap { \npublic void load ( PropertyReader reader ) throws PropertyException , IOException { \nif ( reader == null ) throw new NullArgumentException ( \"reader\" ) ; \nload ( reader . readProperties ( ) ) ; \nreturn ; \n} \n} \n"}
{"9384": "public class PropertyMap { \npublic void load ( String className ) throws PropertyException , IOException { \nif ( className == null ) throw new NullArgumentException ( \"className\" ) ; \nPropertyReader reader = null ; \ntry { \nClass type = Class . forName ( className ) ; \nreader = ( PropertyReader ) type . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new PropertyException ( e ) ; \n} \nload ( reader ) ; \nreturn ; \n} \n} \n"}
{"9390": "public class ElementEditor { \npublic void setAsText ( String text ) { \nDocument d = getAsDocument ( text ) ; \nsetValue ( d . getDocumentElement ( ) ) ; \nreturn ; \n} \n} \n"}
{"9395": "public class StopWatch { \npublic void start ( final boolean reset ) { \nif ( ! running ) { \nif ( reset ) reset ( ) ; \nstart = System . currentTimeMillis ( ) ; \nrunning = true ; \n} \nreturn ; \n} \n} \n"}
{"9397": "public class StopWatch { \npublic static StopWatch makeSynchronized ( final StopWatch watch ) { \nreturn new Wrapper ( watch ) { \nprivate static final long serialVersionUID = - 6284244000894114817L ; \npublic synchronized void start ( final boolean reset ) { \nthis . watch . start ( reset ) ; \nreturn ; \n} \npublic synchronized void start ( ) { \nthis . watch . start ( ) ; \nreturn ; \n} \npublic synchronized long stop ( ) { \nreturn this . watch . stop ( ) ; \n} \npublic synchronized void reset ( ) { \nthis . watch . reset ( ) ; \nreturn ; \n} \npublic synchronized long getLapTime ( ) { \nreturn this . watch . getLapTime ( ) ; \n} \npublic synchronized long getAverageLapTime ( ) { \nreturn this . watch . getAverageLapTime ( ) ; \n} \npublic synchronized int getLapCount ( ) { \nreturn this . watch . getLapCount ( ) ; \n} \npublic synchronized long getTime ( ) { \nreturn this . watch . getTime ( ) ; \n} \npublic synchronized boolean isRunning ( ) { \nreturn this . watch . isRunning ( ) ; \n} \npublic synchronized String toString ( ) { \nreturn this . watch . toString ( ) ; \n} \n} \n; \n} \n} \n"}
{"9401": "public class LRUCachePolicy { \npublic void create ( ) { \nm_map = createMap ( ) ; \nm_list = createList ( ) ; \nm_list . m_maxCapacity = m_maxCapacity ; \nm_list . m_minCapacity = m_minCapacity ; \nm_list . m_capacity = m_maxCapacity ; \nreturn ; \n} \n} \n"}
{"9402": "public class FieldBoundPropertyListener { \nprotected void setFieldValue ( String value ) { \ntry { \nvalue = filterValue ( value ) ; \nClass < ? > type = fieldInstance . getField ( ) . getType ( ) ; \nPropertyEditor editor = PropertyEditors . findEditor ( type ) ; \neditor . setAsText ( value ) ; \nObject coerced = editor . getValue ( ) ; \nfieldInstance . set ( coerced ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new PropertyException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9404": "public class DateEditor { \npublic static void initialize ( ) { \nPrivilegedAction action = new PrivilegedAction ( ) { \npublic Object run ( ) { \nString defaultFormat = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.format\" , \"MMM d, yyyy\" ) ; \nString defaultLocale = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.locale\" ) ; \nDateFormat defaultDateFormat ; \nif ( defaultLocale == null || defaultLocale . length ( ) == 0 ) { \ndefaultDateFormat = new SimpleDateFormat ( defaultFormat ) ; \n} \nelse { \ndefaultDateFormat = new SimpleDateFormat ( defaultFormat , Strings . parseLocaleString ( defaultLocale ) ) ; \n} \nformats = new DateFormat [ ] { \ndefaultDateFormat , new SimpleDateFormat ( \"EEE MMM d HH:mm:ss z yyyy\" ) , new SimpleDateFormat ( \"EEE, d MMM yyyy HH:mm:ss Z\" ) } \n; \nreturn null ; \n} \n} \n; \nAccessController . doPrivileged ( action ) ; \nreturn ; \n} \n} \n"}
{"9406": "public class Graph { \npublic void setRootVertex ( Vertex < T > root ) { \nthis . rootVertex = root ; \nif ( verticies . containsValue ( root ) == false ) addVertex ( root ) ; \nreturn ; \n} \n} \n"}
{"9408": "public class Graph { \npublic void depthFirstSearch ( Vertex < T > v , final Visitor < T > visitor ) { \nVisitorEX < T , RuntimeException > wrapper = new VisitorEX < T , RuntimeException > ( ) { \npublic void visit ( Graph < T > g , Vertex < T > v ) throws RuntimeException { \nif ( visitor != null ) visitor . visit ( g , v ) ; \nreturn ; \n} \n} \n; \nthis . depthFirstSearch ( v , wrapper ) ; \nreturn ; \n} \n} \n"}
{"9409": "public class Graph { \npublic void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { \nv . visit ( ) ; \nif ( visitor != null ) visitor . visit ( this , v ) ; \nfor ( int i = 0 ; \ni < v . getOutgoingEdgeCount ( ) ; \ni ++ ) { \nEdge < T > e = v . getOutgoingEdge ( i ) ; \nif ( ! e . getTo ( ) . visited ( ) ) { \nif ( visitor != null ) visitor . visit ( this , v , e ) ; \ne . mark ( ) ; \ndfsSpanningTree ( e . getTo ( ) , visitor ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attribs . getLength ( ) ; \ni ++ ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( uri == null && qname . startsWith ( \"xmlns\" ) ) { \nlog . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \n} \nelse { \ndestElement . setAttributeNS ( uri , qname , value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9424": "public class DeadlockDetector { \npublic void addWaiting ( Object holder , Resource resource ) { \nsynchronized ( waiting ) { \nwaiting . put ( holder , resource ) ; \n} \nreturn ; \n} \n} \n"}
{"9425": "public class DOMCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nDocumentBuilderFactory factory = null ; \nDocumentBuilder builder = null ; \nfactory = DocumentBuilderFactory . newInstance ( ) ; \nfactory . setNamespaceAware ( false ) ; \nfactory . setValidating ( false ) ; \ntry { \nbuilder = factory . newDocumentBuilder ( ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nDocument doc = null ; \ntry { \ndoc = builder . parse ( is ) ; \n} \ncatch ( SAXException se ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \nElement root = doc . getDocumentElement ( ) ; \nString namespaceURI = Namespaces . getNamespaceURI ( root ) ; \nString localName = Namespaces . getLocalName ( root ) ; \nString domParserClass = getCatalogParser ( namespaceURI , localName ) ; \nif ( domParserClass == null ) { \nif ( namespaceURI == null ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + localName ) ; \n} \nelse { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + \"{\" + namespaceURI + \"}\" + localName ) ; \n} \nreturn ; \n} \nDOMCatalogParser domParser = null ; \ntry { \ndomParser = ( DOMCatalogParser ) Class . forName ( domParserClass ) . newInstance ( ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot load XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot instantiate XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot access XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ClassCastException cce ) { \ncatalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot cast XML Catalog Parser class\" , domParserClass ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \nNode node = root . getFirstChild ( ) ; \nwhile ( node != null ) { \ndomParser . parseCatalogEntry ( catalog , node ) ; \nnode = node . getNextSibling ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9426": "public class DOMCatalogReader { \npublic void readCatalog ( Catalog catalog , String fileUrl ) throws MalformedURLException , IOException , CatalogException { \nURL url = new URL ( fileUrl ) ; \nURLConnection urlCon = url . openConnection ( ) ; \nreadCatalog ( catalog , urlCon . getInputStream ( ) ) ; \nreturn ; \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \nfor ( int u = 0 ; \nu < length ; \nu ++ ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < ifaces . length ; \ni ++ ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( clazz == null ) buffer . append ( \"**null**\" ) ; \nelse { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( intfs . length > 0 ) { \nbuffer . append ( \" intfs=\" ) ; \nfor ( int i = 0 ; \ni < intfs . length ; \n++ i ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( i < intfs . length - 1 ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( \"}\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \nreturn ; \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn ++ ) { \nallIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9445": "public class WeakSet { \nprotected final void maintain ( ) { \nWeakObject weak ; \nwhile ( ( weak = ( WeakObject ) queue . poll ( ) ) != null ) { \nset . remove ( weak ) ; \n} \nreturn ; \n} \n} \n"}
{"9446": "public class WeakSet { \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nIterator iter = set . iterator ( ) ; \nObject UNKNOWN = new Object ( ) ; \nObject next = UNKNOWN ; \npublic boolean hasNext ( ) { \nif ( next != UNKNOWN ) { \nreturn true ; \n} \nwhile ( iter . hasNext ( ) ) { \nWeakObject weak = ( WeakObject ) iter . next ( ) ; \nObject obj = null ; \nif ( weak != null && ( obj = weak . get ( ) ) == null ) { \ncontinue ; \n} \nnext = obj ; \nreturn true ; \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( ( next == UNKNOWN ) && ! hasNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \nObject obj = next ; \nnext = UNKNOWN ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) return true ; \nwhile ( next == null ) { \nif ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \nelse { \nbreak ; \n} \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9449": "public class PropertyGroup { \nprotected void addPropertyListener ( final BoundPropertyListener listener ) { \nString name = makePropertyName ( listener . getPropertyName ( ) ) ; \nList list = ( List ) boundListeners . get ( name ) ; \nif ( list == null ) { \nlist = new ArrayList ( ) ; \nboundListeners . put ( name , list ) ; \n} \nif ( ! list . contains ( listener ) ) { \nlist . add ( listener ) ; \nlistener . propertyBound ( this ) ; \n} \nreturn ; \n} \n} \n"}
{"9453": "public class PropertyEditors { \npublic static void registerEditor ( final String typeName , final String editorTypeName ) throws ClassNotFoundException { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nClass < ? > type = loader . loadClass ( typeName ) ; \nClass < ? > editorType = loader . loadClass ( editorTypeName ) ; \nPropertyEditorManager . registerEditor ( type , editorType ) ; \nreturn ; \n} \n} \n"}
{"9458": "public class TimeoutFactory { \nprivate void doWork ( ) { \nwhile ( cancelled . get ( ) == false ) { \nTimeoutExt work = queue . take ( ) ; \nif ( work != null ) { \nTimeoutWorker worker = new TimeoutWorker ( work ) ; \ntry { \nthreadPool . run ( worker ) ; \n} \ncatch ( Throwable t ) { \nThrowableHandler . add ( ThrowableHandler . Type . ERROR , t ) ; \n} \nsynchronized ( work ) { \nwork . done ( ) ; \n} \n} \n} \nqueue . cancel ( ) ; \nreturn ; \n} \n} \n"}
{"9461": "public class Util { \nprotected static void checkObject ( Context context , String name , Object object , Class clazz ) throws Exception { \nClass objectClass = object . getClass ( ) ; \nif ( clazz . isAssignableFrom ( objectClass ) == false ) { \nStringBuffer buffer = new StringBuffer ( 100 ) ; \nbuffer . append ( \"Object at '\" ) . append ( name ) ; \nbuffer . append ( \"' in context \" ) . append ( context . getEnvironment ( ) ) ; \nbuffer . append ( \" is not an instance of \" ) ; \nappendClassInfo ( buffer , clazz ) ; \nbuffer . append ( \" object class is \" ) ; \nappendClassInfo ( buffer , object . getClass ( ) ) ; \nthrow new ClassCastException ( buffer . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9462": "public class Util { \nprotected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { \nbuffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; \nbuffer . append ( \" interfaces={\" ) ; \nClass [ ] interfaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \n++ i ) { \nif ( i > 0 ) buffer . append ( \", \" ) ; \nbuffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; \n} \nbuffer . append ( \"}]\" ) ; \nreturn ; \n} \n} \n"}
{"9464": "public class CatalogManager { \nprivate synchronized void readProperties ( ) { \ntry { \npropertyFileURI = CatalogManager . class . getResource ( \"/\" + propertyFile ) ; \nInputStream in = CatalogManager . class . getResourceAsStream ( \"/\" + propertyFile ) ; \nif ( in == null ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Cannot find \" + propertyFile ) ; \nignoreMissingProperties = true ; \n} \nreturn ; \n} \nresources = new PropertyResourceBundle ( in ) ; \n} \ncatch ( MissingResourceException mre ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Cannot read \" + propertyFile ) ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . println ( \"Failure trying to read \" + propertyFile ) ; \n} \n} \nif ( verbosity == null ) { \ntry { \nString verbStr = resources . getString ( \"verbosity\" ) ; \nint verb = Integer . parseInt ( verbStr . trim ( ) ) ; \ndebug . setDebug ( verb ) ; \nverbosity = new Integer ( verb ) ; \n} \ncatch ( Exception e ) { \n} \n} \nreturn ; \n} \n} \n"}
{"9475": "public class MethodBoundPropertyListener { \nprotected void invokeSetter ( String value ) { \ntry { \nClass < ? > type = descriptor . getPropertyType ( ) ; \nPropertyEditor editor = PropertyEditors . findEditor ( type ) ; \neditor . setAsText ( value ) ; \nObject coerced = editor . getValue ( ) ; \nsetter . invoke ( instance , new Object [ ] { \ncoerced } \n) ; \n} \ncatch ( InvocationTargetException e ) { \nThrowable target = e . getTargetException ( ) ; \nif ( target instanceof PropertyException ) { \nthrow ( PropertyException ) target ; \n} \nelse { \nthrow new PropertyException ( target ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new PropertyException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9481": "public class FilePropertyReader { \nprotected void loadProperties ( Properties props , String filename ) throws IOException { \nif ( filename == null ) throw new NullArgumentException ( \"filename\" ) ; \nif ( filename . equals ( \"\" ) ) throw new IllegalArgumentException ( \"filename\" ) ; \nInputStream in = new BufferedInputStream ( getInputStream ( filename ) ) ; \nprops . load ( in ) ; \nin . close ( ) ; \nreturn ; \n} \n} \n"}
{"9484": "public class Vertex { \npublic void addOutgoingEdge ( Vertex < T > to , int cost ) { \nEdge < T > out = new Edge < T > ( this , to , cost ) ; \noutgoingEdges . add ( out ) ; \nreturn ; \n} \n} \n"}
{"9485": "public class Vertex { \npublic void addIncomingEdge ( Vertex < T > from , int cost ) { \nEdge < T > out = new Edge < T > ( this , from , cost ) ; \nincomingEdges . add ( out ) ; \nreturn ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9493": "public class TinyMachine { \npublic void fireEvent ( Object event ) { \nif ( event == null ) { \nthrow new IllegalArgumentException ( \"Event must not be null.\" ) ; \n} \nmTaskQueue . offer ( Task . obtainTask ( Task . CODE_FIRE_EVENT , event , - 1 ) ) ; \nif ( ! mQueueProcessed ) processTaskQueue ( ) ; \nreturn ; \n} \n} \n"}
{"9494": "public class StructsBatchCompiler { \nprivate void internalInstallJvmTypeProvider ( XtextResourceSet resourceSet , File tmpClassDirectory , boolean skipIndexLookup ) { \nIterable < String > classPathEntries = concat ( getClassPathEntries ( ) , getSourcePathDirectories ( ) , asList ( tmpClassDirectory . toString ( ) ) ) ; \nclassPathEntries = filter ( classPathEntries , new Predicate < String > ( ) { \npublic boolean apply ( String input ) { \nreturn ! Strings . isEmpty ( input . trim ( ) ) ; \n} \n} \n) ; \nFunction < String , URL > toUrl = new Function < String , URL > ( ) { \npublic URL apply ( String from ) { \ntry { \nreturn new File ( from ) . toURI ( ) . toURL ( ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n; \nIterable < URL > classPathUrls = Iterables . transform ( classPathEntries , toUrl ) ; \nlog . debug ( \"classpath used for Struct compilation : \" + classPathUrls ) ; \nClassLoader parentClassLoader ; \nif ( useCurrentClassLoaderAsParent ) { \nparentClassLoader = currentClassLoader ; \n} \nelse { \nif ( isEmpty ( bootClassPath ) ) { \nparentClassLoader = ClassLoader . getSystemClassLoader ( ) . getParent ( ) ; \n} \nelse { \nIterable < URL > bootClassPathUrls = Iterables . transform ( getBootClassPathEntries ( ) , toUrl ) ; \nparentClassLoader = new BootClassLoader ( toArray ( bootClassPathUrls , URL . class ) ) ; \n} \n} \nClassLoader urlClassLoader = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , parentClassLoader ) ; \nnew ClasspathTypeProvider ( urlClassLoader , resourceSet , skipIndexLookup ? null : indexedJvmTypeAccess ) ; \nresourceSet . setClasspathURIContext ( urlClassLoader ) ; \nURLClassLoader urlClassLoaderForAnnotationProcessing = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , currentClassLoader ) ; \nresourceSet . eAdapters ( ) . add ( new ProcessorClassloaderAdapter ( urlClassLoaderForAnnotationProcessing ) ) ; \nreturn ; \n} \n} \n"}
{"9496": "public class Dispatcher { \npublic void dispatchOnFxThread ( Action action ) { \nif ( Platform . isFxApplicationThread ( ) ) { \nactionStream . push ( action ) ; \n} \nelse { \nPlatform . runLater ( ( ) -> actionStream . push ( action ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9504": "public class TakeOrderSteps { \n@ Then ( \"^the instruction generated should be \\\"([^\\\"]*)\\\"$\" ) public void the_instruction_generated_should_be ( String command ) throws Throwable { \nverify ( context . getDrinkMaker ( ) ) . executeCommand ( eq ( command ) ) ; \nreturn ; \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nint n = 1 ; \nif ( args . length < 1 ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( an != null ) { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nelse { \nusage ( ) ; \nreturn ; \n} \nif ( args . length > 1 ) { \ntry { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \n} \nFile path = new File ( args [ 0 ] ) ; \nSystem . out . println ( \"analyzer=\" + analyzer . getClass ( ) . getName ( ) ) ; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \nreturn ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \nSystem . out . println ( \"Usage:\" ) ; \nSystem . out . println ( \"\\t-Dmode=simple, defalut is complex\" ) ; \nSystem . out . println ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) { \nseg = new SimpleSeg ( dic ) ; \n} \nelse { \nseg = new ComplexSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . println ( \"use \" + time + \"ms\" ) ; \nreturn ; \n} \n} \n"}
{"9509": "public class JdbcKeepWordFilterFactory { \n@ Override public void inform ( ResourceLoader loader ) throws IOException { \nsuper . inform ( new JdbcResourceLoader ( loader , reader , StandardCharsets . UTF_8 ) ) ; \nreturn ; \n} \n} \n"}
{"9510": "public class SimpleJdbcReader { \nprotected final void checkDatasource ( ) { \nif ( dataSource != null ) { \ntry ( Connection connection = dataSource . getConnection ( ) ) { \n} \ncatch ( SQLException e ) { \ndataSource = null ; \nlogger . error ( \"Failed to connect to database of data source: {}.\" , e . getMessage ( ) ) ; \nif ( ! ignore ) { \nthrow new IllegalArgumentException ( \"Failed to connect to the database.\" , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"9526": "public class TableHelper { \nprotected void onUpgrade ( final SQLiteDatabase db , final int oldVersion , final int newVersion ) { \ndb . execSQL ( upgradeSql ( oldVersion , newVersion ) ) ; \nreturn ; \n} \n} \n"}
{"9528": "public class TableHelper { \npublic void restore ( SQLiteDatabase db , Context ctx , String suffix ) { \nnew CsvTableReader ( this ) . importFromCsv ( ctx , db , suffix ) ; \nreturn ; \n} \n} \n"}
{"9529": "public class ContactActivity { \npublic void setEmptyText ( CharSequence emptyText ) { \nif ( mListView != null ) { \nView emptyView = mListView . getEmptyView ( ) ; \nif ( emptyText instanceof TextView ) { \n( ( TextView ) emptyView ) . setText ( emptyText ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9538": "public class DatabaseModel { \npublic void writeToIndex ( PrintWriter out ) { \nout . println ( StormEnvironment . BEGIN_DATABASE ) ; \nMap < String , String > dbMap = new HashMap < String , String > ( ) ; \ndbMap . put ( \"dbName\" , this . getDbName ( ) ) ; \ndbMap . put ( \"dbVersion\" , String . valueOf ( this . getDbVersion ( ) ) ) ; \ndbMap . put ( \"helperClass\" , this . getQualifiedClassName ( ) ) ; \nString dbInfo = CsvUtils . mapToCsv ( dbMap ) ; \nout . println ( dbInfo ) ; \nfor ( String th : this . tableHelpers ) { \nout . println ( th ) ; \n} \nout . println ( StormEnvironment . END_DATABASE ) ; \nreturn ; \n} \n} \n"}
{"9539": "public class EntityProcessor { \nprivate void inspectId ( ) { \nif ( entityModel . getIdField ( ) == null ) { \nList < FieldModel > fields = entityModel . getFields ( ) ; \nfor ( FieldModel f : fields ) { \nif ( EntityModel . DEFAULT_ID_FIELD . equals ( f . getFieldName ( ) ) ) { \nentityModel . setIdField ( f ) ; \n} \n} \n} \nFieldModel idField = entityModel . getIdField ( ) ; \nif ( idField != null && \"long\" . equals ( idField . getJavaType ( ) ) ) { \nreturn ; \n} \nelse { \nabort ( \"Entity must contain a field named id or annotated with @Id of type long\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9544": "public class DatabaseHelper { \npublic void restoreAllTablesFromCsv ( Context ctx , SQLiteDatabase db , String suffix ) { \nfor ( TableHelper table : getTableHelpers ( ) ) { \ntable . restore ( db , ctx , suffix ) ; \n} \nreturn ; \n} \n} \n"}
{"9545": "public class StormEnvironment { \nvoid writeIndex ( Filer filer ) { \nStandardLocation location = StandardLocation . SOURCE_OUTPUT ; \nFileObject indexFile ; \ntry { \nindexFile = filer . createResource ( location , \"com.turbomanage.storm\" , ENV_FILE ) ; \nOutputStream fos = indexFile . openOutputStream ( ) ; \nPrintWriter out = new PrintWriter ( fos ) ; \nout . println ( BEGIN_CONVERTERS ) ; \nfor ( ConverterModel converter : converters ) { \nconverter . writeToIndex ( out ) ; \n} \nout . println ( END_CONVERTERS ) ; \nfor ( DatabaseModel dbModel : dbModels . values ( ) ) { \ndbModel . writeToIndex ( out ) ; \n} \nout . close ( ) ; \n} \ncatch ( IOException e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9556": "public class PlanBindings { \npublic void add ( Plan plan , Set < Belief > planBindings ) { \nif ( plan == null ) { \nreturn ; \n} \nif ( this . bindings . containsKey ( plan ) ) { \nSet < Belief > oldBindings = this . bindings . remove ( plan ) ; \nif ( oldBindings == null || oldBindings . isEmpty ( ) ) { \ncachedsize -- ; \n} \nelse { \ncachedsize -= oldBindings . size ( ) ; \n} \n} \nthis . bindings . put ( plan , planBindings ) ; \nif ( planBindings == null || planBindings . isEmpty ( ) ) { \ncachedsize ++ ; \n} \nelse { \ncachedsize += planBindings . size ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9559": "public class PlanBindings { \nprivate final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { \nif ( agent == null || planInstance == null ) { \nreturn ; \n} \nBelief belief = getResultAtIndex ( results , choice ) ; \nif ( belief == null ) { \nreturn ; \n} \nObject [ ] tuple = belief . getTuple ( ) ; \nif ( tuple == null ) { \nreturn ; \n} \nint index = 0 ; \nHashMap < String , Object > vars = new HashMap < String , Object > ( ) ; \nfor ( Object o : belief . getTuple ( ) ) { \ntry { \nString fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; \nvars . put ( fieldname , o ) ; \n} \ncatch ( BeliefBaseException e ) { \nLog . error ( \"Agent \" + agent . getId ( ) + \" could not retrive belief set field: \" + e . getMessage ( ) ) ; \n} \nindex ++ ; \n} \nplanInstance . setPlanVariables ( vars ) ; \nreturn ; \n} \n} \n"}
{"9565": "public class Plan { \npublic void step ( ) { \nif ( body == null || body . length == 0 || index < 0 || index >= body . length ) { \nreturn ; \n} \nbody [ index ++ ] . step ( ) ; \nreturn ; \n} \n} \n"}
{"9566": "public class AgentType { \npublic void setGoals ( byte [ ] arr ) { \nif ( arr == null ) { \ngoals = null ; \nreturn ; \n} \ngoals = new byte [ arr . length ] ; \nSystem . arraycopy ( arr , 0 , goals , 0 , goals . length ) ; \nreturn ; \n} \n} \n"}
{"9567": "public class Program { \nstatic void pauseForUserInput ( ) { \nSystem . out . println ( \"Press the Enter/Return key to continue..\" ) ; \nScanner in = new Scanner ( System . in ) ; \nin . nextLine ( ) ; \nin . close ( ) ; \nreturn ; \n} \n} \n"}
{"9568": "public class Program { \npublic static void initIntentionSelectionPools ( int nagents , int ncores ) { \nMain . poolsize = ( nagents > ncores ) ? ( nagents / ncores ) : 1 ; \nMain . npools = ( nagents > ncores ) ? ncores : nagents ; \nreturn ; \n} \n} \n"}
{"9569": "public class Program { \nstatic void initIntentionSelectionThreads ( Config config ) { \nint ncores = config . getNumThreads ( ) ; \nMain . intentionSelectors = new IntentionSelector [ ncores ] ; \nfor ( int i = 0 ; \ni < Main . npools ; \ni ++ ) { \nMain . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9570": "public class Program { \nstatic void startIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \ni < Main . npools ; \ni ++ ) { \nThread thread = new Thread ( Main . intentionSelectors [ i ] ) ; \nthread . setName ( \"jill-\" + i ) ; \nthread . start ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9571": "public class Program { \nstatic void shutdownIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \ni < Main . npools ; \ni ++ ) { \nMain . intentionSelectors [ i ] . shutdown ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9572": "public class Program { \npublic static void registerExtension ( JillExtension extension ) { \nif ( extension != null ) { \nGlobalState . eventHandlers . add ( extension ) ; \nMain . logger . info ( \"Registered Jill extension: \" + extension ) ; \n} \nelse { \nMain . logger . warn ( \"Cannot register null extension; will ignore.\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9573": "public class GlobalState { \npublic static void reset ( ) { \nagentTypes = new AObjectCatalog ( \"agentTypes\" , 5 , 5 ) ; \ngoalTypes = new AObjectCatalog ( \"goalTypes\" , 10 , 5 ) ; \nplanTypes = new AObjectCatalog ( \"planTypes\" , 20 , 5 ) ; \nagents = null ; \nbeliefbase = null ; \neventHandlers = new HashSet < JillExtension > ( ) ; \nreturn ; \n} \n} \n"}
{"9576": "public class ProgramLoader { \nprivate static void createAgentsInCatalog ( AObjectCatalog agents , AgentType atype , Class < ? > aclass , int num ) { \nint added = 0 ; \ntry { \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nAgent agent = ( Agent ) ( aclass . getConstructor ( String . class ) . newInstance ( \"a\" + Integer . toString ( i ) ) ) ; \nagent . setGoals ( atype . getGoals ( ) ) ; \nagents . push ( agent ) ; \nadded ++ ; \n} \nlogger . info ( \"Finished loading {} agents\" , added ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create instance of class \" + aclass . getName ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && i < args . length ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9582": "public class ArgumentsLoader { \nprivate static void parseArgumentWithOption ( String arg , String opt ) { \nswitch ( arg ) { \ncase \"--config\" : config = loadConfigFromString ( opt ) ; \nbreak ; \ncase \"--configfile\" : config = loadConfigFromFile ( opt ) ; \nbreak ; \ncase \"--exit-on-idle\" : GlobalConstant . EXIT_ON_IDLE = Boolean . parseBoolean ( opt ) ; \nbreak ; \ncase \"--plan-selection-policy\" : try { \nGlobalConstant . PLAN_SELECTION_POLICY = GlobalConstant . PlanSelectionPolicy . valueOf ( opt ) ; \n} \ncatch ( IllegalArgumentException e ) { \nabort ( \"Unknown plan selection policy '\" + opt + \"'\" ) ; \n} \nbreak ; \ncase \"--plan-instances-limit\" : try { \nGlobalConstant . PLAN_INSTANCES_LIMIT = Integer . parseInt ( opt ) ; \n} \ncatch ( NumberFormatException e ) { \nabort ( \"Option value '\" + opt + \"' is not a number\" ) ; \n} \nbreak ; \ndefault : break ; \n} \nreturn ; \n} \n} \n"}
{"9583": "public class BeliefBase { \npublic static void doEval ( BeliefBase bb , int agentId , String query ) throws BeliefBaseException { \nfinal long t0 = System . currentTimeMillis ( ) ; \nbb . eval ( agentId , query ) ; \nfinal long t1 = System . currentTimeMillis ( ) ; \nLog . info ( \"Agent \" + agentId + \" searched for '\" + query + \"' \" + Log . formattedDuration ( t0 , t1 ) ) ; \nreturn ; \n} \n} \n"}
{"9586": "public class AObjectCatalog { \npublic void push ( AObject obj ) { \nif ( obj == null || obj . getId ( ) != GlobalConstant . NULLID ) { \nreturn ; \n} \nif ( nextid == objects . length ) { \ngrow ( ) ; \n} \nobj . setId ( nextid ) ; \nobjects [ nextid ++ ] = obj ; \nreturn ; \n} \n} \n"}
{"9592": "public class ABeliefStore { \npublic static void main ( String [ ] args ) throws BeliefBaseException { \nBeliefBase bb = new ABeliefStore ( 100 , 4 ) ; \nbb . eval ( 0 , \"neighbour.age < 31\" ) ; \nConsole console = System . console ( ) ; \nif ( console == null ) { \nSystem . err . println ( \"No console.\" ) ; \nSystem . exit ( 1 ) ; \n} \nwhile ( true ) { \nPattern pattern = Pattern . compile ( console . readLine ( \"%nEnter your regex: \" ) ) ; \nMatcher matcher = pattern . matcher ( console . readLine ( \"Enter input string to search: \" ) ) ; \nboolean found = false ; \nwhile ( matcher . find ( ) ) { \nconsole . format ( \"I found the text\" + \" \\\"%s\\\" starting at \" + \"index %d and ending at index %d.%n\" , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; \nfound = true ; \n} \nif ( ! found ) { \nconsole . format ( \"No match found.%n\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9594": "public class Agent { \nprivate void post ( Stack255 stack , Goal goal ) { \nsynchronized ( stack ) { \nlogger . debug ( \"{} posting goal {}\" , Log . logPrefix ( getId ( ) ) , goal . getClass ( ) . getSimpleName ( ) ) ; \nstack . push ( goal ) ; \nMain . setAgentIdle ( getId ( ) , false ) ; \n} \nMain . flagMessageTo ( Main . poolid ( getId ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"9598": "public class Agent { \npublic void createBeliefSet ( String name , BeliefSetField [ ] fields ) throws BeliefBaseException { \nbeliefbase . createBeliefSet ( getId ( ) , name , fields ) ; \nreturn ; \n} \n} \n"}
{"9599": "public class Agent { \npublic void addBelief ( String beliefsetName , Object ... tuple ) throws BeliefBaseException { \nbeliefbase . addBelief ( getId ( ) , beliefsetName , tuple ) ; \nreturn ; \n} \n} \n"}
{"9601": "public class Agent { \npublic void suspend ( boolean val ) { \nMain . setAgentIdle ( getId ( ) , val ) ; \nMain . flagMessageTo ( Main . poolid ( getId ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"9603": "public class Greeter { \nprivate void registerNeighbours ( Random rand , int count ) throws BeliefBaseException { \nint size = ( count < 0 ) ? 0 : count ; \nfor ( int i = 0 ; \ni < size ; \ni ++ ) { \nboolean male = ( rand . nextDouble ( ) < 0.5 ) ? true : false ; \nthis . addBelief ( beliefset , buildName ( male ) , male ? \"male\" : \"female\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9605": "public class IntentionSelector { \npublic void run ( ) { \nSet < Integer > toRemove = new HashSet < Integer > ( ) ; \ndo { \nboolean idle = true ; \nremoveInactiveAgents ( ) ; \naddActiveAgents ( ) ; \nfor ( Integer i : activeAgents ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nStack255 agentExecutionStack = ( Stack255 ) ( agent ) . getExecutionStack ( ) ; \nif ( ! isStackValid ( agent , agentExecutionStack ) ) { \ntoRemove . add ( i ) ; \ncontinue ; \n} \nidle = false ; \nObject node = ( Object ) agentExecutionStack . get ( ( byte ) ( agentExecutionStack . size ( ) - 1 ) ) ; \nif ( node instanceof Plan ) { \nmanagePlan ( i , agentExecutionStack , ( Plan ) node , toRemove ) ; \n} \nelse if ( node instanceof Goal ) { \nmanageGoal ( i , agent , agentExecutionStack , ( Goal ) node ) ; \n} \nagent . nextActiveStack ( ) ; \n} \nremoveFinishedAgents ( toRemove ) ; \nif ( idle ) { \nwaitOnExternalMessage ( ) ; \nif ( shutdown ) { \nbreak ; \n} \n} \n} \nwhile ( true ) ; \nlogger . debug ( \"Pool {} is exiting\" , poolid ) ; \nreturn ; \n} \n} \n"}
{"9607": "public class IntentionSelector { \nprivate void removeFinishedAgents ( Set < Integer > toRemove ) { \nif ( ! toRemove . isEmpty ( ) ) { \nfor ( int i : toRemove ) { \nactiveAgents . remove ( i ) ; \n} \ntoRemove . clear ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9609": "public class IntentionSelector { \npublic void shutdown ( ) { \nsynchronized ( lock ) { \nlogger . debug ( \"Pool {} received shutdown message\" , poolid ) ; \nshutdown = true ; \nhasMessage = true ; \nlock . notify ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9610": "public class IntentionSelector { \npublic void setAgentIdle ( int agentId , boolean idle ) { \nif ( ! idle ) { \nsynchronized ( extToAdd ) { \nextToAdd . add ( agentId ) ; \n} \n} \nif ( idle ) { \nsynchronized ( extToRemove ) { \nextToRemove . add ( agentId ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9613": "public class Main { \npublic static void waitUntilIdle ( ) { \nlong t0 = System . currentTimeMillis ( ) ; \nsynchronized ( poolsIdle ) { \nwhile ( ! arePoolsIdle ( ) ) { \ntry { \npoolsIdle . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \nlogger . error ( \"Failed to wait on termination condition: \" + e . getMessage ( ) ) ; \n} \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Finished running \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nreturn ; \n} \n} \n"}
{"9614": "public class Main { \npublic static void finish ( ) { \nfor ( JillExtension extension : GlobalState . eventHandlers ) { \nextension . finish ( ) ; \n} \nProgram . shutdownIntentionSelectionThreads ( ) ; \nlong t0 = System . currentTimeMillis ( ) ; \nfor ( int i = 0 ; \ni < GlobalState . agents . size ( ) ; \ni ++ ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nagent . finish ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Terminated \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nreturn ; \n} \n} \n"}
{"9618": "public class JpaTranslationContext { \npublic < E > void setExpression ( Expression < E > expression ) { \nPreconditions . checkState ( this . expression == null , \"An expression is already set\" ) ; \nthis . expression = expression ; \nreturn ; \n} \n} \n"}
{"9624": "public class RestServlet { \n@ Override protected void handleRequest ( RequestContext context ) throws IOException { \nHttpServletRequest httpRequest = context . getRequest ( ) ; \nHttpServletResponse httpResponse = context . getResponse ( ) ; \nArgumentsReader argumentsReader = null ; \nObject value = null ; \nManagedMethodSPI method = null ; \ntry { \nmethod = restMethods . get ( key ( httpRequest . getPathInfo ( ) ) ) ; \nif ( method == null ) { \nthrow new NoSuchMethodException ( ) ; \n} \nType [ ] formalParameters = method . getParameterTypes ( ) ; \nargumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; \nObject [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; \nObject instance = container . getInstance ( method . getDeclaringClass ( ) ) ; \nvalue = method . invoke ( instance , arguments ) ; \n} \ncatch ( AuthorizationException e ) { \nsendUnauthorized ( context ) ; \nreturn ; \n} \ncatch ( NoSuchMethodException e ) { \nsendNotFound ( context , e ) ; \nreturn ; \n} \ncatch ( IllegalArgumentException e ) { \nsendBadRequest ( context ) ; \nreturn ; \n} \ncatch ( InvocationException e ) { \nsendError ( context , e ) ; \nreturn ; \n} \nfinally { \nif ( argumentsReader != null ) { \nargumentsReader . clean ( ) ; \n} \n} \nhttpResponse . setCharacterEncoding ( \"UTF-8\" ) ; \nif ( method . isVoid ( ) ) { \nhttpResponse . setStatus ( HttpServletResponse . SC_NO_CONTENT ) ; \nreturn ; \n} \nContentType contentType = valueWriterFactory . getContentTypeForValue ( value ) ; \nhttpResponse . setStatus ( HttpServletResponse . SC_OK ) ; \nhttpResponse . setContentType ( contentType . getValue ( ) ) ; \nValueWriter valueWriter = valueWriterFactory . getValueWriter ( contentType ) ; \nvalueWriter . write ( httpResponse , value ) ; \nreturn ; \n} \n} \n"}
{"9628": "public class TransactionalResourceImpl { \n@ Override public void config ( Config config ) throws Exception { \nlog . trace ( \"config(Config.Element)\" ) ; \nlog . debug ( \"Configure transaction manager |%s|.\" , transactionManager . getClass ( ) ) ; \ntransactionManager . config ( config ) ; \nreturn ; \n} \n} \n"}
{"9630": "public class AbstractGenerator { \nprotected final void write ( @ NotNull final GeneratedArtifact artifact ) throws GenerateException { \nContract . requireArgNotNull ( \"artifact\" , artifact ) ; \nfinal GeneratedFile genFile = getTargetFile ( artifact . getName ( ) , artifact . getPathAndName ( ) , null ) ; \nif ( genFile . isSkip ( ) ) { \nLOG . debug ( \"Omitted already existing file: {} [{}]\" , genFile , artifact ) ; \n} \nelse { \nLOG . debug ( \"Writing file:  {} [{}]\" , genFile , artifact ) ; \ntry { \nfinal OutputStream out = new BufferedOutputStream ( new FileOutputStream ( genFile . getTmpFile ( ) ) ) ; \ntry { \nout . write ( artifact . getData ( ) ) ; \n} \nfinally { \nout . close ( ) ; \n} \ngenFile . persist ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new GenerateException ( \"Error writing artifact '\" + artifact + \"' to '\" + artifact . getPathAndName ( ) + \"'!\" , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9631": "public class InstanceFieldsInitializationProcessor { \n@ Override public void postProcessInstance ( ManagedClassSPI managedClass , Object instance ) { \nConfig config = managedClass . getConfig ( ) ; \nif ( config == null ) { \nreturn ; \n} \nList < Config > fields = config . findChildren ( \"instance-field\" ) ; \nif ( ! fields . isEmpty ( ) && ! InstanceType . POJO . equals ( managedClass . getInstanceType ( ) ) ) { \nthrow new BugError ( \"Cannot assign instance field on non %s type.\" , InstanceType . POJO ) ; \n} \nfor ( Config field : fields ) { \nClasses . setFieldValue ( instance , field . getAttribute ( \"name\" ) , field . getAttribute ( \"value\" ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9637": "public class GeneratedFile { \npublic final void persist ( ) { \nif ( persisted ) { \nreturn ; \n} \ntry { \nif ( FileUtils . contentEquals ( tmpFile , file ) ) { \nLOG . debug ( \"Omitted: {} {}\" , getPath ( ) , logInfo ) ; \nif ( ! tmpFile . delete ( ) ) { \ntmpFile . deleteOnExit ( ) ; \n} \n} \nelse { \nif ( file . exists ( ) && ! file . delete ( ) ) { \nthrow new IOException ( \"Wasn't able to delete file \" + file ) ; \n} \nif ( ! tmpFile . renameTo ( file ) ) { \nthrow new IOException ( \"Wasn't able to rename temporary file \" + tmpFile + \" to \" + file ) ; \n} \nLOG . info ( \"Generated: {} {}\" , getPath ( ) , logInfo ) ; \n} \npersisted = true ; \n} \ncatch ( final IOException ex ) { \nthrow new RuntimeException ( \"Error comparing content: tmp=\" + tmpFile + \", target=\" + file + logInfo , ex ) ; \n} \nreturn ; \n} \n} \n"}
{"9638": "public class AbstractEndpoint { \npublic final void setDefaultLink ( String rel , String ... hrefs ) { \nif ( hrefs == null || hrefs . length == 0 ) { \ndefaultLinks . remove ( rel ) ; \n} \nelse { \ndefaultLinks . put ( rel , stream ( hrefs ) . map ( uri :: resolve ) . collect ( toSet ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9639": "public class AbstractEndpoint { \npublic final void setDefaultLinkTemplate ( String rel , String href ) { \nif ( href == null ) { \ndefaultLinkTemplates . remove ( rel ) ; \n} \nelse { \ndefaultLinkTemplates . put ( rel , href ) ; \n} \nreturn ; \n} \n} \n"}
{"9640": "public class AbstractEndpoint { \n@ SuppressWarnings ( \"LocalVariableHidesMemberVariable\" ) private void handleLinks ( HttpResponse response ) { \nMap < String , Map < URI , String > > links = new HashMap < > ( ) ; \nMap < String , String > linkTemplates = new HashMap < > ( ) ; \nhandleHeaderLinks ( response , links , linkTemplates ) ; \nHttpEntity entity = response . getEntity ( ) ; \nif ( entity != null ) { \nHeader contentType = entity . getContentType ( ) ; \nif ( ( contentType != null ) && contentType . getValue ( ) . startsWith ( \"application/json\" ) ) { \ntry { \nhandleBodyLinks ( serializer . readTree ( entity . getContent ( ) ) , links , linkTemplates ) ; \n} \ncatch ( IOException ex ) { \nthrow new RuntimeException ( ) ; \n} \n} \n} \nthis . links = unmodifiableMap ( links ) ; \nthis . linkTemplates = unmodifiableMap ( linkTemplates ) ; \nreturn ; \n} \n} \n"}
{"9641": "public class AbstractEndpoint { \nprotected void handleHeaderLinks ( HttpResponse response , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { \ngetLinkHeaders ( response ) . forEach ( header -> { \nif ( header . getRel ( ) == null ) { \nreturn ; \n} \nif ( header . isTemplated ( ) ) { \nlinkTemplates . put ( header . getRel ( ) , header . getHref ( ) ) ; \n} \nelse { \ngetOrAdd ( links , header . getRel ( ) ) . put ( uri . resolve ( header . getHref ( ) ) , header . getTitle ( ) ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"9642": "public class AbstractEndpoint { \nprotected void handleBodyLinks ( JsonNode jsonBody , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { \nif ( jsonBody . getNodeType ( ) != JsonNodeType . OBJECT ) { \nreturn ; \n} \nJsonNode linksNode = jsonBody . get ( \"_links\" ) ; \nif ( linksNode == null ) { \nlinksNode = jsonBody . get ( \"links\" ) ; \n} \nif ( linksNode == null ) { \nreturn ; \n} \nlinksNode . fields ( ) . forEachRemaining ( x -> { \nString rel = x . getKey ( ) ; \nMap < URI , String > linksForRel = getOrAdd ( links , rel ) ; \nswitch ( x . getValue ( ) . getNodeType ( ) ) { \ncase ARRAY : x . getValue ( ) . forEach ( subobj -> { \nif ( subobj . getNodeType ( ) == JsonNodeType . OBJECT ) { \nparseLinkObject ( rel , ( ObjectNode ) subobj , linksForRel , linkTemplates ) ; \n} \n} \n) ; \nbreak ; \ncase OBJECT : parseLinkObject ( rel , ( ObjectNode ) x . getValue ( ) , linksForRel , linkTemplates ) ; \nbreak ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"9643": "public class AbstractEndpoint { \nprivate void parseLinkObject ( String rel , ObjectNode obj , Map < URI , String > linksForRel , Map < String , String > linkTemplates ) { \nJsonNode href = obj . findValue ( \"href\" ) ; \nif ( href == null ) { \nreturn ; \n} \nJsonNode templated = obj . findValue ( \"templated\" ) ; \nif ( templated != null && templated . isBoolean ( ) && templated . asBoolean ( ) ) { \nlinkTemplates . put ( rel , href . asText ( ) ) ; \n} \nelse { \nJsonNode title = obj . findValue ( \"title\" ) ; \nlinksForRel . put ( uri . resolve ( href . asText ( ) ) , ( title != null && title . getNodeType ( ) == JsonNodeType . STRING ) ? title . asText ( ) : null ) ; \n} \nreturn ; \n} \n} \n"}
{"9645": "public class AbstractEndpoint { \nprotected void handleCapabilities ( HttpResponse response ) { \nallowedMethods = unmodifiableSet ( stream ( response . getHeaders ( \"Allow\" ) ) . filter ( x -> x . getName ( ) . equals ( \"Allow\" ) ) . flatMap ( x -> stream ( x . getElements ( ) ) ) . map ( x -> x . getName ( ) ) . collect ( toSet ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"9647": "public class Container { \nprotected void registerInstanceProcessor ( ) { \nregisterInstanceProcessor ( new InstanceFieldsInjectionProcessor ( ) ) ; \nregisterInstanceProcessor ( new InstanceFieldsInitializationProcessor ( ) ) ; \nregisterInstanceProcessor ( new ConfigurableInstanceProcessor ( ) ) ; \nregisterInstanceProcessor ( new PostConstructInstanceProcessor ( ) ) ; \nregisterInstanceProcessor ( new CronMethodsProcessor ( cronManager ) ) ; \nregisterInstanceProcessor ( new LoggerInstanceProcessor ( ) ) ; \nreturn ; \n} \n} \n"}
{"9648": "public class Container { \nprotected void registerInstanceFactory ( InstanceType instanceType , InstanceFactory instanceFactory ) { \nlog . debug ( \"Register instance factory |%s| to |%s|.\" , instanceFactory . getClass ( ) , instanceType ) ; \nif ( instanceFactories . put ( instanceType , instanceFactory ) != null ) { \nthrow new BugError ( \"Attempt to override instance type |%s|.\" , instanceType ) ; \n} \nreturn ; \n} \n} \n"}
{"9649": "public class Container { \nprotected void registerInstanceProcessor ( InstanceProcessor instanceProcessor ) { \nfor ( InstanceProcessor existingInstanceProcessoor : instanceProcessors ) { \nif ( existingInstanceProcessoor . getClass ( ) . equals ( instanceProcessor . getClass ( ) ) ) { \nthrow new BugError ( \"Attempt to override instance processor |%s|.\" , instanceProcessor . getClass ( ) ) ; \n} \n} \nlog . debug ( \"Register instance processor |%s|.\" , instanceProcessor . getClass ( ) ) ; \ninstanceProcessors . add ( instanceProcessor ) ; \nreturn ; \n} \n} \n"}
{"9650": "public class Container { \nprotected void registerClassProcessor ( ClassProcessor classProcessor ) { \nfor ( ClassProcessor existingClassProcessoor : classProcessors ) { \nif ( existingClassProcessoor . getClass ( ) . equals ( classProcessor . getClass ( ) ) ) { \nthrow new BugError ( \"Attempt to override class processor |%s|.\" , classProcessor . getClass ( ) ) ; \n} \n} \nlog . debug ( \"Register class processor |%s|.\" , classProcessor . getClass ( ) ) ; \nclassProcessors . add ( classProcessor ) ; \nreturn ; \n} \n} \n"}
{"9652": "public class ParameterizedTemplateModel { \npublic final void addArgument ( @ NotNull final Argument argument ) { \nif ( arguments == null ) { \narguments = new ArrayList < Argument > ( ) ; \n} \narguments . add ( argument ) ; \nreturn ; \n} \n} \n"}
{"9655": "public class ParameterizedTemplateModel { \npublic final void init ( final SrcGen4JContext context , final Map < String , String > vars ) { \nif ( template != null ) { \ntemplate = Utils4J . replaceVars ( template , vars ) ; \n} \nif ( arguments != null ) { \nfor ( final Argument argument : arguments ) { \nargument . init ( vars ) ; \n} \n} \nif ( targetFiles != null ) { \nfor ( final TargetFile targetFile : targetFiles ) { \ntargetFile . init ( vars ) ; \n} \n} \nif ( tflProducerConfig != null ) { \ntflProducerConfig . init ( context , this , vars ) ; \n} \nreturn ; \n} \n} \n"}
{"9659": "public class ManagedMethod { \nvoid setRequestPath ( String requestPath ) { \nthis . requestPath = requestPath != null ? requestPath : Strings . toDashCase ( method . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"9662": "public class ContextParamProcessor { \nprivate void setField ( Field field , String parameterName , Object instance ) { \nfinal Object value = context . getProperty ( parameterName , field . getType ( ) ) ; \ntry { \nfield . set ( instance , value ) ; \n} \ncatch ( Exception e ) { \nthrow new BugError ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9663": "public class LogHelper { \npublic void addCaptureToLogger ( final AppenderAttachable logger , final String appenderName ) { \nAppender currentAppender = logger . getAppender ( appenderName ) ; \nAppender captureAppender = CaptureAppender . newAppenderFrom ( currentAppender ) ; \nlogger . addAppender ( captureAppender ) ; \nreturn ; \n} \n} \n"}
{"9664": "public class LogHelper { \npublic void remove ( final AppenderAttachable logger , final String appenderName ) { \nlogger . removeAppender ( CaptureAppender . getAppenderNameFor ( appenderName ) ) ; \nreturn ; \n} \n} \n"}
{"9665": "public class LogHelper { \npublic void clear ( final AppenderAttachable logger , final String appenderName ) { \n( ( CaptureAppender ) logger . getAppender ( CaptureAppender . getAppenderNameFor ( appenderName ) ) ) . clear ( ) ; \nreturn ; \n} \n} \n"}
{"9667": "public class AbstractEMFParser { \nprotected final void parseModel ( ) { \nif ( ( fileExtensions == null ) || ( fileExtensions . size ( ) == 0 ) ) { \nthrow new IllegalStateException ( \"No file extensions for EMF model files set!\" ) ; \n} \nresourceSet = new ResourceSetImpl ( ) ; \nerror = false ; \nparseDirs ( ) ; \nparseResources ( ) ; \nreturn ; \n} \n} \n"}
{"9668": "public class AbstractEMFParser { \nprotected final void resolveProxies ( ) { \nfinal List < String > unresolved = new ArrayList < String > ( ) ; \nif ( ! resolvedAllProxies ( unresolved , 0 ) ) { \nLOG . warn ( \"Could not resolve the following proxies ({}):\" , unresolved . size ( ) ) ; \nfor ( final String ref : unresolved ) { \nLOG . warn ( \"Not found: {}\" , ref ) ; \n} \nfinal Iterator < Notifier > it = resourceSet . getAllContents ( ) ; \nwhile ( it . hasNext ( ) ) { \nfinal Notifier next = it . next ( ) ; \nif ( next instanceof EObject ) { \nfinal EObject obj = ( EObject ) next ; \nif ( obj . eIsProxy ( ) ) { \ntry { \nit . remove ( ) ; \n} \ncatch ( final UnsupportedOperationException ex ) { \nLOG . error ( \"Could not remove proxy: \" + obj , ex ) ; \n} \n} \n} \n} \n} \nreturn ; \n} \n} \n"}
{"9670": "public class AbstractEMFParser { \nprivate void parseDir ( final File dir ) { \nLOG . debug ( \"Parse: {}\" , dir ) ; \nfinal File [ ] files = getFiles ( dir ) ; \nif ( ( files == null ) || ( files . length == 0 ) ) { \nLOG . debug ( \"No files found in directory: {}\" , dir ) ; \n} \nelse { \nfor ( final File file : files ) { \nif ( file . isFile ( ) ) { \nfinal Resource resource = resourceSet . getResource ( URI . createFileURI ( Utils4J . getCanonicalPath ( file ) ) , true ) ; \nfinal EList < Diagnostic > diagnostics = resource . getErrors ( ) ; \nif ( diagnostics . size ( ) == 0 ) { \nLOG . debug ( \"Parsed {}\" , file ) ; \n} \nelse { \nerror = true ; \nLOG . error ( \"Parsed {} with errors: {}\" , file , diagnostics ) ; \n} \n} \nelse { \nparseDir ( file ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"9673": "public class AbstractEMFParser { \nprotected final void setModelDirs ( final File ... modelDirs ) { \nif ( modelDirs == null ) { \nthis . modelDirs = null ; \n} \nelse { \nthis . modelDirs = new ArrayList < File > ( ) ; \nthis . modelDirs . addAll ( Arrays . asList ( modelDirs ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9674": "public class AbstractEMFParser { \nprotected final void setFileExtensions ( final String ... fileExtensions ) { \nif ( fileExtensions == null ) { \nthis . fileExtensions = null ; \n} \nelse { \nthis . fileExtensions = new ArrayList < String > ( ) ; \nthis . fileExtensions . addAll ( Arrays . asList ( fileExtensions ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9675": "public class AbstractEMFParser { \nprotected final void setModelResources ( final URI ... modelResources ) { \nif ( modelResources == null ) { \nthis . modelResources = null ; \n} \nelse { \nthis . modelResources = new ArrayList < URI > ( ) ; \nthis . modelResources . addAll ( Arrays . asList ( modelResources ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9677": "public class StatementImpl { \npublic void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { \nint arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; \nAssertUtils . assertTrue ( values . length <= arrayLen ) ; \nfor ( int i = 0 ; \ni < arrayLen ; \ni ++ ) { \nsetString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; \n} \nreturn ; \n} \n} \n"}
{"9678": "public class StatementImpl { \npublic void setBoolean2 ( String parameterName , Boolean value ) throws java . sql . SQLException { \nif ( value == null ) { \nsetNull ( parameterName , Types . BIT ) ; \n} \nelse { \nsetBoolean ( parameterName , value ) ; \n} \nreturn ; \n} \n} \n"}
{"9681": "public class VelocityGenerator { \nprotected final void merge ( final VelocityContext context , final String artifactName , final String templateName , final String filename ) throws GenerateException { \nfinal GeneratedFile genFile = getTargetFile ( artifactName , filename , templateName ) ; \nif ( genFile . isSkip ( ) ) { \nLOG . debug ( \"Omitted already existing file: {} [{}]\" , genFile , templateName ) ; \n} \nelse { \nLOG . debug ( \"Start merging velocity template: {} [{}]\" , genFile , templateName ) ; \ntry { \nfinal Writer writer = new FileWriter ( genFile . getTmpFile ( ) ) ; \ntry { \nfinal Template template = ve . getTemplate ( templateName ) ; \ntemplate . merge ( context , writer ) ; \n} \nfinally { \nwriter . close ( ) ; \n} \ngenFile . persist ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new GenerateException ( \"Error merging template '\" + templateName + \"' to '\" + filename + \"'!\" , ex ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9684": "public class XmlValueWriter { \n@ Override public void write ( HttpServletResponse httpResponse , Object value ) throws IOException { \nfinal Document document = ( Document ) value ; \ndocument . serialize ( new OutputStreamWriter ( httpResponse . getOutputStream ( ) , \"UTF-8\" ) ) ; \nreturn ; \n} \n} \n"}
{"9685": "public class WebViewFactory { \n@ Validate public void start ( ) { \nQApplication . invokeLater ( new Runnable ( ) { \npublic void run ( ) { \nconfigureApplication ( ) ; \nm_logger . info ( \"Creating a web ui...\" ) ; \nsynchronized ( WebViewFactory . this ) { \nm_browser = new WebWindow ( m_url , WebViewFactory . this ) ; \nconfigureWindow ( m_browser ) ; \nm_browser . show ( ) ; \n} \nm_logger . info ( \"Web UI created.\" ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"9686": "public class WebViewFactory { \nprivate void configureWindow ( WebWindow web ) { \nif ( m_fullscreen ) { \nm_width = web . width ( ) ; \nm_height = web . height ( ) ; \nweb . showFullScreen ( ) ; \n} \nelse { \nweb . showNormal ( ) ; \nif ( ! m_resizable ) { \nweb . setFixedSize ( new QSize ( m_width , m_height ) ) ; \n} \nelse { \nweb . setBaseSize ( new QSize ( m_width , m_height ) ) ; \n} \nweb . resize ( m_width , m_height ) ; \n} \nif ( ! m_bar ) { \nweb . menuBar ( ) . setVisible ( false ) ; \n} \nelse { \nweb . menuBar ( ) . setVisible ( true ) ; \nif ( m_icon != null ) { \nQIcon icon = new QIcon ( m_icon ) ; \nweb . setWindowIcon ( icon ) ; \n} \nweb . setWindowTitle ( m_appName ) ; \n} \nif ( ! m_contextMenu ) { \nweb . setContextMenuPolicy ( ContextMenuPolicy . PreventContextMenu ) ; \n} \nelse { \nweb . setContextMenuPolicy ( ContextMenuPolicy . DefaultContextMenu ) ; \n} \nreturn ; \n} \n} \n"}
{"9687": "public class WebViewFactory { \npublic void print ( QWebView view ) { \nif ( m_print ) { \nQPrinter printer = new QPrinter ( ) ; \nQPrintDialog printDialog = new QPrintDialog ( printer , view ) ; \nif ( printDialog . exec ( ) == QDialog . DialogCode . Accepted . value ( ) ) { \nview . print ( printer ) ; \n} \n} \nelse { \nm_logger . warn ( \"Print disabled\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9688": "public class WebViewFactory { \npublic static void write ( InputStream in , OutputStream out ) throws IOException { \nbyte [ ] b = new byte [ 4096 ] ; \nfor ( int n ; \n( n = in . read ( b ) ) != - 1 ; \n) { \nout . write ( b , 0 , n ) ; \n} \nin . close ( ) ; \nout . close ( ) ; \nreturn ; \n} \n} \n"}
{"9690": "public class RequestContext { \npublic void attach ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) { \nif ( requestURL == null ) { \nrequestURL = httpRequest . getRequestURI ( ) ; \n} \nif ( locale == null ) { \nlocale = httpRequest . getLocale ( ) ; \n} \nif ( requestPath == null ) { \nrequestPath = httpRequest . getRequestURI ( ) . substring ( httpRequest . getContextPath ( ) . length ( ) ) ; \n} \nthis . httpRequest = httpRequest ; \nthis . httpResponse = httpResponse ; \nthis . attached = true ; \nreturn ; \n} \n} \n"}
{"9691": "public class RequestContext { \npublic void detach ( ) { \nattached = false ; \nlocale = null ; \nsecurityDomain = null ; \ncookies = null ; \nrequestPath = null ; \nrequestURL = null ; \nreturn ; \n} \n} \n"}
{"9693": "public class RequestContext { \npublic void dump ( ) { \nif ( ! attached ) { \nreturn ; \n} \nStringBuilder message = new StringBuilder ( ) ; \nmessage . append ( \"Request context |\" ) ; \nmessage . append ( httpRequest . getRequestURI ( ) ) ; \nmessage . append ( \"|:\" ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- remote-address: \" ) ; \nmessage . append ( httpRequest . getRemoteHost ( ) ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- method: \" ) ; \nmessage . append ( httpRequest . getMethod ( ) ) ; \nmessage . append ( System . lineSeparator ( ) ) ; \nmessage . append ( \"\\t- query-string: \" ) ; \nif ( httpRequest . getQueryString ( ) != null ) { \nmessage . append ( httpRequest . getQueryString ( ) ) ; \n} \nEnumeration < String > headerNames = httpRequest . getHeaderNames ( ) ; \nwhile ( headerNames . hasMoreElements ( ) ) { \nmessage . append ( System . lineSeparator ( ) ) ; \nString headerName = headerNames . nextElement ( ) ; \nmessage . append ( \"\\t- \" ) ; \nmessage . append ( headerName ) ; \nmessage . append ( \": \" ) ; \nmessage . append ( httpRequest . getHeader ( headerName ) ) ; \n} \nlog . error ( message . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"9695": "public class EventStream { \nprotected void config ( EventStreamConfig config ) { \nif ( config . hasSecretKey ( ) ) { \nsecretKey = config . getSecretKey ( ) ; \n} \nif ( config . hasKeepAlivePeriod ( ) ) { \nkeepAlivePeriod = config . getKeepAlivePeriod ( ) ; \n} \nparameters = config . getParameters ( ) ; \nreturn ; \n} \n} \n"}
{"9696": "public class EventStream { \nprotected void setRemoteHost ( String remoteHost ) { \nif ( string == null ) { \nstring = Strings . concat ( '#' , STREAM_ID ++ , ':' , remoteHost ) ; \n} \nreturn ; \n} \n} \n"}
{"9703": "public class AppServlet { \nprotected static void dumpError ( RequestContext context , Throwable throwable ) { \nlog . dump ( \"Error on HTTP request:\" , throwable ) ; \ncontext . dump ( ) ; \nreturn ; \n} \n} \n"}
{"9704": "public class AppServlet { \nprotected static void sendJsonObject ( RequestContext context , Object object , int statusCode ) throws IOException { \nfinal HttpServletResponse httpResponse = context . getResponse ( ) ; \nif ( httpResponse . isCommitted ( ) ) { \nlog . fatal ( \"Abort HTTP transaction. Attempt to send JSON object after reponse commited.\" ) ; \nreturn ; \n} \nlog . trace ( \"Send response object |%s|.\" , object . toString ( ) ) ; \nJson json = Classes . loadService ( Json . class ) ; \nString buffer = json . stringify ( object ) ; \nbyte [ ] bytes = buffer . getBytes ( \"UTF-8\" ) ; \nhttpResponse . setStatus ( statusCode ) ; \nhttpResponse . setContentType ( ContentType . APPLICATION_JSON . getValue ( ) ) ; \nhttpResponse . setContentLength ( bytes . length ) ; \nhttpResponse . setHeader ( \"Content-Language\" , context . getLocale ( ) . toLanguageTag ( ) ) ; \nhttpResponse . getOutputStream ( ) . write ( bytes ) ; \nhttpResponse . getOutputStream ( ) . flush ( ) ; \nreturn ; \n} \n} \n"}
{"9705": "public class ParameterizedTemplateModels { \npublic final void addParamTemplate ( final ParameterizedTemplateModel paramTemplate ) { \nif ( paramTemplates == null ) { \nparamTemplates = new ArrayList < ParameterizedTemplateModel > ( ) ; \n} \nparamTemplates . add ( paramTemplate ) ; \nreturn ; \n} \n} \n"}
{"9706": "public class ParameterizedTemplateModels { \npublic final void addParamTemplates ( final List < ParameterizedTemplateModel > list ) { \nif ( list != null ) { \nfor ( final ParameterizedTemplateModel template : list ) { \naddParamTemplate ( template ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9707": "public class ParameterizedTemplateModels { \npublic final void init ( final SrcGen4JContext context , final Map < String , String > vars ) { \nif ( paramTemplates != null ) { \nfor ( final ParameterizedTemplateModel paramTemplate : paramTemplates ) { \nparamTemplate . init ( context , vars ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9709": "public class ElementView { \npublic void setSaveEnabled ( boolean val ) { \nsaveButton . setVisible ( val ) ; \nsetReadOnly ( ! val ) ; \nentityForm . setReadOnly ( ! val ) ; \nreturn ; \n} \n} \n"}
{"9710": "public class ElementView { \nprotected void delete ( ) { \nString question = \"Are you sure you want to delete \" + getCaption ( ) + \"?\" ; \nConfirmDialog . show ( getUI ( ) , question , ( ConfirmDialog cd ) -> { \nif ( cd . isConfirmed ( ) ) { \ntry { \nonDelete ( ) ; \nclose ( ) ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { \nonError ( ex ) ; \n} \ncatch ( RuntimeException ex ) { \ngetUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; \n} \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"9711": "public class ElementView { \nprotected void onDelete ( ) throws IOException , IllegalArgumentException , IllegalAccessException , FileNotFoundException , IllegalStateException { \nendpoint . delete ( ) ; \neventBus . post ( new ElementDeletedEvent < > ( endpoint ) ) ; \nreturn ; \n} \n} \n"}
{"9721": "public class EntityPicker { \npublic void setCandidates ( Collection < T > candidates ) { \ntwinColSelect . setContainerDataSource ( container = new BeanItemContainer < > ( entityType , candidates ) ) ; \nreturn ; \n} \n} \n"}
{"9722": "public class TinyConfigBuilder { \nprotected static void loadXML ( InputStream inputStream , Loader loader ) throws ConfigException { \ntry { \nSAXParserFactory factory = SAXParserFactory . newInstance ( ) ; \nSAXParser parser = factory . newSAXParser ( ) ; \nXMLReader reader = parser . getXMLReader ( ) ; \nreader . setContentHandler ( loader ) ; \nreader . parse ( new InputSource ( inputStream ) ) ; \n} \ncatch ( Exception e ) { \nthrow new ConfigException ( \"Fail to load configuration document from file |%s|: %s\" , inputStream , e ) ; \n} \nreturn ; \n} \n} \n"}
{"9723": "public class AbstractEndpointView { \nprotected void onError ( Exception ex ) { \nNotification . show ( \"Error\" , ex . getLocalizedMessage ( ) , Notification . Type . ERROR_MESSAGE ) ; \nreturn ; \n} \n} \n"}
{"9731": "public class AbstractCollectionView { \n@ Subscribe public void handle ( ElementEvent < TEntity > message ) { \nif ( message . getEndpoint ( ) . getEntityType ( ) == this . endpoint . getEntityType ( ) ) { \nrefresh ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9739": "public class LogEventAnalyzer { \npublic void processNotContainsException ( Map < String , String > parameters ) { \nLoggingEvent match = getMessageWithException ( parameters ) ; \nif ( match == null ) { \ncell . right ( ) ; \n} \nelse { \ncell . wrong ( match . getThrowableInformation ( ) . getThrowableStrRep ( ) [ 0 ] ) ; \n} \nreturn ; \n} \n} \n"}
{"9740": "public class LogEventAnalyzer { \npublic void processNotContains ( Map < String , String > parameters ) { \nLoggingEvent match = getMessageWithString ( parameters ) ; \nif ( match == null ) { \ncell . right ( ) ; \n} \nelse { \ncell . wrong ( match . getMessage ( ) . toString ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9743": "public class AbstractView { \n@ Override public void serialize ( HttpServletResponse httpResponse ) throws IOException { \nhttpResponse . setHeader ( HttpHeader . CACHE_CONTROL , HttpHeader . NO_CACHE ) ; \nhttpResponse . addHeader ( HttpHeader . CACHE_CONTROL , HttpHeader . NO_STORE ) ; \nhttpResponse . setHeader ( HttpHeader . PRAGMA , HttpHeader . NO_CACHE ) ; \nhttpResponse . setDateHeader ( HttpHeader . EXPIRES , 0 ) ; \nhttpResponse . setContentType ( getContentType ( ) . getValue ( ) ) ; \nserialize ( httpResponse . getOutputStream ( ) ) ; \nreturn ; \n} \n} \n"}
{"9745": "public class Cookies { \npublic void add ( String name , String value ) { \nParams . notNullOrEmpty ( name , \"Cookie name\" ) ; \nParams . notNull ( value , \"Cookie value\" ) ; \nCookie cookie = new Cookie ( name , value ) ; \ncookie . setPath ( \"/\" ) ; \nhttpResponse . addCookie ( cookie ) ; \nreturn ; \n} \n} \n"}
{"9746": "public class Cookies { \npublic void remove ( String name ) { \nParams . notNullOrEmpty ( name , \"Cookie name\" ) ; \nif ( cookies == null ) { \nreturn ; \n} \nfor ( Cookie cookie : cookies ) { \nif ( name . equals ( cookie . getName ( ) ) ) { \ncookie . setMaxAge ( 0 ) ; \ncookie . setValue ( \"\" ) ; \ncookie . setPath ( \"/\" ) ; \nhttpResponse . addCookie ( cookie ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"9749": "public class DynamicObjectFactory { \npublic void add ( final Class < ? > type , final String name ) throws ClassNotFoundException { \nFieldGen fg ; \nif ( result != null ) { \nthrow new IllegalStateException ( \"Class already generated\" ) ; \n} \nfg = new FieldGen ( Constants . ACC_PUBLIC | Constants . ACC_SUPER , Type . getType ( type ) , name , cg . getConstantPool ( ) ) ; \ncg . addField ( fg . getField ( ) ) ; \nreturn ; \n} \n} \n"}
{"9765": "public class FileResource { \n@ Override public void serialize ( HttpServletResponse httpResponse ) throws IOException { \nhttpResponse . setHeader ( HttpHeader . CACHE_CONTROL , HttpHeader . NO_CACHE ) ; \nhttpResponse . addHeader ( HttpHeader . CACHE_CONTROL , HttpHeader . NO_STORE ) ; \nhttpResponse . setHeader ( HttpHeader . PRAGMA , HttpHeader . NO_CACHE ) ; \nhttpResponse . setDateHeader ( HttpHeader . EXPIRES , 0 ) ; \nhttpResponse . setContentType ( contentType ) ; \nhttpResponse . setHeader ( HttpHeader . CONTENT_LENGTH , Long . toString ( file . length ( ) ) ) ; \nFiles . copy ( file , httpResponse . getOutputStream ( ) ) ; \nreturn ; \n} \n} \n"}
{"9766": "public class EntryEndpoint { \npublic void readMeta ( ) throws IOException , IllegalArgumentException , IllegalAccessException , FileNotFoundException , IllegalStateException { \nexecuteAndHandle ( Request . Get ( uri ) ) ; \nreturn ; \n} \n} \n"}
{"9767": "public class ResourceServlet { \n@ Override protected void handleRequest ( RequestContext context ) throws ServletException , IOException { \nfinal HttpServletRequest httpRequest = context . getRequest ( ) ; \nfinal HttpServletResponse httpResponse = context . getResponse ( ) ; \nArgumentsReader argumentsReader = null ; \nResource resource = null ; \ntry { \nManagedMethodSPI method = resourceMethods . get ( key ( context . getRequestPath ( ) ) ) ; \nif ( method == null ) { \nthrow new NoSuchMethodException ( httpRequest . getRequestURI ( ) ) ; \n} \nfinal Type [ ] formalParameters = method . getParameterTypes ( ) ; \nargumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; \nObject [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; \nObject controller = container . getInstance ( method . getDeclaringClass ( ) ) ; \nresource = method . invoke ( controller , arguments ) ; \nif ( resource == null ) { \nthrow new BugError ( \"Null resource |%s|.\" , httpRequest . getRequestURI ( ) ) ; \n} \n} \ncatch ( AuthorizationException e ) { \nString loginPage = container . getLoginPage ( ) ; \nif ( loginPage != null ) { \nhttpResponse . sendRedirect ( loginPage ) ; \n} \nelse { \nhttpRequest . authenticate ( httpResponse ) ; \n} \nreturn ; \n} \ncatch ( NoSuchMethodException | IllegalArgumentException e ) { \ndumpError ( context , e ) ; \nhttpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; \nreturn ; \n} \ncatch ( InvocationException e ) { \ndumpError ( context , e ) ; \nif ( e . getCause ( ) instanceof NoSuchResourceException ) { \nhttpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; \n} \nelse { \nhttpResponse . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getCause ( ) . getMessage ( ) ) ; \n} \nreturn ; \n} \nfinally { \nif ( argumentsReader != null ) { \nargumentsReader . clean ( ) ; \n} \n} \nhttpResponse . setStatus ( HttpServletResponse . SC_OK ) ; \nresource . serialize ( httpResponse ) ; \nreturn ; \n} \n} \n"}
{"9768": "public class TableFixture { \n@ Override public void tearDown ( ) throws Exception { \nif ( statement != null ) { \nstatement . close ( ) ; \nstatement = null ; \n} \nsuper . tearDown ( ) ; \nreturn ; \n} \n} \n"}
{"9769": "public class EventStreamManagerImpl { \n@ Override public void preDestroy ( ) { \nif ( eventStreams . isEmpty ( ) ) { \nreturn ; \n} \nfor ( EventStream eventStream : eventStreams . toArray ( new EventStream [ 0 ] ) ) { \nlog . debug ( \"Force close stale event stream |%s|.\" , eventStream ) ; \neventStream . close ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9770": "public class AbstractBlobView { \nprotected void handleAllowedMethods ( ) { \nendpoint . isDownloadAllowed ( ) . ifPresent ( this :: setDownloadEnabled ) ; \nendpoint . isUploadAllowed ( ) . ifPresent ( this :: setUploadEnabled ) ; \nendpoint . isDeleteAllowed ( ) . ifPresent ( this :: setDeleteEnabled ) ; \nreturn ; \n} \n} \n"}
{"9771": "public class AbstractBlobView { \nprotected void upload ( ) { \ntry { \nonUpload ( ) ; \neventBus . post ( new BlobUploadEvent ( endpoint ) ) ; \nNotification . show ( \"Success\" , \"Upload complete\" , Notification . Type . TRAY_NOTIFICATION ) ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { \nonError ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"9772": "public class AbstractBlobView { \nprotected void delete ( ) { \nString question = \"Are you sure you want to delete the data from the server?\" ; \nConfirmDialog . show ( getUI ( ) , question , new ConfirmDialog . Listener ( ) { \n@ Override public void onClose ( ConfirmDialog cd ) { \nif ( cd . isConfirmed ( ) ) { \ntry { \nendpoint . delete ( ) ; \nclose ( ) ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { \nonError ( ex ) ; \n} \ncatch ( RuntimeException ex ) { \ngetUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; \n} \n} \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"9775": "public class Timer { \npublic synchronized void period ( final PeriodicTask periodicTask , long period ) { \nTimerTask task = new PeriodicTaskImpl ( periodicTask ) ; \nthis . tasks . put ( periodicTask , task ) ; \nthis . timer . schedule ( task , 0L , period ) ; \nreturn ; \n} \n} \n"}
{"9776": "public class Timer { \npublic synchronized void timeout ( final TimeoutTask timeoutTask , long timeout ) { \nTimerTask task = this . tasks . get ( timeoutTask ) ; \nif ( task != null ) { \ntask . cancel ( ) ; \nthis . tasks . values ( ) . remove ( task ) ; \n} \ntask = new TimeoutTaskImpl ( timeoutTask ) ; \nthis . tasks . put ( timeoutTask , task ) ; \nthis . timer . schedule ( task , timeout ) ; \nreturn ; \n} \n} \n"}
{"9777": "public class ViewManagerImpl { \n@ Override public void config ( Config config ) throws ConfigException , IOException { \nfor ( Config repositorySection : config . findChildren ( \"repository\" ) ) { \nString className = repositorySection . getAttribute ( \"class\" , DEF_IMPLEMENTATION ) ; \nClass < ? > implementation = Classes . forOptionalName ( className ) ; \nif ( implementation == null ) { \nthrow new ConfigException ( \"Unable to load view implementation |%s|.\" , className ) ; \n} \nif ( ! Types . isKindOf ( implementation , View . class ) ) { \nthrow new ConfigException ( \"View implementation |%s| is not of proper type.\" , className ) ; \n} \nif ( ! Classes . isInstantiable ( implementation ) ) { \nthrow new ConfigException ( \"View implementation |%s| is not instantiable. Ensure is not abstract or interface and have default constructor.\" , implementation ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Class < ? extends View > viewImplementation = ( Class < ? extends View > ) implementation ; \nString repositoryPath = repositorySection . getAttribute ( \"path\" ) ; \nif ( repositoryPath == null ) { \nthrow new ConfigException ( \"Invalid views repository configuration. Missing <path> attribute.\" ) ; \n} \nString filesPattern = repositorySection . getAttribute ( \"files-pattern\" ) ; \nif ( filesPattern == null ) { \nthrow new ConfigException ( \"Invalid views repository configuration. Missing <files-pattern> attribute.\" ) ; \n} \nConfigBuilder builder = new I18nRepository . ConfigBuilder ( repositoryPath , filesPattern ) ; \nI18nRepository repository = new I18nRepository ( builder . build ( ) ) ; \nif ( viewsMetaPool == null ) { \nviewsMetaPool = repository . getPoolInstance ( ) ; \n} \nProperties properties = repositorySection . getProperties ( ) ; \nfor ( I18nFile template : repository ) { \nViewMeta meta = new ViewMeta ( template . getFile ( ) , viewImplementation , properties ) ; \nif ( viewsMetaPool . put ( meta . getName ( ) , meta , template . getLocale ( ) ) ) { \nlog . warn ( \"Override view |%s|\" , meta ) ; \n} \nelse { \nlog . debug ( \"Register view |%s|\" , meta ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"9779": "public class Launcher { \nprivate static void configureApplication ( ) { \nFile file = new File ( \"chameria.props\" ) ; \nif ( file . exists ( ) ) { \nProperties props = new Properties ( ) ; \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nprops . load ( is ) ; \nString n = props . getProperty ( \"application.name\" ) ; \nif ( n != null ) { \nQApplication . setApplicationName ( n ) ; \n} \nelse { \nQApplication . setApplicationName ( \"akquinet ChameRIA\" ) ; \n} \nn = props . getProperty ( \"application.version\" ) ; \nif ( n != null ) { \nQApplication . setApplicationVersion ( n ) ; \n} \nn = props . getProperty ( \"application.icon\" ) ; \nif ( n != null ) { \nQIcon icon = new QIcon ( n ) ; \nQApplication . setWindowIcon ( icon ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"Cannot read the application configuration \" + e . getMessage ( ) ) ; \ne . printStackTrace ( ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \nQApplication . setOrganizationName ( \"akquinet A.G.\" ) ; \nreturn ; \n} \n} \n"}
{"9780": "public class Launcher { \nprivate static void printWelcomeBanner ( ) { \nStringBuffer banner = new StringBuffer ( ) ; \nbanner . append ( \"\\n\" ) ; \nbanner . append ( \"\\t============================\\n\" ) ; \nbanner . append ( \"\\t|                          |\\n\" ) ; \nbanner . append ( \"\\t|   Welcome to ChameRIA    |\\n\" ) ; \nbanner . append ( \"\\t|                          |\\n\" ) ; \nbanner . append ( \"\\t============================\\n\" ) ; \nbanner . append ( \"\\n\" ) ; \nSystem . out . println ( banner ) ; \nreturn ; \n} \n} \n"}
{"9781": "public class Launcher { \nprivate static void printStoppedBanner ( ) { \nSystem . out . println ( \"\\n\" ) ; \nSystem . out . println ( \"\\t=========================\" ) ; \nSystem . out . println ( \"\\t|   ChameRIA  stopped   |\" ) ; \nSystem . out . println ( \"\\t=========================\" ) ; \nSystem . out . println ( \"\\n\" ) ; \nreturn ; \n} \n} \n"}
{"9783": "public class Launcher { \nprivate static void registerShutdownHook ( final ChameRIA chameleon ) { \nRuntime runtime = Runtime . getRuntime ( ) ; \nRunnable hook = new Runnable ( ) { \npublic void run ( ) { \ntry { \nif ( chameleon != null ) { \nchameleon . stop ( ) ; \nprintStoppedBanner ( ) ; \n} \n} \ncatch ( BundleException e ) { \nSystem . err . println ( \"Cannot stop Chameleon correctly : \" + e . getMessage ( ) ) ; \n} \ncatch ( InterruptedException e ) { \nSystem . err . println ( \"Unexpected Exception : \" + e . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n; \nruntime . addShutdownHook ( new Thread ( hook ) ) ; \nreturn ; \n} \n} \n"}
{"9784": "public class ActionView { \npublic void trigger ( ) { \ntry { \nonTrigger ( ) ; \nNotification . show ( getCaption ( ) , \"Successful.\" , Notification . Type . TRAY_NOTIFICATION ) ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { \nonError ( ex ) ; \n} \nreturn ; \n} \n} \n"}
{"9785": "public class ActionView { \nprotected void onTrigger ( ) throws IOException , IllegalArgumentException , IllegalAccessException , FileNotFoundException , IllegalStateException { \nendpoint . trigger ( ) ; \neventBus . post ( new TriggerEvent ( endpoint ) ) ; \nreturn ; \n} \n} \n"}
{"9786": "public class FitParseResult { \npublic void insertAndReplace ( final FitRow row ) { \nif ( results . isEmpty ( ) ) { \nreturn ; \n} \nint index = row . getIndex ( ) ; \nFitTable table = row . getTable ( ) ; \ntable . remove ( index ) ; \naddRows ( table , index ) ; \nreturn ; \n} \n} \n"}
{"9788": "public class Summary { \npublic void setScore ( double v ) { \nif ( Summary_Type . featOkTst && ( ( Summary_Type ) jcasType ) . casFeat_score == null ) jcasType . jcas . throwFeatMissing ( \"score\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \njcasType . ll_cas . ll_setDoubleValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_score , v ) ; \nreturn ; \n} \n} \n"}
{"9790": "public class Summary { \npublic void setVariants ( StringList v ) { \nif ( Summary_Type . featOkTst && ( ( Summary_Type ) jcasType ) . casFeat_variants == null ) jcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_variants , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9792": "public class Question { \npublic void setQuestionType ( String v ) { \nif ( Question_Type . featOkTst && ( ( Question_Type ) jcasType ) . casFeat_questionType == null ) jcasType . jcas . throwFeatMissing ( \"questionType\" , \"edu.cmu.lti.oaqa.type.input.Question\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Question_Type ) jcasType ) . casFeatCode_questionType , v ) ; \nreturn ; \n} \n} \n"}
{"9795": "public class Token { \npublic void setDepLabel ( String v ) { \nif ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) jcasType . jcas . throwFeatMissing ( \"depLabel\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel , v ) ; \nreturn ; \n} \n} \n"}
{"9797": "public class Token { \npublic void setSemanticType ( String v ) { \nif ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_semanticType == null ) jcasType . jcas . throwFeatMissing ( \"semanticType\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_semanticType , v ) ; \nreturn ; \n} \n} \n"}
{"9799": "public class Document { \npublic void setSections ( StringArray v ) { \nif ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9801": "public class Document { \npublic void setSections ( int i , String v ) { \nif ( Document_Type . featOkTst && ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \njcasType . ll_cas . ll_setStringArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i , v ) ; \nreturn ; \n} \n} \n"}
{"9803": "public class Concept { \npublic void setUris ( StringList v ) { \nif ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_uris == null ) jcasType . jcas . throwFeatMissing ( \"uris\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_uris , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9805": "public class Concept { \npublic void setTypes ( FSList v ) { \nif ( Concept_Type . featOkTst && ( ( Concept_Type ) jcasType ) . casFeat_types == null ) jcasType . jcas . throwFeatMissing ( \"types\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_types , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9807": "public class AnswerType { \npublic void setTargetType ( Annotation v ) { \nif ( AnswerType_Type . featOkTst && ( ( AnswerType_Type ) jcasType ) . casFeat_targetType == null ) jcasType . jcas . throwFeatMissing ( \"targetType\" , \"edu.cmu.lti.oaqa.type.answer.AnswerType\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( AnswerType_Type ) jcasType ) . casFeatCode_targetType , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9809": "public class SearchResult { \npublic void setRank ( int v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_rank == null ) jcasType . jcas . throwFeatMissing ( \"rank\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \njcasType . ll_cas . ll_setIntValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_rank , v ) ; \nreturn ; \n} \n} \n"}
{"9811": "public class SearchResult { \npublic void setQueryString ( String v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_queryString == null ) jcasType . jcas . throwFeatMissing ( \"queryString\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_queryString , v ) ; \nreturn ; \n} \n} \n"}
{"9813": "public class SearchResult { \npublic void setCandidateAnswers ( FSArray v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9815": "public class SearchResult { \npublic void setCandidateAnswers ( int i , CandidateAnswerVariant v ) { \nif ( SearchResult_Type . featOkTst && ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ; \njcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9817": "public class Search { \npublic void setQuery ( String v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_query == null ) jcasType . jcas . throwFeatMissing ( \"query\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_query , v ) ; \nreturn ; \n} \n} \n"}
{"9819": "public class Search { \npublic void setHitList ( FSArray v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) jcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9821": "public class Search { \npublic void setHitList ( int i , SearchResult v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) jcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ; \njcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9823": "public class Search { \npublic void setAbstractQuery ( AbstractQuery v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_abstractQuery == null ) jcasType . jcas . throwFeatMissing ( \"abstractQuery\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9825": "public class Search { \npublic void setSearchId ( String v ) { \nif ( Search_Type . featOkTst && ( ( Search_Type ) jcasType ) . casFeat_searchId == null ) jcasType . jcas . throwFeatMissing ( \"searchId\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_searchId , v ) ; \nreturn ; \n} \n} \n"}
{"9826": "public class Passage { \npublic void setDocId ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_docId == null ) jcasType . jcas . throwFeatMissing ( \"docId\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_docId , v ) ; \nreturn ; \n} \n} \n"}
{"9828": "public class Passage { \npublic void setOffsetInBeginSection ( int v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) jcasType . jcas . throwFeatMissing ( \"offsetInBeginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \njcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection , v ) ; \nreturn ; \n} \n} \n"}
{"9830": "public class Passage { \npublic void setOffsetInEndSection ( int v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) jcasType . jcas . throwFeatMissing ( \"offsetInEndSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \njcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInEndSection , v ) ; \nreturn ; \n} \n} \n"}
{"9832": "public class Passage { \npublic void setBeginSection ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_beginSection == null ) jcasType . jcas . throwFeatMissing ( \"beginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_beginSection , v ) ; \nreturn ; \n} \n} \n"}
{"9834": "public class Passage { \npublic void setEndSection ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_endSection == null ) jcasType . jcas . throwFeatMissing ( \"endSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_endSection , v ) ; \nreturn ; \n} \n} \n"}
{"9836": "public class Passage { \npublic void setAspects ( String v ) { \nif ( Passage_Type . featOkTst && ( ( Passage_Type ) jcasType ) . casFeat_aspects == null ) jcasType . jcas . throwFeatMissing ( \"aspects\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_aspects , v ) ; \nreturn ; \n} \n} \n"}
{"9838": "public class TripleSearchResult { \npublic void setTriple ( Triple v ) { \nif ( TripleSearchResult_Type . featOkTst && ( ( TripleSearchResult_Type ) jcasType ) . casFeat_triple == null ) jcasType . jcas . throwFeatMissing ( \"triple\" , \"edu.cmu.lti.oaqa.type.retrieval.TripleSearchResult\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9840": "public class PassageFromRelation { \npublic void setSourceRelation ( Triple v ) { \nif ( PassageFromRelation_Type . featOkTst && ( ( PassageFromRelation_Type ) jcasType ) . casFeat_sourceRelation == null ) jcasType . jcas . throwFeatMissing ( \"sourceRelation\" , \"edu.cmu.lti.oaqa.type.retrieval.PassageFromRelation\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( PassageFromRelation_Type ) jcasType ) . casFeatCode_sourceRelation , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9842": "public class Triple { \npublic void setSubject ( String v ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_subject == null ) jcasType . jcas . throwFeatMissing ( \"subject\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_subject , v ) ; \nreturn ; \n} \n} \n"}
{"9844": "public class Triple { \npublic void setPredicate ( String v ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_predicate == null ) jcasType . jcas . throwFeatMissing ( \"predicate\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_predicate , v ) ; \nreturn ; \n} \n} \n"}
{"9846": "public class Triple { \npublic void setIsObjUri ( boolean v ) { \nif ( Triple_Type . featOkTst && ( ( Triple_Type ) jcasType ) . casFeat_isObjUri == null ) jcasType . jcas . throwFeatMissing ( \"isObjUri\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \njcasType . ll_cas . ll_setBooleanValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri , v ) ; \nreturn ; \n} \n} \n"}
{"9848": "public class ComplexQueryConcept { \npublic void setOperator ( QueryOperator v ) { \nif ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operator == null ) jcasType . jcas . throwFeatMissing ( \"operator\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9850": "public class ComplexQueryConcept { \npublic void setOperatorArgs ( FSList v ) { \nif ( ComplexQueryConcept_Type . featOkTst && ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operatorArgs == null ) jcasType . jcas . throwFeatMissing ( \"operatorArgs\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9854": "public class CandidateAnswerOccurrence { \npublic void setText ( String v ) { \nif ( CandidateAnswerOccurrence_Type . featOkTst && ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeat_text == null ) jcasType . jcas . throwFeatMissing ( \"text\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerOccurrence\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeatCode_text , v ) ; \nreturn ; \n} \n} \n"}
{"9856": "public class ConceptType { \npublic void setId ( String v ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_id == null ) jcasType . jcas . throwFeatMissing ( \"id\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_id , v ) ; \nreturn ; \n} \n} \n"}
{"9859": "public class ConceptType { \npublic void setAbbreviation ( String v ) { \nif ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_abbreviation == null ) jcasType . jcas . throwFeatMissing ( \"abbreviation\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation , v ) ; \nreturn ; \n} \n} \n"}
{"9860": "public class ConceptSearchResult { \npublic void setConcept ( Concept v ) { \nif ( ConceptSearchResult_Type . featOkTst && ( ( ConceptSearchResult_Type ) jcasType ) . casFeat_concept == null ) jcasType . jcas . throwFeatMissing ( \"concept\" , \"edu.cmu.lti.oaqa.type.retrieval.ConceptSearchResult\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ConceptSearchResult_Type ) jcasType ) . casFeatCode_concept , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9862": "public class Answer { \npublic void setVariants ( FSList v ) { \nif ( Answer_Type . featOkTst && ( ( Answer_Type ) jcasType ) . casFeat_variants == null ) jcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Answer\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Answer_Type ) jcasType ) . casFeatCode_variants , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9864": "public class QueryConcept { \npublic void setNamedEntityTypes ( StringList v ) { \nif ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_namedEntityTypes == null ) jcasType . jcas . throwFeatMissing ( \"namedEntityTypes\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_namedEntityTypes , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9866": "public class QueryConcept { \npublic void setConceptType ( String v ) { \nif ( QueryConcept_Type . featOkTst && ( ( QueryConcept_Type ) jcasType ) . casFeat_conceptType == null ) jcasType . jcas . throwFeatMissing ( \"conceptType\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType , v ) ; \nreturn ; \n} \n} \n"}
{"9868": "public class CandidateAnswerVariant { \npublic void setOccurrences ( FSList v ) { \nif ( CandidateAnswerVariant_Type . featOkTst && ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeat_occurrences == null ) jcasType . jcas . throwFeatMissing ( \"occurrences\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerVariant\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9870": "public class AbstractQuery { \npublic void setConcepts ( FSList v ) { \nif ( AbstractQuery_Type . featOkTst && ( ( AbstractQuery_Type ) jcasType ) . casFeat_concepts == null ) jcasType . jcas . throwFeatMissing ( \"concepts\" , \"edu.cmu.lti.oaqa.type.retrieval.AbstractQuery\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9872": "public class AtomicQueryConcept { \npublic void setOriginalText ( String v ) { \nif ( AtomicQueryConcept_Type . featOkTst && ( ( AtomicQueryConcept_Type ) jcasType ) . casFeat_originalText == null ) jcasType . jcas . throwFeatMissing ( \"originalText\" , \"edu.cmu.lti.oaqa.type.retrieval.AtomicQueryConcept\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( AtomicQueryConcept_Type ) jcasType ) . casFeatCode_originalText , v ) ; \nreturn ; \n} \n} \n"}
{"9874": "public class QueryOperator { \npublic void setArgs ( StringList v ) { \nif ( QueryOperator_Type . featOkTst && ( ( QueryOperator_Type ) jcasType ) . casFeat_args == null ) jcasType . jcas . throwFeatMissing ( \"args\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryOperator\" ) ; \njcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \nreturn ; \n} \n} \n"}
{"9876": "public class SemanticRole { \npublic void setLabel ( String v ) { \nif ( SemanticRole_Type . featOkTst && ( ( SemanticRole_Type ) jcasType ) . casFeat_label == null ) jcasType . jcas . throwFeatMissing ( \"label\" , \"edu.cmu.lti.oaqa.type.nlp.SemanticRole\" ) ; \njcasType . ll_cas . ll_setStringValue ( addr , ( ( SemanticRole_Type ) jcasType ) . casFeatCode_label , v ) ; \nreturn ; \n} \n} \n"}
{"9879": "public class BlockCache { \nprotected void freeBuffer ( final ByteBuffer buffer ) throws IOException { \nif ( buffer == null ) { \nreturn ; \n} \nif ( UNMAP_SUPPORTED ) { \ntry { \nAccessController . doPrivileged ( new PrivilegedExceptionAction < Void > ( ) { \n@ Override public Void run ( ) throws Exception { \nfinal Method getCleanerMethod = buffer . getClass ( ) . getMethod ( \"cleaner\" ) ; \ngetCleanerMethod . setAccessible ( true ) ; \nfinal Object cleaner = getCleanerMethod . invoke ( buffer ) ; \nif ( cleaner != null ) { \ncleaner . getClass ( ) . getMethod ( \"clean\" ) . invoke ( cleaner ) ; \n} \nreturn null ; \n} \n} \n) ; \n} \ncatch ( PrivilegedActionException e ) { \nfinal IOException ioe = new IOException ( \"unable to unmap the mapped buffer\" ) ; \nioe . initCause ( e . getCause ( ) ) ; \nthrow ioe ; \n} \n} \nreturn ; \n} \n} \n"}
{"9884": "public class ConnectionNotation { \nprivate void addDetails ( String str ) throws NotationException { \nString [ ] parts = str . split ( \"-\" ) ; \nsourceUnit = parts [ 0 ] . split ( \":\" ) [ 0 ] . toUpperCase ( ) ; \ntargetUnit = parts [ 1 ] . split ( \":\" ) [ 0 ] . toUpperCase ( ) ; \nrGroupSource = parts [ 0 ] . split ( \":\" ) [ 1 ] ; \nrGroupTarget = parts [ 1 ] . split ( \":\" ) [ 1 ] ; \nPattern r = Pattern . compile ( \"R\\\\d\" , Pattern . CASE_INSENSITIVE ) ; \nPattern pair = Pattern . compile ( \"pair\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher mR = r . matcher ( rGroupSource ) ; \nMatcher mPair = pair . matcher ( rGroupTarget ) ; \nif ( mR . matches ( ) ) { \nrGroupSource = rGroupSource . toUpperCase ( ) ; \n} \nelse { \nrGroupSource = rGroupSource . toLowerCase ( ) ; \n} \nif ( mPair . matches ( ) ) { \nrGroupTarget = rGroupTarget . toLowerCase ( ) ; \n} \nelse { \nrGroupTarget = rGroupTarget . toUpperCase ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9886": "public class MonomerNotationGroup { \npublic void addElement ( String str , String type , double one , double two , boolean interval , boolean isDefault ) throws NotationException { \nthis . elements . add ( ValidationMethod . decideWhichMonomerNotationInGroup ( str , type , one , two , interval , isDefault ) ) ; \nreturn ; \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nwhile ( ( line = br . readLine ( ) ) != null ) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) { \noutput = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \n} \nelse if ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) { \noutput = parser . getJSON ( ) ; \n} \nSystem . out . println ( output ) ; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \nSystem . out . println ( \"Please call the program with the following arguments: \" + \"\\n\" + \"-inputHELM  <\" + options . getOption ( \"inputHELM\" ) . getDescription ( ) + \">\\n\" + \"-output <\" + options . getOption ( \"output\" ) . getDescription ( ) + \">\\n-translate(optional) <\" + options . getOption ( \"translate\" ) . getDescription ( ) + \">\" ) ; \n} \ncatch ( ParseException exp ) { \nSystem . out . println ( \"Unexpected exception: \" + exp . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9904": "public class PolymerNotation { \nprivate void setPolymerElements ( ) { \nif ( polymerID instanceof RNAEntity || polymerID instanceof PeptideEntity ) { \nthis . polymerElements = new PolymerListElements ( polymerID ) ; \n} \nelse { \nthis . polymerElements = new PolymerSingleElements ( polymerID ) ; \n} \nreturn ; \n} \n} \n"}
{"9906": "public class MonomerNotation { \npublic void setAnnotation ( String str ) { \nif ( str != null ) { \nannotation = str ; \nisAnnotationHere = true ; \n} \nelse { \nannotation = null ; \nisAnnotationHere = false ; \n} \nreturn ; \n} \n} \n"}
{"9907": "public class MonomerNotation { \npublic void setCount ( String str ) { \nisDefault = false ; \nif ( str . equals ( \"1\" ) ) { \nisDefault = true ; \n} \ncount = str ; \nreturn ; \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) { \nfor ( int i = 0 ; \ni < test . length ( ) - 4 ; \ni ++ ) { \nparser . doAction ( test . charAt ( i ) ) ; \n} \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \nelse { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9913": "public class MonomerNotationUnitRNA { \nprivate void setRNAContents ( String str ) throws NotationException { \nString [ ] list ; \nList < String > items = extractContents ( str ) ; \nfor ( String item : items ) { \nif ( item . length ( ) > 1 ) { \nif ( ! ( item . startsWith ( \"[\" ) && item . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets \" + item ) ; \n} \n} \ncontents . add ( new MonomerNotationUnit ( item , type ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9914": "public class GroupingNotation { \nprivate void defineAmbiguity ( String a ) throws NotationException { \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nMatcher m = patternAND . matcher ( a ) ; \nif ( m . find ( ) ) { \nsetAmbiguity ( new GroupingMixture ( a ) ) ; \n} \nelse { \nsetAmbiguity ( new GroupingOr ( a ) ) ; \n} \nreturn ; \n} \n} \n"}
{"9918": "public class ADiGraph { \nprivate void initPathsInternal ( ) { \nsynchronized ( LOCK ) { \nif ( _incomingPathsInternal == null ) { \nAMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; \nincomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; \nAMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; \noutgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; \nAList < AEdgePath < N , E > > cycles = AList . nil ( ) ; \nfor ( N curNode : nodes ( ) ) { \nfinal Iterable < E > curIncoming = incomingEdges ( curNode ) ; \nList < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; \nfor ( E incomingEdge : curIncoming ) { \nunfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; \n} \nAList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; \nwhile ( unfinishedBusiness . size ( ) > 0 ) { \nfinal List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; \nfor ( AEdgePath < N , E > p : unfinishedBusiness ) { \nif ( ! p . hasCycle ( ) || p . isMinimalCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; \nif ( p . isMinimalCycle ( ) ) cycles = cycles . cons ( p ) ; \n} \nunfinishedBusiness = new ArrayList < > ( ) ; \nfor ( AEdgePath < N , E > curPath : curBusiness ) { \nfinal Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; \nfor ( E newEdge : l ) { \nfinal AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; \nif ( ! pathCandidate . hasNonMinimalCycle ( ) ) { \nunfinishedBusiness . add ( pathCandidate ) ; \n} \n} \n} \n} \nincomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; \nfor ( AEdgePath < N , E > p : nonCycles ) { \noutgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; \n} \n} \n_incomingPathsInternal = incomingPaths ; \n_outgoingPathsInternal = outgoingPaths ; \n_cyclesInternal = cycles ; \n} \n} \nreturn ; \n} \n} \n"}
{"9920": "public class API { \npublic void subscribe ( final String pattern , final Class < ? > clazz , final String methodName ) throws NoSuchMethodException { \nthis . subscribe ( pattern , new FunctionObject9 ( this , clazz , methodName ) ) ; \nreturn ; \n} \n} \n"}
{"9922": "public class API { \npublic void unsubscribe ( final String pattern ) throws InvalidInputException { \nfinal String s = this . prefix + pattern ; \nLinkedList < FunctionInterface9 > callback_list = this . callbacks . get ( s ) ; \nif ( callback_list == null ) { \nthrow new InvalidInputException ( ) ; \n} \nelse { \ncallback_list . removeFirst ( ) ; \nif ( callback_list . isEmpty ( ) ) { \nthis . callbacks . remove ( s ) ; \n} \n} \nOtpOutputStream unsubscribe = new OtpOutputStream ( ) ; \nunsubscribe . write ( OtpExternal . versionTag ) ; \nfinal OtpErlangObject [ ] tuple = { \nnew OtpErlangAtom ( \"unsubscribe\" ) , new OtpErlangString ( pattern ) } \n; \nunsubscribe . write_any ( new OtpErlangTuple ( tuple ) ) ; \nsend ( unsubscribe ) ; \nreturn ; \n} \n} \n"}
{"9923": "public class API { \npublic void return_ ( final Integer request_type , final String name , final String pattern , final byte [ ] response_info , final byte [ ] response , final Integer timeout , final byte [ ] trans_id , final OtpErlangPid pid ) throws ReturnAsyncException , ReturnSyncException , InvalidInputException { \nif ( request_type == API . ASYNC ) return_async ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \nelse if ( request_type == API . SYNC ) return_sync ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \nelse throw new InvalidInputException ( ) ; \nreturn ; \n} \n} \n"}
{"9924": "public class API { \npublic void return_sync ( final String name , final String pattern , byte [ ] response_info , byte [ ] response , Integer timeout , final byte [ ] trans_id , final OtpErlangPid pid ) throws ReturnSyncException { \ntry { \nOtpOutputStream return_sync = new OtpOutputStream ( ) ; \nreturn_sync . write ( OtpExternal . versionTag ) ; \nfinal OtpErlangObject [ ] tuple = { \nnew OtpErlangAtom ( \"return_sync\" ) , new OtpErlangString ( name ) , new OtpErlangString ( pattern ) , new OtpErlangBinary ( response_info ) , new OtpErlangBinary ( response ) , new OtpErlangUInt ( timeout ) , new OtpErlangBinary ( trans_id ) , pid } \n; \nreturn_sync . write_any ( new OtpErlangTuple ( tuple ) ) ; \nsend ( return_sync ) ; \n} \ncatch ( OtpErlangRangeException e ) { \ne . printStackTrace ( API . err ) ; \nreturn ; \n} \nthrow new ReturnSyncException ( ) ; \nreturn ; \n} \n} \n"}
{"9926": "public class API { \npublic void shutdown ( final String reason ) { \nOtpOutputStream shutdown = new OtpOutputStream ( ) ; \nshutdown . write ( OtpExternal . versionTag ) ; \nfinal OtpErlangObject [ ] tuple = { \nnew OtpErlangAtom ( \"shutdown\" ) , new OtpErlangString ( reason ) } \n; \nshutdown . write_any ( new OtpErlangTuple ( tuple ) ) ; \nsend ( shutdown ) ; \nreturn ; \n} \n} \n"}
{"9928": "public class ForkJoinPool { \nprivate void unlockRunState ( int oldRunState , int newRunState ) { \nif ( ! U . compareAndSwapInt ( this , RUNSTATE , oldRunState , newRunState ) ) { \nObject lock = stealCounter ; \nrunState = newRunState ; \nif ( lock != null ) synchronized ( lock ) { \nlock . notifyAll ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9930": "public class ForkJoinPool { \nprivate void tryAddWorker ( long c ) { \nboolean add = false ; \ndo { \nlong nc = ( ( AC_MASK & ( c + AC_UNIT ) ) | ( TC_MASK & ( c + TC_UNIT ) ) ) ; \nif ( ctl == c ) { \nint rs , stop ; \nif ( ( stop = ( rs = lockRunState ( ) ) & STOP ) == 0 ) add = U . compareAndSwapLong ( this , CTL , c , nc ) ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \nif ( stop != 0 ) break ; \nif ( add ) { \ncreateWorker ( ) ; \nbreak ; \n} \n} \n} \nwhile ( ( ( c = ctl ) & ADD_WORKER ) != 0L && ( int ) c == 0 ) ; \nreturn ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \nreturn ; \n} \n} \n"}
{"9933": "public class ForkJoinPool { \nfinal void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { \nlong c ; \nint sp , i ; \nWorkQueue v ; \nThread p ; \nwhile ( ( c = ctl ) < 0L ) { \nif ( ( sp = ( int ) c ) == 0 ) { \nif ( ( c & ADD_WORKER ) != 0L ) tryAddWorker ( c ) ; \nbreak ; \n} \nif ( ws == null ) break ; \nif ( ws . length <= ( i = sp & SMASK ) ) break ; \nif ( ( v = ws [ i ] ) == null ) break ; \nint vs = ( sp + SS_SEQ ) & ~ INACTIVE ; \nint d = sp - v . scanState ; \nlong nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; \nif ( d == 0 && U . compareAndSwapLong ( this , CTL , c , nc ) ) { \nv . scanState = vs ; \nif ( ( p = v . parker ) != null ) U . unpark ( p ) ; \nbreak ; \n} \nif ( q != null && q . base == q . top ) break ; \n} \nreturn ; \n} \n} \n"}
{"9934": "public class ForkJoinPool { \nfinal void runWorker ( WorkQueue w ) { \nw . growArray ( ) ; \nint seed = w . hint ; \nint r = ( seed == 0 ) ? 1 : seed ; \nfor ( ForkJoinTask < ? > t ; \n; \n) { \nif ( ( t = scan ( w , r ) ) != null ) w . runTask ( t ) ; \nelse if ( ! awaitWork ( w , r ) ) break ; \nr ^= r << 13 ; \nr ^= r >>> 17 ; \nr ^= r << 5 ; \n} \nreturn ; \n} \n} \n"}
{"9949": "public class LocalQueue { \nvoid push ( Runnable task ) { \nfinal long _base = UNSAFE . getLongVolatile ( this , OFFS_BASE ) ; \nfinal long _top = top ; \nif ( _top == _base + mask ) { \nthrow new RejectedExecutionExceptionWithoutStacktrace ( \"local queue overflow\" ) ; \n} \ntasks [ asArrayindex ( _top ) ] = task ; \nUNSAFE . putLongVolatile ( this , OFFS_TOP , _top + 1 ) ; \nif ( _top - _base <= 1 ) { \npool . onAvailableTask ( ) ; \n} \nreturn ; \n} \n} \n"}
{"9955": "public class JavaUtilMapWrapper { \n@ Override public Set < K > keySet ( ) { \nreturn new AbstractSet < K > ( ) { \n@ Override public Iterator < K > iterator ( ) { \nreturn new Iterator < K > ( ) { \nfinal Iterator < AMapEntry < K , V > > it = inner . iterator ( ) ; \n@ Override public boolean hasNext ( ) { \nreturn it . hasNext ( ) ; \n} \n@ Override public K next ( ) { \nreturn it . next ( ) . getKey ( ) ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \nreturn ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn inner . size ( ) ; \n} \n} \n; \n} \n} \n"}
{"9963": "public class ApplicationRouter { \npublic void bind ( final RouteBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null || versions . isEmpty ( ) ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( method == Method . ANY ) { \nfor ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \n} \nelse { \nmethods . add ( method ) ; \n} \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nList < PatternRouteBinding > b = routeBindings . get ( key ) ; \nif ( b == null ) { \nb = new ArrayList < > ( ) ; \nrouteBindings . put ( key , b ) ; \n} \nlogger . info ( \"ADD: {}, Pattern: {}, Route: {}\\n\" , key , handler . getPath ( ) , handler ) ; \naddPattern ( handler , b ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"9964": "public class ApplicationRouter { \npublic void bind ( final FilterBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nfinal String path = handler . getPath ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null || versions . isEmpty ( ) ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( method == Method . ANY ) { \nfor ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \n} \nelse { \nmethods . add ( method ) ; \n} \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nlogger . info ( \"ADD: {}, Pattern: {}, Filter: {}\\n\" , key , path , handler ) ; \nList < PatternFilterBinding > allFilterBindings = this . filterBindings . get ( key ) ; \nif ( allFilterBindings == null ) { \nallFilterBindings = new ArrayList < > ( ) ; \nthis . filterBindings . put ( key , allFilterBindings ) ; \n} \nboolean found = false ; \nfor ( final PatternFilterBinding binding : allFilterBindings ) { \nif ( binding . getPattern ( ) . pattern ( ) . equals ( handler . getPath ( ) ) ) { \nbinding . addFilter ( handler ) ; \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nfinal PatternFilterBinding binding = new PatternFilterBinding ( handler . getPath ( ) , handler ) ; \nallFilterBindings . add ( binding ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"9969": "public class PeriodicService { \npublic void doRun ( ) throws Exception { \nif ( inProgress . compareAndSet ( false , true ) ) { \ntry { \nrun ( ) ; \n} \nfinally { \ninProgress . set ( false ) ; \n} \n} \nelse { \nthrow new IllegalStateException ( \"Another run is already in progress\" ) ; \n} \nreturn ; \n} \n} \n"}
{"9974": "public class SecurityKit { \npublic static < T extends Model > void saveMemberInCookie ( T user , boolean save , HttpServletRequest request , HttpServletResponse response ) { \nString new_value = getLoginKey ( user , Requests . remoteIP ( request ) , request . getHeader ( \"user-agent\" ) ) ; \nint max_age = save ? MAX_AGE : - 1 ; \nRequests . deleteCookie ( request , response , COOKIE_LOGIN , true ) ; \nRequests . setCookie ( request , response , COOKIE_LOGIN , new_value , max_age , true ) ; \nreturn ; \n} \n} \n"}
{"9977": "public class Forward { \npublic void to ( WebContext context ) { \nHttpServletRequest request = context . request ( ) ; \nHttpServletResponse response = context . response ( ) ; \ntry { \nrequest . getRequestDispatcher ( path ) . forward ( request , response ) ; \n} \ncatch ( ServletException e ) { \nthrow new UncheckedException ( e ) ; \n} \ncatch ( IOException e ) { \nthrow new UncheckedException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9980": "public class Logger { \npublic static void debug ( String message , Object ... args ) { \nif ( recordCaller ) { \nLoggerFactory . getLogger ( getCallerClassName ( ) ) . debug ( message , args ) ; \n} \nelse { \nslf4j . debug ( message , args ) ; \n} \nreturn ; \n} \n} \n"}
{"9988": "public class Images { \npublic static void crop ( File originalImage , File to , int x1 , int y1 , int x2 , int y2 ) { \ntry { \nBufferedImage source = ImageIO . read ( originalImage ) ; \nString mimeType = \"image/jpeg\" ; \nif ( to . getName ( ) . endsWith ( \".png\" ) ) { \nmimeType = \"image/png\" ; \n} \nif ( to . getName ( ) . endsWith ( \".gif\" ) ) { \nmimeType = \"image/gif\" ; \n} \nint width = x2 - x1 ; \nint height = y2 - y1 ; \nBufferedImage dest = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; \nImage croppedImage = source . getSubimage ( x1 , y1 , width , height ) ; \nGraphics graphics = dest . getGraphics ( ) ; \ngraphics . setColor ( Color . WHITE ) ; \ngraphics . fillRect ( 0 , 0 , width , height ) ; \ngraphics . drawImage ( croppedImage , 0 , 0 , null ) ; \nImageWriter writer = ImageIO . getImageWritersByMIMEType ( mimeType ) . next ( ) ; \nImageWriteParam params = writer . getDefaultWriteParam ( ) ; \nwriter . setOutput ( new FileImageOutputStream ( to ) ) ; \nIIOImage image = new IIOImage ( dest , null , null ) ; \nwriter . write ( null , image , params ) ; \nwriter . dispose ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"9990": "public class Invoker { \npublic static void invokeInThread ( DirectInvocation invocation ) { \nboolean retry = true ; \nwhile ( retry ) { \ninvocation . run ( ) ; \nif ( invocation . retry == null ) { \nretry = false ; \n} \nelse { \ntry { \nif ( invocation . retry . task != null ) { \ninvocation . retry . task . get ( ) ; \n} \nelse { \nThread . sleep ( invocation . retry . timeout ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new UnexpectedException ( e ) ; \n} \nretry = true ; \n} \n} \nreturn ; \n} \n} \n"}
{"9992": "public class Controller { \nprotected void renderAjaxError ( String error , Exception e ) { \nrenderJson ( AjaxMessage . error ( error , e ) ) ; \nreturn ; \n} \n} \n"}
{"9993": "public class Controller { \nprotected < T > void renderAjaxForbidden ( String message , T data ) { \nrenderJson ( AjaxMessage . forbidden ( message , data ) ) ; \nreturn ; \n} \n} \n"}
{"9996": "public class Controller { \nprotected void renderDataTables ( Class < ? extends Model > m_cls ) { \nDTCriterias criterias = getCriterias ( ) ; \nPreconditions . checkNotNull ( criterias , \"datatable criterias is must be not null.\" ) ; \nDTResponse response = criterias . response ( m_cls ) ; \nrenderJson ( response ) ; \nreturn ; \n} \n} \n"}
{"9997": "public class Controller { \nprotected void renderEmptyDataTables ( DTCriterias criterias ) { \nPreconditions . checkNotNull ( criterias , \"datatable criterias is must be not null.\" ) ; \nDTResponse response = DTResponse . build ( criterias , Collections . EMPTY_LIST , 0 , 0 ) ; \nrenderJson ( response ) ; \nreturn ; \n} \n} \n"}
{"9998": "public class ComboBoxEditingSupport { \npublic void setItems ( List < V > items ) { \nfinal List < V > its = items == null ? ImmutableList . of ( ) : items ; \nthis . items = its ; \ngetComboBoxCellEditor ( ) . setInput ( items ) ; \nreturn ; \n} \n} \n"}
{"9999": "public class Redirect { \npublic void to ( WebContext context ) { \nHttpServletResponse response = context . response ( ) ; \nif ( ! mediaType . isEmpty ( ) ) { \nresponse . setHeader ( \"Content-Type\" , mediaType ) ; \n} \nif ( status > 0 ) { \nresponse . setStatus ( status ) ; \n} \ntry { \nresponse . sendRedirect ( response . encodeRedirectURL ( url ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UncheckedException ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"10002": "public class RuntimeKit { \npublic static void compactMemory ( ) { \ntry { \nfinal byte [ ] [ ] unused = new byte [ 128 ] [ ] ; \nfor ( int i = unused . length ; \ni -- != 0 ; \n) { \nunused [ i ] = new byte [ 2000000000 ] ; \n} \n} \ncatch ( OutOfMemoryError ignore ) { \n} \nSystem . gc ( ) ; \nreturn ; \n} \n} \n"}
{"10008": "public class StreamUtil { \npublic static void copy ( InputStream input , Writer output ) throws IOException { \ncopy ( input , output , Const . DEFAULT_ENCODING ) ; \nreturn ; \n} \n} \n"}
{"10011": "public class StreamUtil { \npublic static void copy ( Reader input , OutputStream output ) throws IOException { \ncopy ( input , output , Const . DEFAULT_ENCODING ) ; \nreturn ; \n} \n} \n"}
{"10012": "public class StreamUtil { \npublic static void copy ( Reader input , OutputStream output , String encoding ) throws IOException { \nWriter out = new OutputStreamWriter ( output , encoding ) ; \ncopy ( input , out ) ; \nout . flush ( ) ; \nreturn ; \n} \n} \n"}
{"10018": "public class ZipKit { \npublic static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nwhile ( zipEntries . hasMoreElements ( ) ) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( patterns != null && patterns . length > 0 ) { \nif ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) { \ncontinue ; \n} \n} \nFile file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; \nif ( entry . isDirectory ( ) ) { \nif ( ! file . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + file ) ; \n} \n} \n} \nelse { \nFile parent = file . getParentFile ( ) ; \nif ( parent != null && ! parent . exists ( ) ) { \nif ( ! parent . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + parent ) ; \n} \n} \n} \nInputStream in = zip . getInputStream ( entry ) ; \nOutputStream out = null ; \ntry { \nout = new FileOutputStream ( file ) ; \nStreamUtil . copy ( in , out ) ; \n} \nfinally { \nStreamUtil . close ( out ) ; \nStreamUtil . close ( in ) ; \n} \n} \n} \nclose ( zip ) ; \nreturn ; \n} \n} \n"}
{"10020": "public class PermissionDialogFragment { \n@ Override public void onResume ( ) { \nsuper . onResume ( ) ; \ngetDialog ( ) . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { \n@ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent keyEvent ) { \nreturn keyCode != KeyEvent . ACTION_DOWN ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"10021": "public class Types { \npublic static void addCoreValueType ( Class < ? > clazz , Converter converter ) { \nConvertUtils . register ( converter , clazz ) ; \nvalues . add ( clazz ) ; \nreturn ; \n} \n} \n"}
{"10028": "public class BootlegFilter { \npublic void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { \ntry { \npipeline . apply ( new WebContext ( configuration , ( HttpServletRequest ) request , ( HttpServletResponse ) response , chain ) ) ; \n} \ncatch ( Exception e ) { \nlogger . warn ( \"Failed to process HTTP request\" , e ) ; \n( ( HttpServletResponse ) response ) . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; \n} \nreturn ; \n} \n} \n"}
{"10035": "public class IO { \npublic static void write ( byte [ ] data , File file ) { \nOutputStream os = null ; \ntry { \nos = new FileOutputStream ( file ) ; \nos . write ( data ) ; \nos . flush ( ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \nfinally { \ntry { \nif ( os != null ) os . close ( ) ; \n} \ncatch ( Exception e ) { \n} \n} \nreturn ; \n} \n} \n"}
{"10036": "public class IO { \npublic static void copyDirectory ( File source , File target ) { \nif ( source . isDirectory ( ) ) { \nif ( ! target . exists ( ) ) { \ntarget . mkdir ( ) ; \n} \nfor ( String child : source . list ( ) ) { \ncopyDirectory ( new File ( source , child ) , new File ( target , child ) ) ; \n} \n} \nelse { \ntry { \nwrite ( new FileInputStream ( source ) , new FileOutputStream ( target ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10055": "public class ExtensionFinder { \nprotected < T > void bind ( Class < ? extends T > impl , Class < T > extensionPoint ) { \nExtensionLoaderModule < T > lm = createLoaderModule ( extensionPoint ) ; \nlm . init ( impl , extensionPoint ) ; \ninstall ( lm ) ; \nreturn ; \n} \n} \n"}
{"10063": "public class Goja { \nprivate void initDataSource ( final Plugins plugins ) { \nfinal Map < String , Properties > dbConfig = GojaConfig . loadDBConfig ( GojaConfig . getConfigProps ( ) ) ; \nfor ( String db_config : dbConfig . keySet ( ) ) { \nfinal Properties db_props = dbConfig . get ( db_config ) ; \nif ( db_props != null && ! db_props . isEmpty ( ) ) { \nDruidDbIntializer . init ( db_config , plugins , db_props ) ; \n} \n} \nif ( GojaConfig . getPropertyToBoolean ( GojaPropConst . DB_SQLINXML , true ) ) { \nplugins . add ( new SqlInXmlPlugin ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10064": "public class Goja { \nprivate void setFtlSharedVariable ( ) { \nfinal Configuration config = FreeMarkerRender . getConfiguration ( ) ; \nconfig . setSharedVariable ( \"block\" , new BlockDirective ( ) ) ; \nconfig . setSharedVariable ( \"extends\" , new ExtendsDirective ( ) ) ; \nconfig . setSharedVariable ( \"override\" , new OverrideDirective ( ) ) ; \nconfig . setSharedVariable ( \"super\" , new SuperDirective ( ) ) ; \nconfig . setSharedVariable ( \"prettytime\" , new PrettyTimeDirective ( ) ) ; \nif ( GojaConfig . isSecurity ( ) ) { \nconfig . setSharedVariable ( \"shiro\" , new ShiroTags ( config . getObjectWrapper ( ) ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10065": "public class DTCriterias { \npublic void setParam ( String field , Condition condition , Object value ) { \nthis . params . add ( Triple . of ( field , condition , value ) ) ; \nreturn ; \n} \n} \n"}
{"10066": "public class DTCriterias { \npublic void setParam ( String field , Object value ) { \nthis . setParam ( field , Condition . EQ , value ) ; \nreturn ; \n} \n} \n"}
{"10067": "public class RequestPermission { \nprivate void showDialog ( PermBean permBean ) { \nPermissionDialogFragment fragment = PermissionDialogFragment . getInstance ( permBean , requestCode ) ; \nfragment . show ( mActivity . getSupportFragmentManager ( ) , TAG ) ; \nreturn ; \n} \n} \n"}
{"10074": "public class ConcurrentSoftHashMap { \nprivate void processQueue ( ) { \nSoftValue < ? , ? > sv ; \nwhile ( ( sv = ( SoftValue < ? , ? > ) queue . poll ( ) ) != null ) { \nmap . remove ( sv . key ) ; \n} \nreturn ; \n} \n} \n"}
{"10077": "public class ArgumentHandler { \npublic static < A > A readArguments ( Class < A > interfaceClass , String [ ] args ) { \nA result = null ; \ntry { \nfinal ArgumentHandler argumentHandler = new ArgumentHandler ( args ) ; \nresult = argumentHandler . getInstance ( interfaceClass ) ; \nargumentHandler . processArguments ( new ArgumentProcessor ( ) { \n@ Override public void process ( List < String > remaining ) throws InvalidArgumentsException { \nif ( remaining . size ( ) > 0 ) { \nthrow new InvalidArgumentsException ( \"The following arguments could not be understood: \" + remaining ) ; \n} \nreturn ; \n} \n} \n) ; \n} \ncatch ( InvalidArgumentsException e ) { \nSystem . out . println ( e . getMessage ( ) ) ; \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \nif ( result instanceof ArgumentsWithHelp ) { \nif ( ( ( ArgumentsWithHelp ) result ) . getHelp ( ) ) { \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10086": "public class DefaultContentRect { \npublic void setBorders ( int top , int right , int bottom , int left ) { \nsetTopBorder ( top ) ; \nsetRightBorder ( right ) ; \nsetBottomBorder ( bottom ) ; \nsetLeftBorder ( left ) ; \nreturn ; \n} \n} \n"}
{"10088": "public class AttributeInjector { \npublic void copyOutAttributes ( Object target , List < Attribute > jmxAttributeValues , Map < String , Method > attributeSetters , ObjectName objectName ) { \nthis . copyOutAttributes ( target , jmxAttributeValues , attributeSetters , \"oname\" , objectName ) ; \nreturn ; \n} \n} \n"}
{"10089": "public class AttributeInjector { \nprotected void copyOutAttributes ( Object target , List < Attribute > jmxAttributeValues , Map < String , Method > attributeSetters , String identifierKey , Object identifier ) { \nfor ( Attribute oneAttribute : jmxAttributeValues ) { \nString attributeName = oneAttribute . getName ( ) ; \nMethod setter = attributeSetters . get ( attributeName ) ; \nObject value = oneAttribute . getValue ( ) ; \ntry { \nif ( ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( Integer . class ) ) || ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( int . class ) ) ) { \nif ( value instanceof Long ) { \nvalue = ( ( Long ) value ) . intValue ( ) ; \n} \n} \nsetter . invoke ( target , value ) ; \n} \ncatch ( InvocationTargetException invocationExc ) { \nthis . log . info ( \"invocation exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , invocationExc ) ; \n} \ncatch ( IllegalAccessException illegalAccessExc ) { \nthis . log . info ( \"illegal access exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , illegalAccessExc ) ; \n} \ncatch ( IllegalArgumentException illegalArgumentExc ) { \nthis . log . info ( \"illegal argument exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , illegalArgumentExc ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10091": "public class AppRunner { \npublic void setProperty ( String key , String value ) { \nif ( m_properties == null ) m_properties = new Properties ( ) ; \nm_properties . setProperty ( key , value ) ; \nreturn ; \n} \n} \n"}
{"10092": "public class AppRunner { \npublic JFrame addAppToFrame ( ) { \nJFrame frame = new JFrame ( ) ; \nframe . setTitle ( this . getTitle ( ) ) ; \nframe . setBackground ( Color . lightGray ) ; \nframe . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; \nframe . getContentPane ( ) . add ( this , BorderLayout . CENTER ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nSystem . exit ( 0 ) ; \nreturn ; \n} \n} \n) ; \nframe . pack ( ) ; \nframe . setSize ( frame . getPreferredSize ( ) . width , frame . getPreferredSize ( ) . height ) ; \nreturn frame ; \n} \n} \n"}
{"10093": "public class PrefAuthPersistence { \n@ Override public void saveToken ( Token token ) { \nset ( ACCESS_TOKEN_TOKEN_PREF , token . getToken ( ) ) ; \nset ( ACCESS_TOKEN_SECRET_PREF , token . getSecret ( ) ) ; \nreturn ; \n} \n} \n"}
{"10099": "public class URI { \nprivate void initialize ( URI p_other ) { \nm_scheme = p_other . getScheme ( ) ; \nm_userinfo = p_other . getUserinfo ( ) ; \nm_host = p_other . getHost ( ) ; \nm_port = p_other . m_port ; \nn_port = p_other . n_port ; \nm_path = p_other . getPath ( ) ; \nm_queryString = p_other . getQueryString ( ) ; \nm_fragment = p_other . getFragment ( ) ; \nreturn ; \n} \n} \n"}
{"10100": "public class URI { \nprivate void initializeScheme ( String p_uriSpec ) throws MalformedURIException { \nint uriSpecLen = p_uriSpec . length ( ) ; \nint index = p_uriSpec . indexOf ( ':' ) ; \nif ( index < 1 ) throw new MalformedURIException ( \"No scheme found in URI.\" ) ; \nif ( index == uriSpecLen - 1 ) throw new MalformedURIException ( \"A bare scheme name is not a URI.\" ) ; \nsetScheme ( p_uriSpec . substring ( 0 , index ) ) ; \nreturn ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \nreturn ; \n} \n} \n"}
{"10102": "public class URI { \nprivate void setScheme ( String p_scheme ) throws MalformedURIException { \nif ( p_scheme == null ) { \nthrow new MalformedURIException ( \"Cannot set scheme from null string!\" ) ; \n} \nif ( ! isConformantSchemeName ( p_scheme ) ) { \nthrow new MalformedURIException ( \"The scheme is not conformant.\" ) ; \n} \nm_scheme = p_scheme ; \nreturn ; \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \nreturn ; \n} \n} \n"}
{"10104": "public class URI { \nprivate void setHost ( String p_host ) throws MalformedURIException { \nif ( p_host == null || p_host . length ( ) == 0 ) { \nm_host = p_host ; \nm_userinfo = null ; \nm_port = null ; \nn_port = - 1 ; \n} \nelse if ( ! isWellFormedAddress ( p_host ) ) { \nthrow new MalformedURIException ( \"Host is not a well formed address!\" ) ; \n} \nm_host = p_host ; \nreturn ; \n} \n} \n"}
{"10105": "public class URI { \nprivate void setPort ( int p_port ) throws MalformedURIException { \nif ( p_port >= 0 && p_port <= 65535 ) { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Port cannot be set when host is null!\" ) ; \n} \n} \nelse if ( p_port != - 1 ) { \nthrow new MalformedURIException ( \"Invalid port number!\" ) ; \n} \nn_port = p_port ; \nreturn ; \n} \n} \n"}
{"10106": "public class URI { \nprivate void appendPath ( String p_addToPath ) throws MalformedURIException { \nif ( p_addToPath == null || p_addToPath . length ( ) == 0 ) { \nreturn ; \n} \nif ( ! isURIString ( p_addToPath ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character!\" ) ; \n} \nif ( m_path == null || m_path . length ( ) == 0 ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = p_addToPath ; \n} \nelse { \nm_path = \"/\" + p_addToPath ; \n} \n} \nelse if ( m_path . endsWith ( \"/\" ) ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; \n} \nelse { \nm_path = m_path . concat ( p_addToPath ) ; \n} \n} \nelse { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath ) ; \n} \nelse { \nm_path = m_path . concat ( \"/\" + p_addToPath ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10107": "public class URI { \nprivate void setQueryString ( String p_queryString ) throws MalformedURIException { \nif ( p_queryString == null ) { \nm_queryString = null ; \n} \nelse if ( ! isGenericURI ( ) ) { \nthrow new MalformedURIException ( \"Query string can only be set for a generic URI!\" ) ; \n} \nelse if ( getPath ( ) == null ) { \nthrow new MalformedURIException ( \"Query string cannot be set when path is null!\" ) ; \n} \nelse if ( ! isURIString ( p_queryString ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character!\" ) ; \n} \nelse { \nm_queryString = p_queryString ; \n} \nreturn ; \n} \n} \n"}
{"10108": "public class URI { \npublic void setFragment ( String p_fragment ) throws MalformedURIException { \nif ( p_fragment == null ) { \nm_fragment = null ; \n} \nelse if ( ! isGenericURI ( ) ) { \nthrow new MalformedURIException ( \"Fragment can only be set for a generic URI!\" ) ; \n} \nelse if ( getPath ( ) == null ) { \nthrow new MalformedURIException ( \"Fragment cannot be set when path is null!\" ) ; \n} \nelse if ( ! isURIString ( p_fragment ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character!\" ) ; \n} \nelse { \nm_fragment = p_fragment ; \n} \nreturn ; \n} \n} \n"}
{"10111": "public class MuffinManager { \npublic void init ( Object applet ) { \ntry { \nm_ps = ( PersistenceService ) ServiceManager . lookup ( \"javax.jnlp.PersistenceService\" ) ; \nm_bs = ( BasicService ) ServiceManager . lookup ( \"javax.jnlp.BasicService\" ) ; \nm_strCodeBase = m_bs . getCodeBase ( ) . toString ( ) ; \n} \ncatch ( UnavailableServiceException e ) { \nm_ps = null ; \nm_bs = null ; \n} \nreturn ; \n} \n} \n"}
{"10113": "public class MuffinManager { \npublic void setMuffin ( String strParam , String strValue ) { \nFileContents fc = null ; \nURL url = null ; \ntry { \nurl = new URL ( m_strCodeBase + strParam ) ; \n} \ncatch ( Exception ex ) { \nreturn ; \n} \ntry { \nfc = m_ps . get ( url ) ; \nfc . getMaxLength ( ) ; \n} \ncatch ( Exception ex ) { \nfc = null ; \n} \ntry { \nif ( fc == null ) { \nm_ps . create ( url , 100 ) ; \nfc = m_ps . get ( url ) ; \n} \nif ( strValue != null ) { \nOutputStream os = fc . getOutputStream ( false ) ; \nbyte [ ] buf = strValue . getBytes ( ENCODING ) ; \nos . write ( buf ) ; \nos . close ( ) ; \nm_ps . setTag ( url , PersistenceService . DIRTY ) ; \n} \nelse m_ps . delete ( url ) ; \n} \ncatch ( Exception ex ) { \nex . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10118": "public class ServiceManager { \npublic static void setServiceParams ( ParametrizedOperation op , Map < String , Object > params ) { \nif ( params != null ) { \nfor ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { \nop . setParam ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10123": "public class FastBuffer { \n@ Override public Iterator < E > iterator ( ) { \nreturn new Iterator < E > ( ) { \nint iteratorIndex ; \nint iteratorBufferIndex ; \nint iteratorOffset ; \n@ Override public boolean hasNext ( ) { \nreturn iteratorIndex < size ; \n} \n@ Override public E next ( ) { \nif ( iteratorIndex >= size ) { \nthrow new NoSuchElementException ( ) ; \n} \nE [ ] buf = buffers [ iteratorBufferIndex ] ; \nE result = buf [ iteratorOffset ] ; \niteratorIndex ++ ; \niteratorOffset ++ ; \nif ( iteratorOffset >= buf . length ) { \niteratorOffset = 0 ; \niteratorBufferIndex ++ ; \n} \nreturn result ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"10128": "public class DeclarationScanner { \npublic void visitPackageDeclaration ( PackageDeclaration d ) { \nd . accept ( pre ) ; \nfor ( ClassDeclaration classDecl : d . getClasses ( ) ) { \nclassDecl . accept ( this ) ; \n} \nfor ( InterfaceDeclaration interfaceDecl : d . getInterfaces ( ) ) { \ninterfaceDecl . accept ( this ) ; \n} \nd . accept ( post ) ; \nreturn ; \n} \n} \n"}
{"10129": "public class DeclarationScanner { \npublic void visitClassDeclaration ( ClassDeclaration d ) { \nd . accept ( pre ) ; \nfor ( TypeParameterDeclaration tpDecl : d . getFormalTypeParameters ( ) ) { \ntpDecl . accept ( this ) ; \n} \nfor ( FieldDeclaration fieldDecl : d . getFields ( ) ) { \nfieldDecl . accept ( this ) ; \n} \nfor ( MethodDeclaration methodDecl : d . getMethods ( ) ) { \nmethodDecl . accept ( this ) ; \n} \nfor ( TypeDeclaration typeDecl : d . getNestedTypes ( ) ) { \ntypeDecl . accept ( this ) ; \n} \nfor ( ConstructorDeclaration ctorDecl : d . getConstructors ( ) ) { \nctorDecl . accept ( this ) ; \n} \nd . accept ( post ) ; \nreturn ; \n} \n} \n"}
{"10130": "public class DeclarationScanner { \npublic void visitExecutableDeclaration ( ExecutableDeclaration d ) { \nd . accept ( pre ) ; \nfor ( TypeParameterDeclaration tpDecl : d . getFormalTypeParameters ( ) ) { \ntpDecl . accept ( this ) ; \n} \nfor ( ParameterDeclaration pDecl : d . getParameters ( ) ) { \npDecl . accept ( this ) ; \n} \nd . accept ( post ) ; \nreturn ; \n} \n} \n"}
{"10137": "public class ReflexUtil { \npublic static < T > void makeAccessible ( final Constructor < T > constructor ) { \nif ( ! Modifier . isPublic ( constructor . getModifiers ( ) ) || ! Modifier . isPublic ( constructor . getDeclaringClass ( ) . getModifiers ( ) ) ) { \nconstructor . setAccessible ( true ) ; \n} \nreturn ; \n} \n} \n"}
{"10144": "public class ProtobufSerializer { \nprivate static final void setProtobufFieldValue ( ProtobufAttribute protobufAttribute , Builder protoObjBuilder , String setter , Object fieldValue ) throws NoSuchMethodException , SecurityException , ProtobufAnnotationException , InstantiationException , IllegalAccessException , IllegalArgumentException , InvocationTargetException { \nClass < ? extends Object > fieldValueClass = fieldValue . getClass ( ) ; \nClass < ? extends Object > gpbClass = fieldValueClass ; \nfinal Class < ? extends IProtobufConverter > converterClazz = protobufAttribute . converter ( ) ; \nif ( converterClazz != NullConverter . class ) { \nfinal IProtobufConverter protoBufConverter = ( IProtobufConverter ) converterClazz . newInstance ( ) ; \nfieldValue = protoBufConverter . convertToProtobuf ( fieldValue ) ; \ngpbClass = fieldValue . getClass ( ) ; \nfieldValueClass = gpbClass ; \n} \ngpbClass = ProtobufSerializerUtils . getProtobufClass ( fieldValue , gpbClass ) ; \nfinal Method gpbMethod = protoObjBuilder . getClass ( ) . getDeclaredMethod ( setter , gpbClass ) ; \ngpbMethod . invoke ( protoObjBuilder , fieldValue ) ; \nreturn ; \n} \n} \n"}
{"10145": "public class ProtobufSerializer { \nprivate static final void setPojoFieldValue ( Object pojo , String setter , Object protobufValue , ProtobufAttribute protobufAttribute ) throws InstantiationException , IllegalAccessException , JException { \nfinal Class < ? extends IProtobufConverter > fromProtoBufConverter = protobufAttribute . converter ( ) ; \nif ( fromProtoBufConverter != NullConverter . class ) { \nfinal IProtobufConverter converter = fromProtoBufConverter . newInstance ( ) ; \nprotobufValue = converter . convertFromProtobuf ( protobufValue ) ; \n} \nClass < ? extends Object > argClazz = protobufValue . getClass ( ) ; \nJReflectionUtils . runSetter ( pojo , setter , protobufValue , argClazz ) ; \nreturn ; \n} \n} \n"}
{"10151": "public class JmxAttributePoller { \npublic void poll ( ) throws IOException { \nsynchronized ( this ) { \nif ( shutdownInd ) { \nreturn ; \n} \npollActiveInd = true ; \n} \ntry { \nthis . checkConnection ( ) ; \nthis . concurrencyTestHooks . beforePollProcessorStart ( ) ; \nif ( this . mBeanAccessConnection instanceof MBeanBatchCapableAccessConnection ) { \nthis . batchPollProcessor . pollBatch ( ( MBeanBatchCapableAccessConnection ) this . mBeanAccessConnection , this . polledObjects ) ; \n} \nelse { \nthis . pollIndividually ( ) ; \n} \n} \ncatch ( IOException ioExc ) { \nthis . safeClose ( this . mBeanAccessConnection ) ; \nthis . mBeanAccessConnection = null ; \nthrow ioExc ; \n} \nfinally { \nthis . concurrencyTestHooks . afterPollProcessorFinish ( ) ; \nsynchronized ( this ) { \npollActiveInd = false ; \nthis . notifyAll ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10158": "public class DebugOutputStream { \nprotected void dumpByte ( int b ) { \nif ( passThrough == true ) { \nSystem . out . print ( '\\t' ) ; \n} \nif ( b < 0 ) { \nb += 128 ; \n} \nif ( b < 0x10 ) { \nSystem . out . print ( '0' ) ; \n} \nSystem . out . print ( ' ' ) ; \nSystem . out . print ( Integer . toHexString ( b ) . toUpperCase ( ) ) ; \nreturn ; \n} \n} \n"}
{"10161": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.NullAssignment\" ) private void cleanState ( ) { \ndomain = null ; \nusername = null ; \nCleanser . wipe ( password ) ; \npendingSubject = null ; \ncommittedSubject = null ; \nreturn ; \n} \n} \n"}
{"10162": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initAudit ( final CommonProperties commonProps ) { \ntry { \nfinal String auditClassName = commonProps . getAuditClassName ( ) ; \nif ( ! commonProps . isAuditEnabled ( ) ) { \nfinal String error = \"Auditing has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse if ( auditClassName == null ) { \nfinal String error = \"Auditing has been enabled in the JAAS configuration, but no audit class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nif ( commonProps . isAuditSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; \n} \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The audit class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \nreturn ; \n} \n} \n"}
{"10163": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initMessageQueue ( final CommonProperties commonProps ) { \ntry { \nfinal String messageClassName = commonProps . getMessageQueueClassName ( ) ; \nif ( ! commonProps . isMessageQueueEnabled ( ) ) { \nfinal String error = \"Message queue has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse if ( messageClassName == null ) { \nfinal String error = \"Message queue has been enabled in the JAAS configuration, \" + \"but no message queue class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nif ( commonProps . isMessageQueueSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; \n} \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The message class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \nreturn ; \n} \n} \n"}
{"10164": "public class PasswordLoginModule { \nprivate void initPwValidator ( final CommonProperties commonProps ) { \ntry { \nfinal String validatorClass = commonProps . getPasswordValidatorClassName ( ) ; \nif ( validatorClass == null ) { \nfinal String error = \"No password validator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nif ( commonProps . isPasswordValidatorSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getSingleton ( validatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getInstance ( validatorClass , commonProps ) ; \n} \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \nreturn ; \n} \n} \n"}
{"10165": "public class PasswordLoginModule { \nprivate void initPwAuthenticator ( final CommonProperties commonProps ) { \ntry { \nfinal String authNticatorClass = commonProps . getPasswordAuthenticatorClassName ( ) ; \nif ( authNticatorClass == null ) { \nfinal String error = \"No password authenticator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nif ( commonProps . isPasswordAuthenticatorSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getSingleton ( authNticatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getInstance ( authNticatorClass , commonProps ) ; \n} \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \nreturn ; \n} \n} \n"}
{"10169": "public class ArrayStack { \npublic void clear ( ) { \nint i = size ; \nObject [ ] els = elements ; \nwhile ( i -- > 0 ) { \nels [ i ] = null ; \n} \nthis . size = 0 ; \nreturn ; \n} \n} \n"}
{"10175": "public class Rectangular { \npublic void move ( int xofs , int yofs ) { \nx1 += xofs ; \ny1 += yofs ; \nx2 += xofs ; \ny2 += yofs ; \nreturn ; \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \nreturn ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \nreturn ; \n} \n} \n"}
{"10188": "public class Main { \npublic static void main ( String [ ] args ) { \ntry { \nMain main = new Main ( ) ; \nmain . start ( ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( main . getShutdownHook ( ) ) ; \nmain . awaitTermination ( 1 , TimeUnit . DAYS ) ; \n} \ncatch ( InterruptedException e ) { \ne = null ; \nThread . currentThread ( ) . interrupt ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10189": "public class ByteCodeMonitor { \npublic void onCodeUpdate ( ByteBuffer codeBuffer , int start , int length , VariableAndFunctorInterner interner , WAMCodeView codeView ) { \nlog . fine ( \"public void onCodeUpdate(ByteBuffer codeBuffer, int start = \" + start + \", int length = \" + length + \", VariableAndFunctorInterner interner, WAMCodeView codeView): called\" ) ; \ncopyAndResizeCodeBuffer ( codeBuffer , start , length ) ; \nSizeableList < WAMInstruction > instructions = WAMInstruction . disassemble ( start , length , this . codeBuffer , interner , codeView ) ; \nMap . Entry < Integer , Integer > entry = addressToRow . floorEntry ( start ) ; \nint firstRow = ( entry == null ) ? 0 : ( entry . getValue ( ) + 1 ) ; \nint address = start ; \nint row = firstRow ; \nfor ( WAMInstruction instruction : instructions ) { \naddressToRow . put ( address , row ) ; \nrowToAddress . add ( row , address ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \nrenderInstructions ( instructions , firstRow , start ) ; \nreturn ; \n} \n} \n"}
{"10190": "public class ByteCodeMonitor { \nprivate void copyAndResizeCodeBuffer ( ByteBuffer codeBuffer , int start , int length ) { \nint max = start + length ; \nif ( this . codeBuffer . limit ( ) <= max ) { \nByteBuffer newCodeBuffer = ByteBuffer . allocate ( max * 2 ) ; \nnewCodeBuffer . put ( this . codeBuffer . array ( ) , 0 , this . codeBuffer . limit ( ) ) ; \nlog . fine ( \"Re-sized code buffer to \" + ( max * 2 ) ) ; \n} \ncodeBuffer . position ( start ) ; \ncodeBuffer . get ( this . codeBuffer . array ( ) , start , length ) ; \nreturn ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nint fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \nfor ( int i = 2 ; \ni < 32 ; \ni = i * 2 ) { \nif ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) { \narg += \", \" ; \n} \nswitch ( i ) { \ncase 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) { \narg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; \n} \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) { \narg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \n} \nbreak ; \n} \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10192": "public class PropertyLoaderServlet { \npublic void init ( ) { \nlog . fine ( \"public void init(): called\" ) ; \nString propertyResource = getInitParameter ( PROPERTY_RESOURCE ) ; \nString varName = getInitParameter ( APP_VAR_NAME ) ; \nlog . fine ( \"varName = \" + varName ) ; \nProperties properties = DefaultPropertyReader . getProperties ( propertyResource ) ; \nlog . fine ( \"properties = \" + properties ) ; \ngetServletContext ( ) . setAttribute ( varName , properties ) ; \nreturn ; \n} \n} \n"}
{"10194": "public class SimpleTree { \npublic void addChild ( Tree < E > child ) { \ninitChildren ( ) ; \nchildren . add ( child ) ; \nnodeOrLeaf = Type . Node ; \nchild . setParent ( this ) ; \nreturn ; \n} \n} \n"}
{"10195": "public class SimpleTree { \npublic void clearChildren ( ) { \nif ( children != null ) { \nfor ( Tree < E > child : children ) { \nchild . setParent ( null ) ; \n} \nchildren . clear ( ) ; \nnodeOrLeaf = Type . Leaf ; \n} \nreturn ; \n} \n} \n"}
{"10197": "public class WAMCompiledClause { \npublic void addInstructions ( Functor body , SizeableList < WAMInstruction > instructions ) { \nint oldLength ; \nif ( this . body == null ) { \noldLength = 0 ; \nthis . body = new Functor [ 1 ] ; \n} \nelse { \noldLength = this . body . length ; \nthis . body = Arrays . copyOf ( this . body , oldLength + 1 ) ; \n} \nthis . body [ oldLength ] = body ; \naddInstructionsAndThisToParent ( instructions ) ; \nreturn ; \n} \n} \n"}
{"10198": "public class WAMCompiledClause { \nprivate void addInstructionsAndThisToParent ( SizeableList < WAMInstruction > instructions ) { \nif ( ! addedToParent ) { \nparent . addInstructions ( this , instructions ) ; \naddedToParent = true ; \n} \nelse { \nparent . addInstructions ( instructions ) ; \n} \nreturn ; \n} \n} \n"}
{"10199": "public class ButtonPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nif ( event . getSource ( ) instanceof WorkPanelState ) { \nString state = ( ( WorkPanelState ) event . getSource ( ) ) . getState ( ) ; \nif ( state . equals ( WorkPanelState . NOT_SAVED ) ) { \ncancelButton . setEnabled ( true ) ; \napplyButton . setEnabled ( true ) ; \n} \nelse if ( state . equals ( WorkPanelState . READY ) ) { \ncancelButton . setEnabled ( false ) ; \napplyButton . setEnabled ( false ) ; \n} \nelse if ( state . equals ( WorkPanelState . NOT_INITIALIZED ) ) { \nokButton . setEnabled ( false ) ; \ncancelButton . setEnabled ( false ) ; \napplyButton . setEnabled ( false ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10200": "public class ButtonPanel { \npublic void registerWorkPanel ( WorkPanel panel ) { \nokButton . addActionListener ( panel ) ; \ncancelButton . addActionListener ( panel ) ; \napplyButton . addActionListener ( panel ) ; \npanel . getWorkPanelState ( ) . addPropertyChangeListener ( this ) ; \nreturn ; \n} \n} \n"}
{"10201": "public class DesktopAppLayout { \nprivate void updatePresentComponentFlags ( ) { \nhasConsole = componentMap . containsKey ( CONSOLE ) ; \nhasStatusBar = componentMap . containsKey ( STATUS_BAR ) ; \nhasLeftBar = componentMap . containsKey ( LEFT_VERTICAL_BAR ) ; \nhasLeftPane = componentMap . containsKey ( LEFT_PANE ) ; \nhasRightBar = componentMap . containsKey ( RIGHT_VERTICAL_BAR ) ; \nhasRightPane = componentMap . containsKey ( RIGHT_PANE ) ; \nreturn ; \n} \n} \n"}
{"10206": "public class DataStreamServlet { \npublic void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { \nlog . fine ( \"void service(HttpServletRequest, HttpServletResponse): called\" ) ; \nString contentType = ( String ) request . getAttribute ( \"contentType\" ) ; \nString contentDisposition = ( String ) request . getAttribute ( \"contentDisposition\" ) ; \nInputStream inputStream = ( InputStream ) request . getAttribute ( \"inputStream\" ) ; \nif ( contentType != null ) { \nresponse . setContentType ( contentType ) ; \n} \nif ( contentDisposition != null ) { \nresponse . addHeader ( \"Content-disposition\" , contentDisposition ) ; \n} \nBufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; \nint length = - 1 ; \nbyte [ ] chunk = new byte [ 8192 ] ; \nwhile ( ( length = inputStream . read ( chunk ) ) != - 1 ) { \noutputStream . write ( chunk , 0 , length ) ; \n} \noutputStream . flush ( ) ; \ninputStream . close ( ) ; \nreturn ; \n} \n} \n"}
{"10208": "public class PageControlTag { \nprivate void renderButton ( boolean render , int page , int index , String openDelim , String url , String text , boolean active ) throws JspException { \nlog . fine ( \"private void renderButton(boolean render, int page, int index, String openDelim, String url, String text, boolean active): called\" ) ; \nlog . fine ( \"render = \" + render ) ; \nlog . fine ( \"page = \" + page ) ; \nlog . fine ( \"index = \" + index ) ; \nlog . fine ( \"openDelim = \" + openDelim ) ; \nlog . fine ( \"url = \" + url ) ; \nlog . fine ( \"text = \" + text ) ; \nlog . fine ( \"active = \" + active ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nif ( render ) { \ntagUtils . write ( pageContext , openDelim ) ; \nif ( active ) { \ntagUtils . write ( pageContext , \"<a href=\\\"\" + url + \"?varName=\" + name + \"&number=\" + page + \"&index=\" + index + \"\\\">\" + text + \"</a>\" ) ; \n} \nelse { \ntagUtils . write ( pageContext , text ) ; \n} \ntagUtils . write ( pageContext , closeDelim ) ; \n} \nreturn ; \n} \n} \n"}
{"10209": "public class AbstractLearningMethod { \npublic void reset ( ) { \nmaxSteps = 0 ; \nmachineToTrain = null ; \ninputExamples = new ArrayList < State > ( ) ; \ninputProperties = new HashSet < String > ( ) ; \noutputProperties = new HashSet < String > ( ) ; \ninputPropertiesSet = false ; \noutputPropertiesSet = false ; \nreturn ; \n} \n} \n"}
{"10210": "public class AbstractLearningMethod { \nprotected void initialize ( ) throws LearningFailureException { \nif ( inputExamples . isEmpty ( ) ) { \nthrow new LearningFailureException ( \"No training examples to learn from.\" , null ) ; \n} \nif ( ! outputPropertiesSet ) { \naddGoalProperty ( \"goal\" ) ; \n} \nif ( ! inputPropertiesSet ) { \nState example = inputExamples . iterator ( ) . next ( ) ; \nSet < String > allProperties = example . getComponentType ( ) . getAllPropertyNames ( ) ; \ninputProperties = new HashSet < String > ( allProperties ) ; \ninputProperties . removeAll ( outputProperties ) ; \ninputPropertiesSet = true ; \n} \nfor ( State example : inputExamples ) { \nSet < String > properties = example . getComponentType ( ) . getAllPropertyNames ( ) ; \nString errorMessage = \"\" ; \nfor ( String inputProperty : inputProperties ) { \nif ( ! properties . contains ( inputProperty ) ) { \nerrorMessage += \"The training example, \" + example + \" does not contain the specified input property, \" + inputProperty + \"\\n\" ; \n} \n} \nfor ( String outputProperty : outputProperties ) { \nif ( ! properties . contains ( outputProperty ) ) { \nerrorMessage += \"The training example, \" + example + \" does not contain the specified output property, \" + outputProperty + \"\\n\" ; \n} \n} \nif ( ! \"\" . equals ( errorMessage ) ) { \nthrow new LearningFailureException ( errorMessage , null ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10217": "public class PropertyIntrospectorBase { \nprotected void setProperty ( Object callee , String property , Object value ) { \nif ( ! initialized ) { \ninitialize ( callee ) ; \n} \nMethod [ ] setterMethods = setters . get ( property ) ; \nif ( ( setterMethods == null ) || ( setterMethods . length == 0 ) ) { \nthrow new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; \n} \nMethod setterMethod = null ; \nClass valueType = ( value == null ) ? null : value . getClass ( ) ; \nif ( value == null ) { \nsetterMethod = setterMethods [ 0 ] ; \n} \nelse { \nfor ( Method method : setterMethods ) { \nClass argType = method . getParameterTypes ( ) [ 0 ] ; \nif ( argType . isAssignableFrom ( valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse if ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse if ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) && isAssignableFromPrimitive ( argType , valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \n} \nif ( setterMethod == null ) { \nClass calleeType = ( callee == null ) ? null : callee . getClass ( ) ; \nthrow new IllegalArgumentException ( \"No setter method for property \" + property + \", of type, \" + calleeType + \" will accept the type of value specified, \" + valueType + \".\" ) ; \n} \n} \ntry { \nObject [ ] args = new Object [ ] { \nvalue } \n; \nsetterMethod . invoke ( callee , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalArgumentException ( \"The setter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"The setter method for the property \" + property + \" cannot be accessed.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"10220": "public class PropertyIntrospectorBase { \nprivate void initialize ( Object callee ) { \nMap < String , List < Method > > settersTemp = new HashMap < String , List < Method > > ( ) ; \nMethod [ ] methods = callee . getClass ( ) . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \ngetters . put ( propertyName , nextMethod ) ; \n} \nelse if ( methodName . startsWith ( \"set\" ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \nList < Method > setterMethodsForName = settersTemp . get ( propertyName ) ; \nif ( setterMethodsForName == null ) { \nsetterMethodsForName = new ArrayList < Method > ( ) ; \nsettersTemp . put ( propertyName , setterMethodsForName ) ; \n} \nsetterMethodsForName . add ( nextMethod ) ; \n} \n} \nfor ( Map . Entry < String , List < Method > > entries : settersTemp . entrySet ( ) ) { \nString nextPropertyName = entries . getKey ( ) ; \nList < Method > nextMethodList = entries . getValue ( ) ; \nMethod [ ] methodArray = nextMethodList . toArray ( new Method [ nextMethodList . size ( ) ] ) ; \nsetters . put ( nextPropertyName , methodArray ) ; \n} \ninitialized = true ; \nreturn ; \n} \n} \n"}
{"10222": "public class Decision { \npublic void initializeLookups ( DecisionTree thisNode ) { \nfor ( Iterator < Tree < DecisionTreeElement > > i = thisNode . getChildIterator ( ) ; \ni . hasNext ( ) ; \n) { \nDecisionTree nextChildTree = ( DecisionTree ) i . next ( ) ; \nOrdinalAttribute matchingValue = nextChildTree . getElement ( ) . getAttributeValue ( ) ; \ndecisions [ matchingValue . ordinal ( ) ] = nextChildTree ; \n} \nreturn ; \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( cutLevelVarSlot >= 0 ) { \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \n} \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \nfor ( int i = 0 ; \ni < expressions . length ; \ni ++ ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( expression instanceof BuiltIn ) { \nbuiltIn = ( BuiltIn ) expression ; \n} \nelse { \nbuiltIn = this ; \n} \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \nreturn ; \n} \n} \n"}
{"10228": "public class InstructionCompiler { \nprivate void allocatePermanentQueryRegisters ( Term clause , Map < Byte , Integer > varNames ) { \nQueryRegisterAllocatingVisitor allocatingVisitor = new QueryRegisterAllocatingVisitor ( symbolTable , varNames , null ) ; \nPositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; \npositionalTraverser . setContextChangeVisitor ( allocatingVisitor ) ; \nTermWalker walker = new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , positionalTraverser , allocatingVisitor ) ; \nwalker . walk ( clause ) ; \nreturn ; \n} \n} \n"}
{"10229": "public class InstructionCompiler { \nprivate void gatherPositionAndOccurrenceInfo ( Term clause ) { \nPositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; \nPositionAndOccurrenceVisitor positionAndOccurrenceVisitor = new PositionAndOccurrenceVisitor ( interner , symbolTable , positionalTraverser ) ; \npositionalTraverser . setContextChangeVisitor ( positionAndOccurrenceVisitor ) ; \nTermWalker walker = new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , positionalTraverser , positionAndOccurrenceVisitor ) ; \nwalker . walk ( clause ) ; \nreturn ; \n} \n} \n"}
{"10230": "public class InstructionCompiler { \nprivate void displayCompiledPredicate ( Term predicate ) { \nStringBuffer result = new StringBuffer ( ) ; \nPositionalTermVisitor displayVisitor = new WAMCompiledPredicatePrintingVisitor ( interner , symbolTable , result ) ; \nTermWalkers . positionalWalker ( displayVisitor ) . walk ( predicate ) ; \nreturn ; \n} \n} \n"}
{"10231": "public class InstructionCompiler { \nprivate void displayCompiledQuery ( Term query ) { \nStringBuffer result = new StringBuffer ( ) ; \nPositionalTermVisitor displayVisitor = new WAMCompiledQueryPrintingVisitor ( interner , symbolTable , result ) ; \nTermWalkers . positionalWalker ( displayVisitor ) . walk ( query ) ; \nreturn ; \n} \n} \n"}
{"10235": "public class EnumeratedStringAttribute { \npublic void setStringValue ( String value ) throws IllegalArgumentException { \nByte b = attributeClass . lookupByte . get ( value ) ; \nif ( b == null ) { \nif ( attributeClass . finalized ) { \nthrow new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized EnumeratedStringType, \" + attributeClass . attributeClassName + \".\" ) ; \n} \nelse { \nEnumeratedStringAttribute newAttribute = attributeClass . createStringAttribute ( value ) ; \nb = newAttribute . value ; \n} \n} \nthis . value = b ; \nreturn ; \n} \n} \n"}
{"10236": "public class LojixTermReader { \nprivate void read ( Term term ) { \nif ( term . isNumber ( ) ) { \nNumericType numericType = ( NumericType ) term ; \nif ( numericType . isInteger ( ) ) { \nIntLiteral jplInteger = ( IntLiteral ) term ; \ngetContentHandler ( ) . startIntegerTerm ( jplInteger . longValue ( ) ) ; \n} \nelse if ( numericType . isFloat ( ) ) { \nFloatLiteral jplFloat = ( FloatLiteral ) term ; \ngetContentHandler ( ) . startFloatTerm ( jplFloat . doubleValue ( ) ) ; \n} \n} \nelse if ( term . isVar ( ) ) { \nVariable var = ( Variable ) term ; \ngetContentHandler ( ) . startVariable ( interner . getVariableName ( var . getName ( ) ) ) ; \n} \nelse if ( term . isAtom ( ) ) { \nFunctor atom = ( Functor ) term ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( atom . getName ( ) ) ) ; \n} \nelse if ( term . isCompound ( ) ) { \nFunctor functor = ( Functor ) term ; \ngetContentHandler ( ) . startCompound ( ) ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( functor . getName ( ) ) ) ; \nfor ( com . thesett . aima . logic . fol . Term child : functor . getArguments ( ) ) { \nread ( child ) ; \n} \ngetContentHandler ( ) . endCompound ( ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Unrecognized Lojix term: \" + term ) ; \n} \nreturn ; \n} \n} \n"}
{"10252": "public class BaseQueueSearch { \npublic void reset ( ) { \nstartStates . clear ( ) ; \nenqueuedOnce = false ; \nqueue = createQueue ( ) ; \ngoalPredicate = null ; \nmaxSteps = 0 ; \nsearchSteps = 0 ; \nif ( repeatedStateFilter != null ) { \nrepeatedStateFilter . reset ( ) ; \n} \nsearchAlgorithm . reset ( ) ; \nreturn ; \n} \n} \n"}
{"10255": "public class SchemaDefinitionImpl { \npublic void addSupportedTZ ( String tzName ) { \nif ( ! StringUtils . isBlank ( tzName ) && ! tzNamesAliases . containsKey ( tzName . trim ( ) ) ) { \ntzNamesAliases . put ( tzName . trim ( ) , tzName . trim ( ) ) ; \nif ( LOG . isInfoEnabled ( ) ) { \nLOG . info ( \"Endpoint \" + this . getEndPointName ( ) + \" - add support of TZ: \" + tzName ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10256": "public class SchemaDefinitionImpl { \npublic void addTZAlternateDimension ( String orignalDimensionName , DimensionTable alternateDimension , String tzName ) { \naddSupportedTZ ( tzName ) ; \nif ( tzNamesAliases . containsValue ( tzName ) ) { \nsqlTables . put ( alternateDimension . getTableName ( ) , alternateDimension ) ; \nalternateDimensions . put ( Pair . of ( orignalDimensionName . toUpperCase ( ) , tzName ) , alternateDimension ) ; \n} \nelse { \nLOG . error ( \"Unsuported timezone: \" + tzName ) ; \n} \nreturn ; \n} \n} \n"}
{"10257": "public class SchemaDefinitionImpl { \npublic void addDimension ( DimensionTable table , boolean mandatory ) { \nsqlTables . put ( table . getTableName ( ) , table ) ; \ndimensions . put ( table . getDimensionName ( ) . toUpperCase ( ) , table ) ; \nif ( mandatory ) { \nmandatoryDimensionNames . add ( table . getDimensionName ( ) . toUpperCase ( Locale . ENGLISH ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10261": "public class FileUtils { \npublic static void writeObjectToFile ( String outputFileName , Object toWrite , boolean append ) { \nWriter resultWriter ; \ntry { \nresultWriter = new FileWriter ( outputFileName , append ) ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( \"Unable to open the output file '\" + outputFileName + \"' for writing.\" , e ) ; \n} \ntry { \nresultWriter . write ( toWrite . toString ( ) ) ; \nresultWriter . flush ( ) ; \nresultWriter . close ( ) ; \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( \"There was an error whilst writing to the output file '\" + outputFileName + \"'.\" , e ) ; \n} \nreturn ; \n} \n} \n"}
{"10265": "public class DefaultBuiltIn { \nprotected void allocateArgumentRegisters ( Functor expression ) { \nint reg = 0 ; \nfor ( ; \nreg < expression . getArity ( ) ; \nreg ++ ) { \nTerm term = expression . getArgument ( reg ) ; \nif ( term instanceof Functor ) { \nint allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; \nsymbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10274": "public class Surface { \npublic void setTexture ( Paint obj ) { \nif ( obj instanceof GradientPaint ) { \ntexture = new GradientPaint ( 0 , 0 , Color . white , getSize ( ) . width * 2 , 0 , Color . green ) ; \n} \nelse { \ntexture = obj ; \n} \nreturn ; \n} \n} \n"}
{"10275": "public class Surface { \npublic void paintImmediately ( int x , int y , int w , int h ) { \nRepaintManager repaintManager = null ; \nboolean save = true ; \nif ( ! isDoubleBuffered ( ) ) { \nrepaintManager = RepaintManager . currentManager ( this ) ; \nsave = repaintManager . isDoubleBufferingEnabled ( ) ; \nrepaintManager . setDoubleBufferingEnabled ( false ) ; \n} \nsuper . paintImmediately ( x , y , w , h ) ; \nif ( repaintManager != null ) { \nrepaintManager . setDoubleBufferingEnabled ( save ) ; \n} \nreturn ; \n} \n} \n"}
{"10280": "public class PostFixSearch { \nprotected void setQueueSearchAlgorithm ( QueueSearchAlgorithm < O , T > algorithm ) { \nalgorithm . setPeekAtHead ( true ) ; \nalgorithm . setReverseEnqueueOrder ( true ) ; \nsuper . setQueueSearchAlgorithm ( algorithm ) ; \nreturn ; \n} \n} \n"}
{"10283": "public class PrologParser { \npublic static void main ( String [ ] args ) { \ntry { \nSimpleCharStream inputStream = new SimpleCharStream ( System . in , null , 1 , 1 ) ; \nPrologParserTokenManager tokenManager = new PrologParserTokenManager ( inputStream ) ; \nSource < Token > tokenSource = new TokenSource ( tokenManager ) ; \nPrologParser parser = new PrologParser ( tokenSource , new VariableAndFunctorInternerImpl ( \"Prolog_Variable_Namespace\" , \"Prolog_Functor_Namespace\" ) ) ; \nwhile ( true ) { \nObject nextParsing = parser . clause ( ) ; \nconsole . info ( nextParsing . toString ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nconsole . log ( Level . SEVERE , e . getMessage ( ) , e ) ; \nSystem . exit ( 1 ) ; \n} \nreturn ; \n} \n} \n"}
{"10294": "public class PrologParser { \npublic void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { \nint arity ; \nif ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) { \narity = 2 ; \n} \nelse { \narity = 1 ; \n} \nint name = interner . internFunctorName ( operatorName , arity ) ; \noperatorTable . setOperator ( name , operatorName , priority , associativity ) ; \nreturn ; \n} \n} \n"}
{"10295": "public class PrologParser { \nprotected void initializeBuiltIns ( ) { \ninternOperator ( \":-\" , 1200 , XFX ) ; \ninternOperator ( \":-\" , 1200 , FX ) ; \ninternOperator ( \"-->\" , 1200 , XFX ) ; \ninternOperator ( \"?-\" , 1200 , FX ) ; \ninternOperator ( \";\" , 1100 , XFY ) ; \ninternOperator ( \"->\" , 1050 , XFY ) ; \ninternOperator ( \",\" , 1000 , XFY ) ; \ninternOperator ( \"\\\\+\" , 900 , FY ) ; \ninternOperator ( \"=\" , 700 , XFX ) ; \ninternOperator ( \"\\\\=\" , 700 , XFX ) ; \ninternOperator ( \"==\" , 700 , XFX ) ; \ninternOperator ( \"\\\\==\" , 700 , XFX ) ; \ninternOperator ( \"@<\" , 700 , XFX ) ; \ninternOperator ( \"@=<\" , 700 , XFX ) ; \ninternOperator ( \"@>\" , 700 , XFX ) ; \ninternOperator ( \"@>=\" , 700 , XFX ) ; \ninternOperator ( \"=..\" , 700 , XFX ) ; \ninternOperator ( \"is\" , 700 , XFX ) ; \ninternOperator ( \"=:=\" , 700 , XFX ) ; \ninternOperator ( \"=\\\\=\" , 700 , XFX ) ; \ninternOperator ( \"<\" , 700 , XFX ) ; \ninternOperator ( \"=<\" , 700 , XFX ) ; \ninternOperator ( \">\" , 700 , XFX ) ; \ninternOperator ( \">=\" , 700 , XFX ) ; \ninternOperator ( \"+\" , 500 , YFX ) ; \ninternOperator ( \"-\" , 500 , YFX ) ; \ninternOperator ( \"\\\\/\" , 500 , YFX ) ; \ninternOperator ( \"/\\\\\" , 500 , YFX ) ; \ninternOperator ( \"/\" , 400 , YFX ) ; \ninternOperator ( \"//\" , 400 , YFX ) ; \ninternOperator ( \"*\" , 400 , YFX ) ; \ninternOperator ( \">>\" , 400 , YFX ) ; \ninternOperator ( \"<<\" , 400 , YFX ) ; \ninternOperator ( \"rem\" , 400 , YFX ) ; \ninternOperator ( \"mod\" , 400 , YFX ) ; \ninternOperator ( \"-\" , 200 , FY ) ; \ninternOperator ( \"^\" , 200 , YFX ) ; \ninternOperator ( \"**\" , 200 , YFX ) ; \ninternOperator ( \"\\\\\" , 200 , FY ) ; \ninterner . internFunctorName ( \"nil\" , 0 ) ; \ninterner . internFunctorName ( \"cons\" , 2 ) ; \ninterner . internFunctorName ( \"true\" , 0 ) ; \ninterner . internFunctorName ( \"fail\" , 0 ) ; \ninterner . internFunctorName ( \"!\" , 0 ) ; \nreturn ; \n} \n} \n"}
{"10298": "public class TxSessionImpl { \npublic void bind ( ) { \nif ( ( txId == null ) || ! txId . isValid ( ) ) { \ntxId = TxManager . createTxId ( ) ; \n} \nTxManager . assignTxIdToThread ( txId ) ; \nthreadSession . set ( this ) ; \nreturn ; \n} \n} \n"}
{"10299": "public class TxSessionImpl { \npublic void rollback ( ) { \nfor ( Transactional enlist : enlists ) { \nenlist . rollback ( ) ; \n} \nenlists . clear ( ) ; \ntxId = TxManager . removeTxIdFromThread ( ) ; \nTxManager . invalidateTxId ( txId ) ; \nbind ( ) ; \nreturn ; \n} \n} \n"}
{"10316": "public class SequentialCuckooFunction { \nprivate void rehash ( ) { \nint newSize = hashTableSize ; \nif ( hashTableSize < ( count * 2 ) ) { \nnewSize = hashTableSize * 2 ; \nif ( newSize > maxSize ) { \nthrow new IllegalStateException ( \"'newSize' of \" + newSize + \" would put the table over the maximum size limit of \" + maxSize ) ; \n} \n} \nEntry < K > [ ] oldTable = hashTable ; \nhashTableSize = newSize ; \nlength = hashTable . length ; \nboolean rehashedOk ; \ndo { \nrehashedOk = true ; \nchangeHashFunctions ( ) ; \nhashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; \nfor ( Entry < K > entry : oldTable ) { \nif ( entry != null ) { \nif ( applyWithEntry ( entry . key , entry , false ) == null ) { \nrehashedOk = false ; \nbreak ; \n} \n} \n} \n} \nwhile ( ! rehashedOk ) ; \nreturn ; \n} \n} \n"}
{"10317": "public class WorkPanel { \npublic void actionPerformed ( ActionEvent event ) { \nString action = event . getActionCommand ( ) ; \nif ( \"OK\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \nsaveWork ( ) ; \n} \n} \nelse if ( \"Cancel\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \ndiscardWork ( ) ; \n} \n} \nelse if ( \"Apply\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \nsaveWork ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10318": "public class WorkFlowScreenState { \npublic void setNextAvailable ( boolean avail ) { \nif ( nextAvailable != avail ) { \nnextAvailable = avail ; \nfirePropertyChange ( new PropertyChangeEvent ( this , \"nextAvailable\" , ! avail , avail ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10319": "public class WorkFlowScreenState { \npublic void setPrevAvailable ( boolean avail ) { \nif ( prevAvailable != avail ) { \nprevAvailable = avail ; \nfirePropertyChange ( new PropertyChangeEvent ( this , \"prevAvailable\" , ! avail , avail ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10320": "public class WorkFlowScreenState { \npublic void setFinished ( boolean avail ) { \nif ( finished != avail ) { \nfinished = avail ; \nfirePropertyChange ( new PropertyChangeEvent ( this , \"finished\" , ! avail , avail ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10325": "public class DateOnly { \nvoid setTicks ( long ticks ) { \nyear = TimeUtils . ticksToYears ( ticks ) ; \nmonth = TimeUtils . ticksToMonths ( ticks ) ; \nday = TimeUtils . ticksToDate ( ticks ) ; \nreturn ; \n} \n} \n"}
{"10340": "public class WorkFlowState { \npublic void setCurrentScreenState ( WorkFlowScreenState state ) { \nWorkFlowScreenState oldState = currentScreenState ; \ncurrentScreenState = state ; \nfirePropertyChange ( new PropertyChangeEvent ( this , \"currentScreenState\" , oldState , state ) ) ; \nreturn ; \n} \n} \n"}
{"10341": "public class TermWalker { \npublic void walk ( Term term ) { \nterm . setTermTraverser ( traverser ) ; \nsearch . reset ( ) ; \nif ( goalPredicate != null ) { \nsearch . setGoalPredicate ( goalPredicate ) ; \n} \nsearch . addStartState ( term ) ; \nIterator < Term > treeWalker = Searches . allSolutions ( search ) ; \nif ( traverser instanceof TermVisitor ) { \nterm . accept ( ( TermVisitor ) traverser ) ; \n} \nwhile ( treeWalker . hasNext ( ) ) { \nTerm nextTerm = treeWalker . next ( ) ; \nnextTerm . accept ( visitor ) ; \n} \nterm . setTermTraverser ( null ) ; \nreturn ; \n} \n} \n"}
{"10343": "public class InternalRegisterBean { \npublic void updateRegisters ( WAMInternalRegisters registers ) { \nList < PropertyChangeEvent > changes = delta ( this , registers ) ; \nip = registers . ip ; \nhp = registers . hp ; \nhbp = registers . hbp ; \nsp = registers . sp ; \nup = registers . up ; \nep = registers . ep ; \nbp = registers . bp ; \nb0 = registers . b0 ; \ntrp = registers . trp ; \nwriteMode = registers . writeMode ; \nnotifyChanges ( changes ) ; \nreturn ; \n} \n} \n"}
{"10344": "public class InternalRegisterBean { \nprivate void notifyChanges ( Iterable < PropertyChangeEvent > changes ) { \nList < PropertyChangeListener > activeListeners = listeners . getActiveListeners ( ) ; \nif ( activeListeners != null ) { \nfor ( PropertyChangeListener listener : activeListeners ) { \nfor ( PropertyChangeEvent event : changes ) { \nlistener . propertyChange ( event ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10345": "public class PositionAndOccurrenceVisitor { \nprotected void leaveClause ( Clause clause ) { \nconstants . keySet ( ) . removeAll ( argumentConstants ) ; \nfor ( List < SymbolKey > symbolKeys : constants . values ( ) ) { \nfor ( SymbolKey symbolKey : symbolKeys ) { \nsymbolTable . put ( symbolKey , SymbolTableKeys . SYMKEY_FUNCTOR_NON_ARG , true ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10348": "public class OpSymbol { \npublic void setArguments ( Term [ ] arguments ) { \nif ( ( arguments == null ) || ( arguments . length < 1 ) || ( arguments . length > 2 ) ) { \nthrow new IllegalArgumentException ( \"An operator has minimum 1 and maximum 2 arguments.\" ) ; \n} \nthis . arguments = arguments ; \nthis . arity = arguments . length ; \nreturn ; \n} \n} \n"}
{"10352": "public class WorkFlowButtonsPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nObject source = event . getSource ( ) ; \nObject oldValue = event . getOldValue ( ) ; \nString propertyName = event . getPropertyName ( ) ; \nif ( source instanceof WorkFlowScreenState ) { \nWorkFlowScreenState wfsState = ( WorkFlowScreenState ) source ; \nupdateButtonsForScreen ( wfsState ) ; \n} \nif ( source instanceof WorkFlowState ) { \nWorkFlowState wfState = ( WorkFlowState ) source ; \nif ( \"currentScreenState\" . equals ( propertyName ) ) { \nWorkFlowScreenState newScreenState = wfState . getCurrentScreenState ( ) ; \nWorkFlowScreenState oldScreenState = ( WorkFlowScreenState ) oldValue ; \nif ( oldScreenState != null ) { \noldScreenState . removePropertyChangeListener ( this ) ; \n} \nif ( newScreenState != null ) { \nnewScreenState . addPropertyChangeListener ( this ) ; \n} \nupdateButtonsForScreen ( newScreenState ) ; \n} \nelse if ( \"state\" . equals ( propertyName ) ) { \nupdateButtonsForWorkFlow ( wfState ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10353": "public class WorkFlowButtonsPanel { \npublic void registerWorkFlowController ( WorkFlowController controller ) { \nbackButton . addActionListener ( controller ) ; \nnextButton . addActionListener ( controller ) ; \nfinishButton . addActionListener ( controller ) ; \ncancelButton . addActionListener ( controller ) ; \ncontroller . getWorkFlowState ( ) . addPropertyChangeListener ( this ) ; \nWorkFlowScreenState currentScreenState = controller . getWorkFlowState ( ) . getCurrentScreenState ( ) ; \nif ( currentScreenState != null ) { \ncurrentScreenState . addPropertyChangeListener ( this ) ; \n} \nreturn ; \n} \n} \n"}
{"10358": "public class AttributeGridImpl { \nprivate void setColumnAttribute ( AttributeSet attributes , int c ) { \nif ( c >= columnAttributes . size ( ) ) { \nfor ( int i = columnAttributes . size ( ) ; \ni <= c ; \ni ++ ) { \ncolumnAttributes . add ( null ) ; \n} \n} \ncolumnAttributes . set ( c , attributes ) ; \nreturn ; \n} \n} \n"}
{"10359": "public class AttributeGridImpl { \nprivate void setRowAttribute ( AttributeSet attributes , int r ) { \nif ( r >= rowAttributes . size ( ) ) { \nfor ( int i = rowAttributes . size ( ) ; \ni <= r ; \ni ++ ) { \nrowAttributes . add ( null ) ; \n} \n} \nrowAttributes . set ( r , attributes ) ; \nreturn ; \n} \n} \n"}
{"10362": "public class AttributeGridImpl { \nprivate void internalInsert ( AttributeSet attributes , int c , int r ) { \ncellAttributes . put ( ( long ) c , ( long ) r , attributes ) ; \nreturn ; \n} \n} \n"}
{"10366": "public class PositionalTermTraverserImpl { \nprivate void createInitialContext ( Term term ) { \nif ( ! initialContextCreated ) { \nPositionalContextOperator initialContext = new PositionalContextOperator ( term , - 1 , false , false , false , null , contextStack . peek ( ) ) ; \ncontextStack . offer ( initialContext ) ; \nterm . setReversable ( initialContext ) ; \ninitialContextCreated = true ; \n} \nreturn ; \n} \n} \n"}
{"10367": "public class InternalMemoryLayoutBean { \npublic void updateRegisters ( WAMMemoryLayout layout ) { \nList < PropertyChangeEvent > changes = delta ( this , layout ) ; \nregBase = layout . regBase ; \nregSize = layout . regSize ; \nheapBase = layout . heapBase ; \nheapSize = layout . heapSize ; \nstackBase = layout . stackBase ; \nstackSize = layout . stackSize ; \ntrailBase = layout . trailBase ; \ntrailSize = layout . trailSize ; \npdlBase = layout . pdlBase ; \npdlSize = layout . pdlSize ; \nnotifyChanges ( changes ) ; \nreturn ; \n} \n} \n"}
{"10373": "public class BatchedThrottle { \npublic void setRate ( float hertz ) { \nsuper . setRate ( hertz ) ; \nint x = ( int ) ( Math . log10 ( hertz ) / 2 ) ; \nbatchSize = ( int ) Math . pow ( 100 , x ) ; \nfloat throttleRate = hertz / batchSize ; \ncallCount = 0 ; \nbatchRateThrottle . setRate ( throttleRate ) ; \nreturn ; \n} \n} \n"}
{"10376": "public class Disjunction { \nprivate void gatherDisjunctions ( Disjunction disjunction , List < Term > expressions ) { \ngatherDisjunctionsExploreArgument ( disjunction . getArguments ( ) [ 0 ] , expressions ) ; \ngatherDisjunctionsExploreArgument ( disjunction . getArguments ( ) [ 1 ] , expressions ) ; \nreturn ; \n} \n} \n"}
{"10378": "public class ByteBufferUtils { \npublic static void writeIntToByteArray ( byte [ ] buf , int offset , int value ) { \nbuf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; \nbuf [ offset ++ ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; \nbuf [ offset ++ ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; \nbuf [ offset ] = ( byte ) ( ( value & 0xff000000 ) >> 24 ) ; \nreturn ; \n} \n} \n"}
{"10379": "public class ByteBufferUtils { \npublic static void write24BitIntToByteArray ( byte [ ] buf , int offset , int value ) { \nbuf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; \nbuf [ offset ++ ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; \nbuf [ offset ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; \nreturn ; \n} \n} \n"}
{"10382": "public class ByteBufferUtils { \npublic static void writeShortToByteArray ( byte [ ] buf , int offset , short value ) { \nbuf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; \nbuf [ offset ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; \nreturn ; \n} \n} \n"}
{"10387": "public class IdAttribute { \npublic void setValue ( T value ) throws IllegalArgumentException { \nInteger b = attributeClass . lookupInt . get ( value ) ; \nif ( b == null ) { \nif ( attributeClass . finalized ) { \nthrow new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized IdType, \" + attributeClass . attributeClassName + \".\" ) ; \n} \nelse { \nIdAttribute newAttribute = attributeClass . createIdAttribute ( value ) ; \nb = newAttribute . value ; \n} \n} \nthis . value = b ; \nreturn ; \n} \n} \n"}
{"10400": "public class HierarchyAttribute { \nprivate void writeObject ( ObjectOutputStream out ) throws IOException { \nfor ( HierarchyClassImpl attributeClass : attributeClasses . values ( ) ) { \n} \nList < String > pathValue = getPathValue ( ) ; \nString [ ] pathArrayValue = pathValue . toArray ( new String [ pathValue . size ( ) ] ) ; \nout . writeObject ( pathArrayValue ) ; \nout . writeObject ( attributeClass . getName ( ) ) ; \nreturn ; \n} \n} \n"}
{"10401": "public class HierarchyAttribute { \nprivate void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { \nString [ ] pathArrayValue = ( String [ ] ) in . readObject ( ) ; \nString attributeClassName = ( String ) in . readObject ( ) ; \nHierarchyAttribute attr = getFactoryForClass ( attributeClassName ) . createHierarchyAttribute ( pathArrayValue ) ; \nvalue = attr . value ; \nattributeClass = attr . attributeClass ; \nfor ( HierarchyClassImpl attributeClass : attributeClasses . values ( ) ) { \n} \nreturn ; \n} \n} \n"}
{"10404": "public class MultipleUserErrorException { \npublic void addErrorMessage ( String key , String userMessage ) { \nerrors . add ( new UserReadableErrorImpl ( key , userMessage ) ) ; \nreturn ; \n} \n} \n"}
{"10405": "public class ErrorHandler { \npublic static void handleErrors ( Throwable exception , ActionErrors errors ) { \nlog . log ( Level . SEVERE , exception . getMessage ( ) , exception ) ; \nif ( exception . getCause ( ) == null ) { \nlog . fine ( \"Exception.getCause() is null\" ) ; \n} \nif ( ( exception instanceof WrappedStrutsServletException ) && ( exception . getCause ( ) != null ) ) { \nexception = exception . getCause ( ) ; \nlog . fine ( \"Unwrapped WrappedStrutsServletException\" ) ; \n} \nWriter stackTrace = new StringWriter ( ) ; \nexception . printStackTrace ( new PrintWriter ( new HTMLFilter ( stackTrace ) ) ) ; \nerrors . add ( \"exception\" , new ActionError ( \"error.general\" , stackTrace ) ) ; \nif ( exception instanceof UserReadableError ) { \nUserReadableError userError = ( UserReadableError ) exception ; \nif ( userError . isUserReadable ( ) ) { \nif ( userError . getUserMessageKey ( ) != null ) { \nerrors . add ( \"generalerror\" , new ActionError ( userError . getUserMessageKey ( ) , userError . getUserMessageKey ( ) ) ) ; \n} \nelse { \nerrors . add ( \"generalerror\" , new ActionError ( \"error.general\" , userError . getUserMessage ( ) ) ) ; \n} \nreturn ; \n} \n} \nerrors . add ( \"generalerror\" , new ActionError ( \"error.internalerror\" ) ) ; \nreturn ; \n} \n} \n"}
{"10406": "public class HTMLFilter { \npublic void write ( String str , int off , int len ) throws IOException { \nString inputString = str . substring ( off , off + len ) ; \nStringBuffer outputString = new StringBuffer ( ) ; \nfor ( StringTokenizer tokenizer = new StringTokenizer ( inputString , \"\\n\" , true ) ; \ntokenizer . hasMoreTokens ( ) ; \n) { \nString nextToken = tokenizer . nextToken ( ) ; \nif ( \"\\n\" . equals ( nextToken ) ) { \noutputString . append ( \"<br>\" ) ; \n} \nelse { \noutputString . append ( nextToken ) ; \n} \n} \nout . write ( outputString . toString ( ) ) ; \nreturn ; \n} \n} \n"}
{"10419": "public class WAMCompiledQuery { \npublic void setHead ( Functor head , SizeableList < WAMInstruction > instructions ) { \nthis . head = head ; \naddInstructions ( instructions ) ; \nreturn ; \n} \n} \n"}
{"10420": "public class WAMCompiledQuery { \npublic void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { \nif ( sizeof ( ) > Integer . MAX_VALUE ) { \nthrow new IllegalStateException ( \"The instruction listing size exceeds Integer.MAX_VALUE.\" ) ; \n} \nint length = 0 ; \nfor ( WAMInstruction instruction : instructions ) { \ninstruction . emmitCode ( buffer , machine ) ; \nlength += instruction . sizeof ( ) ; \n} \nthis . machine = machine ; \nthis . callPoint = callPoint ; \nthis . status = LinkStatus . Linked ; \nreturn ; \n} \n} \n"}
{"10421": "public class WorkFlowController { \nprotected void setCurrentScreen ( WorkFlowScreenPanel screen ) { \npanel . removeAll ( ) ; \npanel . add ( screen ) ; \nif ( ! accessedScreens . contains ( screen ) ) { \naccessedScreens . push ( screen ) ; \n} \nstate . setCurrentScreenState ( screen . getState ( ) ) ; \ncurrentScreen = screen ; \nscreen . initialize ( ) ; \npanel . validate ( ) ; \nreturn ; \n} \n} \n"}
{"10425": "public class ContextualProperties { \nprotected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { \nreturn new Iterator ( ) { \nprivate int i ; \npublic boolean hasNext ( ) { \nreturn ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; \n} \npublic Object next ( ) { \nif ( ! hasNext ( ) ) { \nreturn null ; \n} \nint o = ORDER [ i ] ; \nString result = ( ( ( o & E ) != 0 ) ? ( environment + \".\" ) : \"\" ) + ( ( ( o & B ) != 0 ) ? ( base + \".\" ) : \"\" ) + ( ( ( o & M ) != 0 ) ? ( modifier + \".\" ) : \"\" ) + key ; \ni ++ ; \nreturn result ; \n} \npublic void remove ( ) { \nthrow new UnsupportedOperationException ( \"remove() is not supported on this key order iterator as \" + \"the ordering cannot be changed\" ) ; \nreturn ; \n} \n} \n; \n} \n} \n"}
{"10426": "public class ContextualProperties { \nprotected void createArrayProperties ( ) { \nfor ( Object o : keySet ( ) ) { \nString key = ( String ) o ; \nString value = super . getProperty ( key ) ; \nint lastDotIndex = key . lastIndexOf ( '.' ) ; \nString keyEnding = key . substring ( lastDotIndex + 1 , key . length ( ) ) ; \nString keyStart = key . substring ( 0 , ( lastDotIndex == - 1 ) ? 0 : lastDotIndex ) ; \nint index = 0 ; \ntry { \nindex = Integer . parseInt ( keyEnding ) ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \ncontinue ; \n} \nArrayList propArray = ( ArrayList ) arrayProperties . get ( keyStart ) ; \nif ( propArray == null ) { \npropArray = new ArrayList ( ) ; \narrayProperties . put ( keyStart , propArray ) ; \n} \npropArray . set ( index , value ) ; \n} \nreturn ; \n} \n} \n"}
{"10427": "public class BaseThrottle { \npublic void setRate ( float hertz ) { \nif ( hertz <= 0.0f ) { \nthrow new IllegalArgumentException ( \"The throttle rate must be above zero.\" ) ; \n} \ncycleTimeNanos = ( long ) ( 1000000000f / hertz ) ; \nfirstCall = false ; \nfirstCheckCall = false ; \nreturn ; \n} \n} \n"}
{"10429": "public class PropertyReaderBase { \nprotected void findProperties ( ) { \nproperties = getPropertiesUsingSystemProperty ( ) ; \nif ( properties != null ) { \nreturn ; \n} \nproperties = getPropertiesUsingClasspath ( ) ; \nif ( properties != null ) { \nreturn ; \n} \nproperties = getPropertiesUsingCWD ( ) ; \nif ( properties != null ) { \nreturn ; \n} \nreturn ; \n} \n} \n"}
{"10433": "public class BuiltInTransformVisitor { \nprotected void leaveFunctor ( Functor functor ) { \nint pos = traverser . getPosition ( ) ; \nif ( ! traverser . isInHead ( ) && ( pos >= 0 ) ) { \nFunctor transformed = builtInTransform . apply ( functor ) ; \nif ( functor != transformed ) { \nBuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; \nTerm parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; \nif ( parentTerm instanceof Clause ) { \nClause parentClause = ( Clause ) parentTerm ; \nparentClause . getBody ( ) [ pos ] = builtInFunctor ; \n} \nelse if ( parentTerm instanceof Functor ) { \nFunctor parentFunctor = ( Functor ) parentTerm ; \nparentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10435": "public class Variable { \npublic void setSubstitution ( Term term ) { \nTerm termToBindTo = term ; \nif ( termToBindTo instanceof Variable ) { \nVariable variableToBindTo = ( Variable ) term ; \ntermToBindTo = variableToBindTo . getStorageCell ( variableToBindTo ) ; \n} \nsubstitution = termToBindTo ; \nreturn ; \n} \n} \n"}
{"10437": "public class SilentFailSocketAppender { \npublic void cleanUp ( ) { \nif ( oos != null ) { \ntry { \noos . close ( ) ; \n} \ncatch ( IOException e ) { \nLogLog . error ( \"Could not close oos.\" , e ) ; \n} \noos = null ; \n} \nif ( connector != null ) { \nconnector . interrupted = true ; \nconnector = null ; \n} \nreturn ; \n} \n} \n"}
{"10438": "public class SilentFailSocketAppender { \npublic void append ( LoggingEvent event ) { \nif ( event == null ) { \nreturn ; \n} \nif ( address == null ) { \nerrorHandler . error ( \"No remote host is set for SocketAppender named \\\"\" + this . name + \"\\\".\" ) ; \nreturn ; \n} \nif ( oos != null ) { \ntry { \nif ( locationInfo ) { \nevent . getLocationInformation ( ) ; \n} \noos . writeObject ( event ) ; \noos . flush ( ) ; \nif ( ++ counter >= RESET_FREQUENCY ) { \ncounter = 0 ; \noos . reset ( ) ; \n} \n} \ncatch ( IOException e ) { \noos = null ; \nLogLog . warn ( \"Detected problem with connection: \" + e ) ; \nif ( reconnectionDelay > 0 ) { \nfireConnector ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10439": "public class SilentFailSocketAppender { \nvoid fireConnector ( ) { \nif ( connector == null ) { \nLogLog . debug ( \"Starting a new connector thread.\" ) ; \nconnector = new Connector ( ) ; \nconnector . setDaemon ( true ) ; \nconnector . setPriority ( Thread . MIN_PRIORITY ) ; \nconnector . start ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10440": "public class WAMCompiledTermsPrintingVisitor { \nprotected void initializePrinters ( ) { \nint maxColumns = 0 ; \nprinters . add ( new SourceClausePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new PositionPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new UnoptimizedLabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new UnoptimizedByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new LabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nprinters . add ( new ByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; \nreturn ; \n} \n} \n"}
{"10441": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void commit ( ) { \nTxId txId = null ; \nif ( ! getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \ntry { \nacquireGlobalWriteLock ( txId ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new IllegalStateException ( \"Interrupted whilst commit is waiting for global write lock.\" , e ) ; \n} \nList < TxOperation > alterations = txWrites . get ( txId ) ; \ntry { \nif ( alterations != null ) { \nfor ( TxOperation nextAlteration : alterations ) { \nnextAlteration . execute ( ) ; \n} \ntxWrites . remove ( txId ) ; \n} \n} \nfinally { \nreleaseGlobalWriteLock ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10442": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void rollback ( ) { \nTxId txId = null ; \nif ( ! getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \nList < TxOperation > alterations = txWrites . get ( txId ) ; \nif ( alterations != null ) { \nfor ( TxOperation nextAlteration : alterations ) { \nnextAlteration . cancel ( false ) ; \n} \n} \ntxWrites . remove ( txId ) ; \n} \nreturn ; \n} \n} \n"}
{"10443": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void requestWriteOperation ( TxOperation op ) { \nTxId txId = null ; \nif ( getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) > 0 ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \nenlistWithSession ( ) ; \n} \nif ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { \nop . execute ( ) ; \n} \nelse { \naddCachedOperation ( txId , op ) ; \n} \nreturn ; \n} \n} \n"}
{"10444": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void addCachedOperation ( TxId txId , TxOperation cachedWriteOperation ) { \nList < TxOperation > writeCache = txWrites . get ( txId ) ; \nif ( writeCache == null ) { \nwriteCache = new ArrayList < TxOperation > ( ) ; \ntxWrites . put ( txId , writeCache ) ; \n} \nwriteCache . add ( cachedWriteOperation ) ; \nreturn ; \n} \n} \n"}
{"10445": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void acquireGlobalWriteLock ( TxId txId ) throws InterruptedException { \nglobalLock . writeLock ( ) . lock ( ) ; \ntry { \nif ( ! txId . equals ( globalWriteLockTxId ) ) { \nwhile ( globalWriteLockTxId != null ) { \nglobalWriteLockFree . await ( ) ; \n} \nglobalWriteLockTxId = txId ; \n} \n} \nfinally { \nglobalLock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10446": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void releaseGlobalWriteLock ( ) { \nglobalLock . writeLock ( ) . lock ( ) ; \ntry { \nglobalWriteLockTxId = null ; \nglobalWriteLockFree . signal ( ) ; \n} \nfinally { \nglobalLock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10447": "public class GlobalWriteLockWithWriteBehindTxMethod { \nprivate void enlistWithSession ( ) { \nTxSession session = TxSessionImpl . getCurrentSession ( ) ; \nif ( session == null ) { \nthrow new IllegalStateException ( \"Cannot access transactional resource outside of a session.\" ) ; \n} \nsession . enlist ( this ) ; \nreturn ; \n} \n} \n"}
{"10451": "public class BatchSynchQueueBase { \npublic void put ( E e ) throws InterruptedException { \ntry { \ntryPut ( e ) ; \n} \ncatch ( SynchException ex ) { \nex = null ; \n} \nreturn ; \n} \n} \n"}
{"10458": "public class ScopeNode { \nprivate void setAdditionVisitor ( ) { \nsetAdditionVisitor ( new InclusiveNodeVisitor ( ) { \n@ Override public boolean add ( ParametersNode node ) { \nfor ( VariableDefinitionNode variable : NodeTreeUtils . getChildren ( node , VariableDefinitionNode . class ) ) { \n_parameterDefinitions . add ( variable ) ; \nadd ( variable ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( RuleSetNode node ) { \nSelectorGroupNode selectorGroup = NodeTreeUtils . getFirstChild ( node , SelectorGroupNode . class ) ; \nfor ( SelectorNode selectorNode : NodeTreeUtils . getChildren ( selectorGroup , SelectorNode . class ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( Node selectorChild : selectorNode . getChildren ( ) ) { \nsb . append ( selectorChild . toString ( ) ) ; \n} \nString selector = sb . toString ( ) ; \nif ( ! _selectorToRuleSetMap . containsKey ( selector ) ) { \n_selectorToRuleSetMap . put ( selector , node ) ; \n} \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( ScopeNode node ) { \nNodeTreeUtils . moveChildren ( node , ScopeNode . this ) ; \nreturn false ; \n} \n@ Override public boolean add ( VariableDefinitionNode node ) { \nString name = node . getName ( ) ; \nif ( ! _variableNameToValueMap . containsKey ( name ) ) { \n_variableNameToValueMap . put ( name , NodeTreeUtils . getFirstChild ( node , ExpressionGroupNode . class ) ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( PropertyNode node ) { \nString name = node . getName ( ) ; \nif ( name . equals ( FILTER_PROPERTY ) ) { \nreturn super . add ( node ) ; \n} \nif ( node . getChildren ( ) . get ( 0 ) . toString ( ) . startsWith ( \"-\" ) ) { \nreturn super . add ( node ) ; \n} \nif ( _propertyNameToNodeMap . containsKey ( name ) ) { \nPropertyNode oldPropertyNode = _propertyNameToNodeMap . get ( name ) ; \nint oldPropertyIndex = getChildren ( ) . indexOf ( oldPropertyNode ) ; \nif ( oldPropertyNode . isVisible ( ) ) { \noldPropertyNode . setVisible ( false ) ; \nif ( ! hideWhiteSpaceNode ( oldPropertyIndex - 1 ) ) { \nhideWhiteSpaceNode ( oldPropertyIndex + 1 ) ; \n} \n} \n} \n_propertyNameToNodeMap . put ( name , node ) ; \nreturn super . add ( node ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"10459": "public class BacktrackingAlgorithm { \nprotected void backtrack ( SearchNode checkNode ) { \nwhile ( ( checkNode != null ) && ( checkNode . unexaminedSuccessorCount == 0 ) ) { \nReversable undoState = ( ReTraversable ) checkNode . getState ( ) ; \nundoState . undoOperator ( ) ; \ncheckNode = checkNode . getParent ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10463": "public class DirectMemento { \npublic void capture ( ) { \nClass cls = ob . getClass ( ) ; \nwhile ( ! cls . equals ( Object . class ) ) { \nField [ ] attrs = cls . getDeclaredFields ( ) ; \nHashMap map = new HashMap ( ) ; \nvalues . put ( cls , map ) ; \nfor ( Field attr : attrs ) { \nattr . setAccessible ( true ) ; \nif ( shouldBeSaved ( attr ) ) { \ntry { \nmap . put ( attr . getName ( ) , attr . get ( ob ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"Field '\" + attr . getName ( ) + \"' could not be accessed but the 'setAccessible(true)' method was invoked on it.\" , e ) ; \n} \n} \n} \ncls = cls . getSuperclass ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10464": "public class DirectMemento { \npublic void restore ( Object ob ) throws NoSuchFieldException { \nfor ( Object key : values . keySet ( ) ) { \nClass cls = ( Class ) key ; \nMap vals = ( HashMap ) values . get ( cls ) ; \nfor ( Object o : vals . keySet ( ) ) { \nString attr = ( String ) o ; \nObject val = vals . get ( attr ) ; \nField f = cls . getDeclaredField ( attr ) ; \nf . setAccessible ( true ) ; \ntry { \nf . set ( ob , val ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"Field '\" + f . getName ( ) + \"' could not be accessed but the 'setAccessible(true)' method was invoked on it.\" , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10466": "public class DirectMemento { \npublic void put ( Class cls , String attr , Object val ) { \nHashMap map ; \nif ( values . containsKey ( cls ) ) { \nmap = ( HashMap ) values . get ( cls ) ; \n} \nelse { \nmap = new HashMap ( ) ; \nvalues . put ( cls , map ) ; \n} \nmap . put ( attr , val ) ; \nreturn ; \n} \n} \n"}
{"10468": "public class ProductionScriptGenMojo { \npublic void execute ( ) throws MojoExecutionException , MojoFailureException { \nfor ( String commandName : commands . keySet ( ) ) { \nif ( prodScriptOutDirectory != null ) { \nwriteUnixScript ( commandName , prodScriptOutDirectory ) ; \nwriteWindowsScript ( commandName , prodScriptOutDirectory ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10483": "public class JTextGrid { \nprivate void initializeFontMetrics ( ) { \nif ( ! fontMetricsInitialized ) { \nFontMetrics fontMetrics = getFontMetrics ( getFont ( ) ) ; \ncharWidth = fontMetrics . charWidth ( ' ' ) ; \ncharHeight = fontMetrics . getHeight ( ) ; \ndescent = fontMetrics . getDescent ( ) ; \nfontMetricsInitialized = true ; \n} \nreturn ; \n} \n} \n"}
{"10484": "public class BaseState { \npublic void addPropertyChangeListener ( PropertyChangeListener l ) { \nif ( listeners == null ) { \nlisteners = new ArrayList ( ) ; \n} \nsynchronized ( listeners ) { \nlisteners . add ( l ) ; \n} \nreturn ; \n} \n} \n"}
{"10485": "public class BaseState { \npublic void addPropertyChangeListener ( String p , PropertyChangeListener l ) { \nif ( listeners == null ) { \nlisteners = new ArrayList ( ) ; \n} \nsynchronized ( listeners ) { \nlisteners . add ( l ) ; \n} \nreturn ; \n} \n} \n"}
{"10486": "public class BaseState { \npublic void removePropertyChangeListener ( String p , PropertyChangeListener l ) { \nif ( listeners == null ) { \nreturn ; \n} \nsynchronized ( listeners ) { \nlisteners . remove ( l ) ; \n} \nreturn ; \n} \n} \n"}
{"10487": "public class BaseState { \nprotected void firePropertyChange ( PropertyChangeEvent evt ) { \nfinal PropertyChangeEvent finalEvent = evt ; \nIterator it ; \nif ( listeners == null ) { \nreturn ; \n} \nsynchronized ( listeners ) { \nit = listeners . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nfinal PropertyChangeListener l = ( PropertyChangeListener ) it . next ( ) ; \nRunnable r = new Runnable ( ) { \npublic void run ( ) { \nl . propertyChange ( finalEvent ) ; \nreturn ; \n} \n} \n; \nSwingUtilities . invokeLater ( r ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10489": "public class FaderImpl { \npublic void doFade ( ColorDelta target , String groupName ) { \nFadeState fadeState = timers . get ( groupName ) ; \nIterator < Color > interpolator = new ColorInterpolator ( startColor , endColor , 8 ) . iterator ( ) ; \nif ( fadeState == null ) { \nTimer timer = new Timer ( 20 , this ) ; \nfadeState = new FadeState ( timer , target , interpolator ) ; \ntimers . put ( groupName , fadeState ) ; \n} \nelse { \nfadeState . timer . stop ( ) ; \nfadeState . target = target ; \nfadeState . interpolator = interpolator ; \n} \nColor firstColor = fadeState . interpolator . next ( ) ; \nfadeState . target . changeColor ( firstColor ) ; \nfadeState . timer . setActionCommand ( groupName ) ; \nfadeState . timer . setInitialDelay ( 400 ) ; \nfadeState . timer . start ( ) ; \nreturn ; \n} \n} \n"}
{"10490": "public class SwingMainWindow { \nprivate void showHorizontalBar ( ) { \nComponent bar = factory . createGripPanel ( layout . getConsoleHeightResizer ( ) , false ) ; \nframe . getContentPane ( ) . add ( bar , DesktopAppLayout . STATUS_BAR ) ; \nreturn ; \n} \n} \n"}
{"10491": "public class SwingMainWindow { \nprivate void showLeftBar ( ) { \nComponent bar = factory . createGripPanel ( layout . getLeftPaneWidthResizer ( ) , true ) ; \nframe . getContentPane ( ) . add ( bar , DesktopAppLayout . LEFT_VERTICAL_BAR ) ; \nreturn ; \n} \n} \n"}
{"10492": "public class SwingMainWindow { \nprivate void showRightBar ( ) { \nComponent bar = factory . createGripPanel ( layout . getRightPaneWidthResizer ( ) , true ) ; \nframe . getContentPane ( ) . add ( bar , DesktopAppLayout . RIGHT_VERTICAL_BAR ) ; \nreturn ; \n} \n} \n"}
{"10493": "public class JsoupMicrodataDocument { \nprivate static void sanitizeRadioControls ( FormElement form ) { \nMap < String , Element > controlsByName = new HashMap < String , Element > ( ) ; \nfor ( Element control : form . elements ( ) ) { \nif ( \"radio\" . equals ( control . attr ( \"type\" ) ) && control . hasAttr ( \"checked\" ) ) { \nString name = control . attr ( \"name\" ) ; \nif ( controlsByName . containsKey ( name ) ) { \ncontrolsByName . get ( name ) . attr ( \"checked\" , false ) ; \n} \ncontrolsByName . put ( name , control ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10494": "public class BaseUnaryCondition { \npublic void await ( T t ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( waitNanos > 0 ) { \nlong milliPause = waitNanos / 1000000 ; \nint nanoPause = ( int ) ( waitNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10496": "public class ScriptGenMojo { \npublic void execute ( ) throws MojoExecutionException , MojoFailureException { \nfor ( String commandName : commands . keySet ( ) ) { \nif ( scriptOutDirectory != null ) { \nwriteUnixScript ( commandName , scriptOutDirectory ) ; \nwriteWindowsScript ( commandName , scriptOutDirectory ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10499": "public class ResolutionInterpreter { \nprivate void printIntroduction ( ) { \nSystem . out . println ( \"| LoJiX Prolog.\" ) ; \nSystem . out . println ( \"| Copyright The Sett Ltd.\" ) ; \nSystem . out . println ( \"| Licensed under the Apache License, Version 2.0.\" ) ; \nSystem . out . println ( \"| //www.apache.org/licenses/LICENSE-2.0\" ) ; \nSystem . out . println ( ) ; \nreturn ; \n} \n} \n"}
{"10501": "public class ResolutionInterpreter { \nprivate void evaluate ( Sentence < Clause > sentence ) throws SourceCodeException { \nClause clause = sentence . getT ( ) ; \nif ( clause . isQuery ( ) ) { \nengine . endScope ( ) ; \nengine . compile ( sentence ) ; \nevaluateQuery ( ) ; \n} \nelse { \nint name = clause . getHead ( ) . getName ( ) ; \nif ( ( currentPredicateName == null ) || ( currentPredicateName != name ) ) { \nengine . endScope ( ) ; \ncurrentPredicateName = name ; \n} \naddProgramClause ( sentence ) ; \n} \nreturn ; \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \"false. \" ) ; \nreturn ; \n} \nfor ( ; \ni . hasNext ( ) ; \n) { \nSet < Variable > solution = i . next ( ) ; \nif ( solution . isEmpty ( ) ) { \nSystem . out . print ( \"true\" ) ; \n} \nelse { \nfor ( Iterator < Variable > j = solution . iterator ( ) ; \nj . hasNext ( ) ; \n) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \nSystem . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; \nif ( j . hasNext ( ) ) { \nSystem . out . println ( ) ; \n} \n} \n} \nif ( ! i . hasNext ( ) ) { \nSystem . out . println ( \".\" ) ; \nbreak ; \n} \ntry { \nint key = consoleReader . readVirtualKey ( ) ; \nif ( key == SEMICOLON ) { \nSystem . out . println ( \" ;\" ) ; \n} \nelse { \nSystem . out . println ( ) ; \nbreak ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10514": "public class ScopeHelper { \npublic void put ( String name , Object value ) { \npageContext . setAttribute ( name , value , scope ) ; \nreturn ; \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) && ( newStart <= key ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nfor ( ; \nnewStart <= end ; \nnewStart ++ ) { \nif ( data [ offset ( newStart ) ] != null ) { \nbreak ; \n} \n} \nstart = newStart ; \n} \nelse { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \nreturn ; \n} \n} \n"}
{"10516": "public class CircularArrayMap { \nprivate void expand ( int key ) { \nint newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; \nint newSpaceSize = spaceRequired ( key ) ; \nint newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; \nObject [ ] oldData = data ; \ndata = new Object [ newSize ] ; \nint offsetStart = offset ( start ) ; \nint offsetEnd = offset ( end ) ; \nif ( offsetStart < offsetEnd ) { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; \n} \nelse { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; \nSystem . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; \n} \noffset = - start ; \nlength = newSize ; \nreturn ; \n} \n} \n"}
{"10517": "public class TextGridImpl { \nprivate void internalInsert ( char character , int c , int r ) { \nmaxColumn = ( c > maxColumn ) ? c : maxColumn ; \nmaxRow = ( r > maxRow ) ? r : maxRow ; \ndata . put ( ( long ) c , ( long ) r , character ) ; \nreturn ; \n} \n} \n"}
{"10527": "public class CommandLineParser { \npublic void addTrailingPairsToProperties ( Properties properties ) { \nif ( trailingProperties != null ) { \nfor ( Object propKey : trailingProperties . keySet ( ) ) { \nString name = ( String ) propKey ; \nString value = trailingProperties . getProperty ( name ) ; \nproperties . setProperty ( name , value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10528": "public class CommandLineParser { \npublic void addOptionsToProperties ( Properties properties ) { \nif ( parsedProperties != null ) { \nfor ( Object propKey : parsedProperties . keySet ( ) ) { \nString name = ( String ) propKey ; \nString value = parsedProperties . getProperty ( name ) ; \nif ( ! name . matches ( \"^[0-9]+$\" ) ) { \nproperties . setProperty ( name , value ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10529": "public class CommandLineParser { \nprotected void addOption ( String option , String comment , String argument , boolean mandatory , String formatRegexp ) { \nboolean expectsArgs = ( ! ( ( argument == null ) || \"\" . equals ( argument ) ) ) ; \nCommandLineOption opt = new CommandLineOption ( option , expectsArgs , comment , argument , mandatory , formatRegexp ) ; \noptionMap . put ( option , opt ) ; \nreturn ; \n} \n} \n"}
{"10531": "public class CommandLineParser { \nprivate void checkArgumentFormat ( CommandLineOption optionInfo , CharSequence matchedArg ) { \nif ( optionInfo . argumentFormatRegexp != null ) { \nPattern pattern = Pattern . compile ( optionInfo . argumentFormatRegexp ) ; \nMatcher argumentMatcher = pattern . matcher ( matchedArg ) ; \nif ( ! argumentMatcher . matches ( ) ) { \nparsingErrors . add ( \"The argument to option \" + optionInfo . option + \" does not meet its required format.\\n\" ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10535": "public class PTStemmer { \npublic void setStemmer ( SelectedTag value ) { \nif ( value . getTags ( ) == TAGS_STEMMERS ) { \nm_Stemmer = value . getSelectedTag ( ) . getID ( ) ; \ninvalidate ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10538": "public class PTStemmer { \npublic static void main ( String [ ] args ) { \ntry { \nStemming . useStemmer ( new PTStemmer ( ) , args ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10540": "public class WAMResolvingJavaMachine { \npublic void reset ( ) { \ndata = ByteBuffer . allocateDirect ( TOP << 2 ) . order ( ByteOrder . LITTLE_ENDIAN ) . asIntBuffer ( ) ; \ncodeBuffer = ByteBuffer . allocateDirect ( CODE_SIZE ) ; \ncodeBuffer . order ( ByteOrder . LITTLE_ENDIAN ) ; \nhp = HEAP_BASE ; \nhbp = HEAP_BASE ; \nsp = HEAP_BASE ; \nep = 0 ; \nbp = 0 ; \nb0 = 0 ; \ntrp = TRAIL_BASE ; \nup = TOP ; \nwriteMode = false ; \nip = 0 ; \nderefTag = 0 ; \nderefVal = 0 ; \nsuspended = false ; \nsuper . reset ( ) ; \nsetInternalCodeAddress ( internFunctorName ( \"call\" , 1 ) , CALL_1_ID ) ; \nsetInternalCodeAddress ( internFunctorName ( \"execute\" , 1 ) , EXECUTE_1_ID ) ; \nif ( monitor != null ) { \nmonitor . onReset ( this ) ; \n} \nreturn ; \n} \n} \n"}
{"10546": "public class WAMResolvingJavaMachine { \nprivate void trail ( int addr ) { \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { \ndata . put ( trp , addr ) ; \ntrp ++ ; \n} \nreturn ; \n} \n} \n"}
{"10547": "public class WAMResolvingJavaMachine { \nprivate void unwindTrail ( int a1 , int a2 ) { \nfor ( int addr = a1 ; \naddr < a2 ; \naddr ++ ) { \nint tmp = data . get ( addr ) ; \ndata . put ( tmp , refTo ( tmp ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nint i ; \nif ( bp == 0 ) { \ni = TRAIL_BASE ; \n} \nelse { \ni = data . get ( bp + data . get ( bp ) + 5 ) ; \n} \nwhile ( i < trp ) { \nint addr = data . get ( i ) ; \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { \ni ++ ; \n} \nelse { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp -- ; \n} \n} \nreturn ; \n} \n} \n"}
{"10563": "public class WrapperQueue { \nprivate void requeue ( E element ) { \nRequeueElementWrapper < E > record = new RequeueElementWrapper < E > ( element ) ; \nrequeue . add ( record ) ; \nrequeuedElementMap . put ( element , record ) ; \nreturn ; \n} \n} \n"}
{"10565": "public class WrapperQueue { \nprivate void incrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) { \ncount . incrementAndGet ( ) ; \n} \nif ( sizeable && ( record instanceof Sizeable ) ) { \ndataSize . addAndGet ( ( ( Sizeable ) record ) . sizeof ( ) ) ; \n} \nelse if ( sizeable ) { \ndataSize . incrementAndGet ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10566": "public class WrapperQueue { \nprivate void decrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) { \ncount . decrementAndGet ( ) ; \n} \nif ( sizeable && ( record instanceof Sizeable ) ) { \nlong recordSize = - ( ( Sizeable ) record ) . sizeof ( ) ; \nlong oldSize = dataSize . getAndAdd ( recordSize ) ; \nlong newSize = oldSize + recordSize ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \nelse if ( sizeable ) { \nlong oldSize = dataSize . getAndDecrement ( ) ; \nlong newSize = oldSize - 1 ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \nreturn ; \n} \n} \n"}
{"10567": "public class WrapperQueue { \nprivate void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { \nif ( signalable != null ) { \nif ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) { \nsignalable . signalAll ( ) ; \n} \nelse if ( ( oldSize >= highWaterSizeThreshold ) && ( newSize < highWaterSizeThreshold ) ) { \nsignalable . signal ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10572": "public class Sizeof { \nprivate static void runGCTillStable ( ) { \nlong usedMem1 = usedMemory ( ) ; \nlong usedMem2 = Long . MAX_VALUE ; \nfor ( int i = 0 ; \n( usedMem1 < usedMem2 ) && ( i < 500 ) ; \ni ++ ) { \nRUNTIME . runFinalization ( ) ; \nRUNTIME . gc ( ) ; \nThread . currentThread ( ) . yield ( ) ; \nusedMem2 = usedMem1 ; \nusedMem1 = usedMemory ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10576": "public class TextTableImpl { \npublic void setMaxRowHeight ( int row , int height ) { \nInteger previousValue = maxRowSizes . get ( row ) ; \nif ( previousValue == null ) { \nmaxRowSizes . put ( row , height ) ; \n} \nelse if ( previousValue < height ) { \nmaxRowSizes . put ( row , height ) ; \n} \nreturn ; \n} \n} \n"}
{"10577": "public class TextTableImpl { \nprivate void updateMaxColumnWidth ( int column , int width ) { \nInteger previousValue = maxColumnSizes . get ( column ) ; \nif ( previousValue == null ) { \nmaxColumnSizes . put ( column , width ) ; \n} \nelse if ( previousValue < width ) { \nmaxColumnSizes . put ( column , width ) ; \n} \nreturn ; \n} \n} \n"}
{"10581": "public class PreCompiler { \nprivate void substituteBuiltIns ( Term clause ) { \nTermWalker walk = TermWalkers . positionalWalker ( new BuiltInTransformVisitor ( interner , symbolTable , null , builtInTransform ) ) ; \nwalk . walk ( clause ) ; \nreturn ; \n} \n} \n"}
{"10582": "public class PreCompiler { \nprivate void initialiseSymbolTable ( Term clause ) { \nSymbolKeyTraverser symbolKeyTraverser = new SymbolKeyTraverser ( interner , symbolTable , null ) ; \nsymbolKeyTraverser . setContextChangeVisitor ( symbolKeyTraverser ) ; \nTermWalker symWalker = new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , symbolKeyTraverser , symbolKeyTraverser ) ; \nsymWalker . walk ( clause ) ; \nreturn ; \n} \n} \n"}
{"10583": "public class PreCompiler { \nprivate void topLevelCheck ( Term clause ) { \nTermWalker walk = TermWalkers . positionalWalker ( new TopLevelCheckVisitor ( interner , symbolTable , null ) ) ; \nwalk . walk ( clause ) ; \nreturn ; \n} \n} \n"}
{"10586": "public class StartStopLifecycleBase { \npublic void running ( ) { \ntry { \nstateLock . writeLock ( ) . lock ( ) ; \nif ( state == State . Initial ) { \nstate = State . Running ; \nstateChange . signalAll ( ) ; \n} \n} \nfinally { \nstateLock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10587": "public class StartStopLifecycleBase { \npublic void terminating ( ) { \ntry { \nstateLock . writeLock ( ) . lock ( ) ; \nif ( state == State . Running ) { \nstate = State . Shutdown ; \nstateChange . signalAll ( ) ; \n} \n} \nfinally { \nstateLock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10588": "public class StartStopLifecycleBase { \npublic void terminated ( ) { \ntry { \nstateLock . writeLock ( ) . lock ( ) ; \nif ( ( state == State . Shutdown ) || ( state == State . Running ) ) { \nstate = State . Terminated ; \nstateChange . signalAll ( ) ; \n} \n} \nfinally { \nstateLock . writeLock ( ) . unlock ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10591": "public class FibonacciHeap { \nprivate void updateMinimum ( Node node ) { \nif ( entryComparator != null ) { \nif ( entryComparator . compare ( node . element , minNode . element ) < 0 ) { \nminNode = node ; \n} \n} \nelse { \nif ( ( ( Comparable ) node . element ) . compareTo ( minNode . element ) < 0 ) { \nminNode = node ; \n} \n} \nreturn ; \n} \n} \n"}
{"10593": "public class FibonacciHeap { \nprivate void insertNodes ( Node node , Node newNode ) { \nNode oldNodeNext = newNode . next ; \nnewNode . next . prev = node ; \nnewNode . next = node . next ; \nnode . next . prev = newNode ; \nnode . next = oldNodeNext ; \nreturn ; \n} \n} \n"}
{"10594": "public class TimeoutMap { \npublic void restart ( ) { \nsweepThreadKillFlag = false ; \ncacheSweepThread = new Thread ( ) { \npublic void run ( ) { \nsweep ( ) ; \nreturn ; \n} \n} \n; \ncacheSweepThread . setPriority ( Thread . MIN_PRIORITY ) ; \ncacheSweepThread . start ( ) ; \nreturn ; \n} \n} \n"}
{"10597": "public class Searches { \nprivate static < T > void findAll ( Collection < T > result , SearchMethod < T > method ) { \nfor ( Iterator < T > i = allSolutions ( method ) ; \ni . hasNext ( ) ; \n) { \nT nextSoltn = i . next ( ) ; \nresult . add ( nextSoltn ) ; \n} \nreturn ; \n} \n} \n"}
{"10599": "public class BeanMemento { \npublic static void restoreValues ( Object ob , Map < String , Object > values ) throws NoSuchFieldException { \nClass obClass = ob . getClass ( ) ; \nfor ( String propName : values . keySet ( ) ) { \nObject nextValue = values . get ( propName ) ; \nObject paramValue ; \nClass paramType ; \nif ( nextValue == null ) { \nparamValue = null ; \nparamType = null ; \n} \nelse if ( nextValue instanceof TypeConverter . MultiTypeData ) { \nTypeConverter . MultiTypeData multiValue = ( TypeConverter . MultiTypeData ) nextValue ; \nSet < Class > setterTypes = ReflectionUtils . findMatchingSetters ( ob . getClass ( ) , propName ) ; \nparamType = TypeConverter . bestMatchingConversion ( multiValue , setterTypes ) ; \nparamValue = TypeConverter . convert ( multiValue , paramType ) ; \n} \nelse { \nparamValue = nextValue ; \nparamType = nextValue . getClass ( ) ; \n} \nMethod setterMethod ; \ntry { \nString upperPropertyName = Character . toUpperCase ( propName . charAt ( 0 ) ) + propName . substring ( 1 ) ; \nsetterMethod = obClass . getMethod ( \"set\" + upperPropertyName , paramType ) ; \nObject [ ] params = new Object [ ] { \nparamValue } \n; \nsetterMethod . invoke ( ob , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \n} \ncatch ( IllegalAccessException e ) { \n} \ncatch ( InvocationTargetException e ) { \n} \n} \nreturn ; \n} \n} \n"}
{"10601": "public class BeanMemento { \npublic void put ( Class cls , String property , TypeConverter . MultiTypeData value ) { \nvalues . put ( property , value ) ; \nreturn ; \n} \n} \n"}
{"10602": "public class BeanMemento { \npublic void put ( Class cls , String property , Object value ) { \nvalues . put ( property , value ) ; \nreturn ; \n} \n} \n"}
{"10603": "public class BeanMemento { \nprivate void capture ( boolean ignoreNull ) { \nClass cls = ob . getClass ( ) ; \nMethod [ ] methods = cls . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propName = Character . toLowerCase ( methodName . charAt ( 3 ) ) + methodName . substring ( 4 ) ; \ntry { \nObject [ ] params = new Object [ ] { \n} \n; \nObject value = nextMethod . invoke ( ob , params ) ; \nif ( ! ignoreNull || ( value != null ) ) { \nvalues . put ( propName , value ) ; \n} \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10624": "public class WAMInstruction { \npublic void emmitCode ( ByteBuffer codeBuffer , WAMMachine machine ) throws LinkageException { \nmnemonic . emmitCode ( this , codeBuffer , machine ) ; \nreturn ; \n} \n} \n"}
{"10625": "public class JavaType { \nprivate void setBasicType ( Class c ) { \nif ( Boolean . class . equals ( c ) ) { \ntype = BasicTypes . BOOLEAN ; \n} \nelse if ( Character . class . equals ( c ) ) { \ntype = BasicTypes . CHARACTER ; \n} \nelse if ( Byte . class . equals ( c ) ) { \ntype = BasicTypes . BYTE ; \n} \nelse if ( Short . class . equals ( c ) ) { \ntype = BasicTypes . SHORT ; \n} \nelse if ( Integer . class . equals ( c ) ) { \ntype = BasicTypes . INTEGER ; \n} \nelse if ( Long . class . equals ( c ) ) { \ntype = BasicTypes . LONG ; \n} \nelse if ( Float . class . equals ( c ) ) { \ntype = BasicTypes . FLOAT ; \n} \nelse if ( Double . class . equals ( c ) ) { \ntype = BasicTypes . DOUBLE ; \n} \nelse { \ntype = BasicTypes . OTHER ; \n} \nreturn ; \n} \n} \n"}
{"10626": "public class ResolutionEngine { \npublic void consultInputStream ( InputStream stream ) throws SourceCodeException { \nSource < Token > tokenSource = TokenSource . getTokenSourceForInputStream ( stream ) ; \ngetParser ( ) . setTokenSource ( tokenSource ) ; \nwhile ( true ) { \nSentence < S > sentence = getParser ( ) . parse ( ) ; \nif ( sentence == null ) { \nbreak ; \n} \ngetCompiler ( ) . compile ( sentence ) ; \n} \nreturn ; \n} \n} \n"}
{"10629": "public class SocketReadThread { \npublic void run ( ) { \ntry { \nreadStream ( ) ; \n} \ncatch ( EOFException eof ) { \n} \ncatch ( SocketException se ) { \nif ( ! shutdown ) { \ncomponent . getManager ( ) . getLog ( ) . error ( se ) ; \ncomponent . connectionLost ( ) ; \n} \n} \ncatch ( XmlPullParserException ie ) { \ncomponent . getManager ( ) . getLog ( ) . error ( ie ) ; \n} \ncatch ( Exception e ) { \ncomponent . getManager ( ) . getLog ( ) . warn ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"10630": "public class SocketReadThread { \nprivate void readStream ( ) throws Exception { \nwhile ( ! shutdown ) { \nElement doc = reader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nreturn ; \n} \nPacket packet ; \nString tag = doc . getName ( ) ; \nif ( \"message\" . equals ( tag ) ) { \npacket = new Message ( doc ) ; \n} \nelse if ( \"presence\" . equals ( tag ) ) { \npacket = new Presence ( doc ) ; \n} \nelse if ( \"iq\" . equals ( tag ) ) { \npacket = getIQ ( doc ) ; \n} \nelse { \nthrow new XmlPullParserException ( \"Unknown packet type was read: \" + tag ) ; \n} \ncomponent . processPacket ( packet ) ; \n} \nreturn ; \n} \n} \n"}
{"10633": "public class Player { \n@ SuppressWarnings ( \"unused\" ) public void trackInfoUpdate ( Playlist playlist , TrackInfo info ) { \nthis . playlist = playlist ; \nupdatePlayInfo ( info ) ; \nreturn ; \n} \n} \n"}
{"10634": "public class Player { \n@ SuppressWarnings ( \"unused\" ) public void updatePlayInfo ( Playlist playlist , Progress progress , Volume volume ) { \nif ( playlist != null ) this . playlist = playlist ; \nif ( progress != null ) this . progress = progress ; \nif ( volume != null ) this . volume = volume ; \nupdatePlayInfo ( playlist , progress , null , volume ) ; \nreturn ; \n} \n} \n"}
{"10635": "public class Player { \n@ Override public void renderFinalOutput ( List < T > data , EventModel eventModel ) { \nif ( StartMusicRequest . verify ( eventModel , capabilities , this , activators ) ) { \nif ( isOutputRunning ( ) ) { \nplayerError ( PlayerError . ERROR_ALREADY_PLAYING , eventModel . getSource ( ) ) ; \n} \nelse { \nhandleEventRequest ( eventModel ) ; \n} \n} \nelse if ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( MusicUsageResource . ID ) ) ) { \nif ( isOutputRunning ( ) ) { \neventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . forEach ( resourceModel -> playerError ( PlayerError . ERROR_ALREADY_PLAYING , resourceModel . getProvider ( ) ) ) ; \n} \nelse { \nhandleResourceRequest ( eventModel ) ; \n} \n} \nelse { \nhandleCommands ( eventModel ) ; \n} \nreturn ; \n} \n} \n"}
{"10636": "public class Player { \nprivate void handleResourceRequest ( EventModel eventModel ) { \nif ( MusicUsageResource . isPermanent ( eventModel ) ) { \nResourceModel resourceModel = eventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . stream ( ) . filter ( MusicUsageResource :: isPermanent ) . findAny ( ) . orElse ( null ) ; \nFunction < Identification , Optional < StartMusicRequest > > getStartMusicRequest = own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own ) ; \ngetStartMusicRequest = TrackInfoResource . getTrackInfo ( eventModel ) . map ( trackInfo -> ( Function < Identification , Optional < StartMusicRequest > > ) own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own , trackInfo ) ) . orElse ( getStartMusicRequest ) ; \ngetStartMusicRequest = PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> ( Function < Identification , Optional < StartMusicRequest > > ) own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own , playlist ) ) . orElse ( getStartMusicRequest ) ; \ngetStartMusicRequest = getStartMusicRequest . andThen ( VolumeResource . getVolume ( eventModel ) . flatMap ( volume -> IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . map ( identification -> new VolumeResource ( identification , volume ) ) ) . map ( resource -> ( Function < Optional < StartMusicRequest > , Optional < StartMusicRequest > > ) opt -> opt . map ( event -> ( StartMusicRequest ) event . addResource ( resource ) ) ) . orElse ( Function . identity ( ) ) :: apply ) ; \nIdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( getStartMusicRequest :: apply ) . ifPresent ( this :: fire ) ; \n} \nelse { \nplay ( eventModel ) ; \nif ( ! runsInPlay ) { \nblockRequest = lock . newCondition ( ) ; \nlock . lock ( ) ; \ntry { \nblockRequest . await ( 10 , TimeUnit . MINUTES ) ; \n} \ncatch ( InterruptedException e ) { \ndebug ( \"interrupted\" , e ) ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10637": "public class Player { \nprivate void handleEventRequest ( EventModel eventModel ) { \nplayingThread = submit ( ( Runnable ) ( ) -> { \nif ( runsInPlay ) { \nisRunning = false ; \n} \nelse { \nisRunning = true ; \n} \nisPlaying = true ; \nfireStartMusicRequest ( eventModel ) ; \n} \n) . thenRun ( ( ) -> play ( eventModel ) ) . thenRun ( ( ) -> { \nif ( runsInPlay ) { \nisRunning = false ; \nisPlaying = false ; \nendedSound ( ) ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"10638": "public class Player { \nprotected void fireStartMusicRequest ( EventModel eventModel ) { \nOptional < Playlist > playlist = PlaylistResource . getPlaylist ( eventModel ) ; \nOptional < Progress > progress = ProgressResource . getProgress ( eventModel ) ; \nOptional < TrackInfo > trackInfo = TrackInfoResource . getTrackInfo ( eventModel ) ; \nOptional < Volume > volume = VolumeResource . getVolume ( eventModel ) ; \nstartedSound ( playlist . orElse ( null ) , progress . orElse ( null ) , trackInfo . orElse ( null ) , volume . orElse ( null ) , isUsingJava ) ; \nreturn ; \n} \n} \n"}
{"10639": "public class PacketReader { \nprotected void init ( ) { \ndone = false ; \nconnectionID = null ; \nreaderThread = new Thread ( ) { \npublic void run ( ) { \nparsePackets ( this ) ; \nreturn ; \n} \n} \n; \nreaderThread . setName ( \"Smack Packet Reader (\" + connection . connectionCounterValue + \")\" ) ; \nreaderThread . setDaemon ( true ) ; \nlistenerExecutor = Executors . newSingleThreadExecutor ( new ThreadFactory ( ) { \npublic Thread newThread ( Runnable runnable ) { \nThread thread = new Thread ( runnable , \"Smack Listener Processor (\" + connection . connectionCounterValue + \")\" ) ; \nthread . setDaemon ( true ) ; \nreturn thread ; \n} \n} \n) ; \nresetParser ( ) ; \nreturn ; \n} \n} \n"}
{"10640": "public class PacketReader { \nsynchronized public void startup ( ) throws XMPPException { \nfinal List < Exception > errors = new LinkedList < Exception > ( ) ; \nAbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { \n@ Override public void connectionClosedOnError ( Exception e ) { \nerrors . add ( e ) ; \nreturn ; \n} \n} \n; \nconnection . addConnectionListener ( connectionErrorListener ) ; \nreaderThread . start ( ) ; \ntry { \nint waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; \nwait ( 3 * waitTime ) ; \n} \ncatch ( InterruptedException ie ) { \n} \nconnection . removeConnectionListener ( connectionErrorListener ) ; \nif ( connectionID == null ) { \nthrow new XMPPException ( \"Connection failed. No response from server.\" ) ; \n} \nelse if ( ! errors . isEmpty ( ) ) { \nthrow new XMPPException ( errors . iterator ( ) . next ( ) ) ; \n} \nelse { \nconnection . connectionID = connectionID ; \n} \nreturn ; \n} \n} \n"}
{"10641": "public class PacketReader { \npublic void shutdown ( ) { \nif ( ! done ) { \nfor ( ConnectionListener listener : connection . getConnectionListeners ( ) ) { \ntry { \nlistener . connectionClosed ( ) ; \n} \ncatch ( Exception e ) { \nLOGGER . log ( Level . ERROR , \"Error in listener while closing connection\" , e ) ; \n} \n} \n} \ndone = true ; \nlistenerExecutor . shutdown ( ) ; \nreturn ; \n} \n} \n"}
{"10642": "public class PacketReader { \nprivate void resetParser ( ) { \ntry { \ninnerReader = new XPPPacketReader ( ) ; \ninnerReader . setXPPFactory ( XmlPullParserFactory . newInstance ( ) ) ; \ninnerReader . getXPPParser ( ) . setInput ( connection . reader ) ; \nreset = true ; \n} \ncatch ( Exception xppe ) { \nLOGGER . log ( Level . WARN , \"Error while resetting parser\" , xppe ) ; \n} \nreturn ; \n} \n} \n"}
{"10643": "public class PacketReader { \nprivate void parsePackets ( Thread thread ) { \ntry { \nwhile ( ! done ) { \nif ( reset ) { \nstartStream ( ) ; \nLOGGER . debug ( \"Started xmlstream...\" ) ; \nreset = false ; \ncontinue ; \n} \nElement doc = innerReader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nconnection . disconnect ( ) ; \nLOGGER . debug ( \"End of xmlstream.\" ) ; \ncontinue ; \n} \nPacket packet = null ; \nLOGGER . debug ( \"Processing packet \" + doc . asXML ( ) ) ; \npacket = parseFromPlugins ( doc , packet ) ; \nif ( packet == null ) { \npacket = parseFromCore ( doc ) ; \n} \nif ( packet != null ) { \nprocessPacket ( packet ) ; \n} \n} \n} \ncatch ( Exception e ) { \nif ( ! done && ! connection . isSocketClosed ( ) ) { \nconnection . notifyConnectionError ( e ) ; \nif ( ! connection . isConnected ( ) ) { \nreleaseConnectionIDLock ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10644": "public class PacketReader { \nprivate void processPacket ( Packet packet ) { \nif ( packet == null ) { \nreturn ; \n} \nfor ( PacketCollector collector : connection . getPacketCollectors ( ) ) { \ncollector . processPacket ( packet ) ; \n} \nlistenerExecutor . submit ( new ListenerNotification ( packet ) ) ; \nreturn ; \n} \n} \n"}
{"10645": "public class AbstractApplicationOption { \nprotected final void setCliOption ( Option option ) { \nif ( option != null ) { \nthis . cliOption = option ; \n} \nif ( this . cliOption . getDescription ( ) != null ) { \nthis . descr = this . cliOption . getDescription ( ) ; \n} \nelse { \nthis . cliOption . setDescription ( this . descr ) ; \n} \nreturn ; \n} \n} \n"}
{"10647": "public class InternalContent { \nvoid internalize ( ContentManagerImpl contentManager , boolean readOnly ) { \nthis . contentManager = contentManager ; \nupdated = false ; \nnewcontent = false ; \nthis . readOnly = readOnly ; \nreturn ; \n} \n} \n"}
{"10648": "public class InternalContent { \npublic void reset ( Map < String , Object > updatedMap ) { \nif ( ! readOnly ) { \nthis . content = ImmutableMap . copyOf ( updatedMap ) ; \nupdatedContent . clear ( ) ; \nupdated = false ; \nLOGGER . debug ( \"Reset to {} \" , updatedMap ) ; \n} \nreturn ; \n} \n} \n"}
{"10649": "public class InternalContent { \npublic void setProperty ( String key , Object value ) { \nif ( readOnly ) { \nreturn ; \n} \nif ( value == null ) { \nthrow new IllegalArgumentException ( \"value must not be null\" ) ; \n} \nObject o = content . get ( key ) ; \nif ( ! value . equals ( o ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \nelse if ( updatedContent . containsKey ( key ) && ! value . equals ( updatedContent . get ( key ) ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \nreturn ; \n} \n} \n"}
{"10650": "public class OrFilter { \npublic void addFilter ( PacketFilter filter ) { \nif ( filter == null ) { \nthrow new IllegalArgumentException ( \"Parameter cannot be null.\" ) ; \n} \nif ( size == filters . length ) { \nPacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; \nfor ( int i = 0 ; \ni < filters . length ; \ni ++ ) { \nnewFilters [ i ] = filters [ i ] ; \n} \nfilters = newFilters ; \n} \nfilters [ size ] = filter ; \nsize ++ ; \nreturn ; \n} \n} \n"}
{"10651": "public class ModificationRequest { \npublic void processRequest ( HttpServletRequest request ) throws IOException , FileUploadException , StorageClientException , AccessDeniedException { \nboolean debug = LOGGER . isDebugEnabled ( ) ; \nif ( ServletFileUpload . isMultipartContent ( request ) ) { \nif ( debug ) { \nLOGGER . debug ( \"Multipart POST \" ) ; \n} \nfeedback . add ( \"Multipart Upload\" ) ; \nServletFileUpload upload = new ServletFileUpload ( ) ; \nFileItemIterator iterator = upload . getItemIterator ( request ) ; \nwhile ( iterator . hasNext ( ) ) { \nFileItemStream item = iterator . next ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Got Item {}\" , item ) ; \n} \nString name = item . getFieldName ( ) ; \nInputStream stream = item . openStream ( ) ; \nif ( item . isFormField ( ) ) { \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \nelse { \nif ( streamProcessor != null ) { \nfeedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; \n} \n} \n} \nif ( debug ) { \nLOGGER . debug ( \"No More items \" ) ; \n} \n} \nelse { \nif ( debug ) { \nLOGGER . debug ( \"Trad Post \" ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Map < String , String [ ] > parameters = request . getParameterMap ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Traditional POST {} \" , parameters ) ; \n} \nSet < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; \nfor ( Entry < String , String [ ] > param : entries ) { \nString name = ( String ) param . getKey ( ) ; \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10652": "public class ModificationRequest { \npublic void resetProperties ( ) { \nfor ( Entry < ParameterType , Map < String , Object > > e : stores . entrySet ( ) ) { \ne . getValue ( ) . clear ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10653": "public class PacketWriter { \nprotected void init ( ) { \nthis . writer = connection . writer ; \ndone = false ; \nwriterThread = new Thread ( ) { \npublic void run ( ) { \nwritePackets ( this ) ; \nreturn ; \n} \n} \n; \nwriterThread . setName ( \"Smack Packet Writer (\" + connection . connectionCounterValue + \")\" ) ; \nwriterThread . setDaemon ( true ) ; \nreturn ; \n} \n} \n"}
{"10654": "public class PacketWriter { \npublic void sendPacket ( Packet packet ) { \nif ( ! done ) { \nconnection . firePacketInterceptors ( packet ) ; \ntry { \nqueue . put ( packet ) ; \n} \ncatch ( InterruptedException ie ) { \nLOGGER . log ( Level . ERROR , \"Failed to queue packet to send to server: \" + packet . toString ( ) , ie ) ; \nreturn ; \n} \nsynchronized ( queue ) { \nqueue . notifyAll ( ) ; \n} \nconnection . firePacketSendingListeners ( packet ) ; \n} \nreturn ; \n} \n} \n"}
{"10656": "public class PacketWriter { \nvoid openStream ( ) throws IOException { \nStringBuilder stream = new StringBuilder ( ) ; \nstream . append ( \"<stream:stream\" ) ; \nstream . append ( \" to=\\\"\" ) . append ( connection . getServiceName ( ) ) . append ( \"\\\"\" ) ; \nstream . append ( \" xmlns=\\\"jabber:client\\\"\" ) ; \nstream . append ( \" xmlns:stream=\\\"http://etherx.jabber.org/streams\\\"\" ) ; \nstream . append ( \" version=\\\"1.0\\\">\" ) ; \nwriter . write ( stream . toString ( ) ) ; \nwriter . flush ( ) ; \nreturn ; \n} \n} \n"}
{"10660": "public class TaskEngine { \npublic void shutdown ( ) { \nif ( executor != null ) { \nexecutor . shutdownNow ( ) ; \nexecutor = null ; \n} \nif ( timer != null ) { \ntimer . cancel ( ) ; \ntimer = null ; \n} \nreturn ; \n} \n} \n"}
{"10662": "public class Files { \npublic static void cleanDirectByteBuffer ( final ByteBuffer byteBuffer ) { \nif ( byteBuffer == null ) return ; \nif ( ! byteBuffer . isDirect ( ) ) throw new IllegalArgumentException ( \"byteBuffer isn't direct!\" ) ; \nAccessController . doPrivileged ( new PrivilegedAction < Void > ( ) { \npublic Void run ( ) { \ntry { \nMethod cleanerMethod = byteBuffer . getClass ( ) . getMethod ( \"cleaner\" ) ; \ncleanerMethod . setAccessible ( true ) ; \nObject cleaner = cleanerMethod . invoke ( byteBuffer ) ; \nMethod cleanMethod = cleaner . getClass ( ) . getMethod ( \"clean\" ) ; \ncleanMethod . setAccessible ( true ) ; \ncleanMethod . invoke ( cleaner ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nthrow new RuntimeException ( \"Could not clean MappedByteBuffer -- File may still be locked!\" ) ; \n} \nreturn null ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"10667": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) void resize ( int newCapacity ) { \nEntry < K , V > [ ] oldTable = table ; \nint oldCapacity = oldTable . length ; \nif ( oldCapacity == MAXIMUM_CAPACITY ) { \nthreshold = Integer . MAX_VALUE ; \nreturn ; \n} \nEntry < K , V > [ ] newTable = new Entry [ newCapacity ] ; \ntransfer ( newTable ) ; \ntable = newTable ; \nthreshold = ( int ) ( newCapacity * loadFactor ) ; \nreturn ; \n} \n} \n"}
{"10668": "public class TransactionalHashMap { \n@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { \nint numKeysToBeAdded = m . size ( ) ; \nif ( numKeysToBeAdded == 0 ) return ; \nif ( numKeysToBeAdded > threshold ) { \nint targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; \nif ( targetCapacity > MAXIMUM_CAPACITY ) targetCapacity = MAXIMUM_CAPACITY ; \nint newCapacity = table . length ; \nwhile ( newCapacity < targetCapacity ) newCapacity <<= 1 ; \nif ( newCapacity > table . length ) resize ( newCapacity ) ; \n} \nfor ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nMap . Entry < ? extends K , ? extends V > e = i . next ( ) ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10672": "public class TransactionalHashMap { \nvoid addEntry ( int hash , K key , V value , int bucketIndex ) { \ntable [ bucketIndex ] = new Entry < K , V > ( hash , key , value , table [ bucketIndex ] ) ; \nif ( ! auto_commit ) table [ bucketIndex ] . setStatus ( Entry . ADDED , getCurrentThreadId ( ) ) ; \nif ( size ++ >= threshold ) resize ( 2 * table . length ) ; \nreturn ; \n} \n} \n"}
{"10679": "public class CommandHandler { \npublic void setTrackSelectorController ( Consumer < TrackInfo > controller ) { \nif ( controller == null ) return ; \nselectTrack = controller ; \ncapabilities . setAbleToSelectTrack ( true ) ; \nreturn ; \n} \n} \n"}
{"10680": "public class CommandHandler { \npublic void setJumpProgressController ( Consumer < Progress > controller ) { \nif ( controller == null ) return ; \njumpProgress = controller ; \ncapabilities . setAbleToJump ( true ) ; \nreturn ; \n} \n} \n"}
{"10681": "public class CommandHandler { \npublic void setPlaybackChangeableController ( Consumer < String > controller ) { \nif ( controller == null ) return ; \nchangePlayback = controller ; \ncapabilities . setPlaybackChangeable ( true ) ; \nreturn ; \n} \n} \n"}
{"10682": "public class CommandHandler { \npublic void setVolumeChangeableController ( Consumer < Volume > controller ) { \nif ( controller == null ) return ; \nchangeVolume = controller ; \ncapabilities . setChangeVolume ( true ) ; \nreturn ; \n} \n} \n"}
{"10683": "public class CommandHandler { \npublic void broadcastAvailablePlaylists ( Supplier < List < String > > availablePlaylist , Function < String , Playlist > playlistForNameFunction ) { \nif ( availablePlaylist == null || playlistForNameFunction == null ) return ; \nthis . availablePlaylist = availablePlaylist ; \nthis . playlistForNameFunction = playlistForNameFunction ; \ncapabilities . setBroadcasting ( true ) ; \nreturn ; \n} \n} \n"}
{"10684": "public class CommandHandler { \npublic void handleCommandResources ( EventModel eventModel ) { \nList < ResourceModel < String > > resourceModels = eventModel . getListResourceContainer ( ) . provideResource ( CommandResource . ResourceID ) . stream ( ) . filter ( resourceModel -> resourceModel . getResource ( ) instanceof String ) . map ( resourceModel -> { \ntry { \nreturn ( ResourceModel < String > ) resourceModel ; \n} \ncatch ( ClassCastException e ) { \nreturn null ; \n} \n} \n) . filter ( Objects :: nonNull ) . collect ( Collectors . toList ( ) ) ; \nfor ( ResourceModel < String > resourceModel : resourceModels ) { \nif ( ! CommandResource . verifyCommand ( resourceModel . getResource ( ) ) ) continue ; \nif ( ! CommandResource . verifyCapabilities ( resourceModel . getResource ( ) , capabilities ) ) { \nmusicHelper . playerError ( PlayerError . ERROR_NOT_ABLE + \"command: \" + resourceModel . getResource ( ) , resourceModel . getProvider ( ) ) ; \ncontinue ; \n} \nswitch ( resourceModel . getResource ( ) ) { \ncase CommandResource . PLAY : if ( ! musicProvider . isPlaying ( ) ) playPause . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . PAUSE : if ( musicProvider . isPlaying ( ) ) playPause . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . SELECT_TRACK : handleSelectTrack ( eventModel , resourceModel ) ; \nbreak ; \ncase CommandResource . NEXT : nextPrevious . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . PREVIOUS : nextPrevious . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . JUMP : handleJump ( eventModel , resourceModel ) ; \nbreak ; \ncase CommandResource . CHANGE_PLAYBACK : changePlayback . accept ( resourceModel . getResource ( ) ) ; \nbreak ; \ncase CommandResource . CHANGE_VOLUME : handleVolume ( eventModel , resourceModel ) ; \nbreak ; \ncase CommandResource . STOP : stopCallback . run ( ) ; \nbreak ; \n} \n} \nreturn ; \n} \n} \n"}
{"10685": "public class CommandHandler { \nprivate void handleVolume ( EventModel eventModel , ResourceModel < String > resourceModel ) { \nOptional < Volume > volumeResource = VolumeResource . getVolume ( eventModel ) ; \nif ( ! volumeResource . isPresent ( ) ) { \nmusicHelper . playerError ( PlayerError . ERROR_ILLEGAL + \"command: \" + resourceModel . getResource ( ) + \"missing resource\" , resourceModel . getProvider ( ) ) ; \n} \nchangeVolume . accept ( volumeResource . get ( ) ) ; \nreturn ; \n} \n} \n"}
{"10686": "public class CommandHandler { \nprivate void handleJump ( EventModel eventModel , ResourceModel < String > resourceModel ) { \nOptional < Progress > progress = ProgressResource . getProgress ( eventModel ) ; \nif ( ! progress . isPresent ( ) ) { \nmusicHelper . playerError ( PlayerError . ERROR_ILLEGAL + \"command: \" + resourceModel . getResource ( ) + \"missing resource\" , resourceModel . getProvider ( ) ) ; \n} \njumpProgress . accept ( progress . get ( ) ) ; \nreturn ; \n} \n} \n"}
{"10687": "public class CommandHandler { \nprivate void handleSelectTrack ( EventModel eventModel , ResourceModel < String > resourceModel ) { \nOptional < TrackInfo > trackInfo = TrackInfoResource . getTrackInfo ( eventModel ) ; \nif ( ! trackInfo . isPresent ( ) ) { \nmusicHelper . playerError ( PlayerError . ERROR_ILLEGAL + \"command: \" + resourceModel . getResource ( ) + \"missing resource\" , resourceModel . getProvider ( ) ) ; \n} \nselectTrack . accept ( trackInfo . get ( ) ) ; \nreturn ; \n} \n} \n"}
{"10695": "public class StorageClientUtils { \npublic static void deleteTree ( ContentManager contentManager , String path ) throws AccessDeniedException , StorageClientException { \nContent content = contentManager . get ( path ) ; \nif ( content != null ) { \nfor ( String childPath : content . listChildPaths ( ) ) { \ndeleteTree ( contentManager , childPath ) ; \n} \n} \ncontentManager . delete ( path ) ; \nreturn ; \n} \n} \n"}
{"10696": "public class AbstractDao { \n@ Override public void updateOne ( E object , String ... properties ) { \nif ( object . getId ( ) == null ) { \nthrow new RuntimeException ( \"Not a Persisted entity\" ) ; \n} \nif ( properties == null || properties . length == 0 ) { \nentityManager . merge ( object ) ; \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"Update \" + clazz . getName ( ) + \" SET \" ) ; \nMap < String , Object > cache = new HashMap < String , Object > ( ) ; \nfor ( String prop : properties ) { \ntry { \nField field = object . getClass ( ) . getDeclaredField ( prop ) ; \nfield . setAccessible ( true ) ; \nObject value = field . get ( object ) ; \nif ( value instanceof Collection ) { \nthrow new RuntimeException ( \"Collection property is not suppotred.\" ) ; \n} \ncache . put ( prop , value ) ; \nif ( cache . size ( ) > 1 ) { \nsb . append ( \" ,\" ) ; \n} \nsb . append ( prop ) ; \nsb . append ( \" = :\" ) ; \nsb . append ( prop ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( cache . size ( ) == 0 ) return ; \nsb . append ( \" WHERE id = \" + object . getId ( ) ) ; \nQuery query = entityManager . createQuery ( sb . toString ( ) ) ; \nfor ( Entry < String , Object > entry : cache . entrySet ( ) ) { \nquery . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nquery . executeUpdate ( ) ; \nreturn ; \n} \n} \n"}
{"10697": "public class KeepAliveManager { \npublic void setPingInterval ( long newPingInterval ) { \nif ( pingInterval == newPingInterval ) return ; \nif ( newPingInterval > 0 ) enableExecutorService ( ) ; \npingInterval = newPingInterval ; \nif ( pingInterval < 0 ) { \nstopPinging ( ) ; \n} \nelse { \nschedulePingServerTask ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10698": "public class KeepAliveManager { \nprivate synchronized void schedulePingServerTask ( ) { \nenableExecutorService ( ) ; \nstopPingServerTask ( ) ; \nif ( pingInterval > 0 ) { \nperiodicPingTask = periodicPingExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nPing ping = new Ping ( ) ; \nPacketFilter responseFilter = new PacketIDFilter ( ping . getID ( ) ) ; \nConnection connection = weakRefConnection . get ( ) ; \nfinal PacketCollector response = pingFailedListeners . isEmpty ( ) ? null : connection . createPacketCollector ( responseFilter ) ; \nconnection . sendPacket ( ping ) ; \nif ( response != null ) { \nperiodicPingExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nPacket result = response . nextResult ( 1 ) ; \nresponse . cancel ( ) ; \nif ( result == null ) { \nfor ( PingFailedListener listener : pingFailedListeners ) { \nlistener . pingFailed ( ) ; \n} \n} \nreturn ; \n} \n} \n, SmackConfiguration . getPacketReplyTimeout ( ) , TimeUnit . MILLISECONDS ) ; \n} \nreturn ; \n} \n} \n, getPingInterval ( ) , TimeUnit . MILLISECONDS ) ; \n} \nreturn ; \n} \n} \n"}
{"10702": "public class ExecS_CliParser { \npublic void usage ( String appName ) { \nHelpFormatter formatter = new HelpFormatter ( ) ; \nformatter . printHelp ( appName , null , this . options , null , false ) ; \nreturn ; \n} \n} \n"}
{"10704": "public class XMPPConnection { \nprivate void initConnection ( ) throws XMPPException { \nboolean isFirstInitialization = packetReader == null || packetWriter == null ; \ncompressionHandler = null ; \nserverAckdCompression = false ; \ninitReaderAndWriter ( ) ; \ntry { \nif ( isFirstInitialization ) { \npacketWriter = new PacketWriter ( this ) ; \npacketReader = new PacketReader ( this ) ; \nif ( config . isDebuggerEnabled ( ) ) { \naddPacketListener ( debugger . getReaderListener ( ) , null ) ; \nif ( debugger . getWriterListener ( ) != null ) { \naddPacketSendingListener ( debugger . getWriterListener ( ) , null ) ; \n} \n} \n} \nelse { \npacketWriter . init ( ) ; \npacketReader . init ( ) ; \n} \npacketWriter . startup ( ) ; \npacketReader . startup ( ) ; \nconnected = true ; \nif ( isFirstInitialization ) { \nfor ( ConnectionCreationListener listener : getConnectionCreationListeners ( ) ) { \nlistener . connectionCreated ( this ) ; \n} \n} \n} \ncatch ( XMPPException ex ) { \nif ( packetWriter != null ) { \ntry { \npacketWriter . shutdown ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \npacketWriter = null ; \n} \nif ( packetReader != null ) { \ntry { \npacketReader . shutdown ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \npacketReader = null ; \n} \nif ( reader != null ) { \ntry { \nreader . close ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \nreader = null ; \n} \nif ( writer != null ) { \ntry { \nwriter . close ( ) ; \n} \ncatch ( Throwable ignore ) { \n} \nwriter = null ; \n} \nif ( socket != null ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception e ) { \n} \nsocket = null ; \n} \nthis . setWasAuthenticated ( authenticated ) ; \nauthenticated = false ; \nconnected = false ; \nthrow ex ; \n} \nreturn ; \n} \n} \n"}
{"10705": "public class XMPPConnection { \nvoid startTLSReceived ( boolean required ) { \nif ( required && config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) { \nnotifyConnectionError ( new IllegalStateException ( \"TLS required by server but not allowed by connection configuration\" ) ) ; \nreturn ; \n} \nif ( config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) { \nreturn ; \n} \ntry { \nwriter . write ( \"<starttls xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\"/>\" ) ; \nwriter . flush ( ) ; \n} \ncatch ( IOException e ) { \nnotifyConnectionError ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"10707": "public class XMPPConnection { \nprivate void requestStreamCompression ( String method ) { \ntry { \nwriter . write ( \"<compress xmlns='http://jabber.org/protocol/compress'>\" ) ; \nwriter . write ( \"<method>\" + method + \"</method></compress>\" ) ; \nwriter . flush ( ) ; \n} \ncatch ( IOException e ) { \nnotifyConnectionError ( e ) ; \n} \nreturn ; \n} \n} \n"}
{"10708": "public class XMPPConnection { \nvoid startStreamCompression ( ) throws Exception { \nserverAckdCompression = true ; \ninitReaderAndWriter ( ) ; \npacketWriter . setWriter ( writer ) ; \npacketWriter . openStream ( ) ; \nsynchronized ( this ) { \nthis . notify ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10709": "public class XMPPConnection { \nsynchronized void notifyConnectionError ( Exception e ) { \nif ( ( packetReader == null || packetReader . done ) && ( packetWriter == null || packetWriter . done ) ) return ; \nif ( packetReader != null ) packetReader . done = true ; \nif ( packetWriter != null ) packetWriter . done = true ; \nshutdown ( new Presence ( Presence . Type . unavailable ) ) ; \nfor ( ConnectionListener listener : getConnectionListeners ( ) ) { \ntry { \nlistener . connectionClosedOnError ( e ) ; \n} \ncatch ( Exception e2 ) { \ne2 . printStackTrace ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10710": "public class XMPPConnection { \nprotected void notifyReconnection ( ) { \nfor ( ConnectionListener listener : getConnectionListeners ( ) ) { \ntry { \nlistener . reconnectionSuccessful ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10711": "public class SASLAuthentication { \npublic static void registerSASLMechanism ( String name , Class < ? extends SASLMechanism > mClass ) { \nimplementedMechanisms . put ( name , mClass ) ; \nreturn ; \n} \n} \n"}
{"10714": "public class NakamuraMain { \nstatic void info ( String message , Throwable t ) { \nlog ( System . out , \"*INFO*\" , message , t ) ; \nreturn ; \n} \n} \n"}
{"10715": "public class NakamuraMain { \nstatic void error ( String message , Throwable t ) { \nlog ( System . err , \"*ERROR*\" , message , t ) ; \nreturn ; \n} \n} \n"}
{"10716": "public class NakamuraMain { \nprivate static void log ( PrintStream out , String prefix , String message , Throwable t ) { \nfinal StringBuilder linePrefixBuilder = new StringBuilder ( ) ; \nsynchronized ( fmt ) { \nlinePrefixBuilder . append ( fmt . format ( new Date ( ) ) ) ; \n} \nlinePrefixBuilder . append ( prefix ) ; \nlinePrefixBuilder . append ( \" [\" ) ; \nlinePrefixBuilder . append ( Thread . currentThread ( ) . getName ( ) ) ; \nlinePrefixBuilder . append ( \"] \" ) ; \nfinal String linePrefix = linePrefixBuilder . toString ( ) ; \nout . print ( linePrefix ) ; \nout . println ( message ) ; \nif ( t != null ) { \nt . printStackTrace ( new PrintStream ( out ) { \n@ Override public void println ( String x ) { \nsynchronized ( this ) { \nprint ( linePrefix ) ; \nsuper . println ( x ) ; \nflush ( ) ; \n} \nreturn ; \n} \n} \n) ; \n} \nreturn ; \n} \n} \n"}
{"10719": "public class ObservableWriter { \nprivate void notifyListeners ( String str ) { \nWriterListener [ ] writerListeners = null ; \nsynchronized ( listeners ) { \nwriterListeners = new WriterListener [ listeners . size ( ) ] ; \nlisteners . toArray ( writerListeners ) ; \n} \nfor ( int i = 0 ; \ni < writerListeners . length ; \ni ++ ) { \nwriterListeners [ i ] . write ( str ) ; \n} \nreturn ; \n} \n} \n"}
{"10726": "public class CachingManagerImpl { \nprotected void removeCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { \nif ( sharedCache != null ) { \nfinal String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \nputToCacheInternal ( cacheKey , new CacheHolder ( null , managerId ) , false ) ; \nLOGGER . debug ( \"Marked as deleted in Cache {} \" , cacheKey ) ; \nif ( client instanceof Disposer ) { \n( ( Disposer ) client ) . registerDisposable ( new Disposable ( ) { \n@ Override public void setDisposer ( Disposer disposer ) { \nreturn ; \n} \n@ Override public void close ( ) { \nCacheHolder ch = sharedCache . get ( cacheKey ) ; \nif ( ch != null && ch . wasLockedTo ( managerId ) ) { \nsharedCache . remove ( cacheKey ) ; \nLOGGER . debug ( \"Removed deleted marker from Cache {} \" , cacheKey ) ; \n} \nreturn ; \n} \n} \n) ; \n} \n} \nclient . remove ( keySpace , columnFamily , key ) ; \nreturn ; \n} \n} \n"}
{"10727": "public class CachingManagerImpl { \nprotected void putCached ( String keySpace , String columnFamily , String key , Map < String , Object > encodedProperties , boolean probablyNew ) throws StorageClientException { \nString cacheKey = null ; \nif ( sharedCache != null ) { \ncacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \n} \nif ( sharedCache != null && ! probablyNew ) { \nCacheHolder ch = getFromCacheInternal ( cacheKey ) ; \nif ( ch != null && ch . isLocked ( this . managerId ) ) { \nLOGGER . debug ( \"Is Locked {} \" , ch ) ; \nreturn ; \n} \n} \nLOGGER . debug ( \"Saving {} {} {} {} \" , new Object [ ] { \nkeySpace , columnFamily , key , encodedProperties } \n) ; \nclient . insert ( keySpace , columnFamily , key , encodedProperties , probablyNew ) ; \nif ( sharedCache != null ) { \nsharedCache . remove ( cacheKey ) ; \n} \nreturn ; \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) { \nname = \"\" ; \n} \nelse { \nname += \".\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( int i = 0 ; \ni < dirs . length ; \ni ++ ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \nreturn ; \n} \n} \n"}
{"10730": "public class CF_Locator { \nprivate void includeJar ( File file ) { \nif ( file . isDirectory ( ) ) { \nreturn ; \n} \nURL jarURL = null ; \nJarFile jar = null ; \ntry { \njarURL = new URL ( \"jar:\" + new URL ( \"file:/\" + file . getCanonicalPath ( ) ) . toExternalForm ( ) + \"!/\" ) ; \nJarURLConnection conn = ( JarURLConnection ) jarURL . openConnection ( ) ; \njar = conn . getJarFile ( ) ; \n} \ncatch ( MalformedURLException ignore ) { \nreturn ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \nif ( jar == null ) { \nreturn ; \n} \ntry { \nthis . locationMap . put ( jarURL . toURI ( ) , \"\" ) ; \n} \ncatch ( URISyntaxException ignore ) { \n} \nfor ( Enumeration < JarEntry > e = jar . entries ( ) ; \ne . hasMoreElements ( ) ; \n) { \nJarEntry entry = e . nextElement ( ) ; \nif ( this . pkgFilter != null && entry . getName ( ) . startsWith ( this . pkgFilter ) ) { \ncontinue ; \n} \nif ( entry . isDirectory ( ) ) { \nif ( entry . getName ( ) . toUpperCase ( Locale . ENGLISH ) . equals ( \"META-INF/\" ) ) { \ncontinue ; \n} \ntry { \nthis . locationMap . put ( new URI ( jarURL . toExternalForm ( ) + entry . getName ( ) ) , CF_Utils . getPkgName ( entry ) ) ; \n} \ncatch ( URISyntaxException ignore ) { \ncontinue ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10731": "public class SmackConfiguration { \npublic static void addSaslMech ( String mech ) { \ninitialize ( ) ; \nif ( ! defaultMechs . contains ( mech ) ) { \ndefaultMechs . add ( mech ) ; \n} \nreturn ; \n} \n} \n"}
{"10732": "public class SmackConfiguration { \npublic static void addSaslMechs ( Collection < String > mechs ) { \ninitialize ( ) ; \nfor ( String mech : mechs ) { \naddSaslMech ( mech ) ; \n} \nreturn ; \n} \n} \n"}
{"10733": "public class ConsoleDebugger { \nprivate void createDebug ( ) { \nObservableReader debugReader = new ObservableReader ( reader ) ; \nreaderListener = new ReaderListener ( ) { \npublic void read ( String str ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" RCV  (\" + connection . hashCode ( ) + \"): \" + str ) ; \nreturn ; \n} \n} \n; \ndebugReader . addReaderListener ( readerListener ) ; \nObservableWriter debugWriter = new ObservableWriter ( writer ) ; \nwriterListener = new WriterListener ( ) { \npublic void write ( String str ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" SENT (\" + connection . hashCode ( ) + \"): \" + str ) ; \nreturn ; \n} \n} \n; \ndebugWriter . addWriterListener ( writerListener ) ; \nreader = debugReader ; \nwriter = debugWriter ; \nlistener = new PacketListener ( ) { \npublic void processPacket ( Packet packet ) { \nif ( printInterpreted ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" RCV PKT (\" + connection . hashCode ( ) + \"): \" + packet . toXML ( ) ) ; \n} \nreturn ; \n} \n} \n; \nconnListener = new ConnectionListener ( ) { \npublic void connectionClosed ( ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection closed (\" + connection . hashCode ( ) + \")\" ) ; \nreturn ; \n} \npublic void connectionClosedOnError ( Exception e ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection closed due to an exception (\" + connection . hashCode ( ) + \")\" ) ; \ne . printStackTrace ( ) ; \nreturn ; \n} \npublic void reconnectionFailed ( Exception e ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Reconnection failed due to an exception (\" + connection . hashCode ( ) + \")\" ) ; \ne . printStackTrace ( ) ; \nreturn ; \n} \npublic void reconnectionSuccessful ( ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection reconnected (\" + connection . hashCode ( ) + \")\" ) ; \nreturn ; \n} \npublic void reconnectingIn ( int seconds ) { \nSystem . out . println ( dateFormatter . format ( new Date ( ) ) + \" Connection (\" + connection . hashCode ( ) + \") will reconnect in \" + seconds ) ; \nreturn ; \n} \n} \n; \nreturn ; \n} \n} \n"}
{"10734": "public class ProxyClientServiceImpl { \nprotected void activate ( Map < String , Object > properties ) throws Exception { \nconfigProperties = properties ; \nString [ ] safePostProcessorNames = ( String [ ] ) configProperties . get ( SAFE_POSTPROCESSORS ) ; \nif ( safePostProcessorNames == null ) { \nsafeOpenProcessors . add ( \"rss\" ) ; \nsafeOpenProcessors . add ( \"trustedLoginTokenProxyPostProcessor\" ) ; \n} \nelse { \nfor ( String pp : safePostProcessorNames ) { \nsafeOpenProcessors . add ( pp ) ; \n} \n} \nString proxyHost = System . getProperty ( \"http.proxyHost\" , \"\" ) ; \nif ( ! proxyHost . equals ( \"\" ) ) { \nuseJreProxy = true ; \n} \nreturn ; \n} \n} \n"}
{"10735": "public class EventPropertiesAssistant { \nprivate void registerStandardEvents ( ) { \nCommonEvents . Descriptors . stopListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Presence . generalLeavingListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Presence . generalListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Presence . leavingListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Presence . presenceListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Presence . strictLeavingListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Presence . strictListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Response . fullResponseListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Response . majorResponseListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Response . minorResponseListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Type . notificationListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nCommonEvents . Type . responseListener ( this ) . ifPresent ( this :: registerEventListener ) ; \nreturn ; \n} \n} \n"}
{"10736": "public class EventPropertiesAssistant { \npublic void registerEventListener ( EventListener eventListener ) { \nregisterEventID ( eventListener . getDescription ( ) , eventListener . getDescriptorID ( ) , eventListener . getDescriptor ( ) ) ; \nreturn ; \n} \n} \n"}
{"10737": "public class EventPropertiesAssistant { \npublic void registerEventID ( String description , String key , String value ) { \nBufferedWriter bufferedWriter ; \nFileOutputStream out = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nbufferedWriter = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( key ) != null ) { \nreturn ; \n} \ntry { \nbufferedWriter . write ( \"\\n\\n\" + key + \"_DESCRIPTION = \" + description + \"\\n\" + key + \" = \" + value ) ; \nbufferedWriter . flush ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \n} \ncatch ( FileNotFoundException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) { \nout . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10738": "public class EventPropertiesAssistant { \nprivate void doWithLock ( FileChannel channel , Consumer < FileLock > consumer ) { \nFileLock lock = null ; \ntry { \nwhile ( lock == null ) { \ntry { \nlock = channel . tryLock ( ) ; \n} \ncatch ( OverlappingFileLockException e ) { \nThread . sleep ( 500 ) ; \n} \n} \nconsumer . accept ( lock ) ; \n} \ncatch ( IOException | InterruptedException e ) { \nerror ( \"Unable to write\" , e ) ; \n} \nfinally { \ntry { \nif ( lock != null ) { \nlock . release ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10739": "public class EventPropertiesAssistant { \npublic void unregisterEventID ( String eventKey ) { \nproperties . remove ( eventKey + \"_DESCRIPTION\" ) ; \nproperties . remove ( eventKey ) ; \nFileOutputStream out = null ; \nBufferedReader reader = null ; \nBufferedWriter writer = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nfinal File tempFile = new File ( eventPropertiesPath + \"temp.properties\" ) ; \nfinal BufferedReader readerFinal = new BufferedReader ( new FileReader ( eventPropertiesPath ) ) ; \nfinal BufferedWriter writerFinal = new BufferedWriter ( new FileWriter ( tempFile ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( eventKey ) != null ) { \nreturn ; \n} \ntry { \nString currentLine = readerFinal . readLine ( ) ; \nwhile ( currentLine != null ) { \nString trimmedLine = currentLine . trim ( ) ; \nif ( trimmedLine . equals ( eventKey + \"_DESCRIPTION\" ) || trimmedLine . equals ( eventKey ) ) continue ; \nwriterFinal . write ( currentLine + System . getProperty ( \"line.separator\" ) ) ; \ncurrentLine = readerFinal . readLine ( ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \nreader = readerFinal ; \nwriter = writerFinal ; \ntempFile . renameTo ( new File ( eventPropertiesPath ) ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) { \nout . close ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nif ( reader != null ) { \nreader . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10743": "public class PlayerController { \npublic void startPlaying ( TrackInfo trackInfo ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) || ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain identification\" ) ; \nreturn ; \n} \nStartMusicRequest . createStartMusicRequest ( ownIdentification . get ( ) , playerIdentification . get ( ) , trackInfo , player . isUsingJava ) . ifPresent ( event -> fire ( event , 5 ) ) ; \nreturn ; \n} \n} \n"}
{"10744": "public class PlayerController { \npublic void stopPlaying ( ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) || ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nStopMusic . createStopMusic ( ownIdentification . get ( ) , playerIdentification . get ( ) ) . ifPresent ( event -> fire ( event , 5 ) ) ; \nreturn ; \n} \n} \n"}
{"10745": "public class PlayerController { \npublic void command ( String command , Playlist playlist , Progress progress , TrackInfo trackInfo , Volume volume ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) || ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nOptional < PlayerCommand > playerCommand = PlayerCommand . createPlayerCommand ( ownIdentification . get ( ) , playerIdentification . get ( ) , command , player . getCapabilities ( ) , getContext ( ) ) ; \nif ( playlist != null ) { \nplayerCommand . get ( ) . addResource ( new PlaylistResource ( ownIdentification . get ( ) , playlist ) ) ; \n} \nif ( progress != null ) { \nplayerCommand . get ( ) . addResource ( new ProgressResource ( ownIdentification . get ( ) , progress ) ) ; \n} \nif ( trackInfo != null ) { \nplayerCommand . get ( ) . addResource ( new TrackInfoResource ( ownIdentification . get ( ) , trackInfo ) ) ; \n} \nif ( volume != null ) { \nplayerCommand . get ( ) . addResource ( new VolumeResource ( ownIdentification . get ( ) , volume ) ) ; \n} \nfire ( playerCommand . get ( ) , 5 ) ; \nreturn ; \n} \n} \n"}
{"10754": "public class LaunchNakamura { \nprivate void launchButtonActionPerformed ( java . awt . event . ActionEvent evt ) { \nif ( runStatus == APP_NOT_RUNNING ) { \nSystem . setSecurityManager ( null ) ; \ntry { \nNakamuraMain . main ( savedArgs ) ; \nstatusLabel . setText ( \"Nakamura is starting...\" ) ; \nJOptionPane . showMessageDialog ( this , \"Nakamura has been started.\\nPlease allow 30-60 seconds for it to be ready.\" , \"Information\" , JOptionPane . INFORMATION_MESSAGE ) ; \nrunStatus = APP_RUNNING ; \nisStartupFinished ( ) ; \n} \ncatch ( IOException e ) { \nstatusLabel . setText ( \"Nakamura is startup failed \" + e . getMessage ( ) ) ; \n} \n} \nelse { \nJOptionPane . showMessageDialog ( this , \"Nakamura is already running.\" , \"Warning\" , JOptionPane . WARNING_MESSAGE ) ; \n} \nreturn ; \n} \n} \n"}
{"10755": "public class LaunchNakamura { \nprivate void isStartupFinished ( ) { \nboolean started = false ; \ntry { \nwhile ( ! started ) { \nif ( exists ( localhostURL ) ) started = true ; \nThread . sleep ( 5 * 1000 ) ; \n} \n} \ncatch ( InterruptedException e ) { \ne . printStackTrace ( ) ; \n} \nif ( started ) { \nstatusLabel . setText ( \"Nakamura is running.\" ) ; \nstatusLabel . setForeground ( Color . green ) ; \nlaunchButton . setEnabled ( false ) ; \nbrowserButton . setEnabled ( true ) ; \n} \nreturn ; \n} \n} \n"}
{"10757": "public class LaunchNakamura { \nprivate void browserButtonActionPerformed ( java . awt . event . ActionEvent evt ) { \ntry { \nDesktop . getDesktop ( ) . browse ( new URL ( localhostURL ) . toURI ( ) ) ; \n} \ncatch ( IOException e ) { \nSystem . err . println ( \"IO Exception: \" + e . getMessage ( ) ) ; \n} \ncatch ( URISyntaxException e ) { \nSystem . err . println ( \"URISyntaxException: \" + e . getMessage ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10759": "public class LaunchNakamura { \npublic static void main ( String args [ ] ) { \nsavedArgs = args ; \njava . awt . EventQueue . invokeLater ( new Runnable ( ) { \npublic void run ( ) { \nnew LaunchNakamura ( ) . setVisible ( true ) ; \nreturn ; \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"10771": "public class SessionManager { \npublic void executeBatchAsync ( FutureCallback < ResultSet > callback , Statement ... statements ) throws ExceedMaxAsyncJobsException { \nif ( ! asyncSemaphore . tryAcquire ( ) ) { \nif ( callback == null ) { \nthrow new ExceedMaxAsyncJobsException ( maxSyncJobs ) ; \n} \nelse { \ncallback . onFailure ( new ExceedMaxAsyncJobsException ( maxSyncJobs ) ) ; \n} \n} \nelse { \ntry { \nResultSetFuture rsf = CqlUtils . executeBatchAsync ( getSession ( ) , statements ) ; \nif ( callback != null ) { \nFutures . addCallback ( rsf , wrapCallbackResultSet ( callback ) , asyncExecutor ) ; \n} \n} \ncatch ( Exception e ) { \nasyncSemaphore . release ( ) ; \nLOGGER . error ( e . getMessage ( ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10779": "public class PacketCollector { \nprotected void processPacket ( Packet packet ) { \nif ( packet == null ) { \nreturn ; \n} \nif ( packetFilter == null || packetFilter . accept ( packet ) ) { \nwhile ( ! resultQueue . offer ( packet ) ) { \nresultQueue . poll ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10784": "public class User { \npublic void setLoginEnabled ( long from , long to , boolean day , TimeZone timeZone ) { \nString enabledSetting = EnabledPeriod . getEnableValue ( from , to , day , timeZone ) ; \nif ( enabledSetting == null ) { \nremoveProperty ( LOGIN_ENABLED_PERIOD_FIELD ) ; \n} \nelse { \nsetProperty ( LOGIN_ENABLED_PERIOD_FIELD , enabledSetting ) ; \n} \nreturn ; \n} \n} \n"}
{"10786": "public class RosterEntry { \npublic void setName ( String name ) { \nif ( name != null && name . equals ( this . name ) ) { \nreturn ; \n} \nthis . name = name ; \nRoster packet = new Roster ( ) ; \npacket . setType ( IQ . Type . set ) ; \npacket . addItem ( new JID ( user ) , name , ask , subscription , getGroupNames ( ) ) ; \nconnection . sendPacket ( packet ) ; \nreturn ; \n} \n} \n"}
{"10787": "public class RosterEntry { \nvoid updateState ( String name , Subscription type , Ask status ) { \nthis . name = name ; \nthis . subscription = type ; \nthis . ask = status ; \nreturn ; \n} \n} \n"}
{"10789": "public class RSMUtils { \npublic static void appendRSMElement ( Element queryElement , RSM rsm ) { \nElement setElement = queryElement . addElement ( \"set\" , RSM . NAMESPACE ) ; \nif ( rsm . getFirst ( ) != null ) { \nElement firstElement = setElement . addElement ( \"first\" ) ; \nfirstElement . addAttribute ( \"index\" , rsm . getIndex ( ) . toString ( ) ) ; \nfirstElement . setText ( rsm . getFirst ( ) ) ; \n} \nif ( rsm . getLast ( ) != null ) { \nElement lastElement = setElement . addElement ( \"last\" ) ; \nlastElement . setText ( rsm . getLast ( ) ) ; \n} \nsetElement . addElement ( \"count\" ) . setText ( String . valueOf ( rsm . getCount ( ) ) ) ; \nreturn ; \n} \n} \n"}
{"10793": "public class UserRoster { \npublic void reload ( ) { \nif ( ! connection . isAuthenticated ( ) ) { \nthrow new IllegalStateException ( \"Not logged in to server.\" ) ; \n} \nif ( connection . isAnonymous ( ) ) { \nthrow new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \n} \nRoster packet = new Roster ( ) ; \nif ( rosterStore != null && connection . isRosterVersioningSupported ( ) ) { \npacket . getElement ( ) . element ( \"query\" ) . addAttribute ( \"ver\" , rosterStore . getRosterVersion ( ) ) ; \nPacketFilter filter = new PacketIDFilter ( packet . getID ( ) ) ; \nconnection . addPacketListener ( new RosterResultListener ( ) , filter ) ; \n} \nconnection . sendPacket ( packet ) ; \nreturn ; \n} \n} \n"}
{"10794": "public class UserRoster { \npublic void createEntry ( String user , String name , String [ ] groups ) throws XMPPException { \nif ( ! connection . isAuthenticated ( ) ) { \nthrow new IllegalStateException ( \"Not logged in to server.\" ) ; \n} \nif ( connection . isAnonymous ( ) ) { \nthrow new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \n} \nRoster rosterPacket = new Roster ( ) ; \nrosterPacket . setType ( IQ . Type . set ) ; \nrosterPacket . addItem ( new JID ( user ) , name , null , null , Arrays . asList ( groups ) ) ; \nPacketCollector collector = connection . createPacketCollector ( new PacketIDFilter ( rosterPacket . getID ( ) ) ) ; \nconnection . sendPacket ( rosterPacket ) ; \nIQ response = ( IQ ) collector . nextResult ( SmackConfiguration . getPacketReplyTimeout ( ) ) ; \ncollector . cancel ( ) ; \nif ( response == null ) { \nthrow new XMPPException ( \"No response from the server.\" ) ; \n} \nelse if ( response . getType ( ) == IQ . Type . error ) { \nthrow new XMPPException ( response . getError ( ) ) ; \n} \nPresence presencePacket = new Presence ( Presence . Type . subscribe ) ; \npresencePacket . setTo ( user ) ; \nconnection . sendPacket ( presencePacket ) ; \nreturn ; \n} \n} \n"}
{"10797": "public class UserRoster { \nprivate void setOfflinePresences ( ) { \nPresence packetUnavailable ; \nfor ( String user : presenceMap . keySet ( ) ) { \nMap < String , Presence > resources = presenceMap . get ( user ) ; \nif ( resources != null ) { \nfor ( String resource : resources . keySet ( ) ) { \npacketUnavailable = new Presence ( Presence . Type . unavailable ) ; \npacketUnavailable . setFrom ( user + \"/\" + resource ) ; \npresencePacketListener . processPacket ( packetUnavailable ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10798": "public class UserRoster { \nprivate void fireRosterChangedEvent ( Collection < String > addedEntries , Collection < String > updatedEntries , Collection < String > deletedEntries ) { \nfor ( RosterListener listener : rosterListeners ) { \nif ( ! addedEntries . isEmpty ( ) ) { \nlistener . entriesAdded ( addedEntries ) ; \n} \nif ( ! updatedEntries . isEmpty ( ) ) { \nlistener . entriesUpdated ( updatedEntries ) ; \n} \nif ( ! deletedEntries . isEmpty ( ) ) { \nlistener . entriesDeleted ( deletedEntries ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10799": "public class Authentication { \npublic void setDigest ( String connectionID , String password ) { \nsetDigest ( StringUtils . hash ( connectionID + password ) ) ; \nreturn ; \n} \n} \n"}
{"10803": "public class PropertiesAssistant { \npublic void registerUpdateListener ( Consumer < PropertiesAssistant > listener ) { \nif ( listener != null ) listeners . add ( new WeakReference < > ( listener ) ) ; \nreturn ; \n} \n} \n"}
{"10804": "public class PropertiesAssistant { \npublic void initProperties ( ) { \npropertiesPath = getContext ( ) . getFiles ( ) . getPropertiesLocation ( ) + File . separator + getContext ( ) . getAddOns ( ) . getAddOn ( ) . getID ( ) + \".properties\" ; \nthis . propertiesFile = new File ( propertiesPath ) ; \nif ( ! this . propertiesFile . exists ( ) ) try { \nthis . propertiesFile . createNewFile ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to create the new Properties file\" , e ) ; \n} \ntry { \nBufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( this . propertiesFile ) , \"UTF8\" ) ) ; \ntry { \nproperties . load ( in ) ; \n} \ncatch ( IOException e ) { \nerror ( \"unable to load the InputStream for the PropertiesFile\" , e ) ; \n} \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nerror ( \"Error while trying to read Properties-File\" , e ) ; \n} \nif ( defaultPropertiesPath != null && new File ( defaultPropertiesPath ) . exists ( ) ) { \n@ SuppressWarnings ( \"unchecked\" ) Enumeration < String > keys = ( Enumeration < String > ) properties . propertyNames ( ) ; \nif ( ! keys . hasMoreElements ( ) ) { \ntry { \ncreateDefaultPropertyFile ( defaultPropertiesPath ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to copy the Default-Properties File\" , e ) ; \n} \nif ( new File ( defaultPropertiesPath ) . exists ( ) && ! writeToPropertiesFile ( defaultPropertiesPath ) ) return ; \nreloadProperties ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10805": "public class PropertiesAssistant { \nprivate void reloadProperties ( ) { \nProperties temp = new Properties ( ) ; \nBufferedReader bufferedReader = null ; \ntry { \nFile properties = new File ( propertiesPath ) ; \nbufferedReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( properties ) , \"UTF8\" ) ) ; \ntemp . load ( bufferedReader ) ; \nthis . properties = temp ; \nlisteners . removeIf ( weakReference -> weakReference . get ( ) == null ) ; \nlisteners . forEach ( weakReference -> { \nConsumer < PropertiesAssistant > consumer = weakReference . get ( ) ; \nif ( consumer != null ) consumer . accept ( this ) ; \n} \n) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to load the Properties-File: \" + propertiesPath , e ) ; \n} \nfinally { \nif ( bufferedReader != null ) { \ntry { \nbufferedReader . close ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close input stream\" , e ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10818": "public class AbstractReferenceMap { \nprotected void purge ( Reference ref ) { \nint hash = ref . hashCode ( ) ; \nint index = hashIndex ( hash , data . length ) ; \nHashEntry < K , V > previous = null ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { \nif ( previous == null ) { \ndata [ index ] = entry . next ; \n} \nelse { \nprevious . next = entry . next ; \n} \nthis . size -- ; \nreturn ; \n} \nprevious = entry ; \nentry = entry . next ; \n} \nreturn ; \n} \n} \n"}
{"10823": "public class PresenceConstant { \npublic void setPresence ( boolean present ) { \nif ( this . present == present ) return ; \nthis . present = present ; \nupdateVague ( ) ; \nif ( present ) { \nfirePresence ( true ) ; \n} \nelse { \nfireLeaving ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10824": "public class PresenceConstant { \nprivate void updateVague ( ) { \ngenerateResource ( PresenceResource . ID ) . orElse ( CompletableFuture . completedFuture ( new ArrayList < > ( ) ) ) . thenAccept ( list -> mostVague . set ( list . stream ( ) . map ( Presence :: importPresence ) . filter ( Optional :: isPresent ) . map ( Optional :: get ) . map ( Presence :: getLevel ) . noneMatch ( level -> level . compareTo ( getLevel ( ) ) > 0 ) ) ) ; \nreturn ; \n} \n} \n"}
{"10825": "public class Chat { \nvoid deliver ( Message message ) { \nmessage . setThread ( threadID ) ; \nfor ( MessageListener listener : listeners ) { \nlistener . processMessage ( this , message ) ; \n} \nreturn ; \n} \n} \n"}
{"10838": "public class Connection { \npublic void addConnectionListener ( ConnectionListener connectionListener ) { \nif ( connectionListener == null ) { \nreturn ; \n} \nif ( ! connectionListeners . contains ( connectionListener ) ) { \nconnectionListeners . add ( connectionListener ) ; \n} \nreturn ; \n} \n} \n"}
{"10839": "public class Connection { \npublic void addPacketListener ( PacketListener packetListener , PacketFilter packetFilter ) { \nif ( packetListener == null ) { \nthrow new NullPointerException ( \"Packet listener is null.\" ) ; \n} \nListenerWrapper wrapper = new ListenerWrapper ( packetListener , packetFilter ) ; \nrecvListeners . put ( packetListener , wrapper ) ; \nreturn ; \n} \n} \n"}
{"10840": "public class Connection { \npublic void addPacketSendingListener ( PacketListener packetListener , PacketFilter packetFilter ) { \nif ( packetListener == null ) { \nthrow new NullPointerException ( \"Packet listener is null.\" ) ; \n} \nListenerWrapper wrapper = new ListenerWrapper ( packetListener , packetFilter ) ; \nsendListeners . put ( packetListener , wrapper ) ; \nreturn ; \n} \n} \n"}
{"10841": "public class Connection { \nprotected void firePacketSendingListeners ( Packet packet ) { \nfor ( ListenerWrapper listenerWrapper : sendListeners . values ( ) ) { \nlistenerWrapper . notifyListener ( packet ) ; \n} \nreturn ; \n} \n} \n"}
{"10842": "public class Connection { \npublic void addPacketInterceptor ( PacketInterceptor packetInterceptor , PacketFilter packetFilter ) { \nif ( packetInterceptor == null ) { \nthrow new NullPointerException ( \"Packet interceptor is null.\" ) ; \n} \ninterceptors . put ( packetInterceptor , new InterceptorWrapper ( packetInterceptor , packetFilter ) ) ; \nreturn ; \n} \n} \n"}
{"10843": "public class Connection { \nprotected void firePacketInterceptors ( Packet packet ) { \nif ( packet != null ) { \nfor ( InterceptorWrapper interceptorWrapper : interceptors . values ( ) ) { \ninterceptorWrapper . notifyListener ( packet ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10845": "public class ExternalComponent { \npublic void connectionLost ( ) { \nsynchronized ( this ) { \nif ( reconnecting ) { \nreturn ; \n} \nreconnecting = true ; \n} \nreaderThread = null ; \nboolean isConnected = false ; \nif ( ! shutdown ) { \ncomponent . shutdown ( ) ; \n} \nwhile ( ! isConnected && ! shutdown ) { \ntry { \nconnect ( host , port , subdomain ) ; \nisConnected = true ; \nif ( shutdown ) { \ndisconnect ( ) ; \n} \nelse { \nstart ( ) ; \n} \n} \ncatch ( ComponentException e ) { \nmanager . getLog ( ) . error ( \"Error trying to reconnect with the server\" , e ) ; \ntry { \nThread . sleep ( 5000 ) ; \n} \ncatch ( InterruptedException e1 ) { \n} \n} \n} \nreconnecting = false ; \nreturn ; \n} \n} \n"}
{"10858": "public class TransactionalBidiTreeMap { \nprivate static < K , V > void copyColor ( final Node < K , V > from , final Node < K , V > to , final int index ) { \nif ( to != null ) { \nif ( from == null ) { \nto . setBlack ( index ) ; \n} \nelse { \nto . copyColor ( from , index ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10865": "public class TransactionalBidiTreeMap { \nprivate void rotateLeft ( final Node < K , V > node , final int index ) { \nNode < K , V > rightChild = node . getRight ( index ) ; \nnode . setRight ( rightChild . getLeft ( index ) , index ) ; \nif ( rightChild . getLeft ( index ) != null ) { \nrightChild . getLeft ( index ) . setParent ( node , index ) ; \n} \nrightChild . setParent ( node . getParent ( index ) , index ) ; \nif ( node . getParent ( index ) == null ) { \nrootNode [ index ] = rightChild ; \n} \nelse if ( node . getParent ( index ) . getLeft ( index ) == node ) { \nnode . getParent ( index ) . setLeft ( rightChild , index ) ; \n} \nelse { \nnode . getParent ( index ) . setRight ( rightChild , index ) ; \n} \nrightChild . setLeft ( node , index ) ; \nnode . setParent ( rightChild , index ) ; \nreturn ; \n} \n} \n"}
{"10866": "public class TransactionalBidiTreeMap { \nprivate void rotateRight ( final Node < K , V > node , final int index ) { \nNode < K , V > leftChild = node . getLeft ( index ) ; \nnode . setLeft ( leftChild . getRight ( index ) , index ) ; \nif ( leftChild . getRight ( index ) != null ) { \nleftChild . getRight ( index ) . setParent ( node , index ) ; \n} \nleftChild . setParent ( node . getParent ( index ) , index ) ; \nif ( node . getParent ( index ) == null ) { \nrootNode [ index ] = leftChild ; \n} \nelse if ( node . getParent ( index ) . getRight ( index ) == node ) { \nnode . getParent ( index ) . setRight ( leftChild , index ) ; \n} \nelse { \nnode . getParent ( index ) . setLeft ( leftChild , index ) ; \n} \nleftChild . setRight ( node , index ) ; \nnode . setParent ( leftChild , index ) ; \nreturn ; \n} \n} \n"}
{"10867": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackInsert ( final Node < K , V > insertedNode , final int index ) { \nNode < K , V > currentNode = insertedNode ; \nmakeRed ( currentNode , index ) ; \nwhile ( ( currentNode != null ) && ( currentNode != rootNode [ index ] ) && ( isRed ( currentNode . getParent ( index ) , index ) ) ) { \nif ( isLeftChild ( getParent ( currentNode , index ) , index ) ) { \nNode < K , V > y = getRightChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( isRed ( y , index ) ) { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \nelse { \nif ( isRightChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateLeft ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) { \nrotateRight ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \n} \nelse { \nNode < K , V > y = getLeftChild ( getGrandParent ( currentNode , index ) , index ) ; \nif ( isRed ( y , index ) ) { \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeBlack ( y , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \ncurrentNode = getGrandParent ( currentNode , index ) ; \n} \nelse { \nif ( isLeftChild ( currentNode , index ) ) { \ncurrentNode = getParent ( currentNode , index ) ; \nrotateRight ( currentNode , index ) ; \n} \nmakeBlack ( getParent ( currentNode , index ) , index ) ; \nmakeRed ( getGrandParent ( currentNode , index ) , index ) ; \nif ( getGrandParent ( currentNode , index ) != null ) { \nrotateLeft ( getGrandParent ( currentNode , index ) , index ) ; \n} \n} \n} \n} \nmakeBlack ( rootNode [ index ] , index ) ; \nreturn ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \n} \nshrink ( ) ; \nreturn ; \n} \n} \n"}
{"10869": "public class TransactionalBidiTreeMap { \nprivate void checkNonNullComparable ( final Object o , final int index ) { \nif ( o == null ) { \nthrow new NullPointerException ( dataName [ index ] + \" cannot be null\" ) ; \n} \nif ( comparators [ index ] == null && ! ( o instanceof Comparable ) ) { \nthrow new ClassCastException ( dataName [ index ] + \" must be Comparable\" ) ; \n} \nreturn ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse if ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( cmp < 0 ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse { \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10875": "public class TransactionalBidiTreeMap { \n@ Override public void clear ( ) { \nif ( auto_commit ) { \nmodify ( ) ; \nnodeCount = 0 ; \nrootNode [ KEY ] = null ; \nrootNode [ VALUE ] = null ; \n} \nelse { \nString thread_id = getCurrentThreadId ( ) ; \nArrayList < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( entrySet ( ) ) ; \nfor ( Iterator < Entry < K , V > > i = list . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nNode < K , V > node = ( Node < K , V > ) i . next ( ) ; \nif ( node . is ( Node . ADDED , thread_id ) ) doRedBlackDelete ( node ) ; \nelse { \nnode . setStatus ( Node . DELETED , thread_id ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10876": "public class TransactionalBidiTreeMap { \n@ Override public Set < K > keySet ( ) { \nif ( setOfKeysByKey == null ) { \nsetOfKeysByKey = new AbstractFilterableSet < K > ( ) { \n@ Override public Iterator < K > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < K > ( KEY ) { \n@ Override protected K doGetNext ( ) { \nreturn ( K ) lastReturnedNode . getData ( KEY ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsKey ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nint oldNodeCount = nodeCount ; \nTransactionalBidiTreeMap . this . remove ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \nreturn ; \n} \n} \n; \n} \nreturn setOfKeysByKey ; \n} \n} \n"}
{"10877": "public class TransactionalBidiTreeMap { \n@ Override public Collection < V > values ( ) { \nif ( collectionOfValuesByKey == null ) { \ncollectionOfValuesByKey = new AbstractFilterableCollection < V > ( ) { \n@ Override public Iterator < V > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < V > ( KEY ) { \n@ Override protected V doGetNext ( ) { \nreturn ( V ) lastReturnedNode . getData ( VALUE ) ; \n} \n} \n; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( ) ; \n} \n@ Override public boolean contains ( Object o ) { \nreturn containsValue ( o ) ; \n} \n@ Override public boolean remove ( Object o ) { \nint oldNodeCount = nodeCount ; \nremoveValue ( o ) ; \nreturn nodeCount != oldNodeCount ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nboolean modified = false ; \nIterator < ? > iter = c . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nif ( removeValue ( iter . next ( ) ) != null ) { \nmodified = true ; \n} \n} \nreturn modified ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \nreturn ; \n} \n} \n; \n} \nreturn collectionOfValuesByKey ; \n} \n} \n"}
{"10878": "public class TransactionalBidiTreeMap { \npublic FilterableSet < Entry < K , V > > allEntrySet ( ) { \nif ( setOfAllEntries == null ) { \nsetOfAllEntries = new AbstractFilterableSet < Entry < K , V > > ( ) { \n@ Override public Iterator < Entry < K , V > > iterator ( ) { \nreturn new TransactionalBidiTreeMapIterator < Entry < K , V > > ( KEY ) { \n@ Override protected Entry < K , V > doGetNext ( ) { \nreturn lastReturnedNode ; \n} \n@ Override protected Node < K , V > getNextValidNode ( Node < K , V > node , String thread_id ) { \nreturn node ; \n} \n} \n; \n} \n@ Override public boolean contains ( Object o ) { \nthrow new UtilsjException ( \"method not supported\" ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UtilsjException ( \"method not supported\" ) ; \n} \n@ Override public int size ( ) { \nreturn TransactionalBidiTreeMap . this . size ( true ) ; \n} \n@ Override public void clear ( ) { \nTransactionalBidiTreeMap . this . clear ( ) ; \nreturn ; \n} \n} \n; \n} \nreturn setOfAllEntries ; \n} \n} \n"}
{"10879": "public class TransactionalBidiTreeMap { \npublic final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { \nK key ; \nV val ; \nint transaction_status ; \nString transaction_id ; \nnew_map . setAutoCommit ( isAutoCommit ( ) ) ; \nif ( ! isAutoCommit ( ) ) { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { \ntry { \nnew_map . put ( key , val ) ; \nnew_map . commit ( ) ; \n} \ncatch ( Exception e ) { \n} \ntry { \nif ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { \nnew_map . attach ( transaction_id ) ; \nnew_map . remove ( key ) ; \n} \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntransaction_status = entry . getStatus ( ) ; \ntransaction_id = entry . getTransactionId ( ) ; \nif ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { \nnew_map . attach ( transaction_id ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \nnew_map . detach ( ) ; \n} \n} \n} \nelse { \nfor ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nTransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; \nkey = entry . getKey ( ) ; \nval = entry . getValue ( ) ; \ntry { \nnew_map . put ( key , val ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10880": "public class Cache { \nprotected synchronized void deleteExpiredEntries ( ) { \nif ( maxLifetime <= 0 ) { \nreturn ; \n} \nLinkedListNode node = ageList . getLast ( ) ; \nif ( node == null ) { \nreturn ; \n} \nlong expireTime = System . currentTimeMillis ( ) - maxLifetime ; \nwhile ( expireTime > node . timestamp ) { \nif ( remove ( node . object , true ) == null ) { \nlog . warn ( \"Error attempting to remove(\" + node . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nnode . remove ( ) ; \n} \nnode = ageList . getLast ( ) ; \nif ( node == null ) { \nreturn ; \n} \n} \nreturn ; \n} \n} \n"}
{"10881": "public class Cache { \nprotected synchronized void cullCache ( ) { \nif ( maxCacheSize < 0 ) { \nreturn ; \n} \nif ( map . size ( ) > maxCacheSize ) { \ndeleteExpiredEntries ( ) ; \nint desiredSize = ( int ) ( maxCacheSize * .90 ) ; \nfor ( int i = map . size ( ) ; \ni > desiredSize ; \ni -- ) { \nif ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { \nlog . warn ( \"Error attempting to cullCache with remove(\" + lastAccessedList . getLast ( ) . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nlastAccessedList . getLast ( ) . remove ( ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10882": "public class TrustedLoginTokenProxyPreProcessor { \nprotected void activate ( Map < String , Object > props ) { \nsharedSecret = toString ( props . get ( \"sharedSecret\" ) , \"e2KS54H35j6vS5Z38nK40\" ) ; \nhostname = toString ( props . get ( \"hostname\" ) , \"localhost\" ) ; \nLOGGER . info ( \" Trusted hostname: \" + hostname ) ; \nport = toInteger ( props . get ( \"port\" ) , 80 ) ; \nLOGGER . info ( \"Trusted port: \" + port ) ; \nreturn ; \n} \n} \n"}
{"10890": "public class ExecS { \nprotected final void addAllApplications ( Set < Class < ? > > set ) { \nfor ( Class < ? > cls : set ) { \nif ( ! cls . isInterface ( ) && ! Modifier . isAbstract ( cls . getModifiers ( ) ) ) { \nif ( ! this . classmap . containsValue ( cls ) ) { \nthis . classNames . add ( cls . getName ( ) ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"10892": "public class ExecS { \nprotected final void printList ( ) { \nST list = this . stg . getInstanceOf ( \"list\" ) ; \nlist . add ( \"appName\" , this . appName ) ; \nif ( this . classmap . size ( ) > 0 ) { \nList < Map < String , String > > l = new ArrayList < > ( ) ; \nfor ( String key : this . classmap . keySet ( ) ) { \nMap < String , String > m = new HashMap < > ( ) ; \nm . put ( \"key\" , key ) ; \nm . put ( \"val\" , this . classmap . get ( key ) . getName ( ) ) ; \nl . add ( m ) ; \n} \nlist . add ( \"classMap\" , l ) ; \n} \nlist . add ( \"className\" , this . classNames ) ; \nSystem . out . println ( list . render ( ) ) ; \nreturn ; \n} \n} \n"}
{"10893": "public class ExecS { \nprotected final void printUsage ( ) { \nST usage = this . stg . getInstanceOf ( \"usage\" ) ; \nusage . add ( \"appName\" , this . appName ) ; \nusage . add ( \"packageFilter\" , this . packageFilter ) ; \nusage . add ( \"jarFilter\" , this . jarFilter ) ; \nusage . add ( \"excludedNames\" , new TreeSet < > ( Arrays . asList ( new CF ( ) . excludedNames ) ) ) ; \nSystem . out . println ( usage . render ( ) ) ; \nreturn ; \n} \n} \n"}
{"10894": "public class ExecS { \npublic static void main ( String [ ] args ) { \nExecS run = new ExecS ( ) ; \nint ret = run . execute ( args ) ; \nSystem . exit ( ret ) ; \nreturn ; \n} \n} \n"}
{"10900": "public class Gen_ExecJarScripts { \nprotected void addOption ( ApplicationOption < ? > option ) { \nif ( option != null ) { \nthis . getCli ( ) . addOption ( option ) ; \nthis . options . add ( option ) ; \n} \nreturn ; \n} \n} \n"}
{"10907": "public class IterativeCallback { \npublic R iterate ( final FilterableCollection < ? extends T > c ) { \ninitState ( ) ; \ncheckUsed ( ) ; \nif ( c instanceof SynchronizedFilterableCollection ) { \nreturn SyncUtils . synchronizeRead ( c , new Callback < R > ( ) { \n@ Override protected void doAction ( ) { \n_return ( doIteration ( c . iterator ( ) ) ) ; \nreturn ; \n} \n} \n) ; \n} \nreturn doIteration ( c . iterator ( ) ) ; \n} \n} \n"}
{"10915": "public class CollectionUtilities { \npublic static < K , V > void reverse ( Map < K , V > source , Map < V , K > target ) { \nIterator < K > i = source . keySet ( ) . iterator ( ) ; \nwhile ( i . hasNext ( ) ) { \nK key = i . next ( ) ; \nV value = source . get ( key ) ; \ntarget . put ( value , key ) ; \n} \nreturn ; \n} \n} \n"}
{"10917": "public class WorkerThread { \n@ Override public synchronized void start ( ) { \nif ( ! running && ! used ) { \nthis . running = true ; \nthis . used = true ; \nthis . setDaemon ( true ) ; \nsuper . start ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10918": "public class WorkerThread { \nprivate void returnToPool ( ) { \nif ( pool != null ) { \ntry { \npool . returnObject ( this ) ; \n} \ncatch ( Exception e1 ) { \nlog . error ( \"Exception :\" , e1 ) ; \n} \nthis . pool = null ; \n} \nreturn ; \n} \n} \n"}
{"10926": "public class SASLMechanism { \npublic void challengeReceived ( String challenge ) throws IOException { \nbyte response [ ] ; \nif ( challenge != null ) { \nresponse = sc . evaluateChallenge ( StringUtils . decodeBase64 ( challenge ) ) ; \n} \nelse { \nresponse = sc . evaluateChallenge ( new byte [ 0 ] ) ; \n} \nPacket responseStanza ; \nif ( response == null ) { \nresponseStanza = new Response ( ) ; \n} \nelse { \nresponseStanza = new Response ( StringUtils . encodeBase64 ( response , false ) ) ; \n} \ngetSASLAuthentication ( ) . send ( responseStanza ) ; \nreturn ; \n} \n} \n"}
{"10928": "public class OutputPluginArgument { \n@ Override public void run ( ) { \nwhile ( ! stop ) { \nEventModel event ; \ntry { \nevent = blockingQueueHandling ( ) ; \n} \ncatch ( InterruptedException e ) { \ngetContext ( ) . getLogger ( ) . warn ( e ) ; \ncontinue ; \n} \nList < CompletableFuture < X > > outputExtensions = getContext ( ) . getOutput ( ) . generateAllOutputExtensions ( this , getArgument ( ) , event ) ; \ntry { \noutputExtensions = timeOut ( outputExtensions , getTimeoutLimit ( ) ) ; \n} \ncatch ( InterruptedException e ) { \ngetContext ( ) . getLogger ( ) . warn ( e ) ; \n} \nhandleFutures ( outputExtensions , event ) ; \nisDone ( event ) ; \n} \nreturn ; \n} \n} \n"}
{"10929": "public class ContentEventListener { \npublic void handleEvent ( Event event ) { \nString topic = event . getTopic ( ) ; \nLOGGER . debug ( \"Got Event {} {} \" , event , handlers ) ; \nCollection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; \nif ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) { \ntry { \nint ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; \nfor ( IndexingHandler indexingHandler : contentIndexHandler ) { \nif ( indexingHandler instanceof QoSIndexHandler ) { \nttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; \n} \n} \nQueueManager q = null ; \nif ( ttl < queues [ 0 ] . batchDelay ) { \nLOGGER . warn ( \"Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. \" + \"If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. \" + \"Filling the highest priority queue is counter productive. \" , ttl , event ) ; \nqueues [ 0 ] . saveEvent ( event ) ; \n} \nelse { \nfor ( QueueManager qm : queues ) { \nif ( ttl < qm . batchDelay ) { \nq . saveEvent ( event ) ; \nq = null ; \nbreak ; \n} \nq = qm ; \n} \nif ( q != null ) { \nq . saveEvent ( event ) ; \n} \n} \n} \ncatch ( IOException e ) { \nLOGGER . warn ( e . getMessage ( ) , e ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10930": "public class ContentEventListener { \nprotected void joinAll ( ) throws InterruptedException { \nif ( queues != null ) { \nfor ( QueueManager q : queues ) { \nq . getQueueDispatcher ( ) . join ( ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10931": "public class Authorizable { \npublic void setProperty ( String name , Object value ) { \nif ( ! readOnly && ! FILTER_PROPERTIES . contains ( name ) ) { \nObject cv = authorizableMap . get ( name ) ; \nif ( value == null ) { \nif ( cv != null && ! ( cv instanceof RemoveProperty ) ) { \nmodifiedMap . put ( name , new RemoveProperty ( ) ) ; \n} \n} \nelse if ( ! value . equals ( cv ) ) { \nmodifiedMap . put ( name , value ) ; \n} \nelse if ( modifiedMap . containsKey ( name ) && ! value . equals ( modifiedMap . get ( name ) ) ) { \nmodifiedMap . put ( name , value ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10932": "public class Authorizable { \npublic void removeProperty ( String key ) { \nif ( ! readOnly && ( authorizableMap . containsKey ( key ) || modifiedMap . containsKey ( key ) ) ) { \nmodifiedMap . put ( key , new RemoveProperty ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"10933": "public class Authorizable { \npublic void addPrincipal ( String principal ) { \nif ( ! readOnly && ! principals . contains ( principal ) ) { \nprincipals . add ( principal ) ; \nprincipalsModified = true ; \n} \nreturn ; \n} \n} \n"}
{"10934": "public class Authorizable { \npublic void removePrincipal ( String principal ) { \nif ( ! readOnly && principals . contains ( principal ) ) { \nprincipals . remove ( principal ) ; \nprincipalsModified = true ; \n} \nreturn ; \n} \n} \n"}
{"10935": "public class LiteDebugger { \npublic void rootWindowClosing ( WindowEvent evt ) { \nconnection . removePacketListener ( listener ) ; \n( ( ObservableReader ) reader ) . removeReaderListener ( readerListener ) ; \n( ( ObservableWriter ) writer ) . removeWriterListener ( writerListener ) ; \nreturn ; \n} \n} \n"}
{"10936": "public class PresenceNonConstant { \n@ SuppressWarnings ( \"unused\" ) public void userEncountered ( ) { \nList < String > descriptors = new ArrayList < > ( ) ; \ndescriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; \nboolean known = ! fireUnknownIfNotPresent || present ; \nboolean firstPresent = ( ! strict && ! present ) || ( strict && ! strictPresent ) ; \nlong lastSeen = this . lastSeen . until ( LocalDateTime . now ( ) , ChronoUnit . SECONDS ) ; \nOptional < Event > presenceEvent = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( id -> PresenceEvent . createPresenceEvent ( id , strict , known , firstPresent , descriptors , lastSeen ) ) . map ( event -> event . addEventLifeCycleListener ( EventLifeCycle . APPROVED , lifeCycle -> { \nif ( known ) { \nthis . lastSeen = LocalDateTime . now ( ) ; \nif ( strict ) this . strictPresent = true ; \npresent = true ; \n} \n} \n) ) ; \nif ( ! presenceEvent . isPresent ( ) ) { \nerror ( \"unable to create PresenceEvent\" ) ; \n} \nelse { \nfire ( presenceEvent . get ( ) , 5 ) ; \n} \nreturn ; \n} \n} \n"}
{"10937": "public class PresenceNonConstant { \n@ Override public void eventFired ( EventModel event ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) || event . containsDescriptor ( PresenceEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { \npresent = false ; \nstrictPresent = false ; \n} \nelse if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) { \nnonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) present = false ; \nstrictPresent = false ; \n} \n) ; \n} \n} \nelse { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; \n} \nreturn ; \n} \n} \n"}
{"10939": "public class RosterGroup { \npublic void setName ( String name ) { \nsynchronized ( entries ) { \nfor ( RosterEntry entry : entries ) { \nRoster packet = new Roster ( ) ; \npacket . setType ( IQ . Type . set ) ; \nList < String > groupNames = new LinkedList < String > ( entry . getGroupNames ( ) ) ; \ngroupNames . remove ( this . name ) ; \ngroupNames . add ( name ) ; \npacket . addItem ( new JID ( entry . getUser ( ) ) , entry . getName ( ) , entry . getAsk ( ) , entry . getSubscription ( ) , groupNames ) ; \nconnection . sendPacket ( packet ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10943": "public class AbstractHashedMap { \npublic void clear ( ) { \nmodCount ++ ; \nHashEntry [ ] data = this . data ; \nfor ( int i = data . length - 1 ; \ni >= 0 ; \ni -- ) { \ndata [ i ] = null ; \n} \nsize = 0 ; \nreturn ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nint oldCapacity = data . length ; \nif ( newCapacity <= oldCapacity ) { \nreturn ; \n} \nif ( size == 0 ) { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \nelse { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount ++ ; \nfor ( int i = oldCapacity - 1 ; \ni >= 0 ; \ni -- ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nint index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \nreturn ; \n} \n} \n"}
{"10950": "public class Types { \npublic static void loadFromStream ( String key , Map < String , Object > output , InputStream binaryStream , String type ) throws IOException { \nDataInputStream dis = new DataInputStream ( binaryStream ) ; \nString ckey = dis . readUTF ( ) ; \nif ( ! key . equals ( ckey ) ) { \nthrow new IOException ( \"Body Key does not match row key, unable to read\" ) ; \n} \nreadMapFromStream ( output , dis ) ; \nString cftype = null ; \ntry { \ncftype = dis . readUTF ( ) ; \n} \ncatch ( IOException e ) { \nLOGGER . debug ( \"No type specified\" ) ; \n} \nif ( cftype != null && ! cftype . equals ( type ) ) { \nthrow new IOException ( \"Object is not of expected column family, unable to read expected [\" + type + \"] was [\" + cftype + \"]\" ) ; \n} \nLOGGER . debug ( \"Finished Reading\" ) ; \ndis . close ( ) ; \nbinaryStream . close ( ) ; \nreturn ; \n} \n} \n"}
{"10951": "public class AddOn { \n@ Override public void register ( ) { \nprepare ( ) ; \nContentGenerator [ ] contentGenerators = registerContentGenerator ( ) ; \nif ( contentGenerators != null ) { \nfor ( ContentGenerator contentGenerator : contentGenerators ) { \ntry { \ngetContext ( ) . getContentGenerators ( ) . registerContentGenerator ( contentGenerator ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + contentGenerator . getID ( ) , e ) ; \n} \n} \n} \nEventsControllerModel [ ] eventsControllerModels = registerEventController ( ) ; \nif ( eventsControllerModels != null ) { \nfor ( EventsControllerModel eventsController : eventsControllerModels ) { \ntry { \ngetContext ( ) . getEvents ( ) . distributor ( ) . registerEventsController ( eventsController ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + eventsController . getID ( ) , e ) ; \n} \n} \n} \nOutputPluginModel [ ] outputPluginModels = registerOutputPlugin ( ) ; \nif ( outputPluginModels != null ) { \nfor ( OutputPluginModel outputPlugin : outputPluginModels ) { \ntry { \ngetContext ( ) . getOutput ( ) . addOutputPlugin ( outputPlugin ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + outputPlugin . getID ( ) , e ) ; \n} \n} \n} \nOutputExtensionModel [ ] outputExtensionModels = registerOutputExtension ( ) ; \nif ( outputExtensionModels != null ) { \nfor ( OutputExtensionModel outputExtension : outputExtensionModels ) { \ntry { \ngetContext ( ) . getOutput ( ) . addOutputExtension ( outputExtension ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + outputExtension . getID ( ) , e ) ; \n} \n} \n} \nOutputControllerModel [ ] outputControllerModels = registerOutputController ( ) ; \nif ( outputControllerModels != null ) { \nfor ( OutputControllerModel outputController : outputControllerModels ) { \ntry { \ngetContext ( ) . getOutput ( ) . addOutputController ( outputController ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + outputController . getID ( ) , e ) ; \n} \n} \n} \nActivatorModel [ ] activatorModels = registerActivator ( ) ; \ngetContext ( ) . getSystem ( ) . registerInitializedListener ( ( ) -> { \nif ( activatorModels != null ) { \nfor ( ActivatorModel activator : activatorModels ) { \ntry { \ngetContext ( ) . getActivators ( ) . addActivator ( activator ) ; \n} \ncatch ( IllegalIDException e ) { \ncontext . getLogger ( ) . fatal ( \"Illegal Id for Module: \" + activator . getID ( ) , e ) ; \n} \n} \n} \n} \n) ; \nreturn ; \n} \n} \n"}
{"10952": "public class AddOn { \n@ Override public void initAddOn ( org . intellimate . izou . system . Context context ) { \nthis . context = new Context ( context ) ; \nreturn ; \n} \n} \n"}
{"10953": "public class ReconnectionManager { \nprotected void notifyReconnectionFailed ( Exception exception ) { \nif ( isReconnectionAllowed ( ) ) { \nfor ( ConnectionListener listener : connection . connectionListeners ) { \nlistener . reconnectionFailed ( exception ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"10954": "public class ReconnectionManager { \nprotected void notifyAttemptToReconnectIn ( int seconds ) { \nif ( isReconnectionAllowed ( ) ) { \nfor ( ConnectionListener listener : connection . connectionListeners ) { \nlistener . reconnectingIn ( seconds ) ; \n} \n} \nreturn ; \n} \n} \n"}
