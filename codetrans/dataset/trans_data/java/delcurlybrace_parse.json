public class QueueDrainObserver { 
protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { 
final Observer < ? super V > observer = downstream ; 
final SimplePlainQueue < U > q = queue ; 
if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) if ( q . isEmpty ( ) ) { 
accept ( observer , value ) ; 
if ( leave ( - 1 ) == 0 ) return ; 
} 
else q . offer ( value ) ; 
else { 
q . offer ( value ) ; 
if ( ! enter ( ) ) return ; 
} 
QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; 
} 
} 

public class Observable { 
@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { 
ObjectHelper . requireNonNull ( source , "source is null" ) ; 
if ( source instanceof Observable ) return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; 
return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; 
} 
} 

public class FlowableScalarXMap { 
@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { 
if ( source instanceof Callable ) { 
T t ; 
try { 
t = ( ( Callable < T > ) source ) . call ( ) ; 
} 
catch ( Throwable ex ) { 
Exceptions . throwIfFatal ( ex ) ; 
EmptySubscription . error ( ex , subscriber ) ; 
return true ; 
} 
if ( t == null ) { 
EmptySubscription . complete ( subscriber ) ; 
return true ; 
} 
Publisher < ? extends R > r ; 
try { 
r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; 
} 
catch ( Throwable ex ) { 
Exceptions . throwIfFatal ( ex ) ; 
EmptySubscription . error ( ex , subscriber ) ; 
return true ; 
} 
if ( r instanceof Callable ) { 
R u ; 
try { 
u = ( ( Callable < R > ) r ) . call ( ) ; 
} 
catch ( Throwable ex ) { 
Exceptions . throwIfFatal ( ex ) ; 
EmptySubscription . error ( ex , subscriber ) ; 
return true ; 
} 
if ( u == null ) { 
EmptySubscription . complete ( subscriber ) ; 
return true ; 
} 
subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; 
} 
else r . subscribe ( subscriber ) ; 
return true ; 
} 
return false ; 
} 
} 

public class ObjectHelper { 
public static < T > T requireNonNull ( T object , String message ) { 
if ( object == null ) throw new NullPointerException ( message ) ; 
return object ; 
} 
} 

public class BlockingMultiObserver { 
public Throwable blockingGetError ( ) { 
if ( getCount ( ) != 0 ) try { 
BlockingHelper . verifyNonBlocking ( ) ; 
await ( ) ; 
} 
catch ( InterruptedException ex ) { 
dispose ( ) ; 
return ex ; 
} 
return error ; 
} 
} 

public class BlockingMultiObserver { 
public Throwable blockingGetError ( long timeout , TimeUnit unit ) { 
if ( getCount ( ) != 0 ) try { 
BlockingHelper . verifyNonBlocking ( ) ; 
if ( ! await ( timeout , unit ) ) { 
dispose ( ) ; 
throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; 
} 
} 
catch ( InterruptedException ex ) { 
dispose ( ) ; 
throw ExceptionHelper . wrapOrThrow ( ex ) ; 
} 
return error ; 
} 
} 

public class BlockingMultiObserver { 
public boolean blockingAwait ( long timeout , TimeUnit unit ) { 
if ( getCount ( ) != 0 ) try { 
BlockingHelper . verifyNonBlocking ( ) ; 
if ( ! await ( timeout , unit ) ) { 
dispose ( ) ; 
return false ; 
} 
} 
catch ( InterruptedException ex ) { 
dispose ( ) ; 
throw ExceptionHelper . wrapOrThrow ( ex ) ; 
} 
Throwable ex = error ; 
if ( ex != null ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
return true ; 
} 
} 

public class QueueDrainHelper { 
public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { 
int missed = 1 ; 
for ( ; 
; 
) { 
for ( ; 
; 
) { 
boolean d = qd . done ( ) ; 
T v = q . poll ( ) ; 
boolean empty = v == null ; 
if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { 
if ( dispose != null ) dispose . dispose ( ) ; 
return ; 
} 
if ( empty ) break ; 
long r = qd . requested ( ) ; 
if ( r != 0L ) if ( qd . accept ( a , v ) ) if ( r != Long . MAX_VALUE ) qd . produced ( 1 ) ; 
else { 
q . clear ( ) ; 
if ( dispose != null ) dispose . dispose ( ) ; 
a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; 
return ; 
} 
} 
missed = qd . leave ( - missed ) ; 
if ( missed == 0 ) break ; 
} 
} 
} 

public class QueueDrainHelper { 
public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { 
if ( queue . isEmpty ( ) ) { 
actual . onComplete ( ) ; 
return ; 
} 
if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) return ; 
for ( ; 
; 
) { 
long r = state . get ( ) ; 
if ( ( r & COMPLETED_MASK ) != 0L ) return ; 
long u = r | COMPLETED_MASK ; 
if ( state . compareAndSet ( r , u ) ) { 
if ( r != 0L ) postCompleteDrain ( u , actual , queue , state , isCancelled ) ; 
return ; 
} 
} 
} 
} 

public class SinglePostCompleteSubscriber { 
protected final void complete ( R n ) { 
long p = produced ; 
if ( p != 0 ) BackpressureHelper . produced ( this , p ) ; 
for ( ; 
; 
) { 
long r = get ( ) ; 
if ( ( r & COMPLETE_MASK ) != 0 ) { 
onDrop ( n ) ; 
return ; 
} 
if ( ( r & REQUEST_MASK ) != 0 ) { 
lazySet ( COMPLETE_MASK + 1 ) ; 
downstream . onNext ( n ) ; 
downstream . onComplete ( ) ; 
return ; 
} 
value = n ; 
if ( compareAndSet ( 0 , COMPLETE_MASK ) ) return ; 
value = null ; 
} 
} 
} 

public class Notification { 
@ SuppressWarnings ( "unchecked" ) @ Nullable public T getValue ( ) { 
Object o = value ; 
if ( o != null && ! NotificationLite . isError ( o ) ) return ( T ) value ; 
return null ; 
} 
} 

public class Notification { 
@ Nullable public Throwable getError ( ) { 
Object o = value ; 
if ( NotificationLite . isError ( o ) ) return NotificationLite . getError ( o ) ; 
return null ; 
} 
} 

public class EndConsumerHelper { 
public static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { 
ObjectHelper . requireNonNull ( next , "next is null" ) ; 
if ( upstream != null ) { 
next . dispose ( ) ; 
if ( upstream != DisposableHelper . DISPOSED ) reportDoubleSubscription ( observer ) ; 
return false ; 
} 
return true ; 
} 
} 

public class EndConsumerHelper { 
public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { 
ObjectHelper . requireNonNull ( next , "next is null" ) ; 
if ( ! upstream . compareAndSet ( null , next ) ) { 
next . dispose ( ) ; 
if ( upstream . get ( ) != DisposableHelper . DISPOSED ) reportDoubleSubscription ( observer ) ; 
return false ; 
} 
return true ; 
} 
} 

public class EndConsumerHelper { 
public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { 
ObjectHelper . requireNonNull ( next , "next is null" ) ; 
if ( upstream != null ) { 
next . cancel ( ) ; 
if ( upstream != SubscriptionHelper . CANCELLED ) reportDoubleSubscription ( subscriber ) ; 
return false ; 
} 
return true ; 
} 
} 

public class EndConsumerHelper { 
public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { 
ObjectHelper . requireNonNull ( next , "next is null" ) ; 
if ( ! upstream . compareAndSet ( null , next ) ) { 
next . cancel ( ) ; 
if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) reportDoubleSubscription ( subscriber ) ; 
return false ; 
} 
return true ; 
} 
} 

public class BackpressureHelper { 
public static long addCap ( long a , long b ) { 
long u = a + b ; 
if ( u < 0L ) return Long . MAX_VALUE ; 
return u ; 
} 
} 

public class BackpressureHelper { 
public static long multiplyCap ( long a , long b ) { 
long u = a * b ; 
if ( ( ( a | b ) >>> 31 ) != 0 ) if ( u / a != b ) return Long . MAX_VALUE ; 
return u ; 
} 
} 

public class BackpressureHelper { 
public static long add ( AtomicLong requested , long n ) { 
for ( ; 
; 
) { 
long r = requested . get ( ) ; 
if ( r == Long . MAX_VALUE ) return Long . MAX_VALUE ; 
long u = addCap ( r , n ) ; 
if ( requested . compareAndSet ( r , u ) ) return r ; 
} 
} 
} 

public class SchedulerPoolFactory { 
public static void shutdown ( ) { 
ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; 
if ( exec != null ) exec . shutdownNow ( ) ; 
POOLS . clear ( ) ; 
} 
} 

public class SubscriptionArbiter { 
public final void setSubscription ( Subscription s ) { 
if ( cancelled ) { 
s . cancel ( ) ; 
return ; 
} 
ObjectHelper . requireNonNull ( s , "s is null" ) ; 
if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { 
Subscription a = actual ; 
if ( a != null && cancelOnReplace ) a . cancel ( ) ; 
actual = s ; 
long r = requested ; 
if ( decrementAndGet ( ) != 0 ) drainLoop ( ) ; 
if ( r != 0L ) s . request ( r ) ; 
return ; 
} 
Subscription a = missedSubscription . getAndSet ( s ) ; 
if ( a != null && cancelOnReplace ) a . cancel ( ) ; 
drain ( ) ; 
} 
} 

public class ExceptionHelper { 
public static RuntimeException wrapOrThrow ( Throwable error ) { 
if ( error instanceof Error ) throw ( Error ) error ; 
if ( error instanceof RuntimeException ) return ( RuntimeException ) error ; 
return new RuntimeException ( error ) ; 
} 
} 

public class ExceptionHelper { 
public static List < Throwable > flatten ( Throwable t ) { 
List < Throwable > list = new ArrayList < Throwable > ( ) ; 
ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; 
deque . offer ( t ) ; 
while ( ! deque . isEmpty ( ) ) { 
Throwable e = deque . removeFirst ( ) ; 
if ( e instanceof CompositeException ) { 
CompositeException ce = ( CompositeException ) e ; 
List < Throwable > exceptions = ce . getExceptions ( ) ; 
for ( int i = exceptions . size ( ) - 1 ; 
i >= 0 ; 
i -- ) deque . offerFirst ( exceptions . get ( i ) ) ; 
} 
else list . add ( e ) ; 
} 
return list ; 
} 
} 

public class ExceptionHelper { 
@ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { 
if ( e instanceof Exception ) return ( Exception ) e ; 
throw ( E ) e ; 
} 
} 

public class CompositeDisposable { 
public void clear ( ) { 
if ( disposed ) return ; 
OpenHashSet < Disposable > set ; 
synchronized ( this ) { 
if ( disposed ) return ; 
set = resources ; 
resources = null ; 
} 
dispose ( set ) ; 
} 
} 

public class CompositeDisposable { 
public int size ( ) { 
if ( disposed ) return 0 ; 
synchronized ( this ) { 
if ( disposed ) return 0 ; 
OpenHashSet < Disposable > set = resources ; 
return set != null ? set . size ( ) : 0 ; 
} 
} 
} 

public class ObservableScalarXMap { 
@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { 
if ( source instanceof Callable ) { 
T t ; 
try { 
t = ( ( Callable < T > ) source ) . call ( ) ; 
} 
catch ( Throwable ex ) { 
Exceptions . throwIfFatal ( ex ) ; 
EmptyDisposable . error ( ex , observer ) ; 
return true ; 
} 
if ( t == null ) { 
EmptyDisposable . complete ( observer ) ; 
return true ; 
} 
ObservableSource < ? extends R > r ; 
try { 
r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; 
} 
catch ( Throwable ex ) { 
Exceptions . throwIfFatal ( ex ) ; 
EmptyDisposable . error ( ex , observer ) ; 
return true ; 
} 
if ( r instanceof Callable ) { 
R u ; 
try { 
u = ( ( Callable < R > ) r ) . call ( ) ; 
} 
catch ( Throwable ex ) { 
Exceptions . throwIfFatal ( ex ) ; 
EmptyDisposable . error ( ex , observer ) ; 
return true ; 
} 
if ( u == null ) { 
EmptyDisposable . complete ( observer ) ; 
return true ; 
} 
ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; 
observer . onSubscribe ( sd ) ; 
sd . run ( ) ; 
} 
else r . subscribe ( observer ) ; 
return true ; 
} 
return false ; 
} 
} 

public class AppendOnlyLinkedArrayList { 
public < U > boolean accept ( Subscriber < ? super U > subscriber ) { 
Object [ ] a = head ; 
final int c = capacity ; 
while ( a != null ) { 
for ( int i = 0 ; 
i < c ; 
i ++ ) { 
Object o = a [ i ] ; 
if ( o == null ) break ; 
if ( NotificationLite . acceptFull ( o , subscriber ) ) return true ; 
} 
a = ( Object [ ] ) a [ c ] ; 
} 
return false ; 
} 
} 

public class AppendOnlyLinkedArrayList { 
public < U > boolean accept ( Observer < ? super U > observer ) { 
Object [ ] a = head ; 
final int c = capacity ; 
while ( a != null ) { 
for ( int i = 0 ; 
i < c ; 
i ++ ) { 
Object o = a [ i ] ; 
if ( o == null ) break ; 
if ( NotificationLite . acceptFull ( o , observer ) ) return true ; 
} 
a = ( Object [ ] ) a [ c ] ; 
} 
return false ; 
} 
} 

public class MulticastProcessor { 
public void start ( ) { 
if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) queue = new SpscArrayQueue < T > ( bufferSize ) ; 
} 
} 

public class MulticastProcessor { 
public void startUnbounded ( ) { 
if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; 
} 
} 

public class MulticastProcessor { 
public boolean offer ( T t ) { 
if ( once . get ( ) ) return false ; 
ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; 
if ( fusionMode == QueueSubscription . NONE ) if ( queue . offer ( t ) ) { 
drain ( ) ; 
return true ; 
} 
return false ; 
} 
} 

public class SerialDisposable { 
@ Nullable public Disposable get ( ) { 
Disposable d = resource . get ( ) ; 
if ( d == DisposableHelper . DISPOSED ) return Disposables . disposed ( ) ; 
return d ; 
} 
} 

public class DeferredScalarDisposable { 
public final void complete ( T value ) { 
int state = get ( ) ; 
if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) return ; 
Observer < ? super T > a = downstream ; 
if ( state == FUSED_EMPTY ) { 
this . value = value ; 
lazySet ( FUSED_READY ) ; 
a . onNext ( null ) ; 
} 
else { 
lazySet ( TERMINATED ) ; 
a . onNext ( value ) ; 
} 
if ( get ( ) != DISPOSED ) a . onComplete ( ) ; 
} 
} 

public class DeferredScalarDisposable { 
public final void complete ( ) { 
int state = get ( ) ; 
if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) return ; 
lazySet ( TERMINATED ) ; 
downstream . onComplete ( ) ; 
} 
} 

public class PerfAsyncConsumer { 
public PerfAsyncConsumer await ( int count ) { 
if ( count <= 1000 ) while ( getCount ( ) != 0 ) { 
} 
else try { 
await ( ) ; 
} 
catch ( InterruptedException ex ) { 
throw new RuntimeException ( ex ) ; 
} 
return this ; 
} 
} 

public class DefaultSubscriber { 
protected final void request ( long n ) { 
Subscription s = this . upstream ; 
if ( s != null ) s . request ( n ) ; 
} 
} 

public class PublishSubject { 
boolean add ( PublishDisposable < T > ps ) { 
for ( ; 
; 
) { 
PublishDisposable < T > [ ] a = subscribers . get ( ) ; 
if ( a == TERMINATED ) return false ; 
int n = a . length ; 
@ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; 
System . arraycopy ( a , 0 , b , 0 , n ) ; 
b [ n ] = ps ; 
if ( subscribers . compareAndSet ( a , b ) ) return true ; 
} 
} 
} 

public class PublishSubject { 
@ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { 
for ( ; 
; 
) { 
PublishDisposable < T > [ ] a = subscribers . get ( ) ; 
if ( a == TERMINATED || a == EMPTY ) return ; 
int n = a . length ; 
int j = - 1 ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) if ( a [ i ] == ps ) { 
j = i ; 
break ; 
} 
if ( j < 0 ) return ; 
PublishDisposable < T > [ ] b ; 
if ( n == 1 ) b = EMPTY ; 
else { 
b = new PublishDisposable [ n - 1 ] ; 
System . arraycopy ( a , 0 , b , 0 , j ) ; 
System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; 
} 
if ( subscribers . compareAndSet ( a , b ) ) return ; 
} 
} 
} 

public class HttpServiceMethod { 
static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { 
boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; 
boolean continuationWantsResponse = false ; 
boolean continuationBodyNullable = false ; 
Annotation [ ] annotations = method . getAnnotations ( ) ; 
Type adapterType ; 
if ( isKotlinSuspendFunction ) { 
Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; 
Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; 
if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { 
responseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; 
continuationWantsResponse = true ; 
} 
else { 
} 
adapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; 
annotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; 
} 
else adapterType = method . getGenericReturnType ( ) ; 
CallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; 
Type responseType = callAdapter . responseType ( ) ; 
if ( responseType == okhttp3 . Response . class ) throw methodError ( method , "'" + getRawType ( responseType ) . getName ( ) + "' is not a valid response body type. Did you mean ResponseBody?" ) ; 
if ( responseType == Response . class ) throw methodError ( method , "Response must include generic type (e.g., Response<String>)" ) ; 
if ( requestFactory . httpMethod . equals ( "HEAD" ) && ! Void . class . equals ( responseType ) ) throw methodError ( method , "HEAD method must use Void as response type." ) ; 
Converter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; 
okhttp3 . Call . Factory callFactory = retrofit . callFactory ; 
if ( ! isKotlinSuspendFunction ) return new CallAdapted < > ( requestFactory , callFactory , responseConverter , callAdapter ) ; 
else if ( continuationWantsResponse ) return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; 
else return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; 
} 
} 

public class NetworkBehavior { 
public void setDelay ( long amount , TimeUnit unit ) { 
if ( amount < 0 ) throw new IllegalArgumentException ( "Amount must be positive value." ) ; 
this . delayMs = unit . toMillis ( amount ) ; 
} 
} 

public class NetworkBehavior { 
public Response < ? > createErrorResponse ( ) { 
Response < ? > call ; 
try { 
call = errorFactory . call ( ) ; 
} 
catch ( Exception e ) { 
throw new IllegalStateException ( "Error factory threw an exception." , e ) ; 
} 
if ( call == null ) throw new IllegalStateException ( "Error factory returned null." ) ; 
if ( call . isSuccessful ( ) ) throw new IllegalStateException ( "Error factory returned successful response." ) ; 
return call ; 
} 
} 

public class FilterBasedLdapUserSearch { 
@ Override public DirContextOperations searchForUser ( String username ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; 
SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; 
template . setSearchControls ( searchControls ) ; 
try { 
return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { 
username } 
) ; 
} 
catch ( IncorrectResultSizeDataAccessException notFound ) { 
if ( notFound . getActualSize ( ) == 0 ) throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; 
throw notFound ; 
} 
} 
} 

public class SpringSecurityCoreVersion { 
private static void performVersionChecks ( String minSpringVersion ) { 
if ( minSpringVersion == null ) return ; 
String springVersion = SpringVersion . getVersion ( ) ; 
String version = getVersion ( ) ; 
if ( disableChecks ( springVersion , version ) ) return ; 
logger . info ( "You are running with Spring Security Core " + version ) ; 
if ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) < 0 ) logger . warn ( "**** You are advised to use Spring " + minSpringVersion + " or later with this version. You are running: " + springVersion ) ; 
} 
} 

public class SpringSecurityCoreVersion { 
private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { 
if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) return true ; 
return Boolean . getBoolean ( DISABLE_CHECKS ) ; 
} 
} 

public class SpringSecurityLdapTemplate { 
public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { 
String [ ] attributeNames = new String [ ] { 
attributeName } 
; 
Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; 
Set < String > result = new HashSet < > ( ) ; 
for ( Map < String , List < String > > map : multipleAttributeValues ) { 
List < String > values = map . get ( attributeName ) ; 
if ( values != null ) result . addAll ( values ) ; 
} 
return result ; 
} 
} 

public class SpringSecurityLdapTemplate { 
public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { 
Object [ ] encodedParams = new String [ params . length ] ; 
for ( int i = 0 ; 
i < params . length ; 
i ++ ) encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; 
String formattedFilter = MessageFormat . format ( filter , encodedParams ) ; 
logger . debug ( "Using filter: " + formattedFilter ) ; 
final HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; 
ContextMapper roleMapper = new ContextMapper ( ) { 
public Object mapFromContext ( Object ctx ) { 
DirContextAdapter adapter = ( DirContextAdapter ) ctx ; 
Map < String , List < String > > record = new HashMap < String , List < String > > ( ) ; 
if ( attributeNames == null || attributeNames . length == 0 ) try { 
for ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; 
ae . hasMore ( ) ; 
) { 
Attribute attr = ( Attribute ) ae . next ( ) ; 
extractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; 
} 
} 
catch ( NamingException x ) { 
org . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; 
} 
else for ( String attributeName : attributeNames ) { 
extractStringAttributeValues ( adapter , record , attributeName ) ; 
} 
record . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; 
set . add ( record ) ; 
return null ; 
} 
} 
; 
SearchControls ctls = new SearchControls ( ) ; 
ctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; 
ctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; 
search ( base , formattedFilter , ctls , roleMapper ) ; 
return set ; 
} 
} 

public class SpringSecurityLdapTemplate { 
public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { 
final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; 
final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; 
final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; 
Set < DirContextOperations > results = new HashSet < > ( ) ; 
try { 
while ( resultsEnum . hasMore ( ) ) { 
SearchResult searchResult = resultsEnum . next ( ) ; 
DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; 
Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Found DN: " + dca . getDn ( ) ) ; 
results . add ( dca ) ; 
} 
} 
catch ( PartialResultException e ) { 
LdapUtils . closeEnumeration ( resultsEnum ) ; 
logger . info ( "Ignoring PartialResultException" ) ; 
} 
if ( results . size ( ) == 0 ) throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; 
if ( results . size ( ) > 1 ) throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; 
return results . iterator ( ) . next ( ) ; 
} 
} 

public class BasicLookupStrategy { 
private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { 
Assert . notNull ( acls , "ACLs are required" ) ; 
Assert . notEmpty ( findNow , "Items to find now required" ) ; 
String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; 
Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { 
public void setValues ( PreparedStatement ps ) throws SQLException { 
int i = 0 ; 
for ( Long toFind : findNow ) { 
i ++ ; 
ps . setLong ( i , toFind ) ; 
} 
} 
} 
, new ProcessResultSet ( acls , sids ) ) ; 
if ( parentsToLookup . size ( ) > 0 ) lookupPrimaryKeys ( acls , parentsToLookup , sids ) ; 
} 
} 

public class J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource { 
public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { 
Collection < String > j2eeUserRoles = getUserRoles ( context ) ; 
Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; 
PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; 
return result ; 
} 
} 

public class LdapServerBeanDefinitionParser { 
private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { 
Object source = parserContext . extractSource ( element ) ; 
String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; 
if ( ! StringUtils . hasText ( suffix ) ) suffix = OPT_DEFAULT_ROOT_SUFFIX ; 
String port = element . getAttribute ( ATT_PORT ) ; 
if ( ! StringUtils . hasText ( port ) ) { 
port = getDefaultPort ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Using default port of " + port ) ; 
} 
String url = "ldap://127.0.0.1:" + port + "/" + suffix ; 
BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; 
contextSource . addConstructorArgValue ( url ) ; 
contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; 
contextSource . addPropertyValue ( "password" , "secret" ) ; 
RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; 
apacheContainer . setSource ( source ) ; 
apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; 
String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; 
if ( ! StringUtils . hasText ( ldifs ) ) ldifs = OPT_DEFAULT_LDIF_FILE ; 
apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; 
apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; 
logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; 
if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; 
parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; 
return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; 
} 
} 

public class HttpConfigurationBuilder { 
private void createServletApiFilter ( BeanReference authenticationManager ) { 
final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; 
final String DEF_SERVLET_API_PROVISION = "true" ; 
String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; 
if ( ! StringUtils . hasText ( provideServletApi ) ) provideServletApi = DEF_SERVLET_API_PROVISION ; 
if ( "true" . equals ( provideServletApi ) ) { 
servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; 
servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; 
} 
} 
} 

public class HttpConfigurationBuilder { 
private void createJaasApiFilter ( ) { 
final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; 
final String DEF_JAAS_API_PROVISION = "false" ; 
String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; 
if ( ! StringUtils . hasText ( provideJaasApi ) ) provideJaasApi = DEF_JAAS_API_PROVISION ; 
if ( "true" . equals ( provideJaasApi ) ) jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; 
} 
} 

public class AbstractSecurityWebApplicationInitializer { 
private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { 
String filterName = DEFAULT_FILTER_NAME ; 
DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; 
String contextAttribute = getWebApplicationContextAttribute ( ) ; 
if ( contextAttribute != null ) springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; 
registerFilter ( servletContext , true , filterName , springSecurityFilterChain ) ; 
} 
} 

public class JdbcTokenRepositoryImpl { 
public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { 
try { 
return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { 
public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { 
return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; 
} 
} 
, seriesId ) ; 
} 
catch ( EmptyResultDataAccessException zeroResults ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; 
} 
catch ( IncorrectResultSizeDataAccessException moreThanOne ) { 
logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; 
} 
catch ( DataAccessException e ) { 
logger . error ( "Failed to load token for series " + seriesId , e ) ; 
} 
return null ; 
} 
} 

public class AbstractPreAuthenticatedProcessingFilter { 
public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; 
if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; 
chain . doFilter ( request , response ) ; 
} 
} 

public class AbstractPreAuthenticatedProcessingFilter { 
protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { 
Object principal = getPreAuthenticatedPrincipal ( request ) ; 
if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) return false ; 
if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) return false ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; 
return true ; 
} 
} 

public class AbstractPreAuthenticatedProcessingFilter { 
private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { 
Authentication authResult ; 
Object principal = getPreAuthenticatedPrincipal ( request ) ; 
Object credentials = getPreAuthenticatedCredentials ( request ) ; 
if ( principal == null ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "No pre-authenticated principal found in request" ) ; 
return ; 
} 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; 
try { 
PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; 
authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; 
authResult = authenticationManager . authenticate ( authRequest ) ; 
successfulAuthentication ( request , response , authResult ) ; 
} 
catch ( AuthenticationException failed ) { 
unsuccessfulAuthentication ( request , response , failed ) ; 
if ( ! continueFilterChainOnUnsuccessfulAuthentication ) throw failed ; 
} 
} 
} 

public class OnCommittedResponseWrapper { 
private void checkContentLength ( long contentLengthToWrite ) { 
this . contentWritten += contentLengthToWrite ; 
boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; 
int bufferSize = getBufferSize ( ) ; 
boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; 
if ( isBodyFullyWritten || requiresFlush ) doOnResponseCommitted ( ) ; 
} 
} 

public class SimpleAuthorityMapper { 
public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { 
HashSet < GrantedAuthority > mapped = new HashSet < > ( authorities . size ( ) ) ; 
for ( GrantedAuthority authority : authorities ) { 
mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; 
} 
if ( defaultAuthority != null ) mapped . add ( defaultAuthority ) ; 
return mapped ; 
} 
} 

public class AbstractAuthenticationFilterConfigurer { 
protected final void updateAuthenticationDefaults ( ) { 
if ( loginProcessingUrl == null ) loginProcessingUrl ( loginPage ) ; 
if ( failureHandler == null ) failureUrl ( loginPage + "?error" ) ; 
final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; 
if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; 
} 
} 

public class AbstractAuthenticationFilterConfigurer { 
protected final void updateAccessDefaults ( B http ) { 
if ( permitAll ) PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; 
} 
} 

public class LdapUserDetailsMapper { 
protected String mapPassword ( Object passwordValue ) { 
if ( ! ( passwordValue instanceof String ) ) passwordValue = new String ( ( byte [ ] ) passwordValue ) ; 
return ( String ) passwordValue ; 
} 
} 

public class AbstractRememberMeServices { 
protected String extractRememberMeCookie ( HttpServletRequest request ) { 
Cookie [ ] cookies = request . getCookies ( ) ; 
if ( ( cookies == null ) || ( cookies . length == 0 ) ) return null ; 
for ( Cookie cookie : cookies ) { 
if ( cookieName . equals ( cookie . getName ( ) ) ) return cookie . getValue ( ) ; 
} 
return null ; 
} 
} 

public class AbstractRememberMeServices { 
protected String encodeCookie ( String [ ] cookieTokens ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < cookieTokens . length ; 
i ++ ) { 
try { 
sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
if ( i < cookieTokens . length - 1 ) sb . append ( DELIMITER ) ; 
} 
String value = sb . toString ( ) ; 
sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; 
while ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; 
return sb . toString ( ) ; 
} 
} 

public class AbstractRememberMeServices { 
protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { 
String cookieValue = encodeCookie ( tokens ) ; 
Cookie cookie = new Cookie ( cookieName , cookieValue ) ; 
cookie . setMaxAge ( maxAge ) ; 
cookie . setPath ( getCookiePath ( request ) ) ; 
if ( cookieDomain != null ) cookie . setDomain ( cookieDomain ) ; 
if ( maxAge < 1 ) cookie . setVersion ( 1 ) ; 
if ( useSecureCookie == null ) cookie . setSecure ( request . isSecure ( ) ) ; 
else cookie . setSecure ( useSecureCookie ) ; 
cookie . setHttpOnly ( true ) ; 
response . addCookie ( cookie ) ; 
} 
} 

public class CurrentSecurityContextArgumentResolver { 
@ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { 
ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; 
Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; 
if ( reactiveSecurityContext == null ) return null ; 
return reactiveSecurityContext . flatMap ( a -> { 
Object p = resolveSecurityContext ( parameter , a ) ; 
Mono < Object > o = Mono . justOrEmpty ( p ) ; 
return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; 
} 
) ; 
} 
} 

public class DefaultServiceAuthenticationDetails { 
private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { 
final String query = request . getQueryString ( ) ; 
if ( query == null ) return null ; 
final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; 
if ( result . length ( ) == 0 ) return null ; 
return result . startsWith ( "&" ) ? result . substring ( 1 ) : result ; 
} 
} 

public class DefaultServiceAuthenticationDetails { 
private static int getServicePort ( URL casServiceUrl ) { 
int port = casServiceUrl . getPort ( ) ; 
if ( port == - 1 ) port = casServiceUrl . getDefaultPort ( ) ; 
return port ; 
} 
} 

public class SpringSecurityAuthenticationSource { 
public String getPrincipal ( ) { 
Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; 
if ( authentication == null ) { 
log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; 
return "" ; 
} 
Object principal = authentication . getPrincipal ( ) ; 
if ( principal instanceof LdapUserDetails ) { 
LdapUserDetails details = ( LdapUserDetails ) principal ; 
return details . getDn ( ) ; 
} 
else if ( authentication instanceof AnonymousAuthenticationToken ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; 
return "" ; 
} 
else throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; 
} 
} 

public class AbstractJaasAuthenticationProvider { 
public Authentication authenticate ( Authentication auth ) throws AuthenticationException { 
if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) return null ; 
UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; 
Set < GrantedAuthority > authorities ; 
try { 
LoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; 
loginContext . login ( ) ; 
authorities = new HashSet < > ( ) ; 
Set < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; 
for ( Principal principal : principals ) { 
for ( AuthorityGranter granter : this . authorityGranters ) { 
Set < String > roles = granter . grant ( principal ) ; 
if ( ( roles != null ) && ! roles . isEmpty ( ) ) for ( String role : roles ) { 
authorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; 
} 
} 
} 
JaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList < > ( authorities ) , loginContext ) ; 
publishSuccessEvent ( result ) ; 
return result ; 
} 
catch ( LoginException loginException ) { 
AuthenticationException ase = this . loginExceptionResolver . resolveException ( loginException ) ; 
publishFailureEvent ( request , ase ) ; 
throw ase ; 
} 
} 
} 

public class DefaultSpringSecurityContextSource { 
private static String buildProviderUrl ( List < String > urls , String baseDn ) { 
Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; 
Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; 
String trimmedBaseDn = baseDn . trim ( ) ; 
StringBuilder providerUrl = new StringBuilder ( ) ; 
for ( String serverUrl : urls ) { 
String trimmedUrl = serverUrl . trim ( ) ; 
if ( "" . equals ( trimmedUrl ) ) continue ; 
providerUrl . append ( trimmedUrl ) ; 
if ( ! trimmedUrl . endsWith ( "/" ) ) providerUrl . append ( "/" ) ; 
providerUrl . append ( trimmedBaseDn ) ; 
providerUrl . append ( " " ) ; 
} 
return providerUrl . toString ( ) ; 
} 
} 

public class JspAuthorizeTag { 
public int doEndTag ( ) throws JspException { 
try { 
if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; 
} 
catch ( IOException e ) { 
throw new JspException ( e ) ; 
} 
return EVAL_PAGE ; 
} 
} 

public class UserDetailsServiceFactoryBean { 
private UserDetailsService getUserDetailsService ( ) { 
Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; 
if ( beans . size ( ) == 0 ) beans = getBeansOfType ( UserDetailsService . class ) ; 
if ( beans . size ( ) == 0 ) throw new ApplicationContextException ( "No UserDetailsService registered." ) ; 
else if ( beans . size ( ) > 1 ) throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; 
return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; 
} 
} 

public class CasAuthenticationFilter { 
protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { 
final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; 
final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "requiresAuthentication = " + result ) ; 
return result ; 
} 
} 

public class CasAuthenticationFilter { 
private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { 
boolean result = super . requiresAuthentication ( request , response ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "serviceTicketRequest = " + result ) ; 
return result ; 
} 
} 

public class CasAuthenticationFilter { 
private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { 
if ( serviceTicketRequest ) return false ; 
final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "proxyTicketRequest = " + result ) ; 
return result ; 
} 
} 

public class CasAuthenticationFilter { 
private boolean proxyReceptorRequest ( final HttpServletRequest request ) { 
final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "proxyReceptorRequest = " + result ) ; 
return result ; 
} 
} 

public class WebSpherePreAuthenticatedWebAuthenticationDetailsSource { 
private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { 
List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; 
Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; 
return userGas ; 
} 
} 

public class WebSpherePreAuthenticatedProcessingFilter { 
protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { 
Object principal = wasHelper . getCurrentUserName ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; 
return principal ; 
} 
} 

public class MapBasedAttributes2GrantedAuthoritiesMapper { 
public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { 
ArrayList < GrantedAuthority > gaList = new ArrayList < > ( ) ; 
for ( String attribute : attributes ) { 
Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; 
if ( c != null ) gaList . addAll ( c ) ; 
} 
gaList . trimToSize ( ) ; 
return gaList ; 
} 
} 

public class MapBasedAttributes2GrantedAuthoritiesMapper { 
private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { 
if ( value == null ) return ; 
if ( value instanceof Collection < ? > ) addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; 
else if ( value instanceof Object [ ] ) addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; 
else if ( value instanceof String ) addGrantedAuthorityCollection ( result , ( String ) value ) ; 
else if ( value instanceof GrantedAuthority ) result . add ( ( GrantedAuthority ) value ) ; 
else throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; 
} 
} 

public class J2eePreAuthenticatedProcessingFilter { 
protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { 
Object principal = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; 
return principal ; 
} 
} 

public class UrlAuthorizationConfigurer { 
private static String [ ] hasAnyRole ( String ... roles ) { 
for ( int i = 0 ; 
i < roles . length ; 
i ++ ) roles [ i ] = "ROLE_" + roles [ i ] ; 
return roles ; 
} 
} 

public class PersistentTokenBasedRememberMeServices { 
protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { 
if ( cookieTokens . length != 2 ) throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; 
final String presentedSeries = cookieTokens [ 0 ] ; 
final String presentedToken = cookieTokens [ 1 ] ; 
PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; 
if ( token == null ) throw new RememberMeAuthenticationException ( "No persistent token found for series id: " + presentedSeries ) ; 
if ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { 
tokenRepository . removeUserTokens ( token . getUsername ( ) ) ; 
throw new CookieTheftException ( messages . getMessage ( "PersistentTokenBasedRememberMeServices.cookieStolen" , "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack." ) ) ; 
} 
if ( token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L < System . currentTimeMillis ( ) ) throw new RememberMeAuthenticationException ( "Remember-me login has expired" ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Refreshing persistent login token for user '" + token . getUsername ( ) + "', series '" + token . getSeries ( ) + "'" ) ; 
PersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; 
try { 
tokenRepository . updateToken ( newToken . getSeries ( ) , newToken . getTokenValue ( ) , newToken . getDate ( ) ) ; 
addCookie ( newToken , request , response ) ; 
} 
catch ( Exception e ) { 
logger . error ( "Failed to update token: " , e ) ; 
throw new RememberMeAuthenticationException ( "Autologin failed due to data access problem" ) ; 
} 
return getUserDetailsService ( ) . loadUserByUsername ( token . getUsername ( ) ) ; 
} 
} 

public class SwitchUserFilter { 
protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { 
UsernamePasswordAuthenticationToken targetUserRequest ; 
String username = request . getParameter ( this . usernameParameter ) ; 
if ( username == null ) username = "" ; 
if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; 
UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; 
this . userDetailsChecker . check ( targetUser ) ; 
targetUserRequest = createSwitchUserToken ( request , targetUser ) ; 
if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( "Switch User Token [" + targetUserRequest + "]" ) ; 
if ( this . eventPublisher != null ) this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) , targetUser ) ) ; 
return targetUserRequest ; 
} 
} 

public class SwitchUserFilter { 
protected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { 
Authentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; 
if ( null == current ) throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noCurrentUser" , "No current user associated with this request" ) ) ; 
Authentication original = getSourceAuthentication ( current ) ; 
if ( original == null ) { 
this . logger . debug ( "Could not find original user Authentication object!" ) ; 
throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noOriginalAuthentication" , "Could not find original Authentication object" ) ) ; 
} 
UserDetails originalUser = null ; 
Object obj = original . getPrincipal ( ) ; 
if ( ( obj != null ) && obj instanceof UserDetails ) originalUser = ( UserDetails ) obj ; 
if ( this . eventPublisher != null ) this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( current , originalUser ) ) ; 
return original ; 
} 
} 

public class AbstractAuthorizeTag { 
public boolean authorizeUsingAccessExpression ( ) throws IOException { 
if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) return false ; 
SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; 
Expression accessExpression ; 
try { 
accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; 
} 
catch ( ParseException e ) { 
IOException ioException = new IOException ( ) ; 
ioException . initCause ( e ) ; 
throw ioException ; 
} 
return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; 
} 
} 

public class SecurityExpressionRoot { 
private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { 
if ( role == null ) return role ; 
if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) return role ; 
if ( role . startsWith ( defaultRolePrefix ) ) return role ; 
return defaultRolePrefix + role ; 
} 
} 

public class LdapAuthority { 
public List < String > getAttributeValues ( String name ) { 
List < String > result = null ; 
if ( attributes != null ) result = attributes . get ( name ) ; 
if ( result == null ) result = Collections . emptyList ( ) ; 
return result ; 
} 
} 

public class LdapAuthority { 
public String getFirstAttributeValue ( String name ) { 
List < String > result = getAttributeValues ( name ) ; 
if ( result . isEmpty ( ) ) return null ; 
else return result . get ( 0 ) ; 
} 
} 

public class AddDeleteContactController { 
@ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { 
validator . validate ( form , result ) ; 
if ( result . hasErrors ( ) ) return "add" ; 
Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; 
contactManager . create ( contact ) ; 
return "redirect:/secure/index.htm" ; 
} 
} 

public class MapBasedMethodSecurityMetadataSource { 
@ Override protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { 
if ( targetClass == null ) return null ; 
return findAttributesSpecifiedAgainst ( method , targetClass ) ; 
} 
} 

public class MapBasedMethodSecurityMetadataSource { 
private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { 
Assert . notNull ( method , "RegisteredMethod required" ) ; 
Assert . notNull ( attr , "Configuration attribute required" ) ; 
if ( logger . isInfoEnabled ( ) ) logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; 
this . methodMap . put ( method , attr ) ; 
} 
} 

public class BindAuthenticator { 
protected void handleBindException ( String userDn , String username , Throwable cause ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; 
} 
} 

public class SimpleUrlAuthenticationSuccessHandler { 
protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { 
HttpSession session = request . getSession ( false ) ; 
if ( session == null ) return ; 
session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; 
} 
} 

public class FieldUtils { 
public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { 
Assert . notNull ( clazz , "Class required" ) ; 
Assert . hasText ( fieldName , "Field name required" ) ; 
try { 
return clazz . getDeclaredField ( fieldName ) ; 
} 
catch ( NoSuchFieldException nsf ) { 
if ( clazz . getSuperclass ( ) != null ) return getField ( clazz . getSuperclass ( ) , fieldName ) ; 
throw new IllegalStateException ( "Could not locate field '" + fieldName + "' on class " + clazz ) ; 
} 
} 
} 

public class LdapShaPasswordEncoder { 
private String extractPrefix ( String encPass ) { 
if ( ! encPass . startsWith ( "{" ) ) return null ; 
int secondBrace = encPass . lastIndexOf ( '}' ) ; 
if ( secondBrace < 0 ) throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; 
return encPass . substring ( 0 , secondBrace + 1 ) ; 
} 
} 

public class Http403ForbiddenEntryPoint { 
public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; 
response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; 
} 
} 

public class GlobalMethodSecurityBeanDefinitionParser { 
@ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { 
BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; 
ManagedList voters = new ManagedList ( 4 ) ; 
if ( expressionVoter != null ) voters . add ( expressionVoter ) ; 
voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; 
voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; 
if ( jsr250Enabled ) voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; 
accessMgrBuilder . addConstructorArgValue ( voters ) ; 
BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; 
String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; 
pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; 
return id ; 
} 
} 

public class StandardPasswordEncoder { 
private boolean matches ( byte [ ] expected , byte [ ] actual ) { 
if ( expected . length != actual . length ) return false ; 
int result = 0 ; 
for ( int i = 0 ; 
i < expected . length ; 
i ++ ) result |= expected [ i ] ^ actual [ i ] ; 
return result == 0 ; 
} 
} 

public class UrlUtils { 
private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { 
StringBuilder url = new StringBuilder ( ) ; 
if ( servletPath != null ) { 
url . append ( servletPath ) ; 
if ( pathInfo != null ) url . append ( pathInfo ) ; 
} 
else url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; 
if ( queryString != null ) url . append ( "?" ) . append ( queryString ) ; 
return url . toString ( ) ; 
} 
} 

public class UrlUtils { 
public static boolean isAbsoluteUrl ( String url ) { 
if ( url == null ) return false ; 
final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; 
return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; 
} 
} 

public class RegexBasedAxFetchListFactory { 
public List < OpenIDAttribute > createAttributeList ( String identifier ) { 
for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { 
if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) return entry . getValue ( ) ; 
} 
return Collections . emptyList ( ) ; 
} 
} 

public class AclClassIdUtils { 
Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { 
if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; 
else identifier = convertToLong ( identifier ) ; 
return identifier ; 
} 
} 

public class JdbcMutableAclService { 
protected void createEntries ( final MutableAcl acl ) { 
if ( acl . getEntries ( ) . isEmpty ( ) ) return ; 
jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { 
public int getBatchSize ( ) { 
return acl . getEntries ( ) . size ( ) ; 
} 
public void setValues ( PreparedStatement stmt , int i ) throws SQLException { 
AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; 
Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; 
AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; 
stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; 
stmt . setInt ( 2 , i ) ; 
stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; 
stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; 
stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; 
stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; 
stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; 
} 
} 
) ; 
} 
} 

public class JdbcMutableAclService { 
protected void updateObjectIdentity ( MutableAcl acl ) { 
Long parentId = null ; 
if ( acl . getParentAcl ( ) != null ) { 
Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; 
ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; 
parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; 
} 
Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; 
Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; 
int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; 
if ( count != 1 ) throw new NotFoundException ( "Unable to locate ACL to update" ) ; 
} 
} 

public class HttpSessionRequestCache { 
public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { 
if ( requestMatcher . matches ( request ) ) { 
DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; 
if ( createSessionAllowed || request . getSession ( false ) != null ) { 
request . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; 
logger . debug ( "DefaultSavedRequest added to Session: " + savedRequest ) ; 
} 
} 
else logger . debug ( "Request not saved as configured RequestMatcher did not match" ) ; 
} 
} 

public class XFrameOptionsHeaderWriter { 
public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { 
if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { 
String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; 
if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; 
else if ( allowFromValue != null ) if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; 
} 
else response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; 
} 
} 

public class AbstractAuthenticationTargetUrlRequestHandler { 
protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { 
if ( isAlwaysUseDefaultTargetUrl ( ) ) return defaultTargetUrl ; 
String targetUrl = null ; 
if ( targetUrlParameter != null ) { 
targetUrl = request . getParameter ( targetUrlParameter ) ; 
if ( StringUtils . hasText ( targetUrl ) ) { 
logger . debug ( "Found targetUrlParameter in request: " + targetUrl ) ; 
return targetUrl ; 
} 
} 
if ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { 
targetUrl = request . getHeader ( "Referer" ) ; 
logger . debug ( "Using Referer header: " + targetUrl ) ; 
} 
if ( ! StringUtils . hasText ( targetUrl ) ) { 
targetUrl = defaultTargetUrl ; 
logger . debug ( "Using default Url: " + targetUrl ) ; 
} 
return targetUrl ; 
} 
} 

public class AbstractAuthenticationTargetUrlRequestHandler { 
public void setTargetUrlParameter ( String targetUrlParameter ) { 
if ( targetUrlParameter != null ) Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; 
this . targetUrlParameter = targetUrlParameter ; 
} 
} 

public class DocumentDaoImpl { 
private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { 
return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { 
id } 
, new RowMapper < Directory > ( ) { 
public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { 
Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; 
Directory parentDirectory = Directory . ROOT_DIRECTORY ; 
if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) parentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; 
Directory directory = new Directory ( rs . getString ( "directory_name" ) , parentDirectory ) ; 
FieldUtils . setProtectedFieldValue ( "id" , directory , new Long ( rs . getLong ( "id" ) ) ) ; 
return directory ; 
} 
} 
) ; 
} 
} 

public class JaasAuthenticationProvider { 
private void configureJaasUsingLoop ( ) throws IOException { 
String loginConfigUrl = convertLoginConfigToUrl ( ) ; 
boolean alreadySet = false ; 
int n = 1 ; 
final String prefix = "login.config.url." ; 
String existing ; 
while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { 
alreadySet = existing . equals ( loginConfigUrl ) ; 
if ( alreadySet ) break ; 
n ++ ; 
} 
if ( ! alreadySet ) { 
String key = prefix + n ; 
log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; 
Security . setProperty ( key , loginConfigUrl ) ; 
} 
} 
} 

public class FastHttpDateFormat { 
public static String getCurrentDate ( ) { 
long now = System . currentTimeMillis ( ) ; 
if ( ( now - currentDateGenerated ) > 1000 ) synchronized ( format ) { 
if ( ( now - currentDateGenerated ) > 1000 ) { 
currentDateGenerated = now ; 
currentDate = format . format ( new Date ( now ) ) ; 
} 
} 
return currentDate ; 
} 
} 

public class FastHttpDateFormat { 
private static Long internalParseDate ( String value , DateFormat [ ] formats ) { 
Date date = null ; 
for ( int i = 0 ; 
( date == null ) && ( i < formats . length ) ; 
i ++ ) try { 
date = formats [ i ] . parse ( value ) ; 
} 
catch ( ParseException ignored ) { 
} 
if ( date == null ) return null ; 
return new Long ( date . getTime ( ) ) ; 
} 
} 

public class FastHttpDateFormat { 
@ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object value ) { 
if ( value == null ) return ; 
if ( cache . size ( ) > 1000 ) cache . clear ( ) ; 
cache . put ( key , value ) ; 
} 
} 

public class DefaultWASUsernameAndGroupsExtractor { 
private static String getSecurityName ( final Subject subject ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Determining Websphere security name for subject " + subject ) ; 
String userSecurityName = null ; 
if ( subject != null ) { 
Object credential = subject . getPublicCredentials ( getWSCredentialClass ( ) ) . iterator ( ) . next ( ) ; 
if ( credential != null ) userSecurityName = ( String ) invokeMethod ( getSecurityNameMethod ( ) , credential ) ; 
} 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Websphere security name is " + userSecurityName + " for subject " + subject ) ; 
return userSecurityName ; 
} 
} 

public class DefaultWASUsernameAndGroupsExtractor { 
@ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String securityName ) { 
Context ic = null ; 
try { 
ic = new InitialContext ( ) ; 
Object objRef = ic . lookup ( USER_REGISTRY ) ; 
Object userReg = invokeMethod ( getNarrowMethod ( ) , null , objRef , Class . forName ( "com.ibm.websphere.security.UserRegistry" ) ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Determining WebSphere groups for user " + securityName + " using WebSphere UserRegistry " + userReg ) ; 
final Collection groups = ( Collection ) invokeMethod ( getGroupsForUserMethod ( ) , userReg , new Object [ ] { 
securityName } 
) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Groups for user " + securityName + ": " + groups . toString ( ) ) ; 
return new ArrayList ( groups ) ; 
} 
catch ( Exception e ) { 
logger . error ( "Exception occured while looking up groups for user" , e ) ; 
throw new RuntimeException ( "Exception occured while looking up groups for user" , e ) ; 
} 
finally { 
try { 
if ( ic != null ) ic . close ( ) ; 
} 
catch ( NamingException e ) { 
logger . debug ( "Exception occured while closing context" , e ) ; 
} 
} 
} 
} 

public class LdapUserDetailsManager { 
public void changePassword ( final String oldPassword , final String newPassword ) { 
Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; 
Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; 
String username = authentication . getName ( ) ; 
logger . debug ( "Changing password for user '" + username ) ; 
DistinguishedName userDn = usernameMapper . buildDn ( username ) ; 
if ( usePasswordModifyExtensionOperation ) changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; 
else changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; 
} 
} 

public class ConcurrentSessionControlAuthenticationStrategy { 
protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { 
if ( exceptionIfMaximumExceeded || ( sessions == null ) ) throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { 
Integer . valueOf ( allowableSessions ) } 
, "Maximum sessions of {0} for this principal exceeded" ) ) ; 
SessionInformation leastRecentlyUsed = null ; 
for ( SessionInformation session : sessions ) { 
if ( ( leastRecentlyUsed == null ) || session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) leastRecentlyUsed = session ; 
} 
leastRecentlyUsed . expireNow ( ) ; 
} 
} 

public class FilterChainProxy { 
private List < Filter > getFilters ( HttpServletRequest request ) { 
for ( SecurityFilterChain chain : filterChains ) { 
if ( chain . matches ( request ) ) return chain . getFilters ( ) ; 
} 
return null ; 
} 
} 

public class LdapUtils { 
public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { 
DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; 
if ( dn . contains ( baseDn ) ) return dn ; 
baseDn . append ( dn ) ; 
return baseDn ; 
} 
} 

public class RestAssured { 
public static void filters ( Filter filter , Filter ... additionalFilters ) { 
Validate . notNull ( filter , "Filter cannot be null" ) ; 
RestAssured . filters . add ( filter ) ; 
if ( additionalFilters != null ) Collections . addAll ( RestAssured . filters , additionalFilters ) ; 
} 
} 

public class RestAssured { 
public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { 
if ( userName == null ) throw new IllegalArgumentException ( "Username cannot be null" ) ; 
if ( password == null ) throw new IllegalArgumentException ( "Password cannot be null" ) ; 
final FormAuthScheme scheme = new FormAuthScheme ( ) ; 
scheme . setUserName ( userName ) ; 
scheme . setPassword ( password ) ; 
scheme . setConfig ( config ) ; 
return scheme ; 
} 
} 

public class RestAssured { 
public static void proxy ( URI uri ) { 
if ( uri == null ) throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; 
proxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; 
} 
} 

public class ResponsePrinter { 
public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { 
final StringBuilder builder = new StringBuilder ( ) ; 
if ( logDetail == ALL || logDetail == STATUS ) builder . append ( responseOptions . statusLine ( ) ) ; 
if ( logDetail == ALL || logDetail == HEADERS ) { 
final Headers headers = responseOptions . headers ( ) ; 
if ( headers . exist ( ) ) appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; 
} 
else if ( logDetail == COOKIES ) { 
final Cookies cookies = responseOptions . detailedCookies ( ) ; 
if ( cookies . exist ( ) ) appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; 
} 
if ( logDetail == ALL || logDetail == BODY ) { 
String responseBodyToAppend ; 
if ( shouldPrettyPrint ) responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; 
else responseBodyToAppend = responseBody . asString ( ) ; 
if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; 
builder . append ( responseBodyToAppend ) ; 
} 
String response = builder . toString ( ) ; 
stream . println ( response ) ; 
return response ; 
} 
} 

public class MultiPartSpecBuilder { 
public MultiPartSpecBuilder header ( String name , String value ) { 
Validate . notEmpty ( name , "Header name cannot be empty" ) ; 
Validate . notEmpty ( value , "Header value cannot be empty" ) ; 
final Set < String > headerNames = headers . keySet ( ) ; 
final String trimmedName = name . trim ( ) ; 
for ( String headerName : headerNames ) { 
if ( headerName . equalsIgnoreCase ( trimmedName ) ) headers . remove ( headerName ) ; 
} 
headers . put ( name , value ) ; 
return this ; 
} 
} 

public class Headers { 
public static Headers headers ( Header header , Header ... additionalHeaders ) { 
notNull ( header , "Header" ) ; 
final List < Header > headerList = new LinkedList < Header > ( ) ; 
headerList . add ( header ) ; 
if ( additionalHeaders != null ) Collections . addAll ( headerList , additionalHeaders ) ; 
return new Headers ( headerList ) ; 
} 
} 

public class ResponseBuilder { 
public ResponseBuilder setHeader ( String name , String value ) { 
notNull ( name , "Header name" ) ; 
notNull ( value , "Header value" ) ; 
List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; 
newHeaders . add ( new Header ( name , value ) ) ; 
restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; 
if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) restAssuredResponse . setContentType ( value ) ; 
return this ; 
} 
} 

public class ResponseBuilder { 
public Response build ( ) { 
final int statusCode = restAssuredResponse . statusCode ( ) ; 
if ( statusCode < 100 || statusCode >= 600 ) throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; 
if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; 
restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; 
return restAssuredResponse ; 
} 
} 

public class HttpRequestFactory { 
static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { 
String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; 
Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; 
final HttpRequestBase httpRequest ; 
if ( type == null || ( ! ( type . isInstance ( HttpEntityEnclosingRequest . class ) ) && hasBody ) ) httpRequest = new CustomHttpMethod ( method , uri ) ; 
else { 
try { 
httpRequest = type . newInstance ( ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
httpRequest . setURI ( uri ) ; 
} 
return httpRequest ; 
} 
} 

public class JsonPath { 
public int getInt ( String path ) { 
Object value = get ( path ) ; 
if ( value instanceof Integer ) return ( Integer ) value ; 
else if ( value instanceof Short ) return ( ( Short ) value ) . intValue ( ) ; 
else if ( value instanceof Long ) return ( ( Long ) value ) . intValue ( ) ; 
else return ObjectConverter . convertObjectTo ( value , Integer . class ) ; 
} 
} 

public class JsonPath { 
public byte getByte ( String path ) { 
Object value = get ( path ) ; 
if ( value instanceof Byte ) return ( Byte ) value ; 
else if ( value instanceof Long ) return ( ( Long ) value ) . byteValue ( ) ; 
else if ( value instanceof Integer ) return ( ( Integer ) value ) . byteValue ( ) ; 
else return ObjectConverter . convertObjectTo ( value , Byte . class ) ; 
} 
} 

public class JsonPath { 
public short getShort ( String path ) { 
Object value = get ( path ) ; 
if ( value instanceof Short ) return ( Short ) value ; 
else if ( value instanceof Long ) return ( ( Long ) value ) . shortValue ( ) ; 
else if ( value instanceof Integer ) return ( ( Integer ) value ) . shortValue ( ) ; 
else return ObjectConverter . convertObjectTo ( value , Short . class ) ; 
} 
} 

public class JsonPath { 
public float getFloat ( String path ) { 
final Object value = get ( path ) ; 
if ( value instanceof Double ) return ( ( Double ) value ) . floatValue ( ) ; 
else return ObjectConverter . convertObjectTo ( value , Float . class ) ; 
} 
} 

public class JsonPath { 
public double getDouble ( String path ) { 
final Object value = get ( path ) ; 
if ( value instanceof Double ) return ( Double ) value ; 
return ObjectConverter . convertObjectTo ( value , Double . class ) ; 
} 
} 

public class JsonPath { 
public long getLong ( String path ) { 
Object value = get ( path ) ; 
if ( value instanceof Long ) return ( Long ) value ; 
else if ( value instanceof Short ) return ( ( Short ) value ) . longValue ( ) ; 
else if ( value instanceof Integer ) return ( ( Integer ) value ) . longValue ( ) ; 
else return ObjectConverter . convertObjectTo ( value , Long . class ) ; 
} 
} 

public class JsonPath { 
public < T > List < T > getList ( String path , Class < T > genericType ) { 
if ( genericType == null ) throw new IllegalArgumentException ( "Generic type cannot be null" ) ; 
final List < T > original = get ( path ) ; 
final List < T > newList = new LinkedList < T > ( ) ; 
if ( original != null ) for ( T t : original ) { 
T e ; 
if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) { 
String str = objectToString ( t ) ; 
e = ( T ) jsonStringToObject ( str , genericType ) ; 
} 
else e = ObjectConverter . convertObjectTo ( t , genericType ) ; 
newList . add ( e ) ; 
} 
return Collections . unmodifiableList ( newList ) ; 
} 
} 

public class WeakKeySet { 
private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { 
synchronized ( lock ) { 
for ( KeyAndSource keyAndSource : keysAndSources ) { 
Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; 
if ( set != null ) { 
set . remove ( keyAndSource . source ) ; 
if ( set . isEmpty ( ) ) backingMap . remove ( keyAndSource . key ) ; 
} 
} 
} 
} 
} 

public class InjectorImpl { 
< T > BindingImpl < T > getBindingOrThrow ( Key < T > key , Errors errors , JitLimitation jitType ) throws ErrorsException { 
BindingImpl < T > binding = state . getExplicitBinding ( key ) ; 
if ( binding != null ) return binding ; 
return getJustInTimeBinding ( key , errors , jitType ) ; 
} 
} 

public class InjectorImpl { 
private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { 
Key < String > stringKey = key . ofType ( STRING_TYPE ) ; 
BindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; 
if ( stringBinding == null || ! stringBinding . isConstant ( ) ) return null ; 
@ SuppressWarnings ( "unchecked" ) String stringValue = ( ( InstanceBinding < String > ) stringBinding ) . getInstance ( ) ; 
Object source = stringBinding . getSource ( ) ; 
TypeLiteral < T > type = key . getTypeLiteral ( ) ; 
TypeConverterBinding typeConverterBinding = state . getConverter ( stringValue , type , errors , source ) ; 
if ( typeConverterBinding == null ) return null ; 
try { 
@ SuppressWarnings ( "unchecked" ) T converted = ( T ) typeConverterBinding . getTypeConverter ( ) . convert ( stringValue , type ) ; 
if ( converted == null ) throw errors . converterReturnedNull ( stringValue , source , type , typeConverterBinding ) . toException ( ) ; 
if ( ! type . getRawType ( ) . isInstance ( converted ) ) throw errors . conversionTypeError ( stringValue , source , type , typeConverterBinding , converted ) . toException ( ) ; 
return new ConvertedConstantBindingImpl < T > ( this , key , converted , stringBinding , typeConverterBinding ) ; 
} 
catch ( ErrorsException e ) { 
throw e ; 
} 
catch ( RuntimeException e ) { 
throw errors . conversionError ( stringValue , source , type , typeConverterBinding , e ) . toException ( ) ; 
} 
} 
} 

public class InjectorImpl { 
private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { 
boolean bindingFailed = false ; 
Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; 
for ( Dependency dep : deps ) { 
Key < ? > depKey = dep . getKey ( ) ; 
InjectionPoint ip = dep . getInjectionPoint ( ) ; 
if ( encountered . add ( depKey ) ) { 
BindingImpl depBinding = jitBindings . get ( depKey ) ; 
if ( depBinding != null ) { 
boolean failed = cleanup ( depBinding , encountered ) ; 
if ( depBinding instanceof ConstructorBindingImpl ) { 
ConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; 
ip = ctorBinding . getInternalConstructor ( ) ; 
if ( ! ctorBinding . isInitialized ( ) ) failed = true ; 
} 
if ( failed ) { 
removeFailedJitBinding ( depBinding , ip ) ; 
bindingFailed = true ; 
} 
} 
else if ( state . getExplicitBinding ( depKey ) == null ) bindingFailed = true ; 
} 
} 
return bindingFailed ; 
} 
} 

public class InjectorImpl { 
private void removeFailedJitBinding ( Binding < ? > binding , InjectionPoint ip ) { 
failedJitBindings . add ( binding . getKey ( ) ) ; 
jitBindings . remove ( binding . getKey ( ) ) ; 
membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; 
provisionListenerStore . remove ( binding ) ; 
if ( ip != null ) constructors . remove ( ip ) ; 
} 
} 

public class InjectorImpl { 
@ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { 
if ( binding instanceof ConstructorBindingImpl ) return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; 
else if ( binding instanceof HasDependencies ) return ( ( HasDependencies ) binding ) . getDependencies ( ) ; 
else return ImmutableSet . of ( ) ; 
} 
} 

public class InjectorImpl { 
< T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { 
Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; 
ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; 
if ( rawType . isArray ( ) || ( rawType . isEnum ( ) && implementedBy != null ) ) throw errors . missingImplementationWithHint ( key , this ) . toException ( ) ; 
if ( rawType == TypeLiteral . class ) { 
@ SuppressWarnings ( "unchecked" ) BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; 
return binding ; 
} 
if ( implementedBy != null ) { 
Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; 
return createImplementedByBinding ( key , scoping , implementedBy , errors ) ; 
} 
ProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; 
if ( providedBy != null ) { 
Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; 
return createProvidedByBinding ( key , scoping , providedBy , errors ) ; 
} 
return ConstructorBindingImpl . create ( this , key , null , source , scoping , errors , jitBinding && options . jitDisabled , options . atInjectRequired ) ; 
} 
} 

public class SingleParameterInjector { 
static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { 
if ( parameterInjectors == null ) return NO_ARGUMENTS ; 
int size = parameterInjectors . length ; 
Object [ ] parameters = new Object [ size ] ; 
for ( int i = 0 ; 
i < size ; 
i ++ ) parameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; 
return parameters ; 
} 
} 

public class InjectionPoint { 
private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { 
Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; 
if ( misplacedBindingAnnotation == null ) return false ; 
if ( member instanceof Method ) try { 
if ( member . getDeclaringClass ( ) . getDeclaredField ( member . getName ( ) ) != null ) return false ; 
} 
catch ( NoSuchFieldException ignore ) { 
} 
errors . misplacedBindingAnnotation ( member , misplacedBindingAnnotation ) ; 
return true ; 
} 
} 

public class InjectionPoint { 
private static boolean overrides ( Method a , Method b ) { 
int modifiers = b . getModifiers ( ) ; 
if ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) return true ; 
if ( Modifier . isPrivate ( modifiers ) ) return false ; 
return a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; 
} 
} 

public class TypeLiteral { 
private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { 
TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; 
for ( int t = 0 ; 
t < types . length ; 
t ++ ) result [ t ] = resolve ( types [ t ] ) ; 
return ImmutableList . copyOf ( result ) ; 
} 
} 

public class MoreTypes { 
public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { 
Type type = typeLiteral . getType ( ) ; 
if ( ! isFullySpecified ( type ) ) { 
Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; 
throw new ConfigurationException ( errors . getMessages ( ) ) ; 
} 
if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { 
ParameterizedType parameterizedType = ( ParameterizedType ) type ; 
@ SuppressWarnings ( "unchecked" ) TypeLiteral < T > guiceProviderType = ( TypeLiteral < T > ) TypeLiteral . get ( Types . providerOf ( parameterizedType . getActualTypeArguments ( ) [ 0 ] ) ) ; 
return guiceProviderType ; 
} 
@ SuppressWarnings ( "unchecked" ) TypeLiteral < T > wrappedPrimitives = ( TypeLiteral < T > ) PRIMITIVE_TO_WRAPPER . get ( typeLiteral ) ; 
if ( wrappedPrimitives != null ) return wrappedPrimitives ; 
if ( typeLiteral . getClass ( ) == TypeLiteral . class ) return typeLiteral ; 
@ SuppressWarnings ( "unchecked" ) TypeLiteral < T > recreated = ( TypeLiteral < T > ) TypeLiteral . get ( typeLiteral . getType ( ) ) ; 
return recreated ; 
} 
} 

public class TypeConverterBindingProcessor { 
static void prepareBuiltInConverters ( InjectorImpl injector ) { 
convertToPrimitiveType ( injector , int . class , Integer . class ) ; 
convertToPrimitiveType ( injector , long . class , Long . class ) ; 
convertToPrimitiveType ( injector , boolean . class , Boolean . class ) ; 
convertToPrimitiveType ( injector , byte . class , Byte . class ) ; 
convertToPrimitiveType ( injector , short . class , Short . class ) ; 
convertToPrimitiveType ( injector , float . class , Float . class ) ; 
convertToPrimitiveType ( injector , double . class , Double . class ) ; 
convertToClass ( injector , Character . class , new TypeConverter ( ) { 
@ Override public Object convert ( String value , TypeLiteral < ? > toType ) { 
value = value . trim ( ) ; 
if ( value . length ( ) != 1 ) throw new RuntimeException ( "Length != 1." ) ; 
return value . charAt ( 0 ) ; 
} 
@ Override public String toString ( ) { 
return "TypeConverter<Character>" ; 
} 
} 
) ; 
convertToClasses ( injector , Matchers . subclassesOf ( Enum . class ) , new TypeConverter ( ) { 
@ Override @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { 
return Enum . valueOf ( ( Class ) toType . getRawType ( ) , value ) ; 
} 
@ Override public String toString ( ) { 
return "TypeConverter<E extends Enum<E>>" ; 
} 
} 
) ; 
internalConvertToTypes ( injector , new AbstractMatcher < TypeLiteral < ? > > ( ) { 
@ Override public boolean matches ( TypeLiteral < ? > typeLiteral ) { 
return typeLiteral . getRawType ( ) == Class . class ; 
} 
@ Override public String toString ( ) { 
return "Class<?>" ; 
} 
} 
, new TypeConverter ( ) { 
@ Override @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { 
try { 
return Class . forName ( value ) ; 
} 
catch ( ClassNotFoundException e ) { 
throw new RuntimeException ( e . getMessage ( ) ) ; 
} 
} 
@ Override public String toString ( ) { 
return "TypeConverter<Class<?>>" ; 
} 
} 
) ; 
} 
} 

public class BytecodeGen { 
private static boolean isPubliclyCallable ( Member member ) { 
if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) return false ; 
Class < ? > [ ] parameterTypes ; 
if ( member instanceof Constructor ) parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; 
else { 
Method method = ( Method ) member ; 
if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) return false ; 
parameterTypes = method . getParameterTypes ( ) ; 
} 
for ( Class < ? > type : parameterTypes ) { 
if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) return false ; 
} 
return true ; 
} 
} 

public class Initializer { 
< T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { 
checkNotNull ( source ) ; 
Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; 
ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; 
if ( instance == null || ( injectionPoints . isEmpty ( ) && ! injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) ) return Initializables . of ( instance ) ; 
if ( initializablesCache . containsKey ( instance ) ) { 
@ SuppressWarnings ( "unchecked" ) Initializable < T > cached = ( Initializable < T > ) initializablesCache . get ( instance ) ; 
return cached ; 
} 
InjectableReference < T > injectableReference = new InjectableReference < T > ( injector , instance , binding == null ? null : binding . getKey ( ) , provisionCallback , source , cycleDetectingLockFactory . create ( instance . getClass ( ) ) ) ; 
initializablesCache . put ( instance , injectableReference ) ; 
pendingInjections . add ( injectableReference ) ; 
return injectableReference ; 
} 
} 

public class ManagedFilterPipeline { 
@ SuppressWarnings ( { 
"JavaDoc" , "deprecation" } 
) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) { 
if ( ! servletPipeline . hasServletsMapped ( ) ) return servletRequest ; 
HttpServletRequest request = ( HttpServletRequest ) servletRequest ; 
return new HttpServletRequestWrapper ( request ) { 
@ Override public RequestDispatcher getRequestDispatcher ( String path ) { 
final RequestDispatcher dispatcher = servletPipeline . getRequestDispatcher ( path ) ; 
return ( null != dispatcher ) ? dispatcher : super . getRequestDispatcher ( path ) ; 
} 
} 
; 
} 
} 

public class Scoping { 
static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { 
if ( scoping . isNoScope ( ) ) return creator ; 
Scope scope = scoping . getScopeInstance ( ) ; 
Provider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T > ( injector , creator ) ) ; 
return new InternalFactoryToProviderAdapter < T > ( scoped , source ) ; 
} 
} 

public class Scoping { 
static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { 
Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; 
if ( scopeAnnotation == null ) return scoping ; 
ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; 
if ( scope != null ) return forInstance ( scope . getScope ( ) ) ; 
errors . scopeNotFound ( scopeAnnotation ) ; 
return UNSCOPED ; 
} 
} 

public class ServletUtils { 
static String normalizePath ( String path ) { 
StringBuilder sb = new StringBuilder ( path . length ( ) ) ; 
int queryStart = path . indexOf ( '?' ) ; 
String query = null ; 
if ( queryStart != - 1 ) { 
query = path . substring ( queryStart ) ; 
path = path . substring ( 0 , queryStart ) ; 
} 
List < String > segments = new ArrayList < > ( ) ; 
for ( String segment : SLASH_SPLITTER . split ( path ) ) { 
String normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; 
if ( "." . equals ( normalized ) ) { 
} 
else if ( ".." . equals ( normalized ) ) if ( segments . size ( ) > 1 ) segments . remove ( segments . size ( ) - 1 ) ; 
else segments . add ( normalized ) ; 
} 
SLASH_JOINER . appendTo ( sb , segments ) ; 
if ( query != null ) sb . append ( query ) ; 
return sb . toString ( ) ; 
} 
} 

public class Annotations { 
public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { 
Class < ? extends Annotation > found = null ; 
for ( Annotation annotation : annotations ) { 
Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; 
if ( isScopeAnnotation ( annotationType ) ) if ( found != null ) errors . duplicateScopeAnnotations ( found , annotationType ) ; 
else found = annotationType ; 
} 
return found ; 
} 
} 

public class Annotations { 
public static String nameOf ( Key < ? > key ) { 
Annotation annotation = key . getAnnotation ( ) ; 
Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; 
if ( annotation != null && ! isMarker ( annotationType ) ) return key . getAnnotation ( ) . toString ( ) ; 
else if ( key . getAnnotationType ( ) != null ) return "@" + key . getAnnotationType ( ) . getName ( ) ; 
else return "" ; 
} 
} 

public class Struts2Factory { 
private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { 
for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { 
if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) return true ; 
} 
return false ; 
} 
} 

public class Message { 
private Object writeReplace ( ) throws ObjectStreamException { 
Object [ ] sourcesAsStrings = sources . toArray ( ) ; 
for ( int i = 0 ; 
i < sourcesAsStrings . length ; 
i ++ ) sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; 
return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; 
} 
} 

public class CheckedProviderMethodsModule { 
static Module forModule ( Module module ) { 
if ( module instanceof CheckedProviderMethodsModule ) return Modules . EMPTY_MODULE ; 
return new CheckedProviderMethodsModule ( module ) ; 
} 
} 

public class FactoryProvider2 { 
private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { 
Collection < Message > messages = ce . getErrorMessages ( ) ; 
if ( messages . size ( ) == 1 ) { 
Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; 
return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; 
} 
else return false ; 
} 
} 

public class FactoryProvider2 { 
private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { 
List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; 
Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; 
int p = 0 ; 
List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; 
for ( TypeLiteral < ? > param : params ) { 
Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; 
constructorKeys . add ( paramKey ) ; 
} 
for ( Key < ? > key : paramList ) { 
if ( ! constructorKeys . remove ( key ) ) return false ; 
} 
for ( Key < ? > key : constructorKeys ) { 
if ( key . getAnnotationType ( ) == Assisted . class ) return false ; 
} 
return true ; 
} 
} 

public class FactoryProvider2 { 
private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { 
ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; 
builder . addAll ( ctorPoint . getDependencies ( ) ) ; 
if ( ! implementation . getRawType ( ) . isInterface ( ) ) for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { 
builder . addAll ( ip . getDependencies ( ) ) ; 
} 
return builder . build ( ) ; 
} 
} 

public class FactoryProvider2 { 
private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { 
ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; 
for ( Dependency < ? > dep : deps ) { 
Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; 
if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) builder . add ( dep ) ; 
} 
return builder . build ( ) ; 
} 
} 

public class FactoryProvider2 { 
private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { 
Set < Dependency < ? > > badDeps = null ; 
for ( Dependency < ? > dep : dependencies ) { 
if ( isInjectorOrAssistedProvider ( dep ) ) { 
if ( badDeps == null ) badDeps = Sets . newHashSet ( ) ; 
badDeps . add ( dep ) ; 
} 
} 
if ( badDeps != null && ! badDeps . isEmpty ( ) ) { 
logger . log ( Level . WARNING , "AssistedInject factory {0} will be slow " + "because {1} has assisted Provider dependencies or injects the Injector. " + "Stop injecting @Assisted Provider<T> (instead use @Assisted T) " + "or Injector to speed things up. (It will be a ~6500% speed bump!)  " + "The exact offending deps are: {2}" , new Object [ ] { 
factoryType , implementation , badDeps } 
) ; 
return false ; 
} 
return true ; 
} 
} 

public class FactoryProvider2 { 
public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { 
checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; 
final Key < ? > returnType = data . returnType ; 
final Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; 
Module assistedModule = new AbstractModule ( ) { 
@ Override @ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) protected void configure ( ) { 
Binder binder = binder ( ) . withSource ( method ) ; 
int p = 0 ; 
if ( ! data . optimized ) for ( Key < ? > paramKey : data . paramTypes ) { 
binder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; 
} 
else for ( Key < ? > paramKey : data . paramTypes ) { 
binder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; 
} 
Constructor constructor = data . constructor ; 
if ( constructor != null ) binder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; 
} 
} 
; 
Injector forCreate = injector . createChildInjector ( assistedModule ) ; 
Binding < ? > binding = forCreate . getBinding ( returnKey ) ; 
if ( data . optimized ) data . cachedBinding = binding ; 
return binding ; 
} 
} 

public class FactoryProvider2 { 
@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { 
if ( methodHandleByMethod . containsKey ( method ) ) return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; 
if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) if ( "equals" . equals ( method . getName ( ) ) ) return proxy == args [ 0 ] ; 
else if ( "hashCode" . equals ( method . getName ( ) ) ) return System . identityHashCode ( proxy ) ; 
else return method . invoke ( this , args ) ; 
AssistData data = assistDataByMethod . get ( method ) ; 
checkState ( data != null , "No data for method: %s" , method ) ; 
Provider < ? > provider ; 
if ( data . cachedBinding != null ) provider = data . cachedBinding . getProvider ( ) ; 
else provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; 
try { 
int p = 0 ; 
for ( ThreadLocalProvider tlp : data . providers ) { 
tlp . set ( args [ p ++ ] ) ; 
} 
return provider . get ( ) ; 
} 
catch ( ProvisionException e ) { 
if ( e . getErrorMessages ( ) . size ( ) == 1 ) { 
Message onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; 
Throwable cause = onlyError . getCause ( ) ; 
if ( cause != null && canRethrow ( method , cause ) ) throw cause ; 
} 
throw e ; 
} 
finally { 
for ( ThreadLocalProvider tlp : data . providers ) { 
tlp . remove ( ) ; 
} 
} 
} 
} 

public class Errors { 
< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( format ( "No implementation for %s was bound." , key ) ) ; 
List < String > possibleMatches = new ArrayList < > ( ) ; 
TypeLiteral < T > type = key . getTypeLiteral ( ) ; 
List < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; 
if ( ! sameTypes . isEmpty ( ) ) { 
sb . append ( format ( "%n  Did you mean?" ) ) ; 
int howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; 
for ( int i = 0 ; 
i < howMany ; 
++ i ) sb . append ( format ( "%n    * %s" , sameTypes . get ( i ) . getKey ( ) ) ) ; 
int remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; 
if ( remaining > 0 ) { 
String plural = ( remaining == 1 ) ? "" : "s" ; 
sb . append ( format ( "%n    %d more binding%s with other annotations." , remaining , plural ) ) ; 
} 
} 
else { 
String want = type . toString ( ) ; 
Map < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; 
for ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { 
String have = bindingKey . getTypeLiteral ( ) . toString ( ) ; 
if ( have . contains ( want ) || want . contains ( have ) ) { 
Formatter fmt = new Formatter ( ) ; 
Messages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; 
String match = String . format ( "%s bound%s" , convert ( bindingKey ) , fmt . toString ( ) ) ; 
possibleMatches . add ( match ) ; 
if ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) break ; 
} 
} 
if ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { 
sb . append ( format ( "%n  Did you mean?" ) ) ; 
for ( String possibleMatch : possibleMatches ) { 
sb . append ( format ( "%n    %s" , possibleMatch ) ) ; 
} 
} 
} 
if ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) sb . append ( format ( "%nThe key seems very generic, did you forget an annotation?" ) ) ; 
return addMessage ( sb . toString ( ) ) ; 
} 
} 

public class FilterChainInvocation { 
private Filter findNextFilter ( HttpServletRequest request ) { 
while ( ++ index < filterDefinitions . length ) { 
Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; 
if ( filter != null ) return filter ; 
} 
return null ; 
} 
} 

public class ConstructorBindingImpl { 
InjectionPoint getInternalConstructor ( ) { 
if ( factory . constructorInjector != null ) return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; 
else return constructorInjectionPoint ; 
} 
} 

public class ConstructorBindingImpl { 
Set < Dependency < ? > > getInternalDependencies ( ) { 
ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; 
if ( factory . constructorInjector == null ) { 
builder . add ( constructorInjectionPoint ) ; 
try { 
builder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; 
} 
catch ( ConfigurationException ignored ) { 
} 
} 
else builder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers ( ) ) ; 
return Dependency . forInjectionPoints ( builder . build ( ) ) ; 
} 
} 

public class ProviderMethodsModule { 
private Annotation getAnnotation ( Binder binder , Method method ) { 
if ( method . isBridge ( ) || method . isSynthetic ( ) ) return null ; 
Annotation annotation = null ; 
for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { 
Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; 
if ( foundAnnotation != null ) { 
if ( annotation != null ) { 
binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; 
return null ; 
} 
annotation = foundAnnotation ; 
} 
} 
return annotation ; 
} 
} 

public class ServletScopes { 
private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { 
if ( object == null || object == NullObject . INSTANCE ) return NullObject . INSTANCE ; 
if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; 
return object ; 
} 
} 

public class Key { 
static AnnotationStrategy strategyFor ( Annotation annotation ) { 
checkNotNull ( annotation , "annotation" ) ; 
Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; 
ensureRetainedAtRuntime ( annotationType ) ; 
ensureIsBindingAnnotation ( annotationType ) ; 
if ( Annotations . isMarker ( annotationType ) ) return new AnnotationTypeStrategy ( annotationType , annotation ) ; 
return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; 
} 
} 

public class Key { 
static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { 
annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; 
if ( isAllDefaultMethods ( annotationType ) ) return strategyFor ( generateAnnotation ( annotationType ) ) ; 
checkNotNull ( annotationType , "annotation type" ) ; 
ensureRetainedAtRuntime ( annotationType ) ; 
ensureIsBindingAnnotation ( annotationType ) ; 
return new AnnotationTypeStrategy ( annotationType , null ) ; 
} 
} 

public class InterceptorStackCallback { 
private void pruneStacktrace ( Throwable throwable ) { 
for ( Throwable t = throwable ; 
t != null ; 
t = t . getCause ( ) ) { 
StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; 
List < StackTraceElement > pruned = Lists . newArrayList ( ) ; 
for ( StackTraceElement element : stackTrace ) { 
String className = element . getClassName ( ) ; 
if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) pruned . add ( element ) ; 
} 
t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; 
} 
} 
} 

public class DependencyAndSource { 
public String getBindingSource ( ) { 
if ( source instanceof Class ) return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; 
else if ( source instanceof Member ) return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; 
else return source . toString ( ) ; 
} 
} 

public class Messages { 
public static String formatMessages ( String heading , Collection < Message > errorMessages ) { 
Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; 
int index = 1 ; 
boolean displayCauses = getOnlyCause ( errorMessages ) == null ; 
Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; 
for ( Message errorMessage : errorMessages ) { 
int thisIdx = index ++ ; 
fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; 
List < Object > dependencies = errorMessage . getSources ( ) ; 
for ( int i = dependencies . size ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
Object source = dependencies . get ( i ) ; 
formatSource ( fmt , source ) ; 
} 
Throwable cause = errorMessage . getCause ( ) ; 
if ( displayCauses && cause != null ) { 
Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; 
if ( ! causes . containsKey ( causeEquivalence ) ) { 
causes . put ( causeEquivalence , thisIdx ) ; 
fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; 
} 
else { 
int causeIdx = causes . get ( causeEquivalence ) ; 
fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; 
} 
} 
fmt . format ( "%n" ) ; 
} 
if ( errorMessages . size ( ) == 1 ) fmt . format ( "1 error" ) ; 
else fmt . format ( "%s errors" , errorMessages . size ( ) ) ; 
return fmt . toString ( ) ; 
} 
} 

public class SourceProvider { 
public Object getFromClassNames ( List < String > moduleClassNames ) { 
Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; 
for ( final String moduleClassName : moduleClassNames ) { 
if ( ! shouldBeSkipped ( moduleClassName ) ) return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; 
} 
return UNKNOWN_SOURCE ; 
} 
} 

public class ProviderInternalFactory { 
protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { 
T t = provider . get ( ) ; 
if ( t == null && ! dependency . isNullable ( ) ) InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; 
constructionContext . setProxyDelegates ( t ) ; 
return t ; 
} 
} 

public class ConnectionEventListener { 
public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { 
List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; 
if ( processorList != null ) for ( ConnectionEventProcessor processor : processorList ) { 
processor . onEvent ( remoteAddr , conn ) ; 
} 
} 
} 

public class FutureTaskUtil { 
public static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { 
T t = null ; 
if ( null != task ) try { 
t = task . getAfterRun ( ) ; 
} 
catch ( InterruptedException e ) { 
logger . error ( "Future task interrupted!" , e ) ; 
} 
catch ( ExecutionException e ) { 
logger . error ( "Future task execute failed!" , e ) ; 
} 
catch ( FutureTaskNotRunYetException e ) { 
logger . error ( "Future task has not run yet!" , e ) ; 
} 
catch ( FutureTaskNotCompleted e ) { 
logger . error ( "Future task has not completed!" , e ) ; 
} 
return t ; 
} 
} 

public class FutureTaskUtil { 
public static void launderThrowable ( Throwable t ) { 
if ( t instanceof RuntimeException ) throw ( RuntimeException ) t ; 
else if ( t instanceof Error ) throw ( Error ) t ; 
else throw new IllegalStateException ( "Not unchecked!" , t ) ; 
} 
} 

public class ProcessorManager { 
public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { 
if ( this . cmd2processors . containsKey ( cmdCode ) ) logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; 
this . cmd2processors . put ( cmdCode , processor ) ; 
} 
} 

public class ProcessorManager { 
public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { 
if ( this . defaultProcessor == null ) this . defaultProcessor = processor ; 
else throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; 
} 
} 

public class ProcessorManager { 
public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { 
RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; 
if ( processor != null ) return processor ; 
return this . defaultProcessor ; 
} 
} 

public class DefaultConnectionManager { 
@ Override public Map < String , List < Connection > > getAll ( ) { 
Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; 
Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; 
ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; 
if ( null != pool ) allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; 
} 
return allConnections ; 
} 
} 

public class DefaultConnectionManager { 
@ Override public void scan ( ) { 
if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { 
Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
String poolKey = iter . next ( ) ; 
ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; 
if ( null != pool ) { 
pool . scan ( ) ; 
if ( pool . isEmpty ( ) ) if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { 
iter . remove ( ) ; 
logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; 
} 
} 
} 
} 
} 
} 

public class DefaultConnectionManager { 
@ Override public Connection getAndCreateIfAbsent ( Url url ) throws InterruptedException , RemotingException { 
ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; 
if ( null != pool ) return pool . get ( ) ; 
else { 
logger . error ( "[NOTIFYME] bug detected! pool here must not be null!" ) ; 
return null ; 
} 
} 
} 

public class DefaultConnectionManager { 
@ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { 
ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; 
if ( null != pool ) healIfNeed ( pool , url ) ; 
else logger . error ( "[NOTIFYME] bug detected! pool here must not be null!" ) ; 
} 
} 

public class DefaultConnectionManager { 
private void removeTask ( String poolKey ) { 
RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; 
if ( null != task ) { 
ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; 
if ( null != pool ) pool . removeAllAndTryClose ( ) ; 
} 
} 
} 

public class DefaultConnectionManager { 
private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { 
String poolKey = url . getUniqueKey ( ) ; 
if ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { 
FutureTask < Integer > task = this . healTasks . get ( poolKey ) ; 
if ( null == task ) { 
task = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; 
task = this . healTasks . putIfAbsent ( poolKey , task ) ; 
if ( null == task ) { 
task = this . healTasks . get ( poolKey ) ; 
task . run ( ) ; 
} 
} 
try { 
int numAfterHeal = task . get ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "[NOTIFYME] - conn num after heal {}, expected {}, warmup {}" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; 
} 
catch ( InterruptedException e ) { 
this . healTasks . remove ( poolKey ) ; 
throw e ; 
} 
catch ( ExecutionException e ) { 
this . healTasks . remove ( poolKey ) ; 
Throwable cause = e . getCause ( ) ; 
if ( cause instanceof RemotingException ) throw ( RemotingException ) cause ; 
else FutureTaskUtil . launderThrowable ( cause ) ; 
} 
this . healTasks . remove ( poolKey ) ; 
} 
} 
} 

public class DefaultConnectionManager { 
private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { 
final int actualNum = pool . size ( ) ; 
final int expectNum = url . getConnNum ( ) ; 
if ( actualNum < expectNum ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; 
if ( url . isConnWarmup ( ) ) for ( int i = actualNum ; 
i < expectNum ; 
++ i ) { 
Connection connection = create ( url ) ; 
pool . add ( connection ) ; 
} 
else { 
if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; 
if ( syncCreateNumWhenNotWarmup > 0 ) { 
for ( int i = 0 ; 
i < syncCreateNumWhenNotWarmup ; 
++ i ) { 
Connection connection = create ( url ) ; 
pool . add ( connection ) ; 
} 
if ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) return ; 
} 
initializeExecutor ( ) ; 
pool . markAsyncCreationStart ( ) ; 
try { 
this . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { 
@ Override public void run ( ) { 
try { 
for ( int i = pool . size ( ) ; 
i < url . getConnNum ( ) ; 
++ i ) { 
Connection conn = null ; 
try { 
conn = create ( url ) ; 
} 
catch ( RemotingException e ) { 
logger . error ( "Exception occurred in async create connection thread for {}, taskName {}" , url . getUniqueKey ( ) , taskName , e ) ; 
} 
pool . add ( conn ) ; 
} 
} 
finally { 
pool . markAsyncCreationDone ( ) ; 
} 
} 
} 
) ; 
} 
catch ( RejectedExecutionException e ) { 
pool . markAsyncCreationDone ( ) ; 
throw e ; 
} 
} 
} 
} 
} 

public class Connection { 
public void close ( ) { 
if ( closed . compareAndSet ( false , true ) ) try { 
if ( this . getChannel ( ) != null ) this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { 
@ Override public void operationComplete ( ChannelFuture future ) throws Exception { 
if ( logger . isInfoEnabled ( ) ) logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; 
} 
} 
) ; 
} 
catch ( Exception e ) { 
logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; 
} 
} 
} 

public class UserProcessorRegisterHelper { 
public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { 
if ( null == processor ) throw new RuntimeException ( "User processor should not be null!" ) ; 
if ( processor instanceof MultiInterestUserProcessor ) registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; 
else { 
if ( StringUtils . isBlank ( processor . interest ( ) ) ) throw new RuntimeException ( "Processor interest should not be blank!" ) ; 
UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; 
if ( preProcessor != null ) { 
String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; 
throw new RuntimeException ( errMsg ) ; 
} 
} 
} 
} 

public class UserProcessorRegisterHelper { 
private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { 
if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) throw new RuntimeException ( "Processor interest should not be blank!" ) ; 
for ( String interest : processor . multiInterest ( ) ) { 
UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; 
if ( preProcessor != null ) { 
String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; 
throw new RuntimeException ( errMsg ) ; 
} 
} 
} 
} 

public class RpcRequestProcessor { 
private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { 
final int id = cmd . getId ( ) ; 
final byte type = cmd . getType ( ) ; 
UserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; 
if ( processor instanceof AsyncUserProcessor ) try { 
processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; 
} 
catch ( RejectedExecutionException e ) { 
logger . warn ( "RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor" ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; 
} 
catch ( Throwable t ) { 
String errMsg = "AYSNC process rpc request failed in RpcRequestProcessor, id=" + id ; 
logger . error ( errMsg , t ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; 
} 
else try { 
Object responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; 
} 
catch ( RejectedExecutionException e ) { 
logger . warn ( "RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor" ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; 
} 
catch ( Throwable t ) { 
String errMsg = "SYNC process rpc request failed in RpcRequestProcessor, id=" + id ; 
logger . error ( errMsg , t ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; 
} 
} 
} 

public class RpcRequestProcessor { 
private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; 
String remoteAddr = "UNKNOWN" ; 
if ( null != ctx ) { 
ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; 
Channel channel = channelCtx . channel ( ) ; 
if ( null != channel ) remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; 
} 
logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; 
} 
} 

public class AbstractRemotingProcessor { 
@ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { 
ProcessTask task = new ProcessTask ( ctx , msg ) ; 
if ( this . getExecutor ( ) != null ) this . getExecutor ( ) . execute ( task ) ; 
else defaultExecutor . execute ( task ) ; 
} 
} 

public class BaseRemoting { 
protected void oneway ( final Connection conn , final RemotingCommand request ) { 
try { 
conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { 
@ Override public void operationComplete ( ChannelFuture f ) throws Exception { 
if ( ! f . isSuccess ( ) ) logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; 
} 
} 
) ; 
} 
catch ( Exception e ) { 
if ( null == conn ) logger . error ( "Conn is null" ) ; 
else logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; 
} 
} 
} 

public class ProtocolSwitch { 
public static byte toByte ( BitSet bs ) { 
int value = 0 ; 
for ( int i = 0 ; 
i < bs . length ( ) ; 
++ i ) if ( bs . get ( i ) ) value += 1 << i ; 
if ( bs . length ( ) > 7 ) throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; 
return ( byte ) value ; 
} 
} 

public class ProtocolSwitch { 
public static BitSet toBitSet ( int value ) { 
if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; 
BitSet bs = new BitSet ( ) ; 
int index = 0 ; 
while ( value != 0 ) { 
if ( value % 2 != 0 ) bs . set ( index ) ; 
++ index ; 
value = ( byte ) ( value >> 1 ) ; 
} 
return bs ; 
} 
} 

public class ReconnectManager { 
public void stop ( ) { 
if ( ! this . started ) return ; 
this . started = false ; 
healConnectionThreads . interrupt ( ) ; 
this . tasks . clear ( ) ; 
this . canceled . clear ( ) ; 
} 
} 

public class RpcRemoting { 
protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { 
RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; 
if ( null != invokeContext ) { 
Object clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; 
if ( null != clientCustomSerializer ) try { 
command . setSerializer ( ( Byte ) clientCustomSerializer ) ; 
} 
catch ( ClassCastException e ) { 
throw new IllegalArgumentException ( "Illegal custom serializer [" + clientCustomSerializer + "], the type of value should be [byte], but now is [" + clientCustomSerializer . getClass ( ) . getName ( ) + "]." ) ; 
} 
Boolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; 
if ( null != crcSwitch && crcSwitch ) command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { 
ProtocolSwitch . CRC_SWITCH_INDEX } 
) ) ; 
} 
else command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { 
ProtocolSwitch . CRC_SWITCH_INDEX } 
) ) ; 
command . setTimeout ( timeoutMillis ) ; 
command . setRequestClass ( request . getClass ( ) . getName ( ) ) ; 
command . setInvokeContext ( invokeContext ) ; 
command . serialize ( ) ; 
logDebugInfo ( command ) ; 
return command ; 
} 
} 

public class ScheduledDisconnectStrategy { 
@ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { 
List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; 
List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; 
Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; 
for ( Connection connection : connections ) { 
String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; 
if ( serviceStatus != null ) if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) serviceOffConnections . add ( connection ) ; 
else serviceOnConnections . add ( connection ) ; 
} 
filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; 
filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; 
return filteredConnections ; 
} 
} 

public class ScheduledDisconnectStrategy { 
@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { 
try { 
if ( null != connPools && ! connPools . isEmpty ( ) ) { 
Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; 
String poolKey = entry . getKey ( ) ; 
ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; 
List < Connection > connections = pool . getAll ( ) ; 
Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; 
List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; 
List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; 
if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { 
Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; 
freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; 
Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; 
freshSelectConnections . put ( poolKey , freshSelectConnect ) ; 
closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; 
} 
else { 
if ( freshSelectConnections . containsKey ( poolKey ) ) { 
Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; 
closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; 
} 
if ( logger . isInfoEnabled ( ) ) logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; 
} 
for ( Connection offConn : serviceOffConnections ) { 
if ( offConn . isFine ( ) ) offConn . close ( ) ; 
} 
} 
} 
} 
catch ( Exception e ) { 
logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; 
} 
} 
} 

public class ScheduledDisconnectStrategy { 
private void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { 
if ( null != lastSelectConnect ) if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) serviceOffConnections . add ( lastSelectConnect ) ; 
else { 
Thread . sleep ( RETRY_DETECT_PERIOD ) ; 
if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) serviceOffConnections . add ( lastSelectConnect ) ; 
else if ( logger . isInfoEnabled ( ) ) logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; 
} 
} 
} 

public class ConnectionEventHandler { 
private void infoLog ( String format , String addr ) { 
if ( logger . isInfoEnabled ( ) ) if ( StringUtils . isNotEmpty ( addr ) ) logger . info ( format , addr ) ; 
else logger . info ( format , "UNKNOWN-ADDR" ) ; 
} 
} 

public class RemotingContext { 
public boolean isRequestTimeout ( ) { 
if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) return true ; 
return false ; 
} 
} 

public class RandomSelectStrategy { 
private Connection randomGet ( List < Connection > conns ) { 
if ( null == conns || conns . isEmpty ( ) ) return null ; 
int size = conns . size ( ) ; 
int tries = 0 ; 
Connection result = null ; 
while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) result = conns . get ( this . random . nextInt ( size ) ) ; 
if ( result != null && ! result . isFine ( ) ) result = null ; 
return result ; 
} 
} 

public class Url { 
public String getProperty ( String key ) { 
if ( properties == null ) return null ; 
return properties . getProperty ( key ) ; 
} 
} 

public class RpcResponseResolver { 
public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { 
preProcess ( responseCommand , addr ) ; 
if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) return toResponseObject ( responseCommand ) ; 
else { 
String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; 
logger . warn ( msg ) ; 
if ( responseCommand . getCause ( ) != null ) throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; 
else throw new InvokeException ( msg + ", please check the server log for more." ) ; 
} 
} 
} 

public class RpcResponseResolver { 
private static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { 
RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; 
resp . deserialize ( ) ; 
Object ex = resp . getResponseObject ( ) ; 
if ( ex != null && ex instanceof Throwable ) return ( Throwable ) ex ; 
return null ; 
} 
} 

public class RpcResponseResolver { 
private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { 
RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; 
if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; 
else return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; 
} 
} 

public class TraceLogUtil { 
public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { 
String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; 
Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; 
String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; 
Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; 
StringBuilder logMsg = new StringBuilder ( ) ; 
logMsg . append ( traceId ) . append ( "," ) ; 
logMsg . append ( sourceIp ) . append ( "," ) ; 
logMsg . append ( sourcePort ) . append ( "," ) ; 
logMsg . append ( targetIp ) . append ( "," ) ; 
logMsg . append ( targetPort ) ; 
if ( logger . isInfoEnabled ( ) ) logger . info ( logMsg . toString ( ) ) ; 
} 
} 

public class RemotingUtil { 
public static String parseRemoteAddress ( final Channel channel ) { 
if ( null == channel ) return StringUtils . EMPTY ; 
final SocketAddress remote = channel . remoteAddress ( ) ; 
return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; 
} 
} 

public class RemotingUtil { 
public static String parseLocalAddress ( final Channel channel ) { 
if ( null == channel ) return StringUtils . EMPTY ; 
final SocketAddress local = channel . localAddress ( ) ; 
return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; 
} 
} 

public class RemotingUtil { 
public static String parseRemoteIP ( final Channel channel ) { 
if ( null == channel ) return StringUtils . EMPTY ; 
final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; 
if ( remote != null ) return remote . getAddress ( ) . getHostAddress ( ) ; 
return StringUtils . EMPTY ; 
} 
} 

public class RemotingUtil { 
public static String parseRemoteHostName ( final Channel channel ) { 
if ( null == channel ) return StringUtils . EMPTY ; 
final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; 
if ( remote != null ) return remote . getAddress ( ) . getHostName ( ) ; 
return StringUtils . EMPTY ; 
} 
} 

public class RemotingUtil { 
public static String parseLocalIP ( final Channel channel ) { 
if ( null == channel ) return StringUtils . EMPTY ; 
final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; 
if ( local != null ) return local . getAddress ( ) . getHostAddress ( ) ; 
return StringUtils . EMPTY ; 
} 
} 

public class RemotingUtil { 
public static int parseRemotePort ( final Channel channel ) { 
if ( null == channel ) return - 1 ; 
final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; 
if ( remote != null ) return remote . getPort ( ) ; 
return - 1 ; 
} 
} 

public class RemotingUtil { 
public static int parseLocalPort ( final Channel channel ) { 
if ( null == channel ) return - 1 ; 
final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; 
if ( local != null ) return local . getPort ( ) ; 
return - 1 ; 
} 
} 

public class RemotingUtil { 
public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { 
final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; 
if ( addrs != null ) { 
InetAddress addr = addrs . getAddress ( ) ; 
if ( null != addr ) return addr . getHostAddress ( ) ; 
} 
return StringUtils . EMPTY ; 
} 
} 

public class ConnectionPool { 
public void add ( Connection connection ) { 
markAccess ( ) ; 
if ( null == connection ) return ; 
boolean res = this . conns . addIfAbsent ( connection ) ; 
if ( res ) connection . increaseRef ( ) ; 
} 
} 

public class ConnectionPool { 
public void removeAndTryClose ( Connection connection ) { 
if ( null == connection ) return ; 
boolean res = this . conns . remove ( connection ) ; 
if ( res ) connection . decreaseRef ( ) ; 
if ( connection . noRef ( ) ) connection . close ( ) ; 
} 
} 

public class ConnectionPool { 
public Connection get ( ) { 
markAccess ( ) ; 
if ( null != this . conns ) { 
List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; 
if ( snapshot . size ( ) > 0 ) return this . strategy . select ( snapshot ) ; 
else return null ; 
} 
else return null ; 
} 
} 

public class CustomSerializerManager { 
public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { 
CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; 
if ( prevSerializer != null ) throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; 
} 
} 

public class CustomSerializerManager { 
public static CustomSerializer getCustomSerializer ( String className ) { 
if ( ! classCustomSerializer . isEmpty ( ) ) return classCustomSerializer . get ( className ) ; 
return null ; 
} 
} 

public class CustomSerializerManager { 
public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { 
CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; 
if ( prevSerializer != null ) throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; 
} 
} 

public class CustomSerializerManager { 
public static CustomSerializer getCustomSerializer ( CommandCode code ) { 
if ( ! commandCustomSerializer . isEmpty ( ) ) return commandCustomSerializer . get ( code ) ; 
return null ; 
} 
} 

public class RpcServer { 
private void initWriteBufferWaterMark ( ) { 
int lowWaterMark = this . netty_buffer_low_watermark ( ) ; 
int highWaterMark = this . netty_buffer_high_watermark ( ) ; 
if ( lowWaterMark > highWaterMark ) throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; 
else logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; 
this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; 
} 
} 

public class FramedataImpl1 { 
public static FramedataImpl1 get ( Opcode opcode ) { 
if ( opcode == null ) throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; 
switch ( opcode ) { 
case PING : return new PingFrame ( ) ; 
case PONG : return new PongFrame ( ) ; 
case TEXT : return new TextFrame ( ) ; 
case BINARY : return new BinaryFrame ( ) ; 
case CLOSING : return new CloseFrame ( ) ; 
case CONTINUOUS : return new ContinuousFrame ( ) ; 
default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; 
} 
} 
} 

public class SocketChannelIOHelper { 
public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { 
if ( ws == null ) return false ; 
ByteBuffer buffer = ws . outQueue . peek ( ) ; 
WrappedByteChannel c = null ; 
if ( buffer == null ) if ( sockchannel instanceof WrappedByteChannel ) { 
c = ( WrappedByteChannel ) sockchannel ; 
if ( c . isNeedWrite ( ) ) c . writeMore ( ) ; 
} 
else do { 
sockchannel . write ( buffer ) ; 
if ( buffer . remaining ( ) > 0 ) return false ; 
else { 
ws . outQueue . poll ( ) ; 
buffer = ws . outQueue . peek ( ) ; 
} 
} 
while ( buffer != null ) ; 
if ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) ws . closeConnection ( ) ; 
return c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; 
} 
} 

public class Draft_6455 { 
private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { 
if ( curop != Opcode . CONTINUOUS ) processFrameIsNotFin ( frame ) ; 
else if ( frame . isFin ( ) ) processFrameIsFin ( webSocketImpl , frame ) ; 
else if ( currentContinuousFrame == null ) { 
log . error ( "Protocol error: Continuous frame sequence was not started." ) ; 
throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; 
} 
if ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { 
log . error ( "Protocol error: Payload is not UTF8" ) ; 
throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; 
} 
if ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) addToBufferList ( frame . getPayloadData ( ) ) ; 
} 
} 

public class Draft_6455 { 
private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { 
int code = CloseFrame . NOCODE ; 
String reason = "" ; 
if ( frame instanceof CloseFrame ) { 
CloseFrame cf = ( CloseFrame ) frame ; 
code = cf . getCloseCode ( ) ; 
reason = cf . getMessage ( ) ; 
} 
if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) webSocketImpl . closeConnection ( code , reason , true ) ; 
else if ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; 
else webSocketImpl . flushAndClose ( code , reason , false ) ; 
} 
} 

public class Draft { 
private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { 
if ( ! "GET" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) throw new InvalidHandshakeException ( String . format ( "Invalid request method received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; 
if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 2 ] ) ) throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 2 ] , line ) ) ; 
ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client ( ) ; 
clienthandshake . setResourceDescriptor ( firstLineTokens [ 1 ] ) ; 
return clienthandshake ; 
} 
} 

public class Draft { 
private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { 
if ( ! "101" . equals ( firstLineTokens [ 1 ] ) ) throw new InvalidHandshakeException ( String . format ( "Invalid status code received: %s Status line: %s" , firstLineTokens [ 1 ] , line ) ) ; 
if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; 
HandshakeBuilder handshake = new HandshakeImpl1Server ( ) ; 
ServerHandshakeBuilder serverhandshake = ( ServerHandshakeBuilder ) handshake ; 
serverhandshake . setHttpStatus ( Short . parseShort ( firstLineTokens [ 1 ] ) ) ; 
serverhandshake . setHttpStatusMessage ( firstLineTokens [ 2 ] ) ; 
return handshake ; 
} 
} 

public class WebSocketImpl { 
public void decode ( ByteBuffer socketBuffer ) { 
assert ( socketBuffer . hasRemaining ( ) ) ; 
log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; 
if ( readyState != ReadyState . NOT_YET_CONNECTED ) if ( readyState == ReadyState . OPEN ) decodeFrames ( socketBuffer ) ; 
else if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { 
assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; 
if ( socketBuffer . hasRemaining ( ) ) decodeFrames ( socketBuffer ) ; 
else if ( tmpHandshakeBytes . hasRemaining ( ) ) decodeFrames ( tmpHandshakeBytes ) ; 
} 
} 
} 

public class WebSocketClient { 
private void reset ( ) { 
Thread current = Thread . currentThread ( ) ; 
if ( current == writeThread || current == connectReadThread ) throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; 
try { 
closeBlocking ( ) ; 
if ( writeThread != null ) { 
this . writeThread . interrupt ( ) ; 
this . writeThread = null ; 
} 
if ( connectReadThread != null ) { 
this . connectReadThread . interrupt ( ) ; 
this . connectReadThread = null ; 
} 
this . draft . reset ( ) ; 
if ( this . socket != null ) { 
this . socket . close ( ) ; 
this . socket = null ; 
} 
} 
catch ( Exception e ) { 
onError ( e ) ; 
engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; 
return ; 
} 
connectLatch = new CountDownLatch ( 1 ) ; 
closeLatch = new CountDownLatch ( 1 ) ; 
this . engine = new WebSocketImpl ( this , this . draft ) ; 
} 
} 

public class WebSocketClient { 
private int getPort ( ) { 
int port = uri . getPort ( ) ; 
if ( port == - 1 ) { 
String scheme = uri . getScheme ( ) ; 
if ( "wss" . equals ( scheme ) ) return WebSocketImpl . DEFAULT_WSS_PORT ; 
else if ( "ws" . equals ( scheme ) ) return WebSocketImpl . DEFAULT_PORT ; 
else throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; 
} 
return port ; 
} 
} 

public class WebSocketClient { 
private void sendHandshake ( ) throws InvalidHandshakeException { 
String path ; 
String part1 = uri . getRawPath ( ) ; 
String part2 = uri . getRawQuery ( ) ; 
if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; 
else path = part1 ; 
if ( part2 != null ) path += '?' + part2 ; 
int port = getPort ( ) ; 
String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; 
HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; 
handshake . setResourceDescriptor ( path ) ; 
handshake . put ( "Host" , host ) ; 
if ( headers != null ) for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { 
handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; 
} 
engine . startHandshake ( handshake ) ; 
} 
} 

public class AbstractWebSocket { 
private void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { 
if ( ! ( webSocket instanceof WebSocketImpl ) ) return ; 
WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; 
if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { 
log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; 
webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; 
} 
else if ( webSocketImpl . isOpen ( ) ) webSocketImpl . sendPing ( ) ; 
else log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; 
} 
} 

public class WebSocketServer { 
public void stop ( int timeout ) throws InterruptedException { 
if ( ! isclosed . compareAndSet ( false , true ) ) return ; 
List < WebSocket > socketsToClose ; 
synchronized ( connections ) { 
socketsToClose = new ArrayList < WebSocket > ( connections ) ; 
} 
for ( WebSocket ws : socketsToClose ) { 
ws . close ( CloseFrame . GOING_AWAY ) ; 
} 
wsf . close ( ) ; 
synchronized ( this ) { 
if ( selectorthread != null && selector != null ) { 
selector . wakeup ( ) ; 
selectorthread . join ( timeout ) ; 
} 
} 
} 
} 

public class WebSocketServer { 
public int getPort ( ) { 
int port = getAddress ( ) . getPort ( ) ; 
if ( port == 0 && server != null ) port = server . socket ( ) . getLocalPort ( ) ; 
return port ; 
} 
} 

public class WebSocketServer { 
private void doAdditionalRead ( ) throws InterruptedException , IOException { 
WebSocketImpl conn ; 
while ( ! iqueue . isEmpty ( ) ) { 
conn = iqueue . remove ( 0 ) ; 
WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; 
ByteBuffer buf = takeBuffer ( ) ; 
try { 
if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; 
if ( buf . hasRemaining ( ) ) { 
conn . inQueue . put ( buf ) ; 
queue ( conn ) ; 
} 
else pushBuffer ( buf ) ; 
} 
catch ( IOException e ) { 
pushBuffer ( buf ) ; 
throw e ; 
} 
} 
} 
} 

public class WebSocketServer { 
private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { 
if ( ! onConnect ( key ) ) { 
key . cancel ( ) ; 
return ; 
} 
SocketChannel channel = server . accept ( ) ; 
if ( channel == null ) return ; 
channel . configureBlocking ( false ) ; 
Socket socket = channel . socket ( ) ; 
socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; 
socket . setKeepAlive ( true ) ; 
WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; 
w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; 
try { 
w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; 
i . remove ( ) ; 
allocateBuffers ( w ) ; 
} 
catch ( IOException ex ) { 
if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; 
handleIOException ( w . getSelectionKey ( ) , null , ex ) ; 
} 
} 
} 

public class WebSocketServer { 
private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { 
WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; 
ByteBuffer buf = takeBuffer ( ) ; 
if ( conn . getChannel ( ) == null ) { 
key . cancel ( ) ; 
handleIOException ( key , conn , new IOException ( ) ) ; 
return false ; 
} 
try { 
if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) if ( buf . hasRemaining ( ) ) { 
conn . inQueue . put ( buf ) ; 
queue ( conn ) ; 
i . remove ( ) ; 
if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) iqueue . add ( conn ) ; 
} 
else pushBuffer ( buf ) ; 
else pushBuffer ( buf ) ; 
} 
catch ( IOException e ) { 
pushBuffer ( buf ) ; 
throw e ; 
} 
return true ; 
} 
} 

public class WebSocketServer { 
private void doWrite ( SelectionKey key ) throws IOException { 
WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; 
if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) if ( key . isValid ( ) ) key . interestOps ( SelectionKey . OP_READ ) ; 
} 
} 

public class WebSocketServer { 
private boolean doEnsureSingleThread ( ) { 
synchronized ( this ) { 
if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; 
selectorthread = Thread . currentThread ( ) ; 
if ( isclosed . get ( ) ) return false ; 
} 
return true ; 
} 
} 

public class WebSocketServer { 
private void doServerShutdown ( ) { 
stopConnectionLostTimer ( ) ; 
if ( decoders != null ) for ( WebSocketWorker w : decoders ) { 
w . interrupt ( ) ; 
} 
if ( selector != null ) try { 
selector . close ( ) ; 
} 
catch ( IOException e ) { 
log . error ( "IOException during selector.close" , e ) ; 
onError ( null , e ) ; 
} 
if ( server != null ) try { 
server . close ( ) ; 
} 
catch ( IOException e ) { 
log . error ( "IOException during server.close" , e ) ; 
onError ( null , e ) ; 
} 
} 
} 

public class WebSocketServer { 
public void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { 
if ( data == null || clients == null ) throw new IllegalArgumentException ( ) ; 
broadcast ( ByteBuffer . wrap ( data ) , clients ) ; 
} 
} 

public class WebSocketServer { 
public void broadcast ( String text , Collection < WebSocket > clients ) { 
if ( text == null || clients == null ) throw new IllegalArgumentException ( ) ; 
doBroadcast ( text , clients ) ; 
} 
} 

public class WebSocketServer { 
private void doBroadcast ( Object data , Collection < WebSocket > clients ) { 
String sData = null ; 
if ( data instanceof String ) sData = ( String ) data ; 
ByteBuffer bData = null ; 
if ( data instanceof ByteBuffer ) bData = ( ByteBuffer ) data ; 
if ( sData == null && bData == null ) return ; 
Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; 
for ( WebSocket client : clients ) { 
if ( client != null ) { 
Draft draft = client . getDraft ( ) ; 
fillFrames ( draft , draftFrames , sData , bData ) ; 
try { 
client . sendFrame ( draftFrames . get ( draft ) ) ; 
} 
catch ( WebsocketNotConnectedException e ) { 
} 
} 
} 
} 
} 

public class WebSocketServer { 
private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { 
if ( ! draftFrames . containsKey ( draft ) ) { 
List < Framedata > frames = null ; 
if ( sData != null ) frames = draft . createFrames ( sData , false ) ; 
if ( bData != null ) frames = draft . createFrames ( bData , false ) ; 
if ( frames != null ) draftFrames . put ( draft , frames ) ; 
} 
} 
} 

public class ByteBufferUtils { 
public static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { 
if ( source == null || dest == null ) throw new IllegalArgumentException ( ) ; 
int fremain = source . remaining ( ) ; 
int toremain = dest . remaining ( ) ; 
if ( fremain > toremain ) { 
int limit = Math . min ( fremain , toremain ) ; 
source . limit ( limit ) ; 
dest . put ( source ) ; 
return limit ; 
} 
else { 
dest . put ( source ) ; 
return fremain ; 
} 
} 
} 

public class DefaultJPAApi { 
public EntityManager em ( String name ) { 
EntityManagerFactory emf = emfs . get ( name ) ; 
if ( emf == null ) return null ; 
return emf . createEntityManager ( ) ; 
} 
} 

public class MessagesApi { 
@ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { 
List < T > out ; 
if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) out = ( List < T > ) args [ 0 ] ; 
else out = Arrays . asList ( args ) ; 
return out ; 
} 
} 

public class F { 
private static Executor toExecutor ( ExecutionContext ec ) { 
ExecutionContext prepared = ec . prepare ( ) ; 
if ( prepared instanceof Executor ) return ( Executor ) prepared ; 
else return prepared :: execute ; 
} 
} 

public class MethodUtils { 
public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { 
try { 
final Method method = cls . getMethod ( methodName , parameterTypes ) ; 
MemberUtils . setAccessibleWorkaround ( method ) ; 
return method ; 
} 
catch ( final NoSuchMethodException e ) { 
} 
Method bestMatch = null ; 
final Method [ ] methods = cls . getMethods ( ) ; 
for ( final Method method : methods ) { 
if ( method . getName ( ) . equals ( methodName ) && MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { 
final Method accessibleMethod = getAccessibleMethod ( method ) ; 
if ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) < 0 ) ) bestMatch = accessibleMethod ; 
} 
} 
if ( bestMatch != null ) MemberUtils . setAccessibleWorkaround ( bestMatch ) ; 
if ( bestMatch != null && bestMatch . isVarArgs ( ) && bestMatch . getParameterTypes ( ) . length > 0 && parameterTypes . length > 0 ) { 
final Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; 
final Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; 
final String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; 
final String parameterTypeName = parameterTypes [ parameterTypes . length - 1 ] . getName ( ) ; 
final String parameterTypeSuperClassName = parameterTypes [ parameterTypes . length - 1 ] . getSuperclass ( ) . getName ( ) ; 
if ( ! methodParameterComponentTypeName . equals ( parameterTypeName ) && ! methodParameterComponentTypeName . equals ( parameterTypeSuperClassName ) ) return null ; 
} 
return bestMatch ; 
} 
} 

public class DefaultHttpErrorHandler { 
@ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { 
if ( statusCode == 400 ) return onBadRequest ( request , message ) ; 
else if ( statusCode == 403 ) return onForbidden ( request , message ) ; 
else if ( statusCode == 404 ) return onNotFound ( request , message ) ; 
else if ( statusCode >= 400 && statusCode < 500 ) return onOtherClientError ( request , statusCode , message ) ; 
else throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; 
} 
} 

public class DefaultHttpErrorHandler { 
protected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { 
if ( environment . isProd ( ) ) return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; 
else return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; 
} 
} 

public class BuildDocHandlerFactory { 
public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { 
assert ( files . length == baseDirs . length ) ; 
FileRepository [ ] repositories = new FileRepository [ files . length ] ; 
List < JarFile > jarFiles = new ArrayList < > ( ) ; 
for ( int i = 0 ; 
i < files . length ; 
i ++ ) { 
File file = files [ i ] ; 
String baseDir = baseDirs [ i ] ; 
if ( file . isDirectory ( ) ) repositories [ i ] = new FilesystemRepository ( file ) ; 
else { 
JarFile jarFile = new JarFile ( file ) ; 
jarFiles . add ( jarFile ) ; 
repositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; 
} 
} 
return new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { 
for ( JarFile jarFile : jarFiles ) { 
jarFile . close ( ) ; 
} 
} 
) ; 
} 
} 

public class BuildDocHandlerFactory { 
public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { 
FileRepository fileRepo = new FilesystemRepository ( directory ) ; 
FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; 
FileRepository manualRepo ; 
if ( fallbackToJar ) manualRepo = new AggregateFileRepository ( new FileRepository [ ] { 
fileRepo , jarRepo } 
) ; 
else manualRepo = fileRepo ; 
return new DocumentationHandler ( manualRepo , jarRepo ) ; 
} 
} 

public class HttpEntity { 
public static final HttpEntity fromContent ( Content content , String charset ) { 
String body ; 
if ( content instanceof Xml ) body = content . body ( ) . trim ( ) ; 
else body = content . body ( ) ; 
return new Strict ( ByteString . fromString ( body , charset ) , Optional . of ( content . contentType ( ) + "; charset=" + charset ) ) ; 
} 
} 

public class Results { 
public static Result status ( int status , JsonNode content , JsonEncoding encoding ) { 
if ( content == null ) throw new NullPointerException ( "Null content" ) ; 
return status ( status ) . sendJson ( content , encoding ) ; 
} 
} 

public class Results { 
public static Result status ( int status , byte [ ] content ) { 
if ( content == null ) throw new NullPointerException ( "Null content" ) ; 
return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; 
} 
} 

public class Paths { 
public static String relative ( String startPath , String targetPath ) { 
if ( startPath . equals ( targetPath ) ) return CURRENT_DIR ; 
String [ ] start = toSegments ( canonical ( startPath ) ) ; 
String [ ] target = toSegments ( canonical ( targetPath ) ) ; 
if ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; 
String targetFile = "" ; 
if ( ! targetPath . endsWith ( SEPARATOR ) ) { 
targetFile = target [ target . length - 1 ] ; 
target = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; 
} 
String [ ] common = commonPrefix ( start , target ) ; 
String [ ] parents = toParentDirs ( start . length - common . length ) ; 
int relativeStartIdx = common . length ; 
String [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; 
String [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; 
System . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; 
String trailingSep = "" ; 
if ( relativePath . length > 0 ) trailingSep = SEPARATOR ; 
return Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; 
} 
} 

public class ClassUtils { 
public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { 
if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) return false ; 
if ( classArray == null ) classArray = EMPTY_CLASS_ARRAY ; 
if ( toClassArray == null ) toClassArray = EMPTY_CLASS_ARRAY ; 
for ( int i = 0 ; 
i < classArray . length ; 
i ++ ) if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) return false ; 
return true ; 
} 
} 

public class ClientCookieEncoder { 
public String encode ( Cookie cookie ) { 
if ( cookie == null ) throw new NullPointerException ( "cookie" ) ; 
StringBuilder buf = new StringBuilder ( ) ; 
encode ( buf , cookie ) ; 
return stripTrailingSeparator ( buf ) ; 
} 
} 

public class JPAEntityManagerContext { 
public EntityManager em ( ) { 
Deque < EntityManager > ems = this . emStack ( true ) ; 
if ( ems . isEmpty ( ) ) Http . Context . safeCurrent ( ) . map ( ctx -> { 
throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; 
} 
) . orElseGet ( ( ) -> { 
throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; 
} 
) ; 
return ems . peekFirst ( ) ; 
} 
} 

public class JPAEntityManagerContext { 
@ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { 
return Http . Context . safeCurrent ( ) . map ( context -> { 
Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; 
if ( emsObject != null ) return ( Deque < EntityManager > ) emsObject ; 
else { 
Deque < EntityManager > ems = new ArrayDeque < > ( ) ; 
context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; 
return ems ; 
} 
} 
) . orElseGet ( ( ) -> { 
if ( threadLocalFallback ) return this . get ( ) ; 
else throw new RuntimeException ( "No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead." ) ; 
} 
) ; 
} 
} 

public class JPAEntityManagerContext { 
void pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { 
Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; 
if ( em != null ) ems . push ( em ) ; 
else { 
if ( ems . isEmpty ( ) ) throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; 
ems . pop ( ) ; 
} 
} 
} 

public class AkkaStreams { 
public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { 
return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> { 
UniformFanOutShape < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > > broadcast = builder . add ( Broadcast . create ( 2 , true ) ) ; 
UniformFanInShape < Out , Out > merge = builder . add ( mergeStrategy ) ; 
Flow < F . Either < FlowIn , Out > , FlowIn , ? > collectIn = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { 
if ( x . left . isPresent ( ) ) return x . left . get ( ) ; 
else throw Scala . noMatch ( ) ; 
} 
) ) ; 
Flow < F . Either < FlowIn , Out > , Out , ? > collectOut = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { 
if ( x . right . isPresent ( ) ) return x . right . get ( ) ; 
else throw Scala . noMatch ( ) ; 
} 
) ) ; 
Flow < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > , ? > blockCancel = play . api . libs . streams . AkkaStreams . < F . Either < FlowIn , Out > > ignoreAfterCancellation ( ) . asJava ( ) ; 
builder . from ( broadcast . out ( 0 ) ) . via ( builder . add ( collectIn ) ) . via ( builder . add ( flow ) ) . toInlet ( merge . in ( 0 ) ) ; 
builder . from ( broadcast . out ( 1 ) ) . via ( builder . add ( blockCancel ) ) . via ( builder . add ( collectOut ) ) . toInlet ( merge . in ( 1 ) ) ; 
return new FlowShape < > ( broadcast . in ( ) , merge . out ( ) ) ; 
} 
) ) ) ; 
} 
} 

public class Form { 
private List < Object > convertErrorArguments ( Object [ ] arguments ) { 
if ( arguments == null ) return Collections . emptyList ( ) ; 
List < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; 
return Collections . unmodifiableList ( converted ) ; 
} 
} 

public class Form { 
public Form < T > fill ( T value ) { 
if ( value == null ) throw new RuntimeException ( "Cannot fill a form with a null value" ) ; 
return new Form < > ( rootName , backedType , new HashMap < > ( ) , new HashMap < > ( ) , new ArrayList < > ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; 
} 
} 

public class Form { 
public JsonNode errorsAsJson ( Lang lang ) { 
Map < String , List < String > > allMessages = new HashMap < > ( ) ; 
errors . forEach ( error -> { 
if ( error != null ) { 
final List < String > messages = new ArrayList < > ( ) ; 
if ( messagesApi != null && lang != null ) { 
final List < String > reversedMessages = new ArrayList < > ( error . messages ( ) ) ; 
Collections . reverse ( reversedMessages ) ; 
messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; 
} 
else messages . add ( error . message ( ) ) ; 
allMessages . put ( error . key ( ) , messages ) ; 
} 
} 
) ; 
return play . libs . Json . toJson ( allMessages ) ; 
} 
} 

public class Formatters { 
public < T > String print ( T t ) { 
if ( t == null ) return "" ; 
if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) return conversion . convert ( t , String . class ) ; 
else return t . toString ( ) ; 
} 
} 

public class Formatters { 
public < T > String print ( TypeDescriptor desc , T t ) { 
if ( t == null ) return "" ; 
if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; 
else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) return conversion . convert ( t , String . class ) ; 
else return t . toString ( ) ; 
} 
} 

public class ServerCookieEncoder { 
public String encode ( Cookie cookie ) { 
if ( cookie == null ) throw new NullPointerException ( "cookie" ) ; 
final String name = cookie . name ( ) ; 
final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; 
validateCookie ( name , value ) ; 
StringBuilder buf = new StringBuilder ( ) ; 
if ( cookie . wrap ( ) ) addQuoted ( buf , name , value ) ; 
else add ( buf , name , value ) ; 
if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { 
add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; 
Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 ) : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; 
add ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; 
} 
if ( cookie . sameSite ( ) != null ) add ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; 
if ( cookie . path ( ) != null ) add ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; 
if ( cookie . domain ( ) != null ) add ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; 
if ( cookie . isSecure ( ) ) add ( buf , CookieHeaderNames . SECURE ) ; 
if ( cookie . isHttpOnly ( ) ) add ( buf , CookieHeaderNames . HTTPONLY ) ; 
return stripTrailingSeparator ( buf ) ; 
} 
} 

public class WebSocket { 
public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { 
return new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { 
try { 
if ( message instanceof Message . Binary ) return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; 
else if ( message instanceof Message . Text ) return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; 
} 
catch ( Exception e ) { 
return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; 
} 
throw Scala . noMatch ( ) ; 
} 
) , outMessage -> { 
try { 
return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
) ; 
} 
} 

public class WebSocket { 
private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { 
return new WebSocket ( ) { 
@ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { 
return f . apply ( request ) . thenApply ( resultOrFlow -> { 
if ( resultOrFlow . left . isPresent ( ) ) return F . Either . Left ( resultOrFlow . left . get ( ) ) ; 
else { 
Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; 
return F . Either . Right ( flow ) ; 
} 
} 
) ; 
} 
} 
; 
} 
} 

public class MemberUtils { 
static boolean setAccessibleWorkaround ( final AccessibleObject o ) { 
if ( o == null || o . isAccessible ( ) ) return false ; 
final Member m = ( Member ) o ; 
if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) try { 
o . setAccessible ( true ) ; 
return true ; 
} 
catch ( final SecurityException e ) { 
} 
return false ; 
} 
} 

public class MemberUtils { 
private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { 
float cost = 0.0f ; 
Class < ? > cls = srcClass ; 
if ( ! cls . isPrimitive ( ) ) { 
cost += 0.1f ; 
cls = ClassUtils . wrapperToPrimitive ( cls ) ; 
} 
for ( int i = 0 ; 
cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; 
i ++ ) if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { 
cost += 0.1f ; 
if ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) cls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; 
} 
return cost ; 
} 
} 

public class MemberUtils { 
private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { 
final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; 
final boolean isVarArgs = executable . isVarArgs ( ) ; 
float totalCost = 0.0f ; 
final long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; 
if ( srcArgs . length < normalArgsLen ) return Float . MAX_VALUE ; 
for ( int i = 0 ; 
i < normalArgsLen ; 
i ++ ) totalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; 
if ( isVarArgs ) { 
final boolean noVarArgsPassed = srcArgs . length < destArgs . length ; 
final boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; 
final float varArgsCost = 0.001f ; 
final Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; 
if ( noVarArgsPassed ) totalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; 
else if ( explicitArrayForVarags ) { 
final Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; 
totalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; 
} 
else for ( int i = destArgs . length - 1 ; 
i < srcArgs . length ; 
i ++ ) { 
final Class < ? > srcClass = srcArgs [ i ] ; 
totalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; 
} 
} 
return totalCost ; 
} 
} 

public class MemberUtils { 
private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { 
if ( destClass . isPrimitive ( ) ) return getPrimitivePromotionCost ( srcClass , destClass ) ; 
float cost = 0.0f ; 
while ( srcClass != null && ! destClass . equals ( srcClass ) ) { 
if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { 
cost += 0.25f ; 
break ; 
} 
cost ++ ; 
srcClass = srcClass . getSuperclass ( ) ; 
} 
if ( srcClass == null ) cost += 1.5f ; 
return cost ; 
} 
} 

public class CodeEmitter { 
public void cast_numeric ( Type from , Type to ) { 
if ( from != to ) if ( from == Type . DOUBLE_TYPE ) if ( to == Type . FLOAT_TYPE ) mv . visitInsn ( Constants . D2F ) ; 
else if ( to == Type . LONG_TYPE ) mv . visitInsn ( Constants . D2L ) ; 
else { 
mv . visitInsn ( Constants . D2I ) ; 
cast_numeric ( Type . INT_TYPE , to ) ; 
} 
else if ( from == Type . FLOAT_TYPE ) if ( to == Type . DOUBLE_TYPE ) mv . visitInsn ( Constants . F2D ) ; 
else if ( to == Type . LONG_TYPE ) mv . visitInsn ( Constants . F2L ) ; 
else { 
mv . visitInsn ( Constants . F2I ) ; 
cast_numeric ( Type . INT_TYPE , to ) ; 
} 
else if ( from == Type . LONG_TYPE ) if ( to == Type . DOUBLE_TYPE ) mv . visitInsn ( Constants . L2D ) ; 
else if ( to == Type . FLOAT_TYPE ) mv . visitInsn ( Constants . L2F ) ; 
else { 
mv . visitInsn ( Constants . L2I ) ; 
cast_numeric ( Type . INT_TYPE , to ) ; 
} 
else if ( to == Type . BYTE_TYPE ) mv . visitInsn ( Constants . I2B ) ; 
else if ( to == Type . CHAR_TYPE ) mv . visitInsn ( Constants . I2C ) ; 
else if ( to == Type . DOUBLE_TYPE ) mv . visitInsn ( Constants . I2D ) ; 
else if ( to == Type . FLOAT_TYPE ) mv . visitInsn ( Constants . I2F ) ; 
else if ( to == Type . LONG_TYPE ) mv . visitInsn ( Constants . I2L ) ; 
else if ( to == Type . SHORT_TYPE ) mv . visitInsn ( Constants . I2S ) ; 
} 
} 

public class CodeEmitter { 
public void zero_or_null ( Type type ) { 
if ( TypeUtils . isPrimitive ( type ) ) switch ( type . getSort ( ) ) { 
case Type . DOUBLE : push ( 0d ) ; 
break ; 
case Type . LONG : push ( 0L ) ; 
break ; 
case Type . FLOAT : push ( 0f ) ; 
break ; 
case Type . VOID : aconst_null ( ) ; 
default : push ( 0 ) ; 
} 
else aconst_null ( ) ; 
} 
} 

public class CodeEmitter { 
public void unbox_or_zero ( Type type ) { 
if ( TypeUtils . isPrimitive ( type ) ) if ( type != Type . VOID_TYPE ) { 
Label nonNull = make_label ( ) ; 
Label end = make_label ( ) ; 
dup ( ) ; 
ifnonnull ( nonNull ) ; 
pop ( ) ; 
zero_or_null ( type ) ; 
goTo ( end ) ; 
mark ( nonNull ) ; 
unbox ( type ) ; 
mark ( end ) ; 
} 
else checkcast ( type ) ; 
} 
} 

public class BridgeMethodResolver { 
public Map resolveAll ( ) { 
Map resolved = new HashMap ( ) ; 
for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; 
entryIter . hasNext ( ) ; 
) { 
Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; 
Class owner = ( Class ) entry . getKey ( ) ; 
Set bridges = ( Set ) entry . getValue ( ) ; 
try { 
InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( '.' , '/' ) + ".class" ) ; 
if ( is == null ) return resolved ; 
try { 
new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; 
} 
finally { 
is . close ( ) ; 
} 
} 
catch ( IOException ignored ) { 
} 
} 
return resolved ; 
} 
} 

public class BeanGenerator { 
public void setSuperclass ( Class superclass ) { 
if ( superclass != null && superclass . equals ( Object . class ) ) superclass = null ; 
this . superclass = superclass ; 
} 
} 

public class PathUtil { 
public static Path resolve ( final Path base , String child ) { 
if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) child = child . substring ( 1 ) ; 
return base . resolve ( child ) ; 
} 
} 

public class HttpRequest { 
public HttpRequest host ( final String host ) { 
this . host = host ; 
if ( headers . contains ( HEADER_HOST ) ) headerOverwrite ( HEADER_HOST , host ) ; 
return this ; 
} 
} 

public class HttpRequest { 
public HttpRequest path ( String path ) { 
if ( ! path . startsWith ( StringPool . SLASH ) ) path = StringPool . SLASH + path ; 
int ndx = path . indexOf ( '?' ) ; 
if ( ndx != - 1 ) { 
String queryString = path . substring ( ndx + 1 ) ; 
path = path . substring ( 0 , ndx ) ; 
query = HttpUtil . parseQuery ( queryString , true ) ; 
} 
else query = HttpMultiMap . newCaseInsensitiveMap ( ) ; 
this . path = path ; 
return this ; 
} 
} 

public class HttpRequest { 
public HttpRequest cookies ( final Cookie ... cookies ) { 
if ( cookies . length == 0 ) return this ; 
StringBuilder cookieString = new StringBuilder ( ) ; 
boolean first = true ; 
for ( Cookie cookie : cookies ) { 
Integer maxAge = cookie . getMaxAge ( ) ; 
if ( maxAge != null && maxAge . intValue ( ) == 0 ) continue ; 
if ( ! first ) cookieString . append ( "; " ) ; 
first = false ; 
cookieString . append ( cookie . getName ( ) ) ; 
cookieString . append ( '=' ) ; 
cookieString . append ( cookie . getValue ( ) ) ; 
} 
headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; 
return this ; 
} 
} 

public class HttpRequest { 
public String queryString ( ) { 
if ( query == null ) return StringPool . EMPTY ; 
return HttpUtil . buildQuery ( query , queryEncoding ) ; 
} 
} 

public class HttpRequest { 
public String hostUrl ( ) { 
StringBand url = new StringBand ( 8 ) ; 
if ( protocol != null ) { 
url . append ( protocol ) ; 
url . append ( "://" ) ; 
} 
if ( host != null ) url . append ( host ) ; 
if ( port != Defaults . DEFAULT_PORT ) { 
url . append ( ':' ) ; 
url . append ( port ) ; 
} 
return url . toString ( ) ; 
} 
} 

public class HttpRequest { 
public HttpRequest setHostHeader ( ) { 
String hostPort = this . host ; 
if ( port != Defaults . DEFAULT_PORT ) hostPort += StringPool . COLON + port ; 
headerOverwrite ( HEADER_HOST , hostPort ) ; 
return this ; 
} 
} 

public class HttpRequest { 
@ Override protected Buffer buffer ( final boolean fullRequest ) { 
if ( header ( HEADER_HOST ) == null ) setHostHeader ( ) ; 
Buffer formBuffer = formBuffer ( ) ; 
String queryString = queryString ( ) ; 
if ( header ( "User-Agent" ) == null ) header ( "User-Agent" , Defaults . userAgent ) ; 
if ( method . equals ( "POST" ) && ( contentLength ( ) == null ) ) contentLength ( 0 ) ; 
Buffer request = new Buffer ( ) ; 
request . append ( method ) . append ( SPACE ) . append ( path ) ; 
if ( query != null && ! query . isEmpty ( ) ) { 
request . append ( '?' ) ; 
request . append ( queryString ) ; 
} 
request . append ( SPACE ) . append ( httpVersion ) . append ( CRLF ) ; 
populateHeaderAndBody ( request , formBuffer , fullRequest ) ; 
return request ; 
} 
} 

public class Handler { 
static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { 
if ( firstHandler == null ) return null ; 
else firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; 
int handlerStart = firstHandler . startPc . bytecodeOffset ; 
int handlerEnd = firstHandler . endPc . bytecodeOffset ; 
int rangeStart = start . bytecodeOffset ; 
int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; 
if ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) return firstHandler ; 
if ( rangeStart <= handlerStart ) if ( rangeEnd >= handlerEnd ) return firstHandler . nextHandler ; 
else return new Handler ( firstHandler , end , firstHandler . endPc ) ; 
else if ( rangeEnd >= handlerEnd ) return new Handler ( firstHandler , firstHandler . startPc , start ) ; 
else { 
firstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; 
return new Handler ( firstHandler , firstHandler . startPc , start ) ; 
} 
} 
} 

public class BeanUtilBean { 
@ SuppressWarnings ( { 
"unchecked" } 
) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { 
Setter setter = bp . getSetter ( isDeclared ) ; 
if ( setter != null ) { 
invokeSetter ( setter , bp , value ) ; 
return ; 
} 
if ( bp . isMap ( ) ) { 
( ( Map ) bp . bean ) . put ( bp . name , value ) ; 
return ; 
} 
if ( isSilent ) return ; 
throw new BeanException ( "Simple property not found: " + bp . name , bp ) ; 
} 
} 

public class BeanUtilBean { 
@ Override public < T > T getProperty ( final Object bean , final String name ) { 
BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; 
if ( ! isSilent ) { 
resolveNestedProperties ( beanProperty ) ; 
return ( T ) getIndexProperty ( beanProperty ) ; 
} 
else try { 
resolveNestedProperties ( beanProperty ) ; 
return ( T ) getIndexProperty ( beanProperty ) ; 
} 
catch ( Exception ignore ) { 
return null ; 
} 
} 
} 

public class BeanUtilBean { 
@ Override public String extractThisReference ( final String propertyName ) { 
int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; 
if ( ndx == - 1 ) return propertyName ; 
return propertyName . substring ( 0 , ndx ) ; 
} 
} 

public class TemplateData { 
public void setObjectReference ( final String name , final Object object ) { 
if ( objectRefs == null ) objectRefs = new HashMap < > ( ) ; 
objectRefs . put ( name , object ) ; 
} 
} 

public class TemplateData { 
public Object getObjectReference ( final String name ) { 
if ( objectRefs == null ) return null ; 
return objectRefs . get ( name ) ; 
} 
} 

public class TemplateData { 
public Object lookupObject ( final String ref ) { 
Object value = getObjectReference ( ref ) ; 
if ( value == null ) throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; 
return value ; 
} 
} 

public class TemplateData { 
public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { 
if ( tableRefs == null ) return null ; 
TableRefData t = tableRefs . get ( tableRef ) ; 
return t == null ? null : t . desc ; 
} 
} 

public class TemplateData { 
public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { 
for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { 
DbEntityDescriptor ded = entry . getValue ( ) . desc ; 
if ( ded . findByPropertyName ( columnRef ) != null ) return ded ; 
} 
return null ; 
} 
} 

public class TemplateData { 
public String getTableAlias ( final String tableRef ) { 
if ( tableRefs == null ) return null ; 
TableRefData t = tableRefs . get ( tableRef ) ; 
return t == null ? null : t . alias ; 
} 
} 

public class TemplateData { 
public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { 
if ( tableRefs == null ) tableRefs = new HashMap < > ( ) ; 
TableRefData t = new TableRefData ( ded , tableAlias ) ; 
if ( tableRefs . put ( tableReference , t ) != null ) throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; 
} 
} 

public class TemplateData { 
protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { 
DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; 
if ( ded == null ) throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; 
return ded ; 
} 
} 

public class TemplateData { 
public void registerHint ( final String hint ) { 
if ( hints == null ) hints = new ArrayList < > ( hintCount ) ; 
hints . add ( hint ) ; 
} 
} 

public class ValueJsonSerializer { 
@ Override public final boolean serialize ( final JsonContext jsonContext , final T value ) { 
if ( jsonContext . pushValue ( value ) ) return false ; 
serializeValue ( jsonContext , value ) ; 
jsonContext . popValue ( ) ; 
return true ; 
} 
} 

public class RequestScope { 
protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { 
final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; 
final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; 
while ( paramNames . hasMoreElements ( ) ) { 
final String paramName = paramNames . nextElement ( ) ; 
if ( servletRequest . getAttribute ( paramName ) != null ) continue ; 
targets . forEachTargetAndIn ( this , ( target , in ) -> { 
final String name = in . matchedName ( paramName ) ; 
if ( name != null ) { 
String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; 
paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; 
if ( paramValues != null ) { 
if ( encode ) for ( int j = 0 ; 
j < paramValues . length ; 
j ++ ) { 
final String p = paramValues [ j ] ; 
if ( p != null ) { 
final String encoding = madvocEncoding . getEncoding ( ) ; 
paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; 
} 
} 
final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; 
target . writeValue ( name , value , true ) ; 
} 
} 
} 
) ; 
} 
} 
} 

public class RequestScope { 
protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { 
if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) return ; 
final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; 
if ( ! multipartRequest . isMultipart ( ) ) return ; 
final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; 
while ( paramNames . hasMoreElements ( ) ) { 
final String paramName = paramNames . nextElement ( ) ; 
if ( servletRequest . getAttribute ( paramName ) != null ) continue ; 
targets . forEachTargetAndIn ( this , ( target , in ) -> { 
final String name = in . matchedName ( paramName ) ; 
if ( name != null ) { 
final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; 
if ( ignoreInvalidUploadFiles ) for ( int j = 0 ; 
j < paramValues . length ; 
j ++ ) { 
final FileUpload paramValue = paramValues [ j ] ; 
if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) paramValues [ j ] = null ; 
} 
final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; 
target . writeValue ( name , value , true ) ; 
} 
} 
) ; 
} 
} 
} 

public class ColumnNamingStrategy { 
public String convertPropertyNameToColumnName ( final String propertyName ) { 
StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; 
if ( splitCamelCase ) { 
String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; 
tableName . append ( convertedTableName ) ; 
} 
else tableName . append ( propertyName ) ; 
if ( ! changeCase ) return tableName . toString ( ) ; 
return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; 
} 
} 

public class ColumnNamingStrategy { 
public String convertColumnNameToPropertyName ( final String columnName ) { 
StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; 
int len = columnName . length ( ) ; 
if ( splitCamelCase ) { 
boolean toUpper = false ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c = columnName . charAt ( i ) ; 
if ( c == separatorChar ) { 
toUpper = true ; 
continue ; 
} 
if ( toUpper ) { 
propertyName . append ( Character . toUpperCase ( c ) ) ; 
toUpper = false ; 
} 
else propertyName . append ( Character . toLowerCase ( c ) ) ; 
} 
return propertyName . toString ( ) ; 
} 
return columnName ; 
} 
} 

public class SqlType { 
@ SuppressWarnings ( { 
"unchecked" } 
) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { 
if ( t == null ) return null ; 
if ( destinationType == null ) return ( E ) t ; 
return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; 
} 
} 

public class FileNameUtil { 
public static String separatorsToSystem ( final String path ) { 
if ( path == null ) return null ; 
if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) return separatorsToWindows ( path ) ; 
else return separatorsToUnix ( path ) ; 
} 
} 

public class FileNameUtil { 
private static String doGetPath ( final String filename , final int separatorAdd ) { 
if ( filename == null ) return null ; 
int prefix = getPrefixLength ( filename ) ; 
if ( prefix < 0 ) return null ; 
int index = indexOfLastSeparator ( filename ) ; 
int endIndex = index + separatorAdd ; 
if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) return StringPool . EMPTY ; 
return filename . substring ( prefix , endIndex ) ; 
} 
} 

public class FileNameUtil { 
public static String [ ] split ( final String filename ) { 
String prefix = getPrefix ( filename ) ; 
if ( prefix == null ) prefix = StringPool . EMPTY ; 
int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; 
int lastExtensionIndex = indexOfExtension ( filename ) ; 
String path ; 
String baseName ; 
String extension ; 
if ( lastSeparatorIndex == - 1 ) { 
path = StringPool . EMPTY ; 
if ( lastExtensionIndex == - 1 ) { 
baseName = filename . substring ( prefix . length ( ) ) ; 
extension = StringPool . EMPTY ; 
} 
else { 
baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; 
extension = filename . substring ( lastExtensionIndex + 1 ) ; 
} 
} 
else { 
path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; 
if ( lastExtensionIndex == - 1 ) { 
baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; 
extension = StringPool . EMPTY ; 
} 
else { 
baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; 
extension = filename . substring ( lastExtensionIndex + 1 ) ; 
} 
} 
return new String [ ] { 
prefix , path , baseName , extension } 
; 
} 
} 

public class WebApp { 
protected void registerMadvocComponents ( ) { 
if ( madvocContainer == null ) throw new MadvocException ( "Madvoc WebApp not initialized." ) ; 
log . debug ( "Registering Madvoc WebApp components" ) ; 
madvocContainer . registerComponent ( MadvocEncoding . class ) ; 
madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; 
madvocContainer . registerComponent ( ActionConfigManager . class ) ; 
madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; 
madvocContainer . registerComponent ( ActionMethodParser . class ) ; 
madvocContainer . registerComponent ( ActionPathRewriter . class ) ; 
madvocContainer . registerComponent ( ActionsManager . class ) ; 
madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; 
madvocContainer . registerComponent ( InterceptorsManager . class ) ; 
madvocContainer . registerComponent ( FiltersManager . class ) ; 
madvocContainer . registerComponent ( MadvocController . class ) ; 
madvocContainer . registerComponent ( RootPackages . class ) ; 
madvocContainer . registerComponent ( ResultsManager . class ) ; 
madvocContainer . registerComponent ( ResultMapper . class ) ; 
madvocContainer . registerComponent ( ScopeResolver . class ) ; 
madvocContainer . registerComponent ( ScopeDataInspector . class ) ; 
madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; 
madvocContainer . registerComponent ( FileUploader . class ) ; 
} 
} 

public class ClassScanner { 
protected void scanJarFile ( final File file ) { 
final ZipFile zipFile ; 
try { 
zipFile = new ZipFile ( file ) ; 
} 
catch ( IOException ioex ) { 
if ( ! ignoreException ) throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; 
return ; 
} 
final Enumeration entries = zipFile . entries ( ) ; 
while ( entries . hasMoreElements ( ) ) { 
final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; 
final String zipEntryName = zipEntry . getName ( ) ; 
try { 
if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { 
final String entryName = prepareEntryName ( zipEntryName , true ) ; 
final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; 
try { 
scanEntry ( classPathEntry ) ; 
} 
finally { 
classPathEntry . closeInputStream ( ) ; 
} 
} 
else if ( includeResources ) { 
final String entryName = prepareEntryName ( zipEntryName , false ) ; 
final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; 
try { 
scanEntry ( classPathEntry ) ; 
} 
finally { 
classPathEntry . closeInputStream ( ) ; 
} 
} 
} 
catch ( RuntimeException rex ) { 
if ( ! ignoreException ) { 
ZipUtil . close ( zipFile ) ; 
throw rex ; 
} 
} 
} 
ZipUtil . close ( zipFile ) ; 
} 
} 

public class ClassScanner { 
protected void scanClassPath ( final File root ) { 
String rootPath = root . getAbsolutePath ( ) ; 
if ( ! rootPath . endsWith ( File . separator ) ) rootPath += File . separatorChar ; 
final FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; 
File file ; 
while ( ( file = ff . nextFile ( ) ) != null ) { 
final String filePath = file . getAbsolutePath ( ) ; 
try { 
if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) scanClassFile ( filePath , rootPath , file , true ) ; 
else if ( includeResources ) scanClassFile ( filePath , rootPath , file , false ) ; 
} 
catch ( RuntimeException rex ) { 
if ( ! ignoreException ) throw rex ; 
} 
} 
} 
} 

public class ClassScanner { 
public void start ( ) { 
if ( detectEntriesMode ) rulesEntries . detectMode ( ) ; 
filesToScan . forEach ( file -> { 
final String path = file . getAbsolutePath ( ) ; 
if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { 
if ( ! acceptJar ( file ) ) return ; 
scanJarFile ( file ) ; 
} 
else if ( file . isDirectory ( ) ) scanClassPath ( file ) ; 
} 
) ; 
} 
} 

public class ScopeResolver { 
@ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { 
if ( scopeClass == null ) return ( S ) getOrInitScope ( RequestScope . class ) ; 
return ( S ) getOrInitScope ( scopeClass ) ; 
} 
} 

public class ScopeResolver { 
protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { 
for ( final MadvocScope s : allScopes ) { 
if ( s . getClass ( ) . equals ( madvocScopeType ) ) return s ; 
} 
final MadvocScope newScope ; 
try { 
newScope = madpc . createBean ( madvocScopeType ) ; 
} 
catch ( Exception ex ) { 
throw new MadvocException ( "Unable to create scope: " + madvocScopeType , ex ) ; 
} 
allScopes . add ( newScope ) ; 
return newScope ; 
} 
} 

public class Base64 { 
public static byte [ ] decode ( final char [ ] arr ) { 
int length = arr . length ; 
if ( length == 0 ) return new byte [ 0 ] ; 
int sndx = 0 , endx = length - 1 ; 
int pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; 
int cnt = endx - sndx + 1 ; 
int sepCnt = length > 76 ? ( arr [ 76 ] == '\r' ? cnt / 78 : 0 ) << 1 : 0 ; 
int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; 
byte [ ] dest = new byte [ len ] ; 
int d = 0 ; 
for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; 
d < eLen ; 
) { 
int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; 
dest [ d ++ ] = ( byte ) ( i >> 16 ) ; 
dest [ d ++ ] = ( byte ) ( i >> 8 ) ; 
dest [ d ++ ] = ( byte ) i ; 
if ( sepCnt > 0 && ++ cc == 19 ) { 
sndx += 2 ; 
cc = 0 ; 
} 
} 
if ( d < len ) { 
int i = 0 ; 
for ( int j = 0 ; 
sndx <= endx - pad ; 
j ++ ) i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; 
for ( int r = 16 ; 
d < len ; 
r -= 8 ) dest [ d ++ ] = ( byte ) ( i >> r ) ; 
} 
return dest ; 
} 
} 

public class CsrfShield { 
protected static void assureSize ( final Set < Token > tokenSet ) { 
if ( tokenSet . size ( ) < maxTokensPerSession ) return ; 
long validUntilMin = Long . MAX_VALUE ; 
Token tokenToRemove = null ; 
Iterator < Token > iterator = tokenSet . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
Token token = iterator . next ( ) ; 
if ( token . isExpired ( ) ) { 
iterator . remove ( ) ; 
continue ; 
} 
if ( token . validUntil < validUntilMin ) { 
validUntilMin = token . validUntil ; 
tokenToRemove = token ; 
} 
} 
if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) tokenSet . remove ( tokenToRemove ) ; 
} 
} 

public class CsrfShield { 
@ SuppressWarnings ( { 
"unchecked" } 
) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { 
Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; 
if ( ( tokenSet == null ) && ( tokenValue == null ) ) return true ; 
if ( ( tokenSet == null ) || ( tokenValue == null ) ) return false ; 
boolean found = false ; 
Iterator < Token > it = tokenSet . iterator ( ) ; 
while ( it . hasNext ( ) ) { 
Token t = it . next ( ) ; 
if ( t . isExpired ( ) ) { 
it . remove ( ) ; 
continue ; 
} 
if ( t . getValue ( ) . equals ( tokenValue ) ) { 
it . remove ( ) ; 
found = true ; 
} 
} 
return found ; 
} 
} 

public class BeanCopy { 
@ Override protected boolean visitProperty ( String name , final Object value ) { 
if ( isTargetMap ) name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; 
beanUtil . setProperty ( destination , name , value ) ; 
return true ; 
} 
} 

public class TableChunk { 
@ Override public void init ( final TemplateData templateData ) { 
super . init ( templateData ) ; 
if ( entity != null ) ded = lookupType ( entity ) ; 
else { 
Object object = templateData . getObjectReference ( entityName ) ; 
if ( object != null ) ded = lookupType ( resolveClass ( object ) ) ; 
else ded = lookupName ( entityName ) ; 
} 
String tableReference = this . tableReference ; 
if ( tableReference == null ) tableReference = tableAlias ; 
if ( tableReference == null ) tableReference = entityName ; 
if ( tableReference == null ) tableReference = ded . getEntityName ( ) ; 
templateData . registerTableReference ( tableReference , ded , tableAlias ) ; 
} 
} 

public class PetiteBeans { 
public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { 
if ( name == null ) name = resolveBeanName ( type ) ; 
if ( wiringMode == null ) wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; 
if ( wiringMode == WiringMode . DEFAULT ) wiringMode = petiteConfig . getDefaultWiringMode ( ) ; 
if ( scopeType == null ) scopeType = annotationResolver . resolveBeanScopeType ( type ) ; 
if ( scopeType == null ) scopeType = SingletonScope . class ; 
BeanDefinition existing = removeBean ( name ) ; 
if ( existing != null ) if ( petiteConfig . getDetectDuplicatedBeanNames ( ) ) throw new PetiteException ( "Duplicated bean name detected while registering class '" + type . getName ( ) + "'. Petite bean class '" + existing . type . getName ( ) + "' is already registered with the name: " + name ) ; 
if ( type . isInterface ( ) ) throw new PetiteException ( "PetiteBean can not be an interface: " + type . getName ( ) ) ; 
if ( log . isDebugEnabled ( ) ) log . info ( "Petite bean: [" + name + "] --> " + type . getName ( ) + " @ " + scopeType . getSimpleName ( ) + ":" + wiringMode . toString ( ) ) ; 
Scope scope = resolveScope ( scopeType ) ; 
BeanDefinition < T > beanDefinition = createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; 
registerBean ( name , beanDefinition ) ; 
ProviderDefinition [ ] providerDefinitions = petiteResolvers . resolveProviderDefinitions ( type , name ) ; 
if ( providerDefinitions != null ) for ( ProviderDefinition providerDefinition : providerDefinitions ) { 
providers . put ( providerDefinition . name , providerDefinition ) ; 
} 
if ( define ) { 
beanDefinition . ctor = petiteResolvers . resolveCtorInjectionPoint ( beanDefinition . type ( ) ) ; 
beanDefinition . properties = PropertyInjectionPoint . EMPTY ; 
beanDefinition . methods = MethodInjectionPoint . EMPTY ; 
beanDefinition . initMethods = InitMethodPoint . EMPTY ; 
beanDefinition . destroyMethods = DestroyMethodPoint . EMPTY ; 
} 
return beanDefinition ; 
} 
} 

public class PetiteBeans { 
protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { 
beans . put ( name , beanDefinition ) ; 
if ( ! petiteConfig . isUseAltBeanNames ( ) ) return ; 
Class type = beanDefinition . type ( ) ; 
if ( annotationResolver . beanHasAnnotationName ( type ) ) return ; 
Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; 
for ( Class anInterface : interfaces ) { 
String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; 
if ( name . equals ( altName ) ) continue ; 
if ( beans . containsKey ( altName ) ) continue ; 
if ( beansAlt . containsKey ( altName ) ) { 
BeanDefinition existing = beansAlt . get ( altName ) ; 
if ( existing != null ) beansAlt . put ( altName , null ) ; 
} 
else beansAlt . put ( altName , beanDefinition ) ; 
} 
} 
} 

public class PetiteBeans { 
public void removeBean ( final Class type ) { 
Set < String > beanNames = new HashSet < > ( ) ; 
for ( BeanDefinition def : beans . values ( ) ) { 
if ( def . type . equals ( type ) ) beanNames . add ( def . name ) ; 
} 
for ( String beanName : beanNames ) { 
removeBean ( beanName ) ; 
} 
} 
} 

public class PetiteBeans { 
protected String [ ] resolveBeanNamesForType ( final Class type ) { 
String [ ] beanNames = beanCollections . get ( type ) ; 
if ( beanNames != null ) return beanNames ; 
ArrayList < String > list = new ArrayList < > ( ) ; 
for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { 
BeanDefinition beanDefinition = entry . getValue ( ) ; 
if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { 
String beanName = entry . getKey ( ) ; 
list . add ( beanName ) ; 
} 
} 
if ( list . isEmpty ( ) ) beanNames = StringPool . EMPTY_ARRAY ; 
else beanNames = list . toArray ( new String [ 0 ] ) ; 
beanCollections . put ( type , beanNames ) ; 
return beanNames ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
Constructor constructor = null ; 
if ( paramTypes == null ) { 
CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; 
if ( ctors != null && ctors . length > 0 ) { 
if ( ctors . length > 1 ) throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; 
constructor = ctors [ 0 ] . getConstructor ( ) ; 
} 
} 
else { 
CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; 
if ( ctorDescriptor != null ) constructor = ctorDescriptor . getConstructor ( ) ; 
} 
if ( constructor == null ) throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; 
BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; 
beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; 
if ( propertyDescriptor == null ) throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + '#' + property ) ; 
BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; 
PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; 
beanDefinition . addPropertyInjectionPoint ( pip ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; 
if ( propertyDescriptor == null ) throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + '#' + property ) ; 
SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; 
beanDefinition . addSetInjectionPoint ( sip ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
Method method = null ; 
if ( arguments == null ) { 
MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; 
if ( methods != null && methods . length > 0 ) { 
if ( methods . length > 1 ) throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + '#' + methodName ) ; 
method = methods [ 0 ] . getMethod ( ) ; 
} 
} 
else { 
MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; 
if ( md != null ) method = md . getMethod ( ) ; 
} 
if ( method == null ) throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + '#' + methodName ) ; 
BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; 
MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; 
beanDefinition . addMethodInjectionPoint ( mip ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
if ( initMethodNames == null ) initMethodNames = StringPool . EMPTY_ARRAY ; 
int total = initMethodNames . length ; 
InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; 
int i ; 
for ( i = 0 ; 
i < initMethodNames . length ; 
i ++ ) { 
MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; 
if ( md == null ) throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; 
initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; 
} 
beanDefinition . addInitMethodPoints ( initMethodPoints ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
if ( destroyMethodNames == null ) destroyMethodNames = StringPool . EMPTY_ARRAY ; 
int total = destroyMethodNames . length ; 
DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; 
int i ; 
for ( i = 0 ; 
i < destroyMethodNames . length ; 
i ++ ) { 
MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; 
if ( md == null ) throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; 
destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; 
} 
beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { 
BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; 
if ( beanDefinition == null ) throw new PetiteException ( "Bean not found: " + beanName ) ; 
Class beanType = beanDefinition . type ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; 
MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; 
if ( md == null ) throw new PetiteException ( "Provider method not found: " + methodName ) ; 
ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; 
providers . put ( providerName , providerDefinition ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; 
if ( md == null ) throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; 
ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; 
providers . put ( providerName , providerDefinition ) ; 
} 
} 

public class PetiteBeans { 
public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { 
forEachBean ( bd -> { 
if ( ClassUtil . isTypeOf ( bd . type , type ) ) beanNameConsumer . accept ( bd . name ) ; 
} 
) ; 
} 
} 

public class ProxettaAsmUtil { 
public static void pushInt ( final MethodVisitor mv , final int value ) { 
if ( value <= 5 ) mv . visitInsn ( ICONST_0 + value ) ; 
else if ( value <= Byte . MAX_VALUE ) mv . visitIntInsn ( BIPUSH , value ) ; 
else mv . visitIntInsn ( SIPUSH , value ) ; 
} 
} 

public class ProxettaAsmUtil { 
public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { 
if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; 
} 
} 

public class ProxettaAsmUtil { 
public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { 
mv . visitVarInsn ( ALOAD , 0 ) ; 
for ( int i = 1 ; 
i <= methodInfo . getArgumentsCount ( ) ; 
i ++ ) loadMethodArgument ( mv , methodInfo , i ) ; 
} 
} 

public class ProxettaAsmUtil { 
public static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { 
for ( int i = 0 ; 
i < methodInfo . getArgumentsCount ( ) ; 
i ++ ) loadMethodArgument ( mv , methodInfo , i ) ; 
} 
} 

public class ProxettaAsmUtil { 
public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { 
for ( int i = 1 ; 
i <= methodInfo . getArgumentsCount ( ) ; 
i ++ ) loadMethodArgument ( mv , methodInfo , i ) ; 
} 
} 

public class EmailUtil { 
public static String extractEncoding ( final String contentType , String defaultEncoding ) { 
String encoding = extractEncoding ( contentType ) ; 
if ( encoding == null ) { 
if ( defaultEncoding == null ) defaultEncoding = JoddCore . encoding ; 
encoding = defaultEncoding ; 
} 
return encoding ; 
} 
} 

public class EmailUtil { 
public static boolean isEmptyFlags ( Flags flags ) { 
if ( flags == null ) return true ; 
Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; 
if ( systemFlags != null && systemFlags . length > 0 ) return false ; 
String [ ] userFlags = flags . getUserFlags ( ) ; 
if ( userFlags != null && userFlags . length > 0 ) return false ; 
return true ; 
} 
} 

public class ServletUtil { 
public static String resolveAuthBearerToken ( final HttpServletRequest request ) { 
String header = request . getHeader ( HEADER_AUTHORIZATION ) ; 
if ( header == null ) return null ; 
int ndx = header . indexOf ( "Bearer " ) ; 
if ( ndx == - 1 ) return null ; 
return header . substring ( ndx + 7 ) . trim ( ) ; 
} 
} 

public class ServletUtil { 
public static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { 
if ( ! file . exists ( ) ) throw new IllegalArgumentException ( "File not found: " + file ) ; 
if ( file . length ( ) > Integer . MAX_VALUE ) throw new IllegalArgumentException ( "File too big: " + file ) ; 
prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; 
} 
} 

public class ServletUtil { 
public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { 
if ( ( mimeType == null ) && ( fileName != null ) ) { 
String extension = FileNameUtil . getExtension ( fileName ) ; 
mimeType = MimeTypes . getMimeType ( extension ) ; 
} 
if ( mimeType != null ) response . setContentType ( mimeType ) ; 
if ( fileSize >= 0 ) response . setContentLength ( fileSize ) ; 
if ( fileName != null ) { 
String name = FileNameUtil . getName ( fileName ) ; 
String encodedFileName = URLCoder . encode ( name ) ; 
response . setHeader ( CONTENT_DISPOSITION , "attachment;filename=\"" + name + "\";filename*=utf8''" + encodedFileName ) ; 
} 
} 
} 

public class ServletUtil { 
public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { 
Cookie [ ] cookies = request . getCookies ( ) ; 
if ( cookies == null ) return null ; 
ArrayList < Cookie > list = new ArrayList < > ( cookies . length ) ; 
for ( Cookie cookie : cookies ) { 
if ( cookie . getName ( ) . equals ( cookieName ) ) list . add ( cookie ) ; 
} 
if ( list . isEmpty ( ) ) return null ; 
return list . toArray ( new Cookie [ 0 ] ) ; 
} 
} 

public class ServletUtil { 
public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { 
String charEncoding = request . getCharacterEncoding ( ) ; 
if ( charEncoding == null ) charEncoding = JoddCore . encoding ; 
CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; 
BufferedReader bufferedReader = null ; 
try { 
InputStream inputStream = request . getInputStream ( ) ; 
if ( inputStream != null ) { 
bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; 
StreamUtil . copy ( bufferedReader , charArrayWriter ) ; 
} 
else return StringPool . EMPTY ; 
} 
finally { 
StreamUtil . close ( bufferedReader ) ; 
} 
return charArrayWriter . toString ( ) ; 
} 
} 

public class ServletUtil { 
public boolean isGetParameter ( final HttpServletRequest request , String name ) { 
name = URLCoder . encodeQueryParam ( name ) + '=' ; 
String query = request . getQueryString ( ) ; 
String [ ] nameValuePairs = StringUtil . splitc ( query , '&' ) ; 
for ( String nameValuePair : nameValuePairs ) { 
if ( nameValuePair . startsWith ( name ) ) return true ; 
} 
return false ; 
} 
} 

public class ServletUtil { 
public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { 
if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { 
int emptyCount = 0 ; 
int total = paramValues . length ; 
for ( int i = 0 ; 
i < paramValues . length ; 
i ++ ) { 
String paramValue = paramValues [ i ] ; 
if ( paramValue == null ) { 
emptyCount ++ ; 
continue ; 
} 
if ( paramValue . length ( ) == 0 ) { 
emptyCount ++ ; 
if ( treatEmptyParamsAsNull ) paramValue = null ; 
} 
paramValues [ i ] = paramValue ; 
} 
if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) return null ; 
} 
return paramValues ; 
} 
} 

public class ServletUtil { 
public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { 
Enumeration paramNames = servletRequest . getParameterNames ( ) ; 
while ( paramNames . hasMoreElements ( ) ) { 
String paramName = ( String ) paramNames . nextElement ( ) ; 
if ( servletRequest . getAttribute ( paramName ) != null ) continue ; 
String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; 
paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; 
if ( paramValues == null ) continue ; 
servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; 
} 
if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) return ; 
MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; 
if ( ! multipartRequest . isMultipart ( ) ) return ; 
paramNames = multipartRequest . getFileParameterNames ( ) ; 
while ( paramNames . hasMoreElements ( ) ) { 
String paramName = ( String ) paramNames . nextElement ( ) ; 
if ( servletRequest . getAttribute ( paramName ) != null ) continue ; 
FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; 
servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; 
} 
} 
} 

public class TagUtil { 
public static void invokeBody ( final JspFragment body ) throws JspException { 
if ( body == null ) return ; 
try { 
body . invoke ( null ) ; 
} 
catch ( IOException ioex ) { 
throw new JspException ( "Tag body failed" , ioex ) ; 
} 
} 
} 

public class BeanData { 
public void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { 
for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { 
if ( invocationStrategy != initMethod . invocationStrategy ) continue ; 
try { 
initMethod . method . invoke ( bean ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; 
} 
} 
} 
} 

public class BeanData { 
public Object newBeanInstance ( ) { 
if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; 
int paramNo = beanDefinition . ctor . references . length ; 
Object [ ] args = new Object [ paramNo ] ; 
if ( beanDefinition . wiringMode != WiringMode . NONE ) for ( int i = 0 ; 
i < paramNo ; 
i ++ ) { 
args [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; 
if ( args [ i ] == null ) if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) throw new PetiteException ( "Wiring constructor failed. References '" + beanDefinition . ctor . references [ i ] + "' not found for constructor: " + beanDefinition . ctor . constructor ) ; 
} 
final Object bean ; 
try { 
bean = beanDefinition . ctor . constructor . newInstance ( args ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Failed to create new bean instance '" + beanDefinition . type . getName ( ) + "' using constructor: " + beanDefinition . ctor . constructor , ex ) ; 
} 
return bean ; 
} 
} 

public class BeanData { 
public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { 
if ( beanDefinition . name == null ) return ; 
if ( implicitParamInjection ) { 
final int len = beanDefinition . name . length ( ) + 1 ; 
for ( final String param : beanDefinition . params ) { 
final Object value = paramManager . get ( param ) ; 
final String destination = param . substring ( len ) ; 
try { 
BeanUtil . declared . setProperty ( bean , destination , value ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Unable to set parameter: '" + param + "' to bean: " + beanDefinition . name , ex ) ; 
} 
} 
} 
for ( final ValueInjectionPoint pip : beanDefinition . values ) { 
final String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; 
try { 
BeanUtil . declared . setProperty ( bean , pip . property , value ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Unable to set value for: '" + pip . valueTemplate + "' to bean: " + beanDefinition . name , ex ) ; 
} 
} 
} 
} 

public class PropsData { 
protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { 
String realValue = value ; 
if ( append || appendDuplicateProps ) { 
PropsEntry pv = map . get ( key ) ; 
if ( pv != null ) realValue = pv . value + APPEND_SEPARATOR + realValue ; 
} 
PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; 
if ( first == null ) first = propsEntry ; 
else last . next = propsEntry ; 
last = propsEntry ; 
map . put ( key , propsEntry ) ; 
} 
} 

public class PropsData { 
public PropsEntry getProfileProperty ( final String profile , final String key ) { 
final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; 
if ( profileMap == null ) return null ; 
return profileMap . get ( key ) ; 
} 
} 

public class PropsData { 
public String resolveMacros ( String value , final String ... profiles ) { 
StringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; 
stringTemplateParser . setResolveEscapes ( false ) ; 
if ( ! ignoreMissingMacros ) stringTemplateParser . setReplaceMissingKey ( false ) ; 
else { 
stringTemplateParser . setReplaceMissingKey ( true ) ; 
stringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; 
} 
final Function < String , String > macroResolver = macroName -> { 
String [ ] lookupProfiles = profiles ; 
int leftIndex = macroName . indexOf ( '<' ) ; 
if ( leftIndex != - 1 ) { 
int rightIndex = macroName . indexOf ( '>' ) ; 
String profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; 
macroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; 
lookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; 
StringUtil . trimAll ( lookupProfiles ) ; 
} 
return lookupValue ( macroName , lookupProfiles ) ; 
} 
; 
int loopCount = 0 ; 
while ( loopCount ++ < MAX_INNER_MACROS ) { 
final String newValue = stringTemplateParser . parse ( value , macroResolver ) ; 
if ( newValue . equals ( value ) ) break ; 
if ( skipEmptyProps ) if ( newValue . length ( ) == 0 ) return null ; 
value = newValue ; 
} 
return value ; 
} 
} 

public class PropsData { 
public Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { 
if ( target == null ) target = new HashMap ( ) ; 
if ( prefix != null ) if ( ! StringUtil . endsWithChar ( prefix , '.' ) ) prefix += StringPool . DOT ; 
if ( profiles != null ) for ( String profile : profiles ) { 
while ( true ) { 
final Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; 
if ( map != null ) extractMap ( target , map , profiles , wildcardPatterns , prefix ) ; 
final int ndx = profile . lastIndexOf ( '.' ) ; 
if ( ndx == - 1 ) break ; 
profile = profile . substring ( 0 , ndx ) ; 
} 
} 
extractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; 
return target ; 
} 
} 

public class BCrypt { 
public static String hashpw ( String password , String salt ) { 
BCrypt B ; 
String real_salt ; 
byte [ ] passwordb , saltb , hashed ; 
char minor = ( char ) 0 ; 
int rounds , off ; 
StringBuffer rs = new StringBuffer ( ) ; 
if ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) throw new IllegalArgumentException ( "Invalid salt version" ) ; 
if ( salt . charAt ( 2 ) == '$' ) off = 3 ; 
else { 
minor = salt . charAt ( 2 ) ; 
if ( minor != 'a' || salt . charAt ( 3 ) != '$' ) throw new IllegalArgumentException ( "Invalid salt revision" ) ; 
off = 4 ; 
} 
if ( salt . charAt ( off + 2 ) > '$' ) throw new IllegalArgumentException ( "Missing salt rounds" ) ; 
rounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; 
real_salt = salt . substring ( off + 3 , off + 25 ) ; 
try { 
passwordb = ( password + ( minor >= 'a' ? "\000" : "" ) ) . getBytes ( "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException uee ) { 
throw new AssertionError ( "UTF-8 is not supported" ) ; 
} 
saltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; 
B = new BCrypt ( ) ; 
hashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; 
rs . append ( "$2" ) ; 
if ( minor >= 'a' ) rs . append ( minor ) ; 
rs . append ( '$' ) ; 
if ( rounds < 10 ) rs . append ( '0' ) ; 
if ( rounds > 30 ) throw new IllegalArgumentException ( "rounds exceeds maximum (30)" ) ; 
rs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; 
return rs . toString ( ) ; 
} 
} 

public class BCrypt { 
public static boolean checkpw ( String plaintext , String hashed ) { 
byte [ ] hashed_bytes ; 
byte [ ] try_bytes ; 
try { 
String try_pw = hashpw ( plaintext , hashed ) ; 
hashed_bytes = hashed . getBytes ( "UTF-8" ) ; 
try_bytes = try_pw . getBytes ( "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException uee ) { 
return false ; 
} 
if ( hashed_bytes . length != try_bytes . length ) return false ; 
byte ret = 0 ; 
for ( int i = 0 ; 
i < try_bytes . length ; 
i ++ ) ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; 
return ret == 0 ; 
} 
} 

public class MultipartRequestInputStream { 
public int copyAll ( final OutputStream out ) throws IOException { 
int count = 0 ; 
while ( true ) { 
byte b = readByte ( ) ; 
if ( isBoundary ( b ) ) break ; 
out . write ( b ) ; 
count ++ ; 
} 
return count ; 
} 
} 

public class MultipartRequestInputStream { 
public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { 
int count = 0 ; 
while ( true ) { 
byte b = readByte ( ) ; 
if ( isBoundary ( b ) ) break ; 
out . write ( b ) ; 
count ++ ; 
if ( count == maxBytes ) return count ; 
} 
return count ; 
} 
} 

public class ActionMethodParser { 
public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { 
final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; 
final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ; 
ActionInterceptor [ ] actionInterceptors = parseActionInterceptors ( actionClass , actionMethod , actionConfig ) ; 
ActionFilter [ ] actionFilters = parseActionFilters ( actionClass , actionMethod , actionConfig ) ; 
if ( actionDefinition == null ) actionDefinition = parseActionDefinition ( actionClass , actionMethod ) ; 
detectAndRegisterAlias ( annotationValues , actionDefinition ) ; 
final boolean async = parseMethodAsyncFlag ( actionMethod ) ; 
final boolean auth = parseMethodAuthFlag ( actionMethod ) ; 
final Class < ? extends ActionResult > actionResult = parseActionResult ( actionMethod ) ; 
final Class < ? extends ActionResult > defaultActionResult = actionConfig . getActionResult ( ) ; 
return createActionRuntime ( null , actionClass , actionMethod , actionResult , defaultActionResult , actionFilters , actionInterceptors , actionDefinition , async , auth ) ; 
} 
} 

public class ActionMethodParser { 
protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { 
final Class < ? extends Annotation > annotationType ; 
if ( annotationValues == null ) annotationType = Action . class ; 
else annotationType = annotationValues . annotationType ( ) ; 
return actionConfigManager . lookup ( annotationType ) ; 
} 
} 

public class ActionMethodParser { 
protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { 
Class < ? extends ActionInterceptor > [ ] result = null ; 
InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; 
if ( interceptedBy != null ) { 
result = interceptedBy . value ( ) ; 
if ( result . length == 0 ) result = null ; 
} 
return result ; 
} 
} 

public class ActionMethodParser { 
protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { 
Class < ? extends ActionFilter > [ ] result = null ; 
FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; 
if ( filteredBy != null ) { 
result = filteredBy . value ( ) ; 
if ( result . length == 0 ) result = null ; 
} 
return result ; 
} 
} 

public class ActionMethodParser { 
protected String [ ] readPackageActionPath ( final Class actionClass ) { 
Package actionPackage = actionClass . getPackage ( ) ; 
final String actionPackageName = actionPackage . getName ( ) ; 
String packageActionPathFromAnnotation ; 
mainloop : while ( true ) { 
MadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; 
packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; 
if ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) packageActionPathFromAnnotation = null ; 
if ( packageActionPathFromAnnotation == null ) { 
String newPackage = actionPackage . getName ( ) ; 
actionPackage = null ; 
while ( actionPackage == null ) { 
final int ndx = newPackage . lastIndexOf ( '.' ) ; 
if ( ndx == - 1 ) break mainloop ; 
newPackage = newPackage . substring ( 0 , ndx ) ; 
actionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; 
} 
} 
else { 
rootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; 
break ; 
} 
} 
String packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; 
if ( packagePath == null ) return ArraysUtil . array ( null , null ) ; 
return ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; 
} 
} 

public class ActionMethodParser { 
protected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { 
String methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; 
if ( methodActionPath == null ) methodActionPath = methodName ; 
else if ( methodActionPath . equals ( Action . NONE ) ) return ArraysUtil . array ( null , null ) ; 
for ( String path : actionConfig . getActionMethodNames ( ) ) { 
if ( methodActionPath . equals ( path ) ) { 
methodActionPath = null ; 
break ; 
} 
} 
return ArraysUtil . array ( methodName , methodActionPath ) ; 
} 
} 

public class ActionMethodParser { 
protected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { 
String alias = null ; 
if ( annotationValues != null ) alias = annotationValues . alias ( ) ; 
return alias ; 
} 
} 

public class ActionMethodParser { 
public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { 
if ( actionHandler != null ) return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; 
final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; 
final Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; 
final MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; 
final Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; 
String [ ] methodParamNames = null ; 
for ( int ndx = 0 ; 
ndx < paramTypes . length ; 
ndx ++ ) { 
Class paramType = paramTypes [ ndx ] ; 
if ( methodParamNames == null ) methodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; 
final String paramName = methodParamNames [ ndx ] ; 
final Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; 
final ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; 
MapperFunction mapperFunction = null ; 
for ( final Annotation annotation : parameterAnnotations ) { 
if ( annotation instanceof Mapper ) { 
mapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; 
break ; 
} 
} 
params [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; 
} 
return new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; 
} 
} 

public class DecoraResponseWrapper { 
@ Override protected void preResponseCommit ( ) { 
long lastModified = lastModifiedData . getLastModified ( ) ; 
long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; 
if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) response . setDateHeader ( "Last-Modified" , lastModified ) ; 
else { 
response . reset ( ) ; 
response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; 
} 
} 
} 

public class FieldVisitor { 
public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { 
if ( fv != null ) return fv . visitAnnotation ( descriptor , visible ) ; 
return null ; 
} 
} 

public class TypeData { 
public String resolveRealName ( final String jsonName ) { 
if ( jsonNames == null ) return jsonName ; 
int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; 
if ( jsonIndex == - 1 ) return jsonName ; 
return realNames [ jsonIndex ] ; 
} 
} 

public class TypeData { 
public String resolveJsonName ( final String realName ) { 
if ( realNames == null ) return realName ; 
int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; 
if ( realIndex == - 1 ) return realName ; 
return jsonNames [ realIndex ] ; 
} 
} 

public class JsonAnnotationManager { 
public TypeData lookupTypeData ( final Class type ) { 
TypeData typeData = typeDataMap . get ( type ) ; 
if ( typeData == null ) { 
if ( serializationSubclassAware ) typeData = findSubclassTypeData ( type ) ; 
if ( typeData == null ) { 
typeData = scanClassForAnnotations ( type ) ; 
typeDataMap . put ( type , typeData ) ; 
} 
} 
return typeData ; 
} 
} 

public class JsonAnnotationManager { 
protected TypeData findSubclassTypeData ( final Class type ) { 
final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; 
if ( type . getAnnotation ( defaultAnnotation ) != null ) return null ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
Class [ ] superClasses = cd . getAllSuperclasses ( ) ; 
for ( Class superClass : superClasses ) { 
if ( superClass . getAnnotation ( defaultAnnotation ) != null ) return _lookupTypeData ( superClass ) ; 
} 
Class [ ] interfaces = cd . getAllInterfaces ( ) ; 
for ( Class interfaze : interfaces ) { 
if ( interfaze . getAnnotation ( defaultAnnotation ) != null ) return _lookupTypeData ( interfaze ) ; 
} 
return null ; 
} 
} 

public class AdaptiveFileUpload { 
@ Override public byte [ ] getFileContent ( ) throws IOException { 
if ( data != null ) return data ; 
if ( tempFile != null ) return FileUtil . readBytes ( tempFile ) ; 
return null ; 
} 
} 

public class SymbolTable { 
void putBootstrapMethods ( final ByteVector output ) { 
if ( bootstrapMethods != null ) output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; 
} 
} 

public class SymbolTable { 
private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { 
int hashCode = hash ( tag , owner , name , descriptor ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry ; 
entry = entry . next ; 
} 
constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { 
int hashCode = hash ( tag , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) return entry ; 
entry = entry . next ; 
} 
constantPool . putByte ( tag ) . putInt ( value ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantLongOrDouble ( final int tag , final long value ) { 
int hashCode = hash ( tag , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) return entry ; 
entry = entry . next ; 
} 
int index = constantPoolCount ; 
constantPool . putByte ( tag ) . putLong ( value ) ; 
constantPoolCount += 2 ; 
return put ( new Entry ( index , tag , value , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
int addConstantNameAndType ( final String name , final String descriptor ) { 
final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; 
int hashCode = hash ( tag , name , descriptor ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry . index ; 
entry = entry . next ; 
} 
constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; 
} 
} 

public class SymbolTable { 
int addConstantUtf8 ( final String value ) { 
int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) return entry . index ; 
entry = entry . next ; 
} 
constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; 
return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; 
} 
} 

public class SymbolTable { 
Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { 
final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; 
int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry ; 
entry = entry . next ; 
} 
if ( referenceKind <= Opcodes . H_PUTSTATIC ) constantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; 
else constantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { 
int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) return entry ; 
entry = entry . next ; 
} 
constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantUtf8Reference ( final int tag , final String value ) { 
int hashCode = hash ( tag , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) return entry ; 
entry = entry . next ; 
} 
constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { 
ByteVector bootstrapMethodsAttribute = bootstrapMethods ; 
if ( bootstrapMethodsAttribute == null ) bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; 
for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { 
addConstant ( bootstrapMethodArgument ) ; 
} 
int bootstrapMethodOffset = bootstrapMethodsAttribute . length ; 
bootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; 
int numBootstrapArguments = bootstrapMethodArguments . length ; 
bootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; 
for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { 
bootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index ) ; 
} 
int bootstrapMethodlength = bootstrapMethodsAttribute . length - bootstrapMethodOffset ; 
int hashCode = bootstrapMethodHandle . hashCode ( ) ; 
for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { 
hashCode ^= bootstrapMethodArgument . hashCode ( ) ; 
} 
hashCode &= 0x7FFFFFFF ; 
return addBootstrapMethod ( bootstrapMethodOffset , bootstrapMethodlength , hashCode ) ; 
} 
} 

public class SymbolTable { 
int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { 
long data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; 
int hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) return entry . info ; 
entry = entry . next ; 
} 
String type1 = typeTable [ typeTableIndex1 ] . value ; 
String type2 = typeTable [ typeTableIndex2 ] . value ; 
int commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; 
put ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; 
return commonSuperTypeIndex ; 
} 
} 

public class HttpMultiMap { 
private int hash ( final String name ) { 
int h = 0 ; 
for ( int i = name . length ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
char c = name . charAt ( i ) ; 
if ( ! caseSensitive ) if ( c >= 'A' && c <= 'Z' ) c += 32 ; 
h = 31 * h + c ; 
} 
if ( h > 0 ) return h ; 
if ( h == Integer . MIN_VALUE ) return Integer . MAX_VALUE ; 
return - h ; 
} 
} 

public class HttpMultiMap { 
public HttpMultiMap < V > clear ( ) { 
for ( int i = 0 ; 
i < entries . length ; 
i ++ ) entries [ i ] = null ; 
head . before = head . after = head ; 
return this ; 
} 
} 

public class HttpMultiMap { 
public List < V > getAll ( final String name ) { 
LinkedList < V > values = new LinkedList < > ( ) ; 
int h = hash ( name ) ; 
int i = index ( h ) ; 
MapEntry < V > e = entries [ i ] ; 
while ( e != null ) { 
if ( e . hash == h && eq ( name , e . key ) ) values . addFirst ( e . getValue ( ) ) ; 
e = e . next ; 
} 
return values ; 
} 
} 

public class HttpMultiMap { 
@ Override public Iterator < Map . Entry < String , V > > iterator ( ) { 
final MapEntry [ ] e = { 
head . after } 
; 
return new Iterator < Map . Entry < String , V > > ( ) { 
@ Override public boolean hasNext ( ) { 
return e [ 0 ] != head ; 
} 
@ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { 
if ( ! hasNext ( ) ) throw new NoSuchElementException ( "No next() entry in the iteration" ) ; 
MapEntry < V > next = e [ 0 ] ; 
e [ 0 ] = e [ 0 ] . after ; 
return next ; 
} 
@ Override public void remove ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
} 
} 

public class FastCharBuffer { 
private void grow ( final int minCapacity ) { 
final int oldCapacity = buffer . length ; 
int newCapacity = oldCapacity << 1 ; 
if ( newCapacity - minCapacity < 0 ) newCapacity = minCapacity + 512 ; 
buffer = Arrays . copyOf ( buffer , newCapacity ) ; 
} 
} 

public class FastCharBuffer { 
@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { 
for ( int i = start ; 
i < end ; 
i ++ ) append ( csq . charAt ( i ) ) ; 
return this ; 
} 
} 

public class ProxettaMethodBuilder { 
protected void createFirstChainDelegate_Start ( ) { 
int access = msign . getAccessFlags ( ) ; 
if ( ! wd . allowFinalMethods ) if ( ( access & AsmUtil . ACC_FINAL ) != 0 ) throw new ProxettaException ( "Unable to create proxy for final method: " + msign + ". Remove final modifier or change the pointcut definition." ) ; 
tmd = new TargetMethodData ( msign , aspectList ) ; 
access &= ~ ACC_NATIVE ; 
access &= ~ ACC_ABSTRACT ; 
methodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; 
} 
} 

public class Path { 
public Path push ( final CharSequence field ) { 
_push ( field ) ; 
if ( altPath != null ) altPath . push ( field ) ; 
return this ; 
} 
} 

public class BeanSerializer { 
private Object readProperty ( final Object source , final PropertyDescriptor propertyDescriptor ) { 
Getter getter = propertyDescriptor . getGetter ( declared ) ; 
if ( getter != null ) try { 
return getter . invokeGetter ( source ) ; 
} 
catch ( Exception ex ) { 
throw new JsonException ( ex ) ; 
} 
return null ; 
} 
} 

public class Buffer { 
public Buffer append ( final Buffer buffer ) { 
if ( buffer . list . isEmpty ( ) ) return buffer ; 
list . addAll ( buffer . list ) ; 
last = buffer . last ; 
size += buffer . size ; 
return this ; 
} 
} 

public class Buffer { 
public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { 
final int size = size ( ) ; 
final int callbackSize = progressListener . callbackSize ( size ) ; 
int count = 0 ; 
int step = 0 ; 
progressListener . transferred ( count ) ; 
for ( Object o : list ) { 
if ( o instanceof FastByteBuffer ) { 
FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; 
byte [ ] bytes = fastByteBuffer . toArray ( ) ; 
int offset = 0 ; 
while ( offset < bytes . length ) { 
int chunk = callbackSize - step ; 
if ( offset + chunk > bytes . length ) chunk = bytes . length - offset ; 
out . write ( bytes , offset , chunk ) ; 
offset += chunk ; 
step += chunk ; 
count += chunk ; 
if ( step >= callbackSize ) { 
progressListener . transferred ( count ) ; 
step -= callbackSize ; 
} 
} 
} 
else if ( o instanceof Uploadable ) { 
Uploadable uploadable = ( Uploadable ) o ; 
InputStream inputStream = uploadable . openInputStream ( ) ; 
int remaining = uploadable . getSize ( ) ; 
try { 
while ( remaining > 0 ) { 
int chunk = callbackSize - step ; 
if ( chunk > remaining ) chunk = remaining ; 
StreamUtil . copy ( inputStream , out , chunk ) ; 
remaining -= chunk ; 
step += chunk ; 
count += chunk ; 
if ( step >= callbackSize ) { 
progressListener . transferred ( count ) ; 
step -= callbackSize ; 
} 
} 
} 
finally { 
StreamUtil . close ( inputStream ) ; 
} 
} 
} 
if ( step != 0 ) progressListener . transferred ( count ) ; 
} 
} 

public class JsonObject { 
public Integer getInteger ( final String key ) { 
Number number = ( Number ) map . get ( key ) ; 
if ( number == null ) return null ; 
if ( number instanceof Integer ) return ( Integer ) number ; 
return number . intValue ( ) ; 
} 
} 

public class JsonObject { 
public Long getLong ( final String key ) { 
Number number = ( Number ) map . get ( key ) ; 
if ( number == null ) return null ; 
if ( number instanceof Long ) return ( Long ) number ; 
return number . longValue ( ) ; 
} 
} 

public class JsonObject { 
public Double getDouble ( final String key ) { 
Number number = ( Number ) map . get ( key ) ; 
if ( number == null ) return null ; 
if ( number instanceof Double ) return ( Double ) number ; 
return number . doubleValue ( ) ; 
} 
} 

public class JsonObject { 
public Float getFloat ( final String key ) { 
Number number = ( Number ) map . get ( key ) ; 
if ( number == null ) return null ; 
if ( number instanceof Float ) return ( Float ) number ; 
return number . floatValue ( ) ; 
} 
} 

public class JsonObject { 
@ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { 
T val = ( T ) map . get ( key ) ; 
if ( val instanceof Map ) return ( T ) new JsonObject ( ( Map ) val ) ; 
if ( val instanceof List ) return ( T ) new JsonArray ( ( List ) val ) ; 
return val ; 
} 
} 

public class ReceiveMailSession { 
ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { 
useAndOpenFolderIfNotSet ( ) ; 
final Message [ ] messages ; 
try { 
if ( filter == null ) messages = folder . getMessages ( ) ; 
else messages = folder . search ( filter . getSearchTerm ( ) ) ; 
if ( messages . length == 0 ) return ReceivedEmail . EMPTY_ARRAY ; 
if ( envelope ) { 
final FetchProfile fetchProfile = new FetchProfile ( ) ; 
fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; 
fetchProfile . add ( FetchProfile . Item . FLAGS ) ; 
folder . fetch ( messages , fetchProfile ) ; 
} 
final ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; 
for ( int i = 0 ; 
i < messages . length ; 
i ++ ) { 
final Message msg = messages [ i ] ; 
emails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; 
if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { 
emails [ i ] . flags ( flagsToSet ) ; 
msg . setFlags ( flagsToSet , true ) ; 
} 
if ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { 
emails [ i ] . flags ( ) . remove ( flagsToUnset ) ; 
msg . setFlags ( flagsToUnset , false ) ; 
} 
if ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) msg . setFlag ( Flags . Flag . SEEN , false ) ; 
} 
if ( processedMessageConsumer != null ) processedMessageConsumer . accept ( messages ) ; 
if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) if ( flagsToSet . contains ( Flags . Flag . DELETED ) ) folder . expunge ( ) ; 
return emails ; 
} 
catch ( final MessagingException msgexc ) { 
throw new MailException ( "Failed to fetch messages" , msgexc ) ; 
} 
} 
} 

public class ReceiveMailSession { 
protected void closeFolderIfOpened ( final Folder folder ) { 
if ( folder != null ) try { 
folder . close ( true ) ; 
} 
catch ( final MessagingException ignore ) { 
} 
} 
} 

public class DbQueryParser { 
DbQueryNamedParameter lookupNamedParameter ( final String name ) { 
DbQueryNamedParameter p = rootNP ; 
while ( p != null ) { 
if ( p . equalsName ( name ) ) return p ; 
p = p . next ; 
} 
return null ; 
} 
} 

public class RawData { 
public RawData as ( final String mimeOrExtension ) { 
if ( mimeOrExtension . contains ( StringPool . SLASH ) ) this . mimeType = mimeOrExtension ; 
else this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; 
return this ; 
} 
} 

public class ProxettaFactory { 
protected T setTarget ( final String targetName ) { 
assertTargetIsNotDefined ( ) ; 
try { 
targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; 
if ( targetInputStream == null ) throw new ProxettaException ( "Target class not found: " + targetName ) ; 
targetClassName = targetName ; 
targetClass = null ; 
} 
catch ( IOException ioex ) { 
StreamUtil . close ( targetInputStream ) ; 
throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; 
} 
return _this ( ) ; 
} 
} 

public class ProxettaFactory { 
public T setTarget ( final Class target ) { 
assertTargetIsNotDefined ( ) ; 
try { 
targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; 
if ( targetInputStream == null ) throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; 
targetClass = target ; 
targetClassName = target . getName ( ) ; 
} 
catch ( IOException ioex ) { 
StreamUtil . close ( targetInputStream ) ; 
throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; 
} 
return _this ( ) ; 
} 
} 

public class ProxettaFactory { 
protected void process ( ) { 
if ( targetInputStream == null ) throw new ProxettaException ( "Target missing: " + targetClassName ) ; 
final ClassReader classReader ; 
try { 
classReader = new ClassReader ( targetInputStream ) ; 
} 
catch ( IOException ioex ) { 
throw new ProxettaException ( "Error reading class input stream" , ioex ) ; 
} 
final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader ( proxetta . getClassLoader ( ) ) ; 
classReader . accept ( targetClassInfoReader , 0 ) ; 
this . destClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS | ClassWriter . COMPUTE_FRAMES ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "processing: " + classReader . getClassName ( ) ) ; 
WorkData wd = process ( classReader , targetClassInfoReader ) ; 
proxyApplied = wd . proxyApplied ; 
proxyClassName = wd . thisReference . replace ( '/' , '.' ) ; 
} 
} 

public class ProxettaFactory { 
public byte [ ] create ( ) { 
process ( ) ; 
byte [ ] result = toByteArray ( ) ; 
dumpClassInDebugFolder ( result ) ; 
if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; 
return null ; 
} 
if ( log . isDebugEnabled ( ) ) log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; 
return result ; 
} 
} 

public class ProxettaFactory { 
public Class define ( ) { 
process ( ) ; 
if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; 
if ( targetClass != null ) return targetClass ; 
if ( targetClassName != null ) try { 
return ClassLoaderUtil . loadClass ( targetClassName ) ; 
} 
catch ( ClassNotFoundException cnfex ) { 
throw new ProxettaException ( cnfex ) ; 
} 
} 
if ( log . isDebugEnabled ( ) ) log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; 
try { 
ClassLoader classLoader = proxetta . getClassLoader ( ) ; 
if ( classLoader == null ) { 
classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; 
if ( ( classLoader == null ) && ( targetClass != null ) ) classLoader = targetClass . getClassLoader ( ) ; 
} 
final byte [ ] bytes = toByteArray ( ) ; 
dumpClassInDebugFolder ( bytes ) ; 
return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; 
} 
catch ( Exception ex ) { 
throw new ProxettaException ( "Class definition failed" , ex ) ; 
} 
} 
} 

public class ProxettaFactory { 
protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { 
File debugFolder = proxetta . getDebugFolder ( ) ; 
if ( debugFolder == null ) return ; 
if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) log . warn ( "Invalid debug folder: " + debugFolder ) ; 
String fileName = proxyClassName ; 
if ( fileName == null ) fileName = "proxetta-" + System . currentTimeMillis ( ) ; 
fileName += ".class" ; 
File file = new File ( debugFolder , fileName ) ; 
try { 
FileUtil . writeBytes ( file , bytes ) ; 
} 
catch ( IOException ioex ) { 
log . warn ( "Error writing class as " + file , ioex ) ; 
} 
} 
} 

public class SystemUtil { 
public static String get ( final String name , final String defaultValue ) { 
Objects . requireNonNull ( name ) ; 
String value = null ; 
try { 
if ( System . getSecurityManager ( ) == null ) value = System . getProperty ( name ) ; 
else value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; 
} 
catch ( Exception ignore ) { 
} 
if ( value == null ) return defaultValue ; 
return value ; 
} 
} 

public class SystemUtil { 
public static boolean getBoolean ( final String name , final boolean defaultValue ) { 
String value = get ( name ) ; 
if ( value == null ) return defaultValue ; 
value = value . trim ( ) . toLowerCase ( ) ; 
switch ( value ) { 
case "true" : case "yes" : case "1" : case "on" : return true ; 
case "false" : case "no" : case "0" : case "off" : return false ; 
default : return defaultValue ; 
} 
} 
} 

public class SystemUtil { 
public static long getInt ( final String name , final int defaultValue ) { 
String value = get ( name ) ; 
if ( value == null ) return defaultValue ; 
value = value . trim ( ) . toLowerCase ( ) ; 
try { 
return Integer . parseInt ( value ) ; 
} 
catch ( NumberFormatException nfex ) { 
return defaultValue ; 
} 
} 
} 

public class SystemUtil { 
public static long getLong ( final String name , final long defaultValue ) { 
String value = get ( name ) ; 
if ( value == null ) return defaultValue ; 
value = value . trim ( ) . toLowerCase ( ) ; 
try { 
return Long . parseLong ( value ) ; 
} 
catch ( NumberFormatException nfex ) { 
return defaultValue ; 
} 
} 
} 

public class MethodFinder { 
MethodParameter [ ] getResolvedParameters ( ) { 
if ( paramExtractor == null ) return MethodParameter . EMPTY_ARRAY ; 
if ( ! paramExtractor . debugInfoPresent ) throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + '#' + methodName ) ; 
return paramExtractor . getMethodParameters ( ) ; 
} 
} 

public class KeyValueJsonSerializer { 
protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { 
if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) return count ; 
if ( key != null ) currentPath . push ( key . toString ( ) ) ; 
else currentPath . push ( StringPool . NULL ) ; 
boolean include = true ; 
if ( value != null ) { 
include = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; 
include = jsonContext . matchPathToQueries ( include ) ; 
} 
if ( ! include ) { 
currentPath . pop ( ) ; 
return count ; 
} 
if ( key == null ) jsonContext . pushName ( null , count > 0 ) ; 
else jsonContext . pushName ( key . toString ( ) , count > 0 ) ; 
jsonContext . serialize ( value ) ; 
if ( jsonContext . isNamePopped ( ) ) count ++ ; 
currentPath . pop ( ) ; 
return count ; 
} 
} 

public class ResultMapper { 
protected String lookupAlias ( final String alias ) { 
String value = actionsManager . lookupPathAlias ( alias ) ; 
if ( value == null ) { 
ActionRuntime cfg = actionsManager . lookup ( alias ) ; 
if ( cfg != null ) value = cfg . getActionPath ( ) ; 
} 
return value ; 
} 
} 

public class ResultMapper { 
protected String resolveAlias ( final String value ) { 
final StringBuilder result = new StringBuilder ( value . length ( ) ) ; 
int i = 0 ; 
int len = value . length ( ) ; 
while ( i < len ) { 
int ndx = value . indexOf ( '<' , i ) ; 
if ( ndx == - 1 ) { 
if ( i == 0 ) { 
String alias = lookupAlias ( value ) ; 
return ( alias != null ? alias : value ) ; 
} 
else result . append ( value . substring ( i ) ) ; 
break ; 
} 
result . append ( value . substring ( i , ndx ) ) ; 
ndx ++ ; 
int ndx2 = value . indexOf ( '>' , ndx ) ; 
String aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; 
String alias = lookupAlias ( aliasName ) ; 
if ( alias != null ) result . append ( alias ) ; 
else if ( log . isWarnEnabled ( ) ) log . warn ( "Alias not found: " + aliasName ) ; 
i = ndx2 + 1 ; 
} 
i = 0 ; 
len = result . length ( ) ; 
while ( i < len ) { 
if ( result . charAt ( i ) != '/' ) break ; 
i ++ ; 
} 
if ( i > 1 ) return result . substring ( i - 1 , len ) ; 
return result . toString ( ) ; 
} 
} 

public class ResultMapper { 
public ResultPath resolveResultPath ( String path , String value ) { 
boolean absolutePath = false ; 
if ( value != null ) { 
value = resolveAlias ( value ) ; 
if ( StringUtil . startsWithChar ( value , '/' ) ) { 
absolutePath = true ; 
int dotNdx = value . indexOf ( ".." ) ; 
if ( dotNdx != - 1 ) { 
path = value . substring ( 0 , dotNdx ) ; 
value = value . substring ( dotNdx + 2 ) ; 
} 
else { 
path = value ; 
value = null ; 
} 
} 
else { 
int i = 0 ; 
while ( i < value . length ( ) ) { 
if ( value . charAt ( i ) != '#' ) break ; 
int dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; 
if ( dotNdx != - 1 ) path = path . substring ( 0 , dotNdx ) ; 
i ++ ; 
} 
if ( i > 0 ) { 
value = value . substring ( i ) ; 
if ( StringUtil . startsWithChar ( value , '.' ) ) value = value . substring ( 1 ) ; 
else { 
int dotNdx = value . indexOf ( ".." ) ; 
if ( dotNdx != - 1 ) { 
path += '.' + value . substring ( 0 , dotNdx ) ; 
value = value . substring ( dotNdx + 2 ) ; 
} 
else { 
if ( value . length ( ) > 0 ) if ( StringUtil . endsWithChar ( path , '/' ) ) path += value ; 
else path += '.' + value ; 
value = null ; 
} 
} 
} 
} 
} 
if ( ! absolutePath ) if ( resultPathPrefix != null ) path = resultPathPrefix + path ; 
return new ResultPath ( path , value ) ; 
} 
} 

public class MadvocUtil { 
public static int lastIndexOfSlashDot ( final String str ) { 
int slashNdx = str . lastIndexOf ( '/' ) ; 
int dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; 
if ( dotNdx == - 1 ) { 
if ( slashNdx == - 1 ) return - 1 ; 
slashNdx ++ ; 
if ( slashNdx < str . length ( ) - 1 ) dotNdx = slashNdx ; 
else dotNdx = - 1 ; 
} 
return dotNdx ; 
} 
} 

public class MadvocUtil { 
public static int indexOfDotAfterSlash ( final String str ) { 
int slashNdx = str . lastIndexOf ( '/' ) ; 
if ( slashNdx == - 1 ) slashNdx = 0 ; 
return str . indexOf ( '.' , slashNdx ) ; 
} 
} 

public class MadvocUtil { 
public static String stripLastCamelWord ( String name ) { 
int ndx = name . length ( ) - 1 ; 
while ( ndx >= 0 ) { 
if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) break ; 
ndx -- ; 
} 
if ( ndx >= 0 ) name = name . substring ( 0 , ndx ) ; 
return name ; 
} 
} 

public class DbMetaUtil { 
public static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { 
String schemaName = null ; 
final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; 
if ( dbTable != null ) schemaName = dbTable . schema ( ) . trim ( ) ; 
if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) schemaName = defaultSchemaName ; 
return schemaName ; 
} 
} 

public class DbMetaUtil { 
public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { 
String columnName = null ; 
boolean isId = false ; 
Class < ? extends SqlType > sqlTypeClass = null ; 
DbId dbId = null ; 
if ( property . getFieldDescriptor ( ) != null ) dbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; 
if ( dbId == null && property . getReadMethodDescriptor ( ) != null ) dbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; 
if ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) dbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; 
if ( dbId != null ) { 
columnName = dbId . value ( ) . trim ( ) ; 
sqlTypeClass = dbId . sqlType ( ) ; 
isId = true ; 
} 
else { 
DbColumn dbColumn = null ; 
if ( property . getFieldDescriptor ( ) != null ) dbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; 
if ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) dbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; 
if ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) dbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; 
if ( dbColumn != null ) { 
columnName = dbColumn . value ( ) . trim ( ) ; 
sqlTypeClass = dbColumn . sqlType ( ) ; 
} 
else if ( isAnnotated ) return null ; 
} 
if ( StringUtil . isEmpty ( columnName ) ) columnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; 
else if ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) columnName = columnNamingStrategy . applyToColumnName ( columnName ) ; 
if ( sqlTypeClass == SqlType . class ) sqlTypeClass = null ; 
return new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; 
} 
} 

public class Threefish { 
public void init ( final long [ ] key , final long [ ] tweak ) { 
final int newNw = key . length ; 
if ( nw != newNw ) { 
nw = newNw ; 
switch ( nw ) { 
case WORDS_4 : pi = PI4 ; 
rpi = RPI4 ; 
r = R4 ; 
break ; 
case WORDS_8 : pi = PI8 ; 
rpi = RPI8 ; 
r = R8 ; 
break ; 
case WORDS_16 : pi = PI16 ; 
rpi = RPI16 ; 
r = R16 ; 
break ; 
default : throw new RuntimeException ( "Invalid threefish key" ) ; 
} 
this . k = new long [ nw + 1 ] ; 
vd = new long [ nw ] ; 
ed = new long [ nw ] ; 
fd = new long [ nw ] ; 
ksd = new long [ nw ] ; 
} 
System . arraycopy ( key , 0 , this . k , 0 , key . length ) ; 
long knw = EXTENDED_KEY_SCHEDULE_CONST ; 
for ( int i = 0 ; 
i < nw ; 
i ++ ) knw ^= this . k [ i ] ; 
this . k [ nw ] = knw ; 
t [ 0 ] = tweak [ 0 ] ; 
t [ 1 ] = tweak [ 1 ] ; 
t [ 2 ] = t [ 0 ] ^ t [ 1 ] ; 
} 
} 

public class Threefish { 
private void keySchedule ( final int s ) { 
for ( int i = 0 ; 
i < nw ; 
i ++ ) { 
ksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; 
if ( i == nw - 3 ) ksd [ i ] += t [ s % TWEAK_VALUES ] ; 
else if ( i == nw - 2 ) ksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; 
else if ( i == nw - 1 ) ksd [ i ] += s ; 
} 
} 
} 

public class RFC2822AddressParser { 
private static String removeAnyBounding ( final char s , final char e , final String str ) { 
if ( str == null || str . length ( ) < 2 ) return str ; 
if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) return str . substring ( 1 , str . length ( ) - 1 ) ; 
return str ; 
} 
} 

public class ZipUtil { 
public static File zlib ( final File file ) throws IOException { 
if ( file . isDirectory ( ) ) throw new IOException ( "Can't zlib folder" ) ; 
FileInputStream fis = new FileInputStream ( file ) ; 
Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; 
String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; 
DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; 
try { 
StreamUtil . copy ( fis , dos ) ; 
} 
finally { 
StreamUtil . close ( dos ) ; 
StreamUtil . close ( fis ) ; 
} 
return new File ( zlibFileName ) ; 
} 
} 

public class ZipUtil { 
public static File gzip ( final File file ) throws IOException { 
if ( file . isDirectory ( ) ) throw new IOException ( "Can't gzip folder" ) ; 
FileInputStream fis = new FileInputStream ( file ) ; 
String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; 
GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; 
try { 
StreamUtil . copy ( fis , gzos ) ; 
} 
finally { 
StreamUtil . close ( gzos ) ; 
StreamUtil . close ( fis ) ; 
} 
return new File ( gzipName ) ; 
} 
} 

public class ZipUtil { 
public static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { 
if ( ! file . exists ( ) ) throw new FileNotFoundException ( file . toString ( ) ) ; 
if ( path == null ) path = file . getName ( ) ; 
while ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; 
boolean isDir = file . isDirectory ( ) ; 
if ( isDir ) if ( ! StringUtil . endsWithChar ( path , '/' ) ) path += '/' ; 
ZipEntry zipEntry = new ZipEntry ( path ) ; 
zipEntry . setTime ( file . lastModified ( ) ) ; 
if ( comment != null ) zipEntry . setComment ( comment ) ; 
if ( isDir ) { 
zipEntry . setSize ( 0 ) ; 
zipEntry . setCrc ( 0 ) ; 
} 
zos . putNextEntry ( zipEntry ) ; 
if ( ! isDir ) { 
InputStream is = new FileInputStream ( file ) ; 
try { 
StreamUtil . copy ( is , zos ) ; 
} 
finally { 
StreamUtil . close ( is ) ; 
} 
} 
zos . closeEntry ( ) ; 
if ( recursive && file . isDirectory ( ) ) { 
boolean noRelativePath = StringUtil . isEmpty ( path ) ; 
final File [ ] children = file . listFiles ( ) ; 
if ( children != null && children . length != 0 ) for ( File child : children ) { 
String childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; 
addToZip ( zos , child , childRelativePath , comment , recursive ) ; 
} 
} 
} 
} 

public class ZipUtil { 
public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { 
while ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; 
if ( StringUtil . endsWithChar ( path , '/' ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; 
ZipEntry zipEntry = new ZipEntry ( path ) ; 
zipEntry . setTime ( System . currentTimeMillis ( ) ) ; 
if ( comment != null ) zipEntry . setComment ( comment ) ; 
zos . putNextEntry ( zipEntry ) ; 
InputStream is = new ByteArrayInputStream ( content ) ; 
try { 
StreamUtil . copy ( is , zos ) ; 
} 
finally { 
StreamUtil . close ( is ) ; 
} 
zos . closeEntry ( ) ; 
} 
} 

public class ClassDescriptor { 
public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { 
final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; 
if ( fieldDescriptor != null ) if ( ! fieldDescriptor . matchDeclared ( declared ) ) return null ; 
return fieldDescriptor ; 
} 
} 

public class ClassDescriptor { 
public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { 
PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; 
if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) return propertyDescriptor ; 
return null ; 
} 
} 

public class LocalizationUtil { 
public static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "Bundle name for this request: " + bundleName ) ; 
request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; 
} 
} 

public class LocalizationUtil { 
public static void setSessionLocale ( final HttpSession session , final String localeCode ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "Locale stored to session: " + localeCode ) ; 
Locale locale = Locale . forLanguageTag ( localeCode ) ; 
session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; 
} 
} 

public class ParamManager { 
public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { 
beanName = beanName + '.' ; 
List < String > list = new ArrayList < > ( ) ; 
for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { 
String key = entry . getKey ( ) ; 
if ( ! key . startsWith ( beanName ) ) continue ; 
list . add ( key ) ; 
if ( ! resolveReferenceParams ) continue ; 
String value = PropertiesUtil . resolveProperty ( params , key ) ; 
entry . setValue ( value ) ; 
} 
if ( list . isEmpty ( ) ) return StringPool . EMPTY_ARRAY ; 
else return list . toArray ( new String [ 0 ] ) ; 
} 
} 

public class PropsEntries { 
public PropsEntries profile ( final String ... profiles ) { 
if ( profiles == null ) return this ; 
for ( String profile : profiles ) { 
addProfiles ( profile ) ; 
} 
return this ; 
} 
} 

public class ClassReader { 
private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { 
if ( inputStream == null ) throw new IOException ( "Class not found" ) ; 
try { 
ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; 
int bytesRead ; 
while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) outputStream . write ( data , 0 , bytesRead ) ; 
outputStream . flush ( ) ; 
return outputStream . toByteArray ( ) ; 
} 
finally { 
if ( close ) inputStream . close ( ) ; 
} 
} 
} 

public class ClassReader { 
protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { 
if ( labels [ bytecodeOffset ] == null ) labels [ bytecodeOffset ] = new Label ( ) ; 
return labels [ bytecodeOffset ] ; 
} 
} 

public class ClassReader { 
private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { 
if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) return - 1 ; 
return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; 
} 
} 

public class ClassReader { 
private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { 
int currentOffset = annotationOffset ; 
int numElementValuePairs = readUnsignedShort ( currentOffset ) ; 
currentOffset += 2 ; 
if ( named ) while ( numElementValuePairs -- > 0 ) { 
String elementName = readUTF8 ( currentOffset , charBuffer ) ; 
currentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; 
} 
else while ( numElementValuePairs -- > 0 ) currentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; 
if ( annotationVisitor != null ) annotationVisitor . visitEnd ( ) ; 
return currentOffset ; 
} 
} 

public class Ctors { 
protected CtorDescriptor [ ] inspectConstructors ( ) { 
Class type = classDescriptor . getType ( ) ; 
Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; 
CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; 
for ( int i = 0 ; 
i < ctors . length ; 
i ++ ) { 
Constructor ctor = ctors [ i ] ; 
CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; 
allCtors [ i ] = ctorDescriptor ; 
if ( ctorDescriptor . isDefault ( ) ) defaultCtor = ctorDescriptor ; 
} 
return allCtors ; 
} 
} 

public class Ctors { 
public CtorDescriptor getCtorDescriptor ( final Class ... args ) { 
ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { 
Class [ ] arg = ctorDescriptor . getParameters ( ) ; 
if ( arg . length != args . length ) continue ; 
for ( int j = 0 ; 
j < arg . length ; 
j ++ ) if ( arg [ j ] != args [ j ] ) continue ctors ; 
return ctorDescriptor ; 
} 
return null ; 
} 
} 

public class LongArrayConverter { 
protected long [ ] convertArrayToArray ( final Object value ) { 
final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; 
final long [ ] result ; 
if ( valueComponentType . isPrimitive ( ) ) result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; 
else { 
final Object [ ] array = ( Object [ ] ) value ; 
result = new long [ array . length ] ; 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) result [ i ] = convertType ( array [ i ] ) ; 
} 
return result ; 
} 
} 

public class DecoraServletFilter { 
@ Override public void init ( final FilterConfig filterConfig ) throws ServletException { 
final String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; 
if ( decoraManagerClass != null ) try { 
final Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; 
decoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; 
} 
catch ( Exception ex ) { 
log . error ( "Unable to load Decora manager class: " + decoraManagerClass , ex ) ; 
throw new ServletException ( ex ) ; 
} 
else decoraManager = createDecoraManager ( ) ; 
final String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; 
if ( decoraParserClass != null ) try { 
final Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; 
decoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; 
} 
catch ( Exception ex ) { 
log . error ( "Unable to load Decora parser class: " + decoraParserClass , ex ) ; 
throw new ServletException ( ex ) ; 
} 
else decoraParser = createDecoraParser ( ) ; 
final String decoraCache = filterConfig . getInitParameter ( PARAM_DECORA_CACHE ) ; 
if ( decoraCache != null ) cached = Converter . get ( ) . toBoolean ( decoraCache , false ) ; 
} 
} 

public class FindFile { 
public FindFile onFile ( final Consumer < File > fileConsumer ) { 
if ( consumers == null ) consumers = Consumers . of ( fileConsumer ) ; 
else consumers . add ( fileConsumer ) ; 
return this ; 
} 
} 

public class FindFile { 
public FindFile searchPath ( final URL searchPath ) { 
File file = FileUtil . toContainerFile ( searchPath ) ; 
if ( file == null ) throw new FindFileException ( "URL error: " + searchPath ) ; 
addPath ( file ) ; 
return this ; 
} 
} 

public class FindFile { 
protected void addPath ( final File path ) { 
if ( ! path . exists ( ) ) return ; 
if ( pathList == null ) pathList = new LinkedList < > ( ) ; 
pathList . add ( path ) ; 
} 
} 

public class FindFile { 
public List < File > findAll ( ) { 
List < File > allFiles = new ArrayList < > ( ) ; 
File file ; 
while ( ( file = nextFile ( ) ) != null ) allFiles . add ( file ) ; 
return allFiles ; 
} 
} 

public class FindFile { 
protected void init ( ) { 
rules . detectMode ( ) ; 
todoFiles = new LinkedList < > ( ) ; 
todoFolders = new LinkedList < > ( ) ; 
if ( pathList == null ) { 
pathList = new LinkedList < > ( ) ; 
return ; 
} 
if ( pathListOriginal == null ) pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; 
String [ ] files = new String [ pathList . size ( ) ] ; 
int index = 0 ; 
Iterator < File > iterator = pathList . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
File file = iterator . next ( ) ; 
if ( file . isFile ( ) ) { 
files [ index ++ ] = file . getAbsolutePath ( ) ; 
iterator . remove ( ) ; 
} 
} 
if ( index != 0 ) { 
FilesIterator filesIterator = new FilesIterator ( files ) ; 
todoFiles . add ( filesIterator ) ; 
} 
} 
} 

public class FindFile { 
@ Override public Iterator < File > iterator ( ) { 
return new Iterator < File > ( ) { 
private File nextFile ; 
@ Override public boolean hasNext ( ) { 
nextFile = nextFile ( ) ; 
return nextFile != null ; 
} 
@ Override public File next ( ) { 
if ( nextFile == null ) throw new NoSuchElementException ( ) ; 
return nextFile ; 
} 
@ Override public void remove ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
} 
} 

public class AnnotationResolver { 
public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { 
PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; 
String name = null ; 
if ( petiteBean != null ) name = petiteBean . value ( ) . trim ( ) ; 
if ( ( name == null ) || ( name . length ( ) == 0 ) ) if ( useLongTypeName ) name = type . getName ( ) ; 
else name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; 
return name ; 
} 
} 

public class Buffer { 
public PrintWriter getWriter ( ) { 
if ( outWriter == null ) { 
if ( outStream != null ) throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; 
bufferedWriter = new FastCharArrayWriter ( ) ; 
outWriter = new PrintWriter ( bufferedWriter ) { 
@ Override public void close ( ) { 
} 
} 
; 
} 
return outWriter ; 
} 
} 

public class Buffer { 
public ServletOutputStream getOutputStream ( ) { 
if ( outStream == null ) { 
if ( outWriter != null ) throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; 
bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; 
outStream = bufferOutputStream ; 
} 
return outStream ; 
} 
} 

public class Type { 
public String getClassName ( ) { 
switch ( sort ) { 
case VOID : return "void" ; 
case BOOLEAN : return "boolean" ; 
case CHAR : return "char" ; 
case BYTE : return "byte" ; 
case SHORT : return "short" ; 
case INT : return "int" ; 
case FLOAT : return "float" ; 
case LONG : return "long" ; 
case DOUBLE : return "double" ; 
case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; 
for ( int i = getDimensions ( ) ; 
i > 0 ; 
-- i ) stringBuilder . append ( "[]" ) ; 
return stringBuilder . toString ( ) ; 
case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; 
default : throw new AssertionError ( ) ; 
} 
} 
} 

public class Type { 
private void appendDescriptor ( final StringBuilder stringBuilder ) { 
if ( sort == OBJECT ) stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; 
else if ( sort == INTERNAL ) stringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; 
else stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; 
} 
} 

public class Type { 
public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { 
int argumentsSize = 1 ; 
int currentOffset = 1 ; 
int currentChar = methodDescriptor . charAt ( currentOffset ) ; 
while ( currentChar != ')' ) { 
if ( currentChar == 'J' || currentChar == 'D' ) { 
currentOffset ++ ; 
argumentsSize += 2 ; 
} 
else { 
while ( methodDescriptor . charAt ( currentOffset ) == '[' ) currentOffset ++ ; 
if ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) currentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; 
argumentsSize += 1 ; 
} 
currentChar = methodDescriptor . charAt ( currentOffset ) ; 
} 
currentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; 
if ( currentChar == 'V' ) return argumentsSize << 2 ; 
else { 
int returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; 
return argumentsSize << 2 | returnSize ; 
} 
} 
} 

public class JtxTransaction { 
public void setRollbackOnly ( final Throwable th ) { 
if ( ! isNoTransaction ( ) ) if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; 
rollbackCause = th ; 
status = STATUS_MARKED_ROLLBACK ; 
} 
} 

public class JtxTransaction { 
protected void commitOrRollback ( boolean doCommit ) { 
if ( log . isDebugEnabled ( ) ) if ( doCommit ) log . debug ( "Commit JTX" ) ; 
else log . debug ( "Rollback JTX" ) ; 
boolean forcedRollback = false ; 
if ( ! isNoTransaction ( ) ) if ( isRollbackOnly ( ) ) if ( doCommit ) { 
doCommit = false ; 
forcedRollback = true ; 
} 
else if ( ! isActive ( ) ) { 
if ( isCompleted ( ) ) throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; 
throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; 
} 
if ( doCommit ) commitAllResources ( ) ; 
else rollbackAllResources ( forcedRollback ) ; 
} 
} 

public class JtxTransaction { 
protected void rollbackAllResources ( final boolean wasForced ) { 
status = STATUS_ROLLING_BACK ; 
Exception lastException = null ; 
Iterator < JtxResource > it = resources . iterator ( ) ; 
while ( it . hasNext ( ) ) { 
JtxResource resource = it . next ( ) ; 
try { 
resource . rollbackTransaction ( ) ; 
} 
catch ( Exception ex ) { 
lastException = ex ; 
} 
finally { 
it . remove ( ) ; 
} 
} 
txManager . removeTransaction ( this ) ; 
status = STATUS_ROLLEDBACK ; 
if ( lastException != null ) { 
status = STATUS_UNKNOWN ; 
throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; 
} 
if ( wasForced ) throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; 
} 
} 

public class JtxTransaction { 
public < E > E requestResource ( final Class < E > resourceType ) { 
if ( isCompleted ( ) ) throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; 
if ( isRollbackOnly ( ) ) throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; 
if ( ! isNoTransaction ( ) && ! isActive ( ) ) throw new JtxException ( "Resources are not available since TX is not active" ) ; 
checkTimeout ( ) ; 
E resource = lookupResource ( resourceType ) ; 
if ( resource == null ) { 
int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; 
if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) throw new JtxException ( "TX already has attached max. number of resources" ) ; 
JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; 
resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; 
resources . add ( new JtxResource < > ( this , resourceManager , resource ) ) ; 
} 
return resource ; 
} 
} 

public class JsonWriter { 
protected void popName ( ) { 
if ( isPushed ) { 
if ( pushedComma ) writeComma ( ) ; 
String name = pushedName ; 
pushedName = null ; 
isPushed = false ; 
writeName ( name ) ; 
} 
} 
} 

public class JsonWriter { 
public void writeString ( final String value ) { 
popName ( ) ; 
write ( StringPool . QUOTE ) ; 
int len = value . length ( ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c = value . charAt ( i ) ; 
switch ( c ) { 
case '"' : write ( "\\\"" ) ; 
break ; 
case '\\' : write ( "\\\\" ) ; 
break ; 
case '/' : if ( strictStringEncoding ) write ( "\\/" ) ; 
else write ( c ) ; 
break ; 
case '\b' : write ( "\\b" ) ; 
break ; 
case '\f' : write ( "\\f" ) ; 
break ; 
case '\n' : write ( "\\n" ) ; 
break ; 
case '\r' : write ( "\\r" ) ; 
break ; 
case '\t' : write ( "\\t" ) ; 
break ; 
default : if ( Character . isISOControl ( c ) ) unicode ( c ) ; 
else write ( c ) ; 
} 
} 
write ( StringPool . QUOTE ) ; 
} 
} 

public class Attribute { 
public boolean isContaining ( final String include ) { 
if ( value == null ) return false ; 
if ( splits == null ) splits = StringUtil . splitc ( value , ' ' ) ; 
for ( String s : splits ) { 
if ( s . equals ( include ) ) return true ; 
} 
return false ; 
} 
} 

public class PseudoFunctionSelector { 
public static PseudoFunction < ? > lookupPseudoFunction ( final String pseudoFunctionName ) { 
PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP . get ( pseudoFunctionName ) ; 
if ( pseudoFunction == null ) throw new CSSellyException ( "Unsupported pseudo function: " + pseudoFunctionName ) ; 
return pseudoFunction ; 
} 
} 

public class ProxettaClassBuilder { 
@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { 
wd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; 
access &= ~ AsmUtil . ACC_ABSTRACT ; 
final int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; 
wd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; 
wd . proxyAspects = new ProxyAspectData [ aspects . length ] ; 
for ( int i = 0 ; 
i < aspects . length ; 
i ++ ) wd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; 
} 
} 

public class ProxettaClassBuilder { 
protected void makeProxyConstructor ( ) { 
MethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_PRIVATE | AsmUtil . ACC_FINAL , ProxettaNames . initMethodName , DESC_VOID , null , null ) ; 
mv . visitCode ( ) ; 
if ( wd . adviceInits != null ) for ( String name : wd . adviceInits ) { 
mv . visitVarInsn ( ALOAD , 0 ) ; 
mv . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , name , DESC_VOID , false ) ; 
} 
mv . visitInsn ( RETURN ) ; 
mv . visitMaxs ( 0 , 0 ) ; 
mv . visitEnd ( ) ; 
} 
} 

public class ProxettaClassBuilder { 
protected void processSuperMethods ( ) { 
for ( ClassReader cr : targetClassInfo . superClassReaders ) { 
cr . accept ( new EmptyClassVisitor ( ) { 
String declaredClassName ; 
@ Override public void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { 
declaredClassName = name ; 
} 
@ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { 
if ( name . equals ( INIT ) || name . equals ( CLINIT ) ) return null ; 
MethodSignatureVisitor msign = targetClassInfo . lookupMethodSignatureVisitor ( access , name , desc , declaredClassName ) ; 
if ( msign == null ) return null ; 
return applyProxy ( msign ) ; 
} 
} 
, 0 ) ; 
} 
} 
} 

public class BinarySearchBase { 
public int findLast ( int low , int high ) { 
int ndx = - 1 ; 
while ( low <= high ) { 
int mid = ( low + high ) >>> 1 ; 
int delta = compare ( mid ) ; 
if ( delta > 0 ) high = mid - 1 ; 
else { 
if ( delta == 0 ) ndx = mid ; 
low = mid + 1 ; 
} 
} 
if ( ndx == - 1 ) return - ( low + 1 ) ; 
return ndx ; 
} 
} 

public class Chalk { 
public String on ( final String string ) { 
if ( ! enabled ) return string ; 
final StringBuilder sb = new StringBuilder ( ) ; 
if ( prefix != null ) sb . append ( prefix ) . append ( "m" ) ; 
sb . append ( string ) ; 
if ( suffix != null ) sb . append ( suffix ) . append ( "m" ) ; 
return sb . toString ( ) ; 
} 
} 

public class SqlTypeManager { 
public SqlType lookup ( final Class clazz ) { 
SqlType sqlType ; 
for ( Class x = clazz ; 
x != null ; 
x = x . getSuperclass ( ) ) { 
sqlType = types . get ( clazz ) ; 
if ( sqlType != null ) return sqlType ; 
Class [ ] interfaces = x . getInterfaces ( ) ; 
for ( Class i : interfaces ) { 
sqlType = types . get ( i ) ; 
if ( sqlType != null ) return sqlType ; 
} 
} 
return null ; 
} 
} 

public class JtxTransactionManager { 
public int totalThreadTransactions ( ) { 
ArrayList < JtxTransaction > txList = txStack . get ( ) ; 
if ( txList == null ) return 0 ; 
return txList . size ( ) ; 
} 
} 

public class JtxTransactionManager { 
public int totalThreadTransactionsWithStatus ( final JtxStatus status ) { 
ArrayList < JtxTransaction > txlist = txStack . get ( ) ; 
if ( txlist == null ) return 0 ; 
int count = 0 ; 
for ( JtxTransaction tx : txlist ) { 
if ( tx . getStatus ( ) == status ) count ++ ; 
} 
return count ; 
} 
} 

public class JtxTransactionManager { 
protected void continueTx ( final JtxTransaction sourceTx , final JtxTransactionMode destMode ) { 
if ( ! validateExistingTransaction ) return ; 
JtxTransactionMode sourceMode = sourceTx . getTransactionMode ( ) ; 
JtxIsolationLevel destIsolationLevel = destMode . getIsolationLevel ( ) ; 
if ( destIsolationLevel != ISOLATION_DEFAULT ) { 
JtxIsolationLevel currentIsolationLevel = sourceMode . getIsolationLevel ( ) ; 
if ( currentIsolationLevel != destIsolationLevel ) throw new JtxException ( "Participating TX specifies isolation level: " + destIsolationLevel + " which is incompatible with existing TX: " + currentIsolationLevel ) ; 
} 
if ( ( ! destMode . isReadOnly ( ) ) && ( sourceMode . isReadOnly ( ) ) ) throw new JtxException ( "Participating TX is not marked as read-only, but existing TX is" ) ; 
} 
} 

public class JtxTransactionManager { 
protected < E > JtxResourceManager < E > lookupResourceManager ( final Class < E > resourceType ) { 
JtxResourceManager < E > resourceManager = this . resourceManagers . get ( resourceType ) ; 
if ( resourceManager == null ) throw new JtxException ( "No registered resource manager for resource type: " + resourceType . getSimpleName ( ) ) ; 
return resourceManager ; 
} 
} 

public class Pathref { 
protected void append ( final String methodName ) { 
if ( path . length ( ) != 0 ) path += StringPool . DOT ; 
if ( methodName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ) path = StringUtil . substring ( path , 0 , - 1 ) ; 
path += methodName ; 
} 
} 

public class Format { 
public static String alignLeftAndPad ( final String text , final int size ) { 
int textLength = text . length ( ) ; 
if ( textLength > size ) return text . substring ( 0 , size ) ; 
final StringBuilder sb = new StringBuilder ( size ) ; 
sb . append ( text ) ; 
while ( textLength ++ < size ) sb . append ( ' ' ) ; 
return sb . toString ( ) ; 
} 
} 

public class Format { 
public static String toPrettyString ( final Object value ) { 
if ( value == null ) return StringPool . NULL ; 
final Class < ? > type = value . getClass ( ) ; 
if ( type . isArray ( ) ) { 
final Class componentType = type . getComponentType ( ) ; 
if ( componentType . isPrimitive ( ) ) { 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( '[' ) ; 
if ( componentType == int . class ) sb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; 
else if ( componentType == long . class ) sb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; 
else if ( componentType == double . class ) sb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; 
else if ( componentType == float . class ) sb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; 
else if ( componentType == boolean . class ) sb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; 
else if ( componentType == short . class ) sb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; 
else if ( componentType == byte . class ) sb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; 
else throw new IllegalArgumentException ( ) ; 
sb . append ( ']' ) ; 
return sb . toString ( ) ; 
} 
else { 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( '[' ) ; 
final Object [ ] array = ( Object [ ] ) value ; 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( i > 0 ) sb . append ( ',' ) ; 
sb . append ( toPrettyString ( array [ i ] ) ) ; 
} 
sb . append ( ']' ) ; 
return sb . toString ( ) ; 
} 
} 
else if ( value instanceof Iterable ) { 
final Iterable iterable = ( Iterable ) value ; 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( '{' ) ; 
int i = 0 ; 
for ( final Object o : iterable ) { 
if ( i > 0 ) sb . append ( ',' ) ; 
sb . append ( toPrettyString ( o ) ) ; 
i ++ ; 
} 
sb . append ( '}' ) ; 
return sb . toString ( ) ; 
} 
return value . toString ( ) ; 
} 
} 

public class Format { 
public static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { 
final int length = input . length ( ) ; 
final StringBuilder sb = new StringBuilder ( length ) ; 
boolean upperCase = firstCharUppercase ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) { 
final char ch = input . charAt ( i ) ; 
if ( ch == separator ) upperCase = true ; 
else if ( upperCase ) { 
sb . append ( Character . toUpperCase ( ch ) ) ; 
upperCase = false ; 
} 
else sb . append ( ch ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class Format { 
public static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { 
StringBuilder str = new StringBuilder ( ) ; 
int total = src . length ( ) ; 
int from = 0 ; 
while ( from < total ) { 
int to = from + len ; 
if ( to >= total ) to = total ; 
else if ( breakOnWhitespace ) { 
int ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; 
if ( ndx != - 1 ) to = ndx + 1 ; 
} 
int cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; 
if ( cutFrom != - 1 ) { 
int cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; 
str . append ( src , cutFrom , cutTo ) ; 
} 
str . append ( '\n' ) ; 
from = to ; 
} 
return str . toString ( ) ; 
} 
} 

public class Format { 
public static String convertTabsToSpaces ( final String line , final int tabWidth ) { 
int tab_index , tab_size ; 
int last_tab_index = 0 ; 
int added_chars = 0 ; 
if ( tabWidth == 0 ) return StringUtil . remove ( line , '\t' ) ; 
StringBuilder result = new StringBuilder ( ) ; 
while ( ( tab_index = line . indexOf ( '\t' , last_tab_index ) ) != - 1 ) { 
tab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; 
if ( tab_size == 0 ) tab_size = tabWidth ; 
added_chars += tab_size - 1 ; 
result . append ( line , last_tab_index , tab_index ) ; 
result . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; 
last_tab_index = tab_index + 1 ; 
} 
if ( last_tab_index == 0 ) return line ; 
result . append ( line . substring ( last_tab_index ) ) ; 
return result . toString ( ) ; 
} 
} 

public class Format { 
public static String escapeJava ( final String string ) { 
int strLen = string . length ( ) ; 
StringBuilder sb = new StringBuilder ( strLen ) ; 
for ( int i = 0 ; 
i < strLen ; 
i ++ ) { 
char c = string . charAt ( i ) ; 
switch ( c ) { 
case '\b' : sb . append ( "\\b" ) ; 
break ; 
case '\t' : sb . append ( "\\t" ) ; 
break ; 
case '\n' : sb . append ( "\\n" ) ; 
break ; 
case '\f' : sb . append ( "\\f" ) ; 
break ; 
case '\r' : sb . append ( "\\r" ) ; 
break ; 
case '\"' : sb . append ( "\\\"" ) ; 
break ; 
case '\\' : sb . append ( "\\\\" ) ; 
break ; 
default : if ( ( c < 32 ) || ( c > 127 ) ) { 
String hex = Integer . toHexString ( c ) ; 
sb . append ( "\\u" ) ; 
for ( int k = hex . length ( ) ; 
k < 4 ; 
k ++ ) sb . append ( '0' ) ; 
sb . append ( hex ) ; 
} 
else sb . append ( c ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class PetiteContainer { 
public < T > T getBean ( final String name ) { 
BeanDefinition def = lookupBeanDefinition ( name ) ; 
if ( def == null ) { 
ProviderDefinition providerDefinition = providers . get ( name ) ; 
if ( providerDefinition != null ) return ( T ) invokeProvider ( providerDefinition ) ; 
return null ; 
} 
Object bean = def . scopeLookup ( ) ; 
if ( bean == null ) { 
initBeanDefinition ( def ) ; 
final BeanData beanData = new BeanData ( this , def ) ; 
registerBeanAndWireAndInjectParamsAndInvokeInitMethods ( beanData ) ; 
bean = beanData . bean ( ) ; 
} 
return ( T ) bean ; 
} 
} 

public class PetiteContainer { 
protected void initBeanDefinition ( final BeanDefinition def ) { 
if ( def . initMethods == null ) def . initMethods = petiteResolvers . resolveInitMethodPoint ( def . type ) ; 
if ( def . destroyMethods == null ) def . destroyMethods = petiteResolvers . resolveDestroyMethodPoint ( def . type ) ; 
if ( def . properties == null ) def . properties = petiteResolvers . resolvePropertyInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; 
if ( def . methods == null ) def . methods = petiteResolvers . resolveMethodInjectionPoint ( def . type ) ; 
if ( def . ctor == null ) def . ctor = petiteResolvers . resolveCtorInjectionPoint ( def . type ) ; 
if ( def . values == null ) def . values = paramManager . resolveParamInjectionPoints ( def . type ) ; 
if ( def . sets == null ) def . sets = petiteResolvers . resolveSetInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; 
if ( def . params == null ) def . params = paramManager . filterParametersForBeanName ( def . name , petiteConfig . getResolveReferenceParameters ( ) ) ; 
} 
} 

public class PetiteContainer { 
protected Object invokeProvider ( final ProviderDefinition provider ) { 
if ( provider . method != null ) { 
final Object bean ; 
if ( provider . beanName != null ) bean = getBean ( provider . beanName ) ; 
else bean = null ; 
try { 
return provider . method . invoke ( bean ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Invalid provider method: " + provider . method . getName ( ) , ex ) ; 
} 
} 
throw new PetiteException ( "Invalid provider" ) ; 
} 
} 

public class PetiteContainer { 
public void setBeanProperty ( final String name , final Object value ) { 
Object bean = null ; 
int ndx = name . length ( ) ; 
while ( true ) { 
ndx = name . lastIndexOf ( '.' , ndx ) ; 
if ( ndx == - 1 ) break ; 
String beanName = name . substring ( 0 , ndx ) ; 
bean = getBean ( beanName ) ; 
if ( bean != null ) break ; 
ndx -- ; 
} 
if ( bean == null ) throw new PetiteException ( "Invalid bean property: " + name ) ; 
try { 
BeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Invalid bean property: " + name , ex ) ; 
} 
} 
} 

public class PetiteContainer { 
public Object getBeanProperty ( final String name ) { 
int ndx = name . indexOf ( '.' ) ; 
if ( ndx == - 1 ) throw new PetiteException ( "Only bean name is specified, missing property name: " + name ) ; 
String beanName = name . substring ( 0 , ndx ) ; 
Object bean = getBean ( beanName ) ; 
if ( bean == null ) throw new PetiteException ( "Bean doesn't exist: " + name ) ; 
try { 
return BeanUtil . declared . getProperty ( bean , name . substring ( ndx + 1 ) ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Invalid bean property: " + name , ex ) ; 
} 
} 
} 

public class Paramo { 
public static MethodParameter [ ] resolveParameters ( final AccessibleObject methodOrCtor ) { 
Class [ ] paramTypes ; 
Class declaringClass ; 
String name ; 
if ( methodOrCtor instanceof Method ) { 
Method method = ( Method ) methodOrCtor ; 
paramTypes = method . getParameterTypes ( ) ; 
name = method . getName ( ) ; 
declaringClass = method . getDeclaringClass ( ) ; 
} 
else { 
Constructor constructor = ( Constructor ) methodOrCtor ; 
paramTypes = constructor . getParameterTypes ( ) ; 
declaringClass = constructor . getDeclaringClass ( ) ; 
name = CTOR_METHOD ; 
} 
if ( paramTypes . length == 0 ) return MethodParameter . EMPTY_ARRAY ; 
InputStream stream ; 
try { 
stream = ClassLoaderUtil . getClassAsStream ( declaringClass ) ; 
} 
catch ( IOException ioex ) { 
throw new ParamoException ( "Failed to read class bytes: " + declaringClass . getName ( ) , ioex ) ; 
} 
if ( stream == null ) throw new ParamoException ( "Class not found: " + declaringClass ) ; 
try { 
ClassReader reader = new ClassReader ( stream ) ; 
MethodFinder visitor = new MethodFinder ( declaringClass , name , paramTypes ) ; 
reader . accept ( visitor , 0 ) ; 
return visitor . getResolvedParameters ( ) ; 
} 
catch ( IOException ioex ) { 
throw new ParamoException ( ioex ) ; 
} 
finally { 
StreamUtil . close ( stream ) ; 
} 
} 
} 

public class PropsEntry { 
public String getValue ( final String ... profiles ) { 
if ( hasMacro ) return propsData . resolveMacros ( value , profiles ) ; 
return value ; 
} 
} 

public class LagartoDOMBuilderTagVisitor { 
@ Override public void end ( ) { 
if ( parentNode != rootNode ) { 
Node thisNode = parentNode ; 
while ( thisNode != rootNode ) { 
if ( domBuilder . config . isImpliedEndTags ( ) ) if ( implRules . implicitlyCloseTagOnEOF ( thisNode . getNodeName ( ) ) ) { 
thisNode = thisNode . getParentNode ( ) ; 
continue ; 
} 
error ( "Unclosed tag closed: <" + thisNode . getNodeName ( ) + ">" ) ; 
thisNode = thisNode . getParentNode ( ) ; 
} 
} 
if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , true ) ; 
if ( domBuilder . config . isUseFosterRules ( ) ) { 
HtmlFosterRules fosterRules = new HtmlFosterRules ( ) ; 
fosterRules . fixFosterElements ( rootNode ) ; 
} 
rootNode . end ( ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "LagartoDom tree created in " + rootNode . getElapsedTime ( ) + " ms" ) ; 
} 
} 

public class LagartoDOMBuilderTagVisitor { 
protected Element createElementNode ( final Tag tag ) { 
boolean hasVoidTags = htmlVoidRules != null ; 
boolean isVoid = false ; 
boolean selfClosed = false ; 
if ( hasVoidTags ) { 
isVoid = htmlVoidRules . isVoidTag ( tag . getName ( ) ) ; 
if ( isVoid ) selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; 
} 
else selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; 
return new Element ( rootNode , tag , isVoid , selfClosed ) ; 
} 
} 

public class LagartoDOMBuilderTagVisitor { 
@ Override public void tag ( final Tag tag ) { 
if ( ! enabled ) return ; 
TagType tagType = tag . getType ( ) ; 
Element node ; 
switch ( tagType ) { 
case START : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , false ) ; 
node = createElementNode ( tag ) ; 
if ( domBuilder . config . isImpliedEndTags ( ) ) while ( true ) { 
String parentNodeName = parentNode . getNodeName ( ) ; 
if ( ! implRules . implicitlyCloseParentTagOnNewTag ( parentNodeName , node . getNodeName ( ) ) ) break ; 
parentNode = parentNode . getParentNode ( ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "Implicitly closed tag <" + node . getNodeName ( ) + "> " ) ; 
} 
parentNode . addChild ( node ) ; 
if ( ! node . isVoidElement ( ) ) parentNode = node ; 
break ; 
case END : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , true ) ; 
String tagName = tag . getName ( ) . toString ( ) ; 
Node matchingParent = findMatchingParentOpenTag ( tagName ) ; 
if ( matchingParent == parentNode ) { 
parentNode = parentNode . getParentNode ( ) ; 
break ; 
} 
if ( matchingParent == null ) { 
error ( "Orphan closed tag ignored: </" + tagName + "> " + tag . getTagPosition ( ) ) ; 
break ; 
} 
if ( domBuilder . config . isImpliedEndTags ( ) ) { 
boolean fixed = false ; 
while ( implRules . implicitlyCloseParentTagOnTagEnd ( parentNode . getNodeName ( ) , tagName ) ) { 
parentNode = parentNode . getParentNode ( ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "Implicitly closed tag <" + tagName + ">" ) ; 
if ( parentNode == matchingParent ) { 
parentNode = matchingParent . parentNode ; 
fixed = true ; 
break ; 
} 
} 
if ( fixed ) break ; 
} 
fixUnclosedTagsUpToMatchingParent ( tag , matchingParent ) ; 
break ; 
case SELF_CLOSING : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) removeLastChildNodeIfEmptyText ( parentNode , false ) ; 
node = createElementNode ( tag ) ; 
parentNode . addChild ( node ) ; 
break ; 
} 
} 
} 

public class LagartoDOMBuilderTagVisitor { 
protected void removeLastChildNodeIfEmptyText ( final Node parentNode , final boolean closedTag ) { 
if ( parentNode == null ) return ; 
Node lastChild = parentNode . getLastChild ( ) ; 
if ( lastChild == null ) return ; 
if ( lastChild . getNodeType ( ) != Node . NodeType . TEXT ) return ; 
if ( closedTag ) if ( parentNode . getChildNodesCount ( ) == 1 ) return ; 
Text text = ( Text ) lastChild ; 
if ( text . isBlank ( ) ) lastChild . detachFromParent ( ) ; 
} 
} 

public class BaseLoggableStatement { 
public String getQueryString ( ) { 
if ( sqlTemplate == null ) return toString ( ) ; 
if ( parameterValues == null ) return sqlTemplate ; 
final StringBuilder sb = new StringBuilder ( ) ; 
int qMarkCount = 0 ; 
final StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , "?" ) ; 
while ( tok . hasMoreTokens ( ) ) { 
final String oneChunk = tok . nextToken ( ) ; 
sb . append ( oneChunk ) ; 
try { 
Object value = null ; 
if ( parameterValues . size ( ) > 1 + qMarkCount ) { 
value = parameterValues . get ( 1 + qMarkCount ) ; 
qMarkCount ++ ; 
} 
else if ( ! tok . hasMoreTokens ( ) ) value = "" ; 
if ( value == null ) value = "?" ; 
sb . append ( value ) ; 
} 
catch ( Throwable th ) { 
sb . append ( "--- Building query failed: " ) . append ( th . toString ( ) ) ; 
} 
} 
return sb . toString ( ) . trim ( ) ; 
} 
} 

public class IteratorTag { 
protected int calculateTo ( final int from , final int count , final int size ) { 
int to = size ; 
if ( count != - 1 ) { 
to = from + count ; 
if ( to > size ) to = size ; 
} 
return to ; 
} 
} 

public class IteratorTag { 
protected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { 
JspFragment body = getJspBody ( ) ; 
Iterator iter = collection . iterator ( ) ; 
int i = 0 ; 
int to = calculateTo ( from , count , collection . size ( ) ) ; 
while ( i < to ) { 
Object item = iter . next ( ) ; 
if ( i >= from ) { 
if ( status != null ) iteratorStatus . next ( ! iter . hasNext ( ) ) ; 
TagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; 
TagUtil . invokeBody ( body ) ; 
} 
i ++ ; 
} 
} 
} 

public class IteratorTag { 
protected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { 
JspFragment body = getJspBody ( ) ; 
int len = array . length ; 
int to = calculateTo ( from , count , len ) ; 
int last = to - 1 ; 
for ( int i = from ; 
i < to ; 
i ++ ) { 
Object item = array [ i ] ; 
if ( status != null ) iteratorStatus . next ( i == last ) ; 
TagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; 
TagUtil . invokeBody ( body ) ; 
} 
} 
} 

public class StringUtil { 
public static String replace ( final String s , final String sub , final String with ) { 
if ( sub . isEmpty ( ) ) return s ; 
int c = 0 ; 
int i = s . indexOf ( sub , c ) ; 
if ( i == - 1 ) return s ; 
int length = s . length ( ) ; 
StringBuilder sb = new StringBuilder ( length + with . length ( ) ) ; 
do { 
sb . append ( s , c , i ) ; 
sb . append ( with ) ; 
c = i + sub . length ( ) ; 
} 
while ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; 
if ( c < length ) sb . append ( s , c , length ) ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String replaceChar ( final String s , final char sub , final char with ) { 
int startIndex = s . indexOf ( sub ) ; 
if ( startIndex == - 1 ) return s ; 
char [ ] str = s . toCharArray ( ) ; 
for ( int i = startIndex ; 
i < str . length ; 
i ++ ) if ( str [ i ] == sub ) str [ i ] = with ; 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { 
char [ ] str = s . toCharArray ( ) ; 
for ( int i = 0 ; 
i < str . length ; 
i ++ ) { 
char c = str [ i ] ; 
for ( int j = 0 ; 
j < sub . length ; 
j ++ ) if ( c == sub [ j ] ) { 
str [ i ] = with [ j ] ; 
break ; 
} 
} 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String replaceFirst ( final String s , final String sub , final String with ) { 
int i = s . indexOf ( sub ) ; 
if ( i == - 1 ) return s ; 
return s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; 
} 
} 

public class StringUtil { 
public static String replaceFirst ( final String s , final char sub , final char with ) { 
int index = s . indexOf ( sub ) ; 
if ( index == - 1 ) return s ; 
char [ ] str = s . toCharArray ( ) ; 
str [ index ] = with ; 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String replaceLast ( final String s , final String sub , final String with ) { 
int i = s . lastIndexOf ( sub ) ; 
if ( i == - 1 ) return s ; 
return s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; 
} 
} 

public class StringUtil { 
public static String replaceLast ( final String s , final char sub , final char with ) { 
int index = s . lastIndexOf ( sub ) ; 
if ( index == - 1 ) return s ; 
char [ ] str = s . toCharArray ( ) ; 
str [ index ] = with ; 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String remove ( final String s , final String sub ) { 
int c = 0 ; 
int sublen = sub . length ( ) ; 
if ( sublen == 0 ) return s ; 
int i = s . indexOf ( sub , c ) ; 
if ( i == - 1 ) return s ; 
StringBuilder sb = new StringBuilder ( s . length ( ) ) ; 
do { 
sb . append ( s , c , i ) ; 
c = i + sublen ; 
} 
while ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; 
if ( c < s . length ( ) ) sb . append ( s , c , s . length ( ) ) ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String remove ( final String string , final char ch ) { 
int stringLen = string . length ( ) ; 
char [ ] result = new char [ stringLen ] ; 
int offset = 0 ; 
for ( int i = 0 ; 
i < stringLen ; 
i ++ ) { 
char c = string . charAt ( i ) ; 
if ( c == ch ) continue ; 
result [ offset ] = c ; 
offset ++ ; 
} 
if ( offset == stringLen ) return string ; 
return new String ( result , 0 , offset ) ; 
} 
} 

public class StringUtil { 
public static boolean isAllEmpty ( final String ... strings ) { 
for ( String string : strings ) { 
if ( ! isEmpty ( string ) ) return false ; 
} 
return true ; 
} 
} 

public class StringUtil { 
public static boolean isAllBlank ( final String ... strings ) { 
for ( String string : strings ) { 
if ( ! isBlank ( string ) ) return false ; 
} 
return true ; 
} 
} 

public class StringUtil { 
public static String [ ] toStringArray ( final Object value ) { 
if ( value == null ) return new String [ 0 ] ; 
Class < ? > type = value . getClass ( ) ; 
if ( ! type . isArray ( ) ) return new String [ ] { 
value . toString ( ) } 
; 
Class componentType = type . getComponentType ( ) ; 
if ( componentType . isPrimitive ( ) ) if ( componentType == int . class ) return ArraysUtil . toStringArray ( ( int [ ] ) value ) ; 
else if ( componentType == long . class ) return ArraysUtil . toStringArray ( ( long [ ] ) value ) ; 
else if ( componentType == double . class ) return ArraysUtil . toStringArray ( ( double [ ] ) value ) ; 
else if ( componentType == float . class ) return ArraysUtil . toStringArray ( ( float [ ] ) value ) ; 
else if ( componentType == boolean . class ) return ArraysUtil . toStringArray ( ( boolean [ ] ) value ) ; 
else if ( componentType == short . class ) return ArraysUtil . toStringArray ( ( short [ ] ) value ) ; 
else if ( componentType == byte . class ) return ArraysUtil . toStringArray ( ( byte [ ] ) value ) ; 
else throw new IllegalArgumentException ( ) ; 
else return ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; 
} 
} 

public class StringUtil { 
private static String changeFirstCharacterCase ( final boolean capitalize , final String string ) { 
int strLen = string . length ( ) ; 
if ( strLen == 0 ) return string ; 
char ch = string . charAt ( 0 ) ; 
char modifiedCh ; 
if ( capitalize ) modifiedCh = Character . toUpperCase ( ch ) ; 
else modifiedCh = Character . toLowerCase ( ch ) ; 
if ( modifiedCh == ch ) return string ; 
char [ ] chars = string . toCharArray ( ) ; 
chars [ 0 ] = modifiedCh ; 
return new String ( chars ) ; 
} 
} 

public class StringUtil { 
public static String title ( final String string ) { 
char [ ] chars = string . toCharArray ( ) ; 
boolean wasWhitespace = true ; 
for ( int i = 0 ; 
i < chars . length ; 
i ++ ) { 
char c = chars [ i ] ; 
if ( CharUtil . isWhitespace ( c ) ) wasWhitespace = true ; 
else { 
if ( wasWhitespace ) chars [ i ] = Character . toUpperCase ( c ) ; 
else chars [ i ] = Character . toLowerCase ( c ) ; 
wasWhitespace = false ; 
} 
} 
return new String ( chars ) ; 
} 
} 

public class StringUtil { 
public static String compressChars ( final String s , final char c ) { 
int len = s . length ( ) ; 
StringBuilder sb = new StringBuilder ( len ) ; 
boolean wasChar = false ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c1 = s . charAt ( i ) ; 
if ( c1 == c ) { 
if ( wasChar ) continue ; 
wasChar = true ; 
} 
else wasChar = false ; 
sb . append ( c1 ) ; 
} 
if ( sb . length ( ) == len ) return s ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { 
String sub = subS . toLowerCase ( ) ; 
int sublen = sub . length ( ) ; 
if ( startIndex + sublen > src . length ( ) ) return false ; 
int j = 0 ; 
int i = startIndex ; 
while ( j < sublen ) { 
char source = Character . toLowerCase ( src . charAt ( i ) ) ; 
if ( sub . charAt ( j ) != source ) return false ; 
j ++ ; 
i ++ ; 
} 
return true ; 
} 
} 

public class StringUtil { 
public static boolean endsWithChar ( final String s , final char c ) { 
if ( s . length ( ) == 0 ) return false ; 
return s . charAt ( s . length ( ) - 1 ) == c ; 
} 
} 

public class StringUtil { 
public static int countIgnoreCase ( final String source , final String sub ) { 
int count = 0 ; 
int j = 0 ; 
int sublen = sub . length ( ) ; 
if ( sublen == 0 ) return 0 ; 
while ( true ) { 
int i = indexOfIgnoreCase ( source , sub , j ) ; 
if ( i == - 1 ) break ; 
count ++ ; 
j = i + sublen ; 
} 
return count ; 
} 
} 

public class StringUtil { 
public static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { 
if ( as . length != as1 . length ) return false ; 
for ( int i = 0 ; 
i < as . length ; 
i ++ ) if ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) return false ; 
return true ; 
} 
} 

public class StringUtil { 
public static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { 
for ( int i = startindex ; 
i < endindex ; 
i ++ ) if ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) return i ; 
return - 1 ; 
} 
} 

public class StringUtil { 
public static String stripLeadingChar ( final String string , final char c ) { 
if ( string . length ( ) > 0 ) if ( string . charAt ( 0 ) == c ) return string . substring ( 1 ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static String stripTrailingChar ( final String string , final char c ) { 
if ( string . length ( ) > 0 ) if ( string . charAt ( string . length ( ) - 1 ) == c ) return string . substring ( 0 , string . length ( ) - 1 ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static String stripChar ( final String string , final char c ) { 
if ( string . length ( ) == 0 ) return string ; 
if ( string . length ( ) == 1 ) { 
if ( string . charAt ( 0 ) == c ) return StringPool . EMPTY ; 
return string ; 
} 
int left = 0 ; 
int right = string . length ( ) ; 
if ( string . charAt ( left ) == c ) left ++ ; 
if ( string . charAt ( right - 1 ) == c ) right -- ; 
return string . substring ( left , right ) ; 
} 
} 

public class StringUtil { 
public static String stripToChar ( final String string , final char c ) { 
int ndx = string . indexOf ( c ) ; 
if ( ndx == - 1 ) return string ; 
return string . substring ( ndx ) ; 
} 
} 

public class StringUtil { 
public static String stripFromChar ( final String string , final char c ) { 
int ndx = string . indexOf ( c ) ; 
if ( ndx == - 1 ) return string ; 
return string . substring ( 0 , ndx ) ; 
} 
} 

public class StringUtil { 
public static void cropAll ( final String ... strings ) { 
for ( int i = 0 ; 
i < strings . length ; 
i ++ ) { 
String string = strings [ i ] ; 
if ( string != null ) string = crop ( strings [ i ] ) ; 
strings [ i ] = string ; 
} 
} 
} 

public class StringUtil { 
public static String trimLeft ( final String src ) { 
int len = src . length ( ) ; 
int st = 0 ; 
while ( ( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) st ++ ; 
return st > 0 ? src . substring ( st ) : src ; 
} 
} 

public class StringUtil { 
public static String trimRight ( final String src ) { 
int len = src . length ( ) ; 
int count = len ; 
while ( ( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) len -- ; 
return ( len < count ) ? src . substring ( 0 , len ) : src ; 
} 
} 

public class StringUtil { 
public static int [ ] indexOfRegion ( final String string , final String leftBoundary , final String rightBoundary , final int offset ) { 
int ndx = offset ; 
int [ ] res = new int [ 4 ] ; 
ndx = string . indexOf ( leftBoundary , ndx ) ; 
if ( ndx == - 1 ) return null ; 
res [ 0 ] = ndx ; 
ndx += leftBoundary . length ( ) ; 
res [ 1 ] = ndx ; 
ndx = string . indexOf ( rightBoundary , ndx ) ; 
if ( ndx == - 1 ) return null ; 
res [ 2 ] = ndx ; 
res [ 3 ] = ndx + rightBoundary . length ( ) ; 
return res ; 
} 
} 

public class StringUtil { 
public static String join ( final Collection collection , final char separator ) { 
if ( collection == null ) return null ; 
if ( collection . size ( ) == 0 ) return StringPool . EMPTY ; 
final StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; 
final Iterator it = collection . iterator ( ) ; 
for ( int i = 0 ; 
i < collection . size ( ) ; 
i ++ ) { 
if ( i > 0 ) sb . append ( separator ) ; 
sb . append ( it . next ( ) ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String join ( final Object [ ] array , final String separator ) { 
if ( array == null ) return null ; 
if ( array . length == 0 ) return StringPool . EMPTY ; 
if ( array . length == 1 ) return String . valueOf ( array [ 0 ] ) ; 
final StringBuilder sb = new StringBuilder ( array . length * 16 ) ; 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( i > 0 ) sb . append ( separator ) ; 
sb . append ( array [ i ] ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String convertCharset ( final String source , final String srcCharsetName , final String newCharsetName ) { 
if ( srcCharsetName . equals ( newCharsetName ) ) return source ; 
return StringUtil . newString ( StringUtil . getBytes ( source , srcCharsetName ) , newCharsetName ) ; 
} 
} 

public class StringUtil { 
public static boolean isCharAtEqual ( final String string , final int index , final char charToCompare ) { 
if ( ( index < 0 ) || ( index >= string . length ( ) ) ) return false ; 
return string . charAt ( index ) == charToCompare ; 
} 
} 

public class StringUtil { 
public static String surround ( String string , final String prefix , final String suffix ) { 
if ( ! string . startsWith ( prefix ) ) string = prefix + string ; 
if ( ! string . endsWith ( suffix ) ) string += suffix ; 
return string ; 
} 
} 

public class StringUtil { 
public static String prefix ( String string , final String prefix ) { 
if ( ! string . startsWith ( prefix ) ) string = prefix + string ; 
return string ; 
} 
} 

public class StringUtil { 
public static String suffix ( String string , final String suffix ) { 
if ( ! string . endsWith ( suffix ) ) string += suffix ; 
return string ; 
} 
} 

public class StringUtil { 
public static String cutToIndexOf ( String string , final String substring ) { 
int i = string . indexOf ( substring ) ; 
if ( i != - 1 ) string = string . substring ( 0 , i ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static String cutFromIndexOf ( String string , final String substring ) { 
int i = string . indexOf ( substring ) ; 
if ( i != - 1 ) string = string . substring ( i ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static String cutPrefix ( String string , final String prefix ) { 
if ( string . startsWith ( prefix ) ) string = string . substring ( prefix . length ( ) ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static String cutSuffix ( String string , final String suffix ) { 
if ( string . endsWith ( suffix ) ) string = string . substring ( 0 , string . length ( ) - suffix . length ( ) ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static String cutSurrounding ( final String string , final String prefix , final String suffix ) { 
int start = 0 ; 
int end = string . length ( ) ; 
if ( string . startsWith ( prefix ) ) start = prefix . length ( ) ; 
if ( string . endsWith ( suffix ) ) end -= suffix . length ( ) ; 
if ( end <= start ) return StringPool . EMPTY ; 
return string . substring ( start , end ) ; 
} 
} 

public class StringUtil { 
public static String insert ( final String src , final String insert , int offset ) { 
if ( offset < 0 ) offset = 0 ; 
if ( offset > src . length ( ) ) offset = src . length ( ) ; 
StringBuilder sb = new StringBuilder ( src ) ; 
sb . insert ( offset , insert ) ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String reverse ( final String s ) { 
StringBuilder result = new StringBuilder ( s . length ( ) ) ; 
for ( int i = s . length ( ) - 1 ; 
i >= 0 ; 
i -- ) result . append ( s . charAt ( i ) ) ; 
return result . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String maxCommonPrefix ( final String one , final String two ) { 
final int minLength = Math . min ( one . length ( ) , two . length ( ) ) ; 
final StringBuilder sb = new StringBuilder ( minLength ) ; 
for ( int pos = 0 ; 
pos < minLength ; 
pos ++ ) { 
final char currentChar = one . charAt ( pos ) ; 
if ( currentChar != two . charAt ( pos ) ) break ; 
sb . append ( currentChar ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String findCommonPrefix ( final String ... strings ) { 
StringBuilder prefix = new StringBuilder ( ) ; 
int index = 0 ; 
char c = 0 ; 
loop : while ( true ) { 
for ( int i = 0 ; 
i < strings . length ; 
i ++ ) { 
String s = strings [ i ] ; 
if ( index == s . length ( ) ) break loop ; 
if ( i == 0 ) c = s . charAt ( index ) ; 
else if ( s . charAt ( index ) != c ) break loop ; 
} 
index ++ ; 
prefix . append ( c ) ; 
} 
return prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String shorten ( String s , int length , final String suffix ) { 
length -= suffix . length ( ) ; 
if ( s . length ( ) > length ) { 
for ( int j = length ; 
j >= 0 ; 
j -- ) if ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { 
length = j ; 
break ; 
} 
String temp = s . substring ( 0 , length ) ; 
s = temp . concat ( suffix ) ; 
} 
return s ; 
} 
} 

public class StringUtil { 
public static String toUpperCase ( final String s , Locale locale ) { 
if ( s == null ) return null ; 
StringBuilder sb = null ; 
for ( int i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( c > 127 ) { 
if ( locale == null ) locale = Locale . getDefault ( ) ; 
return s . toUpperCase ( locale ) ; 
} 
if ( ( c >= 'a' ) && ( c <= 'z' ) ) { 
if ( sb == null ) sb = new StringBuilder ( s ) ; 
sb . setCharAt ( i , ( char ) ( c - 32 ) ) ; 
} 
} 
if ( sb == null ) return s ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String removeQuotes ( final String string ) { 
if ( ( startsWithChar ( string , '\'' ) && endsWithChar ( string , '\'' ) ) || ( startsWithChar ( string , '"' ) && endsWithChar ( string , '"' ) ) || ( startsWithChar ( string , '`' ) && endsWithChar ( string , '`' ) ) ) return substring ( string , 1 , - 1 ) ; 
return string ; 
} 
} 

public class StringUtil { 
public static char detectQuoteChar ( final String str ) { 
if ( str . length ( ) < 2 ) return 0 ; 
final char c = str . charAt ( 0 ) ; 
if ( c != str . charAt ( str . length ( ) - 1 ) ) return 0 ; 
if ( c == '\'' || c == '"' || c == '`' ) return c ; 
return 0 ; 
} 
} 

public class AnnotationVisitor { 
public void visit ( final String name , final Object value ) { 
if ( av != null ) av . visit ( name , value ) ; 
} 
} 

public class AnnotationVisitor { 
public void visitEnum ( final String name , final String descriptor , final String value ) { 
if ( av != null ) av . visitEnum ( name , descriptor , value ) ; 
} 
} 

public class AnnotationVisitor { 
public AnnotationVisitor visitAnnotation ( final String name , final String descriptor ) { 
if ( av != null ) return av . visitAnnotation ( name , descriptor ) ; 
return null ; 
} 
} 

public class DbEntityManager { 
public < E > DbEntityDescriptor < E > registerType ( final Class < E > type ) { 
DbEntityDescriptor < E > ded = createDbEntityDescriptor ( type ) ; 
DbEntityDescriptor < E > existing = descriptorsMap . put ( type , ded ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "Register " + type . getName ( ) + " as " + ded . getTableName ( ) ) ; 
if ( existing != null ) { 
if ( ded . getType ( ) == type ) return ded ; 
throw new DbOomException ( "Type already registered: " + existing . getType ( ) ) ; 
} 
existing = entityNamesMap . put ( ded . getEntityName ( ) , ded ) ; 
if ( existing != null ) throw new DbOomException ( "Name '" + ded . getEntityName ( ) + "' already mapped to an entity: " + existing . getType ( ) ) ; 
return ded ; 
} 
} 

public class DbEntityManager { 
public < E > DbEntityDescriptor < E > registerEntity ( final Class < E > type , final boolean force ) { 
if ( force ) removeEntity ( type ) ; 
return registerEntity ( type ) ; 
} 
} 

public class DbEntityManager { 
public < E > DbEntityDescriptor < E > removeEntity ( final Class < E > type ) { 
DbEntityDescriptor < E > ded = descriptorsMap . remove ( type ) ; 
if ( ded == null ) ded = createDbEntityDescriptor ( type ) ; 
entityNamesMap . remove ( ded . getEntityName ( ) ) ; 
tableNamesMap . remove ( ded . getTableName ( ) ) ; 
return ded ; 
} 
} 

public class WrapperProxettaFactory { 
public WrapperProxettaFactory setTargetInterface ( final Class targetInterface ) { 
if ( ! targetInterface . isInterface ( ) ) throw new ProxettaException ( "Not an interface: " + targetInterface . getName ( ) ) ; 
this . targetInterface = targetInterface ; 
return this ; 
} 
} 

public class AnnotatedPropertyInterceptor { 
protected PropertyDescriptor [ ] lookupAnnotatedProperties ( final Class type ) { 
PropertyDescriptor [ ] properties = annotatedProperties . get ( type ) ; 
if ( properties != null ) return properties ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; 
List < PropertyDescriptor > list = new ArrayList < > ( ) ; 
for ( PropertyDescriptor propertyDescriptor : allProperties ) { 
Annotation ann = null ; 
if ( propertyDescriptor . getFieldDescriptor ( ) != null ) ann = propertyDescriptor . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( annotations ) ; 
if ( ann == null && propertyDescriptor . getWriteMethodDescriptor ( ) != null ) ann = propertyDescriptor . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; 
if ( ann == null && propertyDescriptor . getReadMethodDescriptor ( ) != null ) ann = propertyDescriptor . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; 
if ( ann != null ) list . add ( propertyDescriptor ) ; 
} 
if ( list . isEmpty ( ) ) properties = EMPTY ; 
else properties = list . toArray ( new PropertyDescriptor [ 0 ] ) ; 
annotatedProperties . put ( type , properties ) ; 
return properties ; 
} 
} 

public class GzipResponseStream { 
@ Override public void close ( ) throws IOException { 
if ( closed ) return ; 
if ( gzipstream != null ) { 
flushToGZip ( ) ; 
gzipstream . close ( ) ; 
gzipstream = null ; 
} 
else if ( bufferCount > 0 ) { 
output . write ( buffer , 0 , bufferCount ) ; 
bufferCount = 0 ; 
} 
output . close ( ) ; 
closed = true ; 
} 
} 

public class GzipResponseStream { 
@ Override public void write ( final int b ) throws IOException { 
if ( closed ) throw new IOException ( "Cannot write to a closed output stream" ) ; 
if ( bufferCount >= buffer . length ) flushToGZip ( ) ; 
buffer [ bufferCount ++ ] = ( byte ) b ; 
} 
} 

public class RemoveSessionFromUrlFilter { 
@ Override public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain chain ) throws IOException , ServletException { 
HttpServletRequest httpRequest = ( HttpServletRequest ) request ; 
HttpServletResponse httpResponse = ( HttpServletResponse ) response ; 
if ( isRequestedSessionIdFromURL ( httpRequest ) ) { 
HttpSession session = httpRequest . getSession ( false ) ; 
if ( session != null ) session . invalidate ( ) ; 
} 
HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper ( httpResponse ) { 
@ Override public String encodeRedirectUrl ( final String url ) { 
return url ; 
} 
@ Override public String encodeRedirectURL ( final String url ) { 
return url ; 
} 
@ Override public String encodeUrl ( final String url ) { 
return url ; 
} 
@ Override public String encodeURL ( final String url ) { 
return url ; 
} 
} 
; 
chain . doFilter ( request , wrappedResponse ) ; 
} 
} 

public class EmailAttachment { 
public String getEncodedName ( ) { 
if ( name == null ) return null ; 
try { 
return MimeUtility . encodeText ( name ) ; 
} 
catch ( final UnsupportedEncodingException ueex ) { 
throw new MailException ( ueex ) ; 
} 
} 
} 

public class EmailAttachment { 
public byte [ ] toByteArray ( ) { 
final FastByteArrayOutputStream out ; 
if ( size != - 1 ) out = new FastByteArrayOutputStream ( size ) ; 
else out = new FastByteArrayOutputStream ( ) ; 
writeToStream ( out ) ; 
return out . toByteArray ( ) ; 
} 
} 

public class StripHtmlTagAdapter { 
@ Override public void text ( final CharSequence text ) { 
if ( ! strip ) { 
super . text ( text ) ; 
return ; 
} 
int textLength = text . length ( ) ; 
char [ ] dest = new char [ textLength ] ; 
int ndx = 0 ; 
boolean regularChar = true ; 
for ( int i = 0 ; 
i < textLength ; 
i ++ ) { 
char c = text . charAt ( i ) ; 
if ( CharUtil . isWhitespace ( c ) ) if ( regularChar ) { 
regularChar = false ; 
c = ' ' ; 
} 
else continue ; 
else regularChar = true ; 
dest [ ndx ] = c ; 
ndx ++ ; 
} 
if ( regularChar || ( ndx != 1 ) ) { 
super . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; 
strippedCharsCount += textLength - ndx ; 
} 
else strippedCharsCount += textLength ; 
} 
} 

public class NodeSelector { 
protected void processSelectors ( final List < Node > results , final List < CssSelector > selectors ) { 
List < Node > selectedNodes = select ( rootNode , selectors ) ; 
for ( Node selectedNode : selectedNodes ) { 
if ( ! results . contains ( selectedNode ) ) results . add ( selectedNode ) ; 
} 
} 
} 

public class NodeSelector { 
public Node selectFirst ( final String query ) { 
List < Node > selectedNodes = select ( query ) ; 
if ( selectedNodes . isEmpty ( ) ) return null ; 
return selectedNodes . get ( 0 ) ; 
} 
} 

public class NodeSelector { 
protected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { 
while ( ! nodes . isEmpty ( ) ) { 
Node node = nodes . removeFirst ( ) ; 
selectAndAdd ( node , cssSelector , result ) ; 
int childCount = node . getChildNodesCount ( ) ; 
for ( int i = childCount - 1 ; 
i >= 0 ; 
i -- ) nodes . addFirst ( node . getChild ( i ) ) ; 
} 
} 
} 

public class NodeSelector { 
protected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { 
CssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; 
Combinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; 
switch ( combinator ) { 
case DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; 
int childCount = rootNode . getChildNodesCount ( ) ; 
for ( int i = 0 ; 
i < childCount ; 
i ++ ) nodes . add ( rootNode . getChild ( i ) ) ; 
walkDescendantsIteratively ( nodes , cssSelector , result ) ; 
break ; 
case CHILD : childCount = rootNode . getChildNodesCount ( ) ; 
for ( int i = 0 ; 
i < childCount ; 
i ++ ) { 
Node node = rootNode . getChild ( i ) ; 
selectAndAdd ( node , cssSelector , result ) ; 
} 
break ; 
case ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; 
if ( node != null ) selectAndAdd ( node , cssSelector , result ) ; 
break ; 
case GENERAL_SIBLING : node = rootNode ; 
while ( true ) { 
node = node . getNextSiblingElement ( ) ; 
if ( node == null ) break ; 
selectAndAdd ( node , cssSelector , result ) ; 
} 
break ; 
} 
} 
} 

public class NodeSelector { 
protected void selectAndAdd ( final Node node , final CssSelector cssSelector , final List < Node > result ) { 
if ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) return ; 
boolean matched = cssSelector . accept ( node ) ; 
if ( matched ) { 
if ( result . contains ( node ) ) return ; 
result . add ( node ) ; 
} 
} 
} 

public class DbPager { 
protected < T > PageData < T > page ( String sql , final Map params , final int page , final int pageSize , final String sortColumnName , final boolean ascending , final Class [ ] target ) { 
if ( sortColumnName != null ) sql = buildOrderSql ( sql , sortColumnName , ascending ) ; 
int from = ( page - 1 ) * pageSize ; 
String pageSql = buildPageSql ( sql , from , pageSize ) ; 
DbSqlBuilder dbsql = sql ( pageSql ) ; 
DbOomQuery query = query ( dbsql ) ; 
query . setMaxRows ( pageSize ) ; 
query . setFetchSize ( pageSize ) ; 
query . setMap ( params ) ; 
List < T > list = query . list ( pageSize , target ) ; 
query . close ( ) ; 
String countSql = buildCountSql ( sql ) ; 
dbsql = sql ( countSql ) ; 
query = query ( dbsql ) ; 
query . setMap ( params ) ; 
long count = query . executeCount ( ) ; 
query . close ( ) ; 
return new PageData < > ( page , ( int ) count , pageSize , list ) ; 
} 
} 

public class DbPager { 
protected String removeSelect ( String sql ) { 
int ndx = StringUtil . indexOfIgnoreCase ( sql , "select" ) ; 
if ( ndx != - 1 ) sql = sql . substring ( ndx + 6 ) ; 
return sql ; 
} 
} 

public class DbPager { 
protected String removeToFrom ( String sql ) { 
int from = 0 ; 
int fromCount = 1 ; 
int selectCount = 0 ; 
int lastNdx = 0 ; 
while ( true ) { 
int ndx = StringUtil . indexOfIgnoreCase ( sql , "from" , from ) ; 
if ( ndx == - 1 ) break ; 
String left = sql . substring ( lastNdx , ndx ) ; 
selectCount += StringUtil . countIgnoreCase ( left , "select" ) ; 
if ( fromCount >= selectCount ) { 
sql = sql . substring ( ndx ) ; 
break ; 
} 
lastNdx = ndx ; 
from = ndx + 4 ; 
fromCount ++ ; 
} 
return sql ; 
} 
} 

public class DbPager { 
protected String removeLastOrderBy ( String sql ) { 
int ndx = StringUtil . lastIndexOfIgnoreCase ( sql , "order by" ) ; 
if ( ndx != - 1 ) { 
int ndx2 = sql . lastIndexOf ( sql , ')' ) ; 
if ( ndx > ndx2 ) sql = sql . substring ( 0 , ndx ) ; 
} 
return sql ; 
} 
} 

public class HtmlDecoder { 
public static String decode ( final String html ) { 
int ndx = html . indexOf ( '&' ) ; 
if ( ndx == - 1 ) return html ; 
StringBuilder result = new StringBuilder ( html . length ( ) ) ; 
int lastIndex = 0 ; 
int len = html . length ( ) ; 
mainloop : while ( ndx != - 1 ) { 
result . append ( html . substring ( lastIndex , ndx ) ) ; 
lastIndex = ndx ; 
while ( html . charAt ( lastIndex ) != ';' ) { 
lastIndex ++ ; 
if ( lastIndex == len ) { 
lastIndex = ndx ; 
break mainloop ; 
} 
} 
if ( html . charAt ( ndx + 1 ) == '#' ) { 
char c = html . charAt ( ndx + 2 ) ; 
int radix ; 
if ( ( c == 'x' ) || ( c == 'X' ) ) { 
radix = 16 ; 
ndx += 3 ; 
} 
else { 
radix = 10 ; 
ndx += 2 ; 
} 
String number = html . substring ( ndx , lastIndex ) ; 
int i = Integer . parseInt ( number , radix ) ; 
result . append ( ( char ) i ) ; 
lastIndex ++ ; 
} 
else { 
String encodeToken = html . substring ( ndx + 1 , lastIndex ) ; 
char [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; 
if ( replacement == null ) { 
result . append ( '&' ) ; 
lastIndex = ndx + 1 ; 
} 
else { 
result . append ( replacement ) ; 
lastIndex ++ ; 
} 
} 
ndx = html . indexOf ( '&' , lastIndex ) ; 
} 
result . append ( html . substring ( lastIndex ) ) ; 
return result . toString ( ) ; 
} 
} 

public class HtmlDecoder { 
public static String detectName ( final char [ ] input , int ndx ) { 
final Ptr ptr = new Ptr ( ) ; 
int firstIndex = 0 ; 
int lastIndex = ENTITY_NAMES . length - 1 ; 
int len = input . length ; 
char [ ] lastName = null ; 
final BinarySearchBase binarySearch = new BinarySearchBase ( ) { 
@ Override protected int compare ( final int index ) { 
char [ ] name = ENTITY_NAMES [ index ] ; 
if ( ptr . offset >= name . length ) return - 1 ; 
return name [ ptr . offset ] - ptr . c ; 
} 
} 
; 
while ( true ) { 
ptr . c = input [ ndx ] ; 
if ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) return lastName != null ? new String ( lastName ) : null ; 
firstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; 
if ( firstIndex < 0 ) return lastName != null ? new String ( lastName ) : null ; 
char [ ] element = ENTITY_NAMES [ firstIndex ] ; 
if ( element . length == ptr . offset + 1 ) lastName = ENTITY_NAMES [ firstIndex ] ; 
lastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; 
if ( firstIndex == lastIndex ) { 
for ( int i = ptr . offset ; 
i < element . length ; 
i ++ ) { 
if ( element [ i ] != input [ ndx ] ) return lastName != null ? new String ( lastName ) : null ; 
ndx ++ ; 
} 
return new String ( element ) ; 
} 
ptr . offset ++ ; 
ndx ++ ; 
if ( ndx == len ) return lastName != null ? new String ( lastName ) : null ; 
} 
} 
} 

public class HsqlDbPager { 
@ Override protected String buildOrderSql ( String sql , final String column , final boolean ascending ) { 
sql += " order by " + column ; 
if ( ! ascending ) sql += " desc" ; 
return sql ; 
} 
} 

public class DbEntityDescriptor { 
private void resolveColumnsAndProperties ( final Class type ) { 
PropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; 
List < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; 
int idcount = 0 ; 
HashSet < String > names = new HashSet < > ( allProperties . length ) ; 
for ( PropertyDescriptor propertyDescriptor : allProperties ) { 
DbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; 
if ( dec != null ) { 
if ( ! names . add ( dec . getColumnName ( ) ) ) throw new DbOomException ( "Duplicate column name: " + dec . getColumnName ( ) ) ; 
decList . add ( dec ) ; 
if ( dec . isId ) idcount ++ ; 
} 
} 
if ( decList . isEmpty ( ) ) throw new DbOomException ( "No column mappings in entity: " + type ) ; 
columnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; 
Arrays . sort ( columnDescriptors ) ; 
if ( idcount > 0 ) { 
idColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; 
idcount = 0 ; 
for ( DbEntityColumnDescriptor dec : columnDescriptors ) { 
if ( dec . isId ) idColumnDescriptors [ idcount ++ ] = dec ; 
} 
} 
} 
} 

public class DbEntityDescriptor { 
public DbEntityColumnDescriptor findByColumnName ( final String columnName ) { 
if ( columnName == null ) return null ; 
init ( ) ; 
for ( DbEntityColumnDescriptor columnDescriptor : columnDescriptors ) { 
if ( columnDescriptor . columnName . equalsIgnoreCase ( columnName ) ) return columnDescriptor ; 
} 
return null ; 
} 
} 

public class DbEntityDescriptor { 
public DbEntityColumnDescriptor findByPropertyName ( final String propertyName ) { 
if ( propertyName == null ) return null ; 
init ( ) ; 
for ( DbEntityColumnDescriptor columnDescriptor : columnDescriptors ) { 
if ( columnDescriptor . propertyName . equals ( propertyName ) ) return columnDescriptor ; 
} 
return null ; 
} 
} 

public class StringBand { 
public StringBand append ( String s ) { 
if ( s == null ) s = StringPool . NULL ; 
if ( index >= array . length ) expandCapacity ( ) ; 
array [ index ++ ] = s ; 
length += s . length ( ) ; 
return this ; 
} 
} 

public class StringBand { 
public void setIndex ( final int newIndex ) { 
if ( newIndex < 0 ) throw new ArrayIndexOutOfBoundsException ( newIndex ) ; 
if ( newIndex > array . length ) { 
String [ ] newArray = new String [ newIndex ] ; 
System . arraycopy ( array , 0 , newArray , 0 , index ) ; 
array = newArray ; 
} 
if ( newIndex > index ) for ( int i = index ; 
i < newIndex ; 
i ++ ) array [ i ] = StringPool . EMPTY ; 
else if ( newIndex < index ) for ( int i = newIndex ; 
i < index ; 
i ++ ) array [ i ] = null ; 
index = newIndex ; 
length = calculateLength ( ) ; 
} 
} 

public class StringBand { 
protected int calculateLength ( ) { 
int len = 0 ; 
for ( int i = 0 ; 
i < index ; 
i ++ ) len += array [ i ] . length ( ) ; 
return len ; 
} 
} 

public class ScopedProxyManager { 
protected Object createScopedProxyBean ( final PetiteContainer petiteContainer , final BeanDefinition refBeanDefinition ) { 
Class beanType = refBeanDefinition . type ; 
Class proxyClass = proxyClasses . get ( beanType ) ; 
if ( proxyClass == null ) if ( refBeanDefinition instanceof ProxettaBeanDefinition ) { 
ProxettaBeanDefinition pbd = ( ProxettaBeanDefinition ) refBeanDefinition ; 
ProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspects ( ArraysUtil . insert ( pbd . proxyAspects , aspect , 0 ) ) ; 
proxetta . setClassNameSuffix ( "$ScopedProxy" ) ; 
proxetta . setVariableClassName ( true ) ; 
ProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( pbd . originalTarget ) ; 
proxyClass = builder . define ( ) ; 
proxyClasses . put ( beanType , proxyClass ) ; 
} 
else { 
ProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspect ( aspect ) ; 
proxetta . setClassNameSuffix ( "$ScopedProxy" ) ; 
proxetta . setVariableClassName ( true ) ; 
ProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( beanType ) ; 
proxyClass = builder . define ( ) ; 
proxyClasses . put ( beanType , proxyClass ) ; 
} 
Object proxy ; 
try { 
proxy = ClassUtil . newInstance ( proxyClass ) ; 
Field field = proxyClass . getField ( "$__petiteContainer$0" ) ; 
field . set ( proxy , petiteContainer ) ; 
field = proxyClass . getField ( "$__name$0" ) ; 
field . set ( proxy , refBeanDefinition . name ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( ex ) ; 
} 
return proxy ; 
} 
} 

public class LoopingTagSupport { 
protected void loopBody ( ) throws JspException { 
JspFragment body = getJspBody ( ) ; 
if ( body == null ) return ; 
LoopIterator loopIterator = new LoopIterator ( start , end , step , modulus ) ; 
if ( status != null ) getJspContext ( ) . setAttribute ( status , loopIterator ) ; 
while ( loopIterator . next ( ) ) TagUtil . invokeBody ( body ) ; 
if ( status != null ) getJspContext ( ) . removeAttribute ( status ) ; 
} 
} 

public class DirWatcher { 
protected void init ( ) { 
File [ ] filesArray = dir . listFiles ( ) ; 
filesCount = 0 ; 
if ( filesArray != null ) { 
filesCount = filesArray . length ; 
for ( File file : filesArray ) { 
if ( ! acceptFile ( file ) ) continue ; 
map . put ( file , new MutableLong ( file . lastModified ( ) ) ) ; 
} 
} 
} 
} 

public class DirWatcher { 
protected boolean acceptFile ( final File file ) { 
if ( ! file . isFile ( ) ) return false ; 
String fileName = file . getName ( ) ; 
if ( ignoreDotFiles ) if ( fileName . startsWith ( StringPool . DOT ) ) return false ; 
if ( patterns == null ) return true ; 
return Wildcard . matchOne ( fileName , patterns ) != - 1 ; 
} 
} 

public class DirWatcher { 
public DirWatcher useWatchFile ( final String name ) { 
watchFile = new File ( dir , name ) ; 
if ( ! watchFile . isFile ( ) || ! watchFile . exists ( ) ) try { 
FileUtil . touch ( watchFile ) ; 
} 
catch ( IOException ioex ) { 
throw new DirWatcherException ( "Invalid watch file: " + name , ioex ) ; 
} 
watchFileLastAccessTime = watchFile . lastModified ( ) ; 
return this ; 
} 
} 

public class DirWatcher { 
public void start ( final long pollingInterval ) { 
if ( timer == null ) { 
if ( ! startBlank ) init ( ) ; 
timer = new Timer ( true ) ; 
timer . schedule ( new WatchTask ( ) , 0 , pollingInterval ) ; 
} 
} 
} 

public class CompositeEnumeration { 
public void add ( final Enumeration < T > enumeration ) { 
if ( allEnumerations . contains ( enumeration ) ) throw new IllegalArgumentException ( "Duplicate enumeration" ) ; 
allEnumerations . add ( enumeration ) ; 
} 
} 

public class FieldWriter { 
int computeFieldInfoSize ( ) { 
int size = 8 ; 
if ( constantValueIndex != 0 ) { 
symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; 
size += 8 ; 
} 
if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { 
symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; 
size += 6 ; 
} 
if ( signatureIndex != 0 ) { 
symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; 
size += 8 ; 
} 
if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { 
symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; 
size += 6 ; 
} 
if ( lastRuntimeVisibleAnnotation != null ) size += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; 
if ( lastRuntimeInvisibleAnnotation != null ) size += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; 
if ( lastRuntimeVisibleTypeAnnotation != null ) size += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; 
if ( lastRuntimeInvisibleTypeAnnotation != null ) size += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; 
if ( firstAttribute != null ) size += firstAttribute . computeAttributesSize ( symbolTable ) ; 
return size ; 
} 
} 

public class FieldWriter { 
void putFieldInfo ( final ByteVector output ) { 
boolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; 
int mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; 
output . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; 
int attributesCount = 0 ; 
if ( constantValueIndex != 0 ) ++ attributesCount ; 
if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) ++ attributesCount ; 
if ( signatureIndex != 0 ) ++ attributesCount ; 
if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) ++ attributesCount ; 
if ( lastRuntimeVisibleAnnotation != null ) ++ attributesCount ; 
if ( lastRuntimeInvisibleAnnotation != null ) ++ attributesCount ; 
if ( lastRuntimeVisibleTypeAnnotation != null ) ++ attributesCount ; 
if ( lastRuntimeInvisibleTypeAnnotation != null ) ++ attributesCount ; 
if ( firstAttribute != null ) attributesCount += firstAttribute . getAttributeCount ( ) ; 
output . putShort ( attributesCount ) ; 
if ( constantValueIndex != 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; 
if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; 
if ( signatureIndex != 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; 
if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; 
if ( lastRuntimeVisibleAnnotation != null ) lastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; 
if ( lastRuntimeInvisibleAnnotation != null ) lastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; 
if ( lastRuntimeVisibleTypeAnnotation != null ) lastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; 
if ( lastRuntimeInvisibleTypeAnnotation != null ) lastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; 
if ( firstAttribute != null ) firstAttribute . putAttributes ( symbolTable , output ) ; 
} 
} 

public class DecoraParser { 
protected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { 
int ndx = 0 ; 
for ( DecoraTag decoraTag : decoraTags ) { 
int decoratorLen = decoraTag . getStartIndex ( ) - ndx ; 
if ( decoratorLen <= 0 ) continue ; 
out . write ( decoratorContent , ndx , decoratorLen ) ; 
ndx = decoraTag . getEndIndex ( ) ; 
int regionLen = decoraTag . getRegionLength ( ) ; 
if ( regionLen == 0 ) if ( decoraTag . hasDefaultValue ( ) ) out . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; 
else writeRegion ( out , pageContent , decoraTag , decoraTags ) ; 
} 
out . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; 
} 
} 

public class DecoraParser { 
protected void writeRegion ( final Writer out , final char [ ] pageContent , final DecoraTag decoraTag , final DecoraTag [ ] decoraTags ) throws IOException { 
int regionStart = decoraTag . getRegionStart ( ) ; 
int regionLen = decoraTag . getRegionLength ( ) ; 
int regionEnd = regionStart + regionLen ; 
for ( DecoraTag innerDecoraTag : decoraTags ) { 
if ( decoraTag == innerDecoraTag ) continue ; 
if ( decoraTag . isRegionUndefined ( ) ) continue ; 
if ( innerDecoraTag . isInsideOtherTagRegion ( decoraTag ) ) { 
out . write ( pageContent , regionStart , innerDecoraTag . getRegionTagStart ( ) - regionStart ) ; 
regionStart = innerDecoraTag . getRegionTagEnd ( ) ; 
} 
} 
out . write ( pageContent , regionStart , regionEnd - regionStart ) ; 
} 
} 

public class ImapSslServer { 
@ Override protected IMAPSSLStore getStore ( final Session session ) { 
SimpleAuthenticator simpleAuthenticator = ( SimpleAuthenticator ) authenticator ; 
final URLName url ; 
if ( simpleAuthenticator == null ) url = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , null , null ) ; 
else { 
final PasswordAuthentication pa = simpleAuthenticator . getPasswordAuthentication ( ) ; 
url = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , pa . getUserName ( ) , pa . getPassword ( ) ) ; 
} 
return new IMAPSSLStore ( session , url ) ; 
} 
} 

public class ColumnsSelectChunk { 
@ Override public void init ( final TemplateData templateData ) { 
super . init ( templateData ) ; 
if ( hint != null ) templateData . incrementHintsCount ( ) ; 
} 
} 

public class InExRules { 
protected void addRule ( final D ruleDefinition , final boolean include ) { 
if ( rules == null ) rules = new ArrayList < > ( ) ; 
if ( include ) includesCount ++ ; 
else excludesCount ++ ; 
Rule < R > newRule = new Rule < > ( makeRule ( ruleDefinition ) , include ) ; 
if ( rules . contains ( newRule ) ) return ; 
rules . add ( newRule ) ; 
} 
} 

public class InExRules { 
public boolean apply ( final V value , final boolean blacklist , boolean flag ) { 
if ( rules == null ) return flag ; 
if ( blacklist ) { 
flag = processExcludes ( value , flag ) ; 
flag = processIncludes ( value , flag ) ; 
} 
else { 
flag = processIncludes ( value , flag ) ; 
flag = processExcludes ( value , flag ) ; 
} 
return flag ; 
} 
} 

public class InExRules { 
protected boolean processIncludes ( final V value , boolean include ) { 
if ( includesCount > 0 ) if ( ! include ) for ( Rule < R > rule : rules ) { 
if ( ! rule . include ) continue ; 
if ( inExRuleMatcher . accept ( value , rule . value , true ) ) { 
include = true ; 
break ; 
} 
} 
return include ; 
} 
} 

public class InExRules { 
protected boolean processExcludes ( final V value , boolean include ) { 
if ( excludesCount > 0 ) if ( include ) for ( Rule < R > rule : rules ) { 
if ( rule . include ) continue ; 
if ( inExRuleMatcher . accept ( value , rule . value , false ) ) { 
include = false ; 
break ; 
} 
} 
return include ; 
} 
} 

public class SortedArrayList { 
@ Override public boolean addAll ( final Collection < ? extends E > c ) { 
Iterator < ? extends E > i = c . iterator ( ) ; 
boolean changed = false ; 
while ( i . hasNext ( ) ) { 
boolean ret = add ( i . next ( ) ) ; 
if ( ! changed ) changed = ret ; 
} 
return changed ; 
} 
} 

public class SortedArrayList { 
protected int findInsertionPoint ( final E o , int low , int high ) { 
while ( low <= high ) { 
int mid = ( low + high ) >>> 1 ; 
int delta = compare ( get ( mid ) , o ) ; 
if ( delta > 0 ) high = mid - 1 ; 
else low = mid + 1 ; 
} 
return low ; 
} 
} 

public class ActionConfigManager { 
public void bindAnnotationConfig ( final Class < ? extends Annotation > annotationType , final Class < ? extends ActionConfig > actionConfigClass ) { 
final ActionConfig actionConfig = registerNewActionConfiguration ( actionConfigClass ) ; 
actionConfigs . put ( annotationType , actionConfig ) ; 
for ( final AnnotationParser annotationParser : annotationParsers ) { 
if ( annotationType . equals ( annotationParser . getAnnotationType ( ) ) ) return ; 
} 
annotationParsers = ArraysUtil . append ( annotationParsers , new AnnotationParser ( annotationType , Action . class ) ) ; 
} 
} 

public class ActionConfigManager { 
public ActionConfig lookup ( final Class actionTypeOrAnnotationType ) { 
final ActionConfig actionConfig = actionConfigs . get ( actionTypeOrAnnotationType ) ; 
if ( actionConfig == null ) throw new MadvocException ( "ActionConfiguration not registered:" + actionTypeOrAnnotationType . getName ( ) ) ; 
return actionConfig ; 
} 
} 

public class HtmlFosterRules { 
protected Element findLastTable ( final Node node ) { 
Node tableNode = node ; 
while ( tableNode != null ) { 
if ( tableNode . getNodeType ( ) == Node . NodeType . ELEMENT ) { 
String tableNodeName = tableNode . getNodeName ( ) . toLowerCase ( ) ; 
if ( tableNodeName . equals ( "table" ) ) break ; 
} 
tableNode = tableNode . getParentNode ( ) ; 
} 
return ( Element ) tableNode ; 
} 
} 

public class HtmlFosterRules { 
protected void fixElements ( ) { 
for ( Element fosterElement : fosterElements ) { 
Element lastTable = findLastTable ( fosterElement ) ; 
Node fosterElementParent = fosterElement . getParentNode ( ) ; 
Node [ ] fosterChilds = fosterElement . getChildNodes ( ) ; 
for ( Node fosterChild : fosterChilds ) { 
if ( fosterChild . getNodeType ( ) == Node . NodeType . ELEMENT ) if ( isOneOfTableElements ( ( Element ) fosterChild ) ) { 
fosterChild . detachFromParent ( ) ; 
fosterElementParent . insertBefore ( fosterChild , fosterElement ) ; 
} 
} 
fosterElement . detachFromParent ( ) ; 
lastTable . getParentNode ( ) . insertBefore ( fosterElement , lastTable ) ; 
} 
} 
} 

public class SessionScope { 
@ SuppressWarnings ( "unchecked" ) protected Map < String , BeanData > getSessionMap ( final HttpSession session ) { 
SessionBeans sessionBeans = ( SessionBeans ) session . getAttribute ( SESSION_BEANS_NAME ) ; 
if ( sessionBeans == null ) return null ; 
return sessionBeans . getBeanMap ( ) ; 
} 
} 

public class WorkData { 
public void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { 
int lastSlash = name . lastIndexOf ( '/' ) ; 
this . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; 
this . targetClassname = name . substring ( lastSlash + 1 ) ; 
this . nextSupername = superName ; 
this . superName = name ; 
if ( reqProxyClassName != null ) if ( reqProxyClassName . startsWith ( DOT ) ) name = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; 
else if ( reqProxyClassName . endsWith ( DOT ) ) name = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; 
else name = reqProxyClassName . replace ( '.' , '/' ) ; 
if ( suffix != null ) name += suffix ; 
this . thisReference = name ; 
this . superReference = this . superName ; 
} 
} 

public class WorkData { 
void addAdviceInitMethod ( final String name ) { 
if ( adviceInits == null ) adviceInits = new ArrayList < > ( ) ; 
adviceInits . add ( name ) ; 
} 
} 

public class BundleAction { 
public void end ( ) { 
if ( newAction ) bundleId = bundlesManager . registerBundle ( contextPath , actionPath , bundleId , bundleContentType , sources ) ; 
} 
} 

public class PropsParser { 
protected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { 
if ( key == null ) return ; 
String fullKey = key ; 
if ( section != null ) if ( fullKey . length ( ) != 0 ) fullKey = section + '.' + fullKey ; 
else fullKey = section ; 
String v = value . toString ( ) ; 
if ( trim ) if ( valueTrimLeft && valueTrimRight ) v = v . trim ( ) ; 
else if ( valueTrimLeft ) v = StringUtil . trimLeft ( v ) ; 
else v = StringUtil . trimRight ( v ) ; 
if ( v . length ( ) == 0 && skipEmptyProps ) return ; 
extractProfilesAndAdd ( fullKey , v , operator ) ; 
} 
} 

public class PropsParser { 
protected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { 
String fullKey = key ; 
int ndx = fullKey . indexOf ( PROFILE_LEFT ) ; 
if ( ndx == - 1 ) { 
justAdd ( fullKey , value , null , operator ) ; 
return ; 
} 
ArrayList < String > keyProfiles = new ArrayList < > ( ) ; 
while ( true ) { 
ndx = fullKey . indexOf ( PROFILE_LEFT ) ; 
if ( ndx == - 1 ) break ; 
final int len = fullKey . length ( ) ; 
int ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; 
if ( ndx2 == - 1 ) ndx2 = len ; 
final String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; 
keyProfiles . add ( profile ) ; 
ndx2 ++ ; 
final String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; 
fullKey = fullKey . substring ( 0 , ndx ) + right ; 
} 
if ( fullKey . startsWith ( StringPool . DOT ) ) fullKey = fullKey . substring ( 1 ) ; 
justAdd ( fullKey , value , keyProfiles , operator ) ; 
} 
} 

public class PropsParser { 
protected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { 
if ( operator == Operator . COPY ) { 
HashMap < String , Object > target = new HashMap < > ( ) ; 
String [ ] profiles = null ; 
if ( keyProfiles != null ) profiles = keyProfiles . toArray ( new String [ 0 ] ) ; 
String [ ] sources = StringUtil . splitc ( value , ',' ) ; 
for ( String source : sources ) { 
source = source . trim ( ) ; 
String [ ] lookupProfiles = profiles ; 
String lookupProfilesString = null ; 
int leftIndex = source . indexOf ( '<' ) ; 
if ( leftIndex != - 1 ) { 
int rightIndex = source . indexOf ( '>' ) ; 
lookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; 
source = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; 
lookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; 
StringUtil . trimAll ( lookupProfiles ) ; 
} 
String [ ] wildcards = new String [ ] { 
source + ".*" } 
; 
propsData . extract ( target , lookupProfiles , wildcards , null ) ; 
for ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { 
String entryKey = entry . getKey ( ) ; 
String suffix = entryKey . substring ( source . length ( ) ) ; 
String newKey = key + suffix ; 
String newValue = "${" + entryKey ; 
if ( lookupProfilesString != null ) newValue += "<" + lookupProfilesString + ">" ; 
newValue += "}" ; 
if ( profiles == null ) propsData . putBaseProperty ( newKey , newValue , false ) ; 
else for ( final String p : profiles ) { 
propsData . putProfileProperty ( newKey , newValue , p , false ) ; 
} 
} 
} 
return ; 
} 
boolean append = operator == Operator . QUICK_APPEND ; 
if ( keyProfiles == null ) { 
propsData . putBaseProperty ( key , value , append ) ; 
return ; 
} 
for ( final String p : keyProfiles ) { 
propsData . putProfileProperty ( key , value , p , append ) ; 
} 
} 
} 

public class AsmUtil { 
public static String typedesc2ClassName ( final String desc ) { 
String className = desc ; 
switch ( desc . charAt ( 0 ) ) { 
case 'B' : case 'C' : case 'D' : case 'F' : case 'I' : case 'J' : case 'S' : case 'Z' : case 'V' : if ( desc . length ( ) != 1 ) throw new IllegalArgumentException ( INVALID_BASE_TYPE + desc ) ; 
break ; 
case 'L' : className = className . substring ( 1 , className . length ( ) - 1 ) ; 
break ; 
case '[' : className = className . replace ( '/' , '.' ) ; 
break ; 
default : throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; 
} 
return className ; 
} 
} 

public class AsmUtil { 
public static String typeref2Name ( final String desc ) { 
if ( desc . charAt ( 0 ) != TYPE_REFERENCE ) throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; 
String name = desc . substring ( 1 , desc . length ( ) - 1 ) ; 
return name . replace ( '/' , '.' ) ; 
} 
} 

public class AsmUtil { 
public static String typedescToSignature ( final String desc , final MutableInteger from ) { 
int fromIndex = from . get ( ) ; 
from . value ++ ; 
switch ( desc . charAt ( fromIndex ) ) { 
case 'B' : return "byte" ; 
case 'C' : return "char" ; 
case 'D' : return "double" ; 
case 'F' : return "float" ; 
case 'I' : return "int" ; 
case 'J' : return "long" ; 
case 'S' : return "short" ; 
case 'Z' : return "boolean" ; 
case 'V' : return "void" ; 
case 'L' : int index = desc . indexOf ( ';' , fromIndex ) ; 
if ( index < 0 ) throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; 
from . set ( index + 1 ) ; 
String str = desc . substring ( fromIndex + 1 , index ) ; 
return str . replace ( '/' , '.' ) ; 
case 'T' : return desc . substring ( from . value ) ; 
case '[' : StringBuilder brackets = new StringBuilder ( ) ; 
int n = fromIndex ; 
while ( desc . charAt ( n ) == '[' ) { 
brackets . append ( "[]" ) ; 
n ++ ; 
} 
from . value = n ; 
String type = typedescToSignature ( desc , from ) ; 
return type + brackets ; 
default : if ( from . value == 0 ) throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; 
return desc . substring ( from . value ) ; 
} 
} 
} 

public class AsmUtil { 
public static String typeToTyperef ( final Class type ) { 
if ( ! type . isArray ( ) ) { 
if ( ! type . isPrimitive ( ) ) return 'L' + typeToSignature ( type ) + ';' ; 
if ( type == int . class ) return "I" ; 
if ( type == long . class ) return "J" ; 
if ( type == boolean . class ) return "Z" ; 
if ( type == double . class ) return "D" ; 
if ( type == float . class ) return "F" ; 
if ( type == short . class ) return "S" ; 
if ( type == void . class ) return "V" ; 
if ( type == byte . class ) return "B" ; 
if ( type == char . class ) return "C" ; 
} 
return type . getName ( ) ; 
} 
} 

public class CollectionConverter { 
@ SuppressWarnings ( "unchecked" ) protected Collection < T > createCollection ( final int length ) { 
if ( collectionType . isInterface ( ) ) { 
if ( collectionType == List . class ) if ( length > 0 ) return new ArrayList < > ( length ) ; 
else return new ArrayList < > ( ) ; 
if ( collectionType == Set . class ) if ( length > 0 ) return new HashSet < > ( length ) ; 
else return new HashSet < > ( ) ; 
throw new TypeConversionException ( "Unknown collection: " + collectionType . getName ( ) ) ; 
} 
if ( length > 0 ) try { 
Constructor < Collection < T > > ctor = ( Constructor < Collection < T > > ) collectionType . getConstructor ( int . class ) ; 
return ctor . newInstance ( Integer . valueOf ( length ) ) ; 
} 
catch ( Exception ex ) { 
} 
try { 
return collectionType . getDeclaredConstructor ( ) . newInstance ( ) ; 
} 
catch ( Exception ex ) { 
throw new TypeConversionException ( ex ) ; 
} 
} 
} 

public class CollectionConverter { 
protected Collection < T > convertValueToCollection ( Object value ) { 
if ( value instanceof Iterable ) { 
Iterable iterable = ( Iterable ) value ; 
Collection < T > collection = createCollection ( 0 ) ; 
for ( Object element : iterable ) { 
collection . add ( convertType ( element ) ) ; 
} 
return collection ; 
} 
if ( value instanceof CharSequence ) value = CsvUtil . toStringArray ( value . toString ( ) ) ; 
Class type = value . getClass ( ) ; 
if ( type . isArray ( ) ) { 
Class componentType = type . getComponentType ( ) ; 
if ( componentType . isPrimitive ( ) ) return convertPrimitiveArrayToCollection ( value , componentType ) ; 
else { 
Object [ ] array = ( Object [ ] ) value ; 
Collection < T > result = createCollection ( array . length ) ; 
for ( Object a : array ) { 
result . add ( convertType ( a ) ) ; 
} 
return result ; 
} 
} 
return convertToSingleElementCollection ( value ) ; 
} 
} 

public class Label { 
final void addLineNumber ( final int lineNumber ) { 
if ( this . lineNumber == 0 ) this . lineNumber = ( short ) lineNumber ; 
else { 
if ( otherLineNumbers == null ) otherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; 
int otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; 
if ( otherLineNumberIndex >= otherLineNumbers . length ) { 
int [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; 
System . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; 
otherLineNumbers = newLineNumbers ; 
} 
otherLineNumbers [ otherLineNumberIndex ] = lineNumber ; 
} 
} 
} 

public class Label { 
final void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { 
methodVisitor . visitLabel ( this ) ; 
if ( visitLineNumbers && lineNumber != 0 ) { 
methodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; 
if ( otherLineNumbers != null ) for ( int i = 1 ; 
i <= otherLineNumbers [ 0 ] ; 
++ i ) methodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; 
} 
} 
} 

public class Label { 
final void put ( final ByteVector code , final int sourceInsnBytecodeOffset , final boolean wideReference ) { 
if ( ( flags & FLAG_RESOLVED ) == 0 ) if ( wideReference ) { 
addForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_WIDE , code . length ) ; 
code . putInt ( - 1 ) ; 
} 
else { 
addForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_SHORT , code . length ) ; 
code . putShort ( - 1 ) ; 
} 
else if ( wideReference ) code . putInt ( bytecodeOffset - sourceInsnBytecodeOffset ) ; 
else code . putShort ( bytecodeOffset - sourceInsnBytecodeOffset ) ; 
} 
} 

public class Label { 
private void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { 
if ( forwardReferences == null ) forwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; 
int lastElementIndex = forwardReferences [ 0 ] ; 
if ( lastElementIndex + 2 >= forwardReferences . length ) { 
int [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; 
System . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; 
forwardReferences = newValues ; 
} 
forwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; 
forwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; 
forwardReferences [ 0 ] = lastElementIndex ; 
} 
} 

public class Label { 
final boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { 
this . flags |= FLAG_RESOLVED ; 
this . bytecodeOffset = bytecodeOffset ; 
if ( forwardReferences == null ) return false ; 
boolean hasAsmInstructions = false ; 
for ( int i = forwardReferences [ 0 ] ; 
i > 0 ; 
i -= 2 ) { 
final int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; 
final int reference = forwardReferences [ i ] ; 
final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; 
int handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; 
if ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { 
if ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { 
int opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; 
if ( opcode < Opcodes . IFNULL ) code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; 
else code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; 
hasAsmInstructions = true ; 
} 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; 
code [ handle ] = ( byte ) relativeOffset ; 
} 
else { 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; 
code [ handle ] = ( byte ) relativeOffset ; 
} 
} 
return hasAsmInstructions ; 
} 
} 

public class Label { 
final void addSubroutineRetSuccessors ( final Label subroutineCaller ) { 
Label listOfProcessedBlocks = EMPTY_LIST ; 
Label listOfBlocksToProcess = this ; 
listOfBlocksToProcess . nextListElement = EMPTY_LIST ; 
while ( listOfBlocksToProcess != EMPTY_LIST ) { 
Label basicBlock = listOfBlocksToProcess ; 
listOfBlocksToProcess = basicBlock . nextListElement ; 
basicBlock . nextListElement = listOfProcessedBlocks ; 
listOfProcessedBlocks = basicBlock ; 
if ( ( basicBlock . flags & FLAG_SUBROUTINE_END ) != 0 && basicBlock . subroutineId != subroutineCaller . subroutineId ) basicBlock . outgoingEdges = new Edge ( basicBlock . outputStackSize , subroutineCaller . outgoingEdges . successor , basicBlock . outgoingEdges ) ; 
listOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; 
} 
while ( listOfProcessedBlocks != EMPTY_LIST ) { 
Label newListOfProcessedBlocks = listOfProcessedBlocks . nextListElement ; 
listOfProcessedBlocks . nextListElement = null ; 
listOfProcessedBlocks = newListOfProcessedBlocks ; 
} 
} 
} 

public class NaturalOrderComparator { 
protected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { 
int zeroCount1 = 0 ; 
while ( charAt ( str1 , ndx1 ) == '0' ) { 
zeroCount1 ++ ; 
ndx1 ++ ; 
} 
int len1 = 0 ; 
while ( true ) { 
final char char1 = charAt ( str1 , ndx1 ) ; 
final boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; 
if ( ! isDigitChar1 ) break ; 
len1 ++ ; 
ndx1 ++ ; 
} 
int zeroCount2 = 0 ; 
while ( charAt ( str2 , ndx2 ) == '0' ) { 
zeroCount2 ++ ; 
ndx2 ++ ; 
} 
int len2 = 0 ; 
int ndx1_new = ndx1 - len1 ; 
int equalNumbers = 0 ; 
while ( true ) { 
final char char2 = charAt ( str2 , ndx2 ) ; 
final boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; 
if ( ! isDigitChar2 ) break ; 
if ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) equalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; 
len2 ++ ; 
ndx2 ++ ; 
} 
if ( len1 != len2 ) return new int [ ] { 
len1 - len2 } 
; 
if ( equalNumbers != 0 ) return new int [ ] { 
equalNumbers } 
; 
return new int [ ] { 
0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } 
; 
} 
} 

public class NaturalOrderComparator { 
private char fixAccent ( final char c ) { 
for ( int i = 0 ; 
i < ACCENT_CHARS . length ; 
i += 2 ) { 
final char accentChar = ACCENT_CHARS [ i ] ; 
if ( accentChar == c ) return ACCENT_CHARS [ i + 1 ] ; 
} 
return c ; 
} 
} 

public class ByteVector { 
public ByteVector putByte ( final int byteValue ) { 
int currentLength = length ; 
if ( currentLength + 1 > data . length ) enlarge ( 1 ) ; 
data [ currentLength ++ ] = ( byte ) byteValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { 
int currentLength = length ; 
if ( currentLength + 2 > data . length ) enlarge ( 2 ) ; 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue1 ; 
currentData [ currentLength ++ ] = ( byte ) byteValue2 ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putShort ( final int shortValue ) { 
int currentLength = length ; 
if ( currentLength + 2 > data . length ) enlarge ( 2 ) ; 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put12 ( final int byteValue , final int shortValue ) { 
int currentLength = length ; 
if ( currentLength + 3 > data . length ) enlarge ( 3 ) ; 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { 
int currentLength = length ; 
if ( currentLength + 4 > data . length ) enlarge ( 4 ) ; 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue1 ; 
currentData [ currentLength ++ ] = ( byte ) byteValue2 ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putInt ( final int intValue ) { 
int currentLength = length ; 
if ( currentLength + 4 > data . length ) enlarge ( 4 ) ; 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) intValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { 
int currentLength = length ; 
if ( currentLength + 5 > data . length ) enlarge ( 5 ) ; 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue1 >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue1 ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue2 >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue2 ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putLong ( final long longValue ) { 
int currentLength = length ; 
if ( currentLength + 8 > data . length ) enlarge ( 8 ) ; 
byte [ ] currentData = data ; 
int intValue = ( int ) ( longValue >>> 32 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) intValue ; 
intValue = ( int ) longValue ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) intValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putByteArray ( final byte [ ] byteArrayValue , final int byteOffset , final int byteLength ) { 
if ( length + byteLength > data . length ) enlarge ( byteLength ) ; 
if ( byteArrayValue != null ) System . arraycopy ( byteArrayValue , byteOffset , data , length , byteLength ) ; 
length += byteLength ; 
return this ; 
} 
} 

public class AuthInterceptor { 
protected T authenticateUserViaHttpSession ( final ActionRequest actionRequest ) { 
final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; 
final UserSession < T > userSession = UserSession . get ( servletRequest ) ; 
if ( userSession == null ) return null ; 
final T authToken = userSession . getAuthToken ( ) ; 
if ( authToken == null ) return null ; 
final T newAuthToken = userAuth ( ) . rotateToken ( authToken ) ; 
if ( newAuthToken != authToken ) { 
final UserSession < T > newUserSesion = new UserSession < > ( newAuthToken , userAuth ( ) . tokenValue ( newAuthToken ) ) ; 
newUserSesion . start ( servletRequest , actionRequest . getHttpServletResponse ( ) ) ; 
} 
return newAuthToken ; 
} 
} 

public class AuthInterceptor { 
protected T authenticateUserViaToken ( final ActionRequest actionRequest ) { 
final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; 
final String token = ServletUtil . resolveAuthBearerToken ( servletRequest ) ; 
if ( token == null ) return null ; 
final T authToken = userAuth ( ) . validateToken ( token ) ; 
if ( authToken == null ) return null ; 
final T newAuthToken = userAuth ( ) . rotateToken ( authToken ) ; 
actionRequest . getHttpServletResponse ( ) . setHeader ( "Authentication" , "Bearer: " + userAuth ( ) . tokenValue ( newAuthToken ) ) ; 
return newAuthToken ; 
} 
} 

public class AuthInterceptor { 
protected T authenticateUserViaBasicAuth ( final ActionRequest actionRequest ) { 
final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; 
final String username = ServletUtil . resolveAuthUsername ( servletRequest ) ; 
if ( username == null ) return null ; 
final String password = ServletUtil . resolveAuthPassword ( servletRequest ) ; 
final T authToken = userAuth ( ) . login ( username , password ) ; 
if ( authToken == null ) return null ; 
return authToken ; 
} 
} 

public class ResourceBundleMessageResolver { 
public String findDefaultMessage ( final Locale locale , final String key ) { 
String indexedKey = calcIndexKey ( key ) ; 
String msg = getMessage ( fallbackBundlename , locale , key , indexedKey ) ; 
if ( msg != null ) return msg ; 
for ( String bname : defaultBundles ) { 
msg = getMessage ( bname , locale , key , indexedKey ) ; 
if ( msg != null ) return msg ; 
} 
return null ; 
} 
} 

public class StringKeyedMapAdapter { 
@ Override public void clear ( ) { 
entries = null ; 
Iterator < String > keys = getAttributeNames ( ) ; 
while ( keys . hasNext ( ) ) removeAttribute ( keys . next ( ) ) ; 
} 
} 

public class StringKeyedMapAdapter { 
@ Override public Set < Entry < String , Object > > entrySet ( ) { 
if ( entries == null ) { 
entries = new HashSet < > ( ) ; 
Iterator < String > iterator = getAttributeNames ( ) ; 
while ( iterator . hasNext ( ) ) { 
final String key = iterator . next ( ) ; 
final Object value = getAttribute ( key ) ; 
entries . add ( new Entry < String , Object > ( ) { 
@ Override public boolean equals ( final Object obj ) { 
if ( obj == null ) return false ; 
if ( this . getClass ( ) != obj . getClass ( ) ) return false ; 
Entry entry = ( Entry ) obj ; 
return ( ( key == null ) ? ( entry . getKey ( ) == null ) : key . equals ( entry . getKey ( ) ) ) && ( ( value == null ) ? ( entry . getValue ( ) == null ) : value . equals ( entry . getValue ( ) ) ) ; 
} 
@ Override public int hashCode ( ) { 
return ( ( key == null ) ? 0 : key . hashCode ( ) ) ^ ( ( value == null ) ? 0 : value . hashCode ( ) ) ; 
} 
@ Override public String getKey ( ) { 
return key ; 
} 
@ Override public Object getValue ( ) { 
return value ; 
} 
@ Override public Object setValue ( final Object obj ) { 
setAttribute ( key , obj ) ; 
return value ; 
} 
} 
) ; 
} 
} 
return entries ; 
} 
} 

public class ExceptionUtil { 
@ SuppressWarnings ( { 
"ThrowCaughtLocally" } 
) public static StackTraceElement [ ] getCurrentStackTrace ( ) { 
StackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; 
if ( ste . length > 1 ) { 
StackTraceElement [ ] result = new StackTraceElement [ ste . length - 1 ] ; 
System . arraycopy ( ste , 1 , result , 0 , ste . length - 1 ) ; 
return result ; 
} 
else return ste ; 
} 
} 

public class ExceptionUtil { 
public static StackTraceElement [ ] getStackTrace ( final Throwable t , final String [ ] allow , final String [ ] deny ) { 
StackTraceElement [ ] st = t . getStackTrace ( ) ; 
ArrayList < StackTraceElement > result = new ArrayList < > ( st . length ) ; 
elementLoop : for ( StackTraceElement element : st ) { 
String className = element . getClassName ( ) ; 
if ( allow != null ) { 
boolean validElemenet = false ; 
for ( String filter : allow ) { 
if ( className . contains ( filter ) ) { 
validElemenet = true ; 
break ; 
} 
} 
if ( ! validElemenet ) continue ; 
} 
if ( deny != null ) for ( String filter : deny ) { 
if ( className . contains ( filter ) ) continue elementLoop ; 
} 
result . add ( element ) ; 
} 
st = new StackTraceElement [ result . size ( ) ] ; 
return result . toArray ( st ) ; 
} 
} 

public class ExceptionUtil { 
public static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { 
ArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; 
while ( t != null ) { 
StackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; 
result . add ( stack ) ; 
t = t . getCause ( ) ; 
} 
StackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; 
for ( int i = 0 ; 
i < allStacks . length ; 
i ++ ) allStacks [ i ] = result . get ( i ) ; 
return allStacks ; 
} 
} 

public class ExceptionUtil { 
public static Throwable [ ] getExceptionChain ( Throwable throwable ) { 
ArrayList < Throwable > list = new ArrayList < > ( ) ; 
list . add ( throwable ) ; 
while ( ( throwable = throwable . getCause ( ) ) != null ) list . add ( throwable ) ; 
Throwable [ ] result = new Throwable [ list . size ( ) ] ; 
return list . toArray ( result ) ; 
} 
} 

public class ExceptionUtil { 
public static String buildMessage ( final String message , Throwable cause ) { 
if ( cause != null ) { 
cause = getRootCause ( cause ) ; 
StringBuilder buf = new StringBuilder ( ) ; 
if ( message != null ) buf . append ( message ) . append ( "; " ) ; 
buf . append ( "<--- " ) . append ( cause ) ; 
return buf . toString ( ) ; 
} 
else return message ; 
} 
} 

public class ExceptionUtil { 
public static Throwable unwrapThrowable ( final Throwable wrappedThrowable ) { 
Throwable unwrapped = wrappedThrowable ; 
while ( true ) if ( unwrapped instanceof InvocationTargetException ) unwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; 
else if ( unwrapped instanceof UndeclaredThrowableException ) unwrapped = ( ( UndeclaredThrowableException ) unwrapped ) . getUndeclaredThrowable ( ) ; 
else return unwrapped ; 
} 
} 

public class AutomagicMadvocConfigurator { 
protected void registerAsConsumer ( final ClassScanner classScanner ) { 
classScanner . registerEntryConsumer ( classPathEntry -> { 
final String entryName = classPathEntry . name ( ) ; 
if ( entryName . endsWith ( actionClassSuffix ) ) try { 
acceptActionClass ( classPathEntry . loadClass ( ) ) ; 
} 
catch ( Exception ex ) { 
log . debug ( "Invalid Madvoc action, ignoring: " + entryName ) ; 
} 
else if ( classPathEntry . isTypeSignatureInUse ( MADVOC_COMPONENT_ANNOTATION ) ) try { 
acceptMadvocComponentClass ( classPathEntry . loadClass ( ) ) ; 
} 
catch ( Exception ex ) { 
log . debug ( "Invalid Madvoc component ignoring: {}" + entryName ) ; 
} 
} 
) ; 
} 
} 

public class AutomagicMadvocConfigurator { 
protected void acceptMadvocComponentClass ( final Class componentClass ) { 
if ( componentClass == null ) return ; 
if ( ! checkClass ( componentClass ) ) return ; 
madvocComponents . add ( ( ) -> madvocContainer . registerComponent ( componentClass ) ) ; 
} 
} 

public class ClassLoaderUtil { 
public static ClassLoader getSystemClassLoader ( ) { 
if ( System . getSecurityManager ( ) == null ) return ClassLoader . getSystemClassLoader ( ) ; 
else return AccessController . doPrivileged ( ( PrivilegedAction < ClassLoader > ) ClassLoader :: getSystemClassLoader ) ; 
} 
} 

public class ClassLoaderUtil { 
public static InputStream getResourceAsStream ( final String resourceName , final ClassLoader callingClass ) throws IOException { 
URL url = getResourceUrl ( resourceName , callingClass ) ; 
if ( url != null ) return url . openStream ( ) ; 
return null ; 
} 
} 

public class RouteChunk { 
public RouteChunk add ( final String newValue ) { 
RouteChunk routeChunk = new RouteChunk ( routes , this , newValue ) ; 
if ( children == null ) children = new RouteChunk [ ] { 
routeChunk } 
; 
else children = ArraysUtil . append ( children , routeChunk ) ; 
return routeChunk ; 
} 
} 

public class RouteChunk { 
public RouteChunk findOrCreateChild ( final String value ) { 
if ( children != null ) for ( RouteChunk child : children ) { 
if ( child . get ( ) . equals ( value ) ) return child ; 
} 
return add ( value ) ; 
} 
} 

public class MultipartRequest { 
public void parseRequest ( ) throws IOException { 
if ( ServletUtil . isMultipartRequest ( request ) ) parseRequestStream ( request . getInputStream ( ) , characterEncoding ) ; 
else { 
Enumeration names = request . getParameterNames ( ) ; 
while ( names . hasMoreElements ( ) ) { 
String paramName = ( String ) names . nextElement ( ) ; 
String [ ] values = request . getParameterValues ( paramName ) ; 
putParameters ( paramName , values ) ; 
} 
} 
} 
} 

public class BeanUtilUtil { 
protected Object invokeSetter ( final Setter setter , final BeanProperty bp , Object value ) { 
try { 
final MapperFunction setterMapperFunction = setter . getMapperFunction ( ) ; 
if ( setterMapperFunction != null ) value = setterMapperFunction . apply ( value ) ; 
final Class type = setter . getSetterRawType ( ) ; 
if ( ClassUtil . isTypeOf ( type , Collection . class ) ) { 
Class componentType = setter . getSetterRawComponentType ( ) ; 
value = convertToCollection ( value , type , componentType ) ; 
} 
else value = convertType ( value , type ) ; 
setter . invokeSetter ( bp . bean , value ) ; 
} 
catch ( Exception ex ) { 
if ( isSilent ) return null ; 
throw new BeanException ( "Setter failed: " + setter , ex ) ; 
} 
return value ; 
} 
} 

public class BeanUtilUtil { 
protected Object createBeanProperty ( final BeanProperty bp ) { 
Setter setter = bp . getSetter ( true ) ; 
if ( setter == null ) return null ; 
Class type = setter . getSetterRawType ( ) ; 
Object newInstance ; 
try { 
newInstance = ClassUtil . newInstance ( type ) ; 
} 
catch ( Exception ex ) { 
if ( isSilent ) return null ; 
throw new BeanException ( "Invalid property: " + bp . name , bp , ex ) ; 
} 
newInstance = invokeSetter ( setter , bp , newInstance ) ; 
return newInstance ; 
} 
} 

public class UserSession { 
public static void stop ( final HttpServletRequest servletRequest , final HttpServletResponse servletResponse ) { 
final HttpSession httpSession = servletRequest . getSession ( false ) ; 
if ( httpSession != null ) httpSession . removeAttribute ( AUTH_SESSION_NAME ) ; 
final Cookie cookie = ServletUtil . getCookie ( servletRequest , AUTH_COOKIE_NAME ) ; 
if ( cookie == null ) return ; 
cookie . setMaxAge ( 0 ) ; 
cookie . setPath ( "/" ) ; 
servletResponse . addCookie ( cookie ) ; 
} 
} 

public class ValidationContext { 
@ SuppressWarnings ( { 
"unchecked" } 
) protected void collectAnnotationChecks ( final List < Check > annChecks , final Class targetType , final String targetName , final Annotation [ ] annotations ) { 
for ( Annotation annotation : annotations ) { 
Constraint c = annotation . annotationType ( ) . getAnnotation ( Constraint . class ) ; 
Class < ? extends ValidationConstraint > constraintClass ; 
if ( c == null ) { 
String constraintClassName = annotation . annotationType ( ) . getName ( ) + "Constraint" ; 
try { 
constraintClass = ClassLoaderUtil . loadClass ( constraintClassName , this . getClass ( ) . getClassLoader ( ) ) ; 
} 
catch ( ClassNotFoundException ingore ) { 
continue ; 
} 
} 
else constraintClass = c . value ( ) ; 
ValidationConstraint vc ; 
try { 
vc = newConstraint ( constraintClass , targetType ) ; 
} 
catch ( Exception ex ) { 
throw new VtorException ( "Invalid constraint: " + constraintClass . getClass ( ) . getName ( ) , ex ) ; 
} 
vc . configure ( annotation ) ; 
Check check = new Check ( targetName , vc ) ; 
copyDefaultCheckProperties ( check , annotation ) ; 
annChecks . add ( check ) ; 
} 
} 
} 

public class URLCoder { 
private static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { 
if ( source == null ) return null ; 
byte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; 
char [ ] chars = new char [ bytes . length ] ; 
for ( int i = 0 ; 
i < bytes . length ; 
i ++ ) chars [ i ] = ( char ) bytes [ i ] ; 
return new String ( chars ) ; 
} 
} 

public class Properties { 
protected HashMap < String , PropertyDescriptor > inspectProperties ( ) { 
boolean scanAccessible = classDescriptor . isScanAccessible ( ) ; 
Class type = classDescriptor . getType ( ) ; 
HashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; 
Method [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; 
for ( int iteration = 0 ; 
iteration < 2 ; 
iteration ++ ) for ( Method method : methods ) { 
if ( Modifier . isStatic ( method . getModifiers ( ) ) ) continue ; 
boolean add = false ; 
boolean issetter = false ; 
String propertyName ; 
if ( iteration == 0 ) { 
propertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; 
if ( propertyName != null ) { 
add = true ; 
issetter = false ; 
} 
} 
else { 
propertyName = ClassUtil . getBeanPropertySetterName ( method ) ; 
if ( propertyName != null ) { 
add = true ; 
issetter = true ; 
} 
} 
if ( add ) { 
MethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; 
addProperty ( map , propertyName , methodDescriptor , issetter ) ; 
} 
} 
if ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { 
FieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; 
String [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; 
for ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { 
Field field = fieldDescriptor . getField ( ) ; 
if ( Modifier . isStatic ( field . getModifiers ( ) ) ) continue ; 
String name = field . getName ( ) ; 
if ( prefix != null ) for ( String p : prefix ) { 
if ( ! name . startsWith ( p ) ) continue ; 
name = name . substring ( p . length ( ) ) ; 
break ; 
} 
if ( ! map . containsKey ( name ) ) map . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; 
} 
} 
return map ; 
} 
} 

public class HttpResponse { 
public Cookie [ ] cookies ( ) { 
List < String > newCookies = headers ( "set-cookie" ) ; 
if ( newCookies == null ) return new Cookie [ 0 ] ; 
List < Cookie > cookieList = new ArrayList < > ( newCookies . size ( ) ) ; 
for ( String cookieValue : newCookies ) { 
try { 
Cookie cookie = new Cookie ( cookieValue ) ; 
cookieList . add ( cookie ) ; 
} 
catch ( Exception ex ) { 
} 
} 
return cookieList . toArray ( new Cookie [ 0 ] ) ; 
} 
} 

public class HttpResponse { 
public HttpResponse unzip ( ) { 
String contentEncoding = contentEncoding ( ) ; 
if ( contentEncoding != null && contentEncoding ( ) . equals ( "gzip" ) ) if ( body != null ) { 
headerRemove ( HEADER_CONTENT_ENCODING ) ; 
try { 
ByteArrayInputStream in = new ByteArrayInputStream ( body . getBytes ( StringPool . ISO_8859_1 ) ) ; 
GZIPInputStream gzipInputStream = new GZIPInputStream ( in ) ; 
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
StreamUtil . copy ( gzipInputStream , out ) ; 
body ( out . toString ( StringPool . ISO_8859_1 ) ) ; 
} 
catch ( IOException ioex ) { 
throw new HttpException ( ioex ) ; 
} 
} 
return this ; 
} 
} 

public class ThreadLocalScope { 
@ Override public boolean accept ( final Scope referenceScope ) { 
Class < ? extends Scope > refScopeType = referenceScope . getClass ( ) ; 
if ( refScopeType == ProtoScope . class ) return true ; 
if ( refScopeType == SingletonScope . class ) return true ; 
if ( refScopeType == ThreadLocalScope . class ) return true ; 
return false ; 
} 
} 

public class JoyMadvoc { 
protected void printRoutes ( final int width ) { 
final ActionsManager actionsManager = webApp . madvocContainer ( ) . lookupComponent ( ActionsManager . class ) ; 
final List < ActionRuntime > actions = actionsManager . getAllActionRuntimes ( ) ; 
final Map < String , String > aliases = actionsManager . getAllAliases ( ) ; 
if ( actions . isEmpty ( ) ) return ; 
final Print print = new Print ( ) ; 
print . line ( "Routes" , width ) ; 
actions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { 
final String actionMethod = ar . getActionMethod ( ) ; 
print . out ( Chalk256 . chalk ( ) . yellow ( ) , actionMethod == null ? "*" : actionMethod , 7 ) ; 
print . space ( ) ; 
final String signature = ClassUtil . getShortClassName ( ProxettaUtil . resolveTargetClass ( ar . getActionClass ( ) ) , 2 ) + '#' + ar . getActionClassMethod ( ) . getName ( ) ; 
print . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , ar . getActionPath ( ) , Chalk256 . chalk ( ) . blue ( ) , signature , width - 7 - 1 ) ; 
} 
) ; 
if ( ! aliases . isEmpty ( ) ) { 
print . line ( "Aliases" , width ) ; 
actions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { 
final String actionPath = ar . getActionPath ( ) ; 
for ( final Map . Entry < String , String > entry : aliases . entrySet ( ) ) { 
if ( entry . getValue ( ) . equals ( actionPath ) ) { 
print . space ( 8 ) ; 
print . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , entry . getValue ( ) , Chalk256 . chalk ( ) . blue ( ) , entry . getKey ( ) , width - 8 ) ; 
} 
} 
} 
) ; 
} 
print . line ( width ) ; 
} 
} 

public class BlockCipher { 
public byte [ ] encrypt ( final byte [ ] content ) { 
FastByteBuffer fbb = new FastByteBuffer ( ) ; 
int length = content . length + 1 ; 
int blockCount = length / blockSizeInBytes ; 
int remaining = length ; 
int offset = 0 ; 
for ( int i = 0 ; 
i < blockCount ; 
i ++ ) { 
if ( remaining == blockSizeInBytes ) break ; 
byte [ ] encrypted = encryptBlock ( content , offset ) ; 
fbb . append ( encrypted ) ; 
offset += blockSizeInBytes ; 
remaining -= blockSizeInBytes ; 
} 
if ( remaining != 0 ) { 
byte [ ] block = new byte [ blockSizeInBytes ] ; 
System . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; 
block [ remaining - 1 ] = TERMINATOR ; 
byte [ ] encrypted = encryptBlock ( block , 0 ) ; 
fbb . append ( encrypted ) ; 
} 
return fbb . toArray ( ) ; 
} 
} 

public class BlockCipher { 
public byte [ ] decrypt ( final byte [ ] encryptedContent ) { 
FastByteBuffer fbb = new FastByteBuffer ( ) ; 
int length = encryptedContent . length ; 
int blockCount = length / blockSizeInBytes ; 
int offset = 0 ; 
for ( int i = 0 ; 
i < blockCount - 1 ; 
i ++ ) { 
byte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; 
fbb . append ( decrypted ) ; 
offset += blockSizeInBytes ; 
} 
byte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; 
int ndx = blockSizeInBytes - 1 ; 
while ( ndx >= 0 ) { 
if ( decrypted [ ndx ] == TERMINATOR ) break ; 
ndx -- ; 
} 
fbb . append ( decrypted , 0 , ndx ) ; 
return fbb . toArray ( ) ; 
} 
} 

public class MapToBean { 
public Object map2bean ( final Map map , Class targetType ) { 
Object target = null ; 
String className = ( String ) map . get ( classMetadataName ) ; 
if ( className == null ) if ( targetType == null ) target = map ; 
else { 
checkClassName ( jsonParser . classnameWhitelist , className ) ; 
try { 
targetType = ClassLoaderUtil . loadClass ( className ) ; 
} 
catch ( ClassNotFoundException cnfex ) { 
throw new JsonException ( cnfex ) ; 
} 
} 
if ( target == null ) target = jsonParser . newObjectInstance ( targetType ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target . getClass ( ) ) ; 
boolean targetIsMap = target instanceof Map ; 
for ( Object key : map . keySet ( ) ) { 
String keyName = key . toString ( ) ; 
if ( classMetadataName != null ) if ( keyName . equals ( classMetadataName ) ) continue ; 
PropertyDescriptor pd = cd . getPropertyDescriptor ( keyName , declared ) ; 
if ( ! targetIsMap && pd == null ) continue ; 
Object value = map . get ( key ) ; 
Class propertyType = pd == null ? null : pd . getType ( ) ; 
Class componentType = pd == null ? null : pd . resolveComponentType ( true ) ; 
if ( value != null ) if ( value instanceof List ) if ( componentType != null && componentType != String . class ) value = generifyList ( ( List ) value , componentType ) ; 
else if ( value instanceof Map ) if ( ! ClassUtil . isTypeOf ( propertyType , Map . class ) ) value = map2bean ( ( Map ) value , propertyType ) ; 
else { 
Class keyType = pd == null ? null : pd . resolveKeyType ( true ) ; 
if ( keyType != String . class || componentType != String . class ) value = generifyMap ( ( Map ) value , keyType , componentType ) ; 
} 
if ( targetIsMap ) ( ( Map ) target ) . put ( keyName , value ) ; 
else try { 
setValue ( target , pd , value ) ; 
} 
catch ( Exception ignore ) { 
ignore . printStackTrace ( ) ; 
} 
} 
return target ; 
} 
} 

public class MapToBean { 
private Object generifyList ( final List list , final Class componentType ) { 
for ( int i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Object element = list . get ( i ) ; 
if ( element != null ) if ( element instanceof Map ) { 
Object bean = map2bean ( ( Map ) element , componentType ) ; 
list . set ( i , bean ) ; 
} 
else { 
Object value = convert ( element , componentType ) ; 
list . set ( i , value ) ; 
} 
} 
return list ; 
} 
} 

public class MapToBean { 
protected < K , V > Map < K , V > generifyMap ( final Map < Object , Object > map , final Class < K > keyType , final Class < V > valueType ) { 
if ( keyType == String . class ) { 
for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { 
Object value = entry . getValue ( ) ; 
Object newValue = convert ( value , valueType ) ; 
if ( value != newValue ) entry . setValue ( newValue ) ; 
} 
return ( Map < K , V > ) map ; 
} 
Map < K , V > newMap = new HashMap < > ( map . size ( ) ) ; 
for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { 
Object key = entry . getKey ( ) ; 
Object newKey = convert ( key , keyType ) ; 
Object value = entry . getValue ( ) ; 
Object newValue = convert ( value , valueType ) ; 
newMap . put ( ( K ) newKey , ( V ) newValue ) ; 
} 
return newMap ; 
} 
} 

public class DbEntityColumnDescriptor { 
@ Override public int compareTo ( final Object o ) { 
DbEntityColumnDescriptor that = ( DbEntityColumnDescriptor ) o ; 
if ( this . isId != that . isId ) return this . isId ? - 1 : 1 ; 
return this . columnName . compareTo ( that . columnName ) ; 
} 
} 

public class HttpBrowser { 
public HttpResponse sendRequest ( HttpRequest httpRequest ) { 
elapsedTime = System . currentTimeMillis ( ) ; 
httpRequest . followRedirects ( false ) ; 
while ( true ) { 
this . httpRequest = httpRequest ; 
HttpResponse previousResponse = this . httpResponse ; 
this . httpResponse = null ; 
addDefaultHeaders ( httpRequest ) ; 
addCookies ( httpRequest ) ; 
if ( catchTransportExceptions ) try { 
this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; 
} 
catch ( HttpException httpException ) { 
httpResponse = new HttpResponse ( ) ; 
httpResponse . assignHttpRequest ( httpRequest ) ; 
httpResponse . statusCode ( 503 ) ; 
httpResponse . statusPhrase ( "Service unavailable. " + ExceptionUtil . message ( httpException ) ) ; 
} 
else this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; 
readCookies ( httpResponse ) ; 
int statusCode = httpResponse . statusCode ( ) ; 
if ( statusCode == 301 ) { 
String newPath = httpResponse . location ( ) ; 
if ( newPath == null ) break ; 
httpRequest = HttpRequest . get ( newPath ) ; 
continue ; 
} 
if ( statusCode == 302 || statusCode == 303 ) { 
String newPath = httpResponse . location ( ) ; 
if ( newPath == null ) break ; 
httpRequest = HttpRequest . get ( newPath ) ; 
continue ; 
} 
if ( statusCode == 307 || statusCode == 308 ) { 
String newPath = httpResponse . location ( ) ; 
if ( newPath == null ) break ; 
String originalMethod = httpRequest . method ( ) ; 
httpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; 
continue ; 
} 
break ; 
} 
elapsedTime = System . currentTimeMillis ( ) - elapsedTime ; 
return this . httpResponse ; 
} 
} 

public class HttpBrowser { 
protected HttpResponse _sendRequest ( final HttpRequest httpRequest , final HttpResponse previouseResponse ) { 
if ( ! keepAlive ) httpRequest . open ( httpConnectionProvider ) ; 
else if ( previouseResponse == null ) httpRequest . open ( httpConnectionProvider ) . connectionKeepAlive ( true ) ; 
else httpRequest . keepAlive ( previouseResponse , true ) ; 
return httpRequest . send ( ) ; 
} 
} 

public class HttpBrowser { 
protected void addDefaultHeaders ( final HttpRequest httpRequest ) { 
for ( Map . Entry < String , String > entry : defaultHeaders . entries ( ) ) { 
String name = entry . getKey ( ) ; 
if ( ! httpRequest . headers . contains ( name ) ) httpRequest . headers . add ( name , entry . getValue ( ) ) ; 
} 
} 
} 

public class SendMailSession { 
private void setSubject ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { 
if ( emailWithData . subjectEncoding ( ) != null ) msgToSet . setSubject ( emailWithData . subject ( ) , emailWithData . subjectEncoding ( ) ) ; 
else msgToSet . setSubject ( emailWithData . subject ( ) ) ; 
} 
} 

public class SendMailSession { 
private void setSentDate ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { 
Date date = emailWithData . sentDate ( ) ; 
if ( date == null ) date = new Date ( ) ; 
msgToSet . setSentDate ( date ) ; 
} 
} 

public class SendMailSession { 
private void setHeaders ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { 
final Map < String , String > headers = emailWithData . headers ( ) ; 
if ( headers != null ) for ( final Map . Entry < String , String > entry : headers . entrySet ( ) ) { 
msgToSet . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
} 
} 

public class SendMailSession { 
private void setRecipients ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { 
final InternetAddress [ ] to = EmailAddress . convert ( emailWithData . to ( ) ) ; 
if ( to . length > 0 ) msgToSet . setRecipients ( RecipientType . TO , to ) ; 
final InternetAddress [ ] cc = EmailAddress . convert ( emailWithData . cc ( ) ) ; 
if ( cc . length > 0 ) msgToSet . setRecipients ( RecipientType . CC , cc ) ; 
final InternetAddress [ ] bcc = EmailAddress . convert ( emailWithData . bcc ( ) ) ; 
if ( bcc . length > 0 ) msgToSet . setRecipients ( RecipientType . BCC , bcc ) ; 
} 
} 

public class SendMailSession { 
private void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { 
final List < EmailMessage > messages = emailWithData . messages ( ) ; 
final int totalMessages = messages . size ( ) ; 
final List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList < > ( emailWithData . attachments ( ) ) ; 
if ( attachments . isEmpty ( ) && totalMessages == 1 ) setContent ( messages . get ( 0 ) , msgToSet ) ; 
else { 
final MimeMultipart multipart = new MimeMultipart ( ) ; 
final MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; 
multipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; 
for ( final EmailMessage emailMessage : messages ) { 
msgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; 
} 
addAnyAttachments ( attachments , multipart ) ; 
msgToSet . setContent ( multipart ) ; 
} 
} 
} 

public class SendMailSession { 
protected MimeBodyPart createAttachmentBodyPart ( final EmailAttachment < ? extends DataSource > attachment ) throws MessagingException { 
final MimeBodyPart part = new MimeBodyPart ( ) ; 
final String attachmentName = attachment . getEncodedName ( ) ; 
if ( attachmentName != null ) part . setFileName ( attachmentName ) ; 
part . setDataHandler ( new DataHandler ( attachment . getDataSource ( ) ) ) ; 
if ( attachment . getContentId ( ) != null ) part . setContentID ( StringPool . LEFT_CHEV + attachment . getContentId ( ) + StringPool . RIGHT_CHEV ) ; 
if ( attachment . isInline ( ) ) part . setDisposition ( INLINE ) ; 
return part ; 
} 
} 

public class FileUploadHeader { 
private String getContentType ( final String dataHeader ) { 
String token = "Content-Type:" ; 
int start = dataHeader . indexOf ( token ) ; 
if ( start == - 1 ) return StringPool . EMPTY ; 
start += token . length ( ) ; 
return dataHeader . substring ( start ) . trim ( ) ; 
} 
} 

public class DbQueryBase { 
protected void saveResultSet ( final ResultSet rs ) { 
if ( resultSets == null ) resultSets = new HashSet < > ( ) ; 
resultSets . add ( rs ) ; 
} 
} 

public class DbQueryBase { 
public Q closeAllResultSets ( ) { 
final SQLException sex = closeQueryResultSets ( ) ; 
if ( sex != null ) throw new DbSqlException ( "Close associated ResultSets error" , sex ) ; 
return _this ( ) ; 
} 
} 

public class DbQueryBase { 
protected SQLException closeQuery ( ) { 
SQLException sqlException = closeQueryResultSets ( ) ; 
if ( statement != null ) { 
try { 
statement . close ( ) ; 
} 
catch ( SQLException sex ) { 
if ( sqlException == null ) sqlException = sex ; 
else sqlException . setNextException ( sex ) ; 
} 
statement = null ; 
} 
query = null ; 
queryState = CLOSED ; 
return sqlException ; 
} 
} 

public class DbQueryBase { 
@ Override @ SuppressWarnings ( { 
"ClassReferencesSubclass" } 
) public void close ( ) { 
final SQLException sqlException = closeQuery ( ) ; 
connection = null ; 
if ( this . session != null ) this . session . detachQuery ( this ) ; 
if ( sqlException != null ) throw new DbSqlException ( "Close query error" , sqlException ) ; 
} 
} 

public class DbQueryBase { 
public Q setFetchSize ( final int rows ) { 
checkNotClosed ( ) ; 
this . fetchSize = rows ; 
if ( statement != null ) try { 
statement . setFetchSize ( fetchSize ) ; 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( this , "Unable to set fetch size: " + fetchSize , sex ) ; 
} 
return _this ( ) ; 
} 
} 

public class DbQueryBase { 
public Q setMaxRows ( final int maxRows ) { 
checkNotClosed ( ) ; 
this . maxRows = maxRows ; 
if ( statement != null ) try { 
statement . setMaxRows ( maxRows ) ; 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( this , "Unable to set max rows: " + maxRows , sex ) ; 
} 
return _this ( ) ; 
} 
} 

public class DbQueryBase { 
protected int executeUpdate ( final boolean closeQuery ) { 
start = System . currentTimeMillis ( ) ; 
init ( ) ; 
final int result ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "Executing update: " + getQueryString ( ) ) ; 
try { 
if ( preparedStatement == null ) if ( generatedColumns != null ) if ( generatedColumns . length == 0 ) result = statement . executeUpdate ( query . sql , Statement . RETURN_GENERATED_KEYS ) ; 
else result = statement . executeUpdate ( query . sql , generatedColumns ) ; 
else result = statement . executeUpdate ( query . sql ) ; 
else result = preparedStatement . executeUpdate ( ) ; 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( this , "Query execution failed" , sex ) ; 
} 
if ( closeQuery ) close ( ) ; 
elapsed = System . currentTimeMillis ( ) - start ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "execution time: " + elapsed + "ms" ) ; 
return result ; 
} 
} 

public class DbQueryBase { 
protected long executeCount ( final boolean close ) { 
start = System . currentTimeMillis ( ) ; 
init ( ) ; 
ResultSet rs = null ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "Executing prepared count: " + getQueryString ( ) ) ; 
try { 
if ( preparedStatement == null ) rs = statement . executeQuery ( query . sql ) ; 
else rs = preparedStatement . executeQuery ( ) ; 
final long firstLong = DbUtil . getFirstLong ( rs ) ; 
elapsed = System . currentTimeMillis ( ) - start ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "execution time: " + elapsed + "ms" ) ; 
return firstLong ; 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( this , "Count query failed" , sex ) ; 
} 
finally { 
DbUtil . close ( rs ) ; 
if ( close ) close ( ) ; 
} 
} 
} 

public class DbQueryBase { 
public ResultSet getGeneratedColumns ( ) { 
checkInitialized ( ) ; 
if ( generatedColumns == null ) throw new DbSqlException ( this , "No column is specified as auto-generated" ) ; 
final ResultSet rs ; 
try { 
rs = statement . getGeneratedKeys ( ) ; 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( this , "No generated keys" , sex ) ; 
} 
saveResultSet ( rs ) ; 
totalOpenResultSetCount ++ ; 
return rs ; 
} 
} 

public class DbQueryBase { 
public String getQueryString ( ) { 
if ( debug ) { 
if ( ( callableStatement != null ) ) if ( preparedStatement instanceof LoggableCallableStatement ) return ( ( LoggableCallableStatement ) callableStatement ) . getQueryString ( ) ; 
if ( preparedStatement != null ) if ( preparedStatement instanceof LoggablePreparedStatement ) return ( ( LoggablePreparedStatement ) preparedStatement ) . getQueryString ( ) ; 
} 
if ( query != null ) return query . sql ; 
return sqlString ; 
} 
} 

public class CollectionUtil { 
public static < T > Collection < T > collectionOf ( final Iterator < ? extends T > iterator ) { 
final List < T > list = new ArrayList < > ( ) ; 
while ( iterator . hasNext ( ) ) list . add ( iterator . next ( ) ) ; 
return list ; 
} 
} 

public class MultiComparator { 
@ Override public int compare ( final T o1 , final T o2 ) { 
for ( Comparator < T > comparator : comparators ) { 
int result = comparator . compare ( o1 , o2 ) ; 
if ( result != 0 ) return result ; 
} 
return 0 ; 
} 
} 

public class PetiteConfig { 
public PetiteConfig setDefaultWiringMode ( final WiringMode defaultWiringMode ) { 
if ( ( defaultWiringMode == null ) || ( defaultWiringMode == WiringMode . DEFAULT ) ) throw new PetiteException ( "Invalid default wiring mode: " + defaultWiringMode ) ; 
this . defaultWiringMode = defaultWiringMode ; 
return this ; 
} 
} 

public class SimpleLogger { 
protected void print ( final Level level , final String message , final Throwable throwable ) { 
if ( ! isEnabled ( level ) ) return ; 
StringBuilder msg = new StringBuilder ( ) . append ( slf . getElapsedTime ( ) ) . append ( ' ' ) . append ( '[' ) . append ( level ) . append ( ']' ) . append ( ' ' ) . append ( getCallerClass ( ) ) . append ( ' ' ) . append ( '-' ) . append ( ' ' ) . append ( message ) ; 
System . out . println ( msg . toString ( ) ) ; 
if ( throwable != null ) throwable . printStackTrace ( System . out ) ; 
} 
} 

public class SimpleLogger { 
protected String getCallerClass ( ) { 
Exception exception = new Exception ( ) ; 
StackTraceElement [ ] stackTrace = exception . getStackTrace ( ) ; 
for ( StackTraceElement stackTraceElement : stackTrace ) { 
String className = stackTraceElement . getClassName ( ) ; 
if ( className . equals ( SimpleLoggerProvider . class . getName ( ) ) ) continue ; 
if ( className . equals ( SimpleLogger . class . getName ( ) ) ) continue ; 
if ( className . equals ( Logger . class . getName ( ) ) ) continue ; 
return shortenClassName ( className ) + '.' + stackTraceElement . getMethodName ( ) + ':' + stackTraceElement . getLineNumber ( ) ; 
} 
return "N/A" ; 
} 
} 

public class SimpleLogger { 
protected String shortenClassName ( final String className ) { 
int lastDotIndex = className . lastIndexOf ( '.' ) ; 
if ( lastDotIndex == - 1 ) return className ; 
StringBuilder shortClassName = new StringBuilder ( className . length ( ) ) ; 
int start = 0 ; 
while ( true ) { 
shortClassName . append ( className . charAt ( start ) ) ; 
int next = className . indexOf ( '.' , start ) ; 
if ( next == lastDotIndex ) break ; 
start = next + 1 ; 
shortClassName . append ( '.' ) ; 
} 
shortClassName . append ( className . substring ( lastDotIndex ) ) ; 
return shortClassName . toString ( ) ; 
} 
} 

public class JsonSerializer { 
public JsonSerializer excludeTypes ( final Class ... types ) { 
if ( excludedTypes == null ) excludedTypes = types ; 
else excludedTypes = ArraysUtil . join ( excludedTypes , types ) ; 
return this ; 
} 
} 

public class DefaultResultSetMapper { 
protected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { 
if ( cachedMappedNames == null ) { 
String [ ] [ ] names = new String [ types . length ] [ ] ; 
for ( int i = 0 ; 
i < types . length ; 
i ++ ) { 
Class type = types [ i ] ; 
if ( type != null ) { 
DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; 
if ( ded != null ) { 
Class [ ] mappedTypes = ded . getMappedTypes ( ) ; 
if ( mappedTypes != null ) names [ i ] = createTypesTableNames ( mappedTypes ) ; 
} 
} 
} 
cachedMappedNames = names ; 
} 
return cachedMappedNames ; 
} 
} 

public class DefaultResultSetMapper { 
@ SuppressWarnings ( { 
"unchecked" } 
) protected Object readColumnValue ( final int colNdx , final Class destinationType , final Class < ? extends SqlType > sqlTypeClass , final int columnDbSqlType ) { 
if ( colNdx != cachedColumnNdx ) { 
try { 
SqlType sqlType ; 
if ( sqlTypeClass != null ) sqlType = SqlTypeManager . get ( ) . lookupSqlType ( sqlTypeClass ) ; 
else sqlType = SqlTypeManager . get ( ) . lookup ( destinationType ) ; 
if ( sqlType != null ) cachedColumnValue = sqlType . readValue ( resultSet , colNdx + 1 , destinationType , columnDbSqlType ) ; 
else { 
cachedColumnValue = resultSet . getObject ( colNdx + 1 ) ; 
cachedColumnValue = TypeConverterManager . get ( ) . convertType ( cachedColumnValue , destinationType ) ; 
} 
} 
catch ( SQLException sex ) { 
throw new DbOomException ( dbOomQuery , "Invalid value for column #" + ( colNdx + 1 ) , sex ) ; 
} 
cachedColumnNdx = colNdx ; 
} 
return cachedColumnValue ; 
} 
} 

public class DefaultResultSetMapper { 
protected void cacheResultSetEntities ( final Object [ ] result ) { 
if ( entitiesCache == null ) entitiesCache = new HashMap < > ( ) ; 
for ( int i = 0 ; 
i < result . length ; 
i ++ ) { 
Object object = result [ i ] ; 
if ( object == null ) continue ; 
DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; 
if ( ded == null ) continue ; 
Object key ; 
if ( ded . hasIdColumn ( ) ) key = ded . getKeyValue ( object ) ; 
else key = object ; 
Object cachedObject = entitiesCache . get ( key ) ; 
if ( cachedObject == null ) entitiesCache . put ( key , object ) ; 
else result [ i ] = cachedObject ; 
} 
} 
} 

public class ProviderResolver { 
public ProviderDefinition [ ] resolve ( final Class type , final String name ) { 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( ) ; 
List < ProviderDefinition > list = new ArrayList < > ( ) ; 
for ( MethodDescriptor methodDescriptor : methods ) { 
Method method = methodDescriptor . getMethod ( ) ; 
PetiteProvider petiteProvider = method . getAnnotation ( PetiteProvider . class ) ; 
if ( petiteProvider == null ) continue ; 
String providerName = petiteProvider . value ( ) ; 
if ( StringUtil . isBlank ( providerName ) ) { 
providerName = method . getName ( ) ; 
if ( providerName . endsWith ( "Provider" ) ) providerName = StringUtil . substring ( providerName , 0 , - 8 ) ; 
} 
ProviderDefinition providerDefinition ; 
if ( Modifier . isStatic ( method . getModifiers ( ) ) ) providerDefinition = new ProviderDefinition ( providerName , method ) ; 
else providerDefinition = new ProviderDefinition ( providerName , name , method ) ; 
list . add ( providerDefinition ) ; 
} 
ProviderDefinition [ ] providers ; 
if ( list . isEmpty ( ) ) providers = ProviderDefinition . EMPTY ; 
else providers = list . toArray ( new ProviderDefinition [ 0 ] ) ; 
return providers ; 
} 
} 

public class CoreConnectionPool { 
private boolean isConnectionValid ( final ConnectionData connectionData , final long now ) { 
if ( ! validateConnection ) return true ; 
if ( now < connectionData . lastUsed + validationTimeout ) return true ; 
Connection conn = connectionData . connection ; 
if ( validationQuery == null ) try { 
return ! conn . isClosed ( ) ; 
} 
catch ( SQLException sex ) { 
return false ; 
} 
boolean valid = true ; 
Statement st = null ; 
try { 
st = conn . createStatement ( ) ; 
st . execute ( validationQuery ) ; 
} 
catch ( SQLException sex ) { 
valid = false ; 
} 
finally { 
if ( st != null ) try { 
st . close ( ) ; 
} 
catch ( SQLException ignore ) { 
} 
} 
return valid ; 
} 
} 

public class ServletDispatcherActionResult { 
@ Override protected void renderView ( final ActionRequest actionRequest , final String target ) throws Exception { 
HttpServletRequest request = actionRequest . getHttpServletRequest ( ) ; 
HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; 
RequestDispatcher dispatcher = request . getRequestDispatcher ( target ) ; 
if ( dispatcher == null ) { 
response . sendError ( SC_NOT_FOUND , "Result not found: " + target ) ; 
return ; 
} 
if ( DispatcherUtil . isPageIncluded ( request , response ) ) dispatcher . include ( request , response ) ; 
else dispatcher . forward ( request , response ) ; 
} 
} 

public class ServletDispatcherActionResult { 
@ Override protected String locateTarget ( final ActionRequest actionRequest , String path ) { 
String target ; 
if ( path . endsWith ( StringPool . SLASH ) ) path = path + defaultViewPageName ; 
for ( final String ext : defaultViewExtensions ) { 
target = path + ext ; 
if ( targetExists ( actionRequest , target ) ) return target ; 
} 
return null ; 
} 
} 

public class BufferResponseWrapper { 
@ Override public PrintWriter getWriter ( ) throws IOException { 
preResponseCommit ( ) ; 
if ( buffer == null ) return getResponse ( ) . getWriter ( ) ; 
return buffer . getWriter ( ) ; 
} 
} 

public class BufferResponseWrapper { 
@ Override public ServletOutputStream getOutputStream ( ) throws IOException { 
preResponseCommit ( ) ; 
if ( buffer == null ) return getResponse ( ) . getOutputStream ( ) ; 
return buffer . getOutputStream ( ) ; 
} 
} 

public class BufferResponseWrapper { 
public void writeContentToResponse ( final char [ ] content ) throws IOException { 
if ( buffer == null ) return ; 
if ( buffer . isUsingStream ( ) ) { 
ServletOutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; 
String encoding = getContentTypeEncoding ( ) ; 
if ( encoding == null ) outputStream . write ( CharUtil . toByteArray ( content ) ) ; 
else outputStream . write ( CharUtil . toByteArray ( content , encoding ) ) ; 
outputStream . flush ( ) ; 
} 
else { 
Writer out = getResponse ( ) . getWriter ( ) ; 
out . write ( content ) ; 
out . flush ( ) ; 
} 
} 
} 

public class BufferResponseWrapper { 
@ Override public void setContentType ( final String type ) { 
super . setContentType ( type ) ; 
contentTypeResolver = new ContentTypeHeaderResolver ( type ) ; 
if ( bufferContentType ( type , contentTypeResolver . getMimeType ( ) , contentTypeResolver . getEncoding ( ) ) ) enableBuffering ( ) ; 
else disableBuffering ( ) ; 
} 
} 

public class BufferResponseWrapper { 
public void print ( final String string ) throws IOException { 
if ( isBufferStreamBased ( ) ) { 
String encoding = getContentTypeEncoding ( ) ; 
byte [ ] bytes ; 
if ( encoding == null ) bytes = string . getBytes ( ) ; 
else bytes = string . getBytes ( encoding ) ; 
buffer . getOutputStream ( ) . write ( bytes ) ; 
return ; 
} 
buffer . getWriter ( ) . write ( string ) ; 
} 
} 

public class AuthAction { 
protected JsonResult login ( ) { 
T authToken ; 
authToken = loginViaBasicAuth ( servletRequest ) ; 
if ( authToken == null ) authToken = loginViaRequestParams ( servletRequest ) ; 
if ( authToken == null ) { 
log . warn ( "Login failed." ) ; 
return JsonResult . of ( HttpStatus . error401 ( ) . unauthorized ( "Login failed." ) ) ; 
} 
log . info ( "login OK!" ) ; 
final UserSession < T > userSession = new UserSession < > ( authToken , userAuth . tokenValue ( authToken ) ) ; 
userSession . start ( servletRequest , servletResponse ) ; 
return tokenAsJson ( authToken ) ; 
} 
} 

public class AuthAction { 
protected T loginViaBasicAuth ( final HttpServletRequest servletRequest ) { 
final String username = ServletUtil . resolveAuthUsername ( servletRequest ) ; 
if ( username == null ) return null ; 
final String password = ServletUtil . resolveAuthPassword ( servletRequest ) ; 
return userAuth . login ( username , password ) ; 
} 
} 

public class FileUtil { 
public static File toContainerFile ( final URL url ) { 
String protocol = url . getProtocol ( ) ; 
if ( protocol . equals ( FILE_PROTOCOL ) ) return toFile ( url ) ; 
String path = url . getPath ( ) ; 
return new File ( URI . create ( path . substring ( ZERO , path . lastIndexOf ( "!/" ) ) ) ) ; 
} 
} 

public class FileUtil { 
private static void _copyFile ( final File srcFile , final File destFile ) throws IOException { 
if ( destFile . exists ( ) ) if ( destFile . isDirectory ( ) ) throw new IOException ( "Destination '" + destFile + "' is a directory" ) ; 
FileInputStream input = null ; 
FileOutputStream output = null ; 
try { 
input = new FileInputStream ( srcFile ) ; 
output = new FileOutputStream ( destFile , false ) ; 
StreamUtil . copy ( input , output ) ; 
} 
finally { 
StreamUtil . close ( output ) ; 
StreamUtil . close ( input ) ; 
} 
if ( srcFile . length ( ) != destFile . length ( ) ) throw new IOException ( "Copy file failed of '" + srcFile + "' to '" + destFile + "' due to different sizes" ) ; 
destFile . setLastModified ( srcFile . lastModified ( ) ) ; 
} 
} 

public class FileUtil { 
public static void cleanDir ( final File destDir ) throws IOException { 
checkExists ( destDir ) ; 
checkIsDirectory ( destDir ) ; 
File [ ] files = destDir . listFiles ( ) ; 
if ( files == null ) throw new IOException ( "Failed to list contents of: " + destDir ) ; 
IOException exception = null ; 
for ( File file : files ) { 
try { 
if ( file . isDirectory ( ) ) deleteDir ( file ) ; 
else file . delete ( ) ; 
} 
catch ( IOException ioex ) { 
exception = ioex ; 
continue ; 
} 
} 
if ( exception != null ) throw exception ; 
} 
} 

public class FileUtil { 
public static byte [ ] readBytes ( final File file , final int count ) throws IOException { 
checkExists ( file ) ; 
checkIsFile ( file ) ; 
long numToRead = file . length ( ) ; 
if ( numToRead >= Integer . MAX_VALUE ) throw new IOException ( "File is larger then max array size" ) ; 
if ( count > NEGATIVE_ONE && count < numToRead ) numToRead = count ; 
byte [ ] bytes = new byte [ ( int ) numToRead ] ; 
RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "r" ) ; 
randomAccessFile . readFully ( bytes ) ; 
randomAccessFile . close ( ) ; 
return bytes ; 
} 
} 

public class FileUtil { 
public static boolean isBinary ( final File file ) throws IOException { 
byte [ ] bytes = readBytes ( file , 128 ) ; 
for ( byte b : bytes ) { 
if ( b < 32 && b != 9 && b != 10 && b != 13 ) return true ; 
} 
return false ; 
} 
} 

public class FileUtil { 
private static void checkDirCopy ( final File srcDir , final File destDir ) throws IOException { 
checkExists ( srcDir ) ; 
checkIsDirectory ( srcDir ) ; 
if ( equals ( srcDir , destDir ) ) throw new IOException ( "Source '" + srcDir + "' and destination '" + destDir + "' are equal" ) ; 
} 
} 

public class FileUtil { 
private static void checkFileCopy ( final File srcFile , final File destFile ) throws IOException { 
checkExists ( srcFile ) ; 
checkIsFile ( srcFile ) ; 
if ( equals ( srcFile , destFile ) ) throw new IOException ( "Files '" + srcFile + "' and '" + destFile + "' are equal" ) ; 
File destParent = destFile . getParentFile ( ) ; 
if ( destParent != null && ! destParent . exists ( ) ) checkCreateDirectory ( destParent ) ; 
} 
} 

public class Cli { 
public void printUsage ( final String commandName ) { 
final StringBuilder usage = new StringBuilder ( commandName ) ; 
for ( final Option option : options ) { 
if ( option . shortName != null ) usage . append ( " [-" ) . append ( option . shortName ) . append ( "]" ) ; 
else if ( option . longName != null ) usage . append ( " [--" ) . append ( option . longName ) . append ( "]" ) ; 
} 
for ( final Param param : params ) { 
usage . append ( " " ) . append ( param . label ) ; 
} 
System . out . println ( usage ) ; 
} 
} 

public class ActionsManager { 
public Method resolveActionMethod ( final Class < ? > actionClass , final String methodName ) { 
MethodDescriptor methodDescriptor = ClassIntrospector . get ( ) . lookup ( actionClass ) . getMethodDescriptor ( methodName , false ) ; 
if ( methodDescriptor == null ) throw new MadvocException ( "Public method not found: " + actionClass . getSimpleName ( ) + "#" + methodName ) ; 
return methodDescriptor . getMethod ( ) ; 
} 
} 

public class ActionsManager { 
public void registerPathAlias ( final String alias , final String path ) { 
final String existing = pathAliases . put ( alias , path ) ; 
if ( existing != null ) throw new MadvocException ( "Duplicated alias detected: [" + alias + "] for paths: " + path + ", " + existing ) ; 
} 
} 

public class LoopIterator { 
public boolean next ( ) { 
if ( ! looping ) return false ; 
if ( last ) return false ; 
if ( count == 0 ) { 
value = start ; 
first = true ; 
} 
else { 
value += step ; 
first = false ; 
} 
count ++ ; 
last = isLastIteration ( value + step ) ; 
return true ; 
} 
} 

public class Scanner { 
public final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { 
if ( ndx + uppercaseTarget . length > total ) return false ; 
int j = ndx ; 
for ( int i = 0 ; 
i < uppercaseTarget . length ; 
i ++ , j ++ ) { 
final char c = CharUtil . toUpperAscii ( input [ j ] ) ; 
if ( c != uppercaseTarget [ i ] ) return false ; 
} 
return true ; 
} 
} 

public class Scanner { 
protected final CharSequence charSequence ( final int from , final int to ) { 
if ( from == to ) return CharArraySequence . EMPTY ; 
return CharArraySequence . of ( input , from , to - from ) ; 
} 
} 

public class ClassPathURLs { 
public static URL [ ] of ( ClassLoader classLoader , Class clazz ) { 
if ( clazz == null ) clazz = ClassPathURLs . class ; 
if ( classLoader == null ) classLoader = clazz . getClassLoader ( ) ; 
final Set < URL > urls = new LinkedHashSet < > ( ) ; 
while ( classLoader != null ) { 
if ( classLoader instanceof URLClassLoader ) { 
URLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; 
URL [ ] allURLS = urlClassLoader . getURLs ( ) ; 
Collections . addAll ( urls , allURLS ) ; 
break ; 
} 
URL classUrl = classModuleUrl ( classLoader , clazz ) ; 
if ( classUrl != null ) urls . add ( classUrl ) ; 
classUrl = classModuleUrl ( classLoader , ClassPathURLs . class ) ; 
if ( classUrl != null ) urls . add ( classUrl ) ; 
ModuleDescriptor moduleDescriptor = clazz . getModule ( ) . getDescriptor ( ) ; 
if ( moduleDescriptor != null ) moduleDescriptor . requires ( ) . forEach ( req -> { 
ModuleLayer . boot ( ) . findModule ( req . name ( ) ) . ifPresent ( mod -> { 
ClassLoader moduleClassLoader = mod . getClassLoader ( ) ; 
if ( moduleClassLoader != null ) { 
URL url = moduleClassLoader . getResource ( MANIFEST ) ; 
if ( url != null ) { 
url = fixManifestUrl ( url ) ; 
urls . add ( url ) ; 
} 
} 
} 
) ; 
} 
) ; 
classLoader = classLoader . getParent ( ) ; 
} 
return urls . toArray ( new URL [ 0 ] ) ; 
} 
} 

public class TypeJsonSerializerMap { 
protected TypeJsonSerializer lookupSerializer ( final Class type ) { 
TypeJsonSerializer tjs = map . get ( type ) ; 
if ( tjs == null ) if ( defaultSerializerMap != null ) tjs = defaultSerializerMap . map . get ( type ) ; 
return tjs ; 
} 
} 

public class MultipartStreamParser { 
public void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { 
setParsed ( ) ; 
MultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; 
input . readBoundary ( ) ; 
while ( true ) { 
FileUploadHeader header = input . readDataHeader ( encoding ) ; 
if ( header == null ) break ; 
if ( header . isFile ) { 
String fileName = header . fileName ; 
if ( fileName . length ( ) > 0 ) if ( header . contentType . indexOf ( "application/x-macbinary" ) > 0 ) input . skipBytes ( 128 ) ; 
FileUpload newFile = fileUploadFactory . create ( input ) ; 
newFile . processStream ( ) ; 
if ( fileName . length ( ) == 0 ) if ( newFile . getSize ( ) == 0 ) newFile . size = - 1 ; 
putFile ( header . formFieldName , newFile ) ; 
} 
else { 
FastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; 
input . copyAll ( fbos ) ; 
String value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; 
putParameter ( header . formFieldName , value ) ; 
} 
input . skipBytes ( 1 ) ; 
input . mark ( 1 ) ; 
int nextByte = input . read ( ) ; 
if ( nextByte == - 1 || nextByte == '-' ) { 
input . reset ( ) ; 
break ; 
} 
input . reset ( ) ; 
} 
} 
} 

public class MultipartStreamParser { 
public String getParameter ( final String paramName ) { 
if ( requestParameters == null ) return null ; 
String [ ] values = requestParameters . get ( paramName ) ; 
if ( ( values != null ) && ( values . length > 0 ) ) return values [ 0 ] ; 
return null ; 
} 
} 

public class MultipartStreamParser { 
public String [ ] getParameterValues ( final String paramName ) { 
if ( requestParameters == null ) return null ; 
return requestParameters . get ( paramName ) ; 
} 
} 

public class MultipartStreamParser { 
public FileUpload getFile ( final String paramName ) { 
if ( requestFiles == null ) return null ; 
FileUpload [ ] values = requestFiles . get ( paramName ) ; 
if ( ( values != null ) && ( values . length > 0 ) ) return values [ 0 ] ; 
return null ; 
} 
} 

public class MultipartStreamParser { 
public FileUpload [ ] getFiles ( final String paramName ) { 
if ( requestFiles == null ) return null ; 
return requestFiles . get ( paramName ) ; 
} 
} 

public class CharacterEncodingFilter { 
@ Override public void init ( final FilterConfig filterConfig ) { 
this . filterConfig = filterConfig ; 
this . encoding = filterConfig . getInitParameter ( "encoding" ) ; 
if ( this . encoding == null ) this . encoding = JoddCore . encoding ; 
this . ignore = Converter . get ( ) . toBooleanValue ( filterConfig . getInitParameter ( "ignore" ) , true ) ; 
} 
} 

public class TemplateParser { 
public void parse ( final DbSqlBuilder sqlBuilder , final String template ) { 
int length = template . length ( ) ; 
int last = 0 ; 
while ( true ) { 
int mark = template . indexOf ( '$' , last ) ; 
if ( mark == - 1 ) { 
if ( last < length ) sqlBuilder . appendRaw ( template . substring ( last ) ) ; 
break ; 
} 
int escapesCount = countEscapes ( template , mark ) ; 
if ( escapesCount > 0 ) { 
boolean isEscaped = escapesCount % 2 != 0 ; 
int escapesToAdd = escapesCount >> 1 ; 
sqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; 
if ( isEscaped ) { 
last = mark + 1 ; 
continue ; 
} 
} 
else sqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; 
int end ; 
if ( template . startsWith ( MACRO_TABLE , mark ) ) { 
mark += MACRO_TABLE . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onTable ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else if ( template . startsWith ( MACRO_COLUMN , mark ) ) { 
mark += MACRO_COLUMN . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onColumn ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else if ( template . startsWith ( MACRO_MATCH , mark ) ) { 
mark += MACRO_MATCH . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onMatch ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else if ( template . startsWith ( MACRO_VALUE , mark ) ) { 
mark += MACRO_VALUE . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onValue ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else { 
mark ++ ; 
end = mark ; 
while ( end < length ) { 
if ( ! isReferenceChar ( template , end ) ) break ; 
end ++ ; 
} 
onReference ( sqlBuilder , template . substring ( mark , end ) ) ; 
end -- ; 
} 
end ++ ; 
last = end ; 
} 
} 
} 

public class TemplateParser { 
protected int findMacroEnd ( final String template , final int fromIndex ) { 
int endIndex = template . indexOf ( '}' , fromIndex ) ; 
if ( endIndex == - 1 ) throw new DbSqlBuilderException ( "Template syntax error, some macros are not closed. Error at: '..." + template . substring ( fromIndex ) ) ; 
return endIndex ; 
} 
} 

public class TemplateParser { 
protected int countEscapes ( final String template , int macroIndex ) { 
macroIndex -- ; 
int escapeCount = 0 ; 
while ( macroIndex >= 0 ) { 
if ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) break ; 
escapeCount ++ ; 
macroIndex -- ; 
} 
return escapeCount ; 
} 
} 

public class HttpUtil { 
public static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { 
if ( queryMap . isEmpty ( ) ) return StringPool . EMPTY ; 
int queryMapSize = queryMap . size ( ) ; 
StringBand query = new StringBand ( queryMapSize * 4 ) ; 
int count = 0 ; 
for ( Map . Entry < String , ? > entry : queryMap ) { 
String key = entry . getKey ( ) ; 
key = URLCoder . encodeQueryParam ( key , encoding ) ; 
Object value = entry . getValue ( ) ; 
if ( value == null ) { 
if ( count != 0 ) query . append ( '&' ) ; 
query . append ( key ) ; 
count ++ ; 
} 
else { 
if ( count != 0 ) query . append ( '&' ) ; 
query . append ( key ) ; 
count ++ ; 
query . append ( '=' ) ; 
String valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; 
query . append ( valueString ) ; 
} 
} 
return query . toString ( ) ; 
} 
} 

public class HttpUtil { 
public static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { 
final HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; 
if ( StringUtil . isBlank ( query ) ) return queryMap ; 
int lastNdx = 0 ; 
while ( lastNdx < query . length ( ) ) { 
int ndx = query . indexOf ( '&' , lastNdx ) ; 
if ( ndx == - 1 ) ndx = query . length ( ) ; 
final String paramAndValue = query . substring ( lastNdx , ndx ) ; 
ndx = paramAndValue . indexOf ( '=' ) ; 
if ( ndx == - 1 ) queryMap . add ( paramAndValue , null ) ; 
else { 
String name = paramAndValue . substring ( 0 , ndx ) ; 
if ( decode ) name = URLDecoder . decodeQuery ( name ) ; 
String value = paramAndValue . substring ( ndx + 1 ) ; 
if ( decode ) value = URLDecoder . decodeQuery ( value ) ; 
queryMap . add ( name , value ) ; 
} 
lastNdx += paramAndValue . length ( ) + 1 ; 
} 
return queryMap ; 
} 
} 

public class HttpUtil { 
public static String prepareHeaderParameterName ( final String headerName ) { 
if ( headerName . equals ( "etag" ) ) return HttpBase . HEADER_ETAG ; 
if ( headerName . equals ( "www-authenticate" ) ) return "WWW-Authenticate" ; 
char [ ] name = headerName . toCharArray ( ) ; 
boolean capitalize = true ; 
for ( int i = 0 ; 
i < name . length ; 
i ++ ) { 
char c = name [ i ] ; 
if ( c == '-' ) { 
capitalize = true ; 
continue ; 
} 
if ( capitalize ) { 
name [ i ] = Character . toUpperCase ( c ) ; 
capitalize = false ; 
} 
else name [ i ] = Character . toLowerCase ( c ) ; 
} 
return new String ( name ) ; 
} 
} 

public class HttpUtil { 
public static String extractMediaType ( final String contentType ) { 
int index = contentType . indexOf ( ';' ) ; 
if ( index == - 1 ) return contentType ; 
return contentType . substring ( 0 , index ) ; 
} 
} 

public class JsonParser { 
protected void reset ( ) { 
this . ndx = 0 ; 
this . textLen = 0 ; 
this . path = new Path ( ) ; 
this . notFirstObject = false ; 
if ( useAltPaths ) path . altPath = new Path ( ) ; 
if ( classMetadataName != null ) mapToBean = createMapToBean ( classMetadataName ) ; 
} 
} 

public class JsonParser { 
protected Class replaceWithMappedTypeForPath ( final Class target ) { 
if ( mappings == null ) return target ; 
Class newType ; 
Path altPath = path . getAltPath ( ) ; 
if ( altPath != null ) if ( ! altPath . equals ( path ) ) { 
newType = mappings . get ( altPath ) ; 
if ( newType != null ) return newType ; 
} 
newType = mappings . get ( path ) ; 
if ( newType != null ) return newType ; 
return target ; 
} 
} 

public class JsonParser { 
private Object resolveLazyValue ( Object value ) { 
if ( value instanceof Supplier ) value = ( ( Supplier ) value ) . get ( ) ; 
return value ; 
} 
} 

public class JsonParser { 
private void skipObject ( ) { 
int bracketCount = 1 ; 
boolean insideString = false ; 
while ( ndx < total ) { 
final char c = input [ ndx ] ; 
if ( insideString ) if ( c == '\"' && notPrecededByEvenNumberOfBackslashes ( ) ) insideString = false ; 
else if ( c == '\"' ) insideString = true ; 
else if ( c == '{' ) bracketCount ++ ; 
else if ( c == '}' ) { 
bracketCount -- ; 
if ( bracketCount == 0 ) { 
ndx ++ ; 
return ; 
} 
} 
ndx ++ ; 
} 
} 
} 

public class JsonParser { 
protected String parseString ( ) { 
char quote = '\"' ; 
if ( looseMode ) { 
quote = consumeOneOf ( '\"' , '\'' ) ; 
if ( quote == 0 ) return parseUnquotedStringContent ( ) ; 
} 
else consume ( quote ) ; 
return parseStringContent ( quote ) ; 
} 
} 

public class JsonParser { 
protected String parseStringContent ( final char quote ) { 
final int startNdx = ndx ; 
while ( true ) { 
final char c = input [ ndx ] ; 
if ( c == quote ) { 
ndx ++ ; 
return new String ( input , startNdx , ndx - 1 - startNdx ) ; 
} 
if ( c == '\\' ) break ; 
ndx ++ ; 
} 
textLen = ndx - startNdx ; 
growEmpty ( ) ; 
System . arraycopy ( input , startNdx , text , 0 , textLen ) ; 
while ( true ) { 
char c = input [ ndx ] ; 
if ( c == quote ) { 
ndx ++ ; 
final String str = new String ( text , 0 , textLen ) ; 
textLen = 0 ; 
return str ; 
} 
if ( c == '\\' ) { 
ndx ++ ; 
c = input [ ndx ] ; 
switch ( c ) { 
case '\"' : c = '\"' ; 
break ; 
case '\\' : c = '\\' ; 
break ; 
case '/' : c = '/' ; 
break ; 
case 'b' : c = '\b' ; 
break ; 
case 'f' : c = '\f' ; 
break ; 
case 'n' : c = '\n' ; 
break ; 
case 'r' : c = '\r' ; 
break ; 
case 't' : c = '\t' ; 
break ; 
case 'u' : ndx ++ ; 
c = parseUnicode ( ) ; 
break ; 
default : if ( looseMode ) if ( c != '\'' ) { 
c = '\\' ; 
ndx -- ; 
} 
else syntaxError ( "Invalid escape char: " + c ) ; 
} 
} 
text [ textLen ] = c ; 
textLen ++ ; 
growAndCopy ( ) ; 
ndx ++ ; 
} 
} 
} 

public class JsonParser { 
protected Number parseNumber ( ) { 
final int startIndex = ndx ; 
char c = input [ ndx ] ; 
boolean isDouble = false ; 
boolean isExp = false ; 
if ( c == '-' ) ndx ++ ; 
while ( true ) { 
if ( isEOF ( ) ) break ; 
c = input [ ndx ] ; 
if ( c >= '0' && c <= '9' ) { 
ndx ++ ; 
continue ; 
} 
if ( c <= 32 ) break ; 
if ( c == ',' || c == '}' || c == ']' ) break ; 
if ( c == '.' ) isDouble = true ; 
else if ( c == 'e' || c == 'E' ) isExp = true ; 
ndx ++ ; 
} 
final String value = new String ( input , startIndex , ndx - startIndex ) ; 
if ( isDouble ) return Double . valueOf ( value ) ; 
long longNumber ; 
if ( isExp ) longNumber = Double . valueOf ( value ) . longValue ( ) ; 
else if ( value . length ( ) >= 19 ) { 
BigInteger bigInteger = new BigInteger ( value ) ; 
if ( isGreaterThanLong ( bigInteger ) ) return bigInteger ; 
longNumber = bigInteger . longValue ( ) ; 
} 
else longNumber = Long . parseLong ( value ) ; 
if ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) return ( int ) longNumber ; 
return longNumber ; 
} 
} 

public class JsonParser { 
protected Object parseArrayContent ( Class targetType , Class componentType ) { 
if ( targetType == Object . class ) targetType = List . class ; 
targetType = replaceWithMappedTypeForPath ( targetType ) ; 
if ( componentType == null && targetType != null && targetType . isArray ( ) ) componentType = targetType . getComponentType ( ) ; 
path . push ( VALUES ) ; 
componentType = replaceWithMappedTypeForPath ( componentType ) ; 
Collection < Object > target = newArrayInstance ( targetType ) ; 
boolean koma = false ; 
mainloop : while ( true ) { 
skipWhiteSpaces ( ) ; 
char c = input [ ndx ] ; 
if ( c == ']' ) { 
if ( koma ) syntaxError ( "Trailing comma" ) ; 
ndx ++ ; 
path . pop ( ) ; 
return target ; 
} 
Object value = parseValue ( componentType , null , null ) ; 
target . add ( value ) ; 
skipWhiteSpaces ( ) ; 
c = input [ ndx ] ; 
switch ( c ) { 
case ']' : ndx ++ ; 
break mainloop ; 
case ',' : ndx ++ ; 
koma = true ; 
break ; 
default : syntaxError ( "Invalid char: expected ] or ," ) ; 
} 
} 
path . pop ( ) ; 
if ( targetType != null ) return convertType ( target , targetType ) ; 
return target ; 
} 
} 

public class ProxettaWrapperClassBuilder { 
protected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { 
int access = msign . getAccessFlags ( ) ; 
access &= ~ ACC_ABSTRACT ; 
access &= ~ ACC_NATIVE ; 
MethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; 
mv . visitCode ( ) ; 
mv . visitVarInsn ( ALOAD , 0 ) ; 
mv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; 
loadVirtualMethodArguments ( mv , msign ) ; 
if ( wd . wrapInterface ) mv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; 
else mv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; 
ProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; 
visitReturn ( mv , msign , true ) ; 
mv . visitMaxs ( 0 , 0 ) ; 
mv . visitEnd ( ) ; 
} 
} 

public class MethodSignatureVisitor { 
private String resolveRawTypeName ( String typeName ) { 
if ( typeName == null ) return null ; 
boolean isArray = typeName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ; 
if ( isArray ) typeName = typeName . substring ( 1 ) ; 
String rawTypeName ; 
if ( generics . containsKey ( typeName ) ) rawTypeName = generics . get ( typeName ) ; 
else rawTypeName = declaredTypeGeneric . getOrDefault ( typeName , typeName ) ; 
if ( isArray ) rawTypeName = '[' + rawTypeName ; 
return rawTypeName ; 
} 
} 

public class ReferencesResolver { 
public BeanReferences resolveReferenceFromValue ( final PropertyDescriptor propertyDescriptor , final String refName ) { 
BeanReferences references ; 
if ( refName == null || refName . isEmpty ( ) ) references = buildDefaultReference ( propertyDescriptor ) ; 
else references = BeanReferences . of ( refName ) ; 
references = references . removeDuplicateNames ( ) ; 
return references ; 
} 
} 

public class ReferencesResolver { 
public BeanReferences [ ] resolveReferenceFromValues ( final Executable methodOrCtor , final String ... parameterReferences ) { 
BeanReferences [ ] references = convertRefToReferences ( parameterReferences ) ; 
if ( references == null || references . length == 0 ) references = buildDefaultReferences ( methodOrCtor ) ; 
if ( methodOrCtor . getParameterTypes ( ) . length != references . length ) throw new PetiteException ( "Different number of method parameters and references for: " + methodOrCtor . getDeclaringClass ( ) . getName ( ) + '#' + methodOrCtor . getName ( ) ) ; 
removeAllDuplicateNames ( references ) ; 
return references ; 
} 
} 

public class ReferencesResolver { 
public BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { 
PetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; 
final Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; 
BeanReferences [ ] references ; 
final boolean hasAnnotationOnMethodOrCtor ; 
if ( petiteInject != null ) { 
references = convertAnnValueToReferences ( petiteInject . value ( ) ) ; 
hasAnnotationOnMethodOrCtor = true ; 
} 
else { 
references = new BeanReferences [ parameters . length ] ; 
hasAnnotationOnMethodOrCtor = false ; 
} 
int parametersWithAnnotationCount = 0 ; 
for ( int i = 0 ; 
i < parameters . length ; 
i ++ ) { 
Parameter parameter = parameters [ i ] ; 
petiteInject = parameter . getAnnotation ( PetiteInject . class ) ; 
if ( petiteInject == null ) continue ; 
String annotationValue = readAnnotationValue ( petiteInject ) ; 
if ( annotationValue != null ) references [ i ] = BeanReferences . of ( annotationValue ) ; 
parametersWithAnnotationCount ++ ; 
} 
if ( ! hasAnnotationOnMethodOrCtor ) { 
if ( parametersWithAnnotationCount == 0 ) return null ; 
if ( parametersWithAnnotationCount != parameters . length ) throw new PetiteException ( "All arguments must be annotated with PetiteInject" ) ; 
} 
references = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; 
removeAllDuplicateNames ( references ) ; 
return references ; 
} 
} 

public class ReferencesResolver { 
private BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { 
final boolean useParamo = petiteConfig . getUseParamo ( ) ; 
final PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; 
MethodParameter [ ] methodParameters = null ; 
if ( useParamo ) methodParameters = Paramo . resolveParameters ( methodOrCtor ) ; 
final Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; 
final BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; 
for ( int j = 0 ; 
j < paramTypes . length ; 
j ++ ) { 
String [ ] ref = new String [ lookupReferences . length ] ; 
references [ j ] = BeanReferences . of ( ref ) ; 
for ( int i = 0 ; 
i < ref . length ; 
i ++ ) switch ( lookupReferences [ i ] ) { 
case NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; 
break ; 
case TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; 
break ; 
case TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; 
break ; 
} 
} 
return references ; 
} 
} 

public class ReferencesResolver { 
public BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { 
final PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; 
final String [ ] references = new String [ lookupReferences . length ] ; 
for ( int i = 0 ; 
i < references . length ; 
i ++ ) switch ( lookupReferences [ i ] ) { 
case NAME : references [ i ] = propertyDescriptor . getName ( ) ; 
break ; 
case TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; 
break ; 
case TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; 
break ; 
} 
return BeanReferences . of ( references ) ; 
} 
} 

public class ReferencesResolver { 
private BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { 
if ( references == null ) return null ; 
BeanReferences [ ] ref = new BeanReferences [ references . length ] ; 
for ( int i = 0 ; 
i < references . length ; 
i ++ ) ref [ i ] = BeanReferences . of ( references [ i ] ) ; 
return ref ; 
} 
} 

public class ReferencesResolver { 
private BeanReferences [ ] convertAnnValueToReferences ( String value ) { 
if ( value == null ) return null ; 
value = value . trim ( ) ; 
if ( value . length ( ) == 0 ) return null ; 
String [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; 
BeanReferences [ ] references = new BeanReferences [ refNames . length ] ; 
for ( int i = 0 ; 
i < refNames . length ; 
i ++ ) references [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; 
return references ; 
} 
} 

public class StandaloneJoddJoy { 
public void runJoy ( final Consumer < JoddJoyRuntime > consumer ) { 
final JoddJoy joddJoy = new JoddJoy ( ) ; 
final JoddJoyRuntime joyRuntime = joddJoy . startOnlyBackend ( ) ; 
joddJoy . withDb ( joyDb -> setJtxManager ( joyRuntime . getJtxManager ( ) ) ) ; 
final JtxTransaction tx = startRwTx ( ) ; 
final Print print = new Print ( ) ; 
try { 
print . line ( "START" , 80 ) ; 
print . newLine ( ) ; 
consumer . accept ( joyRuntime ) ; 
print . newLine ( ) ; 
print . line ( "END" , 80 ) ; 
if ( tx != null ) tx . commit ( ) ; 
} 
catch ( Throwable throwable ) { 
throwable . printStackTrace ( ) ; 
if ( tx != null ) tx . rollback ( ) ; 
} 
joddJoy . stop ( ) ; 
} 
} 

public class ClassUtil { 
public static < T > Constructor < T > findConstructor ( final Class < T > clazz , final Class < ? > ... parameterTypes ) { 
final Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; 
Class < ? > [ ] pts ; 
for ( Constructor < ? > constructor : constructors ) { 
pts = constructor . getParameterTypes ( ) ; 
if ( isAllAssignableFrom ( pts , parameterTypes ) ) return ( Constructor < T > ) constructor ; 
} 
return null ; 
} 
} 

public class ClassUtil { 
public static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { 
if ( first . length != second . length ) return false ; 
for ( int i = 0 ; 
i < first . length ; 
i ++ ) if ( first [ i ] != second [ i ] ) return false ; 
return true ; 
} 
} 

public class ClassUtil { 
public static void forceAccess ( final AccessibleObject accObject ) { 
try { 
if ( System . getSecurityManager ( ) == null ) accObject . setAccessible ( true ) ; 
else AccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { 
accObject . setAccessible ( true ) ; 
return null ; 
} 
) ; 
} 
catch ( SecurityException sex ) { 
} 
} 
} 

public class ClassUtil { 
@ SuppressWarnings ( "unchecked" ) public static < T > T newInstance ( final Class < T > clazz , final Object ... params ) throws InstantiationException , IllegalAccessException , InvocationTargetException , NoSuchMethodException { 
if ( params . length == 0 ) return newInstance ( clazz ) ; 
final Class < ? > [ ] paramTypes = getClasses ( params ) ; 
final Constructor < ? > constructor = findConstructor ( clazz , paramTypes ) ; 
if ( constructor == null ) throw new InstantiationException ( "No constructor matched parameter types." ) ; 
return ( T ) constructor . newInstance ( params ) ; 
} 
} 

public class ClassUtil { 
public static Class [ ] getSuperclasses ( final Class type ) { 
int i = 0 ; 
for ( Class x = type . getSuperclass ( ) ; 
x != null ; 
x = x . getSuperclass ( ) ) i ++ ; 
Class [ ] result = new Class [ i ] ; 
i = 0 ; 
for ( Class x = type . getSuperclass ( ) ; 
x != null ; 
x = x . getSuperclass ( ) ) { 
result [ i ] = x ; 
i ++ ; 
} 
return result ; 
} 
} 

public class ClassUtil { 
public static Class < ? > childClassOf ( final Class < ? > parentClass , final Object instance ) { 
if ( instance == null || instance == Object . class ) return null ; 
if ( parentClass != null ) if ( parentClass . isInterface ( ) ) return null ; 
Class < ? > childClass = instance . getClass ( ) ; 
while ( true ) { 
Class < ? > parent = childClass . getSuperclass ( ) ; 
if ( parent == parentClass ) return childClass ; 
if ( parent == null ) return null ; 
childClass = parent ; 
} 
} 
} 

public class ClassUtil { 
public static JarFile jarFileOf ( final Class < ? > klass ) { 
URL url = klass . getResource ( "/" + klass . getName ( ) . replace ( '.' , '/' ) + ".class" ) ; 
if ( url == null ) return null ; 
String s = url . getFile ( ) ; 
int beginIndex = s . indexOf ( "file:" ) + "file:" . length ( ) ; 
int endIndex = s . indexOf ( ".jar!" ) ; 
if ( endIndex == - 1 ) return null ; 
endIndex += ".jar" . length ( ) ; 
String f = s . substring ( beginIndex , endIndex ) ; 
f = URLDecoder . decode ( f , "UTF-8" ) ; 
File file = new File ( f ) ; 
try { 
return file . exists ( ) ? new JarFile ( file ) : null ; 
} 
catch ( IOException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class LazyValue { 
@ Override public T get ( ) { 
if ( ! initialized ) synchronized ( this ) { 
if ( ! initialized ) { 
final T t = supplier . get ( ) ; 
value = t ; 
initialized = true ; 
supplier = null ; 
return t ; 
} 
} 
return value ; 
} 
} 

public class MethodVisitor { 
public void visitParameter ( final String name , final int access ) { 
if ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; 
if ( mv != null ) mv . visitParameter ( name , access ) ; 
} 
} 

public class MethodVisitor { 
public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { 
if ( mv != null ) return mv . visitAnnotation ( descriptor , visible ) ; 
return null ; 
} 
} 

public class MethodVisitor { 
public AnnotationVisitor visitTypeAnnotation ( final int typeRef , final TypePath typePath , final String descriptor , final boolean visible ) { 
if ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; 
if ( mv != null ) return mv . visitTypeAnnotation ( typeRef , typePath , descriptor , visible ) ; 
return null ; 
} 
} 

public class MethodVisitor { 
public AnnotationVisitor visitParameterAnnotation ( final int parameter , final String descriptor , final boolean visible ) { 
if ( mv != null ) return mv . visitParameterAnnotation ( parameter , descriptor , visible ) ; 
return null ; 
} 
} 

public class MethodVisitor { 
public void visitFieldInsn ( final int opcode , final String owner , final String name , final String descriptor ) { 
if ( mv != null ) mv . visitFieldInsn ( opcode , owner , name , descriptor ) ; 
} 
} 

public class MethodVisitor { 
public void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { 
if ( api < Opcodes . ASM5 ) { 
if ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) throw new IllegalArgumentException ( "INVOKESPECIAL/STATIC on interfaces requires ASM5" ) ; 
visitMethodInsn ( opcode , owner , name , descriptor ) ; 
return ; 
} 
if ( mv != null ) mv . visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; 
} 
} 

public class MethodVisitor { 
public void visitInvokeDynamicInsn ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { 
if ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; 
if ( mv != null ) mv . visitInvokeDynamicInsn ( name , descriptor , bootstrapMethodHandle , bootstrapMethodArguments ) ; 
} 
} 

public class MethodVisitor { 
public void visitJumpInsn ( final int opcode , final Label label ) { 
if ( mv != null ) mv . visitJumpInsn ( opcode , label ) ; 
} 
} 

public class MethodVisitor { 
public void visitMultiANewArrayInsn ( final String descriptor , final int numDimensions ) { 
if ( mv != null ) mv . visitMultiANewArrayInsn ( descriptor , numDimensions ) ; 
} 
} 

public class MethodVisitor { 
public void visitTryCatchBlock ( final Label start , final Label end , final Label handler , final String type ) { 
if ( mv != null ) mv . visitTryCatchBlock ( start , end , handler , type ) ; 
} 
} 

public class MethodVisitor { 
public AnnotationVisitor visitLocalVariableAnnotation ( final int typeRef , final TypePath typePath , final Label [ ] start , final Label [ ] end , final int [ ] index , final String descriptor , final boolean visible ) { 
if ( api < Opcodes . ASM5 ) throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; 
if ( mv != null ) return mv . visitLocalVariableAnnotation ( typeRef , typePath , start , end , index , descriptor , visible ) ; 
return null ; 
} 
} 

public class MemoryFileUpload { 
@ Override public void processStream ( ) throws IOException { 
FastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; 
size = 0 ; 
if ( maxFileSize == - 1 ) size += input . copyAll ( out ) ; 
else { 
size += input . copyMax ( out , maxFileSize + 1 ) ; 
if ( size > maxFileSize ) { 
fileTooBig = true ; 
valid = false ; 
input . skipToBoundary ( ) ; 
return ; 
} 
} 
data = out . toByteArray ( ) ; 
size = data . length ; 
valid = true ; 
} 
} 

public class DbListIterator { 
@ Override public T next ( ) { 
if ( hasNext == null ) hasNext = Boolean . valueOf ( moveToNext ( ) ) ; 
if ( hasNext == false ) throw new NoSuchElementException ( ) ; 
if ( ! entityAwareMode ) { 
hasNext = null ; 
return newElement ; 
} 
count ++ ; 
T result = previousElement ; 
previousElement = newElement ; 
hasNext = null ; 
return result ; 
} 
} 

public class DbListIterator { 
private boolean moveToNext ( ) { 
if ( last ) { 
if ( closeOnEnd ) query . close ( ) ; 
else query . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; 
return false ; 
} 
while ( true ) { 
if ( ! resultSetMapper . next ( ) ) { 
last = true ; 
return entityAwareMode ; 
} 
Object [ ] objects = resultSetMapper . parseObjects ( types ) ; 
Object row = query . resolveRowResults ( objects ) ; 
newElement = ( T ) row ; 
if ( entityAwareMode ) { 
if ( count == 0 && previousElement == null ) { 
previousElement = newElement ; 
continue ; 
} 
if ( previousElement != null && newElement != null ) { 
boolean equals ; 
if ( newElement . getClass ( ) . isArray ( ) ) equals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; 
else equals = previousElement . equals ( newElement ) ; 
if ( equals ) continue ; 
} 
} 
break ; 
} 
return true ; 
} 
} 

public class ArraysUtil { 
@ SuppressWarnings ( { 
"unchecked" } 
) public static < T > T [ ] join ( Class < T > componentType , T [ ] [ ] arrays ) { 
if ( arrays . length == 1 ) return arrays [ 0 ] ; 
int length = 0 ; 
for ( T [ ] array : arrays ) { 
length += array . length ; 
} 
T [ ] result = ( T [ ] ) Array . newInstance ( componentType , length ) ; 
length = 0 ; 
for ( T [ ] array : arrays ) { 
System . arraycopy ( array , 0 , result , length , array . length ) ; 
length += array . length ; 
} 
return result ; 
} 
} 

public class ArraysUtil { 
public static int indexOf ( char [ ] array , char value ) { 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) if ( array [ i ] == value ) return i ; 
return - 1 ; 
} 
} 

public class ArraysUtil { 
public static int indexOf ( Object [ ] array , Object value ) { 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) if ( array [ i ] . equals ( value ) ) return i ; 
return - 1 ; 
} 
} 

public class MethodWriter { 
private void computeMaxStackAndLocal ( ) { 
Handler handler = firstHandler ; 
while ( handler != null ) { 
Label handlerBlock = handler . handlerPc ; 
Label handlerRangeBlock = handler . startPc ; 
Label handlerRangeEnd = handler . endPc ; 
while ( handlerRangeBlock != handlerRangeEnd ) { 
if ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) handlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; 
else handlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; 
handlerRangeBlock = handlerRangeBlock . nextBasicBlock ; 
} 
handler = handler . nextHandler ; 
} 
if ( hasSubroutines ) { 
short numSubroutines = 1 ; 
firstBasicBlock . markSubroutine ( numSubroutines ) ; 
for ( short currentSubroutine = 1 ; 
currentSubroutine <= numSubroutines ; 
++ currentSubroutine ) { 
Label basicBlock = firstBasicBlock ; 
while ( basicBlock != null ) { 
if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { 
Label jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; 
if ( jsrTarget . subroutineId == 0 ) jsrTarget . markSubroutine ( ++ numSubroutines ) ; 
} 
basicBlock = basicBlock . nextBasicBlock ; 
} 
} 
Label basicBlock = firstBasicBlock ; 
while ( basicBlock != null ) { 
if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { 
Label subroutine = basicBlock . outgoingEdges . nextEdge . successor ; 
subroutine . addSubroutineRetSuccessors ( basicBlock ) ; 
} 
basicBlock = basicBlock . nextBasicBlock ; 
} 
} 
Label listOfBlocksToProcess = firstBasicBlock ; 
listOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; 
int maxStackSize = maxStack ; 
while ( listOfBlocksToProcess != Label . EMPTY_LIST ) { 
Label basicBlock = listOfBlocksToProcess ; 
listOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; 
int inputStackTop = basicBlock . inputStackSize ; 
int maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; 
if ( maxBlockStackSize > maxStackSize ) maxStackSize = maxBlockStackSize ; 
Edge outgoingEdge = basicBlock . outgoingEdges ; 
if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) outgoingEdge = outgoingEdge . nextEdge ; 
while ( outgoingEdge != null ) { 
Label successorBlock = outgoingEdge . successor ; 
if ( successorBlock . nextListElement == null ) { 
successorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; 
successorBlock . nextListElement = listOfBlocksToProcess ; 
listOfBlocksToProcess = successorBlock ; 
} 
outgoingEdge = outgoingEdge . nextEdge ; 
} 
} 
this . maxStack = maxStackSize ; 
} 
} 

public class ContextInjectorComponent { 
public void injectContext ( final Object targetObject ) { 
final Class targetType = targetObject . getClass ( ) ; 
final ScopeData scopeData = scopeDataInspector . inspectClassScopesWithCache ( targetType ) ; 
final Targets targets = new Targets ( targetObject , scopeData ) ; 
scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( targets ) ) ; 
scopeResolver . forScope ( ParamsScope . class , scope -> scope . inject ( targets ) ) ; 
final ServletContext servletContext = madvocController . getApplicationContext ( ) ; 
if ( servletContext != null ) scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( servletContext , targets ) ) ; 
} 
} 

public class PseudoClassSelector { 
public static PseudoClass lookupPseudoClass ( final String pseudoClassName ) { 
PseudoClass pseudoClass = PSEUDO_CLASS_MAP . get ( pseudoClassName ) ; 
if ( pseudoClass == null ) throw new CSSellyException ( "Unsupported pseudo class: " + pseudoClassName ) ; 
return pseudoClass ; 
} 
} 

public class AsyncActionExecutor { 
public void invoke ( final ActionRequest actionRequest ) { 
if ( executorService == null ) throw new MadvocException ( "No action is marked as async!" ) ; 
final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; 
log . debug ( ( ) -> "Async call to: " + actionRequest ) ; 
final AsyncContext asyncContext = servletRequest . startAsync ( ) ; 
executorService . submit ( ( ) -> { 
try { 
actionRequest . invoke ( ) ; 
} 
catch ( Exception ex ) { 
log . error ( "Invoking async action path failed: " , ExceptionUtil . unwrapThrowable ( ex ) ) ; 
} 
finally { 
asyncContext . complete ( ) ; 
} 
} 
) ; 
} 
} 

public class BeanVisitor { 
protected String [ ] getAllBeanPropertyNames ( final Class type , final boolean declared ) { 
ClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; 
PropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; 
ArrayList < String > names = new ArrayList < > ( propertyDescriptors . length ) ; 
for ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { 
MethodDescriptor getter = propertyDescriptor . getReadMethodDescriptor ( ) ; 
if ( getter != null ) if ( getter . matchDeclared ( declared ) ) names . add ( propertyDescriptor . getName ( ) ) ; 
else if ( includeFields ) { 
FieldDescriptor field = propertyDescriptor . getFieldDescriptor ( ) ; 
if ( field != null ) if ( field . matchDeclared ( declared ) ) names . add ( field . getName ( ) ) ; 
} 
} 
return names . toArray ( new String [ 0 ] ) ; 
} 
} 

public class BeanVisitor { 
public void visit ( ) { 
String [ ] properties = resolveProperties ( source , declared ) ; 
for ( String name : properties ) { 
if ( name == null ) continue ; 
if ( ! rules . match ( name , blacklist ) ) continue ; 
Object value ; 
String propertyName = name ; 
if ( isSourceMap ) propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; 
if ( declared ) value = BeanUtil . declared . getProperty ( source , propertyName ) ; 
else value = BeanUtil . pojo . getProperty ( source , propertyName ) ; 
if ( value == null && ignoreNullValues ) continue ; 
if ( value instanceof String && StringUtil . isEmpty ( ( String ) value ) ) continue ; 
visitProperty ( name , value ) ; 
} 
} 
} 

public class MethodResolver { 
public MethodInjectionPoint [ ] resolve ( final Class type ) { 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
List < MethodInjectionPoint > list = new ArrayList < > ( ) ; 
MethodDescriptor [ ] allMethods = cd . getAllMethodDescriptors ( ) ; 
for ( MethodDescriptor methodDescriptor : allMethods ) { 
Method method = methodDescriptor . getMethod ( ) ; 
if ( ClassUtil . isBeanPropertySetter ( method ) ) continue ; 
if ( method . getParameterTypes ( ) . length == 0 ) continue ; 
BeanReferences [ ] references = referencesResolver . readAllReferencesFromAnnotation ( method ) ; 
if ( references != null ) { 
MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint ( method , references ) ; 
list . add ( methodInjectionPoint ) ; 
} 
} 
final MethodInjectionPoint [ ] methodInjectionPoints ; 
if ( list . isEmpty ( ) ) methodInjectionPoints = MethodInjectionPoint . EMPTY ; 
else methodInjectionPoints = list . toArray ( new MethodInjectionPoint [ 0 ] ) ; 
return methodInjectionPoints ; 
} 
} 

public class HtmlStaplerFilter { 
protected void readFilterConfigParameters ( final FilterConfig filterConfig , final Object target , final String ... parameters ) { 
for ( String parameter : parameters ) { 
String value = filterConfig . getInitParameter ( parameter ) ; 
if ( value != null ) BeanUtil . declared . setProperty ( target , parameter , value ) ; 
} 
} 
} 

public class HtmlStaplerBundlesManager { 
public File lookupBundleFile ( String bundleId ) { 
if ( ( mirrors != null ) && ( ! mirrors . isEmpty ( ) ) ) { 
String realBundleId = mirrors . remove ( bundleId ) ; 
if ( realBundleId != null ) bundleId = realBundleId ; 
} 
return createBundleFile ( bundleId ) ; 
} 
} 

public class HtmlStaplerBundlesManager { 
public File lookupGzipBundleFile ( final File file ) throws IOException { 
String path = file . getPath ( ) + ZipUtil . GZIP_EXT ; 
File gzipFile = new File ( path ) ; 
if ( ! gzipFile . exists ( ) ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "gzip bundle to " + path ) ; 
ZipUtil . gzip ( file ) ; 
} 
return gzipFile ; 
} 
} 

public class HtmlStaplerBundlesManager { 
public synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { 
if ( tempBundleId == null || sources . isEmpty ( ) ) { 
if ( strategy == Strategy . ACTION_MANAGED ) actionBundles . put ( actionPath , StringPool . EMPTY ) ; 
return null ; 
} 
String [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; 
for ( int i = 0 , sourcesArrayLength = sourcesArray . length ; 
i < sourcesArrayLength ; 
i ++ ) sourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; 
if ( sortResources ) Arrays . sort ( sourcesArray ) ; 
StringBand sb = new StringBand ( sourcesArray . length ) ; 
for ( String src : sourcesArray ) { 
sb . append ( src ) ; 
} 
String sourcesString = sb . toString ( ) ; 
String bundleId = createDigest ( sourcesString ) ; 
bundleId += '.' + bundleContentType ; 
if ( strategy == Strategy . ACTION_MANAGED ) { 
actionBundles . put ( actionPath , bundleId ) ; 
mirrors . put ( tempBundleId , bundleId ) ; 
} 
try { 
createBundle ( contextPath , actionPath , bundleId , sources ) ; 
} 
catch ( IOException ioex ) { 
throw new HtmlStaplerException ( "Can't create bundle" , ioex ) ; 
} 
return bundleId ; 
} 
} 

public class HtmlStaplerBundlesManager { 
protected String createDigest ( final String source ) { 
final DigestEngine digestEngine = DigestEngine . sha256 ( ) ; 
final byte [ ] bytes = digestEngine . digest ( CharUtil . toSimpleByteArray ( source ) ) ; 
String digest = Base32 . encode ( bytes ) ; 
if ( uniqueDigestKey != null ) digest += uniqueDigestKey ; 
return digest ; 
} 
} 

public class HtmlStaplerBundlesManager { 
protected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { 
final File bundleFile = createBundleFile ( bundleId ) ; 
if ( bundleFile . exists ( ) ) return ; 
StringBand sb = new StringBand ( sources . size ( ) * 2 ) ; 
for ( String src : sources ) { 
if ( sb . length ( ) != 0 ) sb . append ( StringPool . NEWLINE ) ; 
String content ; 
if ( isExternalResource ( src ) ) content = downloadString ( src ) ; 
else { 
if ( ! downloadLocal ) { 
String localFile = webRoot ; 
if ( src . startsWith ( contextPath + '/' ) ) src = src . substring ( contextPath . length ( ) ) ; 
if ( src . startsWith ( StringPool . SLASH ) ) localFile += src ; 
else localFile += '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; 
int qmndx = localFile . indexOf ( '?' ) ; 
if ( qmndx != - 1 ) localFile = localFile . substring ( 0 , qmndx ) ; 
try { 
content = FileUtil . readString ( localFile ) ; 
} 
catch ( IOException ioex ) { 
if ( notFoundExceptionEnabled ) throw ioex ; 
if ( log . isWarnEnabled ( ) ) log . warn ( ioex . getMessage ( ) ) ; 
content = null ; 
} 
} 
else { 
String localUrl = localAddressAndPort ; 
if ( src . startsWith ( StringPool . SLASH ) ) localUrl += contextPath + src ; 
else localUrl += contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; 
content = downloadString ( localUrl ) ; 
} 
if ( content != null ) if ( isCssResource ( src ) ) content = fixCssRelativeUrls ( content , src ) ; 
} 
if ( content != null ) { 
content = onResourceContent ( content ) ; 
sb . append ( content ) ; 
} 
} 
FileUtil . writeString ( bundleFile , sb . toString ( ) ) ; 
if ( log . isInfoEnabled ( ) ) log . info ( "Bundle created: " + bundleId ) ; 
} 
} 

public class HtmlStaplerBundlesManager { 
public synchronized void reset ( ) { 
if ( strategy == Strategy . ACTION_MANAGED ) { 
actionBundles . clear ( ) ; 
mirrors . clear ( ) ; 
} 
final FindFile ff = new FindFile ( ) ; 
ff . includeDirs ( false ) ; 
ff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; 
File f ; 
int count = 0 ; 
while ( ( f = ff . nextFile ( ) ) != null ) { 
f . delete ( ) ; 
count ++ ; 
} 
if ( log . isInfoEnabled ( ) ) log . info ( "reset: " + count + " bundle files deleted." ) ; 
} 
} 

public class HtmlStaplerBundlesManager { 
protected String fixCssRelativeUrls ( final String content , final String src ) { 
final String path = FileNameUtil . getPath ( src ) ; 
final Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; 
final StringBuilder sb = new StringBuilder ( content . length ( ) ) ; 
int start = 0 ; 
while ( matcher . find ( ) ) { 
sb . append ( content , start , matcher . start ( ) ) ; 
final String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , "'\"" ) ; 
final String url ; 
if ( matchedUrl . startsWith ( "https://" ) || matchedUrl . startsWith ( "http://" ) || matchedUrl . startsWith ( "data:" ) ) url = "url('" + matchedUrl + "')" ; 
else url = fixRelativeUrl ( matchedUrl , path ) ; 
sb . append ( url ) ; 
start = matcher . end ( ) ; 
} 
sb . append ( content . substring ( start ) ) ; 
return sb . toString ( ) ; 
} 
} 

public class DbJtxSessionProvider { 
@ Override public DbSession getDbSession ( ) { 
log . debug ( "Requesting db TX manager session" ) ; 
final DbJtxTransaction jtx = ( DbJtxTransaction ) jtxTxManager . getTransaction ( ) ; 
if ( jtx == null ) throw new DbSqlException ( "No transaction is in progress and DbSession can't be provided. " + "It seems that transaction manager is not used to begin a transaction." ) ; 
return jtx . requestResource ( ) ; 
} 
} 

public class GenericsReader { 
public Map < String , String > parseSignatureForGenerics ( final String signature , final boolean isInterface ) { 
if ( signature == null ) return Collections . emptyMap ( ) ; 
final Map < String , String > genericsMap = new HashMap < > ( ) ; 
SignatureReader sr = new SignatureReader ( signature ) ; 
StringBuilder sb = new StringBuilder ( ) ; 
TraceSignatureVisitor v = new TraceSignatureVisitor ( sb , isInterface ) { 
String genericName ; 
@ Override public void visitFormalTypeParameter ( final String name ) { 
genericName = name ; 
super . visitFormalTypeParameter ( name ) ; 
} 
@ Override public void visitClassType ( final String name ) { 
if ( genericName != null ) { 
genericsMap . put ( genericName , 'L' + name + ';' ) ; 
genericName = null ; 
} 
super . visitClassType ( name ) ; 
} 
} 
; 
sr . accept ( v ) ; 
return genericsMap ; 
} 
} 

public class SetResolver { 
public SetInjectionPoint [ ] resolve ( final Class type , final boolean autowire ) { 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
List < SetInjectionPoint > list = new ArrayList < > ( ) ; 
PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; 
for ( PropertyDescriptor propertyDescriptor : allProperties ) { 
if ( propertyDescriptor . isGetterOnly ( ) ) continue ; 
Class propertyType = propertyDescriptor . getType ( ) ; 
if ( ! ClassUtil . isTypeOf ( propertyType , Collection . class ) ) continue ; 
MethodDescriptor writeMethodDescriptor = propertyDescriptor . getWriteMethodDescriptor ( ) ; 
FieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; 
PetiteInject ref = null ; 
if ( writeMethodDescriptor != null ) ref = writeMethodDescriptor . getMethod ( ) . getAnnotation ( PetiteInject . class ) ; 
if ( ref == null && fieldDescriptor != null ) ref = fieldDescriptor . getField ( ) . getAnnotation ( PetiteInject . class ) ; 
if ( ( ! autowire ) && ( ref == null ) ) continue ; 
list . add ( new SetInjectionPoint ( propertyDescriptor ) ) ; 
} 
SetInjectionPoint [ ] fields ; 
if ( list . isEmpty ( ) ) fields = SetInjectionPoint . EMPTY ; 
else fields = list . toArray ( new SetInjectionPoint [ 0 ] ) ; 
return fields ; 
} 
} 

public class JsonContext { 
public boolean matchIgnoredPropertyTypes ( final Class propertyType , final boolean excludeMaps , final boolean include ) { 
if ( ! include ) return false ; 
if ( propertyType != null ) { 
if ( ! jsonSerializer . deep ) { 
ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector . get ( ) . lookup ( propertyType ) ; 
if ( propertyTypeClassDescriptor . isArray ( ) ) return false ; 
if ( propertyTypeClassDescriptor . isCollection ( ) ) return false ; 
if ( excludeMaps ) if ( propertyTypeClassDescriptor . isMap ( ) ) return false ; 
} 
if ( jsonSerializer . excludedTypes != null ) for ( Class excludedType : jsonSerializer . excludedTypes ) { 
if ( ClassUtil . isTypeOf ( propertyType , excludedType ) ) return false ; 
} 
final String propertyTypeName = propertyType . getName ( ) ; 
if ( jsonSerializer . excludedTypeNames != null ) for ( String excludedTypeName : jsonSerializer . excludedTypeNames ) { 
if ( Wildcard . match ( propertyTypeName , excludedTypeName ) ) return false ; 
} 
} 
return true ; 
} 
} 

public class DbSession { 
protected void openTx ( ) { 
if ( connection == null ) connection = connectionProvider . getConnection ( ) ; 
txActive = true ; 
try { 
connection . setAutoCommit ( false ) ; 
if ( txMode . getIsolation ( ) != DbTransactionMode . ISOLATION_DEFAULT ) connection . setTransactionIsolation ( txMode . getIsolation ( ) ) ; 
connection . setReadOnly ( txMode . isReadOnly ( ) ) ; 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( "Open TX failed" , sex ) ; 
} 
} 
} 

public class PropertiesUtil { 
public static Properties subset ( final Properties p , String prefix , final boolean stripPrefix ) { 
if ( StringUtil . isBlank ( prefix ) ) return p ; 
if ( ! prefix . endsWith ( StringPool . DOT ) ) prefix += '.' ; 
Properties result = new Properties ( ) ; 
int baseLen = prefix . length ( ) ; 
for ( Object o : p . keySet ( ) ) { 
String key = ( String ) o ; 
if ( key . startsWith ( prefix ) ) result . setProperty ( stripPrefix ? key . substring ( baseLen ) : key , p . getProperty ( key ) ) ; 
} 
return result ; 
} 
} 

public class PropertiesUtil { 
public static String resolveProperty ( final Map map , final String key ) { 
String value = getProperty ( map , key ) ; 
if ( value == null ) return null ; 
value = stp . parse ( value , macroName -> getProperty ( map , macroName ) ) ; 
return value ; 
} 
} 

public class AnnotationTxAdviceManager { 
public String resolveScope ( final Class type , final String methodName ) { 
if ( scopePattern == null ) return null ; 
String ctx = scopePattern ; 
ctx = StringUtil . replace ( ctx , JTXCTX_PATTERN_CLASS , type . getName ( ) ) ; 
ctx = StringUtil . replace ( ctx , JTXCTX_PATTERN_METHOD , methodName ) ; 
return ctx ; 
} 
} 

public class AnnotationTxAdviceManager { 
public synchronized JtxTransactionMode getTxMode ( final Class type , final String methodName , final Class [ ] methodArgTypes , final String unique ) { 
String signature = type . getName ( ) + '#' + methodName + '%' + unique ; 
JtxTransactionMode txMode = txmap . get ( signature ) ; 
if ( txMode == null ) if ( ! txmap . containsKey ( signature ) ) { 
final Method m ; 
try { 
m = type . getMethod ( methodName , methodArgTypes ) ; 
} 
catch ( NoSuchMethodException nsmex ) { 
throw new ProxettaException ( nsmex ) ; 
} 
final TransactionAnnotationValues txAnn = readTransactionAnnotation ( m ) ; 
if ( txAnn != null ) txMode = new JtxTransactionMode ( txAnn . propagation ( ) , txAnn . isolation ( ) , txAnn . readOnly ( ) , txAnn . timeout ( ) ) ; 
else txMode = defaultTransactionMode ; 
txmap . put ( signature , txMode ) ; 
} 
return txMode ; 
} 
} 

public class AnnotationTxAdviceManager { 
@ SuppressWarnings ( { 
"unchecked" } 
) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { 
this . annotations = annotations ; 
this . annotationParsers = new AnnotationParser [ annotations . length ] ; 
for ( int i = 0 ; 
i < annotations . length ; 
i ++ ) annotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; 
} 
} 

public class AnnotationTxAdviceManager { 
protected TransactionAnnotationValues readTransactionAnnotation ( final Method method ) { 
for ( AnnotationParser annotationParser : annotationParsers ) { 
TransactionAnnotationValues tad = TransactionAnnotationValues . of ( annotationParser , method ) ; 
if ( tad != null ) return tad ; 
} 
return null ; 
} 
} 

public class CssSelector { 
@ Override public boolean accept ( final Node node ) { 
if ( ! matchElement ( node ) ) return false ; 
int totalSelectors = selectorsCount ( ) ; 
for ( int i = 0 ; 
i < totalSelectors ; 
i ++ ) { 
Selector selector = getSelector ( i ) ; 
switch ( selector . getType ( ) ) { 
case ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) return false ; 
break ; 
case PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) return false ; 
break ; 
case PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) return false ; 
break ; 
} 
} 
return true ; 
} 
} 

public class CssSelector { 
protected boolean matchElement ( final Node node ) { 
if ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) return false ; 
String element = getElement ( ) ; 
String nodeName = node . getNodeName ( ) ; 
return element . equals ( StringPool . STAR ) || element . equals ( nodeName ) ; 
} 
} 

public class CssSelector { 
public boolean accept ( final List < Node > currentResults , final Node node , final int index ) { 
int totalSelectors = selectorsCount ( ) ; 
for ( int i = 0 ; 
i < totalSelectors ; 
i ++ ) { 
Selector selector = getSelector ( i ) ; 
switch ( selector . getType ( ) ) { 
case PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) return false ; 
break ; 
case PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) return false ; 
break ; 
default : } 
} 
return true ; 
} 
} 

public class CssSelector { 
protected String unescape ( final String value ) { 
if ( value . indexOf ( '\\' ) == - 1 ) return value ; 
return StringUtil . remove ( value , '\\' ) ; 
} 
} 

public class Node { 
public void detachFromParent ( ) { 
if ( parentNode == null ) return ; 
if ( parentNode . childNodes != null ) { 
parentNode . childNodes . remove ( siblingIndex ) ; 
parentNode . reindexChildren ( ) ; 
} 
parentNode = null ; 
} 
} 

public class Node { 
public void addChild ( final Node ... nodes ) { 
if ( nodes . length == 0 ) return ; 
for ( Node node : nodes ) { 
node . detachFromParent ( ) ; 
node . parentNode = this ; 
initChildNodes ( node ) ; 
childNodes . add ( node ) ; 
} 
reindexChildrenOnAdd ( nodes . length ) ; 
} 
} 

public class Node { 
public void insertBefore ( final Node [ ] newChilds , final Node refChild ) { 
if ( newChilds . length == 0 ) return ; 
int siblingIndex = refChild . getSiblingIndex ( ) ; 
refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; 
} 
} 

public class Node { 
public void insertAfter ( final Node newChild , final Node refChild ) { 
int siblingIndex = refChild . getSiblingIndex ( ) + 1 ; 
if ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) refChild . parentNode . addChild ( newChild ) ; 
else refChild . parentNode . insertChild ( newChild , siblingIndex ) ; 
} 
} 

public class Node { 
public void insertAfter ( final Node [ ] newChilds , final Node refChild ) { 
if ( newChilds . length == 0 ) return ; 
int siblingIndex = refChild . getSiblingIndex ( ) + 1 ; 
if ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) refChild . parentNode . addChild ( newChilds ) ; 
else refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; 
} 
} 

public class Node { 
public void removeAllChilds ( ) { 
List < Node > removedNodes = childNodes ; 
childNodes = null ; 
childElementNodes = null ; 
childElementNodesCount = 0 ; 
if ( removedNodes != null ) for ( int i = 0 , removedNodesSize = removedNodes . size ( ) ; 
i < removedNodesSize ; 
i ++ ) { 
Node removedNode = removedNodes . get ( i ) ; 
removedNode . detachFromParent ( ) ; 
} 
} 
} 

public class Node { 
public Node findChildNodeWithName ( final String name ) { 
if ( childNodes == null ) return null ; 
for ( final Node childNode : childNodes ) { 
if ( childNode . getNodeName ( ) . equals ( name ) ) return childNode ; 
} 
return null ; 
} 
} 

public class Node { 
public Node [ ] filterChildNodes ( final Predicate < Node > nodePredicate ) { 
if ( childNodes == null ) return new Node [ 0 ] ; 
return childNodes . stream ( ) . filter ( nodePredicate ) . toArray ( Node [ ] :: new ) ; 
} 
} 

public class Node { 
public boolean check ( ) { 
if ( childNodes == null ) return true ; 
int siblingElementIndex = 0 ; 
for ( int i = 0 , childNodesSize = childNodes . size ( ) ; 
i < childNodesSize ; 
i ++ ) { 
Node childNode = childNodes . get ( i ) ; 
if ( childNode . siblingIndex != i ) return false ; 
if ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { 
if ( childNode . siblingElementIndex != siblingElementIndex ) return false ; 
siblingElementIndex ++ ; 
} 
} 
if ( childElementNodesCount != siblingElementIndex ) return false ; 
if ( childElementNodes != null ) { 
if ( childElementNodes . length != childElementNodesCount ) return false ; 
int childCount = getChildNodesCount ( ) ; 
for ( int i = 0 ; 
i < childCount ; 
i ++ ) { 
Node child = getChild ( i ) ; 
if ( child . siblingElementIndex >= 0 ) if ( childElementNodes [ child . siblingElementIndex ] != child ) return false ; 
} 
} 
if ( siblingNameIndex != - 1 ) { 
List < Node > siblings = parentNode . childNodes ; 
int index = 0 ; 
for ( int i = 0 , siblingsSize = siblings . size ( ) ; 
i < siblingsSize ; 
i ++ ) { 
Node sibling = siblings . get ( i ) ; 
if ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) if ( sibling . siblingNameIndex != index ++ ) return false ; 
} 
} 
for ( Node childNode : childNodes ) { 
if ( ! childNode . check ( ) ) return false ; 
} 
return true ; 
} 
} 

public class Node { 
protected void initChildElementNodes ( ) { 
if ( childElementNodes == null ) { 
childElementNodes = new Element [ childElementNodesCount ] ; 
int childCount = getChildNodesCount ( ) ; 
for ( int i = 0 ; 
i < childCount ; 
i ++ ) { 
Node child = getChild ( i ) ; 
if ( child . siblingElementIndex >= 0 ) childElementNodes [ child . siblingElementIndex ] = ( Element ) child ; 
} 
} 
} 
} 

public class Node { 
protected void initSiblingNames ( ) { 
if ( siblingNameIndex == - 1 ) { 
List < Node > siblings = parentNode . childNodes ; 
int index = 0 ; 
for ( int i = 0 , siblingsSize = siblings . size ( ) ; 
i < siblingsSize ; 
i ++ ) { 
Node sibling = siblings . get ( i ) ; 
if ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) sibling . siblingNameIndex = index ++ ; 
} 
} 
} 
} 

public class Node { 
protected void initChildNodes ( final Node newNode ) { 
if ( childNodes == null ) childNodes = new ArrayList < > ( ) ; 
if ( ownerDocument != null ) if ( newNode . ownerDocument != ownerDocument ) changeOwnerDocument ( newNode , ownerDocument ) ; 
} 
} 

public class Node { 
public Node getPreviousSiblingName ( ) { 
if ( nodeName == null ) return null ; 
initSiblingNames ( ) ; 
int index = siblingNameIndex - 1 ; 
for ( int i = siblingIndex ; 
i >= 0 ; 
i -- ) { 
Node sibling = parentNode . childNodes . get ( i ) ; 
if ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) return sibling ; 
} 
return null ; 
} 
} 

public class Node { 
public String getHtml ( ) { 
LagartoDomBuilderConfig lagartoDomBuilderConfig ; 
if ( ownerDocument == null ) lagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; 
else lagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; 
LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; 
return lagartoHtmlRenderer . toHtml ( this , new StringBuilder ( ) ) ; 
} 
} 

public class Node { 
public String getInnerHtml ( ) { 
LagartoDomBuilderConfig lagartoDomBuilderConfig ; 
if ( ownerDocument == null ) lagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; 
else lagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; 
LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; 
return lagartoHtmlRenderer . toInnerHtml ( this , new StringBuilder ( ) ) ; 
} 
} 

public class Node { 
protected void visitChildren ( final NodeVisitor nodeVisitor ) { 
if ( childNodes != null ) for ( int i = 0 , childNodesSize = childNodes . size ( ) ; 
i < childNodesSize ; 
i ++ ) { 
Node childNode = childNodes . get ( i ) ; 
childNode . visit ( nodeVisitor ) ; 
} 
} 
} 

public class Node { 
public String getCssPath ( ) { 
StringBuilder path = new StringBuilder ( ) ; 
Node node = this ; 
while ( node != null ) { 
String nodeName = node . getNodeName ( ) ; 
if ( nodeName != null ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( ' ' ) . append ( nodeName ) ; 
String id = node . getAttribute ( "id" ) ; 
if ( id != null ) sb . append ( '#' ) . append ( id ) ; 
path . insert ( 0 , sb ) ; 
} 
node = node . getParentNode ( ) ; 
} 
if ( path . charAt ( 0 ) == ' ' ) return path . substring ( 1 ) ; 
return path . toString ( ) ; 
} 
} 

public class RootPackages { 
public void addRootPackage ( final String rootPackage , String mapping ) { 
if ( packages == null ) packages = new String [ 0 ] ; 
if ( mappings == null ) mappings = new String [ 0 ] ; 
if ( mapping . length ( ) > 0 ) { 
if ( ! mapping . startsWith ( StringPool . SLASH ) ) mapping = StringPool . SLASH + mapping ; 
if ( mapping . endsWith ( StringPool . SLASH ) ) mapping = StringUtil . substring ( mapping , 0 , - 1 ) ; 
} 
for ( int i = 0 ; 
i < packages . length ; 
i ++ ) if ( packages [ i ] . equals ( rootPackage ) ) { 
if ( mappings [ i ] . equals ( mapping ) ) return ; 
throw new MadvocException ( "Different mappings for the same root package: " + rootPackage ) ; 
} 
packages = ArraysUtil . append ( packages , rootPackage ) ; 
mappings = ArraysUtil . append ( mappings , mapping ) ; 
} 
} 

public class RootPackages { 
public String findRootPackageForActionPath ( final String actionPath ) { 
if ( mappings == null ) return null ; 
int ndx = - 1 ; 
int delta = Integer . MAX_VALUE ; 
for ( int i = 0 ; 
i < mappings . length ; 
i ++ ) { 
String mapping = mappings [ i ] ; 
boolean found = false ; 
if ( actionPath . equals ( mapping ) ) found = true ; 
else { 
mapping += StringPool . SLASH ; 
if ( actionPath . startsWith ( mapping ) ) found = true ; 
} 
if ( found ) { 
int distance = actionPath . length ( ) - mapping . length ( ) ; 
if ( distance < delta ) { 
ndx = i ; 
delta = distance ; 
} 
} 
} 
if ( ndx == - 1 ) return null ; 
return packages [ ndx ] ; 
} 
} 

public class VtorUtil { 
public static String resolveValidationMessage ( final HttpServletRequest request , final Violation violation ) { 
ValidationConstraint vc = violation . getConstraint ( ) ; 
String key = vc != null ? vc . getClass ( ) . getName ( ) : violation . getName ( ) ; 
String msg = LocalizationUtil . findMessage ( request , key ) ; 
if ( msg != null ) return beanTemplateParser . parseWithBean ( msg , violation ) ; 
return null ; 
} 
} 

public class BeanReferences { 
public BeanReferences removeDuplicateNames ( ) { 
if ( names . length < 2 ) return this ; 
int nullCount = 0 ; 
for ( int i = 1 ; 
i < names . length ; 
i ++ ) { 
String thisRef = names [ i ] ; 
if ( thisRef == null ) { 
nullCount ++ ; 
continue ; 
} 
for ( int j = 0 ; 
j < i ; 
j ++ ) { 
if ( names [ j ] == null ) continue ; 
if ( thisRef . equals ( names [ j ] ) ) { 
names [ i ] = null ; 
break ; 
} 
} 
} 
if ( nullCount == 0 ) return this ; 
String [ ] newRefs = new String [ names . length - nullCount ] ; 
int ndx = 0 ; 
for ( String name : names ) { 
if ( name == null ) continue ; 
newRefs [ ndx ] = name ; 
ndx ++ ; 
} 
return new BeanReferences ( newRefs ) ; 
} 
} 

public class Targets { 
public void forEachTargetAndIn ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { 
for ( final Target target : targets ) { 
final ScopeData scopeData = target . scopeData ( ) ; 
if ( scopeData . in ( ) == null ) continue ; 
for ( final InjectionPoint in : scopeData . in ( ) ) { 
if ( in . scope ( ) != scope ) continue ; 
biConsumer . accept ( target , in ) ; 
} 
} 
} 
} 

public class Targets { 
public void forEachTargetAndOut ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { 
for ( final Target target : targets ) { 
final ScopeData scopeData = target . scopeData ( ) ; 
if ( scopeData . out ( ) == null ) continue ; 
for ( final InjectionPoint out : scopeData . out ( ) ) { 
if ( out . scope ( ) != scope ) continue ; 
biConsumer . accept ( target , out ) ; 
} 
} 
} 
} 

public class Targets { 
public Object [ ] extractParametersValues ( ) { 
final Object [ ] values = new Object [ targets . length - 1 ] ; 
for ( int i = 1 ; 
i < targets . length ; 
i ++ ) values [ i - 1 ] = targets [ i ] . value ( ) ; 
return values ; 
} 
} 

public class Targets { 
protected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { 
if ( methodParams == null ) return new Target [ ] { 
actionTarget } 
; 
final Target [ ] target = new Target [ methodParams . length + 1 ] ; 
target [ 0 ] = actionTarget ; 
final Object action = actionTarget . value ( ) ; 
for ( int i = 0 ; 
i < methodParams . length ; 
i ++ ) { 
final MethodParam methodParam = methodParams [ i ] ; 
final Class paramType = methodParam . type ( ) ; 
final Target paramTarget ; 
if ( methodParam . annotationType ( ) == null ) { 
final ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; 
paramTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; 
} 
else if ( methodParam . annotationType ( ) == Out . class ) paramTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; 
else paramTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; 
target [ i + 1 ] = paramTarget ; 
} 
return target ; 
} 
} 

public class Targets { 
@ SuppressWarnings ( { 
"unchecked" , "NullArgumentToVariableArgMethod" } 
) protected Object createActionMethodArgument ( final Class type , final Object action ) { 
try { 
if ( type . getEnclosingClass ( ) == null || Modifier . isStatic ( type . getModifiers ( ) ) ) return ClassUtil . newInstance ( type ) ; 
else { 
Constructor ctor = type . getDeclaredConstructor ( type . getDeclaringClass ( ) ) ; 
ctor . setAccessible ( true ) ; 
return ctor . newInstance ( action ) ; 
} 
} 
catch ( Exception ex ) { 
throw new MadvocException ( ex ) ; 
} 
} 
} 

public class JsonArray { 
public Object remove ( final int pos ) { 
Object removed = list . remove ( pos ) ; 
if ( removed instanceof Map ) return new JsonObject ( ( Map ) removed ) ; 
if ( removed instanceof ArrayList ) return new JsonArray ( ( List ) removed ) ; 
return removed ; 
} 
} 

public class AbstractTemplateViewActionResult { 
protected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { 
String resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; 
ResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; 
String actionPath = resultPath . path ( ) ; 
String path = actionPath ; 
String value = resultPath . value ( ) ; 
if ( StringUtil . isEmpty ( value ) ) value = null ; 
String target ; 
while ( true ) { 
if ( value != null ) { 
if ( path == null ) { 
int lastSlashNdx = actionPath . lastIndexOf ( '/' ) ; 
if ( lastSlashNdx != - 1 ) target = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; 
else target = '/' + value ; 
} 
else target = path + '.' + value ; 
target = locateTarget ( actionRequest , target ) ; 
if ( target != null ) break ; 
} 
if ( path != null ) { 
target = locateTarget ( actionRequest , path ) ; 
if ( target != null ) break ; 
} 
if ( path == null ) return null ; 
int dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; 
if ( dotNdx == - 1 ) path = null ; 
else path = path . substring ( 0 , dotNdx ) ; 
} 
return target ; 
} 
} 

public class AbstractTemplateViewActionResult { 
protected void targetNotFound ( final ActionRequest actionRequest , final String actionAndResultPath ) throws IOException { 
final HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; 
if ( ! response . isCommitted ( ) ) response . sendError ( SC_NOT_FOUND , "Result not found: " + actionAndResultPath ) ; 
} 
} 

public class FormProcessorVisitor { 
protected String valueToString ( final String name , final Object valueObject ) { 
if ( ! valueObject . getClass ( ) . isArray ( ) ) return valueObject . toString ( ) ; 
String [ ] array = ( String [ ] ) valueObject ; 
if ( valueNameIndexes == null ) valueNameIndexes = new HashMap < > ( ) ; 
MutableInteger index = valueNameIndexes . get ( name ) ; 
if ( index == null ) { 
index = new MutableInteger ( 0 ) ; 
valueNameIndexes . put ( name , index ) ; 
} 
if ( index . value >= array . length ) return null ; 
String result = array [ index . value ] ; 
index . value ++ ; 
return result ; 
} 
} 

public class PropertyResolver { 
public PropertyInjectionPoint [ ] resolve ( Class type , final boolean autowire ) { 
final List < PropertyInjectionPoint > list = new ArrayList < > ( ) ; 
final Set < String > usedPropertyNames = new HashSet < > ( ) ; 
while ( type != Object . class ) { 
final ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
final PropertyDescriptor [ ] allPropertyDescriptors = cd . getAllPropertyDescriptors ( ) ; 
for ( PropertyDescriptor propertyDescriptor : allPropertyDescriptors ) { 
if ( propertyDescriptor . isGetterOnly ( ) ) continue ; 
if ( usedPropertyNames . contains ( propertyDescriptor . getName ( ) ) ) continue ; 
Class propertyType = propertyDescriptor . getType ( ) ; 
if ( ClassUtil . isTypeOf ( propertyType , Collection . class ) ) continue ; 
BeanReferences reference = referencesResolver . readReferenceFromAnnotation ( propertyDescriptor ) ; 
if ( reference == null ) if ( ! autowire ) continue ; 
else reference = referencesResolver . buildDefaultReference ( propertyDescriptor ) ; 
list . add ( new PropertyInjectionPoint ( propertyDescriptor , reference ) ) ; 
usedPropertyNames . add ( propertyDescriptor . getName ( ) ) ; 
} 
type = type . getSuperclass ( ) ; 
} 
final PropertyInjectionPoint [ ] fields ; 
if ( list . isEmpty ( ) ) fields = PropertyInjectionPoint . EMPTY ; 
else fields = list . toArray ( new PropertyInjectionPoint [ 0 ] ) ; 
return fields ; 
} 
} 

public class Socks4ProxySocketFactory { 
private Socket createSocks4ProxySocket ( final String host , final int port ) { 
Socket socket = null ; 
final String proxyHost = proxy . getProxyAddress ( ) ; 
final int proxyPort = proxy . getProxyPort ( ) ; 
final String user = proxy . getProxyUsername ( ) ; 
try { 
socket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; 
final InputStream in = socket . getInputStream ( ) ; 
final OutputStream out = socket . getOutputStream ( ) ; 
socket . setTcpNoDelay ( true ) ; 
byte [ ] buf = new byte [ 1024 ] ; 
int index = 0 ; 
buf [ index ++ ] = 4 ; 
buf [ index ++ ] = 1 ; 
buf [ index ++ ] = ( byte ) ( port >>> 8 ) ; 
buf [ index ++ ] = ( byte ) ( port & 0xff ) ; 
InetAddress addr = InetAddress . getByName ( host ) ; 
byte [ ] byteAddress = addr . getAddress ( ) ; 
for ( byte byteAddres : byteAddress ) { 
buf [ index ++ ] = byteAddres ; 
} 
if ( user != null ) { 
System . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; 
index += user . length ( ) ; 
} 
buf [ index ++ ] = 0 ; 
out . write ( buf , 0 , index ) ; 
int len = 6 ; 
int s = 0 ; 
while ( s < len ) { 
int i = in . read ( buf , s , len - s ) ; 
if ( i <= 0 ) throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , "stream is closed" ) ; 
s += i ; 
} 
if ( buf [ 0 ] != 0 ) throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , "proxy returned VN " + buf [ 0 ] ) ; 
if ( buf [ 1 ] != 90 ) { 
try { 
socket . close ( ) ; 
} 
catch ( Exception ignore ) { 
} 
throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , "proxy returned CD " + buf [ 1 ] ) ; 
} 
byte [ ] temp = new byte [ 2 ] ; 
in . read ( temp , 0 , 2 ) ; 
return socket ; 
} 
catch ( RuntimeException rtex ) { 
closeSocket ( socket ) ; 
throw rtex ; 
} 
catch ( Exception ex ) { 
closeSocket ( socket ) ; 
throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; 
} 
} 
} 

public class CharSequenceUtil { 
public static boolean equalsOne ( final char c , final CharSequence match ) { 
for ( int i = 0 ; 
i < match . length ( ) ; 
i ++ ) { 
char aMatch = match . charAt ( i ) ; 
if ( c == aMatch ) return true ; 
} 
return false ; 
} 
} 

public class CharSequenceUtil { 
public static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { 
for ( int i = index ; 
i < source . length ( ) ; 
i ++ ) if ( equalsOne ( source . charAt ( i ) , match ) ) return i ; 
return - 1 ; 
} 
} 

public class CharSequenceUtil { 
public static int findFirstEqual ( final char [ ] source , final int index , final char match ) { 
for ( int i = index ; 
i < source . length ; 
i ++ ) if ( source [ i ] == match ) return i ; 
return - 1 ; 
} 
} 

public class CommandLine { 
public CommandLine args ( final String ... arguments ) { 
if ( arguments != null && arguments . length > 0 ) Collections . addAll ( cmdLine , arguments ) ; 
return this ; 
} 
} 

public class CommandLine { 
public CommandLine env ( final String key , final String value ) { 
if ( env == null ) env = new HashMap < > ( ) ; 
env . put ( key , value ) ; 
return this ; 
} 
} 

public class CommandLine { 
public ProcessRunner . ProcessResult run ( ) { 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
out = err = baos ; 
try { 
baos . write ( StringUtil . join ( cmdLine , ' ' ) . getBytes ( ) ) ; 
baos . write ( StringPool . BYTES_NEW_LINE ) ; 
} 
catch ( IOException ignore ) { 
} 
ProcessBuilder processBuilder = new ProcessBuilder ( ) ; 
processBuilder . command ( cmdLine ) ; 
if ( cleanEnvironment ) processBuilder . environment ( ) . clear ( ) ; 
if ( env != null ) processBuilder . environment ( ) . putAll ( env ) ; 
processBuilder . directory ( workingDirectory ) ; 
Process process = null ; 
try { 
process = processBuilder . start ( ) ; 
} 
catch ( IOException ioex ) { 
return writeException ( baos , ioex ) ; 
} 
StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , out , outPrefix ) ; 
StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , err , errPrefix ) ; 
outputGobbler . start ( ) ; 
errorGobbler . start ( ) ; 
int result ; 
try { 
result = process . waitFor ( ) ; 
} 
catch ( InterruptedException iex ) { 
return writeException ( baos , iex ) ; 
} 
outputGobbler . waitFor ( ) ; 
errorGobbler . waitFor ( ) ; 
return new ProcessRunner . ProcessResult ( result , baos . toString ( ) ) ; 
} 
} 

public class Frame { 
static int getAbstractTypeFromApiFormat ( final SymbolTable symbolTable , final Object type ) { 
if ( type instanceof Integer ) return CONSTANT_KIND | ( ( Integer ) type ) . intValue ( ) ; 
else if ( type instanceof String ) { 
String descriptor = Type . getObjectType ( ( String ) type ) . getDescriptor ( ) ; 
return getAbstractTypeFromDescriptor ( symbolTable , descriptor , 0 ) ; 
} 
else return UNINITIALIZED_KIND | symbolTable . addUninitializedType ( "" , ( ( Label ) type ) . bytecodeOffset ) ; 
} 
} 

public class Frame { 
private static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { 
String internalName ; 
switch ( buffer . charAt ( offset ) ) { 
case 'V' : return 0 ; 
case 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; 
case 'F' : return FLOAT ; 
case 'J' : return LONG ; 
case 'D' : return DOUBLE ; 
case 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; 
return REFERENCE_KIND | symbolTable . addType ( internalName ) ; 
case '[' : int elementDescriptorOffset = offset + 1 ; 
while ( buffer . charAt ( elementDescriptorOffset ) == '[' ) ++ elementDescriptorOffset ; 
int typeValue ; 
switch ( buffer . charAt ( elementDescriptorOffset ) ) { 
case 'Z' : typeValue = BOOLEAN ; 
break ; 
case 'C' : typeValue = CHAR ; 
break ; 
case 'B' : typeValue = BYTE ; 
break ; 
case 'S' : typeValue = SHORT ; 
break ; 
case 'I' : typeValue = INTEGER ; 
break ; 
case 'F' : typeValue = FLOAT ; 
break ; 
case 'J' : typeValue = LONG ; 
break ; 
case 'D' : typeValue = DOUBLE ; 
break ; 
case 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; 
typeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; 
break ; 
default : throw new IllegalArgumentException ( ) ; 
} 
return ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; 
default : throw new IllegalArgumentException ( ) ; 
} 
} 
} 

public class Frame { 
final void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { 
int inputLocalIndex = 0 ; 
for ( int i = 0 ; 
i < numLocal ; 
++ i ) { 
inputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; 
if ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) inputLocals [ inputLocalIndex ++ ] = TOP ; 
} 
while ( inputLocalIndex < inputLocals . length ) inputLocals [ inputLocalIndex ++ ] = TOP ; 
int numStackTop = 0 ; 
for ( int i = 0 ; 
i < numStack ; 
++ i ) if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) ++ numStackTop ; 
inputStack = new int [ numStack + numStackTop ] ; 
int inputStackIndex = 0 ; 
for ( int i = 0 ; 
i < numStack ; 
++ i ) { 
inputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; 
if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) inputStack [ inputStackIndex ++ ] = TOP ; 
} 
outputStackTop = 0 ; 
initializationCount = 0 ; 
} 
} 

public class Frame { 
private int getLocal ( final int localIndex ) { 
if ( outputLocals == null || localIndex >= outputLocals . length ) return LOCAL_KIND | localIndex ; 
else { 
int abstractType = outputLocals [ localIndex ] ; 
if ( abstractType == 0 ) abstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; 
return abstractType ; 
} 
} 
} 

public class Frame { 
private void setLocal ( final int localIndex , final int abstractType ) { 
if ( outputLocals == null ) outputLocals = new int [ 10 ] ; 
int outputLocalsLength = outputLocals . length ; 
if ( localIndex >= outputLocalsLength ) { 
int [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; 
System . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; 
outputLocals = newOutputLocals ; 
} 
outputLocals [ localIndex ] = abstractType ; 
} 
} 

public class Frame { 
private void push ( final int abstractType ) { 
if ( outputStack == null ) outputStack = new int [ 10 ] ; 
int outputStackLength = outputStack . length ; 
if ( outputStackTop >= outputStackLength ) { 
int [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; 
System . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; 
outputStack = newOutputStack ; 
} 
outputStack [ outputStackTop ++ ] = abstractType ; 
short outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; 
if ( outputStackSize > owner . outputStackMax ) owner . outputStackMax = outputStackSize ; 
} 
} 

public class Frame { 
private void push ( final SymbolTable symbolTable , final String descriptor ) { 
int typeDescriptorOffset = descriptor . charAt ( 0 ) == '(' ? descriptor . indexOf ( ')' ) + 1 : 0 ; 
int abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; 
if ( abstractType != 0 ) { 
push ( abstractType ) ; 
if ( abstractType == LONG || abstractType == DOUBLE ) push ( TOP ) ; 
} 
} 
} 

public class Frame { 
private void pop ( final int elements ) { 
if ( outputStackTop >= elements ) outputStackTop -= elements ; 
else { 
outputStackStart -= elements - outputStackTop ; 
outputStackTop = 0 ; 
} 
} 
} 

public class Frame { 
private void pop ( final String descriptor ) { 
char firstDescriptorChar = descriptor . charAt ( 0 ) ; 
if ( firstDescriptorChar == '(' ) pop ( ( Type . getArgumentsAndReturnSizes ( descriptor ) >> 2 ) - 1 ) ; 
else if ( firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ) pop ( 2 ) ; 
else pop ( 1 ) ; 
} 
} 

public class Frame { 
private void addInitializedType ( final int abstractType ) { 
if ( initializations == null ) initializations = new int [ 2 ] ; 
int initializationsLength = initializations . length ; 
if ( initializationCount >= initializationsLength ) { 
int [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; 
System . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; 
initializations = newInitializations ; 
} 
initializations [ initializationCount ++ ] = abstractType ; 
} 
} 

public class Frame { 
private int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { 
if ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) for ( int i = 0 ; 
i < initializationCount ; 
++ i ) { 
int initializedType = initializations [ i ] ; 
int dim = initializedType & DIM_MASK ; 
int kind = initializedType & KIND_MASK ; 
int value = initializedType & VALUE_MASK ; 
if ( kind == LOCAL_KIND ) initializedType = dim + inputLocals [ value ] ; 
else if ( kind == STACK_KIND ) initializedType = dim + inputStack [ inputStack . length - value ] ; 
if ( abstractType == initializedType ) if ( abstractType == UNINITIALIZED_THIS ) return REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; 
else return REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; 
} 
return abstractType ; 
} 
} 

public class Frame { 
static void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { 
int arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; 
if ( arrayDimensions == 0 ) { 
int typeValue = abstractType & VALUE_MASK ; 
switch ( abstractType & KIND_MASK ) { 
case CONSTANT_KIND : output . putByte ( typeValue ) ; 
break ; 
case REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; 
break ; 
case UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; 
break ; 
default : throw new AssertionError ( ) ; 
} 
} 
else { 
StringBuilder typeDescriptor = new StringBuilder ( ) ; 
while ( arrayDimensions -- > 0 ) typeDescriptor . append ( '[' ) ; 
if ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) typeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; 
else switch ( abstractType & VALUE_MASK ) { 
case Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; 
break ; 
case Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; 
break ; 
case Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; 
break ; 
case Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; 
break ; 
case Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; 
break ; 
case Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; 
break ; 
case Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; 
break ; 
case Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; 
break ; 
default : throw new AssertionError ( ) ; 
} 
output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; 
} 
} 
} 

public class TimedCache { 
public void schedulePrune ( final long delay ) { 
if ( pruneTimer != null ) pruneTimer . cancel ( ) ; 
pruneTimer = new Timer ( ) ; 
pruneTimer . schedule ( new TimerTask ( ) { 
@ Override public void run ( ) { 
prune ( ) ; 
} 
} 
, delay , delay ) ; 
} 
} 

public class ClassVisitor { 
public ModuleVisitor visitModule ( final String name , final int access , final String version ) { 
if ( api < Opcodes . ASM6 ) throw new UnsupportedOperationException ( "This feature requires ASM6" ) ; 
if ( cv != null ) return cv . visitModule ( name , access , version ) ; 
return null ; 
} 
} 

public class ClassVisitor { 
public void visitNestHost ( final String nestHost ) { 
if ( api < Opcodes . ASM7 ) throw new UnsupportedOperationException ( "This feature requires ASM7" ) ; 
if ( cv != null ) cv . visitNestHost ( nestHost ) ; 
} 
} 

public class ClassVisitor { 
public void visitOuterClass ( final String owner , final String name , final String descriptor ) { 
if ( cv != null ) cv . visitOuterClass ( owner , name , descriptor ) ; 
} 
} 

public class ClassVisitor { 
public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { 
if ( cv != null ) return cv . visitAnnotation ( descriptor , visible ) ; 
return null ; 
} 
} 

public class ClassVisitor { 
public void visitNestMember ( final String nestMember ) { 
if ( api < Opcodes . ASM7 ) throw new UnsupportedOperationException ( "This feature requires ASM7" ) ; 
if ( cv != null ) cv . visitNestMember ( nestMember ) ; 
} 
} 

public class ClassVisitor { 
public void visitInnerClass ( final String name , final String outerName , final String innerName , final int access ) { 
if ( cv != null ) cv . visitInnerClass ( name , outerName , innerName , access ) ; 
} 
} 

public class ClassVisitor { 
public FieldVisitor visitField ( final int access , final String name , final String descriptor , final String signature , final Object value ) { 
if ( cv != null ) return cv . visitField ( access , name , descriptor , signature , value ) ; 
return null ; 
} 
} 

public class DbThreadSession { 
public static DbThreadSession getThreadSession ( ) { 
DbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; 
if ( session == null ) session = new DbThreadSession ( ) ; 
return session ; 
} 
} 

public class DbThreadSession { 
public static void closeThreadSession ( ) { 
DbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; 
if ( session != null ) session . closeSession ( ) ; 
} 
} 

public class ActionRequest { 
public String readRequestBody ( ) { 
if ( requestBody == null ) try { 
requestBody = ServletUtil . readRequestBodyFromStream ( getHttpServletRequest ( ) ) ; 
} 
catch ( IOException ioex ) { 
requestBody = StringPool . EMPTY ; 
} 
return requestBody ; 
} 
} 

public class PageData { 
public static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { 
if ( total == 0 ) return 0 ; 
if ( page < 1 ) page = 1 ; 
int first = ( page - 1 ) * pageSize ; 
if ( first >= total ) first = ( ( total - 1 ) / pageSize ) * pageSize ; 
return first ; 
} 
} 

public class PseudoFunctionExpression { 
public boolean match ( final int value ) { 
if ( a == 0 ) return value == b ; 
if ( a > 0 ) { 
if ( value < b ) return false ; 
return ( value - b ) % a == 0 ; 
} 
if ( value > b ) return false ; 
return ( b - value ) % ( - a ) == 0 ; 
} 
} 

public class CharUtil { 
public static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { 
for ( int i = index ; 
i < source . length ; 
i ++ ) if ( ! equalsOne ( source [ i ] , match ) ) return i ; 
return - 1 ; 
} 
} 

public class Props { 
public Props load ( final File file ) throws IOException { 
final String extension = FileNameUtil . getExtension ( file . getAbsolutePath ( ) ) ; 
final String data ; 
if ( extension . equalsIgnoreCase ( "properties" ) ) data = FileUtil . readString ( file , StringPool . ISO_8859_1 ) ; 
else data = FileUtil . readString ( file ) ; 
parse ( data ) ; 
return this ; 
} 
} 

public class Props { 
public Props load ( final Map < ? , ? > p ) { 
for ( final Map . Entry < ? , ? > entry : p . entrySet ( ) ) { 
final String name = entry . getKey ( ) . toString ( ) ; 
final Object value = entry . getValue ( ) ; 
if ( value == null ) continue ; 
data . putBaseProperty ( name , value . toString ( ) , false ) ; 
} 
return this ; 
} 
} 

public class Props { 
@ SuppressWarnings ( "unchecked" ) public Props load ( final Map < ? , ? > map , final String prefix ) { 
String realPrefix = prefix ; 
realPrefix += '.' ; 
for ( final Map . Entry entry : map . entrySet ( ) ) { 
final String name = entry . getKey ( ) . toString ( ) ; 
final Object value = entry . getValue ( ) ; 
if ( value == null ) continue ; 
data . putBaseProperty ( realPrefix + name , value . toString ( ) , false ) ; 
} 
return this ; 
} 
} 

public class Props { 
public Props loadFromClasspath ( final String ... patterns ) { 
ClassScanner . create ( ) . registerEntryConsumer ( entryData -> { 
String usedEncoding = JoddCore . encoding ; 
if ( StringUtil . endsWithIgnoreCase ( entryData . name ( ) , ".properties" ) ) usedEncoding = StringPool . ISO_8859_1 ; 
final String encoding = usedEncoding ; 
UncheckedException . runAndWrapException ( ( ) -> load ( entryData . openInputStream ( ) , encoding ) ) ; 
} 
) . includeResources ( true ) . ignoreException ( true ) . excludeCommonJars ( ) . excludeAllEntries ( true ) . includeEntries ( patterns ) . scanDefaultClasspath ( ) . start ( ) ; 
return this ; 
} 
} 

public class Props { 
public String getValueOrDefault ( final String key , final String defaultValue ) { 
initialize ( ) ; 
final String value = data . lookupValue ( key , activeProfiles ) ; 
if ( value == null ) return defaultValue ; 
return value ; 
} 
} 

public class Props { 
public void setValue ( final String key , final String value , final String profile ) { 
if ( profile == null ) data . putBaseProperty ( key , value , false ) ; 
else data . putProfileProperty ( key , value , profile , false ) ; 
initialized = false ; 
} 
} 

public class Props { 
public void addInnerMap ( String prefix , final Map < ? , ? > map , final String profile ) { 
if ( ! StringUtil . endsWithChar ( prefix , '.' ) ) prefix += StringPool . DOT ; 
for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { 
String key = entry . getKey ( ) . toString ( ) ; 
key = prefix + key ; 
setValue ( key , entry . getValue ( ) . toString ( ) , profile ) ; 
} 
} 
} 

public class Props { 
protected void resolveActiveProfiles ( ) { 
if ( activeProfilesProp == null ) { 
activeProfiles = null ; 
return ; 
} 
final PropsEntry pv = data . getBaseProperty ( activeProfilesProp ) ; 
if ( pv == null ) return ; 
final String value = pv . getValue ( ) ; 
if ( StringUtil . isBlank ( value ) ) { 
activeProfiles = null ; 
return ; 
} 
activeProfiles = StringUtil . splitc ( value , ',' ) ; 
StringUtil . trimAll ( activeProfiles ) ; 
} 
} 

public class BeanDefinition { 
protected void addPropertyInjectionPoint ( final PropertyInjectionPoint pip ) { 
if ( properties == null ) { 
properties = new PropertyInjectionPoint [ 1 ] ; 
properties [ 0 ] = pip ; 
} 
else properties = ArraysUtil . append ( properties , pip ) ; 
} 
} 

public class BeanDefinition { 
protected void addSetInjectionPoint ( final SetInjectionPoint sip ) { 
if ( sets == null ) { 
sets = new SetInjectionPoint [ 1 ] ; 
sets [ 0 ] = sip ; 
} 
else sets = ArraysUtil . append ( sets , sip ) ; 
} 
} 

public class BeanDefinition { 
protected void addMethodInjectionPoint ( final MethodInjectionPoint mip ) { 
if ( methods == null ) { 
methods = new MethodInjectionPoint [ 1 ] ; 
methods [ 0 ] = mip ; 
} 
else methods = ArraysUtil . append ( methods , mip ) ; 
} 
} 

public class BeanDefinition { 
protected void addInitMethodPoints ( final InitMethodPoint [ ] methods ) { 
if ( initMethods == null ) initMethods = methods ; 
else initMethods = ArraysUtil . join ( initMethods , methods ) ; 
} 
} 

public class BeanDefinition { 
protected void addDestroyMethodPoints ( final DestroyMethodPoint [ ] methods ) { 
if ( destroyMethods == null ) destroyMethods = methods ; 
else destroyMethods = ArraysUtil . join ( destroyMethods , methods ) ; 
} 
} 

public class ProxettaUtil { 
public static Class resolveTargetClass ( final Class proxy ) { 
final String name = proxy . getName ( ) ; 
if ( name . endsWith ( ProxettaNames . proxyClassNameSuffix ) ) return proxy . getSuperclass ( ) ; 
if ( name . endsWith ( ProxettaNames . wrapperClassNameSuffix ) ) return getTargetWrapperType ( proxy ) ; 
return proxy ; 
} 
} 

public class PropertyDescriptor { 
protected FieldDescriptor findField ( final String fieldName ) { 
FieldDescriptor fieldDescriptor = classDescriptor . getFieldDescriptor ( fieldName , true ) ; 
if ( fieldDescriptor != null ) return fieldDescriptor ; 
Class [ ] superclasses = classDescriptor . getAllSuperclasses ( ) ; 
for ( Class superclass : superclasses ) { 
ClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( superclass ) ; 
fieldDescriptor = classDescriptor . getFieldDescriptor ( fieldName , true ) ; 
if ( fieldDescriptor != null ) return fieldDescriptor ; 
} 
return null ; 
} 
} 

public class PropertyDescriptor { 
public Class getType ( ) { 
if ( type == null ) if ( fieldDescriptor != null ) type = fieldDescriptor . getRawType ( ) ; 
else if ( readMethodDescriptor != null ) type = getGetter ( true ) . getGetterRawType ( ) ; 
else if ( writeMethodDescriptor != null ) type = getSetter ( true ) . getSetterRawType ( ) ; 
return type ; 
} 
} 

public class PropertyDescriptor { 
public Class resolveKeyType ( final boolean declared ) { 
Class keyType = null ; 
Getter getter = getGetter ( declared ) ; 
if ( getter != null ) keyType = getter . getGetterRawKeyComponentType ( ) ; 
if ( keyType == null ) { 
FieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; 
if ( fieldDescriptor != null ) keyType = fieldDescriptor . getRawKeyComponentType ( ) ; 
} 
return keyType ; 
} 
} 

public class PropertyDescriptor { 
public Class resolveComponentType ( final boolean declared ) { 
Class componentType = null ; 
Getter getter = getGetter ( declared ) ; 
if ( getter != null ) componentType = getter . getGetterRawComponentType ( ) ; 
if ( componentType == null ) { 
FieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; 
if ( fieldDescriptor != null ) componentType = fieldDescriptor . getRawComponentType ( ) ; 
} 
return componentType ; 
} 
} 

public class RestActionNamingStrategy { 
protected String resolveHttpMethodFromMethodName ( final String methodName ) { 
int i = 0 ; 
while ( i < methodName . length ( ) ) { 
if ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) break ; 
i ++ ; 
} 
final String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; 
for ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { 
if ( httpMethod . equalsName ( name ) ) return httpMethod . name ( ) ; 
} 
return null ; 
} 
} 

public class Wildcard { 
private static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { 
int pLen = pattern . length ( ) ; 
if ( pLen == 1 ) if ( pattern . charAt ( 0 ) == '*' ) return true ; 
int sLen = string . length ( ) ; 
boolean nextIsNotWildcard = false ; 
while ( true ) { 
if ( ( sNdx >= sLen ) ) { 
while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) pNdx ++ ; 
return pNdx >= pLen ; 
} 
if ( pNdx >= pLen ) return false ; 
char p = pattern . charAt ( pNdx ) ; 
if ( ! nextIsNotWildcard ) { 
if ( p == '\\' ) { 
pNdx ++ ; 
nextIsNotWildcard = true ; 
continue ; 
} 
if ( p == '?' ) { 
sNdx ++ ; 
pNdx ++ ; 
continue ; 
} 
if ( p == '*' ) { 
char pNext = 0 ; 
if ( pNdx + 1 < pLen ) pNext = pattern . charAt ( pNdx + 1 ) ; 
if ( pNext == '*' ) { 
pNdx ++ ; 
continue ; 
} 
int i ; 
pNdx ++ ; 
for ( i = string . length ( ) ; 
i >= sNdx ; 
i -- ) if ( match ( string , pattern , i , pNdx ) ) return true ; 
return false ; 
} 
} 
else nextIsNotWildcard = false ; 
if ( p != string . charAt ( sNdx ) ) return false ; 
sNdx ++ ; 
pNdx ++ ; 
} 
} 
} 

public class ExtendedURLClassLoader { 
protected Loading resolveLoading ( final boolean parentFirstStrategy , final String className ) { 
boolean withParent = true ; 
boolean withLoader = true ; 
if ( parentFirstStrategy ) if ( isMatchingRules ( className , loaderOnlyRules ) ) withParent = false ; 
else if ( isMatchingRules ( className , parentOnlyRules ) ) withLoader = false ; 
else if ( isMatchingRules ( className , parentOnlyRules ) ) withLoader = false ; 
else if ( isMatchingRules ( className , loaderOnlyRules ) ) withParent = false ; 
return new Loading ( withParent , withLoader ) ; 
} 
} 

public class ExtendedURLClassLoader { 
protected Loading resolveResourceLoading ( final boolean parentFirstStrategy , String resourceName ) { 
if ( matchResourcesAsPackages ) resourceName = StringUtil . replaceChar ( resourceName , '/' , '.' ) ; 
return resolveLoading ( parentFirstStrategy , resourceName ) ; 
} 
} 

public class ExtendedURLClassLoader { 
@ Override protected synchronized Class < ? > loadClass ( final String className , final boolean resolve ) throws ClassNotFoundException { 
Class < ? > c = findLoadedClass ( className ) ; 
if ( c != null ) { 
if ( resolve ) resolveClass ( c ) ; 
return c ; 
} 
Loading loading = resolveLoading ( parentFirst , className ) ; 
if ( parentFirst ) { 
if ( loading . withParent ) try { 
c = parentClassLoader . loadClass ( className ) ; 
} 
catch ( ClassNotFoundException ignore ) { 
} 
if ( c == null ) if ( loading . withLoader ) c = this . findClass ( className ) ; 
else throw new ClassNotFoundException ( "Class not found: " + className ) ; 
} 
else { 
if ( loading . withLoader ) try { 
c = this . findClass ( className ) ; 
} 
catch ( ClassNotFoundException ignore ) { 
} 
if ( c == null ) if ( loading . withParent ) c = parentClassLoader . loadClass ( className ) ; 
else throw new ClassNotFoundException ( "Class not found: " + className ) ; 
} 
if ( resolve ) resolveClass ( c ) ; 
return c ; 
} 
} 

public class ExtendedURLClassLoader { 
@ Override public URL getResource ( final String resourceName ) { 
URL url = null ; 
Loading loading = resolveResourceLoading ( parentFirst , resourceName ) ; 
if ( parentFirst ) { 
if ( loading . withParent ) url = parentClassLoader . getResource ( resourceName ) ; 
if ( url == null ) if ( loading . withLoader ) url = this . findResource ( resourceName ) ; 
} 
else { 
if ( loading . withLoader ) url = this . findResource ( resourceName ) ; 
if ( url == null ) if ( loading . withParent ) url = parentClassLoader . getResource ( resourceName ) ; 
} 
return url ; 
} 
} 

public class StreamGobbler { 
public void waitFor ( ) { 
try { 
synchronized ( lock ) { 
if ( ! end ) lock . wait ( ) ; 
} 
} 
catch ( InterruptedException ignore ) { 
Thread . currentThread ( ) . interrupt ( ) ; 
} 
} 
} 

public class ScopeDataInspector { 
public Class < ? extends Annotation > detectAnnotationType ( final Annotation [ ] annotations ) { 
for ( final Annotation annotation : annotations ) { 
if ( annotation instanceof In ) return annotation . annotationType ( ) ; 
else if ( annotation instanceof Out ) return annotation . annotationType ( ) ; 
} 
return null ; 
} 
} 

public class TypeJsonVisitor { 
public void visit ( ) { 
ClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; 
if ( classMetadataName != null ) onProperty ( classMetadataName , null , false ) ; 
PropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; 
for ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { 
Getter getter = propertyDescriptor . getGetter ( declared ) ; 
if ( getter != null ) { 
String propertyName = propertyDescriptor . getName ( ) ; 
boolean isTransient = false ; 
FieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; 
if ( fieldDescriptor != null ) isTransient = Modifier . isTransient ( fieldDescriptor . getField ( ) . getModifiers ( ) ) ; 
onProperty ( propertyName , propertyDescriptor , isTransient ) ; 
} 
} 
} 
} 

public class ClassPathURLs { 
public static URL [ ] of ( ClassLoader classLoader , Class clazz ) { 
if ( clazz == null ) clazz = ClassPathURLs . class ; 
if ( classLoader == null ) classLoader = clazz . getClassLoader ( ) ; 
final Set < URL > urls = new LinkedHashSet < > ( ) ; 
while ( classLoader != null ) { 
if ( classLoader instanceof URLClassLoader ) { 
final URLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; 
return urlClassLoader . getURLs ( ) ; 
} 
final URL url = classModuleUrl ( classLoader , clazz ) ; 
if ( url != null ) urls . add ( url ) ; 
classLoader = classLoader . getParent ( ) ; 
} 
return urls . toArray ( new URL [ 0 ] ) ; 
} 
} 

public class BeanProperty { 
private void loadPropertyDescriptor ( ) { 
if ( updateProperty ) { 
if ( cd == null ) propertyDescriptor = null ; 
else propertyDescriptor = cd . getPropertyDescriptor ( name , true ) ; 
updateProperty = false ; 
} 
} 
} 

public class CompositeIterator { 
public void add ( final Iterator < T > iterator ) { 
if ( allIterators . contains ( iterator ) ) throw new IllegalArgumentException ( "Duplicate iterator" ) ; 
allIterators . add ( iterator ) ; 
} 
} 

public class JoddJoy { 
public void stop ( ) { 
joyProps . stop ( ) ; 
try { 
joyDb . stop ( ) ; 
joyPetite . stop ( ) ; 
} 
catch ( Exception ignore ) { 
} 
if ( log != null ) log . info ( "Joy is down. Bye, bye!" ) ; 
} 
} 

public class SocketHttpConnectionProvider { 
protected Socket createSocket ( final String host , final int port , final int connectionTimeout ) throws IOException { 
final SocketFactory socketFactory = getSocketFactory ( proxy , false , false , connectionTimeout ) ; 
if ( connectionTimeout < 0 ) return socketFactory . createSocket ( host , port ) ; 
else { 
Socket socket = socketFactory . createSocket ( ) ; 
socket . connect ( new InetSocketAddress ( host , port ) , connectionTimeout ) ; 
return socket ; 
} 
} 
} 

public class SocketHttpConnectionProvider { 
protected SSLSocket createSSLSocket ( final String host , final int port , final int connectionTimeout , final boolean trustAll , final boolean verifyHttpsHost ) throws IOException { 
final SocketFactory socketFactory = getSocketFactory ( proxy , true , trustAll , connectionTimeout ) ; 
final Socket socket ; 
if ( connectionTimeout < 0 ) socket = socketFactory . createSocket ( host , port ) ; 
else socket = Sockets . connect ( host , port , connectionTimeout ) ; 
SSLSocket sslSocket ; 
if ( socket instanceof SSLSocket ) sslSocket = ( SSLSocket ) socket ; 
else if ( socketFactory instanceof SSLSocketFactory ) sslSocket = ( SSLSocket ) ( ( SSLSocketFactory ) socketFactory ) . createSocket ( socket , host , port , true ) ; 
else sslSocket = ( SSLSocket ) ( getDefaultSSLSocketFactory ( trustAll ) ) . createSocket ( socket , host , port , true ) ; 
if ( secureEnabledProtocols != null ) { 
final String [ ] values = StringUtil . splitc ( secureEnabledProtocols , ',' ) ; 
StringUtil . trimAll ( values ) ; 
sslSocket . setEnabledProtocols ( values ) ; 
} 
if ( verifyHttpsHost ) { 
final SSLParameters sslParams = new SSLParameters ( ) ; 
sslParams . setEndpointIdentificationAlgorithm ( "HTTPS" ) ; 
sslSocket . setSSLParameters ( sslParams ) ; 
} 
return sslSocket ; 
} 
} 

public class SocketHttpConnectionProvider { 
protected SSLSocketFactory getDefaultSSLSocketFactory ( final boolean trustAllCertificates ) throws IOException { 
if ( trustAllCertificates ) try { 
SSLContext sc = SSLContext . getInstance ( sslProtocol ) ; 
sc . init ( null , TrustManagers . TRUST_ALL_CERTS , new java . security . SecureRandom ( ) ) ; 
return sc . getSocketFactory ( ) ; 
} 
catch ( NoSuchAlgorithmException | KeyManagementException e ) { 
throw new IOException ( e ) ; 
} 
else return ( SSLSocketFactory ) SSLSocketFactory . getDefault ( ) ; 
} 
} 

public class SocketHttpConnectionProvider { 
protected SocketFactory getSocketFactory ( final ProxyInfo proxy , final boolean ssl , final boolean trustAllCertificates , final int connectionTimeout ) throws IOException { 
switch ( proxy . getProxyType ( ) ) { 
case NONE : if ( ssl ) return getDefaultSSLSocketFactory ( trustAllCertificates ) ; 
else return SocketFactory . getDefault ( ) ; 
case HTTP : return new HTTPProxySocketFactory ( proxy , connectionTimeout ) ; 
case SOCKS4 : return new Socks4ProxySocketFactory ( proxy , connectionTimeout ) ; 
case SOCKS5 : return new Socks5ProxySocketFactory ( proxy , connectionTimeout ) ; 
default : return null ; 
} 
} 
} 

public class RandomString { 
public String random ( int count , final char [ ] chars ) { 
if ( count == 0 ) return StringPool . EMPTY ; 
final char [ ] result = new char [ count ] ; 
while ( count -- > 0 ) result [ count ] = chars [ rnd . nextInt ( chars . length ) ] ; 
return new String ( result ) ; 
} 
} 

public class RandomString { 
public String random ( int count , final char start , final char end ) { 
if ( count == 0 ) return StringPool . EMPTY ; 
final char [ ] result = new char [ count ] ; 
final int len = end - start + 1 ; 
while ( count -- > 0 ) result [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; 
return new String ( result ) ; 
} 
} 

public class RandomString { 
public String randomRanges ( int count , final char ... ranges ) { 
if ( count == 0 ) return StringPool . EMPTY ; 
int i = 0 ; 
int len = 0 ; 
final int [ ] lens = new int [ ranges . length ] ; 
while ( i < ranges . length ) { 
int gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; 
len += gap ; 
lens [ i ] = len ; 
i += 2 ; 
} 
final char [ ] result = new char [ count ] ; 
while ( count -- > 0 ) { 
char c = 0 ; 
int r = rnd . nextInt ( len ) ; 
for ( i = 0 ; 
i < ranges . length ; 
i += 2 ) if ( r < lens [ i ] ) { 
r += ranges [ i ] ; 
if ( i != 0 ) r -= lens [ i - 2 ] ; 
c = ( char ) r ; 
break ; 
} 
result [ count ] = c ; 
} 
return new String ( result ) ; 
} 
} 

public class JsonParserBase { 
@ SuppressWarnings ( "unchecked" ) protected Collection < Object > newArrayInstance ( final Class targetType ) { 
if ( targetType == null || targetType == List . class || targetType == Collection . class || targetType . isArray ( ) ) return listSupplier . get ( ) ; 
if ( targetType == Set . class ) return new HashSet < > ( ) ; 
try { 
return ( Collection < Object > ) targetType . getDeclaredConstructor ( ) . newInstance ( ) ; 
} 
catch ( Exception e ) { 
throw new JsonException ( e ) ; 
} 
} 
} 

public class JsonParserBase { 
protected void injectValueIntoObject ( final Object target , final PropertyDescriptor pd , final Object value ) { 
Object convertedValue = value ; 
if ( value != null ) { 
Class targetClass = pd . getType ( ) ; 
convertedValue = convertType ( value , targetClass ) ; 
} 
try { 
Setter setter = pd . getSetter ( true ) ; 
if ( setter != null ) setter . invokeSetter ( target , convertedValue ) ; 
} 
catch ( Exception ex ) { 
throw new JsonException ( ex ) ; 
} 
} 
} 

public class JsonParserBase { 
protected Object convertType ( final Object value , final Class targetType ) { 
final Class valueClass = value . getClass ( ) ; 
if ( valueClass == targetType ) return value ; 
try { 
return TypeConverterManager . get ( ) . convertType ( value , targetType ) ; 
} 
catch ( Exception ex ) { 
if ( ! strictTypes ) return null ; 
throw new JsonException ( "Type conversion failed" , ex ) ; 
} 
} 
} 

public class ModuleVisitor { 
public void visitProvide ( final String service , final String ... providers ) { 
if ( mv != null ) mv . visitProvide ( service , providers ) ; 
} 
} 

public class NetUtil { 
public static String resolveIpAddress ( final String hostname ) { 
try { 
InetAddress netAddress ; 
if ( hostname == null || hostname . equalsIgnoreCase ( LOCAL_HOST ) ) netAddress = InetAddress . getLocalHost ( ) ; 
else netAddress = Inet4Address . getByName ( hostname ) ; 
return netAddress . getHostAddress ( ) ; 
} 
catch ( UnknownHostException ignore ) { 
return null ; 
} 
} 
} 

public class NetUtil { 
public static int getIpAsInt ( final String ipAddress ) { 
int ipIntValue = 0 ; 
String [ ] tokens = StringUtil . splitc ( ipAddress , '.' ) ; 
for ( String token : tokens ) { 
if ( ipIntValue > 0 ) ipIntValue <<= 8 ; 
ipIntValue += Integer . parseInt ( token ) ; 
} 
return ipIntValue ; 
} 
} 

public class NetUtil { 
public static boolean validateAgaintIPAdressV4Format ( final String input ) { 
if ( input == null ) return false ; 
int hitDots = 0 ; 
char [ ] data = input . toCharArray ( ) ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) { 
char c = data [ i ] ; 
int b = 0 ; 
do { 
if ( c < '0' || c > '9' ) return false ; 
b = ( b * 10 + c ) - 48 ; 
if ( ++ i >= data . length ) break ; 
c = data [ i ] ; 
} 
while ( c != '.' ) ; 
if ( b > 255 ) return false ; 
hitDots ++ ; 
} 
return hitDots == 4 ; 
} 
} 

public class Sockets { 
public static Socket connect ( final String hostname , final int port , final int connectionTimeout ) throws IOException { 
final Socket socket = new Socket ( ) ; 
if ( connectionTimeout <= 0 ) socket . connect ( new InetSocketAddress ( hostname , port ) ) ; 
else socket . connect ( new InetSocketAddress ( hostname , port ) , connectionTimeout ) ; 
return socket ; 
} 
} 

public class DefaultClassLoaderStrategy { 
private static int getPrimitiveClassNameIndex ( final String className ) { 
int dotIndex = className . indexOf ( '.' ) ; 
if ( dotIndex != - 1 ) return - 1 ; 
return Arrays . binarySearch ( PRIMITIVE_TYPE_NAMES , className ) ; 
} 
} 

public class DefaultClassLoaderStrategy { 
@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { 
String arrayClassName = prepareArrayClassnameForLoading ( className ) ; 
if ( ( className . indexOf ( '.' ) == - 1 ) && ( arrayClassName == null ) ) { 
int primitiveNdx = getPrimitiveClassNameIndex ( className ) ; 
if ( primitiveNdx >= 0 ) return PRIMITIVE_TYPES [ primitiveNdx ] ; 
} 
if ( classLoader != null ) { 
Class klass = loadClass ( className , arrayClassName , classLoader ) ; 
if ( klass != null ) return klass ; 
} 
ClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
if ( ( currentThreadClassLoader != null ) && ( currentThreadClassLoader != classLoader ) ) { 
Class klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; 
if ( klass != null ) return klass ; 
} 
Class callerClass = ClassUtil . getCallerClass ( ) ; 
ClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; 
if ( ( callerClassLoader != classLoader ) && ( callerClassLoader != currentThreadClassLoader ) ) { 
Class klass = loadClass ( className , arrayClassName , callerClassLoader ) ; 
if ( klass != null ) return klass ; 
} 
if ( arrayClassName != null ) try { 
return loadArrayClassByComponentType ( className , classLoader ) ; 
} 
catch ( ClassNotFoundException ignore ) { 
} 
throw new ClassNotFoundException ( "Class not found: " + className ) ; 
} 
} 

public class DefaultClassLoaderStrategy { 
protected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { 
int ndx = className . indexOf ( '[' ) ; 
int multi = StringUtil . count ( className , '[' ) ; 
String componentTypeName = className . substring ( 0 , ndx ) ; 
Class componentType = loadClass ( componentTypeName , classLoader ) ; 
if ( multi == 1 ) return Array . newInstance ( componentType , 0 ) . getClass ( ) ; 
int [ ] multiSizes ; 
if ( multi == 2 ) multiSizes = new int [ ] { 
0 , 0 } 
; 
else if ( multi == 3 ) multiSizes = new int [ ] { 
0 , 0 , 0 } 
; 
else multiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; 
return Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; 
} 
} 

public class DbOomQuery { 
protected void resolveColumnDbSqlType ( final Connection connection , final DbEntityColumnDescriptor dec ) { 
if ( dec . dbSqlType != SqlType . DB_SQLTYPE_UNKNOWN ) return ; 
ResultSet rs = null ; 
DbEntityDescriptor ded = dec . getDbEntityDescriptor ( ) ; 
try { 
DatabaseMetaData dmd = connection . getMetaData ( ) ; 
rs = dmd . getColumns ( null , ded . getSchemaName ( ) , ded . getTableName ( ) , dec . getColumnName ( ) ) ; 
if ( rs . next ( ) ) dec . dbSqlType = rs . getInt ( "DATA_TYPE" ) ; 
else { 
dec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; 
if ( log . isWarnEnabled ( ) ) log . warn ( "Column SQL type not available: " + ded . toString ( ) + '.' + dec . getColumnName ( ) ) ; 
} 
} 
catch ( SQLException sex ) { 
dec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; 
if ( log . isWarnEnabled ( ) ) log . warn ( "Column SQL type not resolved: " + ded . toString ( ) + '.' + dec . getColumnName ( ) , sex ) ; 
} 
finally { 
DbUtil . close ( rs ) ; 
} 
} 
} 

public class DbOomQuery { 
protected String preprocessSql ( String sqlString ) { 
if ( sqlString . charAt ( 0 ) == '{' ) return sqlString ; 
if ( ! CharUtil . isAlpha ( sqlString . charAt ( 0 ) ) ) sqlString = sqlString . substring ( 1 ) ; 
else if ( sqlString . indexOf ( ' ' ) != - 1 ) return sqlString ; 
final String sqlFromMap = dbOom . queryMap ( ) . getQuery ( sqlString ) ; 
if ( sqlFromMap != null ) sqlString = sqlFromMap . trim ( ) ; 
return sqlString ; 
} 
} 

public class DbOomQuery { 
public void populateGeneratedKeys ( final Object entity ) { 
final String [ ] generatedColumns = getGeneratedColumnNames ( ) ; 
if ( generatedColumns == null ) return ; 
DbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; 
Class [ ] keyTypes = new Class [ generatedColumns . length ] ; 
String [ ] properties = new String [ generatedColumns . length ] ; 
for ( int i = 0 ; 
i < generatedColumns . length ; 
i ++ ) { 
String column = generatedColumns [ i ] ; 
DbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; 
if ( decd != null ) { 
keyTypes [ i ] = decd . getPropertyType ( ) ; 
properties [ i ] = decd . getPropertyName ( ) ; 
} 
} 
final Object keyValues = findGeneratedColumns ( keyTypes ) ; 
if ( ! keyValues . getClass ( ) . isArray ( ) ) BeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; 
else for ( int i = 0 ; 
i < properties . length ; 
i ++ ) BeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; 
} 
} 

public class DbQuery { 
public Q setBean ( final String beanName , final Object bean ) { 
if ( bean == null ) return _this ( ) ; 
init ( ) ; 
final String beanNamePrefix = beanName + '.' ; 
query . forEachNamedParameter ( p -> { 
final String paramName = p . name ; 
if ( paramName . startsWith ( beanNamePrefix ) ) { 
final String propertyName = paramName . substring ( beanNamePrefix . length ( ) ) ; 
if ( BeanUtil . declared . hasRootProperty ( bean , propertyName ) ) { 
final Object value = BeanUtil . declared . getProperty ( bean , propertyName ) ; 
setObject ( paramName , value ) ; 
} 
} 
} 
) ; 
return _this ( ) ; 
} 
} 

public class DbQuery { 
public Q setMap ( final Map parameters ) { 
if ( parameters == null ) return _this ( ) ; 
init ( ) ; 
query . forEachNamedParameter ( p -> { 
final String paramName = p . name ; 
setObject ( paramName , parameters . get ( paramName ) ) ; 
} 
) ; 
return _this ( ) ; 
} 
} 

public class SqlChunk { 
protected DbEntityDescriptor lookupType ( final Class entity ) { 
final DbEntityDescriptor ded = dbEntityManager . lookupType ( entity ) ; 
if ( ded == null ) throw new DbSqlBuilderException ( "Invalid or not-persistent entity: " + entity . getName ( ) ) ; 
return ded ; 
} 
} 

public class SqlChunk { 
protected DbEntityDescriptor findColumnRef ( final String columnRef ) { 
DbEntityDescriptor ded = templateData . findTableDescriptorByColumnRef ( columnRef ) ; 
if ( ded == null ) throw new DbSqlBuilderException ( "Invalid column reference: [" + columnRef + "]" ) ; 
return ded ; 
} 
} 

public class SqlChunk { 
protected String resolveTable ( final String tableRef , final DbEntityDescriptor ded ) { 
String tableAlias = templateData . getTableAlias ( tableRef ) ; 
if ( tableAlias != null ) return tableAlias ; 
return ded . getTableNameForQuery ( ) ; 
} 
} 

public class SqlChunk { 
protected void appendMissingSpace ( final StringBuilder out ) { 
int len = out . length ( ) ; 
if ( len == 0 ) return ; 
len -- ; 
if ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) out . append ( ' ' ) ; 
} 
} 

public class MultipartRequestWrapper { 
public Enumeration < String > getFileParameterNames ( ) { 
if ( mreq == null ) return null ; 
return Collections . enumeration ( mreq . getFileParameterNames ( ) ) ; 
} 
} 

public class DispatcherUtil { 
public static String getUrl ( final HttpServletRequest request ) { 
String servletPath = request . getServletPath ( ) ; 
String query = request . getQueryString ( ) ; 
if ( ( query != null ) && ( query . length ( ) != 0 ) ) servletPath += '?' + query ; 
return servletPath ; 
} 
} 

public class DispatcherUtil { 
public static String getRequestUri ( final HttpServletRequest request ) { 
String result = getIncludeRequestUri ( request ) ; 
if ( result == null ) result = request . getRequestURI ( ) ; 
return result ; 
} 
} 

public class ActionMethodParamNameResolver { 
public String [ ] resolveParamNames ( final Method actionClassMethod ) { 
MethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; 
String [ ] names = new String [ methodParameters . length ] ; 
for ( int i = 0 ; 
i < methodParameters . length ; 
i ++ ) names [ i ] = methodParameters [ i ] . getName ( ) ; 
return names ; 
} 
} 

public class JoyPetite { 
@ Override public void start ( ) { 
initLogger ( ) ; 
log . info ( "PETITE start  ----------" ) ; 
petiteContainer = createPetiteContainer ( ) ; 
if ( externalsCache ) petiteContainer . setExternalsCache ( TypeCache . createDefault ( ) ) ; 
log . info ( "Web application? " + isWebApplication ) ; 
if ( ! isWebApplication ) petiteContainer . registerScope ( SessionScope . class , new SingletonScope ( petiteContainer ) ) ; 
petiteContainer . defineParameters ( joyPropsSupplier . get ( ) . getProps ( ) ) ; 
if ( autoConfiguration ) { 
final AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator ( petiteContainer ) ; 
automagicPetiteConfigurator . registerAsConsumer ( joyScannerSupplier . get ( ) . getClassScanner ( ) ) ; 
} 
petiteContainerConsumers . accept ( this . petiteContainer ) ; 
log . info ( "PETITE OK!" ) ; 
} 
} 

public class JoyPetite { 
@ Override public void stop ( ) { 
if ( log != null ) log . info ( "PETITE stop" ) ; 
if ( petiteContainer != null ) petiteContainer . shutdown ( ) ; 
petiteContainer = null ; 
} 
} 

public class EmailFilter { 
public EmailFilter and ( final EmailFilter ... emailFilters ) { 
final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; 
for ( int i = 0 ; 
i < emailFilters . length ; 
i ++ ) searchTerms [ i ] = emailFilters [ i ] . searchTerm ; 
concat ( new AndTerm ( searchTerms ) ) ; 
return this ; 
} 
} 

public class EmailFilter { 
public EmailFilter or ( final EmailFilter ... emailFilters ) { 
final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; 
for ( int i = 0 ; 
i < emailFilters . length ; 
i ++ ) searchTerms [ i ] = emailFilters [ i ] . searchTerm ; 
concat ( new OrTerm ( searchTerms ) ) ; 
return this ; 
} 
} 

public class EmailFilter { 
protected void concat ( SearchTerm searchTerm ) { 
if ( nextIsNot ) { 
searchTerm = new NotTerm ( searchTerm ) ; 
nextIsNot = false ; 
} 
if ( operatorAnd ) and ( searchTerm ) ; 
else or ( searchTerm ) ; 
} 
} 

public class ByteArrayConverter { 
protected byte [ ] convertValueToArray ( final Object value ) { 
if ( value instanceof Blob ) { 
final Blob blob = ( Blob ) value ; 
try { 
final long length = blob . length ( ) ; 
if ( length > Integer . MAX_VALUE ) throw new TypeConversionException ( "Blob is too big." ) ; 
return blob . getBytes ( 1 , ( int ) length ) ; 
} 
catch ( SQLException sex ) { 
throw new TypeConversionException ( value , sex ) ; 
} 
} 
if ( value instanceof File ) try { 
return FileUtil . readBytes ( ( File ) value ) ; 
} 
catch ( IOException ioex ) { 
throw new TypeConversionException ( value , ioex ) ; 
} 
if ( value instanceof Collection ) { 
final Collection collection = ( Collection ) value ; 
final byte [ ] target = new byte [ collection . size ( ) ] ; 
int i = 0 ; 
for ( final Object element : collection ) { 
target [ i ] = convertType ( element ) ; 
i ++ ; 
} 
return target ; 
} 
if ( value instanceof Iterable ) { 
final Iterable iterable = ( Iterable ) value ; 
final ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; 
for ( final Object element : iterable ) { 
final byte convertedValue = convertType ( element ) ; 
byteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; 
} 
final byte [ ] array = new byte [ byteArrayList . size ( ) ] ; 
for ( int i = 0 ; 
i < byteArrayList . size ( ) ; 
i ++ ) { 
final Byte b = byteArrayList . get ( i ) ; 
array [ i ] = b . byteValue ( ) ; 
} 
return array ; 
} 
if ( value instanceof CharSequence ) { 
final String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; 
return convertArrayToArray ( strings ) ; 
} 
return convertToSingleElementArray ( value ) ; 
} 
} 

public class GzipFilter { 
protected boolean isGzipEligible ( final HttpServletRequest request ) { 
if ( requestParameterName . length ( ) != 0 ) { 
String forceGzipString = request . getParameter ( requestParameterName ) ; 
if ( forceGzipString != null ) return Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; 
} 
String uri = request . getRequestURI ( ) ; 
if ( uri == null ) return false ; 
uri = uri . toLowerCase ( ) ; 
boolean result = false ; 
if ( matches == null ) { 
if ( extensions == null ) return true ; 
String extension = FileNameUtil . getExtension ( uri ) ; 
if ( extension . length ( ) > 0 ) { 
extension = extension . toLowerCase ( ) ; 
if ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) result = true ; 
} 
} 
else if ( wildcards ) result = Wildcard . matchPathOne ( uri , matches ) != - 1 ; 
else for ( String match : matches ) { 
if ( uri . contains ( match ) ) { 
result = true ; 
break ; 
} 
} 
if ( ( result ) && ( excludes != null ) ) if ( wildcards ) if ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) result = false ; 
else for ( String exclude : excludes ) { 
if ( uri . contains ( exclude ) ) { 
result = false ; 
break ; 
} 
} 
return result ; 
} 
} 

public class Vtor { 
public List < Violation > validate ( final ValidationContext ctx , final Object target , final String targetName ) { 
for ( Map . Entry < String , List < Check > > entry : ctx . map . entrySet ( ) ) { 
String name = entry . getKey ( ) ; 
Object value = BeanUtil . declaredSilent . getProperty ( target , name ) ; 
String valueName = targetName != null ? ( targetName + '.' + name ) : name ; 
ValidationConstraintContext vcc = new ValidationConstraintContext ( this , target , valueName ) ; 
for ( Check check : entry . getValue ( ) ) { 
String [ ] checkProfiles = check . getProfiles ( ) ; 
if ( ! matchProfiles ( checkProfiles ) ) continue ; 
if ( check . getSeverity ( ) < severity ) continue ; 
ValidationConstraint constraint = check . getConstraint ( ) ; 
if ( ! constraint . isValid ( vcc , value ) ) addViolation ( new Violation ( valueName , target , value , check ) ) ; 
} 
} 
return getViolations ( ) ; 
} 
} 

public class Vtor { 
public void useProfile ( final String profile ) { 
if ( profile == null ) return ; 
if ( this . enabledProfiles == null ) this . enabledProfiles = new HashSet < > ( ) ; 
this . enabledProfiles . add ( profile ) ; 
} 
} 

public class Vtor { 
public void useProfiles ( final String ... enabledProfiles ) { 
if ( enabledProfiles == null ) return ; 
if ( this . enabledProfiles == null ) this . enabledProfiles = new HashSet < > ( ) ; 
Collections . addAll ( this . enabledProfiles , enabledProfiles ) ; 
} 
} 

public class Vtor { 
protected boolean matchProfiles ( final String [ ] checkProfiles ) { 
if ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) return true ; 
if ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { 
if ( validateAllProfilesByDefault ) return true ; 
if ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) return true ; 
for ( String profile : checkProfiles ) { 
if ( StringUtil . isEmpty ( profile ) ) return true ; 
if ( profile . equals ( DEFAULT_PROFILE ) ) return true ; 
} 
return false ; 
} 
if ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) return enabledProfiles . contains ( DEFAULT_PROFILE ) ; 
boolean result = false ; 
for ( String profile : checkProfiles ) { 
boolean b = true ; 
boolean must = false ; 
if ( StringUtil . isEmpty ( profile ) ) profile = DEFAULT_PROFILE ; 
else if ( profile . charAt ( 0 ) == '-' ) { 
profile = profile . substring ( 1 ) ; 
b = false ; 
} 
else if ( profile . charAt ( 0 ) == '+' ) { 
profile = profile . substring ( 1 ) ; 
must = true ; 
} 
if ( enabledProfiles . contains ( profile ) ) { 
if ( ! b ) return false ; 
result = true ; 
} 
else if ( must ) return false ; 
} 
return result ; 
} 
} 

public class LagartoParser { 
protected void emitComment ( final int from , final int to ) { 
if ( config . enableConditionalComments ) { 
if ( match ( CC_IF , from ) ) { 
int endBracketNdx = find ( ']' , from + 3 , to ) ; 
CharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; 
ndx = endBracketNdx + 1 ; 
char c = input [ ndx ] ; 
if ( c != '>' ) errorInvalidToken ( ) ; 
visitor . condComment ( expression , true , true , false ) ; 
state = DATA_STATE ; 
return ; 
} 
if ( to > CC_ENDIF2 . length && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { 
visitor . condComment ( _ENDIF , false , true , true ) ; 
state = DATA_STATE ; 
return ; 
} 
} 
CharSequence comment = charSequence ( from , to ) ; 
visitor . comment ( comment ) ; 
commentStart = - 1 ; 
} 
} 

public class LagartoParser { 
protected void _error ( String message ) { 
if ( config . calculatePosition ) { 
Position currentPosition = position ( ndx ) ; 
message = message . concat ( StringPool . SPACE ) . concat ( currentPosition . toString ( ) ) ; 
} 
else message = message . concat ( " [@" ) . concat ( Integer . toString ( ndx ) ) . concat ( StringPool . RIGHT_SQ_BRACKET ) ; 
visitor . error ( message ) ; 
} 
} 

public class PBKDF2Hash { 
private static byte [ ] fromHex ( final String hex ) { 
final byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; 
for ( int i = 0 ; 
i < binary . length ; 
i ++ ) binary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; 
return binary ; 
} 
} 

public class EmailAttachmentBuilder { 
public EmailAttachmentBuilder name ( final String name ) { 
if ( name != null && ! name . trim ( ) . isEmpty ( ) ) this . name = name ; 
return this ; 
} 
} 

public class EmailAttachmentBuilder { 
protected EmailAttachmentBuilder setContentIdFromNameIfMissing ( ) { 
if ( contentId == null ) if ( name != null ) contentId ( FileNameUtil . getName ( name ) ) ; 
else contentId ( NO_NAME ) ; 
return this ; 
} 
} 

public class EmailAttachmentBuilder { 
protected String resolveContentType ( final String contentType ) { 
if ( contentType != null ) return contentType ; 
if ( name == null ) return MimeTypes . MIME_APPLICATION_OCTET_STREAM ; 
final String extension = FileNameUtil . getExtension ( name ) ; 
return MimeTypes . getMimeType ( extension ) ; 
} 
} 

public class SignatureReader { 
private static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { 
int offset = startOffset ; 
char currentChar = signature . charAt ( offset ++ ) ; 
switch ( currentChar ) { 
case 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; 
return offset ; 
case '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; 
case 'T' : int endOffset = signature . indexOf ( ';' , offset ) ; 
signatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; 
return endOffset + 1 ; 
case 'L' : int start = offset ; 
boolean visited = false ; 
boolean inner = false ; 
while ( true ) { 
currentChar = signature . charAt ( offset ++ ) ; 
if ( currentChar == '.' || currentChar == ';' ) { 
if ( ! visited ) { 
String name = signature . substring ( start , offset - 1 ) ; 
if ( inner ) signatureVisitor . visitInnerClassType ( name ) ; 
else signatureVisitor . visitClassType ( name ) ; 
} 
if ( currentChar == ';' ) { 
signatureVisitor . visitEnd ( ) ; 
break ; 
} 
start = offset ; 
visited = false ; 
inner = true ; 
} 
else if ( currentChar == '<' ) { 
String name = signature . substring ( start , offset - 1 ) ; 
if ( inner ) signatureVisitor . visitInnerClassType ( name ) ; 
else signatureVisitor . visitClassType ( name ) ; 
visited = true ; 
while ( ( currentChar = signature . charAt ( offset ) ) != '>' ) switch ( currentChar ) { 
case '*' : ++ offset ; 
signatureVisitor . visitTypeArgument ( ) ; 
break ; 
case '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; 
break ; 
default : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; 
break ; 
} 
} 
} 
return offset ; 
default : throw new IllegalArgumentException ( ) ; 
} 
} 
} 

public class ModuleWriter { 
void putAttributes ( final ByteVector output ) { 
int moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; 
if ( packageCount > 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; 
if ( mainClassIndex > 0 ) output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; 
} 
} 

public class JoyDb { 
protected void checkConnectionProvider ( ) { 
final Connection connection = connectionProvider . getConnection ( ) ; 
try { 
final DatabaseMetaData databaseMetaData = connection . getMetaData ( ) ; 
String name = databaseMetaData . getDatabaseProductName ( ) ; 
String version = databaseMetaData . getDatabaseProductVersion ( ) ; 
if ( log . isInfoEnabled ( ) ) log . info ( "Connected to database: " + name + " v" + version ) ; 
} 
catch ( SQLException sex ) { 
log . error ( "DB connection failed: " , sex ) ; 
} 
finally { 
connectionProvider . closeConnection ( connection ) ; 
} 
} 
} 

public class TargetClassInfoReader { 
@ Override public void visitEnd ( ) { 
if ( classAnnotations != null ) { 
annotations = classAnnotations . toArray ( new AnnotationInfo [ 0 ] ) ; 
classAnnotations = null ; 
} 
List < String > superList = new ArrayList < > ( ) ; 
Set < String > allInterfaces = new HashSet < > ( ) ; 
if ( nextInterfaces != null ) allInterfaces . addAll ( nextInterfaces ) ; 
while ( nextSupername != null ) { 
InputStream inputStream = null ; 
ClassReader cr ; 
try { 
inputStream = ClassLoaderUtil . getClassAsStream ( nextSupername , classLoader ) ; 
cr = new ClassReader ( inputStream ) ; 
} 
catch ( IOException ioex ) { 
throw new ProxettaException ( "Unable to inspect super class: " + nextSupername , ioex ) ; 
} 
finally { 
StreamUtil . close ( inputStream ) ; 
} 
superList . add ( nextSupername ) ; 
superClassReaders . add ( cr ) ; 
cr . accept ( new SuperClassVisitor ( ) , 0 ) ; 
if ( cr . getInterfaces ( ) != null ) Collections . addAll ( allInterfaces , cr . getInterfaces ( ) ) ; 
} 
superClasses = superList . toArray ( new String [ 0 ] ) ; 
Set < String > todoInterfaces = new HashSet < > ( allInterfaces ) ; 
Set < String > newCollectedInterfaces = new HashSet < > ( ) ; 
while ( true ) { 
for ( String next : todoInterfaces ) { 
InputStream inputStream = null ; 
ClassReader cr ; 
try { 
inputStream = ClassLoaderUtil . getClassAsStream ( next , classLoader ) ; 
cr = new ClassReader ( inputStream ) ; 
} 
catch ( IOException ioex ) { 
throw new ProxettaException ( "Unable to inspect super interface: " + next , ioex ) ; 
} 
finally { 
StreamUtil . close ( inputStream ) ; 
} 
superClassReaders . add ( cr ) ; 
cr . accept ( new SuperClassVisitor ( ) , 0 ) ; 
if ( cr . getInterfaces ( ) != null ) for ( String newInterface : cr . getInterfaces ( ) ) { 
if ( ! allInterfaces . contains ( newInterface ) && ! todoInterfaces . contains ( newInterface ) ) newCollectedInterfaces . add ( newInterface ) ; 
} 
} 
allInterfaces . addAll ( todoInterfaces ) ; 
if ( newCollectedInterfaces . isEmpty ( ) ) break ; 
todoInterfaces . clear ( ) ; 
todoInterfaces . addAll ( newCollectedInterfaces ) ; 
newCollectedInterfaces . clear ( ) ; 
} 
} 
} 

public class CsvUtil { 
public static String toCsvString ( final Object ... elements ) { 
StringBuilder line = new StringBuilder ( ) ; 
int last = elements . length - 1 ; 
for ( int i = 0 ; 
i < elements . length ; 
i ++ ) { 
if ( elements [ i ] == null ) { 
if ( i != last ) line . append ( FIELD_SEPARATOR ) ; 
continue ; 
} 
String field = elements [ i ] . toString ( ) ; 
int ndx = field . indexOf ( FIELD_SEPARATOR ) ; 
if ( ndx == - 1 ) ndx = field . indexOf ( FIELD_QUOTE ) ; 
if ( ndx == - 1 ) if ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) ndx = 1 ; 
if ( ndx == - 1 ) ndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; 
if ( ndx != - 1 ) line . append ( FIELD_QUOTE ) ; 
field = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; 
line . append ( field ) ; 
if ( ndx != - 1 ) line . append ( FIELD_QUOTE ) ; 
if ( i != last ) line . append ( FIELD_SEPARATOR ) ; 
} 
return line . toString ( ) ; 
} 
} 

public class CsvUtil { 
public static String [ ] toStringArray ( final String line ) { 
List < String > row = new ArrayList < > ( ) ; 
boolean inQuotedField = false ; 
int fieldStart = 0 ; 
final int len = line . length ( ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c = line . charAt ( i ) ; 
if ( c == FIELD_SEPARATOR ) if ( ! inQuotedField ) { 
addField ( row , line , fieldStart , i , inQuotedField ) ; 
fieldStart = i + 1 ; 
} 
else if ( c == FIELD_QUOTE ) if ( inQuotedField ) if ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { 
addField ( row , line , fieldStart , i , inQuotedField ) ; 
fieldStart = i + 2 ; 
i ++ ; 
inQuotedField = false ; 
} 
else if ( fieldStart == i ) { 
inQuotedField = true ; 
fieldStart ++ ; 
} 
} 
if ( len > 0 && fieldStart <= len ) addField ( row , line , fieldStart , len , inQuotedField ) ; 
return row . toArray ( new String [ 0 ] ) ; 
} 
} 

public class CtorResolver { 
public CtorInjectionPoint resolve ( final Class type , final boolean useAnnotation ) { 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; 
CtorDescriptor [ ] allCtors = cd . getAllCtorDescriptors ( ) ; 
Constructor foundedCtor = null ; 
Constructor defaultCtor = null ; 
BeanReferences [ ] references = null ; 
for ( CtorDescriptor ctorDescriptor : allCtors ) { 
Constructor < ? > ctor = ctorDescriptor . getConstructor ( ) ; 
Class < ? > [ ] paramTypes = ctor . getParameterTypes ( ) ; 
if ( paramTypes . length == 0 ) defaultCtor = ctor ; 
if ( ! useAnnotation ) continue ; 
BeanReferences [ ] ctorReferences = referencesResolver . readAllReferencesFromAnnotation ( ctor ) ; 
if ( ctorReferences == null ) continue ; 
if ( foundedCtor != null ) throw new PetiteException ( "Two or more constructors are annotated as injection points in the bean: " + type . getName ( ) ) ; 
foundedCtor = ctor ; 
references = ctorReferences ; 
} 
if ( foundedCtor == null ) { 
if ( allCtors . length == 1 ) foundedCtor = allCtors [ 0 ] . getConstructor ( ) ; 
else foundedCtor = defaultCtor ; 
if ( foundedCtor == null ) return CtorInjectionPoint . EMPTY ; 
references = referencesResolver . readAllReferencesFromAnnotation ( foundedCtor ) ; 
if ( references == null ) references = new BeanReferences [ 0 ] ; 
} 
return new CtorInjectionPoint ( foundedCtor , references ) ; 
} 
} 

public class ProxyAspectData { 
private ClassReader getCachedAdviceClassReader ( final Class < ? extends ProxyAdvice > advice ) { 
if ( adviceClassReaderCache == null ) adviceClassReaderCache = TypeCache . createDefault ( ) ; 
ClassReader adviceReader = adviceClassReaderCache . get ( advice ) ; 
if ( adviceReader == null ) { 
adviceReader = createAdviceClassReader ( advice ) ; 
adviceClassReaderCache . put ( advice , adviceReader ) ; 
} 
return adviceReader ; 
} 
} 

public class LoggerFactory { 
public static Logger getLogger ( final String name ) { 
if ( loggers == null ) return loggerProvider . apply ( name ) ; 
return loggers . computeIfAbsent ( name , loggerProvider ) ; 
} 
} 

public class Cookie { 
private void setName ( final String name ) { 
if ( name . contains ( ";" ) || name . contains ( "," ) || name . startsWith ( "$" ) ) throw new IllegalArgumentException ( "Invalid cookie name:" + name ) ; 
for ( int n = 0 ; 
n < name . length ( ) ; 
n ++ ) { 
char c = name . charAt ( n ) ; 
if ( c <= 0x20 || c >= 0x7f ) throw new IllegalArgumentException ( "Invalid cookie name:" + name ) ; 
} 
this . name = name ; 
} 
} 

public class ShutdownAwareScope { 
protected void destroyBean ( final BeanData beanData ) { 
if ( destroyableBeans == null ) return ; 
if ( ! isBeanDestroyable ( beanData ) ) return ; 
if ( destroyableBeans . remove ( beanData ) ) beanData . callDestroyMethods ( ) ; 
} 
} 

public class ShutdownAwareScope { 
@ Override public void shutdown ( ) { 
if ( destroyableBeans == null ) return ; 
for ( final BeanData destroyableBean : destroyableBeans ) { 
destroyableBean . callDestroyMethods ( ) ; 
} 
destroyableBeans . clear ( ) ; 
} 
} 

public class ReceiverBuilder { 
public ReceivedEmail [ ] get ( ) { 
if ( fromFolder != null ) session . useFolder ( fromFolder ) ; 
return session . receiveMessages ( filter , flagsToSet , flagsToUnset , envelopeOnly , messages -> { 
if ( targetFolder != null ) try { 
session . folder . copyMessages ( messages , session . getFolder ( targetFolder ) ) ; 
} 
catch ( MessagingException e ) { 
throw new MailException ( "Copying messages failed" ) ; 
} 
} 
) ; 
} 
} 

public class ReplayMerge { 
public void close ( ) { 
final State state = this . state ; 
if ( State . CLOSED != state ) { 
if ( isReplayActive ) { 
isReplayActive = false ; 
archive . stopReplay ( replaySessionId ) ; 
} 
if ( State . MERGED != state ) subscription . removeDestination ( replayDestination ) ; 
state ( State . CLOSED ) ; 
} 
} 
} 

public class Publication { 
public long position ( ) { 
if ( isClosed ) return CLOSED ; 
final long rawTail = rawTailVolatile ( logMetaDataBuffer ) ; 
final int termOffset = termOffset ( rawTail , termBufferLength ) ; 
return computePosition ( termId ( rawTail ) , termOffset , positionBitsToShift , initialTermId ) ; 
} 
} 

public class ExclusivePublication { 
public long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { 
final int length = DirectBufferVector . validateAndComputeLength ( vectors ) ; 
long newPosition = CLOSED ; 
if ( ! isClosed ) { 
final long limit = positionLimit . getVolatile ( ) ; 
final ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; 
final long position = termBeginPosition + termOffset ; 
if ( position < limit ) { 
final int result ; 
if ( length <= maxPayloadLength ) result = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; 
else { 
checkMaxMessageLength ( length ) ; 
result = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; 
} 
newPosition = newPosition ( result ) ; 
} 
else newPosition = backPressureStatus ( position , length ) ; 
} 
return newPosition ; 
} 
} 

public class ExclusivePublication { 
public long appendPadding ( final int length ) { 
checkMaxMessageLength ( length ) ; 
long newPosition = CLOSED ; 
if ( ! isClosed ) { 
final long limit = positionLimit . getVolatile ( ) ; 
final ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; 
final long position = termBeginPosition + termOffset ; 
if ( position < limit ) { 
checkPositiveLength ( length ) ; 
final int result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; 
newPosition = newPosition ( result ) ; 
} 
else newPosition = backPressureStatus ( position , length ) ; 
} 
return newPosition ; 
} 
} 

public class AeronArchive { 
public String pollForErrorResponse ( ) { 
lock . lock ( ) ; 
try { 
ensureOpen ( ) ; 
if ( controlResponsePoller . poll ( ) != 0 && controlResponsePoller . isPollComplete ( ) ) if ( controlResponsePoller . controlSessionId ( ) == controlSessionId && controlResponsePoller . templateId ( ) == ControlResponseDecoder . TEMPLATE_ID && controlResponsePoller . code ( ) == ControlResponseCode . ERROR ) return controlResponsePoller . errorMessage ( ) ; 
return null ; 
} 
finally { 
lock . unlock ( ) ; 
} 
} 
} 

public class AeronArchive { 
public void stopReplay ( final long replaySessionId ) { 
lock . lock ( ) ; 
try { 
ensureOpen ( ) ; 
final long correlationId = aeron . nextCorrelationId ( ) ; 
if ( ! archiveProxy . stopReplay ( replaySessionId , correlationId , controlSessionId ) ) throw new ArchiveException ( "failed to send stop replay request" ) ; 
pollForResponse ( correlationId ) ; 
} 
finally { 
lock . unlock ( ) ; 
} 
} 
} 

public class StatusUtil { 
public static StatusIndicatorReader sendChannelStatus ( final CountersReader countersReader , final String channel ) { 
StatusIndicatorReader statusReader = null ; 
final MutableInteger id = new MutableInteger ( - 1 ) ; 
countersReader . forEach ( ( counterId , typeId , keyBuffer , label ) -> { 
if ( typeId == SendChannelStatus . SEND_CHANNEL_STATUS_TYPE_ID ) if ( channel . startsWith ( keyBuffer . getStringAscii ( ChannelEndpointStatus . CHANNEL_OFFSET ) ) ) id . value = counterId ; 
} 
) ; 
if ( Aeron . NULL_VALUE != id . value ) statusReader = new UnsafeBufferStatusIndicator ( countersReader . valuesBuffer ( ) , id . value ) ; 
return statusReader ; 
} 
} 

public class StatusUtil { 
public static StatusIndicatorReader receiveChannelStatus ( final CountersReader countersReader , final String channel ) { 
StatusIndicatorReader statusReader = null ; 
final MutableInteger id = new MutableInteger ( - 1 ) ; 
countersReader . forEach ( ( counterId , typeId , keyBuffer , label ) -> { 
if ( typeId == ReceiveChannelStatus . RECEIVE_CHANNEL_STATUS_TYPE_ID ) if ( channel . startsWith ( keyBuffer . getStringAscii ( ChannelEndpointStatus . CHANNEL_OFFSET ) ) ) id . value = counterId ; 
} 
) ; 
if ( Aeron . NULL_VALUE != id . value ) statusReader = new UnsafeBufferStatusIndicator ( countersReader . valuesBuffer ( ) , id . value ) ; 
return statusReader ; 
} 
} 

public class BufferBuilder { 
public void limit ( final int limit ) { 
if ( limit < 0 || limit >= buffer . capacity ( ) ) throw new IllegalArgumentException ( "limit outside range: capacity=" + buffer . capacity ( ) + " limit=" + limit ) ; 
this . limit = limit ; 
} 
} 

public class CounterMessageFlyweight { 
public CounterMessageFlyweight keyBuffer ( final DirectBuffer keyBuffer , final int keyOffset , final int keyLength ) { 
buffer . putInt ( KEY_LENGTH_OFFSET , keyLength ) ; 
if ( null != keyBuffer && keyLength > 0 ) buffer . putBytes ( keyBufferOffset ( ) , keyBuffer , keyOffset , keyLength ) ; 
return this ; 
} 
} 

public class UdpChannel { 
public boolean matchesTag ( final UdpChannel udpChannel ) { 
if ( ! hasTag || ! udpChannel . hasTag ( ) || tag != udpChannel . tag ( ) ) return false ; 
if ( udpChannel . remoteData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . remoteData ( ) . getPort ( ) == 0 && udpChannel . localData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . localData ( ) . getPort ( ) == 0 ) return true ; 
throw new IllegalArgumentException ( "matching tag has set endpoint or control address" ) ; 
} 
} 

public class UdpChannel { 
public String description ( ) { 
final StringBuilder builder = new StringBuilder ( "UdpChannel - " ) ; 
if ( null != localInterface ) builder . append ( "interface: " ) . append ( localInterface . getDisplayName ( ) ) . append ( ", " ) ; 
builder . append ( "localData: " ) . append ( localData ) . append ( ", remoteData: " ) . append ( remoteData ) . append ( ", ttl: " ) . append ( multicastTtl ) ; 
return builder . toString ( ) ; 
} 
} 

public class PublicationImage { 
void addDestination ( final int transportIndex , final ReceiveDestinationUdpTransport transport ) { 
imageConnections = ArrayUtil . ensureCapacity ( imageConnections , transportIndex + 1 ) ; 
if ( transport . isMulticast ( ) ) imageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . udpChannel ( ) . remoteControl ( ) ) ; 
else if ( transport . hasExplicitControl ( ) ) imageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . explicitControlAddress ( ) ) ; 
} 
} 

public class ClusterControl { 
public static AtomicCounter findControlToggle ( final CountersReader counters ) { 
final AtomicBuffer buffer = counters . metaDataBuffer ( ) ; 
for ( int i = 0 , size = counters . maxCounterId ( ) ; 
i < size ; 
i ++ ) { 
final int recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) return new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; 
} 
return null ; 
} 
} 

public class ExclusiveTermAppender { 
public int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { 
final int frameLength = length + HEADER_LENGTH ; 
final int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; 
final UnsafeBuffer termBuffer = this . termBuffer ; 
final int termLength = termBuffer . capacity ( ) ; 
int resultingOffset = termOffset + alignedLength ; 
putRawTailOrdered ( termId , resultingOffset ) ; 
if ( resultingOffset > termLength ) resultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; 
else { 
header . write ( termBuffer , termOffset , frameLength , termId ) ; 
frameType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; 
frameLengthOrdered ( termBuffer , termOffset , frameLength ) ; 
} 
return resultingOffset ; 
} 
} 

public class NetworkPublication { 
final int updatePublisherLimit ( ) { 
int workCount = 0 ; 
final long senderPosition = this . senderPosition . getVolatile ( ) ; 
if ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) { 
long minConsumerPosition = senderPosition ; 
for ( final ReadablePosition spyPosition : spyPositions ) { 
minConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; 
} 
final long proposedPublisherLimit = minConsumerPosition + termWindowLength ; 
if ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { 
cleanBuffer ( proposedPublisherLimit ) ; 
workCount = 1 ; 
} 
} 
else if ( publisherLimit . get ( ) > senderPosition ) publisherLimit . setOrdered ( senderPosition ) ; 
return workCount ; 
} 
} 

public class TermScanner { 
public static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { 
final int limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; 
int available = 0 ; 
int padding = 0 ; 
do { 
final int termOffset = offset + available ; 
final int frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; 
if ( frameLength <= 0 ) break ; 
int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; 
if ( isPaddingFrame ( termBuffer , termOffset ) ) { 
padding = alignedFrameLength - HEADER_LENGTH ; 
alignedFrameLength = HEADER_LENGTH ; 
} 
available += alignedFrameLength ; 
if ( available > limit ) { 
available -= alignedFrameLength ; 
padding = 0 ; 
break ; 
} 
} 
while ( 0 == padding && available < limit ) ; 
return pack ( padding , available ) ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder validate ( ) { 
if ( null == media ) throw new IllegalStateException ( "media type is mandatory" ) ; 
if ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) throw new IllegalStateException ( "either 'endpoint' or 'control' must be specified for UDP." ) ; 
int count = 0 ; 
count += null == initialTermId ? 0 : 1 ; 
count += null == termId ? 0 : 1 ; 
count += null == termOffset ? 0 : 1 ; 
if ( count > 0 ) { 
if ( count < 3 ) throw new IllegalStateException ( "if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided" ) ; 
if ( termId - initialTermId < 0 ) throw new IllegalStateException ( "difference greater than 2^31 - 1: termId=" + termId + " - initialTermId=" + initialTermId ) ; 
if ( null != termLength && termOffset > termLength ) throw new IllegalStateException ( "termOffset=" + termOffset + " > termLength=" + termLength ) ; 
} 
return this ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder prefix ( final String prefix ) { 
if ( null != prefix && ! prefix . equals ( "" ) && ! prefix . equals ( SPY_QUALIFIER ) ) throw new IllegalArgumentException ( "invalid prefix: " + prefix ) ; 
this . prefix = prefix ; 
return this ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder controlMode ( final String controlMode ) { 
if ( null != controlMode && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_MANUAL ) && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_DYNAMIC ) ) throw new IllegalArgumentException ( "invalid control mode: " + controlMode ) ; 
this . controlMode = controlMode ; 
return this ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder termLength ( final Integer termLength ) { 
if ( null != termLength ) LogBufferDescriptor . checkTermLength ( termLength ) ; 
this . termLength = termLength ; 
return this ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder termOffset ( final Integer termOffset ) { 
if ( null != termOffset ) { 
if ( ( termOffset < 0 || termOffset > LogBufferDescriptor . TERM_MAX_LENGTH ) ) throw new IllegalArgumentException ( "term offset not in range 0-1g: " + termOffset ) ; 
if ( 0 != ( termOffset & ( FRAME_ALIGNMENT - 1 ) ) ) throw new IllegalArgumentException ( "term offset not multiple of FRAME_ALIGNMENT: " + termOffset ) ; 
} 
this . termOffset = termOffset ; 
return this ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder linger ( final Long lingerNs ) { 
if ( null != lingerNs && lingerNs < 0 ) throw new IllegalArgumentException ( "linger value cannot be negative: " + lingerNs ) ; 
this . linger = lingerNs ; 
return this ; 
} 
} 

public class UdpChannelTransport { 
public void openDatagramChannel ( final AtomicCounter statusIndicator ) { 
try { 
sendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; 
receiveDatagramChannel = sendDatagramChannel ; 
if ( udpChannel . isMulticast ( ) ) { 
if ( null != connectAddress ) receiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; 
receiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; 
receiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; 
receiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; 
sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( ) ) ; 
if ( udpChannel . isHasMulticastTtl ( ) ) { 
sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , udpChannel . multicastTtl ( ) ) ; 
multicastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; 
} 
else if ( context . socketMulticastTtl ( ) != 0 ) { 
sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , context . socketMulticastTtl ( ) ) ; 
multicastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; 
} 
} 
else sendDatagramChannel . bind ( bindAddress ) ; 
if ( null != connectAddress ) sendDatagramChannel . connect ( connectAddress ) ; 
if ( 0 != context . socketSndbufLength ( ) ) sendDatagramChannel . setOption ( SO_SNDBUF , context . socketSndbufLength ( ) ) ; 
if ( 0 != context . socketRcvbufLength ( ) ) receiveDatagramChannel . setOption ( SO_RCVBUF , context . socketRcvbufLength ( ) ) ; 
sendDatagramChannel . configureBlocking ( false ) ; 
receiveDatagramChannel . configureBlocking ( false ) ; 
} 
catch ( final IOException ex ) { 
if ( null != statusIndicator ) statusIndicator . setOrdered ( ChannelEndpointStatus . ERRORED ) ; 
CloseHelper . quietClose ( sendDatagramChannel ) ; 
if ( receiveDatagramChannel != sendDatagramChannel ) CloseHelper . quietClose ( receiveDatagramChannel ) ; 
sendDatagramChannel = null ; 
receiveDatagramChannel = null ; 
throw new AeronException ( "channel error - " + ex . getMessage ( ) + " (at " + ex . getStackTrace ( ) [ 0 ] . toString ( ) + "): " + udpChannel . originalUriString ( ) , ex ) ; 
} 
} 
} 

public class UdpChannelTransport { 
public void close ( ) { 
if ( ! isClosed ) { 
isClosed = true ; 
try { 
if ( null != selectionKey ) selectionKey . cancel ( ) ; 
if ( null != transportPoller ) { 
transportPoller . cancelRead ( this ) ; 
transportPoller . selectNowWithoutProcessing ( ) ; 
} 
if ( null != sendDatagramChannel ) sendDatagramChannel . close ( ) ; 
if ( receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel ) receiveDatagramChannel . close ( ) ; 
if ( null != transportPoller ) transportPoller . selectNowWithoutProcessing ( ) ; 
} 
catch ( final IOException ex ) { 
errorLog . record ( ex ) ; 
} 
} 
} 
} 

public class UdpChannelTransport { 
public InetSocketAddress receive ( final ByteBuffer buffer ) { 
buffer . clear ( ) ; 
InetSocketAddress address = null ; 
try { 
if ( receiveDatagramChannel . isOpen ( ) ) address = ( InetSocketAddress ) receiveDatagramChannel . receive ( buffer ) ; 
} 
catch ( final PortUnreachableException ignored ) { 
} 
catch ( final Exception ex ) { 
LangUtil . rethrowUnchecked ( ex ) ; 
} 
return address ; 
} 
} 

public class RetransmitHandler { 
public void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { 
if ( ! isInvalid ( termOffset , termLength ) ) if ( null == activeRetransmitsMap . get ( termId , termOffset ) && activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { 
final RetransmitAction action = assignRetransmitAction ( ) ; 
action . termId = termId ; 
action . termOffset = termOffset ; 
action . length = Math . min ( length , termLength - termOffset ) ; 
final long delay = delayGenerator . generateDelay ( ) ; 
if ( 0 == delay ) { 
retransmitSender . resend ( termId , termOffset , action . length ) ; 
action . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; 
} 
else action . delay ( delay , nanoClock . nanoTime ( ) ) ; 
activeRetransmitsMap . put ( termId , termOffset , action ) ; 
} 
} 
} 

public class RetransmitHandler { 
public void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { 
if ( activeRetransmitsMap . size ( ) > 0 ) for ( final RetransmitAction action : retransmitActionPool ) { 
if ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { 
retransmitSender . resend ( action . termId , action . termOffset , action . length ) ; 
action . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; 
} 
else if ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { 
action . cancel ( ) ; 
activeRetransmitsMap . remove ( action . termId , action . termOffset ) ; 
} 
} 
} 
} 

public class ChannelEndpointStatus { 
public static String status ( final long status ) { 
if ( INITIALIZING == status ) return "INITIALIZING" ; 
if ( ERRORED == status ) return "ERRORED" ; 
if ( ACTIVE == status ) return "ACTIVE" ; 
if ( CLOSING == status ) return "CLOSING" ; 
return "unknown id=" + status ; 
} 
} 

public class DirectBufferVector { 
public DirectBufferVector validate ( ) { 
final int capacity = buffer . capacity ( ) ; 
if ( offset < 0 || offset >= capacity ) throw new IllegalArgumentException ( "offset=" + offset + " capacity=" + capacity ) ; 
if ( length < 0 || length > ( capacity - offset ) ) throw new IllegalArgumentException ( "offset=" + offset + " capacity=" + capacity + " length=" + length ) ; 
return this ; 
} 
} 

public class DirectBufferVector { 
public static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { 
int messageLength = 0 ; 
for ( final DirectBufferVector vector : vectors ) { 
vector . validate ( ) ; 
messageLength += vector . length ; 
if ( messageLength < 0 ) throw new IllegalStateException ( "length overflow: " + Arrays . toString ( vectors ) ) ; 
} 
return messageLength ; 
} 
} 

public class Configuration { 
public static int producerWindowLength ( final int termBufferLength , final int defaultTermWindowLength ) { 
int termWindowLength = termBufferLength / 2 ; 
if ( 0 != defaultTermWindowLength ) termWindowLength = Math . min ( defaultTermWindowLength , termWindowLength ) ; 
return termWindowLength ; 
} 
} 

public class Configuration { 
public static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { 
try ( DatagramChannel probe = DatagramChannel . open ( ) ) { 
final int defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; 
probe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; 
final int maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; 
if ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) System . err . format ( "WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; 
probe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; 
final int maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; 
if ( maxSoRcvBuf < ctx . socketRcvbufLength ( ) ) System . err . format ( "WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; 
final int soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; 
if ( ctx . mtuLength ( ) > soSndBuf ) throw new ConfigurationException ( String . format ( "MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; 
if ( ctx . initialWindowLength ( ) > maxSoRcvBuf ) throw new ConfigurationException ( "window length greater than socket SO_RCVBUF, increase '" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + "' to match window: windowLength=" + ctx . initialWindowLength ( ) + ", SO_RCVBUF=" + maxSoRcvBuf ) ; 
} 
catch ( final IOException ex ) { 
throw new AeronException ( "probe socket: " + ex . toString ( ) , ex ) ; 
} 
} 
} 

public class Configuration { 
public static void validatePageSize ( final int pageSize ) { 
if ( pageSize < PAGE_MIN_SIZE ) throw new ConfigurationException ( "page size less than min size of " + PAGE_MIN_SIZE + ": " + pageSize ) ; 
if ( pageSize > PAGE_MAX_SIZE ) throw new ConfigurationException ( "page size greater than max size of " + PAGE_MAX_SIZE + ": " + pageSize ) ; 
if ( ! BitUtil . isPowerOfTwo ( pageSize ) ) throw new ConfigurationException ( "page size not a power of 2: " + pageSize ) ; 
} 
} 

public class Configuration { 
public static void validateSessionIdRange ( final int low , final int high ) { 
if ( low > high ) throw new ConfigurationException ( "low session id value " + low + " must be <= high value " + high ) ; 
if ( Math . abs ( ( long ) high - low ) > Integer . MAX_VALUE ) throw new ConfigurationException ( "reserved range to too large" ) ; 
} 
} 

public class Configuration { 
public static void validateUnblockTimeout ( final long publicationUnblockTimeoutNs , final long clientLivenessTimeoutNs , final long timerIntervalNs ) { 
if ( publicationUnblockTimeoutNs <= clientLivenessTimeoutNs ) throw new ConfigurationException ( "publicationUnblockTimeoutNs=" + publicationUnblockTimeoutNs + " <= clientLivenessTimeoutNs=" + clientLivenessTimeoutNs ) ; 
if ( clientLivenessTimeoutNs <= timerIntervalNs ) throw new ConfigurationException ( "clientLivenessTimeoutNs=" + clientLivenessTimeoutNs + " <= timerIntervalNs=" + timerIntervalNs ) ; 
} 
} 

public class ClusterMember { 
public static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { 
final StringBuilder builder = new StringBuilder ( ) ; 
for ( int i = 0 , length = clusterMembers . length ; 
i < length ; 
i ++ ) { 
final ClusterMember member = clusterMembers [ i ] ; 
builder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; 
if ( ( length - 1 ) != i ) builder . append ( '|' ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class ClusterMember { 
public static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { 
int threshold = quorumThreshold ( clusterMembers . length ) ; 
for ( final ClusterMember member : clusterMembers ) { 
if ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) if ( -- threshold <= 0 ) return true ; 
} 
return false ; 
} 
} 

public class ClusterMember { 
public static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { 
final int length = rankedPositions . length ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) rankedPositions [ i ] = 0 ; 
for ( final ClusterMember member : members ) { 
long newPosition = member . logPosition ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) { 
final long rankedPosition = rankedPositions [ i ] ; 
if ( newPosition > rankedPosition ) { 
rankedPositions [ i ] = newPosition ; 
newPosition = rankedPosition ; 
} 
} 
} 
return rankedPositions [ length - 1 ] ; 
} 
} 

public class ClusterMember { 
public static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { 
for ( final ClusterMember member : clusterMembers ) { 
if ( member . vote != null && ( member . logPosition < position || member . leadershipTermId != leadershipTermId ) ) return false ; 
} 
return true ; 
} 
} 

public class ClusterMember { 
public static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { 
int votes = 0 ; 
for ( final ClusterMember member : members ) { 
if ( null == member . vote || member . candidateTermId != candidateTermId ) return false ; 
votes += member . vote ? 1 : 0 ; 
} 
return votes >= ClusterMember . quorumThreshold ( members . length ) ; 
} 
} 

public class ClusterMember { 
public static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { 
int votes = 0 ; 
for ( final ClusterMember member : clusterMembers ) { 
if ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) ++ votes ; 
} 
return votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; 
} 
} 

public class ClusterMember { 
public static ClusterMember determineMember ( final ClusterMember [ ] clusterMembers , final int memberId , final String memberEndpoints ) { 
ClusterMember member = NULL_VALUE != memberId ? ClusterMember . findMember ( clusterMembers , memberId ) : null ; 
if ( ( null == clusterMembers || 0 == clusterMembers . length ) && null == member ) member = ClusterMember . parseEndpoints ( NULL_VALUE , memberEndpoints ) ; 
else { 
if ( null == member ) throw new ClusterException ( "memberId=" + memberId + " not found in clusterMembers" ) ; 
if ( ! "" . equals ( memberEndpoints ) ) ClusterMember . validateMemberEndpoints ( member , memberEndpoints ) ; 
} 
return member ; 
} 
} 

public class ClusterMember { 
public static void validateMemberEndpoints ( final ClusterMember member , final String memberEndpoints ) { 
final ClusterMember endpointMember = ClusterMember . parseEndpoints ( Aeron . NULL_VALUE , memberEndpoints ) ; 
if ( ! areSameEndpoints ( member , endpointMember ) ) throw new ClusterException ( "clusterMembers and memberEndpoints differ: " + member . endpointsDetail ( ) + " != " + memberEndpoints ) ; 
} 
} 

public class ClusterMember { 
public static boolean isUnanimousCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { 
for ( final ClusterMember member : clusterMembers ) { 
if ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) return false ; 
} 
return true ; 
} 
} 

public class ClusterMember { 
public static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { 
int possibleVotes = 0 ; 
for ( final ClusterMember member : clusterMembers ) { 
if ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) continue ; 
++ possibleVotes ; 
} 
return possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; 
} 
} 

public class ClusterMember { 
public static boolean isNotDuplicateEndpoints ( final ClusterMember [ ] members , final String memberEndpoints ) { 
for ( final ClusterMember member : members ) { 
if ( member . endpointsDetail ( ) . equals ( memberEndpoints ) ) return false ; 
} 
return true ; 
} 
} 

public class ClusterMember { 
public static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { 
final int length = clusterMembers . length ; 
int index = ArrayUtil . UNKNOWN_INDEX ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) if ( clusterMembers [ i ] . id ( ) == memberId ) index = i ; 
return index ; 
} 
} 

public class CommonContext { 
public MappedByteBuffer mapExistingCncFile ( final Consumer < String > logger ) { 
final File cncFile = new File ( aeronDirectory , CncFileDescriptor . CNC_FILE ) ; 
if ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { 
if ( null != logger ) logger . accept ( "INFO: Aeron CnC file exists: " + cncFile ) ; 
return IoUtil . mapExistingFile ( cncFile , CncFileDescriptor . CNC_FILE ) ; 
} 
return null ; 
} 
} 

public class CommonContext { 
public static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { 
if ( null == cncByteBuffer ) return false ; 
final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; 
final long startTimeMs = System . currentTimeMillis ( ) ; 
int cncVersion ; 
while ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { 
if ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) throw new DriverTimeoutException ( "CnC file is created but not initialised." ) ; 
sleep ( 1 ) ; 
} 
if ( CNC_VERSION != cncVersion ) throw new AeronException ( "Aeron CnC version does not match: required=" + CNC_VERSION + " version=" + cncVersion ) ; 
final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; 
final long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; 
final long now = System . currentTimeMillis ( ) ; 
final long timestampAge = now - timestamp ; 
logger . accept ( "INFO: Aeron toDriver consumer heartbeat is (ms): " + timestampAge ) ; 
return timestampAge <= driverTimeoutMs ; 
} 
} 

public class CommonContext { 
public static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { 
final File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; 
if ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { 
final MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , "CnC file" ) ; 
try { 
final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; 
final int cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; 
if ( CncFileDescriptor . CNC_VERSION != cncVersion ) throw new AeronException ( "Aeron CnC version does not match: required=" + CNC_VERSION + " version=" + cncVersion ) ; 
final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; 
final long clientId = toDriverBuffer . nextCorrelationId ( ) ; 
final DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; 
return driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; 
} 
finally { 
IoUtil . unmap ( cncByteBuffer ) ; 
} 
} 
return false ; 
} 
} 

public class FrameDescriptor { 
public static int frameLengthVolatile ( final UnsafeBuffer buffer , final int termOffset ) { 
int frameLength = buffer . getIntVolatile ( termOffset ) ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) frameLength = Integer . reverseBytes ( frameLength ) ; 
return frameLength ; 
} 
} 

public class FrameDescriptor { 
public static void frameLengthOrdered ( final UnsafeBuffer buffer , final int termOffset , final int frameLength ) { 
int length = frameLength ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) length = Integer . reverseBytes ( frameLength ) ; 
buffer . putIntOrdered ( termOffset , length ) ; 
} 
} 

public class RecordingPos { 
public static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
for ( int i = 0 , size = countersReader . maxCounterId ( ) ; 
i < size ; 
i ++ ) if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) return i ; 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class RecordingPos { 
public static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
for ( int i = 0 , size = countersReader . maxCounterId ( ) ; 
i < size ; 
i ++ ) if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) return i ; 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class RecordingPos { 
public static long getRecordingId ( final CountersReader countersReader , final int counterId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) return buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) ; 
} 
return NULL_RECORDING_ID ; 
} 
} 

public class RecordingLog { 
public Entry findLastTerm ( ) { 
for ( int i = entries . size ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
final Entry entry = entries . get ( i ) ; 
if ( ENTRY_TYPE_TERM == entry . type ) return entry ; 
} 
return null ; 
} 
} 

public class RecordingLog { 
public void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { 
final int size = entries . size ( ) ; 
if ( size > 0 ) { 
final Entry lastEntry = entries . get ( size - 1 ) ; 
if ( lastEntry . type != NULL_VALUE && lastEntry . leadershipTermId >= leadershipTermId ) throw new ClusterException ( "leadershipTermId out of sequence: previous " + lastEntry . leadershipTermId + " this " + leadershipTermId ) ; 
} 
indexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; 
append ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; 
} 
} 

public class RecordingLog { 
public void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { 
final int size = entries . size ( ) ; 
if ( size > 0 ) { 
final Entry entry = entries . get ( size - 1 ) ; 
if ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) throw new ClusterException ( "leadershipTermId out of sequence: previous " + entry . leadershipTermId + " this " + leadershipTermId ) ; 
} 
append ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; 
} 
} 

public class RecordingLog { 
public void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { 
int index = - 1 ; 
for ( int i = 0 , size = entries . size ( ) ; 
i < size ; 
i ++ ) { 
final Entry entry = entries . get ( i ) ; 
if ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { 
index = entry . entryIndex ; 
if ( ENTRY_TYPE_TERM == entry . type ) indexByLeadershipTermIdMap . remove ( leadershipTermId ) ; 
break ; 
} 
} 
if ( - 1 == index ) throw new ClusterException ( "unknown entry index: " + entryIndex ) ; 
buffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; 
byteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; 
final long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; 
try { 
if ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) throw new ClusterException ( "failed to write field atomically" ) ; 
} 
catch ( final Exception ex ) { 
LangUtil . rethrowUnchecked ( ex ) ; 
} 
} 
} 

public class AeronCluster { 
public void close ( ) { 
if ( null != publication && publication . isConnected ( ) ) closeSession ( ) ; 
if ( ! ctx . ownsAeronClient ( ) ) { 
CloseHelper . close ( subscription ) ; 
CloseHelper . close ( publication ) ; 
} 
ctx . close ( ) ; 
} 
} 

public class AeronCluster { 
public long offer ( final DirectBufferVector [ ] vectors ) { 
if ( headerVector != vectors [ 0 ] ) vectors [ 0 ] = headerVector ; 
return publication . offer ( vectors , null ) ; 
} 
} 

public class LogBufferDescriptor { 
public static void checkTermLength ( final int termLength ) { 
if ( termLength < TERM_MIN_LENGTH ) throw new IllegalStateException ( "Term length less than min length of " + TERM_MIN_LENGTH + ": length=" + termLength ) ; 
if ( termLength > TERM_MAX_LENGTH ) throw new IllegalStateException ( "Term length more than max length of " + TERM_MAX_LENGTH + ": length=" + termLength ) ; 
if ( ! BitUtil . isPowerOfTwo ( termLength ) ) throw new IllegalStateException ( "Term length not a power of 2: length=" + termLength ) ; 
} 
} 

public class LogBufferDescriptor { 
public static void checkPageSize ( final int pageSize ) { 
if ( pageSize < PAGE_MIN_SIZE ) throw new IllegalStateException ( "Page size less than min size of " + PAGE_MIN_SIZE + ": page size=" + pageSize ) ; 
if ( pageSize > PAGE_MAX_SIZE ) throw new IllegalStateException ( "Page size more than max size of " + PAGE_MAX_SIZE + ": page size=" + pageSize ) ; 
if ( ! BitUtil . isPowerOfTwo ( pageSize ) ) throw new IllegalStateException ( "Page size not a power of 2: page size=" + pageSize ) ; 
} 
} 

public class LogBufferDescriptor { 
public static long computeLogLength ( final int termLength , final int filePageSize ) { 
if ( termLength < ( 1024 * 1024 * 1024 ) ) return align ( ( termLength * PARTITION_COUNT ) + LOG_META_DATA_LENGTH , filePageSize ) ; 
return ( PARTITION_COUNT * ( long ) termLength ) + align ( LOG_META_DATA_LENGTH , filePageSize ) ; 
} 
} 

public class LogBufferDescriptor { 
public static void storeDefaultFrameHeader ( final UnsafeBuffer metadataBuffer , final DirectBuffer defaultHeader ) { 
if ( defaultHeader . capacity ( ) != HEADER_LENGTH ) throw new IllegalArgumentException ( "Default header length not equal to HEADER_LENGTH: length=" + defaultHeader . capacity ( ) ) ; 
metadataBuffer . putInt ( LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET , HEADER_LENGTH ) ; 
metadataBuffer . putBytes ( LOG_DEFAULT_FRAME_HEADER_OFFSET , defaultHeader , 0 , HEADER_LENGTH ) ; 
} 
} 

public class LogBufferDescriptor { 
public static boolean rotateLog ( final UnsafeBuffer metadataBuffer , final int termCount , final int termId ) { 
final int nextTermId = termId + 1 ; 
final int nextTermCount = termCount + 1 ; 
final int nextIndex = indexByTermCount ( nextTermCount ) ; 
final int expectedTermId = nextTermId - PARTITION_COUNT ; 
long rawTail ; 
do { 
rawTail = rawTail ( metadataBuffer , nextIndex ) ; 
if ( expectedTermId != termId ( rawTail ) ) break ; 
} 
while ( ! casRawTail ( metadataBuffer , nextIndex , rawTail , packTail ( nextTermId , 0 ) ) ) ; 
return casActiveTermCount ( metadataBuffer , termCount , nextTermCount ) ; 
} 
} 

public class TerminateDriverFlyweight { 
public TerminateDriverFlyweight tokenBuffer ( final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { 
buffer . putInt ( TOKEN_LENGTH_OFFSET , tokenLength ) ; 
if ( null != tokenBuffer && tokenLength > 0 ) buffer . putBytes ( tokenBufferOffset ( ) , tokenBuffer , tokenOffset , tokenLength ) ; 
return this ; 
} 
} 

public class RecoveryState { 
public static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { 
tempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; 
tempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; 
tempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; 
tempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; 
final int serviceCount = snapshotRecordingIds . length ; 
tempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; 
final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; 
if ( keyLength > MAX_KEY_LENGTH ) throw new ClusterException ( keyLength + " exceeds max key length " + MAX_KEY_LENGTH ) ; 
for ( int i = 0 ; 
i < serviceCount ; 
i ++ ) tempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; 
final int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; 
int labelLength = 0 ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; 
labelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , " logPosition=" ) ; 
labelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , " hasReplay=" + hasReplay ) ; 
return aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; 
} 
} 

public class RecoveryState { 
public static int findCounterId ( final CountersReader counters ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
for ( int i = 0 , size = counters . maxCounterId ( ) ; 
i < size ; 
i ++ ) if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) return i ; 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class RecoveryState { 
public static boolean hasReplay ( final CountersReader counters , final int counterId ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
if ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) return buffer . getInt ( recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET ) == 1 ; 
} 
return false ; 
} 
} 

public class RecoveryState { 
public static long getSnapshotRecordingId ( final CountersReader counters , final int counterId , final int serviceId ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
if ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { 
final int serviceCount = buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET ) ; 
if ( serviceId < 0 || serviceId >= serviceCount ) throw new ClusterException ( "invalid serviceId " + serviceId + " for count of " + serviceCount ) ; 
return buffer . getLong ( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceId * SIZE_OF_LONG ) ) ; 
} 
} 
throw new ClusterException ( "Active counter not found " + counterId ) ; 
} 
} 

public class HeaderFlyweight { 
public static char [ ] flagsToChars ( final short flags ) { 
final char [ ] chars = new char [ ] { 
'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } 
; 
final int length = chars . length ; 
short mask = ( short ) ( 1 << ( length - 1 ) ) ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) { 
if ( ( flags & mask ) == mask ) chars [ i ] = '1' ; 
mask >>= 1 ; 
} 
return chars ; 
} 
} 

public class BufferClaim { 
public final void commit ( ) { 
int frameLength = buffer . capacity ( ) ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) frameLength = Integer . reverseBytes ( frameLength ) ; 
buffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; 
} 
} 

public class BufferClaim { 
public final void abort ( ) { 
int frameLength = buffer . capacity ( ) ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) frameLength = Integer . reverseBytes ( frameLength ) ; 
buffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_PAD , LITTLE_ENDIAN ) ; 
buffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; 
} 
} 

public class MediaDriver { 
public void close ( ) { 
CloseHelper . close ( sharedRunner ) ; 
CloseHelper . close ( sharedNetworkRunner ) ; 
CloseHelper . close ( receiverRunner ) ; 
CloseHelper . close ( senderRunner ) ; 
CloseHelper . close ( conductorRunner ) ; 
CloseHelper . close ( sharedInvoker ) ; 
if ( ctx . useWindowsHighResTimer ( ) && SystemUtil . osName ( ) . startsWith ( "win" ) ) if ( ! wasHighResTimerEnabled ) HighResolutionTimer . disable ( ) ; 
} 
} 

public class ServiceHeartbeat { 
public static int findCounterId ( final CountersReader counters , final int serviceId ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
for ( int i = 0 , size = counters . maxCounterId ( ) ; 
i < size ; 
i ++ ) if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final int recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) return i ; 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class CapacityByteArrayOutputStream { 
private void addSlab ( int minimumSize ) { 
int nextSlabSize ; 
if ( bytesUsed == 0 ) nextSlabSize = initialSlabSize ; 
else if ( bytesUsed > maxCapacityHint / 5 ) nextSlabSize = maxCapacityHint / 5 ; 
else nextSlabSize = bytesUsed ; 
if ( nextSlabSize < minimumSize ) { 
LOG . debug ( "slab size {} too small for value of size {}. Bumping up slab size" , nextSlabSize , minimumSize ) ; 
nextSlabSize = minimumSize ; 
} 
LOG . debug ( "used {} slabs, adding new slab of size {}" , slabs . size ( ) , nextSlabSize ) ; 
this . currentSlab = allocator . allocate ( nextSlabSize ) ; 
this . slabs . add ( currentSlab ) ; 
this . bytesAllocated += nextSlabSize ; 
this . currentSlabIndex = 0 ; 
} 
} 

public class ColumnIndexBuilder { 
public void add ( Statistics < ? > stats ) { 
if ( stats . hasNonNullValue ( ) ) { 
nullPages . add ( false ) ; 
Object min = stats . genericGetMin ( ) ; 
Object max = stats . genericGetMax ( ) ; 
addMinMax ( min , max ) ; 
pageIndexes . add ( nextPageIndex ) ; 
minMaxSize += sizeOf ( min ) ; 
minMaxSize += sizeOf ( max ) ; 
} 
else nullPages . add ( true ) ; 
nullCounts . add ( stats . getNumNulls ( ) ) ; 
++ nextPageIndex ; 
} 
} 

public class GlobParser { 
private static String annotateMessage ( String message , int pos ) { 
StringBuilder sb = new StringBuilder ( message ) ; 
sb . append ( '\n' ) ; 
for ( int i = 0 ; 
i < pos ; 
i ++ ) sb . append ( '-' ) ; 
sb . append ( '^' ) ; 
return sb . toString ( ) ; 
} 
} 

public class RunLengthBitPackingHybridEncoder { 
private void endPreviousBitPackedRun ( ) { 
if ( bitPackedRunHeaderPointer == - 1 ) return ; 
byte bitPackHeader = ( byte ) ( ( bitPackedGroupCount << 1 ) | 1 ) ; 
baos . setByte ( bitPackedRunHeaderPointer , bitPackHeader ) ; 
bitPackedRunHeaderPointer = - 1 ; 
bitPackedGroupCount = 0 ; 
} 
} 

public class ParquetFileReader { 
@ Deprecated public static final ParquetMetadata readFooter ( InputFile file , MetadataFilter filter ) throws IOException { 
ParquetReadOptions options ; 
if ( file instanceof HadoopInputFile ) options = HadoopReadOptions . builder ( ( ( HadoopInputFile ) file ) . getConfiguration ( ) ) . withMetadataFilter ( filter ) . build ( ) ; 
else options = ParquetReadOptions . builder ( ) . withMetadataFilter ( filter ) . build ( ) ; 
try ( SeekableInputStream in = file . newStream ( ) ) { 
return readFooter ( file , options , in ) ; 
} 
} 
} 

public class ParquetFileReader { 
public PageReadStore readNextRowGroup ( ) throws IOException { 
if ( currentBlock == blocks . size ( ) ) return null ; 
BlockMetaData block = blocks . get ( currentBlock ) ; 
if ( block . getRowCount ( ) == 0 ) throw new RuntimeException ( "Illegal row group of 0 rows" ) ; 
this . currentRowGroup = new ColumnChunkPageReadStore ( block . getRowCount ( ) ) ; 
List < ConsecutivePartList > allParts = new ArrayList < ConsecutivePartList > ( ) ; 
ConsecutivePartList currentParts = null ; 
for ( ColumnChunkMetaData mc : block . getColumns ( ) ) { 
ColumnPath pathKey = mc . getPath ( ) ; 
BenchmarkCounter . incrementTotalBytes ( mc . getTotalSize ( ) ) ; 
ColumnDescriptor columnDescriptor = paths . get ( pathKey ) ; 
if ( columnDescriptor != null ) { 
long startingPos = mc . getStartingPos ( ) ; 
if ( currentParts == null || currentParts . endPos ( ) != startingPos ) { 
currentParts = new ConsecutivePartList ( startingPos ) ; 
allParts . add ( currentParts ) ; 
} 
currentParts . addChunk ( new ChunkDescriptor ( columnDescriptor , mc , startingPos , ( int ) mc . getTotalSize ( ) ) ) ; 
} 
} 
ChunkListBuilder builder = new ChunkListBuilder ( ) ; 
for ( ConsecutivePartList consecutiveChunks : allParts ) { 
consecutiveChunks . readAll ( f , builder ) ; 
} 
for ( Chunk chunk : builder . build ( ) ) { 
currentRowGroup . addColumn ( chunk . descriptor . col , chunk . readAllPages ( ) ) ; 
} 
if ( nextDictionaryReader != null ) nextDictionaryReader . setRowGroup ( currentRowGroup ) ; 
advanceToNextBlock ( ) ; 
return currentRowGroup ; 
} 
} 

public class ParquetFileReader { 
public PageReadStore readNextFilteredRowGroup ( ) throws IOException { 
if ( currentBlock == blocks . size ( ) ) return null ; 
if ( ! options . useColumnIndexFilter ( ) ) return readNextRowGroup ( ) ; 
BlockMetaData block = blocks . get ( currentBlock ) ; 
if ( block . getRowCount ( ) == 0 ) throw new RuntimeException ( "Illegal row group of 0 rows" ) ; 
ColumnIndexStore ciStore = getColumnIndexStore ( currentBlock ) ; 
RowRanges rowRanges = getRowRanges ( currentBlock ) ; 
long rowCount = rowRanges . rowCount ( ) ; 
if ( rowCount == 0 ) { 
advanceToNextBlock ( ) ; 
return readNextFilteredRowGroup ( ) ; 
} 
if ( rowCount == block . getRowCount ( ) ) return readNextRowGroup ( ) ; 
this . currentRowGroup = new ColumnChunkPageReadStore ( rowRanges ) ; 
ChunkListBuilder builder = new ChunkListBuilder ( ) ; 
List < ConsecutivePartList > allParts = new ArrayList < ConsecutivePartList > ( ) ; 
ConsecutivePartList currentParts = null ; 
for ( ColumnChunkMetaData mc : block . getColumns ( ) ) { 
ColumnPath pathKey = mc . getPath ( ) ; 
ColumnDescriptor columnDescriptor = paths . get ( pathKey ) ; 
if ( columnDescriptor != null ) { 
OffsetIndex offsetIndex = ciStore . getOffsetIndex ( mc . getPath ( ) ) ; 
OffsetIndex filteredOffsetIndex = filterOffsetIndex ( offsetIndex , rowRanges , block . getRowCount ( ) ) ; 
for ( OffsetRange range : calculateOffsetRanges ( filteredOffsetIndex , mc , offsetIndex . getOffset ( 0 ) ) ) { 
BenchmarkCounter . incrementTotalBytes ( range . getLength ( ) ) ; 
long startingPos = range . getOffset ( ) ; 
if ( currentParts == null || currentParts . endPos ( ) != startingPos ) { 
currentParts = new ConsecutivePartList ( startingPos ) ; 
allParts . add ( currentParts ) ; 
} 
ChunkDescriptor chunkDescriptor = new ChunkDescriptor ( columnDescriptor , mc , startingPos , ( int ) range . getLength ( ) ) ; 
currentParts . addChunk ( chunkDescriptor ) ; 
builder . setOffsetIndex ( chunkDescriptor , filteredOffsetIndex ) ; 
} 
} 
} 
for ( ConsecutivePartList consecutiveChunks : allParts ) { 
consecutiveChunks . readAll ( f , builder ) ; 
} 
for ( Chunk chunk : builder . build ( ) ) { 
currentRowGroup . addColumn ( chunk . descriptor . col , chunk . readAllPages ( ) ) ; 
} 
if ( nextDictionaryReader != null ) nextDictionaryReader . setRowGroup ( currentRowGroup ) ; 
advanceToNextBlock ( ) ; 
return currentRowGroup ; 
} 
} 

public class ParquetFileReader { 
DictionaryPage readDictionary ( ColumnChunkMetaData meta ) throws IOException { 
if ( ! meta . getEncodings ( ) . contains ( Encoding . PLAIN_DICTIONARY ) && ! meta . getEncodings ( ) . contains ( Encoding . RLE_DICTIONARY ) ) return null ; 
if ( f . getPos ( ) != meta . getStartingPos ( ) ) f . seek ( meta . getStartingPos ( ) ) ; 
PageHeader pageHeader = Util . readPageHeader ( f ) ; 
if ( ! pageHeader . isSetDictionary_page_header ( ) ) return null ; 
DictionaryPage compressedPage = readCompressedDictionary ( pageHeader , f ) ; 
BytesInputDecompressor decompressor = options . getCodecFactory ( ) . getDecompressor ( meta . getCodec ( ) ) ; 
return new DictionaryPage ( decompressor . decompress ( compressedPage . getBytes ( ) , compressedPage . getUncompressedSize ( ) ) , compressedPage . getDictionarySize ( ) , compressedPage . getEncoding ( ) ) ; 
} 
} 

public class MemoryManager { 
synchronized void addWriter ( InternalParquetRecordWriter writer , Long allocation ) { 
Long oldValue = writerList . get ( writer ) ; 
if ( oldValue == null ) writerList . put ( writer , allocation ) ; 
else throw new IllegalArgumentException ( "[BUG] The Parquet Memory Manager should not add an " + "instance of InternalParquetRecordWriter more than once. The Manager already contains " + "the writer: " + writer ) ; 
updateAllocation ( ) ; 
} 
} 

public class MemoryManager { 
synchronized void removeWriter ( InternalParquetRecordWriter writer ) { 
if ( writerList . containsKey ( writer ) ) writerList . remove ( writer ) ; 
if ( ! writerList . isEmpty ( ) ) updateAllocation ( ) ; 
} 
} 

public class MemoryManager { 
private void updateAllocation ( ) { 
long totalAllocations = 0 ; 
for ( Long allocation : writerList . values ( ) ) { 
totalAllocations += allocation ; 
} 
if ( totalAllocations <= totalMemoryPool ) scale = 1.0 ; 
else { 
scale = ( double ) totalMemoryPool / totalAllocations ; 
LOG . warn ( String . format ( "Total allocation exceeds %.2f%% (%,d bytes) of heap memory\n" + "Scaling row group sizes to %.2f%% for %d writers" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; 
for ( Runnable callBack : callBacks . values ( ) ) { 
callBack . run ( ) ; 
} 
} 
int maxColCount = 0 ; 
for ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { 
maxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; 
} 
for ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { 
long newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; 
if ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) throw new ParquetRuntimeException ( String . format ( "New Memory allocation %d bytes" + " is smaller than the minimum allocation size of %d bytes." , newSize , minMemoryAllocation ) ) { 
} 
; 
entry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; 
LOG . debug ( String . format ( "Adjust block size from %,d to %,d for writer: %s" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; 
} 
} 
} 

public class MemoryManager { 
public void registerScaleCallBack ( String callBackName , Runnable callBack ) { 
Preconditions . checkNotNull ( callBackName , "callBackName" ) ; 
Preconditions . checkNotNull ( callBack , "callBack" ) ; 
if ( callBacks . containsKey ( callBackName ) ) throw new IllegalArgumentException ( "The callBackName " + callBackName + " is duplicated and has been registered already." ) ; 
else callBacks . put ( callBackName , callBack ) ; 
} 
} 

public class ParquetFileWriter { 
void writeColumnChunk ( ColumnDescriptor descriptor , long valueCount , CompressionCodecName compressionCodecName , DictionaryPage dictionaryPage , BytesInput bytes , long uncompressedTotalPageSize , long compressedTotalPageSize , Statistics < ? > totalStats , ColumnIndexBuilder columnIndexBuilder , OffsetIndexBuilder offsetIndexBuilder , Set < Encoding > rlEncodings , Set < Encoding > dlEncodings , List < Encoding > dataEncodings ) throws IOException { 
startColumn ( descriptor , valueCount , compressionCodecName ) ; 
state = state . write ( ) ; 
if ( dictionaryPage != null ) writeDictionaryPage ( dictionaryPage ) ; 
LOG . debug ( "{}: write data pages" , out . getPos ( ) ) ; 
long headersSize = bytes . size ( ) - compressedTotalPageSize ; 
this . uncompressedLength += uncompressedTotalPageSize + headersSize ; 
this . compressedLength += compressedTotalPageSize + headersSize ; 
LOG . debug ( "{}: write data pages content" , out . getPos ( ) ) ; 
firstPageOffset = out . getPos ( ) ; 
bytes . writeAllTo ( out ) ; 
encodingStatsBuilder . addDataEncodings ( dataEncodings ) ; 
if ( rlEncodings . isEmpty ( ) ) encodingStatsBuilder . withV2Pages ( ) ; 
currentEncodings . addAll ( rlEncodings ) ; 
currentEncodings . addAll ( dlEncodings ) ; 
currentEncodings . addAll ( dataEncodings ) ; 
currentStatistics = totalStats ; 
this . columnIndexBuilder = columnIndexBuilder ; 
this . offsetIndexBuilder = offsetIndexBuilder ; 
endColumn ( ) ; 
} 
} 

public class ParquetFileWriter { 
private static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { 
LOG . debug ( "Copying {} bytes at {} to {}" , length , start , to . getPos ( ) ) ; 
from . seek ( start ) ; 
long bytesCopied = 0 ; 
byte [ ] buffer = COPY_BUFFER . get ( ) ; 
while ( bytesCopied < length ) { 
long bytesLeft = length - bytesCopied ; 
int bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; 
if ( bytesRead < 0 ) throw new IllegalArgumentException ( "Unexpected end of input file at " + start + bytesCopied ) ; 
to . write ( buffer , 0 , bytesRead ) ; 
bytesCopied += bytesRead ; 
} 
} 
} 

public class ColumnReaderBase { 
public void readValue ( ) { 
try { 
if ( ! valueRead ) { 
binding . read ( ) ; 
valueRead = true ; 
} 
} 
catch ( RuntimeException e ) { 
if ( CorruptDeltaByteArrays . requiresSequentialReads ( writerVersion , currentEncoding ) && e instanceof ArrayIndexOutOfBoundsException ) throw new ParquetDecodingException ( "Read failure possibly due to " + "PARQUET-246: try setting parquet.split.files to false" , new ParquetDecodingException ( format ( "Can't read value in column %s at value %d out of %d, " + "%d out of %d in currentPage. repetition level: " + "%d, definition level: %d" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ) ; 
throw new ParquetDecodingException ( format ( "Can't read value in column %s at value %d out of %d, " + "%d out of %d in currentPage. repetition level: " + "%d, definition level: %d" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ; 
} 
} 
} 

public class Schemas { 
public static boolean nullOk ( Schema schema ) { 
if ( Schema . Type . NULL == schema . getType ( ) ) return true ; 
else if ( Schema . Type . UNION == schema . getType ( ) ) for ( Schema possible : schema . getTypes ( ) ) { 
if ( nullOk ( possible ) ) return true ; 
} 
return false ; 
} 
} 

public class Schemas { 
@ SafeVarargs private static < E > E coalesce ( E ... objects ) { 
for ( E object : objects ) { 
if ( object != null ) return object ; 
} 
return null ; 
} 
} 

public class RecordBuilder { 
private static Object makeValue ( String string , Schema schema ) { 
if ( string == null ) return null ; 
try { 
switch ( schema . getType ( ) ) { 
case BOOLEAN : return Boolean . valueOf ( string ) ; 
case STRING : return string ; 
case FLOAT : return Float . valueOf ( string ) ; 
case DOUBLE : return Double . valueOf ( string ) ; 
case INT : return Integer . valueOf ( string ) ; 
case LONG : return Long . valueOf ( string ) ; 
case ENUM : if ( schema . hasEnumSymbol ( string ) ) return string ; 
else try { 
return schema . getEnumSymbols ( ) . get ( Integer . parseInt ( string ) ) ; 
} 
catch ( IndexOutOfBoundsException ex ) { 
return null ; 
} 
case UNION : Object value = null ; 
for ( Schema possible : schema . getTypes ( ) ) { 
value = makeValue ( string , possible ) ; 
if ( value != null ) return value ; 
} 
return null ; 
case NULL : return null ; 
default : throw new RecordException ( "Unsupported field type:" + schema . getType ( ) ) ; 
} 
} 
catch ( NumberFormatException e ) { 
if ( string . isEmpty ( ) ) return null ; 
else throw e ; 
} 
} 
} 

public class ThriftMetaData { 
public static ThriftMetaData fromExtraMetaData ( Map < String , String > extraMetaData ) { 
final String thriftClassName = extraMetaData . get ( THRIFT_CLASS ) ; 
final String thriftDescriptorString = extraMetaData . get ( THRIFT_DESCRIPTOR ) ; 
if ( thriftClassName == null || thriftDescriptorString == null ) return null ; 
final StructType descriptor = parseDescriptor ( thriftDescriptorString ) ; 
return new ThriftMetaData ( thriftClassName , descriptor ) ; 
} 
} 

public class ColumnWriterBase { 
void writePage ( ) { 
if ( valueCount == 0 ) throw new ParquetEncodingException ( "writing empty page" ) ; 
this . rowsWrittenSoFar += pageRowCount ; 
if ( DEBUG ) LOG . debug ( "write page" ) ; 
try { 
writePage ( pageRowCount , valueCount , statistics , repetitionLevelColumn , definitionLevelColumn , dataColumn ) ; 
} 
catch ( IOException e ) { 
throw new ParquetEncodingException ( "could not write page for " + path , e ) ; 
} 
repetitionLevelColumn . reset ( ) ; 
definitionLevelColumn . reset ( ) ; 
dataColumn . reset ( ) ; 
valueCount = 0 ; 
resetStatistics ( ) ; 
pageRowCount = 0 ; 
} 
} 

public class DeltaBinaryPackingValuesReader { 
@ Override public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { 
this . in = stream ; 
long startPos = in . position ( ) ; 
this . config = DeltaBinaryPackingConfig . readConfig ( in ) ; 
this . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; 
allocateValuesBuffer ( ) ; 
bitWidths = new int [ config . miniBlockNumInABlock ] ; 
valuesBuffer [ valuesBuffered ++ ] = BytesUtils . readZigZagVarLong ( in ) ; 
while ( valuesBuffered < totalValueCount ) loadNewBlockToBuffer ( ) ; 
updateNextOffset ( ( int ) ( in . position ( ) - startPos ) ) ; 
} 
} 

public class BufferedProtocolReadToWrite { 
private void checkEnum ( ThriftType expectedType , int i ) { 
if ( expectedType . getType ( ) == ThriftTypeID . ENUM ) { 
ThriftType . EnumType expectedEnumType = ( ThriftType . EnumType ) expectedType ; 
if ( expectedEnumType . getEnumValueById ( i ) == null ) throw new DecodingSchemaMismatchException ( "can not find index " + i + " in enum " + expectedType ) ; 
} 
} 
} 

public class DeltaBinaryPackingValuesWriterForInteger { 
private void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { 
for ( int miniBlockIndex = 0 ; 
miniBlockIndex < miniBlocksToFlush ; 
miniBlockIndex ++ ) { 
int mask = 0 ; 
int miniStart = miniBlockIndex * config . miniBlockSizeInValues ; 
int miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; 
for ( int i = miniStart ; 
i < miniEnd ; 
i ++ ) mask |= deltaBlockBuffer [ i ] ; 
bitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; 
} 
} 
} 

public class Exceptions { 
public static < E extends Exception > void throwIfInstance ( Throwable t , Class < E > excClass ) throws E { 
if ( excClass . isAssignableFrom ( t . getClass ( ) ) ) throw excClass . cast ( t ) ; 
} 
} 

public class Statistics { 
public void mergeStatistics ( Statistics stats ) { 
if ( stats . isEmpty ( ) ) return ; 
if ( type . equals ( stats . type ) ) { 
incrementNumNulls ( stats . getNumNulls ( ) ) ; 
if ( stats . hasNonNullValue ( ) ) { 
mergeStatisticsMinMax ( stats ) ; 
markAsNotEmpty ( ) ; 
} 
} 
else throw StatisticsClassException . create ( this , stats ) ; 
} 
} 

public class AvroSchemaConverter { 
public static Schema getNonNull ( Schema schema ) { 
if ( schema . getType ( ) . equals ( Schema . Type . UNION ) ) { 
List < Schema > schemas = schema . getTypes ( ) ; 
if ( schemas . size ( ) == 2 ) if ( schemas . get ( 0 ) . getType ( ) . equals ( Schema . Type . NULL ) ) return schemas . get ( 1 ) ; 
else if ( schemas . get ( 1 ) . getType ( ) . equals ( Schema . Type . NULL ) ) return schemas . get ( 0 ) ; 
else return schema ; 
else return schema ; 
} 
else return schema ; 
} 
} 

public class GroupType { 
void membersDisplayString ( StringBuilder sb , String indent ) { 
for ( Type field : fields ) { 
field . writeToStringBuilder ( sb , indent ) ; 
if ( field . isPrimitive ( ) ) sb . append ( ";" ) ; 
sb . append ( "\n" ) ; 
} 
} 
} 

public class GroupType { 
List < Type > mergeFields ( GroupType toMerge , boolean strict ) { 
List < Type > newFields = new ArrayList < Type > ( ) ; 
for ( Type type : this . getFields ( ) ) { 
Type merged ; 
if ( toMerge . containsField ( type . getName ( ) ) ) { 
Type fieldToMerge = toMerge . getType ( type . getName ( ) ) ; 
if ( type . getLogicalTypeAnnotation ( ) != null && ! type . getLogicalTypeAnnotation ( ) . equals ( fieldToMerge . getLogicalTypeAnnotation ( ) ) ) throw new IncompatibleSchemaModificationException ( "cannot merge logical type " + fieldToMerge . getLogicalTypeAnnotation ( ) + " into " + type . getLogicalTypeAnnotation ( ) ) ; 
merged = type . union ( fieldToMerge , strict ) ; 
} 
else merged = type ; 
newFields . add ( merged ) ; 
} 
for ( Type type : toMerge . getFields ( ) ) { 
if ( ! this . containsField ( type . getName ( ) ) ) newFields . add ( type ) ; 
} 
return newFields ; 
} 
} 

public class ProtocolEventsAmender { 
private void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { 
TSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; 
ThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; 
int setSize = thriftSet . size ; 
for ( int i = 0 ; 
i < setSize ; 
i ++ ) checkField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; 
acceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; 
} 
} 

public class Util { 
public static FileMetaData readFileMetaData ( InputStream from , boolean skipRowGroups ) throws IOException { 
FileMetaData md = new FileMetaData ( ) ; 
if ( skipRowGroups ) readFileMetaData ( from , new DefaultFileMetaDataConsumer ( md ) , skipRowGroups ) ; 
else read ( from , md ) ; 
return md ; 
} 
} 

public class ValidTypeMap { 
public static < T extends Comparable < T > > void assertTypeValid ( Column < T > foundColumn , PrimitiveTypeName primitiveType ) { 
Class < T > foundColumnType = foundColumn . getColumnType ( ) ; 
ColumnPath columnPath = foundColumn . getColumnPath ( ) ; 
Set < PrimitiveTypeName > validTypeDescriptors = classToParquetType . get ( foundColumnType ) ; 
if ( validTypeDescriptors == null ) { 
StringBuilder message = new StringBuilder ( ) ; 
message . append ( "Column " ) . append ( columnPath . toDotString ( ) ) . append ( " was declared as type: " ) . append ( foundColumnType . getName ( ) ) . append ( " which is not supported in FilterPredicates." ) ; 
Set < Class < ? > > supportedTypes = parquetTypeToClass . get ( primitiveType ) ; 
if ( supportedTypes != null ) message . append ( " Supported types for this column are: " ) . append ( supportedTypes ) ; 
else message . append ( " There are no supported types for columns of " + primitiveType ) ; 
throw new IllegalArgumentException ( message . toString ( ) ) ; 
} 
if ( ! validTypeDescriptors . contains ( primitiveType ) ) { 
StringBuilder message = new StringBuilder ( ) ; 
message . append ( "FilterPredicate column: " ) . append ( columnPath . toDotString ( ) ) . append ( "'s declared type (" ) . append ( foundColumnType . getName ( ) ) . append ( ") does not match the schema found in file metadata. Column " ) . append ( columnPath . toDotString ( ) ) . append ( " is of type: " ) . append ( primitiveType ) . append ( "\nValid types for this column are: " ) . append ( parquetTypeToClass . get ( primitiveType ) ) ; 
throw new IllegalArgumentException ( message . toString ( ) ) ; 
} 
} 
} 

public class Ints { 
public static int checkedCast ( long value ) { 
int valueI = ( int ) value ; 
if ( valueI != value ) throw new IllegalArgumentException ( String . format ( "Overflow casting %d to an int" , value ) ) ; 
return valueI ; 
} 
} 

public class FilteredRecordReader { 
private void skipToMatch ( ) { 
while ( recordsRead < recordCount && ! recordFilter . isMatch ( ) ) { 
State currentState = getState ( 0 ) ; 
do { 
ColumnReader columnReader = currentState . column ; 
if ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) columnReader . skip ( ) ; 
columnReader . consume ( ) ; 
int nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; 
currentState = currentState . getNextState ( nextR ) ; 
} 
while ( currentState != null ) ; 
++ recordsRead ; 
} 
} 
} 

public class LruCache { 
public V remove ( final K key ) { 
V oldValue = cacheMap . remove ( key ) ; 
if ( oldValue != null ) LOG . debug ( "Removed cache entry for '{}'" , key ) ; 
return oldValue ; 
} 
} 

public class LruCache { 
public void put ( final K key , final V newValue ) { 
if ( newValue == null || ! newValue . isCurrent ( key ) ) { 
if ( LOG . isWarnEnabled ( ) ) LOG . warn ( "Ignoring new cache entry for '{}' because it is {}" , key , ( newValue == null ? "null" : "not current" ) ) ; 
return ; 
} 
V oldValue = cacheMap . get ( key ) ; 
if ( oldValue != null && oldValue . isNewerThan ( newValue ) ) { 
if ( LOG . isWarnEnabled ( ) ) LOG . warn ( "Ignoring new cache entry for '{}' because " + "existing cache entry is newer" , key ) ; 
return ; 
} 
oldValue = cacheMap . put ( key , newValue ) ; 
if ( LOG . isDebugEnabled ( ) ) if ( oldValue == null ) LOG . debug ( "Added new cache entry for '{}'" , key ) ; 
else LOG . debug ( "Overwrote existing cache entry for '{}'" , key ) ; 
} 
} 

public class AvroWriteSupport { 
private void writeValue ( Type type , Schema avroSchema , Object value ) { 
Schema nonNullAvroSchema = AvroSchemaConverter . getNonNull ( avroSchema ) ; 
LogicalType logicalType = nonNullAvroSchema . getLogicalType ( ) ; 
if ( logicalType != null ) { 
Conversion < ? > conversion = model . getConversionByClass ( value . getClass ( ) , logicalType ) ; 
writeValueWithoutConversion ( type , nonNullAvroSchema , convert ( nonNullAvroSchema , logicalType , conversion , value ) ) ; 
} 
else writeValueWithoutConversion ( type , nonNullAvroSchema , value ) ; 
} 
} 

public class AvroWriteSupport { 
@ SuppressWarnings ( "unchecked" ) private void writeValueWithoutConversion ( Type type , Schema avroSchema , Object value ) { 
switch ( avroSchema . getType ( ) ) { 
case BOOLEAN : recordConsumer . addBoolean ( ( Boolean ) value ) ; 
break ; 
case INT : if ( value instanceof Character ) recordConsumer . addInteger ( ( Character ) value ) ; 
else recordConsumer . addInteger ( ( ( Number ) value ) . intValue ( ) ) ; 
break ; 
case LONG : recordConsumer . addLong ( ( ( Number ) value ) . longValue ( ) ) ; 
break ; 
case FLOAT : recordConsumer . addFloat ( ( ( Number ) value ) . floatValue ( ) ) ; 
break ; 
case DOUBLE : recordConsumer . addDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; 
break ; 
case FIXED : recordConsumer . addBinary ( Binary . fromReusedByteArray ( ( ( GenericFixed ) value ) . bytes ( ) ) ) ; 
break ; 
case BYTES : if ( value instanceof byte [ ] ) recordConsumer . addBinary ( Binary . fromReusedByteArray ( ( byte [ ] ) value ) ) ; 
else recordConsumer . addBinary ( Binary . fromReusedByteBuffer ( ( ByteBuffer ) value ) ) ; 
break ; 
case STRING : recordConsumer . addBinary ( fromAvroString ( value ) ) ; 
break ; 
case RECORD : writeRecord ( type . asGroupType ( ) , avroSchema , value ) ; 
break ; 
case ENUM : recordConsumer . addBinary ( Binary . fromString ( value . toString ( ) ) ) ; 
break ; 
case ARRAY : listWriter . writeList ( type . asGroupType ( ) , avroSchema , value ) ; 
break ; 
case MAP : writeMap ( type . asGroupType ( ) , avroSchema , ( Map < CharSequence , ? > ) value ) ; 
break ; 
case UNION : writeUnion ( type . asGroupType ( ) , avroSchema , value ) ; 
break ; 
} 
} 


public class PathGlobPattern { 
public void set ( String glob ) { 
StringBuilder regex = new StringBuilder ( ) ; 
int setOpen = 0 ; 
int curlyOpen = 0 ; 
int len = glob . length ( ) ; 
hasWildcard = false ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c = glob . charAt ( i ) ; 
switch ( c ) { 
case BACKSLASH : if ( ++ i >= len ) error ( "Missing escaped character" , glob , i ) ; 
regex . append ( c ) . append ( glob . charAt ( i ) ) ; 
continue ; 
case '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; 
break ; 
case '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { 
regex . append ( '.' ) ; 
i ++ ; 
break ; 
} 
regex . append ( "[^" + PATH_SEPARATOR + "]" ) ; 
hasWildcard = true ; 
break ; 
case '?' : regex . append ( '.' ) ; 
hasWildcard = true ; 
continue ; 
case '{' : regex . append ( "(?:" ) ; 
curlyOpen ++ ; 
hasWildcard = true ; 
continue ; 
case ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; 
continue ; 
case '}' : if ( curlyOpen > 0 ) { 
curlyOpen -- ; 
regex . append ( ")" ) ; 
continue ; 
} 
break ; 
case '[' : if ( setOpen > 0 ) error ( "Unclosed character class" , glob , i ) ; 
setOpen ++ ; 
hasWildcard = true ; 
break ; 
case '^' : if ( setOpen == 0 ) regex . append ( BACKSLASH ) ; 
break ; 
case '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; 
continue ; 
case ']' : setOpen = 0 ; 
break ; 
default : } 
regex . append ( c ) ; 
} 
if ( setOpen > 0 ) error ( "Unclosed character class" , glob , len ) ; 
if ( curlyOpen > 0 ) error ( "Unclosed group" , glob , len ) ; 
compiled = Pattern . compile ( regex . toString ( ) ) ; 
} 
} 

public class BaseCommand { 
public void output ( String content , Logger console , String filename ) throws IOException { 
if ( filename == null || "-" . equals ( filename ) ) console . info ( content ) ; 
else { 
FSDataOutputStream outgoing = create ( filename ) ; 
try { 
outgoing . write ( content . getBytes ( StandardCharsets . UTF_8 ) ) ; 
} 
finally { 
outgoing . close ( ) ; 
} 
} 
} 
} 

public class BaseCommand { 
public InputStream open ( String filename ) throws IOException { 
if ( STDIN_AS_SOURCE . equals ( filename ) ) return System . in ; 
URI uri = qualifiedURI ( filename ) ; 
if ( RESOURCE_URI_SCHEME . equals ( uri . getScheme ( ) ) ) return Resources . getResource ( uri . getRawSchemeSpecificPart ( ) ) . openStream ( ) ; 
else { 
Path filePath = new Path ( uri ) ; 
FileSystem fs = filePath . getFileSystem ( getConf ( ) ) ; 
return fs . open ( filePath ) ; 
} 
} 
} 

public class ColumnRecordFilter { 
public static final UnboundRecordFilter column ( final String columnPath , final ColumnPredicates . Predicate predicate ) { 
checkNotNull ( columnPath , "columnPath" ) ; 
checkNotNull ( predicate , "predicate" ) ; 
return new UnboundRecordFilter ( ) { 
final String [ ] filterPath = columnPath . split ( "\\." ) ; 
@ Override public RecordFilter bind ( Iterable < ColumnReader > readers ) { 
for ( ColumnReader reader : readers ) { 
if ( Arrays . equals ( reader . getDescriptor ( ) . getPath ( ) , filterPath ) ) return new ColumnRecordFilter ( reader , predicate ) ; 
} 
throw new IllegalArgumentException ( "Column " + columnPath + " does not exist." ) ; 
} 
} 
; 
} 
} 

public class ConversionPatterns { 
private static GroupType listWrapper ( Repetition repetition , String alias , LogicalTypeAnnotation logicalTypeAnnotation , Type nested ) { 
if ( ! nested . isRepetition ( Repetition . REPEATED ) ) throw new IllegalArgumentException ( "Nested type should be repeated: " + nested ) ; 
return new GroupType ( repetition , alias , logicalTypeAnnotation , nested ) ; 
} 
} 

public class InitContext { 
@ Deprecated public Map < String , String > getMergedKeyValueMetaData ( ) { 
if ( mergedKeyValueMetadata == null ) { 
Map < String , String > mergedKeyValues = new HashMap < String , String > ( ) ; 
for ( Entry < String , Set < String > > entry : keyValueMetadata . entrySet ( ) ) { 
if ( entry . getValue ( ) . size ( ) > 1 ) throw new RuntimeException ( "could not merge metadata: key " + entry . getKey ( ) + " has conflicting values: " + entry . getValue ( ) ) ; 
mergedKeyValues . put ( entry . getKey ( ) , entry . getValue ( ) . iterator ( ) . next ( ) ) ; 
} 
mergedKeyValueMetadata = mergedKeyValues ; 
} 
return mergedKeyValueMetadata ; 
} 
} 

public class ParquetRecordReaderWrapper { 
protected ParquetInputSplit getSplit ( final InputSplit oldSplit , final JobConf conf ) throws IOException { 
if ( oldSplit instanceof FileSplit ) { 
FileSplit fileSplit = ( FileSplit ) oldSplit ; 
final long splitStart = fileSplit . getStart ( ) ; 
final long splitLength = fileSplit . getLength ( ) ; 
final Path finalPath = fileSplit . getPath ( ) ; 
final JobConf cloneJob = hiveBinding . pushProjectionsAndFilters ( conf , finalPath . getParent ( ) ) ; 
final ParquetMetadata parquetMetadata = ParquetFileReader . readFooter ( cloneJob , finalPath , SKIP_ROW_GROUPS ) ; 
final FileMetaData fileMetaData = parquetMetadata . getFileMetaData ( ) ; 
final ReadContext readContext = new DataWritableReadSupport ( ) . init ( cloneJob , fileMetaData . getKeyValueMetaData ( ) , fileMetaData . getSchema ( ) ) ; 
schemaSize = MessageTypeParser . parseMessageType ( readContext . getReadSupportMetadata ( ) . get ( DataWritableReadSupport . HIVE_SCHEMA_KEY ) ) . getFieldCount ( ) ; 
return new ParquetInputSplit ( finalPath , splitStart , splitStart + splitLength , splitLength , fileSplit . getLocations ( ) , null ) ; 
} 
else throw new IllegalArgumentException ( "Unknown split type: " + oldSplit ) ; 
} 
} 

public class AvroRecordConverter { 
private static Map < String , Class < ? > > getFieldsByName ( Class < ? > recordClass , boolean excludeJava ) { 
Map < String , Class < ? > > fields = new LinkedHashMap < String , Class < ? > > ( ) ; 
if ( recordClass != null ) { 
Class < ? > current = recordClass ; 
do { 
if ( excludeJava && current . getPackage ( ) != null && current . getPackage ( ) . getName ( ) . startsWith ( "java." ) ) break ; 
for ( Field field : current . getDeclaredFields ( ) ) { 
if ( field . isAnnotationPresent ( AvroIgnore . class ) || isTransientOrStatic ( field ) ) continue ; 
AvroName altName = field . getAnnotation ( AvroName . class ) ; 
Class < ? > existing = fields . put ( altName != null ? altName . value ( ) : field . getName ( ) , field . getType ( ) ) ; 
if ( existing != null ) throw new AvroTypeException ( current + " contains two fields named: " + field . getName ( ) ) ; 
} 
current = current . getSuperclass ( ) ; 
} 
while ( current != null ) ; 
} 
return fields ; 
} 
} 

public class MergeCommand { 
private List < Path > getInputFiles ( List < String > input ) throws IOException { 
List < Path > inputFiles = null ; 
if ( input . size ( ) == 1 ) { 
Path p = new Path ( input . get ( 0 ) ) ; 
FileSystem fs = p . getFileSystem ( conf ) ; 
FileStatus status = fs . getFileStatus ( p ) ; 
if ( status . isDir ( ) ) inputFiles = getInputFilesFromDirectory ( status ) ; 
} 
else inputFiles = parseInputFiles ( input ) ; 
checkParquetFiles ( inputFiles ) ; 
return inputFiles ; 
} 
} 

public class MergeCommand { 
private void checkParquetFiles ( List < Path > inputFiles ) throws IOException { 
if ( inputFiles == null || inputFiles . size ( ) <= 1 ) throw new IllegalArgumentException ( "Not enough files to merge" ) ; 
for ( Path inputFile : inputFiles ) { 
FileSystem fs = inputFile . getFileSystem ( conf ) ; 
FileStatus status = fs . getFileStatus ( inputFile ) ; 
if ( status . isDir ( ) ) throw new IllegalArgumentException ( "Illegal parquet file: " + inputFile . toUri ( ) ) ; 
} 
} 
} 

public class ByteBasedBitPackingEncoder { 
public void writeInt ( int value ) throws IOException { 
input [ inputSize ] = value ; 
++ inputSize ; 
if ( inputSize == VALUES_WRITTEN_AT_A_TIME ) { 
pack ( ) ; 
if ( packedPosition == slabSize ) { 
slabs . add ( BytesInput . from ( packed ) ) ; 
totalFullSlabSize += slabSize ; 
if ( slabSize < bitWidth * MAX_SLAB_SIZE_MULT ) slabSize *= 2 ; 
initPackedSlab ( ) ; 
} 
} 
} 
} 

public class MapR52StreamsValidationUtil09 { 
@ Override public void createTopicIfNotExists ( String topic , Map < String , Object > kafkaClientConfigs , String metadataBrokerList ) throws StageException { 
if ( topic . startsWith ( "/" ) && topic . contains ( ":" ) ) { 
String [ ] path = topic . split ( ":" ) ; 
if ( path . length != 2 ) throw new StageException ( MapRStreamsErrors . MAPRSTREAMS_21 , topic ) ; 
String streamPath = path [ 0 ] ; 
if ( ! streamCache . contains ( streamPath ) ) { 
Configuration conf = new Configuration ( ) ; 
kafkaClientConfigs . forEach ( ( k , v ) -> { 
conf . set ( k , v . toString ( ) ) ; 
} 
) ; 
Admin streamAdmin = null ; 
try { 
streamAdmin = Streams . newAdmin ( conf ) ; 
streamAdmin . countTopics ( streamPath ) ; 
streamCache . add ( streamPath ) ; 
} 
catch ( TableNotFoundException e ) { 
LOG . debug ( "Stream not found. Creating a new stream: " + streamPath ) ; 
try { 
streamAdmin . createStream ( streamPath , Streams . newStreamDescriptor ( ) ) ; 
streamCache . add ( streamPath ) ; 
} 
catch ( IOException ioex ) { 
throw new StageException ( MapRStreamsErrors . MAPRSTREAMS_22 , streamPath , e . getMessage ( ) , e ) ; 
} 
} 
catch ( IOException | IllegalArgumentException e ) { 
throw new StageException ( MapRStreamsErrors . MAPRSTREAMS_23 , e . getMessage ( ) , e ) ; 
} 
finally { 
if ( streamAdmin != null ) streamAdmin . close ( ) ; 
} 
} 
} 
KafkaProducer < String , String > kafkaProducer = createProducerTopicMetadataClient ( kafkaClientConfigs ) ; 
kafkaProducer . partitionsFor ( topic ) ; 
} 
} 

public class PipelineBeanCreator { 
public PipelineStageBeans duplicatePipelineStageBeans ( StageLibraryTask stageLib , PipelineStageBeans pipelineStageBeans , InterceptorCreatorContextBuilder interceptorCreatorContextBuilder , Map < String , Object > constants , List < Issue > errors ) { 
List < StageBean > stageBeans = new ArrayList < > ( pipelineStageBeans . size ( ) ) ; 
for ( StageBean original : pipelineStageBeans . getStages ( ) ) { 
Map < Class , ServiceDefinition > services = original . getServices ( ) . stream ( ) . collect ( Collectors . toMap ( c -> c . getDefinition ( ) . getProvides ( ) , ServiceBean :: getDefinition ) ) ; 
StageBean stageBean = createStage ( stageLib , original . getDefinition ( ) , ClassLoaderReleaser . NOOP_RELEASER , original . getConfiguration ( ) , services :: get , interceptorCreatorContextBuilder , constants , errors ) ; 
if ( stageBean != null ) stageBeans . add ( stageBean ) ; 
} 
return new PipelineStageBeans ( stageBeans ) ; 
} 
} 

public class PipelineBeanCreator { 
public StageBean createStageBean ( boolean forExecution , StageLibraryTask library , StageConfiguration stageConf , boolean validateAnnotations , boolean errorStage , boolean pipelineLifecycleStage , Map < String , Object > constants , InterceptorCreatorContextBuilder interceptorContextBuilder , List < Issue > errors ) { 
IssueCreator issueCreator = IssueCreator . getStage ( stageConf . getInstanceName ( ) ) ; 
StageBean bean = null ; 
StageDefinition stageDef = library . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , forExecution ) ; 
if ( stageDef != null ) { 
if ( validateAnnotations ) if ( pipelineLifecycleStage ) if ( ! stageDef . isPipelineLifecycleStage ( ) ) errors . add ( issueCreator . create ( CreationError . CREATION_018 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; 
else if ( stageDef . isErrorStage ( ) != errorStage ) if ( stageDef . isErrorStage ( ) ) errors . add ( issueCreator . create ( CreationError . CREATION_007 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; 
else errors . add ( issueCreator . create ( CreationError . CREATION_008 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; 
bean = createStage ( library , stageDef , library , stageConf , serviceClass -> library . getServiceDefinition ( serviceClass , true ) , interceptorContextBuilder , constants , errors ) ; 
} 
else errors . add ( issueCreator . create ( CreationError . CREATION_006 , stageConf . getLibrary ( ) , stageConf . getStageName ( ) , stageConf . getStageVersion ( ) ) ) ; 
return bean ; 
} 
} 

public class PipelineBeanCreator { 
public List < InterceptorBean > createInterceptors ( StageLibraryTask stageLib , StageConfiguration stageConfiguration , StageDefinition stageDefinition , InterceptorCreatorContextBuilder contextBuilder , InterceptorCreator . InterceptorType interceptorType , List < Issue > issues ) { 
List < InterceptorBean > beans = new ArrayList < > ( ) ; 
if ( contextBuilder == null ) return beans ; 
for ( InterceptorDefinition definition : stageLib . getInterceptorDefinitions ( ) ) { 
InterceptorBean bean = createInterceptor ( stageLib , definition , stageConfiguration , stageDefinition , contextBuilder , interceptorType , issues ) ; 
if ( bean != null ) beans . add ( bean ) ; 
} 
return beans ; 
} 
} 

public class PipelineBeanCreator { 
public InterceptorBean createInterceptor ( StageLibraryTask stageLib , InterceptorDefinition definition , StageConfiguration stageConfiguration , StageDefinition stageDefinition , InterceptorCreatorContextBuilder contextBuilder , InterceptorCreator . InterceptorType interceptorType , List < Issue > issues ) { 
ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
InterceptorCreator . Context context = contextBuilder . buildFor ( definition . getLibraryDefinition ( ) . getName ( ) , definition . getKlass ( ) . getName ( ) , stageConfiguration , stageDefinition , interceptorType ) ; 
try { 
Thread . currentThread ( ) . setContextClassLoader ( definition . getStageClassLoader ( ) ) ; 
InterceptorCreator creator = definition . getDefaultCreator ( ) . newInstance ( ) ; 
Interceptor interceptor = creator . create ( context ) ; 
if ( interceptor == null ) return null ; 
return new InterceptorBean ( definition , interceptor , stageLib ) ; 
} 
catch ( IllegalAccessException | InstantiationException e ) { 
LOG . debug ( "Can't instantiate interceptor: {}" , e . toString ( ) , e ) ; 
IssueCreator issueCreator = IssueCreator . getStage ( stageDefinition . getName ( ) ) ; 
issues . add ( issueCreator . create ( CreationError . CREATION_000 , "interceptor" , definition . getKlass ( ) . getName ( ) , e . toString ( ) ) ) ; 
} 
finally { 
Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; 
} 
return null ; 
} 
} 

public class AvroTypeUtil { 
private static int millisToDays ( long millisLocal ) { 
long millisUtc = millisLocal + localTimeZone . getOffset ( millisLocal ) ; 
int days ; 
if ( millisUtc >= 0L ) days = ( int ) ( millisUtc / MILLIS_PER_DAY ) ; 
else days = ( int ) ( ( millisUtc - 86399999 ) / MILLIS_PER_DAY ) ; 
return days ; 
} 
} 

public class AvroTypeUtil { 
public static String getAvroSchemaFromHeader ( Record record , String headerName ) throws DataGeneratorException { 
String jsonSchema = record . getHeader ( ) . getAttribute ( headerName ) ; 
if ( jsonSchema == null || jsonSchema . isEmpty ( ) ) throw new DataGeneratorException ( Errors . AVRO_GENERATOR_03 , record . getHeader ( ) . getSourceId ( ) ) ; 
return jsonSchema ; 
} 
} 

public class RecordWriter { 
public long getLength ( ) throws IOException { 
long length = - 1 ; 
if ( generator != null ) length = textOutputStream . getByteCount ( ) ; 
else if ( seqWriter != null ) length = seqWriter . getLength ( ) ; 
return length ; 
} 
} 

public class BaseClusterProvider { 
private void copyBlobstore ( List < String > blobStoreResources , File rootDataDir , File pipelineDir ) throws IOException { 
if ( blobStoreResources == null ) return ; 
File blobstoreDir = new File ( runtimeInfo . getDataDir ( ) , BLOBSTORE_BASE_DIR ) ; 
File stagingBlobstoreDir = new File ( rootDataDir , BLOBSTORE_BASE_DIR ) ; 
if ( ! stagingBlobstoreDir . exists ( ) ) if ( ! stagingBlobstoreDir . mkdirs ( ) ) throw new RuntimeException ( "Failed to create blobstore directory: " + pipelineDir . getPath ( ) ) ; 
for ( String blobstoreFile : blobStoreResources ) { 
File srcFile = new File ( blobstoreDir , blobstoreFile ) ; 
if ( srcFile . exists ( ) ) { 
final File dstFile = new File ( stagingBlobstoreDir , srcFile . getName ( ) ) ; 
if ( srcFile . canRead ( ) ) try ( InputStream in = new FileInputStream ( ( srcFile ) ) ) { 
try ( OutputStream out = new FileOutputStream ( ( dstFile ) ) ) { 
IOUtils . copy ( in , out ) ; 
} 
} 
} 
} 
} 
} 

public class ThreadHealthReporter { 
public boolean register ( String threadName ) { 
if ( threadToGaugeMap . containsKey ( threadName ) ) return false ; 
ThreadHealthReportGauge threadHealthReportGauge = new ThreadHealthReportGauge ( ) ; 
MetricsConfigurator . createGauge ( metrics , getHealthGaugeName ( threadName ) , threadHealthReportGauge , name , rev ) ; 
threadToGaugeMap . put ( threadName , threadHealthReportGauge ) ; 
return true ; 
} 
} 

public class RuntimeInfo { 
public static void storeControlHubConfigs ( RuntimeInfo runtimeInfo , Map < String , String > newConfigs ) throws IOException { 
File configFile = new File ( runtimeInfo . getDataDir ( ) , SCH_CONF_OVERRIDE ) ; 
Properties properties = new Properties ( ) ; 
if ( configFile . exists ( ) ) try ( FileReader reader = new FileReader ( configFile ) ) { 
properties . load ( reader ) ; 
} 
for ( Map . Entry < String , String > entry : newConfigs . entrySet ( ) ) { 
if ( entry . getValue ( ) == null ) properties . remove ( entry . getKey ( ) ) ; 
else properties . setProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
try ( FileWriter writer = new FileWriter ( configFile ) ) { 
properties . store ( writer , null ) ; 
} 
} 
} 

public class LdapLoginModule { 
protected boolean credentialLogin ( Object webCredential ) throws LoginException { 
boolean credResult = getCurrentUser ( ) . checkCredential ( webCredential ) ; 
setAuthenticated ( credResult ) ; 
if ( ! credResult ) LOG . warn ( "Authentication failed - Possibly the user password is wrong" ) ; 
return isAuthenticated ( ) ; 
} 
} 

public class PipelineConfigurationUpgrader { 
public PipelineConfiguration upgradeIfNecessary ( StageLibraryTask library , PipelineConfiguration pipelineConf , List < Issue > issues ) { 
Preconditions . checkArgument ( issues . isEmpty ( ) , "Given list of issues must be empty." ) ; 
boolean upgrade ; 
upgrade = needsSchemaUpgrade ( pipelineConf , issues ) ; 
if ( upgrade && issues . isEmpty ( ) ) pipelineConf = upgradeSchema ( library , pipelineConf , issues ) ; 
if ( ! issues . isEmpty ( ) ) return null ; 
upgrade = needsUpgrade ( library , pipelineConf , issues ) ; 
if ( upgrade && issues . isEmpty ( ) ) pipelineConf = upgrade ( library , pipelineConf , issues ) ; 
return ( issues . isEmpty ( ) ) ? pipelineConf : null ; 
} 
} 

public class PipelineConfigurationUpgrader { 
private static ServiceConfiguration upgradeServicesIfNeeded ( StageLibraryTask library , StageConfiguration stageConf , ServiceConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { 
ServiceDefinition def = library . getServiceDefinition ( conf . getService ( ) , false ) ; 
if ( def == null ) issues . add ( issueCreator . create ( ContainerError . CONTAINER_0903 , conf . getService ( ) . getName ( ) ) ) ; 
int fromVersion = conf . getServiceVersion ( ) ; 
int toVersion = def . getVersion ( ) ; 
if ( ! needsUpgrade ( toVersion , fromVersion , issueCreator , issues ) ) return conf ; 
ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
try { 
LOG . warn ( "Upgrading service instance from version '{}' to version '{}'" , conf . getServiceVersion ( ) , def . getVersion ( ) ) ; 
UpgradeContext upgradeContext = new UpgradeContext ( "" , def . getName ( ) , stageConf . getInstanceName ( ) , fromVersion , toVersion ) ; 
List < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; 
if ( ! upgradeContext . registeredServices . isEmpty ( ) ) throw new StageException ( ContainerError . CONTAINER_0904 ) ; 
conf . setServiceVersion ( toVersion ) ; 
conf . setConfig ( configs ) ; 
} 
catch ( StageException ex ) { 
issues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; 
} 
finally { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
} 
return conf ; 
} 
} 

public class PipelineConfigurationUpgrader { 
static private void upgradeStageIfNeeded ( StageDefinition def , StageConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { 
int fromVersion = conf . getStageVersion ( ) ; 
int toVersion = def . getVersion ( ) ; 
if ( ! needsUpgrade ( toVersion , fromVersion , IssueCreator . getStage ( conf . getInstanceName ( ) ) , issues ) ) return ; 
ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
try { 
Thread . currentThread ( ) . setContextClassLoader ( def . getStageClassLoader ( ) ) ; 
LOG . warn ( "Upgrading stage instance '{}' from version '{}' to version '{}'" , conf . getInstanceName ( ) , fromVersion , toVersion ) ; 
UpgradeContext upgradeContext = new UpgradeContext ( def . getLibrary ( ) , def . getName ( ) , conf . getInstanceName ( ) , fromVersion , toVersion ) ; 
List < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; 
conf . setStageVersion ( def . getVersion ( ) ) ; 
conf . setConfig ( configs ) ; 
if ( ! upgradeContext . registeredServices . isEmpty ( ) ) { 
List < ServiceConfiguration > services = new ArrayList < > ( ) ; 
services . addAll ( conf . getServices ( ) ) ; 
upgradeContext . registeredServices . forEach ( ( s , c ) -> services . add ( new ServiceConfiguration ( s , - 1 , c ) ) ) ; 
conf . setServices ( services ) ; 
} 
} 
catch ( StageException ex ) { 
issues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; 
} 
finally { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
} 
} 
} 

public class FieldValueReplacerProcessor { 
private List < String > getFieldsToNull ( List < NullReplacerConditionalConfig > nullReplacerConditionalConfigs , Set < String > fieldsThatDoNotExist , Set < String > fieldPaths , Record record ) throws OnRecordErrorException { 
List < String > fieldsToNull = new ArrayList < > ( ) ; 
for ( NullReplacerConditionalConfig nullReplacerConditionalConfig : nullReplacerConditionalConfigs ) { 
List < String > fieldNamesToNull = nullReplacerConditionalConfig . fieldsToNull ; 
List < String > fieldPathsToNull = new ArrayList < > ( ) ; 
for ( String fieldNameToNull : fieldNamesToNull ) { 
try { 
final List < String > matchingPaths = FieldPathExpressionUtil . evaluateMatchingFieldPaths ( fieldNameToNull , fieldPathEval , fieldPathVars , record , fieldPaths ) ; 
if ( matchingPaths . isEmpty ( ) ) fieldsThatDoNotExist . add ( fieldNameToNull ) ; 
else for ( String matchingField : matchingPaths ) { 
if ( record . has ( matchingField ) ) fieldPathsToNull . add ( matchingField ) ; 
else fieldsThatDoNotExist . add ( matchingField ) ; 
} 
} 
catch ( ELEvalException e ) { 
LOG . error ( "Error evaluating condition: " + nullReplacerConditionalConfig . condition , e ) ; 
throw new OnRecordErrorException ( record , Errors . VALUE_REPLACER_07 , fieldNameToNull , e . toString ( ) , e ) ; 
} 
} 
try { 
boolean evaluatedCondition = true ; 
if ( ! StringUtils . isEmpty ( nullReplacerConditionalConfig . condition ) ) evaluatedCondition = nullConditionELEval . eval ( nullConditionELVars , nullReplacerConditionalConfig . condition , Boolean . class ) ; 
if ( evaluatedCondition ) fieldsToNull . addAll ( fieldPathsToNull ) ; 
} 
catch ( ELEvalException e ) { 
LOG . error ( "Error evaluating condition: " + nullReplacerConditionalConfig . condition , e ) ; 
throw new OnRecordErrorException ( record , Errors . VALUE_REPLACER_06 , nullReplacerConditionalConfig . condition , e . toString ( ) ) ; 
} 
} 
return fieldsToNull ; 
} 
} 

public class SystemPackage { 
private static boolean isSystemClass ( String name , List < String > packageList ) { 
boolean result = false ; 
if ( packageList != null ) { 
String canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; 
for ( String c : packageList ) { 
boolean shouldInclude = true ; 
if ( c . startsWith ( "-" ) ) { 
c = c . substring ( 1 ) ; 
shouldInclude = false ; 
} 
if ( canonicalName . startsWith ( c ) ) if ( c . endsWith ( "." ) || canonicalName . length ( ) == c . length ( ) || canonicalName . length ( ) > c . length ( ) && canonicalName . charAt ( c . length ( ) ) == '$' ) if ( shouldInclude ) result = true ; 
else return false ; 
} 
} 
return result ; 
} 
} 

public class XEvictingQueue { 
@ Override public boolean add ( E e ) { 
checkNotNull ( e ) ; 
if ( maxSize == 0 ) return true ; 
if ( size ( ) == maxSize ) delegate . remove ( ) ; 
delegate . add ( e ) ; 
return true ; 
} 
} 

public class XEvictingQueue { 
public E addAndGetEvicted ( E e ) { 
checkNotNull ( e ) ; 
if ( maxSize == 0 ) return null ; 
E evicted = null ; 
if ( size ( ) == maxSize ) evicted = delegate . remove ( ) ; 
delegate . add ( e ) ; 
return evicted ; 
} 
} 

public class OptionalLoadingCache { 
private Optional < Value > valueOrDefault ( Key key , Optional < Value > value ) { 
if ( value . isPresent ( ) ) return value ; 
if ( ! cacheMissingValues ) delegate . invalidate ( key ) ; 
return defaultValue ; 
} 
} 

public class PreviewPipelineRunner { 
private List < StageOutput > addReportedErrorsIfNeeded ( List < StageOutput > snapshotsOfAllStagesOutput ) { 
synchronized ( this . reportedErrors ) { 
if ( reportedErrors . isEmpty ( ) ) return snapshotsOfAllStagesOutput ; 
try { 
return snapshotsOfAllStagesOutput . stream ( ) . map ( so -> new StageOutput ( so . getInstanceName ( ) , so . getOutput ( ) , so . getErrorRecords ( ) , reportedErrors . get ( so . getInstanceName ( ) ) , so . getEventRecords ( ) ) ) . collect ( Collectors . toList ( ) ) ; 
} 
finally { 
reportedErrors . clear ( ) ; 
} 
} 
} 
} 

public class ProtobufTypeUtil { 
public static void populateDefaultsAndExtensions ( Map < String , Descriptors . FileDescriptor > fileDescriptorMap , Map < String , Set < Descriptors . FieldDescriptor > > typeToExtensionMap , Map < String , Object > defaultValueMap ) { 
for ( Descriptors . FileDescriptor f : fileDescriptorMap . values ( ) ) { 
for ( Descriptors . FieldDescriptor fieldDescriptor : f . getExtensions ( ) ) { 
String containingType = fieldDescriptor . getContainingType ( ) . getFullName ( ) ; 
Set < Descriptors . FieldDescriptor > fieldDescriptors = typeToExtensionMap . get ( containingType ) ; 
if ( fieldDescriptors == null ) { 
fieldDescriptors = new LinkedHashSet < > ( ) ; 
typeToExtensionMap . put ( containingType , fieldDescriptors ) ; 
} 
fieldDescriptors . add ( fieldDescriptor ) ; 
if ( fieldDescriptor . hasDefaultValue ( ) ) defaultValueMap . put ( containingType + "." + fieldDescriptor . getName ( ) , fieldDescriptor . getDefaultValue ( ) ) ; 
} 
for ( Descriptors . Descriptor d : f . getMessageTypes ( ) ) { 
addDefaultsAndExtensions ( typeToExtensionMap , defaultValueMap , d ) ; 
} 
} 
} 
} 

public class ProtobufTypeUtil { 
public static Descriptors . Descriptor getDescriptor ( DescriptorProtos . FileDescriptorSet set , Map < String , Descriptors . FileDescriptor > fileDescriptorMap , String descriptorFile , String qualifiedMessageType ) throws StageException { 
String packageName = null ; 
String messageType = qualifiedMessageType ; 
int lastIndex = qualifiedMessageType . lastIndexOf ( '.' ) ; 
if ( lastIndex != - 1 ) { 
packageName = qualifiedMessageType . substring ( 0 , lastIndex ) ; 
messageType = qualifiedMessageType . substring ( lastIndex + 1 ) ; 
} 
DescriptorProtos . FileDescriptorProto file = getFileDescProtoForMsgType ( packageName , messageType , set ) ; 
if ( file == null ) throw new StageException ( Errors . PROTOBUF_00 , qualifiedMessageType , descriptorFile ) ; 
Descriptors . FileDescriptor fileDescriptor = fileDescriptorMap . get ( file . getName ( ) ) ; 
return fileDescriptor . findMessageTypeByName ( messageType ) ; 
} 
} 

public class ProtobufTypeUtil { 
public static Field protobufToSdcField ( Record record , String fieldPath , Descriptors . Descriptor descriptor , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Object message ) throws DataParserException { 
LinkedHashMap < String , Field > sdcRecordMapFieldValue = new LinkedHashMap < > ( ) ; 
Map < String , Descriptors . FieldDescriptor > protobufFields = new LinkedHashMap < > ( ) ; 
for ( Descriptors . FieldDescriptor fieldDescriptor : descriptor . getFields ( ) ) { 
protobufFields . put ( fieldDescriptor . getName ( ) , fieldDescriptor ) ; 
} 
Map < Descriptors . FieldDescriptor , Object > values = ( ( DynamicMessage ) message ) . getAllFields ( ) ; 
for ( Descriptors . FieldDescriptor fieldDescriptor : protobufFields . values ( ) ) { 
Object value = values . get ( fieldDescriptor ) ; 
sdcRecordMapFieldValue . put ( fieldDescriptor . getName ( ) , createField ( record , fieldPath , fieldDescriptor , messageTypeToExtensionMap , value ) ) ; 
} 
if ( messageTypeToExtensionMap . containsKey ( descriptor . getFullName ( ) ) ) for ( Descriptors . FieldDescriptor fieldDescriptor : messageTypeToExtensionMap . get ( descriptor . getFullName ( ) ) ) { 
if ( values . containsKey ( fieldDescriptor ) ) { 
Object value = values . get ( fieldDescriptor ) ; 
sdcRecordMapFieldValue . put ( fieldDescriptor . getName ( ) , createField ( record , fieldPath , fieldDescriptor , messageTypeToExtensionMap , value ) ) ; 
} 
} 
UnknownFieldSet unknownFields = ( ( DynamicMessage ) message ) . getUnknownFields ( ) ; 
if ( ! unknownFields . asMap ( ) . isEmpty ( ) ) { 
ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; 
try { 
unknownFields . writeDelimitedTo ( bOut ) ; 
bOut . flush ( ) ; 
bOut . close ( ) ; 
} 
catch ( IOException e ) { 
throw new DataParserException ( Errors . PROTOBUF_10 , e . toString ( ) , e ) ; 
} 
String path = fieldPath . isEmpty ( ) ? FORWARD_SLASH : fieldPath ; 
byte [ ] bytes = org . apache . commons . codec . binary . Base64 . encodeBase64 ( bOut . toByteArray ( ) ) ; 
record . getHeader ( ) . setAttribute ( PROTOBUF_UNKNOWN_FIELDS_PREFIX + path , new String ( bytes , StandardCharsets . UTF_8 ) ) ; 
} 
return Field . createListMap ( sdcRecordMapFieldValue ) ; 
} 
} 

public class ProtobufTypeUtil { 
private static DynamicMessage sdcFieldToProtobufMsg ( Record record , Field field , String fieldPath , Descriptors . Descriptor desc , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Map < String , Object > defaultValueMap ) throws DataGeneratorException { 
if ( field == null ) return null ; 
DynamicMessage . Builder builder = DynamicMessage . newBuilder ( desc ) ; 
List < Descriptors . FieldDescriptor > fields = new ArrayList < > ( ) ; 
fields . addAll ( desc . getFields ( ) ) ; 
if ( messageTypeToExtensionMap . containsKey ( desc . getFullName ( ) ) ) fields . addAll ( messageTypeToExtensionMap . get ( desc . getFullName ( ) ) ) ; 
Map < String , Field > valueAsMap = field . getValueAsMap ( ) ; 
for ( Descriptors . FieldDescriptor f : fields ) { 
Field mapField = valueAsMap . get ( f . getName ( ) ) ; 
if ( f . isMapField ( ) ) handleMapField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; 
else if ( f . isRepeated ( ) ) if ( mapField != null ) handleRepeatedField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; 
else handleNonRepeatedField ( record , valueAsMap , fieldPath , messageTypeToExtensionMap , defaultValueMap , desc , f , builder ) ; 
} 
try { 
handleUnknownFields ( record , fieldPath , builder ) ; 
} 
catch ( IOException e ) { 
throw new DataGeneratorException ( Errors . PROTOBUF_05 , e . toString ( ) , e ) ; 
} 
return builder . build ( ) ; 
} 
} 

public class KuduUtils { 
public static Field . Type convertFromKuduType ( Type kuduType ) { 
switch ( kuduType ) { 
case BINARY : return Field . Type . BYTE_ARRAY ; 
case BOOL : return Field . Type . BOOLEAN ; 
case DOUBLE : return Field . Type . DOUBLE ; 
case FLOAT : return Field . Type . FLOAT ; 
case INT8 : return Field . Type . BYTE ; 
case INT16 : return Field . Type . SHORT ; 
case INT32 : return Field . Type . INTEGER ; 
case INT64 : return Field . Type . LONG ; 
case STRING : return Field . Type . STRING ; 
case UNIXTIME_MICROS : return Field . Type . DATETIME ; 
default : if ( "DECIMAL" . equals ( kuduType . name ( ) ) ) return Field . Type . DECIMAL ; 
throw new UnsupportedOperationException ( "Unknown data type: " + kuduType . getName ( ) ) ; 
} 
} 
} 

public class KuduUtils { 
public static Field createField ( RowResult result , String fieldName , Type type ) throws StageException { 
switch ( type ) { 
case INT8 : return Field . create ( Field . Type . BYTE , result . getByte ( fieldName ) ) ; 
case INT16 : return Field . create ( Field . Type . SHORT , result . getShort ( fieldName ) ) ; 
case INT32 : return Field . create ( Field . Type . INTEGER , result . getInt ( fieldName ) ) ; 
case INT64 : return Field . create ( Field . Type . LONG , result . getLong ( fieldName ) ) ; 
case BINARY : try { 
return Field . create ( Field . Type . BYTE_ARRAY , result . getBinary ( fieldName ) ) ; 
} 
catch ( IllegalArgumentException ex ) { 
throw new OnRecordErrorException ( Errors . KUDU_35 , fieldName ) ; 
} 
case STRING : return Field . create ( Field . Type . STRING , result . getString ( fieldName ) ) ; 
case BOOL : return Field . create ( Field . Type . BOOLEAN , result . getBoolean ( fieldName ) ) ; 
case FLOAT : return Field . create ( Field . Type . FLOAT , result . getFloat ( fieldName ) ) ; 
case DOUBLE : return Field . create ( Field . Type . DOUBLE , result . getDouble ( fieldName ) ) ; 
case UNIXTIME_MICROS : return Field . create ( Field . Type . DATETIME , new Date ( result . getLong ( fieldName ) / 1000L ) ) ; 
default : if ( "DECIMAL" . equals ( type . name ( ) ) ) return Field . create ( Field . Type . DECIMAL , result . getDecimal ( fieldName ) ) ; 
throw new StageException ( Errors . KUDU_10 , fieldName , type . getName ( ) ) ; 
} 
} 
} 

public class FileLine { 
public String getText ( ) { 
if ( line == null ) line = new String ( buffer , offsetInChunk , length , charset ) ; 
return line ; 
} 
} 

public class ValidationUtil { 
public static void addMissingConfigsToStage ( StageLibraryTask stageLibrary , StageConfiguration stageConf ) { 
StageDefinition stageDef = stageLibrary . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , false ) ; 
if ( stageDef != null ) for ( ConfigDefinition configDef : stageDef . getConfigDefinitions ( ) ) { 
String configName = configDef . getName ( ) ; 
Config config = stageConf . getConfig ( configName ) ; 
if ( config == null ) { 
Object defaultValue = configDef . getDefaultValue ( ) ; 
LOG . warn ( "Stage '{}' missing configuration '{}', adding with '{}' as default" , stageConf . getInstanceName ( ) , configName , defaultValue ) ; 
config = new Config ( configName , defaultValue ) ; 
stageConf . addConfig ( config ) ; 
} 
} 
} 
} 

public class HttpProcessor { 
private Record parseResponse ( InputStream response ) throws StageException { 
Record record = null ; 
if ( conf . httpMethod == HttpMethod . HEAD ) { 
record = getContext ( ) . createRecord ( "" ) ; 
record . set ( Field . create ( new HashMap ( ) ) ) ; 
} 
else if ( response != null ) try ( DataParser parser = parserFactory . getParser ( "" , response , "0" ) ) { 
record = parser . parse ( ) ; 
if ( conf . dataFormat == DataFormat . TEXT ) record . set ( record . get ( "/text" ) ) ; 
} 
catch ( IOException | DataParserException e ) { 
errorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; 
} 
return record ; 
} 
} 

public class HttpProcessor { 
private void addResponseHeaders ( Record record , Response response ) throws StageException { 
if ( conf . headerOutputLocation == HeaderOutputLocation . NONE ) return ; 
Record . Header header = record . getHeader ( ) ; 
if ( conf . headerOutputLocation == HeaderOutputLocation . FIELD ) writeResponseHeaderToField ( record , response ) ; 
else if ( conf . headerOutputLocation == HeaderOutputLocation . HEADER ) writeResponseHeaderToRecordHeader ( response , header ) ; 
} 
} 

public class HttpProcessor { 
private void writeResponseHeaderToField ( Record record , Response response ) throws StageException { 
if ( record . has ( conf . headerOutputField ) ) throw new StageException ( Errors . HTTP_11 , conf . headerOutputField ) ; 
Map < String , Field > headers = new HashMap < > ( response . getStringHeaders ( ) . size ( ) ) ; 
for ( Map . Entry < String , List < String > > entry : response . getStringHeaders ( ) . entrySet ( ) ) { 
if ( ! entry . getValue ( ) . isEmpty ( ) ) { 
String firstValue = entry . getValue ( ) . get ( 0 ) ; 
headers . put ( entry . getKey ( ) , Field . create ( firstValue ) ) ; 
} 
} 
record . set ( conf . headerOutputField , Field . create ( headers ) ) ; 
} 
} 

public class BlobStoreTaskImpl { 
synchronized private void saveMetadata ( ) throws StageException { 
if ( Files . exists ( newMetadataFile ) ) throw new StageException ( BlobStoreError . BLOB_STORE_0010 ) ; 
try ( OutputStream os = Files . newOutputStream ( newMetadataFile , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING ) ) { 
jsonMapper . writeValue ( os , metadata ) ; 
} 
catch ( IOException e ) { 
throw new StageException ( BlobStoreError . BLOB_STORE_0001 , e . toString ( ) , e ) ; 
} 
try { 
if ( Files . exists ( metadataFile ) ) Files . delete ( metadataFile ) ; 
} 
catch ( IOException e ) { 
throw new StageException ( BlobStoreError . BLOB_STORE_0011 , e . toString ( ) , e ) ; 
} 
try { 
Files . move ( newMetadataFile , metadataFile ) ; 
} 
catch ( IOException e ) { 
throw new StageException ( BlobStoreError . BLOB_STORE_0012 , e . toString ( ) , e ) ; 
} 
} 
} 

public class HttpClientSource { 
private void incrementSourceOffset ( HttpSourceOffset sourceOffset , int increment ) { 
if ( conf . pagination . mode == PaginationMode . BY_PAGE ) sourceOffset . incrementStartAt ( 1 ) ; 
else if ( conf . pagination . mode == PaginationMode . BY_OFFSET ) sourceOffset . incrementStartAt ( increment ) ; 
} 
} 

public class HttpClientSource { 
private int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { 
int numSubRecords = 0 ; 
if ( ! record . has ( conf . pagination . resultFieldPath ) ) { 
final StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; 
LOG . error ( stageException . getMessage ( ) ) ; 
throw stageException ; 
} 
Field resultField = record . get ( conf . pagination . resultFieldPath ) ; 
if ( resultField . getType ( ) != Field . Type . LIST ) { 
final StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; 
LOG . error ( stageException . getMessage ( ) ) ; 
throw stageException ; 
} 
List < Field > results = resultField . getValueAsList ( ) ; 
int subRecordIdx = 0 ; 
for ( Field result : results ) { 
Record r = getContext ( ) . createRecord ( sourceOffset + "::" + subRecordIdx ++ ) ; 
if ( conf . pagination . keepAllFields ) { 
r . set ( record . get ( ) . clone ( ) ) ; 
r . set ( conf . pagination . resultFieldPath , result ) ; 
} 
else r . set ( result ) ; 
addResponseHeaders ( r . getHeader ( ) ) ; 
batchMaker . addRecord ( r ) ; 
++ numSubRecords ; 
} 
if ( conf . pagination . mode != PaginationMode . LINK_FIELD ) haveMorePages = numSubRecords > 0 ; 
return numSubRecords ; 
} 
} 

public class HttpClientSource { 
private void addResponseHeaders ( Record . Header header ) { 
final MultivaluedMap < String , String > headers = getResponse ( ) . getStringHeaders ( ) ; 
if ( headers == null ) return ; 
for ( Map . Entry < String , List < String > > entry : headers . entrySet ( ) ) { 
if ( ! entry . getValue ( ) . isEmpty ( ) ) { 
String firstValue = entry . getValue ( ) . get ( 0 ) ; 
header . setAttribute ( entry . getKey ( ) , firstValue ) ; 
} 
} 
} 
} 

public class HttpClientSource { 
private Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { 
Optional < String > newSourceOffset = Optional . empty ( ) ; 
if ( getResponse ( ) == null ) return newSourceOffset ; 
int status = getResponse ( ) . getStatus ( ) ; 
if ( status < 200 || status >= 300 ) { 
lastRequestCompletedTime = System . currentTimeMillis ( ) ; 
String reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; 
String respString = getResponse ( ) . readEntity ( String . class ) ; 
getResponse ( ) . close ( ) ; 
setResponse ( null ) ; 
final String errorMsg = reason + " : " + respString ; 
LOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; 
errorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; 
return newSourceOffset ; 
} 
if ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { 
next = getResponse ( ) . getLink ( "next" ) ; 
if ( next == null ) haveMorePages = false ; 
} 
if ( getResponse ( ) . hasEntity ( ) ) newSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; 
else if ( conf . httpMethod . getLabel ( ) == "HEAD" ) newSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; 
return newSourceOffset ; 
} 
} 

public class ShimUtil { 
public static DataParserException convert ( com . streamsets . pipeline . lib . parser . DataParserException original ) { 
if ( original instanceof com . streamsets . pipeline . lib . parser . RecoverableDataParserException ) return new RecoverableDataParserException ( ( ( com . streamsets . pipeline . lib . parser . RecoverableDataParserException ) original ) . getUnparsedRecord ( ) , original . getErrorCode ( ) , original . getParams ( ) ) ; 
return new DataParserException ( original . getErrorCode ( ) , original . getParams ( ) ) ; 
} 
} 

public class GoogleCloudCredentialsConfig { 
private Credentials getCredentials ( Stage . Context context , List < Stage . ConfigIssue > issues ) { 
Credentials credentials = null ; 
File credentialsFile ; 
if ( Paths . get ( path ) . isAbsolute ( ) ) credentialsFile = new File ( path ) ; 
else credentialsFile = new File ( context . getResourcesDirectory ( ) , path ) ; 
if ( ! credentialsFile . exists ( ) || ! credentialsFile . isFile ( ) ) { 
LOG . error ( GOOGLE_01 . getMessage ( ) , credentialsFile . getPath ( ) ) ; 
issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_01 , credentialsFile . getPath ( ) ) ) ; 
return null ; 
} 
try ( InputStream in = new FileInputStream ( credentialsFile ) ) { 
credentials = ServiceAccountCredentials . fromStream ( in ) ; 
} 
catch ( IOException | IllegalArgumentException e ) { 
LOG . error ( GOOGLE_02 . getMessage ( ) , e ) ; 
issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_02 ) ) ; 
} 
return credentials ; 
} 
} 

public class PreviewApi { 
public PreviewInfoJson previewWithOverride ( String pipelineId , List < StageOutputJson > stageOutputsToOverrideJson , String rev , Integer batchSize , Integer batches , Boolean skipTargets , String endStage , Long timeout ) throws ApiException { 
Object postBody = stageOutputsToOverrideJson ; 
byte [ ] postBinaryBody = null ; 
if ( pipelineId == null ) throw new ApiException ( 400 , "Missing the required parameter 'pipelineId' when calling previewWithOverride" ) ; 
if ( stageOutputsToOverrideJson == null ) throw new ApiException ( 400 , "Missing the required parameter 'stageOutputsToOverrideJson' when calling previewWithOverride" ) ; 
String path = "/v1/pipeline/{pipelineId}/preview" . replaceAll ( "\\{format\\}" , "json" ) . replaceAll ( "\\{" + "pipelineId" + "\\}" , apiClient . escapeString ( pipelineId . toString ( ) ) ) ; 
List < Pair > queryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > headerParams = new HashMap < String , String > ( ) ; 
Map < String , Object > formParams = new HashMap < String , Object > ( ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "rev" , rev ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "batchSize" , batchSize ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "batches" , batches ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "skipTargets" , skipTargets ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "endStage" , endStage ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "timeout" , timeout ) ) ; 
final String [ ] accepts = { 
"application/json" } 
; 
final String accept = apiClient . selectHeaderAccept ( accepts ) ; 
final String [ ] contentTypes = { 
} 
; 
final String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; 
String [ ] authNames = new String [ ] { 
"basic" } 
; 
TypeRef returnType = new TypeRef < PreviewInfoJson > ( ) { 
} 
; 
return apiClient . invokeAPI ( path , "POST" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; 
} 
} 

public class AbstractOverrunDelimitedReader { 
protected int copyToBuffer ( StringBuilder s , int initialLen , int startChar , int currentChar ) { 
int overrun = 0 ; 
int currentSize = s . length ( ) - initialLen ; 
int readSize = currentChar - startChar ; 
if ( maxLine > - 1 && currentSize + readSize > maxLine ) { 
int adjustedReadSize = maxLine - currentSize ; 
if ( adjustedReadSize > 0 ) { 
s . append ( cb , startChar , adjustedReadSize ) ; 
overrun = readSize - adjustedReadSize ; 
} 
else overrun = readSize ; 
} 
else s . append ( cb , startChar , readSize ) ; 
return overrun ; 
} 
} 

public class ApplicationPackage { 
static void removeLogicalDuplicates ( SortedSet < String > packages ) { 
Iterator < String > iterator = packages . iterator ( ) ; 
if ( ! iterator . hasNext ( ) ) return ; 
String last = iterator . next ( ) ; 
while ( iterator . hasNext ( ) ) { 
String current = iterator . next ( ) ; 
if ( current . startsWith ( last ) ) iterator . remove ( ) ; 
else last = current ; 
} 
} 
} 

public class HdfsTarget { 
protected void emptyBatch ( ) throws StageException { 
setBatchTime ( ) ; 
try { 
hdfsTargetConfigBean . getUGI ( ) . doAs ( new PrivilegedExceptionAction < Void > ( ) { 
@ Override public Void run ( ) throws Exception { 
hdfsTargetConfigBean . getCurrentWriters ( ) . purge ( ) ; 
if ( hdfsTargetConfigBean . getLateWriters ( ) != null ) hdfsTargetConfigBean . getLateWriters ( ) . purge ( ) ; 
return null ; 
} 
} 
) ; 
} 
catch ( Exception ex ) { 
throw throwStageException ( ex ) ; 
} 
} 
} 

public class MultiLineLiveFileReader { 
int findNextMainLine ( LiveFileChunk chunk , int startIdx ) { 
List < FileLine > lines = chunk . getLines ( ) ; 
int found = - 1 ; 
for ( int i = startIdx ; 
found == - 1 && i < lines . size ( ) ; 
i ++ ) if ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) found = i ; 
return found ; 
} 
} 

public class MultiLineLiveFileReader { 
LiveFileChunk resolveChunk ( LiveFileChunk chunk ) { 
List < FileLine > completeLines = new ArrayList < > ( ) ; 
List < FileLine > chunkLines = chunk . getLines ( ) ; 
if ( incompleteMultiLine . length ( ) == 0 ) { 
incompleteMultiLineOffset = chunk . getOffset ( ) ; 
incompleteMultiLineTruncated = chunk . isTruncated ( ) ; 
} 
incompleteMultiLineTruncated |= chunk . isTruncated ( ) ; 
int pos = 0 ; 
int idx = findNextMainLine ( chunk , pos ) ; 
while ( idx > - 1 ) { 
for ( int i = pos ; 
i < idx ; 
i ++ ) incompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; 
if ( incompleteMultiLine . length ( ) != 0 ) { 
completeLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; 
incompleteMultiLineOffset += incompleteMultiLine . length ( ) ; 
incompleteMultiLine . setLength ( 0 ) ; 
incompleteMultiLineTruncated = false ; 
} 
incompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; 
pos = idx + 1 ; 
idx = findNextMainLine ( chunk , pos ) ; 
} 
for ( int i = pos ; 
i < chunkLines . size ( ) ; 
i ++ ) incompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; 
if ( completeLines . isEmpty ( ) ) chunk = null ; 
else chunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; 
return chunk ; 
} 
} 

public class ConnectionManager { 
public void closeConnection ( ) { 
LOGGER . debug ( "Closing connection" ) ; 
Connection connectionToRemove = threadLocalConnection . get ( ) ; 
jdbcUtil . closeQuietly ( connectionToRemove ) ; 
if ( connectionToRemove != null ) synchronized ( this ) { 
connectionsToCloseDuringDestroy . remove ( connectionToRemove ) ; 
} 
threadLocalConnection . set ( null ) ; 
} 
} 

public class FieldRenamerProcessor { 
private static String escapeQuotedSubstring ( String input ) { 
String [ ] parts = input . split ( "'" ) ; 
StringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; 
for ( int i = 0 ; 
i < parts . length ; 
i ++ ) if ( ( i % 2 ) == 1 ) output . append ( "'" ) . append ( parts [ i ] . replace ( "|" , "\\|" ) ) . append ( "'" ) ; 
else output . append ( parts [ i ] ) ; 
return output . toString ( ) ; 
} 
} 

public class Producer { 
public Object put ( OffsetAndResult < Map . Entry > batch ) { 
if ( consumerError != null ) throw new RuntimeException ( Utils . format ( "Consumer encountered error: {}" , consumerError ) , consumerError ) ; 
if ( producerError != null ) throw new RuntimeException ( Utils . format ( "Producer encountered error: {}" , producerError ) , producerError ) ; 
try { 
Object expectedOffset = "EMPTY_BATCH" ; 
if ( ! batch . getResult ( ) . isEmpty ( ) ) expectedOffset = batch . getResult ( ) . get ( batch . getResult ( ) . size ( ) - 1 ) . getKey ( ) ; 
while ( ! dataChannel . offer ( batch , 10 , TimeUnit . MILLISECONDS ) ) for ( ControlChannel . Message controlMessage : controlChannel . getProducerMessages ( ) ) { 
switch ( controlMessage . getType ( ) ) { 
case CONSUMER_ERROR : Throwable throwable = ( Throwable ) controlMessage . getPayload ( ) ; 
consumerError = throwable ; 
throw new ConsumerRuntimeException ( Utils . format ( "Consumer encountered error: {}" , throwable ) , throwable ) ; 
default : String msg = Utils . format ( "Illegal control message type: '{}'" , controlMessage . getType ( ) ) ; 
throw new IllegalStateException ( msg ) ; 
} 
} 
return expectedOffset ; 
} 
catch ( Throwable throwable ) { 
controlChannel . producerComplete ( ) ; 
if ( ! ( throwable instanceof ConsumerRuntimeException ) ) { 
String msg = "Error caught in producer: " + throwable ; 
LOG . error ( msg , throwable ) ; 
controlChannel . producerError ( throwable ) ; 
if ( producerError == null ) producerError = throwable ; 
} 
throw Throwables . propagate ( throwable ) ; 
} 
} 
} 

public class GrokDictionary { 
private String digestExpressionAux ( String originalExpression ) { 
final String PATTERN_START = "%{" ; 
final String PATTERN_STOP = "}" ; 
final char PATTERN_DELIMITER = ':' ; 
while ( true ) { 
int PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; 
int PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; 
if ( PATTERN_START_INDEX < 0 || PATTERN_STOP_INDEX < 0 ) break ; 
String grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; 
int PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; 
String regexName = grokPattern ; 
String groupName = null ; 
if ( PATTERN_DELIMITER_INDEX >= 0 ) { 
regexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; 
groupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; 
} 
final String dictionaryValue = regexDictionary . get ( regexName ) ; 
if ( dictionaryValue == null ) throw new GrokCompilationException ( "Missing value for regex name : " + regexName ) ; 
if ( dictionaryValue . contains ( PATTERN_START ) ) break ; 
String replacement = dictionaryValue ; 
if ( null != groupName ) replacement = "(?<" + groupName + ">" + dictionaryValue + ")" ; 
originalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; 
} 
return originalExpression ; 
} 
} 

public class AggregatorDataProvider { 
public Map < Aggregator , AggregatorData > roll ( long newDataWindowEndTimeMillis ) { 
Utils . checkState ( started , "Not started" ) ; 
Utils . checkState ( ! stopped , "Already stopped" ) ; 
Map < Aggregator , AggregatorData > result = data ; 
Map < Aggregator , AggregatorData > newData = new ConcurrentHashMap < > ( ) ; 
for ( Aggregator aggregator : aggregators ) { 
newData . put ( aggregator , aggregator . createAggregatorData ( newDataWindowEndTimeMillis ) ) ; 
} 
data = newData ; 
Map < Aggregator , AggregatorData > oldData = result ; 
result = aggregateDataWindows ( result ) ; 
if ( currentDataWindow != null ) currentDataWindow . setDataAndClose ( oldData ) ; 
DataWindow newDataWindow = createDataWindow ( newDataWindowEndTimeMillis ) ; 
synchronized ( dataWindowQueue ) { 
dataWindowQueue . add ( newDataWindow ) ; 
dataWindowList = new ArrayList < > ( dataWindowQueue ) ; 
} 
currentDataWindow = newDataWindow ; 
return result ; 
} 
} 

public class SampleTarget { 
private void write ( Record record ) throws OnRecordErrorException { 
if ( ! record . has ( "/someField" ) ) throw new OnRecordErrorException ( Errors . SAMPLE_01 , record , "exception detail message." ) ; 
} 
} 

public class HiveMetastoreUtil { 
private static < T > Field generateInnerFieldFromTheList ( LinkedHashMap < String , T > original , String innerPairFirstFieldName , String innerPairSecondFieldName , boolean isSecondFieldHiveType ) throws HiveStageCheckedException { 
List < Field > columnList = new LinkedList < > ( ) ; 
for ( Map . Entry < String , T > pair : original . entrySet ( ) ) { 
LinkedHashMap < String , Field > entry = new LinkedHashMap < > ( ) ; 
entry . put ( innerPairFirstFieldName , Field . create ( pair . getKey ( ) ) ) ; 
if ( isSecondFieldHiveType ) { 
HiveTypeInfo hiveTypeInfo = ( HiveTypeInfo ) pair . getValue ( ) ; 
entry . put ( innerPairSecondFieldName , hiveTypeInfo . getHiveType ( ) . getSupport ( ) . generateHiveTypeInfoFieldForMetadataRecord ( hiveTypeInfo ) ) ; 
} 
else entry . put ( innerPairSecondFieldName , Field . create ( pair . getValue ( ) . toString ( ) ) ) ; 
columnList . add ( Field . createListMap ( entry ) ) ; 
} 
return ! columnList . isEmpty ( ) ? Field . create ( columnList ) : null ; 
} 
} 

public class HiveMetastoreUtil { 
public static String getTableName ( Record metadataRecord ) throws HiveStageCheckedException { 
if ( metadataRecord . has ( SEP + TABLE_FIELD ) ) return metadataRecord . get ( SEP + TABLE_FIELD ) . getValueAsString ( ) ; 
throw new HiveStageCheckedException ( Errors . HIVE_17 , TABLE_FIELD , metadataRecord ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static boolean getInternalField ( Record metadataRecord ) throws HiveStageCheckedException { 
if ( metadataRecord . has ( SEP + INTERNAL_FIELD ) ) return metadataRecord . get ( SEP + INTERNAL_FIELD ) . getValueAsBoolean ( ) ; 
throw new HiveStageCheckedException ( Errors . HIVE_17 , INTERNAL_FIELD , metadataRecord ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static String getLocation ( Record metadataRecord ) throws HiveStageCheckedException { 
if ( metadataRecord . has ( SEP + LOCATION_FIELD ) ) return metadataRecord . get ( SEP + LOCATION_FIELD ) . getValueAsString ( ) ; 
throw new HiveStageCheckedException ( Errors . HIVE_17 , LOCATION_FIELD , metadataRecord ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static boolean getCustomLocation ( Record metadataRecord ) throws HiveStageCheckedException { 
if ( metadataRecord . get ( SEP + VERSION ) . getValueAsInteger ( ) < 3 ) return DEFAULT_CUSTOM_LOCATION ; 
if ( metadataRecord . has ( SEP + CUSTOM_LOCATION ) ) return metadataRecord . get ( SEP + CUSTOM_LOCATION ) . getValueAsBoolean ( ) ; 
throw new HiveStageCheckedException ( Errors . HIVE_17 , CUSTOM_LOCATION , metadataRecord ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static String getAvroSchema ( Record metadataRecord ) throws HiveStageCheckedException { 
if ( metadataRecord . has ( SEP + AVRO_SCHEMA ) ) return metadataRecord . get ( SEP + AVRO_SCHEMA ) . getValueAsString ( ) ; 
throw new HiveStageCheckedException ( Errors . HIVE_17 , AVRO_SCHEMA , metadataRecord ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static String getDataFormat ( Record metadataRecord ) throws HiveStageCheckedException { 
if ( metadataRecord . get ( SEP + VERSION ) . getValueAsInteger ( ) == 1 ) return DEFAULT_DATA_FORMAT ; 
if ( metadataRecord . has ( SEP + DATA_FORMAT ) ) return metadataRecord . get ( SEP + DATA_FORMAT ) . getValueAsString ( ) ; 
throw new HiveStageCheckedException ( Errors . HIVE_17 , DATA_FORMAT , metadataRecord ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static Field newSchemaMetadataFieldBuilder ( String database , String tableName , LinkedHashMap < String , HiveTypeInfo > columnList , LinkedHashMap < String , HiveTypeInfo > partitionTypeList , boolean internal , String location , String avroSchema , HMPDataFormat dataFormat ) throws HiveStageCheckedException { 
LinkedHashMap < String , Field > metadata = new LinkedHashMap < > ( ) ; 
metadata . put ( VERSION , Field . create ( SCHEMA_CHANGE_METADATA_RECORD_VERSION ) ) ; 
metadata . put ( METADATA_RECORD_TYPE , Field . create ( MetadataRecordType . TABLE . name ( ) ) ) ; 
metadata . put ( DATABASE_FIELD , Field . create ( database ) ) ; 
metadata . put ( TABLE_FIELD , Field . create ( tableName ) ) ; 
metadata . put ( LOCATION_FIELD , Field . create ( location ) ) ; 
metadata . put ( DATA_FORMAT , Field . create ( dataFormat . name ( ) ) ) ; 
metadata . put ( COLUMNS_FIELD , generateInnerFieldFromTheList ( columnList , COLUMN_NAME , TYPE_INFO , true ) ) ; 
if ( partitionTypeList != null && ! partitionTypeList . isEmpty ( ) ) metadata . put ( PARTITION_FIELD , generateInnerFieldFromTheList ( partitionTypeList , PARTITION_NAME , TYPE_INFO , true ) ) ; 
metadata . put ( INTERNAL_FIELD , Field . create ( internal ) ) ; 
metadata . put ( AVRO_SCHEMA , Field . create ( avroSchema ) ) ; 
return Field . createListMap ( metadata ) ; 
} 
} 

public class HiveMetastoreUtil { 
public static String serializeSchemaToHDFS ( UserGroupInformation loginUGI , final FileSystem fs , final String location , final String schemaFolder , final String databaseName , final String tableName , final String schemaJson ) throws StageException { 
String folderLocation ; 
if ( schemaFolder . startsWith ( SEP ) ) folderLocation = schemaFolder ; 
else folderLocation = location + SEP + schemaFolder ; 
final Path schemasFolderPath = new Path ( folderLocation ) ; 
final String path = folderLocation + SEP + String . format ( AVRO_SCHEMA_FILE_FORMAT , databaseName , tableName , UUID . randomUUID ( ) . toString ( ) ) ; 
try { 
loginUGI . doAs ( new PrivilegedExceptionAction < Void > ( ) { 
@ Override public Void run ( ) throws Exception { 
if ( ! fs . exists ( schemasFolderPath ) ) fs . mkdirs ( schemasFolderPath ) ; 
Path schemaFilePath = new Path ( path ) ; 
if ( ! fs . exists ( schemaFilePath ) ) try ( FSDataOutputStream os = fs . create ( schemaFilePath ) ) { 
byte [ ] schemaBytes = schemaJson . getBytes ( "UTF-8" ) ; 
os . write ( schemaBytes , 0 , schemaBytes . length ) ; 
} 
else { 
LOG . error ( Utils . format ( "Already schema file {} exists in HDFS" , path ) ) ; 
throw new IOException ( "Already schema file exists" ) ; 
} 
return null ; 
} 
} 
) ; 
} 
catch ( Exception e ) { 
LOG . error ( "Error in Writing Schema to HDFS: " + e . toString ( ) , e ) ; 
throw new StageException ( Errors . HIVE_18 , path , e . getMessage ( ) ) ; 
} 
return path ; 
} 
} 

public class JdbcGenericRecordWriter { 
@ VisibleForTesting @ SuppressWarnings ( "unchecked" ) int setParameters ( int opCode , SortedMap < String , String > columnsToParameters , final Record record , final Connection connection , PreparedStatement statement ) throws OnRecordErrorException { 
int paramIdx = 1 ; 
if ( opCode != OperationType . DELETE_CODE ) paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , record , connection , opCode ) ; 
if ( opCode != OperationType . INSERT_CODE ) paramIdx = setPrimaryKeys ( paramIdx , record , statement , opCode ) ; 
return paramIdx ; 
} 
} 

public class SyslogDecoder { 
public static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { 
LocalDateTime now = LocalDateTime . now ( ) ; 
int year = now . getYear ( ) ; 
ts = TWO_SPACES . matcher ( ts ) . replaceFirst ( " " ) ; 
LocalDateTime date ; 
try { 
MonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; 
LocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; 
date = now ; 
date = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; 
date = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; 
date = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; 
} 
catch ( DateTimeParseException e ) { 
throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; 
} 
LocalDateTime fixed = date ; 
if ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) fixed = date . withYear ( year - 1 ) ; 
else if ( fixed . isBefore ( now ) && fixed . plusMonths ( 11 ) . isBefore ( now ) ) fixed = date . withYear ( year + 1 ) ; 
date = fixed ; 
return date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; 
} 
} 

public class Utils { 
public static String format ( String template , Object ... args ) { 
String [ ] templateArr = TEMPLATES . get ( template ) ; 
if ( templateArr == null ) { 
templateArr = prepareTemplate ( template ) ; 
TEMPLATES . put ( template , templateArr ) ; 
} 
StringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; 
for ( int i = 0 ; 
i < templateArr . length ; 
i ++ ) { 
sb . append ( templateArr [ i ] ) ; 
if ( args != null && ( i < templateArr . length - 1 ) ) sb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class SolrTarget { 
private boolean checkRecordContainsSolrFields ( Map < String , Field > recordFieldMap , Record record , List < String > solrFieldsMap , Errors errorToThrow ) throws StageException { 
List < String > fieldsFound = new ArrayList < > ( ) ; 
recordFieldMap . keySet ( ) . forEach ( recordFieldKey -> { 
if ( solrFieldsMap . contains ( recordFieldKey ) ) fieldsFound . add ( recordFieldKey ) ; 
} 
) ; 
if ( solrFieldsMap . size ( ) != fieldsFound . size ( ) ) { 
Set < String > missingFields = new HashSet < > ( ) ; 
solrFieldsMap . forEach ( requiredField -> { 
if ( ! fieldsFound . contains ( requiredField ) ) missingFields . add ( requiredField ) ; 
} 
) ; 
handleError ( record , errorToThrow , Joiner . on ( "," ) . join ( missingFields ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class SolrTarget { 
private List < String > filterAutogeneratedFieldNames ( List < String > fieldNames ) { 
List < String > result = new ArrayList < > ( ) ; 
fieldNames . forEach ( name -> { 
if ( ! autogeneratedFieldNamesMap . contains ( name ) ) result . add ( name ) ; 
} 
) ; 
return result ; 
} 
} 

public class CouchbaseConnector { 
public static synchronized CouchbaseConnector getInstance ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { 
Map < String , Object > runnerSharedMap = context . getStageRunnerSharedMap ( ) ; 
if ( runnerSharedMap . containsKey ( INSTANCE ) ) LOG . debug ( "Using existing instance of CouchbaseConnector" ) ; 
else { 
LOG . debug ( "CouchbaseConnector not yet instantiated. Creating new instance" ) ; 
validateConfig ( config , issues , context ) ; 
if ( issues . isEmpty ( ) ) runnerSharedMap . put ( INSTANCE , new CouchbaseConnector ( config , issues , context ) ) ; 
} 
return ( CouchbaseConnector ) runnerSharedMap . get ( INSTANCE ) ; 
} 
} 

public class CouchbaseConnector { 
private static void validateConfig ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { 
if ( config . couchbase . nodes == null ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , "config.couchbase.nodes" , Errors . COUCHBASE_29 ) ) ; 
if ( config . couchbase . kvTimeout < 0 ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , "config.couchbase.kvTimeout" , Errors . COUCHBASE_30 ) ) ; 
if ( config . couchbase . connectTimeout < 0 ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , "config.couchbase.connectTimeout" , Errors . COUCHBASE_31 ) ) ; 
if ( config . couchbase . disconnectTimeout < 0 ) issues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , "config.couchbase.disconnectTimeout" , Errors . COUCHBASE_32 ) ) ; 
if ( config . couchbase . tls . tlsEnabled ) config . couchbase . tls . init ( context , Groups . COUCHBASE . name ( ) , "config.couchbase.tls." , issues ) ; 
if ( config . credentials . version == null ) issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , "config.credentials.version" , Errors . COUCHBASE_33 ) ) ; 
if ( config . credentials . version == AuthenticationType . USER ) { 
if ( config . credentials . userName == null ) issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , "config.credentials.userName" , Errors . COUCHBASE_34 ) ) ; 
if ( config . credentials . userPassword == null ) issues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , "config.credentials.userPassword" , Errors . COUCHBASE_35 ) ) ; 
} 
} 
} 

public class Vault { 
public String read ( String path , String key , long delay ) { 
if ( ! secrets . containsKey ( path ) ) { 
VaultClient vault = new VaultClient ( getConfig ( ) ) ; 
Secret secret ; 
try { 
secret = vault . logical ( ) . read ( path ) ; 
} 
catch ( VaultException e ) { 
LOG . error ( e . toString ( ) , e ) ; 
throw new VaultRuntimeException ( e . toString ( ) ) ; 
} 
String leaseId ; 
if ( secret . isRenewable ( ) ) leaseId = secret . getLeaseId ( ) ; 
else leaseId = path + "/" ; 
leases . put ( leaseId , System . currentTimeMillis ( ) + ( secret . getLeaseDuration ( ) * 1000 ) ) ; 
secrets . put ( path , secret ) ; 
try { 
Thread . sleep ( delay ) ; 
} 
catch ( InterruptedException e ) { 
Thread . currentThread ( ) . interrupt ( ) ; 
} 
} 
Map < String , Object > data = secrets . get ( path ) . getData ( ) ; 
String value = getSecretValue ( data , key ) . orElseThrow ( ( ) -> new VaultRuntimeException ( "Value not found for key" ) ) ; 
LOG . trace ( "CredentialStore '{}' Vault, retrieved value for key '{}'" , csId , key ) ; 
return value ; 
} 
} 

public class CouchbaseTarget { 
private WriteOperationType getOperationFromHeader ( Record record , String key ) { 
String op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; 
if ( op == null || op . isEmpty ( ) ) return config . defaultWriteOperation ; 
int opCode ; 
try { 
opCode = Integer . parseInt ( op ) ; 
} 
catch ( NumberFormatException e ) { 
LOG . debug ( "Unparsable CDC operation. Sending record to error." ) ; 
handleError ( record , Errors . COUCHBASE_08 , e ) ; 
return null ; 
} 
switch ( opCode ) { 
case OperationType . INSERT_CODE : return WriteOperationType . INSERT ; 
case OperationType . UPDATE_CODE : return WriteOperationType . REPLACE ; 
case OperationType . UPSERT_CODE : return WriteOperationType . UPSERT ; 
case OperationType . DELETE_CODE : return WriteOperationType . DELETE ; 
default : switch ( config . unsupportedOperation ) { 
case DISCARD : LOG . debug ( "Unsupported CDC operation for key: {}. Discarding record per configuration." , key ) ; 
return null ; 
case TOERROR : LOG . debug ( "Unsupported CDC operation for key: {}. Sending record to error configuration." , key ) ; 
handleError ( record , Errors . COUCHBASE_09 , new RuntimeException ( ) ) ; 
return null ; 
default : LOG . debug ( "Unsupported CDC operation for key: {}. Using default write operation per configuration." , key ) ; 
return config . defaultWriteOperation ; 
} 
} 
} 
} 

public class CouchbaseTarget { 
private Observable < AbstractDocument > writeDoc ( String key , int ttl , long cas , ByteArrayOutputStream baos , Record record ) { 
WriteOperationType opType = getOperationFromHeader ( record , key ) ; 
if ( opType == null ) return Observable . empty ( ) ; 
AbstractDocument doc ; 
if ( config . dataFormat == DataFormat . JSON ) try { 
doc = JsonDocument . create ( key , ttl , JsonObject . fromJson ( baos . toString ( config . dataFormatConfig . charset ) ) , cas ) ; 
} 
catch ( Exception e ) { 
return handleError ( record , Errors . COUCHBASE_10 , e ) ; 
} 
else doc = ByteArrayDocument . create ( key , ttl , baos . toByteArray ( ) , cas ) ; 
switch ( opType ) { 
case DELETE : { 
LOG . debug ( "DELETE key: {}, TTL: {}, CAS: {}" , key , ttl , cas ) ; 
return connector . bucket ( ) . remove ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; 
} 
case INSERT : { 
LOG . debug ( "INSERT key: {}, TTL: {}, CAS: {}" , key , ttl , cas ) ; 
return connector . bucket ( ) . insert ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; 
} 
case REPLACE : { 
LOG . debug ( "REPLACE key: {}, TTL: {}, CAS: {}" , key , ttl , cas ) ; 
return connector . bucket ( ) . replace ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; 
} 
case UPSERT : { 
LOG . debug ( "UPSERT key: {}, TTL: {}, CAS: {}" , key , ttl , cas ) ; 
return connector . bucket ( ) . upsert ( doc , config . persistTo , config . replicateTo ) . timeout ( config . couchbase . kvTimeout , TimeUnit . MILLISECONDS ) ; 
} 
default : return Observable . empty ( ) ; 
} 
} 
} 

public class H2SchemaWriter { 
@ Override protected String makeAlterTableSqlString ( String schema , String tableName , LinkedHashMap < String , JdbcTypeInfo > columnDiff ) { 
String tableSchema = ( schema == null ) ? getDefaultSchema ( ) : schema ; 
StringBuilder sqlString = new StringBuilder ( ) ; 
boolean first = true ; 
for ( Map . Entry < String , JdbcTypeInfo > entry : columnDiff . entrySet ( ) ) { 
if ( first ) first = false ; 
else sqlString . append ( "\n" ) ; 
sqlString . append ( ALTER_TABLE ) . append ( " " ) ; 
if ( tableSchema != null ) { 
sqlString . append ( tableSchema ) ; 
sqlString . append ( "." ) ; 
} 
sqlString . append ( tableName ) . append ( " " ) . append ( "ADD COLUMN" ) . append ( " " ) . append ( entry . getKey ( ) ) . append ( " " ) . append ( entry . getValue ( ) . toString ( ) ) . append ( ";" ) ; 
} 
return sqlString . toString ( ) ; 
} 
} 

public class Consumer { 
public OffsetAndResult < Map . Entry > take ( ) { 
if ( producerError != null ) throw new RuntimeException ( Utils . format ( "Producer encountered error: {}" , producerError ) , producerError ) ; 
if ( consumerError != null ) throw new RuntimeException ( Utils . format ( "Consumer encountered error: {}" , consumerError ) , consumerError ) ; 
try { 
Utils . checkState ( batchCommitted , "Cannot take messages when last batch is uncommitted" ) ; 
while ( running ) { 
for ( ControlChannel . Message controlMessage : controlChannel . getConsumerMessages ( ) ) { 
switch ( controlMessage . getType ( ) ) { 
case PRODUCER_COMPLETE : running = false ; 
break ; 
case PRODUCER_ERROR : running = false ; 
Throwable throwable = ( Throwable ) controlMessage . getPayload ( ) ; 
producerError = throwable ; 
throw new ProducerRuntimeException ( Utils . format ( "Producer encountered error: {}" , throwable ) , throwable ) ; 
default : String msg = Utils . format ( "Illegal control message type: '{}'" , controlMessage . getType ( ) ) ; 
throw new IllegalStateException ( msg ) ; 
} 
} 
OffsetAndResult < Map . Entry > batch = dataChannel . take ( 10 , TimeUnit . MILLISECONDS ) ; 
LOG . trace ( "Received batch: {}" , batch ) ; 
if ( batch != null ) { 
batchCommitted = false ; 
return batch ; 
} 
} 
LOG . trace ( "Returning null" ) ; 
return null ; 
} 
catch ( Throwable throwable ) { 
if ( ! ( throwable instanceof ProducerRuntimeException ) ) { 
String msg = "Error caught in consumer: " + throwable ; 
LOG . error ( msg , throwable ) ; 
error ( throwable ) ; 
} 
throw Throwables . propagate ( throwable ) ; 
} 
} 
} 

public class DefinitionsApi { 
public DefinitionsJson getDefinitions ( HideStage . Type hideStage ) throws ApiException { 
Object postBody = null ; 
byte [ ] postBinaryBody = null ; 
String path = "/v1/definitions" . replaceAll ( "\\{format\\}" , "json" ) ; 
List < Pair > queryParams = new ArrayList < Pair > ( ) ; 
if ( hideStage != null ) queryParams . add ( new Pair ( "hideStage" , hideStage . name ( ) ) ) ; 
Map < String , String > headerParams = new HashMap < String , String > ( ) ; 
Map < String , Object > formParams = new HashMap < String , Object > ( ) ; 
final String [ ] accepts = { 
"application/json" } 
; 
final String accept = apiClient . selectHeaderAccept ( accepts ) ; 
final String [ ] contentTypes = { 
} 
; 
final String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; 
String [ ] authNames = new String [ ] { 
"basic" } 
; 
TypeRef returnType = new TypeRef < DefinitionsJson > ( ) { 
} 
; 
return apiClient . invokeAPI ( path , "GET" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; 
} 
} 

public class LineagePublisherTaskImpl { 
private LineagePublisherDefinition getDefinition ( String name ) { 
String defConfig = LineagePublisherConstants . configDef ( name ) ; 
String publisherDefinition = configuration . get ( defConfig , null ) ; 
if ( StringUtils . isEmpty ( publisherDefinition ) ) throw new IllegalArgumentException ( Utils . format ( "Missing definition '{}'" , defConfig ) ) ; 
String [ ] lineagePluginDefs = publisherDefinition . split ( "::" ) ; 
if ( lineagePluginDefs . length != 2 ) throw new IllegalStateException ( Utils . format ( "Invalid definition '{}', expected $libraryName::$publisherName" , publisherDefinition ) ) ; 
LineagePublisherDefinition def = stageLibraryTask . getLineagePublisherDefinition ( lineagePluginDefs [ 0 ] , lineagePluginDefs [ 1 ] ) ; 
if ( def == null ) throw new IllegalStateException ( Utils . format ( "Can't find publisher '{}'" , publisherDefinition ) ) ; 
return def ; 
} 
} 

public class SQLParserUtils { 
private static String formatName ( String columnName , boolean caseSensitive ) { 
String returnValue = format ( columnName ) ; 
if ( caseSensitive ) return returnValue ; 
return returnValue . toUpperCase ( ) ; 
} 
} 

public class SQLParserUtils { 
private static String formatValue ( String value ) { 
if ( value == null || NULL_STRING . equalsIgnoreCase ( value ) ) return null ; 
String returnValue = format ( value ) ; 
return returnValue . replaceAll ( "''" , "'" ) ; 
} 
} 

public class StoreApi { 
public PipelineConfigurationJson getPipelineInfo ( String pipelineId , String rev , String get , Boolean attachment ) throws ApiException { 
Object postBody = null ; 
byte [ ] postBinaryBody = null ; 
if ( pipelineId == null ) throw new ApiException ( 400 , "Missing the required parameter 'pipelineId' when calling getPipelineInfo" ) ; 
String path = "/v1/pipeline/{pipelineId}" . replaceAll ( "\\{format\\}" , "json" ) . replaceAll ( "\\{" + "pipelineId" + "\\}" , apiClient . escapeString ( pipelineId . toString ( ) ) ) ; 
List < Pair > queryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > headerParams = new HashMap < String , String > ( ) ; 
Map < String , Object > formParams = new HashMap < String , Object > ( ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "rev" , rev ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "get" , get ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "attachment" , attachment ) ) ; 
final String [ ] accepts = { 
"application/json" } 
; 
final String accept = apiClient . selectHeaderAccept ( accepts ) ; 
final String [ ] contentTypes = { 
} 
; 
final String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; 
String [ ] authNames = new String [ ] { 
"basic" } 
; 
TypeRef returnType = new TypeRef < PipelineConfigurationJson > ( ) { 
} 
; 
return apiClient . invokeAPI ( path , "GET" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; 
} 
} 

public class StoreApi { 
public PipelineFragmentEnvelopeJson createDraftPipelineFragment ( String fragmentId , String description , List < StageConfigurationJson > stageInstances ) throws ApiException { 
Object postBody = stageInstances ; 
byte [ ] postBinaryBody = null ; 
if ( fragmentId == null ) throw new ApiException ( 400 , "Missing the required parameter 'fragmentId' when calling createPipelineFragment" ) ; 
String path = "/v1/fragment/{fragmentId}" . replaceAll ( "\\{format\\}" , "json" ) . replaceAll ( "\\{" + "fragmentId" + "\\}" , apiClient . escapeString ( fragmentId . toString ( ) ) ) ; 
List < Pair > queryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > headerParams = new HashMap < String , String > ( ) ; 
Map < String , Object > formParams = new HashMap < String , Object > ( ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "description" , description ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "draft" , true ) ) ; 
final String [ ] accepts = { 
"application/json" } 
; 
final String accept = apiClient . selectHeaderAccept ( accepts ) ; 
final String [ ] contentTypes = { 
} 
; 
final String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; 
String [ ] authNames = new String [ ] { 
"basic" } 
; 
TypeRef returnType = new TypeRef < PipelineFragmentEnvelopeJson > ( ) { 
} 
; 
return apiClient . invokeAPI ( path , "PUT" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; 
} 
} 

public class StoreApi { 
public PipelineFragmentEnvelopeJson importPipelineFragment ( String fragmentId , boolean draft , boolean includeLibraryDefinitions , PipelineFragmentEnvelopeJson fragmentEnvelope ) throws ApiException { 
Object postBody = fragmentEnvelope ; 
byte [ ] postBinaryBody = null ; 
if ( fragmentId == null ) throw new ApiException ( 400 , "Missing the required parameter 'fragmentId' when calling importPipelineFragment" ) ; 
if ( fragmentEnvelope == null ) throw new ApiException ( 400 , "Missing the required parameter 'pipelineEnvelope' when calling importPipelineFragment" ) ; 
String path = "/v1/fragment/{fragmentId}/import" . replaceAll ( "\\{format\\}" , "json" ) . replaceAll ( "\\{" + "fragmentId" + "\\}" , apiClient . escapeString ( fragmentId . toString ( ) ) ) ; 
List < Pair > queryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > headerParams = new HashMap < String , String > ( ) ; 
Map < String , Object > formParams = new HashMap < String , Object > ( ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "draft" , draft ) ) ; 
queryParams . addAll ( apiClient . parameterToPairs ( "" , "includeLibraryDefinitions" , includeLibraryDefinitions ) ) ; 
final String [ ] accepts = { 
"application/json" } 
; 
final String accept = apiClient . selectHeaderAccept ( accepts ) ; 
final String [ ] contentTypes = { 
"application/json" } 
; 
final String contentType = apiClient . selectHeaderContentType ( contentTypes ) ; 
String [ ] authNames = new String [ ] { 
"basic" } 
; 
TypeRef returnType = new TypeRef < PipelineFragmentEnvelopeJson > ( ) { 
} 
; 
return apiClient . invokeAPI ( path , "POST" , queryParams , postBody , postBinaryBody , headerParams , formParams , accept , contentType , authNames , returnType ) ; 
} 
} 

public class DataLakeGeneratorManager { 
public String getFilePath ( String dirPathTemplate , Record record , Date recordTime ) throws StageException { 
String dirPath ; 
if ( dirPathTemplateInHeader ) { 
dirPath = record . getHeader ( ) . getAttribute ( DataLakeTarget . TARGET_DIRECTORY_HEADER ) ; 
Utils . checkArgument ( ! ( dirPath == null || dirPath . isEmpty ( ) ) , "Directory Path cannot be null" ) ; 
} 
else dirPath = resolvePath ( dirPathTemplateEval , dirPathTemplateVars , dirPathTemplate , recordTime , record ) ; 
dirPath = dirPath . replaceAll ( "/+" , "/" ) ; 
if ( dirPath . endsWith ( "/" ) ) dirPath = dirPath . substring ( 0 , dirPath . length ( ) - 1 ) ; 
return outputStreamHelper . getTempFilePath ( dirPath , record , recordTime ) ; 
} 
} 

public class JdbcRecordReader { 
int getOperationFromRecord ( Record record , int defaultOpCode , UnsupportedOperationAction unsupportedAction , List < OnRecordErrorException > errorRecords ) { 
String op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; 
int opCode = - 1 ; 
if ( Strings . isNullOrEmpty ( op ) ) return defaultOpCode ; 
try { 
opCode = JDBCOperationType . convertToIntCode ( op ) ; 
} 
catch ( NumberFormatException | UnsupportedOperationException ex ) { 
LOG . debug ( "Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}" , unsupportedAction . getLabel ( ) , ex ) ; 
switch ( unsupportedAction ) { 
case SEND_TO_ERROR : LOG . debug ( "Sending record to error due to unsupported operation {}" , op ) ; 
errorRecords . add ( new OnRecordErrorException ( record , JdbcErrors . JDBC_70 , op ) ) ; 
break ; 
case USE_DEFAULT : opCode = defaultOpCode ; 
break ; 
case DISCARD : default : LOG . debug ( "Discarding record with unsupported operation {}" , op ) ; 
} 
} 
return opCode ; 
} 
} 

public class RunnerPool { 
public T getIdleRunner ( long idleTime ) { 
QueueItem < T > item = queue . poll ( ) ; 
if ( item == null ) return null ; 
if ( ( System . currentTimeMillis ( ) - item . timestamp ) < idleTime ) { 
queue . add ( item ) ; 
return null ; 
} 
return item . runner ; 
} 
} 

public class RunnerPool { 
public void destroy ( ) throws PipelineRuntimeException { 
destroyed . set ( true ) ; 
if ( queue . size ( ) < runtimeStats . getTotalRunners ( ) ) throw new PipelineRuntimeException ( ContainerError . CONTAINER_0802 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; 
} 
} 

public class RunnerPool { 
private void validateNotDestroyed ( ) throws PipelineRuntimeException { 
if ( destroyed . get ( ) ) throw new PipelineRuntimeException ( ContainerError . CONTAINER_0803 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; 
} 
} 

public class KinesisUtil { 
public static String getLastShardId ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName ) throws StageException { 
AmazonKinesis kinesisClient = getKinesisClient ( awsClientConfig , conf ) ; 
String lastShardId = null ; 
try { 
StreamDescription description ; 
do { 
if ( lastShardId == null ) description = kinesisClient . describeStream ( streamName ) . getStreamDescription ( ) ; 
else description = kinesisClient . describeStream ( streamName , lastShardId ) . getStreamDescription ( ) ; 
int pageSize = description . getShards ( ) . size ( ) ; 
lastShardId = description . getShards ( ) . get ( pageSize - 1 ) . getShardId ( ) ; 
} 
while ( description . getHasMoreShards ( ) ) ; 
return lastShardId ; 
} 
finally { 
kinesisClient . shutdown ( ) ; 
} 
} 
} 

public class JdbcMultiRowRecordWriter { 
private void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { 
if ( queue . isEmpty ( ) ) return ; 
int rowCount = 0 ; 
final Record first = queue . getFirst ( ) ; 
SortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; 
if ( columnsToParameters . isEmpty ( ) ) { 
if ( LOG . isWarnEnabled ( ) ) LOG . warn ( "No parameters found for record with ID {}; skipping" , first . getHeader ( ) . getSourceId ( ) ) ; 
return ; 
} 
String query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; 
LinkedList < Record > removed = new LinkedList < > ( ) ; 
try ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { 
int paramIdx = 1 ; 
while ( ! queue . isEmpty ( ) ) { 
Record r = queue . removeFirst ( ) ; 
if ( opCode != DELETE_CODE ) paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; 
if ( opCode != OperationType . INSERT_CODE ) paramIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; 
removed . add ( r ) ; 
++ rowCount ; 
if ( rowCount == maxRowsPerBatch ) { 
processBatch ( removed , errorRecords , statement , connection ) ; 
rowCount = 0 ; 
paramIdx = 1 ; 
removed . clear ( ) ; 
} 
} 
} 
catch ( SQLException e ) { 
handleSqlException ( e , removed , errorRecords ) ; 
} 
if ( ! removed . isEmpty ( ) ) { 
query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; 
try ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { 
int paramIdx = 1 ; 
for ( Record r : removed ) { 
if ( opCode != DELETE_CODE ) paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; 
if ( opCode != OperationType . INSERT_CODE ) paramIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; 
} 
processBatch ( removed , errorRecords , statement , connection ) ; 
} 
catch ( SQLException e ) { 
handleSqlException ( e , removed , errorRecords ) ; 
} 
} 
} 
} 

public class SpoolDirUtil { 
public static boolean compareFiles ( WrappedFileSystem fs , WrappedFile f1 , WrappedFile f2 ) { 
if ( ! fs . exists ( f2 ) ) return true ; 
try { 
long mtime1 = fs . getLastModifiedTime ( f1 ) ; 
long mtime2 = fs . getLastModifiedTime ( f2 ) ; 
long ctime1 = fs . getChangedTime ( f1 ) ; 
long ctime2 = fs . getChangedTime ( f2 ) ; 
long time1 = Math . max ( mtime1 , ctime1 ) ; 
long time2 = Math . max ( mtime2 , ctime2 ) ; 
int compares = Long . compare ( time1 , time2 ) ; 
if ( compares != 0 ) return compares > 0 ; 
} 
catch ( IOException ex ) { 
LOG . error ( "Failed to get ctime: '{}'" , f1 . getFileName ( ) , ex ) ; 
return false ; 
} 
return f1 . getAbsolutePath ( ) . compareTo ( f2 . getAbsolutePath ( ) ) > 0 ; 
} 
} 

public class ShellExecutor { 
private static int retrievePidIfFeasible ( Process process ) { 
if ( unixProcessClass == null ) return UNDETERMINED_PID ; 
if ( ! unixProcessClass . isInstance ( process ) ) { 
LOG . debug ( "Do not support retrieving PID from {}" , process . getClass ( ) . getName ( ) ) ; 
return UNDETERMINED_PID ; 
} 
try { 
return ( int ) pidField . get ( process ) ; 
} 
catch ( IllegalAccessException e ) { 
LOG . debug ( "Can't retrieve PID value from the field" , e ) ; 
return UNDETERMINED_PID ; 
} 
} 
} 

public class FieldHasherProcessor { 
private Set < String > validateAndExtractFieldsToHash ( Record record , Set < String > fieldsDontExist , Set < String > fieldsWithListOrMapType , Set < String > fieldsWithNull , Collection < String > matchingFieldsPath ) { 
Set < String > validFieldsToHashForThisConfig = new HashSet < String > ( ) ; 
for ( String matchingFieldPath : matchingFieldsPath ) { 
if ( record . has ( matchingFieldPath ) ) { 
Field field = record . get ( matchingFieldPath ) ; 
if ( UNSUPPORTED_FIELD_TYPES . contains ( field . getType ( ) ) ) fieldsWithListOrMapType . add ( matchingFieldPath ) ; 
else if ( field . getValue ( ) == null ) fieldsWithNull . add ( matchingFieldPath ) ; 
else validFieldsToHashForThisConfig . add ( matchingFieldPath ) ; 
} 
else fieldsDontExist . add ( matchingFieldPath ) ; 
} 
return validFieldsToHashForThisConfig ; 
} 
} 

public class HadoopSecurityUtil { 
public static UserGroupInformation getProxyUser ( String user , Stage . Context context , UserGroupInformation loginUser , List < Stage . ConfigIssue > issues , String configGroup , String configName ) { 
boolean alwaysImpersonate = context . getConfiguration ( ) . get ( HadoopConfigConstants . IMPERSONATION_ALWAYS_CURRENT_USER , false ) ; 
if ( alwaysImpersonate ) { 
if ( ! StringUtils . isEmpty ( user ) ) issues . add ( context . createConfigIssue ( configGroup , configName , Errors . HADOOP_00001 ) ) ; 
user = context . getUserContext ( ) . getAliasName ( ) ; 
} 
if ( StringUtils . isEmpty ( user ) ) return loginUser ; 
boolean lowerCase = context . getConfiguration ( ) . get ( HadoopConfigConstants . LOWERCASE_USER , false ) ; 
if ( lowerCase ) user = user . toLowerCase ( ) ; 
return UserGroupInformation . createProxyUser ( user , loginUser ) ; 
} 
} 

public class HdfsMetadataExecutor { 
private void ensureDirectoryExists ( FileSystem fs , Path path ) throws IOException { 
if ( ! fs . exists ( path ) ) { 
LOG . debug ( "Creating directory: {}" , path ) ; 
if ( ! fs . mkdirs ( path ) ) throw new IOException ( "Can't create directory: " + path ) ; 
} 
} 
} 

public class HiveMetadataProcessor { 
private Map < PartitionInfoCacheSupport . PartitionValues , String > detectNewPartition ( PartitionInfoCacheSupport . PartitionValues partitionValues , PartitionInfoCacheSupport . PartitionInfo pCache , String location ) throws StageException { 
Map < PartitionInfoCacheSupport . PartitionValues , String > partitionInfoDiff = new HashMap < > ( ) ; 
partitionInfoDiff . put ( partitionValues , location ) ; 
partitionInfoDiff = ( pCache != null ) ? pCache . getDiff ( partitionInfoDiff ) : partitionInfoDiff ; 
if ( pCache == null || ! partitionInfoDiff . isEmpty ( ) ) return partitionInfoDiff ; 
return null ; 
} 
} 

public class HiveMetadataProcessor { 
@ VisibleForTesting static void updateRecordForHDFS ( Record record , boolean roll , String avroSchema , String location ) { 
if ( roll ) record . getHeader ( ) . setAttribute ( HDFS_HEADER_ROLL , "true" ) ; 
record . getHeader ( ) . setAttribute ( HDFS_HEADER_AVROSCHEMA , avroSchema ) ; 
record . getHeader ( ) . setAttribute ( HDFS_HEADER_TARGET_DIRECTORY , location ) ; 
LOG . trace ( "Record {} will be stored in {} path: roll({}), avro schema: {}" , record . getHeader ( ) . getSourceId ( ) , location , roll , avroSchema ) ; 
} 
} 

public class BootstrapMesosDriver { 
public static void main ( String [ ] args ) throws Exception { 
BootstrapCluster . printSystemPropsEnvVariables ( ) ; 
String mesosDir = System . getenv ( "MESOS_DIRECTORY" ) ; 
if ( mesosDir == null ) throw new IllegalStateException ( "Expected the env. variable MESOS_DIRECTORY to be defined" ) ; 
File mesosHomeDir = new File ( mesosDir ) ; 
String sparkDir = System . getenv ( "SPARK_HOME" ) ; 
if ( sparkDir == null ) throw new IllegalStateException ( "Expected the env. variable SPARK_HOME to be defined" ) ; 
File sparkHomeDir = new File ( sparkDir ) ; 
int processExitValue = BootstrapCluster . findAndExtractJar ( mesosHomeDir , sparkHomeDir ) ; 
if ( processExitValue != 0 ) throw new IllegalStateException ( "Process extracting archives from uber jar exited abnormally; check Mesos driver stdout file" ) ; 
System . setProperty ( "SDC_MESOS_BASE_DIR" , new File ( mesosHomeDir , BootstrapCluster . SDC_MESOS_BASE_DIR ) . getAbsolutePath ( ) ) ; 
final Class < ? > clazz = Class . forName ( "com.streamsets.pipeline.BootstrapClusterStreaming" ) ; 
final Method method = clazz . getMethod ( "main" , String [ ] . class ) ; 
method . invoke ( null , new Object [ ] { 
args } 
) ; 
} 
} 

public class HttpClientCommon { 
private void configureAuthAndBuildClient ( ClientBuilder clientBuilder , List < Stage . ConfigIssue > issues ) { 
if ( jerseyClientConfig . authType == AuthenticationType . OAUTH ) { 
String consumerKey = jerseyClientConfig . oauth . resolveConsumerKey ( context , "CREDENTIALS" , "conf.oauth." , issues ) ; 
String consumerSecret = jerseyClientConfig . oauth . resolveConsumerSecret ( context , "CREDENTIALS" , "conf.oauth." , issues ) ; 
String token = jerseyClientConfig . oauth . resolveToken ( context , "CREDENTIALS" , "conf.oauth." , issues ) ; 
String tokenSecret = jerseyClientConfig . oauth . resolveTokenSecret ( context , "CREDENTIALS" , "conf.oauth." , issues ) ; 
if ( issues . isEmpty ( ) ) authToken = JerseyClientUtil . configureOAuth1 ( consumerKey , consumerSecret , token , tokenSecret , clientBuilder ) ; 
} 
else if ( jerseyClientConfig . authType . isOneOf ( AuthenticationType . DIGEST , AuthenticationType . BASIC , AuthenticationType . UNIVERSAL ) ) { 
String username = jerseyClientConfig . basicAuth . resolveUsername ( context , "CREDENTIALS" , "conf.basicAuth." , issues ) ; 
String password = jerseyClientConfig . basicAuth . resolvePassword ( context , "CREDENTIALS" , "conf.basicAuth." , issues ) ; 
if ( issues . isEmpty ( ) ) JerseyClientUtil . configurePasswordAuth ( jerseyClientConfig . authType , username , password , clientBuilder ) ; 
} 
try { 
buildNewAuthenticatedClient ( issues , false ) ; 
clientInitialized = true ; 
} 
catch ( StageException e ) { 
ExceptionUtils . throwUndeclared ( e ) ; 
} 
} 
} 

public class HttpClientCommon { 
public HttpMethod getHttpMethod ( HttpMethod httpMethod , String methodExpression , Record record ) throws ELEvalException { 
if ( httpMethod != HttpMethod . EXPRESSION ) return httpMethod ; 
RecordEL . setRecordInContext ( methodVars , record ) ; 
return HttpMethod . valueOf ( methodEval . eval ( methodVars , methodExpression , String . class ) ) ; 
} 
} 

public class ScriptTypedNullObject { 
public static Object getFieldNull ( Record record , String fieldPath ) { 
Field f = record . get ( fieldPath ) ; 
if ( f != null ) return f . getValue ( ) == null ? getTypedNullFromField ( f ) : f . getValue ( ) ; 
return null ; 
} 
} 

public class AvroSchemaHelper { 
public Schema loadFromRegistry ( String subject , int schemaId ) throws SchemaRegistryException { 
try { 
if ( isEmpty ( subject ) ) return loadFromRegistry ( schemaId ) ; 
else return loadFromRegistry ( subject ) ; 
} 
catch ( SchemaRegistryException e ) { 
throw new SchemaRegistryException ( e ) ; 
} 
} 
} 

public class AvroSchemaHelper { 
public Optional < Integer > detectSchemaId ( byte [ ] data ) { 
if ( data . length < 5 ) return Optional . empty ( ) ; 
ByteBuffer wrapped = ByteBuffer . wrap ( data ) ; 
if ( wrapped . get ( ) != MAGIC_BYTE ) return Optional . empty ( ) ; 
return Optional . of ( wrapped . getInt ( ) ) ; 
} 
} 

public class ServicesUtil { 
public static List < Record > parseAll ( Stage . Context stageContext , ToErrorContext toErrorContext , boolean produceSingleRecordPerMessage , String messageId , byte [ ] payload ) throws StageException { 
List < Record > records = new ArrayList < > ( ) ; 
try ( DataParser parser = stageContext . getService ( DataFormatParserService . class ) . getParser ( messageId , payload ) ) { 
Record record = null ; 
do { 
try { 
record = parser . parse ( ) ; 
} 
catch ( RecoverableDataParserException e ) { 
handleException ( stageContext , toErrorContext , messageId , e , e . getUnparsedRecord ( ) ) ; 
continue ; 
} 
if ( record != null ) records . add ( record ) ; 
} 
while ( record != null ) ; 
} 
catch ( IOException | DataParserException ex ) { 
Record record = stageContext . createRecord ( messageId ) ; 
record . set ( Field . create ( payload ) ) ; 
handleException ( stageContext , toErrorContext , messageId , ex , record ) ; 
return records ; 
} 
if ( produceSingleRecordPerMessage ) { 
List < Field > list = new ArrayList < > ( ) ; 
for ( Record record : records ) { 
list . add ( record . get ( ) ) ; 
} 
Record record = records . get ( 0 ) ; 
record . set ( Field . create ( list ) ) ; 
records . clear ( ) ; 
records . add ( record ) ; 
} 
return records ; 
} 
} 

public class ClasspathValidatorResult { 
public void logDetails ( ) { 
if ( isValid ( ) ) return ; 
LOG . warn ( "Validation results for {}" , name ) ; 
if ( ! unparseablePaths . isEmpty ( ) ) { 
LOG . warn ( "Can't parse the following artifacts:" ) ; 
for ( String path : unparseablePaths ) { 
LOG . warn ( "  {}" , path ) ; 
} 
} 
if ( ! versionCollisions . isEmpty ( ) ) { 
LOG . warn ( "Detected colliding dependency versions:" ) ; 
for ( Map . Entry < String , Map < String , List < Dependency > > > entry : versionCollisions . entrySet ( ) ) { 
LOG . warn ( "  Dependency {} have versions: {}" , entry . getKey ( ) , StringUtils . join ( entry . getValue ( ) . keySet ( ) , ", " ) ) ; 
for ( Map . Entry < String , List < Dependency > > versionEntry : entry . getValue ( ) . entrySet ( ) ) { 
LOG . warn ( "    Version: {}" , versionEntry . getKey ( ) ) ; 
for ( Dependency dependency : versionEntry . getValue ( ) ) { 
LOG . warn ( "      {}" , dependency . getSourceName ( ) ) ; 
} 
} 
} 
} 
} 
} 

public class OffsetUtil { 
@ SuppressWarnings ( "unchecked" ) public static Map < String , String > deserializeOffsetMap ( String lastSourceOffset ) throws IOException { 
Map < String , String > offsetMap ; 
if ( lastSourceOffset == null || lastSourceOffset . isEmpty ( ) ) offsetMap = new HashMap < > ( ) ; 
else offsetMap = JSON_MAPPER . readValue ( lastSourceOffset , Map . class ) ; 
return offsetMap ; 
} 
} 

public class OmniturePollingConsumer { 
public int queueReport ( ) throws IOException , InterruptedException , ExecutionException , TimeoutException , StageException { 
final AsyncInvoker asyncInvoker = queueResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; 
LOG . debug ( "Queueing report using URL {} with description {}" , queueResource . getUri ( ) . toURL ( ) . toString ( ) , reportDescription ) ; 
final Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( reportDescription ) ) ; 
Response response = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
if ( response == null ) { 
LOG . error ( "Failed to get response using URL {}" , queueResource . getUri ( ) . toURL ( ) . toString ( ) ) ; 
throw new StageException ( Errors . OMNITURE_01 , "HTTP response was null" ) ; 
} 
LOG . debug ( "Received response: status {}" , response . getStatus ( ) ) ; 
ObjectMapper mapper = new ObjectMapper ( ) ; 
String json = response . readEntity ( String . class ) ; 
LOG . trace ( "Response JSON: {}" , json ) ; 
JsonNode root = mapper . readTree ( json ) ; 
if ( root == null ) { 
LOG . error ( "Invalid JSON in response: {}" , json ) ; 
throw new StageException ( Errors . OMNITURE_01 , json ) ; 
} 
if ( root . has ( "error" ) ) throw new StageException ( Errors . OMNITURE_01 , root . get ( "error_description" ) . asText ( ) ) ; 
LOG . info ( "Omniture report queued" ) ; 
return root . get ( "reportID" ) . asInt ( ) ; 
} 
} 

public class OmniturePollingConsumer { 
public void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { 
int waitTime = 1000 ; 
Response response = null ; 
while ( ! stop ) { 
final AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; 
LOG . debug ( "Getting report using URL {} with report ID {}" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; 
final Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( "{ \"reportID\": " + reportId + " }" ) ) ; 
response = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
String input = response . readEntity ( String . class ) ; 
ObjectMapper mapper = new ObjectMapper ( ) ; 
JsonNode root = mapper . readTree ( input ) ; 
if ( ! root . has ( "error" ) ) { 
boolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
if ( ! accepted ) LOG . warn ( "Response buffer full, dropped record." ) ; 
break ; 
} 
else if ( root . get ( "error" ) . textValue ( ) . equals ( "report_not_ready" ) ) { 
waitTime *= 2 ; 
LOG . info ( "Report not available. Sleeping for {} seconds" , waitTime / 1000 ) ; 
Thread . sleep ( waitTime ) ; 
} 
else throw new StageException ( Errors . OMNITURE_02 , root . get ( "error" ) . get ( "error_description" ) . asText ( ) ) ; 
} 
response . close ( ) ; 
} 
} 

public class GcsObjectPostProcessingHandler { 
private void delete ( BlobId blobId ) { 
LOG . debug ( "Deleting object '{}'" , String . format ( BLOB_PATH_TEMPLATE , blobId . getBucket ( ) , blobId . getName ( ) ) ) ; 
boolean deleted = storage . delete ( blobId ) ; 
if ( ! deleted ) LOG . error ( "Cannot delete object '{}'" , String . format ( BLOB_PATH_TEMPLATE , blobId . getBucket ( ) , blobId . getName ( ) ) ) ; 
} 
} 

public class FileContext { 
public LiveFileReader getReader ( ) throws IOException { 
Utils . checkState ( open , "FileContext is closed" ) ; 
if ( reader == null ) { 
currentFile = getStartingCurrentFileName ( ) ; 
long fileOffset = getStartingOffset ( ) ; 
boolean needsToScan = currentFile == null || fileOffset == Long . MAX_VALUE ; 
if ( needsToScan ) { 
if ( currentFile != null ) currentFile = currentFile . refresh ( ) ; 
currentFile = scanner . scan ( currentFile ) ; 
fileOffset = 0 ; 
} 
if ( currentFile != null ) { 
reader = new SingleLineLiveFileReader ( getRollMode ( ) , getMultiFileInfo ( ) . getTag ( ) , currentFile , charset , fileOffset , maxLineLength ) ; 
if ( ! multiFileInfo . getMultiLineMainLinePatter ( ) . isEmpty ( ) ) reader = new MultiLineLiveFileReader ( getMultiFileInfo ( ) . getTag ( ) , reader , Pattern . compile ( multiFileInfo . getMultiLineMainLinePatter ( ) ) ) ; 
if ( fileOffset == 0 ) eventPublisher . publish ( new FileEvent ( currentFile , FileEvent . Action . START ) ) ; 
} 
} 
return reader ; 
} 
} 

public class FileContext { 
public void releaseReader ( boolean inErrorDiscardReader ) throws IOException { 
Utils . checkState ( open , "FileContext is closed" ) ; 
boolean hasNext ; 
try { 
hasNext = reader != null && reader . hasNext ( ) ; 
} 
catch ( IOException ex ) { 
IOUtils . closeQuietly ( reader ) ; 
reader = null ; 
hasNext = false ; 
} 
boolean doneWithFile = ! hasNext || inErrorDiscardReader ; 
if ( doneWithFile ) { 
IOUtils . closeQuietly ( reader ) ; 
reader = null ; 
setStartingCurrentFileName ( currentFile ) ; 
setStartingOffset ( Long . MAX_VALUE ) ; 
if ( currentFile == null ) return ; 
LiveFile file = currentFile . refresh ( ) ; 
if ( inErrorDiscardReader ) { 
LOG . warn ( "Processing file '{}' produced an error, skipping '{}' post processing on that file" , file , postProcessing ) ; 
eventPublisher . publish ( new FileEvent ( file , FileEvent . Action . ERROR ) ) ; 
} 
else { 
eventPublisher . publish ( new FileEvent ( file , FileEvent . Action . END ) ) ; 
switch ( postProcessing ) { 
case NONE : LOG . debug ( "File '{}' processing completed, post processing action 'NONE'" , file ) ; 
break ; 
case DELETE : if ( ! inPreviewMode ) try { 
Files . delete ( file . getPath ( ) ) ; 
LOG . debug ( "File '{}' processing completed, post processing action 'DELETED'" , file ) ; 
} 
catch ( IOException ex ) { 
throw new IOException ( Utils . format ( "Could not delete '{}': {}" , file , ex . toString ( ) ) , ex ) ; 
} 
break ; 
case ARCHIVE : if ( ! inPreviewMode ) { 
Path fileArchive = Paths . get ( archiveDir , file . getPath ( ) . toString ( ) ) ; 
if ( fileArchive == null ) throw new IOException ( "Could not find archive file" ) ; 
try { 
Files . createDirectories ( fileArchive . getParent ( ) ) ; 
Files . move ( file . getPath ( ) , fileArchive ) ; 
LOG . debug ( "File '{}' processing completed, post processing action 'ARCHIVED' as" , file ) ; 
} 
catch ( IOException ex ) { 
throw new IOException ( Utils . format ( "Could not archive '{}': {}" , file , ex . toString ( ) ) , ex ) ; 
} 
} 
break ; 
} 
} 
} 
else { 
setStartingCurrentFileName ( currentFile ) ; 
setStartingOffset ( getReader ( ) . getOffset ( ) ) ; 
} 
} 
} 

public class ApiClient { 
public ApiClient setDPMBaseURL ( String dpmBaseURL ) { 
if ( dpmBaseURL != null && authentication != null ) authentication . setDPMBaseURL ( dpmBaseURL ) ; 
return this ; 
} 
} 

public class AvroSchemaGenerator { 
public static Schema buildSchema ( Map < String , Schema > fields , Object ... levels ) { 
List < Schema . Field > recordFields = new ArrayList < > ( fields . size ( ) ) ; 
for ( Map . Entry < String , Schema > entry : fields . entrySet ( ) ) { 
recordFields . add ( new Schema . Field ( entry . getKey ( ) , entry . getValue ( ) , null , entry . getValue ( ) . getJsonProp ( "default" ) ) ) ; 
} 
Schema recordSchema ; 
if ( levels . length == 0 ) recordSchema = Schema . createRecord ( schemaName , null , null , false ) ; 
else { 
LinkedList < String > lvl = ( LinkedList < String > ) levels [ 0 ] ; 
recordSchema = Schema . createRecord ( joiner . join ( lvl ) , null , null , false ) ; 
} 
recordSchema . setFields ( recordFields ) ; 
return recordSchema ; 
} 
} 

public class MapreduceUtils { 
public static void addJarsToJob ( Configuration conf , boolean allowMultiple , String ... jarPatterns ) { 
final ClassLoader loader = MapreduceUtils . class . getClassLoader ( ) ; 
if ( ! ( loader instanceof URLClassLoader ) ) throw new IllegalStateException ( String . format ( "ClassLoader for %s is not an instance of URLClassLoader (it is %s), and thus this method cannot be used" , MapreduceUtils . class . getCanonicalName ( ) , loader . getClass ( ) . getCanonicalName ( ) ) ) ; 
final URLClassLoader urlClassLoader = ( URLClassLoader ) loader ; 
addJarsToJob ( conf , allowMultiple , urlClassLoader . getURLs ( ) , jarPatterns ) ; 
} 
} 

public class ForceSource { 
private boolean checkConditionExpressions ( SOQLParser . ConditionExpressionsContext conditionExpressions , String fieldName ) { 
for ( SOQLParser . ConditionExpressionContext ce : conditionExpressions . conditionExpression ( ) ) { 
if ( ( ce . conditionExpressions ( ) != null && checkConditionExpressions ( ce . conditionExpressions ( ) , fieldName ) ) || ( ce . fieldExpression ( ) != null && ce . fieldExpression ( ) . fieldElement ( ) . getText ( ) . equalsIgnoreCase ( fieldName ) ) ) return true ; 
} 
return false ; 
} 
} 

public class BootstrapMain { 
public static void premain ( String args , Instrumentation instrumentation ) { 
if ( BootstrapMain . instrumentation == null ) BootstrapMain . instrumentation = instrumentation ; 
else throw new IllegalStateException ( "Premain method cannot be called twice (" + BootstrapMain . instrumentation + ")" ) ; 
} 
} 

public class BaseKafkaSource { 
public int getParallelism ( ) throws StageException { 
if ( originParallelism == 0 ) { 
originParallelism = kafkaValidationUtil . getPartitionCount ( conf . metadataBrokerList , conf . topic , new HashMap < String , Object > ( conf . kafkaConsumerConfigs ) , 3 , 1000 ) ; 
if ( originParallelism < 1 ) throw new StageException ( KafkaErrors . KAFKA_42 , conf . topic ) ; 
} 
return originParallelism ; 
} 
} 

public class BigQueryDelegate { 
public TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { 
checkArgument ( timeout >= 1000 , "Timeout must be at least one second." ) ; 
Instant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; 
JobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; 
JobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; 
Job queryJob = bigquery . create ( jobInfo ) ; 
if ( queryJob == null ) { 
LOG . error ( "Job no longer exists: {}" , jobInfo ) ; 
throw new RuntimeException ( "Job no longer exists: " + jobInfo ) ; 
} 
else if ( queryJob . getStatus ( ) . getError ( ) != null ) { 
BigQueryError error = queryJob . getStatus ( ) . getError ( ) ; 
LOG . error ( "Query Job execution error: {}" , error ) ; 
throw new StageException ( Errors . BIGQUERY_02 , error ) ; 
} 
while ( ! queryJob . isDone ( ) ) if ( Instant . now ( clock ) . isAfter ( maxTime ) || ! ThreadUtil . sleep ( 100 ) ) { 
if ( bigquery . cancel ( queryJob . getJobId ( ) ) ) LOG . info ( "Job {} cancelled successfully." , queryJob . getJobId ( ) ) ; 
else LOG . warn ( "Job {} not found" , queryJob . getJobId ( ) ) ; 
throw new StageException ( Errors . BIGQUERY_00 ) ; 
} 
if ( queryJob . getStatus ( ) . getError ( ) != null ) { 
String errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; 
throw new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; 
} 
TableResult result = null ; 
try { 
result = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; 
} 
catch ( InterruptedException e ) { 
String errorMsg = e . getMessage ( ) ; 
throw new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; 
} 
return result ; 
} 
} 

public class BigQueryDelegate { 
public LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { 
checkState ( schema . size ( ) == values . size ( ) , "Schema '{}' and Values '{}' sizes do not match." , schema . size ( ) , values . size ( ) ) ; 
LinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; 
for ( int i = 0 ; 
i < values . size ( ) ; 
i ++ ) { 
FieldValue value = values . get ( i ) ; 
com . google . cloud . bigquery . Field field = schema . get ( i ) ; 
if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) root . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; 
else if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) root . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; 
else if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) root . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; 
} 
return root ; 
} 
} 

public class KineticaTableUtils { 
private List < String > getTableDescription ( ) throws GPUdbException { 
List < List < String > > descriptions = showTableResponse . getTableDescriptions ( ) ; 
if ( descriptions == null || descriptions . size ( ) != 1 ) throw new GPUdbException ( "Error getting description for table " + tableName ) ; 
return descriptions . get ( 0 ) ; 
} 
} 

public class KineticaTableUtils { 
private void validateTableAcceptsInserts ( ) throws GPUdbException { 
for ( String s : tableDescription ) { 
if ( s . equalsIgnoreCase ( "COLLECTION" ) ) throw new GPUdbException ( "Error: table " + tableName + " is a Collection" ) ; 
else if ( s . equalsIgnoreCase ( "VIEW" ) ) throw new GPUdbException ( "Error: table " + tableName + " is a View" ) ; 
else if ( s . equalsIgnoreCase ( "JOIN" ) ) throw new GPUdbException ( "Error: table " + tableName + " is a Join Table" ) ; 
else if ( s . equalsIgnoreCase ( "RESULT_TABLE" ) ) throw new GPUdbException ( "Error: table " + tableName + " is a Result Table" ) ; 
} 
} 
} 

public class KineticaTableUtils { 
private Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { 
Class < ? > columnType = null ; 
if ( field . get ( "type" ) instanceof JSONArray ) { 
JSONArray columnTypes = field . getJSONArray ( "type" ) ; 
for ( int j = 0 ; 
j < columnTypes . length ( ) ; 
j ++ ) { 
String ct = ( String ) columnTypes . get ( j ) ; 
if ( ! ct . equals ( "null" ) ) { 
columnType = getClassForType ( ct ) ; 
break ; 
} 
} 
} 
else columnType = getClassForType ( field . getString ( "type" ) ) ; 
if ( columnType == null ) throw new GPUdbException ( "Error getting column type for field: " + field . toString ( ) ) ; 
return columnType ; 
} 
} 

public class KineticaTableUtils { 
private boolean typeIsNullable ( JSONObject field ) throws GPUdbException { 
if ( field . get ( "type" ) instanceof JSONArray ) { 
JSONArray columnTypes = field . getJSONArray ( "type" ) ; 
for ( int j = 0 ; 
j < columnTypes . length ( ) ; 
j ++ ) { 
String ct = ( String ) columnTypes . get ( j ) ; 
if ( ct . equals ( "null" ) ) return true ; 
} 
} 
return false ; 
} 
} 

public class KineticaTableUtils { 
private JSONObject getTableSchema ( String tableName , ShowTableResponse showTableResponse ) throws GPUdbException { 
List < String > schemas = showTableResponse . getTypeSchemas ( ) ; 
if ( schemas == null || schemas . size ( ) != 1 ) throw new GPUdbException ( "Error getting schema for table " + tableName ) ; 
return new JSONObject ( schemas . get ( 0 ) ) ; 
} 
} 

public class KineticaTableUtils { 
private Map < String , List < String > > getColumnProperties ( String tableName , ShowTableResponse showTableResponse ) throws GPUdbException { 
List < Map < String , List < String > > > columnPropertiesList = showTableResponse . getProperties ( ) ; 
if ( columnPropertiesList == null || columnPropertiesList . size ( ) != 1 ) throw new GPUdbException ( "Error getting properties for table " + tableName ) ; 
return columnPropertiesList . get ( 0 ) ; 
} 
} 

public class KineticaTableUtils { 
private Class < ? > getClassForType ( String typeName ) throws GPUdbException { 
typeName = typeName . replace ( " " , "" ) ; 
if ( typeName . equalsIgnoreCase ( STRING_TYPE_NAME ) ) return String . class ; 
else if ( typeName . equalsIgnoreCase ( LONG_TYPE_NAME ) ) return Long . class ; 
else if ( typeName . equalsIgnoreCase ( INTEGER_TYPE_NAME ) ) return Integer . class ; 
else if ( typeName . equalsIgnoreCase ( FLOAT_TYPE_NAME ) ) return Float . class ; 
else if ( typeName . equalsIgnoreCase ( DOUBLE_TYPE_NAME ) ) return Double . class ; 
else if ( typeName . equalsIgnoreCase ( BYTES_TYPE_NAME ) ) return ByteBuffer . class ; 
else throw new GPUdbException ( "Error: unknown type '" + typeName + "' in table schema" ) ; 
} 
} 

public class MqttClientTarget { 
String getTopic ( Record record ) throws StageException { 
String result = publisherConf . topic ; 
if ( publisherConf . runtimeTopicResolution ) { 
RecordEL . setRecordInContext ( topicVars , record ) ; 
try { 
result = topicEval . eval ( topicVars , publisherConf . topicExpression , String . class ) ; 
if ( isEmpty ( result ) ) throw new StageException ( Errors . MQTT_08 , publisherConf . topicExpression , record . getHeader ( ) . getSourceId ( ) ) ; 
if ( ! allowedTopics . contains ( result ) && ! allowAllTopics ) throw new StageException ( Errors . MQTT_09 , result , record . getHeader ( ) . getSourceId ( ) ) ; 
} 
catch ( ELEvalException e ) { 
throw new StageException ( Errors . MQTT_10 , publisherConf . topicExpression , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) ) ; 
} 
} 
return result ; 
} 
} 

public class JmsSourceUpgrader { 
private static void upgradeV5ToV6 ( List < Config > configs , Context context ) { 
List < Config > dataFormatConfigs = configs . stream ( ) . filter ( c -> c . getName ( ) . startsWith ( "dataFormat" ) ) . collect ( Collectors . toList ( ) ) ; 
configs . removeAll ( dataFormatConfigs ) ; 
if ( dataFormatConfigs . stream ( ) . noneMatch ( c -> "dataFormatConfig.compression" . equals ( c . getName ( ) ) ) ) dataFormatConfigs . add ( new Config ( "dataFormatConfig.compression" , "NONE" ) ) ; 
context . registerService ( DataFormatParserService . class , dataFormatConfigs ) ; 
} 
} 

public class DataStore { 
public InputStream getInputStream ( ) throws IOException { 
acquireLock ( ) ; 
try { 
isClosed = false ; 
forWrite = false ; 
LOG . trace ( "Starts read '{}'" , file ) ; 
verifyAndRecover ( ) ; 
InputStream is = new ProxyInputStream ( new FileInputStream ( file . toFile ( ) ) ) { 
@ Override public void close ( ) throws IOException { 
if ( isClosed ) return ; 
try { 
super . close ( ) ; 
} 
finally { 
release ( ) ; 
isClosed = true ; 
stream = null ; 
} 
LOG . trace ( "Finishes read '{}'" , file ) ; 
} 
} 
; 
stream = is ; 
return is ; 
} 
catch ( Exception ex ) { 
release ( ) ; 
throw ex ; 
} 
} 
} 

public class DataStore { 
public OutputStream getOutputStream ( ) throws IOException { 
acquireLock ( ) ; 
try { 
isClosed = false ; 
forWrite = true ; 
LOG . trace ( "Starts write '{}'" , file ) ; 
verifyAndRecover ( ) ; 
if ( Files . exists ( file ) ) { 
Files . move ( file , fileOld ) ; 
LOG . trace ( "Starting write, move '{}' to '{}'" , file , fileOld ) ; 
} 
OutputStream os = new ProxyOutputStream ( new FileOutputStream ( fileTmp . toFile ( ) ) ) { 
@ Override public void close ( ) throws IOException { 
if ( isClosed ) return ; 
try { 
super . close ( ) ; 
} 
finally { 
isClosed = true ; 
stream = null ; 
} 
LOG . trace ( "Finishes write '{}'" , file ) ; 
} 
} 
; 
stream = os ; 
return os ; 
} 
catch ( Exception ex ) { 
release ( ) ; 
throw ex ; 
} 
} 
} 

public class HdfsUtils { 
public static FsPermission parseFsPermission ( String permissions ) throws IllegalArgumentException { 
try { 
return new FsPermission ( permissions ) ; 
} 
catch ( IllegalArgumentException e ) { 
if ( permissions . length ( ) == 9 ) permissions = "-" + permissions ; 
return FsPermission . valueOf ( permissions ) ; 
} 
} 
} 

public class ClassLoaderStageLibraryTask { 
private void validateAllServicesAvailable ( ) { 
List < String > missingServices = new LinkedList < > ( ) ; 
for ( StageDefinition stage : stageList ) { 
for ( ServiceDependencyDefinition service : stage . getServices ( ) ) { 
if ( ! serviceMap . containsKey ( service . getService ( ) ) ) missingServices . add ( Utils . format ( "Stage {} is missing service {}" , stage . getName ( ) , service . getService ( ) . getName ( ) ) ) ; 
} 
} 
if ( ! missingServices . isEmpty ( ) ) throw new RuntimeException ( "Missing services: " + StringUtils . join ( missingServices , ", " ) ) ; 
List < String > unsupportedServices = new LinkedList < > ( ) ; 
for ( ServiceDefinition serviceDefinition : serviceList ) { 
if ( ! ServiceRuntime . supports ( serviceDefinition . getProvides ( ) ) ) unsupportedServices . add ( serviceDefinition . getProvides ( ) . toString ( ) ) ; 
} 
if ( ! unsupportedServices . isEmpty ( ) ) throw new RuntimeException ( "Unsupported services: " + StringUtils . join ( unsupportedServices , ", " ) ) ; 
} 
} 

public class FileFilter { 
private static String globToRegex ( String glob ) { 
if ( glob . charAt ( 0 ) == '.' || glob . contains ( "/" ) || glob . contains ( "~" ) ) throw new IllegalArgumentException ( "Invalid character in file glob" ) ; 
glob = glob . replace ( "." , "\\." ) ; 
glob = glob . replace ( "*" , ".+" ) ; 
glob = glob . replace ( "?" , ".{1}+" ) ; 
return glob ; 
} 
} 

public class AmazonS3Util { 
static List < S3ObjectSummary > listObjectsLexicographically ( AmazonS3 s3Client , S3ConfigBean s3ConfigBean , AntPathMatcher pathMatcher , S3Offset s3Offset , int fetchSize ) { 
List < S3ObjectSummary > list = new ArrayList < > ( fetchSize ) ; 
ListObjectsRequest listObjectsRequest = new ListObjectsRequest ( ) ; 
listObjectsRequest . setBucketName ( s3ConfigBean . s3Config . bucket ) ; 
listObjectsRequest . setPrefix ( s3ConfigBean . s3Config . commonPrefix ) ; 
listObjectsRequest . setMaxKeys ( BATCH_SIZE ) ; 
if ( s3Offset . getKey ( ) != null ) listObjectsRequest . setMarker ( s3Offset . getKey ( ) ) ; 
ObjectListing objectListing = s3Client . listObjects ( listObjectsRequest ) ; 
while ( true ) { 
for ( S3ObjectSummary s : objectListing . getObjectSummaries ( ) ) { 
String fullPrefix = s . getKey ( ) ; 
String remainingPrefix = fullPrefix . substring ( s3ConfigBean . s3Config . commonPrefix . length ( ) , fullPrefix . length ( ) ) ; 
if ( ! remainingPrefix . isEmpty ( ) ) { 
if ( pathMatcher . match ( s3ConfigBean . s3FileConfig . prefixPattern , remainingPrefix ) ) list . add ( s ) ; 
if ( list . size ( ) == fetchSize ) return list ; 
} 
} 
if ( ! objectListing . isTruncated ( ) ) break ; 
objectListing = s3Client . listNextBatchOfObjects ( objectListing ) ; 
} 
return list ; 
} 
} 

public class ProductionPipelineRunner { 
public int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { 
LOG . debug ( "Checking if any active runner is idle" ) ; 
int counter = 0 ; 
try { 
destroyLock . lock ( ) ; 
while ( running && counter < pipes . size ( ) ) { 
counter ++ ; 
PipeRunner runner = null ; 
try { 
runner = runnerPool . getIdleRunner ( idleTime ) ; 
if ( runner == null ) return counter ; 
LOG . debug ( "Generating empty batch for runner: {}" , runner . getRunnerId ( ) ) ; 
pipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; 
FullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; 
pipeBatch . setIdleBatch ( true ) ; 
pipeBatch . skipStage ( originPipe ) ; 
executeRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; 
} 
finally { 
if ( runner != null ) runnerPool . returnRunner ( runner ) ; 
} 
} 
} 
finally { 
destroyLock . unlock ( ) ; 
} 
return counter ; 
} 
} 

public class ProductionPipelineRunner { 
private void createFailureBatch ( FullPipeBatch pipeBatch ) { 
if ( ! pipelineConfigBean . shouldCreateFailureSnapshot ) return ; 
try { 
for ( SnapshotInfo info : snapshotStore . getSummaryForPipeline ( pipelineName , revision ) ) { 
if ( info . isFailureSnapshot ( ) ) { 
LOG . trace ( "Skipping creation of failure snapshot as {} already exists." , info . getId ( ) ) ; 
return ; 
} 
} 
String snapshotName = "Failure_" + UUID . randomUUID ( ) . toString ( ) ; 
String snapshotLabel = "Failure at " + LocalDateTime . now ( ) . toString ( ) ; 
snapshotStore . create ( "" , pipelineName , revision , snapshotName , snapshotLabel , true ) ; 
snapshotStore . save ( pipelineName , revision , snapshotName , - 1 , ImmutableList . of ( pipeBatch . createFailureSnapshot ( ) ) ) ; 
} 
catch ( PipelineException ex ) { 
LOG . error ( "Can't serialize failure snapshot" , ex ) ; 
} 
} 
} 

public class CassandraTarget { 
@ SuppressWarnings ( "unchecked" ) private BoundStatement recordToBoundStatement ( Record record ) throws StageException { 
ImmutableList . Builder < Object > values = new ImmutableList . Builder < > ( ) ; 
SortedSet < String > columnsPresent = Sets . newTreeSet ( columnMappings . keySet ( ) ) ; 
for ( Map . Entry < String , String > mapping : columnMappings . entrySet ( ) ) { 
String columnName = mapping . getKey ( ) ; 
String fieldPath = mapping . getValue ( ) ; 
if ( ! record . has ( fieldPath ) || record . get ( fieldPath ) . getValue ( ) == null ) { 
columnsPresent . remove ( columnName ) ; 
continue ; 
} 
final Object value = record . get ( fieldPath ) . getValue ( ) ; 
if ( value instanceof List ) { 
List < Object > unpackedList = new ArrayList < > ( ) ; 
for ( Field item : ( List < Field > ) value ) { 
unpackedList . add ( item . getValue ( ) ) ; 
} 
values . add ( unpackedList ) ; 
} 
else if ( value instanceof Map ) { 
Map < Object , Object > unpackedMap = new HashMap < > ( ) ; 
for ( Map . Entry < String , Field > entry : ( ( Map < String , Field > ) value ) . entrySet ( ) ) { 
unpackedMap . put ( entry . getKey ( ) , entry . getValue ( ) . getValue ( ) ) ; 
} 
values . add ( unpackedMap ) ; 
} 
else values . add ( value ) ; 
} 
PreparedStatement stmt = statementCache . getUnchecked ( columnsPresent ) ; 
Object [ ] valuesArray = values . build ( ) . toArray ( ) ; 
BoundStatement boundStmt = null ; 
try { 
boundStmt = stmt . bind ( valuesArray ) ; 
} 
catch ( CodecNotFoundException | InvalidTypeException | NullPointerException e ) { 
errorRecordHandler . onError ( new OnRecordErrorException ( record , Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) , e ) ) ; 
} 
return boundStmt ; 
} 
} 

public class Configuration { 
public void set ( Map < String , String > newConfiguration ) { 
for ( Map . Entry < String , String > entry : newConfiguration . entrySet ( ) ) { 
if ( entry . getValue ( ) == null ) this . unset ( entry . getKey ( ) ) ; 
else this . set ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
} 
} 

public class KuduLookupProcessor { 
private KuduLookupKey generateLookupKey ( final Record record , final String tableName ) throws OnRecordErrorException { 
Map < String , Field > keyList = new HashMap < > ( ) ; 
for ( Map . Entry < String , String > key : columnToField . entrySet ( ) ) { 
String fieldName = key . getValue ( ) ; 
if ( ! record . has ( fieldName ) ) throw new OnRecordErrorException ( record , Errors . KUDU_32 , fieldName ) ; 
keyList . put ( key . getKey ( ) , record . get ( fieldName ) ) ; 
} 
return new KuduLookupKey ( tableName , keyList ) ; 
} 
} 

public class MultithreadedTableProvider { 
private void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { 
for ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { 
final SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; 
final TableRuntimeContext lastPartition = partitions . last ( ) ; 
final TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; 
Utils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( "Source table context for %s should match TableContext map key of %s" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; 
final boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; 
final boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; 
if ( ! partitioningTurnedOff && ! partitioningTurnedOn ) continue ; 
final Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; 
final Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; 
final int newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; 
if ( partitioningTurnedOff ) { 
LOG . info ( "Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with" + " no max offsets)" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; 
lastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { 
String basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; 
nextStartingOffsets . put ( col , basedOnStartOffset ) ; 
} 
) ; 
} 
else if ( partitioningTurnedOn ) { 
lastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { 
String basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; 
nextStartingOffsets . put ( col , basedOnStoredOffset ) ; 
} 
) ; 
nextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; 
if ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) throw new IllegalStateException ( String . format ( "Failed to remove partition %s for table %s in switching partitioning from off to on" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; 
LOG . info ( "Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting" + " offsets for the new partition {}" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; 
} 
final TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; 
reconstructedPartitions . put ( sourceTableContext , nextPartition ) ; 
} 
} 
} 

public class SchAdmin { 
public static void enableDPM ( DPMInfoJson dpmInfo , Context context ) throws IOException { 
Utils . checkNotNull ( dpmInfo , "DPMInfo" ) ; 
String dpmBaseURL = normalizeDpmBaseURL ( dpmInfo . getBaseURL ( ) ) ; 
String currentDPMBaseURL = context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , "" ) ; 
String currentAppAuthToken = context . configuration . get ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , "" ) . trim ( ) ; 
if ( ! currentDPMBaseURL . equals ( dpmBaseURL ) || currentAppAuthToken . length ( ) == 0 ) { 
String userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; 
String appAuthToken = null ; 
Response response = null ; 
try { 
Map < String , Object > newComponentJson = new HashMap < > ( ) ; 
newComponentJson . put ( "organization" , dpmInfo . getOrganization ( ) ) ; 
newComponentJson . put ( "componentType" , "dc" ) ; 
newComponentJson . put ( "numberOfComponents" , 1 ) ; 
newComponentJson . put ( "active" , true ) ; 
response = ClientBuilder . newClient ( ) . target ( dpmBaseURL + "/security/rest/v1/organization/" + dpmInfo . getOrganization ( ) + "/components" ) . register ( new CsrfProtectionFilter ( "CSRF" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; 
if ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) throw new RuntimeException ( Utils . format ( "DPM Create Application Token failed, status code '{}': {}" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; 
List < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { 
} 
) ; 
if ( newComponent . size ( ) > 0 ) appAuthToken = ( String ) newComponent . get ( 0 ) . get ( "fullAuthToken" ) ; 
else throw new RuntimeException ( "DPM Create Application Token failed: No token data from DPM Server." ) ; 
} 
finally { 
if ( response != null ) response . close ( ) ; 
logout ( dpmBaseURL , userAuthToken ) ; 
} 
updateTokenFile ( context , appAuthToken ) ; 
} 
updateDpmProperties ( context , dpmBaseURL , dpmInfo . getLabels ( ) , true ) ; 
} 
} 

public class SchAdmin { 
private static String normalizeDpmBaseURL ( String url ) { 
if ( url . endsWith ( "/" ) ) url = url . substring ( 0 , url . length ( ) - 1 ) ; 
return url ; 
} 
} 

public class SchAdmin { 
private static String retrieveUserToken ( String url , String username , String password ) { 
Response response = null ; 
try { 
Map < String , String > loginJson = new HashMap < > ( ) ; 
loginJson . put ( "userName" , username ) ; 
loginJson . put ( "password" , password ) ; 
response = ClientBuilder . newClient ( ) . target ( url + "/security/public-rest/v1/authentication/login" ) . register ( new CsrfProtectionFilter ( "CSRF" ) ) . request ( ) . post ( Entity . json ( loginJson ) ) ; 
if ( response . getStatus ( ) != Response . Status . OK . getStatusCode ( ) ) throw new RuntimeException ( Utils . format ( "DPM Login failed, status code '{}': {}" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; 
} 
finally { 
if ( response != null ) response . close ( ) ; 
} 
return response . getHeaderString ( SSOConstants . X_USER_AUTH_TOKEN ) ; 
} 
} 

public class SchAdmin { 
private static void logout ( String dpmBaseURL , String userAuthToken ) { 
Response response = null ; 
try { 
response = ClientBuilder . newClient ( ) . target ( dpmBaseURL + "/security/_logout" ) . register ( new CsrfProtectionFilter ( "CSRF" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . cookie ( SSOConstants . AUTHENTICATION_COOKIE_PREFIX + "LOGIN" , userAuthToken ) . get ( ) ; 
} 
finally { 
if ( response != null ) response . close ( ) ; 
} 
} 
} 

public class SchAdmin { 
private static void updateDpmProperties ( Context context , String dpmBaseURL , List < String > labels , boolean enableSch ) { 
if ( context . skipUpdatingDpmProperties ) return ; 
try { 
FileBasedConfigurationBuilder < PropertiesConfiguration > builder = new FileBasedConfigurationBuilder < > ( PropertiesConfiguration . class ) . configure ( new Parameters ( ) . properties ( ) . setFileName ( context . runtimeInfo . getConfigDir ( ) + "/dpm.properties" ) . setThrowExceptionOnMissing ( true ) . setListDelimiterHandler ( new DefaultListDelimiterHandler ( ';' ) ) . setIncludesAllowed ( false ) ) ; 
PropertiesConfiguration config = null ; 
config = builder . getConfiguration ( ) ; 
config . setProperty ( RemoteSSOService . DPM_ENABLED , Boolean . toString ( enableSch ) ) ; 
config . setProperty ( RemoteSSOService . DPM_BASE_URL_CONFIG , dpmBaseURL ) ; 
config . setProperty ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , APP_TOKEN_FILE_PROP_VAL ) ; 
if ( labels != null && labels . size ( ) > 0 ) config . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , StringUtils . join ( labels , ',' ) ) ; 
else config . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , "" ) ; 
builder . save ( ) ; 
} 
catch ( ConfigurationException e ) { 
throw new RuntimeException ( Utils . format ( "Updating dpm.properties file failed: {}" , e . getMessage ( ) ) , e ) ; 
} 
} 
} 

public class AvroSchemaGenerator { 
private Schema . Field schemaFieldForType ( String fieldPath , Record record , String fieldName , Field field ) throws OnRecordErrorException { 
Schema simpleSchema = simpleSchemaForType ( fieldPath , record , field ) ; 
Schema finalSchema = simpleSchema ; 
if ( getConfig ( ) . avroNullableFields ) finalSchema = Schema . createUnion ( ImmutableList . of ( Schema . create ( Schema . Type . NULL ) , simpleSchema ) ) ; 
return new Schema . Field ( fieldName , finalSchema , null , getDefaultValue ( simpleSchema ) ) ; 
} 
} 

public class AvroSchemaGenerator { 
private Schema complexSchemaForType ( String fieldPath , Record record , Field field ) throws OnRecordErrorException { 
Schema simpleSchema = simpleSchemaForType ( fieldPath , record , field ) ; 
Schema finalSchema = simpleSchema ; 
if ( getConfig ( ) . avroNullableFields ) finalSchema = Schema . createUnion ( ImmutableList . of ( Schema . create ( Schema . Type . NULL ) , simpleSchema ) ) ; 
JsonNode defaultValue = getDefaultValue ( simpleSchema ) ; 
if ( defaultValue != null ) finalSchema . addProp ( "defaultValue" , defaultValue ) ; 
return finalSchema ; 
} 
} 

public class AvroSchemaGenerator { 
private int getDecimalScaleOrPrecision ( Record record , Field field , String attributeName , int defaultValue , int minAllowed ) throws OnRecordErrorException { 
int finalValue = - 1 ; 
String stringValue = field . getAttribute ( attributeName ) ; 
if ( ! StringUtils . isEmpty ( stringValue ) ) finalValue = Integer . valueOf ( stringValue ) ; 
if ( finalValue < minAllowed ) finalValue = defaultValue ; 
if ( finalValue < minAllowed ) throw new OnRecordErrorException ( record , Errors . SCHEMA_GEN_0004 , finalValue , field ) ; 
return finalValue ; 
} 
} 

public class AvroSchemaGenerator { 
private JsonNode getDefaultValue ( Schema schema ) { 
if ( getConfig ( ) . avroNullableFields && getConfig ( ) . avroDefaultNullable ) return NullNode . getInstance ( ) ; 
if ( ! getConfig ( ) . avroNullableFields && defaultValuesForTypes . containsKey ( schema . getType ( ) ) ) return defaultValuesForTypes . get ( schema . getType ( ) ) ; 
return null ; 
} 
} 

public class FileRefUtil { 
@ SuppressWarnings ( "unchecked" ) public static synchronized void initMetricsIfNeeded ( ProtoConfigurableEntity . Context context ) { 
Gauge < Map < String , Object > > gauge = context . getGauge ( fileStatisticGaugeName ( context ) ) ; 
if ( gauge == null ) { 
gauge = context . createGauge ( fileStatisticGaugeName ( context ) , Comparator . comparing ( GAUGE_MAP_ORDERING :: get ) ) ; 
Map < String , Object > gaugeStatistics = gauge . getValue ( ) ; 
gaugeStatistics . put ( FileRefUtil . FILE , "" ) ; 
gaugeStatistics . put ( FileRefUtil . TRANSFER_THROUGHPUT , 0L ) ; 
gaugeStatistics . put ( FileRefUtil . SENT_BYTES , String . format ( FileRefUtil . BRACKETED_TEMPLATE , 0 , 0 ) ) ; 
gaugeStatistics . put ( FileRefUtil . REMAINING_BYTES , 0L ) ; 
gaugeStatistics . put ( FileRefUtil . COMPLETED_FILE_COUNT , 0L ) ; 
} 
Meter dataTransferMeter = context . getMeter ( FileRefUtil . TRANSFER_THROUGHPUT_METER ) ; 
if ( dataTransferMeter == null ) context . createMeter ( FileRefUtil . TRANSFER_THROUGHPUT_METER ) ; 
} 
} 

public class LocalFileSystem { 
public int compare ( WrappedFile path1 , WrappedFile path2 , boolean useLastModified ) { 
try { 
if ( useLastModified && ! exists ( path2 ) ) return 1 ; 
return getComparator ( useLastModified ) . compare ( path1 , path2 ) ; 
} 
catch ( RuntimeException ex ) { 
Throwable cause = ex . getCause ( ) ; 
if ( cause != null && cause instanceof NoSuchFileException ) { 
LOG . debug ( "Starting file may have already been archived." , cause ) ; 
return 1 ; 
} 
LOG . warn ( "Error while comparing files" , ex ) ; 
throw ex ; 
} 
} 
} 

public class Pattern { 
public List < String > groupNames ( ) { 
if ( groupNames == null ) groupNames = new ArrayList < String > ( groupInfo . keySet ( ) ) ; 
return groupNames ; 
} 
} 

public class Pattern { 
static private boolean isInsideCharClass ( String s , int pos ) { 
boolean openBracketFound = false ; 
boolean closeBracketFound = false ; 
String s2 = s . substring ( 0 , pos ) ; 
int posOpen = pos ; 
while ( ( posOpen = s2 . lastIndexOf ( '[' , posOpen - 1 ) ) != - 1 ) if ( ! isEscapedChar ( s2 , posOpen ) ) { 
openBracketFound = true ; 
break ; 
} 
if ( openBracketFound ) { 
String s3 = s . substring ( posOpen , pos ) ; 
int posClose = - 1 ; 
while ( ( posClose = s3 . indexOf ( ']' , posClose + 1 ) ) != - 1 ) if ( ! isEscapedChar ( s3 , posClose ) ) { 
closeBracketFound = true ; 
break ; 
} 
} 
return openBracketFound && ! closeBracketFound ; 
} 
} 

public class Pattern { 
static private int countOpenParens ( String s , int pos ) { 
java . util . regex . Pattern p = java . util . regex . Pattern . compile ( "\\(" ) ; 
java . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; 
int numParens = 0 ; 
while ( m . find ( ) ) { 
if ( isInsideCharClass ( s , m . start ( ) ) ) continue ; 
if ( isEscapedChar ( s , m . start ( ) ) ) continue ; 
if ( ! isNoncapturingParen ( s , m . start ( ) ) ) numParens ++ ; 
} 
return numParens ; 
} 
} 

public class Pattern { 
static public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { 
Map < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; 
java . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; 
while ( matcher . find ( ) ) { 
int pos = matcher . start ( ) ; 
if ( isEscapedChar ( namedPattern , pos ) ) continue ; 
String name = matcher . group ( INDEX_GROUP_NAME ) ; 
int groupIndex = countOpenParens ( namedPattern , pos ) ; 
List < GroupInfo > list ; 
if ( groupInfo . containsKey ( name ) ) list = groupInfo . get ( name ) ; 
else list = new ArrayList < GroupInfo > ( ) ; 
list . add ( new GroupInfo ( groupIndex , pos ) ) ; 
groupInfo . put ( name , list ) ; 
} 
return groupInfo ; 
} 
} 

public class Pattern { 
static private StringBuilder replace ( StringBuilder input , java . util . regex . Pattern pattern , String replacement ) { 
java . util . regex . Matcher m = pattern . matcher ( input ) ; 
while ( m . find ( ) ) { 
if ( isEscapedChar ( input . toString ( ) , m . start ( ) ) ) continue ; 
input . replace ( m . start ( ) , m . end ( ) , replacement ) ; 
m . reset ( input ) ; 
} 
return input ; 
} 
} 

public class JMXJsonServlet { 
@ Override public void doGet ( HttpServletRequest request , HttpServletResponse response ) { 
try { 
JsonGenerator jg = null ; 
String jsonpcb = null ; 
PrintWriter writer = null ; 
try { 
writer = response . getWriter ( ) ; 
jsonpcb = request . getParameter ( CALLBACK_PARAM ) ; 
if ( jsonpcb != null ) { 
response . setContentType ( "application/javascript; charset=utf8" ) ; 
writer . write ( jsonpcb + "(" ) ; 
} 
else response . setContentType ( "application/json; charset=utf8" ) ; 
jg = jsonFactory . createGenerator ( writer ) ; 
jg . disable ( JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ; 
jg . useDefaultPrettyPrinter ( ) ; 
jg . writeStartObject ( ) ; 
String getmethod = request . getParameter ( "get" ) ; 
if ( getmethod != null ) { 
String [ ] splitStrings = getmethod . split ( "\\:\\:" ) ; 
if ( splitStrings . length != 2 ) { 
jg . writeStringField ( "result" , "ERROR" ) ; 
jg . writeStringField ( "message" , "query format is not as expected." ) ; 
jg . flush ( ) ; 
response . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; 
return ; 
} 
listBeans ( jg , new ObjectName ( splitStrings [ 0 ] ) , splitStrings [ 1 ] , response ) ; 
return ; 
} 
String qry = request . getParameter ( "qry" ) ; 
if ( qry == null ) qry = "*:*" ; 
listBeans ( jg , new ObjectName ( qry ) , null , response ) ; 
} 
finally { 
if ( jg != null ) jg . close ( ) ; 
if ( jsonpcb != null ) writer . write ( ");" ) ; 
if ( writer != null ) writer . close ( ) ; 
} 
} 
catch ( IOException e ) { 
response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; 
} 
catch ( MalformedObjectNameException e ) { 
response . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; 
} 
} 
} 

public class OracleCDCSource { 
private boolean refreshSchema ( BigDecimal scnDecimal , SchemaAndTable schemaAndTable ) throws SQLException { 
try { 
if ( ! tableSchemaLastUpdate . containsKey ( schemaAndTable ) || scnDecimal . compareTo ( tableSchemaLastUpdate . get ( schemaAndTable ) ) > 0 ) { 
if ( containerized ) try ( Statement switchToPdb = connection . createStatement ( ) ) { 
switchToPdb . execute ( "ALTER SESSION SET CONTAINER = " + configBean . pdb ) ; 
} 
tableSchemas . put ( schemaAndTable , getTableSchema ( schemaAndTable ) ) ; 
tableSchemaLastUpdate . put ( schemaAndTable , scnDecimal ) ; 
return true ; 
} 
return false ; 
} 
finally { 
alterSession ( ) ; 
} 
} 
} 

public class MathEL { 
private static Object convertStringToAppropriateNumber ( String value ) { 
if ( value . contains ( "." ) ) return Double . valueOf ( value ) ; 
else return Long . valueOf ( value ) ; 
} 
} 

public class CollectdParser { 
private int parsePart ( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { 
int offset = startOffset ; 
int type = buf . getUnsignedShort ( offset ) ; 
offset += 2 ; 
final int length = buf . getUnsignedShort ( offset ) ; 
offset += 2 ; 
switch ( type ) { 
case HOST : case PLUGIN : case PLUGIN_INSTANCE : case TYPE : case TYPE_INSTANCE : case MESSAGE : pruneFields ( type ) ; 
fields . put ( PART_TYPES . get ( type ) , Field . create ( parseString ( offset , length , buf ) ) ) ; 
offset += length - 4 ; 
break ; 
case TIME_HIRES : case INTERVAL_HIRES : if ( type != INTERVAL_HIRES || ! excludeInterval ) { 
long value = parseNumeric ( offset , buf ) ; 
if ( convertTime ) { 
value *= ( Math . pow ( 2 , - 30 ) * 1000 ) ; 
type = type == TIME_HIRES ? TIME : INTERVAL ; 
} 
fields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; 
} 
offset += 8 ; 
break ; 
case TIME : case INTERVAL : case SEVERITY : if ( type != INTERVAL || ! excludeInterval ) fields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; 
offset += 8 ; 
break ; 
case VALUES : offset = parseValues ( offset , buf ) ; 
startNewRecord ( ) ; 
break ; 
case SIGNATURE : if ( ! verifySignature ( offset , length , buf ) ) throw new OnRecordErrorException ( Errors . COLLECTD_02 ) ; 
offset += length - 4 ; 
break ; 
case ENCRYPTION : String user = parseUser ( offset , buf ) ; 
offset += ( 2 + user . length ( ) ) ; 
byte [ ] iv = parseIv ( offset , buf ) ; 
offset += 16 ; 
decrypt ( offset , length , buf , user , iv ) ; 
offset += 20 ; 
break ; 
default : LOG . warn ( "Unrecognized part type: {}" , type ) ; 
offset += length - 4 ; 
break ; 
} 
return offset ; 
} 
} 

public class JdbcBaseRecordWriter { 
void lookupPrimaryKeys ( ) throws StageException { 
Connection connection = null ; 
try { 
connection = dataSource . getConnection ( ) ; 
primaryKeyColumns = jdbcUtil . getPrimaryKeys ( connection , schema , tableName ) ; 
} 
catch ( SQLException e ) { 
String formattedError = jdbcUtil . formatSqlException ( e ) ; 
LOG . error ( formattedError , e ) ; 
throw new StageException ( JdbcErrors . JDBC_17 , tableName , formattedError ) ; 
} 
finally { 
if ( connection != null ) try { 
connection . close ( ) ; 
} 
catch ( SQLException e ) { 
String formattedError = jdbcUtil . formatSqlException ( e ) ; 
LOG . error ( formattedError , e ) ; 
} 
} 
} 
} 

public class JdbcBaseRecordWriter { 
protected String getTableName ( ) { 
if ( ! Strings . isNullOrEmpty ( schema ) ) if ( caseSensitive ) return "\"" + schema + "\"." + "\"" + tableName + "\"" ; 
else return schema + "." + tableName ; 
if ( caseSensitive ) return "\"" + tableName + "\"" ; 
return tableName ; 
} 
} 

public class SampleExecutor { 
private void execute ( Record record ) throws OnRecordErrorException { 
if ( ! record . has ( "/someField" ) ) throw new OnRecordErrorException ( Errors . SAMPLE_01 , record , "exception detail message." ) ; 
} 
} 

public class JdbcMySqlBinLogRecordReader { 
@ Override public SortedMap < String , String > getColumnsToParameters ( final Record record , int op , Map < String , String > parameters , Map < String , String > columnsToFields ) { 
SortedMap < String , String > columnsToParameters = new TreeMap < > ( ) ; 
for ( Map . Entry < String , String > entry : columnsToFields . entrySet ( ) ) { 
String columnName = entry . getKey ( ) ; 
String fieldPath = entry . getValue ( ) ; 
if ( op == OperationType . DELETE_CODE ) fieldPath = fieldPath . replace ( DATA_FIELD , OLD_DATA_FIELD ) ; 
if ( record . has ( fieldPath ) ) columnsToParameters . put ( columnName , parameters . get ( columnName ) ) ; 
} 
return columnsToParameters ; 
} 
} 

public class OffsetQueryUtil { 
public static Map < String , String > validateStoredAndSpecifiedOffset ( TableContext tableContext , String offset ) throws StageException { 
Set < String > expectedColumns = Sets . newHashSet ( tableContext . getOffsetColumns ( ) ) ; 
final Map < String , String > actualOffsets = getColumnsToOffsetMapFromOffsetFormat ( offset ) ; 
if ( actualOffsets . size ( ) == 0 ) return actualOffsets ; 
Set < String > actualColumns = actualOffsets . keySet ( ) ; 
Set < String > expectedSetDifference = Sets . difference ( expectedColumns , actualColumns ) ; 
Set < String > actualSetDifference = Sets . difference ( actualColumns , expectedColumns ) ; 
if ( expectedSetDifference . size ( ) > 0 || actualSetDifference . size ( ) > 0 ) throw new StageException ( JdbcErrors . JDBC_71 , tableContext . getQualifiedName ( ) , COMMA_SPACE_JOINER . join ( actualColumns ) , COMMA_SPACE_JOINER . join ( expectedColumns ) ) ; 
return actualOffsets ; 
} 
} 

public class SupportBundleManager { 
private List < BundleContentGeneratorDefinition > getRequestedDefinitions ( List < String > generators ) { 
Stream < BundleContentGeneratorDefinition > stream = definitions . stream ( ) ; 
if ( generators == null || generators . isEmpty ( ) ) stream = stream . filter ( BundleContentGeneratorDefinition :: isEnabledByDefault ) ; 
else stream = stream . filter ( def -> generators . contains ( def . getId ( ) ) ) ; 
return stream . sorted ( Comparator . comparingInt ( BundleContentGeneratorDefinition :: getOrder ) ) . collect ( Collectors . toList ( ) ) ; 
} 
} 

public class YarnAppLauncher { 
private String [ ] getNonEmptyArgs ( List < String > appArgs ) { 
List < String > nonEmpty = new ArrayList < > ( ) ; 
appArgs . forEach ( ( String val ) -> { 
if ( ! StringUtils . isEmpty ( val ) ) nonEmpty . add ( val ) ; 
} 
) ; 
return nonEmpty . toArray ( new String [ nonEmpty . size ( ) ] ) ; 
} 
} 

public class LiveDirectoryScanner { 
public long getPendingFiles ( LiveFile current ) throws IOException { 
if ( current == null || rollMode . isCurrentAcceptable ( current . getPath ( ) . getFileName ( ) . toString ( ) ) ) return findToBeProcessedMatchingFiles ( current != null ? current . refresh ( ) : null ) . size ( ) ; 
return 0 ; 
} 
} 

public class CollisionWhitelist { 
public static boolean isWhitelisted ( String name , Properties specificWhitelist , Map < String , List < Dependency > > dependencies ) { 
if ( specificWhitelist != null && specificWhitelist . containsKey ( name ) ) return versionsMatch ( specificWhitelist . getProperty ( name ) , dependencies . keySet ( ) ) ; 
WhitelistRule rule = WHITELIST_RULES . get ( name ) ; 
return rule != null && rule . isWhitelisted ( dependencies ) ; 
} 
} 

public class BootstrapClusterStreaming { 
public static void main ( String [ ] args ) throws Exception { 
SparkStreamingBinding binding = null ; 
try { 
binding = SparkStreamingBindingFactory . build ( BootstrapCluster . getProperties ( ) ) ; 
binding . init ( ) ; 
BootstrapCluster . createTransformers ( binding . getStreamingContext ( ) . sparkContext ( ) , binding . getSparkSession ( ) ) ; 
binding . startContext ( ) ; 
binding . awaitTermination ( ) ; 
} 
catch ( Throwable error ) { 
String msg = "Error trying to invoke BootstrapClusterStreaming.main: " + error ; 
System . err . println ( new Date ( ) + ": " + msg ) ; 
error . printStackTrace ( System . err ) ; 
LOG . error ( msg , error ) ; 
throw new IllegalStateException ( msg , error ) ; 
} 
finally { 
try { 
if ( binding != null ) binding . close ( ) ; 
} 
catch ( Exception ex ) { 
LOG . warn ( "Error on binding close: " + ex , ex ) ; 
} 
} 
} 
} 

public class PipelineConfigurationValidator { 
private void propagateRuntimeConfiguration ( ) { 
if ( pipelineBean == null || pipelineBean . getPipelineStageBeans ( ) == null ) return ; 
for ( StageBean stageBean : pipelineBean . getPipelineStageBeans ( ) . getStages ( ) ) { 
for ( ServiceDependencyDefinition serviceDependency : stageBean . getDefinition ( ) . getServices ( ) ) { 
ServiceBean stageService = stageBean . getService ( serviceDependency . getService ( ) ) ; 
if ( stageService == null ) continue ; 
ServiceConfiguration serviceConfiguration = stageService . getConf ( ) ; 
List < Config > configs = serviceConfiguration . getConfiguration ( ) ; 
configs . removeAll ( serviceDependency . getConfiguration ( ) . keySet ( ) . stream ( ) . map ( serviceConfiguration :: getConfig ) . collect ( Collectors . toList ( ) ) ) ; 
serviceDependency . getConfiguration ( ) . forEach ( ( key , value ) -> configs . add ( new Config ( key , value ) ) ) ; 
serviceConfiguration . setConfig ( configs ) ; 
} 
} 
} 
} 

public class OmnitureSource { 
private void validateReportDescription ( List < ConfigIssue > issues ) { 
if ( ! jsonMapper . isValidJson ( this . reportDescription ) ) issues . add ( getContext ( ) . createConfigIssue ( Groups . REPORT . name ( ) , "reportDescription" , Errors . OMNITURE_03 ) ) ; 
} 
} 

public class JdbcRecordReaderWriterFactory { 
public static JdbcRecordWriter createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , DuplicateKeyAction duplicateKeyAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { 
if ( defaultOpCode == OperationType . LOAD_CODE ) return new JdbcLoadRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , duplicateKeyAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; 
else return createJdbcRecordWriter ( connectionString , dataSource , schema , tableName , customMappings , null , rollbackOnError , useMultiRowOp , maxPrepStmtParameters , defaultOpCode , unsupportedAction , recordReader , caseSensitive , customDataSqlStateCodes ) ; 
} 
} 

public class JdbcRecordReaderWriterFactory { 
public static JdbcRecordWriter createJdbcRecordWriter ( String connectionString , HikariDataSource dataSource , String schema , String tableName , List < JdbcFieldColumnParamMapping > customMappings , List < JdbcFieldColumnMapping > generatedColumnMappings , boolean rollbackOnError , boolean useMultiRowOp , int maxPrepStmtParameters , int defaultOpCode , UnsupportedOperationAction unsupportedAction , JdbcRecordReader recordReader , boolean caseSensitive , List < String > customDataSqlStateCodes ) throws StageException { 
JdbcRecordWriter recordWriter ; 
if ( useMultiRowOp ) recordWriter = new JdbcMultiRowRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , maxPrepStmtParameters , defaultOpCode , unsupportedAction , generatedColumnMappings , recordReader , caseSensitive , customDataSqlStateCodes ) ; 
else recordWriter = new JdbcGenericRecordWriter ( connectionString , dataSource , schema , tableName , rollbackOnError , customMappings , defaultOpCode , unsupportedAction , generatedColumnMappings , recordReader , caseSensitive , customDataSqlStateCodes ) ; 
return recordWriter ; 
} 
} 

public class Grok { 
public Map < String , String > extractNamedGroups ( final CharSequence rawData ) { 
Matcher matcher = compiledPattern . matcher ( rawData ) ; 
if ( matcher . find ( ) ) { 
MatchResult r = matcher . toMatchResult ( ) ; 
if ( r != null && r . namedGroups ( ) != null ) return r . namedGroups ( ) ; 
} 
return null ; 
} 
} 

public class ControlChannel { 
public void consumerCommit ( String offset ) { 
Object offsetValue = offset ; 
if ( offsetValue == null ) offsetValue = new NullOffset ( ) ; 
LOG . trace ( "Commit Offset: '{}'" , offsetValue ) ; 
try { 
producerQueue . put ( new Message ( MessageType . CONSUMER_COMMIT , offsetValue ) ) ; 
} 
catch ( InterruptedException e ) { 
LOG . info ( "Interrupted while queuing '{}'" , MessageType . CONSUMER_COMMIT . name ( ) , offsetValue ) ; 
Thread . currentThread ( ) . interrupt ( ) ; 
} 
} 
} 

public class EmbeddedSDCPool { 
@ SuppressWarnings ( "unchecked" ) protected EmbeddedSDC create ( ) throws Exception { 
Utils . checkState ( open , "Not open" ) ; 
final EmbeddedSDC embeddedSDC = new EmbeddedSDC ( ) ; 
Object source ; 
Object pipelineStartResult = BootstrapCluster . startPipeline ( ( ) -> LOG . debug ( "Batch completed" ) ) ; 
source = pipelineStartResult . getClass ( ) . getDeclaredField ( "source" ) . get ( pipelineStartResult ) ; 
if ( source instanceof DSource ) { 
long startTime = System . currentTimeMillis ( ) ; 
long endTime = startTime ; 
long diff = 0 ; 
Source actualSource = ( ( DSource ) source ) . getSource ( ) ; 
while ( actualSource == null && diff < 60000 ) { 
Thread . sleep ( 100 ) ; 
actualSource = ( ( DSource ) source ) . getSource ( ) ; 
endTime = System . currentTimeMillis ( ) ; 
diff = endTime - startTime ; 
} 
if ( actualSource == null ) throw new IllegalStateException ( "Actual source is null, pipeline may not have been initialized" ) ; 
source = actualSource ; 
} 
if ( ! ( source instanceof ClusterSource ) ) throw new IllegalArgumentException ( "Source is not of type ClusterSource: " + source . getClass ( ) . getName ( ) ) ; 
embeddedSDC . setSource ( ( ClusterSource ) source ) ; 
embeddedSDC . setSparkProcessors ( ( List < Object > ) pipelineStartResult . getClass ( ) . getDeclaredField ( "sparkProcessors" ) . get ( pipelineStartResult ) ) ; 
return embeddedSDC ; 
} 
} 

public class RemoteDataCollector { 
@ Override public List < PipelineAndValidationStatus > getRemotePipelinesWithChanges ( ) throws PipelineException { 
List < PipelineAndValidationStatus > pipelineAndValidationStatuses = new ArrayList < > ( ) ; 
for ( Pair < PipelineState , Map < String , String > > pipelineStateAndOffset : stateEventListener . getPipelineStateEvents ( ) ) { 
PipelineState pipelineState = pipelineStateAndOffset . getLeft ( ) ; 
Map < String , String > offset = pipelineStateAndOffset . getRight ( ) ; 
String name = pipelineState . getPipelineId ( ) ; 
String rev = pipelineState . getRev ( ) ; 
boolean isClusterMode = ( pipelineState . getExecutionMode ( ) != ExecutionMode . STANDALONE ) ? true : false ; 
List < WorkerInfo > workerInfos = new ArrayList < > ( ) ; 
String title ; 
int runnerCount = 0 ; 
if ( pipelineStore . hasPipeline ( name ) ) { 
title = pipelineStore . getInfo ( name ) . getTitle ( ) ; 
Runner runner = manager . getRunner ( name , rev ) ; 
if ( isClusterMode ) workerInfos = getWorkers ( runner . getSlaveCallbackList ( CallbackObjectType . METRICS ) ) ; 
runnerCount = runner . getRunnerCount ( ) ; 
} 
else title = null ; 
pipelineAndValidationStatuses . add ( new PipelineAndValidationStatus ( getSchGeneratedPipelineName ( name , rev ) , title , rev , pipelineState . getTimeStamp ( ) , true , pipelineState . getStatus ( ) , pipelineState . getMessage ( ) , workerInfos , isClusterMode , getSourceOffset ( name , offset ) , null , runnerCount ) ) ; 
} 
return pipelineAndValidationStatuses ; 
} 
} 

public class JdbcMongoDBOplogRecordReader { 
@ Override public SortedMap < String , String > getColumnsToParameters ( final Record record , int op , Map < String , String > parameters , Map < String , String > columnsToFields ) { 
SortedMap < String , String > columnsToParameters = new TreeMap < > ( ) ; 
for ( Map . Entry < String , String > entry : columnsToFields . entrySet ( ) ) { 
String columnName = entry . getKey ( ) ; 
String fieldPath = getFieldPath ( columnName , columnsToFields , op ) ; 
if ( record . has ( fieldPath ) ) columnsToParameters . put ( columnName , parameters . get ( columnName ) ) ; 
else LOG . trace ( "Record is missing a field for column {} for the operation code {}" , columnName , op ) ; 
} 
return columnsToParameters ; 
} 
} 

public class FieldEncrypter { 
public Optional < Field > checkInputEncrypt ( Field field ) throws StageException { 
if ( UNSUPPORTED_TYPES . contains ( field . getType ( ) ) ) throw new StageException ( CRYPTO_03 , field . getType ( ) ) ; 
return Optional . of ( field ) ; 
} 
} 

public class FieldEncrypter { 
public Optional < Field > checkInputDecrypt ( Field field ) throws StageException { 
if ( field . getType ( ) != Field . Type . BYTE_ARRAY ) throw new StageException ( CRYPTO_02 , field . getType ( ) ) ; 
return Optional . of ( field ) ; 
} 
} 

public class FieldEncrypter { 
public byte [ ] prepareEncrypt ( Field field , Map < String , String > context ) { 
context . put ( SDC_FIELD_TYPE , field . getType ( ) . name ( ) ) ; 
if ( field . getType ( ) == Field . Type . BYTE_ARRAY ) return field . getValueAsByteArray ( ) ; 
else return field . getValueAsString ( ) . getBytes ( Charsets . UTF_8 ) ; 
} 
} 

public class Matcher { 
public Matcher usePattern ( Pattern newPattern ) { 
if ( newPattern == null ) throw new IllegalArgumentException ( "newPattern cannot be null" ) ; 
this . parentPattern = newPattern ; 
matcher . usePattern ( newPattern . pattern ( ) ) ; 
return this ; 
} 
} 

public class Matcher { 
@ Override public Map < String , String > namedGroups ( ) { 
Map < String , String > result = new LinkedHashMap < String , String > ( ) ; 
if ( matcher . find ( 0 ) ) for ( String groupName : parentPattern . groupNames ( ) ) { 
String groupValue = matcher . group ( groupIndex ( groupName ) ) ; 
result . put ( groupName , groupValue ) ; 
} 
return result ; 
} 
} 

public class DataFormatUpgradeHelper { 
public static void ensureAvroSchemaExists ( List < Config > configs , String prefix ) { 
Optional < Config > avroSchema = findByName ( configs , "avroSchema" ) ; 
if ( ! avroSchema . isPresent ( ) ) configs . add ( new Config ( prefix + ".avroSchema" , null ) ) ; 
} 
} 

public class Util { 
public static String getGlobalVariable ( DataSource dataSource , String variable ) throws SQLException { 
try ( Connection conn = dataSource . getConnection ( ) ) { 
try ( Statement stmt = conn . createStatement ( ) ; 
ResultSet rs = stmt . executeQuery ( String . format ( "show global variables like '%s'" , variable ) ) ; 
) { 
if ( rs . next ( ) ) return rs . getString ( 2 ) ; 
else return "" ; 
} 
} 
} 
} 

public class Pipeline { 
private Record createStartEvent ( ) { 
Preconditions . checkState ( startEventStage != null , "Start Event Stage is not set!" ) ; 
EventRecord eventRecord = new EventRecordImpl ( "pipeline-start" , 1 , startEventStage . getInfo ( ) . getInstanceName ( ) , "" , null , null ) ; 
Map < String , Field > rootField = new LinkedHashMap < > ( ) ; 
rootField . put ( "user" , Field . create ( Field . Type . STRING , userContext . getUser ( ) ) ) ; 
rootField . put ( "pipelineId" , Field . create ( Field . Type . STRING , name ) ) ; 
rootField . put ( "pipelineTitle" , Field . create ( Field . Type . STRING , pipelineConf . getTitle ( ) ) ) ; 
Map < String , Field > parameters = new LinkedHashMap < > ( ) ; 
if ( runtimeParameters != null ) for ( Map . Entry < String , Object > entry : runtimeParameters . entrySet ( ) ) { 
parameters . put ( entry . getKey ( ) , Field . create ( Field . Type . STRING , entry . getValue ( ) . toString ( ) ) ) ; 
} 
rootField . put ( "parameters" , Field . create ( parameters ) ) ; 
eventRecord . set ( Field . create ( rootField ) ) ; 
return eventRecord ; 
} 
} 

public class SobjectRecordCreator { 
protected String fixOffset ( String offsetColumn , String offset ) { 
com . sforce . soap . partner . Field sfdcField = getFieldMetadata ( sobjectType , offsetColumn ) ; 
if ( SobjectRecordCreator . DECIMAL_TYPES . contains ( sfdcField . getType ( ) . toString ( ) ) && offset . contains ( "E" ) ) { 
BigDecimal val = new BigDecimal ( offset ) ; 
offset = val . toPlainString ( ) ; 
if ( val . compareTo ( MAX_OFFSET_INT ) > 0 && ! offset . contains ( "." ) ) offset += ".0" ; 
} 
return offset ; 
} 
} 

public class ConfigValueExtractor { 
private Object extractAsRuntime ( Field field , String valueStr ) { 
if ( field . getType ( ) == Byte . TYPE || field . getType ( ) == Byte . class || field . getType ( ) == Short . TYPE || field . getType ( ) == Short . class || field . getType ( ) == Integer . TYPE || field . getType ( ) == Integer . class || field . getType ( ) == Long . TYPE || field . getType ( ) == Long . class || field . getType ( ) == Float . TYPE || field . getType ( ) == Float . class || field . getType ( ) == Double . TYPE || field . getType ( ) == Double . class ) return extractAsNumber ( field , valueStr ) ; 
else if ( String . class . isAssignableFrom ( field . getType ( ) ) ) return valueStr ; 
throw new IllegalArgumentException ( Utils . format ( "Invalid type for RUNTIME type: {}" , field . getType ( ) ) ) ; 
} 
} 

public class HiveQueryExecutor { 
public String executeDescribeDatabase ( String dbName ) throws StageException { 
String sql = buildDescribeDatabase ( dbName ) ; 
return executeQuery ( sql , rs -> { 
if ( ! rs . next ( ) ) throw new HiveStageCheckedException ( Errors . HIVE_35 , "Database doesn't exists." ) ; 
return HiveMetastoreUtil . stripHdfsHostAndPort ( rs . getString ( RESULT_SET_LOCATION ) ) ; 
} 
) ; 
} 
} 

public class PipeRunner { 
public void executeBatch ( String offsetKey , String offsetValue , long batchStartTime , ThrowingConsumer < Pipe > consumer ) throws PipelineRuntimeException , StageException { 
MDC . put ( LogConstants . RUNNER , String . valueOf ( runnerId ) ) ; 
this . runtimeMetricGauge . put ( METRIC_BATCH_START_TIME , batchStartTime ) ; 
this . runtimeMetricGauge . put ( METRIC_OFFSET_KEY , Optional . ofNullable ( offsetKey ) . orElse ( "" ) ) ; 
this . runtimeMetricGauge . put ( METRIC_OFFSET_VALUE , Optional . ofNullable ( offsetValue ) . orElse ( "" ) ) ; 
this . runtimeMetricGauge . put ( METRIC_STAGE_START_TIME , System . currentTimeMillis ( ) ) ; 
try { 
for ( Pipe p : pipes ) { 
String instanceName = p . getStage ( ) . getInfo ( ) . getInstanceName ( ) ; 
this . runtimeMetricGauge . put ( METRIC_CURRENT_STAGE , instanceName ) ; 
MDC . put ( LogConstants . STAGE , instanceName ) ; 
if ( p instanceof StagePipe ) this . runtimeMetricGauge . put ( METRIC_STAGE_START_TIME , System . currentTimeMillis ( ) ) ; 
acceptConsumer ( consumer , p ) ; 
} 
this . runtimeMetricGauge . computeIfPresent ( METRIC_BATCH_COUNT , ( key , value ) -> ( ( long ) value ) + 1 ) ; 
} 
finally { 
resetBatchSpecificMetrics ( ) ; 
MDC . put ( LogConstants . RUNNER , "" ) ; 
MDC . put ( LogConstants . STAGE , "" ) ; 
} 
} 
} 

public class PipeRunner { 
public OffsetCommitTrigger getOffsetCommitTrigger ( ) { 
for ( Pipe pipe : pipes ) { 
Stage stage = pipe . getStage ( ) . getStage ( ) ; 
if ( stage instanceof Target && stage instanceof OffsetCommitTrigger ) return ( OffsetCommitTrigger ) stage ; 
} 
return null ; 
} 
} 

public class PipeRunner { 
public boolean onRecordErrorStopPipeline ( ) { 
for ( Pipe pipe : pipes ) { 
StageContext stageContext = pipe . getStage ( ) . getContext ( ) ; 
if ( stageContext . getOnErrorRecord ( ) == OnRecordError . STOP_PIPELINE ) return true ; 
} 
return false ; 
} 
} 

public class BigQueryTarget { 
private String getInsertIdForRecord ( ELVars elVars , Record record ) throws OnRecordErrorException { 
String recordId = null ; 
RecordEL . setRecordInContext ( elVars , record ) ; 
try { 
if ( ! ( StringUtils . isEmpty ( conf . rowIdExpression ) ) ) { 
recordId = rowIdELEval . eval ( elVars , conf . rowIdExpression , String . class ) ; 
if ( StringUtils . isEmpty ( recordId ) ) throw new OnRecordErrorException ( record , Errors . BIGQUERY_15 ) ; 
} 
} 
catch ( ELEvalException e ) { 
LOG . error ( "Error evaluating Row Expression EL" , e ) ; 
throw new OnRecordErrorException ( record , Errors . BIGQUERY_10 , e ) ; 
} 
return recordId ; 
} 
} 

public class CouchbaseProcessor { 
private Observable < Record > setFragmentInRecord ( Record record , DocumentFragment < Lookup > frag ) { 
if ( frag . content ( 0 ) == null ) { 
LOG . debug ( "Sub-document path not found" ) ; 
return handleError ( record , Errors . COUCHBASE_25 , true ) ; 
} 
for ( SubdocMappingConfig subdocMapping : config . subdocMappingConfigs ) { 
Object fragJson = frag . content ( subdocMapping . subdocPath ) ; 
if ( fragJson == null ) return handleError ( record , Errors . COUCHBASE_25 , true ) ; 
try { 
record . set ( subdocMapping . sdcField , jsonToField ( fragJson ) ) ; 
record . getHeader ( ) . setAttribute ( config . CAS_HEADER_ATTRIBUTE , String . valueOf ( frag . cas ( ) ) ) ; 
} 
catch ( IOException e ) { 
try { 
record . set ( subdocMapping . sdcField , jsonToField ( JsonObject . fromJson ( fragJson . toString ( ) ) . toMap ( ) ) ) ; 
record . getHeader ( ) . setAttribute ( config . CAS_HEADER_ATTRIBUTE , String . valueOf ( frag . cas ( ) ) ) ; 
} 
catch ( IOException ex ) { 
return handleError ( record , Errors . COUCHBASE_19 , ex , false ) ; 
} 
} 
} 
return Observable . just ( record ) ; 
} 
} 

public class AmazonS3Runnable { 
private void handleWholeFileDataFormat ( S3ObjectSummary s3ObjectSummary , String recordId ) throws StageException { 
S3Object partialS3ObjectForMetadata ; 
partialS3ObjectForMetadata = AmazonS3Util . getObjectRange ( s3Client , s3ConfigBean . s3Config . bucket , s3ObjectSummary . getKey ( ) , 1 , s3ConfigBean . sseConfig . useCustomerSSEKey , s3ConfigBean . sseConfig . customerKey , s3ConfigBean . sseConfig . customerKeyMd5 ) ; 
S3FileRef . Builder s3FileRefBuilder = new S3FileRef . Builder ( ) . s3Client ( s3Client ) . s3ObjectSummary ( s3ObjectSummary ) . useSSE ( s3ConfigBean . sseConfig . useCustomerSSEKey ) . customerKey ( s3ConfigBean . sseConfig . customerKey ) . customerKeyMd5 ( s3ConfigBean . sseConfig . customerKeyMd5 ) . bufferSize ( ( int ) dataParser . suggestedWholeFileBufferSize ( ) ) . createMetrics ( true ) . totalSizeInBytes ( s3ObjectSummary . getSize ( ) ) . rateLimit ( dataParser . wholeFileRateLimit ( ) ) ; 
if ( dataParser . isWholeFileChecksumRequired ( ) ) s3FileRefBuilder . verifyChecksum ( true ) . checksumAlgorithm ( HashingUtil . HashType . MD5 ) . checksum ( partialS3ObjectForMetadata . getObjectMetadata ( ) . getETag ( ) ) ; 
Map < String , Object > metadata = AmazonS3Util . getMetaData ( partialS3ObjectForMetadata ) ; 
metadata . put ( S3Constants . BUCKET , s3ObjectSummary . getBucketName ( ) ) ; 
metadata . put ( S3Constants . OBJECT_KEY , s3ObjectSummary . getKey ( ) ) ; 
metadata . put ( S3Constants . OWNER , s3ObjectSummary . getOwner ( ) ) ; 
metadata . put ( S3Constants . SIZE , s3ObjectSummary . getSize ( ) ) ; 
metadata . put ( HeaderAttributeConstants . FILE_NAME , s3ObjectSummary . getKey ( ) ) ; 
metadata . remove ( S3Constants . CONTENT_LENGTH ) ; 
parser = dataParser . getParser ( recordId , metadata , s3FileRefBuilder . build ( ) ) ; 
object = partialS3ObjectForMetadata ; 
} 
} 

public class SecurityContext { 
public synchronized void logout ( ) { 
if ( subject != null ) { 
LOG . debug ( "Logout. Kerberos enabled '{}', Principal '{}'" , securityConfiguration . isKerberosEnabled ( ) , subject . getPrincipals ( ) ) ; 
if ( loginContext != null ) try { 
loginContext . logout ( ) ; 
} 
catch ( LoginException ex ) { 
LOG . warn ( "Error while doing logout from Kerberos: {}" , ex . toString ( ) , ex ) ; 
} 
finally { 
loginContext = null ; 
} 
subject = null ; 
} 
} 
} 

public class SdcSecurityManager { 
private void ensureProperPermissions ( String path ) { 
ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
if ( cl instanceof ContainerClassLoader ) return ; 
if ( exceptions . contains ( path ) ) return ; 
if ( cl instanceof SDCClassLoader ) { 
String libraryName = ( ( SDCClassLoader ) cl ) . getName ( ) ; 
if ( stageLibExceptions . containsKey ( libraryName ) && stageLibExceptions . get ( libraryName ) . contains ( path ) ) return ; 
} 
throw new SecurityException ( Utils . format ( "Classloader {} is not allowed access to Data Collector internal directories ({})." , cl . toString ( ) , path ) ) ; 
} 
} 

public class BootstrapEmrBatch { 
public static void main ( String [ ] args ) throws Exception { 
EmrBinding binding = null ; 
try { 
binding = new EmrBinding ( args ) ; 
binding . init ( ) ; 
binding . awaitTermination ( ) ; 
} 
catch ( Exception ex ) { 
String msg = "Error trying to invoke BootstrapEmrBatch.main: " + ex ; 
throw new IllegalStateException ( msg , ex ) ; 
} 
finally { 
try { 
if ( binding != null ) binding . close ( ) ; 
} 
catch ( Exception ex ) { 
LOG . warn ( "Error on binding close: " + ex , ex ) ; 
} 
} 
} 
} 

public class RecordWriterManager { 
String getDirPath ( Date date , Record record ) throws StageException { 
if ( dirPathTemplateInHeader ) return record . getHeader ( ) . getAttribute ( HdfsTarget . TARGET_DIRECTORY_HEADER ) ; 
return pathResolver . resolvePath ( date , record ) ; 
} 
} 

public class StageLibraryDelegateCreator { 
public < R > R createAndInitialize ( StageLibraryTask stageLib , Configuration configuration , String stageLibraryName , Class < R > exportedInterface ) { 
StageLibraryDelegate instance = create ( stageLib , stageLibraryName , exportedInterface ) ; 
if ( instance == null ) return null ; 
StageLibraryDelegateContext context = new StageLibraryDelegateContext ( configuration ) ; 
instance . setContext ( context ) ; 
return ( R ) new StageLibraryDelegateRuntime ( instance . getClass ( ) . getClassLoader ( ) , instance ) ; 
} 
} 

public class StageLibraryDelegateCreator { 
public StageLibraryDelegate create ( StageLibraryTask stageLib , String stageLibraryName , Class exportedInterface ) { 
StageLibraryDelegateDefinitition def = stageLib . getStageLibraryDelegateDefinition ( stageLibraryName , exportedInterface ) ; 
if ( def == null ) return null ; 
return createInstance ( def ) ; 
} 
} 

public class MetricRuleEvaluatorHelper { 
public static Object getMetricValue ( MetricRegistry metrics , String metricId , MetricType metricType , MetricElement metricElement ) throws ObserverException { 
if ( metricElement . isOneOf ( MetricElement . CURRENT_BATCH_AGE , MetricElement . TIME_IN_CURRENT_STAGE ) ) switch ( metricElement ) { 
case CURRENT_BATCH_AGE : return getTimeFromRunner ( metrics , PipeRunner . METRIC_BATCH_START_TIME ) ; 
case TIME_IN_CURRENT_STAGE : return getTimeFromRunner ( metrics , PipeRunner . METRIC_STAGE_START_TIME ) ; 
default : throw new IllegalStateException ( Utils . format ( "Unknown metric type '{}'" , metricType ) ) ; 
} 
Metric metric = getMetric ( metrics , metricId , metricType ) ; 
if ( metric != null ) return getMetricValue ( metricElement , metricType , metric ) ; 
return null ; 
} 
} 

public class HTTPSession { 
private int findHeaderEnd ( final byte [ ] buf , int rlen ) { 
int splitbyte = 0 ; 
while ( splitbyte + 1 < rlen ) { 
if ( buf [ splitbyte ] == '\r' && buf [ splitbyte + 1 ] == '\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\r' && buf [ splitbyte + 3 ] == '\n' ) return splitbyte + 4 ; 
if ( buf [ splitbyte ] == '\n' && buf [ splitbyte + 1 ] == '\n' ) return splitbyte + 2 ; 
splitbyte ++ ; 
} 
return 0 ; 
} 
} 

public class HTTPSession { 
public long getBodySize ( ) { 
if ( this . headers . containsKey ( "content-length" ) ) return Long . parseLong ( this . headers . get ( "content-length" ) ) ; 
else if ( this . splitbyte < this . rlen ) return this . rlen - this . splitbyte ; 
return 0 ; 
} 
} 

public class NanoHTTPD { 
public static SSLServerSocketFactory makeSSLSocketFactory ( String keyAndTrustStoreClasspathPath , char [ ] passphrase ) throws IOException { 
try { 
KeyStore keystore = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; 
InputStream keystoreStream = NanoHTTPD . class . getResourceAsStream ( keyAndTrustStoreClasspathPath ) ; 
if ( keystoreStream == null ) throw new IOException ( "Unable to load keystore from classpath: " + keyAndTrustStoreClasspathPath ) ; 
keystore . load ( keystoreStream , passphrase ) ; 
KeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; 
keyManagerFactory . init ( keystore , passphrase ) ; 
return makeSSLSocketFactory ( keystore , keyManagerFactory ) ; 
} 
catch ( Exception e ) { 
throw new IOException ( e . getMessage ( ) ) ; 
} 
} 
} 

public class NanoHTTPD { 
public static String getMimeTypeForFile ( String uri ) { 
int dot = uri . lastIndexOf ( '.' ) ; 
String mime = null ; 
if ( dot >= 0 ) mime = mimeTypes ( ) . get ( uri . substring ( dot + 1 ) . toLowerCase ( ) ) ; 
return mime == null ? "application/octet-stream" : mime ; 
} 
} 

public class NanoHTTPD { 
public void stop ( ) { 
try { 
safeClose ( this . myServerSocket ) ; 
this . asyncRunner . closeAll ( ) ; 
if ( this . myThread != null ) this . myThread . join ( ) ; 
} 
catch ( Exception e ) { 
NanoHTTPD . LOG . log ( Level . SEVERE , "Could not stop all connections" , e ) ; 
} 
} 
} 

public class Response { 
public void send ( OutputStream outputStream ) { 
SimpleDateFormat gmtFrmt = new SimpleDateFormat ( "E, d MMM yyyy HH:mm:ss 'GMT'" , Locale . US ) ; 
gmtFrmt . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; 
try { 
if ( this . status == null ) throw new Error ( "sendResponse(): Status can't be null." ) ; 
PrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( outputStream , new ContentType ( this . mimeType ) . getEncoding ( ) ) ) , false ) ; 
pw . append ( "HTTP/1.1 " ) . append ( this . status . getDescription ( ) ) . append ( " \r\n" ) ; 
if ( this . mimeType != null ) printHeader ( pw , "Content-Type" , this . mimeType ) ; 
if ( getHeader ( "date" ) == null ) printHeader ( pw , "Date" , gmtFrmt . format ( new Date ( ) ) ) ; 
for ( Entry < String , String > entry : this . header . entrySet ( ) ) { 
printHeader ( pw , entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
for ( String cookieHeader : this . cookieHeaders ) { 
printHeader ( pw , "Set-Cookie" , cookieHeader ) ; 
} 
if ( getHeader ( "connection" ) == null ) printHeader ( pw , "Connection" , ( this . keepAlive ? "keep-alive" : "close" ) ) ; 
if ( getHeader ( "content-length" ) != null ) setUseGzip ( false ) ; 
if ( useGzipWhenAccepted ( ) ) { 
printHeader ( pw , "Content-Encoding" , "gzip" ) ; 
setChunkedTransfer ( true ) ; 
} 
long pending = this . data != null ? this . contentLength : 0 ; 
if ( this . requestMethod != Method . HEAD && this . chunkedTransfer ) printHeader ( pw , "Transfer-Encoding" , "chunked" ) ; 
else if ( ! useGzipWhenAccepted ( ) ) pending = sendContentLengthHeaderIfNotAlreadyPresent ( pw , pending ) ; 
pw . append ( "\r\n" ) ; 
pw . flush ( ) ; 
sendBodyWithCorrectTransferAndEncoding ( outputStream , pending ) ; 
outputStream . flush ( ) ; 
NanoHTTPD . safeClose ( this . data ) ; 
} 
catch ( IOException ioe ) { 
NanoHTTPD . LOG . log ( Level . SEVERE , "Could not send response to the client" , ioe ) ; 
} 
} 
} 

public class Response { 
private void sendBody ( OutputStream outputStream , long pending ) throws IOException { 
long BUFFER_SIZE = 16 * 1024 ; 
byte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; 
boolean sendEverything = pending == - 1 ; 
while ( pending > 0 || sendEverything ) { 
long bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; 
int read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; 
if ( read <= 0 ) break ; 
try { 
outputStream . write ( buff , 0 , read ) ; 
} 
catch ( Exception e ) { 
if ( this . data != null ) this . data . close ( ) ; 
} 
if ( ! sendEverything ) pending -= read ; 
} 
} 
} 

public class SpringSessionBackedSessionRegistry { 
protected String name ( Object principal ) { 
if ( principal instanceof UserDetails ) return ( ( UserDetails ) principal ) . getUsername ( ) ; 
if ( principal instanceof Principal ) return ( ( Principal ) principal ) . getName ( ) ; 
return principal . toString ( ) ; 
} 
} 

public class AbstractHttpSessionApplicationInitializer { 
private void insertSessionRepositoryFilter ( ServletContext servletContext ) { 
String filterName = DEFAULT_FILTER_NAME ; 
DelegatingFilterProxy springSessionRepositoryFilter = new DelegatingFilterProxy ( filterName ) ; 
String contextAttribute = getWebApplicationContextAttribute ( ) ; 
if ( contextAttribute != null ) springSessionRepositoryFilter . setContextAttribute ( contextAttribute ) ; 
registerFilter ( servletContext , true , filterName , springSessionRepositoryFilter ) ; 
} 
} 

public class SpringSessionBackedSessionInformation { 
private static String resolvePrincipal ( Session session ) { 
String principalName = session . getAttribute ( FindByIndexNameSessionRepository . PRINCIPAL_NAME_INDEX_NAME ) ; 
if ( principalName != null ) return principalName ; 
SecurityContext securityContext = session . getAttribute ( SPRING_SECURITY_CONTEXT ) ; 
if ( securityContext != null && securityContext . getAuthentication ( ) != null ) return securityContext . getAuthentication ( ) . getName ( ) ; 
return "" ; 
} 
} 

public class RedisOperationsSessionRepository { 
private RedisSession getSession ( String id , boolean allowExpired ) { 
Map < Object , Object > entries = getSessionBoundHashOperations ( id ) . entries ( ) ; 
if ( entries . isEmpty ( ) ) return null ; 
MapSession loaded = loadSession ( id , entries ) ; 
if ( ! allowExpired && loaded . isExpired ( ) ) return null ; 
RedisSession result = new RedisSession ( loaded ) ; 
result . originalLastAccessTime = loaded . getLastAccessedTime ( ) ; 
return result ; 
} 
} 

public class MethodInfoHelper { 
public static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { 
Class < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; 
if ( parameterTypes == null ) return NO_STRINGS ; 
String [ ] canonicalNames = new String [ parameterTypes . length ] ; 
for ( int i = 0 ; 
i < parameterTypes . length ; 
i ++ ) canonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; 
return canonicalNames ; 
} 
} 

public class JCAOrderedLastSynchronizationList { 
public void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { 
int status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; 
switch ( status ) { 
case javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; 
case Status . STATUS_MARKED_ROLLBACK : return ; 
default : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; 
} 
if ( synchronization . getClass ( ) . getName ( ) . startsWith ( "org.jboss.jca" ) ) { 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: " + synchronization . getClass ( ) + " HashCode: " + synchronization . hashCode ( ) + " toString: " + synchronization ) ; 
jcaSyncs . add ( synchronization ) ; 
} 
else { 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: " + synchronization . getClass ( ) + " HashCode: " + synchronization . hashCode ( ) + " toString: " + synchronization ) ; 
preJcaSyncs . add ( synchronization ) ; 
} 
} 
} 

public class JCAOrderedLastSynchronizationList { 
@ Override public void beforeCompletion ( ) { 
int lastIndexProcessed = 0 ; 
while ( ( lastIndexProcessed < preJcaSyncs . size ( ) ) ) { 
Synchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: " + preJcaSync . getClass ( ) + " HashCode: " + preJcaSync . hashCode ( ) + " toString: " + preJcaSync ) ; 
preJcaSync . beforeCompletion ( ) ; 
lastIndexProcessed = lastIndexProcessed + 1 ; 
} 
lastIndexProcessed = 0 ; 
while ( ( lastIndexProcessed < jcaSyncs . size ( ) ) ) { 
Synchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: " + jcaSync . getClass ( ) + " HashCode: " + jcaSync . hashCode ( ) + " toString: " + jcaSync ) ; 
jcaSync . beforeCompletion ( ) ; 
lastIndexProcessed = lastIndexProcessed + 1 ; 
} 
} 
} 

public class TxServerInterceptor { 
public static Transaction getCurrentTransaction ( ) { 
Transaction tx = null ; 
if ( piCurrent != null ) try { 
Any any = piCurrent . get_slot ( slotId ) ; 
if ( any . type ( ) . kind ( ) . value ( ) != TCKind . _tk_null ) tx = ForeignTransaction . INSTANCE ; 
} 
catch ( InvalidSlot e ) { 
throw IIOPLogger . ROOT_LOGGER . errorGettingSlotInTxInterceptor ( e ) ; 
} 
return tx ; 
} 
} 

public class WSSubsystemAdd { 
private static List < ServiceName > getServerConfigDependencies ( OperationContext context , boolean appclient ) { 
final List < ServiceName > serviceNames = new ArrayList < ServiceName > ( ) ; 
final Resource subsystemResource = context . readResourceFromRoot ( PathAddress . pathAddress ( WSExtension . SUBSYSTEM_PATH ) , false ) ; 
readConfigServiceNames ( serviceNames , subsystemResource , Constants . CLIENT_CONFIG ) ; 
readConfigServiceNames ( serviceNames , subsystemResource , Constants . ENDPOINT_CONFIG ) ; 
if ( ! appclient ) serviceNames . add ( CommonWebServer . SERVICE_NAME ) ; 
return serviceNames ; 
} 
} 

public class CalendarTimer { 
public void handleRestorationCalculation ( ) { 
if ( nextExpiration == null ) return ; 
if ( nextExpiration . getTime ( ) >= System . currentTimeMillis ( ) ) return ; 
nextExpiration = new Date ( System . currentTimeMillis ( ) - 1 ) ; 
} 
} 

public class HibernateSearchProcessor { 
public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; 
final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; 
if ( JPADeploymentMarker . isJPADeployment ( deploymentUnit ) ) addSearchDependency ( moduleSpecification , moduleLoader , deploymentUnit ) ; 
} 
} 

public class WeldDeployment { 
private void makeTopLevelBdasVisibleFromStaticModules ( ) { 
for ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { 
if ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL ) || bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ) ) for ( BeanDeploymentArchiveImpl topLevelBda : rootBeanDeploymentModule . getBeanDeploymentArchives ( ) ) { 
bda . addBeanDeploymentArchive ( topLevelBda ) ; 
} 
} 
} 
} 

public class AbstractMetaDataBuilderPOJO { 
JSEArchiveMetaData create ( final Deployment dep ) { 
if ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) WSLogger . ROOT_LOGGER . tracef ( "Creating JBoss agnostic meta data for POJO webservice deployment: %s" , dep . getSimpleName ( ) ) ; 
final JBossWebMetaData jbossWebMD = WSHelper . getRequiredAttachment ( dep , JBossWebMetaData . class ) ; 
final DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; 
final List < POJOEndpoint > pojoEndpoints = getPojoEndpoints ( unit ) ; 
final JSEArchiveMetaData . Builder builder = new JSEArchiveMetaData . Builder ( ) ; 
final String contextRoot = getContextRoot ( dep , jbossWebMD ) ; 
builder . setContextRoot ( contextRoot ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Setting context root: %s" , contextRoot ) ; 
final Map < String , String > servletMappings = getServletUrlPatternsMappings ( jbossWebMD , pojoEndpoints ) ; 
builder . setServletMappings ( servletMappings ) ; 
final Map < String , String > servletClassNamesMappings = getServletClassMappings ( jbossWebMD , pojoEndpoints ) ; 
builder . setServletClassNames ( servletClassNamesMappings ) ; 
final String securityDomain = jbossWebMD . getSecurityDomain ( ) ; 
builder . setSecurityDomain ( securityDomain ) ; 
final JBossWebservicesMetaData jbossWebservicesMD = WSHelper . getOptionalAttachment ( dep , JBossWebservicesMetaData . class ) ; 
if ( jbossWebservicesMD != null ) { 
final PublishLocationAdapter resolver = new PublishLocationAdapterImpl ( jbossWebservicesMD . getWebserviceDescriptions ( ) ) ; 
builder . setPublishLocationAdapter ( resolver ) ; 
} 
final List < JSESecurityMetaData > jseSecurityMDs = getSecurityMetaData ( jbossWebMD . getSecurityConstraints ( ) ) ; 
builder . setSecurityMetaData ( jseSecurityMDs ) ; 
setConfigNameAndFile ( builder , jbossWebMD , jbossWebservicesMD ) ; 
return builder . build ( ) ; 
} 
} 

public class AbstractMetaDataBuilderPOJO { 
private void setConfigNameAndFile ( final JSEArchiveMetaData . Builder builder , final JBossWebMetaData jbossWebMD , final JBossWebservicesMetaData jbossWebservicesMD ) { 
if ( jbossWebservicesMD != null ) if ( jbossWebservicesMD . getConfigName ( ) != null ) { 
final String configName = jbossWebservicesMD . getConfigName ( ) ; 
builder . setConfigName ( configName ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Setting config name: %s" , configName ) ; 
final String configFile = jbossWebservicesMD . getConfigFile ( ) ; 
builder . setConfigFile ( configFile ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Setting config file: %s" , configFile ) ; 
return ; 
} 
final List < ParamValueMetaData > contextParams = jbossWebMD . getContextParams ( ) ; 
if ( contextParams != null ) for ( final ParamValueMetaData contextParam : contextParams ) { 
if ( WSConstants . JBOSSWS_CONFIG_NAME . equals ( contextParam . getParamName ( ) ) ) { 
final String configName = contextParam . getParamValue ( ) ; 
builder . setConfigName ( configName ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Setting config name: %s" , configName ) ; 
} 
if ( WSConstants . JBOSSWS_CONFIG_FILE . equals ( contextParam . getParamName ( ) ) ) { 
final String configFile = contextParam . getParamValue ( ) ; 
builder . setConfigFile ( configFile ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Setting config file: %s" , configFile ) ; 
} 
} 
} 
} 

public class AbstractMetaDataBuilderPOJO { 
private List < JSESecurityMetaData > getSecurityMetaData ( final List < SecurityConstraintMetaData > securityConstraintsMD ) { 
final List < JSESecurityMetaData > jseSecurityMDs = new LinkedList < JSESecurityMetaData > ( ) ; 
if ( securityConstraintsMD != null ) for ( final SecurityConstraintMetaData securityConstraintMD : securityConstraintsMD ) { 
final JSESecurityMetaData . Builder jseSecurityMDBuilder = new JSESecurityMetaData . Builder ( ) ; 
jseSecurityMDBuilder . setTransportGuarantee ( securityConstraintMD . getTransportGuarantee ( ) . name ( ) ) ; 
for ( final WebResourceCollectionMetaData webResourceMD : securityConstraintMD . getResourceCollections ( ) ) { 
jseSecurityMDBuilder . addWebResource ( webResourceMD . getName ( ) , webResourceMD . getUrlPatterns ( ) ) ; 
} 
jseSecurityMDs . add ( jseSecurityMDBuilder . build ( ) ) ; 
} 
return jseSecurityMDs ; 
} 
} 

public class EjbInjectionSource { 
private void resolve ( ) { 
if ( ! resolved ) synchronized ( this ) { 
if ( ! resolved ) { 
final Set < ViewDescription > views = getViews ( ) ; 
final Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; 
for ( final ViewDescription view : views ) { 
if ( view instanceof EJBViewDescription ) { 
final MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; 
if ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) continue ; 
ejbsForViewName . add ( ( EJBViewDescription ) view ) ; 
} 
} 
if ( ejbsForViewName . isEmpty ( ) ) if ( beanName == null ) error = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; 
else error = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; 
else if ( ejbsForViewName . size ( ) > 1 ) if ( beanName == null ) error = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; 
else error = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; 
else { 
final EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; 
final EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; 
if ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { 
final EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; 
final EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; 
final String earApplicationName = moduleDescription . getEarApplicationName ( ) ; 
final Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { 
@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { 
final Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; 
return module != null ? module . getClassLoader ( ) : null ; 
} 
} 
; 
remoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; 
} 
final ServiceName serviceName = description . getServiceName ( ) ; 
resolvedViewName = serviceName ; 
} 
resolved = true ; 
} 
} 
} 
} 

public class TransactionSubsystem10Parser { 
static void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { 
final int count = reader . getAttributeCount ( ) ; 
for ( int i = 0 ; 
i < count ; 
i ++ ) { 
requireNoNamespaceAttribute ( reader , i ) ; 
final String value = reader . getAttributeValue ( i ) ; 
final Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; 
switch ( attribute ) { 
case NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; 
break ; 
case PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; 
default : throw unexpectedAttribute ( reader , i ) ; 
} 
} 
final EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; 
final EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; 
while ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { 
final Element element = Element . forName ( reader . getLocalName ( ) ) ; 
required . remove ( element ) ; 
switch ( element ) { 
case PROCESS_ID : { 
if ( ! encountered . add ( element ) ) throw duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; 
parseProcessIdEnvironmentElement ( reader , operation ) ; 
break ; 
} 
default : throw unexpectedElement ( reader ) ; 
} 
} 
if ( ! required . isEmpty ( ) ) throw missingRequiredElement ( reader , required ) ; 
} 
} 

public class TransactionSubsystem10Parser { 
static void parseProcessIdEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { 
if ( reader . getAttributeCount ( ) > 0 ) throw unexpectedAttribute ( reader , 0 ) ; 
boolean encountered = false ; 
while ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { 
final Element element = Element . forName ( reader . getLocalName ( ) ) ; 
switch ( element ) { 
case UUID : if ( encountered ) throw unexpectedElement ( reader ) ; 
encountered = true ; 
if ( reader . getAttributeCount ( ) > 0 ) throw unexpectedAttribute ( reader , 0 ) ; 
coreEnvironmentAdd . get ( TransactionSubsystemRootResourceDefinition . PROCESS_ID_UUID . getName ( ) ) . set ( true ) ; 
requireNoContent ( reader ) ; 
break ; 
case SOCKET : { 
if ( encountered ) throw unexpectedElement ( reader ) ; 
encountered = true ; 
parseSocketProcessIdElement ( reader , coreEnvironmentAdd ) ; 
break ; 
} 
default : throw unexpectedElement ( reader ) ; 
} 
} 
if ( ! encountered ) throw missingOneOf ( reader , EnumSet . of ( Element . UUID , Element . SOCKET ) ) ; 
} 
} 

public class InitialContext { 
public static synchronized void removeUrlContextFactory ( final String scheme , ObjectFactory factory ) { 
Map < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; 
ObjectFactory f = factories . get ( scheme ) ; 
if ( f == factory ) { 
factories . remove ( scheme ) ; 
urlContextFactories = Collections . unmodifiableMap ( factories ) ; 
return ; 
} 
else throw new IllegalArgumentException ( ) ; 
} 
} 

public class WildFlyProviderResolver { 
private List < ValidationProvider < ? > > loadProviders ( ClassLoader classLoader ) { 
@ SuppressWarnings ( "rawtypes" ) Iterator < ValidationProvider > providerIterator = ServiceLoader . load ( ValidationProvider . class , classLoader ) . iterator ( ) ; 
LinkedList < ValidationProvider < ? > > providers = new LinkedList < ValidationProvider < ? > > ( ) ; 
while ( providerIterator . hasNext ( ) ) try { 
ValidationProvider < ? > provider = providerIterator . next ( ) ; 
if ( provider . getClass ( ) . getName ( ) . equals ( "org.hibernate.validator.HibernateValidator" ) ) providers . addFirst ( provider ) ; 
else providers . add ( provider ) ; 
} 
catch ( ServiceConfigurationError e ) { 
} 
return providers ; 
} 
} 

public class WebMetaDataModifier { 
private void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { 
final String transportClassName = this . getTransportClassName ( dep ) ; 
WSLogger . ROOT_LOGGER . trace ( "Modifying servlets" ) ; 
final Set < String > epNames = new HashSet < String > ( ) ; 
for ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { 
epNames . add ( ep . getTargetBeanName ( ) ) ; 
} 
for ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { 
final String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; 
if ( endpointClassName != null && endpointClassName . length ( ) > 0 ) if ( epNames . contains ( endpointClassName ) ) { 
servletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Setting transport class: %s for endpoint: %s" , transportClassName , endpointClassName ) ; 
final List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; 
WebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; 
WebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; 
} 
else if ( endpointClassName . startsWith ( "org.apache.cxf" ) ) throw WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; 
} 
} 
} 

public class WebMetaDataModifier { 
private void modifyContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { 
final String contextRoot = dep . getService ( ) . getContextRoot ( ) ; 
if ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) WSLogger . ROOT_LOGGER . tracef ( "Setting context root: %s for deployment: %s" , contextRoot , dep . getSimpleName ( ) ) ; 
jbossWebMD . setContextRoot ( contextRoot ) ; 
} 
} 

public class SecurityActions { 
static RunAs setRunAsIdentity ( final RunAs principal , final SecurityContext sc ) { 
if ( WildFlySecurityManager . isChecking ( ) ) return WildFlySecurityManager . doUnchecked ( new PrivilegedAction < RunAs > ( ) { 
@ Override public RunAs run ( ) { 
if ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; 
RunAs old = sc . getOutgoingRunAs ( ) ; 
sc . setOutgoingRunAs ( principal ) ; 
return old ; 
} 
} 
) ; 
else { 
if ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; 
RunAs old = sc . getOutgoingRunAs ( ) ; 
sc . setOutgoingRunAs ( principal ) ; 
return old ; 
} 
} 
} 

public class SecurityActions { 
static RunAs popRunAsIdentity ( final SecurityContext sc ) { 
if ( WildFlySecurityManager . isChecking ( ) ) return AccessController . doPrivileged ( new PrivilegedAction < RunAs > ( ) { 
@ Override public RunAs run ( ) { 
if ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; 
RunAs principal = sc . getOutgoingRunAs ( ) ; 
sc . setOutgoingRunAs ( null ) ; 
return principal ; 
} 
} 
) ; 
else { 
if ( sc == null ) throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; 
RunAs principal = sc . getOutgoingRunAs ( ) ; 
sc . setOutgoingRunAs ( null ) ; 
return principal ; 
} 
} 
} 

public class Injection { 
protected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { 
while ( ! clz . equals ( Object . class ) ) { 
List < Method > hits = null ; 
Method [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) { 
final Method method = methods [ i ] ; 
if ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) if ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { 
if ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; 
SecurityActions . setAccessible ( method ) ; 
hits . add ( method ) ; 
} 
} 
if ( hits != null ) if ( hits . size ( ) == 1 ) return hits . get ( 0 ) ; 
else { 
Collections . sort ( hits , new MethodSorter ( ) ) ; 
if ( propertyType != null ) for ( Method m : hits ) { 
if ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; 
} 
return hits . get ( 0 ) ; 
} 
clz = clz . getSuperclass ( ) ; 
} 
return null ; 
} 
} 

public class Injection { 
protected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { 
while ( ! clz . equals ( Object . class ) ) { 
List < Field > hits = null ; 
Field [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; 
for ( int i = 0 ; 
i < fields . length ; 
i ++ ) { 
final Field field = fields [ i ] ; 
if ( fieldName . equals ( field . getName ( ) ) ) if ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { 
if ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; 
SecurityActions . setAccessible ( field ) ; 
hits . add ( field ) ; 
} 
} 
if ( hits != null ) if ( hits . size ( ) == 1 ) return hits . get ( 0 ) ; 
else { 
Collections . sort ( hits , new FieldSorter ( ) ) ; 
if ( fieldType != null ) for ( Field f : hits ) { 
if ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; 
} 
return hits . get ( 0 ) ; 
} 
clz = clz . getSuperclass ( ) ; 
} 
return null ; 
} 
} 

public class AuditNotificationReceiver { 
private static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( "[" ) . append ( httpRequest . getContextPath ( ) ) ; 
sb . append ( ":cookies=" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( ":headers=" ) ; 
Enumeration < ? > en = httpRequest . getHeaderNames ( ) ; 
while ( en . hasMoreElements ( ) ) { 
String headerName = ( String ) en . nextElement ( ) ; 
sb . append ( headerName ) . append ( "=" ) ; 
if ( ! headerName . contains ( "authorization" ) ) sb . append ( httpRequest . getHeader ( headerName ) ) . append ( "," ) ; 
} 
sb . append ( "]" ) ; 
sb . append ( "[parameters=" ) ; 
Enumeration < ? > enparam = httpRequest . getParameterNames ( ) ; 
while ( enparam . hasMoreElements ( ) ) { 
String paramName = ( String ) enparam . nextElement ( ) ; 
String [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; 
int len = paramValues != null ? paramValues . length : 0 ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) sb . append ( paramValues [ i ] ) . append ( "::" ) ; 
sb . append ( "," ) ; 
} 
sb . append ( "][attributes=" ) ; 
Enumeration < ? > enu = httpRequest . getAttributeNames ( ) ; 
while ( enu . hasMoreElements ( ) ) { 
String attrName = ( String ) enu . nextElement ( ) ; 
sb . append ( attrName ) . append ( "=" ) ; 
sb . append ( httpRequest . getAttribute ( attrName ) ) . append ( "," ) ; 
} 
sb . append ( "]" ) ; 
return sb . toString ( ) ; 
} 
} 

public class StubStrategy { 
public void writeParams ( OutputStream out , Object [ ] params ) { 
int len = params . length ; 
if ( len != paramWriters . length ) throw IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
Object param = params [ i ] ; 
if ( param instanceof PortableRemoteObject ) try { 
param = PortableRemoteObject . toStub ( ( Remote ) param ) ; 
} 
catch ( NoSuchObjectException e ) { 
throw new RuntimeException ( e ) ; 
} 
paramWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; 
} 
} 
} 

public class StubStrategy { 
public Exception readException ( String id , InputStream in ) { 
ExceptionReader exceptionReader = ( ExceptionReader ) exceptionMap . get ( id ) ; 
if ( exceptionReader == null ) return new UnexpectedException ( id ) ; 
else return exceptionReader . read ( in ) ; 
} 
} 

public class JSFDependencyProcessor { 
private void addCDIFlag ( WarMetaData warMetaData , DeploymentUnit deploymentUnit ) { 
JBossWebMetaData webMetaData = warMetaData . getMergedJBossWebMetaData ( ) ; 
if ( webMetaData == null ) { 
webMetaData = new JBossWebMetaData ( ) ; 
warMetaData . setMergedJBossWebMetaData ( webMetaData ) ; 
} 
List < ParamValueMetaData > contextParams = webMetaData . getContextParams ( ) ; 
if ( contextParams == null ) contextParams = new ArrayList < ParamValueMetaData > ( ) ; 
boolean isCDI = false ; 
final CapabilityServiceSupport support = deploymentUnit . getAttachment ( Attachments . CAPABILITY_SERVICE_SUPPORT ) ; 
if ( support . hasCapability ( WELD_CAPABILITY_NAME ) ) isCDI = support . getOptionalCapabilityRuntimeAPI ( WELD_CAPABILITY_NAME , WeldCapability . class ) . get ( ) . isPartOfWeldDeployment ( deploymentUnit ) ; 
ParamValueMetaData param = new ParamValueMetaData ( ) ; 
param . setParamName ( IS_CDI_PARAM ) ; 
param . setParamValue ( Boolean . toString ( isCDI ) ) ; 
contextParams . add ( param ) ; 
webMetaData . setContextParams ( contextParams ) ; 
} 
} 

public class AbstractInvocationHandler { 
protected ComponentView getComponentView ( ) { 
ComponentView cv = componentView ; 
if ( cv == null ) synchronized ( this ) { 
cv = componentView ; 
if ( cv == null ) { 
cv = getMSCService ( componentViewName , ComponentView . class ) ; 
if ( cv == null ) throw WSLogger . ROOT_LOGGER . cannotFindComponentView ( componentViewName ) ; 
if ( reference == null ) try { 
reference = cv . createInstance ( ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
componentView = cv ; 
} 
} 
return cv ; 
} 
} 

public class AbstractInvocationHandler { 
public void invoke ( final Endpoint endpoint , final Invocation wsInvocation ) throws Exception { 
try { 
if ( ! EndpointState . STARTED . equals ( endpoint . getState ( ) ) ) throw WSLogger . ROOT_LOGGER . endpointAlreadyStopped ( endpoint . getShortName ( ) ) ; 
SecurityDomainContext securityDomainContext = endpoint . getSecurityDomainContext ( ) ; 
securityDomainContext . runAs ( ( Callable < Void > ) ( ) -> { 
invokeInternal ( endpoint , wsInvocation ) ; 
return null ; 
} 
) ; 
} 
catch ( Throwable t ) { 
handleInvocationException ( t ) ; 
} 
finally { 
onAfterInvocation ( wsInvocation ) ; 
} 
} 
} 

public class AbstractInvocationHandler { 
protected Method getComponentViewMethod ( final Method seiMethod , final Collection < Method > viewMethods ) { 
for ( final Method viewMethod : viewMethods ) { 
if ( matches ( seiMethod , viewMethod ) ) return viewMethod ; 
} 
throw new IllegalStateException ( ) ; 
} 
} 

public class AbstractInvocationHandler { 
private boolean matches ( final Method seiMethod , final Method viewMethod ) { 
if ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; 
final Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; 
final Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; 
if ( sourceParams . length != targetParams . length ) return false ; 
for ( int i = 0 ; 
i < sourceParams . length ; 
i ++ ) if ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; 
return true ; 
} 
} 

public class JPAService { 
public static Resource createManagementStatisticsResource ( final ManagementAdaptor managementAdaptor , final String scopedPersistenceUnitName , final DeploymentUnit deploymentUnit ) { 
synchronized ( existingResourceDescriptionResolver ) { 
final EntityManagerFactoryLookup entityManagerFactoryLookup = new EntityManagerFactoryLookup ( ) ; 
final Statistics statistics = managementAdaptor . getStatistics ( ) ; 
if ( false == existingResourceDescriptionResolver . contains ( managementAdaptor . getVersion ( ) ) ) { 
ResourceDescriptionResolver resourceDescriptionResolver = new StandardResourceDescriptionResolver ( statistics . getResourceBundleKeyPrefix ( ) , statistics . getResourceBundleName ( ) , statistics . getClass ( ) . getClassLoader ( ) ) { 
private ResourceDescriptionResolver fallback = JPAExtension . getResourceDescriptionResolver ( ) ; 
@ Override public String getResourceAttributeDescription ( String attributeName , Locale locale , ResourceBundle bundle ) { 
if ( bundle . containsKey ( getBundleKey ( attributeName ) ) ) return super . getResourceAttributeDescription ( attributeName , locale , bundle ) ; 
else return fallback . getResourceAttributeDescription ( attributeName , locale , fallback . getResourceBundle ( locale ) ) ; 
} 
} 
; 
PathElement subsystemPE = PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM , JPAExtension . SUBSYSTEM_NAME ) ; 
ManagementResourceRegistration deploymentResourceRegistration = deploymentUnit . getAttachment ( DeploymentModelUtils . MUTABLE_REGISTRATION_ATTACHMENT ) ; 
ManagementResourceRegistration deploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( subsystemPE ) ) ; 
ManagementResourceRegistration subdeploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBDEPLOYMENT ) , subsystemPE ) ) ; 
ManagementResourceRegistration providerResource = deploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; 
providerResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; 
providerResource = subdeploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; 
providerResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; 
existingResourceDescriptionResolver . add ( managementAdaptor . getVersion ( ) ) ; 
} 
return new DynamicManagementStatisticsResource ( statistics , scopedPersistenceUnitName , managementAdaptor . getIdentificationLabel ( ) , entityManagerFactoryLookup ) ; 
} 
} 
} 

public class AbstractSecurityMetaDataAccessorEJB { 
private String getDomain ( final String oldSecurityDomain , final String nextSecurityDomain ) { 
if ( nextSecurityDomain == null ) return oldSecurityDomain ; 
if ( oldSecurityDomain == null ) return nextSecurityDomain ; 
ensureSameDomains ( oldSecurityDomain , nextSecurityDomain ) ; 
return oldSecurityDomain ; 
} 
} 

public class AttributeAnalysis { 
void setIDLName ( String idlName ) { 
super . setIDLName ( idlName ) ; 
if ( idlName . charAt ( 0 ) >= 0x41 && idlName . charAt ( 0 ) <= 0x5a && ( idlName . length ( ) <= 1 || idlName . charAt ( 1 ) < 0x41 || idlName . charAt ( 1 ) > 0x5a ) ) idlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; 
if ( accessorAnalysis != null ) accessorAnalysis . setIDLName ( "_get_" + idlName ) ; 
if ( mutatorAnalysis != null ) mutatorAnalysis . setIDLName ( "_set_" + idlName ) ; 
} 
} 

public class JndiName { 
public String getAbsoluteName ( ) { 
final StringBuilder absolute = new StringBuilder ( ) ; 
if ( parent != null ) absolute . append ( parent ) . append ( ENTRY_SEPARATOR ) ; 
absolute . append ( local ) ; 
return absolute . toString ( ) ; 
} 
} 

public class IronJacamarDeploymentParsingProcessor { 
@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
final ResourceRoot resourceRoot = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; 
final VirtualFile deploymentRoot = resourceRoot . getRoot ( ) ; 
final boolean resolveProperties = Util . shouldResolveJBoss ( deploymentUnit ) ; 
IronJacamarXmlDescriptor xmlDescriptor = process ( deploymentRoot , resolveProperties ) ; 
if ( xmlDescriptor != null ) deploymentUnit . putAttachment ( IronJacamarXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; 
} 
} 

public class AbstractActiveMQComponentControlHandler { 
protected final T getActiveMQComponentControl ( final OperationContext context , final ModelNode operation , final boolean forWrite ) throws OperationFailedException { 
final ServiceName artemisServiceName = MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP_ADDR ) ) ) ; 
ServiceController < ? > artemisService = context . getServiceRegistry ( forWrite ) . getService ( artemisServiceName ) ; 
ActiveMQServer server = ActiveMQServer . class . cast ( artemisService . getValue ( ) ) ; 
PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; 
T control = getActiveMQComponentControl ( server , address ) ; 
if ( control == null ) throw ControllerLogger . ROOT_LOGGER . managementResourceNotFound ( address ) ; 
return control ; 
} 
} 

public class CommonIronJacamarParser { 
private String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { 
String poolName = null ; 
String jndiName = null ; 
int attributeSize = reader . getAttributeCount ( ) ; 
for ( int i = 0 ; 
i < attributeSize ; 
i ++ ) { 
ConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; 
String value = reader . getAttributeValue ( i ) ; 
switch ( attribute ) { 
case ENABLED : { 
ENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case CONNECTABLE : { 
CONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case TRACKING : { 
TRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case JNDI_NAME : { 
jndiName = value ; 
JNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; 
break ; 
} 
case POOL_NAME : { 
poolName = value ; 
break ; 
} 
case USE_JAVA_CONTEXT : { 
USE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case USE_CCM : { 
USE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case SHARABLE : { 
SHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case ENLISTMENT : { 
ENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case CLASS_NAME : { 
CLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case MCP : { 
MCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
default : throw ParseUtils . unexpectedAttribute ( reader , i ) ; 
} 
} 
if ( poolName == null || poolName . trim ( ) . equals ( "" ) ) if ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) if ( jndiName . contains ( "/" ) ) poolName = jndiName . substring ( jndiName . lastIndexOf ( "/" ) + 1 ) ; 
else poolName = jndiName . substring ( jndiName . lastIndexOf ( ":" ) + 1 ) ; 
else throw ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; 
return poolName ; 
} 
} 

public class JaxrsSpringProcessor { 
protected synchronized VirtualFile getResteasySpringVirtualFile ( ) throws DeploymentUnitProcessingException { 
if ( resourceRoot != null ) return resourceRoot ; 
try { 
Module module = Module . getBootModuleLoader ( ) . loadModule ( MODULE ) ; 
URL fileUrl = module . getClassLoader ( ) . getResource ( JAR_LOCATION ) ; 
if ( fileUrl == null ) throw JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; 
File dir = new File ( fileUrl . toURI ( ) ) ; 
File file = null ; 
for ( String jar : dir . list ( ) ) { 
if ( jar . endsWith ( ".jar" ) ) { 
file = new File ( dir , jar ) ; 
break ; 
} 
} 
if ( file == null ) throw JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; 
VirtualFile vf = VFS . getChild ( file . toURI ( ) ) ; 
final Closeable mountHandle = VFS . mountZip ( file , vf , TempFileProviderService . provider ( ) ) ; 
Service < Closeable > mountHandleService = new Service < Closeable > ( ) { 
public void start ( StartContext startContext ) throws StartException { 
} 
public void stop ( StopContext stopContext ) { 
VFSUtils . safeClose ( mountHandle ) ; 
} 
public Closeable getValue ( ) throws IllegalStateException , IllegalArgumentException { 
return mountHandle ; 
} 
} 
; 
ServiceBuilder < Closeable > builder = serviceTarget . addService ( ServiceName . JBOSS . append ( SERVICE_NAME ) , mountHandleService ) ; 
builder . setInitialMode ( ServiceController . Mode . ACTIVE ) . install ( ) ; 
resourceRoot = vf ; 
return resourceRoot ; 
} 
catch ( Exception e ) { 
throw new DeploymentUnitProcessingException ( e ) ; 
} 
} 
} 

public class ShutDownInterceptorFactory { 
public void shutdown ( ) { 
int value ; 
int oldValue ; 
do { 
oldValue = invocationCount ; 
value = SHUTDOWN_FLAG | oldValue ; 
if ( oldValue == value ) return ; 
} 
while ( ! updater . compareAndSet ( this , oldValue , value ) ) ; 
synchronized ( lock ) { 
value = invocationCount ; 
while ( value != SHUTDOWN_FLAG ) { 
try { 
lock . wait ( ) ; 
} 
catch ( InterruptedException e ) { 
throw new RuntimeException ( e ) ; 
} 
value = invocationCount ; 
if ( ( value & SHUTDOWN_FLAG ) == 0 ) return ; 
} 
} 
} 
} 

public class JPAInterceptorProcessor { 
private void registerSessionBeanInterceptors ( SessionBeanComponentDescription componentDescription , final DeploymentUnit deploymentUnit ) { 
if ( componentDescription . isStateful ( ) ) componentDescription . getConfigurators ( ) . addFirst ( new ComponentConfigurator ( ) { 
@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { 
configuration . addPostConstructInterceptor ( SFSBPreCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_PRE_CREATE ) ; 
configuration . addPostConstructInterceptor ( SFSBCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_CREATE ) ; 
configuration . addPreDestroyInterceptor ( SFSBDestroyInterceptor . FACTORY , InterceptorOrder . ComponentPreDestroy . JPA_SFSB_DESTROY ) ; 
configuration . addComponentInterceptor ( SFSBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SFSB_INTERCEPTOR , false ) ; 
configuration . getInterceptorContextKeys ( ) . add ( SFSBInvocationInterceptor . CONTEXT_KEY ) ; 
} 
} 
) ; 
if ( ( componentDescription . isStateful ( ) || componentDescription . isStateless ( ) ) ) componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { 
@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { 
configuration . addComponentInterceptor ( SBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SESSION_BEAN_INTERCEPTOR , false ) ; 
} 
} 
) ; 
} 
} 

public class AbstractDeploymentDescriptorBindingsProcessor { 
protected Class < ? > processInjectionTargets ( final ResourceInjectionTarget resourceInjectionTarget , InjectionSource injectionSource , ClassLoader classLoader , DeploymentReflectionIndex deploymentReflectionIndex , ResourceInjectionMetaData entry , Class < ? > classType ) throws DeploymentUnitProcessingException { 
if ( entry . getInjectionTargets ( ) != null ) for ( ResourceInjectionTargetMetaData injectionTarget : entry . getInjectionTargets ( ) ) { 
final String injectionTargetClassName = injectionTarget . getInjectionTargetClass ( ) ; 
final String injectionTargetName = injectionTarget . getInjectionTargetName ( ) ; 
final AccessibleObject fieldOrMethod = getInjectionTarget ( injectionTargetClassName , injectionTargetName , classLoader , deploymentReflectionIndex ) ; 
final Class < ? > injectionTargetType = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getType ( ) : ( ( Method ) fieldOrMethod ) . getParameterTypes ( ) [ 0 ] ; 
final String memberName = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getName ( ) : ( ( Method ) fieldOrMethod ) . getName ( ) ; 
if ( classType != null ) if ( ! injectionTargetType . isAssignableFrom ( classType ) ) { 
boolean ok = false ; 
if ( classType . isPrimitive ( ) ) if ( BOXED_TYPES . get ( classType ) . equals ( injectionTargetType ) ) ok = true ; 
else if ( injectionTargetType . isPrimitive ( ) ) if ( BOXED_TYPES . get ( injectionTargetType ) . equals ( classType ) ) ok = true ; 
if ( ! ok ) throw EeLogger . ROOT_LOGGER . invalidInjectionTarget ( injectionTarget . getInjectionTargetName ( ) , injectionTarget . getInjectionTargetClass ( ) , classType ) ; 
classType = injectionTargetType ; 
} 
else classType = injectionTargetType ; 
final InjectionTarget injectionTargetDescription = fieldOrMethod instanceof Field ? new FieldInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) : new MethodInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) ; 
final ResourceInjectionConfiguration injectionConfiguration = new ResourceInjectionConfiguration ( injectionTargetDescription , injectionSource ) ; 
resourceInjectionTarget . addResourceInjection ( injectionConfiguration ) ; 
} 
return classType ; 
} 
} 

public class WeldStartService { 
@ Override public void stop ( final StopContext context ) { 
final WeldBootstrapService bootstrapService = bootstrapSupplier . get ( ) ; 
if ( ! bootstrapService . isStarted ( ) ) throw WeldLogger . ROOT_LOGGER . notStarted ( "WeldContainer" ) ; 
WeldLogger . DEPLOYMENT_LOGGER . stoppingWeldService ( bootstrapService . getDeploymentName ( ) ) ; 
ClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; 
try { 
WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; 
WeldProvider . containerShutDown ( Container . instance ( bootstrapService . getDeploymentName ( ) ) ) ; 
bootstrapService . getBootstrap ( ) . shutdown ( ) ; 
} 
finally { 
WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; 
ModuleGroupSingletonProvider . removeClassLoader ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; 
} 
bootstrapService . setStarted ( false ) ; 
} 
} 

public class JMSConnectionFactoryDefinitionInjectionSource { 
static boolean targetsPooledConnectionFactory ( String server , String resourceAdapter , ServiceRegistry serviceRegistry ) { 
if ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) return true ; 
ServiceName activeMQServiceName = MessagingServices . getActiveMQServiceName ( server ) ; 
ServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( activeMQServiceName ) . append ( resourceAdapter ) ; 
return serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; 
} 
} 

public class JMSConnectionFactoryDefinitionInjectionSource { 
static boolean targetsExternalPooledConnectionFactory ( String resourceAdapter , ServiceRegistry serviceRegistry ) { 
if ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) return false ; 
ServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( MessagingServices . getActiveMQServiceName ( "" ) ) . append ( resourceAdapter ) ; 
return serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; 
} 
} 

public class PersistenceUnitSearch { 
private static String defaultPersistenceUnitName ( String persistenceUnitName , PersistenceUnitMetadataHolder holder ) { 
if ( ( persistenceUnitName == null || persistenceUnitName . length ( ) == 0 ) ) for ( PersistenceUnitMetadata persistenceUnit : holder . getPersistenceUnits ( ) ) { 
String defaultPU = persistenceUnit . getProperties ( ) . getProperty ( Configuration . JPA_DEFAULT_PERSISTENCE_UNIT ) ; 
if ( Boolean . TRUE . toString ( ) . equals ( defaultPU ) ) persistenceUnitName = persistenceUnit . getPersistenceUnitName ( ) ; 
} 
return persistenceUnitName ; 
} 
} 

public class EJBSuspendHandlerService { 
@ Override public void suspended ( ServerActivityCallback listener ) { 
this . suspended = true ; 
listenerUpdater . set ( this , listener ) ; 
localTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; 
final int activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; 
if ( activeInvocationCount == 0 ) if ( gracefulTxnShutdown ) if ( activeTransactionCountUpdater . get ( this ) == 0 ) this . doneSuspended ( ) ; 
else EjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; 
else this . doneSuspended ( ) ; 
} 
} 

public class EJBSuspendHandlerService { 
@ Override public void resume ( ) { 
this . suspended = false ; 
localTransactionContextInjectedValue . getValue ( ) . resumeRequests ( ) ; 
ServerActivityCallback listener = listenerUpdater . get ( this ) ; 
if ( listener != null ) listenerUpdater . compareAndSet ( this , listener , null ) ; 
deploymentRepositoryInjectedValue . getValue ( ) . resume ( ) ; 
} 
} 

public class EJBSuspendHandlerService { 
public void invocationComplete ( ) { 
int activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; 
if ( suspended && activeInvocations == 0 && ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) ) doneSuspended ( ) ; 
} 
} 

public class MessagingServices { 
public static ServiceName getCapabilityServiceName ( String capabilityBaseName , String ... dynamicParts ) { 
if ( capabilityServiceSupport == null ) throw new IllegalStateException ( ) ; 
if ( dynamicParts == null || dynamicParts . length == 0 ) return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; 
return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName , dynamicParts ) ; 
} 
} 

public class WarStructureDeploymentProcessor { 
private List < ResourceRoot > createResourceRoots ( final VirtualFile deploymentRoot , final DeploymentUnit deploymentUnit ) throws IOException , DeploymentUnitProcessingException { 
final List < ResourceRoot > entries = new ArrayList < ResourceRoot > ( ) ; 
final VirtualFile webinfClasses = deploymentRoot . getChild ( WEB_INF_CLASSES ) ; 
if ( webinfClasses . exists ( ) ) { 
final ResourceRoot webInfClassesRoot = new ResourceRoot ( webinfClasses . getName ( ) , webinfClasses , null ) ; 
ModuleRootMarker . mark ( webInfClassesRoot ) ; 
entries . add ( webInfClassesRoot ) ; 
} 
Map < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_OVERLAY_LOCATIONS ) ; 
final VirtualFile webinfLib = deploymentRoot . getChild ( WEB_INF_LIB ) ; 
if ( webinfLib . exists ( ) ) { 
final List < VirtualFile > archives = webinfLib . getChildren ( DEFAULT_WEB_INF_LIB_FILTER ) ; 
for ( final VirtualFile archive : archives ) { 
try { 
String relativeName = archive . getPathNameRelativeTo ( deploymentRoot ) ; 
MountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; 
Closeable closable = null ; 
if ( overlay != null ) overlay . remountAsZip ( false ) ; 
else if ( archive . isFile ( ) ) closable = VFS . mountZip ( archive , archive , TempFileProviderService . provider ( ) ) ; 
else closable = null ; 
final ResourceRoot webInfArchiveRoot = new ResourceRoot ( archive . getName ( ) , archive , new MountHandle ( closable ) ) ; 
ModuleRootMarker . mark ( webInfArchiveRoot ) ; 
entries . add ( webInfArchiveRoot ) ; 
} 
catch ( IOException e ) { 
throw new DeploymentUnitProcessingException ( UndertowLogger . ROOT_LOGGER . failToProcessWebInfLib ( archive ) , e ) ; 
} 
} 
} 
return entries ; 
} 
} 

public class PersistenceProviderHandler { 
private static Set < ClassLoader > allDeploymentModuleClassLoaders ( DeploymentUnit deploymentUnit ) { 
Set < ClassLoader > deploymentClassLoaders = new HashSet < ClassLoader > ( ) ; 
final DeploymentUnit topDeploymentUnit = DeploymentUtils . getTopDeploymentUnit ( deploymentUnit ) ; 
final Module toplevelModule = topDeploymentUnit . getAttachment ( Attachments . MODULE ) ; 
if ( toplevelModule != null ) { 
deploymentClassLoaders . add ( toplevelModule . getClassLoader ( ) ) ; 
final List < DeploymentUnit > subDeployments = topDeploymentUnit . getAttachmentList ( Attachments . SUB_DEPLOYMENTS ) ; 
for ( DeploymentUnit subDeploymentUnit : subDeployments ) { 
final Module subDeploymentModule = subDeploymentUnit . getAttachment ( Attachments . MODULE ) ; 
if ( subDeploymentModule != null ) deploymentClassLoaders . add ( subDeploymentModule . getClassLoader ( ) ) ; 
} 
} 
return deploymentClassLoaders ; 
} 
} 

public class Configuration { 
public static boolean needClassFileTransformer ( PersistenceUnitMetadata pu ) { 
boolean result = true ; 
String provider = pu . getPersistenceProviderClassName ( ) ; 
if ( pu . getProperties ( ) . containsKey ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) ; 
else if ( isHibernateProvider ( provider ) ) result = ( Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_USE_CLASS_ENHANCER ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_DIRTY_TRACKING ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_LAZY_INITIALIZATION ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT ) ) ) ; 
return result ; 
} 
} 

public class Configuration { 
public static boolean allowTwoPhaseBootstrap ( PersistenceUnitMetadata pu ) { 
boolean result = true ; 
if ( EE_DEFAULT_DATASOURCE . equals ( pu . getJtaDataSourceName ( ) ) ) result = false ; 
if ( pu . getProperties ( ) . containsKey ( Configuration . JPA_ALLOW_TWO_PHASE_BOOTSTRAP ) ) result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_ALLOW_TWO_PHASE_BOOTSTRAP ) ) ; 
return result ; 
} 
} 

public class Configuration { 
public static boolean allowDefaultDataSourceUse ( PersistenceUnitMetadata pu ) { 
boolean result = true ; 
if ( pu . getProperties ( ) . containsKey ( Configuration . JPA_ALLOW_DEFAULT_DATA_SOURCE_USE ) ) result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_ALLOW_DEFAULT_DATA_SOURCE_USE ) ) ; 
return result ; 
} 
} 

public class Configuration { 
public static boolean skipMixedSynchronizationTypeCheck ( EntityManagerFactory emf , Map targetEntityManagerProperties ) { 
boolean result = false ; 
if ( targetEntityManagerProperties != null && targetEntityManagerProperties . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) result = Boolean . parseBoolean ( ( String ) targetEntityManagerProperties . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; 
else if ( emf . getProperties ( ) != null && emf . getProperties ( ) . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) result = Boolean . parseBoolean ( ( String ) emf . getProperties ( ) . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; 
return result ; 
} 
} 

public class CorbaUtils { 
public static ORB getOrb ( String server , int port , Hashtable env ) { 
Properties orbProp ; 
if ( env != null ) { 
orbProp = new Properties ( ) ; 
final Enumeration envProp = env . keys ( ) ; 
while ( envProp . hasMoreElements ( ) ) { 
String key = ( String ) envProp . nextElement ( ) ; 
Object val = env . get ( key ) ; 
if ( val instanceof String ) orbProp . put ( key , val ) ; 
} 
final Enumeration mainProps = orbProperties . keys ( ) ; 
while ( mainProps . hasMoreElements ( ) ) { 
String key = ( String ) mainProps . nextElement ( ) ; 
Object val = orbProperties . get ( key ) ; 
if ( val instanceof String ) orbProp . put ( key , val ) ; 
} 
} 
else orbProp = orbProperties ; 
if ( server != null ) orbProp . put ( "org.omg.CORBA.ORBInitialHost" , server ) ; 
if ( port >= 0 ) orbProp . put ( "org.omg.CORBA.ORBInitialPort" , "" + port ) ; 
if ( env != null ) { 
Object applet = env . get ( Context . APPLET ) ; 
if ( applet != null ) return initAppletORB ( applet , orbProp ) ; 
} 
return ORB . init ( new String [ 0 ] , orbProp ) ; 
} 
} 

public class CorbaUtils { 
private static ORB initAppletORB ( Object applet , Properties orbProp ) { 
try { 
Class < ? > appletClass = Class . forName ( "java.applet.Applet" , true , null ) ; 
if ( ! appletClass . isInstance ( applet ) ) throw new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; 
Method method = ORB . class . getMethod ( "init" , appletClass , Properties . class ) ; 
return ( ORB ) method . invoke ( null , applet , orbProp ) ; 
} 
catch ( ClassNotFoundException e ) { 
throw new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; 
} 
catch ( NoSuchMethodException e ) { 
throw new AssertionError ( e ) ; 
} 
catch ( InvocationTargetException e ) { 
Throwable cause = e . getCause ( ) ; 
if ( cause instanceof RuntimeException ) throw ( RuntimeException ) cause ; 
else if ( cause instanceof Error ) throw ( Error ) cause ; 
throw new AssertionError ( e ) ; 
} 
catch ( IllegalAccessException iae ) { 
throw new AssertionError ( iae ) ; 
} 
} 
} 

public class NamingContext { 
public static void setActiveNamingStore ( final NamingStore namingStore ) { 
if ( WildFlySecurityManager . isChecking ( ) ) System . getSecurityManager ( ) . checkPermission ( SET_ACTIVE_NAMING_STORE ) ; 
ACTIVE_NAMING_STORE = namingStore ; 
} 
} 

public class JaxrsMethodParameterProcessor { 
private void validateDefaultValues ( List < ParamDetail > detailList , HashMap < String , List < Validator > > paramConverterMap ) throws DeploymentUnitProcessingException { 
for ( ParamDetail detail : detailList ) { 
List < Validator > validators = paramConverterMap . get ( detail . parameter . getName ( ) ) ; 
if ( validators == null ) validators = paramConverterMap . get ( Object . class . getName ( ) ) ; 
boolean isCheckClazzMethods = true ; 
if ( validators != null ) for ( Validator v : validators ) { 
if ( ! v . isLazyLoad ( ) ) try { 
Object obj = v . verify ( detail ) ; 
if ( obj != null ) { 
isCheckClazzMethods = false ; 
break ; 
} 
} 
catch ( Exception e ) { 
JAXRS_LOGGER . paramConverterFailed ( detail . defaultValue . value ( ) , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , v . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; 
} 
} 
if ( isCheckClazzMethods ) { 
Class baseType = detail . parameter ; 
Method valueOf = null ; 
try { 
Constructor < ? > ctor = baseType . getConstructor ( String . class ) ; 
if ( Modifier . isPublic ( ctor . getModifiers ( ) ) ) continue ; 
} 
catch ( NoSuchMethodException ignored ) { 
} 
try { 
Method fromValue = baseType . getDeclaredMethod ( "fromValue" , String . class ) ; 
if ( Modifier . isPublic ( fromValue . getModifiers ( ) ) ) { 
for ( Annotation ann : baseType . getAnnotations ( ) ) { 
if ( ann . annotationType ( ) . getName ( ) . equals ( "javax.xml.bind.annotation.XmlEnum" ) ) valueOf = fromValue ; 
} 
validateBaseType ( fromValue , detail . defaultValue . value ( ) , detail ) ; 
continue ; 
} 
} 
catch ( NoSuchMethodException ignoredA ) { 
} 
Method fromString = null ; 
try { 
fromString = baseType . getDeclaredMethod ( "fromString" , String . class ) ; 
if ( Modifier . isStatic ( fromString . getModifiers ( ) ) ) { 
validateBaseType ( fromString , detail . defaultValue . value ( ) , detail ) ; 
continue ; 
} 
} 
catch ( NoSuchMethodException ignoredB ) { 
} 
try { 
valueOf = baseType . getDeclaredMethod ( "valueOf" , String . class ) ; 
if ( Modifier . isStatic ( valueOf . getModifiers ( ) ) ) { 
validateBaseType ( valueOf , detail . defaultValue . value ( ) , detail ) ; 
continue ; 
} 
} 
catch ( NoSuchMethodException ignored ) { 
} 
} 
} 
} 
} 

public class JaxrsMethodParameterProcessor { 
private Class checkParamType ( Type genParamType , final Method method , final int paramPos , final ClassLoader classLoader ) { 
Class paramClazz = null ; 
if ( genParamType instanceof ParameterizedType ) { 
ParameterizedType pType = ( ParameterizedType ) genParamType ; 
Type [ ] actualTypeArgs = pType . getActualTypeArguments ( ) ; 
if ( actualTypeArgs . length == 1 ) try { 
paramClazz = classLoader . loadClass ( actualTypeArgs [ 0 ] . getTypeName ( ) ) ; 
} 
catch ( Exception ee ) { 
JAXRS_LOGGER . classIntrospectionFailure ( ee . getClass ( ) . getName ( ) , ee . getMessage ( ) ) ; 
} 
} 
else { 
Class < ? > [ ] paramArr = method . getParameterTypes ( ) ; 
if ( paramArr [ paramPos ] . isArray ( ) ) { 
Class compClazz = paramArr [ paramPos ] . getComponentType ( ) ; 
if ( ! compClazz . isPrimitive ( ) ) paramClazz = compClazz ; 
} 
else if ( ! paramArr [ paramPos ] . isPrimitive ( ) ) paramClazz = paramArr [ paramPos ] ; 
} 
return paramClazz ; 
} 
} 

public class JaxrsMethodParameterProcessor { 
private DefaultValue lookupDefaultValueAnn ( Annotation [ ] annotationArr ) { 
for ( Annotation ann : annotationArr ) { 
if ( ann instanceof DefaultValue ) return ( DefaultValue ) ann ; 
} 
return null ; 
} 
} 

public class JaxrsMethodParameterProcessor { 
private void validateBaseType ( Method method , String defaultValue , ParamDetail detail ) throws DeploymentUnitProcessingException { 
if ( defaultValue != null ) try { 
method . invoke ( method . getDeclaringClass ( ) , defaultValue ) ; 
} 
catch ( Exception e ) { 
JAXRS_LOGGER . baseTypeMethodFailed ( defaultValue , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , method . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; 
} 
} 
} 

public class CreatedEntityManagers { 
public static ExtendedEntityManager [ ] getDeferredEntityManagers ( ) { 
List < ExtendedEntityManager > store = deferToPostConstruct . get ( ) ; 
try { 
if ( store . isEmpty ( ) ) return EMPTY ; 
else return store . toArray ( new ExtendedEntityManager [ store . size ( ) ] ) ; 
} 
finally { 
store . clear ( ) ; 
} 
} 
} 

public class StatusHelper { 
public static String statusAsString ( int status ) { 
if ( status >= Status . STATUS_ACTIVE && status <= Status . STATUS_ROLLING_BACK ) return TxStatusStrings [ status ] ; 
else return "STATUS_INVALID(" + status + ")" ; 
} 
} 

public class DatabaseTimerPersistence { 
private void extractDialects ( ) { 
for ( Object prop : sql . keySet ( ) ) { 
int dot = ( ( String ) prop ) . indexOf ( '.' ) ; 
if ( dot > 0 ) databaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; 
} 
} 
} 

public class DatabaseTimerPersistence { 
private void investigateDialect ( ) { 
Connection connection = null ; 
if ( database == null ) { 
try { 
connection = dataSource . getConnection ( ) ; 
DatabaseMetaData metaData = connection . getMetaData ( ) ; 
String dbProduct = metaData . getDatabaseProductName ( ) ; 
database = identifyDialect ( dbProduct ) ; 
if ( database == null ) { 
EjbLogger . EJB3_TIMER_LOGGER . debug ( "Attempting to guess on driver name." ) ; 
database = identifyDialect ( metaData . getDriverName ( ) ) ; 
} 
} 
catch ( Exception e ) { 
EjbLogger . EJB3_TIMER_LOGGER . debug ( "Unable to read JDBC metadata." , e ) ; 
} 
finally { 
safeClose ( connection ) ; 
} 
if ( database == null ) EjbLogger . EJB3_TIMER_LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString ( ) ) ; 
else EjbLogger . EJB3_TIMER_LOGGER . debugf ( "Detect database dialect as '%s'.  If this is incorrect, please specify the correct dialect using the 'database' attribute in your configuration.  Supported database dialect strings are %s" , database , databaseDialects ) ; 
} 
else { 
EjbLogger . EJB3_TIMER_LOGGER . debugf ( "Database dialect '%s' read from configuration, adjusting it to match the final database valid value." , database ) ; 
database = identifyDialect ( database ) ; 
EjbLogger . EJB3_TIMER_LOGGER . debugf ( "New Database dialect is '%s'." , database ) ; 
} 
} 
} 

public class DatabaseTimerPersistence { 
private String identifyDialect ( String name ) { 
String unified = null ; 
if ( name != null ) if ( name . toLowerCase ( ) . contains ( "postgres" ) ) unified = "postgresql" ; 
else if ( name . toLowerCase ( ) . contains ( "mysql" ) ) unified = "mysql" ; 
else if ( name . toLowerCase ( ) . contains ( "mariadb" ) ) unified = "mariadb" ; 
else if ( name . toLowerCase ( ) . contains ( "db2" ) ) unified = "db2" ; 
else if ( name . toLowerCase ( ) . contains ( "hsql" ) || name . toLowerCase ( ) . contains ( "hypersonic" ) ) unified = "hsql" ; 
else if ( name . toLowerCase ( ) . contains ( "h2" ) ) unified = "h2" ; 
else if ( name . toLowerCase ( ) . contains ( "oracle" ) ) unified = "oracle" ; 
else if ( name . toLowerCase ( ) . contains ( "microsoft" ) ) unified = "mssql" ; 
else if ( name . toLowerCase ( ) . contains ( "jconnect" ) ) unified = "sybase" ; 
EjbLogger . EJB3_TIMER_LOGGER . debugf ( "Check dialect for '%s', result is '%s'" , name , unified ) ; 
return unified ; 
} 
} 

public class DatabaseTimerPersistence { 
private void checkDatabase ( ) { 
String loadTimer = sql ( LOAD_TIMER ) ; 
Connection connection = null ; 
Statement statement = null ; 
PreparedStatement preparedStatement = null ; 
ResultSet resultSet = null ; 
try { 
connection = dataSource . getConnection ( ) ; 
if ( connection . getTransactionIsolation ( ) < Connection . TRANSACTION_READ_COMMITTED ) EjbLogger . EJB3_TIMER_LOGGER . wrongTransactionIsolationConfiguredForTimer ( ) ; 
preparedStatement = connection . prepareStatement ( loadTimer ) ; 
preparedStatement . setString ( 1 , "NON-EXISTENT" ) ; 
preparedStatement . setString ( 2 , "NON-EXISTENT" ) ; 
preparedStatement . setString ( 3 , "NON-EXISTENT" ) ; 
resultSet = preparedStatement . executeQuery ( ) ; 
} 
catch ( SQLException e ) { 
if ( connection != null ) try { 
String createTable = sql ( CREATE_TABLE ) ; 
String [ ] statements = createTable . split ( ";" ) ; 
for ( final String sql : statements ) { 
try { 
statement = connection . createStatement ( ) ; 
statement . executeUpdate ( sql ) ; 
} 
finally { 
safeClose ( statement ) ; 
} 
} 
} 
catch ( SQLException e1 ) { 
EjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e1 ) ; 
} 
else EjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e ) ; 
} 
finally { 
safeClose ( resultSet ) ; 
safeClose ( preparedStatement ) ; 
safeClose ( statement ) ; 
safeClose ( connection ) ; 
} 
} 
} 

public class DatabaseTimerPersistence { 
private Date stringAsSchedulerDate ( final String date , final String timerId ) { 
if ( date == null ) return null ; 
try { 
return new SimpleDateFormat ( SCHEDULER_DATE_FORMAT ) . parse ( date ) ; 
} 
catch ( ParseException e ) { 
EjbLogger . EJB3_TIMER_LOGGER . scheduleExpressionDateFromTimerPersistenceInvalid ( timerId , e . getMessage ( ) ) ; 
return null ; 
} 
} 
} 

public class DatabaseTimerPersistence { 
private void setNodeName ( final TimerState timerState , PreparedStatement statement , int paramIndex ) throws SQLException { 
if ( timerState == TimerState . IN_TIMEOUT || timerState == TimerState . RETRY_TIMEOUT ) statement . setString ( paramIndex , nodeName ) ; 
else statement . setNull ( paramIndex , Types . VARCHAR ) ; 
} 
} 

public class WeldDeploymentMarker { 
public static void mark ( DeploymentUnit unit ) { 
unit . putAttachment ( MARKER , Boolean . TRUE ) ; 
if ( unit . getParent ( ) != null ) mark ( unit . getParent ( ) ) ; 
} 
} 

public class SkeletonStrategy { 
public Object [ ] readParams ( InputStream in ) { 
int len = paramReaders . length ; 
Object [ ] params = new Object [ len ] ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) params [ i ] = paramReaders [ i ] . read ( in ) ; 
return params ; 
} 
} 

public class SkeletonStrategy { 
public void writeException ( OutputStream out , Throwable e ) { 
int len = excepWriters . length ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) if ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { 
excepWriters [ i ] . write ( out , e ) ; 
return ; 
} 
throw new UnknownException ( e ) ; 
} 
} 

public class SFSBCallStack { 
public static void endSfsbCreation ( ) { 
SFSBCallStackThreadData data = CURRENT . get ( ) ; 
int no = data . creationBeanNestingLevel ; 
no -- ; 
data . creationBeanNestingLevel = no ; 
if ( no == 0 ) { 
data . creationTimeXPCRegistration = null ; 
data . creationTimeInjectedXPCs = null ; 
} 
else data . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; 
} 
} 

public class SFSBCallStack { 
public static Map < String , ExtendedEntityManager > currentSFSBCallStackInvocation ( ) { 
ArrayList < Map < String , ExtendedEntityManager > > stack = CURRENT . get ( ) . invocationStack ; 
if ( stack != null && stack . size ( ) > 0 ) return stack . get ( stack . size ( ) - 1 ) ; 
return null ; 
} 
} 

public class SFSBCallStack { 
public static void pushCall ( Map < String , ExtendedEntityManager > entityManagers ) { 
currentSFSBCallStack ( ) . add ( entityManagers ) ; 
if ( entityManagers != null ) for ( ExtendedEntityManager extendedEntityManager : entityManagers . values ( ) ) { 
extendedEntityManager . internalAssociateWithJtaTx ( ) ; 
} 
} 
} 

public class SFSBCallStack { 
static Map < String , ExtendedEntityManager > getCurrentCall ( ) { 
ArrayList < Map < String , ExtendedEntityManager > > stack = currentSFSBCallStack ( ) ; 
Map < String , ExtendedEntityManager > result = null ; 
if ( stack != null ) result = stack . get ( stack . size ( ) - 1 ) ; 
return result ; 
} 
} 

public class WeldDependencyProcessor { 
public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; 
final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; 
addDependency ( moduleSpecification , moduleLoader , JAVAX_ENTERPRISE_API ) ; 
addDependency ( moduleSpecification , moduleLoader , JAVAX_INJECT_API ) ; 
if ( ! WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit ) ) return ; 
addDependency ( moduleSpecification , moduleLoader , JAVAX_PERSISTENCE_API_ID ) ; 
addDependency ( moduleSpecification , moduleLoader , WELD_CORE_ID ) ; 
addDependency ( moduleSpecification , moduleLoader , WELD_PROBE_ID , true ) ; 
addDependency ( moduleSpecification , moduleLoader , WELD_API_ID ) ; 
addDependency ( moduleSpecification , moduleLoader , WELD_SPI_ID ) ; 
ModuleDependency weldSubsystemDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_ID , false , false , false , false ) ; 
weldSubsystemDependency . addImportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; 
weldSubsystemDependency . addImportFilter ( PathFilters . is ( "org/jboss/as/weld/injection" ) , true ) ; 
weldSubsystemDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; 
weldSubsystemDependency . addExportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; 
moduleSpecification . addSystemDependency ( weldSubsystemDependency ) ; 
ModuleDependency weldEjbDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_EJB_ID , true , false , false , false ) ; 
weldEjbDependency . addImportFilter ( PathFilters . is ( "org/jboss/as/weld/ejb" ) , true ) ; 
weldEjbDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; 
moduleSpecification . addSystemDependency ( weldEjbDependency ) ; 
} 
} 

public class JSFComponentProcessor { 
private void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { 
for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { 
InputStream is = null ; 
try { 
is = facesConfig . openStream ( ) ; 
final XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; 
inputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; 
XMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; 
StringBuilder className = null ; 
int indent = 0 ; 
boolean managedBean = false ; 
boolean managedBeanClass = false ; 
while ( true ) { 
int event = parser . next ( ) ; 
if ( event == XMLStreamConstants . END_DOCUMENT ) { 
parser . close ( ) ; 
break ; 
} 
if ( event == XMLStreamConstants . START_ELEMENT ) { 
indent ++ ; 
if ( indent == 2 ) if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) managedBean = true ; 
else if ( indent == 3 && managedBean ) if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { 
managedBeanClass = true ; 
className = new StringBuilder ( ) ; 
} 
} 
else if ( event == XMLStreamConstants . END_ELEMENT ) { 
indent -- ; 
managedBeanClass = false ; 
if ( indent == 1 ) managedBean = false ; 
if ( className != null ) { 
managedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; 
className = null ; 
} 
} 
else if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) className . append ( parser . getText ( ) ) ; 
} 
} 
catch ( Exception e ) { 
JSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; 
} 
finally { 
try { 
if ( is != null ) is . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
} 
} 
} 

public class JSFComponentProcessor { 
private void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { 
for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { 
InputStream is = null ; 
try { 
is = facesConfig . openStream ( ) ; 
final XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; 
inputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; 
XMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; 
StringBuilder phaseListenerName = null ; 
int indent = 0 ; 
boolean lifecycle = false ; 
boolean phaseListener = false ; 
while ( true ) { 
int event = parser . next ( ) ; 
if ( event == XMLStreamConstants . END_DOCUMENT ) { 
parser . close ( ) ; 
break ; 
} 
if ( event == XMLStreamConstants . START_ELEMENT ) { 
indent ++ ; 
if ( indent == 2 ) if ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) lifecycle = true ; 
else if ( indent == 3 && lifecycle ) if ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { 
phaseListener = true ; 
phaseListenerName = new StringBuilder ( ) ; 
} 
} 
else if ( event == XMLStreamConstants . END_ELEMENT ) { 
indent -- ; 
phaseListener = false ; 
if ( indent == 1 ) lifecycle = false ; 
if ( phaseListenerName != null ) { 
managedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; 
phaseListenerName = null ; 
} 
} 
else if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) phaseListenerName . append ( parser . getText ( ) ) ; 
} 
} 
catch ( Exception e ) { 
JSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; 
} 
finally { 
try { 
if ( is != null ) is . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
} 
} 
} 

public class Util { 
public static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { 
if ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; 
if ( cls . isArray ( ) ) { 
Class componentClass = cls ; 
int sequence = 0 ; 
while ( componentClass . isArray ( ) ) { 
componentClass = componentClass . getComponentType ( ) ; 
++ sequence ; 
} 
String idlName = getTypeIDLName ( componentClass ) ; 
int idx = idlName . lastIndexOf ( "::" ) ; 
String idlModule = idlName . substring ( 0 , idx + 2 ) ; 
String baseName = idlName . substring ( idx + 2 ) ; 
return "::org::omg::boxedRMI" + idlModule + "seq" + sequence + "_" + baseName ; 
} 
if ( cls == java . lang . String . class ) return "::CORBA::WStringValue" ; 
if ( cls == java . lang . Object . class ) return "::java::lang::_Object" ; 
if ( cls == java . lang . Class . class ) return "::javax::rmi::CORBA::ClassDesc" ; 
if ( cls == java . io . Serializable . class ) return "::java::io::Serializable" ; 
if ( cls == java . io . Externalizable . class ) return "::java::io::Externalizable" ; 
if ( cls == java . rmi . Remote . class ) return "::java::rmi::Remote" ; 
if ( cls == org . omg . CORBA . Object . class ) return "::CORBA::Object" ; 
if ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { 
InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; 
return ia . getIDLModuleName ( ) + "::" + ia . getIDLName ( ) ; 
} 
if ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { 
InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; 
return ia . getIDLModuleName ( ) + "::" + ia . getIDLName ( ) ; 
} 
if ( Throwable . class . isAssignableFrom ( cls ) ) if ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { 
ExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; 
return ea . getIDLModuleName ( ) + "::" + ea . getIDLName ( ) ; 
} 
ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; 
return va . getIDLModuleName ( ) + "::" + va . getIDLName ( ) ; 
} 
} 

public class TransactionScopedEntityManager { 
private EntityManager getOrCreateTransactionScopedEntityManager ( final EntityManagerFactory emf , final String scopedPuName , final Map properties , final SynchronizationType synchronizationType ) { 
EntityManager entityManager = TransactionUtil . getTransactionScopedEntityManager ( puScopedName , transactionSynchronizationRegistry ) ; 
if ( entityManager == null ) { 
entityManager = createEntityManager ( emf , properties , synchronizationType ) ; 
if ( ROOT_LOGGER . isDebugEnabled ( ) ) ROOT_LOGGER . debugf ( "%s: created entity manager session %s" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; 
TransactionUtil . registerSynchronization ( entityManager , scopedPuName , transactionSynchronizationRegistry , transactionManager ) ; 
TransactionUtil . putEntityManagerInTransactionRegistry ( scopedPuName , entityManager , transactionSynchronizationRegistry ) ; 
} 
else { 
testForMixedSynchronizationTypes ( emf , entityManager , puScopedName , synchronizationType , properties ) ; 
if ( ROOT_LOGGER . isDebugEnabled ( ) ) ROOT_LOGGER . debugf ( "%s: reuse entity manager session already in tx %s" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; 
} 
return entityManager ; 
} 
} 

public class ManagementUtil { 
static ModelNode convertSecurityRole ( final ModelNode camelCase ) { 
final ModelNode result = new ModelNode ( ) ; 
result . setEmptyList ( ) ; 
if ( camelCase . isDefined ( ) ) for ( ModelNode role : camelCase . asList ( ) ) { 
final ModelNode roleNode = result . add ( ) ; 
for ( Property prop : role . asPropertyList ( ) ) { 
String key = prop . getName ( ) ; 
if ( "createDurableQueue" . equals ( key ) ) key = SecurityRoleDefinition . CREATE_DURABLE_QUEUE . getName ( ) ; 
else if ( "deleteDurableQueue" . equals ( key ) ) key = SecurityRoleDefinition . DELETE_DURABLE_QUEUE . getName ( ) ; 
else if ( "createNonDurableQueue" . equals ( key ) ) key = SecurityRoleDefinition . CREATE_NON_DURABLE_QUEUE . getName ( ) ; 
else if ( "deleteNonDurableQueue" . equals ( key ) ) key = SecurityRoleDefinition . DELETE_NON_DURABLE_QUEUE . getName ( ) ; 
roleNode . get ( key ) . set ( prop . getValue ( ) ) ; 
} 
} 
return result ; 
} 
} 

public class FileTimerPersistence { 
private TimerImpl mostRecentEntityVersion ( final TimerImpl timerImpl ) { 
try { 
final int status = ContextTransactionManager . getInstance ( ) . getStatus ( ) ; 
if ( status == Status . STATUS_UNKNOWN || status == Status . STATUS_NO_TRANSACTION ) return timerImpl ; 
final String key = timerTransactionKey ( timerImpl ) ; 
TimerImpl existing = ( TimerImpl ) transactionSynchronizationRegistry . getValue ( ) . getResource ( key ) ; 
return existing != null ? existing : timerImpl ; 
} 
catch ( SystemException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class FileTimerPersistence { 
private String getDirectory ( String timedObjectId ) { 
String dirName = directories . get ( timedObjectId ) ; 
if ( dirName == null ) { 
dirName = baseDir . getAbsolutePath ( ) + File . separator + timedObjectId . replace ( File . separator , "-" ) ; 
File file = new File ( dirName ) ; 
if ( ! file . exists ( ) ) if ( ! file . mkdirs ( ) ) EJB3_TIMER_LOGGER . failToCreateDirectoryForPersistTimers ( file ) ; 
directories . put ( timedObjectId , dirName ) ; 
} 
return dirName ; 
} 
} 

public class NamingEventCoordinator { 
synchronized void addListener ( final String target , final int scope , final NamingListener namingListener ) { 
final TargetScope targetScope = new TargetScope ( target , scope ) ; 
ListenerHolder holder = holdersByListener . get ( namingListener ) ; 
if ( holder == null ) { 
holder = new ListenerHolder ( namingListener , targetScope ) ; 
final Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; 
byListenerCopy . put ( namingListener , holder ) ; 
holdersByListener = byListenerCopy ; 
} 
else holder . addTarget ( targetScope ) ; 
List < ListenerHolder > holdersForTarget = holdersByTarget . get ( targetScope ) ; 
if ( holdersForTarget == null ) { 
holdersForTarget = new CopyOnWriteArrayList < ListenerHolder > ( ) ; 
final Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; 
byTargetCopy . put ( targetScope , holdersForTarget ) ; 
holdersByTarget = byTargetCopy ; 
} 
holdersForTarget . add ( holder ) ; 
} 
} 

public class NamingEventCoordinator { 
synchronized void removeListener ( final NamingListener namingListener ) { 
final ListenerHolder holder = holdersByListener . get ( namingListener ) ; 
if ( holder == null ) return ; 
final Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; 
byListenerCopy . remove ( namingListener ) ; 
holdersByListener = byListenerCopy ; 
final Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; 
for ( TargetScope targetScope : holder . targets ) { 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
holders . remove ( holder ) ; 
if ( holders . isEmpty ( ) ) byTargetCopy . remove ( targetScope ) ; 
} 
holdersByTarget = byTargetCopy ; 
} 
} 

public class NamingEventCoordinator { 
void fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { 
final String target = name . toString ( ) ; 
final Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; 
final NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; 
final Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; 
if ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { 
final TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
if ( holders != null ) for ( ListenerHolder holder : holders ) { 
holdersToFire . add ( holder ) ; 
} 
} 
if ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { 
final TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
if ( holders != null ) for ( ListenerHolder holder : holders ) { 
holdersToFire . add ( holder ) ; 
} 
} 
if ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) for ( int i = 1 ; 
i < name . size ( ) ; 
i ++ ) { 
final Name parentName = name . getPrefix ( i ) ; 
final TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
if ( holders != null ) for ( ListenerHolder holder : holders ) { 
holdersToFire . add ( holder ) ; 
} 
} 
executor . execute ( new FireEventTask ( holdersToFire , event ) ) ; 
} 
} 

public class ElytronSubjectFactory { 
private void addPrivateCredential ( final Subject subject , final Object credential ) { 
if ( ! WildFlySecurityManager . isChecking ( ) ) subject . getPrivateCredentials ( ) . add ( credential ) ; 
else AccessController . doPrivileged ( ( PrivilegedAction < Void > ) ( ) -> { 
subject . getPrivateCredentials ( ) . add ( credential ) ; 
return null ; 
} 
) ; 
} 
} 

public class ObjectFactoryBuilder { 
public Object getObjectInstance ( final Object ref , final Name name , final Context nameCtx , final Hashtable < ? , ? > environment ) throws Exception { 
final ClassLoader classLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; 
if ( classLoader == null ) return ref ; 
final String factoriesProp = ( String ) environment . get ( Context . OBJECT_FACTORIES ) ; 
if ( factoriesProp != null ) { 
final String [ ] classes = factoriesProp . split ( ":" ) ; 
for ( String className : classes ) { 
try { 
final Class < ? > factoryClass = classLoader . loadClass ( className ) ; 
final ObjectFactory objectFactory = ObjectFactory . class . cast ( factoryClass . newInstance ( ) ) ; 
final Object result = objectFactory . getObjectInstance ( ref , name , nameCtx , environment ) ; 
if ( result != null ) return result ; 
} 
catch ( Throwable ignored ) { 
} 
} 
} 
return ref ; 
} 
} 

public class SessionBeanComponentDescription { 
protected static void addTxManagementInterceptorForView ( ViewDescription view ) { 
view . getConfigurators ( ) . add ( new ViewConfigurator ( ) { 
@ Override public void configure ( DeploymentPhaseContext context , ComponentConfiguration componentConfiguration , ViewDescription description , ViewConfiguration configuration ) throws DeploymentUnitProcessingException { 
EJBComponentDescription ejbComponentDescription = ( EJBComponentDescription ) componentConfiguration . getComponentDescription ( ) ; 
if ( TransactionManagementType . CONTAINER . equals ( ejbComponentDescription . getTransactionManagementType ( ) ) ) configuration . addViewInterceptor ( CMTTxInterceptor . FACTORY , InterceptorOrder . View . CMT_TRANSACTION_INTERCEPTOR ) ; 
} 
} 
) ; 
} 
} 

public class ImportJournalOperation { 
private TransportConfiguration createInVMTransportConfiguration ( OperationContext context ) throws OperationFailedException { 
final Resource serverResource = context . readResource ( EMPTY_ADDRESS , false ) ; 
Set < Resource . ResourceEntry > invmConnectors = serverResource . getChildren ( CommonAttributes . IN_VM_CONNECTOR ) ; 
if ( invmConnectors . isEmpty ( ) ) throw MessagingLogger . ROOT_LOGGER . noInVMConnector ( ) ; 
Resource . ResourceEntry connectorEntry = invmConnectors . iterator ( ) . next ( ) ; 
Resource connectorResource = context . readResource ( PathAddress . pathAddress ( connectorEntry . getPathElement ( ) ) , false ) ; 
ModelNode model = connectorResource . getModel ( ) ; 
Map < String , Object > params = new HashMap < > ( CommonAttributes . PARAMS . unwrap ( context , model ) ) ; 
params . put ( InVMTransportDefinition . SERVER_ID . getName ( ) , InVMTransportDefinition . SERVER_ID . resolveModelAttribute ( context , model ) . asInt ( ) ) ; 
TransportConfiguration transportConfiguration = new TransportConfiguration ( InVMConnectorFactory . class . getName ( ) , params ) ; 
return transportConfiguration ; 
} 
} 

public class ResourceAdaptorMergingProcessor { 
private String addEarPrefixIfRelativeName ( final String configuredName , final DeploymentUnit deploymentUnit , final Class < ? > componentClass ) throws DeploymentUnitProcessingException { 
if ( ! configuredName . startsWith ( "#" ) ) return configuredName ; 
final DeploymentUnit parent = deploymentUnit . getParent ( ) ; 
if ( parent == null ) throw EjbLogger . ROOT_LOGGER . relativeResourceAdapterNameInStandaloneModule ( deploymentUnit . getName ( ) , componentClass . getName ( ) , configuredName ) ; 
return new StringBuilder ( ) . append ( parent . getName ( ) ) . append ( configuredName ) . toString ( ) ; 
} 
} 

public class Utils { 
public static DeploymentUnit getRootDeploymentUnit ( DeploymentUnit deploymentUnit ) { 
if ( deploymentUnit . getParent ( ) == null ) return deploymentUnit ; 
return deploymentUnit . getParent ( ) ; 
} 
} 

public class ViewDescription { 
public ServiceName getServiceName ( ) { 
if ( ! viewNameParts . isEmpty ( ) ) return componentDescription . getServiceName ( ) . append ( "VIEW" ) . append ( viewNameParts . toArray ( new String [ viewNameParts . size ( ) ] ) ) ; 
else return componentDescription . getServiceName ( ) . append ( "VIEW" ) . append ( viewClassName ) ; 
} 
} 

public class ViewConfiguration { 
public List < InterceptorFactory > getViewInterceptors ( Method method ) { 
OrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; 
if ( container == null ) return Collections . emptyList ( ) ; 
return container . getSortedItems ( ) ; 
} 
} 

public class ViewConfiguration { 
public void addViewInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { 
OrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; 
if ( container == null ) viewInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; 
container . add ( interceptorFactory , priority ) ; 
} 
} 

public class ViewConfiguration { 
public List < InterceptorFactory > getClientInterceptors ( Method method ) { 
OrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; 
if ( container == null ) return Collections . emptyList ( ) ; 
return container . getSortedItems ( ) ; 
} 
} 

public class ViewConfiguration { 
public void addClientInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { 
OrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; 
if ( container == null ) clientInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; 
container . add ( interceptorFactory , priority ) ; 
} 
} 

public class ASHelper { 
public static ServletMetaData getServletForName ( final JBossWebMetaData jbossWebMD , final String servletName ) { 
for ( JBossServletMetaData servlet : jbossWebMD . getServlets ( ) ) { 
if ( servlet . getName ( ) . equals ( servletName ) ) return servlet ; 
} 
return null ; 
} 
} 

public class ASHelper { 
public static < A > A getRequiredAttachment ( final DeploymentUnit unit , final AttachmentKey < A > key ) { 
final A value = unit . getAttachment ( key ) ; 
if ( value == null ) throw new IllegalStateException ( ) ; 
return value ; 
} 
} 

public class ASHelper { 
public static JBossWebMetaData getJBossWebMetaData ( final DeploymentUnit unit ) { 
final WarMetaData warMetaData = getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; 
JBossWebMetaData result = null ; 
if ( warMetaData != null ) { 
result = warMetaData . getMergedJBossWebMetaData ( ) ; 
if ( result == null ) result = warMetaData . getJBossWebMetaData ( ) ; 
} 
else result = getOptionalAttachment ( unit , WSAttachmentKeys . JBOSSWEB_METADATA_KEY ) ; 
return result ; 
} 
} 

public class ASHelper { 
public static JBossPortComponentMetaData getJBossWebserviceMetaDataPortComponent ( final DeploymentUnit unit , final String name ) { 
if ( name != null ) { 
final JBossWebservicesMetaData jbossWebserviceMetaData = unit . getAttachment ( JBOSS_WEBSERVICES_METADATA_KEY ) ; 
if ( jbossWebserviceMetaData != null ) { 
JBossPortComponentMetaData [ ] portComponent = jbossWebserviceMetaData . getPortComponents ( ) ; 
if ( portComponent != null ) for ( JBossPortComponentMetaData component : portComponent ) { 
if ( name . equals ( component . getEjbName ( ) ) ) return component ; 
} 
} 
} 
return null ; 
} 
} 

public class ASHelper { 
public static EJBEndpoint getWebserviceMetadataEJBEndpoint ( final JAXWSDeployment jaxwsDeployment , final String className ) { 
java . util . List < EJBEndpoint > ejbEndpointList = jaxwsDeployment . getEjbEndpoints ( ) ; 
for ( EJBEndpoint ejbEndpoint : ejbEndpointList ) { 
if ( className . equals ( ejbEndpoint . getClassName ( ) ) ) return ejbEndpoint ; 
} 
return null ; 
} 
} 

public class ASHelper { 
public static String getContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { 
final DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; 
final JBossAppMetaData jbossAppMD = unit . getParent ( ) == null ? null : ASHelper . getOptionalAttachment ( unit . getParent ( ) , WSAttachmentKeys . JBOSS_APP_METADATA_KEY ) ; 
String contextRoot = null ; 
if ( jbossAppMD != null ) { 
final ModuleMetaData moduleMD = jbossAppMD . getModules ( ) . get ( dep . getSimpleName ( ) ) ; 
if ( moduleMD != null ) { 
final WebModuleMetaData webModuleMD = ( WebModuleMetaData ) moduleMD . getValue ( ) ; 
contextRoot = webModuleMD . getContextRoot ( ) ; 
} 
} 
if ( contextRoot == null ) contextRoot = jbossWebMD != null ? jbossWebMD . getContextRoot ( ) : null ; 
return contextRoot ; 
} 
} 

public class WeldModuleResourceLoader { 
@ Override public Class < ? > classForName ( String name ) { 
try { 
if ( classes . containsKey ( name ) ) return classes . get ( name ) ; 
final Class < ? > clazz = module . getClassLoader ( ) . loadClass ( name ) ; 
classes . put ( name , clazz ) ; 
return clazz ; 
} 
catch ( ClassNotFoundException | LinkageError e ) { 
throw new ResourceLoadingException ( e ) ; 
} 
} 
} 

public class WeldModuleResourceLoader { 
@ Override public Collection < URL > getResources ( String name ) { 
try { 
final HashSet < URL > resources = new HashSet < URL > ( ) ; 
Enumeration < URL > urls = module . getClassLoader ( ) . getResources ( name ) ; 
while ( urls . hasMoreElements ( ) ) resources . add ( urls . nextElement ( ) ) ; 
return resources ; 
} 
catch ( Exception e ) { 
throw new ResourceLoadingException ( e ) ; 
} 
} 
} 

public class ServletResourceManager { 
public List < Resource > list ( String path ) { 
try { 
final List < Resource > ret = new ArrayList < > ( ) ; 
Resource res = deploymentResourceManager . getResource ( path ) ; 
if ( res != null ) for ( Resource child : res . list ( ) ) { 
ret . add ( new ServletResource ( this , child ) ) ; 
} 
String p = path ; 
if ( p . startsWith ( "/" ) ) p = p . substring ( 1 ) ; 
if ( overlays != null ) for ( VirtualFile overlay : overlays ) { 
VirtualFile child = overlay . getChild ( p ) ; 
if ( child . exists ( ) ) { 
VirtualFileResource vfsResource = new VirtualFileResource ( overlay . getPhysicalFile ( ) , child , path ) ; 
for ( Resource c : vfsResource . list ( ) ) { 
ret . add ( new ServletResource ( this , c ) ) ; 
} 
} 
} 
return ret ; 
} 
catch ( IOException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class NonTxEmCloser { 
public static void popCall ( ) { 
Map < String , EntityManager > emStack = nonTxStack . pop ( ) ; 
if ( emStack != null ) for ( EntityManager entityManager : emStack . values ( ) ) { 
try { 
if ( entityManager . isOpen ( ) ) entityManager . close ( ) ; 
} 
catch ( RuntimeException safeToIgnore ) { 
if ( ROOT_LOGGER . isTraceEnabled ( ) ) ROOT_LOGGER . trace ( "Could not close (non-transactional) container managed entity manager." + "  This shouldn't impact application functionality (only read " + "operations occur in non-transactional mode)" , safeToIgnore ) ; 
} 
} 
} 
} 

public class NonTxEmCloser { 
public static EntityManager get ( String puScopedName ) { 
Map < String , EntityManager > map = nonTxStack . peek ( ) ; 
if ( map != null ) return map . get ( puScopedName ) ; 
return null ; 
} 
} 

public class WarAnnotationDeploymentProcessor { 
public void deploy ( final DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
if ( ! DeploymentTypeMarker . isType ( DeploymentType . WAR , deploymentUnit ) ) return ; 
WarMetaData warMetaData = deploymentUnit . getAttachment ( WarMetaData . ATTACHMENT_KEY ) ; 
assert warMetaData != null ; 
Map < String , WebMetaData > annotationsMetaData = warMetaData . getAnnotationsMetaData ( ) ; 
if ( annotationsMetaData == null ) { 
annotationsMetaData = new HashMap < String , WebMetaData > ( ) ; 
warMetaData . setAnnotationsMetaData ( annotationsMetaData ) ; 
} 
Map < ResourceRoot , Index > indexes = AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit ) ; 
for ( final Entry < ResourceRoot , Index > entry : indexes . entrySet ( ) ) { 
final Index jarIndex = entry . getValue ( ) ; 
annotationsMetaData . put ( entry . getKey ( ) . getRootName ( ) , processAnnotations ( jarIndex ) ) ; 
} 
Map < ModuleIdentifier , CompositeIndex > additionalModelAnnotations = deploymentUnit . getAttachment ( Attachments . ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE ) ; 
if ( additionalModelAnnotations != null ) { 
final List < WebMetaData > additional = new ArrayList < WebMetaData > ( ) ; 
for ( Entry < ModuleIdentifier , CompositeIndex > entry : additionalModelAnnotations . entrySet ( ) ) { 
for ( Index index : entry . getValue ( ) . getIndexes ( ) ) { 
additional . add ( processAnnotations ( index ) ) ; 
} 
} 
warMetaData . setAdditionalModuleAnnotationsMetadata ( additional ) ; 
} 
} 
} 

public class WSServerConfigAttributeHandler { 
private boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { 
final ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; 
try { 
if ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { 
final boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; 
config . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; 
} 
else if ( WSDL_HOST . equals ( attributeName ) ) { 
final String host = value != null ? value : null ; 
try { 
config . setWebServiceHost ( host , isRevert ) ; 
} 
catch ( final UnknownHostException e ) { 
throw new OperationFailedException ( e . getMessage ( ) , e ) ; 
} 
} 
else if ( WSDL_PORT . equals ( attributeName ) ) { 
final int port = value != null ? Integer . parseInt ( value ) : - 1 ; 
config . setWebServicePort ( port , isRevert ) ; 
} 
else if ( WSDL_SECURE_PORT . equals ( attributeName ) ) { 
final int securePort = value != null ? Integer . parseInt ( value ) : - 1 ; 
config . setWebServiceSecurePort ( securePort , isRevert ) ; 
} 
else if ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { 
final String path = value != null ? value : null ; 
config . setWebServicePathRewriteRule ( path , isRevert ) ; 
} 
else if ( WSDL_URI_SCHEME . equals ( attributeName ) ) if ( value == null || value . equals ( "http" ) || value . equals ( "https" ) ) config . setWebServiceUriScheme ( value , isRevert ) ; 
else throw new IllegalArgumentException ( attributeName + " = " + value ) ; 
else if ( STATISTICS_ENABLED . equals ( attributeName ) ) { 
final boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; 
config . setStatisticsEnabled ( enabled ) ; 
} 
else throw new IllegalArgumentException ( attributeName ) ; 
} 
catch ( DisabledOperationException doe ) { 
if ( ! isRevert ) return false ; 
else throw doe ; 
} 
return true ; 
} 
} 

public class AbstractDeploymentModelBuilder { 
private ArchiveDeployment newDeployment ( final DeploymentUnit unit ) { 
WSLogger . ROOT_LOGGER . tracef ( "Creating new unified WS deployment model for %s" , unit ) ; 
final ResourceRoot deploymentRoot = unit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; 
final VirtualFile root = deploymentRoot != null ? deploymentRoot . getRoot ( ) : null ; 
final ClassLoader classLoader ; 
final Module module = unit . getAttachment ( Attachments . MODULE ) ; 
if ( module == null ) { 
classLoader = unit . getAttachment ( CLASSLOADER_KEY ) ; 
if ( classLoader == null ) throw WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( unit ) ; 
} 
else classLoader = module . getClassLoader ( ) ; 
ArchiveDeployment parentDep = null ; 
if ( unit . getParent ( ) != null ) { 
final Module parentModule = unit . getParent ( ) . getAttachment ( Attachments . MODULE ) ; 
if ( parentModule == null ) throw WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( deploymentRoot ) ; 
WSLogger . ROOT_LOGGER . tracef ( "Creating new unified WS deployment model for %s" , unit . getParent ( ) ) ; 
parentDep = this . newDeployment ( null , unit . getParent ( ) . getName ( ) , parentModule . getClassLoader ( ) , null ) ; 
} 
final UnifiedVirtualFile uvf = root != null ? new VirtualFileAdaptor ( root ) : new ResourceLoaderAdapter ( classLoader ) ; 
final ArchiveDeployment dep = this . newDeployment ( parentDep , unit . getName ( ) , classLoader , uvf ) ; 
dep . addAttachment ( AnnotationsInfo . class , new JandexAnnotationsInfo ( unit ) ) ; 
return dep ; 
} 
} 

public class TimerImpl { 
public void setNextTimeout ( Date next ) { 
if ( next == null ) setTimerState ( TimerState . EXPIRED , null ) ; 
this . nextExpiration = next ; 
} 
} 

public class ResteasyDeploymentData { 
public void merge ( final List < ResteasyDeploymentData > deploymentData ) throws DeploymentUnitProcessingException { 
for ( ResteasyDeploymentData data : deploymentData ) { 
scannedApplicationClasses . addAll ( data . getScannedApplicationClasses ( ) ) ; 
if ( scanResources ) { 
scannedResourceClasses . addAll ( data . getScannedResourceClasses ( ) ) ; 
scannedJndiComponentResources . addAll ( data . getScannedJndiComponentResources ( ) ) ; 
} 
if ( scanProviders ) scannedProviderClasses . addAll ( data . getScannedProviderClasses ( ) ) ; 
} 
} 
} 

public class EJBComponentDescription { 
protected void addRemoteTransactionsDependency ( ) { 
this . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { 
@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration componentConfiguration ) throws DeploymentUnitProcessingException { 
if ( this . hasRemoteView ( ( EJBComponentDescription ) description ) ) componentConfiguration . getCreateDependencies ( ) . add ( ( sb , cs ) -> sb . requires ( TxnServices . JBOSS_TXN_REMOTE_TRANSACTION_SERVICE ) ) ; 
} 
private boolean hasRemoteView ( final EJBComponentDescription ejbComponentDescription ) { 
final Set < ViewDescription > views = ejbComponentDescription . getViews ( ) ; 
for ( final ViewDescription view : views ) { 
if ( ! ( view instanceof EJBViewDescription ) ) continue ; 
final MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; 
if ( viewType == MethodIntf . REMOTE || viewType == MethodIntf . HOME ) return true ; 
} 
return false ; 
} 
} 
) ; 
} 
} 

public class EJBComponentDescription { 
public Set < InterceptorDescription > getAllContainerInterceptors ( ) { 
if ( this . allContainerInterceptors == null ) { 
this . allContainerInterceptors = new HashSet < InterceptorDescription > ( ) ; 
this . allContainerInterceptors . addAll ( this . classLevelContainerInterceptors ) ; 
if ( ! this . excludeDefaultContainerInterceptors ) this . allContainerInterceptors . addAll ( this . defaultContainerInterceptors ) ; 
for ( List < InterceptorDescription > interceptors : this . methodLevelContainerInterceptors . values ( ) ) { 
this . allContainerInterceptors . addAll ( interceptors ) ; 
} 
} 
return this . allContainerInterceptors ; 
} 
} 

public class ApplicableMethodInformation { 
public boolean isMethodLevel ( MethodIntf methodIntf , Method method , MethodIntf defaultMethodIntf ) { 
assert methodIntf != null : "methodIntf is null" ; 
assert method != null : "method is null" ; 
Method classMethod = resolveRealMethod ( method ) ; 
String [ ] methodParams = MethodInfoHelper . getCanonicalParameterTypes ( classMethod ) ; 
final String methodName = classMethod . getName ( ) ; 
final String className = classMethod . getDeclaringClass ( ) . getName ( ) ; 
ArrayKey methodParamsKey = new ArrayKey ( ( Object [ ] ) methodParams ) ; 
T attr = get ( get ( get ( perViewStyle3 , methodIntf ) , methodName ) , methodParamsKey ) ; 
if ( attr != null ) return true ; 
attr = get ( get ( perViewStyle2 , methodIntf ) , methodName ) ; 
if ( attr != null ) return true ; 
attr = get ( perViewStyle1 , methodIntf ) ; 
if ( attr != null ) return false ; 
attr = get ( get ( get ( style3 , className ) , methodName ) , methodParamsKey ) ; 
if ( attr != null ) return true ; 
attr = get ( style2 , methodName ) ; 
if ( attr != null ) return true ; 
attr = get ( style1 , className ) ; 
if ( attr != null ) return false ; 
if ( defaultMethodIntf == null ) return false ; 
else return isMethodLevel ( defaultMethodIntf , method , null ) ; 
} 
} 

public class MessagingSubsystemParser { 
protected static void checkOnlyOneOfElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { 
if ( ! seen . contains ( element1 ) && ! seen . contains ( element2 ) ) throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . required ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; 
if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; 
} 
} 

public class AbstractConfigVisitorNode { 
protected static Class < ? > getType ( ConfigVisitor visitor , String className ) { 
if ( className != null ) try { 
return visitor . getModule ( ) . getClassLoader ( ) . loadClass ( className ) ; 
} 
catch ( Exception e ) { 
throw new IllegalArgumentException ( e ) ; 
} 
return null ; 
} 
} 

public class ElytronIntegrationResourceDefinitions { 
public static ResourceDefinition getElytronKeyStoreResourceDefinition ( ) { 
final AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { 
LEGACY_JSSE_CONFIG } 
; 
final AbstractAddStepHandler addHandler = new BasicAddHandler < KeyStore > ( attributes , KEY_STORE_RUNTIME_CAPABILITY ) { 
@ Override protected BasicService . ValueSupplier < KeyStore > getValueSupplier ( ServiceBuilder < KeyStore > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { 
final String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; 
final InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; 
if ( legacyJSSEConfig != null ) serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; 
return ( ) -> { 
final SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; 
final JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; 
if ( jsseDomain == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; 
final KeyStore keyStore = jsseDomain . getKeyStore ( ) ; 
if ( keyStore == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( "KeyStore" , legacyJSSEConfig ) ; 
return keyStore ; 
} 
; 
} 
} 
; 
return new BasicResourceDefinition ( Constants . ELYTRON_KEY_STORE , addHandler , attributes , KEY_STORE_RUNTIME_CAPABILITY ) ; 
} 
} 

public class ElytronIntegrationResourceDefinitions { 
public static ResourceDefinition getElytronKeyManagersResourceDefinition ( ) { 
final AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { 
LEGACY_JSSE_CONFIG } 
; 
final AbstractAddStepHandler addHandler = new BasicAddHandler < KeyManager > ( attributes , KEY_MANAGER_RUNTIME_CAPABILITY ) { 
@ Override protected BasicService . ValueSupplier < KeyManager > getValueSupplier ( ServiceBuilder < KeyManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { 
final String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; 
final InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; 
if ( legacyJSSEConfig != null ) serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; 
return ( ) -> { 
final SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; 
final JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; 
if ( jsseDomain == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; 
final KeyManager [ ] keyManagers = jsseDomain . getKeyManagers ( ) ; 
if ( keyManagers == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( "KeyManager" , legacyJSSEConfig ) ; 
for ( KeyManager keyManager : keyManagers ) { 
if ( keyManager instanceof X509ExtendedKeyManager ) return keyManager ; 
} 
throw SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( "KeyManager" , X509ExtendedKeyManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; 
} 
; 
} 
} 
; 
return new BasicResourceDefinition ( Constants . ELYTRON_KEY_MANAGER , addHandler , attributes , KEY_MANAGER_RUNTIME_CAPABILITY ) ; 
} 
} 

public class ElytronIntegrationResourceDefinitions { 
public static ResourceDefinition getElytronTrustManagersResourceDefinition ( ) { 
final AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { 
LEGACY_JSSE_CONFIG } 
; 
final AbstractAddStepHandler addHandler = new BasicAddHandler < TrustManager > ( attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) { 
@ Override protected BasicService . ValueSupplier < TrustManager > getValueSupplier ( ServiceBuilder < TrustManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { 
final String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; 
final InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue < > ( ) ; 
if ( legacyJSSEConfig != null ) serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; 
return ( ) -> { 
final SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; 
final JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; 
if ( jsseDomain == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; 
final TrustManager [ ] trustManagers = jsseDomain . getTrustManagers ( ) ; 
if ( trustManagers == null ) throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( "TrustManager" , legacyJSSEConfig ) ; 
for ( TrustManager trustManager : trustManagers ) { 
if ( trustManager instanceof X509ExtendedTrustManager ) return trustManager ; 
} 
throw SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( "TrustManager" , X509ExtendedTrustManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; 
} 
; 
} 
} 
; 
return new BasicResourceDefinition ( Constants . ELYTRON_TRUST_MANAGER , addHandler , attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) ; 
} 
} 

public class CNNameParser { 
private static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { 
int len = str . length ( ) ; 
Vector components = new Vector ( 10 ) ; 
char [ ] id = new char [ len ] ; 
char [ ] kind = new char [ len ] ; 
int idCount , kindCount ; 
boolean idMode ; 
for ( int i = 0 ; 
i < len ; 
) { 
idCount = kindCount = 0 ; 
idMode = true ; 
while ( i < len ) if ( str . charAt ( i ) == compSeparator ) break ; 
else if ( str . charAt ( i ) == escapeChar ) if ( i + 1 >= len ) throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; 
else if ( isMeta ( str . charAt ( i + 1 ) ) ) { 
++ i ; 
if ( idMode ) id [ idCount ++ ] = str . charAt ( i ++ ) ; 
else kind [ kindCount ++ ] = str . charAt ( i ++ ) ; 
} 
else throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; 
else if ( idMode && str . charAt ( i ) == kindSeparator ) { 
++ i ; 
idMode = false ; 
} 
else if ( idMode ) id [ idCount ++ ] = str . charAt ( i ++ ) ; 
else kind [ kindCount ++ ] = str . charAt ( i ++ ) ; 
components . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; 
if ( i < len ) ++ i ; 
} 
return components ; 
} 
} 

public class CNNameParser { 
private static NameComponent parseComponent ( String compStr ) throws InvalidNameException { 
NameComponent comp = new NameComponent ( ) ; 
int kindSep = - 1 ; 
int len = compStr . length ( ) ; 
int j = 0 ; 
char [ ] newStr = new char [ len ] ; 
boolean escaped = false ; 
for ( int i = 0 ; 
i < len && kindSep < 0 ; 
i ++ ) if ( escaped ) { 
newStr [ j ++ ] = compStr . charAt ( i ) ; 
escaped = false ; 
} 
else if ( compStr . charAt ( i ) == escapeChar ) if ( i + 1 >= len ) throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; 
else if ( isMeta ( compStr . charAt ( i + 1 ) ) ) escaped = true ; 
else throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; 
else if ( compStr . charAt ( i ) == kindSeparator ) kindSep = i ; 
else newStr [ j ++ ] = compStr . charAt ( i ) ; 
comp . id = new String ( newStr , 0 , j ) ; 
if ( kindSep < 0 ) comp . kind = "" ; 
else { 
j = 0 ; 
escaped = false ; 
for ( int i = kindSep + 1 ; 
i < len ; 
i ++ ) if ( escaped ) { 
newStr [ j ++ ] = compStr . charAt ( i ) ; 
escaped = false ; 
} 
else if ( compStr . charAt ( i ) == escapeChar ) if ( i + 1 >= len ) throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; 
else if ( isMeta ( compStr . charAt ( i + 1 ) ) ) escaped = true ; 
else throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; 
else newStr [ j ++ ] = compStr . charAt ( i ) ; 
comp . kind = new String ( newStr , 0 , j ) ; 
} 
return comp ; 
} 
} 

public class ElytronSecurityManager { 
private SecurityIdentity authenticate ( final String username , final String password ) { 
ServerAuthenticationContext context = this . securityDomain . createNewAuthenticationContext ( ) ; 
PasswordGuessEvidence evidence = null ; 
try { 
if ( password == null ) if ( username == null ) if ( context . authorizeAnonymous ( ) ) { 
context . succeed ( ) ; 
return context . getAuthorizedIdentity ( ) ; 
} 
else { 
context . fail ( ) ; 
return null ; 
} 
else { 
context . fail ( ) ; 
return null ; 
} 
context . setAuthenticationName ( username ) ; 
evidence = new PasswordGuessEvidence ( password . toCharArray ( ) ) ; 
if ( context . verifyEvidence ( evidence ) ) if ( context . authorize ( ) ) { 
context . succeed ( ) ; 
return context . getAuthorizedIdentity ( ) ; 
} 
else { 
context . fail ( ) ; 
MessagingLogger . ROOT_LOGGER . failedAuthorization ( username ) ; 
} 
else { 
context . fail ( ) ; 
MessagingLogger . ROOT_LOGGER . failedAuthentication ( username ) ; 
} 
} 
catch ( IllegalArgumentException | IllegalStateException | RealmUnavailableException e ) { 
context . fail ( ) ; 
MessagingLogger . ROOT_LOGGER . failedAuthenticationWithException ( e , username , e . getMessage ( ) ) ; 
} 
finally { 
if ( evidence != null ) evidence . destroy ( ) ; 
} 
return null ; 
} 
} 

public class GetDataSourceClassInfoOperationHandler { 
private static boolean isTypeMatched ( Class < ? > clz ) { 
if ( clz . equals ( String . class ) ) return true ; 
else if ( clz . equals ( byte . class ) || clz . equals ( Byte . class ) ) return true ; 
else if ( clz . equals ( short . class ) || clz . equals ( Short . class ) ) return true ; 
else if ( clz . equals ( int . class ) || clz . equals ( Integer . class ) ) return true ; 
else if ( clz . equals ( long . class ) || clz . equals ( Long . class ) ) return true ; 
else if ( clz . equals ( float . class ) || clz . equals ( Float . class ) ) return true ; 
else if ( clz . equals ( double . class ) || clz . equals ( Double . class ) ) return true ; 
else if ( clz . equals ( boolean . class ) || clz . equals ( Boolean . class ) ) return true ; 
else if ( clz . equals ( char . class ) || clz . equals ( Character . class ) ) return true ; 
else if ( clz . equals ( InetAddress . class ) ) return true ; 
else if ( clz . equals ( Class . class ) ) return true ; 
else if ( clz . equals ( Properties . class ) ) return true ; 
return false ; 
} 
} 

public class WildFlyBindingRegistry { 
@ Override public Object lookup ( String name ) { 
final ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; 
ServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; 
if ( bindingService == null ) return null ; 
ManagedReferenceFactory managedReferenceFactory = ManagedReferenceFactory . class . cast ( bindingService . getValue ( ) ) ; 
return managedReferenceFactory . getReference ( ) . getInstance ( ) ; 
} 
} 

public class WildFlyBindingRegistry { 
@ Override public void unbind ( String name ) { 
if ( name == null || name . isEmpty ( ) ) throw MessagingLogger . ROOT_LOGGER . cannotUnbindJndiName ( ) ; 
final ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; 
ServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; 
if ( bindingService == null ) { 
ROOT_LOGGER . debugf ( "Cannot unbind %s since no binding exists with that name" , name ) ; 
return ; 
} 
bindingService . setMode ( ServiceController . Mode . REMOVE ) ; 
final StabilityMonitor monitor = new StabilityMonitor ( ) ; 
monitor . addController ( bindingService ) ; 
try { 
monitor . awaitStability ( ) ; 
ROOT_LOGGER . unboundJndiName ( bindInfo . getAbsoluteJndiName ( ) ) ; 
} 
catch ( InterruptedException e ) { 
ROOT_LOGGER . failedToUnbindJndiName ( name , 5 , SECONDS . toString ( ) . toLowerCase ( Locale . US ) ) ; 
} 
finally { 
monitor . removeController ( bindingService ) ; 
} 
} 
} 

public class NamespaceContextSelector { 
public static NamespaceContextSelector getCurrentSelector ( ) { 
NamespaceContextSelector selector = currentSelector . peek ( ) ; 
if ( selector != null ) return selector ; 
return defaultSelector ; 
} 
} 

public class EEApplicationClasses { 
public EEModuleClassDescription getClassByName ( String name ) { 
for ( EEModuleDescription module : availableModules ) { 
final EEModuleClassDescription desc = module . getClassDescription ( name ) ; 
if ( desc != null ) return desc ; 
} 
return null ; 
} 
} 

public class SessionBeanComponentDescriptionFactory { 
@ Override protected void processAnnotations ( final DeploymentUnit deploymentUnit , final CompositeIndex compositeIndex ) throws DeploymentUnitProcessingException { 
if ( MetadataCompleteMarker . isMetadataComplete ( deploymentUnit ) ) return ; 
final List < AnnotationInstance > slsbAnnotations = compositeIndex . getAnnotations ( STATELESS_ANNOTATION ) ; 
if ( ! slsbAnnotations . isEmpty ( ) ) processSessionBeans ( deploymentUnit , slsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATELESS ) ; 
final List < AnnotationInstance > sfsbAnnotations = compositeIndex . getAnnotations ( STATEFUL_ANNOTATION ) ; 
if ( ! sfsbAnnotations . isEmpty ( ) ) processSessionBeans ( deploymentUnit , sfsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATEFUL ) ; 
final List < AnnotationInstance > sbAnnotations = compositeIndex . getAnnotations ( SINGLETON_ANNOTATION ) ; 
if ( ! sbAnnotations . isEmpty ( ) ) processSessionBeans ( deploymentUnit , sbAnnotations , SessionBeanComponentDescription . SessionBeanType . SINGLETON ) ; 
} 
} 

public class PersistenceUnitParseProcessor { 
private void postParseSteps ( final VirtualFile persistence_xml , final PersistenceUnitMetadataHolder puHolder , final DeploymentUnit deploymentUnit ) { 
for ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { 
List < URL > jarfilesUrls = new ArrayList < URL > ( ) ; 
if ( pu . getJarFiles ( ) != null ) for ( String jar : pu . getJarFiles ( ) ) { 
jarfilesUrls . add ( getRelativeURL ( persistence_xml , jar ) ) ; 
} 
pu . setJarFileUrls ( jarfilesUrls ) ; 
URL url = getPersistenceUnitURL ( persistence_xml ) ; 
pu . setPersistenceUnitRootUrl ( url ) ; 
String scopedPersistenceUnitName ; 
scopedPersistenceUnitName = Configuration . getScopedPersistenceUnitName ( pu ) ; 
if ( scopedPersistenceUnitName == null ) scopedPersistenceUnitName = createBeanName ( deploymentUnit , pu . getPersistenceUnitName ( ) ) ; 
else { 
ROOT_LOGGER . tracef ( "persistence unit '%s' specified a custom scoped persistence unit name hint " + "(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments." , pu . getPersistenceUnitName ( ) , scopedPersistenceUnitName ) ; 
if ( scopedPersistenceUnitName . indexOf ( '/' ) != - 1 ) throw JpaLogger . ROOT_LOGGER . invalidScopedName ( scopedPersistenceUnitName , '/' ) ; 
} 
pu . setScopedPersistenceUnitName ( scopedPersistenceUnitName ) ; 
} 
} 
} 

public class DescriptorUtils { 
public static String validateDescriptor ( String descriptor ) { 
if ( descriptor . length ( ) == 0 ) throw EeLogger . ROOT_LOGGER . cannotBeEmpty ( "descriptors" ) ; 
if ( descriptor . length ( ) > 1 ) if ( descriptor . startsWith ( "L" ) ) if ( ! descriptor . endsWith ( ";" ) ) throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; 
else if ( descriptor . startsWith ( "[" ) ) { 
} 
else throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; 
else { 
char type = descriptor . charAt ( 0 ) ; 
switch ( type ) { 
case 'I' : case 'Z' : case 'S' : case 'B' : case 'F' : case 'D' : case 'V' : case 'J' : case 'C' : break ; 
default : throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; 
} 
} 
return descriptor ; 
} 
} 

public class WebMetaDataCreator { 
void create ( final Deployment dep ) { 
final DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; 
WarMetaData warMD = ASHelper . getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; 
JBossWebMetaData jbossWebMD = warMD != null ? warMD . getMergedJBossWebMetaData ( ) : null ; 
if ( warMD == null ) warMD = new WarMetaData ( ) ; 
if ( jbossWebMD == null ) { 
jbossWebMD = new JBossWebMetaData ( ) ; 
warMD . setMergedJBossWebMetaData ( jbossWebMD ) ; 
unit . putAttachment ( WarMetaData . ATTACHMENT_KEY , warMD ) ; 
} 
createWebAppDescriptor ( dep , jbossWebMD ) ; 
createJBossWebAppDescriptor ( dep , jbossWebMD ) ; 
dep . addAttachment ( JBossWebMetaData . class , jbossWebMD ) ; 
} 
} 

public class WebMetaDataCreator { 
private String getAuthMethod ( final Deployment dep ) { 
for ( final Endpoint ejbEndpoint : dep . getService ( ) . getEndpoints ( ) ) { 
final String beanAuthMethod = ejb3SecurityAccessor . getAuthMethod ( ejbEndpoint ) ; 
final boolean hasBeanAuthMethod = beanAuthMethod != null ; 
if ( hasBeanAuthMethod ) return beanAuthMethod ; 
} 
return null ; 
} 
} 

public class ServiceDeploymentParsingProcessor { 
public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
final VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; 
if ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; 
VirtualFile serviceXmlFile = null ; 
if ( deploymentRoot . isDirectory ( ) ) serviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; 
else if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) serviceXmlFile = deploymentRoot ; 
if ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; 
final XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; 
final JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; 
xmlMapper . registerRootElement ( new QName ( "urn:jboss:service:7.0" , "server" ) , jBossServiceXmlDescriptorParser ) ; 
xmlMapper . registerRootElement ( new QName ( null , "server" ) , jBossServiceXmlDescriptorParser ) ; 
InputStream xmlStream = null ; 
try { 
xmlStream = serviceXmlFile . openStream ( ) ; 
final XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; 
final ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; 
xmlMapper . parseDocument ( result , reader ) ; 
final JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; 
if ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; 
else throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; 
} 
catch ( Exception e ) { 
throw SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; 
} 
finally { 
VFSUtils . safeClose ( xmlStream ) ; 
} 
} 
} 

public class DynamicStubFactoryFactory { 
public static Class < ? > makeStubClass ( final Class < ? > myClass ) { 
final String stubClassName = myClass + "_Stub" ; 
ClassLoader cl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; 
if ( cl == null ) cl = myClass . getClassLoader ( ) ; 
if ( cl == null ) throw EjbLogger . ROOT_LOGGER . couldNotFindClassLoaderForStub ( stubClassName ) ; 
Class < ? > theClass ; 
try { 
theClass = cl . loadClass ( stubClassName ) ; 
} 
catch ( ClassNotFoundException e ) { 
try { 
final ClassFile clazz = IIOPStubCompiler . compile ( myClass , stubClassName ) ; 
theClass = clazz . define ( cl , myClass . getProtectionDomain ( ) ) ; 
} 
catch ( Throwable ex ) { 
try { 
theClass = cl . loadClass ( stubClassName ) ; 
} 
catch ( ClassNotFoundException e1 ) { 
EjbLogger . ROOT_LOGGER . dynamicStubCreationFailed ( stubClassName , ex ) ; 
throw ex ; 
} 
} 
} 
return theClass ; 
} 
} 

public class PersistenceProviderResolverImpl { 
@ Override public List < PersistenceProvider > getPersistenceProviders ( ) { 
List < PersistenceProvider > providersCopy = new ArrayList < > ( providers . size ( ) ) ; 
synchronized ( persistenceProviderPerClassLoader ) { 
if ( persistenceProviderPerClassLoader . size ( ) > 0 ) { 
ClassLoader deploymentClassLoader = findParentModuleCl ( WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ) ; 
ROOT_LOGGER . tracef ( "get application level Persistence Provider for classloader %s" , deploymentClassLoader ) ; 
List < Class < ? extends PersistenceProvider > > deploymentSpecificPersistenceProviders = persistenceProviderPerClassLoader . get ( deploymentClassLoader ) ; 
ROOT_LOGGER . tracef ( "got application level Persistence Provider list %s" , deploymentSpecificPersistenceProviders ) ; 
if ( deploymentSpecificPersistenceProviders != null ) for ( Class < ? extends PersistenceProvider > providerClass : deploymentSpecificPersistenceProviders ) { 
try { 
ROOT_LOGGER . tracef ( "application has its own Persistence Provider %s" , providerClass . getName ( ) ) ; 
providersCopy . add ( providerClass . newInstance ( ) ) ; 
} 
catch ( InstantiationException e ) { 
throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; 
} 
catch ( IllegalAccessException e ) { 
throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; 
} 
} 
} 
} 
for ( Class < ? > providerClass : providers ) { 
try { 
providersCopy . add ( ( PersistenceProvider ) providerClass . newInstance ( ) ) ; 
ROOT_LOGGER . tracef ( "returning global (module) Persistence Provider %s" , providerClass . getName ( ) ) ; 
} 
catch ( InstantiationException e ) { 
throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; 
} 
catch ( IllegalAccessException e ) { 
throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; 
} 
} 
return providersCopy ; 
} 
} 

public class PersistenceProviderResolverImpl { 
private ClassLoader findParentModuleCl ( ClassLoader classLoader ) { 
ClassLoader c = classLoader ; 
while ( c != null && ! ( c instanceof ModuleClassLoader ) ) c = c . getParent ( ) ; 
return c ; 
} 
} 

public class SarModuleDependencyProcessor { 
public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; 
final JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit . getAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY ) ; 
if ( serviceXmlDescriptor == null ) return ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_MODULES_ID , false , false , false , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_AS_SYSTEM_JMX_ID , true , false , false , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , PROPERTIES_EDITOR_MODULE_ID , false , false , true , false ) ) ; 
moduleSpecification . addPermissionFactory ( REGISTER_PERMISSION_FACTORY ) ; 
} 
} 

public class PersistenceUnitServiceHandler { 
private static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { 
if ( puList . size ( ) > 0 ) { 
final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
final Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; 
final EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; 
final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; 
final ModuleClassLoader classLoader = module . getClassLoader ( ) ; 
for ( PersistenceUnitMetadataHolder holder : puList ) { 
setAnnotationIndexes ( holder , deploymentUnit ) ; 
for ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { 
String jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; 
boolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; 
if ( deployPU ) { 
final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; 
final PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; 
final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; 
final boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; 
if ( startEarly ) if ( twoPhaseBootStrapCapable ) deployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; 
else if ( false == Configuration . needClassFileTransformer ( pu ) ) ROOT_LOGGER . tracef ( "persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; 
else { 
final boolean allowCdiBeanManagerAccess = false ; 
deployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; 
} 
else if ( twoPhaseBootStrapCapable ) deployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; 
else if ( false == Configuration . needClassFileTransformer ( pu ) ) { 
final boolean allowCdiBeanManagerAccess = true ; 
deployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; 
} 
} 
else ROOT_LOGGER . tracef ( "persistence unit %s in deployment %s is not container managed (%s is set to false)" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; 
} 
} 
} 
} 
} 

public class PersistenceUnitServiceHandler { 
private static void setAnnotationIndexes ( final PersistenceUnitMetadataHolder puHolder , DeploymentUnit deploymentUnit ) { 
final Map < URL , Index > annotationIndexes = new HashMap < > ( ) ; 
do { 
for ( ResourceRoot root : DeploymentUtils . allResourceRoots ( deploymentUnit ) ) { 
final Index index = root . getAttachment ( Attachments . ANNOTATION_INDEX ) ; 
if ( index != null ) try { 
ROOT_LOGGER . tracef ( "adding '%s' to annotation index map" , root . getRoot ( ) . toURL ( ) ) ; 
annotationIndexes . put ( root . getRoot ( ) . toURL ( ) , index ) ; 
} 
catch ( MalformedURLException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
deploymentUnit = deploymentUnit . getParent ( ) ; 
} 
while ( deploymentUnit != null ) ; 
for ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { 
pu . setAnnotationIndex ( annotationIndexes ) ; 
} 
} 
} 

public class PersistenceUnitServiceHandler { 
private static PersistenceProviderAdaptor getPersistenceProviderAdaptor ( final PersistenceUnitMetadata pu , final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , final DeploymentUnit deploymentUnit , final PersistenceProvider provider , final Platform platform ) throws DeploymentUnitProcessingException { 
String adapterClass = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_CLASS ) ; 
if ( persistenceProviderDeploymentHolder != null && adapterClass != null ) { 
List < PersistenceProviderAdaptor > persistenceProviderAdaptors = persistenceProviderDeploymentHolder . getAdapters ( ) ; 
for ( PersistenceProviderAdaptor persistenceProviderAdaptor : persistenceProviderAdaptors ) { 
if ( adapterClass . equals ( persistenceProviderAdaptor . getClass ( ) . getName ( ) ) ) return persistenceProviderAdaptor ; 
} 
} 
String adaptorModule = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_MODULE ) ; 
PersistenceProviderAdaptor adaptor ; 
adaptor = getPerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , provider ) ; 
if ( adaptor == null ) { 
try { 
if ( adaptorModule != null ) adaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapterModule ( adaptorModule , platform , createManager ( deploymentUnit ) ) ; 
else adaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapter ( provider , platform , createManager ( deploymentUnit ) ) ; 
} 
catch ( ModuleLoadException e ) { 
throw JpaLogger . ROOT_LOGGER . persistenceProviderAdaptorModuleLoadError ( e , adaptorModule ) ; 
} 
adaptor = savePerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , adaptor , provider ) ; 
} 
if ( adaptor == null ) throw JpaLogger . ROOT_LOGGER . failedToGetAdapter ( pu . getPersistenceProviderClassName ( ) ) ; 
return adaptor ; 
} 
} 

public class PersistenceUnitServiceHandler { 
private static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor ( DeploymentUnit deploymentUnit , String adaptorModule , PersistenceProviderAdaptor adaptor , PersistenceProvider provider ) { 
if ( deploymentUnit . getParent ( ) != null ) deploymentUnit = deploymentUnit . getParent ( ) ; 
synchronized ( deploymentUnit ) { 
Map < String , PersistenceProviderAdaptor > map = deploymentUnit . getAttachment ( providerAdaptorMapKey ) ; 
String key ; 
if ( adaptorModule != null ) key = adaptorModule ; 
else key = provider . getClass ( ) . getName ( ) ; 
PersistenceProviderAdaptor current = map . get ( key ) ; 
if ( current == null ) { 
map . put ( key , adaptor ) ; 
current = adaptor ; 
} 
return current ; 
} 
} 
} 

public class PersistenceUnitServiceHandler { 
private static PersistenceProvider lookupProvider ( PersistenceUnitMetadata pu , PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { 
Map < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; 
if ( providerMap != null ) synchronized ( providerMap ) { 
if ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { 
ROOT_LOGGER . tracef ( "deployment %s is using %s" , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; 
return providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; 
} 
} 
String configuredPersistenceProviderModule = pu . getProperties ( ) . getProperty ( Configuration . PROVIDER_MODULE ) ; 
String persistenceProviderClassName = pu . getPersistenceProviderClassName ( ) ; 
if ( persistenceProviderClassName == null ) persistenceProviderClassName = Configuration . PROVIDER_CLASS_DEFAULT ; 
if ( configuredPersistenceProviderModule != null ) { 
List < PersistenceProvider > providers ; 
if ( Configuration . PROVIDER_MODULE_APPLICATION_SUPPLIED . equals ( configuredPersistenceProviderModule ) ) try { 
final ModuleClassLoader classLoader = deploymentUnit . getAttachment ( Attachments . MODULE ) . getClassLoader ( ) ; 
PersistenceProvider provider = PersistenceProviderLoader . loadProviderFromDeployment ( classLoader , persistenceProviderClassName ) ; 
providers = new ArrayList < > ( ) ; 
providers . add ( provider ) ; 
PersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; 
return provider ; 
} 
catch ( ClassNotFoundException e ) { 
throw JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; 
} 
catch ( InstantiationException e ) { 
throw JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; 
} 
catch ( IllegalAccessException e ) { 
throw JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; 
} 
else try { 
providers = PersistenceProviderLoader . loadProviderModuleByName ( configuredPersistenceProviderModule ) ; 
PersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; 
PersistenceProvider provider = getProviderByName ( pu , providers ) ; 
if ( provider != null ) return provider ; 
} 
catch ( ModuleLoadException e ) { 
throw JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , configuredPersistenceProviderModule , persistenceProviderClassName ) ; 
} 
} 
String providerNameDerivedFromClassName = Configuration . getProviderModuleNameFromProviderClassName ( persistenceProviderClassName ) ; 
PersistenceProvider provider = getProviderByName ( pu ) ; 
if ( provider == null && providerNameDerivedFromClassName != null ) try { 
List < PersistenceProvider > providers = PersistenceProviderLoader . loadProviderModuleByName ( providerNameDerivedFromClassName ) ; 
PersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; 
provider = getProviderByName ( pu , providers ) ; 
} 
catch ( ModuleLoadException e ) { 
throw JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , providerNameDerivedFromClassName , persistenceProviderClassName ) ; 
} 
if ( provider == null ) throw JpaLogger . ROOT_LOGGER . persistenceProviderNotFound ( persistenceProviderClassName ) ; 
return provider ; 
} 
} 

public class AbstractMetaDataBuilderEJB { 
final EJBArchiveMetaData create ( final Deployment dep ) { 
if ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) WSLogger . ROOT_LOGGER . tracef ( "Building JBoss agnostic meta data for EJB webservice deployment: %s" , dep . getSimpleName ( ) ) ; 
final EJBArchiveMetaData . Builder ejbArchiveMDBuilder = new EJBArchiveMetaData . Builder ( ) ; 
this . buildEnterpriseBeansMetaData ( dep , ejbArchiveMDBuilder ) ; 
this . buildWebservicesMetaData ( dep , ejbArchiveMDBuilder ) ; 
return ejbArchiveMDBuilder . build ( ) ; 
} 
} 

public class WorkCacheManager { 
ContainerAnalysis getAnalysis ( final Class cls ) throws RMIIIOPViolationException { 
ContainerAnalysis ret = null ; 
boolean created = false ; 
try { 
synchronized ( this ) { 
ret = lookupDone ( cls ) ; 
if ( ret != null ) return ret ; 
final ContainerAnalysis inProgress = workInProgress . get ( new InProgressKey ( cls , Thread . currentThread ( ) ) ) ; 
if ( inProgress != null ) return inProgress ; 
ret = createWorkInProgress ( cls ) ; 
} 
created = true ; 
doTheWork ( cls , ret ) ; 
} 
finally { 
synchronized ( this ) { 
if ( created ) { 
workInProgress . remove ( new InProgressKey ( cls , Thread . currentThread ( ) ) ) ; 
workDone . put ( cls , new SoftReference < ContainerAnalysis > ( ret ) ) ; 
ClassLoader classLoader = cls . getClassLoader ( ) ; 
if ( classLoader != null ) { 
Set < Class < ? > > classes = classesByLoader . get ( classLoader ) ; 
if ( classes == null ) classesByLoader . put ( classLoader , classes = new HashSet < Class < ? > > ( ) ) ; 
classes . add ( cls ) ; 
} 
} 
notifyAll ( ) ; 
} 
} 
return ret ; 
} 
} 

public class ContainerAnalysis { 
protected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { 
for ( int i = 0 ; 
i < methods . length ; 
++ i ) { 
if ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; 
OperationAnalysis oa = null ; 
String javaName = methods [ i ] . getName ( ) ; 
for ( int opIdx = 0 ; 
oa == null && opIdx < operations . length ; 
++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; 
if ( oa == null ) continue ; 
ParameterAnalysis [ ] params = oa . getParameters ( ) ; 
StringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; 
if ( params . length == 0 ) b . append ( "__" ) ; 
for ( int j = 0 ; 
j < params . length ; 
++ j ) { 
String s = params [ j ] . getTypeIDLName ( ) ; 
if ( s . startsWith ( "::" ) ) s = s . substring ( 2 ) ; 
if ( s . startsWith ( "_" ) ) s = s . substring ( 1 ) ; 
b . append ( '_' ) ; 
while ( ! "" . equals ( s ) ) { 
int idx = s . indexOf ( "::" ) ; 
b . append ( '_' ) ; 
if ( idx == - 1 ) { 
b . append ( s ) ; 
s = "" ; 
} 
else { 
b . append ( s . substring ( 0 , idx ) ) ; 
if ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) s = s . substring ( idx + 3 ) ; 
else s = s . substring ( idx + 2 ) ; 
} 
} 
} 
oa . setIDLName ( b . toString ( ) ) ; 
} 
} 
} 

public class ContainerAnalysis { 
protected void fixupCaseNames ( ) throws RMIIIOPViolationException { 
ArrayList entries = getContainedEntries ( ) ; 
boolean [ ] clash = new boolean [ entries . size ( ) ] ; 
String [ ] upperNames = new String [ entries . size ( ) ] ; 
for ( int i = 0 ; 
i < entries . size ( ) ; 
++ i ) { 
AbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; 
clash [ i ] = false ; 
upperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; 
for ( int j = 0 ; 
j < i ; 
++ j ) if ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { 
clash [ i ] = true ; 
clash [ j ] = true ; 
} 
} 
for ( int i = 0 ; 
i < entries . size ( ) ; 
++ i ) { 
if ( ! clash [ i ] ) continue ; 
AbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; 
boolean noUpper = true ; 
String name = aa . getIDLName ( ) ; 
StringBuffer b = new StringBuffer ( name ) ; 
b . append ( '_' ) ; 
for ( int j = 0 ; 
j < name . length ( ) ; 
++ j ) { 
if ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; 
if ( noUpper ) noUpper = false ; 
else b . append ( '_' ) ; 
b . append ( j ) ; 
} 
aa . setIDLName ( b . toString ( ) ) ; 
} 
} 
} 

public class XTSSubsystemParser { 
private void parseDefaultContextPropagationElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { 
processAttributes ( reader , ( index , attribute ) -> { 
final String value = reader . getAttributeValue ( index ) ; 
switch ( attribute ) { 
case ENABLED : if ( value == null || ( ! value . toLowerCase ( ) . equals ( "true" ) && ! value . toLowerCase ( ) . equals ( "false" ) ) ) throw ParseUtils . invalidAttributeValue ( reader , index ) ; 
DEFAULT_CONTEXT_PROPAGATION . parseAndSetParameter ( value , subsystem , reader ) ; 
break ; 
default : throw ParseUtils . unexpectedAttribute ( reader , index ) ; 
} 
} 
) ; 
ParseUtils . requireNoContent ( reader ) ; 
} 
} 

public class PersistenceProviderLoader { 
public static List < PersistenceProvider > loadProviderModuleByName ( String moduleName ) throws ModuleLoadException { 
final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; 
Module module = moduleLoader . loadModule ( ModuleIdentifier . fromString ( moduleName ) ) ; 
final ServiceLoader < PersistenceProvider > serviceLoader = module . loadService ( PersistenceProvider . class ) ; 
List < PersistenceProvider > result = new ArrayList < > ( ) ; 
if ( serviceLoader != null ) for ( PersistenceProvider provider1 : serviceLoader ) { 
PersistenceProviderResolverImpl . getInstance ( ) . addPersistenceProvider ( provider1 ) ; 
result . add ( provider1 ) ; 
} 
return result ; 
} 
} 

public class ManagementHelper { 
static AbstractAddStepHandler createAddOperation ( final String childType , final boolean allowSibling , Collection < ? extends AttributeDefinition > attributes ) { 
return new ActiveMQReloadRequiredHandlers . AddStepHandler ( attributes ) { 
@ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { 
super . execute ( context , operation ) ; 
if ( ! allowSibling ) context . addStep ( checkNoOtherSibling ( childType ) , MODEL ) ; 
} 
} 
; 
} 
} 

public class EjbDependencyDeploymentUnitProcessor { 
@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { 
DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; 
final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; 
final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_API , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , JAX_RPC_API , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_CLIENT , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_NAMING_CLIENT , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_IIOP_CLIENT , false , false , false , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_SUBSYSTEM , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_EJB , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_NAMING , false , false , true , false ) ) ; 
moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_TRANSACTION , false , false , true , false ) ) ; 
if ( IIOPDeploymentMarker . isIIOPDeployment ( deploymentUnit ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , IIOP_OPENJDK , false , false , false , false ) ) ; 
if ( ! isEjbDeployment ( deploymentUnit ) && ! DeploymentTypeMarker . isType ( DeploymentType . APPLICATION_CLIENT , deploymentUnit ) ) return ; 
if ( Boolean . getBoolean ( "org.jboss.as.ejb3.EMBEDDED" ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . CLASSPATH , false , false , false , false ) ) ; 
} 
} 

public class MethodIntfHelper { 
public static MethodIntf of ( final InterceptorContext invocation ) { 
MethodIntf methodIntf = invocation . getPrivateData ( MethodIntf . class ) ; 
if ( methodIntf == null ) { 
final ComponentView componentView = invocation . getPrivateData ( ComponentView . class ) ; 
if ( componentView != null ) methodIntf = componentView . getPrivateData ( MethodIntf . class ) ; 
else methodIntf = MethodIntf . BEAN ; 
} 
return methodIntf ; 
} 
} 

public class StatefulSessionComponent { 
public SessionID createSessionRemote ( ) { 
ControlPoint controlPoint = getControlPoint ( ) ; 
if ( controlPoint == null ) return createSession ( ) ; 
else try { 
RunResult result = controlPoint . beginRequest ( ) ; 
if ( result == RunResult . REJECTED ) throw EjbLogger . ROOT_LOGGER . containerSuspended ( ) ; 
try { 
return createSession ( ) ; 
} 
finally { 
controlPoint . requestComplete ( ) ; 
} 
} 
catch ( EJBComponentUnavailableException | ComponentIsStoppedException e ) { 
throw e ; 
} 
catch ( Exception e ) { 
throw new EJBException ( e ) ; 
} 
} 
} 

public class JMSServerControlHandler { 
private String inferDestinationName ( String address ) { 
if ( address . startsWith ( JMS_QUEUE_PREFIX ) ) return address . substring ( JMS_QUEUE_PREFIX . length ( ) ) ; 
else if ( address . startsWith ( JMS_TOPIC_PREFIX ) ) return address . substring ( JMS_TOPIC_PREFIX . length ( ) ) ; 
else return address ; 
} 
} 

public class WSEndpointHandlersMapping { 
public void registerEndpointHandlers ( final String endpointClass , final Set < String > endpointHandlers ) { 
if ( ( endpointClass == null ) || ( endpointHandlers == null ) ) throw new IllegalArgumentException ( ) ; 
endpointHandlersMap . put ( endpointClass , Collections . unmodifiableSet ( endpointHandlers ) ) ; 
} 
} 

public class WildFlyJobXmlResolver { 
Set < String > getJobXmlNames ( final String jobName ) { 
if ( jobNames . containsKey ( jobName ) ) return Collections . unmodifiableSet ( jobNames . get ( jobName ) ) ; 
return Collections . emptySet ( ) ; 
} 
} 

public class JbossAuthorizationManager { 
protected String requestURI ( HttpServerExchange request ) { 
String uri = request . getRelativePath ( ) ; 
if ( uri == null || uri . equals ( "/" ) ) uri = "" ; 
return uri ; 
} 
} 

public class CNCtx { 
public static ResolveResult createUsingURL ( String url , Hashtable env ) throws NamingException { 
CNCtx ctx = new CNCtx ( ) ; 
if ( env != null ) env = ( Hashtable ) env . clone ( ) ; 
ctx . _env = env ; 
String rest = ctx . initUsingUrl ( env != null ? ( org . omg . CORBA . ORB ) env . get ( "java.naming.corba.orb" ) : null , url , env ) ; 
return new ResolveResult ( ctx , parser . parse ( rest ) ) ; 
} 
} 

public class CNCtx { 
private void callUnbind ( NameComponent [ ] path ) throws NamingException { 
if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; 
try { 
_nc . unbind ( path ) ; 
} 
catch ( NotFound e ) { 
if ( leafNotFound ( e , path [ path . length - 1 ] ) ) { 
} 
else throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; 
} 
catch ( Exception e ) { 
throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; 
} 
} 
} 

public class CNCtx { 
public NamingEnumeration listBindings ( Name name ) throws NamingException { 
if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; 
if ( name . size ( ) > 0 ) try { 
java . lang . Object obj = lookup ( name ) ; 
if ( obj instanceof CNCtx ) return new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; 
else throw new NotContextException ( name . toString ( ) ) ; 
} 
catch ( NamingException ne ) { 
throw ne ; 
} 
catch ( BAD_PARAM e ) { 
NamingException ne = new NotContextException ( name . toString ( ) ) ; 
ne . setRootCause ( e ) ; 
throw ne ; 
} 
return new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( this , false , _env ) ; 
} 
} 

public class CNCtx { 
public void destroySubcontext ( Name name ) throws NamingException { 
if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; 
NamingContext the_nc = _nc ; 
NameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; 
if ( name . size ( ) > 0 ) try { 
javax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; 
CNCtx cnc = ( CNCtx ) ctx ; 
the_nc = cnc . _nc ; 
cnc . close ( ) ; 
} 
catch ( ClassCastException e ) { 
throw new NotContextException ( name . toString ( ) ) ; 
} 
catch ( CannotProceedException e ) { 
javax . naming . Context cctx = getContinuationContext ( e ) ; 
cctx . destroySubcontext ( e . getRemainingName ( ) ) ; 
return ; 
} 
catch ( NameNotFoundException e ) { 
if ( e . getRootCause ( ) instanceof NotFound && leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) return ; 
throw e ; 
} 
catch ( NamingException e ) { 
throw e ; 
} 
callDestroy ( the_nc ) ; 
callUnbind ( path ) ; 
} 
} 

public class CNCtx { 
public java . lang . Object addToEnvironment ( String propName , java . lang . Object propValue ) throws NamingException { 
if ( _env == null ) _env = new Hashtable ( 7 , 0.75f ) ; 
else _env = ( Hashtable ) _env . clone ( ) ; 
return _env . put ( propName , propValue ) ; 
} 
} 

public class AbstractProtocolResourceDefinition { 
@ SuppressWarnings ( "deprecation" ) static void addTransformations ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { 
if ( JGroupsModel . VERSION_5_0_0 . requiresTransformation ( version ) ) builder . getAttributeBuilder ( ) . setDiscard ( DiscardAttributeChecker . UNDEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . end ( ) ; 
if ( JGroupsModel . VERSION_3_0_0 . requiresTransformation ( version ) ) { 
AttributeConverter typeConverter = new AttributeConverter . DefaultAttributeConverter ( ) { 
@ Override protected void convertAttribute ( PathAddress address , String name , ModelNode value , TransformationContext context ) { 
if ( ! value . isDefined ( ) ) value . set ( address . getLastElement ( ) . getValue ( ) ) ; 
} 
} 
; 
builder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( Attribute . MODULE . getDefinition ( ) . getDefaultValue ( ) ) , Attribute . MODULE . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . MODULE . getDefinition ( ) ) . setValueConverter ( typeConverter , DeprecatedAttribute . TYPE . getDefinition ( ) ) . end ( ) ; 
builder . addRawOperationTransformationOverride ( MapOperations . MAP_GET_DEFINITION . getName ( ) , new SimpleOperationTransformer ( new LegacyPropertyMapGetOperationTransformer ( ) ) ) ; 
for ( String opName : Operations . getAllWriteAttributeOperationNames ( ) ) { 
builder . addOperationTransformationOverride ( opName ) . inheritResourceAttributeDefinitions ( ) . setCustomOperationTransformer ( new LegacyPropertyWriteOperationTransformer ( ) ) ; 
} 
} 
PropertyResourceDefinition . buildTransformation ( version , builder ) ; 
} 
} 

public class DsXmlParser { 
@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { 
String userName = null ; 
String password = null ; 
String securityDomain = null ; 
boolean elytronEnabled = false ; 
String authenticationContext = null ; 
while ( reader . hasNext ( ) ) switch ( reader . nextTag ( ) ) { 
case END_ELEMENT : { 
if ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) return new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; 
else if ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) throw new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; 
break ; 
} 
case START_ELEMENT : { 
switch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { 
case PASSWORD : { 
password = elementAsString ( reader ) ; 
if ( propertyResolver != null && password != null ) { 
String resolvedPassword = propertyResolver . resolve ( password ) ; 
if ( resolvedPassword != null ) password = resolvedPassword ; 
} 
break ; 
} 
case USER_NAME : { 
userName = elementAsString ( reader ) ; 
break ; 
} 
case SECURITY_DOMAIN : { 
securityDomain = elementAsString ( reader ) ; 
break ; 
} 
case ELYTRON_ENABLED : { 
Boolean value = elementAsBoolean ( reader ) ; 
elytronEnabled = value == null ? true : value ; 
break ; 
} 
case AUTHENTICATION_CONTEXT : { 
authenticationContext = elementAsString ( reader ) ; 
break ; 
} 
default : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; 
} 
break ; 
} 
} 
throw new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; 
} 
} 

public class IDLTypeImpl { 
static LocalIDLType getIDLType ( TypeCode typeCode , RepositoryImpl repository ) { 
TCKind tcKind = typeCode . kind ( ) ; 
if ( PrimitiveDefImpl . isPrimitiveTCKind ( tcKind ) ) return new PrimitiveDefImpl ( typeCode , repository ) ; 
if ( tcKind == TCKind . tk_sequence ) return repository . getSequenceImpl ( typeCode ) ; 
if ( tcKind == TCKind . tk_value || tcKind == TCKind . tk_value_box || tcKind == TCKind . tk_alias || tcKind == TCKind . tk_struct || tcKind == TCKind . tk_union || tcKind == TCKind . tk_enum || tcKind == TCKind . tk_objref ) try { 
return ( LocalIDLType ) repository . _lookup_id ( typeCode . id ( ) ) ; 
} 
catch ( BadKind ex ) { 
throw IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; 
} 
throw IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; 
} 
} 

public class SecurityDomainResourceDefinition { 
private static void waitForService ( final ServiceController < ? > controller ) throws OperationFailedException { 
if ( controller . getState ( ) == ServiceController . State . UP ) return ; 
final StabilityMonitor monitor = new StabilityMonitor ( ) ; 
monitor . addController ( controller ) ; 
try { 
monitor . awaitStability ( 100 , MILLISECONDS ) ; 
} 
catch ( final InterruptedException e ) { 
Thread . currentThread ( ) . interrupt ( ) ; 
throw SecurityLogger . ROOT_LOGGER . interruptedWaitingForSecurityDomain ( controller . getName ( ) . getSimpleName ( ) ) ; 
} 
finally { 
monitor . removeController ( controller ) ; 
} 
if ( controller . getState ( ) != ServiceController . State . UP ) throw SecurityLogger . ROOT_LOGGER . requiredSecurityDomainServiceNotAvailable ( controller . getName ( ) . getSimpleName ( ) ) ; 
} 
} 

public class VaultSession { 
public void startVaultSession ( String vaultAlias ) throws Exception { 
if ( vaultAlias == null ) throw SecurityLogger . ROOT_LOGGER . vaultAliasNotSpecified ( ) ; 
this . keystoreMaskedPassword = ( org . jboss . security . Util . isPasswordCommand ( keystorePassword ) ) ? keystorePassword : computeMaskedPassword ( ) ; 
this . vaultAlias = vaultAlias ; 
initSecurityVault ( ) ; 
} 
} 

public class ConnectorServices { 
public static synchronized ServiceName getDeploymentServiceName ( final String raName , final Activation raxml ) { 
if ( raName == null ) throw ConnectorLogger . ROOT_LOGGER . undefinedVar ( "RaName" ) ; 
ServiceName serviceName = null ; 
ModifiableResourceAdapter ra = ( ModifiableResourceAdapter ) raxml ; 
if ( ra != null && ra . getId ( ) != null ) serviceName = getDeploymentServiceName ( raName , ra . getId ( ) ) ; 
else serviceName = getDeploymentServiceName ( raName , ( String ) null ) ; 
ROOT_LOGGER . tracef ( "ConnectorServices: getDeploymentServiceName(%s,%s) -> %s" , raName , raxml , serviceName ) ; 
return serviceName ; 
} 
} 

public class JndiPermission { 
public String getActions ( ) { 
final String actionString = this . actionString ; 
if ( actionString != null ) return actionString ; 
int actionBits = this . actionBits ; 
if ( actionBits == ACTION_ALL ) return this . actionString = "*" ; 
int m = Integer . lowestOneBit ( actionBits ) ; 
if ( m != 0 ) { 
StringBuilder b = new StringBuilder ( ) ; 
b . append ( getAction ( m ) ) ; 
actionBits &= ~ m ; 
while ( actionBits != 0 ) { 
m = Integer . lowestOneBit ( actionBits ) ; 
b . append ( ',' ) . append ( getAction ( m ) ) ; 
actionBits &= ~ m ; 
} 
return this . actionString = b . toString ( ) ; 
} 
else return this . actionString = "" ; 
} 
} 

public class RemoteToCorba { 
public Object getStateToBind ( Object orig , Name name , Context ctx , Hashtable < ? , ? > env ) throws NamingException { 
if ( orig instanceof org . omg . CORBA . Object ) return null ; 
if ( orig instanceof Remote ) try { 
return CorbaUtils . remoteToCorba ( ( Remote ) orig , ( ( CNCtx ) ctx ) . _orb ) ; 
} 
catch ( ClassNotFoundException e ) { 
throw IIOPLogger . ROOT_LOGGER . unavailableRMIPackages ( ) ; 
} 
return null ; 
} 
} 

public class ValueConfig { 
public Object getValue ( Type type ) { 
if ( type == null || ( type instanceof Class ) ) return getClassValue ( ( Class ) type ) ; 
else if ( type instanceof ParameterizedType ) { 
ParameterizedType pt = ( ParameterizedType ) type ; 
return getPtValue ( pt ) ; 
} 
else throw PojoLogger . ROOT_LOGGER . unknownType ( type ) ; 
} 
} 

public class ComponentDescription { 
public ServiceName getContextServiceName ( ) { 
if ( contextServiceName != null ) return contextServiceName ; 
if ( getNamingMode ( ) == ComponentNamingMode . CREATE ) return ContextNames . contextServiceNameOfComponent ( getApplicationName ( ) , getModuleName ( ) , getComponentName ( ) ) ; 
else if ( getNamingMode ( ) == ComponentNamingMode . USE_MODULE ) return ContextNames . contextServiceNameOfModule ( getApplicationName ( ) , getModuleName ( ) ) ; 
else throw new IllegalStateException ( ) ; 
} 
} 

public class ComponentDescription { 
public Set < InterceptorDescription > getAllInterceptors ( ) { 
if ( allInterceptors == null ) { 
allInterceptors = new HashSet < InterceptorDescription > ( ) ; 
allInterceptors . addAll ( classInterceptors ) ; 
if ( ! excludeDefaultInterceptors ) allInterceptors . addAll ( defaultInterceptors ) ; 
for ( List < InterceptorDescription > interceptors : methodInterceptors . values ( ) ) { 
allInterceptors . addAll ( interceptors ) ; 
} 
} 
return allInterceptors ; 
} 
} 

public class ComponentDescription { 
public void addMethodInterceptor ( MethodIdentifier method , InterceptorDescription description ) { 
List < InterceptorDescription > interceptors = methodInterceptors . get ( method ) ; 
if ( interceptors == null ) methodInterceptors . put ( method , interceptors = new ArrayList < InterceptorDescription > ( ) ) ; 
final String name = description . getInterceptorClassName ( ) ; 
interceptors . add ( description ) ; 
this . allInterceptors = null ; 
} 
} 

public class ComponentDescription { 
public void addDependency ( ServiceName serviceName ) { 
if ( serviceName == null ) throw EeLogger . ROOT_LOGGER . nullVar ( "serviceName" , "component" , componentName ) ; 
dependencies . add ( serviceName ) ; 
} 
} 

public class ComponentConfiguration { 
public List < InterceptorFactory > getComponentInterceptors ( Method method ) { 
Map < Method , OrderedItemContainer < List < InterceptorFactory > > > map = componentInterceptors ; 
OrderedItemContainer < List < InterceptorFactory > > interceptors = map . get ( method ) ; 
if ( interceptors == null ) return Collections . emptyList ( ) ; 
List < List < InterceptorFactory > > sortedItems = interceptors . getSortedItems ( ) ; 
List < InterceptorFactory > ret = new ArrayList < > ( ) ; 
for ( List < InterceptorFactory > item : sortedItems ) { 
ret . addAll ( item ) ; 
} 
return ret ; 
} 
} 

public class ComponentConfiguration { 
public List < InterceptorFactory > getAroundTimeoutInterceptors ( Method method ) { 
Map < Method , OrderedItemContainer < InterceptorFactory > > map = timeoutInterceptors ; 
OrderedItemContainer < InterceptorFactory > interceptors = map . get ( method ) ; 
if ( interceptors == null ) return Collections . emptyList ( ) ; 
return interceptors . getSortedItems ( ) ; 
} 
} 

public class ComponentConfiguration { 
public void addTimeoutViewInterceptor ( final Method method , InterceptorFactory factory , int priority ) { 
OrderedItemContainer < InterceptorFactory > interceptors = timeoutInterceptors . get ( method ) ; 
if ( interceptors == null ) timeoutInterceptors . put ( method , interceptors = new OrderedItemContainer < InterceptorFactory > ( ) ) ; 
interceptors . add ( factory , priority ) ; 
} 
} 

public class ComponentConfiguration { 
public void setComponentCreateServiceFactory ( final ComponentCreateServiceFactory componentCreateServiceFactory ) { 
if ( componentCreateServiceFactory == null ) throw EeLogger . ROOT_LOGGER . nullVar ( "componentCreateServiceFactory" , "component" , getComponentName ( ) ) ; 
this . componentCreateServiceFactory = componentCreateServiceFactory ; 
} 
} 

public class PooledConnectionFactoryRemove { 
protected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { 
if ( entries . size ( ) > 1 ) for ( int i = 1 ; 
i < entries . size ( ) ; 
i ++ ) { 
ContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; 
context . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; 
} 
} 
} 

public class ContextNames { 
public static BindInfo bindInfoForEnvEntry ( String app , String module , String comp , boolean useCompNamespace , final String envEntryName ) { 
if ( envEntryName . startsWith ( "java:" ) ) if ( useCompNamespace ) return bindInfoFor ( app , module , comp , envEntryName ) ; 
else if ( envEntryName . startsWith ( "java:comp" ) ) return bindInfoFor ( app , module , module , "java:module" + envEntryName . substring ( "java:comp" . length ( ) ) ) ; 
else return bindInfoFor ( app , module , module , envEntryName ) ; 
else if ( useCompNamespace ) return bindInfoFor ( app , module , comp , "java:comp/env/" + envEntryName ) ; 
else return bindInfoFor ( app , module , module , "java:module/env/" + envEntryName ) ; 
} 
} 

public class ContextNames { 
public static BindInfo bindInfoFor ( final String jndiName ) { 
String bindName ; 
if ( jndiName . startsWith ( "java:" ) ) bindName = jndiName . substring ( 5 ) ; 
else if ( ! jndiName . startsWith ( "jboss" ) && ! jndiName . startsWith ( "global" ) && ! jndiName . startsWith ( "/" ) ) bindName = "/" + jndiName ; 
else bindName = jndiName ; 
final ServiceName parentContextName ; 
if ( bindName . startsWith ( "jboss/exported/" ) ) { 
parentContextName = EXPORTED_CONTEXT_SERVICE_NAME ; 
bindName = bindName . substring ( 15 ) ; 
} 
else if ( bindName . startsWith ( "jboss/" ) ) { 
parentContextName = JBOSS_CONTEXT_SERVICE_NAME ; 
bindName = bindName . substring ( 6 ) ; 
} 
else if ( bindName . startsWith ( "global/" ) ) { 
parentContextName = GLOBAL_CONTEXT_SERVICE_NAME ; 
bindName = bindName . substring ( 7 ) ; 
} 
else if ( bindName . startsWith ( "/" ) ) { 
parentContextName = JAVA_CONTEXT_SERVICE_NAME ; 
bindName = bindName . substring ( 1 ) ; 
} 
else throw NamingLogger . ROOT_LOGGER . illegalContextInName ( jndiName ) ; 
return new BindInfo ( parentContextName , bindName ) ; 
} 
} 

public class DefaultAuthenticationCacheFactory { 
public ConcurrentMap < Principal , DomainInfo > getCache ( ) { 
return new LRUCache < > ( 1000 , ( key , value ) -> { 
if ( value != null ) value . logout ( ) ; 
} 
) ; 
} 
} 

public class AbstractFederationSubsystemReader { 
protected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { 
if ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) return null ; 
ModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; 
int attributeCount = reader . getAttributeCount ( ) ; 
for ( int i = 0 ; 
i < attributeCount ; 
i ++ ) { 
String attributeLocalName = reader . getAttributeLocalName ( i ) ; 
if ( ModelElement . forName ( attributeLocalName ) == null ) throw unexpectedAttribute ( reader , i ) ; 
} 
for ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { 
String attributeValue = reader . getAttributeValue ( "" , simpleAttributeDefinition . getXmlName ( ) ) ; 
simpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; 
} 
String name = xmlElement . getName ( ) ; 
if ( key != null ) { 
name = key ; 
if ( modelNode . hasDefined ( key ) ) name = modelNode . get ( key ) . asString ( ) ; 
else { 
String attributeValue = reader . getAttributeValue ( "" , key ) ; 
if ( attributeValue != null ) name = attributeValue ; 
} 
} 
modelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; 
addOperations . add ( modelNode ) ; 
return modelNode ; 
} 
} 

public class WeldComponentIntegrationProcessor { 
private void addWeldIntegration ( final Iterable < ComponentIntegrator > componentIntegrators , final ComponentInterceptorSupport componentInterceptorSupport , final ServiceTarget target , final ComponentConfiguration configuration , final ComponentDescription description , final Class < ? > componentClass , final String beanName , final ServiceName weldServiceName , final ServiceName weldStartService , final ServiceName beanManagerService , final Set < Class < ? > > interceptorClasses , final ClassLoader classLoader , final String beanDeploymentArchiveId ) { 
final ServiceName serviceName = configuration . getComponentDescription ( ) . getServiceName ( ) . append ( "WeldInstantiator" ) ; 
final ServiceBuilder < ? > builder = target . addService ( serviceName ) ; 
builder . requires ( weldStartService ) ; 
configuration . setInstanceFactory ( WeldManagedReferenceFactory . INSTANCE ) ; 
configuration . getStartDependencies ( ) . add ( new DependencyConfigurator < ComponentStartService > ( ) { 
@ Override public void configureDependency ( final ServiceBuilder < ? > serviceBuilder , ComponentStartService service ) throws DeploymentUnitProcessingException { 
serviceBuilder . requires ( serviceName ) ; 
} 
} 
) ; 
boolean isComponentIntegrationPerformed = false ; 
for ( ComponentIntegrator componentIntegrator : componentIntegrators ) { 
Supplier < ServiceName > bindingServiceNameSupplier = ( ) -> { 
if ( componentInterceptorSupport == null ) throw WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; 
return addWeldInterceptorBindingService ( target , configuration , componentClass , beanName , weldServiceName , weldStartService , beanDeploymentArchiveId , componentInterceptorSupport ) ; 
} 
; 
DefaultInterceptorIntegrationAction integrationAction = ( bindingServiceName ) -> { 
if ( componentInterceptorSupport == null ) throw WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; 
addJsr299BindingsCreateInterceptor ( configuration , description , beanName , weldServiceName , builder , bindingServiceName , componentInterceptorSupport ) ; 
addCommonLifecycleInterceptionSupport ( configuration , builder , bindingServiceName , beanManagerService , componentInterceptorSupport ) ; 
configuration . addComponentInterceptor ( new UserInterceptorFactory ( factory ( InterceptionType . AROUND_INVOKE , builder , bindingServiceName , componentInterceptorSupport ) , factory ( InterceptionType . AROUND_TIMEOUT , builder , bindingServiceName , componentInterceptorSupport ) ) , InterceptorOrder . Component . CDI_INTERCEPTORS , false ) ; 
} 
; 
if ( componentIntegrator . integrate ( beanManagerService , configuration , description , builder , bindingServiceNameSupplier , integrationAction , componentInterceptorSupport ) ) { 
isComponentIntegrationPerformed = true ; 
break ; 
} 
} 
} 


public class EEApplicationDescription { 
public void addComponent ( final ComponentDescription description , final VirtualFile deploymentRoot ) { 
for ( final ViewDescription viewDescription : description . getViews ( ) ) { 
List < ViewInformation > viewComponents = componentsByViewName . get ( viewDescription . getViewClassName ( ) ) ; 
if ( viewComponents == null ) { 
viewComponents = new ArrayList < ViewInformation > ( 1 ) ; 
componentsByViewName . put ( viewDescription . getViewClassName ( ) , viewComponents ) ; 
} 
viewComponents . add ( new ViewInformation ( viewDescription , deploymentRoot , description . getComponentName ( ) ) ) ; 
} 
List < Description > components = componentsByName . get ( description . getComponentName ( ) ) ; 
if ( components == null ) componentsByName . put ( description . getComponentName ( ) , components = new ArrayList < Description > ( 1 ) ) ; 
components . add ( new Description ( description , deploymentRoot ) ) ; 
} 
} 

public class EEApplicationDescription { 
public void addMessageDestination ( final String name , final String resolvedName , final VirtualFile deploymentRoot ) { 
List < MessageDestinationMapping > components = messageDestinationJndiMapping . get ( name ) ; 
if ( components == null ) messageDestinationJndiMapping . put ( name , components = new ArrayList < MessageDestinationMapping > ( 1 ) ) ; 
components . add ( new MessageDestinationMapping ( resolvedName , deploymentRoot ) ) ; 
} 
} 

public class EEApplicationDescription { 
public Set < ViewDescription > getComponentsForViewName ( final String viewType , final VirtualFile deploymentRoot ) { 
final List < ViewInformation > info = componentsByViewName . get ( viewType ) ; 
if ( info == null ) return Collections . < ViewDescription > emptySet ( ) ; 
final Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; 
final Set < ViewDescription > currentDep = new HashSet < ViewDescription > ( ) ; 
for ( ViewInformation i : info ) { 
if ( deploymentRoot . equals ( i . deploymentRoot ) ) currentDep . add ( i . viewDescription ) ; 
ret . add ( i . viewDescription ) ; 
} 
if ( ! currentDep . isEmpty ( ) ) return currentDep ; 
return ret ; 
} 
} 

public class EEApplicationDescription { 
public Set < ComponentDescription > getComponents ( final String componentName , final VirtualFile deploymentRoot ) { 
if ( componentName . contains ( "#" ) ) { 
final String [ ] parts = componentName . split ( "#" ) ; 
String path = parts [ 0 ] ; 
if ( ! path . startsWith ( "../" ) ) path = "../" + path ; 
final VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; 
final String name = parts [ 1 ] ; 
final List < Description > info = componentsByName . get ( name ) ; 
if ( info == null ) return Collections . emptySet ( ) ; 
final Set < ComponentDescription > ret = new HashSet < ComponentDescription > ( ) ; 
for ( Description i : info ) { 
if ( virtualPath . equals ( i . deploymentRoot ) ) ret . add ( i . componentDescription ) ; 
} 
return ret ; 
} 
else { 
final List < Description > info = componentsByName . get ( componentName ) ; 
if ( info == null ) return Collections . emptySet ( ) ; 
final Set < ComponentDescription > all = new HashSet < ComponentDescription > ( ) ; 
final Set < ComponentDescription > thisDeployment = new HashSet < ComponentDescription > ( ) ; 
for ( Description i : info ) { 
all . add ( i . componentDescription ) ; 
if ( i . deploymentRoot . equals ( deploymentRoot ) ) thisDeployment . add ( i . componentDescription ) ; 
} 
if ( all . size ( ) > 1 ) return thisDeployment ; 
return all ; 
} 
} 
} 

public class EEApplicationDescription { 
public Set < ViewDescription > getComponents ( final String componentName , final String viewName , final VirtualFile deploymentRoot ) { 
final List < ViewInformation > info = componentsByViewName . get ( viewName ) ; 
if ( info == null ) return Collections . < ViewDescription > emptySet ( ) ; 
if ( componentName . contains ( "#" ) ) { 
final String [ ] parts = componentName . split ( "#" ) ; 
String path = parts [ 0 ] ; 
if ( ! path . startsWith ( "../" ) ) path = "../" + path ; 
final VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; 
final String name = parts [ 1 ] ; 
final Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; 
for ( ViewInformation i : info ) { 
if ( i . beanName . equals ( name ) ) if ( virtualPath . equals ( i . deploymentRoot ) ) ret . add ( i . viewDescription ) ; 
} 
return ret ; 
} 
else { 
final Set < ViewDescription > all = new HashSet < ViewDescription > ( ) ; 
final Set < ViewDescription > thisDeployment = new HashSet < ViewDescription > ( ) ; 
for ( ViewInformation i : info ) { 
if ( i . beanName . equals ( componentName ) ) { 
all . add ( i . viewDescription ) ; 
if ( i . deploymentRoot . equals ( deploymentRoot ) ) thisDeployment . add ( i . viewDescription ) ; 
} 
} 
if ( all . size ( ) > 1 ) return thisDeployment ; 
return all ; 
} 
} 
} 

public class EEApplicationDescription { 
public Set < String > resolveMessageDestination ( final String messageDestName , final VirtualFile deploymentRoot ) { 
if ( messageDestName . contains ( "#" ) ) { 
final String [ ] parts = messageDestName . split ( "#" ) ; 
String path = parts [ 0 ] ; 
if ( ! path . startsWith ( "../" ) ) path = "../" + path ; 
final VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; 
final String name = parts [ 1 ] ; 
final Set < String > ret = new HashSet < String > ( ) ; 
final List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( name ) ; 
if ( data != null ) for ( final MessageDestinationMapping i : data ) { 
if ( virtualPath . equals ( i . deploymentRoot ) ) ret . add ( i . jndiName ) ; 
} 
return ret ; 
} 
else { 
final Set < String > all = new HashSet < String > ( ) ; 
final Set < String > thisDeployment = new HashSet < String > ( ) ; 
final List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( messageDestName ) ; 
if ( data != null ) for ( final MessageDestinationMapping i : data ) { 
all . add ( i . jndiName ) ; 
if ( i . deploymentRoot . equals ( deploymentRoot ) ) thisDeployment . add ( i . jndiName ) ; 
} 
if ( all . size ( ) > 1 ) return thisDeployment ; 
return all ; 
} 
} 
} 

public class InterfaceRepository { 
private void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { 
if ( cls . isPrimitive ( ) ) return ; 
if ( cls . isArray ( ) ) addArray ( cls ) ; 
else if ( cls . isInterface ( ) ) if ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) { 
InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; 
addInterface ( ia ) ; 
} 
else { 
ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; 
addValue ( va ) ; 
} 
else if ( Exception . class . isAssignableFrom ( cls ) ) { 
ExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; 
addException ( ea ) ; 
} 
else { 
ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; 
addValue ( va ) ; 
} 
} 
} 

public class NamingStoreService { 
public void stop ( StopContext context ) { 
if ( store != null ) try { 
store . close ( ) ; 
store = null ; 
} 
catch ( NamingException e ) { 
throw NamingLogger . ROOT_LOGGER . failedToDestroyRootContext ( e ) ; 
} 
} 
} 

public class AllowedMethodsInformation { 
public static void checkAllowed ( final MethodType methodType ) { 
final InterceptorContext context = CurrentInvocationContext . get ( ) ; 
if ( context == null ) return ; 
final Component component = context . getPrivateData ( Component . class ) ; 
if ( ! ( component instanceof EJBComponent ) ) return ; 
final InvocationType invocationType = context . getPrivateData ( InvocationType . class ) ; 
( ( EJBComponent ) component ) . getAllowedMethodsInformation ( ) . realCheckPermission ( methodType , invocationType ) ; 
} 
} 

public class AllowedMethodsInformation { 
private void checkTransactionSync ( MethodType methodType ) { 
final CurrentSynchronizationCallback . CallbackType currentSync = CurrentSynchronizationCallback . get ( ) ; 
if ( currentSync != null ) if ( deniedSyncMethods . contains ( new DeniedSyncMethodKey ( currentSync , methodType ) ) ) throwException ( methodType , currentSync ) ; 
} 
} 

public class TimerServiceImpl { 
private Map < String , TimerImpl > getWaitingOnTxCompletionTimers ( ) { 
Map < String , TimerImpl > timers = null ; 
if ( getTransaction ( ) != null ) timers = ( Map < String , TimerImpl > ) tsr . getResource ( waitingOnTxCompletionKey ) ; 
return timers == null ? Collections . < String , TimerImpl > emptyMap ( ) : timers ; 
} 
} 

public class TransportConfigOperationHandlers { 
private static Map < String , Object > getExtraParameters ( final Set < String > allowedKeys , final Map < String , Object > parameters ) { 
Map < String , Object > extraParameters = new HashMap < > ( ) ; 
for ( Map . Entry < String , Object > parameter : parameters . entrySet ( ) ) { 
if ( ! allowedKeys . contains ( parameter . getKey ( ) ) ) extraParameters . put ( parameter . getKey ( ) , parameter . getValue ( ) ) ; 
} 
for ( String extraParam : extraParameters . keySet ( ) ) { 
parameters . remove ( extraParam ) ; 
} 
return extraParameters ; 
} 
} 

public class Configurator { 
public static Class < ? > toClass ( Type type ) { 
if ( type instanceof Class ) return ( Class ) type ; 
else if ( type instanceof ParameterizedType ) { 
ParameterizedType pt = ( ParameterizedType ) type ; 
return toClass ( pt . getRawType ( ) ) ; 
} 
else throw PojoLogger . ROOT_LOGGER . unknownType ( type ) ; 
} 
} 

public class Configurator { 
@ SuppressWarnings ( "unchecked" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { 
if ( clazz == null ) return value ; 
if ( value == null ) return null ; 
Class < ? > valueClass = value . getClass ( ) ; 
if ( valueClass == String . class ) { 
String string = ( String ) value ; 
if ( trim ) string = string . trim ( ) ; 
if ( replaceProperties ) value = PropertiesValueResolver . replaceProperties ( string ) ; 
} 
if ( clazz . isAssignableFrom ( valueClass ) ) return value ; 
if ( clazz . isEnum ( ) ) { 
Class < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; 
return Enum . valueOf ( eclazz , value . toString ( ) ) ; 
} 
if ( valueClass == String . class ) { 
PropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; 
if ( editor != null ) { 
editor . setAsText ( ( String ) value ) ; 
return editor . getValue ( ) ; 
} 
} 
try { 
Method method = clazz . getMethod ( "valueOf" , valueClass ) ; 
int modifiers = method . getModifiers ( ) ; 
if ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) && clazz . isAssignableFrom ( method . getReturnType ( ) ) ) return method . invoke ( null , value ) ; 
} 
catch ( Exception ignored ) { 
} 
if ( valueClass == String . class ) try { 
Constructor constructor = clazz . getConstructor ( valueClass ) ; 
if ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) return constructor . newInstance ( value ) ; 
} 
catch ( Exception ignored ) { 
} 
return value ; 
} 
} 

public class CNBindingEnumeration { 
public java . lang . Object next ( ) throws NamingException { 
if ( more && counter >= _bindingList . value . length ) getMore ( ) ; 
if ( more && counter < _bindingList . value . length ) { 
org . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; 
counter ++ ; 
return mapBinding ( bndg ) ; 
} 
else throw new NoSuchElementException ( ) ; 
} 
} 

public class EjbIIOPService { 
public org . omg . CORBA . Object referenceForLocator ( final EJBLocator < ? > locator ) { 
final EJBComponent ejbComponent = ejbComponentInjectedValue . getValue ( ) ; 
try { 
final String earApplicationName = ejbComponent . getEarApplicationName ( ) == null ? "" : ejbComponent . getEarApplicationName ( ) ; 
if ( locator . getBeanName ( ) . equals ( ejbComponent . getComponentName ( ) ) && locator . getAppName ( ) . equals ( earApplicationName ) && locator . getModuleName ( ) . equals ( ejbComponent . getModuleName ( ) ) && locator . getDistinctName ( ) . equals ( ejbComponent . getDistinctName ( ) ) ) { 
if ( locator instanceof EJBHomeLocator ) return ( org . omg . CORBA . Object ) ejbHome ; 
else if ( locator instanceof StatelessEJBLocator ) return beanReferenceFactory . createReference ( beanRepositoryIds [ 0 ] ) ; 
else if ( locator instanceof StatefulEJBLocator ) { 
final Marshaller marshaller = factory . createMarshaller ( configuration ) ; 
final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; 
marshaller . start ( new OutputStreamByteOutput ( stream ) ) ; 
marshaller . writeObject ( ( ( StatefulEJBLocator < ? > ) locator ) . getSessionId ( ) ) ; 
marshaller . finish ( ) ; 
return beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; 
} 
else if ( locator instanceof EntityEJBLocator ) { 
final Marshaller marshaller = factory . createMarshaller ( configuration ) ; 
final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; 
marshaller . start ( new OutputStreamByteOutput ( stream ) ) ; 
marshaller . writeObject ( ( ( EntityEJBLocator < ? > ) locator ) . getPrimaryKey ( ) ) ; 
marshaller . finish ( ) ; 
return beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; 
} 
throw EjbLogger . ROOT_LOGGER . unknownEJBLocatorType ( locator ) ; 
} 
else throw EjbLogger . ROOT_LOGGER . incorrectEJBLocatorForBean ( locator , ejbComponent . getComponentName ( ) ) ; 
} 
catch ( Exception e ) { 
throw EjbLogger . ROOT_LOGGER . couldNotCreateCorbaObject ( e , locator ) ; 
} 
} 
} 

public class EjbIIOPService { 
public Object handleForLocator ( final EJBLocator < ? > locator ) { 
final org . omg . CORBA . Object reference = referenceForLocator ( locator ) ; 
if ( locator instanceof EJBHomeLocator ) return new HomeHandleImplIIOP ( orb . getValue ( ) . object_to_string ( reference ) ) ; 
return new HandleImplIIOP ( orb . getValue ( ) . object_to_string ( reference ) ) ; 
} 
} 

public class Messaging13SubsystemParser { 
protected static void checkNotBothElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { 
if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; 
} 
} 

public class EEModuleDescription { 
public void addComponent ( ComponentDescription description ) { 
final String componentName = description . getComponentName ( ) ; 
final String componentClassName = description . getComponentClassName ( ) ; 
if ( componentName == null ) throw EeLogger . ROOT_LOGGER . nullVar ( "componentName" , "module" , moduleName ) ; 
if ( componentClassName == null ) throw EeLogger . ROOT_LOGGER . nullVar ( "componentClassName" , "module" , moduleName ) ; 
if ( componentsByName . containsKey ( componentName ) ) throw EeLogger . ROOT_LOGGER . componentAlreadyDefined ( componentName ) ; 
componentsByName . put ( componentName , description ) ; 
List < ComponentDescription > list = componentsByClassName . get ( componentClassName ) ; 
if ( list == null ) componentsByClassName . put ( componentClassName , list = new ArrayList < ComponentDescription > ( 1 ) ) ; 
list . add ( description ) ; 
} 
} 

public class InMemoryNamingStore { 
public void unbind ( final Name name ) throws NamingException { 
if ( isLastComponentEmpty ( name ) ) throw emptyNameException ( ) ; 
writeLock . lock ( ) ; 
try { 
root . accept ( new UnbindVisitor ( name ) ) ; 
} 
finally { 
writeLock . unlock ( ) ; 
} 
} 
} 

public class ConcurrentContext { 
public synchronized void addFactory ( ContextHandleFactory factory ) { 
final String factoryName = factory . getName ( ) ; 
if ( factoryMap . containsKey ( factoryName ) ) throw EeLogger . ROOT_LOGGER . factoryAlreadyExists ( this , factoryName ) ; 
factoryMap . put ( factoryName , factory ) ; 
final Comparator < ContextHandleFactory > comparator = new Comparator < ContextHandleFactory > ( ) { 
@ Override public int compare ( ContextHandleFactory o1 , ContextHandleFactory o2 ) { 
return Integer . compare ( o1 . getChainPriority ( ) , o2 . getChainPriority ( ) ) ; 
} 
} 
; 
SortedSet < ContextHandleFactory > sortedSet = new TreeSet < > ( comparator ) ; 
sortedSet . addAll ( factoryMap . values ( ) ) ; 
factoryOrderedList = new ArrayList < > ( sortedSet ) ; 
} 
} 

public class WebMigrateOperation { 
private void createIoSubsystem ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , PathAddress baseAddress ) { 
Resource root = context . readResourceFromRoot ( baseAddress , false ) ; 
if ( root . getChildrenNames ( SUBSYSTEM ) . contains ( IOExtension . SUBSYSTEM_NAME ) ) return ; 
PathAddress address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) ) ; 
migrationOperations . put ( address , createAddOperation ( address ) ) ; 
address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( "worker" , "default" ) ) ; 
migrationOperations . put ( address , createAddOperation ( address ) ) ; 
address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( "buffer-pool" , "default" ) ) ; 
migrationOperations . put ( address , createAddOperation ( address ) ) ; 
} 
} 

public class StrictMaxPool { 
public T get ( ) { 
try { 
boolean acquired = semaphore . tryAcquire ( timeout , timeUnit ) ; 
if ( ! acquired ) throw EjbLogger . ROOT_LOGGER . failedToAcquirePermit ( timeout , timeUnit ) ; 
} 
catch ( InterruptedException e ) { 
throw EjbLogger . ROOT_LOGGER . acquireSemaphoreInterrupted ( ) ; 
} 
T bean = pool . poll ( ) ; 
if ( bean != null ) return bean ; 
try { 
bean = create ( ) ; 
} 
finally { 
if ( bean == null ) semaphore . release ( ) ; 
} 
return bean ; 
} 
} 

public class EndpointPublisherImpl { 
protected void doDeploy ( ServiceTarget target , DeploymentUnit unit ) { 
List < DeploymentAspect > aspects = getDeploymentAspects ( ) ; 
ClassLoader origClassLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; 
Deployment dep = null ; 
try { 
WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( ClassLoaderProvider . getDefaultProvider ( ) . getServerIntegrationClassLoader ( ) ) ; 
dep = unit . getAttachment ( WSAttachmentKeys . DEPLOYMENT_KEY ) ; 
dep . addAttachment ( ServiceTarget . class , target ) ; 
DeploymentAspectManager dam = new DeploymentAspectManagerImpl ( ) ; 
dam . setDeploymentAspects ( aspects ) ; 
dam . deploy ( dep ) ; 
} 
finally { 
if ( dep != null ) dep . removeAttachment ( ServiceTarget . class ) ; 
WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( origClassLoader ) ; 
} 
} 
} 

public class WeldBootstrapService { 
public synchronized void start ( final StartContext context ) { 
if ( started ) throw WeldLogger . ROOT_LOGGER . alreadyRunning ( "WeldContainer" ) ; 
started = true ; 
WeldLogger . DEPLOYMENT_LOGGER . startingWeldService ( deploymentName ) ; 
addWeldService ( SecurityServices . class , securityServicesSupplier . get ( ) ) ; 
TransactionServices transactionServices = weldTransactionServicesSupplier != null ? weldTransactionServicesSupplier . get ( ) : null ; 
if ( transactionServices != null ) addWeldService ( TransactionServices . class , transactionServices ) ; 
if ( ! deployment . getServices ( ) . contains ( ExecutorServices . class ) ) addWeldService ( ExecutorServices . class , executorServicesSupplier . get ( ) ) ; 
ModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule ( ) . getClassLoader ( ) , deployment . getSubDeploymentClassLoaders ( ) ) ; 
ClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; 
try { 
WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule ( ) . getClassLoader ( ) ) ; 
bootstrap . startContainer ( deploymentName , environment , deployment ) ; 
WeldProvider . containerInitialized ( Container . instance ( deploymentName ) , getBeanManager ( ) , deployment ) ; 
} 
finally { 
WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; 
} 
weldBootstrapServiceConsumer . accept ( this ) ; 
} 
} 

public class WSEndpointConfigMapping { 
public void registerEndpointConfig ( final String endpointClass , final EndpointConfig config ) { 
if ( ( endpointClass == null ) || ( config == null ) ) throw new IllegalArgumentException ( ) ; 
endpointConfigMap . put ( endpointClass , config ) ; 
} 
} 

public class TimerTask { 
protected void retryTimeout ( TimerImpl timer ) throws Exception { 
boolean callTimeout = false ; 
timer . lock ( ) ; 
try { 
if ( timer . isActive ( ) ) { 
EJB3_TIMER_LOGGER . retryingTimeout ( timer ) ; 
timer . setTimerState ( TimerState . RETRY_TIMEOUT , Thread . currentThread ( ) ) ; 
timerService . persistTimer ( timer , false ) ; 
callTimeout = true ; 
} 
else EJB3_TIMER_LOGGER . timerNotActive ( timer ) ; 
} 
finally { 
timer . unlock ( ) ; 
} 
if ( callTimeout ) this . callTimeout ( timer ) ; 
} 
} 

public class TimerTask { 
protected void postTimeoutProcessing ( TimerImpl timer ) throws InterruptedException { 
timer . lock ( ) ; 
try { 
TimerState timerState = timer . getState ( ) ; 
if ( timerState != TimerState . CANCELED && timerState != TimerState . EXPIRED ) { 
if ( timer . getInterval ( ) == 0 ) timerService . expireTimer ( timer ) ; 
else timer . setTimerState ( TimerState . ACTIVE , null ) ; 
timerService . persistTimer ( timer , false ) ; 
} 
} 
finally { 
timer . unlock ( ) ; 
} 
} 
} 

public class MigrateOperation { 
private void addMessagingActiveMQExtension ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , boolean describe ) { 
Resource root = context . readResourceFromRoot ( PathAddress . EMPTY_ADDRESS , false ) ; 
if ( root . getChildrenNames ( EXTENSION ) . contains ( MESSAGING_ACTIVEMQ_EXTENSION ) ) return ; 
PathAddress extensionAddress = pathAddress ( EXTENSION , MESSAGING_ACTIVEMQ_EXTENSION ) ; 
OperationEntry addEntry = context . getRootResourceRegistration ( ) . getOperationEntry ( extensionAddress , ADD ) ; 
ModelNode addOperation = createAddOperation ( extensionAddress ) ; 
addOperation . get ( MODULE ) . set ( MESSAGING_ACTIVEMQ_MODULE ) ; 
if ( describe ) migrationOperations . put ( extensionAddress , addOperation ) ; 
else context . addStep ( context . getResult ( ) . get ( extensionAddress . toString ( ) ) , addOperation , addEntry . getOperationHandler ( ) , MODEL ) ; 
} 
} 

public class MigrateOperation { 
private boolean parameterIsAllowed ( String name , String resourceType ) { 
switch ( resourceType ) { 
case REMOTE_ACCEPTOR : case HTTP_ACCEPTOR : case REMOTE_CONNECTOR : case HTTP_CONNECTOR : if ( "use-nio" . equals ( name ) ) return false ; 
else return true ; 
default : return true ; 
} 
} 
} 

public class CancellationFlag { 
public boolean cancel ( boolean setFlag ) { 
final AtomicInteger stateRef = this . stateRef ; 
int oldVal , newVal ; 
do { 
oldVal = stateRef . get ( ) ; 
if ( oldVal == ST_WAITING ) newVal = ST_CANCELLED ; 
else if ( oldVal == ST_CANCELLED ) { 
if ( ! setFlag ) return true ; 
newVal = ST_CANCELLED_FLAG_SET ; 
} 
else if ( oldVal == ST_CANCELLED_FLAG_SET ) return true ; 
else if ( oldVal == ST_STARTED ) { 
if ( ! setFlag ) return false ; 
newVal = ST_STARTED_FLAG_SET ; 
} 
else { 
assert oldVal == ST_STARTED_FLAG_SET ; 
return false ; 
} 
} 
while ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; 
return newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; 
} 
} 

public class CancellationFlag { 
public boolean runIfNotCancelled ( ) { 
final AtomicInteger stateRef = this . stateRef ; 
int oldVal ; 
do { 
oldVal = stateRef . get ( ) ; 
if ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) return false ; 
else if ( oldVal != ST_WAITING ) throw Assert . unreachableCode ( ) ; 
} 
while ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; 
return true ; 
} 
} 

public class OBaseExpression { 
public boolean canExecuteIndexedFunctionWithoutIndex ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { 
if ( this . identifier == null ) return false ; 
return identifier . canExecuteIndexedFunctionWithoutIndex ( target , context , operator , right ) ; 
} 
} 

public class OWhereClause { 
public long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { 
long count = oClass . count ( ) ; 
if ( count > 1 ) count = count / 2 ; 
if ( count < threshold ) return count ; 
long indexesCount = 0l ; 
List < OAndBlock > flattenedConditions = flatten ( ) ; 
Set < OIndex < ? > > indexes = oClass . getIndexes ( ) ; 
for ( OAndBlock condition : flattenedConditions ) { 
List < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; 
long conditionEstimation = Long . MAX_VALUE ; 
if ( indexedFunctConditions != null ) for ( OBinaryCondition cond : indexedFunctConditions ) { 
OFromClause from = new OFromClause ( - 1 ) ; 
OFromItem item = new OFromItem ( - 1 ) ; 
from . item = item ; 
from . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; 
long newCount = cond . estimateIndexed ( from , ctx ) ; 
if ( newCount < conditionEstimation ) conditionEstimation = newCount ; 
} 
else { 
Map < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; 
for ( OIndex index : indexes ) { 
if ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) continue ; 
List < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; 
int nMatchingKeys = 0 ; 
for ( String indexedField : indexedFields ) { 
if ( conditions . containsKey ( indexedField ) ) nMatchingKeys ++ ; 
else break ; 
} 
if ( nMatchingKeys > 0 ) { 
long newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; 
if ( newCount < conditionEstimation ) conditionEstimation = newCount ; 
} 
} 
} 
if ( conditionEstimation > count ) return count ; 
indexesCount += conditionEstimation ; 
} 
return Math . min ( indexesCount , count ) ; 
} 
} 

public class OReflectionHelper { 
public static List < Class < ? > > getClassessOfInterface ( String thePackage , Class < ? > theInterface , final ClassLoader iClassLoader ) { 
List < Class < ? > > classList = new ArrayList < Class < ? > > ( ) ; 
try { 
for ( Class < ? > discovered : getClassesFor ( thePackage , iClassLoader ) ) { 
if ( Arrays . asList ( discovered . getInterfaces ( ) ) . contains ( theInterface ) ) classList . add ( discovered ) ; 
} 
} 
catch ( ClassNotFoundException ex ) { 
OLogManager . instance ( ) . error ( null , "Error finding classes" , ex ) ; 
} 
return classList ; 
} 
} 

public class OReflectionHelper { 
public static Class < ? > getGenericMultivalueType ( final Field p ) { 
if ( p . getType ( ) instanceof Class < ? > ) { 
final Type genericType = p . getGenericType ( ) ; 
if ( genericType != null && genericType instanceof ParameterizedType ) { 
final ParameterizedType pt = ( ParameterizedType ) genericType ; 
if ( pt . getActualTypeArguments ( ) != null && pt . getActualTypeArguments ( ) . length > 0 ) if ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) return ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; 
else if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; 
else if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) return ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; 
else if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; 
} 
else if ( p . getType ( ) . isArray ( ) ) return p . getType ( ) . getComponentType ( ) ; 
} 
return null ; 
} 
} 

public class ODocumentSimpleFieldHandlingStrategy { 
protected OType deriveFieldType ( ODocument iRecord , String fieldName , OType requestedFieldType ) { 
if ( iRecord . getSchemaClass ( ) . existsProperty ( fieldName ) ) return iRecord . getSchemaClass ( ) . getProperty ( fieldName ) . getType ( ) ; 
if ( requestedFieldType != null ) return requestedFieldType ; 
return iRecord . fieldType ( fieldName ) ; 
} 
} 

public class OLocalRecordCache { 
public void updateRecord ( final ORecord record ) { 
if ( record . getIdentity ( ) . getClusterId ( ) != excludedCluster && record . getIdentity ( ) . isValid ( ) && ! record . isDirty ( ) && ! ORecordVersionHelper . isTombstone ( record . getVersion ( ) ) ) if ( underlying . get ( record . getIdentity ( ) ) != record ) underlying . put ( record ) ; 
} 
} 

public class OSelectExecutionPlanner { 
private Map < String , Set < String > > getMinimalSetOfNodesForShardedQuery ( String localNode , Map < String , Set < String > > clusterMap , Set < String > queryClusters ) { 
Map < String , Set < String > > result = new LinkedHashMap < > ( ) ; 
Set < String > uncovered = new HashSet < > ( ) ; 
uncovered . addAll ( queryClusters ) ; 
uncovered = uncovered . stream ( ) . filter ( x -> x != null ) . map ( x -> x . toLowerCase ( Locale . ENGLISH ) ) . collect ( Collectors . toSet ( ) ) ; 
Set < String > nextNodeClusters = new HashSet < > ( ) ; 
Set < String > clustersForNode = clusterMap . get ( localNode ) ; 
if ( clustersForNode != null ) nextNodeClusters . addAll ( clustersForNode ) ; 
nextNodeClusters . retainAll ( uncovered ) ; 
if ( nextNodeClusters . size ( ) > 0 ) { 
result . put ( localNode , nextNodeClusters ) ; 
uncovered . removeAll ( nextNodeClusters ) ; 
} 
while ( uncovered . size ( ) > 0 ) { 
String nextNode = findItemThatCoversMore ( uncovered , clusterMap ) ; 
nextNodeClusters = new HashSet < > ( ) ; 
nextNodeClusters . addAll ( clusterMap . get ( nextNode ) ) ; 
nextNodeClusters . retainAll ( uncovered ) ; 
if ( nextNodeClusters . size ( ) == 0 ) throw new OCommandExecutionException ( "Cannot execute a sharded query: clusters [" + uncovered . stream ( ) . collect ( Collectors . joining ( ", " ) ) + "] are not present on any node" + "\n [" + clusterMap . entrySet ( ) . stream ( ) . map ( x -> "" + x . getKey ( ) + ":(" + x . getValue ( ) . stream ( ) . collect ( Collectors . joining ( "," ) ) + ")" ) . collect ( Collectors . joining ( ", " ) ) + "]" ) ; 
result . put ( nextNode , nextNodeClusters ) ; 
uncovered . removeAll ( nextNodeClusters ) ; 
} 
return result ; 
} 
} 

public class OSelectExecutionPlanner { 
private static List < OAndBlock > moveFlattededEqualitiesLeft ( List < OAndBlock > flattenedWhereClause ) { 
if ( flattenedWhereClause == null ) return null ; 
List < OAndBlock > result = new ArrayList < > ( ) ; 
for ( OAndBlock block : flattenedWhereClause ) { 
List < OBooleanExpression > equalityExpressions = new ArrayList < > ( ) ; 
List < OBooleanExpression > nonEqualityExpressions = new ArrayList < > ( ) ; 
OAndBlock newBlock = block . copy ( ) ; 
for ( OBooleanExpression exp : newBlock . getSubBlocks ( ) ) { 
if ( exp instanceof OBinaryCondition ) if ( ( ( OBinaryCondition ) exp ) . getOperator ( ) instanceof OEqualsCompareOperator ) equalityExpressions . add ( exp ) ; 
else nonEqualityExpressions . add ( exp ) ; 
else nonEqualityExpressions . add ( exp ) ; 
} 
OAndBlock newAnd = new OAndBlock ( - 1 ) ; 
newAnd . getSubBlocks ( ) . addAll ( equalityExpressions ) ; 
newAnd . getSubBlocks ( ) . addAll ( nonEqualityExpressions ) ; 
result . add ( newAnd ) ; 
} 
return result ; 
} 
} 

public class OSelectExecutionPlanner { 
private static void addOrderByProjections ( QueryPlanningInfo info ) { 
if ( info . orderApplied || info . expand || info . unwind != null || info . orderBy == null || info . orderBy . getItems ( ) . size ( ) == 0 || info . projection == null || info . projection . getItems ( ) == null || ( info . projection . getItems ( ) . size ( ) == 1 && info . projection . getItems ( ) . get ( 0 ) . isAll ( ) ) ) return ; 
OOrderBy newOrderBy = info . orderBy == null ? null : info . orderBy . copy ( ) ; 
List < OProjectionItem > additionalOrderByProjections = calculateAdditionalOrderByProjections ( info . projection . getAllAliases ( ) , newOrderBy ) ; 
if ( additionalOrderByProjections . size ( ) > 0 ) info . orderBy = newOrderBy ; 
if ( additionalOrderByProjections . size ( ) > 0 ) { 
info . projectionAfterOrderBy = new OProjection ( - 1 ) ; 
info . projectionAfterOrderBy . setItems ( new ArrayList < > ( ) ) ; 
for ( String alias : info . projection . getAllAliases ( ) ) { 
info . projectionAfterOrderBy . getItems ( ) . add ( projectionFromAlias ( new OIdentifier ( alias ) ) ) ; 
} 
for ( OProjectionItem item : additionalOrderByProjections ) { 
if ( info . preAggregateProjection != null ) { 
info . preAggregateProjection . getItems ( ) . add ( item ) ; 
info . aggregateProjection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; 
info . projection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; 
} 
else info . projection . getItems ( ) . add ( item ) ; 
} 
} 
} 
} 

public class OSelectExecutionPlanner { 
private static void extractSubQueries ( QueryPlanningInfo info ) { 
SubQueryCollector collector = new SubQueryCollector ( ) ; 
if ( info . perRecordLetClause != null ) info . perRecordLetClause . extractSubQueries ( collector ) ; 
int i = 0 ; 
int j = 0 ; 
for ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { 
OIdentifier alias = entry . getKey ( ) ; 
OStatement query = entry . getValue ( ) ; 
if ( query . refersToParent ( ) ) addRecordLevelLet ( info , alias , query , j ++ ) ; 
else addGlobalLet ( info , alias , query , i ++ ) ; 
} 
collector . reset ( ) ; 
if ( info . whereClause != null ) info . whereClause . extractSubQueries ( collector ) ; 
if ( info . projection != null ) info . projection . extractSubQueries ( collector ) ; 
if ( info . orderBy != null ) info . orderBy . extractSubQueries ( collector ) ; 
if ( info . groupBy != null ) info . groupBy . extractSubQueries ( collector ) ; 
for ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { 
OIdentifier alias = entry . getKey ( ) ; 
OStatement query = entry . getValue ( ) ; 
if ( query . refersToParent ( ) ) addRecordLevelLet ( info , alias , query ) ; 
else addGlobalLet ( info , alias , query ) ; 
} 
} 
} 

public class OSelectExecutionPlanner { 
private boolean isFromClusters ( ORid rid , Set < String > filterClusters , ODatabase database ) { 
if ( filterClusters == null ) throw new IllegalArgumentException ( ) ; 
String clusterName = database . getClusterNameById ( rid . getCluster ( ) . getValue ( ) . intValue ( ) ) ; 
return filterClusters . contains ( clusterName ) ; 
} 
} 

public class OSelectExecutionPlanner { 
private boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { 
OSchema schema = getSchemaFromContext ( ctx ) ; 
OClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; 
if ( clazz == null ) { 
clazz = schema . getView ( queryTarget . getStringValue ( ) ) ; 
if ( clazz == null ) throw new OCommandExecutionException ( "Class not found: " + queryTarget ) ; 
} 
for ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { 
List < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; 
if ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) continue ; 
boolean indexFound = true ; 
String orderType = null ; 
for ( int i = 0 ; 
i < info . orderBy . getItems ( ) . size ( ) ; 
i ++ ) { 
OOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; 
if ( orderItem . getCollate ( ) != null ) return false ; 
String indexField = indexFields . get ( i ) ; 
if ( i == 0 ) orderType = orderItem . getType ( ) ; 
else if ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { 
indexFound = false ; 
break ; 
} 
if ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { 
indexFound = false ; 
break ; 
} 
} 
if ( indexFound && orderType != null ) { 
plan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; 
int [ ] filterClusterIds = null ; 
if ( filterClusters != null ) filterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; 
plan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; 
if ( info . serverToClusters . size ( ) == 1 ) info . orderApplied = true ; 
return true ; 
} 
} 
return false ; 
} 
} 

public class OSelectExecutionPlanner { 
private boolean isDiamondHierarchy ( OClass clazz ) { 
Set < OClass > traversed = new HashSet < > ( ) ; 
List < OClass > stack = new ArrayList < > ( ) ; 
stack . add ( clazz ) ; 
while ( ! stack . isEmpty ( ) ) { 
OClass current = stack . remove ( 0 ) ; 
traversed . add ( current ) ; 
for ( OClass sub : current . getSubclasses ( ) ) { 
if ( traversed . contains ( sub ) ) return true ; 
stack . add ( sub ) ; 
traversed . add ( sub ) ; 
} 
} 
return false ; 
} 
} 

public class OSelectExecutionPlanner { 
private Boolean getOrderDirection ( QueryPlanningInfo info ) { 
if ( info . orderBy == null ) return null ; 
String result = null ; 
for ( OOrderByItem item : info . orderBy . getItems ( ) ) { 
if ( result == null ) result = item . getType ( ) == null ? OOrderByItem . ASC : item . getType ( ) ; 
else { 
String newType = item . getType ( ) == null ? OOrderByItem . ASC : item . getType ( ) ; 
if ( ! newType . equals ( result ) ) return null ; 
} 
} 
return result == null || result . equals ( OOrderByItem . ASC ) ; 
} 
} 

public class OSelectExecutionPlanner { 
private boolean requiresMultipleIndexLookups ( OAndBlock keyCondition ) { 
for ( OBooleanExpression oBooleanExpression : keyCondition . getSubBlocks ( ) ) { 
if ( ! ( oBooleanExpression instanceof OBinaryCondition ) ) return true ; 
} 
return false ; 
} 
} 

public class OSelectExecutionPlanner { 
private IndexSearchDescriptor buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index , OAndBlock block , OClass clazz ) { 
List < String > indexFields = index . getDefinition ( ) . getFields ( ) ; 
OBinaryCondition keyCondition = new OBinaryCondition ( - 1 ) ; 
OIdentifier key = new OIdentifier ( "key" ) ; 
keyCondition . setLeft ( new OExpression ( key ) ) ; 
boolean found = false ; 
OAndBlock blockCopy = block . copy ( ) ; 
Iterator < OBooleanExpression > blockIterator ; 
OAndBlock indexKeyValue = new OAndBlock ( - 1 ) ; 
IndexSearchDescriptor result = new IndexSearchDescriptor ( ) ; 
result . idx = index ; 
result . keyCondition = indexKeyValue ; 
for ( String indexField : indexFields ) { 
blockIterator = blockCopy . getSubBlocks ( ) . iterator ( ) ; 
boolean breakHere = false ; 
boolean indexFieldFound = false ; 
while ( blockIterator . hasNext ( ) ) { 
OBooleanExpression singleExp = blockIterator . next ( ) ; 
if ( singleExp instanceof OContainsTextCondition ) { 
OExpression left = ( ( OContainsTextCondition ) singleExp ) . getLeft ( ) ; 
if ( left . isBaseIdentifier ( ) ) { 
String fieldName = left . getDefaultAlias ( ) . getStringValue ( ) ; 
if ( indexField . equals ( fieldName ) ) { 
found = true ; 
indexFieldFound = true ; 
OContainsTextCondition condition = new OContainsTextCondition ( - 1 ) ; 
condition . setLeft ( left ) ; 
condition . setRight ( ( ( OContainsTextCondition ) singleExp ) . getRight ( ) . copy ( ) ) ; 
indexKeyValue . getSubBlocks ( ) . add ( condition ) ; 
blockIterator . remove ( ) ; 
break ; 
} 
} 
} 
} 
if ( breakHere || ! indexFieldFound ) break ; 
} 
if ( result . keyCondition . getSubBlocks ( ) . size ( ) < index . getDefinition ( ) . getFields ( ) . size ( ) && ! index . supportsOrderedIterations ( ) ) return null ; 
if ( found ) { 
result . remainingCondition = blockCopy ; 
return result ; 
} 
return null ; 
} 
} 

public class ODocumentFieldHandlingStrategyFactory { 
public ODocumentFieldHandlingStrategy create ( int strategy ) { 
Optional < ODocumentFieldHandlingStrategy > registered = ODocumentFieldHandlingStrategyRegistry . getInstance ( ) . getStrategy ( strategy ) ; 
if ( registered . isPresent ( ) ) return registered . get ( ) ; 
Map < OType , ODocumentFieldOTypeHandlingStrategy > typeHandlingStrategies = new HashMap < OType , ODocumentFieldOTypeHandlingStrategy > ( ) ; 
switch ( strategy ) { 
case SINGLE_ORECORD_BYTES : typeHandlingStrategies . put ( OType . BINARY , new ODocumentSingleRecordBytesOTypeHandlingStrategy ( ) ) ; 
break ; 
case SPLIT_ORECORD_BYTES : typeHandlingStrategies . put ( OType . BINARY , new ODocumentSplitRecordBytesOTypeHandlingStrategy ( ) ) ; 
break ; 
case SIMPLE : default : break ; 
} 
ODocumentSmartFieldHandlingStrategy strategyInstance = new ODocumentSmartFieldHandlingStrategy ( typeHandlingStrategies ) ; 
ODocumentFieldHandlingStrategyRegistry . getInstance ( ) . registerStrategy ( strategy , strategyInstance ) ; 
return strategyInstance ; 
} 
} 

public class OUser { 
public ORole allow ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific , final int iOperation ) { 
if ( roles == null || roles . isEmpty ( ) ) if ( document . field ( "roles" ) != null && ! ( ( Collection < OIdentifiable > ) document . field ( "roles" ) ) . isEmpty ( ) ) { 
final ODocument doc = document ; 
document = null ; 
fromStream ( doc ) ; 
} 
else throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , "User '" + document . field ( "name" ) + "' has no role defined" ) ; 
final ORole role = checkIfAllowed ( resourceGeneric , resourceSpecific , iOperation ) ; 
if ( role == null ) throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , "User '" + document . field ( "name" ) + "' does not have permission to execute the operation '" + ORole . permissionToString ( iOperation ) + "' against the resource: " + resourceGeneric + "." + resourceSpecific ) ; 
return role ; 
} 
} 

public class OMicroTransaction { 
public void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { 
if ( oldRid . equals ( newRid ) ) return ; 
final List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList < > ( ) ; 
final OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; 
for ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { 
final OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; 
if ( index == null ) throw new OTransactionException ( "Cannot find index '" + entry . getValue ( ) + "' while committing transaction" ) ; 
final Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; 
if ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) continue ; 
final OTransactionIndexChanges indexChanges = entry . getValue ( ) ; 
for ( final Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; 
iterator . hasNext ( ) ; 
) { 
final OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; 
if ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { 
keyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; 
iterator . remove ( ) ; 
} 
} 
} 
final ORecordOperation rec = resolveRecordOperation ( oldRid ) ; 
if ( rec != null ) { 
updatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; 
if ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { 
ORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; 
final ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; 
if ( recordId == null ) ORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; 
else { 
recordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; 
recordId . setClusterId ( newRid . getClusterId ( ) ) ; 
} 
ORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; 
} 
} 
for ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; 
final List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; 
if ( transactionIndexOperations != null ) for ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { 
OTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; 
if ( indexEntryChanges == null ) continue ; 
final OTransactionIndexChangesPerKey keyChanges ; 
if ( indexOperation . key == null ) keyChanges = indexEntryChanges . nullKeyChanges ; 
else keyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; 
if ( keyChanges != null ) updateChangesIdentity ( oldRid , newRid , keyChanges ) ; 
} 
} 
} 

public class ODistributedStorage { 
protected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { 
boolean executeLocally = false ; 
if ( exec . isIdempotent ( ) ) { 
final int availableNodes = nodes . size ( ) ; 
int maxReadQuorum ; 
if ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; 
else { 
maxReadQuorum = 0 ; 
for ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; 
} 
if ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; 
} 
return executeLocally ; 
} 
public boolean isLocalEnv ( ) { 
return localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; 
} 
public OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { 
if ( isLocalEnv ( ) ) return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; 
final ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; 
if ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; 
try { 
final String clusterName = getClusterNameByRID ( iRecordId ) ; 
final ODistributedConfiguration dbCfg = distributedConfiguration ; 
final List < String > nodes = dbCfg . getServers ( clusterName , null ) ; 
final int availableNodes = nodes . size ( ) ; 
final String localNodeName = dManager . getLocalNodeName ( ) ; 
if ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { 
@ Override public Object call ( ) throws Exception { 
return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; 
} 
} 
) ; 
final OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; 
final ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; 
final Object dResult = response != null ? response . getPayload ( ) : null ; 
if ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; 
else if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( "Error on execution distributed read record" ) , ( Exception ) dResult ) ; 
return new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; 
} 
catch ( ONeedRetryException e ) { 
throw e ; 
} 
catch ( Exception e ) { 
handleDistributedException ( "Cannot route read record operation for %s to the distributed node" , e , iRecordId ) ; 
return null ; 
} 
} 
@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { 
if ( isLocalEnv ( ) ) return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; 
final ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; 
if ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; 
try { 
final String clusterName = getClusterNameByRID ( rid ) ; 
final ODistributedConfiguration dbCfg = distributedConfiguration ; 
final List < String > nodes = dbCfg . getServers ( clusterName , null ) ; 
final int availableNodes = nodes . size ( ) ; 
final String localNodeName = dManager . getLocalNodeName ( ) ; 
if ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { 
@ Override public Object call ( ) throws Exception { 
return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; 
} 
} 
) ; 
final OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; 
task . init ( rid , recordVersion ) ; 
final Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; 
if ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; 
else if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( "Error on execution distributed read record" ) , ( Exception ) result ) ; 
return new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; 
} 
catch ( ONeedRetryException e ) { 
throw e ; 
} 
catch ( Exception e ) { 
handleDistributedException ( "Cannot route read record operation for %s to the distributed node" , e , rid ) ; 
return null ; 
} 
} 
@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { 
return wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; 
} 
} 

public class OCommandExecutorSQLCreateProperty { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( type == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocument database = getDatabase ( ) ; 
final OClassEmbedded sourceClass = ( OClassEmbedded ) database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; 
if ( sourceClass == null ) throw new OCommandExecutionException ( "Source class '" + className + "' not found" ) ; 
OPropertyImpl prop = ( OPropertyImpl ) sourceClass . getProperty ( fieldName ) ; 
if ( prop != null ) { 
if ( ifNotExists ) return sourceClass . properties ( ) . size ( ) ; 
throw new OCommandExecutionException ( "Property '" + className + "." + fieldName + "' already exists. Remove it before to retry." ) ; 
} 
OClass linkedClass = null ; 
OType linkedType = null ; 
if ( linked != null ) { 
linkedClass = database . getMetadata ( ) . getSchema ( ) . getClass ( linked ) ; 
if ( linkedClass == null ) linkedType = OType . valueOf ( linked . toUpperCase ( Locale . ENGLISH ) ) ; 
} 
OPropertyImpl internalProp = sourceClass . addPropertyInternal ( fieldName , type , linkedType , linkedClass , unsafe ) ; 
if ( readonly ) internalProp . setReadonly ( true ) ; 
if ( mandatory ) internalProp . setMandatory ( true ) ; 
if ( notnull ) internalProp . setNotNull ( true ) ; 
if ( max != null ) internalProp . setMax ( max ) ; 
if ( min != null ) internalProp . setMin ( min ) ; 
if ( defaultValue != null ) internalProp . setDefaultValue ( defaultValue ) ; 
return sourceClass . properties ( ) . size ( ) ; 
} 
} 

public class OIndexFullText { 
@ Override public OIndexFullText put ( Object key , final OIdentifiable singleValue ) { 
if ( key == null ) return this ; 
key = getCollatingValue ( key ) ; 
final Set < String > words = splitIntoWords ( key . toString ( ) ) ; 
for ( final String word : words ) { 
acquireSharedLock ( ) ; 
try { 
if ( apiVersion == 0 ) doPutV0 ( singleValue , word ) ; 
else if ( apiVersion == 1 ) doPutV1 ( singleValue , word ) ; 
else throw new IllegalStateException ( "Invalid API version, " + apiVersion ) ; 
} 
finally { 
releaseSharedLock ( ) ; 
} 
} 
return this ; 
} 
} 

public class OIndexFullText { 
@ Override public boolean remove ( Object key , final OIdentifiable value ) { 
if ( key == null ) return false ; 
key = getCollatingValue ( key ) ; 
final Set < String > words = splitIntoWords ( key . toString ( ) ) ; 
final OModifiableBoolean removed = new OModifiableBoolean ( false ) ; 
for ( final String word : words ) { 
acquireSharedLock ( ) ; 
try { 
if ( apiVersion == 0 ) removeV0 ( value , removed , word ) ; 
else if ( apiVersion == 1 ) removeV1 ( value , removed , word ) ; 
else throw new IllegalStateException ( "Invalid API version, " + apiVersion ) ; 
} 
finally { 
releaseSharedLock ( ) ; 
} 
} 
return removed . getValue ( ) ; 
} 
} 

public class OSQLQuery { 
@ SuppressWarnings ( "unchecked" ) public List < T > run ( final Object ... iArgs ) { 
final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; 
if ( database == null ) throw new OQueryParsingException ( "No database configured" ) ; 
( ( OMetadataInternal ) database . getMetadata ( ) ) . makeThreadLocalSchemaSnapshot ( ) ; 
try { 
setParameters ( iArgs ) ; 
Object o = database . getStorage ( ) . command ( this ) ; 
if ( o instanceof List ) return ( List < T > ) o ; 
else return ( List < T > ) Collections . singletonList ( o ) ; 
} 
finally { 
( ( OMetadataInternal ) database . getMetadata ( ) ) . clearThreadLocalSchemaSnapshot ( ) ; 
} 
} 
} 

public class OFileClassic { 
private long checkRegions ( final long iOffset , final long iLength ) { 
acquireReadLock ( ) ; 
try { 
if ( iOffset < 0 || iOffset + iLength > size ) throw new OIOException ( "You cannot access outside the file size (" + size + " bytes). You have requested portion " + iOffset + "-" + ( iOffset + iLength ) + " bytes. File: " + this ) ; 
return iOffset + HEADER_SIZE ; 
} 
finally { 
releaseReadLock ( ) ; 
} 
} 
} 

public class OLazyCollectionUtil { 
protected static OObjectDatabaseTx getDatabase ( ) { 
ODatabaseInternal < ? > databaseOwner = ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ; 
if ( databaseOwner instanceof OObjectDatabaseTx ) return ( OObjectDatabaseTx ) databaseOwner ; 
else if ( databaseOwner instanceof ODatabaseDocumentInternal ) return new OObjectDatabaseTx ( ( ODatabaseDocumentInternal ) databaseOwner ) ; 
throw new IllegalStateException ( "Current database not of expected type" ) ; 
} 
} 

public class OClientConnectionManager { 
public void pushDistribCfg2Clients ( final ODocument iConfig ) { 
if ( iConfig == null ) return ; 
final Set < String > pushed = new HashSet < String > ( ) ; 
for ( OClientConnection c : connections . values ( ) ) { 
if ( ! c . getData ( ) . supportsLegacyPushMessages ) continue ; 
try { 
final String remoteAddress = c . getRemoteAddress ( ) ; 
if ( pushed . contains ( remoteAddress ) ) continue ; 
} 
catch ( Exception e ) { 
continue ; 
} 
if ( ! ( c . getProtocol ( ) instanceof ONetworkProtocolBinary ) || c . getData ( ) . getSerializationImpl ( ) == null ) continue ; 
final ONetworkProtocolBinary p = ( ONetworkProtocolBinary ) c . getProtocol ( ) ; 
final OChannelBinary channel = p . getChannel ( ) ; 
final ORecordSerializer ser = ORecordSerializerFactory . instance ( ) . getFormat ( c . getData ( ) . getSerializationImpl ( ) ) ; 
if ( ser == null ) return ; 
final byte [ ] content = ser . toStream ( iConfig , false ) ; 
try { 
if ( channel . tryAcquireWriteLock ( TIMEOUT_PUSH ) ) try { 
channel . writeByte ( OChannelBinaryProtocol . PUSH_DATA ) ; 
channel . writeInt ( Integer . MIN_VALUE ) ; 
channel . writeByte ( OChannelBinaryProtocol . REQUEST_PUSH_DISTRIB_CONFIG ) ; 
channel . writeBytes ( content ) ; 
channel . flush ( ) ; 
pushed . add ( c . getRemoteAddress ( ) ) ; 
OLogManager . instance ( ) . debug ( this , "Sent updated cluster configuration to the remote client %s" , c . getRemoteAddress ( ) ) ; 
} 
finally { 
channel . releaseWriteLock ( ) ; 
} 
else OLogManager . instance ( ) . info ( this , "Timeout on sending updated cluster configuration to the remote client %s" , c . getRemoteAddress ( ) ) ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . warn ( this , "Cannot push cluster configuration to the client %s" , e , c . getRemoteAddress ( ) ) ; 
} 
} 
} 
} 

public class OTransactionAbstract { 
@ Override public void close ( ) { 
for ( Map . Entry < ORID , LockedRecordMetadata > lock : locks . entrySet ( ) ) { 
try { 
final LockedRecordMetadata lockedRecordMetadata = lock . getValue ( ) ; 
if ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . EXCLUSIVE_LOCK ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseWriteLock ( lock . getKey ( ) ) ; 
else if ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . SHARED_LOCK ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseReadLock ( lock . getKey ( ) ) ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . debug ( this , "Error on releasing lock against record " + lock . getKey ( ) , e ) ; 
} 
} 
locks . clear ( ) ; 
} 
} 

public class OSchemaProxyObject { 
public synchronized void synchronizeSchema ( ) { 
OObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; 
Collection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; 
boolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; 
boolean reloadSchema = false ; 
for ( Class < ? > iClass : registeredEntities ) { 
if ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) || iClass . isAnonymousClass ( ) ) return ; 
if ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { 
database . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; 
reloadSchema = true ; 
} 
for ( Class < ? > currentClass = iClass ; 
currentClass != Object . class ; 
) { 
if ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) && ! currentClass . equals ( ODocument . class ) ) ( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; 
String iClassName = currentClass . getSimpleName ( ) ; 
currentClass = currentClass . getSuperclass ( ) ; 
if ( currentClass == null || currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; 
if ( database != null && ! database . isClosed ( ) && ! currentClass . equals ( Object . class ) ) { 
OClass oSuperClass ; 
OClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; 
if ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) { 
oSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; 
reloadSchema = true ; 
} 
else { 
oSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; 
reloadSchema = true ; 
} 
if ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { 
currentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; 
reloadSchema = true ; 
} 
} 
} 
} 
if ( database != null && ! database . isClosed ( ) && reloadSchema ) database . getMetadata ( ) . getSchema ( ) . reload ( ) ; 
} 
} 

public class OJSONReader { 
public int nextChar ( ) throws IOException { 
if ( missedChar != null ) { 
c = missedChar . charValue ( ) ; 
missedChar = null ; 
} 
else { 
int read = in . read ( ) ; 
if ( read == - 1 ) return - 1 ; 
c = ( char ) read ; 
if ( c == '\\' ) { 
read = in . read ( ) ; 
if ( read == - 1 ) return - 1 ; 
char c2 = ( char ) read ; 
if ( c2 == 'u' ) { 
final StringBuilder buff = new StringBuilder ( 8 ) ; 
for ( int i = 0 ; 
i < 4 ; 
++ i ) { 
read = in . read ( ) ; 
if ( read == - 1 ) return - 1 ; 
buff . append ( ( char ) read ) ; 
} 
cursor += 6 ; 
return ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; 
} 
else missedChar = c2 ; 
} 
} 
cursor ++ ; 
if ( c == NEW_LINE ) { 
++ lineNumber ; 
columnNumber = 0 ; 
} 
else ++ columnNumber ; 
return ( char ) c ; 
} 
} 

public class OCommandRequestAbstract { 
@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { 
if ( iCallback != null ) onAsyncReplicationError = new OAsyncReplicationError ( ) { 
int retry = 0 ; 
@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { 
switch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { 
case RETRY : execute ( ) ; 
break ; 
case IGNORE : } 
return ACTION . IGNORE ; 
} 
} 
; 
else onAsyncReplicationError = null ; 
return this ; 
} 
} 

public class ONative { 
public int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { 
if ( Platform . isLinux ( ) ) { 
final OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; 
final int result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; 
if ( result == 0 && rlimit . rlim_cur > 0 ) { 
if ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , "Detected limit of amount of simultaneously open files is %d, " + " limit of open files for disk cache will be set to %d" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; 
if ( rlimit . rlim_cur < recommended ) OLogManager . instance ( ) . warnNoDb ( this , "Value of limit of simultaneously open files is too small, recommended value is %d" , recommended ) ; 
return ( int ) rlimit . rlim_cur / 2 - 512 ; 
} 
else if ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , "Can not detect value of limit of open files." ) ; 
} 
else if ( Platform . isWindows ( ) ) { 
if ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , "Windows OS is detected, %d limit of open files will be set for the disk cache." , recommended ) ; 
return recommended ; 
} 
if ( verbose ) OLogManager . instance ( ) . infoNoDb ( this , "Default limit of open files (%d) will be used." , defLimit ) ; 
return defLimit ; 
} 
} 

public class OMathExpression { 
public boolean allowsIndexedFunctionExecutionOnTarget ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { 
if ( this . childExpressions . size ( ) != 1 ) return false ; 
return this . childExpressions . get ( 0 ) . allowsIndexedFunctionExecutionOnTarget ( target , context , operator , right ) ; 
} 
} 

public class OScriptExecutionPlan { 
public OExecutionStepInternal executeUntilReturn ( ) { 
if ( steps . size ( ) > 0 ) lastStep = steps . get ( steps . size ( ) - 1 ) ; 
for ( int i = 0 ; 
i < steps . size ( ) - 1 ; 
i ++ ) { 
ScriptLineStep step = steps . get ( i ) ; 
if ( step . containsReturn ( ) ) { 
OExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; 
if ( returnStep != null ) { 
lastStep = returnStep ; 
return lastStep ; 
} 
} 
OResultSet lastResult = step . syncPull ( ctx , 100 ) ; 
while ( lastResult . hasNext ( ) ) { 
while ( lastResult . hasNext ( ) ) lastResult . next ( ) ; 
lastResult = step . syncPull ( ctx , 100 ) ; 
} 
} 
this . lastStep = steps . get ( steps . size ( ) - 1 ) ; 
return lastStep ; 
} 
} 

public class OScriptExecutionPlan { 
public OExecutionStepInternal executeFull ( ) { 
for ( int i = 0 ; 
i < steps . size ( ) ; 
i ++ ) { 
ScriptLineStep step = steps . get ( i ) ; 
if ( step . containsReturn ( ) ) { 
OExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; 
if ( returnStep != null ) return returnStep ; 
} 
OResultSet lastResult = step . syncPull ( ctx , 100 ) ; 
while ( lastResult . hasNext ( ) ) { 
while ( lastResult . hasNext ( ) ) lastResult . next ( ) ; 
lastResult = step . syncPull ( ctx , 100 ) ; 
} 
} 
return null ; 
} 
} 

public class OMatchStatement { 
@ Override public < RET extends OCommandExecutor > RET parse ( OCommandRequest iRequest ) { 
final OCommandRequestText textRequest = ( OCommandRequestText ) iRequest ; 
if ( iRequest instanceof OSQLSynchQuery ) request = ( OSQLSynchQuery < ODocument > ) iRequest ; 
else if ( iRequest instanceof OSQLAsynchQuery ) request = ( OSQLAsynchQuery < ODocument > ) iRequest ; 
else { 
request = new OSQLSynchQuery < ODocument > ( textRequest . getText ( ) ) ; 
if ( textRequest . getResultListener ( ) != null ) request . setResultListener ( textRequest . getResultListener ( ) ) ; 
} 
String queryText = textRequest . getText ( ) ; 
final InputStream is = new ByteArrayInputStream ( queryText . getBytes ( ) ) ; 
OrientSql osql = null ; 
try { 
ODatabaseDocumentInternal db = getDatabase ( ) ; 
if ( db == null ) osql = new OrientSql ( is ) ; 
else osql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
OLogManager . instance ( ) . warn ( this , "Invalid charset for database " + getDatabase ( ) + " " + getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; 
osql = new OrientSql ( is ) ; 
} 
try { 
OMatchStatement result = ( OMatchStatement ) osql . parse ( ) ; 
this . matchExpressions = result . matchExpressions ; 
this . notMatchExpressions = result . notMatchExpressions ; 
this . returnItems = result . returnItems ; 
this . returnAliases = result . returnAliases ; 
this . limit = result . limit ; 
} 
catch ( ParseException e ) { 
OCommandSQLParsingException ex = new OCommandSQLParsingException ( e , queryText ) ; 
OErrorCode . QUERY_PARSE_ERROR . throwException ( ex . getMessage ( ) , ex ) ; 
} 
buildPatterns ( ) ; 
pattern . validate ( ) ; 
return ( RET ) this ; 
} 
} 

public class OMatchStatement { 
private void updateScheduleStartingAt ( PatternNode startNode , Set < PatternNode > visitedNodes , Set < PatternEdge > visitedEdges , Map < String , Set < String > > remainingDependencies , List < EdgeTraversal > resultingSchedule ) { 
visitedNodes . add ( startNode ) ; 
for ( Set < String > dependencies : remainingDependencies . values ( ) ) { 
dependencies . remove ( startNode . alias ) ; 
} 
Map < PatternEdge , Boolean > edges = new LinkedHashMap < PatternEdge , Boolean > ( ) ; 
for ( PatternEdge outEdge : startNode . out ) { 
edges . put ( outEdge , true ) ; 
} 
for ( PatternEdge inEdge : startNode . in ) { 
edges . put ( inEdge , false ) ; 
} 
for ( Map . Entry < PatternEdge , Boolean > edgeData : edges . entrySet ( ) ) { 
PatternEdge edge = edgeData . getKey ( ) ; 
boolean isOutbound = edgeData . getValue ( ) ; 
PatternNode neighboringNode = isOutbound ? edge . in : edge . out ; 
if ( ! remainingDependencies . get ( neighboringNode . alias ) . isEmpty ( ) ) continue ; 
if ( visitedNodes . contains ( neighboringNode ) ) if ( ! visitedEdges . contains ( edge ) ) { 
boolean traversalDirection ; 
if ( startNode . optional || edge . item . isBidirectional ( ) ) traversalDirection = ! isOutbound ; 
else traversalDirection = isOutbound ; 
visitedEdges . add ( edge ) ; 
resultingSchedule . add ( new EdgeTraversal ( edge , traversalDirection ) ) ; 
} 
else if ( ! startNode . optional ) { 
if ( visitedEdges . contains ( edge ) ) throw new AssertionError ( "The edge was visited, but the neighboring vertex was not: " + edge + " " + neighboringNode ) ; 
visitedEdges . add ( edge ) ; 
resultingSchedule . add ( new EdgeTraversal ( edge , isOutbound ) ) ; 
updateScheduleStartingAt ( neighboringNode , visitedNodes , visitedEdges , remainingDependencies , resultingSchedule ) ; 
} 
} 
} 
} 

public class OCompositeIndexDefinition { 
public void addIndex ( final OIndexDefinition indexDefinition ) { 
indexDefinitions . add ( indexDefinition ) ; 
if ( indexDefinition instanceof OIndexDefinitionMultiValue ) if ( multiValueDefinitionIndex == - 1 ) multiValueDefinitionIndex = indexDefinitions . size ( ) - 1 ; 
else throw new OIndexException ( "Composite key cannot contain more than one collection item" ) ; 
collate . addCollate ( indexDefinition . getCollate ( ) ) ; 
} 
} 

public class OProjectionItem { 
public OProjectionItem splitForAggregation ( AggregateProjectionSplit aggregateSplit , OCommandContext ctx ) { 
if ( isAggregate ( ) ) { 
OProjectionItem result = new OProjectionItem ( - 1 ) ; 
result . alias = getProjectionAlias ( ) ; 
result . expression = expression . splitForAggregation ( aggregateSplit , ctx ) ; 
result . nestedProjection = nestedProjection ; 
return result ; 
} 
else return this ; 
} 
} 

public class OJson { 
public Object toObjectDetermineType ( OResult source , OCommandContext ctx ) { 
String className = getClassNameForDocument ( ctx ) ; 
String type = getTypeForDocument ( ctx ) ; 
if ( className != null || ( type != null && "d" . equalsIgnoreCase ( type ) ) ) return toDocument ( source , ctx , className ) ; 
else return toMap ( source , ctx ) ; 
} 
} 

public class OSQLFilterItemField { 
public OCollate getCollate ( Object doc ) { 
if ( collate != null || operationsChain == null || ! isFieldChain ( ) ) return collate ; 
if ( ! ( doc instanceof OIdentifiable ) ) return null ; 
FieldChain chain = getFieldChain ( ) ; 
ODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; 
for ( int i = 0 ; 
i < chain . getItemCount ( ) - 1 ; 
i ++ ) { 
if ( lastDoc == null ) return null ; 
Object nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; 
if ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) return null ; 
lastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; 
} 
if ( lastDoc == null ) return null ; 
OClass schemaClass = lastDoc . getSchemaClass ( ) ; 
if ( schemaClass == null ) return null ; 
OProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; 
if ( property == null ) return null ; 
return property . getCollate ( ) ; 
} 
} 

public class OIdentifier { 
public String getStringValue ( ) { 
if ( value == null ) return null ; 
if ( value . contains ( "`" ) ) return value . replaceAll ( "\\\\`" , "`" ) ; 
return value ; 
} 
} 

public class OFileManager { 
public static ODocument buildJsonFromFile ( String filePath ) throws IOException { 
if ( filePath == null ) return null ; 
File jsonFile = new File ( filePath ) ; 
if ( ! jsonFile . exists ( ) ) return null ; 
FileInputStream is = new FileInputStream ( jsonFile ) ; 
BufferedReader rd = new BufferedReader ( new InputStreamReader ( is , Charset . forName ( "UTF-8" ) ) ) ; 
ODocument json = new ODocument ( ) ; 
String jsonText = OFileManager . readAllTextFile ( rd ) ; 
json . fromJSON ( jsonText , "noMap" ) ; 
return json ; 
} 
} 

public class OSecurityManager { 
public String createHash ( final String iInput , final String iAlgorithm , final boolean iIncludeAlgorithm ) { 
if ( iInput == null ) throw new IllegalArgumentException ( "Input string is null" ) ; 
if ( iAlgorithm == null ) throw new IllegalArgumentException ( "Algorithm is null" ) ; 
final StringBuilder buffer = new StringBuilder ( 128 ) ; 
final String algorithm = validateAlgorithm ( iAlgorithm ) ; 
if ( iIncludeAlgorithm ) { 
buffer . append ( '{' ) ; 
buffer . append ( algorithm ) ; 
buffer . append ( '}' ) ; 
} 
final String transformed ; 
if ( HASH_ALGORITHM . equalsIgnoreCase ( algorithm ) ) transformed = createSHA256 ( iInput ) ; 
else if ( PBKDF2_ALGORITHM . equalsIgnoreCase ( algorithm ) ) transformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; 
else if ( PBKDF2_SHA256_ALGORITHM . equalsIgnoreCase ( algorithm ) ) transformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; 
else throw new IllegalArgumentException ( "Algorithm '" + algorithm + "' is not supported" ) ; 
buffer . append ( transformed ) ; 
return buffer . toString ( ) ; 
} 
} 

public class OSecurityManager { 
private static boolean isAlgorithmSupported ( final String algorithm ) { 
if ( Runtime . class . getPackage ( ) != null && Runtime . class . getPackage ( ) . getImplementationVersion ( ) != null ) if ( Runtime . class . getPackage ( ) . getImplementationVersion ( ) . startsWith ( "1.7" ) ) if ( algorithm != null && algorithm . equals ( PBKDF2_SHA256_ALGORITHM ) ) return false ; 
return true ; 
} 
} 

public class OIndexAbstract { 
public OIndexInternal < ? > create ( final OIndexDefinition indexDefinition , final String clusterIndexName , final Set < String > clustersToIndex , boolean rebuild , final OProgressListener progressListener , final OBinarySerializer valueSerializer ) { 
acquireExclusiveLock ( ) ; 
try { 
configuration = indexConfigurationInstance ( new ODocument ( ) . setTrackingChanges ( false ) ) ; 
this . indexDefinition = indexDefinition ; 
if ( clustersToIndex != null ) this . clustersToIndex = new HashSet < > ( clustersToIndex ) ; 
else this . clustersToIndex = new HashSet < > ( ) ; 
try { 
if ( apiVersion == 0 ) removeValuesContainer ( ) ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . error ( this , "Error during deletion of index '%s'" , e , name ) ; 
} 
indexId = storage . addIndexEngine ( name , algorithm , type , indexDefinition , valueSerializer , isAutomatic ( ) , true , version , 1 , this instanceof OIndexMultiValues , getEngineProperties ( ) , clustersToIndex , metadata ) ; 
apiVersion = OAbstractPaginatedStorage . extractEngineAPIVersion ( indexId ) ; 
assert indexId >= 0 ; 
assert apiVersion >= 0 ; 
onIndexEngineChange ( indexId ) ; 
if ( rebuild ) fillIndex ( progressListener , false ) ; 
updateConfiguration ( ) ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . error ( this , "Exception during index '%s' creation" , e , name ) ; 
while ( true ) try { 
if ( indexId >= 0 ) storage . deleteIndexEngine ( indexId ) ; 
break ; 
} 
catch ( OInvalidIndexEngineIdException ignore ) { 
doReloadIndexEngine ( ) ; 
} 
catch ( Exception ex ) { 
OLogManager . instance ( ) . error ( this , "Exception during index '%s' deletion" , ex , name ) ; 
} 
if ( e instanceof OIndexException ) throw ( OIndexException ) e ; 
throw OException . wrapException ( new OIndexException ( "Cannot create the index '" + name + "'" ) , e ) ; 
} 
finally { 
releaseExclusiveLock ( ) ; 
} 
return this ; 
} 
} 

public class OrientGraphQuery { 
@ Override public Iterable < Vertex > vertices ( ) { 
if ( limit == 0 ) return Collections . emptyList ( ) ; 
OTransaction transaction = ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) ; 
if ( transaction . isActive ( ) && transaction . getEntryCount ( ) > 0 || hasCustomPredicate ( ) ) { 
String [ ] classes = allSubClassesLabels ( ) ; 
return new OrientGraphQueryIterable < Vertex > ( true , classes ) ; 
} 
final StringBuilder text = new StringBuilder ( 512 ) ; 
text . append ( QUERY_SELECT_FROM ) ; 
if ( ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) && labels != null && labels . length > 0 ) if ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; 
else { 
String [ ] classes = allSubClassesLabels ( ) ; 
return new OrientGraphQueryIterable < Vertex > ( true , classes ) ; 
} 
else text . append ( OrientVertexType . CLASS_NAME ) ; 
final List < Object > queryParams = manageFilters ( text ) ; 
if ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; 
if ( orderBy . length ( ) > 1 ) { 
text . append ( ORDERBY ) ; 
text . append ( orderBy ) ; 
text . append ( " " ) . append ( orderByDir ) . append ( " " ) ; 
} 
if ( skip > 0 && skip < Integer . MAX_VALUE ) { 
text . append ( SKIP ) ; 
text . append ( skip ) ; 
} 
if ( limit > 0 && limit < Integer . MAX_VALUE ) { 
text . append ( LIMIT ) ; 
text . append ( limit ) ; 
} 
final OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; 
if ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; 
return new OrientElementIterable < Vertex > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; 
} 
} 

public class OrientGraphQuery { 
@ Override public Iterable < Edge > edges ( ) { 
if ( limit == 0 ) return Collections . emptyList ( ) ; 
if ( ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) . isActive ( ) || hasCustomPredicate ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; 
if ( ( ( OrientBaseGraph ) graph ) . isUseLightweightEdges ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; 
final StringBuilder text = new StringBuilder ( 512 ) ; 
text . append ( QUERY_SELECT_FROM ) ; 
if ( ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) && labels != null && labels . length > 0 ) if ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; 
else return new OrientGraphQueryIterable < Edge > ( false , labels ) ; 
else text . append ( OrientEdgeType . CLASS_NAME ) ; 
List < Object > queryParams = manageFilters ( text ) ; 
if ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; 
final OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; 
if ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; 
if ( limit > 0 && limit < Integer . MAX_VALUE ) query . setLimit ( limit ) ; 
return new OrientElementIterable < Edge > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; 
} 
} 

public class OAtomicOperation { 
private static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { 
if ( changesContainer == null ) return true ; 
else if ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) return pageIndex < changesContainer . maxNewPageIndex + 1 ; 
else return ! changesContainer . truncate ; 
} 
} 

public class OSystemDatabase { 
public void createCluster ( final String className , final String clusterName ) { 
final ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; 
try { 
final ODatabaseDocumentInternal sysdb = openSystemDatabase ( ) ; 
try { 
if ( ! sysdb . existsCluster ( clusterName ) ) { 
OSchema schema = sysdb . getMetadata ( ) . getSchema ( ) ; 
OClass cls = schema . getClass ( className ) ; 
if ( cls != null ) cls . addCluster ( clusterName ) ; 
else OLogManager . instance ( ) . error ( this , "createCluster() Class name %s does not exist" , null , className ) ; 
} 
} 
finally { 
sysdb . close ( ) ; 
} 
} 
finally { 
if ( currentDB != null ) ODatabaseRecordThreadLocal . instance ( ) . set ( currentDB ) ; 
else ODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; 
} 
} 
} 

public class OCommandExecutorSQLDelete { 
public boolean result ( final Object iRecord ) { 
final ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; 
if ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) return true ; 
try { 
if ( record . getIdentity ( ) . isValid ( ) ) { 
if ( returning . equalsIgnoreCase ( "BEFORE" ) ) allDeletedRecords . add ( record ) ; 
if ( ! unsafe && record instanceof ODocument ) { 
final OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; 
if ( cls != null ) if ( cls . isSubClassOf ( "V" ) ) throw new OCommandExecutionException ( "'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it" ) ; 
else if ( cls . isSubClassOf ( "E" ) ) throw new OCommandExecutionException ( "'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it" ) ; 
} 
record . delete ( ) ; 
recordCount ++ ; 
return true ; 
} 
return false ; 
} 
finally { 
if ( lockStrategy . equalsIgnoreCase ( "RECORD" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; 
} 
} 
} 

public class OSQLPredicate { 
public void bindParameters ( final Map < Object , Object > iArgs ) { 
if ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; 
for ( int i = 0 ; 
i < parameterItems . size ( ) ; 
i ++ ) { 
OSQLFilterItemParameter value = parameterItems . get ( i ) ; 
if ( "?" . equals ( value . getName ( ) ) ) value . setValue ( iArgs . get ( i ) ) ; 
else value . setValue ( iArgs . get ( value . getName ( ) ) ) ; 
} 
} 
} 

public class OPropertyImpl { 
@ Deprecated public OPropertyImpl dropIndexes ( ) { 
getDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_DELETE ) ; 
acquireSchemaReadLock ( ) ; 
try { 
final OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; 
final ArrayList < OIndex < ? > > relatedIndexes = new ArrayList < OIndex < ? > > ( ) ; 
for ( final OIndex < ? > index : indexManager . getClassIndexes ( owner . getName ( ) ) ) { 
final OIndexDefinition definition = index . getDefinition ( ) ; 
if ( OCollections . indexOf ( definition . getFields ( ) , globalRef . getName ( ) , new OCaseInsentiveComparator ( ) ) > - 1 ) if ( definition instanceof OPropertyIndexDefinition ) relatedIndexes . add ( index ) ; 
else throw new IllegalArgumentException ( "This operation applicable only for property indexes. " + index . getName ( ) + " is " + index . getDefinition ( ) ) ; 
} 
for ( final OIndex < ? > index : relatedIndexes ) getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( index . getName ( ) ) ; 
return this ; 
} 
finally { 
releaseSchemaReadLock ( ) ; 
} 
} 
} 

public class ODatabaseDocumentEmbedded { 
public ODatabaseDocumentInternal copy ( ) { 
ODatabaseDocumentEmbedded database = new ODatabaseDocumentEmbedded ( getSharedContext ( ) . getStorage ( ) ) ; 
database . init ( config , this . sharedContext ) ; 
String user ; 
if ( getUser ( ) != null ) user = getUser ( ) . getName ( ) ; 
else user = null ; 
database . internalOpen ( user , null , false ) ; 
database . callOnOpenListeners ( ) ; 
this . activateOnCurrentThread ( ) ; 
return database ; 
} 
} 

public class OCommandExecutorUtility { 
public static Object transformResult ( Object result ) { 
if ( java8MethodIsArray == null || ! ( result instanceof Map ) ) return result ; 
try { 
if ( ( Boolean ) java8MethodIsArray . invoke ( result ) ) { 
List < ? > partial = new ArrayList ( ( ( Map ) result ) . values ( ) ) ; 
List < Object > finalResult = new ArrayList < Object > ( ) ; 
for ( Object o : partial ) { 
finalResult . add ( transformResult ( o ) ) ; 
} 
return finalResult ; 
} 
else { 
Map < Object , Object > mapResult = ( Map ) result ; 
List < Object > keys = new ArrayList < Object > ( mapResult . keySet ( ) ) ; 
for ( Object key : keys ) { 
mapResult . put ( key , transformResult ( mapResult . get ( key ) ) ) ; 
} 
return mapResult ; 
} 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . error ( OCommandExecutorUtility . class , "" , e ) ; 
} 
return result ; 
} 
} 

public class OCommandExecutorSQLCreateCluster { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( clusterName == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocument database = getDatabase ( ) ; 
final int clusterId = database . getClusterIdByName ( clusterName ) ; 
if ( clusterId > - 1 ) throw new OCommandSQLParsingException ( "Cluster '" + clusterName + "' already exists" ) ; 
if ( blob ) if ( requestedId == - 1 ) return database . addBlobCluster ( clusterName ) ; 
else throw new OCommandExecutionException ( "Request id not supported by blob cluster creation." ) ; 
else if ( requestedId == - 1 ) return database . addCluster ( clusterName ) ; 
else return database . addCluster ( clusterName , requestedId , null ) ; 
} 
} 

public class ODatabasePoolAbstract { 
public void close ( ) { 
lock ( ) ; 
try { 
if ( this . evictionTask != null ) this . evictionTask . cancel ( ) ; 
for ( Entry < String , OReentrantResourcePool < String , DB > > pool : pools . entrySet ( ) ) { 
for ( DB db : pool . getValue ( ) . getResources ( ) ) { 
pool . getValue ( ) . close ( ) ; 
try { 
OLogManager . instance ( ) . debug ( this , "Closing pooled database '%s'..." , db . getName ( ) ) ; 
( ( ODatabasePooled ) db ) . forceClose ( ) ; 
OLogManager . instance ( ) . debug ( this , "OK" , db . getName ( ) ) ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . debug ( this , "Error: %d" , e . toString ( ) ) ; 
} 
} 
} 
} 
finally { 
unlock ( ) ; 
} 
} 
} 

public class OSQLEngine { 
public static Set < String > getFunctionNames ( ) { 
final Set < String > types = new HashSet < String > ( ) ; 
final Iterator < OSQLFunctionFactory > ite = getFunctionFactories ( ) ; 
while ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getFunctionNames ( ) ) ; 
return types ; 
} 
} 

public class OSQLEngine { 
public static Set < String > getCollateNames ( ) { 
final Set < String > types = new HashSet < String > ( ) ; 
final Iterator < OCollateFactory > ite = getCollateFactories ( ) ; 
while ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getNames ( ) ) ; 
return types ; 
} 
} 

public class OSQLEngine { 
public static Set < String > getCommandNames ( ) { 
final Set < String > types = new HashSet < String > ( ) ; 
final Iterator < OCommandExecutorSQLFactory > ite = getCommandFactories ( ) ; 
while ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getCommandNames ( ) ) ; 
return types ; 
} 
} 

public class OSBTreeCollectionManagerShared { 
@ Override public UUID listenForChanges ( ORidBag collection ) { 
UUID ownerUUID = collection . getTemporaryId ( ) ; 
if ( ownerUUID != null ) { 
final OBonsaiCollectionPointer pointer = collection . getPointer ( ) ; 
Map < UUID , OBonsaiCollectionPointer > changedPointers = collectionPointerChanges . get ( ) ; 
if ( pointer != null && pointer . isValid ( ) ) changedPointers . put ( ownerUUID , pointer ) ; 
} 
return null ; 
} 
} 

public class OSessionStoragePerformanceStatistic { 
public void pushComponentCounters ( String name , PerformanceCountersHolder holder ) { 
if ( snapshot == null ) return ; 
final PerformanceCountersHolder countersHolder = snapshot . countersByComponent . get ( name ) ; 
if ( countersHolder != null ) countersHolder . pushData ( holder ) ; 
} 
} 

public class OStatementCache { 
protected static OStatement parse ( String statement ) throws OCommandSQLParsingException { 
try { 
ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; 
InputStream is ; 
if ( db == null ) is = new ByteArrayInputStream ( statement . getBytes ( ) ) ; 
else try { 
is = new ByteArrayInputStream ( statement . getBytes ( db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ) ; 
} 
catch ( UnsupportedEncodingException e2 ) { 
OLogManager . instance ( ) . warn ( null , "Unsupported charset for database " + db + " " + db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; 
is = new ByteArrayInputStream ( statement . getBytes ( ) ) ; 
} 
OrientSql osql = null ; 
if ( db == null ) osql = new OrientSql ( is ) ; 
else try { 
osql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; 
} 
catch ( UnsupportedEncodingException e2 ) { 
OLogManager . instance ( ) . warn ( null , "Unsupported charset for database " + db + " " + db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; 
osql = new OrientSql ( is ) ; 
} 
OStatement result = osql . parse ( ) ; 
result . originalStatement = statement ; 
return result ; 
} 
catch ( ParseException e ) { 
throwParsingException ( e , statement ) ; 
} 
catch ( TokenMgrError e2 ) { 
throwParsingException ( e2 , statement ) ; 
} 
return null ; 
} 
} 

public class ONodeManager { 
protected void initReceiveMessages ( ) throws IOException { 
messageThread = new Thread ( ( ) -> { 
while ( ! Thread . interrupted ( ) ) receiveMessages ( ) ; 
} 
) ; 
messageThread . setName ( "OrientDB_DistributedDiscoveryThread" ) ; 
messageThread . setDaemon ( true ) ; 
messageThread . start ( ) ; 
} 
} 

public class ONodeManager { 
protected void initCheckDisconnect ( ) { 
disconnectTimer = new TimerTask ( ) { 
public void run ( ) { 
try { 
checkIfKnownServersAreAlive ( ) ; 
if ( running ) initCheckDisconnect ( ) ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
} 
} 
} 
; 
taskScheduler . scheduleOnce ( disconnectTimer , discoveryPingIntervalMillis ) ; 
} 
} 

public class OrientElement { 
protected String checkForClassInSchema ( final String className ) { 
if ( className == null ) return null ; 
OrientBaseGraph graph = getGraph ( ) ; 
if ( graph == null ) return className ; 
final OSchema schema = graph . getRawGraph ( ) . getMetadata ( ) . getSchema ( ) ; 
if ( ! schema . existsClass ( className ) ) try { 
graph . executeOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { 
@ Override public OClass call ( final OrientBaseGraph g ) { 
return schema . createClass ( className , schema . getClass ( getBaseClassName ( ) ) ) ; 
} 
} 
, "Committing the active transaction to create the new type '" , className , "' as subclass of '" , getBaseClassName ( ) , "'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction" ) ; 
} 
catch ( OSchemaException e ) { 
if ( ! schema . existsClass ( className ) ) throw e ; 
} 
else { 
final OClass cls = schema . getClass ( className ) ; 
if ( ! cls . isSubClassOf ( getBaseClassName ( ) ) ) throw new IllegalArgumentException ( "Class '" + className + "' is not an instance of " + getBaseClassName ( ) ) ; 
} 
return className ; 
} 
} 

public class OIndexChangesWrapper { 
public static OIndexCursor wrap ( OIndex < ? > source , OIndexCursor cursor , long indexRebuildVersion ) { 
if ( cursor instanceof OIndexChangesWrapper ) return cursor ; 
if ( cursor instanceof OSizeable ) return new OIndexChangesSizeable ( source , cursor , indexRebuildVersion ) ; 
return new OIndexChangesWrapper ( source , cursor , indexRebuildVersion ) ; 
} 
} 

public class OTransactionRealAbstract { 
public List < ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { 
final List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; 
if ( iClass == null ) for ( ORecordOperation entry : allEntries . values ( ) ) { 
if ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; 
} 
else for ( ORecordOperation entry : allEntries . values ( ) ) { 
if ( entry . type == ORecordOperation . CREATED ) if ( entry . getRecord ( ) != null && entry . getRecord ( ) instanceof ODocument ) if ( iPolymorphic ) if ( iClass . isSuperClassOf ( ( ( ODocument ) entry . getRecord ( ) ) . getSchemaClass ( ) ) ) result . add ( entry ) ; 
else if ( iClass . getName ( ) . equals ( ( ( ODocument ) entry . getRecord ( ) ) . getClassName ( ) ) ) result . add ( entry ) ; 
} 
return result ; 
} 
} 

public class ODirtyManager { 
private static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { 
if ( source != null ) if ( target == null ) return source ; 
else if ( target . size ( ) > source . size ( ) ) { 
target . addAll ( source ) ; 
return target ; 
} 
else { 
source . addAll ( target ) ; 
return source ; 
} 
else return target ; 
} 
} 

public class OCommandExecutorSQLUpdate { 
@ SuppressWarnings ( "unchecked" ) public boolean result ( final Object iRecord ) { 
final ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; 
if ( isUpdateEdge ( ) && ! isRecordInstanceOf ( iRecord , "E" ) ) throw new OCommandExecutionException ( "Using UPDATE EDGE on a record that is not an instance of E" ) ; 
if ( compiledFilter != null ) if ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) return false ; 
parameters . reset ( ) ; 
returnHandler . beforeUpdate ( record ) ; 
boolean updated = handleContent ( record ) ; 
updated |= handleMerge ( record ) ; 
updated |= handleSetEntries ( record ) ; 
updated |= handleIncrementEntries ( record ) ; 
updated |= handleAddEntries ( record ) ; 
updated |= handlePutEntries ( record ) ; 
updated |= handleRemoveEntries ( record ) ; 
if ( updated ) { 
handleUpdateEdge ( record ) ; 
record . setDirty ( ) ; 
record . save ( ) ; 
returnHandler . afterUpdate ( record ) ; 
this . updated = true ; 
} 
return true ; 
} 
} 

public class OFunctionCall { 
public boolean canExecuteIndexedFunctionWithoutIndex ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { 
OSQLFunction function = OSQLEngine . getInstance ( ) . getFunction ( name . getStringValue ( ) ) ; 
if ( function instanceof OIndexableSQLFunction ) return ( ( OIndexableSQLFunction ) function ) . canExecuteInline ( target , operator , right , context , this . getParams ( ) . toArray ( new OExpression [ ] { 
} 
) ) ; 
return false ; 
} 
} 

public class OChainedIndexProxy { 
private Set < Comparable > prepareKeys ( OIndex < ? > index , Object keys ) { 
final OIndexDefinition indexDefinition = index . getDefinition ( ) ; 
if ( keys instanceof Collection ) { 
final Set < Comparable > newKeys = new TreeSet < Comparable > ( ) ; 
for ( Object o : ( ( Collection ) keys ) ) { 
newKeys . add ( ( Comparable ) indexDefinition . createValue ( o ) ) ; 
} 
return newKeys ; 
} 
else return Collections . singleton ( ( Comparable ) indexDefinition . createValue ( keys ) ) ; 
} 
} 

public class OWALSegmentCache { 
void writePage ( ByteBuffer page , long pageIndex ) throws IOException { 
synchronized ( lockObject ) { 
lastAccessTime = System . nanoTime ( ) ; 
if ( pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache . size ( ) ) if ( pageIndex < firstCachedPage + pageCache . size ( ) ) pageCache . set ( ( int ) ( pageIndex - firstCachedPage ) , page ) ; 
else pageCache . add ( page ) ; 
else if ( pageCache . isEmpty ( ) ) { 
pageCache . add ( page ) ; 
firstCachedPage = pageIndex ; 
} 
lastWrittenPage = page ; 
lastWrittenPageIndex = pageIndex ; 
if ( pageCache . size ( ) * OWALPage . PAGE_SIZE >= bufferSize + OWALPage . PAGE_SIZE ) flushAllBufferPagesExceptLastOne ( ) ; 
} 
} 
} 

public class OWALSegmentCache { 
byte [ ] readPage ( long pageIndex ) throws IOException { 
synchronized ( lockObject ) { 
lastAccessTime = System . nanoTime ( ) ; 
if ( pageIndex == lastWrittenPageIndex ) return lastWrittenPage . array ( ) ; 
if ( pageIndex >= firstCachedPage && pageIndex < firstCachedPage + pageCache . size ( ) ) { 
final ByteBuffer buffer = pageCache . get ( ( int ) ( pageIndex - firstCachedPage ) ) ; 
return buffer . array ( ) ; 
} 
final ByteBuffer buffer = ByteBuffer . allocate ( OWALPage . PAGE_SIZE ) . order ( ByteOrder . nativeOrder ( ) ) ; 
initFile ( ) ; 
segChannel . position ( pageIndex * OWALPage . PAGE_SIZE ) ; 
readByteBuffer ( buffer , segChannel ) ; 
return buffer . array ( ) ; 
} 
} 
} 

public class ODistributedConfiguration { 
public boolean isReplicationActive ( final String iClusterName , final String iLocalNode ) { 
final Collection < String > servers = getClusterConfiguration ( iClusterName ) . field ( SERVERS ) ; 
if ( servers != null && ! servers . isEmpty ( ) ) return true ; 
return false ; 
} 
} 

public class ODistributedConfiguration { 
public Map < String , Collection < String > > getServerClusterMap ( Collection < String > iClusterNames , final String iLocalNode , final boolean optimizeForLocalOnly ) { 
if ( iClusterNames == null || iClusterNames . isEmpty ( ) ) iClusterNames = DEFAULT_CLUSTER_NAME ; 
final Map < String , Collection < String > > servers = new HashMap < String , Collection < String > > ( iClusterNames . size ( ) ) ; 
boolean canUseLocalNode = true ; 
for ( String p : iClusterNames ) { 
final List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; 
if ( serverList != null && ! serverList . contains ( iLocalNode ) ) { 
canUseLocalNode = false ; 
break ; 
} 
} 
if ( optimizeForLocalOnly && canUseLocalNode ) { 
servers . put ( iLocalNode , iClusterNames ) ; 
return servers ; 
} 
final Map < String , Collection < String > > serverMap = new HashMap < String , Collection < String > > ( ) ; 
for ( String p : iClusterNames ) { 
final List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; 
for ( String s : serverList ) { 
if ( NEW_NODE_TAG . equalsIgnoreCase ( s ) ) continue ; 
Collection < String > clustersInServer = serverMap . get ( s ) ; 
if ( clustersInServer == null ) { 
clustersInServer = new HashSet < String > ( ) ; 
serverMap . put ( s , clustersInServer ) ; 
} 
clustersInServer . add ( p ) ; 
} 
} 
if ( serverMap . size ( ) == 1 ) return serverMap ; 
if ( ! optimizeForLocalOnly ) return serverMap ; 
final List < String > orderedServers = new ArrayList < String > ( serverMap . keySet ( ) ) ; 
Collections . sort ( orderedServers , new Comparator < String > ( ) { 
@ Override public int compare ( final String o1 , final String o2 ) { 
return ( ( Integer ) serverMap . get ( o2 ) . size ( ) ) . compareTo ( ( Integer ) serverMap . get ( o1 ) . size ( ) ) ; 
} 
} 
) ; 
final Set < String > remainingClusters = new HashSet < String > ( iClusterNames ) ; 
final Set < String > includedClusters = new HashSet < String > ( iClusterNames . size ( ) ) ; 
for ( String s : orderedServers ) { 
final Collection < String > clusters = serverMap . get ( s ) ; 
if ( ! servers . isEmpty ( ) ) clusters . removeAll ( includedClusters ) ; 
servers . put ( s , clusters ) ; 
remainingClusters . removeAll ( clusters ) ; 
includedClusters . addAll ( clusters ) ; 
if ( remainingClusters . isEmpty ( ) ) break ; 
} 
return servers ; 
} 
} 

public class ODistributedConfiguration { 
public Set < String > getServers ( Collection < String > iClusterNames ) { 
if ( iClusterNames == null || iClusterNames . isEmpty ( ) ) return getAllConfiguredServers ( ) ; 
final Set < String > partitions = new HashSet < String > ( iClusterNames . size ( ) ) ; 
for ( String p : iClusterNames ) { 
final List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; 
if ( serverList != null ) for ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) partitions . add ( s ) ; 
} 
return partitions ; 
} 
} 

public class ODistributedConfiguration { 
public boolean isServerContainingAllClusters ( final String server , Collection < String > clusters ) { 
if ( clusters == null || clusters . isEmpty ( ) ) clusters = DEFAULT_CLUSTER_NAME ; 
for ( String cluster : clusters ) { 
final List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; 
if ( serverList != null ) if ( ! serverList . contains ( server ) ) return false ; 
} 
return true ; 
} 
} 

public class ODistributedConfiguration { 
public boolean isServerContainingCluster ( final String server , String cluster ) { 
if ( cluster == null ) cluster = ALL_WILDCARD ; 
final List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; 
if ( serverList != null ) return serverList . contains ( server ) ; 
return true ; 
} 
} 

public class ODistributedConfiguration { 
public List < String > getMasterServers ( ) { 
final List < String > serverList = getClusterConfiguration ( null ) . field ( SERVERS ) ; 
if ( serverList != null ) { 
List < String > masters = new ArrayList < String > ( serverList . size ( ) ) ; 
for ( String s : serverList ) { 
if ( ! s . equals ( NEW_NODE_TAG ) ) masters . add ( s ) ; 
} 
final ROLES defRole = getDefaultServerRole ( ) ; 
final ODocument servers = configuration . field ( SERVERS ) ; 
if ( servers != null ) for ( Iterator < String > it = masters . iterator ( ) ; 
it . hasNext ( ) ; 
) { 
final String server = it . next ( ) ; 
final String roleAsString = servers . field ( server ) ; 
final ROLES role = roleAsString != null ? ROLES . valueOf ( roleAsString . toUpperCase ( Locale . ENGLISH ) ) : defRole ; 
if ( role != ROLES . MASTER ) it . remove ( ) ; 
} 
return masters ; 
} 
return Collections . EMPTY_LIST ; 
} 
} 

public class ODistributedConfiguration { 
public Set < String > getAllConfiguredServers ( ) { 
final Set < String > servers = new HashSet < String > ( ) ; 
for ( String p : getClusterNames ( ) ) { 
final List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; 
if ( serverList != null ) for ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) servers . add ( s ) ; 
} 
return servers ; 
} 
} 

public class ODistributedConfiguration { 
public int getDataCenterWriteQuorum ( final String dataCenter ) { 
final ODocument dc = getDataCenterConfiguration ( dataCenter ) ; 
Object wq = dc . field ( WRITE_QUORUM ) ; 
if ( wq instanceof String ) if ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_MAJORITY ) ) { 
final List < String > servers = dc . field ( SERVERS ) ; 
wq = servers . size ( ) / 2 + 1 ; 
} 
else if ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_ALL ) ) { 
final List < String > servers = dc . field ( SERVERS ) ; 
wq = servers . size ( ) ; 
} 
return ( Integer ) wq ; 
} 
} 

public class ODistributedConfiguration { 
public boolean isSharded ( ) { 
final ODocument allCluster = getClusterConfiguration ( ALL_WILDCARD ) ; 
if ( allCluster != null ) { 
final List < String > allServers = allCluster . field ( SERVERS ) ; 
if ( allServers != null && ! allServers . isEmpty ( ) ) for ( String cl : getClusterNames ( ) ) { 
final List < String > servers = getServers ( cl , null ) ; 
if ( servers != null && ! servers . isEmpty ( ) && ! allServers . containsAll ( servers ) ) return false ; 
} 
} 
return false ; 
} 
} 

public class ODistributedConfiguration { 
public String getDataCenterOfServer ( final String server ) { 
final ODocument dcs = configuration . field ( DCS ) ; 
if ( dcs != null ) for ( String dc : dcs . fieldNames ( ) ) { 
final ODocument dcConfig = dcs . field ( dc ) ; 
if ( dcConfig != null ) { 
final List < String > dcServers = dcConfig . field ( "servers" ) ; 
if ( dcServers != null && ! dcServers . isEmpty ( ) ) if ( dcServers . contains ( server ) ) return dc ; 
} 
} 
return null ; 
} 
} 

public class OrientBaseGraph { 
public void dropIndex ( final String indexName ) { 
makeActive ( ) ; 
executeOutsideTx ( new OCallable < Object , OrientBaseGraph > ( ) { 
@ Override public Object call ( OrientBaseGraph g ) { 
try { 
final OIndexManager indexManager = getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) ; 
final OIndex index = indexManager . getIndex ( indexName ) ; 
ODocument metadata = index . getConfiguration ( ) . field ( "metadata" ) ; 
String recordMapIndexName = null ; 
if ( metadata != null ) recordMapIndexName = metadata . field ( OrientIndex . CONFIG_RECORD_MAP_NAME ) ; 
indexManager . dropIndex ( indexName ) ; 
if ( recordMapIndexName != null ) getRawGraph ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( recordMapIndexName ) ; 
saveIndexConfiguration ( ) ; 
return null ; 
} 
catch ( Exception e ) { 
g . rollback ( ) ; 
throw new RuntimeException ( e . getMessage ( ) , e ) ; 
} 
} 
} 
, "drop index '" , indexName , "'" ) ; 
} 
} 

public class OrientBaseGraph { 
@ Override public OrientEdge addEdge ( final Object id , Vertex outVertex , Vertex inVertex , final String label ) { 
makeActive ( ) ; 
String className = null ; 
String clusterName = null ; 
if ( id != null ) if ( id instanceof String ) { 
final String [ ] args = ( ( String ) id ) . split ( "," ) ; 
for ( String s : args ) { 
if ( s . startsWith ( CLASS_PREFIX ) ) className = s . substring ( CLASS_PREFIX . length ( ) ) ; 
else if ( s . startsWith ( CLUSTER_PREFIX ) ) clusterName = s . substring ( CLUSTER_PREFIX . length ( ) ) ; 
} 
} 
final Object [ ] fields = isSaveOriginalIds ( ) && id != null ? new Object [ ] { 
OrientElement . DEF_ORIGINAL_ID_FIELDNAME , id } 
: null ; 
if ( outVertex instanceof PartitionVertex ) outVertex = ( ( PartitionVertex ) outVertex ) . getBaseVertex ( ) ; 
if ( inVertex instanceof PartitionVertex ) inVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; 
return ( ( OrientVertex ) outVertex ) . addEdge ( label , ( OrientVertex ) inVertex , className , clusterName , fields ) ; 
} 
} 

public class OrientBaseGraph { 
public OrientVertex getVertex ( final Object id ) { 
makeActive ( ) ; 
if ( null == id ) throw ExceptionFactory . vertexIdCanNotBeNull ( ) ; 
if ( id instanceof OrientVertex ) return ( OrientVertex ) id ; 
else if ( id instanceof ODocument ) return getVertexInstance ( ( OIdentifiable ) id ) ; 
setCurrentGraphInThreadLocal ( ) ; 
ORID rid ; 
if ( id instanceof OIdentifiable ) rid = ( ( OIdentifiable ) id ) . getIdentity ( ) ; 
else try { 
rid = new ORecordId ( id . toString ( ) ) ; 
} 
catch ( IllegalArgumentException iae ) { 
return null ; 
} 
if ( ! rid . isValid ( ) ) return null ; 
final ORecord rec = rid . getRecord ( ) ; 
if ( rec == null || ! ( rec instanceof ODocument ) ) return null ; 
final OClass cls = ( ( ODocument ) rec ) . getSchemaClass ( ) ; 
if ( cls != null && cls . isEdgeType ( ) ) throw new IllegalArgumentException ( "Cannot retrieve a vertex with the RID " + rid + " because it is an edge" ) ; 
return getVertexInstance ( rec ) ; 
} 
} 

public class OrientBaseGraph { 
public void shutdown ( boolean closeDb , boolean commitTx ) { 
makeActive ( ) ; 
try { 
if ( ! isClosed ( ) ) if ( commitTx ) { 
final OStorage storage = getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ; 
if ( storage instanceof OAbstractPaginatedStorage ) if ( ( ( OAbstractPaginatedStorage ) storage ) . getWALInstance ( ) != null ) getDatabase ( ) . commit ( ) ; 
else getDatabase ( ) . commit ( ) ; 
} 
else if ( closeDb ) getDatabase ( ) . rollback ( ) ; 
} 
catch ( ONeedRetryException e ) { 
throw e ; 
} 
catch ( RuntimeException e ) { 
OLogManager . instance ( ) . error ( this , "Error during context close for db " + url , e ) ; 
throw e ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . error ( this , "Error during context close for db " + url , e ) ; 
throw OException . wrapException ( new ODatabaseException ( "Error during context close for db " + url ) , e ) ; 
} 
finally { 
try { 
if ( closeDb ) { 
getDatabase ( ) . close ( ) ; 
if ( getDatabase ( ) . isPooled ( ) ) database = null ; 
} 
pollGraphFromStack ( closeDb ) ; 
} 
catch ( Exception e ) { 
OLogManager . instance ( ) . error ( this , "Error during context close for db " + url , e ) ; 
} 
} 
url = null ; 
username = null ; 
password = null ; 
if ( ! closeDb ) getDatabase ( ) . activateOnCurrentThread ( ) ; 
} 
} 

public class OWOWCache { 
@ Override public void removeBackgroundExceptionListener ( final OBackgroundExceptionListener listener ) { 
final List < WeakReference < OBackgroundExceptionListener > > itemsToRemove = new ArrayList < > ( 1 ) ; 
for ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { 
final OBackgroundExceptionListener l = ref . get ( ) ; 
if ( l != null && l . equals ( listener ) ) itemsToRemove . add ( ref ) ; 
} 
backgroundExceptionListeners . removeAll ( itemsToRemove ) ; 
} 
} 

public class OWOWCache { 
private void fireBackgroundDataFlushExceptionEvent ( final Throwable e ) { 
for ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { 
final OBackgroundExceptionListener listener = ref . get ( ) ; 
if ( listener != null ) listener . onException ( e ) ; 
} 
} 
} 

public class OPerformanceStatisticManager { 
public void registerMBean ( String storageName , int storageId ) { 
if ( mbeanIsRegistered . compareAndSet ( false , true ) ) try { 
final MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; 
final ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; 
if ( ! server . isRegistered ( mbeanName ) ) server . registerMBean ( new OPerformanceStatisticManagerMBean ( this ) , mbeanName ) ; 
else { 
mbeanIsRegistered . set ( false ) ; 
OLogManager . instance ( ) . warn ( this , "MBean with name %s has already registered. Probably your system was not shutdown correctly" + " or you have several running applications which use OrientDB engine inside" , mbeanName . getCanonicalName ( ) ) ; 
} 
} 
catch ( MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e ) { 
throw OException . wrapException ( new OStorageException ( "Error during registration of profiler MBean" ) , e ) ; 
} 
} 
} 

public class OPerformanceStatisticManager { 
public void unregisterMBean ( String storageName , int storageId ) { 
if ( storageName == null ) OLogManager . instance ( ) . warnNoDb ( this , "Can not unregister MBean for performance statistics, storage name is null" ) ; 
if ( mbeanIsRegistered . compareAndSet ( true , false ) ) try { 
final MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; 
final ObjectName mbeanName = new ObjectName ( getMBeanName ( storageName , storageId ) ) ; 
server . unregisterMBean ( mbeanName ) ; 
} 
catch ( MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e ) { 
throw OException . wrapException ( new OStorageException ( "Error during unregistration of profiler MBean" ) , e ) ; 
} 
} 
} 

public class OPerformanceStatisticManager { 
private WritCacheCountersHolder fetchWriteCacheCounters ( ) { 
final Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; 
final Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; 
for ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { 
final Thread thread = entry . getKey ( ) ; 
final OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; 
snapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; 
} 
WritCacheCountersHolder holder = null ; 
for ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { 
final Thread thread = pair . getFirst ( ) ; 
if ( thread . isAlive ( ) ) { 
final PerformanceSnapshot snapshot = pair . getSecond ( ) ; 
if ( snapshot . writCacheCountersHolder != null ) { 
if ( holder == null ) holder = new WritCacheCountersHolder ( ) ; 
snapshot . writCacheCountersHolder . pushData ( holder ) ; 
} 
} 
else threadsToRemove . add ( thread ) ; 
} 
if ( ! threadsToRemove . isEmpty ( ) ) updateDeadThreadsStatistic ( threadsToRemove ) ; 
final ImmutableStatistic ds = deadThreadsStatistic ; 
if ( ds != null ) { 
final WritCacheCountersHolder wch = ds . writCacheCountersHolder ; 
if ( wch != null ) { 
if ( holder == null ) holder = new WritCacheCountersHolder ( ) ; 
wch . pushData ( holder ) ; 
} 
} 
return holder ; 
} 
} 

public class OPerformanceStatisticManager { 
private void fetchSystemCounters ( PerformanceCountersHolder countersHolder ) { 
final Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; 
final Collection < Thread > threadsToRemove = new ArrayList < > ( ) ; 
for ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { 
final Thread thread = entry . getKey ( ) ; 
final OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; 
snapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; 
} 
for ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { 
final Thread thread = pair . getFirst ( ) ; 
if ( thread . isAlive ( ) ) { 
final PerformanceSnapshot snapshot = pair . getSecond ( ) ; 
snapshot . performanceCountersHolder . pushData ( countersHolder ) ; 
} 
else threadsToRemove . add ( thread ) ; 
} 
if ( ! threadsToRemove . isEmpty ( ) ) updateDeadThreadsStatistic ( threadsToRemove ) ; 
final ImmutableStatistic ds = deadThreadsStatistic ; 
if ( ds != null ) { 
final PerformanceCountersHolder dch = ds . countersHolder ; 
dch . pushData ( countersHolder ) ; 
} 
} 
} 

public class OPerformanceStatisticManager { 
private void fetchComponentCounters ( String componentName , PerformanceCountersHolder componentCountersHolder ) { 
final Collection < ORawPair < Thread , PerformanceSnapshot > > snapshots = new ArrayList < > ( statistics . size ( ) ) ; 
final List < Thread > threadsToRemove = new ArrayList < > ( ) ; 
for ( Map . Entry < Thread , OSessionStoragePerformanceStatistic > entry : statistics . entrySet ( ) ) { 
final Thread thread = entry . getKey ( ) ; 
final OSessionStoragePerformanceStatistic statistic = entry . getValue ( ) ; 
snapshots . add ( new ORawPair < > ( thread , statistic . getSnapshot ( ) ) ) ; 
} 
for ( ORawPair < Thread , PerformanceSnapshot > pair : snapshots ) { 
final Thread thread = pair . getFirst ( ) ; 
if ( thread . isAlive ( ) ) { 
final PerformanceSnapshot snapshot = pair . getSecond ( ) ; 
final PerformanceCountersHolder holder = snapshot . countersByComponent . get ( componentName ) ; 
if ( holder != null ) holder . pushData ( componentCountersHolder ) ; 
} 
else threadsToRemove . add ( thread ) ; 
} 
if ( ! threadsToRemove . isEmpty ( ) ) updateDeadThreadsStatistic ( threadsToRemove ) ; 
final ImmutableStatistic ds = deadThreadsStatistic ; 
if ( ds != null ) { 
final PerformanceCountersHolder dch = ds . countersByComponents . get ( componentName ) ; 
if ( dch != null ) dch . pushData ( componentCountersHolder ) ; 
} 
} 
} 

public class OHttpResponse { 
public byte [ ] compress ( String jsonStr ) { 
if ( jsonStr == null || jsonStr . length ( ) == 0 ) return null ; 
GZIPOutputStream gout = null ; 
ByteArrayOutputStream baos = null ; 
try { 
byte [ ] incoming = jsonStr . getBytes ( "UTF-8" ) ; 
baos = new ByteArrayOutputStream ( ) ; 
gout = new GZIPOutputStream ( baos , 16384 ) ; 
gout . write ( incoming ) ; 
gout . finish ( ) ; 
return baos . toByteArray ( ) ; 
} 
catch ( Exception ex ) { 
OLogManager . instance ( ) . error ( this , "Error on compressing HTTP response" , ex ) ; 
} 
finally { 
try { 
if ( gout != null ) gout . close ( ) ; 
if ( baos != null ) baos . close ( ) ; 
} 
catch ( Exception ex ) { 
} 
} 
return null ; 
} 
} 

public class OIndexes { 
private static Set < String > getIndexTypes ( ) { 
final Set < String > types = new HashSet < > ( ) ; 
final Iterator < OIndexFactory > ite = getAllFactories ( ) ; 
while ( ite . hasNext ( ) ) types . addAll ( ite . next ( ) . getTypes ( ) ) ; 
return types ; 
} 
} 

public class OIndexes { 
public static Set < String > getIndexEngines ( ) { 
final Set < String > engines = new HashSet < > ( ) ; 
final Iterator < OIndexFactory > ite = getAllFactories ( ) ; 
while ( ite . hasNext ( ) ) engines . addAll ( ite . next ( ) . getAlgorithms ( ) ) ; 
return engines ; 
} 
} 

public class ODistributedResponseManagerImpl { 
protected List < ODistributedResponse > getConflictResponses ( ) { 
final List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; 
int bestGroupSoFar = getBestResponsesGroup ( ) ; 
for ( int i = 0 ; 
i < responseGroups . size ( ) ; 
++ i ) if ( i != bestGroupSoFar ) for ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; 
return servers ; 
} 
} 

public class ODistributedResponseManagerImpl { 
private boolean computeQuorumResponse ( boolean reachedTimeout ) { 
if ( quorumResponse != null ) return true ; 
if ( groupResponsesByResult ) for ( List < ODistributedResponse > group : responseGroups ) { 
if ( group . size ( ) >= quorum ) { 
int responsesForQuorum = 0 ; 
for ( ODistributedResponse r : group ) { 
if ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { 
final Object payload = r . getPayload ( ) ; 
if ( payload instanceof Throwable ) { 
if ( payload instanceof ODistributedRecordLockedException ) break ; 
if ( payload instanceof OConcurrentCreateException ) break ; 
} 
else if ( ++ responsesForQuorum >= quorum ) { 
setQuorumResponse ( r ) ; 
return true ; 
} 
} 
} 
} 
} 
else if ( receivedResponses >= quorum ) { 
int responsesForQuorum = 0 ; 
for ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { 
if ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { 
ODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; 
if ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; 
return true ; 
} 
} 
} 
return false ; 
} 
} 

public class OExecutionPlanCache { 
public static OExecutionPlan get ( String statement , OCommandContext ctx , ODatabaseDocumentInternal db ) { 
if ( db == null ) throw new IllegalArgumentException ( "DB cannot be null" ) ; 
if ( statement == null ) return null ; 
OExecutionPlanCache resource = db . getSharedContext ( ) . getExecutionPlanCache ( ) ; 
OExecutionPlan result = resource . getInternal ( statement , ctx , db ) ; 
return result ; 
} 
} 

public class OScriptManager { 
public void releaseDatabaseEngine ( final String iLanguage , final String iDatabaseName , final OPartitionedObjectPool . PoolEntry < ScriptEngine > poolEntry ) { 
final ODatabaseScriptManager dbManager = dbManagers . get ( iDatabaseName ) ; 
if ( dbManager != null ) dbManager . releaseEngine ( iLanguage , poolEntry ) ; 
} 
} 

public class OSBTreeRidBag { 
private int updateSize ( ) { 
int size = 0 ; 
if ( collectionPointer != null ) { 
final OSBTreeBonsai < OIdentifiable , Integer > tree = loadTree ( ) ; 
if ( tree == null ) throw new IllegalStateException ( "RidBag is not properly initialized, can not load tree implementation" ) ; 
try { 
size = tree . getRealBagSize ( changes ) ; 
} 
finally { 
releaseTree ( ) ; 
} 
} 
else for ( Change change : changes . values ( ) ) { 
size += change . applyTo ( 0 ) ; 
} 
for ( OModifiableInteger diff : newEntries . values ( ) ) { 
size += diff . getValue ( ) ; 
} 
this . size = size ; 
return size ; 
} 
} 

public class OHashIndexBucket { 
public V getValue ( int index ) { 
int entryPosition = getIntValue ( POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer . INT_SIZE ) ; 
entryPosition += OLongSerializer . LONG_SIZE ; 
if ( encryption == null ) entryPosition += getObjectSizeInDirectMemory ( keySerializer , entryPosition ) ; 
else { 
final int encryptedLength = getIntValue ( entryPosition ) ; 
entryPosition += encryptedLength + OIntegerSerializer . INT_SIZE ; 
} 
return deserializeFromDirectMemory ( valueSerializer , entryPosition ) ; 
} 
} 

public class OOrderByOptimizer { 
boolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { 
if ( orderedFields . isEmpty ( ) ) return false ; 
if ( ! index . supportsOrderedIterations ( ) ) return false ; 
final OIndexDefinition definition = index . getDefinition ( ) ; 
final List < String > indexFields = definition . getFields ( ) ; 
int endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; 
final String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; 
for ( int i = 0 ; 
i < endIndex ; 
i ++ ) { 
final String equalsFieldName = equalsFilterFields . get ( i ) ; 
final String indexFieldName = indexFields . get ( i ) ; 
if ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; 
} 
endIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; 
if ( endIndex == equalsFilterFields . size ( ) ) return false ; 
for ( int i = equalsFilterFields . size ( ) ; 
i < endIndex ; 
i ++ ) { 
int fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; 
final OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; 
if ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; 
final String orderFieldName = pair . getKey ( ) ; 
final String indexFieldName = indexFields . get ( i ) ; 
if ( ! orderFieldName . equals ( indexFieldName ) ) return false ; 
} 
return true ; 
} 
} 

public class OStringParser { 
public static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { 
if ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; 
if ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; 
char c ; 
char stringChar = ' ' ; 
boolean escape = false ; 
final StringBuilder buffer = new StringBuilder ( 1024 ) ; 
int i = iFrom ; 
while ( true ) { 
c = iText . charAt ( i ) ; 
if ( ! escape && c == '\\' && ( ( i + 1 ) < iText . length ( ) ) ) if ( iText . charAt ( i + 1 ) == 'u' ) i = readUnicode ( iText , i + 2 , buffer ) ; 
else escape = true ; 
else { 
if ( c == '\'' || c == '"' ) if ( stringChar == ' ' ) stringChar = c ; 
else if ( ! escape && c == stringChar ) stringChar = ' ' ; 
if ( c == iToFind && stringChar == ' ' ) return i ; 
if ( escape ) escape = false ; 
} 
if ( iFrom < iTo ) if ( ++ i > iTo ) break ; 
else if ( -- i < iFrom ) break ; 
} 
return - 1 ; 
} 
} 

public class OStringParser { 
public static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { 
if ( iCurrentPosition < 0 ) return - 1 ; 
final int size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; 
final int jumpCharSize = iJumpChars . length ( ) ; 
boolean found = true ; 
char c ; 
for ( ; 
iCurrentPosition < size ; 
++ iCurrentPosition ) { 
found = false ; 
c = iText . charAt ( iCurrentPosition ) ; 
for ( int jumpIndex = 0 ; 
jumpIndex < jumpCharSize ; 
++ jumpIndex ) if ( iJumpChars . charAt ( jumpIndex ) == c ) { 
found = true ; 
break ; 
} 
if ( ! found ) break ; 
} 
return iCurrentPosition >= size ? - 1 : iCurrentPosition ; 
} 
} 

public class OMatchExecutionPlanner { 
private Map < String , Set < String > > getDependencies ( Pattern pattern ) { 
Map < String , Set < String > > result = new HashMap < String , Set < String > > ( ) ; 
for ( PatternNode node : pattern . aliasToNode . values ( ) ) { 
Set < String > currentDependencies = new HashSet < String > ( ) ; 
OWhereClause filter = aliasFilters . get ( node . alias ) ; 
if ( filter != null && filter . getBaseExpression ( ) != null ) { 
List < String > involvedAliases = filter . getBaseExpression ( ) . getMatchPatternInvolvedAliases ( ) ; 
if ( involvedAliases != null ) currentDependencies . addAll ( involvedAliases ) ; 
} 
result . put ( node . alias , currentDependencies ) ; 
} 
return result ; 
} 
} 

public class OEntityManager { 
public synchronized void registerEntityClasses ( Class < ? > aClass , boolean recursive ) { 
if ( recursive ) { 
classHandler . registerEntityClass ( aClass ) ; 
Field [ ] declaredFields = aClass . getDeclaredFields ( ) ; 
for ( Field declaredField : declaredFields ) { 
Class < ? > declaredFieldType = declaredField . getType ( ) ; 
if ( ! classHandler . containsEntityClass ( declaredFieldType ) ) registerEntityClasses ( declaredFieldType , recursive ) ; 
} 
} 
else classHandler . registerEntityClass ( aClass ) ; 
} 
} 

public class OCommandExecutorSQLHASyncCluster { 
public Object execute ( final Map < Object , Object > iArgs ) { 
final ODatabaseDocumentInternal database = getDatabase ( ) ; 
database . checkSecurity ( ORule . ResourceGeneric . CLUSTER , "sync" , ORole . PERMISSION_UPDATE ) ; 
if ( ! ( database instanceof ODatabaseDocumentDistributed ) ) throw new OCommandExecutionException ( "OrientDB is not started in distributed mode" ) ; 
final OHazelcastPlugin dManager = ( OHazelcastPlugin ) ( ( ODatabaseDocumentDistributed ) database ) . getDistributedManager ( ) ; 
if ( dManager == null || ! dManager . isEnabled ( ) ) throw new OCommandExecutionException ( "OrientDB is not started in distributed mode" ) ; 
final String databaseName = database . getName ( ) ; 
try { 
if ( this . parsedStatement . modeFull ) return replaceCluster ( dManager , database , dManager . getServerInstance ( ) , databaseName , this . parsedStatement . clusterName . getStringValue ( ) ) ; 
} 
catch ( Exception e ) { 
throw OException . wrapException ( new OCommandExecutionException ( "Cannot execute synchronization of cluster" ) , e ) ; 
} 
return "Mode not supported" ; 
} 
} 

public class OETLHandler { 
public ODocument status ( ) { 
ODocument status = new ODocument ( ) ; 
Collection < ODocument > jobs = new ArrayList < ODocument > ( ) ; 
if ( currentJob != null ) jobs . add ( currentJob . status ( ) ) ; 
status . field ( "jobs" , jobs ) ; 
return status ; 
} 
} 

public class OSymmetricKey { 
public static OSymmetricKey fromConfig ( final OSymmetricKeyConfig keyConfig ) { 
if ( keyConfig . usesKeyString ( ) ) return fromString ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyString ( ) ) ; 
else if ( keyConfig . usesKeyFile ( ) ) return fromFile ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyFile ( ) ) ; 
else if ( keyConfig . usesKeystore ( ) ) return fromKeystore ( keyConfig . getKeystoreFile ( ) , keyConfig . getKeystorePassword ( ) , keyConfig . getKeystoreKeyAlias ( ) , keyConfig . getKeystoreKeyPassword ( ) ) ; 
else throw new OSecurityException ( "OSymmetricKey(OSymmetricKeyConfig) Invalid configuration" ) ; 
} 
} 

public class OBasicCommandContext { 
public OCommandContext setChild ( final OCommandContext iContext ) { 
if ( iContext == null ) if ( child != null ) { 
child . setParent ( null ) ; 
child = null ; 
} 
else if ( child != iContext ) { 
child = iContext ; 
iContext . setParent ( this ) ; 
} 
return this ; 
} 
} 

public class OBasicCommandContext { 
public synchronized boolean addToUniqueResult ( Object o ) { 
Object toAdd = o ; 
if ( o instanceof ODocument && ( ( ODocument ) o ) . getIdentity ( ) . isNew ( ) ) toAdd = new ODocumentEqualityWrapper ( ( ODocument ) o ) ; 
return this . uniqueResult . add ( toAdd ) ; 
} 
} 

public class ORecordSerializerJSON { 
private Object getValueAsObjectOrMap ( ODocument iRecord , String iFieldValue , OType iType , OType iLinkedType , Map < String , Character > iFieldTypes , boolean iNoMap , String iOptions ) { 
final String [ ] fields = OStringParser . getWords ( iFieldValue . substring ( 1 , iFieldValue . length ( ) - 1 ) , ":," , true ) ; 
if ( fields == null || fields . length == 0 ) if ( iNoMap ) { 
ODocument res = new ODocument ( ) ; 
ODocumentInternal . addOwner ( res , iRecord ) ; 
return res ; 
} 
else return new HashMap < String , Object > ( ) ; 
if ( iNoMap || hasTypeField ( fields ) ) return getValueAsRecord ( iRecord , iFieldValue , iType , iOptions , fields ) ; 
else return getValueAsMap ( iRecord , iFieldValue , iLinkedType , iFieldTypes , false , iOptions , fields ) ; 
} 
} 

public class OServerCommandPostAuthToken { 
protected String authenticate ( final String username , final String password , final String iDatabaseName ) throws IOException { 
ODatabaseDocument db = null ; 
String userRid = null ; 
try { 
db = ( ODatabaseDocument ) server . openDatabase ( iDatabaseName , username , password ) ; 
userRid = ( db . getUser ( ) == null ? "<server user>" : db . getUser ( ) . getDocument ( ) . getIdentity ( ) . toString ( ) ) ; 
} 
catch ( OSecurityAccessException e ) { 
} 
catch ( OLockException e ) { 
OLogManager . instance ( ) . error ( this , "Cannot access to the database '" + iDatabaseName + "'" , e ) ; 
} 
finally { 
if ( db != null ) db . close ( ) ; 
} 
return userRid ; 
} 
} 

public class OrientGraphFactory { 
public OrientGraph getTx ( ) { 
final OrientGraph g ; 
if ( pool == null ) g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; 
else g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; 
initGraph ( g ) ; 
return g ; 
} 
} 

public class OrientGraphFactory { 
public OrientGraphNoTx getNoTx ( ) { 
final OrientGraphNoTx g ; 
if ( pool == null ) g = ( OrientGraphNoTx ) getNoTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; 
else g = ( OrientGraphNoTx ) getNoTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; 
initGraph ( g ) ; 
return g ; 
} 
} 

public class OrientGraphFactory { 
public OrientGraphFactory setupPool ( final int iMin , final int iMax ) { 
if ( pool != null ) pool . close ( ) ; 
pool = new OPartitionedDatabasePool ( url , user , password , 8 , iMax ) . setAutoCreate ( true ) ; 
properties . entrySet ( ) . forEach ( p -> pool . setProperty ( p . getKey ( ) , p . getValue ( ) ) ) ; 
return this ; 
} 
} 

public class OrientSql { 
final public OStatement parse ( ) throws ParseException { 
Oparse jjtn000 = new Oparse ( JJTPARSE ) ; 
boolean jjtc000 = true ; 
jjtree . openNodeScope ( jjtn000 ) ; 
jjtn000 . jjtSetFirstToken ( getToken ( 1 ) ) ; 
OStatement result ; 
try { 
result = Statement ( ) ; 
jj_consume_token ( 0 ) ; 
jjtree . closeNodeScope ( jjtn000 , true ) ; 
jjtc000 = false ; 
jjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; 
{ 
if ( true ) return result ; 
} 
} 
catch ( Throwable jjte000 ) { 
if ( jjtc000 ) { 
jjtree . clearNodeScope ( jjtn000 ) ; 
jjtc000 = false ; 
} 
else jjtree . popNode ( ) ; 
if ( jjte000 instanceof RuntimeException ) { 
if ( true ) throw ( RuntimeException ) jjte000 ; 
} 
if ( jjte000 instanceof ParseException ) { 
if ( true ) throw ( ParseException ) jjte000 ; 
} 
{ 
if ( true ) throw ( Error ) jjte000 ; 
} 
} 
finally { 
if ( jjtc000 ) { 
jjtree . closeNodeScope ( jjtn000 , true ) ; 
jjtn000 . jjtSetLastToken ( getToken ( 0 ) ) ; 
} 
} 
throw new Error ( "Missing return statement in function" ) ; 
} 
} 

public class OrientSql { 
final public Token getToken ( int index ) { 
Token t = token ; 
for ( int i = 0 ; 
i < index ; 
i ++ ) if ( t . next != null ) t = t . next ; 
else t = t . next = token_source . getNextToken ( ) ; 
return t ; 
} 
} 

public class OrientSql { 
public ParseException generateParseException ( ) { 
jj_expentries . clear ( ) ; 
boolean [ ] la1tokens = new boolean [ 279 ] ; 
if ( jj_kind >= 0 ) { 
la1tokens [ jj_kind ] = true ; 
jj_kind = - 1 ; 
} 
for ( int i = 0 ; 
i < 424 ; 
i ++ ) if ( jj_la1 [ i ] == jj_gen ) for ( int j = 0 ; 
j < 32 ; 
j ++ ) { 
if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ j ] = true ; 
if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 32 + j ] = true ; 
if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 64 + j ] = true ; 
if ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 96 + j ] = true ; 
if ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 128 + j ] = true ; 
if ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 160 + j ] = true ; 
if ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 192 + j ] = true ; 
if ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 224 + j ] = true ; 
if ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) la1tokens [ 256 + j ] = true ; 
} 
for ( int i = 0 ; 
i < 279 ; 
i ++ ) if ( la1tokens [ i ] ) { 
jj_expentry = new int [ 1 ] ; 
jj_expentry [ 0 ] = i ; 
jj_expentries . add ( jj_expentry ) ; 
} 
jj_endpos = 0 ; 
jj_rescan_token ( ) ; 
jj_add_error_token ( 0 , 0 ) ; 
int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; 
for ( int i = 0 ; 
i < jj_expentries . size ( ) ; 
i ++ ) exptokseq [ i ] = jj_expentries . get ( i ) ; 
return new ParseException ( token , exptokseq , tokenImage ) ; 
} 
} 

public class OrientVertex { 
@ Override public Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { 
setCurrentGraphInThreadLocal ( ) ; 
OrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; 
OrientBaseGraph . encodeClassNames ( iLabels ) ; 
final ODocument doc = getRecord ( ) ; 
final OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; 
for ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { 
String fieldName = connectionField . getKey ( ) ; 
OPair < Direction , String > connection = connectionField . getValue ( ) ; 
final Object fieldValue = doc . rawField ( fieldName ) ; 
if ( fieldValue != null ) if ( fieldValue instanceof OIdentifiable ) addSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; 
else if ( fieldValue instanceof Collection < ? > ) { 
Collection < ? > coll = ( Collection < ? > ) fieldValue ; 
if ( coll . size ( ) == 1 ) if ( coll instanceof ORecordLazyMultiValue ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) . next ( ) , iLabels ) ; 
else if ( coll instanceof List < ? > ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( List < ? > ) coll ) . get ( 0 ) , iLabels ) ; 
else addSingleVertex ( doc , iterable , fieldName , connection , coll . iterator ( ) . next ( ) , iLabels ) ; 
else if ( coll instanceof ORecordLazyMultiValue ) iterable . add ( new OrientVertexIterator ( this , coll , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) , connection , iLabels , coll . size ( ) ) ) ; 
else iterable . add ( new OrientVertexIterator ( this , coll , coll . iterator ( ) , connection , iLabels , - 1 ) ) ; 
} 
else if ( fieldValue instanceof ORidBag ) iterable . add ( new OrientVertexIterator ( this , fieldValue , ( ( ORidBag ) fieldValue ) . rawIterator ( ) , connection , iLabels , - 1 ) ) ; 
} 
return iterable ; 
} 
} 

public class OrientVertex { 
@ Override public void remove ( ) { 
checkClass ( ) ; 
final OrientBaseGraph graph = checkIfAttached ( ) ; 
graph . setCurrentGraphInThreadLocal ( ) ; 
graph . autoStartTransaction ( ) ; 
final ODocument doc = getRecord ( ) ; 
if ( doc == null ) throw ExceptionFactory . vertexWithIdDoesNotExist ( this . getId ( ) ) ; 
Map < String , List < ODocument > > treeRidbagEdgesToRemove = new HashMap < String , List < ODocument > > ( ) ; 
if ( ! graph . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) for ( String fieldName : doc . fieldNames ( ) ) { 
final OPair < Direction , String > connection = getConnection ( Direction . BOTH , fieldName ) ; 
if ( connection == null ) continue ; 
Object fv = doc . field ( fieldName ) ; 
if ( fv instanceof ORidBag && ! ( ( ORidBag ) fv ) . isEmbedded ( ) ) { 
List < ODocument > docs = new ArrayList < ODocument > ( ) ; 
for ( OIdentifiable id : ( ORidBag ) fv ) docs . add ( OrientBaseGraph . getDocument ( id , true ) ) ; 
treeRidbagEdgesToRemove . put ( fieldName , docs ) ; 
} 
} 
super . removeRecord ( ) ; 
final Iterator < Index < ? extends Element > > it = graph . getIndices ( ) . iterator ( ) ; 
if ( it . hasNext ( ) ) { 
final Set < Edge > allEdges = new HashSet < Edge > ( ) ; 
for ( Edge e : getEdges ( Direction . BOTH ) ) allEdges . add ( e ) ; 
while ( it . hasNext ( ) ) { 
final Index < ? extends Element > index = it . next ( ) ; 
if ( Vertex . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { 
OrientIndex < OrientVertex > idx = ( OrientIndex < OrientVertex > ) index ; 
idx . removeElement ( this ) ; 
} 
if ( Edge . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { 
OrientIndex < OrientEdge > idx = ( OrientIndex < OrientEdge > ) index ; 
for ( Edge e : allEdges ) idx . removeElement ( ( OrientEdge ) e ) ; 
} 
} 
} 
for ( Map . Entry < String , List < ODocument > > entry : treeRidbagEdgesToRemove . entrySet ( ) ) { 
doc . removeField ( entry . getKey ( ) ) ; 
Iterator < ODocument > iter = entry . getValue ( ) . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
ODocument docEdge = iter . next ( ) ; 
OrientBaseGraph . deleteEdgeIfAny ( docEdge , false ) ; 
} 
} 
graph . removeEdgesInternal ( this , doc , null , true , settings . isUseVertexFieldsForEdgeLabels ( ) , settings . isAutoScaleEdgeType ( ) ) ; 
} 
} 

public class OrientVertex { 
public String getConnectionClass ( final Direction iDirection , final String iFieldName ) { 
if ( iDirection == Direction . OUT ) if ( iFieldName . length ( ) > CONNECTION_OUT_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_OUT_PREFIX . length ( ) ) ; 
else if ( iDirection == Direction . IN ) if ( iFieldName . length ( ) > CONNECTION_IN_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_IN_PREFIX . length ( ) ) ; 
return OrientEdgeType . CLASS_NAME ; 
} 
} 

public class OrientVertex { 
protected OPair < Direction , String > getConnection ( final Direction iDirection , final String iFieldName , String ... iClassNames ) { 
if ( iClassNames != null && iClassNames . length == 1 && iClassNames [ 0 ] . equalsIgnoreCase ( "E" ) ) iClassNames = null ; 
final OrientBaseGraph graph = getGraph ( ) ; 
if ( iDirection == Direction . OUT || iDirection == Direction . BOTH ) if ( settings . isUseVertexFieldsForEdgeLabels ( ) ) if ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { 
String connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; 
if ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; 
OrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; 
if ( edgeType != null ) for ( String clsName : iClassNames ) { 
if ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; 
} 
} 
else if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) return new OPair < Direction , String > ( Direction . OUT , null ) ; 
if ( iDirection == Direction . IN || iDirection == Direction . BOTH ) if ( settings . isUseVertexFieldsForEdgeLabels ( ) ) if ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { 
String connClass = getConnectionClass ( Direction . IN , iFieldName ) ; 
if ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; 
OrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; 
if ( edgeType != null ) for ( String clsName : iClassNames ) { 
if ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; 
} 
} 
else if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) return new OPair < Direction , String > ( Direction . IN , null ) ; 
return null ; 
} 
} 

public class OConsoleApplication { 
protected Map < Method , Object > getConsoleMethods ( ) { 
if ( methods != null ) return methods ; 
final Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; 
final Collection < Object > candidates = new ArrayList < Object > ( ) ; 
candidates . add ( this ) ; 
while ( ite . hasNext ( ) ) try { 
final OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; 
cc . setContext ( this ) ; 
candidates . add ( cc ) ; 
} 
catch ( InstantiationException ex ) { 
Logger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; 
} 
catch ( IllegalAccessException ex ) { 
Logger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; 
} 
methods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { 
public int compare ( Method o1 , Method o2 ) { 
final ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; 
final ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; 
if ( ann1 != null && ann2 != null ) if ( ann1 . priority ( ) != ann2 . priority ( ) ) return ann1 . priority ( ) - ann2 . priority ( ) ; 
int res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; 
if ( res == 0 ) res = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; 
return res ; 
} 
} 
) ; 
for ( final Object candidate : candidates ) { 
final Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; 
for ( Method m : classMethods ) { 
if ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) || ! Modifier . isPublic ( m . getModifiers ( ) ) ) continue ; 
if ( m . getReturnType ( ) != Void . TYPE ) continue ; 
methods . put ( m , candidate ) ; 
} 
} 
return methods ; 
} 
} 

public class OCommandExecutorSQLCreateIndex { 
@ SuppressWarnings ( "rawtypes" ) public Object execute ( final Map < Object , Object > iArgs ) { 
if ( indexName == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocument database = getDatabase ( ) ; 
final OIndex < ? > idx ; 
List < OCollate > collatesList = null ; 
if ( collates != null ) { 
collatesList = new ArrayList < OCollate > ( ) ; 
for ( String collate : collates ) { 
if ( collate != null ) { 
final OCollate col = OSQLEngine . getCollate ( collate ) ; 
collatesList . add ( col ) ; 
} 
else collatesList . add ( null ) ; 
} 
} 
if ( fields == null || fields . length == 0 ) { 
OIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; 
if ( keyTypes != null ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; 
else if ( serializerKeyId != 0 ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; 
else throw new ODatabaseException ( "Impossible to create an index without specify the key type or the associated property" ) ; 
} 
else if ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) idx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; 
else { 
final List < OType > fieldTypeList ; 
if ( keyTypes == null ) { 
for ( final String fieldName : fields ) { 
if ( ! fieldName . equals ( "@rid" ) && ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( "Index with name : '" + indexName + "' cannot be created on class : '" + oClass . getName ( ) + "' because field: '" + fieldName + "' is absent in class definition." ) ; 
} 
fieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; 
} 
else fieldTypeList = Arrays . asList ( keyTypes ) ; 
final OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; 
idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; 
} 
if ( idx != null ) return idx . getSize ( ) ; 
return null ; 
} 
} 

public class OGraphCommandExecutorSQLFactory { 
public static OrientGraph getGraph ( final boolean autoStartTx , OModifiableBoolean shouldBeShutDown ) { 
final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; 
final OrientBaseGraph result = OrientBaseGraph . getActiveGraph ( ) ; 
if ( result != null && ( result instanceof OrientGraph ) ) { 
final ODatabaseDocumentInternal graphDb = result . getRawGraph ( ) ; 
if ( canReuseActiveGraph ( graphDb , database ) ) if ( ! graphDb . isClosed ( ) ) { 
ODatabaseRecordThreadLocal . instance ( ) . set ( graphDb ) ; 
if ( autoStartTx && autoTxStartRequired ( graphDb ) ) ( ( OrientGraph ) result ) . begin ( ) ; 
shouldBeShutDown . setValue ( false ) ; 
return ( OrientGraph ) result ; 
} 
} 
ODatabaseRecordThreadLocal . instance ( ) . set ( database ) ; 
shouldBeShutDown . setValue ( true ) ; 
final OrientGraph g = ( OrientGraph ) OrientGraphFactory . getTxGraphImplFactory ( ) . getGraph ( database , false ) ; 
if ( autoStartTx && autoTxStartRequired ( database ) ) g . begin ( ) ; 
return g ; 
} 
} 

public class OCommandExecutorSQLRetryAbstract { 
protected void parseRetry ( ) throws OCommandSQLParsingException { 
retry = Integer . parseInt ( parserNextWord ( true ) ) ; 
String temp = parseOptionalWord ( true ) ; 
if ( temp . equals ( "WAIT" ) ) wait = Integer . parseInt ( parserNextWord ( true ) ) ; 
else parserGoBack ( ) ; 
} 
} 

public class OSystemUserAuthenticator { 
public String authenticate ( final String username , final String password ) { 
String principal = null ; 
try { 
if ( getServer ( ) != null ) { 
OUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; 
if ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) if ( user . checkPassword ( password ) ) principal = username ; 
} 
} 
catch ( Exception ex ) { 
OLogManager . instance ( ) . error ( this , "authenticate()" , ex ) ; 
} 
return principal ; 
} 
} 

public class OSystemUserAuthenticator { 
public boolean isAuthorized ( final String username , final String resource ) { 
if ( username == null || resource == null ) return false ; 
try { 
if ( getServer ( ) != null ) { 
OUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; 
if ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { 
ORole role = null ; 
ORule . ResourceGeneric rg = ORule . mapLegacyResourceToGenericResource ( resource ) ; 
if ( rg != null ) { 
String specificResource = ORule . mapLegacyResourceToSpecificResource ( resource ) ; 
if ( specificResource == null || specificResource . equals ( "*" ) ) specificResource = null ; 
role = user . checkIfAllowed ( rg , specificResource , ORole . PERMISSION_EXECUTE ) ; 
} 
return role != null ; 
} 
} 
} 
catch ( Exception ex ) { 
OLogManager . instance ( ) . error ( this , "isAuthorized()" , ex ) ; 
} 
return false ; 
} 
} 

public class OServerShutdownHook { 
@ Override public void run ( ) { 
if ( server != null ) if ( ! server . shutdown ( ) ) try { 
Thread . sleep ( 5000 ) ; 
} 
catch ( InterruptedException e ) { 
} 
} 
} 

public class JavaCharStream { 
public void adjustBeginLineColumn ( int newLine , int newCol ) { 
int start = tokenBegin ; 
int len ; 
if ( bufpos >= tokenBegin ) len = bufpos - tokenBegin + inBuf + 1 ; 
else len = bufsize - tokenBegin + bufpos + 1 + inBuf ; 
int i = 0 , j = 0 , k = 0 ; 
int nextColDiff = 0 , columnDiff = 0 ; 
while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { 
bufline [ j ] = newLine ; 
nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; 
bufcolumn [ j ] = newCol + columnDiff ; 
columnDiff = nextColDiff ; 
i ++ ; 
} 
if ( i < len ) { 
bufline [ j ] = newLine ++ ; 
bufcolumn [ j ] = newCol + columnDiff ; 
while ( i ++ < len ) if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; 
else bufline [ j ] = newLine ; 
} 
line = bufline [ j ] ; 
column = bufcolumn [ j ] ; 
} 
} 

public class OAtomicOperationsManager { 
public OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { 
final OAtomicOperation operation = currentOperation . get ( ) ; 
if ( operation == null ) { 
OLogManager . instance ( ) . error ( this , "There is no atomic operation active" , null ) ; 
throw new ODatabaseException ( "There is no atomic operation active" ) ; 
} 
int counter = operation . getCounter ( ) ; 
operation . decrementCounter ( ) ; 
assert counter > 0 ; 
final OLogSequenceNumber lsn ; 
try { 
if ( rollback ) operation . rollback ( ) ; 
if ( counter == 1 ) try { 
final boolean useWal = useWal ( ) ; 
if ( ! operation . isRollback ( ) ) lsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; 
else lsn = null ; 
if ( trackAtomicOperations ) activeAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; 
} 
finally { 
final Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; 
while ( lockedObjectIterator . hasNext ( ) ) { 
final String lockedObject = lockedObjectIterator . next ( ) ; 
lockedObjectIterator . remove ( ) ; 
lockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; 
} 
currentOperation . set ( null ) ; 
} 
else lsn = null ; 
} 
catch ( Error e ) { 
final OAbstractPaginatedStorage st = storage ; 
if ( st != null ) st . handleJVMError ( e ) ; 
counter = 1 ; 
throw e ; 
} 
finally { 
if ( counter == 1 ) atomicOperationsCount . decrement ( ) ; 
} 
return lsn ; 
} 
} 

public class OAtomicOperationsManager { 
public void acquireExclusiveLockTillOperationComplete ( OAtomicOperation operation , String lockName ) { 
if ( operation . containsInLockedObjects ( lockName ) ) return ; 
lockManager . acquireLock ( lockName , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; 
operation . addLockedObject ( lockName ) ; 
} 
} 

public class O2QCache { 
public void changeMaximumAmountOfMemory ( final long readCacheMaxMemory ) throws IllegalStateException { 
MemoryData memoryData ; 
MemoryData newMemoryData ; 
final int newMemorySize = normalizeMemory ( readCacheMaxMemory , pageSize ) ; 
do { 
memoryData = memoryDataContainer . get ( ) ; 
if ( memoryData . maxSize == newMemorySize ) return ; 
if ( ( 100 * memoryData . pinnedPages / newMemorySize ) > percentOfPinnedPages ) throw new IllegalStateException ( "Cannot decrease amount of memory used by disk cache " + "because limit of pinned pages will be more than allowed limit " + percentOfPinnedPages ) ; 
newMemoryData = new MemoryData ( newMemorySize , memoryData . pinnedPages ) ; 
} 
while ( ! memoryDataContainer . compareAndSet ( memoryData , newMemoryData ) ) ; 
OLogManager . instance ( ) . info ( this , "Disk cache size was changed from " + memoryData . maxSize + " pages to " + newMemorySize + " pages" ) ; 
} 
} 

public class OServerNetworkListener { 
private void readParameters ( final OContextConfiguration iServerConfig , final OServerParameterConfiguration [ ] iParameters ) { 
configuration = new OContextConfiguration ( iServerConfig ) ; 
if ( iParameters != null && iParameters . length > 0 ) for ( OServerParameterConfiguration param : iParameters ) configuration . setValue ( param . name , param . value ) ; 
socketBufferSize = configuration . getValueAsInteger ( OGlobalConfiguration . NETWORK_SOCKET_BUFFER_SIZE ) ; 
} 
} 

public class OLogManager { 
public void shutdown ( ) { 
if ( shutdownFlag . compareAndSet ( false , true ) ) try { 
if ( LogManager . getLogManager ( ) instanceof ShutdownLogManager ) ( ( ShutdownLogManager ) LogManager . getLogManager ( ) ) . shutdown ( ) ; 
} 
catch ( NoClassDefFoundError ignore ) { 
} 
} 
} 

public class OClosableLinkedContainer { 
public void add ( K key , V item ) throws InterruptedException { 
if ( ! item . isOpen ( ) ) throw new IllegalArgumentException ( "All passed in items should be in open state" ) ; 
checkOpenFilesLimit ( ) ; 
final OClosableEntry < K , V > closableEntry = new OClosableEntry < K , V > ( item ) ; 
final OClosableEntry < K , V > oldEntry = data . putIfAbsent ( key , closableEntry ) ; 
if ( oldEntry != null ) throw new IllegalStateException ( "Item with key " + key + " already exists" ) ; 
logAdd ( closableEntry ) ; 
} 
} 

public class OClosableLinkedContainer { 
public V remove ( K key ) { 
final OClosableEntry < K , V > removed = data . remove ( key ) ; 
if ( removed != null ) { 
long preStatus = removed . makeRetired ( ) ; 
if ( OClosableEntry . isOpen ( preStatus ) ) countClosedFiles ( ) ; 
logRemoved ( removed ) ; 
return removed . get ( ) ; 
} 
return null ; 
} 
} 

public class OClosableLinkedContainer { 
public OClosableEntry < K , V > acquire ( K key ) throws InterruptedException { 
checkOpenFilesLimit ( ) ; 
final OClosableEntry < K , V > entry = data . get ( key ) ; 
if ( entry == null ) return null ; 
boolean logOpen = false ; 
entry . acquireStateLock ( ) ; 
try { 
if ( entry . isRetired ( ) || entry . isDead ( ) ) return null ; 
else if ( entry . isClosed ( ) ) { 
entry . makeAcquiredFromClosed ( entry . get ( ) ) ; 
logOpen = true ; 
} 
else if ( entry . isOpen ( ) ) entry . makeAcquiredFromOpen ( ) ; 
else entry . incrementAcquired ( ) ; 
} 
finally { 
entry . releaseStateLock ( ) ; 
} 
if ( logOpen ) logOpen ( entry ) ; 
else logAcquire ( entry ) ; 
assert entry . get ( ) . isOpen ( ) ; 
return entry ; 
} 
} 

public class OClosableLinkedContainer { 
public void clear ( ) { 
lruLock . lock ( ) ; 
try { 
data . clear ( ) ; 
openFiles . set ( 0 ) ; 
for ( int n = 0 ; 
n < NUMBER_OF_READ_BUFFERS ; 
n ++ ) { 
final AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; 
for ( int i = 0 ; 
i < READ_BUFFER_SIZE ; 
i ++ ) buffer [ i ] . set ( null ) ; 
readBufferReadCount [ n ] = 0 ; 
readBufferWriteCount [ n ] . set ( 0 ) ; 
readBufferDrainAtWriteCount [ n ] . set ( 0 ) ; 
} 
stateBuffer . clear ( ) ; 
while ( lruList . poll ( ) != null ) ; 
} 
finally { 
lruLock . unlock ( ) ; 
} 
} 
} 

public class OProfileStorageStatement { 
@ Override public OResultSet executeSimple ( OCommandContext ctx ) { 
OResultInternal result = new OResultInternal ( ) ; 
result . setProperty ( "operation" , "optimize database" ) ; 
OStorage storage = ( ( ODatabaseInternal ) ctx . getDatabase ( ) ) . getStorage ( ) ; 
if ( on ) { 
( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; 
result . setProperty ( "value" , "on" ) ; 
} 
else { 
final OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; 
result . setProperty ( "value" , "off" ) ; 
if ( performanceStatistic != null ) result . setProperty ( "result" , performanceStatistic . toDocument ( ) ) ; 
else { 
result . setProperty ( "result" , "error" ) ; 
result . setProperty ( "errorMessage" , "profiling of storage was not started" ) ; 
} 
} 
OInternalResultSet rs = new OInternalResultSet ( ) ; 
rs . add ( result ) ; 
return rs ; 
} 
} 

public class OProfileStorageStatement { 
@ Override public Object execute ( OSQLAsynchQuery < ODocument > request , OCommandContext context , OProgressListener progressListener ) { 
try { 
ODatabaseDocumentInternal db = getDatabase ( ) ; 
final OStorage storage = db . getStorage ( ) ; 
if ( on ) { 
( ( OAbstractPaginatedStorage ) storage ) . startGatheringPerformanceStatisticForCurrentThread ( ) ; 
ODocument result = new ODocument ( ) ; 
result . field ( "result" , "OK" ) ; 
request . getResultListener ( ) . result ( result ) ; 
} 
else { 
final OSessionStoragePerformanceStatistic performanceStatistic = ( ( OAbstractPaginatedStorage ) storage ) . completeGatheringPerformanceStatisticForCurrentThread ( ) ; 
if ( performanceStatistic != null ) request . getResultListener ( ) . result ( performanceStatistic . toDocument ( ) ) ; 
else { 
ODocument result = new ODocument ( ) ; 
result . field ( "result" , "Error: profiling of storage was not started." ) ; 
request . getResultListener ( ) . result ( result ) ; 
} 
} 
return getResult ( request ) ; 
} 
finally { 
if ( request . getResultListener ( ) != null ) request . getResultListener ( ) . end ( ) ; 
} 
} 
} 

public class OSecurityShared { 
public OUser authenticate ( final OToken authToken ) { 
final String dbName = getDatabase ( ) . getName ( ) ; 
if ( authToken . getIsValid ( ) != true ) throw new OSecurityAccessException ( dbName , "Token not valid" ) ; 
OUser user = authToken . getUser ( getDatabase ( ) ) ; 
if ( user == null && authToken . getUserName ( ) != null ) user = getUser ( authToken . getUserName ( ) ) ; 
if ( user == null ) throw new OSecurityAccessException ( dbName , "Authentication failed, could not load user from token" ) ; 
if ( user . getAccountStatus ( ) != STATUSES . ACTIVE ) throw new OSecurityAccessException ( dbName , "User '" + user . getName ( ) + "' is not active" ) ; 
return user ; 
} 
} 

public class OSecurityShared { 
public OUser createMetadata ( ) { 
final ODatabaseDocument database = getDatabase ( ) ; 
OClass identityClass = database . getMetadata ( ) . getSchema ( ) . getClass ( OIdentity . CLASS_NAME ) ; 
if ( identityClass == null ) identityClass = database . getMetadata ( ) . getSchema ( ) . createAbstractClass ( OIdentity . CLASS_NAME ) ; 
OClass roleClass = createOrUpdateORoleClass ( database , identityClass ) ; 
createOrUpdateOUserClass ( database , identityClass , roleClass ) ; 
ORole adminRole = getRole ( ORole . ADMIN ) ; 
if ( adminRole == null ) { 
adminRole = createRole ( ORole . ADMIN , ORole . ALLOW_MODES . ALLOW_ALL_BUT ) ; 
adminRole . addRule ( ORule . ResourceGeneric . BYPASS_RESTRICTED , null , ORole . PERMISSION_ALL ) . save ( ) ; 
} 
OUser adminUser = getUser ( OUser . ADMIN ) ; 
if ( adminUser == null ) { 
boolean createDefUsers = getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getContextConfiguration ( ) . getValueAsBoolean ( OGlobalConfiguration . CREATE_DEFAULT_USERS ) ; 
if ( createDefUsers ) adminUser = createUser ( OUser . ADMIN , OUser . ADMIN , adminRole ) ; 
} 
createOrUpdateORestrictedClass ( database ) ; 
return adminUser ; 
} 
} 

public class OReadersWriterSpinLock { 
public boolean tryAcquireReadLock ( long timeout ) { 
final OModifiableInteger lHolds = lockHolds . get ( ) ; 
final int holds = lHolds . intValue ( ) ; 
if ( holds > 0 ) { 
lHolds . increment ( ) ; 
return true ; 
} 
else if ( holds < 0 ) return true ; 
distributedCounter . increment ( ) ; 
WNode wNode = tail . get ( ) ; 
final long start = System . nanoTime ( ) ; 
while ( wNode . locked ) { 
distributedCounter . decrement ( ) ; 
while ( wNode . locked && wNode == tail . get ( ) ) { 
wNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; 
if ( wNode . locked && wNode == tail . get ( ) ) { 
final long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; 
if ( parkTimeout > 0 ) LockSupport . parkNanos ( this , parkTimeout ) ; 
else return false ; 
} 
wNode = tail . get ( ) ; 
if ( System . nanoTime ( ) - start > timeout ) return false ; 
} 
distributedCounter . increment ( ) ; 
wNode = tail . get ( ) ; 
if ( System . nanoTime ( ) - start > timeout ) { 
distributedCounter . decrement ( ) ; 
return false ; 
} 
} 
lHolds . increment ( ) ; 
assert lHolds . intValue ( ) == 1 ; 
return true ; 
} 
} 

public class OGraphBatchInsertBasic { 
public void end ( ) { 
final OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; 
try { 
runningThreads = new AtomicInteger ( parallel ) ; 
for ( int i = 0 ; 
i < parallel - 1 ; 
i ++ ) { 
Thread t = new BatchImporterJob ( i , vClass ) ; 
t . start ( ) ; 
} 
Thread t = new BatchImporterJob ( parallel - 1 , vClass ) ; 
t . run ( ) ; 
if ( runningThreads . get ( ) > 0 ) synchronized ( runningThreads ) { 
while ( runningThreads . get ( ) > 0 ) try { 
runningThreads . wait ( ) ; 
} 
catch ( InterruptedException e ) { 
} 
} 
} 
finally { 
db . activateOnCurrentThread ( ) ; 
db . declareIntent ( null ) ; 
db . close ( ) ; 
if ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; 
} 
} 
} 

public class OGraphBatchInsertBasic { 
public void createVertex ( final Long v ) { 
last = last < v ? v : last ; 
final List < Long > outList = out . get ( v ) ; 
if ( outList == null ) out . put ( v , new ArrayList < Long > ( averageEdgeNumberPerNode <= 0 ? 4 : averageEdgeNumberPerNode ) ) ; 
} 
} 

public class OCommandExecutorSQLInsert { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( newRecords == null && content == null && subQuery == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final OCommandParameters commandParameters = new OCommandParameters ( iArgs ) ; 
if ( indexName != null ) { 
if ( newRecords == null ) throw new OCommandExecutionException ( "No key/value found" ) ; 
final OIndex < ? > index = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . getIndex ( indexName ) ; 
if ( index == null ) throw new OCommandExecutionException ( "Target index '" + indexName + "' not found" ) ; 
Map < String , Object > result = new HashMap < String , Object > ( ) ; 
for ( Map < String , Object > candidate : newRecords ) { 
Object indexKey = getIndexKeyValue ( commandParameters , candidate ) ; 
OIdentifiable indexValue = getIndexValue ( commandParameters , candidate ) ; 
if ( index instanceof OIndexMultiValues ) { 
final Collection < ORID > rids = ( ( OIndexMultiValues ) index ) . get ( indexKey ) ; 
if ( ! rids . contains ( indexValue . getIdentity ( ) ) ) index . put ( indexKey , indexValue ) ; 
} 
else index . put ( indexKey , indexValue ) ; 
result . put ( KEYWORD_KEY , indexKey ) ; 
result . put ( KEYWORD_RID , indexValue ) ; 
} 
return prepareReturnItem ( new ODocument ( result ) ) ; 
} 
else { 
final List < ODocument > docs = new ArrayList < ODocument > ( ) ; 
if ( newRecords != null ) { 
for ( Map < String , Object > candidate : newRecords ) { 
final ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; 
OSQLHelper . bindParameters ( doc , candidate , commandParameters , context ) ; 
saveRecord ( doc ) ; 
docs . add ( doc ) ; 
} 
if ( docs . size ( ) == 1 ) return prepareReturnItem ( docs . get ( 0 ) ) ; 
else return prepareReturnResult ( docs ) ; 
} 
else if ( content != null ) { 
final ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; 
doc . merge ( content , true , false ) ; 
saveRecord ( doc ) ; 
return prepareReturnItem ( doc ) ; 
} 
else if ( subQuery != null ) { 
subQuery . execute ( ) ; 
if ( queryResult != null ) return prepareReturnResult ( queryResult ) ; 
return saved . longValue ( ) ; 
} 
} 
return null ; 
} 
} 

public class ORecordInternal { 
public static byte getRecordType ( final ORecord record ) { 
if ( record instanceof ORecordAbstract ) return ( ( ORecordAbstract ) record ) . getRecordType ( ) ; 
final ORecordAbstract rec = ( ORecordAbstract ) record . getRecord ( ) ; 
return rec . getRecordType ( ) ; 
} 
} 

public class ODistributedWorker { 
public void initDatabaseInstance ( ) { 
if ( database == null ) { 
for ( int retry = 0 ; 
retry < 100 ; 
++ retry ) try { 
database = distributed . getDatabaseInstance ( ) ; 
break ; 
} 
catch ( OStorageException e ) { 
if ( ! dbNotAvailable ( retry ) ) return ; 
} 
catch ( OConfigurationException e ) { 
if ( ! dbNotAvailable ( retry ) ) return ; 
} 
if ( database == null ) { 
ODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , "Database '%s' not present, shutting down database manager" , databaseName ) ; 
distributed . shutdown ( ) ; 
throw new ODistributedException ( "Cannot open database '" + databaseName + "'" ) ; 
} 
} 
else if ( database . isClosed ( ) ) { 
database . activateOnCurrentThread ( ) ; 
database . close ( ) ; 
database = distributed . getDatabaseInstance ( ) ; 
} 
} 
} 

public class OHttpNetworkCommandManager { 
public void registerCommand ( final OServerCommand iServerCommandInstance ) { 
for ( String name : iServerCommandInstance . getNames ( ) ) if ( OStringSerializerHelper . contains ( name , '{' ) ) restCommands . put ( name , iServerCommandInstance ) ; 
else if ( OStringSerializerHelper . contains ( name , '*' ) ) wildcardCommands . put ( name , iServerCommandInstance ) ; 
else exactCommands . put ( name , iServerCommandInstance ) ; 
iServerCommandInstance . configure ( server ) ; 
} 
} 

public class OFilterAnalyzer { 
public List < OIndexSearchResult > analyzeCondition ( OSQLFilterCondition condition , final OClass schemaClass , OCommandContext context ) { 
final List < OIndexSearchResult > indexSearchResults = new ArrayList < OIndexSearchResult > ( ) ; 
OIndexSearchResult lastCondition = analyzeFilterBranch ( schemaClass , condition , indexSearchResults , context ) ; 
if ( indexSearchResults . isEmpty ( ) && lastCondition != null ) indexSearchResults . add ( lastCondition ) ; 
Collections . sort ( indexSearchResults , new Comparator < OIndexSearchResult > ( ) { 
public int compare ( final OIndexSearchResult searchResultOne , final OIndexSearchResult searchResultTwo ) { 
return searchResultTwo . getFieldCount ( ) - searchResultOne . getFieldCount ( ) ; 
} 
} 
) ; 
return indexSearchResults ; 
} 
} 

public class OFilterAnalyzer { 
private OIndexSearchResult createIndexedProperty ( final OSQLFilterCondition iCondition , final Object iItem , OCommandContext ctx ) { 
if ( iItem == null || ! ( iItem instanceof OSQLFilterItemField ) ) return null ; 
if ( iCondition . getLeft ( ) instanceof OSQLFilterItemField && iCondition . getRight ( ) instanceof OSQLFilterItemField ) return null ; 
final OSQLFilterItemField item = ( OSQLFilterItemField ) iItem ; 
if ( item . hasChainOperators ( ) && ! item . isFieldChain ( ) ) return null ; 
boolean inverted = iCondition . getRight ( ) == iItem ; 
final Object origValue = inverted ? iCondition . getLeft ( ) : iCondition . getRight ( ) ; 
OQueryOperator operator = iCondition . getOperator ( ) ; 
if ( inverted ) if ( operator instanceof OQueryOperatorIn ) operator = new OQueryOperatorContains ( ) ; 
else if ( operator instanceof OQueryOperatorContains ) operator = new OQueryOperatorIn ( ) ; 
else if ( operator instanceof OQueryOperatorMajor ) operator = new OQueryOperatorMinor ( ) ; 
else if ( operator instanceof OQueryOperatorMinor ) operator = new OQueryOperatorMajor ( ) ; 
else if ( operator instanceof OQueryOperatorMajorEquals ) operator = new OQueryOperatorMinorEquals ( ) ; 
else if ( operator instanceof OQueryOperatorMinorEquals ) operator = new OQueryOperatorMajorEquals ( ) ; 
if ( iCondition . getOperator ( ) instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn ) return new OIndexSearchResult ( operator , item . getFieldChain ( ) , origValue ) ; 
final Object value = OSQLHelper . getValue ( origValue , null , ctx ) ; 
return new OIndexSearchResult ( operator , item . getFieldChain ( ) , value ) ; 
} 
} 

public class OCreateIndexStatement { 
private OClass getIndexClass ( OCommandContext ctx ) { 
if ( className == null ) return null ; 
OClass result = ctx . getDatabase ( ) . getMetadata ( ) . getSchema ( ) . getClass ( className . getStringValue ( ) ) ; 
if ( result == null ) throw new OCommandExecutionException ( "Cannot find class " + className ) ; 
return result ; 
} 
} 

public class OSequenceCached { 
protected long nextWithNewCurrentValue ( long currentValue , boolean executeViaDistributed ) throws OSequenceLimitReachedException , ODatabaseException { 
if ( ! executeViaDistributed ) synchronized ( this ) { 
cacheStart = currentValue ; 
return nextWork ( ) ; 
} 
else try { 
return sendSequenceActionSetAndNext ( currentValue ) ; 
} 
catch ( InterruptedException | ExecutionException exc ) { 
OLogManager . instance ( ) . error ( this , exc . getMessage ( ) , exc , ( Object [ ] ) null ) ; 
throw new ODatabaseException ( exc . getMessage ( ) ) ; 
} 
} 
} 

public class OClassImpl { 
public void truncate ( ) throws IOException { 
ODatabaseDocumentInternal db = getDatabase ( ) ; 
db . checkSecurity ( ORule . ResourceGeneric . CLASS , ORole . PERMISSION_UPDATE ) ; 
if ( isSubClassOf ( OSecurityShared . RESTRICTED_CLASSNAME ) ) throw new OSecurityException ( "Class '" + getName ( ) + "' cannot be truncated because has record level security enabled (extends '" + OSecurityShared . RESTRICTED_CLASSNAME + "')" ) ; 
final OStorage storage = db . getStorage ( ) ; 
acquireSchemaReadLock ( ) ; 
try { 
for ( int id : clusterIds ) { 
OCluster cl = storage . getClusterById ( id ) ; 
db . checkForClusterPermissions ( cl . getName ( ) ) ; 
cl . truncate ( ) ; 
} 
for ( OIndex < ? > index : getClassIndexes ( ) ) index . clear ( ) ; 
Set < OIndex < ? > > superclassIndexes = new HashSet < OIndex < ? > > ( ) ; 
superclassIndexes . addAll ( getIndexes ( ) ) ; 
superclassIndexes . removeAll ( getClassIndexes ( ) ) ; 
for ( OIndex index : superclassIndexes ) { 
index . rebuild ( ) ; 
} 
} 
finally { 
releaseSchemaReadLock ( ) ; 
} 
} 
} 

public class OClassImpl { 
protected void addPolymorphicClusterIds ( final OClassImpl iBaseClass ) { 
Set < Integer > clusters = new TreeSet < Integer > ( ) ; 
for ( int clusterId : polymorphicClusterIds ) { 
clusters . add ( clusterId ) ; 
} 
for ( int clusterId : iBaseClass . polymorphicClusterIds ) { 
if ( clusters . add ( clusterId ) ) try { 
addClusterIdToIndexes ( clusterId ) ; 
} 
catch ( RuntimeException e ) { 
OLogManager . instance ( ) . warn ( this , "Error adding clusterId '%d' to index of class '%s'" , e , clusterId , getName ( ) ) ; 
clusters . remove ( clusterId ) ; 
} 
} 
polymorphicClusterIds = new int [ clusters . size ( ) ] ; 
int i = 0 ; 
for ( Integer cluster : clusters ) { 
polymorphicClusterIds [ i ] = cluster ; 
i ++ ; 
} 
} 
} 

public class ORecordSerializerCSVAbstract { 
private static OIdentifiable linkToStream ( final StringBuilder buffer , final ODocument iParentRecord , Object iLinked ) { 
if ( iLinked == null ) return null ; 
OIdentifiable resultRid = null ; 
ORID rid ; 
if ( iLinked instanceof ORID ) { 
rid = ( ORID ) iLinked ; 
assert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : "Impossible to serialize invalid link " + rid . getIdentity ( ) ; 
resultRid = rid ; 
} 
else { 
if ( iLinked instanceof String ) iLinked = new ORecordId ( ( String ) iLinked ) ; 
if ( ! ( iLinked instanceof OIdentifiable ) ) throw new IllegalArgumentException ( "Invalid object received. Expected a OIdentifiable but received type=" + iLinked . getClass ( ) . getName ( ) + " and value=" + iLinked ) ; 
ORecord iLinkedRecord = ( ( OIdentifiable ) iLinked ) . getRecord ( ) ; 
rid = iLinkedRecord . getIdentity ( ) ; 
assert rid . getIdentity ( ) . isValid ( ) || ( ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getStorage ( ) instanceof OStorageProxy ) : "Impossible to serialize invalid link " + rid . getIdentity ( ) ; 
final ODatabaseDocument database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; 
if ( iParentRecord != null ) if ( ! database . isRetainRecords ( ) ) resultRid = iLinkedRecord . getIdentity ( ) ; 
} 
if ( rid . isValid ( ) ) rid . toString ( buffer ) ; 
return resultRid ; 
} 
} 

public class OByteBufferPool { 
public final void release ( OPointer pointer ) { 
if ( TRACK ) pointerMapping . remove ( pointer ) ; 
long poolSize = pointersPoolSize . incrementAndGet ( ) ; 
if ( poolSize > this . poolSize ) { 
pointersPoolSize . decrementAndGet ( ) ; 
allocator . deallocate ( pointer ) ; 
} 
else pointersPool . add ( pointer ) ; 
} 
} 

public class OByteBufferPool { 
public void checkMemoryLeaks ( ) { 
boolean detected = false ; 
if ( TRACK ) for ( Map . Entry < OPointer , PointerTracker > entry : pointerMapping . entrySet ( ) ) { 
OLogManager . instance ( ) . errorNoDb ( this , "DIRECT-TRACK: unreleased direct memory pointer `%X` detected." , entry . getValue ( ) . allocation , System . identityHashCode ( entry . getKey ( ) ) ) ; 
detected = true ; 
} 
assert ! detected ; 
} 
} 

public class OCollections { 
public static int indexOf ( final Object [ ] array , final Comparable object ) { 
for ( int i = 0 ; 
i < array . length ; 
++ i ) if ( object . compareTo ( array [ i ] ) == 0 ) return i ; 
return - 1 ; 
} 
} 

public class OCollections { 
public static int indexOf ( final int [ ] array , final int object ) { 
for ( int i = 0 ; 
i < array . length ; 
++ i ) if ( array [ i ] == object ) return i ; 
return - 1 ; 
} 
} 

public class OCommandExecutorSQLSelect { 
@ Override public Set < String > getInvolvedClusters ( ) { 
final Set < String > clusters = new HashSet < String > ( ) ; 
if ( parsedTarget != null ) { 
final ODatabaseDocument db = getDatabase ( ) ; 
if ( parsedTarget . getTargetQuery ( ) != null && parsedTarget . getTargetRecords ( ) instanceof OCommandExecutorSQLResultsetDelegate ) { 
final Set < String > clIds = ( ( OCommandExecutorSQLResultsetDelegate ) parsedTarget . getTargetRecords ( ) ) . getInvolvedClusters ( ) ; 
for ( String c : clIds ) { 
if ( checkClusterAccess ( db , c ) ) clusters . add ( c ) ; 
} 
} 
else if ( parsedTarget . getTargetRecords ( ) != null ) for ( OIdentifiable identifiable : parsedTarget . getTargetRecords ( ) ) { 
final String c = db . getClusterNameById ( identifiable . getIdentity ( ) . getClusterId ( ) ) . toLowerCase ( Locale . ENGLISH ) ; 
if ( checkClusterAccess ( db , c ) ) clusters . add ( c ) ; 
} 
if ( parsedTarget . getTargetClasses ( ) != null ) return getInvolvedClustersOfClasses ( parsedTarget . getTargetClasses ( ) . values ( ) ) ; 
if ( parsedTarget . getTargetClusters ( ) != null ) return getInvolvedClustersOfClusters ( parsedTarget . getTargetClusters ( ) . keySet ( ) ) ; 
if ( parsedTarget . getTargetIndex ( ) != null ) return getInvolvedClustersOfIndex ( parsedTarget . getTargetIndex ( ) ) ; 
} 
return clusters ; 
} 
} 

public class OCommandExecutorSQLSelect { 
@ Override protected boolean handleResult ( final OIdentifiable iRecord , final OCommandContext iContext ) { 
lastRecord = iRecord ; 
if ( ( orderedFields . isEmpty ( ) || fullySortedByIndex || isRidOnlySort ( ) ) && skip > 0 && this . unwindFields == null && this . expandTarget == null ) { 
lastRecord = null ; 
skip -- ; 
return true ; 
} 
if ( ! addResult ( lastRecord , iContext ) ) return false ; 
return continueSearching ( ) ; 
} 
} 

public class OCommandExecutorSQLSelect { 
protected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { 
if ( ! w . equals ( KEYWORD_FETCHPLAN ) ) return false ; 
parserSkipWhiteSpaces ( ) ; 
int start = parserGetCurrentPosition ( ) ; 
parserNextWord ( true ) ; 
int end = parserGetCurrentPosition ( ) ; 
parserSkipWhiteSpaces ( ) ; 
int position = parserGetCurrentPosition ( ) ; 
while ( ! parserIsEnded ( ) ) { 
final String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; 
if ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) break ; 
end = parserGetCurrentPosition ( ) ; 
parserSkipWhiteSpaces ( ) ; 
position = parserGetCurrentPosition ( ) ; 
} 
parserSetCurrentPosition ( position ) ; 
if ( end < 0 ) fetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; 
else fetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; 
request . setFetchPlan ( fetchPlan ) ; 
return true ; 
} 
} 

public class OETLJob { 
public ODocument status ( ) { 
synchronized ( listener ) { 
ODocument status = new ODocument ( ) ; 
status . field ( "cfg" , cfg ) ; 
status . field ( "status" , this . status ) ; 
String lastBatchLog = "" ; 
if ( this . messageHandler != null ) lastBatchLog = extractBatchLog ( ) ; 
status . field ( "log" , lastBatchLog ) ; 
if ( this . status == Status . FINISHED ) listener . notifyAll ( ) ; 
return status ; 
} 
} 
} 

public class OAbstractPaginatedStorage { 
public final void handleJVMError ( final Error e ) { 
if ( jvmError . compareAndSet ( null , e ) ) OLogManager . instance ( ) . errorNoDb ( this , "JVM error was thrown" , e ) ; 
} 
} 

public class OAbstractPaginatedStorage { 
@ SuppressWarnings ( "UnusedReturnValue" ) public boolean validatedPutIndexValue ( int indexId , final Object key , final ORID value , final OBaseIndexEngine . Validator < Object , ORID > validator ) throws OInvalidIndexEngineIdException { 
indexId = extractInternalId ( indexId ) ; 
try { 
if ( transaction . get ( ) != null ) return doValidatedPutIndexValue ( indexId , key , value , validator ) ; 
checkOpenness ( ) ; 
stateLock . acquireReadLock ( ) ; 
try { 
checkOpenness ( ) ; 
checkLowDiskSpaceRequestsAndReadOnlyConditions ( ) ; 
return doValidatedPutIndexValue ( indexId , key , value , validator ) ; 
} 
finally { 
stateLock . releaseReadLock ( ) ; 
} 
} 
catch ( final OInvalidIndexEngineIdException ie ) { 
throw logAndPrepareForRethrow ( ie ) ; 
} 
catch ( final RuntimeException ee ) { 
throw logAndPrepareForRethrow ( ee ) ; 
} 
catch ( final Error ee ) { 
throw logAndPrepareForRethrow ( ee ) ; 
} 
catch ( final Throwable t ) { 
throw logAndPrepareForRethrow ( t ) ; 
} 
} 
} 

public class OAbstractPaginatedStorage { 
public void rollback ( final OMicroTransaction microTransaction ) { 
try { 
checkOpenness ( ) ; 
stateLock . acquireReadLock ( ) ; 
try { 
try { 
checkOpenness ( ) ; 
if ( transaction . get ( ) == null ) return ; 
if ( transaction . get ( ) . getMicroTransaction ( ) . getId ( ) != microTransaction . getId ( ) ) throw new OStorageException ( "Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be " + "rolled back." ) ; 
makeStorageDirty ( ) ; 
rollbackStorageTx ( ) ; 
microTransaction . updateRecordCacheAfterRollback ( ) ; 
txRollback . incrementAndGet ( ) ; 
} 
catch ( final IOException e ) { 
throw OException . wrapException ( new OStorageException ( "Error during micro-transaction rollback" ) , e ) ; 
} 
finally { 
transaction . set ( null ) ; 
} 
} 
finally { 
stateLock . releaseReadLock ( ) ; 
} 
} 
catch ( final RuntimeException ee ) { 
throw logAndPrepareForRethrow ( ee ) ; 
} 
catch ( final Error ee ) { 
throw logAndPrepareForRethrow ( ee ) ; 
} 
catch ( final Throwable t ) { 
throw logAndPrepareForRethrow ( t ) ; 
} 
} 
} 

public class OAbstractPaginatedStorage { 
@ Override public final Object command ( final OCommandRequestText iCommand ) { 
try { 
while ( true ) try { 
final OCommandExecutor executor = OCommandManager . instance ( ) . getExecutor ( iCommand ) ; 
executor . setContext ( iCommand . getContext ( ) ) ; 
executor . setProgressListener ( iCommand . getProgressListener ( ) ) ; 
executor . parse ( iCommand ) ; 
return executeCommand ( iCommand , executor ) ; 
} 
catch ( final ORetryQueryException ignore ) { 
if ( iCommand instanceof OQueryAbstract ) { 
final OQueryAbstract query = ( OQueryAbstract ) iCommand ; 
query . reset ( ) ; 
} 
} 
} 
catch ( final RuntimeException ee ) { 
throw logAndPrepareForRethrow ( ee ) ; 
} 
catch ( final Error ee ) { 
throw logAndPrepareForRethrow ( ee , false ) ; 
} 
catch ( final Throwable t ) { 
throw logAndPrepareForRethrow ( t ) ; 
} 
} 
} 

public class OAbstractPaginatedStorage { 
private int registerCluster ( final OCluster cluster ) { 
final int id ; 
if ( cluster != null ) { 
if ( clusterMap . containsKey ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) ) ) throw new OConfigurationException ( "Cannot add cluster '" + cluster . getName ( ) + "' because it is already registered in database '" + name + "'" ) ; 
clusterMap . put ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) , cluster ) ; 
id = cluster . getId ( ) ; 
} 
else id = clusters . size ( ) ; 
setCluster ( id , cluster ) ; 
return id ; 
} 
} 

public class OPartitionedDatabasePool { 
public Object setProperty ( final String iName , final Object iValue ) { 
if ( iValue != null ) return properties . put ( iName . toLowerCase ( Locale . ENGLISH ) , iValue ) ; 
else return properties . remove ( iName . toLowerCase ( Locale . ENGLISH ) ) ; 
} 
} 

public class OCommandExecutorSQLCreateClass { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( className == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocument database = getDatabase ( ) ; 
boolean alreadyExists = database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ; 
if ( ! alreadyExists || ! ifNotExists ) if ( clusters != null ) database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusters , superClasses . toArray ( new OClass [ 0 ] ) ) ; 
else database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusterIds , superClasses . toArray ( new OClass [ 0 ] ) ) ; 
return database . getMetadata ( ) . getSchema ( ) . getClasses ( ) . size ( ) ; 
} 
} 

public class OBaseParser { 
protected String parserRequiredWord ( final boolean iUpperCase , final String iCustomMessage , String iSeparators ) { 
if ( iSeparators == null ) iSeparators = " ()=><,\r\n" ; 
parserNextWord ( iUpperCase , iSeparators ) ; 
if ( parserLastWord . length ( ) == 0 ) throwSyntaxErrorException ( iCustomMessage ) ; 
if ( parserLastWord . charAt ( 0 ) == '`' && parserLastWord . charAt ( parserLastWord . length ( ) - 1 ) == '`' ) return parserLastWord . substring ( 1 , parserLastWord . length ( ) - 1 ) ; 
return parserLastWord . toString ( ) ; 
} 
} 

public class OBaseParser { 
private boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { 
for ( int sepIndex = 0 ; 
sepIndex < iSeparatorChars . length ( ) ; 
++ sepIndex ) if ( iSeparatorChars . charAt ( sepIndex ) == c ) { 
parserLastSeparator = c ; 
return true ; 
} 
return false ; 
} 
} 

public class OCommandExecutorSQLDropClass { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( className == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocument database = getDatabase ( ) ; 
if ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) return true ; 
final OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; 
if ( cls == null ) return null ; 
final long records = cls . count ( true ) ; 
if ( records > 0 && ! unsafe ) if ( cls . isSubClassOf ( "V" ) ) throw new OCommandExecutionException ( "'DROP CLASS' command cannot drop class '" + className + "' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it" ) ; 
else if ( cls . isSubClassOf ( "E" ) ) throw new OCommandExecutionException ( "'DROP CLASS' command cannot drop class '" + className + "' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it" ) ; 
database . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; 
if ( records > 0 && unsafe ) if ( cls . isSubClassOf ( "V" ) ) if ( unsafe ) OLogManager . instance ( ) . warn ( this , "Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges" , className , records ) ; 
else if ( cls . isSubClassOf ( "E" ) ) OLogManager . instance ( ) . warn ( this , "Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices" , className , records ) ; 
return true ; 
} 
} 

public class OAuth2FeignRequestInterceptor { 
protected OAuth2AccessToken acquireAccessToken ( ) throws UserRedirectRequiredException { 
AccessTokenRequest tokenRequest = oAuth2ClientContext . getAccessTokenRequest ( ) ; 
if ( tokenRequest == null ) throw new AccessTokenRequiredException ( "Cannot find valid context on request for resource '" + resource . getId ( ) + "'." , resource ) ; 
String stateKey = tokenRequest . getStateKey ( ) ; 
if ( stateKey != null ) tokenRequest . setPreservedState ( oAuth2ClientContext . removePreservedState ( stateKey ) ) ; 
OAuth2AccessToken existingToken = oAuth2ClientContext . getAccessToken ( ) ; 
if ( existingToken != null ) oAuth2ClientContext . setAccessToken ( existingToken ) ; 
OAuth2AccessToken obtainableAccessToken ; 
obtainableAccessToken = accessTokenProvider . obtainAccessToken ( resource , tokenRequest ) ; 
if ( obtainableAccessToken == null || obtainableAccessToken . getValue ( ) == null ) throw new IllegalStateException ( " Access token provider returned a null token, which is illegal according to the contract." ) ; 
oAuth2ClientContext . setAccessToken ( obtainableAccessToken ) ; 
return obtainableAccessToken ; 
} 
} 

public class AccessTokenContextRelay { 
public boolean copyToken ( ) { 
if ( context . getAccessToken ( ) == null ) { 
Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; 
if ( authentication != null ) { 
Object details = authentication . getDetails ( ) ; 
if ( details instanceof OAuth2AuthenticationDetails ) { 
OAuth2AuthenticationDetails holder = ( OAuth2AuthenticationDetails ) details ; 
String token = holder . getTokenValue ( ) ; 
DefaultOAuth2AccessToken accessToken = new DefaultOAuth2AccessToken ( token ) ; 
String tokenType = holder . getTokenType ( ) ; 
if ( tokenType != null ) accessToken . setTokenType ( tokenType ) ; 
context . setAccessToken ( accessToken ) ; 
return true ; 
} 
} 
} 
return false ; 
} 
} 

public class FastBufferedInputStream { 
public int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { 
ByteArrays . ensureOffsetLength ( array , off , len ) ; 
if ( len == 0 ) return 0 ; 
if ( noMoreCharacters ( ) ) return - 1 ; 
int i , k = 0 , remaining = len , read = 0 ; 
for ( ; 
; 
) { 
for ( i = 0 ; 
i < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\n' && k != '\r' ; 
i ++ ) ; 
System . arraycopy ( buffer , pos , array , off + read , i ) ; 
pos += i ; 
avail -= i ; 
read += i ; 
remaining -= i ; 
if ( remaining == 0 ) { 
readBytes += read ; 
return read ; 
} 
if ( avail > 0 ) if ( k == '\n' ) { 
pos ++ ; 
avail -- ; 
if ( terminators . contains ( LineTerminator . LF ) ) { 
readBytes += read + 1 ; 
return read ; 
} 
else { 
array [ off + read ++ ] = '\n' ; 
remaining -- ; 
} 
} 
else if ( k == '\r' ) { 
pos ++ ; 
avail -- ; 
if ( terminators . contains ( LineTerminator . CR_LF ) ) if ( avail > 0 ) if ( buffer [ pos ] == '\n' ) { 
pos ++ ; 
avail -- ; 
readBytes += read + 2 ; 
return read ; 
} 
else { 
if ( noMoreCharacters ( ) ) { 
if ( ! terminators . contains ( LineTerminator . CR ) ) { 
array [ off + read ++ ] = '\r' ; 
remaining -- ; 
readBytes += read ; 
} 
else readBytes += read + 1 ; 
return read ; 
} 
if ( buffer [ 0 ] == '\n' ) { 
pos ++ ; 
avail -- ; 
readBytes += read + 2 ; 
return read ; 
} 
} 
if ( terminators . contains ( LineTerminator . CR ) ) { 
readBytes += read + 1 ; 
return read ; 
} 
array [ off + read ++ ] = '\r' ; 
remaining -- ; 
} 
else if ( noMoreCharacters ( ) ) { 
readBytes += read ; 
return read ; 
} 
} 
} 
} 

public class FastBufferedInputStream { 
@ Override public long skip ( final long n ) throws IOException { 
if ( n <= avail ) { 
final int m = ( int ) n ; 
pos += m ; 
avail -= m ; 
readBytes += n ; 
return n ; 
} 
long toSkip = n - avail , result = 0 ; 
avail = 0 ; 
while ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) if ( result == 0 ) { 
if ( is . read ( ) == - 1 ) break ; 
toSkip -- ; 
} 
else toSkip -= result ; 
final long t = n - ( toSkip - result ) ; 
readBytes += t ; 
return t ; 
} 
} 

public class Arrays { 
public static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { 
final int length = to - from ; 
if ( length < MERGESORT_NO_REC ) { 
for ( int i = from ; 
i < to ; 
i ++ ) for ( int j = i ; 
j > from && ( c . compare ( j - 1 , j ) > 0 ) ; 
j -- ) swapper . swap ( j , j - 1 ) ; 
return ; 
} 
int mid = ( from + to ) >>> 1 ; 
mergeSort ( from , mid , c , swapper ) ; 
mergeSort ( mid , to , c , swapper ) ; 
if ( c . compare ( mid - 1 , mid ) <= 0 ) return ; 
inPlaceMerge ( from , mid , to , c , swapper ) ; 
} 
} 

public class HashIndexSelect { 
public Stream < S > findMatches ( Q query ) { 
Object [ ] queryArray = matchFields . stream ( ) . map ( mf -> mf . extract ( query ) ) . toArray ( ) ; 
HollowHashIndexResult matches = hhi . findMatches ( queryArray ) ; 
if ( matches == null ) return Stream . empty ( ) ; 
return matches . stream ( ) . mapToObj ( i -> selectField . extract ( api , i ) ) ; 
} 
} 

public class HollowCompactor { 
private Set < String > findCompactionTargets ( ) { 
List < HollowSchema > schemas = HollowSchemaSorter . dependencyOrderedSchemaList ( readEngine . getSchemas ( ) ) ; 
Set < String > typesToCompact = new HashSet < String > ( ) ; 
for ( HollowSchema schema : schemas ) { 
if ( isCompactionCandidate ( schema . getName ( ) ) ) if ( ! candidateIsDependentOnAnyTargetedType ( schema . getName ( ) , typesToCompact ) ) typesToCompact . add ( schema . getName ( ) ) ; 
} 
return typesToCompact ; 
} 
} 

public class HollowFilesystemBlobStorageCleaner { 
@ Override public void cleanSnapshots ( ) { 
File [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; 
if ( files == null || files . length <= numOfSnapshotsToKeep ) return ; 
sortByLastModified ( files ) ; 
for ( int i = numOfSnapshotsToKeep ; 
i < files . length ; 
i ++ ) { 
File file = files [ i ] ; 
boolean deleted = file . delete ( ) ; 
if ( ! deleted ) log . warning ( "Could not delete snapshot " + file . getPath ( ) ) ; 
} 
} 
} 

public class TransitiveSetTraverser { 
public static void removeReferencedOutsideClosure ( HollowReadStateEngine stateEngine , Map < String , BitSet > matches ) { 
List < HollowSchema > orderedSchemas = HollowSchemaSorter . dependencyOrderedSchemaList ( stateEngine ) ; 
Collections . reverse ( orderedSchemas ) ; 
for ( HollowSchema referencedSchema : orderedSchemas ) { 
if ( matches . containsKey ( referencedSchema . getName ( ) ) ) for ( HollowSchema referencerSchema : orderedSchemas ) { 
if ( referencerSchema == referencedSchema ) break ; 
if ( matches . containsKey ( referencedSchema . getName ( ) ) && matches . get ( referencedSchema . getName ( ) ) . cardinality ( ) > 0 ) traverseReferencesOutsideClosure ( stateEngine , referencerSchema . getName ( ) , referencedSchema . getName ( ) , matches , REMOVE_REFERENCED_OUTSIDE_CLOSURE ) ; 
} 
} 
} 
} 

public class HollowBlobHeaderReader { 
private Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { 
int numHeaderTags = dis . readShort ( ) ; 
Map < String , String > headerTags = new HashMap < String , String > ( ) ; 
for ( int i = 0 ; 
i < numHeaderTags ; 
i ++ ) headerTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; 
return headerTags ; 
} 
} 

public class ThreadSafeBitSet { 
public void clearAll ( ) { 
ThreadSafeBitSetSegments segments = this . segments . get ( ) ; 
for ( int i = 0 ; 
i < segments . numSegments ( ) ; 
i ++ ) { 
AtomicLongArray segment = segments . getSegment ( i ) ; 
for ( int j = 0 ; 
j < segment . length ( ) ; 
j ++ ) segment . set ( j , 0L ) ; 
} 
} 
} 

public class DiffViewOutputGenerator { 
private static String getFieldValue ( HollowDiffViewRow row , boolean useFrom ) { 
Field field = useFrom ? row . getFieldPair ( ) . getFrom ( ) : row . getFieldPair ( ) . getTo ( ) ; 
if ( row . getFieldPair ( ) . isLeafNode ( ) ) return field . getValue ( ) == null ? "null" : field . getValue ( ) . toString ( ) . replace ( "|" , "&#x2502" ) ; 
else { 
String suffix = field . getValue ( ) == null ? " [null]" : "" ; 
return "(" + field . getTypeName ( ) + ")" + suffix ; 
} 
} 
} 

public class SegmentedByteArray { 
public void copy ( ByteData src , long srcPos , long destPos , long length ) { 
for ( long i = 0 ; 
i < length ; 
i ++ ) set ( destPos ++ , src . get ( srcPos ++ ) ) ; 
} 
} 

public class SegmentedByteArray { 
public void readFrom ( InputStream is , long length ) throws IOException { 
int segmentSize = 1 << log2OfSegmentSize ; 
int segment = 0 ; 
byte scratch [ ] = new byte [ segmentSize ] ; 
while ( length > 0 ) { 
ensureCapacity ( segment ) ; 
long bytesToCopy = Math . min ( segmentSize , length ) ; 
long bytesCopied = 0 ; 
while ( bytesCopied < bytesToCopy ) bytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; 
orderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; 
length -= bytesCopied ; 
} 
} 
} 

public class SegmentedByteArray { 
private void ensureCapacity ( int segmentIndex ) { 
while ( segmentIndex >= segments . length ) segments = Arrays . copyOf ( segments , segments . length * 3 / 2 ) ; 
if ( segments [ segmentIndex ] == null ) segments [ segmentIndex ] = memoryRecycler . getByteArray ( ) ; 
} 
} 

public class HollowObjectSchema { 
public int getPosition ( String fieldName ) { 
Integer index = nameFieldIndexLookup . get ( fieldName ) ; 
if ( index == null ) return - 1 ; 
return index ; 
} 
} 

public class HollowAPIGenerator { 
protected static boolean hasCollectionsInDataSet ( HollowDataset dataset ) { 
for ( HollowSchema schema : dataset . getSchemas ( ) ) { 
if ( ( schema instanceof HollowListSchema ) || ( schema instanceof HollowSetSchema ) || ( schema instanceof HollowMapSchema ) ) return true ; 
} 
return false ; 
} 
} 

public class HollowAPIGenerator { 
public void generateFiles ( File directory ) throws IOException { 
if ( packageName != null && ! packageName . trim ( ) . isEmpty ( ) ) { 
String packageDir = packageName . replace ( "." , File . separator ) ; 
if ( ! directory . getAbsolutePath ( ) . endsWith ( packageDir ) ) directory = new File ( directory , packageDir ) ; 
} 
directory . mkdirs ( ) ; 
HollowAPIClassJavaGenerator apiClassGenerator = new HollowAPIClassJavaGenerator ( packageName , apiClassname , dataset , parameterizeClassNames , config ) ; 
HollowAPIFactoryJavaGenerator apiFactoryGenerator = new HollowAPIFactoryJavaGenerator ( packageName , apiClassname , dataset , config ) ; 
HollowHashIndexGenerator hashIndexGenerator = new HollowHashIndexGenerator ( packageName , apiClassname , dataset , config ) ; 
generateFile ( directory , apiClassGenerator ) ; 
generateFile ( directory , apiFactoryGenerator ) ; 
generateFile ( directory , hashIndexGenerator ) ; 
generateFilesForHollowSchemas ( directory ) ; 
} 
} 

public class HollowAPIGenerator { 
protected void generateFilesForHollowSchemas ( File directory ) throws IOException { 
for ( HollowSchema schema : dataset . getSchemas ( ) ) { 
String type = schema . getName ( ) ; 
if ( config . isUseHollowPrimitiveTypes ( ) && HollowCodeGenerationUtils . isPrimitiveType ( type ) ) continue ; 
generateFile ( directory , getStaticAPIGenerator ( schema ) ) ; 
generateFile ( directory , getHollowObjectGenerator ( schema ) ) ; 
generateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; 
if ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { 
HollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; 
generateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; 
generateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; 
generateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; 
generateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; 
if ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) generateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; 
else if ( ( objSchema ) . getPrimaryKey ( ) != null ) { 
generateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; 
generateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; 
} 
} 
} 
} 
} 

public class HollowPrimaryKeyValueDeriver { 
public boolean keyMatches ( int ordinal , Object ... keys ) { 
if ( keys . length != fieldPathIndexes . length ) return false ; 
for ( int i = 0 ; 
i < keys . length ; 
i ++ ) if ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; 
return true ; 
} 
} 

public class HollowPrimaryKeyValueDeriver { 
public Object [ ] getRecordKey ( int ordinal ) { 
Object [ ] results = new Object [ fieldPathIndexes . length ] ; 
for ( int i = 0 ; 
i < fieldPathIndexes . length ; 
i ++ ) results [ i ] = readValue ( ordinal , i ) ; 
return results ; 
} 
} 

public class HollowIncrementalProducer { 
public void restoreFromLastState ( ) { 
producer . initializeDataModel ( dataModel ) ; 
long latestAnnouncedVersion = announcementWatcher . getLatestVersion ( ) ; 
if ( latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher . NO_ANNOUNCEMENT_AVAILABLE || latestAnnouncedVersion < 0 ) return ; 
restore ( latestAnnouncedVersion , blobRetriever ) ; 
} 
} 

public class HollowIncrementalProducer { 
public long runCycle ( ) { 
long recordsRemoved = countRecordsToRemove ( ) ; 
long recordsAddedOrModified = this . mutations . values ( ) . size ( ) - recordsRemoved ; 
try { 
long version = producer . runCycle ( populator ) ; 
if ( version == lastSucessfulCycle ) return version ; 
listeners . fireIncrementalCycleComplete ( version , recordsAddedOrModified , recordsRemoved , new HashMap < String , Object > ( cycleMetadata ) ) ; 
clearChanges ( ) ; 
lastSucessfulCycle = version ; 
return version ; 
} 
catch ( Exception e ) { 
listeners . fireIncrementalCycleFail ( e , recordsAddedOrModified , recordsRemoved , new HashMap < String , Object > ( cycleMetadata ) ) ; 
return FAILED_VERSION ; 
} 
finally { 
clearCycleMetadata ( ) ; 
} 
} 
} 

public class HollowObjectWriteRecord { 
public void writeDataTo ( ByteDataBuffer buf ) { 
for ( int i = 0 ; 
i < fieldData . length ; 
i ++ ) writeField ( buf , i ) ; 
} 
} 

public class FreeOrdinalTracker { 
public void returnOrdinalToPool ( int ordinal ) { 
if ( size == freeOrdinals . length ) freeOrdinals = Arrays . copyOf ( freeOrdinals , freeOrdinals . length * 3 / 2 ) ; 
freeOrdinals [ size ] = ordinal ; 
size ++ ; 
} 
} 

public class FixedLengthMultipleOccurrenceElementArray { 
private void resizeStorage ( ) { 
int currentElementsPerNode = maxElementsPerNode ; 
int newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; 
if ( newElementsPerNode <= currentElementsPerNode ) throw new IllegalStateException ( "cannot resize fixed length array from " + currentElementsPerNode + " to " + newElementsPerNode ) ; 
FixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; 
LongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { 
long currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; 
long newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; 
for ( int offset = 0 ; 
offset < currentElementsPerNode ; 
offset ++ ) { 
long element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; 
if ( element == NO_ELEMENT ) break ; 
newStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; 
} 
} 
) ; 
storage . destroy ( memoryRecycler ) ; 
storage = newStorage ; 
maxElementsPerNode = newElementsPerNode ; 
} 
} 

public class ByteArrayOrdinalMap { 
public void prepareForWrite ( ) { 
int maxOrdinal = 0 ; 
AtomicLongArray pao = pointersAndOrdinals ; 
for ( int i = 0 ; 
i < pao . length ( ) ; 
i ++ ) { 
long key = pao . get ( i ) ; 
if ( key != EMPTY_BUCKET_VALUE ) { 
int ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; 
if ( ordinal > maxOrdinal ) maxOrdinal = ordinal ; 
} 
} 
long [ ] pbo = new long [ maxOrdinal + 1 ] ; 
Arrays . fill ( pbo , - 1 ) ; 
for ( int i = 0 ; 
i < pao . length ( ) ; 
i ++ ) { 
long key = pao . get ( i ) ; 
if ( key != EMPTY_BUCKET_VALUE ) { 
int ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; 
pbo [ ordinal ] = key & POINTER_MASK ; 
} 
} 
pointersByOrdinal = pbo ; 
} 
} 

public class ByteArrayOrdinalMap { 
private boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { 
long position = key & POINTER_MASK ; 
int sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; 
if ( sizeOfData != serializedRepresentation . length ( ) ) return false ; 
position += VarInt . sizeOfVInt ( sizeOfData ) ; 
for ( int i = 0 ; 
i < sizeOfData ; 
i ++ ) if ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) return false ; 
return true ; 
} 
} 

public class ByteArrayOrdinalMap { 
private void growKeyArray ( ) { 
int newSize = pointersAndOrdinals . length ( ) << 1 ; 
if ( newSize < 0 ) throw new IllegalStateException ( "New size computed to grow the underlying array for the map is negative. " + "This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. " + "Current array size :" + pointersAndOrdinals . length ( ) + " and size to grow :" + newSize ) ; 
growKeyArray ( newSize ) ; 
} 
} 

public class ByteArrayOrdinalMap { 
private AtomicLongArray emptyKeyArray ( int size ) { 
AtomicLongArray arr = new AtomicLongArray ( size ) ; 
for ( int i = 0 ; 
i < arr . length ( ) ; 
i ++ ) arr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; 
return arr ; 
} 
} 

public class HollowIndexerValueTraverser { 
public boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { 
for ( int i = 0 ; 
i < getNumFieldPaths ( ) ; 
i ++ ) if ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; 
return true ; 
} 
} 

public class UniqueKeyIndex { 
public T findMatch ( Q key ) { 
Object [ ] keyArray = matchFields . stream ( ) . map ( mf -> mf . extract ( key ) ) . toArray ( ) ; 
int ordinal = hpki . getMatchingOrdinal ( keyArray ) ; 
if ( ordinal == - 1 ) return null ; 
return uniqueTypeExtractor . extract ( api , ordinal ) ; 
} 
} 

public class HashCodes { 
public static int hashTableSize ( int numElements ) throws IllegalArgumentException { 
if ( numElements < 0 ) throw new IllegalArgumentException ( "cannot be negative; numElements=" + numElements ) ; 
else if ( numElements > HASH_TABLE_MAX_SIZE ) throw new IllegalArgumentException ( "exceeds maximum number of buckets; numElements=" + numElements ) ; 
if ( numElements == 0 ) return 1 ; 
if ( numElements < 3 ) return numElements * 2 ; 
int sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; 
int bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; 
return 1 << bits ; 
} 
} 

public class HollowProducer { 
public long runCompactionCycle ( HollowCompactor . CompactionConfig config ) { 
if ( config != null && readStates . hasCurrent ( ) ) { 
final HollowCompactor compactor = new HollowCompactor ( getWriteEngine ( ) , readStates . current ( ) . getStateEngine ( ) , config ) ; 
if ( compactor . needsCompaction ( ) ) return runCycle ( newState -> compactor . compact ( ) ) ; 
} 
return NO_ANNOUNCEMENT_AVAILABLE ; 
} 
} 

public class HollowConsumerJavaFileGenerator { 
private void addToSetIfNotPrimitiveOrCollection ( Set < String > schemaNameSet , String ... schemaNames ) { 
for ( String schemaName : schemaNames ) { 
if ( ! HollowCodeGenerationUtils . isCollectionType ( schemaName , dataset ) && ! HollowCodeGenerationUtils . isPrimitiveType ( schemaName ) ) schemaNameSet . add ( schemaName ) ; 
} 
} 
} 

public class HollowCodeGenerationUtils { 
public static String normalizeFieldPathToParamName ( String fieldPath ) { 
String result = null ; 
if ( fieldPath . contains ( "." ) ) { 
String [ ] parts = fieldPath . split ( "\\." ) ; 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( lowercase ( parts [ 0 ] ) ) ; 
for ( int i = 1 ; 
i < parts . length ; 
i ++ ) sb . append ( uppercase ( parts [ i ] ) ) ; 
result = sb . toString ( ) ; 
} 
else result = lowercase ( fieldPath ) ; 
if ( result . endsWith ( "!" ) ) return result . substring ( 0 , result . length ( ) - 1 ) ; 
return result ; 
} 
} 

public class PullToRefreshBase { 
protected final void refreshLoadingViewsSize ( ) { 
final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * 1.2f ) ; 
int pLeft = getPaddingLeft ( ) ; 
int pTop = getPaddingTop ( ) ; 
int pRight = getPaddingRight ( ) ; 
int pBottom = getPaddingBottom ( ) ; 
switch ( getPullToRefreshScrollDirection ( ) ) { 
case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { 
mHeaderLayout . setWidth ( maximumPullScroll ) ; 
pLeft = - maximumPullScroll ; 
} 
else pLeft = 0 ; 
if ( mMode . showFooterLoadingLayout ( ) ) { 
mFooterLayout . setWidth ( maximumPullScroll ) ; 
pRight = - maximumPullScroll ; 
} 
else pRight = 0 ; 
break ; 
case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { 
mHeaderLayout . setHeight ( maximumPullScroll ) ; 
pTop = - maximumPullScroll ; 
} 
else pTop = 0 ; 
if ( mMode . showFooterLoadingLayout ( ) ) { 
mFooterLayout . setHeight ( maximumPullScroll ) ; 
pBottom = - maximumPullScroll ; 
} 
else pBottom = 0 ; 
break ; 
} 
if ( DEBUG ) Log . d ( LOG_TAG , String . format ( "Setting Padding. L: %d, T: %d, R: %d, B: %d" , pLeft , pTop , pRight , pBottom ) ) ; 
setPadding ( pLeft , pTop , pRight , pBottom ) ; 
} 
} 

public class PullToRefreshBase { 
protected void updateUIForMode ( ) { 
final LinearLayout . LayoutParams lp = getLoadingLayoutLayoutParams ( ) ; 
if ( this == mHeaderLayout . getParent ( ) ) removeView ( mHeaderLayout ) ; 
if ( mMode . showHeaderLoadingLayout ( ) ) addViewInternal ( mHeaderLayout , 0 , lp ) ; 
if ( this == mFooterLayout . getParent ( ) ) removeView ( mFooterLayout ) ; 
if ( mMode . showFooterLoadingLayout ( ) ) addViewInternal ( mFooterLayout , lp ) ; 
refreshLoadingViewsSize ( ) ; 
mCurrentMode = ( mMode != Mode . BOTH ) ? mMode : Mode . PULL_FROM_START ; 
} 
} 

public class PullToRefreshBase { 
private void pullEvent ( ) { 
final int newScrollValue ; 
final int itemDimension ; 
final float initialMotionValue , lastMotionValue ; 
switch ( getPullToRefreshScrollDirection ( ) ) { 
case HORIZONTAL : initialMotionValue = mInitialMotionX ; 
lastMotionValue = mLastMotionX ; 
break ; 
case VERTICAL : default : initialMotionValue = mInitialMotionY ; 
lastMotionValue = mLastMotionY ; 
break ; 
} 
switch ( mCurrentMode ) { 
case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; 
itemDimension = getFooterSize ( ) ; 
break ; 
case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; 
itemDimension = getHeaderSize ( ) ; 
break ; 
} 
setHeaderScroll ( newScrollValue ) ; 
if ( newScrollValue != 0 && ! isRefreshing ( ) ) { 
float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; 
switch ( mCurrentMode ) { 
case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; 
break ; 
case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; 
break ; 
} 
if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) setState ( State . PULL_TO_REFRESH ) ; 
else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) setState ( State . RELEASE_TO_REFRESH ) ; 
} 
} 
} 

public class OverscrollHelper { 
public static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { 
final int deltaValue , currentScrollValue , scrollValue ; 
switch ( view . getPullToRefreshScrollDirection ( ) ) { 
case HORIZONTAL : deltaValue = deltaX ; 
scrollValue = scrollX ; 
currentScrollValue = view . getScrollX ( ) ; 
break ; 
case VERTICAL : default : deltaValue = deltaY ; 
scrollValue = scrollY ; 
currentScrollValue = view . getScrollY ( ) ; 
break ; 
} 
if ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { 
final Mode mode = view . getMode ( ) ; 
if ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { 
final int newScrollValue = ( deltaValue + scrollValue ) ; 
if ( PullToRefreshBase . DEBUG ) Log . d ( LOG_TAG , "OverScroll. DeltaX: " + deltaX + ", ScrollX: " + scrollX + ", DeltaY: " + deltaY + ", ScrollY: " + scrollY + ", NewY: " + newScrollValue + ", ScrollRange: " + scrollRange + ", CurrentScroll: " + currentScrollValue ) ; 
if ( newScrollValue < ( 0 - fuzzyThreshold ) ) if ( mode . showHeaderLoadingLayout ( ) ) { 
if ( currentScrollValue == 0 ) view . setState ( State . OVERSCROLLING ) ; 
view . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; 
} 
else if ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) if ( mode . showFooterLoadingLayout ( ) ) { 
if ( currentScrollValue == 0 ) view . setState ( State . OVERSCROLLING ) ; 
view . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; 
} 
else if ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) view . setState ( State . RESET ) ; 
} 
else if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) view . setState ( State . RESET ) ; 
} 
} 
} 

public class RuleBuilder { 
@ SuppressWarnings ( "unchecked" ) public GivenRuleBuilder < T , U > given ( String name , T value ) { 
Rule < T , U > rule = _name . map ( ruleName -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , ruleName ) ) . orElse ( newRule ( ) ) ; 
if ( rule == null ) throw new IllegalStateException ( "No Rule is instantiated; An invalid Rule class may have been provided" ) ; 
return new GivenRuleBuilder < T , U > ( rule , new Fact < T > ( name , value ) ) ; 
} 
} 

public class RuleBuilder { 
@ SuppressWarnings ( "unchecked" ) @ SafeVarargs public final GivenRuleBuilder < T , U > given ( NameValueReferable ... facts ) { 
Rule < T , U > rule = _name . map ( name -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , name ) ) . orElse ( newRule ( ) ) ; 
if ( rule == null ) throw new IllegalStateException ( "No Rule is instantiated; An invalid Rule class may have been provided" ) ; 
return new GivenRuleBuilder < T , U > ( rule , facts ) ; 
} 
} 

public class RuleBuilder { 
@ SuppressWarnings ( "unchecked" ) public ThenRuleBuilder < T , U > then ( Consumer < NameValueReferableTypeConvertibleMap < T > > action ) { 
Rule < T , U > rule = _name . map ( name -> ( Rule < T , U > ) new AuditableRule < T , U > ( newRule ( ) , name ) ) . orElse ( newRule ( ) ) ; 
if ( rule == null ) throw new IllegalStateException ( "No Rule is instantiated; An invalid Rule class may have been provided" ) ; 
return new ThenRuleBuilder < T , U > ( rule , action ) ; 
} 
} 

public class Result { 
public void reset ( ) { 
_lock . readLock ( ) . lock ( ) ; 
try { 
if ( _defaultValue == null ) return ; 
} 
finally { 
_lock . readLock ( ) . unlock ( ) ; 
} 
setValue ( _defaultValue ) ; 
} 
} 

public class AsciiDocParser { 
private String readEmptyLineOrEndTable ( final BufferedReader tableContent ) throws IOException { 
final String column = tableContent . readLine ( ) ; 
if ( column != null && column . startsWith ( END_TABLE ) ) return END_TABLE ; 
if ( column == null || ! column . isEmpty ( ) ) throw new IllegalArgumentException ( String . format ( "Trying to read an empty line for end of row, but content %s was found or EOF" , column ) ) ; 
return "" ; 
} 
} 

public class DefaultServiceEnricher { 
private Service [ ] toArray ( List < Service > services ) { 
if ( services == null ) return new Service [ 0 ] ; 
if ( services instanceof ArrayList ) return ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; 
else { 
Service [ ] ret = new Service [ services . size ( ) ] ; 
for ( int i = 0 ; 
i < services . size ( ) ; 
i ++ ) ret [ i ] = services . get ( i ) ; 
return ret ; 
} 
} 
} 

public class DefaultServiceEnricher { 
private List < String > getPortsFromBuildConfiguration ( ImageConfiguration image ) { 
BuildImageConfiguration buildConfig = image . getBuildConfiguration ( ) ; 
if ( buildConfig == null ) return Collections . emptyList ( ) ; 
return buildConfig . getPorts ( ) ; 
} 
} 

public class DefaultServiceEnricher { 
private List < ServicePort > extractPortsFromConfig ( ) { 
List < ServicePort > ret = new LinkedList < > ( ) ; 
String ports = getConfig ( Config . port ) ; 
if ( ports != null ) for ( String port : StringUtils . split ( ports , "," ) ) { 
ret . add ( parsePortMapping ( port ) ) ; 
} 
return ret ; 
} 
} 

public class DefaultServiceEnricher { 
private ServicePort parsePortMapping ( String port ) { 
Matcher matcher = PORT_MAPPING_PATTERN . matcher ( port ) ; 
if ( ! matcher . matches ( ) ) { 
log . error ( "Invalid 'port' configuration '%s'. Must match <port>(:<targetPort>)?,<port2>?,..." , port ) ; 
throw new IllegalArgumentException ( "Invalid port mapping specification " + port ) ; 
} 
int servicePort = Integer . parseInt ( matcher . group ( "port" ) ) ; 
String optionalTargetPort = matcher . group ( "targetPort" ) ; 
String protocol = getProtocol ( matcher . group ( "protocol" ) ) ; 
ServicePortBuilder builder = new ServicePortBuilder ( ) . withPort ( servicePort ) . withProtocol ( protocol ) . withName ( getDefaultPortName ( servicePort , protocol ) ) ; 
if ( optionalTargetPort != null ) builder . withNewTargetPort ( Integer . parseInt ( optionalTargetPort ) ) ; 
return builder . build ( ) ; 
} 
} 

public class DefaultServiceEnricher { 
private void addPortIfNotNull ( List < ServicePort > ret , ServicePort port ) { 
if ( port != null ) ret . add ( port ) ; 
} 
} 

public class DefaultServiceEnricher { 
private ServicePort shiftOrNull ( List < ServicePort > ports ) { 
if ( ! ports . isEmpty ( ) ) return ports . remove ( 0 ) ; 
return null ; 
} 
} 

public class ServiceUrlUtil { 
private static boolean portsMatch ( ServicePort servicePort , IntOrString intOrString ) { 
if ( intOrString != null ) { 
Integer port = servicePort . getPort ( ) ; 
Integer intVal = intOrString . getIntVal ( ) ; 
String strVal = intOrString . getStrVal ( ) ; 
if ( intVal != null ) if ( port != null ) return port . intValue ( ) == intVal . intValue ( ) ; 
else { 
} 
else if ( strVal != null ) return Objects . equal ( strVal , servicePort . getName ( ) ) ; 
} 
return false ; 
} 
} 

public class MapUtil { 
public static void putIfAbsent ( Map < String , String > map , String name , String value ) { 
if ( ! map . containsKey ( name ) ) map . put ( name , value ) ; 
} 
} 

public class MapUtil { 
public static < K , V > Map < K , V > mergeMaps ( Map < K , V > map1 , Map < K , V > map2 ) { 
Map < K , V > answer = new HashMap < > ( ) ; 
if ( map2 != null ) answer . putAll ( map2 ) ; 
if ( map1 != null ) answer . putAll ( map1 ) ; 
return answer ; 
} 
} 

public class MapUtil { 
public static void putAllIfNotNull ( Map < String , String > ret , Map < String , String > toPut ) { 
if ( toPut != null ) ret . putAll ( toPut ) ; 
} 
} 

public class OpenshiftBuildService { 
private void waitUntilPodIsReady ( String podName , int nAwaitTimeout , final Logger log ) throws InterruptedException { 
final CountDownLatch readyLatch = new CountDownLatch ( 1 ) ; 
try ( Watch watch = client . pods ( ) . withName ( podName ) . watch ( new Watcher < Pod > ( ) { 
@ Override public void eventReceived ( Action action , Pod aPod ) { 
if ( KubernetesHelper . isPodReady ( aPod ) ) readyLatch . countDown ( ) ; 
} 
@ Override public void onClose ( KubernetesClientException e ) { 
} 
} 
) ) { 
readyLatch . await ( nAwaitTimeout , TimeUnit . SECONDS ) ; 
} 
catch ( KubernetesClientException | InterruptedException e ) { 
log . error ( "Could not watch pod" , e ) ; 
} 
} 
} 

public class KubernetesHelper { 
public static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { 
if ( StringUtils . isBlank ( currentValue ) ) throw new IllegalArgumentException ( "No " + description + " is specified!" ) ; 
int size = currentValue . length ( ) ; 
for ( int i = 0 ; 
i < size ; 
i ++ ) { 
char ch = currentValue . charAt ( i ) ; 
if ( Character . isUpperCase ( ch ) ) throw new IllegalArgumentException ( "Invalid upper case letter '" + ch + "' at index " + i + " for " + description + " value: " + currentValue ) ; 
} 
return currentValue ; 
} 
} 

public class KubernetesHelper { 
@ SuppressWarnings ( "unchecked" ) public static List < HasMetadata > toItemList ( Object entity ) throws IOException { 
if ( entity instanceof List ) return ( List < HasMetadata > ) entity ; 
else if ( entity instanceof HasMetadata [ ] ) { 
HasMetadata [ ] array = ( HasMetadata [ ] ) entity ; 
return Arrays . asList ( array ) ; 
} 
else if ( entity instanceof KubernetesList ) { 
KubernetesList config = ( KubernetesList ) entity ; 
return config . getItems ( ) ; 
} 
else if ( entity instanceof Template ) { 
Template objects = ( Template ) entity ; 
return objects . getObjects ( ) ; 
} 
else { 
List < HasMetadata > answer = new ArrayList < > ( ) ; 
if ( entity instanceof HasMetadata ) answer . add ( ( HasMetadata ) entity ) ; 
return answer ; 
} 
} 
} 

public class KubernetesHelper { 
public static String getResourceVersion ( HasMetadata entity ) { 
if ( entity != null ) { 
ObjectMeta metadata = entity . getMetadata ( ) ; 
if ( metadata != null ) { 
String resourceVersion = metadata . getResourceVersion ( ) ; 
if ( StringUtils . isNotBlank ( resourceVersion ) ) return resourceVersion ; 
} 
} 
return null ; 
} 
} 

public class KubernetesHelper { 
public static boolean isPodReady ( Pod pod ) { 
if ( ! isPodRunning ( pod ) ) return false ; 
PodStatus podStatus = pod . getStatus ( ) ; 
if ( podStatus == null ) return true ; 
List < PodCondition > conditions = podStatus . getConditions ( ) ; 
if ( conditions == null || conditions . isEmpty ( ) ) return true ; 
for ( PodCondition condition : conditions ) { 
if ( "ready" . equalsIgnoreCase ( condition . getType ( ) ) ) return Boolean . parseBoolean ( condition . getStatus ( ) ) ; 
} 
return true ; 
} 
} 

public class KubernetesHelper { 
private static Context getCurrentContext ( Config config ) { 
String contextName = config . getCurrentContext ( ) ; 
if ( contextName != null ) { 
List < NamedContext > contexts = config . getContexts ( ) ; 
if ( contexts != null ) for ( NamedContext context : contexts ) { 
if ( Objects . equals ( contextName , context . getName ( ) ) ) return context . getContext ( ) ; 
} 
} 
return null ; 
} 
} 

public class RouteEnricher { 
private boolean hasRoute ( final KubernetesListBuilder listBuilder , final String name ) { 
final AtomicBoolean answer = new AtomicBoolean ( false ) ; 
listBuilder . accept ( new TypedVisitor < RouteBuilder > ( ) { 
@ Override public void visit ( RouteBuilder builder ) { 
ObjectMeta metadata = builder . getMetadata ( ) ; 
if ( metadata != null && name . equals ( metadata . getName ( ) ) ) answer . set ( true ) ; 
} 
} 
) ; 
return answer . get ( ) ; 
} 
} 

public class MavenUtil { 
public static boolean hasResource ( MavenProject project , String ... paths ) { 
URLClassLoader compileClassLoader = getCompileClassLoader ( project ) ; 
for ( String path : paths ) { 
try { 
if ( compileClassLoader . getResource ( path ) != null ) return true ; 
} 
catch ( Throwable e ) { 
} 
} 
return false ; 
} 
} 

public class KubernetesResourceUtil { 
private static Map < String , Object > readAndEnrichFragment ( PlatformMode platformMode , ResourceVersioning apiVersions , File file , String appName ) throws IOException { 
Pattern pattern = Pattern . compile ( FILENAME_PATTERN , Pattern . CASE_INSENSITIVE ) ; 
Matcher matcher = pattern . matcher ( file . getName ( ) ) ; 
if ( ! matcher . matches ( ) ) throw new IllegalArgumentException ( String . format ( "Resource file name '%s' does not match pattern <name>-<type>.(yaml|yml|json)" , file . getName ( ) ) ) ; 
String name = matcher . group ( "name" ) ; 
String type = matcher . group ( "type" ) ; 
String ext = matcher . group ( "ext" ) . toLowerCase ( ) ; 
String kind ; 
Map < String , Object > fragment = readFragment ( file , ext ) ; 
if ( type != null ) kind = getAndValidateKindFromType ( file , type ) ; 
else { 
kind = FILENAME_TO_KIND_MAPPER . get ( name . toLowerCase ( ) ) ; 
if ( kind != null ) name = null ; 
} 
addKind ( fragment , kind , file . getName ( ) ) ; 
String apiVersion = apiVersions . getCoreVersion ( ) ; 
if ( Objects . equals ( kind , "Ingress" ) ) apiVersion = apiVersions . getExtensionsVersion ( ) ; 
else if ( Objects . equals ( kind , "StatefulSet" ) || Objects . equals ( kind , "Deployment" ) ) apiVersion = apiVersions . getAppsVersion ( ) ; 
else if ( Objects . equals ( kind , "Job" ) ) apiVersion = apiVersions . getJobVersion ( ) ; 
else if ( Objects . equals ( kind , "DeploymentConfig" ) && platformMode == PlatformMode . openshift ) apiVersion = apiVersions . getOpenshiftV1version ( ) ; 
addIfNotExistent ( fragment , "apiVersion" , apiVersion ) ; 
Map < String , Object > metaMap = getMetadata ( fragment ) ; 
addIfNotExistent ( metaMap , "name" , StringUtils . isNotBlank ( name ) ? name : appName ) ; 
return fragment ; 
} 
} 

public class KubernetesResourceUtil { 
public static HasMetadata mergeResources ( HasMetadata item1 , HasMetadata item2 , Logger log , boolean switchOnLocalCustomisation ) { 
if ( item1 instanceof Deployment && item2 instanceof Deployment ) return mergeDeployments ( ( Deployment ) item1 , ( Deployment ) item2 , log , switchOnLocalCustomisation ) ; 
if ( item1 instanceof ConfigMap && item2 instanceof ConfigMap ) { 
ConfigMap cm1 = ( ConfigMap ) item1 ; 
ConfigMap cm2 = ( ConfigMap ) item2 ; 
return mergeConfigMaps ( cm1 , cm2 , log , switchOnLocalCustomisation ) ; 
} 
mergeMetadata ( item1 , item2 ) ; 
return item1 ; 
} 
} 

public class KubernetesResourceUtil { 
private static boolean isLocalCustomisation ( PodSpec podSpec ) { 
List < Container > containers = podSpec . getContainers ( ) != null ? podSpec . getContainers ( ) : Collections . < Container > emptyList ( ) ; 
for ( Container container : containers ) { 
if ( StringUtils . isNotBlank ( container . getImage ( ) ) ) return false ; 
} 
return true ; 
} 
} 

public class AbstractPortsExtractor { 
private Map < String , String > readConfig ( File f ) throws IOException { 
Map < String , String > map ; 
if ( f . getName ( ) . endsWith ( JSON_EXTENSION ) ) map = flatten ( JSON_MAPPER . readValue ( f , Map . class ) ) ; 
else if ( f . getName ( ) . endsWith ( YAML_EXTENSION ) || f . getName ( ) . endsWith ( YML_EXTENSION ) ) map = flatten ( YAML_MAPPER . readValue ( f , Map . class ) ) ; 
else if ( f . getName ( ) . endsWith ( PROPERTIES_EXTENSION ) ) { 
Properties properties = new Properties ( ) ; 
properties . load ( new FileInputStream ( f ) ) ; 
map = propertiesToMap ( properties ) ; 
} 
else throw new IllegalArgumentException ( "Can't read configuration from: [" + f . getName ( ) + "]. Unknown file extension." ) ; 
return map ; 
} 
} 

public class AbstractPortsExtractor { 
private void addPortIfValid ( Map < String , Integer > map , String key , String port ) { 
if ( StringUtils . isNotBlank ( port ) ) { 
String t = port . trim ( ) ; 
if ( t . matches ( NUMBER_REGEX ) ) map . put ( key , Integer . parseInt ( t ) ) ; 
} 
} 
} 

public class MavenEnricherContext { 
public String getDockerJsonConfigString ( final Settings settings , final String serverId ) { 
Server server = getServer ( settings , serverId ) ; 
if ( server == null ) return "" ; 
JsonObject auth = new JsonObject ( ) ; 
auth . add ( "username" , new JsonPrimitive ( server . getUsername ( ) ) ) ; 
auth . add ( "password" , new JsonPrimitive ( server . getPassword ( ) ) ) ; 
String mail = getConfigurationValue ( server , "email" ) ; 
if ( ! StringUtils . isBlank ( mail ) ) auth . add ( "email" , new JsonPrimitive ( mail ) ) ; 
JsonObject json = new JsonObject ( ) ; 
json . add ( serverId , auth ) ; 
return json . toString ( ) ; 
} 
} 

public class VersionUtil { 
public static int compareVersions ( String v1 , String v2 ) { 
String [ ] components1 = split ( v1 ) ; 
String [ ] components2 = split ( v2 ) ; 
int diff ; 
int length = Math . min ( components1 . length , components2 . length ) ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) { 
String s1 = components1 [ i ] ; 
String s2 = components2 [ i ] ; 
Integer i1 = tryParseInteger ( s1 ) ; 
Integer i2 = tryParseInteger ( s2 ) ; 
if ( i1 != null && i2 != null ) diff = i1 . compareTo ( i2 ) ; 
else diff = s1 . compareTo ( s2 ) ; 
if ( diff != 0 ) return diff ; 
} 
diff = Integer . compare ( components1 . length , components2 . length ) ; 
if ( diff == 0 ) { 
if ( v1 == v2 ) return 0 ; 
; 
return v1 != null ? v1 . compareTo ( v2 ) : - 1 ; 
} 
return diff ; 
} 
} 

public class ProfileUtil { 
public static List < Profile > readAllFromClasspath ( String name , String ext ) throws IOException { 
List < Profile > ret = new ArrayList < > ( ) ; 
for ( String location : getMetaInfProfilePaths ( ext ) ) { 
for ( String url : ClassUtil . getResources ( location ) ) { 
for ( Profile profile : fromYaml ( new URL ( url ) . openStream ( ) ) ) { 
if ( name . equals ( profile . getName ( ) ) ) ret . add ( profile ) ; 
} 
} 
} 
return ret ; 
} 
} 

public class ProfileUtil { 
private static File findProfileYaml ( File directory ) { 
for ( String profileFile : PROFILE_FILENAMES ) { 
File ret = new File ( directory , String . format ( profileFile , "" ) ) ; 
if ( ret . exists ( ) ) return ret ; 
} 
return null ; 
} 
} 

public class DefaultControllerEnricher { 
private String getImagePullPolicy ( ResourceConfig resourceConfig , String defaultValue ) { 
if ( resourceConfig != null ) return resourceConfig . getImagePullPolicy ( ) != null ? resourceConfig . getImagePullPolicy ( ) : defaultValue ; 
return defaultValue ; 
} 
} 

public class BaseEnricher { 
protected boolean isOpenShiftMode ( ) { 
Properties properties = getContext ( ) . getConfiguration ( ) . getProperties ( ) ; 
if ( properties != null ) return RuntimeMode . isOpenShiftMode ( properties ) ; 
return false ; 
} 
} 

public class BaseEnricher { 
protected int getReplicaCount ( KubernetesListBuilder builder , ResourceConfig xmlResourceConfig , int defaultValue ) { 
if ( xmlResourceConfig != null ) { 
List < HasMetadata > items = builder . buildItems ( ) ; 
for ( HasMetadata item : items ) { 
if ( item instanceof Deployment ) if ( ( ( Deployment ) item ) . getSpec ( ) . getReplicas ( ) != null ) return ( ( Deployment ) item ) . getSpec ( ) . getReplicas ( ) ; 
if ( item instanceof DeploymentConfig ) if ( ( ( DeploymentConfig ) item ) . getSpec ( ) . getReplicas ( ) != null ) return ( ( DeploymentConfig ) item ) . getSpec ( ) . getReplicas ( ) ; 
} 
return xmlResourceConfig . getReplicas ( ) > 0 ? xmlResourceConfig . getReplicas ( ) : defaultValue ; 
} 
return defaultValue ; 
} 
} 

public class XmlUtils { 
public static Element firstChild ( Element element , String name ) { 
NodeList nodes = element . getChildNodes ( ) ; 
if ( nodes != null ) for ( int i = 0 , size = nodes . getLength ( ) ; 
i < size ; 
i ++ ) { 
Node item = nodes . item ( i ) ; 
if ( item instanceof Element ) { 
Element childElement = ( Element ) item ; 
if ( name . equals ( childElement . getTagName ( ) ) ) return childElement ; 
} 
} 
return null ; 
} 
} 

public class ApplyService { 
public void installTemplate ( Template entity , String sourceName ) { 
OpenShiftClient openShiftClient = getOpenShiftClient ( ) ; 
if ( openShiftClient == null ) return ; 
if ( ! isProcessTemplatesLocally ( ) ) { 
String namespace = getNamespace ( ) ; 
String id = getName ( entity ) ; 
Objects . requireNonNull ( id , "No name for " + entity + " " + sourceName ) ; 
Template old = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; 
if ( isRunning ( old ) ) if ( UserConfigurationCompare . configEqual ( entity , old ) ) log . info ( "Template has not changed so not doing anything" ) ; 
else { 
boolean recreateMode = isRecreateMode ( ) ; 
recreateMode = true ; 
if ( recreateMode ) { 
openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . delete ( ) ; 
doCreateTemplate ( entity , namespace , sourceName ) ; 
} 
else { 
log . info ( "Updating a Template from " + sourceName ) ; 
try { 
Object answer = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . replace ( entity ) ; 
log . info ( "Updated Template: " + answer ) ; 
} 
catch ( Exception e ) { 
onApplyError ( "Failed to update Template from " + sourceName + ". " + e + ". " + entity , e ) ; 
} 
} 
} 
else if ( ! isAllowCreate ( ) ) log . warn ( "Creation disabled so not creating a Template from " + sourceName + " namespace " + namespace + " name " + getName ( entity ) ) ; 
else doCreateTemplate ( entity , namespace , sourceName ) ; 
} 
} 
} 

public class ApplyService { 
private int removeTagByName ( List < TagReference > tags , String tagName ) { 
List < TagReference > removeTags = new ArrayList < > ( ) ; 
for ( TagReference tag : tags ) { 
if ( Objects . equals ( tagName , tag . getName ( ) ) ) removeTags . add ( tag ) ; 
} 
tags . removeAll ( removeTags ) ; 
return removeTags . size ( ) ; 
} 
} 

public class ApplyService { 
public boolean applyNamespace ( Namespace entity ) { 
String namespace = getOrCreateMetadata ( entity ) . getName ( ) ; 
log . info ( "Using namespace: " + namespace ) ; 
String name = getName ( entity ) ; 
Objects . requireNonNull ( name , "No name for " + entity ) ; 
Namespace old = kubernetesClient . namespaces ( ) . withName ( name ) . get ( ) ; 
if ( ! isRunning ( old ) ) try { 
Object answer = kubernetesClient . namespaces ( ) . create ( entity ) ; 
logGeneratedEntity ( "Created namespace: " , namespace , entity , answer ) ; 
return true ; 
} 
catch ( Exception e ) { 
onApplyError ( "Failed to create namespace: " + name + " due " + e . getMessage ( ) , e ) ; 
} 
return false ; 
} 
} 

public class ApplyService { 
public boolean applyProjectRequest ( ProjectRequest entity ) { 
String namespace = getOrCreateMetadata ( entity ) . getName ( ) ; 
log . info ( "Using project: " + namespace ) ; 
String name = getName ( entity ) ; 
Objects . requireNonNull ( name , "No name for " + entity ) ; 
OpenShiftClient openshiftClient = getOpenShiftClient ( ) ; 
if ( openshiftClient == null ) { 
log . warn ( "Cannot check for Project " + namespace + " as not running against OpenShift!" ) ; 
return false ; 
} 
boolean exists = checkNamespace ( name ) ; 
if ( ! exists ) try { 
Object answer = openshiftClient . projectrequests ( ) . create ( entity ) ; 
logGeneratedEntity ( "Created ProjectRequest: " , namespace , entity , answer ) ; 
return true ; 
} 
catch ( Exception e ) { 
onApplyError ( "Failed to create ProjectRequest: " + name + " due " + e . getMessage ( ) , e ) ; 
} 
return false ; 
} 
} 

public class ApplyService { 
protected String getNamespace ( HasMetadata entity ) { 
String answer = KubernetesHelper . getNamespace ( entity ) ; 
if ( StringUtils . isBlank ( answer ) ) answer = getNamespace ( ) ; 
applyNamespace ( answer ) ; 
return answer ; 
} 
} 

public class DefaultNamespaceEnricher { 
@ Override public void create ( PlatformMode platformMode , KubernetesListBuilder builder ) { 
final String name = config . getNamespace ( ) ; 
if ( name == null || name . isEmpty ( ) ) return ; 
if ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { 
String type = getConfig ( Config . type ) ; 
if ( "project" . equalsIgnoreCase ( type ) || "namespace" . equalsIgnoreCase ( type ) ) if ( platformMode == PlatformMode . kubernetes ) { 
log . info ( "Adding a default Namespace:" + config . getNamespace ( ) ) ; 
Namespace namespace = handlerHub . getNamespaceHandler ( ) . getNamespace ( config . getNamespace ( ) ) ; 
builder . addToNamespaceItems ( namespace ) ; 
} 
else { 
log . info ( "Adding a default Project" + config . getNamespace ( ) ) ; 
Project project = handlerHub . getProjectHandler ( ) . getProject ( config . getNamespace ( ) ) ; 
builder . addToProjectItems ( project ) ; 
} 
} 
} 
} 

public class DefaultNamespaceEnricher { 
@ Override public void enrich ( PlatformMode platformMode , KubernetesListBuilder builder ) { 
builder . accept ( new TypedVisitor < ObjectMetaBuilder > ( ) { 
private String getNamespaceName ( ) { 
String name = null ; 
if ( config . getNamespace ( ) != null && ! config . getNamespace ( ) . isEmpty ( ) ) name = config . getNamespace ( ) ; 
name = builder . getItems ( ) . stream ( ) . filter ( item -> Arrays . asList ( NAMESPACE_KINDS ) . contains ( item . getKind ( ) ) ) . findFirst ( ) . get ( ) . getMetadata ( ) . getName ( ) ; 
return name ; 
} 
@ Override public void visit ( ObjectMetaBuilder metaBuilder ) { 
if ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) return ; 
String name = getNamespaceName ( ) ; 
if ( name == null || name . isEmpty ( ) ) return ; 
metaBuilder . withNamespace ( name ) . build ( ) ; 
} 
} 
) ; 
builder . accept ( new TypedVisitor < NamespaceBuilder > ( ) { 
@ Override public void visit ( NamespaceBuilder builder ) { 
builder . withNewStatus ( "active" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; 
} 
} 
) ; 
builder . accept ( new TypedVisitor < ProjectBuilder > ( ) { 
@ Override public void visit ( ProjectBuilder builder ) { 
builder . withNewStatus ( "active" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; 
} 
} 
) ; 
} 
} 

public class JavaExecGenerator { 
protected Map < String , String > getEnv ( boolean prePackagePhase ) throws MojoExecutionException { 
Map < String , String > ret = new HashMap < > ( ) ; 
if ( ! isFatJar ( ) ) { 
String mainClass = getConfig ( Config . mainClass ) ; 
if ( mainClass == null ) { 
mainClass = mainClassDetector . getMainClass ( ) ; 
if ( mainClass == null ) if ( ! prePackagePhase ) throw new MojoExecutionException ( "Cannot extract main class to startup" ) ; 
} 
if ( mainClass != null ) { 
log . verbose ( "Detected main class %s" , mainClass ) ; 
ret . put ( JAVA_MAIN_CLASS_ENV_VAR , mainClass ) ; 
} 
} 
List < String > javaOptions = getExtraJavaOptions ( ) ; 
if ( javaOptions . size ( ) > 0 ) ret . put ( JAVA_OPTIONS , StringUtils . join ( javaOptions . iterator ( ) , " " ) ) ; 
return ret ; 
} 
} 

public class GoTimeUtil { 
public static Integer durationSeconds ( String duration ) { 
BigDecimal ns = durationNs ( duration ) ; 
if ( ns == null ) return null ; 
BigDecimal sec = ns . divide ( new BigDecimal ( 1_000_000_000 ) ) ; 
if ( sec . compareTo ( new BigDecimal ( Integer . MAX_VALUE ) ) > 0 ) throw new IllegalArgumentException ( "Integer Overflow" ) ; 
return sec . intValue ( ) ; 
} 
} 

public class GoTimeUtil { 
public static BigDecimal durationNs ( String durationP ) { 
if ( durationP == null ) return null ; 
String duration = durationP . trim ( ) ; 
if ( duration . length ( ) == 0 ) return null ; 
int unitPos = 1 ; 
while ( unitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) unitPos ++ ; 
if ( unitPos >= duration . length ( ) ) throw new IllegalArgumentException ( "Time unit not found in string: " + duration ) ; 
String tail = duration . substring ( unitPos ) ; 
Long multiplier = null ; 
Integer unitEnd = null ; 
for ( int i = 0 ; 
i < TIME_UNITS . length ; 
i ++ ) if ( tail . startsWith ( TIME_UNITS [ i ] ) ) { 
multiplier = UNIT_MULTIPLIERS [ i ] ; 
unitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; 
break ; 
} 
if ( multiplier == null ) throw new IllegalArgumentException ( "Unknown time unit in string: " + duration ) ; 
BigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; 
value = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; 
String remaining = duration . substring ( unitEnd ) ; 
BigDecimal remainingValue = durationNs ( remaining ) ; 
if ( remainingValue != null ) value = value . add ( remainingValue ) ; 
return value ; 
} 
} 

public class AbstractAppServerHandler { 
protected String [ ] scanFiles ( String ... patterns ) { 
String buildOutputDir = project . getBuild ( ) . getDirectory ( ) ; 
if ( buildOutputDir != null && new File ( buildOutputDir ) . exists ( ) ) { 
DirectoryScanner directoryScanner = new DirectoryScanner ( ) ; 
directoryScanner . setBasedir ( buildOutputDir ) ; 
directoryScanner . setIncludes ( patterns ) ; 
directoryScanner . scan ( ) ; 
return directoryScanner . getIncludedFiles ( ) ; 
} 
else return new String [ 0 ] ; 
} 
} 

public class ApplyMojo { 
private boolean serviceHasIngressRule ( List < Ingress > ingresses , Service service ) { 
String serviceName = KubernetesHelper . getName ( service ) ; 
for ( Ingress ingress : ingresses ) { 
IngressSpec spec = ingress . getSpec ( ) ; 
if ( spec == null ) break ; 
List < IngressRule > rules = spec . getRules ( ) ; 
if ( rules == null ) break ; 
for ( IngressRule rule : rules ) { 
HTTPIngressRuleValue http = rule . getHttp ( ) ; 
if ( http == null ) break ; 
List < HTTPIngressPath > paths = http . getPaths ( ) ; 
if ( paths == null ) break ; 
for ( HTTPIngressPath path : paths ) { 
IngressBackend backend = path . getBackend ( ) ; 
if ( backend == null ) break ; 
if ( Objects . equals ( serviceName , backend . getServiceName ( ) ) ) return true ; 
} 
} 
} 
return false ; 
} 
} 

public class IconEnricher { 
private String getDefaultIconRef ( ) { 
ProjectClassLoaders cls = getContext ( ) . getProjectClassLoaders ( ) ; 
if ( cls . isClassInCompileClasspath ( false , "io.fabric8.funktion.runtime.Main" ) || getContext ( ) . hasDependency ( "io.fabric8.funktion" , null ) ) return "funktion" ; 
if ( cls . isClassInCompileClasspath ( false , "org.apache.camel.CamelContext" ) ) return "camel" ; 
if ( getContext ( ) . hasPlugin ( null , SpringBootConfigurationHelper . SPRING_BOOT_MAVEN_PLUGIN_ARTIFACT_ID ) || cls . isClassInCompileClasspath ( false , "org.springframework.boot.SpringApplication" ) ) return "spring-boot" ; 
if ( cls . isClassInCompileClasspath ( false , "org.springframework.core.Constants" ) ) return "spring" ; 
if ( cls . isClassInCompileClasspath ( false , "org.vertx.java.core.Handler" , "io.vertx.core.Handler" ) ) return "vertx" ; 
if ( getContext ( ) . hasPlugin ( "org.wildfly.swarm" , "wildfly-swarm-plugin" ) || getContext ( ) . hasDependency ( "org.wildfly.swarm" , null ) ) return "wildfly-swarm" ; 
if ( getContext ( ) . hasPlugin ( "io.thorntail" , "thorntail-maven-plugin" ) || getContext ( ) . hasDependency ( "io.thorntail" , null ) ) return "wildfly-swarm" ; 
return null ; 
} 
} 

public class IconEnricher { 
private void copyAppConfigFiles ( File appBuildDir , File appConfigDir ) throws IOException { 
File [ ] files = appConfigDir . listFiles ( ) ; 
if ( files != null ) { 
appBuildDir . mkdirs ( ) ; 
for ( File file : files ) { 
File outFile = new File ( appBuildDir , file . getName ( ) ) ; 
if ( file . isDirectory ( ) ) copyAppConfigFiles ( outFile , file ) ; 
else Files . copy ( file , outFile ) ; 
} 
} 
} 
} 

public class SpringBootUtil { 
protected static Properties getPropertiesResource ( URL resource ) { 
Properties answer = new Properties ( ) ; 
if ( resource != null ) try ( InputStream stream = resource . openStream ( ) ) { 
answer . load ( stream ) ; 
} 
catch ( IOException e ) { 
throw new IllegalStateException ( "Error while reading resource from URL " + resource , e ) ; 
} 
return answer ; 
} 
} 

public class ResourceMojo { 
protected static Template getSingletonTemplate ( KubernetesList resources ) { 
if ( resources != null ) { 
List < HasMetadata > items = resources . getItems ( ) ; 
if ( items != null && items . size ( ) == 1 ) { 
HasMetadata singleEntity = items . get ( 0 ) ; 
if ( singleEntity instanceof Template ) return ( Template ) singleEntity ; 
} 
} 
return null ; 
} 
} 

public class ResourceMojo { 
private Date getBuildReferenceDate ( ) throws MojoExecutionException { 
File tsFile = new File ( project . getBuild ( ) . getDirectory ( ) , AbstractDockerMojo . DOCKER_BUILD_TIMESTAMP ) ; 
if ( ! tsFile . exists ( ) ) return new Date ( ) ; 
try { 
return EnvUtil . loadTimestamp ( tsFile ) ; 
} 
catch ( IOException e ) { 
throw new MojoExecutionException ( "Cannot read timestamp from " + tsFile , e ) ; 
} 
} 
} 

public class BaseGenerator { 
protected void addFrom ( BuildImageConfiguration . Builder builder ) { 
String fromMode = getConfigWithFallback ( Config . fromMode , "fabric8.generator.fromMode" , getFromModeDefault ( context . getRuntimeMode ( ) ) ) ; 
String from = getConfigWithFallback ( Config . from , "fabric8.generator.from" , null ) ; 
if ( "docker" . equalsIgnoreCase ( fromMode ) ) { 
String fromImage = from ; 
if ( fromImage == null ) fromImage = fromSelector != null ? fromSelector . getFrom ( ) : null ; 
builder . from ( fromImage ) ; 
log . info ( "Using Docker image %s as base / builder" , fromImage ) ; 
} 
else if ( "istag" . equalsIgnoreCase ( fromMode ) ) { 
Map < String , String > fromExt = new HashMap < > ( ) ; 
if ( from != null ) { 
ImageName iName = new ImageName ( from ) ; 
String tag = iName . getTag ( ) ; 
if ( StringUtils . isBlank ( tag ) ) tag = "latest" ; 
fromExt . put ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) , iName . getSimpleName ( ) + ":" + tag ) ; 
if ( iName . getUser ( ) != null ) fromExt . put ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) , iName . getUser ( ) ) ; 
fromExt . put ( OpenShiftBuildStrategy . SourceStrategy . kind . key ( ) , "ImageStreamTag" ) ; 
} 
else fromExt = fromSelector != null ? fromSelector . getImageStreamTagFromExt ( ) : null ; 
if ( fromExt != null ) { 
String namespace = fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) ) ; 
if ( namespace != null ) log . info ( "Using ImageStreamTag '%s' from namespace '%s' as builder image" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) , namespace ) ; 
else log . info ( "Using ImageStreamTag '%s' as builder image" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) ) ; 
builder . fromExt ( fromExt ) ; 
} 
} 
else throw new IllegalArgumentException ( String . format ( "Invalid 'fromMode' in generator configuration for '%s'" , getName ( ) ) ) ; 
} 
} 

public class BaseGenerator { 
private String getFromModeDefault ( RuntimeMode mode ) { 
if ( mode == RuntimeMode . openshift && fromSelector != null && fromSelector . isRedHat ( ) ) return "istag" ; 
else return "docker" ; 
} 
} 

public class BaseGenerator { 
protected String getImageName ( ) { 
if ( RuntimeMode . isOpenShiftMode ( getProject ( ) . getProperties ( ) ) ) return getConfigWithFallback ( Config . name , "fabric8.generator.name" , "%a:%l" ) ; 
else return getConfigWithFallback ( Config . name , "fabric8.generator.name" , "%g/%a:%l" ) ; 
} 
} 

public class BaseGenerator { 
protected String getRegistry ( ) { 
if ( ! RuntimeMode . isOpenShiftMode ( getProject ( ) . getProperties ( ) ) ) return getConfigWithFallback ( Config . registry , "fabric8.generator.registry" , null ) ; 
return null ; 
} 
} 

public class AbstractLiveEnricher { 
boolean isOnline ( ) { 
String isOnline = getConfig ( Config . online ) ; 
if ( isOnline != null ) return Configs . asBoolean ( isOnline ) ; 
Boolean ret = asBooleanFromGlobalProp ( "fabric8.online" ) ; 
return ret != null ? ret : getDefaultOnline ( ) ; 
} 
} 

public class AbstractLiveEnricher { 
protected String getExternalServiceURL ( String serviceName , String protocol ) { 
if ( ! isOnline ( ) ) { 
getLog ( ) . info ( "Not looking for service " + serviceName + " as we are in offline mode" ) ; 
return null ; 
} 
else try { 
KubernetesClient kubernetes = getKubernetes ( ) ; 
String ns = kubernetes . getNamespace ( ) ; 
if ( StringUtils . isBlank ( ns ) ) ns = getNamespace ( ) ; 
Service service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; 
return service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; 
} 
catch ( Throwable e ) { 
Throwable cause = e ; 
boolean notFound = false ; 
boolean connectError = false ; 
Stack < Throwable > stack = unfoldExceptions ( e ) ; 
while ( ! stack . isEmpty ( ) ) { 
Throwable t = stack . pop ( ) ; 
if ( t instanceof ConnectException || "No route to host" . equals ( t . getMessage ( ) ) ) { 
getLog ( ) . warn ( "Cannot connect to Kubernetes to find URL for service %s : %s" , serviceName , cause . getMessage ( ) ) ; 
return null ; 
} 
else if ( t instanceof IllegalArgumentException || t . getMessage ( ) != null && t . getMessage ( ) . matches ( "^No.*found.*$" ) ) { 
getLog ( ) . warn ( "%s" , cause . getMessage ( ) ) ; 
return null ; 
} 
; 
} 
getLog ( ) . warn ( "Cannot find URL for service %s : %s" , serviceName , cause . getMessage ( ) ) ; 
return null ; 
} 
} 
} 

public class AbstractLiveEnricher { 
protected Boolean asBooleanFromGlobalProp ( String prop ) { 
String value = getContext ( ) . getConfiguration ( ) . getProperty ( prop ) ; 
if ( value == null ) value = System . getProperty ( prop ) ; 
return value != null ? Boolean . valueOf ( value ) : null ; 
} 
} 

public class ElasticsearchJestAutoConfiguration { 
private JestClient createJestClient ( String uri ) { 
HttpClientConfig . Builder builder = new HttpClientConfig . Builder ( uri ) . maxTotalConnection ( properties . getMaxTotalConnection ( ) ) . defaultMaxTotalConnectionPerRoute ( properties . getDefaultMaxTotalConnectionPerRoute ( ) ) . maxConnectionIdleTime ( properties . getMaxConnectionIdleTime ( ) , TimeUnit . MILLISECONDS ) . readTimeout ( properties . getReadTimeout ( ) ) . multiThreaded ( properties . getMultiThreaded ( ) ) ; 
if ( StringUtils . hasText ( this . properties . getUsername ( ) ) ) builder . defaultCredentials ( this . properties . getUsername ( ) , this . properties . getPassword ( ) ) ; 
String proxyHost = this . properties . getProxy ( ) . getHost ( ) ; 
if ( StringUtils . hasText ( proxyHost ) ) { 
Integer proxyPort = this . properties . getProxy ( ) . getPort ( ) ; 
Assert . notNull ( proxyPort , "Proxy port must not be null" ) ; 
builder . proxy ( new HttpHost ( proxyHost , proxyPort ) ) ; 
} 
List < HttpClientConfigBuilderCustomizer > configBuilderCustomizers = builderCustomizers != null ? builderCustomizers . getIfAvailable ( ) : new ArrayList < > ( ) ; 
if ( ! CollectionUtils . isEmpty ( configBuilderCustomizers ) ) { 
logger . info ( "Custom HttpClientConfigBuilderCustomizers detected. Applying these to the HttpClientConfig builder." ) ; 
configBuilderCustomizers . stream ( ) . forEach ( customizer -> customizer . customize ( builder ) ) ; 
logger . info ( "Custom HttpClientConfigBuilderCustomizers applied." ) ; 
} 
JestClientFactory factory = jestClientFactory != null ? jestClientFactory : new JestClientFactory ( ) ; 
factory . setHttpClientConfig ( builder . build ( ) ) ; 
return factory . getObject ( ) ; 
} 
} 

public class ElasticsearchJestAutoConfiguration { 
private int createInternalNode ( ) throws NodeValidationException { 
if ( logger . isInfoEnabled ( ) ) logger . info ( "Create test ES node" ) ; 
int port = SocketUtils . findAvailableTcpPort ( ) ; 
String clusterName = INTERNAL_TEST_CLUSTER_NAME + UUID . randomUUID ( ) ; 
Settings . Builder settingsBuilder = Settings . builder ( ) . put ( "cluster.name" , clusterName ) . put ( "http.type" , "netty4" ) . put ( "http.port" , String . valueOf ( port ) ) ; 
if ( this . esNodeproperties != null ) this . esNodeproperties . getProperties ( ) . forEach ( settingsBuilder :: put ) ; 
Collection < Class < ? extends Plugin > > plugins = scanPlugins ( ) ; 
plugins . add ( Netty4Plugin . class ) ; 
this . node = new InternalNode ( settingsBuilder . build ( ) , plugins ) . start ( ) ; 
return Integer . parseInt ( settingsBuilder . get ( "http.port" ) ) ; 
} 
} 

public class PayPalPaymentResource { 
public static PayPalPaymentResource fromJson ( String jsonString ) throws JSONException { 
JSONObject json = new JSONObject ( jsonString ) ; 
PayPalPaymentResource payPalPaymentResource = new PayPalPaymentResource ( ) ; 
JSONObject redirectJson = json . optJSONObject ( PAYMENT_RESOURCE_KEY ) ; 
if ( redirectJson != null ) payPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , REDIRECT_URL_KEY , "" ) ) ; 
else { 
redirectJson = json . optJSONObject ( AGREEMENT_SETUP_KEY ) ; 
payPalPaymentResource . redirectUrl ( Json . optString ( redirectJson , APPROVAL_URL_KEY , "" ) ) ; 
} 
return payPalPaymentResource ; 
} 
} 

public class BraintreeHttpClient { 
@ Override public void get ( String path , HttpResponseCallback callback ) { 
if ( path == null ) { 
postCallbackOnMainThread ( callback , new IllegalArgumentException ( "Path cannot be null" ) ) ; 
return ; 
} 
Uri uri ; 
if ( path . startsWith ( "http" ) ) uri = Uri . parse ( path ) ; 
else uri = Uri . parse ( mBaseUrl + path ) ; 
if ( mAuthorization instanceof ClientToken ) uri = uri . buildUpon ( ) . appendQueryParameter ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . build ( ) ; 
super . get ( uri . toString ( ) , callback ) ; 
} 
} 

public class BraintreeHttpClient { 
@ Override public void post ( String path , String data , HttpResponseCallback callback ) { 
try { 
if ( mAuthorization instanceof ClientToken ) data = new JSONObject ( data ) . put ( AUTHORIZATION_FINGERPRINT_KEY , ( ( ClientToken ) mAuthorization ) . getAuthorizationFingerprint ( ) ) . toString ( ) ; 
super . post ( path , data , callback ) ; 
} 
catch ( JSONException e ) { 
postCallbackOnMainThread ( callback , e ) ; 
} 
} 
} 

public class VenmoConfiguration { 
static VenmoConfiguration fromJson ( JSONObject json ) { 
if ( json == null ) json = new JSONObject ( ) ; 
VenmoConfiguration venmoConfiguration = new VenmoConfiguration ( ) ; 
venmoConfiguration . mAccessToken = Json . optString ( json , ACCESS_TOKEN_KEY , "" ) ; 
venmoConfiguration . mEnvironment = Json . optString ( json , ENVIRONMENT_KEY , "" ) ; 
venmoConfiguration . mMerchantId = Json . optString ( json , MERCHANT_ID_KEY , "" ) ; 
return venmoConfiguration ; 
} 
} 

public class DataCollector { 
public static void collectDeviceData ( final BraintreeFragment fragment , final String merchantId , final BraintreeResponseListener < String > listener ) { 
fragment . waitForConfiguration ( new ConfigurationListener ( ) { 
@ Override public void onConfigurationFetched ( Configuration configuration ) { 
final JSONObject deviceData = new JSONObject ( ) ; 
try { 
String clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; 
if ( ! TextUtils . isEmpty ( clientMetadataId ) ) deviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; 
} 
catch ( JSONException ignored ) { 
} 
if ( configuration . getKount ( ) . isEnabled ( ) ) { 
final String id ; 
if ( merchantId != null ) id = merchantId ; 
else id = configuration . getKount ( ) . getKountMerchantId ( ) ; 
try { 
final String deviceSessionId = UUIDHelper . getFormattedUUID ( ) ; 
startDeviceCollector ( fragment , id , deviceSessionId , new BraintreeResponseListener < String > ( ) { 
@ Override public void onResponse ( String sessionId ) { 
try { 
deviceData . put ( DEVICE_SESSION_ID_KEY , deviceSessionId ) ; 
deviceData . put ( FRAUD_MERCHANT_ID_KEY , id ) ; 
} 
catch ( JSONException ignored ) { 
} 
listener . onResponse ( deviceData . toString ( ) ) ; 
} 
} 
) ; 
} 
catch ( ClassNotFoundException | NoClassDefFoundError | NumberFormatException ignored ) { 
listener . onResponse ( deviceData . toString ( ) ) ; 
} 
} 
else listener . onResponse ( deviceData . toString ( ) ) ; 
} 
} 
) ; 
} 
} 

public class DataCollector { 
public static void collectPayPalDeviceData ( final BraintreeFragment fragment , final BraintreeResponseListener < String > listener ) { 
final JSONObject deviceData = new JSONObject ( ) ; 
try { 
String clientMetadataId = getPayPalClientMetadataId ( fragment . getApplicationContext ( ) ) ; 
if ( ! TextUtils . isEmpty ( clientMetadataId ) ) deviceData . put ( CORRELATION_ID_KEY , clientMetadataId ) ; 
} 
catch ( JSONException ignored ) { 
} 
listener . onResponse ( deviceData . toString ( ) ) ; 
} 
} 

public class SignatureVerification { 
@ SuppressLint ( "PackageManagerGetSignatures" ) public static boolean isSignatureValid ( Context context , String packageName , String certificateSubject , String certificateIssuer , int publicKeyHashCode ) { 
if ( ! sEnableSignatureVerification ) return true ; 
PackageManager packageManager = context . getPackageManager ( ) ; 
Signature [ ] signatures ; 
try { 
signatures = packageManager . getPackageInfo ( packageName , PackageManager . GET_SIGNATURES ) . signatures ; 
} 
catch ( NameNotFoundException e ) { 
return false ; 
} 
InputStream certStream = null ; 
boolean validated = ( signatures . length != 0 ) ; 
for ( Signature signature : signatures ) { 
try { 
certStream = new ByteArrayInputStream ( signature . toByteArray ( ) ) ; 
X509Certificate x509Cert = ( X509Certificate ) CertificateFactory . getInstance ( "X509" ) . generateCertificate ( certStream ) ; 
String subject = x509Cert . getSubjectX500Principal ( ) . getName ( ) ; 
String issuer = x509Cert . getIssuerX500Principal ( ) . getName ( ) ; 
int actualPublicKeyHashCode = x509Cert . getPublicKey ( ) . hashCode ( ) ; 
validated &= ( certificateSubject . equals ( subject ) && certificateIssuer . equals ( issuer ) && publicKeyHashCode == actualPublicKeyHashCode ) ; 
if ( ! validated ) return false ; 
} 
catch ( CertificateException e ) { 
return false ; 
} 
finally { 
try { 
if ( certStream != null ) certStream . close ( ) ; 
} 
catch ( IOException ignored ) { 
} 
} 
} 
return validated ; 
} 
} 

public class Json { 
public static String optString ( JSONObject json , String name , String fallback ) { 
if ( json . isNull ( name ) ) return fallback ; 
else return json . optString ( name , fallback ) ; 
} 
} 

public class PaymentMethodNonce { 
public static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { 
JSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; 
if ( paymentMethods == null ) return Collections . emptyList ( ) ; 
List < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; 
JSONObject json ; 
PaymentMethodNonce paymentMethodNonce ; 
for ( int i = 0 ; 
i < paymentMethods . length ( ) ; 
i ++ ) { 
json = paymentMethods . getJSONObject ( i ) ; 
paymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; 
if ( paymentMethodNonce != null ) paymentMethodsNonces . add ( paymentMethodNonce ) ; 
} 
return paymentMethodsNonces ; 
} 
} 

public class OtcConfiguration { 
public CheckoutRecipe getBrowserCheckoutConfig ( ) { 
for ( CheckoutRecipe recipe : mCheckoutRecipesInDecreasingPriorityOrder ) { 
if ( recipe . getTarget ( ) == RequestTarget . browser ) return recipe ; 
} 
return null ; 
} 
} 

public class OtcConfiguration { 
public BillingAgreementRecipe getBrowserBillingAgreementConfig ( ) { 
for ( BillingAgreementRecipe recipe : mBillingAgreementRecipesInDecreasingPriorityOrder ) { 
if ( recipe . getTarget ( ) == RequestTarget . browser ) return recipe ; 
} 
return null ; 
} 
} 

public class HttpClient { 
public void get ( final String path , final HttpResponseCallback callback ) { 
if ( path == null ) { 
postCallbackOnMainThread ( callback , new IllegalArgumentException ( "Path cannot be null" ) ) ; 
return ; 
} 
final String url ; 
if ( path . startsWith ( "http" ) ) url = path ; 
else url = mBaseUrl + path ; 
mThreadPool . submit ( new Runnable ( ) { 
@ Override public void run ( ) { 
HttpURLConnection connection = null ; 
try { 
connection = init ( url ) ; 
connection . setRequestMethod ( METHOD_GET ) ; 
postCallbackOnMainThread ( callback , parseResponse ( connection ) ) ; 
} 
catch ( Exception e ) { 
postCallbackOnMainThread ( callback , e ) ; 
} 
finally { 
if ( connection != null ) connection . disconnect ( ) ; 
} 
} 
} 
) ; 
} 
} 

public class HttpClient { 
public String post ( String path , String data ) throws Exception { 
HttpURLConnection connection = null ; 
try { 
if ( path . startsWith ( "http" ) ) connection = init ( path ) ; 
else connection = init ( mBaseUrl + path ) ; 
connection . setRequestProperty ( "Content-Type" , "application/json" ) ; 
connection . setRequestMethod ( METHOD_POST ) ; 
connection . setDoOutput ( true ) ; 
writeOutputStream ( connection . getOutputStream ( ) , data ) ; 
return parseResponse ( connection ) ; 
} 
finally { 
if ( connection != null ) connection . disconnect ( ) ; 
} 
} 
} 

public class BraintreeFragment { 
public < T extends BraintreeListener > void addListener ( T listener ) { 
if ( listener instanceof ConfigurationListener ) mConfigurationListener = ( ConfigurationListener ) listener ; 
if ( listener instanceof BraintreeCancelListener ) mCancelListener = ( BraintreeCancelListener ) listener ; 
if ( listener instanceof PaymentMethodNoncesUpdatedListener ) mPaymentMethodNoncesUpdatedListener = ( PaymentMethodNoncesUpdatedListener ) listener ; 
if ( listener instanceof PaymentMethodNonceCreatedListener ) mPaymentMethodNonceCreatedListener = ( PaymentMethodNonceCreatedListener ) listener ; 
if ( listener instanceof PaymentMethodNonceDeletedListener ) mPaymentMethodNonceDeletedListener = ( PaymentMethodNonceDeletedListener ) listener ; 
if ( listener instanceof BraintreePaymentResultListener ) mBraintreePaymentResultListener = ( BraintreePaymentResultListener ) listener ; 
if ( listener instanceof BraintreeErrorListener ) mErrorListener = ( BraintreeErrorListener ) listener ; 
if ( listener instanceof UnionPayListener ) mUnionPayListener = ( UnionPayListener ) listener ; 
if ( listener instanceof AmericanExpressListener ) mAmericanExpressListener = ( AmericanExpressListener ) listener ; 
flushCallbacks ( ) ; 
} 
} 

public class BraintreeFragment { 
public < T extends BraintreeListener > void removeListener ( T listener ) { 
if ( listener instanceof ConfigurationListener ) mConfigurationListener = null ; 
if ( listener instanceof BraintreeCancelListener ) mCancelListener = null ; 
if ( listener instanceof PaymentMethodNoncesUpdatedListener ) mPaymentMethodNoncesUpdatedListener = null ; 
if ( listener instanceof PaymentMethodNonceCreatedListener ) mPaymentMethodNonceCreatedListener = null ; 
if ( listener instanceof PaymentMethodNonceDeletedListener ) mPaymentMethodNonceDeletedListener = null ; 
if ( listener instanceof BraintreePaymentResultListener ) mBraintreePaymentResultListener = null ; 
if ( listener instanceof BraintreeErrorListener ) mErrorListener = null ; 
if ( listener instanceof UnionPayListener ) mUnionPayListener = null ; 
if ( listener instanceof AmericanExpressListener ) mAmericanExpressListener = null ; 
} 
} 

public class PayPal { 
public static void requestBillingAgreement ( BraintreeFragment fragment , PayPalRequest request , PayPalApprovalHandler handler ) { 
if ( request . getAmount ( ) == null ) { 
fragment . sendAnalyticsEvent ( "paypal.billing-agreement.selected" ) ; 
if ( request . shouldOfferCredit ( ) ) fragment . sendAnalyticsEvent ( "paypal.billing-agreement.credit.offered" ) ; 
requestOneTimePayment ( fragment , request , true , handler ) ; 
} 
else fragment . postCallback ( new BraintreeException ( "There must be no amount specified for the Billing Agreement flow" ) ) ; 
} 
} 

public class PayPal { 
protected static void onActivityResult ( final BraintreeFragment fragment , int resultCode , Intent data ) { 
Request request = getPersistedRequest ( fragment . getApplicationContext ( ) ) ; 
String paymentType = paymentTypeForRequest ( request ) ; 
String switchType = switchTypeForIntent ( data ) ; 
String eventPrefix = paymentType + "." + switchType ; 
if ( resultCode == AppCompatActivity . RESULT_OK && data != null && request != null ) { 
Result result = PayPalOneTouchCore . parseResponse ( fragment . getApplicationContext ( ) , request , data ) ; 
switch ( result . getResultType ( ) ) { 
case Error : fragment . postCallback ( new BrowserSwitchException ( result . getError ( ) . getMessage ( ) ) ) ; 
fragment . sendAnalyticsEvent ( eventPrefix + ".failed" ) ; 
break ; 
case Cancel : fragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; 
fragment . sendAnalyticsEvent ( eventPrefix + ".canceled" ) ; 
break ; 
case Success : onSuccess ( fragment , data , request , result ) ; 
fragment . sendAnalyticsEvent ( eventPrefix + ".succeeded" ) ; 
break ; 
} 
} 
else { 
fragment . sendAnalyticsEvent ( eventPrefix + ".canceled" ) ; 
if ( resultCode != AppCompatActivity . RESULT_CANCELED ) fragment . postCancelCallback ( BraintreeRequestCodes . PAYPAL ) ; 
} 
} 
} 

public class PayPal { 
private static PayPalAccountBuilder parseResponse ( PayPalRequest paypalRequest , Request request , Result result , Intent intent ) { 
PayPalAccountBuilder paypalAccountBuilder = new PayPalAccountBuilder ( ) . clientMetadataId ( request . getClientMetadataId ( ) ) ; 
if ( paypalRequest != null && paypalRequest . getMerchantAccountId ( ) != null ) paypalAccountBuilder . merchantAccountId ( paypalRequest . getMerchantAccountId ( ) ) ; 
if ( request instanceof CheckoutRequest && paypalRequest != null ) paypalAccountBuilder . intent ( paypalRequest . getIntent ( ) ) ; 
if ( isAppSwitch ( intent ) ) paypalAccountBuilder . source ( "paypal-app" ) ; 
else paypalAccountBuilder . source ( "paypal-browser" ) ; 
paypalAccountBuilder . oneTouchCoreData ( result . getResponse ( ) ) ; 
return paypalAccountBuilder ; 
} 
} 

public class OpenKoreanTextProcessorJava { 
public static List < String > tokensToJavaStringList ( Seq < KoreanToken > tokens , boolean keepSpace ) { 
Iterator < KoreanToken > tokenized = tokens . iterator ( ) ; 
List < String > output = new LinkedList < > ( ) ; 
while ( tokenized . hasNext ( ) ) { 
final KoreanToken token = tokenized . next ( ) ; 
if ( keepSpace || token . pos ( ) != KoreanPos . Space ( ) ) output . add ( token . text ( ) ) ; 
} 
return output ; 
} 
} 

public class BaseResampler { 
public static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { 
double sum = 0 ; 
for ( int i = 0 ; 
i < taps . length ; 
i ++ ) sum += taps [ i ] ; 
int sumFix = 0 ; 
int precNum = 1 << precBits ; 
for ( int i = 0 ; 
i < taps . length ; 
i ++ ) { 
double d = ( taps [ i ] * precNum ) / sum + precNum ; 
int s = ( int ) d ; 
taps [ i ] = d - s ; 
out [ i ] = ( short ) ( s - precNum ) ; 
sumFix += out [ i ] ; 
} 
long tapsTaken = 0 ; 
while ( sumFix < precNum ) { 
int maxI = - 1 ; 
for ( int i = 0 ; 
i < taps . length ; 
i ++ ) if ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; 
out [ maxI ] ++ ; 
sumFix ++ ; 
tapsTaken |= ( 1 << maxI ) ; 
} 
for ( int i = 0 ; 
i < taps . length ; 
i ++ ) { 
taps [ i ] += out [ i ] ; 
if ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; 
} 
} 
} 

public class SegmentReader { 
public final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { 
if ( done ) return State . STOP ; 
int skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; 
int written = out . position ( ) ; 
do { 
while ( buf . hasRemaining ( ) ) { 
if ( curMarker >= 0x100 && curMarker <= 0x1ff ) { 
if ( skipOneMarker == 0 ) return State . DONE ; 
-- skipOneMarker ; 
} 
if ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; 
out . put ( ( byte ) ( curMarker >>> 24 ) ) ; 
curMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; 
} 
buf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; 
pos += buf . remaining ( ) ; 
} 
while ( buf . hasRemaining ( ) ) ; 
written = out . position ( ) - written ; 
if ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; 
for ( ; 
bytesInMarker > 0 && out . hasRemaining ( ) ; 
) { 
out . put ( ( byte ) ( curMarker >>> 24 ) ) ; 
curMarker = ( curMarker << 8 ) ; 
-- bytesInMarker ; 
if ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; 
} 
if ( bytesInMarker == 0 ) { 
done = true ; 
return State . STOP ; 
} 
else return State . MORE_DATA ; 
} 
} 

public class ImageSequenceDemuxer { 
public int getMaxAvailableFrame ( ) { 
if ( maxAvailableFrame == - 1 ) { 
int firstPoint = 0 ; 
for ( int i = MAX_MAX ; 
i > 0 ; 
i /= 2 ) if ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { 
firstPoint = i ; 
break ; 
} 
int pos = firstPoint ; 
for ( int interv = firstPoint / 2 ; 
interv > 1 ; 
interv /= 2 ) if ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) pos += interv ; 
maxAvailableFrame = pos ; 
Logger . info ( "Max frame found: " + maxAvailableFrame ) ; 
} 
return Math . min ( maxAvailableFrame , maxFrames ) ; 
} 
} 

public class QTTimeUtil { 
public static long editedToMedia ( TrakBox trak , long editedTv , int movieTimescale ) { 
if ( trak . getEdits ( ) == null ) return editedTv ; 
long accum = 0 ; 
for ( Edit edit : trak . getEdits ( ) ) { 
long duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; 
if ( accum + duration > editedTv ) return edit . getMediaTime ( ) + editedTv - accum ; 
accum += duration ; 
} 
return accum ; 
} 
} 

public class AACDecoderConfig { 
public static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { 
final IBitStream _in = BitStream . createBitStream ( data ) ; 
final AACDecoderConfig config = new AACDecoderConfig ( ) ; 
try { 
config . profile = readProfile ( _in ) ; 
int sf = _in . readBits ( 4 ) ; 
if ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; 
else config . sampleFrequency = SampleFrequency . forInt ( sf ) ; 
config . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; 
Profile cp = config . profile ; 
if ( AAC_SBR == cp ) { 
config . extProfile = cp ; 
config . sbrPresent = true ; 
sf = _in . readBits ( 4 ) ; 
config . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; 
config . sampleFrequency = SampleFrequency . forInt ( sf ) ; 
config . profile = readProfile ( _in ) ; 
} 
else if ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { 
config . frameLengthFlag = _in . readBool ( ) ; 
if ( config . frameLengthFlag ) throw new AACException ( "config uses 960-sample frames, not yet supported" ) ; 
config . dependsOnCoreCoder = _in . readBool ( ) ; 
if ( config . dependsOnCoreCoder ) config . coreCoderDelay = _in . readBits ( 14 ) ; 
else config . coreCoderDelay = 0 ; 
config . extensionFlag = _in . readBool ( ) ; 
if ( config . extensionFlag ) { 
if ( cp . isErrorResilientProfile ( ) ) { 
config . sectionDataResilience = _in . readBool ( ) ; 
config . scalefactorResilience = _in . readBool ( ) ; 
config . spectralDataResilience = _in . readBool ( ) ; 
} 
_in . skipBit ( ) ; 
} 
if ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { 
_in . skipBits ( 3 ) ; 
PCE pce = new PCE ( ) ; 
pce . decode ( _in ) ; 
config . profile = pce . getProfile ( ) ; 
config . sampleFrequency = pce . getSampleFrequency ( ) ; 
config . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; 
} 
if ( _in . getBitsLeft ( ) > 10 ) readSyncExtension ( _in , config ) ; 
} 
else throw new AACException ( "profile not supported: " + cp . getIndex ( ) ) ; 
return config ; 
} 
finally { 
_in . destroy ( ) ; 
} 
} 
} 

public class SequenceEncoder { 
public void encodeNativeFrame ( Picture pic ) throws IOException { 
if ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( "The input images is expected in RGB color." ) ; 
ColorSpace sinkColor = sink . getInputColor ( ) ; 
LoanerPicture toEncode ; 
if ( sinkColor != null ) { 
toEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; 
transform . transform ( pic , toEncode . getPicture ( ) ) ; 
} 
else toEncode = new LoanerPicture ( pic , 0 ) ; 
Packet pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; 
sink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; 
if ( sinkColor != null ) pixelStore . putBack ( toEncode ) ; 
timestamp += fps . getDen ( ) ; 
frameNo ++ ; 
} 
} 

public class EbmlUtil { 
public static byte [ ] ebmlEncodeLen ( long value , int length ) { 
byte [ ] b = new byte [ length ] ; 
for ( int idx = 0 ; 
idx < length ; 
idx ++ ) b [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; 
b [ 0 ] |= 0x80 >>> ( length - 1 ) ; 
return b ; 
} 
} 

public class MDecoder { 
public int decodeBinBypass ( ) { 
code <<= 1 ; 
-- nBitsPending ; 
if ( nBitsPending <= 0 ) readOneByte ( ) ; 
int tmp = code - ( range << 8 ) ; 
if ( tmp < 0 ) return 0 ; 
else { 
code = tmp ; 
return 1 ; 
} 
} 
} 

public class GainControl { 
private int getGainChangePointID ( int lngain ) { 
for ( int i = 0 ; 
i < ID_GAIN ; 
i ++ ) if ( lngain == LN_GAIN [ i ] ) return i ; 
return 0 ; 
} 
} 

public class AudioUtil { 
public static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { 
if ( ! format . isSigned ( ) ) throw new NotSupportedException ( "Unsigned PCM is not supported ( yet? )." ) ; 
if ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + " bit PCM is not supported ( yet? )." ) ; 
if ( format . isBigEndian ( ) ) if ( format . getSampleSizeInBits ( ) == 16 ) toFloat16BE ( buf , floatBuf ) ; 
else toFloat24BE ( buf , floatBuf ) ; 
else if ( format . getSampleSizeInBits ( ) == 16 ) toFloat16LE ( buf , floatBuf ) ; 
else toFloat24LE ( buf , floatBuf ) ; 
} 
} 

public class AudioUtil { 
public static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { 
if ( ! format . isSigned ( ) ) throw new NotSupportedException ( "Unsigned PCM is not supported ( yet? )." ) ; 
if ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + " bit PCM is not supported ( yet? )." ) ; 
if ( format . isBigEndian ( ) ) if ( format . getSampleSizeInBits ( ) == 16 ) fromFloat16BE ( buf , floatBuf ) ; 
else fromFloat24BE ( buf , floatBuf ) ; 
else if ( format . getSampleSizeInBits ( ) == 16 ) fromFloat16LE ( buf , floatBuf ) ; 
else fromFloat24LE ( buf , floatBuf ) ; 
} 
} 

public class AudioUtil { 
public static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { 
int bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; 
int bytesPerFrame = bytesPerSample * ins . length ; 
int max = 0 ; 
for ( int i = 0 ; 
i < ins . length ; 
i ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; 
for ( int frames = 0 ; 
frames < max && outb . remaining ( ) >= bytesPerFrame ; 
frames ++ ) for ( int j = 0 ; 
j < ins . length ; 
j ++ ) if ( ins [ j ] . remaining ( ) < bytesPerSample ) for ( int i = 0 ; 
i < bytesPerSample ; 
i ++ ) outb . put ( ( byte ) 0 ) ; 
else for ( int i = 0 ; 
i < bytesPerSample ; 
i ++ ) outb . put ( ins [ j ] . get ( ) ) ; 
} 
} 

public class AudioUtil { 
public static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { 
int bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; 
int bytesPerFrame = bytesPerSample * outs . length ; 
while ( inb . remaining ( ) >= bytesPerFrame ) for ( int j = 0 ; 
j < outs . length ; 
j ++ ) for ( int i = 0 ; 
i < bytesPerSample ; 
i ++ ) outs [ j ] . put ( inb . get ( ) ) ; 
} 
} 

public class SliceGroupMapBuilder { 
public static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { 
int picSizeInMbs = picWidthInMbs * picHeightInMbs ; 
int [ ] groups = new int [ picSizeInMbs ] ; 
int changeDirectionInt = changeDirection ? 1 : 0 ; 
for ( int i = 0 ; 
i < picSizeInMbs ; 
i ++ ) groups [ i ] = 1 ; 
int x = ( picWidthInMbs - changeDirectionInt ) / 2 ; 
int y = ( picHeightInMbs - changeDirectionInt ) / 2 ; 
int leftBound = x ; 
int topBound = y ; 
int rightBound = x ; 
int bottomBound = y ; 
int xDir = changeDirectionInt - 1 ; 
int yDir = changeDirectionInt ; 
boolean mapUnitVacant = false ; 
for ( int k = 0 ; 
k < numberOfMbsInBox ; 
k += ( mapUnitVacant ? 1 : 0 ) ) { 
int mbAddr = y * picWidthInMbs + x ; 
mapUnitVacant = ( groups [ mbAddr ] == 1 ) ; 
if ( mapUnitVacant ) groups [ mbAddr ] = 0 ; 
if ( xDir == - 1 && x == leftBound ) { 
leftBound = Max ( leftBound - 1 , 0 ) ; 
x = leftBound ; 
xDir = 0 ; 
yDir = 2 * changeDirectionInt - 1 ; 
} 
else if ( xDir == 1 && x == rightBound ) { 
rightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; 
x = rightBound ; 
xDir = 0 ; 
yDir = 1 - 2 * changeDirectionInt ; 
} 
else if ( yDir == - 1 && y == topBound ) { 
topBound = Max ( topBound - 1 , 0 ) ; 
y = topBound ; 
xDir = 1 - 2 * changeDirectionInt ; 
yDir = 0 ; 
} 
else if ( yDir == 1 && y == bottomBound ) { 
bottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; 
y = bottomBound ; 
xDir = 2 * changeDirectionInt - 1 ; 
yDir = 0 ; 
} 
else { 
x += xDir ; 
y += yDir ; 
} 
} 
return groups ; 
} 
} 

public class SliceGroupMapBuilder { 
public static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { 
int picSizeInMbs = picWidthInMbs * picHeightInMbs ; 
int [ ] groups = new int [ picSizeInMbs ] ; 
int changeDirectionInt = changeDirection ? 1 : 0 ; 
int k = 0 ; 
for ( int j = 0 ; 
j < picWidthInMbs ; 
j ++ ) for ( int i = 0 ; 
i < picHeightInMbs ; 
i ++ ) { 
int mbAddr = i * picWidthInMbs + j ; 
if ( k ++ < sizeOfUpperLeftGroup ) groups [ mbAddr ] = changeDirectionInt ; 
else groups [ mbAddr ] = 1 - changeDirectionInt ; 
} 
return groups ; 
} 
} 

public class MXFMetadata { 
protected static UL [ ] readULBatch ( ByteBuffer _bb ) { 
int count = _bb . getInt ( ) ; 
_bb . getInt ( ) ; 
UL [ ] result = new UL [ count ] ; 
for ( int i = 0 ; 
i < count ; 
i ++ ) result [ i ] = UL . read ( _bb ) ; 
return result ; 
} 
} 

public class MXFMetadata { 
protected static int [ ] readInt32Batch ( ByteBuffer _bb ) { 
int count = _bb . getInt ( ) ; 
_bb . getInt ( ) ; 
int [ ] result = new int [ count ] ; 
for ( int i = 0 ; 
i < count ; 
i ++ ) result [ i ] = _bb . getInt ( ) ; 
return result ; 
} 
} 

public class H264Encoder { 
public EncodedFrame encodeFrame ( Picture pic , ByteBuffer _out ) { 
if ( pic . getColor ( ) != ColorSpace . YUV420J ) throw new IllegalArgumentException ( "Input picture color is not supported: " + pic . getColor ( ) ) ; 
if ( frameNumber >= keyInterval ) frameNumber = 0 ; 
SliceType sliceType = frameNumber == 0 ? SliceType . I : SliceType . P ; 
boolean idr = frameNumber == 0 ; 
ByteBuffer data = doEncodeFrame ( pic , _out , idr , frameNumber ++ , sliceType ) ; 
return new EncodedFrame ( data , idr ) ; 
} 
} 

public class JNIMemoryManager { 
void gcInternal ( ) { 
JNIReference ref = null ; 
while ( ( ref = ( JNIReference ) mRefQueue . poll ( ) ) != null ) ref . delete ( ) ; 
} 
} 

public class JNILibrary { 
private boolean unpackLibrary ( String path ) { 
boolean retval = false ; 
try { 
final Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; 
while ( c . hasMoreElements ( ) ) { 
final URL url = c . nextElement ( ) ; 
log . trace ( "path: {}; url: {}" , path , url ) ; 
if ( url == null ) return false ; 
boolean unpacked = false ; 
File lib ; 
if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( "file" ) ) { 
try { 
lib = new File ( new URI ( url . toString ( ) ) ) ; 
} 
catch ( URISyntaxException e ) { 
lib = new File ( url . getPath ( ) ) ; 
} 
if ( ! lib . exists ( ) ) { 
log . error ( "Unpacked library not unpacked correctedly;  url: {}" , url ) ; 
continue ; 
} 
} 
else if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( "jar" ) ) { 
InputStream stream = url . openStream ( ) ; 
if ( stream == null ) { 
log . error ( "could not get stream for resource: {}" , url . getPath ( ) ) ; 
continue ; 
} 
FileOutputStream out = null ; 
try { 
File dir = getTmpDir ( ) ; 
lib = File . createTempFile ( "humble" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? ".dll" : null , dir ) ; 
lib . deleteOnExit ( ) ; 
out = new FileOutputStream ( lib ) ; 
int bytesRead = 0 ; 
final byte [ ] buffer = new byte [ 2048 ] ; 
while ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) out . write ( buffer , 0 , bytesRead ) ; 
unpacked = true ; 
} 
catch ( IOException e ) { 
log . error ( "could not create temp file: {}" , e ) ; 
continue ; 
} 
finally { 
try { 
stream . close ( ) ; 
} 
catch ( IOException e ) { 
} 
if ( out != null ) try { 
out . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
try { 
doJNILoad ( lib . getAbsolutePath ( ) ) ; 
retval = true ; 
break ; 
} 
catch ( UnsatisfiedLinkError e ) { 
} 
finally { 
if ( unpacked ) deleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; 
} 
} 
} 
} 
catch ( IOException e1 ) { 
retval = false ; 
} 
return retval ; 
} 
} 

public class DecodeAndPlayVideo { 
private static void playVideo ( String filename ) throws InterruptedException , IOException { 
Demuxer demuxer = Demuxer . make ( ) ; 
demuxer . open ( filename , null , false , true , null , null ) ; 
int numStreams = demuxer . getNumStreams ( ) ; 
int videoStreamId = - 1 ; 
long streamStartTime = Global . NO_PTS ; 
Decoder videoDecoder = null ; 
for ( int i = 0 ; 
i < numStreams ; 
i ++ ) { 
final DemuxerStream stream = demuxer . getStream ( i ) ; 
streamStartTime = stream . getStartTime ( ) ; 
final Decoder decoder = stream . getDecoder ( ) ; 
if ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { 
videoStreamId = i ; 
videoDecoder = decoder ; 
break ; 
} 
} 
if ( videoStreamId == - 1 ) throw new RuntimeException ( "could not find video stream in container: " + filename ) ; 
videoDecoder . open ( null , null ) ; 
final MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; 
final MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; 
BufferedImage image = null ; 
final ImageFrame window = ImageFrame . make ( ) ; 
if ( window == null ) throw new RuntimeException ( "Attempting this demo on a headless machine, and that will not work. Sad day for you." ) ; 
long systemStartTime = System . nanoTime ( ) ; 
final Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; 
final Rational streamTimebase = videoDecoder . getTimeBase ( ) ; 
final MediaPacket packet = MediaPacket . make ( ) ; 
while ( demuxer . read ( packet ) >= 0 ) if ( packet . getStreamIndex ( ) == videoStreamId ) { 
int offset = 0 ; 
int bytesRead = 0 ; 
do { 
bytesRead += videoDecoder . decode ( picture , packet , offset ) ; 
if ( picture . isComplete ( ) ) image = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; 
offset += bytesRead ; 
} 
while ( offset < packet . getSize ( ) ) ; 
} 
do { 
videoDecoder . decode ( picture , null , 0 ) ; 
if ( picture . isComplete ( ) ) image = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; 
} 
while ( picture . isComplete ( ) ) ; 
demuxer . close ( ) ; 
window . dispose ( ) ; 
} 
} 

public class Configuration { 
public static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { 
if ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) stream . printf ( "  %s; default= %s; type=%s;\n" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; 
else { 
stream . printf ( "  %s; default= %d; valid values=(" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; 
int numSettings = prop . getNumFlagSettings ( ) ; 
long value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; 
for ( int i = 0 ; 
i < numSettings ; 
i ++ ) { 
Property fprop = prop . getFlagConstant ( i ) ; 
long flagMask = fprop . getDefault ( ) ; 
boolean isSet = ( value & flagMask ) > 0 ; 
stream . printf ( "%s%s; " , isSet ? "+" : "-" , fprop . getName ( ) ) ; 
} 
stream . printf ( "); type=%s;\n" , prop . getType ( ) ) ; 
} 
stream . printf ( "    help for %s: %s\n" , prop . getName ( ) , prop . getHelp ( ) == null ? "no help available" : prop . getHelp ( ) ) ; 
} 
} 

public class HumbleIO { 
static public String generateUniqueName ( Object src , String extension ) { 
StringBuilder builder = new StringBuilder ( ) ; 
builder . append ( UUID . randomUUID ( ) . toString ( ) ) ; 
if ( src != null ) { 
builder . append ( "-" ) ; 
builder . append ( src . getClass ( ) . getName ( ) ) ; 
builder . append ( "-" ) ; 
builder . append ( Integer . toHexString ( src . hashCode ( ) ) ) ; 
} 
if ( extension != null ) builder . append ( extension ) ; 
return builder . toString ( ) ; 
} 
} 

public class JNIEnv { 
public static CPUArch getCPUArch ( String javaCPU ) { 
final CPUArch javaArch ; 
final String javaCPUArch = javaCPU != null ? javaCPU . toLowerCase ( ) : "" ; 
if ( javaCPUArch . startsWith ( "x86_64" ) || javaCPUArch . startsWith ( "amd64" ) || javaCPUArch . startsWith ( "ia64" ) ) javaArch = CPUArch . X86_64 ; 
else if ( javaCPUArch . startsWith ( "ppc64" ) || javaCPUArch . startsWith ( "powerpc64" ) ) javaArch = CPUArch . PPC64 ; 
else if ( javaCPUArch . startsWith ( "ppc" ) || javaCPUArch . startsWith ( "powerpc" ) ) javaArch = CPUArch . PPC ; 
else if ( javaCPUArch . contains ( "86" ) ) javaArch = CPUArch . X86 ; 
else javaArch = CPUArch . UNKNOWN ; 
return javaArch ; 
} 
} 

public class JNIEnv { 
public static OSFamily getOSFamily ( String osName ) { 
final OSFamily retval ; 
if ( osName != null && osName . length ( ) > 0 ) if ( osName . startsWith ( "Windows" ) ) retval = OSFamily . WINDOWS ; 
else if ( osName . startsWith ( "Mac" ) ) retval = OSFamily . MAC ; 
else if ( osName . startsWith ( "Linux" ) ) retval = OSFamily . LINUX ; 
else retval = OSFamily . UNKNOWN ; 
else retval = OSFamily . UNKNOWN ; 
return retval ; 
} 
} 

public class DecodeAndPlayAudio { 
private static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { 
Demuxer demuxer = Demuxer . make ( ) ; 
demuxer . open ( filename , null , false , true , null , null ) ; 
int numStreams = demuxer . getNumStreams ( ) ; 
int audioStreamId = - 1 ; 
Decoder audioDecoder = null ; 
for ( int i = 0 ; 
i < numStreams ; 
i ++ ) { 
final DemuxerStream stream = demuxer . getStream ( i ) ; 
final Decoder decoder = stream . getDecoder ( ) ; 
if ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { 
audioStreamId = i ; 
audioDecoder = decoder ; 
break ; 
} 
} 
if ( audioStreamId == - 1 ) throw new RuntimeException ( "could not find audio stream in container: " + filename ) ; 
audioDecoder . open ( null , null ) ; 
final MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; 
final MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; 
final AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; 
if ( audioFrame == null ) throw new LineUnavailableException ( ) ; 
ByteBuffer rawAudio = null ; 
final MediaPacket packet = MediaPacket . make ( ) ; 
while ( demuxer . read ( packet ) >= 0 ) if ( packet . getStreamIndex ( ) == audioStreamId ) { 
int offset = 0 ; 
int bytesRead = 0 ; 
do { 
bytesRead += audioDecoder . decode ( samples , packet , offset ) ; 
if ( samples . isComplete ( ) ) { 
rawAudio = converter . toJavaAudio ( rawAudio , samples ) ; 
audioFrame . play ( rawAudio ) ; 
} 
offset += bytesRead ; 
} 
while ( offset < packet . getSize ( ) ) ; 
} 
do { 
audioDecoder . decode ( samples , null , 0 ) ; 
if ( samples . isComplete ( ) ) { 
rawAudio = converter . toJavaAudio ( rawAudio , samples ) ; 
audioFrame . play ( rawAudio ) ; 
} 
} 
while ( samples . isComplete ( ) ) ; 
demuxer . close ( ) ; 
audioFrame . dispose ( ) ; 
} 
} 

public class JNILibraryLoader { 
boolean alreadyLoadedLibrary ( String aLibraryName , Long aMajorVersion ) { 
boolean retval = false ; 
Set < Long > foundVersions = mLoadedLibraries . get ( aLibraryName ) ; 
if ( foundVersions != null ) if ( aMajorVersion == null || foundVersions . contains ( aMajorVersion ) ) retval = true ; 
else log . warn ( "Attempting load of {}, version {}, but already loaded verions: {}." + "  We will attempt to load the specified version but behavior is undefined" , new Object [ ] { 
aLibraryName , aMajorVersion , foundVersions . toArray ( ) } 
) ; 
return retval ; 
} 
} 

public class RecordAndEncodeVideo { 
private static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { 
final Robot robot = new Robot ( ) ; 
final Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; 
final Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; 
final Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; 
final Muxer muxer = Muxer . make ( filename , null , formatname ) ; 
final MuxerFormat format = muxer . getFormat ( ) ; 
final Codec codec ; 
if ( codecname != null ) codec = Codec . findEncodingCodecByName ( codecname ) ; 
else codec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; 
Encoder encoder = Encoder . make ( codec ) ; 
encoder . setWidth ( screenbounds . width ) ; 
encoder . setHeight ( screenbounds . height ) ; 
final PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; 
encoder . setPixelFormat ( pixelformat ) ; 
encoder . setTimeBase ( framerate ) ; 
if ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; 
encoder . open ( null , null ) ; 
muxer . addNewStream ( encoder ) ; 
muxer . open ( null , null ) ; 
MediaPictureConverter converter = null ; 
final MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; 
picture . setTimeBase ( framerate ) ; 
final MediaPacket packet = MediaPacket . make ( ) ; 
for ( int i = 0 ; 
i < duration / framerate . getDouble ( ) ; 
i ++ ) { 
final BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; 
if ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; 
converter . toPicture ( picture , screen , i ) ; 
do { 
encoder . encode ( packet , picture ) ; 
if ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; 
} 
while ( packet . isComplete ( ) ) ; 
Thread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; 
} 
do { 
encoder . encode ( packet , null ) ; 
if ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; 
} 
while ( packet . isComplete ( ) ) ; 
muxer . close ( ) ; 
} 
} 

public class JNIReference { 
public void delete ( ) { 
final long swigPtr = mSwigCPtr . getAndSet ( 0 ) ; 
if ( swigPtr != 0 ) { 
if ( mJavaRefCount . decrementAndGet ( ) == 0 ) FerryJNI . RefCounted_release ( swigPtr , null ) ; 
mMemAllocator = null ; 
} 
} 
} 

public class Base58 { 
public static byte [ ] decode ( String input ) throws IllegalArgumentException { 
if ( input . startsWith ( "base58:" ) ) input = input . substring ( 7 ) ; 
if ( input . length ( ) == 0 ) return new byte [ 0 ] ; 
byte [ ] input58 = new byte [ input . length ( ) ] ; 
for ( int i = 0 ; 
i < input . length ( ) ; 
++ i ) { 
char c = input . charAt ( i ) ; 
int digit = c < 128 ? INDEXES [ c ] : - 1 ; 
if ( digit < 0 ) throw new IllegalArgumentException ( "Illegal character " + c + " at position " + i ) ; 
input58 [ i ] = ( byte ) digit ; 
} 
int zeros = 0 ; 
while ( zeros < input58 . length && input58 [ zeros ] == 0 ) ++ zeros ; 
byte [ ] decoded = new byte [ input . length ( ) ] ; 
int outputStart = decoded . length ; 
for ( int inputStart = zeros ; 
inputStart < input58 . length ; 
) { 
decoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; 
if ( input58 [ inputStart ] == 0 ) ++ inputStart ; 
} 
while ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) ++ outputStart ; 
return Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; 
} 
} 

public class Node { 
public List < Transaction > getAddressTransactions ( String address , int limit , String after ) throws IOException { 
String requestUrl = String . format ( "/transactions/address/%s/limit/%d" , address , limit ) ; 
if ( after != null ) requestUrl += String . format ( "?after=%s" , after ) ; 
return wavesJsonMapper . < List < List < Transaction > > > convertValue ( send ( requestUrl ) , new TypeReference < List < List < Transaction > > > ( ) { 
} 
) . get ( 0 ) ; 
} 
} 

public class Node { 
public String compileScript ( String script ) throws IOException { 
if ( script == null || script . isEmpty ( ) ) return null ; 
HttpPost request = new HttpPost ( uri . resolve ( "/utils/script/compile" ) ) ; 
request . setEntity ( new StringEntity ( script ) ) ; 
return parse ( exec ( request ) , "script" ) . asText ( ) ; 
} 
} 

public class FSTBytezEncoder { 
public void writePrimitiveArray ( Object array , int off , int len ) throws IOException { 
Class < ? > componentType = array . getClass ( ) . getComponentType ( ) ; 
if ( componentType == byte . class ) writeRawBytes ( ( byte [ ] ) array , off , len ) ; 
else if ( componentType == char . class ) writeFCharArr ( ( char [ ] ) array , off , len ) ; 
else if ( componentType == short . class ) writeFShortArr ( ( short [ ] ) array , off , len ) ; 
else if ( componentType == int . class ) writeFIntArr ( ( int [ ] ) array , off , len ) ; 
else if ( componentType == double . class ) writeFDoubleArr ( ( double [ ] ) array , off , len ) ; 
else if ( componentType == float . class ) writeFFloatArr ( ( float [ ] ) array , off , len ) ; 
else if ( componentType == long . class ) writeFLongArr ( ( long [ ] ) array , off , len ) ; 
else if ( componentType == boolean . class ) writeFBooleanArr ( ( boolean [ ] ) array , off , len ) ; 
else throw new RuntimeException ( "expected primitive array" ) ; 
} 
} 

public class DefaultCoder { 
public int toByteArray ( Object obj , byte result [ ] , int resultOffset , int avaiableSize ) { 
output . resetForReUse ( ) ; 
try { 
output . writeObject ( obj ) ; 
} 
catch ( IOException e ) { 
FSTUtil . < RuntimeException > rethrow ( e ) ; 
} 
int written = output . getWritten ( ) ; 
if ( written > avaiableSize ) throw FSTBufferTooSmallException . Instance ; 
System . arraycopy ( output . getBuffer ( ) , 0 , result , resultOffset , written ) ; 
return written ; 
} 
} 

public class FSTBinaryOffheapMap { 
public void resizeStore ( long required , long maxgrowbytes ) { 
if ( mappedFile == null ) throw new RuntimeException ( "store is full. Required: " + required ) ; 
if ( required <= memory . length ( ) ) return ; 
mutationCount ++ ; 
System . out . println ( "resizing underlying " + mappedFile + " to " + required + " numElem:" + numElem ) ; 
long tim = System . currentTimeMillis ( ) ; 
( ( MMFBytez ) memory ) . freeAndClose ( ) ; 
memory = null ; 
try { 
File mf = new File ( mappedFile ) ; 
FileOutputStream f = new FileOutputStream ( mf , true ) ; 
long len = mf . length ( ) ; 
required = required + Math . min ( required , maxgrowbytes ) ; 
byte [ ] toWrite = new byte [ 1000 ] ; 
long max = ( required - len ) / 1000 ; 
for ( long i = 0 ; 
i < max + 2 ; 
i ++ ) f . write ( toWrite ) ; 
f . flush ( ) ; 
f . close ( ) ; 
resetMem ( mappedFile , mf . length ( ) ) ; 
System . out . println ( "resizing done in " + ( System . currentTimeMillis ( ) - tim ) + " numElemAfter:" + numElem ) ; 
} 
catch ( FileNotFoundException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
} 
} 
} 

public class FSTStreamEncoder { 
void writeStringAsc ( String name ) throws IOException { 
int len = name . length ( ) ; 
if ( len >= 127 ) throw new RuntimeException ( "Ascii String too long" ) ; 
writeFByte ( ( byte ) len ) ; 
buffout . ensureFree ( len ) ; 
if ( ascStringCache == null || ascStringCache . length < len ) ascStringCache = new byte [ len ] ; 
name . getBytes ( 0 , len , ascStringCache , 0 ) ; 
writeRawBytes ( ascStringCache , 0 , len ) ; 
} 
} 

public class FSTConfiguration { 
public static FSTConfiguration createJsonConfiguration ( boolean prettyPrint , boolean shareReferences ) { 
if ( shareReferences && prettyPrint ) throw new RuntimeException ( "unsupported flag combination" ) ; 
return createJsonConfiguration ( prettyPrint , shareReferences , null ) ; 
} 
} 

public class FSTConfiguration { 
public String getCPNameForClass ( Class cl ) { 
String res = minbinNamesReverse . get ( cl . getName ( ) ) ; 
if ( res == null ) { 
if ( cl . isAnonymousClass ( ) ) return getCPNameForClass ( cl . getSuperclass ( ) ) ; 
return cl . getName ( ) ; 
} 
return res ; 
} 
} 

public class MBOut { 
public void writeArray ( Object primitiveArray , int start , int len ) { 
byte type = MinBin . ARRAY_MASK ; 
Class < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; 
if ( componentType == boolean . class ) type |= MinBin . INT_8 ; 
else if ( componentType == byte . class ) type |= MinBin . INT_8 ; 
else if ( componentType == short . class ) type |= MinBin . INT_16 ; 
else if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; 
else if ( componentType == int . class ) type |= MinBin . INT_32 ; 
else if ( componentType == long . class ) type |= MinBin . INT_64 ; 
else throw new RuntimeException ( "unsupported type " + componentType . getName ( ) ) ; 
writeOut ( type ) ; 
writeIntPacked ( len ) ; 
switch ( type ) { 
case MinBin . INT_8 | MinBin . ARRAY_MASK : { 
if ( componentType == boolean . class ) { 
boolean [ ] arr = ( boolean [ ] ) primitiveArray ; 
for ( int i = start ; 
i < start + len ; 
i ++ ) writeRawInt ( type , arr [ i ] ? 1 : 0 ) ; 
} 
else { 
byte [ ] arr = ( byte [ ] ) primitiveArray ; 
for ( int i = start ; 
i < start + len ; 
i ++ ) writeRawInt ( type , arr [ i ] ) ; 
} 
} 
break ; 
case MinBin . CHAR | MinBin . ARRAY_MASK : { 
char [ ] charArr = ( char [ ] ) primitiveArray ; 
for ( int i = start ; 
i < start + len ; 
i ++ ) writeRawInt ( type , charArr [ i ] ) ; 
} 
break ; 
case MinBin . INT_32 | MinBin . ARRAY_MASK : { 
int [ ] arr = ( int [ ] ) primitiveArray ; 
for ( int i = start ; 
i < start + len ; 
i ++ ) writeRawInt ( type , arr [ i ] ) ; 
} 
break ; 
case MinBin . INT_64 | MinBin . ARRAY_MASK : { 
long [ ] arr = ( long [ ] ) primitiveArray ; 
for ( int i = start ; 
i < start + len ; 
i ++ ) writeRawInt ( type , arr [ i ] ) ; 
} 
break ; 
default : { 
for ( int i = start ; 
i < start + len ; 
i ++ ) if ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; 
else writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; 
} 
} 
} 
} 

public class MBOut { 
public void writeRaw ( byte [ ] bufferedName , int i , int length ) { 
if ( pos + length >= bytez . length - 1 ) resize ( ) ; 
System . arraycopy ( bufferedName , i , bytez , pos , length ) ; 
pos += length ; 
} 
} 

public class FSTObjectOutput { 
protected FSTClazzInfo . FSTFieldInfo getCachedFI ( Class ... possibles ) { 
if ( refs == null ) refs = refsLocal . get ( ) ; 
if ( curDepth >= refs . length ) return new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; 
else { 
FSTClazzInfo . FSTFieldInfo inf = refs [ curDepth ] ; 
if ( inf == null ) { 
inf = new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; 
refs [ curDepth ] = inf ; 
return inf ; 
} 
inf . setPossibleClasses ( possibles ) ; 
return inf ; 
} 
} 
} 

public class FSTObjectOutput { 
protected void objectWillBeWritten ( Object obj , int streamPosition ) { 
if ( listener != null ) listener . objectWillBeWritten ( obj , streamPosition ) ; 
} 
} 

public class FSTObjectOutput { 
protected void objectHasBeenWritten ( Object obj , int oldStreamPosition , int streamPosition ) { 
if ( listener != null ) listener . objectHasBeenWritten ( obj , oldStreamPosition , streamPosition ) ; 
} 
} 

public class FSTObjectOutput { 
protected FSTClazzInfo getFstClazzInfo ( FSTClazzInfo . FSTFieldInfo referencee , Class clazz ) { 
FSTClazzInfo serializationInfo = null ; 
FSTClazzInfo lastInfo = referencee . lastInfo ; 
if ( lastInfo != null && lastInfo . getClazz ( ) == clazz && lastInfo . conf == conf ) serializationInfo = lastInfo ; 
else { 
serializationInfo = getClassInfoRegistry ( ) . getCLInfo ( clazz , conf ) ; 
referencee . lastInfo = serializationInfo ; 
} 
return serializationInfo ; 
} 
} 

public class FSTObjectOutput { 
protected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { 
if ( array == null ) { 
getCodec ( ) . writeClass ( Object . class ) ; 
getCodec ( ) . writeFInt ( - 1 ) ; 
return ; 
} 
final int len = Array . getLength ( array ) ; 
Class < ? > componentType = array . getClass ( ) . getComponentType ( ) ; 
getCodec ( ) . writeClass ( array . getClass ( ) ) ; 
getCodec ( ) . writeFInt ( len ) ; 
if ( ! componentType . isArray ( ) ) if ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) getCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; 
else { 
Object arr [ ] = ( Object [ ] ) array ; 
Class lastClz = null ; 
FSTClazzInfo lastInfo = null ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
Object toWrite = arr [ i ] ; 
if ( toWrite != null ) { 
lastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; 
lastClz = toWrite . getClass ( ) ; 
} 
else writeObjectWithContext ( referencee , toWrite , null ) ; 
} 
} 
else { 
Object [ ] arr = ( Object [ ] ) array ; 
FSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
Object subArr = arr [ i ] ; 
boolean needsWrite = true ; 
if ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) if ( subArr == null ) needsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; 
else needsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; 
if ( needsWrite ) { 
writeArray ( ref1 , subArr ) ; 
getCodec ( ) . writeArrayEnd ( ) ; 
} 
} 
} 
} 
} 

public class StructString { 
public void setString ( String s ) { 
if ( s == null ) { 
setLen ( 0 ) ; 
return ; 
} 
if ( s . length ( ) > charsLen ( ) ) throw new RuntimeException ( "String length exceeds buffer size. String len " + s . length ( ) + " charsLen:" + charsLen ( ) ) ; 
for ( int i = 0 ; 
i < s . length ( ) ; 
i ++ ) chars ( i , s . charAt ( i ) ) ; 
len = s . length ( ) ; 
} 
} 

public class FSTStructChange { 
public void snapshotChanges ( int originBase , Bytez origin ) { 
int sumLen = 0 ; 
for ( int i = 0 ; 
i < curIndex ; 
i ++ ) sumLen += changeLength [ i ] ; 
snapshot = new byte [ sumLen ] ; 
int targetIdx = 0 ; 
for ( int i = 0 ; 
i < curIndex ; 
i ++ ) { 
int changeOffset = changeOffsets [ i ] ; 
int len = changeLength [ i ] ; 
for ( int ii = 0 ; 
ii < len ; 
ii ++ ) snapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; 
} 
rebase ( originBase ) ; 
} 
} 

public class FSTObjectRegistry { 
public int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { 
if ( disabled ) return Integer . MIN_VALUE ; 
if ( clzInfo == null ) { 
} 
else if ( clzInfo . isFlat ( ) ) return Integer . MIN_VALUE ; 
int handle = objects . putOrGet ( o , streamPosition ) ; 
if ( handle >= 0 ) { 
reUseType [ 0 ] = 0 ; 
return handle ; 
} 
return Integer . MIN_VALUE ; 
} 
} 

public class BinaryQueue { 
public byte [ ] readByteArray ( int len ) { 
if ( available ( ) < len ) throw new RuntimeException ( "not enough data available, check available() > len before calling" ) ; 
byte b [ ] = new byte [ len ] ; 
int count = 0 ; 
while ( pollIndex != addIndex && count < len ) { 
b [ count ++ ] = storage . get ( pollIndex ++ ) ; 
if ( pollIndex >= storage . length ( ) ) pollIndex = 0 ; 
} 
return b ; 
} 
} 

public class BinaryQueue { 
public int readInt ( ) { 
if ( available ( ) < 4 ) throw new RuntimeException ( "not enough data available, check available() > 4 before calling" ) ; 
int ch1 = poll ( ) ; 
int ch2 = poll ( ) ; 
int ch3 = poll ( ) ; 
int ch4 = poll ( ) ; 
return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; 
} 
} 

public class HproseTcpServer { 
public void setThreadPoolEnabled ( boolean value ) { 
if ( value && ( threadPool == null ) ) threadPool = Executors . newCachedThreadPool ( ) ; 
threadPoolEnabled = value ; 
} 
} 

public class EmbeddedCassandraServerHelper { 
public static void startEmbeddedCassandra ( File file , String tmpDir , long timeout ) throws IOException , ConfigurationException { 
if ( cassandraDaemon != null ) return ; 
checkConfigNameForRestart ( file . getAbsolutePath ( ) ) ; 
log . debug ( "Starting cassandra..." ) ; 
log . debug ( "Initialization needed" ) ; 
System . setProperty ( "cassandra.config" , "file:" + file . getAbsolutePath ( ) ) ; 
System . setProperty ( "cassandra-foreground" , "true" ) ; 
System . setProperty ( "cassandra.native.epoll.enabled" , "false" ) ; 
System . setProperty ( "cassandra.unsafesystem" , "true" ) ; 
if ( System . getProperty ( "log4j.configuration" ) == null ) { 
copy ( DEFAULT_LOG4J_CONFIG_FILE , tmpDir ) ; 
System . setProperty ( "log4j.configuration" , "file:" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE ) ; 
} 
DatabaseDescriptor . daemonInitialization ( ) ; 
cleanupAndLeaveDirs ( ) ; 
final CountDownLatch startupLatch = new CountDownLatch ( 1 ) ; 
ExecutorService executor = Executors . newSingleThreadExecutor ( ) ; 
executor . execute ( ( ) -> { 
cassandraDaemon = new CassandraDaemon ( ) ; 
cassandraDaemon . activate ( ) ; 
startupLatch . countDown ( ) ; 
} 
) ; 
try { 
if ( ! startupLatch . await ( timeout , MILLISECONDS ) ) { 
log . error ( "Cassandra daemon did not start after " + timeout + " ms. Consider increasing the timeout" ) ; 
throw new AssertionError ( "Cassandra daemon did not start within timeout" ) ; 
} 
Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ( ) -> { 
if ( session != null ) session . close ( ) ; 
if ( cluster != null ) cluster . close ( ) ; 
} 
) ) ; 
} 
catch ( InterruptedException e ) { 
log . error ( "Interrupted waiting for Cassandra daemon to start:" , e ) ; 
throw new AssertionError ( e ) ; 
} 
finally { 
executor . shutdown ( ) ; 
} 
} 
} 

public class EmbeddedCassandraServerHelper { 
public static void cleanDataEmbeddedCassandra ( String keyspace , String ... excludedTables ) { 
if ( session != null ) cleanDataWithNativeDriver ( keyspace , excludedTables ) ; 
} 
} 

public class ReflectionUtils { 
public static void printThreadInfo ( PrintWriter stream , String title ) { 
final int STACK_DEPTH = 20 ; 
boolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; 
long [ ] threadIds = threadBean . getAllThreadIds ( ) ; 
stream . println ( "Process Thread Dump: " + title ) ; 
stream . println ( threadIds . length + " active threads" ) ; 
for ( long tid : threadIds ) { 
ThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; 
if ( info == null ) { 
stream . println ( "  Inactive" ) ; 
continue ; 
} 
stream . println ( "Thread " + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + ":" ) ; 
Thread . State state = info . getThreadState ( ) ; 
stream . println ( "  State: " + state ) ; 
stream . println ( "  Blocked count: " + info . getBlockedCount ( ) ) ; 
stream . println ( "  Waited count: " + info . getWaitedCount ( ) ) ; 
if ( contention ) { 
stream . println ( "  Blocked time: " + info . getBlockedTime ( ) ) ; 
stream . println ( "  Waited time: " + info . getWaitedTime ( ) ) ; 
} 
if ( state == Thread . State . WAITING ) stream . println ( "  Waiting on " + info . getLockName ( ) ) ; 
else if ( state == Thread . State . BLOCKED ) { 
stream . println ( "  Blocked on " + info . getLockName ( ) ) ; 
stream . println ( "  Blocked by " + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; 
} 
stream . println ( "  Stack:" ) ; 
for ( StackTraceElement frame : info . getStackTrace ( ) ) { 
stream . println ( "    " + frame . toString ( ) ) ; 
} 
} 
stream . flush ( ) ; 
} 
} 

public class CheckSocket { 
public static boolean remotePortTaken ( String node , int port , int timeout ) { 
Socket s = null ; 
try { 
s = new Socket ( ) ; 
s . setReuseAddress ( true ) ; 
SocketAddress sa = new InetSocketAddress ( node , port ) ; 
s . connect ( sa , timeout * 1000 ) ; 
} 
catch ( IOException e ) { 
if ( e . getMessage ( ) . equals ( "Connection refused" ) ) return false ; 
if ( e instanceof SocketTimeoutException || e instanceof UnknownHostException ) throw e ; 
} 
finally { 
if ( s != null ) { 
if ( s . isConnected ( ) ) return true ; 
else { 
} 
try { 
s . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
return false ; 
} 
} 
} 

public class BooleanIndexing { 
public static boolean or ( IComplexNDArray n , Condition cond ) { 
boolean ret = false ; 
IComplexNDArray linear = n . linearView ( ) ; 
for ( int i = 0 ; 
i < linear . length ( ) ; 
i ++ ) ret = ret || cond . apply ( linear . getComplex ( i ) ) ; 
return ret ; 
} 
} 

public class BooleanIndexing { 
public static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { 
if ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( "Only static Conditions are supported" ) ; 
MatchCondition op = new MatchCondition ( n , condition ) ; 
INDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; 
boolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; 
long tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; 
for ( int i = 0 ; 
i < arr . length ( ) ; 
i ++ ) if ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; 
else result [ i ] = false ; 
return result ; 
} 
} 

public class BooleanIndexing { 
public static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { 
if ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( "Only static Conditions are supported" ) ; 
MatchCondition op = new MatchCondition ( n , condition ) ; 
INDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; 
boolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; 
for ( int i = 0 ; 
i < arr . length ( ) ; 
i ++ ) if ( arr . getDouble ( i ) > 0 ) result [ i ] = true ; 
else result [ i ] = false ; 
return result ; 
} 
} 

public class BooleanIndexing { 
public static void applyWhere ( final INDArray to , final Condition condition , final Number number ) { 
if ( condition instanceof BaseCondition ) Nd4j . getExecutioner ( ) . exec ( new CompareAndSet ( to , number . doubleValue ( ) , condition ) ) ; 
else { 
final double value = number . doubleValue ( ) ; 
final Function < Number , Number > dynamic = new Function < Number , Number > ( ) { 
@ Override public Number apply ( Number number ) { 
return value ; 
} 
} 
; 
Shape . iterate ( to , new CoordinateFunction ( ) { 
@ Override public void process ( long [ ] ... coord ) { 
if ( condition . apply ( to . getDouble ( coord [ 0 ] ) ) ) to . putScalar ( coord [ 0 ] , dynamic . apply ( to . getDouble ( coord [ 0 ] ) ) . doubleValue ( ) ) ; 
} 
} 
) ; 
} 
} 
} 

public class BaseNDArrayFactory { 
protected static void validateConcat ( int dimension , INDArray ... arrs ) { 
if ( arrs [ 0 ] . isScalar ( ) ) for ( int i = 1 ; 
i < arrs . length ; 
i ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( "All arrays must have same dimensions" ) ; 
else { 
int dims = arrs [ 0 ] . shape ( ) . length ; 
long [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; 
for ( int i = 1 ; 
i < arrs . length ; 
i ++ ) { 
assert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; 
assert arrs [ i ] . shape ( ) . length == dims ; 
} 
} 
} 
} 

public class BaseNDArrayFactory { 
@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { 
assert curr . shape ( ) . length == 3 ; 
if ( in . columns ( ) != 1 ) throw new AssertionError ( "Expected a column vector" ) ; 
if ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) throw new AssertionError ( "Number of rows in the input does not match number of columns in tensor" ) ; 
if ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) throw new AssertionError ( "Can only perform this operation on a SimpleTensor with square slices" ) ; 
INDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; 
INDArray inT = in . transpose ( ) ; 
for ( int i = 0 ; 
i < curr . slices ( ) ; 
i ++ ) { 
INDArray slice = curr . slice ( i ) ; 
INDArray inTTimesSlice = inT . mmul ( slice ) ; 
ret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; 
} 
return ret ; 
} 
} 

public class StringUtils { 
public static String simpleHostname ( String fullHostname ) { 
if ( InetAddresses . isInetAddress ( fullHostname ) ) return fullHostname ; 
int offset = fullHostname . indexOf ( '.' ) ; 
if ( offset != - 1 ) return fullHostname . substring ( 0 , offset ) ; 
return fullHostname ; 
} 
} 

public class StringUtils { 
public static String arrayToString ( String [ ] strs ) { 
if ( strs . length == 0 ) return "" ; 
StringBuilder sbuf = new StringBuilder ( ) ; 
sbuf . append ( strs [ 0 ] ) ; 
for ( int idx = 1 ; 
idx < strs . length ; 
idx ++ ) { 
sbuf . append ( "," ) ; 
sbuf . append ( strs [ idx ] ) ; 
} 
return sbuf . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String byteToHexString ( byte [ ] bytes , int start , int end ) { 
if ( bytes == null ) throw new IllegalArgumentException ( "bytes == null" ) ; 
StringBuilder s = new StringBuilder ( ) ; 
for ( int i = start ; 
i < end ; 
i ++ ) s . append ( format ( "%02x" , bytes [ i ] ) ) ; 
return s . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String [ ] getStrings ( String str , String delim ) { 
Collection < String > values = getStringCollection ( str , delim ) ; 
if ( values . size ( ) == 0 ) return null ; 
return values . toArray ( new String [ values . size ( ) ] ) ; 
} 
} 

public class StringUtils { 
public static String [ ] split ( String str , char escapeChar , char separator ) { 
if ( str == null ) return null ; 
ArrayList < String > strList = new ArrayList < String > ( ) ; 
StringBuilder split = new StringBuilder ( ) ; 
int index = 0 ; 
while ( ( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ) { 
++ index ; 
strList . add ( split . toString ( ) ) ; 
split . setLength ( 0 ) ; 
} 
strList . add ( split . toString ( ) ) ; 
int last = strList . size ( ) ; 
while ( -- last >= 0 && "" . equals ( strList . get ( last ) ) ) strList . remove ( last ) ; 
return strList . toArray ( new String [ strList . size ( ) ] ) ; 
} 
} 

public class StringUtils { 
public static String [ ] split ( String str , char separator ) { 
if ( str . isEmpty ( ) ) return new String [ ] { 
"" } 
; 
ArrayList < String > strList = new ArrayList < String > ( ) ; 
int startIndex = 0 ; 
int nextIndex = 0 ; 
while ( ( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ) { 
strList . add ( str . substring ( startIndex , nextIndex ) ) ; 
startIndex = nextIndex + 1 ; 
} 
strList . add ( str . substring ( startIndex ) ) ; 
int last = strList . size ( ) ; 
while ( -- last >= 0 && "" . equals ( strList . get ( last ) ) ) strList . remove ( last ) ; 
return strList . toArray ( new String [ strList . size ( ) ] ) ; 
} 
} 

public class StringUtils { 
public static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { 
int numPreEscapes = 0 ; 
for ( int i = start ; 
i < str . length ( ) ; 
i ++ ) { 
char curChar = str . charAt ( i ) ; 
if ( numPreEscapes == 0 && curChar == separator ) return i ; 
else { 
split . append ( curChar ) ; 
numPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; 
} 
} 
return - 1 ; 
} 
} 

public class StringUtils { 
public static String escapeHTML ( String string ) { 
if ( string == null ) return null ; 
StringBuilder sb = new StringBuilder ( ) ; 
boolean lastCharacterWasSpace = false ; 
char [ ] chars = string . toCharArray ( ) ; 
for ( char c : chars ) { 
if ( c == ' ' ) if ( lastCharacterWasSpace ) { 
lastCharacterWasSpace = false ; 
sb . append ( "&nbsp;" ) ; 
} 
else { 
lastCharacterWasSpace = true ; 
sb . append ( " " ) ; 
} 
else { 
lastCharacterWasSpace = false ; 
switch ( c ) { 
case '<' : sb . append ( "&lt;" ) ; 
break ; 
case '>' : sb . append ( "&gt;" ) ; 
break ; 
case '&' : sb . append ( "&amp;" ) ; 
break ; 
case '"' : sb . append ( "&quot;" ) ; 
break ; 
default : sb . append ( c ) ; 
break ; 
} 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String join ( CharSequence separator , Iterable < ? > strings ) { 
Iterator < ? > i = strings . iterator ( ) ; 
if ( ! i . hasNext ( ) ) return "" ; 
StringBuilder sb = new StringBuilder ( i . next ( ) . toString ( ) ) ; 
while ( i . hasNext ( ) ) { 
sb . append ( separator ) ; 
sb . append ( i . next ( ) . toString ( ) ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String replaceTokens ( String template , Pattern pattern , Map < String , String > replacements ) { 
StringBuffer sb = new StringBuffer ( ) ; 
Matcher matcher = pattern . matcher ( template ) ; 
while ( matcher . find ( ) ) { 
String replacement = replacements . get ( matcher . group ( 1 ) ) ; 
if ( replacement == null ) replacement = "" ; 
matcher . appendReplacement ( sb , Matcher . quoteReplacement ( replacement ) ) ; 
} 
matcher . appendTail ( sb ) ; 
return sb . toString ( ) ; 
} 
} 

public class InvertMatrix { 
public static INDArray invert ( INDArray arr , boolean inPlace ) { 
if ( ! arr . isSquare ( ) ) throw new IllegalArgumentException ( "invalid array: must be square matrix" ) ; 
RealMatrix rm = CheckUtil . convertToApacheMatrix ( arr ) ; 
RealMatrix rmInverse = new LUDecomposition ( rm ) . getSolver ( ) . getInverse ( ) ; 
INDArray inverse = CheckUtil . convertFromApacheMatrix ( rmInverse ) ; 
if ( inPlace ) arr . assign ( inverse ) ; 
return inverse ; 
} 
} 

public class BaseDataBuffer { 
@ Override public DataBuffer reallocate ( long length ) { 
Pointer oldPointer = pointer ; 
if ( isAttached ( ) ) { 
long capacity = length * getElementSize ( ) ; 
switch ( dataType ( ) ) { 
case DOUBLE : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . DOUBLE , false ) . asDoublePointer ( ) ; 
indexer = DoubleIndexer . create ( ( DoublePointer ) pointer ) ; 
break ; 
case FLOAT : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . FLOAT , false ) . asFloatPointer ( ) ; 
indexer = FloatIndexer . create ( ( FloatPointer ) pointer ) ; 
break ; 
case INT : pointer = getParentWorkspace ( ) . alloc ( capacity , Type . INT , false ) . asIntPointer ( ) ; 
indexer = IntIndexer . create ( ( IntPointer ) pointer ) ; 
break ; 
} 
workspaceGenerationId = getParentWorkspace ( ) . getGenerationId ( ) ; 
} 
else switch ( dataType ( ) ) { 
case INT : pointer = new IntPointer ( length ) ; 
indexer = IntIndexer . create ( ( IntPointer ) pointer ) ; 
break ; 
case DOUBLE : pointer = new DoublePointer ( length ) ; 
indexer = DoubleIndexer . create ( ( DoublePointer ) pointer ) ; 
break ; 
case FLOAT : pointer = new FloatPointer ( length ) ; 
indexer = FloatIndexer . create ( ( FloatPointer ) pointer ) ; 
break ; 
} 
Pointer . memcpy ( pointer , oldPointer , this . length ( ) * getElementSize ( ) ) ; 
return this ; 
} 
} 

public class NioUtil { 
public static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { 
ByteBuffer fromView = from ; 
ByteBuffer toView = to ; 
fromView . order ( ByteOrder . nativeOrder ( ) ) ; 
toView . order ( ByteOrder . nativeOrder ( ) ) ; 
switch ( bufferType ) { 
case INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; 
IntBuffer toInt = toView . asIntBuffer ( ) ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) { 
int put = fromInt . get ( fromOffset + i * fromStride ) ; 
toInt . put ( toOffset + i * toStride , put ) ; 
} 
break ; 
case FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; 
FloatBuffer toFloat = toView . asFloatBuffer ( ) ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) { 
float put = fromFloat . get ( fromOffset + i * fromStride ) ; 
toFloat . put ( toOffset + i * toStride , put ) ; 
} 
break ; 
case DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; 
DoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) toDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; 
break ; 
default : throw new IllegalArgumentException ( "Only floats and double supported" ) ; 
} 
} 
} 

public class Transforms { 
public static INDArray max ( INDArray first , INDArray second , boolean dup ) { 
if ( dup ) first = first . dup ( ) ; 
return exec ( new OldMax ( second , first , first , first . length ( ) ) ) ; 
} 
} 

public class Transforms { 
public static INDArray min ( INDArray first , INDArray second , boolean dup ) { 
if ( dup ) first = first . dup ( ) ; 
return exec ( new OldMin ( second , first , first , first . length ( ) ) ) ; 
} 
} 

public class TwoPointApproximation { 
public static INDArray [ ] adjustSchemeToBounds ( INDArray x , INDArray h , int numSteps , INDArray lowerBound , INDArray upperBound ) { 
INDArray oneSided = Nd4j . onesLike ( h ) ; 
if ( and ( lowerBound . eq ( Double . NEGATIVE_INFINITY ) , upperBound . eq ( Double . POSITIVE_INFINITY ) ) . sumNumber ( ) . doubleValue ( ) > 0 ) return new INDArray [ ] { 
h , oneSided } 
; 
INDArray hTotal = h . mul ( numSteps ) ; 
INDArray hAdjusted = h . dup ( ) ; 
INDArray lowerDist = x . sub ( lowerBound ) ; 
INDArray upperBound2 = upperBound . sub ( x ) ; 
INDArray central = and ( greaterThanOrEqual ( lowerDist , hTotal ) , greaterThanOrEqual ( upperBound2 , hTotal ) ) ; 
INDArray forward = and ( greaterThanOrEqual ( upperBound , lowerDist ) , not ( central ) ) ; 
hAdjusted . put ( forward , min ( h . get ( forward ) , upperBound2 . get ( forward ) . mul ( 0.5 ) . divi ( numSteps ) ) ) ; 
oneSided . put ( forward , Nd4j . scalar ( 1.0 ) ) ; 
INDArray backward = and ( upperBound2 . lt ( lowerBound ) , not ( central ) ) ; 
hAdjusted . put ( backward , min ( h . get ( backward ) , lowerDist . get ( backward ) . mul ( 0.5 ) . divi ( numSteps ) ) ) ; 
oneSided . put ( backward , Nd4j . scalar ( 1.0 ) ) ; 
INDArray minDist = min ( upperBound2 , lowerDist ) . divi ( numSteps ) ; 
INDArray adjustedCentral = and ( not ( central ) , lessThanOrEqual ( abs ( hAdjusted ) , minDist ) ) ; 
hAdjusted . put ( adjustedCentral , minDist . get ( adjustedCentral ) ) ; 
oneSided . put ( adjustedCentral , Nd4j . scalar ( 0.0 ) ) ; 
return new INDArray [ ] { 
hAdjusted , oneSided } 
; 
} 
} 

public class CpuLapack { 
@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { 
INDArray tau = Nd4j . create ( N ) ; 
int status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; 
if ( status != 0 ) throw new BlasException ( "Failed to execute sgeqrf" , status ) ; 
if ( R != null ) { 
R . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; 
INDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; 
for ( int i = 1 ; 
i < Math . min ( A . rows ( ) , A . columns ( ) ) ; 
i ++ ) { 
ix [ 0 ] = NDArrayIndex . point ( i ) ; 
ix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; 
R . put ( ix , 0 ) ; 
} 
} 
status = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; 
if ( status != 0 ) throw new BlasException ( "Failed to execute sorgqr" , status ) ; 
} 
} 

public class JCublasNDArrayFactory { 
@ Override public INDArray createFromNpyPointer ( Pointer pointer ) { 
Pointer dataPointer = nativeOps . dataPointForNumpy ( pointer ) ; 
int dataBufferElementSize = nativeOps . elementSizeForNpyArray ( pointer ) ; 
DataBuffer data = null ; 
Pointer shapeBufferPointer = nativeOps . shapeBufferForNumpy ( pointer ) ; 
int length = nativeOps . lengthForShapeBufferPointer ( shapeBufferPointer ) ; 
shapeBufferPointer . capacity ( 4 * length ) ; 
shapeBufferPointer . limit ( 4 * length ) ; 
shapeBufferPointer . position ( 0 ) ; 
val intPointer = new LongPointer ( shapeBufferPointer ) ; 
DataBuffer shapeBuffer = Nd4j . createBuffer ( shapeBufferPointer , DataBuffer . Type . LONG , length , LongRawIndexer . create ( intPointer ) ) ; 
dataPointer . position ( 0 ) ; 
dataPointer . limit ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; 
dataPointer . capacity ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; 
if ( dataBufferElementSize == ( Float . SIZE / 8 ) ) data = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . FLOAT , Shape . length ( shapeBuffer ) , FloatIndexer . create ( new FloatPointer ( dataPointer ) ) ) ; 
else if ( dataBufferElementSize == ( Double . SIZE / 8 ) ) data = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . DOUBLE , Shape . length ( shapeBuffer ) , DoubleIndexer . create ( new DoublePointer ( dataPointer ) ) ) ; 
INDArray ret = Nd4j . create ( data , Shape . shape ( shapeBuffer ) , Shape . strideArr ( shapeBuffer ) , Shape . offset ( shapeBuffer ) , Shape . order ( shapeBuffer ) ) ; 
return ret ; 
} 
} 

public class CudaGridExecutioner { 
@ Override public Op exec ( Op op ) { 
checkForCompression ( op ) ; 
invokeWatchdog ( op ) ; 
if ( op instanceof Accumulation ) exec ( ( Accumulation ) op , new int [ ] { 
Integer . MAX_VALUE } 
) ; 
else if ( op instanceof IndexAccumulation ) exec ( ( IndexAccumulation ) op , new int [ ] { 
Integer . MAX_VALUE } 
) ; 
else if ( op instanceof ScalarOp || op instanceof TransformOp ) processAsGridOp ( op ) ; 
else if ( op instanceof BroadcastOp ) invoke ( ( BroadcastOp ) op ) ; 
else pushToGrid ( new OpDescriptor ( op ) ) ; 
return op ; 
} 
} 

public class JarResource { 
public InputStream getInputStream ( ) throws FileNotFoundException { 
URL url = this . getUrl ( ) ; 
if ( isJarURL ( url ) ) try { 
url = extractActualUrl ( url ) ; 
ZipFile zipFile = new ZipFile ( url . getFile ( ) ) ; 
ZipEntry entry = zipFile . getEntry ( this . resourceName ) ; 
InputStream stream = zipFile . getInputStream ( entry ) ; 
return stream ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
else { 
File srcFile = this . getFile ( ) ; 
return new FileInputStream ( srcFile ) ; 
} 
} 
} 

public class CudaAffinityManager { 
protected Integer getNextDevice ( long threadId ) { 
Integer device = null ; 
if ( ! CudaEnvironment . getInstance ( ) . getConfiguration ( ) . isForcedSingleGPU ( ) && getNumberOfDevices ( ) > 0 ) synchronized ( this ) { 
device = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( devPtr . getAndIncrement ( ) ) ; 
if ( devPtr . get ( ) >= CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) devPtr . set ( 0 ) ; 
logger . debug ( "Mapping thread [{}] to device [{}], out of [{}] devices..." , threadId , device , CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) ; 
} 
else { 
device = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( 0 ) ; 
logger . debug ( "Single device is forced, mapping to device [{}]" , device ) ; 
} 
return device ; 
} 
} 

public class LibUtils { 
public static ARCHType calculateArch ( ) { 
String osArch = System . getProperty ( "os.arch" ) ; 
osArch = osArch . toLowerCase ( Locale . ENGLISH ) ; 
if ( osArch . equals ( "i386" ) || osArch . equals ( "x86" ) || osArch . equals ( "i686" ) ) return ARCHType . X86 ; 
if ( osArch . startsWith ( "amd64" ) || osArch . startsWith ( "x86_64" ) ) return ARCHType . X86_64 ; 
if ( osArch . equals ( "ppc" ) || osArch . equals ( "powerpc" ) ) return ARCHType . PPC ; 
if ( osArch . startsWith ( "ppc" ) ) return ARCHType . PPC_64 ; 
if ( osArch . startsWith ( "sparc" ) ) return ARCHType . SPARC ; 
if ( osArch . startsWith ( "arm" ) ) return ARCHType . ARM ; 
if ( osArch . startsWith ( "mips" ) ) return ARCHType . MIPS ; 
if ( osArch . contains ( "risc" ) ) return ARCHType . RISC ; 
return ARCHType . UNKNOWN ; 
} 
} 

public class DistributedAssignMessage { 
@ Override public void processMessage ( ) { 
if ( payload != null ) if ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) storage . getArray ( key ) . assign ( payload ) ; 
else storage . setArray ( key , payload ) ; 
else if ( index >= 0 ) { 
if ( storage . getArray ( key ) == null ) throw new RuntimeException ( "Init wasn't called before for key [" + key + "]" ) ; 
storage . getArray ( key ) . getRow ( index ) . assign ( value ) ; 
} 
else storage . getArray ( key ) . assign ( value ) ; 
} 
} 

public class OpProfiler { 
protected String getOpClass ( Op op ) { 
if ( op instanceof ScalarOp ) return "ScalarOp" ; 
else if ( op instanceof MetaOp ) return "MetaOp" ; 
else if ( op instanceof GridOp ) return "GridOp" ; 
else if ( op instanceof BroadcastOp ) return "BroadcastOp" ; 
else if ( op instanceof RandomOp ) return "RandomOp" ; 
else if ( op instanceof Accumulation ) return "AccumulationOp" ; 
else if ( op instanceof TransformOp ) if ( op . y ( ) == null ) return "TransformOp" ; 
else return "PairWiseTransformOp" ; 
else if ( op instanceof IndexAccumulation ) return "IndexAccumulationOp" ; 
else if ( op instanceof CustomOp ) return "CustomOp" ; 
else return "Unknown Op calls" ; 
} 
} 

public class SDVariable { 
public INDArray storeAndAllocateNewArray ( ) { 
val shape = sameDiff . getShapeForVarName ( getVarName ( ) ) ; 
if ( getArr ( ) != null && Arrays . equals ( getArr ( ) . shape ( ) , shape ) ) return getArr ( ) ; 
if ( varName == null ) throw new ND4JIllegalStateException ( "Unable to store array for null variable name!" ) ; 
if ( shape == null ) throw new ND4JIllegalStateException ( "Unable to allocate new array. No shape found for variable " + varName ) ; 
val arr = getWeightInitScheme ( ) . create ( shape ) ; 
sameDiff . putArrayForVarName ( getVarName ( ) , arr ) ; 
return arr ; 
} 
} 

public class ComplexNDArrayUtil { 
public static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { 
if ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; 
for ( int i = 0 ; 
i < shape . length ; 
i ++ ) if ( shape [ i ] < 1 ) shape [ i ] = 1 ; 
INDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; 
INDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; 
INDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; 
INDArray endIndex = startIndex . add ( shapeMatrix ) ; 
INDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; 
if ( shapeMatrix . length ( ) > 1 ) return arr . get ( indexes ) ; 
else { 
IComplexNDArray ret = Nd4j . createComplex ( new int [ ] { 
( int ) shapeMatrix . getDouble ( 0 ) } 
) ; 
int start = ( int ) startIndex . getDouble ( 0 ) ; 
int end = ( int ) endIndex . getDouble ( 0 ) ; 
int count = 0 ; 
for ( int i = start ; 
i < end ; 
i ++ ) ret . putScalar ( count ++ , arr . getComplex ( i ) ) ; 
return ret ; 
} 
} 
} 

public class DeviceLocalNDArray { 
public void broadcast ( INDArray array ) { 
if ( array == null ) return ; 
Nd4j . getExecutioner ( ) . commit ( ) ; 
int numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; 
for ( int i = 0 ; 
i < numDevices ; 
i ++ ) if ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) set ( i , array ) ; 
else set ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; 
} 
} 

public class BigDecimalMath { 
static public BigDecimal gamma ( MathContext mc ) { 
if ( mc . getPrecision ( ) < GAMMA . precision ( ) ) return GAMMA . round ( mc ) ; 
else { 
double eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; 
MathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; 
BigDecimal resul = BigDecimal . ONE ; 
resul = resul . add ( log ( 2 , mcloc ) ) ; 
resul = resul . subtract ( log ( 3 , mcloc ) ) ; 
int kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; 
mcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; 
for ( int n = 1 ; 
; 
n ++ ) { 
BigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; 
BigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; 
fourn = fourn . shiftLeft ( 2 * n ) ; 
c = divideRound ( c , fourn ) ; 
resul = resul . subtract ( c ) ; 
if ( c . doubleValue ( ) < 0.1 * eps ) break ; 
} 
return resul . round ( mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal sqrt ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) throw new ArithmeticException ( "negative argument " + x . toString ( ) + " of square root" ) ; 
return root ( 2 , x ) ; 
} 
} 

public class BigDecimalMath { 
static public BigDecimal cbrt ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return root ( 3 , x . negate ( ) ) . negate ( ) ; 
else return root ( 3 , x ) ; 
} 
} 

public class BigDecimalMath { 
static public BigDecimal root ( final int n , final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) throw new ArithmeticException ( "negative argument " + x . toString ( ) + " of root" ) ; 
if ( n <= 0 ) throw new ArithmeticException ( "negative power " + n + " of root" ) ; 
if ( n == 1 ) return x ; 
BigDecimal s = new BigDecimal ( Math . pow ( x . doubleValue ( ) , 1.0 / n ) ) ; 
final BigDecimal nth = new BigDecimal ( n ) ; 
final BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
MathContext mc = new MathContext ( 2 + x . precision ( ) ) ; 
final double eps = x . ulp ( ) . doubleValue ( ) / ( 2 * n * x . doubleValue ( ) ) ; 
for ( ; 
; 
) { 
BigDecimal c = xhighpr . divide ( s . pow ( n - 1 ) , mc ) ; 
c = s . subtract ( c ) ; 
MathContext locmc = new MathContext ( c . precision ( ) ) ; 
c = c . divide ( nth , locmc ) ; 
s = s . subtract ( c ) ; 
if ( Math . abs ( c . doubleValue ( ) / s . doubleValue ( ) ) < eps ) break ; 
} 
return s . round ( new MathContext ( err2prec ( eps ) ) ) ; 
} 
} 

public class BigDecimalMath { 
static public BigDecimal exp ( BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
final BigDecimal invx = exp ( x . negate ( ) ) ; 
MathContext mc = new MathContext ( invx . precision ( ) ) ; 
return BigDecimal . ONE . divide ( invx , mc ) ; 
} 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; 
else { 
final double xDbl = x . doubleValue ( ) ; 
final double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; 
if ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { 
BigDecimal resul = BigDecimal . ONE ; 
BigDecimal xpowi = BigDecimal . ONE ; 
BigInteger ifac = BigInteger . ONE ; 
MathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; 
for ( int i = 1 ; 
i <= TAYLOR_NTERM ; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; 
xpowi = xpowi . multiply ( x ) ; 
final BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( c ) ; 
if ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) break ; 
} 
MathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; 
return resul . round ( mc ) ; 
} 
else { 
int exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; 
BigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; 
BigDecimal expxby10 = exp ( xby10 ) ; 
MathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; 
while ( exSc > 0 ) { 
int exsub = Math . min ( 8 , exSc ) ; 
exSc -= exsub ; 
MathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; 
int pex = 1 ; 
while ( exsub -- > 0 ) pex *= 10 ; 
expxby10 = expxby10 . pow ( pex , mctmp ) ; 
} 
return expxby10 . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal exp ( final MathContext mc ) { 
if ( mc . getPrecision ( ) < E . precision ( ) ) return E . round ( mc ) ; 
else { 
BigDecimal uni = scalePrec ( BigDecimal . ONE , mc . getPrecision ( ) ) ; 
return exp ( uni ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal pow ( final BigDecimal x , final BigDecimal y ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) throw new ArithmeticException ( "Cannot power negative " + x . toString ( ) ) ; 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; 
else { 
BigDecimal logx = log ( x ) ; 
BigDecimal ylogx = y . multiply ( logx ) ; 
BigDecimal resul = exp ( ylogx ) ; 
double errR = Math . abs ( logx . doubleValue ( ) * y . ulp ( ) . doubleValue ( ) / 2. ) + Math . abs ( y . doubleValue ( ) * x . ulp ( ) . doubleValue ( ) / 2. / x . doubleValue ( ) ) ; 
MathContext mcR = new MathContext ( err2prec ( 1.0 , errR ) ) ; 
return resul . round ( mcR ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal sin ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return sin ( x . negate ( ) ) . negate ( ) ; 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; 
else { 
BigDecimal res = mod2pi ( x ) ; 
double errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; 
int val = 2 + err2prec ( FastMath . PI , errpi ) ; 
MathContext mc = new MathContext ( val ) ; 
BigDecimal p = pi ( mc ) ; 
mc = new MathContext ( x . precision ( ) ) ; 
if ( res . compareTo ( p ) > 0 ) return sin ( subtractRound ( res , p ) ) . negate ( ) ; 
else if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) return sin ( subtractRound ( p , res ) ) ; 
else if ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) return cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; 
else { 
BigDecimal resul = res ; 
BigDecimal xpowi = res ; 
BigInteger ifac = BigInteger . ONE ; 
double xUlpDbl = res . ulp ( ) . doubleValue ( ) ; 
int k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; 
MathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; 
for ( int i = 1 ; 
; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; 
xpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; 
BigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( corr ) ; 
if ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) break ; 
} 
mc = new MathContext ( res . precision ( ) ) ; 
return resul . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal tan ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; 
else if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return tan ( x . negate ( ) ) . negate ( ) ; 
else { 
BigDecimal res = modpi ( x ) ; 
final double xDbl = res . doubleValue ( ) ; 
final double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; 
final double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; 
if ( xDbl > 0.8 ) { 
BigDecimal co = cot ( x ) ; 
MathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; 
return BigDecimal . ONE . divide ( co , mc ) ; 
} 
else { 
final BigDecimal xhighpr = scalePrec ( res , 2 ) ; 
final BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; 
BigDecimal result = xhighpr . plus ( ) ; 
BigDecimal xpowi = xhighpr ; 
Bernoulli b = new Bernoulli ( ) ; 
BigInteger fourn = BigInteger . valueOf ( 4 ) ; 
BigInteger fac = BigInteger . valueOf ( 2 ) ; 
for ( int i = 2 ; 
; 
i ++ ) { 
Rational f = b . at ( 2 * i ) . abs ( ) ; 
fourn = fourn . shiftLeft ( 2 ) ; 
fac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; 
f = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; 
xpowi = multiplyRound ( xpowi , xhighprSq ) ; 
BigDecimal c = multiplyRound ( xpowi , f ) ; 
result = result . add ( c ) ; 
if ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) break ; 
} 
MathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; 
return result . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal cosh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return cos ( x . negate ( ) ) ; 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ONE ; 
else if ( x . doubleValue ( ) > 1.5 ) return hypot ( 1 , sinh ( x ) ) ; 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal resul = BigDecimal . ONE ; 
BigDecimal xpowi = BigDecimal . ONE ; 
BigInteger ifac = BigInteger . ONE ; 
double xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; 
int k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; 
MathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; 
for ( int i = 1 ; 
; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; 
xpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; 
BigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( corr ) ; 
if ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) break ; 
} 
MathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; 
return resul . round ( mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal sinh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return sinh ( x . negate ( ) ) . negate ( ) ; 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; 
else if ( x . doubleValue ( ) > 2.4 ) { 
BigDecimal two = new BigDecimal ( 2 ) ; 
BigDecimal xhalf = x . divide ( two ) ; 
BigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; 
double eps = Math . tanh ( x . doubleValue ( ) ) ; 
MathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; 
return resul . round ( mc ) ; 
} 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal resul = xhighpr ; 
BigDecimal xpowi = xhighpr ; 
BigInteger ifac = BigInteger . ONE ; 
double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; 
int k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; 
MathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; 
for ( int i = 1 ; 
; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; 
xpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; 
BigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( corr ) ; 
if ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) break ; 
} 
MathContext mc = new MathContext ( x . precision ( ) ) ; 
return resul . round ( mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal tanh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return tanh ( x . negate ( ) ) . negate ( ) ; 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal exp2x = exp ( xhighpr . multiply ( new BigDecimal ( - 2 ) ) ) ; 
double eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . pow ( Math . cosh ( x . doubleValue ( ) ) , 2.0 ) ; 
MathContext mc = new MathContext ( err2prec ( Math . tanh ( x . doubleValue ( ) ) , eps ) ) ; 
return BigDecimal . ONE . subtract ( exp2x ) . divide ( BigDecimal . ONE . add ( exp2x ) , mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal asinh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) return BigDecimal . ZERO ; 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal logx = log ( hypot ( 1 , xhighpr ) . add ( xhighpr ) ) ; 
double xDbl = x . doubleValue ( ) ; 
double eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . hypot ( 1. , xDbl ) ; 
MathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; 
return logx . round ( mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal acosh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ONE ) < 0 ) throw new ArithmeticException ( "Out of range argument cosh " + x . toString ( ) ) ; 
else if ( x . compareTo ( BigDecimal . ONE ) == 0 ) return BigDecimal . ZERO ; 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal logx = log ( sqrt ( xhighpr . pow ( 2 ) . subtract ( BigDecimal . ONE ) ) . add ( xhighpr ) ) ; 
double xDbl = x . doubleValue ( ) ; 
double eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . sqrt ( xDbl * xDbl - 1. ) ; 
MathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; 
return logx . round ( mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal Gamma ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) return divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; 
else if ( x . doubleValue ( ) > 1.5 ) { 
int n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; 
BigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; 
return multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; 
} 
else { 
BigDecimal z = x . subtract ( BigDecimal . ONE ) ; 
z = scalePrec ( z , 2 ) ; 
MathContext mcloc = new MathContext ( z . precision ( ) ) ; 
double eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; 
BigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; 
if ( x . compareTo ( BigDecimal . ONE ) != 0 ) { 
BigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; 
resul = resul . add ( multiplyRound ( z , gammCompl ) ) ; 
for ( int n = 2 ; 
; 
n ++ ) { 
BigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; 
MathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; 
c = c . round ( m ) ; 
if ( eps / 100. / c . doubleValue ( ) < 0.01 ) m = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; 
else m = new MathContext ( 2 ) ; 
BigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; 
c = multiplyRound ( c , zetm1 ) ; 
if ( n % 2 == 0 ) resul = resul . add ( c ) ; 
else resul = resul . subtract ( c ) ; 
if ( Math . abs ( c . doubleValue ( ) ) < eps ) break ; 
} 
} 
double psi = 0.5772156649 ; 
double zdbl = z . doubleValue ( ) ; 
for ( int n = 1 ; 
n < 5 ; 
n ++ ) psi += zdbl / n / ( n + zdbl ) ; 
eps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; 
mcloc = new MathContext ( err2prec ( eps ) ) ; 
return exp ( resul ) . round ( mcloc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { 
double x = 0.0 ; 
for ( int k = 1 ; 
k < 10 ; 
k ++ ) x += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; 
double eps = prec2err ( x , mc . getPrecision ( ) ) ; 
int kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; 
eps /= kmax ; 
BigDecimal res = BigDecimal . ZERO ; 
for ( int c = 0 ; 
; 
c ++ ) { 
Rational r = new Rational ( ) ; 
for ( int k = 0 ; 
k < 8 ; 
k ++ ) { 
Rational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; 
int pk1h = p * ( 2 + 8 * c + k ) / 2 ; 
tmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; 
r = r . add ( tmp ) ; 
} 
if ( Math . abs ( r . doubleValue ( ) ) < eps ) break ; 
MathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; 
res = res . add ( r . BigDecimalValue ( mcloc ) ) ; 
} 
return res . round ( mc ) ; 
} 
} 

public class BigDecimalMath { 
static public BigDecimal scalePrec ( final BigDecimal x , final MathContext mc ) { 
final int diffPr = mc . getPrecision ( ) - x . precision ( ) ; 
if ( diffPr > 0 ) return scalePrec ( x , diffPr ) ; 
else return x ; 
} 
} 

public class SameDiff { 
public void putFunctionForId ( String id , DifferentialFunction function ) { 
if ( functionInstancesById . containsKey ( id ) ) throw new ND4JIllegalStateException ( "Function by id already exists!" ) ; 
else if ( function instanceof SDVariable ) throw new ND4JIllegalStateException ( "Function must not be a variable!" ) ; 
functionInstancesById . put ( id , function ) ; 
} 
} 

public class SameDiff { 
public void updateArrayForVarName ( String varName , INDArray arr ) { 
if ( ! variableNameToArr . containsKey ( varName ) ) throw new ND4JIllegalStateException ( "Array for " + varName + " does not exist. Please use putArrayForVertexId instead." ) ; 
variableNameToArr . put ( varName , arr ) ; 
reverseArrayLookup . put ( arr , getVariable ( varName ) ) ; 
} 
} 

public class SameDiff { 
public void putShapeForVarName ( String varName , long [ ] shape ) { 
if ( shape == null ) throw new ND4JIllegalStateException ( "Shape must not be null!" ) ; 
if ( variableNameToShape . containsKey ( varName ) ) throw new ND4JIllegalStateException ( "Shape for " + varName + " already exists!" ) ; 
for ( int i = 0 ; 
i < shape . length ; 
i ++ ) if ( shape [ i ] < 1 ) { 
addAsPlaceHolder ( varName ) ; 
placeHolderOriginalShapes . put ( varName , shape ) ; 
return ; 
} 
variableNameToShape . put ( varName , shape ) ; 
} 
} 

public class SameDiff { 
public void associateArrayWithVariable ( INDArray arr , SDVariable variable ) { 
if ( variable == null ) throw new ND4JIllegalArgumentException ( "Variable must not be null!" ) ; 
if ( arr == null ) throw new ND4JIllegalArgumentException ( "Array must not be null" ) ; 
reverseArrayLookup . put ( arr , variable ) ; 
variableNameToArr . put ( variable . getVarName ( ) , arr ) ; 
if ( ! shapeAlreadyExistsForVarName ( variable . getVarName ( ) ) ) putShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; 
else updateShapeForVarName ( variable . getVarName ( ) , arr . shape ( ) ) ; 
} 
} 

public class SameDiff { 
public < T > T getPropertyForFunction ( DifferentialFunction functionInstance , String propertyName ) { 
if ( ! propertiesForFunction . containsKey ( functionInstance . getOwnName ( ) ) ) return null ; 
else { 
val map = propertiesForFunction . get ( functionInstance . getOwnName ( ) ) ; 
return ( T ) map . get ( propertyName ) ; 
} 
} 
} 

public class SameDiff { 
public void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { 
if ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( "Instance id can not be null. Function not initialized properly" ) ; 
if ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) throw new ND4JIllegalStateException ( "Outgoing arguments already declared for " + function ) ; 
if ( varNames == null ) throw new ND4JIllegalStateException ( "Var names can not be null!" ) ; 
for ( int i = 0 ; 
i < varNames . length ; 
i ++ ) if ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( "Variable name elements can not be null!" ) ; 
outgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; 
outgoingArgs . put ( varNames , function ) ; 
for ( val resultName : varNames ) { 
List < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; 
if ( funcs == null ) { 
funcs = new ArrayList < > ( ) ; 
functionOutputFor . put ( resultName , funcs ) ; 
} 
funcs . add ( function ) ; 
} 
} 
} 

public class SameDiff { 
public void addArgsFor ( String [ ] variables , DifferentialFunction function ) { 
if ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( "Instance id can not be null. Function not initialized properly" ) ; 
for ( val varName : variables ) { 
if ( isPlaceHolder ( varName ) ) placeHolderFunctions . add ( function . getOwnName ( ) ) ; 
} 
incomingArgs . put ( variables , function ) ; 
incomingArgsReverse . put ( function . getOwnName ( ) , variables ) ; 
for ( val variableName : variables ) { 
List < DifferentialFunction > funcs = functionsArgsFor . get ( variableName ) ; 
if ( funcs == null ) { 
funcs = new ArrayList < > ( ) ; 
functionsArgsFor . put ( variableName , funcs ) ; 
} 
funcs . add ( function ) ; 
} 
} 
} 

public class SameDiff { 
public void removeArgFromFunction ( String varName , DifferentialFunction function ) { 
val args = function . args ( ) ; 
for ( int i = 0 ; 
i < args . length ; 
i ++ ) if ( args [ i ] . getVarName ( ) . equals ( varName ) ) { 
val reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; 
incomingArgs . remove ( reverseArgs ) ; 
incomingArgsReverse . remove ( function . getOwnName ( ) ) ; 
val newArgs = new ArrayList < String > ( args . length - 1 ) ; 
for ( int arg = 0 ; 
arg < args . length ; 
arg ++ ) if ( ! reverseArgs [ arg ] . equals ( varName ) ) newArgs . add ( reverseArgs [ arg ] ) ; 
val newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; 
incomingArgs . put ( newArgsArr , function ) ; 
incomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; 
break ; 
} 
} 
} 

public class SameDiff { 
public void setGradientForVariableName ( String variableName , SDVariable variable ) { 
if ( variable == null ) throw new ND4JIllegalStateException ( "Unable to set null gradient for variable name " + variableName ) ; 
gradients . put ( variableName , variable ) ; 
} 
} 

public class SameDiff { 
public Pair < Map < SDVariable , DifferentialFunction > , List < DifferentialFunction > > exec ( String functionName ) { 
if ( debugMode ) return sameDiffFunctionInstances . get ( functionName ) . enableDebugMode ( ) . exec ( ) ; 
else return sameDiffFunctionInstances . get ( functionName ) . exec ( ) ; 
} 
} 

public class SameDiff { 
public INDArray execBackwardAndEndResult ( ) { 
List < DifferentialFunction > backwards = execBackwards ( ) . getRight ( ) ; 
DifferentialFunction df = backwards . get ( backwards . size ( ) - 1 ) ; 
if ( df instanceof Op ) return ( ( Op ) df ) . z ( ) ; 
else if ( df instanceof DynamicCustomOp ) return ( ( DynamicCustomOp ) df ) . getOutputArgument ( 0 ) ; 
else return null ; 
} 
} 

public class SameDiff { 
public void addAsPlaceHolder ( String varName ) { 
placeHolderVarNames . add ( varName ) ; 
if ( getVariable ( varName ) != null && getVariable ( varName ) . getShape ( ) != null ) placeHolderOriginalShapes . put ( varName , getVariable ( varName ) . getShape ( ) ) ; 
} 
} 

public class TFGraphMapper { 
public String getNodeName ( String name ) { 
String ret = name ; 
if ( ret . startsWith ( "^" ) ) ret = ret . substring ( 1 ) ; 
if ( ret . endsWith ( "/read" ) ) ret = ret . replace ( "/read" , "" ) ; 
return ret ; 
} 
} 

public class NativeOpExecutioner { 
private void invoke ( ScalarOp op , int [ ] dimension ) { 
dimension = Shape . normalizeAxis ( op . x ( ) . rank ( ) , dimension ) ; 
Pair < DataBuffer , DataBuffer > tadBuffers = tadManager . getTADOnlyShapeInfo ( op . x ( ) , dimension ) ; 
Pointer hostTadShapeInfo = tadBuffers . getFirst ( ) . addressPointer ( ) ; 
Pointer hostTadOffsets = tadBuffers . getSecond ( ) . addressPointer ( ) ; 
Pointer devTadShapeInfoZ = null ; 
Pointer devTadOffsetsZ = null ; 
Pair < DataBuffer , DataBuffer > tadBuffersZ = tadManager . getTADOnlyShapeInfo ( op . z ( ) , dimension ) ; 
devTadShapeInfoZ = tadBuffersZ . getFirst ( ) . addressPointer ( ) ; 
devTadOffsetsZ = tadBuffersZ . getSecond ( ) . addressPointer ( ) ; 
if ( extraz . get ( ) == null ) extraz . set ( new PointerPointer ( 32 ) ) ; 
PointerPointer dummy = extraz . get ( ) . put ( hostTadShapeInfo , hostTadOffsets , devTadShapeInfoZ , devTadOffsetsZ ) ; 
if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) loop . execScalarFloat ( dummy , op . opNum ( ) , ( FloatPointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( FloatPointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; 
else if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) loop . execScalarDouble ( dummy , op . opNum ( ) , ( DoublePointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( DoublePointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; 
} 
} 

public class WorkspaceUtils { 
public static void assertNoWorkspacesOpen ( String msg ) throws ND4JWorkspaceException { 
if ( Nd4j . getWorkspaceManager ( ) . anyWorkspaceActiveForCurrentThread ( ) ) { 
List < MemoryWorkspace > l = Nd4j . getWorkspaceManager ( ) . getAllWorkspacesForCurrentThread ( ) ; 
List < String > workspaces = new ArrayList < > ( l . size ( ) ) ; 
for ( MemoryWorkspace ws : l ) { 
if ( ws . isScopeActive ( ) ) workspaces . add ( ws . getId ( ) ) ; 
} 
throw new ND4JWorkspaceException ( msg + " - Open/active workspaces: " + workspaces ) ; 
} 
} 
} 

public class AtomicState { 
public void releaseToe ( ) { 
if ( getCurrentState ( ) == AccessState . TOE ) if ( 1 > 0 ) if ( toeRequests . decrementAndGet ( ) == 0 ) { 
tickRequests . set ( 0 ) ; 
tackRequests . set ( 0 ) ; 
currentState . set ( AccessState . TACK . ordinal ( ) ) ; 
} 
else throw new IllegalStateException ( "releaseToe() is called from different thread." ) ; 
else throw new IllegalStateException ( "Object is NOT in Toe state!" ) ; 
} 
} 

public class AtomicState { 
public AccessState getCurrentState ( ) { 
if ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) return AccessState . TOE ; 
else if ( tickRequests . get ( ) <= tackRequests . get ( ) ) { 
tickRequests . set ( 0 ) ; 
tackRequests . set ( 0 ) ; 
return AccessState . TACK ; 
} 
else return AccessState . TICK ; 
} 
} 

public class AtomicAllocator { 
@ Override public void synchronizeHostData ( DataBuffer buffer ) { 
if ( buffer . isConstant ( ) ) return ; 
if ( memoryHandler . isDeviceDependant ( ) ) { 
AllocationPoint point = getAllocationPoint ( buffer . getTrackingPoint ( ) ) ; 
if ( point == null ) throw new RuntimeException ( "AllocationPoint is NULL" ) ; 
memoryHandler . synchronizeThreadDevice ( Thread . currentThread ( ) . getId ( ) , memoryHandler . getDeviceId ( ) , point ) ; 
} 
} 
} 

public class GridFlowController { 
@ Override public void synchronizeToHost ( AllocationPoint point ) { 
if ( ! point . isConstant ( ) && point . isEnqueued ( ) ) waitTillFinished ( point ) ; 
super . synchronizeToHost ( point ) ; 
} 
} 

public class NDArrayIndex { 
public static INDArrayIndex [ ] create ( INDArray index ) { 
if ( index . isMatrix ( ) ) { 
if ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; 
NDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; 
for ( int i = 0 ; 
i < index . rows ( ) ; 
i ++ ) { 
INDArray row = index . getRow ( i ) ; 
val nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; 
for ( int j = 0 ; 
j < row . columns ( ) ; 
j ++ ) nums [ j ] = ( int ) row . getFloat ( j ) ; 
NDArrayIndex idx = new NDArrayIndex ( nums ) ; 
ret [ i ] = idx ; 
} 
return ret ; 
} 
else if ( index . isVector ( ) ) { 
long [ ] indices = NDArrayUtil . toLongs ( index ) ; 
return new NDArrayIndex [ ] { 
new NDArrayIndex ( indices ) } 
; 
} 
throw new IllegalArgumentException ( "Passed in ndarray must be a matrix or a vector" ) ; 
} 
} 

public class DifferentialFunction { 
public List < SDVariable > diff ( List < SDVariable > i_v1 ) { 
List < SDVariable > vals = doDiff ( i_v1 ) ; 
if ( vals == null ) throw new IllegalStateException ( "Error executing diff operation: doDiff returned null for op: " + this . opName ( ) ) ; 
val outputVars = args ( ) ; 
for ( int i = 0 ; 
i < vals . size ( ) ; 
i ++ ) { 
SDVariable var = outputVars [ i ] ; 
SDVariable grad = var . getGradient ( ) ; 
if ( grad != null ) { 
SDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; 
try { 
vals . set ( i , gradVar ) ; 
} 
catch ( UnsupportedOperationException e ) { 
throw new UnsupportedOperationException ( "Use a mutable list when returning values from " + this . getClass ( ) . getSimpleName ( ) + ".doDiff (e.g. Arrays.asList instead of Collections.singletonList)" , e ) ; 
} 
sameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; 
} 
else { 
SDVariable gradVar = vals . get ( i ) ; 
sameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + "-grad" ) ; 
sameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; 
sameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; 
} 
} 
return vals ; 
} 
} 

public class BaseComplexNDArray { 
protected void copyRealTo ( INDArray arr ) { 
INDArray linear = arr . linearView ( ) ; 
IComplexNDArray thisLinear = linearView ( ) ; 
if ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; 
else for ( int i = 0 ; 
i < linear . length ( ) ; 
i ++ ) arr . putScalar ( i , thisLinear . getReal ( i ) ) ; 
} 
} 

public class BaseComplexNDArray { 
protected void copyImagTo ( INDArray arr ) { 
INDArray linear = arr . linearView ( ) ; 
IComplexNDArray thisLinear = linearView ( ) ; 
if ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; 
else for ( int i = 0 ; 
i < linear . length ( ) ; 
i ++ ) arr . putScalar ( i , thisLinear . getImag ( i ) ) ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { 
if ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; 
IComplexNDArray linear = linearView ( ) ; 
IComplexNDArray otherLinear = arr . linearView ( ) ; 
for ( int i = 0 ; 
i < linear . length ( ) ; 
i ++ ) linear . putScalar ( i , otherLinear . getComplex ( i ) ) ; 
return this ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray getRows ( int [ ] rindices ) { 
INDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; 
for ( int i = 0 ; 
i < rindices . length ; 
i ++ ) rows . putRow ( i , getRow ( rindices [ i ] ) ) ; 
return ( IComplexNDArray ) rows ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { 
assert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : "Illegal length for row " + toPut . length ( ) + " should have been " + columns ( ) ; 
IComplexNDArray r = getColumn ( column ) ; 
if ( toPut instanceof IComplexNDArray ) { 
IComplexNDArray putComplex = ( IComplexNDArray ) toPut ; 
for ( int i = 0 ; 
i < r . length ( ) ; 
i ++ ) { 
IComplexNumber n = putComplex . getComplex ( i ) ; 
r . putScalar ( i , n ) ; 
} 
} 
else for ( int i = 0 ; 
i < r . length ( ) ; 
i ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; 
return this ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray subi ( INDArray other , INDArray result ) { 
IComplexNDArray cOther = ( IComplexNDArray ) other ; 
IComplexNDArray cResult = ( IComplexNDArray ) result ; 
if ( other . isScalar ( ) ) return subi ( cOther . getComplex ( 0 ) , result ) ; 
if ( result == this ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; 
else if ( result == other ) if ( data . dataType ( ) == ( DataBuffer . Type . DOUBLE ) ) { 
Nd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asDouble ( ) , cResult ) ; 
Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; 
} 
else { 
Nd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asFloat ( ) , cResult ) ; 
Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; 
} 
else { 
Nd4j . getBlasWrapper ( ) . copy ( this , result ) ; 
Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; 
} 
return cResult ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { 
IComplexNDArray cOther = ( IComplexNDArray ) other ; 
IComplexNDArray cResult = ( IComplexNDArray ) result ; 
if ( cOther . isScalar ( ) ) return cResult . addi ( cOther . getComplex ( 0 ) , result ) ; 
if ( isScalar ( ) ) return cOther . addi ( getComplex ( 0 ) , result ) ; 
if ( result == this ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; 
else if ( result == other ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; 
else { 
INDArray resultLinear = result . linearView ( ) ; 
INDArray otherLinear = other . linearView ( ) ; 
INDArray linear = linearView ( ) ; 
for ( int i = 0 ; 
i < resultLinear . length ( ) ; 
i ++ ) resultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; 
} 
return ( IComplexNDArray ) result ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray ravel ( ) { 
if ( length ( ) >= Integer . MAX_VALUE ) throw new IllegalArgumentException ( "length() can not be >= Integer.MAX_VALUE" ) ; 
IComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; 
IComplexNDArray linear = linearView ( ) ; 
for ( int i = 0 ; 
i < length ( ) ; 
i ++ ) ret . putScalar ( i , linear . getComplex ( i ) ) ; 
return ret ; 
} 
} 

public class LossFunctions { 
private static LossInfo doReduce ( SameDiff sd , String outputName , boolean isMean , LossInfo . Builder b , Reduction reduction , SDVariable preReduceLoss , SDVariable label , SDVariable weights , int [ ] dimensions ) { 
switch ( reduction ) { 
case NONE : b . loss ( preReduceLoss ) ; 
break ; 
case SPECIFIED_DIMS : if ( isMean ) b . loss ( sd . mean ( outputName , preReduceLoss , dimensions ) ) ; 
else b . loss ( sd . sum ( outputName , preReduceLoss , dimensions ) ) ; 
case SUM : if ( isMean ) { 
SDVariable m = sd . mean ( preReduceLoss , dimensions ) ; 
b . loss ( sd . sum ( outputName , m ) ) ; 
} 
else b . loss ( sd . sum ( outputName , preReduceLoss ) ) ; 
break ; 
case MEAN_BY_WEIGHT : SDVariable weightSum = sd . sum ( weights ) ; 
if ( isMean ) { 
SDVariable m2 = sd . mean ( preReduceLoss ) ; 
b . loss ( m2 . div ( outputName , weightSum ) ) ; 
} 
else { 
SDVariable sum = sd . sum ( preReduceLoss , dimensions ) ; 
b . loss ( sum . div ( outputName , weightSum ) ) ; 
} 
break ; 
case MEAN_BY_COUNT : SDVariable nonZeroWeights = nonZeroCount ( weights , label ) ; 
SDVariable r ; 
if ( isMean ) r = sd . sum ( preReduceLoss ) ; 
else { 
SDVariable sum = sd . sum ( preReduceLoss , dimensions ) ; 
r = sd . mean ( sum ) ; 
} 
b . loss ( r . div ( outputName , nonZeroWeights ) ) ; 
break ; 
default : throw new RuntimeException ( "Unknown reduction: " + reduction ) ; 
} 
return b . build ( ) ; 
} 
} 

public class HybridQueryResults { 
private < T > Iterator < Iterator < T > > safePartition ( final Iterator < T > input , int chunkSize ) { 
if ( chunkSize > 1000 ) chunkSize = 1000 ; 
return Iterators . transform ( Iterators . partition ( input , chunkSize ) , IterateFunction . instance ( ) ) ; 
} 
} 

public class GenericTypeReflector { 
static boolean isMissingTypeParameters ( Type type ) { 
if ( type instanceof Class ) { 
for ( Class < ? > clazz = ( Class < ? > ) type ; 
clazz != null ; 
clazz = clazz . getEnclosingClass ( ) ) if ( clazz . getTypeParameters ( ) . length != 0 ) return true ; 
return false ; 
} 
else if ( type instanceof ParameterizedType ) return false ; 
else throw new AssertionError ( "Unexpected type " + type . getClass ( ) ) ; 
} 
} 

public class GenericTypeReflector { 
public static boolean isSuperType ( Type superType , Type subType ) { 
if ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { 
Class < ? > superClass = erase ( superType ) ; 
Type mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; 
if ( mappedSubType == null ) return false ; 
else if ( superType instanceof Class < ? > ) return true ; 
else if ( mappedSubType instanceof Class < ? > ) return true ; 
else if ( mappedSubType instanceof GenericArrayType ) { 
Type superComponentType = getArrayComponentType ( superType ) ; 
assert superComponentType != null ; 
Type mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; 
assert mappedSubComponentType != null ; 
return isSuperType ( superComponentType , mappedSubComponentType ) ; 
} 
else { 
assert mappedSubType instanceof ParameterizedType ; 
ParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; 
assert pMappedSubType . getRawType ( ) == superClass ; 
ParameterizedType pSuperType = ( ParameterizedType ) superType ; 
Type [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; 
Type [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; 
assert superTypeArgs . length == subTypeArgs . length ; 
for ( int i = 0 ; 
i < superTypeArgs . length ; 
i ++ ) if ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) return false ; 
return pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; 
} 
} 
else if ( superType instanceof CaptureType ) { 
if ( superType . equals ( subType ) ) return true ; 
for ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { 
if ( isSuperType ( lowerBound , subType ) ) return true ; 
} 
return false ; 
} 
else if ( superType instanceof GenericArrayType ) return isArraySupertype ( superType , subType ) ; 
else throw new RuntimeException ( "not implemented: " + superType . getClass ( ) ) ; 
} 
} 

public class GenericTypeReflector { 
private static Type [ ] getExactDirectSuperTypes ( Type type ) { 
if ( type instanceof ParameterizedType || type instanceof Class ) { 
Class < ? > clazz ; 
if ( type instanceof ParameterizedType ) clazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; 
else { 
clazz = ( Class < ? > ) type ; 
if ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; 
} 
Type [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; 
Type superClass = clazz . getGenericSuperclass ( ) ; 
if ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) return new Type [ ] { 
Object . class } 
; 
Type [ ] result ; 
int resultIndex ; 
if ( superClass == null ) { 
result = new Type [ superInterfaces . length ] ; 
resultIndex = 0 ; 
} 
else { 
result = new Type [ superInterfaces . length + 1 ] ; 
resultIndex = 1 ; 
result [ 0 ] = mapTypeParameters ( superClass , type ) ; 
} 
for ( Type superInterface : superInterfaces ) { 
result [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; 
} 
return result ; 
} 
else if ( type instanceof TypeVariable ) { 
TypeVariable < ? > tv = ( TypeVariable < ? > ) type ; 
return tv . getBounds ( ) ; 
} 
else if ( type instanceof WildcardType ) return ( ( WildcardType ) type ) . getUpperBounds ( ) ; 
else if ( type instanceof CaptureType ) return ( ( CaptureType ) type ) . getUpperBounds ( ) ; 
else if ( type instanceof GenericArrayType ) return getArrayExactDirectSuperTypes ( type ) ; 
else if ( type == null ) throw new NullPointerException ( ) ; 
else throw new RuntimeException ( "not implemented type: " + type ) ; 
} 
} 

public class GenericTypeReflector { 
public static Type capture ( Type type ) { 
if ( type instanceof ParameterizedType ) return capture ( ( ParameterizedType ) type ) ; 
else return type ; 
} 
} 

public class CreateContext { 
@ SuppressWarnings ( "unchecked" ) public < P > Populator < P > getPopulator ( final Class < P > clazz , final Path path ) { 
if ( clazz == null || clazz . equals ( Object . class ) ) return ( Populator < P > ) NullPopulator . INSTANCE ; 
else { 
final ClassTranslator < P > classTranslator = ( ClassTranslator < P > ) this . < P , FullEntity < ? > > getTranslator ( new TypeKey < > ( clazz ) , this , path ) ; 
return classTranslator . getPopulator ( ) ; 
} 
} 
} 

public class Round { 
private Result < Map < com . google . cloud . datastore . Key , Entity > > fetchPending ( ) { 
final Map < com . google . cloud . datastore . Key , Entity > combined = new HashMap < > ( ) ; 
Set < com . google . cloud . datastore . Key > fetch = new HashSet < > ( ) ; 
for ( com . google . cloud . datastore . Key key : pending ) { 
Entity ent = stuffed . get ( key ) ; 
if ( ent == null ) fetch . add ( key ) ; 
else combined . put ( key , ent ) ; 
} 
if ( fetch . isEmpty ( ) ) return new ResultNow < > ( combined ) ; 
else { 
final Result < Map < com . google . cloud . datastore . Key , Entity > > fetched = loadEngine . fetch ( fetch ) ; 
return ( ) -> { 
combined . putAll ( fetched . now ( ) ) ; 
return combined ; 
} 
; 
} 
} 
} 

public class Path { 
public String toPathString ( ) { 
if ( this == ROOT ) return "" ; 
else { 
StringBuilder builder = new StringBuilder ( ) ; 
toPathString ( builder ) ; 
return builder . toString ( ) ; 
} 
} 
} 

public class KeyMetadata { 
@ SuppressWarnings ( "unchecked" ) public < K extends IncompleteKey > void setKey ( final FullEntity . Builder < K > container , final P pojo ) { 
final IncompleteKey rawKey = getIncompleteKey ( pojo ) ; 
if ( ! ( rawKey instanceof com . google . cloud . datastore . Key ) ) Preconditions . checkState ( isIdNumeric ( ) , "Cannot save an entity with a null String @Id: %s" , pojo ) ; 
container . setKey ( ( K ) rawKey ) ; 
} 
} 

public class TypeFactory { 
private static boolean couldHaveCommonSubtype ( Type type1 , Type type2 ) { 
Class < ? > erased1 = GenericTypeReflector . erase ( type1 ) ; 
Class < ? > erased2 = GenericTypeReflector . erase ( type2 ) ; 
if ( ! erased1 . isInterface ( ) && ! erased2 . isInterface ( ) ) if ( ! erased1 . isAssignableFrom ( erased2 ) && ! erased2 . isAssignableFrom ( erased1 ) ) return false ; 
return true ; 
} 
} 

public class TypeFactory { 
private static Type transformOwner ( Type givenOwner , Class < ? > clazz ) { 
if ( givenOwner == null ) return clazz . getDeclaringClass ( ) ; 
else { 
Type transformedOwner = GenericTypeReflector . getExactSuperType ( givenOwner , clazz . getDeclaringClass ( ) ) ; 
if ( transformedOwner == null ) throw new IllegalArgumentException ( "Given owner type [" + givenOwner + "] is not appropriate for [" + clazz + "]: it should be a subtype of " + clazz . getDeclaringClass ( ) ) ; 
if ( Modifier . isStatic ( clazz . getModifiers ( ) ) ) return GenericTypeReflector . erase ( transformedOwner ) ; 
else return transformedOwner ; 
} 
} 
} 

public class TypeKey { 
public < A extends Annotation > A getAnnotationAnywhere ( Class < A > annotationType ) { 
A anno = getAnnotation ( annotationType ) ; 
if ( anno == null ) { 
Class < ? > clazz = ( Class < ? > ) GenericTypeReflector . erase ( type ) ; 
return clazz . getAnnotation ( annotationType ) ; 
} 
else return anno ; 
} 
} 

public class LoadEngine { 
public < T > Result < T > load ( final Key < T > key ) { 
if ( key == null ) throw new NullPointerException ( "You tried to load a null key!" ) ; 
final Result < T > result = round . get ( key ) ; 
if ( ofy . getTransaction ( ) != null ) ( ( PrivateAsyncTransaction ) ofy . getTransaction ( ) ) . enlist ( result ) ; 
if ( key . getParent ( ) != null ) { 
final KeyMetadata < ? > meta = ofy . factory ( ) . keys ( ) . getMetadata ( key ) ; 
if ( meta != null ) if ( meta . shouldLoadParent ( loadArrangement ) ) load ( key . getParent ( ) ) ; 
} 
return result ; 
} 
} 

public class Keys { 
@ SuppressWarnings ( "unchecked" ) public static < S > Value < S > getIdValue ( final IncompleteKey key ) { 
if ( key instanceof com . google . cloud . datastore . Key ) { 
final com . google . cloud . datastore . Key completeKey = ( com . google . cloud . datastore . Key ) key ; 
if ( completeKey . hasId ( ) ) return ( Value < S > ) LongValue . of ( completeKey . getId ( ) ) ; 
else return ( Value < S > ) StringValue . of ( completeKey . getName ( ) ) ; 
} 
else return null ; 
} 
} 

public class Keys { 
@ SneakyThrows public static com . google . cloud . datastore . Key fromUrlSafe ( final String urlSafeKey ) { 
if ( urlSafeKey . startsWith ( "a" ) ) return KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey ) ; 
else return com . google . cloud . datastore . Key . fromUrlSafe ( urlSafeKey ) ; 
} 
} 

public class TransactorNo { 
private < R > R transactOnce ( final ObjectifyImpl parent , final Work < R > work ) { 
final ObjectifyImpl txnOfy = factory . open ( parent . getOptions ( ) , next -> new TransactorYes ( next , this ) ) ; 
boolean committedSuccessfully = false ; 
try { 
final R result = work . run ( ) ; 
txnOfy . flush ( ) ; 
txnOfy . getTransaction ( ) . commit ( ) ; 
committedSuccessfully = true ; 
return result ; 
} 
finally { 
if ( txnOfy . getTransaction ( ) . isActive ( ) ) try { 
txnOfy . getTransaction ( ) . rollback ( ) ; 
} 
catch ( RuntimeException ex ) { 
log . error ( "Rollback failed, suppressing error" , ex ) ; 
} 
txnOfy . close ( ) ; 
if ( committedSuccessfully ) ( ( PrivateAsyncTransaction ) txnOfy . getTransaction ( ) ) . runCommitListeners ( ) ; 
} 
} 
} 

public class AbstractOpenRtbJsonWriter { 
@ SuppressWarnings ( "unchecked" ) protected final < EM extends ExtendableMessage < EM > > void writeExtensions ( EM msg , JsonGenerator gen ) throws IOException { 
boolean openExt = false ; 
for ( Map . Entry < FieldDescriptor , Object > field : msg . getAllFields ( ) . entrySet ( ) ) { 
FieldDescriptor fd = field . getKey ( ) ; 
if ( fd . isExtension ( ) ) if ( fd . isRepeated ( ) ) { 
List < Object > extValue = ( List < Object > ) field . getValue ( ) ; 
if ( ! extValue . isEmpty ( ) ) { 
OpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . get ( 0 ) . getClass ( ) , fd . getName ( ) ) ; 
if ( extWriter != null ) { 
openExt = openExt ( gen , openExt ) ; 
extWriter . writeRepeated ( extValue , gen ) ; 
} 
} 
} 
else { 
Object extValue = field . getValue ( ) ; 
OpenRtbJsonExtWriter < Object > extWriter = factory . getWriter ( msg . getClass ( ) , extValue . getClass ( ) , fd . getName ( ) ) ; 
if ( extWriter != null ) { 
openExt = openExt ( gen , openExt ) ; 
extWriter . writeSingle ( extValue , gen ) ; 
} 
} 
} 
if ( openExt ) gen . writeEndObject ( ) ; 
} 
} 

public class AbstractOpenRtbJsonWriter { 
protected final boolean writeContentCategory ( String cat , JsonGenerator gen ) throws IOException { 
if ( ! factory . isStrict ( ) || OpenRtbUtils . categoryFromName ( cat ) != null ) { 
gen . writeString ( cat ) ; 
return true ; 
} 
else return false ; 
} 
} 

public class OpenRtbUtils { 
@ Nullable public static Bid . Builder bidWithId ( BidResponse . Builder response , String id ) { 
checkNotNull ( id ) ; 
for ( SeatBid . Builder seatbid : response . getSeatbidBuilderList ( ) ) { 
for ( Bid . Builder bid : seatbid . getBidBuilderList ( ) ) { 
if ( id . equals ( bid . getId ( ) ) ) return bid ; 
} 
} 
return null ; 
} 
} 

public class OpenRtbUtils { 
public static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { 
checkNotNull ( impFilter ) ; 
List < Imp > imps = request . getImpList ( ) ; 
if ( imps . isEmpty ( ) || impFilter == IMP_ALL ) return imps ; 
else if ( impFilter == IMP_NONE ) return ImmutableList . of ( ) ; 
boolean included = impFilter . test ( imps . get ( 0 ) ) ; 
int size = imps . size ( ) , i ; 
for ( i = 1 ; 
i < size ; 
++ i ) if ( impFilter . test ( imps . get ( i ) ) != included ) break ; 
if ( i == size ) return included ? imps : ImmutableList . < Imp > of ( ) ; 
int headingSize = i ; 
return new FluentIterable < Imp > ( ) { 
@ Override public Iterator < Imp > iterator ( ) { 
Iterator < Imp > unfiltered = imps . iterator ( ) ; 
return new AbstractIterator < Imp > ( ) { 
private int heading = 0 ; 
@ Override protected Imp computeNext ( ) { 
while ( unfiltered . hasNext ( ) ) { 
Imp imp = unfiltered . next ( ) ; 
if ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) return imp ; 
} 
return endOfData ( ) ; 
} 
} 
; 
} 
} 
; 
} 
} 

public class AbstractOpenRtbJsonReader { 
protected final < EB extends ExtendableBuilder < ? , EB > > void readExtensions ( EB msg , JsonParser par ) throws IOException { 
@ SuppressWarnings ( "unchecked" ) Set < OpenRtbJsonExtReader < EB > > extReaders = factory . getReaders ( ( Class < EB > ) msg . getClass ( ) ) ; 
if ( extReaders . isEmpty ( ) ) { 
par . skipChildren ( ) ; 
return ; 
} 
startObject ( par ) ; 
JsonToken tokLast = par . getCurrentToken ( ) ; 
JsonLocation locLast = par . getCurrentLocation ( ) ; 
while ( true ) { 
boolean extRead = false ; 
for ( OpenRtbJsonExtReader < EB > extReader : extReaders ) { 
if ( extReader . filter ( par ) ) { 
extReader . read ( msg , par ) ; 
JsonToken tokNew = par . getCurrentToken ( ) ; 
JsonLocation locNew = par . getCurrentLocation ( ) ; 
boolean advanced = tokNew != tokLast || ! locNew . equals ( locLast ) ; 
extRead |= advanced ; 
if ( ! endObject ( par ) ) return ; 
else if ( advanced && par . getCurrentToken ( ) != JsonToken . FIELD_NAME ) { 
tokLast = par . nextToken ( ) ; 
locLast = par . getCurrentLocation ( ) ; 
} 
else { 
tokLast = tokNew ; 
locLast = locNew ; 
} 
} 
} 
if ( ! endObject ( par ) ) return ; 
if ( ! extRead ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Extension field not consumed by any reader, skipping: {} @{}:{}" , par . getCurrentName ( ) , locLast . getLineNr ( ) , locLast . getCharOffset ( ) ) ; 
par . nextToken ( ) ; 
par . skipChildren ( ) ; 
tokLast = par . nextToken ( ) ; 
locLast = par . getCurrentLocation ( ) ; 
} 
} 
} 
} 

public class AbstractOpenRtbJsonReader { 
protected final boolean emptyToNull ( JsonParser par ) throws IOException { 
JsonToken token = par . getCurrentToken ( ) ; 
if ( token == null ) token = par . nextToken ( ) ; 
return ! factory ( ) . isStrict ( ) && token == null ; 
} 
} 

public class OpenRtbJsonFactory { 
public final < T > OpenRtbJsonFactory register ( OpenRtbJsonExtWriter < T > extWriter , Class < T > extKlass , Class < ? extends Message > msgKlass , String fieldName ) { 
Map < String , Map < String , OpenRtbJsonExtWriter < ? > > > mapMsg = extWriters . get ( msgKlass . getName ( ) ) ; 
if ( mapMsg == null ) extWriters . put ( msgKlass . getName ( ) , mapMsg = new LinkedHashMap < > ( ) ) ; 
Map < String , OpenRtbJsonExtWriter < ? > > mapKlass = mapMsg . get ( extKlass . getName ( ) ) ; 
if ( mapKlass == null ) mapMsg . put ( extKlass . getName ( ) , mapKlass = new LinkedHashMap < > ( ) ) ; 
mapKlass . put ( fieldName == null ? FIELDNAME_ALL : fieldName , extWriter ) ; 
return this ; 
} 
} 

public class OpenRtbSnippetProcessor { 
protected void processFields ( SnippetProcessorContext bidCtx ) { 
Bid . Builder bid = bidCtx . getBid ( ) ; 
if ( extendedFields ) { 
if ( bid . hasAdid ( ) ) bid . setAdid ( process ( bidCtx , bid . getAdid ( ) ) ) ; 
bid . setId ( process ( bidCtx , bid . getId ( ) ) ) ; 
} 
if ( bid . hasAdm ( ) ) bid . setAdm ( process ( bidCtx , bid . getAdm ( ) ) ) ; 
if ( extendedFields ) { 
if ( bid . hasBurl ( ) ) bid . setBurl ( process ( bidCtx , bid . getBurl ( ) ) ) ; 
if ( bid . hasCid ( ) ) bid . setCid ( process ( bidCtx , bid . getCid ( ) ) ) ; 
if ( bid . hasCrid ( ) ) bid . setCrid ( process ( bidCtx , bid . getCrid ( ) ) ) ; 
if ( bid . hasDealid ( ) ) bid . setDealid ( process ( bidCtx , bid . getDealid ( ) ) ) ; 
bid . setImpid ( process ( bidCtx , bid . getImpid ( ) ) ) ; 
if ( bid . hasIurl ( ) ) bid . setIurl ( process ( bidCtx , bid . getIurl ( ) ) ) ; 
if ( bid . hasLurl ( ) ) bid . setIurl ( process ( bidCtx , bid . getLurl ( ) ) ) ; 
if ( bid . hasNurl ( ) ) bid . setNurl ( process ( bidCtx , bid . getNurl ( ) ) ) ; 
} 
} 
} 

public class ProtoUtils { 
public static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { 
checkNotNull ( filter ) ; 
for ( int i = 0 ; 
i < objs . size ( ) ; 
++ i ) if ( ! filter . test ( objs . get ( i ) ) ) return filterFrom ( objs , filter , i ) ; 
return objs ; 
} 
} 

public class OpenRtbJsonUtils { 
public static void startObject ( JsonParser par ) throws IOException { 
JsonToken token = par . getCurrentToken ( ) ; 
if ( token == null || token == JsonToken . FIELD_NAME ) token = par . nextToken ( ) ; 
if ( token == JsonToken . START_OBJECT ) par . nextToken ( ) ; 
else throw new JsonParseException ( par , "Expected start of object" ) ; 
} 
} 

public class OpenRtbJsonUtils { 
public static void startArray ( JsonParser par ) throws IOException { 
JsonToken token = par . getCurrentToken ( ) ; 
if ( token == null || token == JsonToken . FIELD_NAME ) token = par . nextToken ( ) ; 
if ( token == JsonToken . START_ARRAY ) par . nextToken ( ) ; 
else throw new JsonParseException ( par , "Expected start of array" ) ; 
} 
} 

public class OpenRtbJsonUtils { 
public static JsonToken peekToken ( JsonParser par ) throws IOException { 
JsonToken token = par . getCurrentToken ( ) ; 
if ( token == null || token == JsonToken . FIELD_NAME ) token = par . nextToken ( ) ; 
return token ; 
} 
} 

public class URLUtil { 
public static URL resolveURL ( URL base , String target ) throws MalformedURLException { 
target = target . trim ( ) ; 
if ( target . startsWith ( "?" ) ) return fixPureQueryTargets ( base , target ) ; 
return new URL ( base , target ) ; 
} 
} 

public class URLUtil { 
static URL fixPureQueryTargets ( URL base , String target ) throws MalformedURLException { 
if ( ! target . startsWith ( "?" ) ) return new URL ( base , target ) ; 
String basePath = base . getPath ( ) ; 
String baseRightMost = "" ; 
int baseRightMostIdx = basePath . lastIndexOf ( "/" ) ; 
if ( baseRightMostIdx != - 1 ) baseRightMost = basePath . substring ( baseRightMostIdx + 1 ) ; 
if ( target . startsWith ( "?" ) ) target = baseRightMost + target ; 
return new URL ( base , target ) ; 
} 
} 

public class ConfUtils { 
public static List < String > loadListFromConf ( String paramKey , Map stormConf ) { 
Object obj = stormConf . get ( paramKey ) ; 
List < String > list = new LinkedList < > ( ) ; 
if ( obj == null ) return list ; 
if ( obj instanceof PersistentVector ) list . addAll ( ( PersistentVector ) obj ) ; 
else list . add ( obj . toString ( ) ) ; 
return list ; 
} 
} 

public class ConfUtils { 
public static Map extractConfigElement ( Map conf ) { 
if ( conf . size ( ) == 1 ) { 
Object confNode = conf . get ( "config" ) ; 
if ( confNode != null && confNode instanceof Map ) conf = ( Map ) confNode ; 
} 
return conf ; 
} 
} 

public class RefreshTag { 
public static String extractRefreshURL ( String value ) { 
if ( StringUtils . isBlank ( value ) ) return null ; 
try { 
if ( matcher . reset ( value ) . matches ( ) ) return matcher . group ( 1 ) ; 
} 
catch ( Exception e ) { 
} 
return null ; 
} 
} 

public class MetadataTransfer { 
public Metadata getMetaForOutlink ( String targetURL , String sourceURL , Metadata parentMD ) { 
Metadata md = _filter ( parentMD , mdToTransfer ) ; 
if ( trackPath ) md . addValue ( urlPathKeyName , sourceURL ) ; 
if ( trackDepth ) { 
String existingDepth = md . getFirstValue ( depthKeyName ) ; 
int depth ; 
try { 
depth = Integer . parseInt ( existingDepth ) ; 
} 
catch ( Exception e ) { 
depth = 0 ; 
} 
md . setValue ( depthKeyName , Integer . toString ( ++ depth ) ) ; 
} 
return md ; 
} 
} 

public class CharsetIdentification { 
private static String getCharsetFromBOM ( final byte [ ] byteData ) { 
BOMInputStream bomIn = new BOMInputStream ( new ByteArrayInputStream ( byteData ) ) ; 
try { 
ByteOrderMark bom = bomIn . getBOM ( ) ; 
if ( bom != null ) return bom . getCharsetName ( ) ; 
} 
catch ( IOException e ) { 
return null ; 
} 
return null ; 
} 
} 

public class CharsetIdentification { 
private static String getCharsetFromText ( byte [ ] content , String declaredCharset , int maxLengthCharsetDetection ) { 
String charset = null ; 
CharsetDetector charsetDetector = new CharsetDetector ( ) ; 
charsetDetector . enableInputFilter ( true ) ; 
if ( declaredCharset != null ) charsetDetector . setDeclaredEncoding ( declaredCharset ) ; 
byte [ ] subContent = content ; 
if ( maxLengthCharsetDetection != - 1 && content . length > maxLengthCharsetDetection ) subContent = Arrays . copyOfRange ( content , 0 , maxLengthCharsetDetection ) ; 
charsetDetector . setText ( subContent ) ; 
try { 
CharsetMatch charsetMatch = charsetDetector . detect ( ) ; 
charset = validateCharset ( charsetMatch . getName ( ) ) ; 
} 
catch ( Exception e ) { 
charset = null ; 
} 
return charset ; 
} 
} 

public class CharsetIdentification { 
private static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { 
int len = buffer . length ; 
if ( maxlength > 0 && maxlength < len ) len = maxlength ; 
String html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; 
Document doc = Parser . htmlParser ( ) . parseInput ( html , "dummy" ) ; 
Elements metaElements = doc . select ( "meta[http-equiv=content-type], meta[charset]" ) ; 
String foundCharset = null ; 
for ( Element meta : metaElements ) { 
if ( meta . hasAttr ( "http-equiv" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( "content" ) ) ; 
if ( foundCharset == null && meta . hasAttr ( "charset" ) ) foundCharset = meta . attr ( "charset" ) ; 
if ( foundCharset != null ) return foundCharset ; 
} 
return foundCharset ; 
} 
} 

public class SiteMapParserBolt { 
private final boolean sniff ( byte [ ] content ) { 
byte [ ] beginning = content ; 
if ( content . length > maxOffsetGuess && maxOffsetGuess > 0 ) beginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; 
int position = Bytes . indexOf ( beginning , clue ) ; 
if ( position != - 1 ) return true ; 
return false ; 
} 
} 

public class CookieConverter { 
public static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { 
ArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; 
for ( String cs : cookiesStrings ) { 
String name = null ; 
String value = null ; 
String expires = null ; 
String domain = null ; 
String path = null ; 
boolean secure = false ; 
String [ ] tokens = cs . split ( ";" ) ; 
int equals = tokens [ 0 ] . indexOf ( "=" ) ; 
name = tokens [ 0 ] . substring ( 0 , equals ) ; 
value = tokens [ 0 ] . substring ( equals + 1 ) ; 
for ( int i = 1 ; 
i < tokens . length ; 
i ++ ) { 
String ti = tokens [ i ] . trim ( ) ; 
if ( ti . equalsIgnoreCase ( "secure" ) ) secure = true ; 
if ( ti . toLowerCase ( ) . startsWith ( "path=" ) ) path = ti . substring ( 5 ) ; 
if ( ti . toLowerCase ( ) . startsWith ( "domain=" ) ) domain = ti . substring ( 7 ) ; 
if ( ti . toLowerCase ( ) . startsWith ( "expires=" ) ) expires = ti . substring ( 8 ) ; 
} 
BasicClientCookie cookie = new BasicClientCookie ( name , value ) ; 
if ( domain != null ) { 
cookie . setDomain ( domain ) ; 
if ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; 
} 
if ( path != null ) { 
cookie . setPath ( path ) ; 
if ( ! path . equals ( "" ) && ! path . equals ( "/" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; 
} 
if ( secure ) { 
cookie . setSecure ( secure ) ; 
if ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( "https" ) ) continue ; 
} 
if ( expires != null ) try { 
Date expirationDate = DATE_FORMAT . parse ( expires ) ; 
cookie . setExpiryDate ( expirationDate ) ; 
if ( cookie . isExpired ( new Date ( ) ) ) continue ; 
cookie . setExpiryDate ( expirationDate ) ; 
} 
catch ( ParseException e ) { 
} 
list . add ( cookie ) ; 
} 
return list ; 
} 
} 

public class CookieConverter { 
public static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { 
try { 
if ( cookieDomain . startsWith ( "." ) ) cookieDomain = cookieDomain . substring ( 1 ) ; 
String [ ] domainTokens = cookieDomain . split ( "\\." ) ; 
String [ ] hostTokens = urlHostName . split ( "\\." ) ; 
int tokenDif = hostTokens . length - domainTokens . length ; 
if ( tokenDif < 0 ) return false ; 
for ( int i = domainTokens . length - 1 ; 
i >= 0 ; 
i -- ) if ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) return false ; 
return true ; 
} 
catch ( Exception e ) { 
return true ; 
} 
} 
} 

public class HttpRobotRulesParser { 
protected static String getCacheKey ( URL url ) { 
String protocol = url . getProtocol ( ) . toLowerCase ( Locale . ROOT ) ; 
String host = url . getHost ( ) . toLowerCase ( Locale . ROOT ) ; 
int port = url . getPort ( ) ; 
if ( port == - 1 ) port = url . getDefaultPort ( ) ; 
return protocol + ":" + host + ":" + port ; 
} 
} 

public class HttpRobotRulesParser { 
public BaseRobotRules getRobotRulesSetFromCache ( URL url ) { 
String cacheKey = getCacheKey ( url ) ; 
BaseRobotRules robotRules = CACHE . getIfPresent ( cacheKey ) ; 
if ( robotRules != null ) return robotRules ; 
return EMPTY_RULES ; 
} 
} 

public class AbstractStatusUpdaterBolt { 
protected final void ack ( Tuple t , String url ) { 
if ( useCache ) cache . put ( url , "" ) ; 
_collector . ack ( t ) ; 
} 
} 

public class Rules { 
public boolean filter ( String url , Metadata metadata ) throws MalformedURLException { 
URL u = new URL ( url ) ; 
String hostname = u . getHost ( ) ; 
if ( checkScope ( hostNameRules . get ( hostname ) , u ) ) return true ; 
String [ ] domainParts = hostname . split ( "\\." ) ; 
String domain = null ; 
for ( int i = domainParts . length - 1 ; 
i >= 0 ; 
i -- ) { 
domain = domainParts [ i ] + ( domain == null ? "" : "." + domain ) ; 
if ( checkScope ( domainRules . get ( domain ) , u ) ) return true ; 
} 
for ( MDScope scope : metadataRules ) { 
String [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; 
if ( vals == null ) continue ; 
for ( String v : vals ) { 
if ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { 
FastURLFilter . LOG . debug ( "Filtering {} matching metadata {}:{}" , url , scope . getKey ( ) , scope . getValue ( ) ) ; 
if ( checkScope ( scope , u ) ) return true ; 
} 
} 
} 
if ( checkScope ( globalRules , u ) ) return true ; 
return false ; 
} 
} 

public class RegexURLNormalizer { 
@ Override public String filter ( URL sourceUrl , Metadata sourceMetadata , String urlString ) { 
Iterator < Rule > i = rules . iterator ( ) ; 
while ( i . hasNext ( ) ) { 
Rule r = i . next ( ) ; 
Matcher matcher = r . pattern . matcher ( urlString ) ; 
urlString = matcher . replaceAll ( r . substitution ) ; 
} 
if ( urlString . equals ( "" ) ) urlString = null ; 
return urlString ; 
} 
} 

public class BasicURLNormalizer { 
private String processQueryElements ( String urlToFilter ) { 
try { 
URL url = new URL ( urlToFilter ) ; 
String query = url . getQuery ( ) ; 
String path = url . getPath ( ) ; 
if ( path . contains ( ";" ) ) { 
String [ ] pathElements = path . split ( "/" ) ; 
String last = pathElements [ pathElements . length - 1 ] ; 
int semicolon = last . indexOf ( ";" ) ; 
if ( semicolon != - 1 ) { 
pathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; 
String params = last . substring ( semicolon + 1 ) . replaceAll ( ";" , "&" ) ; 
if ( query == null ) query = params ; 
else query += "&" + params ; 
StringBuilder newPath = new StringBuilder ( ) ; 
for ( String p : pathElements ) { 
if ( StringUtils . isNotBlank ( p ) ) newPath . append ( "/" ) . append ( p ) ; 
} 
path = newPath . toString ( ) ; 
} 
} 
if ( StringUtils . isEmpty ( query ) ) return urlToFilter ; 
List < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; 
Iterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; 
while ( pairsIterator . hasNext ( ) ) { 
NameValuePair param = pairsIterator . next ( ) ; 
if ( queryElementsToRemove . contains ( param . getName ( ) ) ) pairsIterator . remove ( ) ; 
else if ( removeHashes && param . getValue ( ) != null ) { 
Matcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; 
if ( m . matches ( ) ) pairsIterator . remove ( ) ; 
} 
} 
StringBuilder newFile = new StringBuilder ( ) ; 
if ( StringUtils . isNotBlank ( path ) ) newFile . append ( path ) ; 
if ( ! pairs . isEmpty ( ) ) { 
Collections . sort ( pairs , comp ) ; 
String newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; 
newFile . append ( '?' ) . append ( newQueryString ) ; 
} 
if ( url . getRef ( ) != null ) newFile . append ( '#' ) . append ( url . getRef ( ) ) ; 
return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; 
} 
catch ( MalformedURLException e ) { 
LOG . warn ( "Invalid urlToFilter {}. {}" , urlToFilter , e ) ; 
return null ; 
} 
} 
} 

public class NavigationFilters { 
@ SuppressWarnings ( "rawtypes" ) public static NavigationFilters fromConf ( Map stormConf ) { 
String configfile = ConfUtils . getString ( stormConf , "navigationfilters.config.file" ) ; 
if ( StringUtils . isNotBlank ( configfile ) ) try { 
return new NavigationFilters ( stormConf , configfile ) ; 
} 
catch ( IOException e ) { 
String message = "Exception caught while loading the NavigationFilters from " + configfile ; 
LOG . error ( message ) ; 
throw new RuntimeException ( message , e ) ; 
} 
return NavigationFilters . emptyNavigationFilters ; 
} 
} 

public class GzipHdfsBolt { 
public GzipHdfsBolt addRecordFormat ( RecordFormat format , int position ) { 
MultipleRecordFormat formats ; 
if ( this . format == null ) { 
formats = new MultipleRecordFormat ( format ) ; 
this . format = formats ; 
} 
else { 
if ( this . format instanceof MultipleRecordFormat ) formats = ( MultipleRecordFormat ) this . format ; 
else { 
formats = new MultipleRecordFormat ( this . format ) ; 
this . format = formats ; 
} 
formats . addFormat ( new GzippedRecordFormat ( format ) , position ) ; 
} 
return this ; 
} 
} 

public class AbstractQueryingSpout { 
private long throttleQueries ( ) { 
if ( timeLastQuerySent != 0 ) { 
long difference = System . currentTimeMillis ( ) - timeLastQuerySent ; 
if ( difference < minDelayBetweenQueries ) return minDelayBetweenQueries - difference ; 
} 
return - 1 ; 
} 
} 

public class AbstractQueryingSpout { 
private boolean triggerQueries ( ) { 
if ( timeLastQueryReceived != 0 && maxDelayBetweenQueries > 0 ) { 
long difference = System . currentTimeMillis ( ) - timeLastQueryReceived ; 
if ( difference > maxDelayBetweenQueries ) return true ; 
} 
return false ; 
} 
} 

public class ParseFilters { 
@ SuppressWarnings ( "rawtypes" ) public static ParseFilters fromConf ( Map stormConf ) { 
String parseconfigfile = ConfUtils . getString ( stormConf , "parsefilters.config.file" ) ; 
if ( StringUtils . isNotBlank ( parseconfigfile ) ) try { 
return new ParseFilters ( stormConf , parseconfigfile ) ; 
} 
catch ( IOException e ) { 
String message = "Exception caught while loading the ParseFilters from " + parseconfigfile ; 
LOG . error ( message ) ; 
throw new RuntimeException ( message , e ) ; 
} 
return ParseFilters . emptyParseFilter ; 
} 
} 

public class DOMBuilder { 
protected void append ( Node newNode ) throws org . xml . sax . SAXException { 
Node currentNode = m_currentNode ; 
if ( null != currentNode ) currentNode . appendChild ( newNode ) ; 
else if ( null != m_docFrag ) m_docFrag . appendChild ( newNode ) ; 
else { 
boolean ok = true ; 
short type = newNode . getNodeType ( ) ; 
if ( type == Node . TEXT_NODE ) { 
String data = newNode . getNodeValue ( ) ; 
if ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) throw new org . xml . sax . SAXException ( "Warning: can't output text before document element!  Ignoring..." ) ; 
ok = false ; 
} 
else if ( type == Node . ELEMENT_NODE ) if ( m_doc . getDocumentElement ( ) != null ) throw new org . xml . sax . SAXException ( "Can't have more than one root on a DOM!" ) ; 
if ( ok ) m_doc . appendChild ( newNode ) ; 
} 
} 
} 

public class DOMBuilder { 
@ Override public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { 
if ( isOutsideDocElem ( ) ) return ; 
String s = new String ( ch , start , length ) ; 
append ( m_doc . createTextNode ( s ) ) ; 
} 
} 

public class DOMBuilder { 
@ Override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { 
if ( ch == null || start < 0 || length >= ( ch . length - start ) || length < 0 ) return ; 
append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; 
} 
} 

public class DOMBuilder { 
public void cdata ( char ch [ ] , int start , int length ) { 
if ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; 
String s = new String ( ch , start , length ) ; 
Node n = m_currentNode . getLastChild ( ) ; 
if ( n instanceof CDATASection ) ( ( CDATASection ) n ) . appendData ( s ) ; 
else if ( n instanceof Comment ) ( ( Comment ) n ) . appendData ( s ) ; 
} 
} 

public class AbstractIndexerBolt { 
protected String valueForURL ( Tuple tuple ) { 
String url = tuple . getStringByField ( "url" ) ; 
Metadata metadata = ( Metadata ) tuple . getValueByField ( "metadata" ) ; 
if ( StringUtils . isBlank ( canonicalMetadataParamName ) ) return url ; 
String canonicalValue = metadata . getFirstValue ( canonicalMetadataName ) ; 
if ( StringUtils . isBlank ( canonicalValue ) ) return url ; 
try { 
URL sURL = new URL ( url ) ; 
URL canonical = URLUtil . resolveURL ( sURL , canonicalValue ) ; 
String sDomain = PaidLevelDomain . getPLD ( sURL . getHost ( ) ) ; 
String canonicalDomain = PaidLevelDomain . getPLD ( canonical . getHost ( ) ) ; 
if ( sDomain . equalsIgnoreCase ( canonicalDomain ) ) return canonical . toExternalForm ( ) ; 
else LOG . info ( "Canonical URL references a different domain, ignoring in {} " , url ) ; 
} 
catch ( MalformedURLException e ) { 
LOG . error ( "Malformed canonical URL {} was found in {} " , canonicalValue , url ) ; 
} 
return url ; 
} 
} 

public class DefaultScheduler { 
protected final Optional < Integer > checkCustomInterval ( Metadata metadata , Status s ) { 
if ( customIntervals == null ) return Optional . empty ( ) ; 
for ( CustomInterval customInterval : customIntervals ) { 
String [ ] values = metadata . getValues ( customInterval . key ) ; 
if ( values == null ) continue ; 
for ( String v : values ) { 
if ( v . equals ( customInterval . value ) ) return customInterval . getDurationForStatus ( s ) ; 
} 
} 
return Optional . empty ( ) ; 
} 
} 

public class URLFilters { 
public static URLFilters fromConf ( Map stormConf ) { 
String configFile = ConfUtils . getString ( stormConf , "urlfilters.config.file" ) ; 
if ( StringUtils . isNotBlank ( configFile ) ) try { 
return new URLFilters ( stormConf , configFile ) ; 
} 
catch ( IOException e ) { 
String message = "Exception caught while loading the URLFilters from " + configFile ; 
LOG . error ( message ) ; 
throw new RuntimeException ( message , e ) ; 
} 
return URLFilters . emptyURLFilters ; 
} 
} 

public class WheelView { 
public void setWheelItemCount ( int count ) { 
mItemCount = count ; 
mItemAngle = calculateItemAngle ( count ) ; 
if ( mWheelBounds != null ) invalidate ( ) ; 
} 
} 

public class WheelView { 
public static int resolveSizeAndState ( int size , int measureSpec ) { 
int result = size ; 
int specMode = MeasureSpec . getMode ( measureSpec ) ; 
int specSize = MeasureSpec . getSize ( measureSpec ) ; 
switch ( specMode ) { 
case MeasureSpec . UNSPECIFIED : result = size ; 
break ; 
case MeasureSpec . AT_MOST : if ( specSize < size ) result = specSize ; 
else result = size ; 
break ; 
case MeasureSpec . EXACTLY : result = specSize ; 
break ; 
} 
return result ; 
} 
} 

public class WheelView { 
public void setEmptyItemDrawable ( Drawable drawable ) { 
mEmptyItemDrawable = drawable ; 
EMPTY_CACHE_ITEM . mDrawable = drawable ; 
if ( mWheelBounds != null ) invalidate ( ) ; 
} 
} 

public class WheelView { 
public void setAngle ( float angle ) { 
mAngle = angle ; 
updateSelectedPosition ( ) ; 
if ( mOnAngleChangeListener != null ) mOnAngleChangeListener . onWheelAngleChange ( mAngle ) ; 
invalidate ( ) ; 
} 
} 

public class WheelView { 
private void update ( float deltaTime ) { 
float vel = mAngularVelocity ; 
float velSqr = vel * vel ; 
if ( vel > 0f ) { 
mAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; 
if ( mAngularVelocity < 0f ) mAngularVelocity = 0f ; 
} 
else if ( vel < 0f ) { 
mAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; 
if ( mAngularVelocity > 0f ) mAngularVelocity = 0f ; 
} 
if ( mAngularVelocity != 0f ) addAngle ( mAngularVelocity * deltaTime ) ; 
else mRequiresUpdate = false ; 
} 
} 

public class Circle { 
static int clamp ( int value , int upperLimit ) { 
if ( value < 0 ) return value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; 
else return value % upperLimit ; 
} 
} 

public class ArrayChar { 
public ArrayObject make1DStringArray ( ) { 
int nelems = ( getRank ( ) == 0 ) ? 1 : ( int ) getSize ( ) / indexCalc . getShape ( getRank ( ) - 1 ) ; 
Array sarr = Array . factory ( DataType . STRING , new int [ ] { 
nelems } 
) ; 
IndexIterator newsiter = sarr . getIndexIterator ( ) ; 
ArrayChar . StringIterator siter = getStringIterator ( ) ; 
while ( siter . hasNext ( ) ) newsiter . setObjectNext ( siter . next ( ) ) ; 
return ( ArrayObject ) sarr ; 
} 
} 

public class CfsrLocalTables { 
@ Override public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { 
Grib2Pds pds = gr . getPDS ( ) ; 
if ( ! pds . isTimeInterval ( ) ) return null ; 
int statType = pds . getOctet ( 47 ) ; 
int n = pds . getInt4StartingAtOctet ( 50 ) ; 
int p2 = pds . getInt4StartingAtOctet ( 55 ) ; 
int p2mp1 = pds . getInt4StartingAtOctet ( 62 ) ; 
int p1 = p2 - p2mp1 ; 
int start , end ; 
switch ( statType ) { 
case 193 : start = p1 ; 
end = p1 + n * p2 ; 
break ; 
case 194 : start = 0 ; 
end = n * p2 ; 
break ; 
case 195 : case 204 : case 205 : start = p1 ; 
end = p2 ; 
break ; 
default : throw new IllegalArgumentException ( "unknown statType " + statType ) ; 
} 
return new int [ ] { 
start , end } 
; 
} 
} 

public class UnitName { 
protected String makePlural ( final String name ) { 
String plural ; 
final int length = name . length ( ) ; 
final char lastChar = name . charAt ( length - 1 ) ; 
if ( lastChar != 'y' ) plural = name + ( lastChar == 's' || lastChar == 'x' || lastChar == 'z' || name . endsWith ( "ch" ) ? "es" : "s" ) ; 
else if ( length == 1 ) plural = name + "s" ; 
else { 
final char penultimateChar = name . charAt ( length - 2 ) ; 
plural = ( penultimateChar == 'a' || penultimateChar == 'e' || penultimateChar == 'i' || penultimateChar == 'o' || penultimateChar == 'u' ) ? name + "s" : name . substring ( 0 , length - 1 ) + "ies" ; 
} 
return plural ; 
} 
} 

public class DateRange { 
private void recalcDuration ( ) { 
long min = getStart ( ) . getDate ( ) . getTime ( ) ; 
long max = getEnd ( ) . getDate ( ) . getTime ( ) ; 
double secs = .001 * ( max - min ) ; 
if ( secs < 0 ) secs = 0 ; 
if ( duration == null ) try { 
duration = new TimeDuration ( chooseResolution ( secs ) ) ; 
} 
catch ( ParseException e ) { 
throw new RuntimeException ( e ) ; 
} 
if ( resolution == null ) duration . setValueInSeconds ( secs ) ; 
else { 
double resSecs = resolution . getValueInSeconds ( ) ; 
double closest = Math . round ( secs / resSecs ) ; 
secs = closest * resSecs ; 
duration . setValueInSeconds ( secs ) ; 
} 
hashCode = 0 ; 
} 
} 

public class GridUI { 
public void addMapBean ( MapBean mb ) { 
mapBeanMenu . addAction ( mb . getActionDesc ( ) , mb . getIcon ( ) , mb . getAction ( ) ) ; 
if ( mapBeanCount == 0 ) setMapRenderer ( mb . getRenderer ( ) ) ; 
mapBeanCount ++ ; 
mb . addPropertyChangeListener ( new PropertyChangeListener ( ) { 
public void propertyChange ( java . beans . PropertyChangeEvent e ) { 
if ( e . getPropertyName ( ) . equals ( "Renderer" ) ) setMapRenderer ( ( Renderer ) e . getNewValue ( ) ) ; 
} 
} 
) ; 
} 
} 

public class CatalogWatcher { 
public void register ( Path dir ) throws IOException { 
if ( ! enable ) return ; 
WatchKey key = dir . register ( watcher , ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY ) ; 
if ( trace ) { 
Path prev = keys . get ( key ) ; 
if ( prev == null ) System . out . format ( "CatalogWatcher register: %s%n" , dir ) ; 
else if ( ! dir . equals ( prev ) ) System . out . format ( "update: %s -> %s%n" , prev , dir ) ; 
} 
keys . put ( key , dir ) ; 
} 
} 

public class CatalogWatcher { 
public void processEvents ( ) { 
if ( ! enable ) return ; 
for ( ; 
; 
) { 
WatchKey key ; 
try { 
key = watcher . take ( ) ; 
} 
catch ( InterruptedException x ) { 
return ; 
} 
Path dir = keys . get ( key ) ; 
if ( dir == null ) { 
System . err . println ( "WatchKey not recognized!!" ) ; 
continue ; 
} 
for ( WatchEvent < ? > event : key . pollEvents ( ) ) { 
WatchEvent . Kind kind = event . kind ( ) ; 
if ( kind == OVERFLOW ) continue ; 
WatchEvent < Path > ev = cast ( event ) ; 
Path name = ev . context ( ) ; 
Path child = dir . resolve ( name ) ; 
System . out . format ( "%s: %s%n" , event . kind ( ) . name ( ) , child ) ; 
if ( recursive && ( kind == ENTRY_CREATE ) ) try { 
if ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) registerAll ( child ) ; 
} 
catch ( IOException x ) { 
} 
} 
boolean valid = key . reset ( ) ; 
if ( ! valid ) { 
keys . remove ( key ) ; 
if ( keys . isEmpty ( ) ) break ; 
} 
} 
} 
} 

public class FeatureDatasetFactoryManager { 
static public FeatureDataset open ( FeatureType wantFeatureType , String location , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { 
if ( location . startsWith ( DataFactory . SCHEME ) ) { 
DataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( wantFeatureType , location , task ) ; 
errlog . format ( "%s" , result . errLog ) ; 
if ( ! featureTypeOk ( wantFeatureType , result . featureType ) ) { 
errlog . format ( "wanted %s but dataset is of type %s%n" , wantFeatureType , result . featureType ) ; 
result . close ( ) ; 
return null ; 
} 
return result . featureDataset ; 
} 
else if ( location . startsWith ( CdmrFeatureDataset . SCHEME ) ) { 
Optional < FeatureDataset > opt = CdmrFeatureDataset . factory ( wantFeatureType , location ) ; 
if ( opt . isPresent ( ) ) return opt . get ( ) ; 
errlog . format ( "%s" , opt . getErrorMessage ( ) ) ; 
return null ; 
} 
else if ( location . startsWith ( ucar . nc2 . ft . point . collection . CompositeDatasetFactory . SCHEME ) ) { 
String spec = location . substring ( CompositeDatasetFactory . SCHEME . length ( ) ) ; 
MFileCollectionManager dcm = MFileCollectionManager . open ( spec , spec , null , errlog ) ; 
return CompositeDatasetFactory . factory ( location , wantFeatureType , dcm , errlog ) ; 
} 
DatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; 
if ( durl . serviceType == null ) { 
Optional < FeatureDatasetCoverage > opt = CoverageDatasetFactory . openGrib ( location ) ; 
if ( opt . isPresent ( ) ) return opt . get ( ) ; 
else if ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NOT_GRIB_FILE ) && ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NO_GRIB_CLASS ) ) { 
errlog . format ( "%s%n" , opt . getErrorMessage ( ) ) ; 
return null ; 
} 
} 
NetcdfDataset ncd = NetcdfDataset . acquireDataset ( durl , true , task ) ; 
FeatureDataset fd = wrap ( wantFeatureType , ncd , task , errlog ) ; 
if ( fd == null ) ncd . close ( ) ; 
return fd ; 
} 
} 

public class FeatureDatasetFactoryManager { 
static public FeatureDataset wrap ( FeatureType wantFeatureType , NetcdfDataset ncd , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { 
if ( debug ) System . out . println ( "wrap " + ncd . getLocation ( ) + " want = " + wantFeatureType ) ; 
if ( ( wantFeatureType == null ) || ( wantFeatureType == FeatureType . ANY ) ) return wrapUnknown ( ncd , task , errlog ) ; 
Object analysis = null ; 
FeatureDatasetFactory useFactory = null ; 
for ( Factory fac : factoryList ) { 
if ( ! featureTypeOk ( wantFeatureType , fac . featureType ) ) continue ; 
if ( debug ) System . out . println ( " wrap try factory " + fac . factory . getClass ( ) . getName ( ) ) ; 
analysis = fac . factory . isMine ( wantFeatureType , ncd , errlog ) ; 
if ( analysis != null ) { 
useFactory = fac . factory ; 
break ; 
} 
} 
if ( null == useFactory ) { 
errlog . format ( "**Failed to find FeatureDatasetFactory for= %s datatype=%s%n" , ncd . getLocation ( ) , wantFeatureType ) ; 
return null ; 
} 
return useFactory . open ( wantFeatureType , ncd , analysis , task , errlog ) ; 
} 
} 

public class FeatureDatasetFactoryManager { 
static public boolean featureTypeOk ( FeatureType want , FeatureType facType ) { 
if ( want == null ) return true ; 
if ( want == facType ) return true ; 
if ( want == FeatureType . ANY_POINT ) return facType . isPointFeatureType ( ) ; 
if ( facType == FeatureType . ANY_POINT ) return want . isPointFeatureType ( ) ; 
if ( want == FeatureType . COVERAGE ) return facType . isCoverageFeatureType ( ) ; 
if ( want == FeatureType . GRID ) return facType . isCoverageFeatureType ( ) ; 
if ( want == FeatureType . SIMPLE_GEOMETRY ) return facType . isCoverageFeatureType ( ) ; 
if ( want == FeatureType . UGRID ) return facType . isUnstructuredGridFeatureType ( ) ; 
return false ; 
} 
} 

public class FeatureDatasetFactoryManager { 
static public FeatureType findFeatureType ( NetcdfFile ncd ) { 
String cdm_datatype = ncd . findAttValueIgnoreCase ( null , CF . FEATURE_TYPE , null ) ; 
if ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , "cdm_data_type" , null ) ; 
if ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , "cdm_datatype" , null ) ; 
if ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , "thredds_data_type" , null ) ; 
if ( cdm_datatype != null ) for ( FeatureType ft : FeatureType . values ( ) ) if ( cdm_datatype . equalsIgnoreCase ( ft . name ( ) ) ) { 
if ( debug ) System . out . println ( " wrapUnknown found cdm_datatype " + cdm_datatype ) ; 
return ft ; 
} 
CF . FeatureType cff = CF . FeatureType . getFeatureTypeFromGlobalAttribute ( ncd ) ; 
if ( cff != null ) return CF . FeatureType . convert ( cff ) ; 
return null ; 
} 
} 

public class CatalogManager { 
private Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { 
boolean isLatest = path . endsWith ( "/latest.xml" ) ; 
int pos = path . lastIndexOf ( "/" ) ; 
String workPath = ( pos >= 0 ) ? path . substring ( 0 , pos ) : path ; 
String filename = ( pos > 0 ) ? path . substring ( pos + 1 ) : path ; 
DataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; 
if ( match == null ) return null ; 
if ( match . dataRoot . getFeatureCollection ( ) != null ) { 
InvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; 
if ( isLatest ) return fc . makeLatest ( match . remaining , path , baseURI ) ; 
else return fc . makeCatalog ( match . remaining , path , baseURI ) ; 
} 
DatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; 
if ( dscan != null ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( " + baseURI + ", " + path + ")." ) ; 
CatalogBuilder cat ; 
if ( isLatest ) cat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; 
else cat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; 
if ( null == cat ) log . error ( "makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = " + workPath ) ; 
return cat ; 
} 
CatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; 
if ( catScan != null ) { 
if ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) return catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( "makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( " + baseURI + ", " + path + ")." ) ; 
CatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; 
if ( null == cat ) log . error ( "makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = " + workPath ) ; 
return cat ; 
} 
log . warn ( "makeDynamicCatalog() failed for =" + workPath + " request path= " + path ) ; 
return null ; 
} 
} 

public class InvDatasetFcGrib { 
@ Override public CatalogBuilder makeCatalog ( String match , String reqPath , URI catURI ) throws IOException { 
StateGrib localState = ( StateGrib ) checkState ( ) ; 
if ( localState == null ) return null ; 
if ( localState . gribCollection == null ) return null ; 
try { 
if ( ( match == null ) || ( match . length ( ) == 0 ) ) return makeCatalogTop ( catURI , localState ) ; 
if ( localState . gribCollection instanceof PartitionCollectionImmutable ) { 
String [ ] paths = match . split ( "/" ) ; 
PartitionCollectionImmutable pc = ( PartitionCollectionImmutable ) localState . gribCollection ; 
return makeCatalogFromPartition ( pc , paths , 0 , catURI ) ; 
} 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
logger . error ( "Error making catalog for " + configPath , e ) ; 
} 
return null ; 
} 
} 

public class NOWRadheader { 
int readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { 
int pos = 0 ; 
raf . seek ( pos ) ; 
int readLen = 35 ; 
byte [ ] b = new byte [ readLen ] ; 
int rc = raf . read ( b ) ; 
if ( rc != readLen ) return 0 ; 
if ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) return 0 ; 
String pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; 
if ( pidd . contains ( "NOWRA" ) || pidd . contains ( "USRAD" ) || pidd . contains ( "NEX" ) ) return 1 ; 
else return 0 ; 
} 
} 

public class NOWRadheader { 
public static int bytesToInt ( byte [ ] bytes , boolean swapBytes ) { 
byte a = bytes [ 0 ] ; 
byte b = bytes [ 1 ] ; 
byte c = bytes [ 2 ] ; 
byte d = bytes [ 3 ] ; 
if ( swapBytes ) return ( ( a & 0xff ) ) + ( ( b & 0xff ) << 8 ) + ( ( c & 0xff ) << 16 ) + ( ( d & 0xff ) << 24 ) ; 
else return ( ( a & 0xff ) << 24 ) + ( ( b & 0xff ) << 16 ) + ( ( c & 0xff ) << 8 ) + ( ( d & 0xff ) ) ; 
} 
} 

public class N3iosp { 
public static String makeValidNetcdfObjectName ( String name ) { 
StringBuilder sb = new StringBuilder ( name ) ; 
while ( sb . length ( ) > 0 ) { 
int cp = sb . codePointAt ( 0 ) ; 
if ( cp <= 0x7f ) if ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { 
sb . deleteCharAt ( 0 ) ; 
continue ; 
} 
break ; 
} 
for ( int pos = 1 ; 
pos < sb . length ( ) ; 
++ pos ) { 
int cp = sb . codePointAt ( pos ) ; 
if ( cp <= 0x7F ) if ( cp < ' ' || cp > 0x7E || cp == '/' ) { 
sb . deleteCharAt ( pos ) ; 
-- pos ; 
} 
} 
while ( sb . length ( ) > 0 ) { 
int cp = sb . codePointAt ( sb . length ( ) - 1 ) ; 
if ( cp <= 0x7f && Character . isWhitespace ( cp ) ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; 
else break ; 
} 
if ( sb . length ( ) == 0 ) throw new IllegalArgumentException ( String . format ( "Illegal NetCDF object name: '%s'" , name ) ) ; 
return sb . toString ( ) ; 
} 
} 

public class GradsTimeDimension { 
public static boolean hasTimeTemplate ( String template ) { 
for ( int i = 0 ; 
i < timeTemplates . length ; 
i ++ ) if ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) return true ; 
return false ; 
} 
} 

public class FunctionLibrary { 
public void add ( ServerSideFunction function ) { 
if ( function instanceof BoolFunction ) boolFunctions . put ( function . getName ( ) , function ) ; 
if ( function instanceof BTFunction ) btFunctions . put ( function . getName ( ) , function ) ; 
} 
} 

public class FunctionLibrary { 
public BoolFunction getBoolFunction ( String name ) throws NoSuchFunctionException { 
if ( ! boolFunctions . containsKey ( name ) ) loadNewFunction ( name ) ; 
return ( BoolFunction ) boolFunctions . get ( name ) ; 
} 
} 

public class FunctionLibrary { 
public BTFunction getBTFunction ( String name ) throws NoSuchFunctionException { 
if ( ! btFunctions . containsKey ( name ) ) loadNewFunction ( name ) ; 
return ( BTFunction ) btFunctions . get ( name ) ; 
} 
} 

public class McIDASLookup { 
public final String getLevelName ( GridRecord gr ) { 
if ( cust != null ) { 
String result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; 
if ( result != null ) return result ; 
} 
String levelUnit = getLevelUnit ( gr ) ; 
if ( levelUnit != null ) { 
int level1 = ( int ) gr . getLevel1 ( ) ; 
int level2 = ( int ) gr . getLevel2 ( ) ; 
if ( levelUnit . equalsIgnoreCase ( "hPa" ) ) return "pressure" ; 
else if ( level1 == 1013 ) return "mean sea level" ; 
else if ( level1 == 0 ) return "tropopause" ; 
else if ( level1 == 1001 ) return "surface" ; 
else if ( level2 != 0 ) return "layer" ; 
} 
return "" ; 
} 
} 

public class McIDASLookup { 
public final boolean isVerticalCoordinate ( GridRecord gr ) { 
if ( cust != null ) return cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; 
int type = gr . getLevelType1 ( ) ; 
if ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { 
if ( type == 20 ) return true ; 
if ( type == 100 ) return true ; 
if ( type == 101 ) return true ; 
if ( ( type >= 103 ) && ( type <= 128 ) ) return true ; 
if ( type == 141 ) return true ; 
if ( type == 160 ) return true ; 
} 
else if ( getLevelUnit ( gr ) . equals ( "hPa" ) ) return true ; 
return false ; 
} 
} 

public class McIDASLookup { 
public boolean isLayer ( GridRecord gr ) { 
if ( cust != null ) return cust . isLayer ( gr . getLevelType1 ( ) ) ; 
if ( gr . getLevel2 ( ) == 0 ) return false ; 
return true ; 
} 
} 

public class CoordTransBuilder { 
static public CoordinateTransform makeCoordinateTransform ( NetcdfDataset ds , AttributeContainer ctv , Formatter parseInfo , Formatter errInfo ) { 
String transform_name = ctv . findAttValueIgnoreCase ( "transform_name" , null ) ; 
if ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( "Projection_Name" , null ) ; 
if ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . GRID_MAPPING_NAME , null ) ; 
if ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . STANDARD_NAME , null ) ; 
if ( null == transform_name ) { 
parseInfo . format ( "**Failed to find Coordinate Transform name from Variable= %s%n" , ctv ) ; 
return null ; 
} 
transform_name = transform_name . trim ( ) ; 
Class builderClass = null ; 
for ( Transform transform : transformList ) { 
if ( transform . transName . equals ( transform_name ) ) { 
builderClass = transform . transClass ; 
break ; 
} 
} 
if ( null == builderClass ) { 
parseInfo . format ( "**Failed to find CoordTransBuilder name= %s from Variable= %s%n" , transform_name , ctv ) ; 
return null ; 
} 
Object builderObject ; 
try { 
builderObject = builderClass . newInstance ( ) ; 
} 
catch ( InstantiationException | IllegalAccessException e ) { 
log . error ( "Cant create new instance " + builderClass . getName ( ) , e ) ; 
return null ; 
} 
if ( null == builderObject ) { 
parseInfo . format ( "**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n" , builderClass . getName ( ) , ctv ) ; 
return null ; 
} 
CoordinateTransform ct ; 
if ( builderObject instanceof VertTransformBuilderIF ) { 
VertTransformBuilderIF vertBuilder = ( VertTransformBuilderIF ) builderObject ; 
vertBuilder . setErrorBuffer ( errInfo ) ; 
ct = vertBuilder . makeCoordinateTransform ( ds , ctv ) ; 
} 
else if ( builderObject instanceof HorizTransformBuilderIF ) { 
HorizTransformBuilderIF horizBuilder = ( HorizTransformBuilderIF ) builderObject ; 
horizBuilder . setErrorBuffer ( errInfo ) ; 
String units = AbstractTransformBuilder . getGeoCoordinateUnits ( ds , ctv ) ; 
ct = horizBuilder . makeCoordinateTransform ( ctv , units ) ; 
} 
else { 
log . error ( "Illegals class " + builderClass . getName ( ) ) ; 
return null ; 
} 
if ( ct != null ) parseInfo . format ( " Made Coordinate transform %s from variable %s: %s%n" , transform_name , ctv . getName ( ) , builderObject . getClass ( ) . getName ( ) ) ; 
return ct ; 
} 
} 

public class ThreddsDatasetChooser { 
public static void main ( String args [ ] ) { 
boolean usePopup = false ; 
for ( int i = 0 ; 
i < args . length ; 
i ++ ) if ( args [ i ] . equals ( "-usePopup" ) ) usePopup = true ; 
try { 
store = XMLStore . createFromFile ( "ThreddsDatasetChooser" , null ) ; 
p = store . getPreferences ( ) ; 
} 
catch ( IOException e ) { 
System . out . println ( "XMLStore Creation failed " + e ) ; 
} 
final JFrame frame = new JFrame ( "Thredds Dataset Chooser" ) ; 
frame . addWindowListener ( new WindowAdapter ( ) { 
public void windowClosing ( WindowEvent e ) { 
chooser . save ( ) ; 
Rectangle bounds = frame . getBounds ( ) ; 
p . putBeanObject ( FRAME_SIZE , bounds ) ; 
try { 
store . save ( ) ; 
} 
catch ( IOException ioe ) { 
ioe . printStackTrace ( ) ; 
} 
System . exit ( 0 ) ; 
} 
} 
) ; 
chooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; 
chooser . setDoResolve ( true ) ; 
frame . getContentPane ( ) . add ( chooser ) ; 
Rectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; 
frame . setBounds ( bounds ) ; 
frame . pack ( ) ; 
frame . setBounds ( bounds ) ; 
frame . setVisible ( true ) ; 
} 
} 

public class SerialWriter { 
public void writeCount ( long count ) throws IOException { 
countbuffer . clear ( ) ; 
countbuffer . putLong ( count ) ; 
byte [ ] countbuf = countbuffer . array ( ) ; 
int len = countbuffer . position ( ) ; 
writeBytes ( countbuf , len ) ; 
if ( DEBUG ) System . err . printf ( "count: %d%n" , count ) ; 
} 
} 

public class SerialWriter { 
public void writeBytes ( byte [ ] bytes , int len ) throws IOException { 
outputBytes ( bytes , 0 , len ) ; 
if ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { 
this . checksum . update ( bytes , 0 , len ) ; 
if ( DUMPCSUM ) { 
System . err . print ( "SSS " ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) System . err . printf ( "%02x" , bytes [ i ] ) ; 
System . err . println ( ) ; 
} 
} 
} 
} 

public class SerialWriter { 
public void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { 
if ( DUMPDATA ) { 
System . err . printf ( "output %d/%d:" , start , count ) ; 
for ( int i = 0 ; 
i < count ; 
i ++ ) System . err . printf ( " %02x" , bytes [ i ] ) ; 
System . err . println ( "" ) ; 
System . err . flush ( ) ; 
} 
output . write ( bytes , start , count ) ; 
} 
} 

public class McIDASGridReader { 
public float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { 
float [ ] data ; 
int te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; 
int rows = gr . getRows ( ) ; 
int cols = gr . getColumns ( ) ; 
rf . seek ( te ) ; 
float scale = ( float ) gr . getParamScale ( ) ; 
data = new float [ rows * cols ] ; 
rf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; 
for ( int nc = 0 ; 
nc < cols ; 
nc ++ ) for ( int nr = 0 ; 
nr < rows ; 
nr ++ ) { 
int temp = rf . readInt ( ) ; 
data [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; 
} 
rf . order ( RandomAccessFile . BIG_ENDIAN ) ; 
return data ; 
} 
} 

public class McIDASGridReader { 
public static void main ( String [ ] args ) throws IOException { 
String file = "GRID2001" ; 
if ( args . length > 0 ) file = args [ 0 ] ; 
McIDASGridReader mg = new McIDASGridReader ( file ) ; 
GridIndex gridIndex = mg . getGridIndex ( ) ; 
List grids = gridIndex . getGridRecords ( ) ; 
System . out . println ( "found " + grids . size ( ) + " grids" ) ; 
int num = Math . min ( grids . size ( ) , 10 ) ; 
for ( int i = 0 ; 
i < num ; 
i ++ ) System . out . println ( grids . get ( i ) ) ; 
} 
} 

public class GempakGridReader { 
public int getGridPackingType ( int gridNumber ) throws IOException { 
int irow = 1 ; 
if ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { 
logWarning ( "bad grid number " + gridNumber ) ; 
return - 9 ; 
} 
int iprt = getPartNumber ( "GRID" ) ; 
if ( iprt == 0 ) { 
logWarning ( "couldn't find part: GRID" ) ; 
return - 10 ; 
} 
DMPart part = parts . get ( iprt - 1 ) ; 
if ( part . ktyprt != MDGRID ) { 
logWarning ( "Not a valid type: " + GempakUtil . getDataType ( part . ktyprt ) ) ; 
return - 21 ; 
} 
int ilenhd = part . klnhdr ; 
int ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; 
int istart = DM_RINT ( ipoint ) ; 
if ( istart == 0 ) return - 15 ; 
int length = DM_RINT ( istart ) ; 
int isword = istart + 1 ; 
if ( length <= ilenhd ) { 
logWarning ( "length (" + length + ") is less than header length (" + ilenhd + ")" ) ; 
return - 15 ; 
} 
else if ( Math . abs ( length ) > 10000000 ) { 
logWarning ( "length is huge: " + length ) ; 
return - 34 ; 
} 
int [ ] header = new int [ ilenhd ] ; 
DM_RINT ( isword , header ) ; 
isword += ilenhd ; 
return DM_RINT ( isword ) ; 
} 
} 

public class GempakGridReader { 
public GempakGridRecord findGrid ( String parm ) { 
List < GridRecord > gridList = gridIndex . getGridRecords ( ) ; 
if ( gridList == null ) return null ; 
for ( GridRecord grid : gridList ) { 
GempakGridRecord gh = ( GempakGridRecord ) grid ; 
if ( gh . param . trim ( ) . equals ( parm ) ) return gh ; 
} 
return null ; 
} 
} 

public class GempakGridReader { 
public float [ ] DM_RPKG ( int isword , int nword , int decimalScale ) throws IOException { 
float [ ] data ; 
int ipktyp = DM_RINT ( isword ) ; 
int iiword = isword + 1 ; 
int lendat = nword - 1 ; 
if ( ipktyp == MDGNON ) { 
data = new float [ lendat ] ; 
DM_RFLT ( iiword , data ) ; 
return data ; 
} 
int iiw ; 
int irw ; 
if ( ipktyp == MDGDIF ) { 
iiw = 4 ; 
irw = 3 ; 
} 
else if ( ipktyp == MDGRB2 ) { 
iiw = 4 ; 
irw = 1 ; 
} 
else { 
iiw = 3 ; 
irw = 2 ; 
} 
int [ ] iarray = new int [ iiw ] ; 
float [ ] rarray = new float [ irw ] ; 
DM_RINT ( iiword , iarray ) ; 
iiword = iiword + iiw ; 
lendat = lendat - iiw ; 
DM_RFLT ( iiword , rarray ) ; 
iiword = iiword + irw ; 
lendat = lendat - irw ; 
if ( ipktyp == MDGRB2 ) { 
data = unpackGrib2Data ( iiword , lendat , iarray , rarray ) ; 
return data ; 
} 
int nbits = iarray [ 0 ] ; 
int misflg = iarray [ 1 ] ; 
boolean miss = misflg != 0 ; 
int kxky = iarray [ 2 ] ; 
int kx = 0 ; 
if ( iiw == 4 ) kx = iarray [ 3 ] ; 
float ref = rarray [ 0 ] ; 
float scale = rarray [ 1 ] ; 
float difmin = 0 ; 
if ( irw == 3 ) difmin = rarray [ 2 ] ; 
data = unpackData ( iiword , lendat , ipktyp , kxky , nbits , ref , scale , miss , difmin , kx , decimalScale ) ; 
return data ; 
} 
} 

public class GempakGridReader { 
private synchronized float [ ] unpackData ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalScale ) throws IOException { 
if ( ipktyp == MDGGRB ) if ( ! useDP ) return unpackGrib1Data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalScale ) ; 
else { 
if ( nword * 32 < kxky * nbits ) nword ++ ; 
int [ ] ksgrid = new int [ nword ] ; 
DM_RINT ( iiword , ksgrid ) ; 
return DP_UGRB ( ksgrid , kxky , nbits , ref , scale , miss , decimalScale ) ; 
} 
else if ( ipktyp == MDGNMC ) return null ; 
else if ( ipktyp == MDGDIF ) return null ; 
return null ; 
} 
} 

public class GempakGridReader { 
private synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { 
float scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; 
float [ ] grid = new float [ kxky ] ; 
if ( ( nbits <= 1 ) || ( nbits > 31 ) ) return grid ; 
if ( scale == 0. ) return grid ; 
int imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; 
int iword = 0 ; 
int ibit = 1 ; 
for ( int i = 0 ; 
i < kxky ; 
i ++ ) { 
int jshft = nbits + ibit - 33 ; 
int idat = 0 ; 
idat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; 
idat = idat & imax ; 
if ( jshft > 0 ) { 
jshft -= 32 ; 
int idat2 = 0 ; 
idat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; 
idat = idat | idat2 ; 
} 
if ( ( idat == imax ) && misflg ) grid [ i ] = RMISSD ; 
else grid [ i ] = ( qmin + idat * scale ) * scaleFactor ; 
ibit += nbits ; 
if ( ibit > 32 ) { 
ibit -= 32 ; 
iword ++ ; 
} 
} 
return grid ; 
} 
} 

public class GempakGridReader { 
private float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { 
float [ ] values = new float [ kxky ] ; 
bitPos = 0 ; 
bitBuf = 0 ; 
next = 0 ; 
ch1 = 0 ; 
ch2 = 0 ; 
ch3 = 0 ; 
ch4 = 0 ; 
rf . seek ( getOffset ( iiword ) ) ; 
int idat ; 
float scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; 
for ( int i = 0 ; 
i < values . length ; 
i ++ ) { 
idat = bits2UInt ( nbits ) ; 
if ( miss && ( idat == IMISSD ) ) values [ i ] = IMISSD ; 
else values [ i ] = ( ref + scale * idat ) * scaleFactor ; 
} 
return values ; 
} 
} 

public class GempakGridReader { 
private float [ ] unpackGrib2Data ( int iiword , int lendat , int [ ] iarray , float [ ] rarray ) throws IOException { 
long start = getOffset ( iiword ) ; 
rf . seek ( start ) ; 
Grib2Record gr = makeGribRecord ( rf , start ) ; 
float [ ] data = gr . readData ( rf ) ; 
if ( ( ( iarray [ 3 ] >> 6 ) & 1 ) == 0 ) data = gb2_ornt ( iarray [ 1 ] , iarray [ 2 ] , iarray [ 3 ] , data ) ; 
return data ; 
} 
} 

public class GempakGridReader { 
private void getNextByte ( ) throws IOException { 
if ( ! needToSwap ) bitBuf = rf . read ( ) ; 
else { 
if ( next == 3 ) bitBuf = ch3 ; 
else if ( next == 2 ) bitBuf = ch2 ; 
else if ( next == 1 ) bitBuf = ch1 ; 
else { 
ch1 = rf . read ( ) ; 
ch2 = rf . read ( ) ; 
ch3 = rf . read ( ) ; 
ch4 = rf . read ( ) ; 
bitBuf = ch4 ; 
next = 4 ; 
} 
next -- ; 
} 
} 
} 

public class CDMUtil { 
static public NetcdfFile unwrapfile ( NetcdfFile file ) { 
for ( ; 
; 
) if ( file instanceof NetcdfDataset ) { 
NetcdfDataset ds = ( NetcdfDataset ) file ; 
file = ds . getReferencedFile ( ) ; 
if ( file == null ) break ; 
} 
else break ; 
return file ; 
} 
} 

public class CDMUtil { 
static public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { 
if ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; 
int effectiverank = dimset . size ( ) ; 
int [ ] shape = new int [ effectiverank ] ; 
for ( int i = 0 ; 
i < effectiverank ; 
i ++ ) shape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; 
return shape ; 
} 
} 

public class ScaledUnit { 
public double toDerivedUnit ( final double amount ) throws ConversionException { 
if ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( this , getDerivedUnit ( ) ) ; 
return ( ( DerivableUnit ) _unit ) . toDerivedUnit ( amount * getScale ( ) ) ; 
} 
} 

public class ScaledUnit { 
public float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { 
final float scale = ( float ) getScale ( ) ; 
for ( int i = input . length ; 
-- i >= 0 ; 
) output [ i ] = input [ i ] * scale ; 
if ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( this , getDerivedUnit ( ) ) ; 
return ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; 
} 
} 

public class ScaledUnit { 
public double fromDerivedUnit ( final double amount ) throws ConversionException { 
if ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( getDerivedUnit ( ) , this ) ; 
return ( ( DerivableUnit ) getUnit ( ) ) . fromDerivedUnit ( amount ) / getScale ( ) ; 
} 
} 

public class SigmetIOServiceProvider { 
public Array readData1 ( ucar . nc2 . Variable v2 , Section section ) throws IOException , InvalidRangeException { 
int [ ] sh = section . getShape ( ) ; 
Array temp = Array . factory ( v2 . getDataType ( ) , sh ) ; 
long pos0 = 0 ; 
LayoutRegular index = new LayoutRegular ( pos0 , v2 . getElementSize ( ) , v2 . getShape ( ) , section ) ; 
if ( v2 . getShortName ( ) . startsWith ( "time" ) | v2 . getShortName ( ) . startsWith ( "numGates" ) ) temp = readIntData ( index , v2 ) ; 
else temp = readFloatData ( index , v2 ) ; 
return temp ; 
} 
} 

public class SigmetIOServiceProvider { 
public long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { 
Array data = readData ( v2 , section ) ; 
float [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; 
byte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; 
IndexIterator iter = data . getIndexIterator ( ) ; 
int i = 0 ; 
ByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; 
while ( iter . hasNext ( ) ) { 
ftdata [ i ] = iter . getFloatNext ( ) ; 
bytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; 
buffer . put ( bytedata [ i ] ) ; 
i ++ ; 
} 
buffer = ByteBuffer . wrap ( bytedata ) ; 
int count = channel . write ( buffer ) ; 
System . out . println ( "COUNT=" + count ) ; 
if ( buffer . hasRemaining ( ) ) buffer . compact ( ) ; 
else buffer . clear ( ) ; 
return ( long ) count ; 
} 
} 

public class SigmetIOServiceProvider { 
static float calcAz ( short az0 , short az1 ) { 
float azim0 = calcAngle ( az0 ) ; 
float azim1 = calcAngle ( az1 ) ; 
float d = 0.0f ; 
d = Math . abs ( azim0 - azim1 ) ; 
if ( ( az0 < 0 ) & ( az1 > 0 ) ) d = Math . abs ( 360.0f - azim0 ) + Math . abs ( azim1 ) ; 
double temp = azim0 + d * 0.5 ; 
if ( temp > 360.0 ) temp -= 360.0 ; 
BigDecimal bd = new BigDecimal ( temp ) ; 
BigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; 
return result . floatValue ( ) ; 
} 
} 

public class SigmetIOServiceProvider { 
static float calcData ( Map < String , Number > recHdr , short dty , byte data ) { 
short [ ] coef = { 
1 , 2 , 3 , 4 } 
; 
short multiprf = recHdr . get ( "multiprf" ) . shortValue ( ) ; 
float vNyq = recHdr . get ( "vNyq" ) . floatValue ( ) ; 
double temp = - 999.99 ; 
switch ( dty ) { 
default : if ( data != 0 ) temp = ( ( ( int ) data & 0xFF ) - 64 ) * 0.5 ; 
break ; 
case 3 : if ( data != 0 ) temp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; 
break ; 
case 4 : if ( data != 0 ) { 
double v = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; 
temp = ( ( ( int ) data & 0xFF ) / 256.0 ) * v ; 
} 
break ; 
case 5 : if ( data != 0 ) temp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 16.0 ) ; 
break ; 
} 
BigDecimal bd = new BigDecimal ( temp ) ; 
BigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; 
return result . floatValue ( ) ; 
} 
} 

public class GridServiceProvider { 
private void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { 
GridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; 
GridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; 
int nx = hsys . getNx ( ) ; 
GridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; 
if ( record == null ) { 
Attribute att = v2 . findAttribute ( "missing_value" ) ; 
float missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; 
int xyCount = yRange . length ( ) * xRange . length ( ) ; 
for ( int j = 0 ; 
j < xyCount ; 
j ++ ) ii . setFloatNext ( missing_value ) ; 
return ; 
} 
float [ ] data = _readData ( record ) ; 
if ( data == null ) { 
_readData ( record ) ; 
return ; 
} 
for ( int y : yRange ) { 
for ( int x : xRange ) { 
int index = y * nx + x ; 
ii . setFloatNext ( data [ index ] ) ; 
} 
} 
} 
} 

public class GridServiceProvider { 
public boolean isMissingXY ( Variable v2 , int timeIdx , int ensIdx , int levIdx ) throws InvalidRangeException { 
GridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; 
if ( ( timeIdx < 0 ) || ( timeIdx >= pv . getNTimes ( ) ) ) throw new InvalidRangeException ( "timeIdx=" + timeIdx ) ; 
if ( ( levIdx < 0 ) || ( levIdx >= pv . getVertNlevels ( ) ) ) throw new InvalidRangeException ( "levIdx=" + levIdx ) ; 
if ( ( ensIdx < 0 ) || ( ensIdx >= pv . getNEnsembles ( ) ) ) throw new InvalidRangeException ( "ensIdx=" + ensIdx ) ; 
return ( null == pv . findRecord ( ensIdx , timeIdx , levIdx ) ) ; 
} 
} 

public class DtCoverageCS { 
public LatLonRect getLatLonBoundingBox ( ) { 
if ( llbb == null ) { 
if ( ( getXHorizAxis ( ) instanceof CoordinateAxis2D ) && ( getYHorizAxis ( ) instanceof CoordinateAxis2D ) ) return null ; 
CoordinateAxis horizXaxis = getXHorizAxis ( ) ; 
CoordinateAxis horizYaxis = getYHorizAxis ( ) ; 
if ( isLatLon ( ) ) { 
double startLat = horizYaxis . getMinValue ( ) ; 
double startLon = horizXaxis . getMinValue ( ) ; 
double deltaLat = horizYaxis . getMaxValue ( ) - startLat ; 
double deltaLon = horizXaxis . getMaxValue ( ) - startLon ; 
LatLonPoint llpt = new LatLonPointImpl ( startLat , startLon ) ; 
llbb = new LatLonRect ( llpt , deltaLat , deltaLon ) ; 
} 
else { 
ProjectionImpl dataProjection = getProjection ( ) ; 
ProjectionRect bb = getBoundingBox ( ) ; 
if ( bb != null ) llbb = dataProjection . projToLatLonBB ( bb ) ; 
} 
} 
return llbb ; 
} 
} 

public class Format { 
public static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { 
int len = sbuff . length ( ) ; 
if ( tabStop > len ) { 
sbuff . setLength ( tabStop ) ; 
for ( int i = len ; 
i < tabStop ; 
i ++ ) sbuff . setCharAt ( i , ' ' ) ; 
} 
else if ( alwaysOne ) { 
sbuff . setLength ( len + 1 ) ; 
sbuff . setCharAt ( len , ' ' ) ; 
} 
} 
} 

public class Format { 
public static String pad ( String s , int width , boolean rightJustify ) { 
if ( s . length ( ) >= width ) return s ; 
StringBuilder sbuff = new StringBuilder ( width ) ; 
int need = width - s . length ( ) ; 
sbuff . setLength ( need ) ; 
for ( int i = 0 ; 
i < need ; 
i ++ ) sbuff . setCharAt ( i , ' ' ) ; 
if ( rightJustify ) sbuff . append ( s ) ; 
else sbuff . insert ( 0 , s ) ; 
return sbuff . toString ( ) ; 
} 
} 

public class Format { 
public static String formatByteSize ( double size ) { 
String unit = null ; 
if ( size > 1.0e15 ) { 
unit = "Pbytes" ; 
size *= 1.0e-15 ; 
} 
else if ( size > 1.0e12 ) { 
unit = "Tbytes" ; 
size *= 1.0e-12 ; 
} 
else if ( size > 1.0e9 ) { 
unit = "Gbytes" ; 
size *= 1.0e-9 ; 
} 
else if ( size > 1.0e6 ) { 
unit = "Mbytes" ; 
size *= 1.0e-6 ; 
} 
else if ( size > 1.0e3 ) { 
unit = "Kbytes" ; 
size *= 1.0e-3 ; 
} 
else unit = "bytes" ; 
return Format . d ( size , 4 ) + " " + unit ; 
} 
} 

public class Slice { 
public String toConstraintString ( ) throws DapException { 
assert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; 
if ( ( this . stop - this . first ) == 0 ) return String . format ( "[0]" ) ; 
else if ( this . stride == 1 ) if ( ( this . stop - this . first ) == 1 ) return String . format ( "[%d]" , this . first ) ; 
else return String . format ( "[%d:%d]" , this . first , this . stop - 1 ) ; 
else return String . format ( "[%d:%d:%d]" , this . first , this . stride , this . stop - 1 ) ; 
} 
} 

public class EarthEllipsoid { 
public static EarthEllipsoid getType ( int epsgId ) { 
Collection < EarthEllipsoid > all = getAll ( ) ; 
for ( EarthEllipsoid ellipsoid : all ) { 
if ( ellipsoid . epsgId == epsgId ) return ellipsoid ; 
} 
return null ; 
} 
} 

public class NcStreamDataCol { 
public Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { 
DataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; 
ByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; 
ByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; 
bb . order ( bo ) ; 
Array alldata = Array . factory ( dataType , new int [ ] { 
dproto . getNelems ( ) } 
, bb ) ; 
IndexIterator all = alldata . getIndexIterator ( ) ; 
Section section = NcStream . decodeSection ( dproto . getSection ( ) ) ; 
Array [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; 
int count = 0 ; 
for ( int len : dproto . getVlensList ( ) ) { 
Array primdata = Array . factory ( dataType , new int [ ] { 
len } 
) ; 
IndexIterator prim = primdata . getIndexIterator ( ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) prim . setObjectNext ( all . getObjectNext ( ) ) ; 
data [ count ++ ] = primdata ; 
} 
return Array . makeVlenArray ( section . getShape ( ) , data ) ; 
} 
} 

public class NcStreamDataCol { 
private Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { 
DataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; 
ByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; 
ByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; 
bb . order ( bo ) ; 
Array alldata = Array . factory ( dataType , new int [ ] { 
dproto . getNelems ( ) } 
, bb ) ; 
IndexIterator all = alldata . getIndexIterator ( ) ; 
int psize = ( int ) parentSection . computeSize ( ) ; 
Section section = NcStream . decodeSection ( dproto . getSection ( ) ) ; 
Section vsection = section . removeFirst ( parentSection ) ; 
int vsectionSize = ( int ) vsection . computeSize ( ) ; 
int countInner = 0 ; 
Array [ ] pdata = new Array [ psize ] ; 
for ( int pCount = 0 ; 
pCount < psize ; 
pCount ++ ) { 
Array [ ] vdata = new Array [ vsectionSize ] ; 
for ( int vCount = 0 ; 
vCount < vsectionSize ; 
vCount ++ ) { 
int vlen = dproto . getVlens ( countInner ++ ) ; 
Array primdata = Array . factory ( dataType , new int [ ] { 
vlen } 
) ; 
IndexIterator prim = primdata . getIndexIterator ( ) ; 
for ( int i = 0 ; 
i < vlen ; 
i ++ ) prim . setObjectNext ( all . getObjectNext ( ) ) ; 
vdata [ vCount ] = primdata ; 
} 
pdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; 
} 
return Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; 
} 
} 

public class GridHorizCoordSys { 
private double getGridSpacingInKm ( String type ) { 
double value = gds . getDouble ( type ) ; 
if ( Double . isNaN ( value ) ) return value ; 
String gridUnit = gds . getParam ( GridDefRecord . GRID_UNITS ) ; 
SimpleUnit unit ; 
if ( gridUnit == null || gridUnit . length ( ) == 0 ) unit = SimpleUnit . meterUnit ; 
else unit = SimpleUnit . factory ( gridUnit ) ; 
if ( unit != null && SimpleUnit . isCompatible ( unit . getUnitString ( ) , "km" ) ) value = unit . convertTo ( value , SimpleUnit . kmUnit ) ; 
return value ; 
} 
} 

public class GridHorizCoordSys { 
private double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { 
Variable v = new Variable ( ncfile , g , null , name ) ; 
v . setDataType ( DataType . DOUBLE ) ; 
v . setDimensions ( name ) ; 
double [ ] data = new double [ n ] ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) data [ i ] = start + incr * i ; 
Array dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { 
n } 
, data ) ; 
v . setCachedData ( dataArray , false ) ; 
v . addAttribute ( new Attribute ( "units" , units ) ) ; 
v . addAttribute ( new Attribute ( "long_name" , desc ) ) ; 
v . addAttribute ( new Attribute ( "standard_name" , standard_name ) ) ; 
v . addAttribute ( new Attribute ( "grid_spacing" , incr + " " + units ) ) ; 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; 
ncfile . addVariable ( g , v ) ; 
return data ; 
} 
} 

public class GridHorizCoordSys { 
private void addGDSparams ( Variable v ) { 
List < String > keyList = new ArrayList < > ( gds . getKeys ( ) ) ; 
Collections . sort ( keyList ) ; 
String pre = getGDSprefix ( ) ; 
for ( String key : keyList ) { 
String name = pre + "_param_" + key ; 
String vals = gds . getParam ( key ) ; 
try { 
int vali = Integer . parseInt ( vals ) ; 
if ( key . equals ( GridDefRecord . VECTOR_COMPONENT_FLAG ) ) { 
String cf = GridCF . VectorComponentFlag . of ( vali ) ; 
v . addAttribute ( new Attribute ( name , cf ) ) ; 
} 
else v . addAttribute ( new Attribute ( name , vali ) ) ; 
} 
catch ( Exception e ) { 
try { 
double vald = Double . parseDouble ( vals ) ; 
v . addAttribute ( new Attribute ( name , vald ) ) ; 
} 
catch ( Exception e2 ) { 
v . addAttribute ( new Attribute ( name , vals ) ) ; 
} 
} 
} 
} 
} 

public class GridHorizCoordSys { 
private void makeLC ( ) { 
proj = new LambertConformal ( gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LOV ) , gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) ) ; 
LatLonPointImpl startLL = new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ; 
ProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; 
startx = start . getX ( ) ; 
starty = start . getY ( ) ; 
if ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; 
if ( GridServiceProvider . debugProj ) { 
System . out . println ( "GridHorizCoordSys.makeLC start at latlon " + startLL ) ; 
double Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; 
double La2 = gds . getDouble ( GridDefRecord . LA2 ) ; 
LatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; 
System . out . println ( "GridHorizCoordSys.makeLC end at latlon " + endLL ) ; 
ProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; 
System . out . println ( "   end at proj coord " + endPP ) ; 
double endx = startx + getNx ( ) * getDxInKm ( ) ; 
double endy = starty + getNy ( ) * getDyInKm ( ) ; 
System . out . println ( "   should be x=" + endx + " y=" + endy ) ; 
} 
attributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , "lambert_conformal_conic" ) ) ; 
if ( gds . getDouble ( GridDefRecord . LATIN1 ) == gds . getDouble ( GridDefRecord . LATIN2 ) ) attributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; 
else { 
double [ ] data = new double [ ] { 
gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) } 
; 
attributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Array . factory ( DataType . DOUBLE , new int [ ] { 
2 } 
, data ) ) ) ; 
} 
attributes . add ( new Attribute ( GridCF . LONGITUDE_OF_CENTRAL_MERIDIAN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; 
attributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; 
} 
} 

public class GridHorizCoordSys { 
private void makePS ( ) { 
String nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; 
double latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( "true" ) ) ? 90.0 : - 90.0 ; 
double scale ; 
double lad = gds . getDouble ( GridDefRecord . LAD ) ; 
if ( Double . isNaN ( lad ) ) scale = .933 ; 
else scale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; 
proj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; 
ProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; 
startx = start . getX ( ) ; 
starty = start . getY ( ) ; 
if ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; 
if ( GridServiceProvider . debugProj ) { 
System . out . printf ( "starting proj coord %s lat/lon %s%n" , start , proj . projToLatLon ( start ) ) ; 
System . out . println ( "   should be LA1=" + gds . getDouble ( GridDefRecord . LA1 ) + " l)1=" + gds . getDouble ( GridDefRecord . LO1 ) ) ; 
} 
attributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , "polar_stereographic" ) ) ; 
attributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; 
attributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; 
attributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; 
attributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; 
} 
} 

public class GridHorizCoordSys { 
private void makeMercator ( ) { 
double Latin = gds . getDouble ( GridDefRecord . LAD ) ; 
if ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; 
double Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; 
double La1 = gds . getDouble ( GridDefRecord . LA1 ) ; 
proj = new Mercator ( Lo1 , Latin ) ; 
ProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; 
startx = startP . getX ( ) ; 
starty = startP . getY ( ) ; 
if ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; 
attributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , "mercator" ) ) ; 
attributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; 
attributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; 
if ( GridServiceProvider . debugProj ) { 
double Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; 
if ( Lo2 < Lo1 ) Lo2 += 360 ; 
double La2 = gds . getDouble ( GridDefRecord . LA2 ) ; 
LatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; 
System . out . println ( "GridHorizCoordSys.makeMercator: end at latlon= " + endLL ) ; 
ProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; 
System . out . println ( "   start at proj coord " + new ProjectionPointImpl ( startx , starty ) ) ; 
System . out . println ( "   end at proj coord " + endPP ) ; 
double endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; 
double endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; 
System . out . println ( "   should be x=" + endx + " y=" + endy ) ; 
} 
} 
} 

public class GridHorizCoordSys { 
private void setDxDy ( double startx , double starty , ProjectionImpl proj ) { 
double Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; 
double La2 = gds . getDouble ( GridDefRecord . LA2 ) ; 
if ( Double . isNaN ( Lo2 ) || Double . isNaN ( La2 ) ) return ; 
LatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; 
ProjectionPointImpl end = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; 
double dx = Math . abs ( end . getX ( ) - startx ) / ( gds . getInt ( GridDefRecord . NX ) - 1 ) ; 
double dy = Math . abs ( end . getY ( ) - starty ) / ( gds . getInt ( GridDefRecord . NY ) - 1 ) ; 
gds . addParam ( GridDefRecord . DX , String . valueOf ( dx ) ) ; 
gds . addParam ( GridDefRecord . DY , String . valueOf ( dy ) ) ; 
gds . addParam ( GridDefRecord . GRID_UNITS , "km" ) ; 
} 
} 

public class InvCatalogFactory10 { 
protected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { 
InvDatasetScan datasetScan ; 
if ( dsElem . getAttributeValue ( "dirLocation" ) == null ) if ( dsElem . getAttributeValue ( "location" ) == null ) { 
logger . error ( "readDatasetScan(): datasetScan has neither a \"location\" nor a \"dirLocation\" attribute." ) ; 
datasetScan = null ; 
} 
else return readDatasetScanNew ( catalog , parent , dsElem , base ) ; 
else { 
String name = dsElem . getAttributeValue ( "name" ) ; 
factory . appendWarning ( "**Warning: Dataset " + name + " using old form of DatasetScan (dirLocation instead of location)\n" ) ; 
String path = dsElem . getAttributeValue ( "path" ) ; 
String scanDir = expandAliasForPath ( dsElem . getAttributeValue ( "dirLocation" ) ) ; 
String filter = dsElem . getAttributeValue ( "filter" ) ; 
String addDatasetSizeString = dsElem . getAttributeValue ( "addDatasetSize" ) ; 
String addLatest = dsElem . getAttributeValue ( "addLatest" ) ; 
String sortOrderIncreasingString = dsElem . getAttributeValue ( "sortOrderIncreasing" ) ; 
boolean sortOrderIncreasing = false ; 
if ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( "true" ) ) sortOrderIncreasing = true ; 
boolean addDatasetSize = true ; 
if ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( "false" ) ) addDatasetSize = false ; 
if ( path != null ) { 
if ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; 
int last = path . length ( ) - 1 ; 
if ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; 
} 
if ( scanDir != null ) { 
int last = scanDir . length ( ) - 1 ; 
if ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; 
} 
Element atcElem = dsElem . getChild ( "addTimeCoverage" , defNS ) ; 
String dsNameMatchPattern = null ; 
String startTimeSubstitutionPattern = null ; 
String duration = null ; 
if ( atcElem != null ) { 
dsNameMatchPattern = atcElem . getAttributeValue ( "datasetNameMatchPattern" ) ; 
startTimeSubstitutionPattern = atcElem . getAttributeValue ( "startTimeSubstitutionPattern" ) ; 
duration = atcElem . getAttributeValue ( "duration" ) ; 
} 
try { 
datasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; 
readDatasetInfo ( catalog , datasetScan , dsElem , base ) ; 
if ( InvCatalogFactory . debugXML ) System . out . println ( " Dataset added: " + datasetScan . dump ( ) ) ; 
} 
catch ( Exception e ) { 
logger . error ( "Reading DatasetScan" , e ) ; 
datasetScan = null ; 
} 
} 
return datasetScan ; 
} 
} 

public class McIDASGridRecord { 
public int getLevelType1 ( ) { 
int gribLevel = getDirBlock ( ) [ 51 ] ; 
int levelType = 0 ; 
if ( ! ( ( gribLevel == McIDASUtil . MCMISSING ) || ( gribLevel == 0 ) ) ) levelType = gribLevel ; 
else levelType = 1 ; 
return levelType ; 
} 
} 

public class AWIPSConvention { 
private Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { 
int len = values . size ( ) ; 
String name = makeZCoordName ( units ) ; 
if ( len > 1 ) name = name + Integer . toString ( len ) ; 
else name = name + values . get ( 0 ) ; 
StringUtil2 . replace ( name , ' ' , "-" ) ; 
Dimension dim ; 
if ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) if ( dim . getLength ( ) == len ) { 
Variable coord = ds . getRootGroup ( ) . findVariable ( name ) ; 
Array coordData = coord . read ( ) ; 
Array newData = Array . makeArray ( coord . getDataType ( ) , values ) ; 
if ( MAMath . nearlyEquals ( coordData , newData ) ) { 
if ( debugBreakup ) parseInfo . format ( "  use existing coord %s%n" , dim ) ; 
return dim ; 
} 
} 
String orgName = name ; 
int count = 1 ; 
while ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { 
name = orgName + "-" + count ; 
count ++ ; 
} 
dim = new Dimension ( name , len ) ; 
ds . addDimension ( null , dim ) ; 
if ( debugBreakup ) parseInfo . format ( "  make Dimension = %s length = %d%n" , name , len ) ; 
if ( debugBreakup ) parseInfo . format ( "  make ZCoordAxis = = %s length = %d%n" , name , len ) ; 
CoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; 
String positive = getZisPositive ( ds , v ) ; 
if ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; 
v . setValues ( values ) ; 
ds . addCoordinateAxis ( v ) ; 
parseInfo . format ( "Created Z Coordinate Axis = " ) ; 
v . getNameAndDimensions ( parseInfo , true , false ) ; 
parseInfo . format ( "%n" ) ; 
return dim ; 
} 
} 

public class EsriShapefile { 
private void discretize ( double [ ] d , int n ) { 
if ( coarseness == 0.0 ) return ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) d [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; 
} 
} 

public class ThreddsMetadata { 
public void add ( ThreddsMetadata tmd , boolean includeInherited ) { 
creators . addAll ( tmd . getCreators ( ) ) ; 
contributors . addAll ( tmd . getContributors ( ) ) ; 
dates . addAll ( tmd . getDates ( ) ) ; 
docs . addAll ( tmd . getDocumentation ( ) ) ; 
keywords . addAll ( tmd . getKeywords ( ) ) ; 
projects . addAll ( tmd . getProjects ( ) ) ; 
properties . addAll ( tmd . getProperties ( ) ) ; 
publishers . addAll ( tmd . getPublishers ( ) ) ; 
variables . addAll ( tmd . getVariables ( ) ) ; 
if ( includeInherited ) metadata . addAll ( tmd . getMetadata ( ) ) ; 
else for ( InvMetadata mdata : tmd . getMetadata ( ) ) { 
if ( ! mdata . isInherited ( ) ) metadata . add ( mdata ) ; 
} 
if ( gc == null ) gc = tmd . getGeospatialCoverage ( ) ; 
if ( timeCoverage == null ) timeCoverage = tmd . getTimeCoverage ( ) ; 
if ( serviceName == null ) serviceName = tmd . getServiceName ( ) ; 
if ( dataType == null ) dataType = tmd . getDataType ( ) ; 
if ( dataSize == 0.0 ) dataSize = tmd . getDataSize ( ) ; 
if ( dataFormat == null ) dataFormat = tmd . getDataFormatType ( ) ; 
if ( authorityName == null ) authorityName = tmd . getAuthority ( ) ; 
if ( variableMapLink == null ) variableMapLink = tmd . getVariableMap ( ) ; 
} 
} 

public class CoordSysBuilder { 
protected void makeCoordinateSystems ( NetcdfDataset ncDataset ) { 
for ( VarProcess vp : varList ) { 
if ( vp . isCoordinateSystem ) vp . makeCoordinateSystem ( ) ; 
} 
} 
} 

public class CoordSysBuilder { 
protected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { 
boolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; 
for ( VarProcess vp : varList ) { 
VariableEnhanced ve = ( VariableEnhanced ) vp . v ; 
if ( vp . hasCoordinateSystem ( ) || ! vp . isData ( ) ) continue ; 
List < CoordinateAxis > axisList = new ArrayList < > ( ) ; 
List < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; 
for ( CoordinateAxis axis : axes ) { 
if ( isCoordinateAxisForVariable ( axis , ve ) ) axisList . add ( axis ) ; 
} 
if ( axisList . size ( ) < 2 ) continue ; 
String csName = CoordinateSystem . makeName ( axisList ) ; 
CoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; 
boolean okToBuild = false ; 
if ( requireCompleteCoordSys ) if ( cs != null ) okToBuild = cs . isComplete ( ve ) ; 
else okToBuild = true ; 
if ( cs != null && okToBuild ) { 
ve . addCoordinateSystem ( cs ) ; 
parseInfo . format ( " assigned maximal CoordSystem '%s' for var= %s%n" , cs . getName ( ) , ve . getFullName ( ) ) ; 
} 
else { 
CoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; 
if ( requireCompleteCoordSys ) okToBuild = csnew . isComplete ( ve ) ; 
if ( okToBuild ) { 
csnew . setImplicit ( true ) ; 
ve . addCoordinateSystem ( csnew ) ; 
ncDataset . addCoordinateSystem ( csnew ) ; 
parseInfo . format ( " created maximal CoordSystem '%s' for var= %s%n" , csnew . getName ( ) , ve . getFullName ( ) ) ; 
} 
} 
} 
} 
} 

public class CoordSysBuilder { 
protected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { 
List < Dimension > varDims = v . getDimensionsAll ( ) ; 
List < Dimension > axisDims = axis . getDimensionsAll ( ) ; 
int checkDims = axisDims . size ( ) ; 
if ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; 
for ( int i = 0 ; 
i < checkDims ; 
i ++ ) { 
Dimension axisDim = axisDims . get ( i ) ; 
if ( ! varDims . contains ( axisDim ) ) return false ; 
} 
return true ; 
} 
} 

public class Counters { 
public boolean count ( String name , Comparable value ) { 
Counter counter = map . get ( name ) ; 
if ( counter == null ) counter = add ( name ) ; 
return counter . count ( value ) ; 
} 
} 

public class DSPRegistry { 
synchronized public void unregister ( Class < ? extends DSP > klass ) { 
for ( int i = 0 ; 
i < registry . size ( ) ; 
i ++ ) if ( registry . get ( i ) . dspclass == klass ) { 
registry . remove ( i ) ; 
break ; 
} 
} 
} 

public class Grib2Tables { 
public double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { 
Grib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; 
int timeUnitOrg = pds . getTimeUnit ( ) ; 
int range = 0 ; 
for ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { 
if ( ti . timeRangeUnit == 255 ) continue ; 
if ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { 
logger . warn ( "TimeInterval(2) has different units timeUnit org=" + timeUnitOrg + " TimeInterval=" + ti . timeIncrementUnit ) ; 
throw new RuntimeException ( "TimeInterval(2) has different units" ) ; 
} 
range += ti . timeRangeLength ; 
if ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; 
} 
CalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; 
if ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; 
if ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; 
double fac ; 
if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) fac = 30.0 * 24.0 ; 
else if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) fac = 365.0 * 24.0 ; 
else fac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; 
return fac * range ; 
} 
} 

public class DapDataset { 
public void sort ( ) { 
List < DapNode > sorted = new ArrayList < DapNode > ( ) ; 
sortR ( this , sorted ) ; 
for ( int i = 0 ; 
i < sorted . size ( ) ; 
i ++ ) sorted . get ( i ) . setIndex ( i ) ; 
this . nodelist = sorted ; 
} 
} 

public class PictureCache { 
public static synchronized void reportCache ( ) { 
Tools . log ( "   PictureCache.reportCache: cache contains: " + Integer . toString ( pictureCache . size ( ) ) + " max: " + Integer . toString ( maxCache ) ) ; 
Enumeration e = pictureCache . keys ( ) ; 
while ( e . hasMoreElements ( ) ) Tools . log ( "   Cache contains: " + ( ( String ) e . nextElement ( ) ) ) ; 
Tools . log ( "  End of cache contents" ) ; 
} 
} 

public class PictureCache { 
public static void stopBackgroundLoading ( ) { 
Enumeration e = cacheLoadsInProgress . elements ( ) ; 
while ( e . hasMoreElements ( ) ) ( ( SourcePicture ) e . nextElement ( ) ) . stopLoading ( ) ; 
} 
} 

public class HTTPFactory { 
static protected HTTPMethod makemethod ( HTTPSession . Methods m , HTTPSession session , String url ) throws HTTPException { 
HTTPMethod meth = null ; 
if ( MOCKMETHODCLASS == null ) meth = new HTTPMethod ( m , session , url ) ; 
else { 
java . lang . Class methodcl = MOCKMETHODCLASS ; 
Constructor < HTTPMethod > cons = null ; 
try { 
cons = methodcl . getConstructor ( HTTPSession . Methods . class , HTTPSession . class , String . class ) ; 
} 
catch ( Exception e ) { 
throw new HTTPException ( "HTTPFactory: no proper HTTPMethod constructor available" , e ) ; 
} 
try { 
meth = cons . newInstance ( m , session , url ) ; 
} 
catch ( Exception e ) { 
throw new HTTPException ( "HTTPFactory: HTTPMethod constructor failed" , e ) ; 
} 
} 
return meth ; 
} 
} 

public class DapNetcdfFile { 
@ Override protected Array readData ( Variable cdmvar , Section section ) throws IOException , InvalidRangeException { 
assert this . dsp != null ; 
Array result = arraymap . get ( cdmvar ) ; 
if ( result == null ) throw new IOException ( "No data for variable: " + cdmvar . getFullName ( ) ) ; 
if ( section != null ) { 
if ( cdmvar . getRank ( ) != section . getRank ( ) ) throw new InvalidRangeException ( String . format ( "Section rank != %s rank" , cdmvar . getFullName ( ) ) ) ; 
List < Range > ranges = section . getRanges ( ) ; 
if ( CDMUtil . hasVLEN ( ranges ) ) ranges = ranges . subList ( 0 , ranges . size ( ) - 1 ) ; 
if ( ranges . size ( ) > 0 && ! CDMUtil . isWhole ( ranges , cdmvar ) ) result = result . sectionNoReduce ( ranges ) ; 
} 
return result ; 
} 
} 

public class RadarServerConfig { 
private static FileSystemProvider getProvider ( URI uri ) throws IOException { 
if ( fsproviders . containsKey ( uri . getScheme ( ) ) ) return fsproviders . get ( uri . getScheme ( ) ) ; 
else { 
FileSystem fs ; 
try { 
fs = FileSystems . newFileSystem ( uri , new HashMap < String , Object > ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; 
} 
catch ( FileSystemAlreadyExistsException e ) { 
fs = FileSystems . getFileSystem ( uri ) ; 
} 
fsproviders . put ( uri . getScheme ( ) , fs . provider ( ) ) ; 
return fs . provider ( ) ; 
} 
} 
} 

public class MetarParseReport { 
private String cloud_hgt2_meters ( String height ) { 
if ( height . equals ( "999" ) ) return "30000" ; 
else return Integer . toString ( 30 * Integer . parseInt ( height ) ) ; 
} 
} 

public class SmartArrayInt { 
public int findIdx ( int want ) { 
if ( isConstant ) return ( want == start ) ? 0 : - 1 ; 
if ( isSequential ) return want - start ; 
if ( isSorted ) return Arrays . binarySearch ( raw , want ) ; 
for ( int i = 0 ; 
i < raw . length ; 
i ++ ) if ( raw [ i ] == want ) return i ; 
return - 1 ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { 
String name = dsSourceElement . getAttributeValue ( "name" ) ; 
String type = dsSourceElement . getAttributeValue ( "type" ) ; 
String structure = dsSourceElement . getAttributeValue ( "structure" ) ; 
String accessPoint = dsSourceElement . getAttributeValue ( "accessPoint" ) ; 
String createCatalogRefs = dsSourceElement . getAttributeValue ( "createCatalogRefs" ) ; 
Element resultServiceElement = dsSourceElement . getChild ( "resultService" , dsSourceElement . getNamespace ( ) ) ; 
ResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; 
DatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; 
if ( createCatalogRefs != null ) dsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; 
java . util . List list = dsSourceElement . getChildren ( "datasetNamer" , dsSourceElement . getNamespace ( ) ) ; 
for ( int i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Element dsNamerElement = ( Element ) list . get ( i ) ; 
dsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; 
} 
list = dsSourceElement . getChildren ( "datasetFilter" , dsSourceElement . getNamespace ( ) ) ; 
for ( int i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Element dsFilterElement = ( Element ) list . get ( i ) ; 
dsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; 
} 
return ( dsSource ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private org . jdom2 . Element createCatGenConfigElement ( CatalogGenConfig cgc ) { 
Element cgcElem = new Element ( "catalogGenConfig" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; 
if ( cgc != null ) { 
if ( cgc . getType ( ) != null ) cgcElem . setAttribute ( "type" , cgc . getType ( ) . toString ( ) ) ; 
DatasetSource dsSource = cgc . getDatasetSource ( ) ; 
cgcElem . addContent ( createDatasetSourceElement ( dsSource ) ) ; 
} 
return ( cgcElem ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { 
Element dssElem = new Element ( "datasetSource" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; 
if ( dsSource != null ) { 
if ( dsSource . getName ( ) != null ) dssElem . setAttribute ( "name" , dsSource . getName ( ) ) ; 
if ( dsSource . getType ( ) != null ) dssElem . setAttribute ( "type" , dsSource . getType ( ) . toString ( ) ) ; 
if ( dsSource . getStructure ( ) != null ) dssElem . setAttribute ( "structure" , dsSource . getStructure ( ) . toString ( ) ) ; 
if ( dsSource . getAccessPoint ( ) != null ) dssElem . setAttribute ( "accessPoint" , dsSource . getAccessPoint ( ) ) ; 
dssElem . setAttribute ( "createCatalogRefs" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; 
ResultService rs = dsSource . getResultService ( ) ; 
dssElem . addContent ( createResultServiceElement ( rs ) ) ; 
java . util . List list = dsSource . getDatasetNamerList ( ) ; 
for ( int j = 0 ; 
j < list . size ( ) ; 
j ++ ) { 
DatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; 
dssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; 
} 
list = dsSource . getDatasetFilterList ( ) ; 
for ( int j = 0 ; 
j < list . size ( ) ; 
j ++ ) { 
DatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; 
dssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; 
} 
} 
return ( dssElem ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private org . jdom2 . Element createDatasetNamerElement ( DatasetNamer dsNamer ) { 
Element dsnElem = new Element ( "datasetNamer" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; 
if ( dsNamer != null ) { 
if ( dsNamer . getName ( ) != null ) dsnElem . setAttribute ( "name" , dsNamer . getName ( ) ) ; 
dsnElem . setAttribute ( "addLevel" , Boolean . toString ( dsNamer . getAddLevel ( ) ) ) ; 
if ( dsNamer . getType ( ) != null ) dsnElem . setAttribute ( "type" , dsNamer . getType ( ) . toString ( ) ) ; 
if ( dsNamer . getMatchPattern ( ) != null ) dsnElem . setAttribute ( "matchPattern" , dsNamer . getMatchPattern ( ) ) ; 
if ( dsNamer . getSubstitutePattern ( ) != null ) dsnElem . setAttribute ( "substitutePattern" , dsNamer . getSubstitutePattern ( ) ) ; 
if ( dsNamer . getAttribContainer ( ) != null ) dsnElem . setAttribute ( "attribContainer" , dsNamer . getAttribContainer ( ) ) ; 
if ( dsNamer . getAttribName ( ) != null ) dsnElem . setAttribute ( "attribName" , dsNamer . getAttribName ( ) ) ; 
} 
return ( dsnElem ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private org . jdom2 . Element createDatasetFilterElement ( DatasetFilter dsFilter ) { 
Element dsfElem = new Element ( "datasetFilter" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; 
if ( dsFilter != null ) { 
if ( dsFilter . getName ( ) != null ) dsfElem . setAttribute ( "name" , dsFilter . getName ( ) ) ; 
if ( dsFilter . getType ( ) != null ) dsfElem . setAttribute ( "type" , dsFilter . getType ( ) . toString ( ) ) ; 
if ( dsFilter . getMatchPattern ( ) != null ) dsfElem . setAttribute ( "matchPattern" , dsFilter . getMatchPattern ( ) ) ; 
if ( dsFilter . getMatchPatternTarget ( ) != null ) dsfElem . setAttribute ( "matchPatternTarget" , dsFilter . getMatchPatternTarget ( ) ) ; 
dsfElem . setAttribute ( "applyToCollectionDatasets" , String . valueOf ( dsFilter . isApplyToCollectionDatasets ( ) ) ) ; 
dsfElem . setAttribute ( "applyToAtomicDatasets" , String . valueOf ( dsFilter . isApplyToAtomicDatasets ( ) ) ) ; 
dsfElem . setAttribute ( "rejectMatchingDatasets" , String . valueOf ( dsFilter . isRejectMatchingDatasets ( ) ) ) ; 
} 
return ( dsfElem ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private org . jdom2 . Element createResultServiceElement ( ResultService resultService ) { 
Element rsElem = new Element ( "resultService" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; 
if ( resultService != null ) { 
if ( resultService . getName ( ) != null ) rsElem . setAttribute ( "name" , resultService . getName ( ) ) ; 
if ( resultService . getServiceType ( ) != null ) rsElem . setAttribute ( "serviceType" , resultService . getServiceType ( ) . toString ( ) ) ; 
if ( resultService . getBase ( ) != null ) rsElem . setAttribute ( "base" , resultService . getBase ( ) ) ; 
if ( resultService . getSuffix ( ) != null ) rsElem . setAttribute ( "suffix" , resultService . getSuffix ( ) ) ; 
if ( resultService . getAccessPointHeader ( ) != null ) rsElem . setAttribute ( "accessPointHeader" , resultService . getAccessPointHeader ( ) ) ; 
} 
return ( rsElem ) ; 
} 
} 

public class Debug { 
static public boolean isSet ( String flagName ) { 
if ( store == null ) return false ; 
NamePart np = partit ( flagName ) ; 
if ( debug ) try { 
if ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) System . out . println ( "Debug.isSet create node = " + flagName + " " + np ) ; 
else if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . println ( "Debug.isSet create flag = " + flagName + " " + np ) ; 
} 
catch ( BackingStoreException e ) { 
} 
boolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; 
store . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; 
return value ; 
} 
} 

public class GempakParameterTable { 
public void addParameters ( String tbl ) throws IOException { 
try ( InputStream is = getInputStream ( tbl ) ) { 
if ( is == null ) throw new IOException ( "Unable to open " + tbl ) ; 
String content = readContents ( is ) ; 
String [ ] lines = content . split ( "\n" ) ; 
List < String [ ] > result = new ArrayList < > ( ) ; 
for ( String line : lines ) { 
String tline = line . trim ( ) ; 
if ( tline . length ( ) == 0 ) continue ; 
if ( tline . startsWith ( "!" ) ) continue ; 
String [ ] words = new String [ indices . length ] ; 
for ( int idx = 0 ; 
idx < indices . length ; 
idx ++ ) { 
if ( indices [ idx ] >= tline . length ( ) ) continue ; 
if ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) words [ idx ] = line . substring ( indices [ idx ] ) ; 
else words [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; 
words [ idx ] = words [ idx ] . trim ( ) ; 
} 
result . add ( words ) ; 
} 
for ( String [ ] aResult : result ) { 
GempakParameter p = makeParameter ( aResult ) ; 
if ( p != null ) if ( p . getName ( ) . contains ( "(" ) ) templateParamMap . put ( p . getName ( ) , p ) ; 
else paramMap . put ( p . getName ( ) , p ) ; 
} 
} 
} 
} 

public class GempakParameterTable { 
private GempakParameter makeParameter ( String [ ] words ) { 
int num = 0 ; 
String description ; 
if ( words [ 0 ] != null ) num = ( int ) Double . parseDouble ( words [ 0 ] ) ; 
if ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( "" ) ) return null ; 
String name = words [ 3 ] ; 
if ( name . contains ( "-" ) ) { 
int first = name . indexOf ( "-" ) ; 
int last = name . lastIndexOf ( "-" ) ; 
StringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; 
buf . append ( "(" ) ; 
for ( int i = first ; 
i <= last ; 
i ++ ) buf . append ( "\\d" ) ; 
buf . append ( ")" ) ; 
buf . append ( name . substring ( last + 1 ) ) ; 
name = buf . toString ( ) ; 
} 
if ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( "" ) ) description = words [ 3 ] ; 
else description = words [ 1 ] ; 
String unit = words [ 2 ] ; 
if ( unit != null ) { 
unit = unit . replaceAll ( "\\*\\*" , "" ) ; 
if ( unit . equals ( "-" ) ) unit = "" ; 
} 
int decimalScale ; 
try { 
decimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; 
} 
catch ( NumberFormatException ne ) { 
decimalScale = 0 ; 
} 
return new GempakParameter ( num , name , description , unit , decimalScale ) ; 
} 
} 

public class GempakParameterTable { 
public GempakParameter getParameter ( String name ) { 
GempakParameter param = paramMap . get ( name ) ; 
if ( param == null ) { 
Set < String > keys = templateParamMap . keySet ( ) ; 
if ( ! keys . isEmpty ( ) ) for ( String key : keys ) { 
Pattern p = Pattern . compile ( key ) ; 
Matcher m = p . matcher ( name ) ; 
if ( m . matches ( ) ) { 
String value = m . group ( 1 ) ; 
GempakParameter match = templateParamMap . get ( key ) ; 
param = new GempakParameter ( match . getNumber ( ) , name , match . getDescription ( ) + " (" + value + " hour)" , match . getUnit ( ) , match . getDecimalScale ( ) ) ; 
paramMap . put ( name , param ) ; 
break ; 
} 
} 
} 
return param ; 
} 
} 

public class GempakParameterTable { 
private byte [ ] readBytes ( InputStream is ) throws IOException { 
int totalRead = 0 ; 
byte [ ] content = new byte [ 1000000 ] ; 
while ( true ) { 
int howMany = is . read ( content , totalRead , content . length - totalRead ) ; 
if ( howMany < 0 ) break ; 
if ( howMany == 0 ) continue ; 
totalRead += howMany ; 
if ( totalRead >= content . length ) { 
byte [ ] tmp = content ; 
int newLength = ( ( content . length < 25000000 ) ? content . length * 2 : content . length + 5000000 ) ; 
content = new byte [ newLength ] ; 
System . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; 
} 
} 
is . close ( ) ; 
byte [ ] results = new byte [ totalRead ] ; 
System . arraycopy ( content , 0 , results , 0 , totalRead ) ; 
return results ; 
} 
} 

public class Grib2SectionBitMap { 
@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { 
if ( bitMapIndicator == 255 ) return null ; 
if ( bitMapIndicator == 254 ) logger . debug ( "HEY bitMapIndicator=254 previously defined bitmap" ) ; 
if ( bitMapIndicator != 0 ) throw new UnsupportedOperationException ( "Grib2 Bit map section pre-defined (provided by center) = " + bitMapIndicator ) ; 
raf . seek ( startingPosition ) ; 
int length = GribNumbers . int4 ( raf ) ; 
raf . skipBytes ( 2 ) ; 
byte [ ] data = new byte [ length - 6 ] ; 
raf . readFully ( data ) ; 
return data ; 
} 
} 

public class DODSNetcdfFile { 
NamePieces parseName ( String name ) { 
NamePieces pieces = new NamePieces ( ) ; 
int dotpos = name . lastIndexOf ( '.' ) ; 
int slashpos = name . lastIndexOf ( '/' ) ; 
if ( slashpos < 0 && dotpos < 0 ) pieces . name = name ; 
else if ( slashpos >= 0 && dotpos < 0 ) { 
pieces . prefix = name . substring ( 0 , slashpos ) ; 
pieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; 
} 
else if ( slashpos < 0 && dotpos >= 0 ) { 
pieces . var = name . substring ( 0 , dotpos ) ; 
pieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; 
} 
else if ( slashpos > dotpos ) { 
pieces . prefix = name . substring ( 0 , slashpos ) ; 
pieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; 
} 
else { 
pieces . prefix = name . substring ( 0 , slashpos ) ; 
pieces . var = name . substring ( slashpos + 1 , dotpos ) ; 
pieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; 
} 
if ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; 
if ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; 
if ( pieces . name . length ( ) == 0 ) pieces . name = null ; 
return pieces ; 
} 
} 

public class DODSNetcdfFile { 
List < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { 
if ( group == null ) group = rootGroup ; 
List < Dimension > dims = new ArrayList < Dimension > ( ) ; 
Enumeration enumerate = dodsArray . getDimensions ( ) ; 
while ( enumerate . hasMoreElements ( ) ) { 
opendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; 
String name = dad . getEncodedName ( ) ; 
if ( name != null ) name = StringUtil2 . unescape ( name ) ; 
Dimension myd ; 
if ( name == null ) myd = new Dimension ( null , dad . getSize ( ) , false ) ; 
else { 
if ( RC . getUseGroups ( ) ) if ( name . indexOf ( '/' ) >= 0 ) { 
group = group . makeRelativeGroup ( this , name , true ) ; 
name = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; 
} 
myd = group . findDimension ( name ) ; 
if ( myd == null ) { 
myd = new Dimension ( name , dad . getSize ( ) ) ; 
group . addDimension ( myd ) ; 
} 
else if ( myd . getLength ( ) != dad . getSize ( ) ) myd = new Dimension ( name , dad . getSize ( ) , false ) ; 
} 
dims . add ( myd ) ; 
} 
return dims ; 
} 
} 

public class IospHelper { 
static public Object makePrimitiveArray ( int size , DataType dataType ) { 
Object arr = null ; 
if ( ( dataType . getPrimitiveClassType ( ) == byte . class ) || ( dataType == DataType . CHAR ) || ( dataType == DataType . OPAQUE ) || ( dataType == DataType . STRUCTURE ) ) arr = new byte [ size ] ; 
else if ( dataType . getPrimitiveClassType ( ) == short . class ) arr = new short [ size ] ; 
else if ( dataType . getPrimitiveClassType ( ) == int . class ) arr = new int [ size ] ; 
else if ( dataType . getPrimitiveClassType ( ) == long . class ) arr = new long [ size ] ; 
else if ( dataType == DataType . FLOAT ) arr = new float [ size ] ; 
else if ( dataType == DataType . DOUBLE ) arr = new double [ size ] ; 
else if ( dataType == DataType . STRING ) arr = new String [ size ] ; 
return arr ; 
} 
} 

public class CrawlableDatasetFactory { 
public static CrawlableDataset createCrawlableDataset ( String path , String className , Object configObj ) throws IOException , ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException , IllegalArgumentException , NullPointerException { 
if ( path == null ) throw new NullPointerException ( "Given path must not be null." ) ; 
String tmpClassName = ( className == null ? defaultClassName : className ) ; 
Class crDsClass = Class . forName ( tmpClassName ) ; 
if ( ! CrawlableDataset . class . isAssignableFrom ( crDsClass ) ) throw new IllegalArgumentException ( "Requested class <" + className + "> not an implementation of thredds.crawlabledataset.CrawlableDataset." ) ; 
Class [ ] argTypes = { 
String . class , Object . class } 
; 
Object [ ] args = { 
path , configObj } 
; 
Constructor constructor = crDsClass . getDeclaredConstructor ( argTypes ) ; 
try { 
return ( CrawlableDataset ) constructor . newInstance ( args ) ; 
} 
catch ( InvocationTargetException e ) { 
if ( IOException . class . isAssignableFrom ( e . getCause ( ) . getClass ( ) ) ) throw ( IOException ) e . getCause ( ) ; 
else throw e ; 
} 
} 
} 

public class Aggregation { 
protected void makeDatasets ( CancelTask cancelTask ) throws IOException { 
datasets = new ArrayList < > ( ) ; 
for ( MFile cd : datasetManager . getFilesSorted ( ) ) { 
datasets . add ( makeDataset ( cd ) ) ; 
} 
Collections . sort ( datasets ) ; 
for ( Aggregation . Dataset dataset : explicitDatasets ) { 
datasets . add ( dataset ) ; 
} 
for ( Iterator < Dataset > datasetsIter = datasets . iterator ( ) ; 
datasetsIter . hasNext ( ) ; 
) { 
Dataset dataset = datasetsIter . next ( ) ; 
Path datasetPath ; 
if ( dataset . getMFile ( ) instanceof MFileOS ) datasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; 
else if ( dataset . getMFile ( ) instanceof MFileOS7 ) datasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; 
else continue ; 
if ( ! Files . isReadable ( datasetPath ) ) { 
logger . warn ( "Aggregation member isn't readable (permissions issue?). Skipping: " + datasetPath ) ; 
datasetsIter . remove ( ) ; 
} 
} 
Set < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; 
for ( Aggregation . Dataset dataset : datasets ) { 
if ( dset . contains ( dataset . cacheLocation ) ) logger . warn ( "Duplicate dataset in aggregation = " + dataset . cacheLocation ) ; 
dset . add ( dataset . cacheLocation ) ; 
} 
if ( datasets . size ( ) == 0 ) throw new IllegalStateException ( "There are no datasets in the aggregation " + datasetManager ) ; 
} 
} 

public class CFLine { 
public void addPoint ( double x , double y ) { 
Point ptPrev = null ; 
if ( points . size ( ) > 0 ) ptPrev = points . get ( points . size ( ) - 1 ) ; 
this . points . add ( new CFPoint ( x , y , ptPrev , null , null ) ) ; 
} 
} 

public class CFLine { 
public double [ ] getBBUpper ( ) { 
double [ ] bbUpper = new double [ 2 ] ; 
List < Point > ptList = this . getPoints ( ) ; 
if ( ptList . isEmpty ( ) ) return null ; 
bbUpper [ 0 ] = ptList . get ( 0 ) . getY ( ) ; 
bbUpper [ 1 ] = ptList . get ( 0 ) . getY ( ) ; 
for ( Point pt : this . getPoints ( ) ) { 
if ( bbUpper [ 0 ] < pt . getX ( ) ) bbUpper [ 0 ] = pt . getX ( ) ; 
if ( bbUpper [ 1 ] < pt . getY ( ) ) bbUpper [ 1 ] = pt . getY ( ) ; 
} 
bbUpper [ 0 ] += 10 ; 
bbUpper [ 1 ] += 10 ; 
return bbUpper ; 
} 
} 

public class CFLine { 
public double [ ] getBBLower ( ) { 
double [ ] bbLower = new double [ 2 ] ; 
List < Point > ptList = this . getPoints ( ) ; 
if ( ptList . isEmpty ( ) ) return null ; 
bbLower [ 0 ] = ptList . get ( 0 ) . getY ( ) ; 
bbLower [ 1 ] = ptList . get ( 0 ) . getY ( ) ; 
for ( Point pt : this . getPoints ( ) ) { 
if ( bbLower [ 0 ] > pt . getX ( ) ) bbLower [ 0 ] = pt . getX ( ) ; 
if ( bbLower [ 1 ] > pt . getY ( ) ) bbLower [ 1 ] = pt . getY ( ) ; 
} 
bbLower [ 0 ] -= 10 ; 
bbLower [ 1 ] -= 10 ; 
return bbLower ; 
} 
} 

public class DatasetFilter { 
boolean validate ( StringBuilder out ) { 
this . isValid = true ; 
if ( this . log . length ( ) > 0 ) out . append ( this . log ) ; 
if ( this . getName ( ) == null ) { 
isValid = false ; 
out . append ( " ** DatasetFilter (4): null value for name is not valid." ) ; 
} 
if ( this . getType ( ) == null ) { 
isValid = false ; 
out . append ( " ** DatasetFilter (5): null value for type is not valid (set with bad string?)." ) ; 
} 
if ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION && this . matchPattern == null ) { 
isValid = false ; 
out . append ( " ** DatasetFilter (6): null value for matchPattern not valid when type is 'RegExp'." ) ; 
} 
if ( this . type != DatasetFilter . Type . REGULAR_EXPRESSION && this . type != null && this . matchPattern != null ) { 
isValid = false ; 
out . append ( " ** DatasetFilter (7): matchPattern value (" + this . matchPattern + ") must be null if type is not 'RegExp'." ) ; 
} 
return ( this . isValid ) ; 
} 
} 

public class DatasetFilter { 
private boolean match ( InvDataset dataset ) { 
if ( this . getParentDatasetSource ( ) . isCollection ( dataset ) && ! this . applyToCollectionDatasets ) return ( false ) ; 
if ( ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) && ! this . applyToAtomicDatasets ) return ( false ) ; 
if ( this . matchPatternTarget == null ) if ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) this . setMatchPatternTarget ( "name" ) ; 
else this . setMatchPatternTarget ( "urlPath" ) ; 
if ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { 
boolean isMatch ; 
if ( this . getMatchPatternTarget ( ) . equals ( "name" ) ) { 
java . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; 
isMatch = matcher . find ( ) ; 
} 
else if ( this . getMatchPatternTarget ( ) . equals ( "urlPath" ) ) { 
java . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; 
isMatch = matcher . find ( ) ; 
} 
else isMatch = false ; 
return ( isMatch ) ; 
} 
else { 
System . err . println ( "WARNING -- DatasetFilter.accept(): unsupported type" + " <" + this . type . toString ( ) + ">." ) ; 
return ( false ) ; 
} 
} 
} 

public class CEEvaluator { 
public boolean evalClauses ( Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { 
boolean result = true ; 
Enumeration ec = getClauses ( ) ; 
while ( ec . hasMoreElements ( ) && result == true ) { 
Object o = ec . nextElement ( ) ; 
if ( _Debug ) System . out . println ( "Evaluating clause: " + ec . nextElement ( ) ) ; 
result = ( ( TopLevelClause ) o ) . evaluate ( ) ; 
} 
return ( result ) ; 
} 
} 

public class HdfEos { 
static public boolean amendFromODL ( NetcdfFile ncfile , Group eosGroup ) throws IOException { 
String smeta = getStructMetadata ( eosGroup ) ; 
if ( smeta == null ) return false ; 
HdfEos fixer = new HdfEos ( ) ; 
fixer . fixAttributes ( ncfile . getRootGroup ( ) ) ; 
fixer . amendFromODL ( ncfile , smeta ) ; 
return true ; 
} 
} 

public class HdfEos { 
private void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { 
if ( values . size ( ) == 0 ) return ; 
Iterator < Element > iter = values . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
Element value = iter . next ( ) ; 
String dimName = value . getText ( ) . trim ( ) ; 
if ( dimName . equalsIgnoreCase ( "scalar" ) ) iter . remove ( ) ; 
} 
List < Dimension > oldDims = v . getDimensions ( ) ; 
if ( oldDims . size ( ) != values . size ( ) ) { 
log . error ( "Different number of dimensions for {} {}" , v , location ) ; 
return ; 
} 
List < Dimension > newDims = new ArrayList < > ( ) ; 
Group group = v . getParentGroup ( ) ; 
for ( int i = 0 ; 
i < values . size ( ) ; 
i ++ ) { 
Element value = values . get ( i ) ; 
String dimName = value . getText ( ) . trim ( ) ; 
dimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; 
Dimension dim = group . findDimension ( dimName ) ; 
Dimension oldDim = oldDims . get ( i ) ; 
if ( dim == null ) dim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; 
if ( dim == null ) { 
log . error ( "Unknown Dimension= {} for variable = {} {} " , dimName , v . getFullName ( ) , location ) ; 
return ; 
} 
if ( dim . getLength ( ) != oldDim . getLength ( ) ) { 
log . error ( "Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; 
return ; 
} 
newDims . add ( dim ) ; 
} 
v . setDimensions ( newDims ) ; 
if ( showWork ) log . debug ( " set shared dimensions for {}" , v . getNameAndDimensions ( ) ) ; 
} 
} 

public class HdfEos { 
private Dimension checkUnknownDims ( String wantDim , List < Dimension > unknownDims , Dimension oldDim , String location ) { 
for ( Dimension dim : unknownDims ) { 
if ( dim . getShortName ( ) . equals ( wantDim ) ) { 
int len = oldDim . getLength ( ) ; 
if ( len == 0 ) dim . setUnlimited ( true ) ; 
dim . setLength ( len ) ; 
Group parent = dim . getGroup ( ) ; 
parent . addDimensionIfNotExists ( dim ) ; 
unknownDims . remove ( dim ) ; 
log . warn ( "unknownDim {} length set to {}{}" , wantDim , oldDim . getLength ( ) , location ) ; 
return dim ; 
} 
} 
return null ; 
} 
} 

public class HdfEos { 
private Group findGroupNested ( Group parent , String name ) { 
for ( Group g : parent . getGroups ( ) ) { 
if ( g . getShortName ( ) . equals ( name ) ) return g ; 
} 
for ( Group g : parent . getGroups ( ) ) { 
Group result = findGroupNested ( g , name ) ; 
if ( result != null ) return result ; 
} 
return null ; 
} 
} 

public class RadialCoordSys { 
public double getMaximumRadial ( ) { 
if ( maxRadial == 0.0 ) try { 
Array radialData = getRadialAxisDataCached ( ) ; 
maxRadial = MAMath . getMaximum ( radialData ) ; 
String units = getRadialAxis ( ) . getUnitsString ( ) ; 
SimpleUnit radialUnit = SimpleUnit . factory ( units ) ; 
maxRadial = radialUnit . convertTo ( maxRadial , SimpleUnit . kmUnit ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( IllegalArgumentException e ) { 
e . printStackTrace ( ) ; 
} 
return maxRadial ; 
} 
} 

public class GEOSTransform { 
public double [ ] earthToSat ( double geographic_lon , double geographic_lat ) { 
geographic_lat = geographic_lat * DEG_TO_RAD ; 
geographic_lon = geographic_lon * DEG_TO_RAD ; 
double geocentric_lat = Math . atan ( ( ( r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . tan ( geographic_lat ) ) ; 
double r_earth = r_pol / Math . sqrt ( 1.0 - ( ( r_eq * r_eq - r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . cos ( geocentric_lat ) * Math . cos ( geocentric_lat ) ) ; 
double r_1 = h - r_earth * Math . cos ( geocentric_lat ) * Math . cos ( geographic_lon - sub_lon ) ; 
double r_2 = - r_earth * Math . cos ( geocentric_lat ) * Math . sin ( geographic_lon - sub_lon ) ; 
double r_3 = r_earth * Math . sin ( geocentric_lat ) ; 
if ( r_1 > h ) return new double [ ] { 
Double . NaN , Double . NaN } 
; 
double lamda_sat = Double . NaN ; 
double theta_sat = Double . NaN ; 
if ( scan_geom . equals ( GEOS ) ) { 
lamda_sat = Math . atan ( - r_2 / r_1 ) ; 
theta_sat = Math . asin ( r_3 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; 
} 
else if ( scan_geom . equals ( GOES ) ) { 
lamda_sat = Math . asin ( - r_2 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; 
theta_sat = Math . atan ( r_3 / r_1 ) ; 
} 
return new double [ ] { 
lamda_sat , theta_sat } 
; 
} 
} 

public class GEOSTransform { 
public double [ ] satToEarth ( double x , double y ) { 
if ( scan_geom . equals ( GOES ) ) { 
double [ ] lambda_theta_geos = GOES_to_GEOS ( x , y ) ; 
x = lambda_theta_geos [ 0 ] ; 
y = lambda_theta_geos [ 1 ] ; 
} 
double c1 = ( h * Math . cos ( x ) * Math . cos ( y ) ) * ( h * Math . cos ( x ) * Math . cos ( y ) ) ; 
double c2 = ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) * d ; 
if ( c1 < c2 ) return new double [ ] { 
Double . NaN , Double . NaN } 
; 
double s_d = Math . sqrt ( c1 - c2 ) ; 
double s_n = ( h * Math . cos ( x ) * Math . cos ( y ) - s_d ) / ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) ; 
double s_1 = h - s_n * Math . cos ( x ) * Math . cos ( y ) ; 
double s_2 = s_n * Math . sin ( x ) * Math . cos ( y ) ; 
double s_3 = - s_n * Math . sin ( y ) ; 
double s_xy = Math . sqrt ( s_1 * s_1 + s_2 * s_2 ) ; 
double geographic_lon = Math . atan ( s_2 / s_1 ) + sub_lon ; 
double geographic_lat = Math . atan ( - fp * ( s_3 / s_xy ) ) ; 
double lonDegrees = RAD_TO_DEG * geographic_lon ; 
double latDegrees = RAD_TO_DEG * geographic_lat ; 
if ( lonDegrees < - 180.0 ) lonDegrees += 360.0 ; 
if ( lonDegrees > 180.0 ) lonDegrees -= 360.0 ; 
return new double [ ] { 
lonDegrees , latDegrees } 
; 
} 
} 

public class GEOSTransform { 
public static String scanGeomToSweepAngleAxis ( String scanGeometry ) { 
String sweepAngleAxis = "y" ; 
if ( scanGeometry . equals ( GOES ) ) sweepAngleAxis = "x" ; 
return sweepAngleAxis ; 
} 
} 

public class GEOSTransform { 
public static String sweepAngleAxisToScanGeom ( String sweepAngleAxis ) { 
String scanGeom = GOES ; 
if ( sweepAngleAxis . equals ( "y" ) ) scanGeom = GEOS ; 
return scanGeom ; 
} 
} 

public class WRFEta { 
private ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { 
int [ ] shape = array . getShape ( ) ; 
int [ ] newShape = new int [ 3 ] ; 
System . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; 
newShape [ dimIndex ] ++ ; 
int ni = newShape [ 0 ] ; 
int nj = newShape [ 1 ] ; 
int nk = newShape [ 2 ] ; 
ArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; 
int n = shape [ dimIndex ] ; 
double [ ] d = new double [ n ] ; 
int [ ] eshape = new int [ 3 ] ; 
int [ ] neweshape = new int [ 3 ] ; 
for ( int i = 0 ; 
i < 3 ; 
i ++ ) { 
eshape [ i ] = ( i == dimIndex ) ? n : 1 ; 
neweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; 
} 
int [ ] origin = new int [ 3 ] ; 
try { 
for ( int i = 0 ; 
i < ( ( dimIndex == 0 ) ? 1 : ni ) ; 
i ++ ) for ( int j = 0 ; 
j < ( ( dimIndex == 1 ) ? 1 : nj ) ; 
j ++ ) for ( int k = 0 ; 
k < ( ( dimIndex == 2 ) ? 1 : nk ) ; 
k ++ ) { 
origin [ 0 ] = i ; 
origin [ 1 ] = j ; 
origin [ 2 ] = k ; 
IndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; 
for ( int l = 0 ; 
l < n ; 
l ++ ) d [ l ] = it . getDoubleNext ( ) ; 
double [ ] d2 = extrapinterpolate ( d ) ; 
IndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; 
for ( int l = 0 ; 
l < n + 1 ; 
l ++ ) newit . setDoubleNext ( d2 [ l ] ) ; 
} 
} 
catch ( InvalidRangeException e ) { 
return null ; 
} 
return newArray ; 
} 
} 

public class WRFEta { 
private double [ ] extrapinterpolate ( double [ ] array ) { 
int n = array . length ; 
double [ ] d = new double [ n + 1 ] ; 
d [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; 
d [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; 
for ( int i = 1 ; 
i < n ; 
i ++ ) d [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; 
return d ; 
} 
} 

public class GempakStationFileIOSP { 
protected Structure makeStructure ( String partName , List < Dimension > dimensions , boolean includeMissing ) { 
List < GempakParameter > params = gemreader . getParameters ( partName ) ; 
if ( params == null ) return null ; 
Structure sVar = new Structure ( ncfile , null , null , partName ) ; 
sVar . setDimensions ( dimensions ) ; 
for ( GempakParameter param : params ) { 
sVar . addMemberVariable ( makeParamVariable ( param , null ) ) ; 
} 
if ( includeMissing ) sVar . addMemberVariable ( makeMissingVariable ( ) ) ; 
return sVar ; 
} 
} 

public class GempakStationFileIOSP { 
protected Variable makeParamVariable ( GempakParameter param , List < Dimension > dims ) { 
Variable var = new Variable ( ncfile , null , null , param . getName ( ) ) ; 
var . setDataType ( DataType . FLOAT ) ; 
var . setDimensions ( dims ) ; 
var . addAttribute ( new Attribute ( CDM . LONG_NAME , param . getDescription ( ) ) ) ; 
String units = param . getUnit ( ) ; 
if ( ( units != null ) && ! units . equals ( "" ) ) var . addAttribute ( new Attribute ( CDM . UNITS , units ) ) ; 
var . addAttribute ( new Attribute ( CDM . MISSING_VALUE , RMISS ) ) ; 
return var ; 
} 
} 

public class GempakStationFileIOSP { 
protected int getStnVarSize ( String name ) { 
int size = - 1 ; 
for ( int i = 0 ; 
i < stnVarNames . length ; 
i ++ ) if ( name . equals ( stnVarNames [ i ] ) ) { 
size = stnVarSizes [ i ] ; 
break ; 
} 
return size ; 
} 
} 

public class GempakStationFileIOSP { 
private Array get1DArray ( DataType type , int len ) { 
Array varArray = null ; 
if ( type . equals ( DataType . FLOAT ) ) varArray = new ArrayFloat . D1 ( len ) ; 
else if ( type . equals ( DataType . DOUBLE ) ) varArray = new ArrayDouble . D1 ( len ) ; 
else if ( type . equals ( DataType . INT ) ) varArray = new ArrayInt . D1 ( len , false ) ; 
return varArray ; 
} 
} 

public class CeParser { 
private String yysyntax_error ( int yystate , int tok ) { 
if ( yyErrorVerbose ) if ( tok != yyempty_ ) { 
StringBuffer res = new StringBuffer ( "syntax error, unexpected " ) ; 
res . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; 
int yyn = yypact_ [ yystate ] ; 
if ( ! yy_pact_value_is_default_ ( yyn ) ) { 
int yyxbegin = yyn < 0 ? - yyn : 0 ; 
int yychecklim = yylast_ - yyn + 1 ; 
int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; 
int count = 0 ; 
for ( int x = yyxbegin ; 
x < yyxend ; 
++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; 
if ( count < 5 ) { 
count = 0 ; 
for ( int x = yyxbegin ; 
x < yyxend ; 
++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { 
res . append ( count ++ == 0 ? ", expecting " : " or " ) ; 
res . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; 
} 
} 
} 
return res . toString ( ) ; 
} 
return "syntax error" ; 
} 
} 

public class ChunkInputStream { 
public String readDMR ( ) throws DapException { 
try { 
if ( state != State . INITIAL ) throw new DapException ( "Attempt to read DMR twice" ) ; 
byte [ ] dmr8 = null ; 
if ( requestmode == RequestMode . DMR ) { 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
int c ; 
while ( ( c = input . read ( ) ) >= 0 ) baos . write ( c ) ; 
baos . close ( ) ; 
dmr8 = baos . toByteArray ( ) ; 
} 
else if ( requestmode == RequestMode . DAP ) { 
if ( ! readHeader ( input ) ) throw new DapException ( "Malformed chunk count" ) ; 
dmr8 = new byte [ this . chunksize ] ; 
int red = read ( dmr8 , 0 , this . chunksize ) ; 
if ( red < this . chunksize ) throw new DapException ( "Short chunk" ) ; 
} 
else assert false : "Internal error" ; 
String dmr = new String ( dmr8 , DapUtil . UTF8 ) ; 
dmr = dmr . trim ( ) ; 
if ( dmr . endsWith ( "\r\n" ) ) { 
} 
else if ( dmr . endsWith ( "\n" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + "\r\n" ; 
else dmr = dmr + "\r\n" ; 
this . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; 
this . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; 
if ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; 
else if ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; 
else state = State . DATA ; 
return dmr ; 
} 
catch ( IOException ioe ) { 
throw new DapException ( ioe . getMessage ( ) ) ; 
} 
} 
} 

public class ChunkInputStream { 
public int read ( byte [ ] buf , int off , int len ) throws IOException { 
if ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; 
if ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; 
if ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( "Attempt to read databuffer when DMR only" ) ; 
int count = len ; 
int pos = off ; 
while ( count > 0 ) if ( avail <= 0 ) { 
if ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; 
if ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { 
String document = readError ( ) ; 
throwError ( document ) ; 
} 
} 
else { 
int actual = ( this . avail < count ? this . avail : count ) ; 
int red = input . read ( buf , pos , actual ) ; 
if ( red < 0 ) throw new IOException ( "Unexpected EOF" ) ; 
pos += red ; 
count -= red ; 
this . avail -= red ; 
} 
return len ; 
} 
} 

public class TableParser { 
static public List < Record > readTable ( String urlString , String format , int maxLines ) throws IOException , NumberFormatException { 
InputStream ios ; 
if ( urlString . startsWith ( "http:" ) ) { 
URL url = new URL ( urlString ) ; 
ios = url . openStream ( ) ; 
} 
else ios = new FileInputStream ( urlString ) ; 
return readTable ( ios , format , maxLines ) ; 
} 
} 

public class DatasetConstructor { 
static private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { 
boolean unlimitedOK = true ; 
transferGroupAttributes ( src , targetGroup ) ; 
for ( Dimension d : src . getDimensions ( ) ) { 
if ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { 
Dimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; 
targetGroup . addDimension ( newd ) ; 
} 
} 
for ( Variable v : src . getVariables ( ) ) { 
Variable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; 
VariableEnhanced targetVe = ( VariableEnhanced ) targetV ; 
boolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; 
if ( replace || ( null == targetV ) ) { 
if ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) v = new StructureDS ( targetGroup , ( Structure ) v ) ; 
else if ( ! ( v instanceof VariableDS ) ) v = new VariableDS ( targetGroup , v , false ) ; 
if ( null != targetV ) targetGroup . remove ( targetV ) ; 
targetGroup . addVariable ( v ) ; 
v . resetDimensions ( ) ; 
} 
else if ( ! targetV . hasCachedData ( ) && ( targetVe . getOriginalVariable ( ) == null ) ) targetVe . setOriginalVariable ( v ) ; 
} 
for ( Group srcNested : src . getGroups ( ) ) { 
Group nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; 
if ( null == nested ) { 
nested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; 
targetGroup . addGroup ( nested ) ; 
} 
transferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; 
} 
} 
} 

public class IgraPor { 
@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { 
super . open ( raff , ncfile , cancelTask ) ; 
int pos = location . lastIndexOf ( "." ) ; 
String ext = location . substring ( pos ) ; 
File file = new File ( location ) ; 
File stnFile = getStnFile ( location ) ; 
if ( stnFile == null ) throw new FileNotFoundException ( "Station File does not exist=" + location ) ; 
if ( ext . equals ( IDX_EXT ) ) stnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; 
else if ( ext . equals ( DAT_EXT ) ) { 
stnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; 
dataRaf = raff ; 
String name = file . getName ( ) ; 
stationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; 
} 
else { 
stnRaf = raff ; 
dataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; 
} 
NcmlConstructor ncmlc = new NcmlConstructor ( ) ; 
if ( ! ncmlc . populateFromResource ( "resources/nj22/iosp/igra-por.ncml" , ncfile ) ) throw new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; 
ncfile . finish ( ) ; 
stnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , "station" ) ; 
seriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , "station.time_series" ) ; 
profileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , "station.time_series.levels" ) ; 
StructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; 
StructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; 
stn_fldno = f . fldno ; 
} 
} 

public class SimpleGeometryIndexFinder { 
public int getBeginning ( int index ) { 
if ( index == ( pastIndex + 1 ) ) return previousEnd + 1 ; 
int newBeginning = 0 ; 
for ( int i = 0 ; 
i < index ; 
i ++ ) newBeginning += getNodeCount ( i ) ; 
pastIndex = index ; 
previousBegin = newBeginning ; 
return newBeginning ; 
} 
} 

public class SimpleGeometryIndexFinder { 
public int getEnd ( int index ) { 
if ( index == ( pastIndex - 1 ) ) return previousBegin - 1 ; 
int new_end = 0 ; 
for ( int i = 0 ; 
i < index + 1 ; 
i ++ ) new_end += getNodeCount ( i ) ; 
pastIndex = index ; 
previousEnd = new_end ; 
return new_end - 1 ; 
} 
} 

public class Cosmic1Convention { 
public static double [ ] ECFtoLLA ( double x , double y , double z , double a , double b ) { 
double longitude = Math . atan2 ( y , x ) ; 
double ePrimeSquared = ( a * a - b * b ) / ( b * b ) ; 
double p = Math . sqrt ( x * x + y * y ) ; 
double theta = Math . atan ( ( z * a ) / ( p * b ) ) ; 
double sineTheta = Math . sin ( theta ) ; 
double cosTheta = Math . cos ( theta ) ; 
double f = 1 / 298.257223563 ; 
double e2 = 2 * f - f * f ; 
double top = z + ePrimeSquared * b * sineTheta * sineTheta * sineTheta ; 
double bottom = p - e2 * a * cosTheta * cosTheta * cosTheta ; 
double geodeticLat = Math . atan ( top / bottom ) ; 
double sineLat = Math . sin ( geodeticLat ) ; 
double N = a / Math . sqrt ( 1 - e2 * sineLat * sineLat ) ; 
double altitude = ( p / Math . cos ( geodeticLat ) ) - N ; 
if ( longitude > Math . PI ) longitude -= 2 * Math . PI ; 
else if ( longitude < - Math . PI ) longitude += 2 * Math . PI ; 
return new double [ ] { 
geodeticLat , longitude , altitude } 
; 
} 
} 

public class Util { 
public static String cleanUnit ( String unit ) { 
if ( unit == null ) return null ; 
if ( unit . equalsIgnoreCase ( "Proportion" ) || unit . equalsIgnoreCase ( "Numeric" ) ) unit = "" ; 
else if ( unit . equalsIgnoreCase ( "-" ) ) unit = "" ; 
else if ( unit . startsWith ( "degree" ) && unit . endsWith ( "true" ) ) unit = unit . replace ( ' ' , '_' ) ; 
else if ( ! unit . contains ( " table " ) ) { 
if ( unit . startsWith ( "/" ) ) unit = "1" + unit ; 
unit = unit . trim ( ) ; 
unit = StringUtil2 . remove ( unit , "**" ) ; 
StringBuilder sb = new StringBuilder ( unit ) ; 
StringUtil2 . remove ( sb , "^[]" ) ; 
StringUtil2 . replace ( sb , ' ' , "." ) ; 
StringUtil2 . replace ( sb , '*' , "." ) ; 
unit = sb . toString ( ) ; 
} 
return unit ; 
} 
} 

public class DodsV { 
void parseDAS ( DAS das ) throws IOException { 
Enumeration tableNames = das . getNames ( ) ; 
while ( tableNames . hasMoreElements ( ) ) { 
String tableName = ( String ) tableNames . nextElement ( ) ; 
AttributeTable attTable = das . getAttributeTableN ( tableName ) ; 
if ( tableName . equals ( "NC_GLOBAL" ) || tableName . equals ( "HDF_GLOBAL" ) ) addAttributeTable ( this , attTable , tableName , true ) ; 
else if ( tableName . equals ( "DODS_EXTRA" ) || tableName . equals ( "EXTRA_DIMENSION" ) ) continue ; 
else { 
DodsV dodsV = findDodsV ( tableName , false ) ; 
if ( dodsV != null ) addAttributeTable ( dodsV , attTable , tableName , true ) ; 
else { 
dodsV = findTableDotDelimited ( tableName ) ; 
if ( dodsV != null ) addAttributeTable ( dodsV , attTable , tableName , true ) ; 
else { 
if ( debugAttributes ) System . out . println ( "DODSNetcdf getAttributes CANT find <" + tableName + "> add to globals" ) ; 
addAttributeTable ( this , attTable , tableName , false ) ; 
} 
} 
} 
} 
} 
} 

public class Variable { 
public Section getShapeAsSection ( ) { 
if ( shapeAsSection == null ) try { 
List < Range > list = new ArrayList < > ( ) ; 
for ( Dimension d : dimensions ) { 
int len = d . getLength ( ) ; 
if ( len > 0 ) list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; 
else if ( len == 0 ) list . add ( Range . EMPTY ) ; 
else { 
assert d . isVariableLength ( ) ; 
list . add ( Range . VLEN ) ; 
} 
} 
shapeAsSection = new Section ( list ) . makeImmutable ( ) ; 
} 
catch ( InvalidRangeException e ) { 
log . error ( "Bad shape in variable " + getFullName ( ) , e ) ; 
throw new IllegalStateException ( e . getMessage ( ) ) ; 
} 
return shapeAsSection ; 
} 
} 

public class Variable { 
public Variable slice ( int dim , int value ) throws InvalidRangeException { 
if ( ( dim < 0 ) || ( dim >= shape . length ) ) throw new InvalidRangeException ( "Slice dim invalid= " + dim ) ; 
boolean recordSliceOk = false ; 
if ( ( dim == 0 ) && ( value == 0 ) ) { 
Dimension d = getDimension ( 0 ) ; 
recordSliceOk = d . isUnlimited ( ) ; 
} 
if ( ! recordSliceOk ) if ( ( value < 0 ) || ( value >= shape [ dim ] ) ) throw new InvalidRangeException ( "Slice value invalid= " + value + " for dimension " + dim ) ; 
Variable sliceV = copy ( ) ; 
Section slice = new Section ( getShapeAsSection ( ) ) ; 
slice . replaceRange ( dim , new Range ( value , value ) ) . makeImmutable ( ) ; 
sliceV . setProxyReader ( new SliceReader ( this , dim , slice ) ) ; 
sliceV . createNewCache ( ) ; 
sliceV . setCaching ( false ) ; 
sliceV . dimensions . remove ( dim ) ; 
sliceV . resetShape ( ) ; 
return sliceV ; 
} 
} 

public class Variable { 
protected Array _read ( ) throws IOException { 
if ( cache . data != null ) { 
if ( debugCaching ) System . out . println ( "got data from cache " + getFullName ( ) ) ; 
return cache . data . copy ( ) ; 
} 
Array data = proxyReader . reallyRead ( this , null ) ; 
if ( isCaching ( ) ) { 
setCachedData ( data ) ; 
if ( debugCaching ) System . out . println ( "cache " + getFullName ( ) ) ; 
return cache . data . copy ( ) ; 
} 
else return data ; 
} 
} 

public class Variable { 
public void resetShape ( ) { 
this . shape = new int [ dimensions . size ( ) ] ; 
for ( int i = 0 ; 
i < dimensions . size ( ) ; 
i ++ ) { 
Dimension dim = dimensions . get ( i ) ; 
shape [ i ] = dim . getLength ( ) ; 
if ( dim . isVariableLength ( ) ) isVariableLength = true ; 
} 
this . shapeAsSection = null ; 
} 
} 

public class Variable { 
public void resetDimensions ( ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
ArrayList < Dimension > newDimensions = new ArrayList < > ( ) ; 
for ( Dimension dim : dimensions ) { 
if ( dim . isShared ( ) ) { 
Dimension newD = getParentGroup ( ) . findDimension ( dim . getShortName ( ) ) ; 
if ( newD == null ) throw new IllegalArgumentException ( "Variable " + getFullName ( ) + " resetDimensions  FAILED, dim doesnt exist in parent group=" + dim ) ; 
newDimensions . add ( newD ) ; 
} 
else newDimensions . add ( dim ) ; 
} 
this . dimensions = newDimensions ; 
resetShape ( ) ; 
} 
} 

public class CDMDSP { 
protected void buildseqtypes ( Variable cdmvar ) throws DapException { 
if ( CDMUtil . hasVLEN ( cdmvar ) ) buildseqtype ( cdmvar ) ; 
if ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { 
Structure struct = ( Structure ) cdmvar ; 
List < Variable > fields = struct . getVariables ( ) ; 
for ( int i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
Variable field = fields . get ( i ) ; 
buildseqtypes ( field ) ; 
} 
} 
} 
} 

public class CDMDSP { 
protected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { 
if ( cdmdims == null || cdmdims . size ( ) == 0 ) return ; 
for ( Dimension cdmdim : cdmdims ) { 
DapDimension dapdim = null ; 
if ( cdmdim . isShared ( ) ) { 
Dimension declareddim = finddimdecl ( cdmdim ) ; 
if ( declareddim == null ) throw new DapException ( "Unprocessed cdm dimension: " + cdmdim ) ; 
dapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; 
assert dapdim != null ; 
} 
else if ( cdmdim . isVariableLength ( ) ) continue ; 
else dapdim = builddim ( cdmdim ) ; 
assert ( dapdim != null ) : "Internal error" ; 
dapvar . addDimension ( dapdim ) ; 
} 
} 
} 

public class CDMDSP { 
static List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { 
if ( dimset == null ) return null ; 
List < Dimension > core = new ArrayList < > ( ) ; 
int pos = - 1 ; 
int count = 0 ; 
for ( int i = 0 ; 
i < dimset . size ( ) ; 
i ++ ) if ( dimset . get ( i ) . isVariableLength ( ) ) { 
pos = i ; 
count ++ ; 
} 
else core . add ( dimset . get ( i ) ) ; 
if ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( "Unsupported use of (*) Dimension" ) ; 
return core ; 
} 
} 

public class CdmValidatorController { 
public void doPost ( HttpServletRequest req , HttpServletResponse res ) throws ServletException , IOException { 
log . info ( "doPost(): " + UsageLog . setupRequestContext ( req ) ) ; 
boolean isMultipart = ServletFileUpload . isMultipartContent ( req ) ; 
if ( ! isMultipart ) { 
log . info ( "doPost(): " + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; 
res . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; 
return ; 
} 
ServletFileUpload upload = new ServletFileUpload ( this . cdmValidatorContext . getFileuploadFileItemFactory ( ) ) ; 
upload . setSizeMax ( this . cdmValidatorContext . getMaxFileUploadSize ( ) ) ; 
List < FileItem > fileItems ; 
try { 
fileItems = ( List < FileItem > ) upload . parseRequest ( req ) ; 
} 
catch ( FileUploadException e ) { 
log . info ( "doPost(): Validator FileUploadException" , e ) ; 
log . info ( "doPost(): " + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; 
if ( ! res . isCommitted ( ) ) res . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; 
return ; 
} 
String username = null ; 
boolean wantXml = false ; 
for ( FileItem item : fileItems ) { 
if ( item . isFormField ( ) ) { 
if ( "username" . equals ( item . getFieldName ( ) ) ) username = item . getString ( ) ; 
if ( "xml" . equals ( item . getFieldName ( ) ) ) wantXml = item . getString ( ) . equals ( "true" ) ; 
} 
} 
for ( FileItem item : fileItems ) { 
if ( ! item . isFormField ( ) ) try { 
processUploadedFile ( req , res , ( DiskFileItem ) item , username , wantXml ) ; 
return ; 
} 
catch ( Exception e ) { 
log . info ( "doPost(): Validator processUploadedFile" , e ) ; 
log . info ( "doPost(): " + UsageLog . closingMessageForRequestContext ( HttpServletResponse . SC_BAD_REQUEST , 0 ) ) ; 
res . sendError ( HttpServletResponse . SC_BAD_REQUEST , e . getMessage ( ) ) ; 
} 
} 
} 
} 

public class AccessLogParser { 
public static void main ( String [ ] args ) throws IOException { 
AccessLogParser p = new AccessLogParser ( ) ; 
String line = "24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \" 200 10409 \"-\" \"-\" 17" ; 
Matcher m = regPattern . matcher ( line ) ; 
System . out . printf ( "%s %s%n" , m . matches ( ) , m ) ; 
for ( int i = 0 ; 
i < m . groupCount ( ) ; 
i ++ ) System . out . println ( " " + i + " " + m . group ( i ) ) ; 
LogReader . Log log = p . parseLog ( line ) ; 
System . out . printf ( "%s%n" , log ) ; 
} 
} 

public class GempakLookup { 
public final boolean isPositiveUp ( GridRecord gr ) { 
int type = gr . getLevelType1 ( ) ; 
if ( ( type == 1 ) || ( type == 5 ) ) return false ; 
return true ; 
} 
} 

public class UnitImpl { 
public String makeLabel ( final String quantityID ) { 
final StringBuilder buf = new StringBuilder ( quantityID ) ; 
if ( quantityID . contains ( " " ) ) buf . insert ( 0 , '(' ) . append ( ')' ) ; 
buf . append ( '/' ) ; 
final int start = buf . length ( ) ; 
buf . append ( toString ( ) ) ; 
if ( buf . substring ( start ) . indexOf ( ' ' ) != - 1 ) buf . insert ( start , '(' ) . append ( ')' ) ; 
return buf . toString ( ) ; 
} 
} 

public class DConnect2 { 
private void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { 
InputStream is = null ; 
try { 
try ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { 
if ( acceptCompress ) method . setCompression ( "deflate,gzip" ) ; 
if ( allowSessions ) method . setUseSessions ( true ) ; 
int statusCode ; 
for ( ; 
; 
) { 
statusCode = method . execute ( ) ; 
if ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; 
Thread . sleep ( 5000 ) ; 
System . err . println ( "Service Unavailable" ) ; 
} 
if ( statusCode == HttpStatus . SC_NOT_FOUND ) throw new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + ": " + urlString ) ; 
if ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) throw new InvalidCredentialsException ( method . getStatusText ( ) ) ; 
if ( statusCode != HttpStatus . SC_OK ) throw new DAP2Exception ( "Method failed:" + method . getStatusText ( ) + " on URL= " + urlString ) ; 
is = method . getResponseAsStream ( ) ; 
Header header = method . getResponseHeader ( "Content-Description" ) ; 
if ( header != null && ( header . getValue ( ) . equals ( "dods-error" ) || header . getValue ( ) . equals ( "dods_error" ) ) ) { 
DAP2Exception ds = new DAP2Exception ( ) ; 
ds . parse ( is ) ; 
throw ds ; 
} 
ver = new ServerVersion ( method ) ; 
checkHeaders ( method ) ; 
Header h = method . getResponseHeader ( "content-encoding" ) ; 
String encoding = ( h == null ) ? null : h . getValue ( ) ; 
if ( encoding != null && encoding . equals ( "deflate" ) ) { 
is = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; 
if ( showCompress ) System . out . printf ( "deflate %s%n" , urlString ) ; 
} 
else if ( encoding != null && encoding . equals ( "gzip" ) ) { 
is = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; 
if ( showCompress ) System . out . printf ( "gzip %s%n" , urlString ) ; 
} 
else if ( showCompress ) System . out . printf ( "none %s%n" , urlString ) ; 
command . process ( is ) ; 
} 
} 
catch ( IOException | DAP2Exception e ) { 
throw e ; 
} 
catch ( Exception e ) { 
Util . check ( e ) ; 
throw new DAP2Exception ( e ) ; 
} 
} 
} 

public class DConnect2 { 
public DAS getDAS ( ) throws IOException , DAP2Exception { 
DASCommand command = new DASCommand ( ) ; 
if ( filePath != null ) { 
File daspath = new File ( filePath + ".das" ) ; 
if ( daspath . canRead ( ) ) try ( FileInputStream is = new FileInputStream ( daspath ) ) { 
command . process ( is ) ; 
} 
} 
else if ( stream != null ) command . process ( stream ) ; 
else try { 
openConnection ( urlString + ".das" + getCompleteCE ( projString , selString ) , command ) ; 
} 
catch ( DAP2Exception de ) { 
} 
return command . das ; 
} 
} 

public class DConnect2 { 
public DDS getDDS ( String CE ) throws IOException , ParseException , DAP2Exception { 
DDSCommand command = new DDSCommand ( ) ; 
command . setURL ( CE == null || CE . length ( ) == 0 ? urlString : urlString + "?" + CE ) ; 
if ( filePath != null ) try ( FileInputStream is = new FileInputStream ( filePath + ".dds" ) ) { 
command . process ( is ) ; 
} 
else if ( stream != null ) command . process ( stream ) ; 
else openConnection ( urlString + ".dds" + ( getCompleteCE ( CE ) ) , command ) ; 
return command . dds ; 
} 
} 

public class Sinusoidal { 
@ Override public LatLonPoint projToLatLon ( ProjectionPoint world , LatLonPointImpl result ) { 
double fromX = world . getX ( ) - falseEasting ; 
double fromY = world . getY ( ) - falseNorthing ; 
double toLat_r = fromY / earthRadius ; 
double toLon_r ; 
if ( Misc . nearlyEquals ( Math . abs ( toLat_r ) , PI_OVER_2 , 1e-10 ) ) { 
toLat_r = toLat_r < 0 ? - PI_OVER_2 : + PI_OVER_2 ; 
toLon_r = Math . toRadians ( centMeridian ) ; 
} 
else if ( Math . abs ( toLat_r ) < PI_OVER_2 ) toLon_r = Math . toRadians ( centMeridian ) + fromX / ( earthRadius * Math . cos ( toLat_r ) ) ; 
else return INVALID ; 
if ( Misc . nearlyEquals ( Math . abs ( toLon_r ) , PI , 1e-10 ) ) toLon_r = toLon_r < 0 ? - PI : + PI ; 
else if ( Math . abs ( toLon_r ) > PI ) return INVALID ; 
result . setLatitude ( Math . toDegrees ( toLat_r ) ) ; 
result . setLongitude ( Math . toDegrees ( toLon_r ) ) ; 
return result ; 
} 
} 

public class Escape { 
private static String xunescapeString ( String in , char escape , boolean spaceplus ) { 
try { 
if ( in == null ) return null ; 
byte [ ] utf8 = in . getBytes ( utf8Charset ) ; 
byte escape8 = ( byte ) escape ; 
byte [ ] out = new byte [ utf8 . length ] ; 
int index8 = 0 ; 
for ( int i = 0 ; 
i < utf8 . length ; 
) { 
byte b = utf8 [ i ++ ] ; 
if ( b == plus && spaceplus ) out [ index8 ++ ] = blank ; 
else if ( b == escape8 ) if ( i + 2 <= utf8 . length ) { 
b = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; 
i += 2 ; 
} 
out [ index8 ++ ] = b ; 
} 
return new String ( out , 0 , index8 , utf8Charset ) ; 
} 
catch ( Exception e ) { 
return in ; 
} 
} 
} 

public class Escape { 
public static String backslashDecode ( String s ) { 
StringBuilder buf = new StringBuilder ( s ) ; 
int i = 0 ; 
while ( i < buf . length ( ) ) { 
if ( buf . charAt ( i ) == '\\' ) buf . deleteCharAt ( i ) ; 
i ++ ; 
} 
return buf . toString ( ) ; 
} 
} 

public class Swap { 
static public int swapInt ( byte [ ] b , int offset ) { 
int accum = 0 ; 
for ( int shiftBy = 0 , i = offset ; 
shiftBy < 32 ; 
shiftBy += 8 , i ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; 
return accum ; 
} 
} 

public class Swap { 
static public byte [ ] shortToBytes ( short v ) { 
byte [ ] b = new byte [ 2 ] ; 
int allbits = 255 ; 
for ( int i = 0 ; 
i < 2 ; 
i ++ ) b [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; 
return b ; 
} 
} 

public class Swap { 
static public byte [ ] intToBytes ( int v ) { 
byte [ ] b = new byte [ 4 ] ; 
int allbits = 255 ; 
for ( int i = 0 ; 
i < 4 ; 
i ++ ) b [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; 
return b ; 
} 
} 

public class Swap { 
static public byte [ ] longToBytes ( long v ) { 
byte [ ] b = new byte [ 8 ] ; 
long allbits = 255 ; 
for ( int i = 0 ; 
i < 8 ; 
i ++ ) b [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; 
return b ; 
} 
} 

public class GridCoordSys { 
void addLevels ( List < GridRecord > records ) { 
for ( GridRecord record : records ) { 
Double d = new Double ( record . getLevel1 ( ) ) ; 
if ( ! levels . contains ( d ) ) levels . add ( d ) ; 
if ( dontUseVertical && ( levels . size ( ) > 1 ) ) if ( GridServiceProvider . debugVert ) System . out . println ( "GribCoordSys: unused level coordinate has > 1 levels = " + verticalName + " " + record . getLevelType1 ( ) + " " + levels . size ( ) ) ; 
} 
Collections . sort ( levels ) ; 
if ( positive . equals ( "down" ) ) Collections . reverse ( levels ) ; 
} 
} 

public class GridCoordSys { 
void addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { 
if ( dontUseVertical ) return ; 
int nlevs = levels . size ( ) ; 
ncfile . addDimension ( g , new Dimension ( verticalName , nlevs , true ) ) ; 
} 
} 

public class GridCoordSys { 
void addToNetcdfFile ( NetcdfFile ncfile , Group g ) { 
if ( dontUseVertical ) return ; 
if ( g == null ) g = ncfile . getRootGroup ( ) ; 
String dims = "time" ; 
if ( ! dontUseVertical ) dims = dims + " " + verticalName ; 
if ( hcs . isLatLon ( ) ) dims = dims + " lat lon" ; 
else dims = dims + " y x" ; 
int nlevs = levels . size ( ) ; 
Variable v = new Variable ( ncfile , g , null , verticalName ) ; 
v . setDataType ( DataType . DOUBLE ) ; 
v . addAttribute ( new Attribute ( "long_name" , lookup . getLevelDescription ( record ) ) ) ; 
v . addAttribute ( new Attribute ( "units" , lookup . getLevelUnit ( record ) ) ) ; 
if ( positive != null ) v . addAttribute ( new Attribute ( "positive" , positive ) ) ; 
if ( units != null ) { 
AxisType axisType ; 
if ( SimpleUnit . isCompatible ( "millibar" , units ) ) axisType = AxisType . Pressure ; 
else if ( SimpleUnit . isCompatible ( "m" , units ) ) axisType = AxisType . Height ; 
else axisType = AxisType . GeoZ ; 
v . addAttribute ( new Attribute ( "grid_level_type" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; 
v . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; 
if ( ! hcs . isLatLon ( ) ) v . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; 
} 
double [ ] data = new double [ nlevs ] ; 
for ( int i = 0 ; 
i < levels . size ( ) ; 
i ++ ) { 
Double d = ( Double ) levels . get ( i ) ; 
data [ i ] = d . doubleValue ( ) ; 
} 
Array dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { 
nlevs } 
, data ) ; 
v . setDimensions ( verticalName ) ; 
v . setCachedData ( dataArray , false ) ; 
ncfile . addVariable ( g , v ) ; 
if ( record . getLevelType1 ( ) == 109 ) findCoordinateTransform ( g , "Pressure" , record . getLevelType1 ( ) ) ; 
} 
} 

public class GridCoordSys { 
void findCoordinateTransform ( Group g , String nameStartsWith , int levelType ) { 
List < Variable > vars = g . getVariables ( ) ; 
for ( Variable v : vars ) { 
if ( v . getShortName ( ) . equals ( nameStartsWith ) ) { 
Attribute att = v . findAttribute ( "grid_level_type" ) ; 
if ( ( att == null ) || ( att . getNumericValue ( ) . intValue ( ) != levelType ) ) continue ; 
v . addAttribute ( new Attribute ( _Coordinate . TransformType , "Vertical" ) ) ; 
v . addAttribute ( new Attribute ( "transform_name" , "Existing3DField" ) ) ; 
} 
} 
} 
} 

public class DiskCache2 { 
public File getFile ( String fileLocation ) { 
if ( ! alwaysUseCache ) { 
File f = new File ( fileLocation ) ; 
if ( f . exists ( ) ) return f ; 
if ( canWrite ( f ) ) return f ; 
} 
if ( neverUseCache ) throw new IllegalStateException ( "neverUseCache=true, but file does not exist and directory is not writeable =" + fileLocation ) ; 
File f = new File ( makeCachePath ( fileLocation ) ) ; 
if ( cachePathPolicy == CachePathPolicy . NestedDirectory ) { 
File dir = f . getParentFile ( ) ; 
if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) cacheLog . warn ( "Cant create directories for file " + dir . getPath ( ) ) ; 
} 
return f ; 
} 
} 

public class DiskCache2 { 
public void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { 
long now = System . currentTimeMillis ( ) ; 
File [ ] files = dir . listFiles ( ) ; 
if ( files == null ) throw new IllegalStateException ( "DiskCache2: not a directory or I/O error on dir=" + dir . getAbsolutePath ( ) ) ; 
if ( ! isRoot && ( files . length == 0 ) ) { 
long duration = now - dir . lastModified ( ) ; 
duration /= 1000 * 60 ; 
if ( duration > persistMinutes ) { 
boolean ok = dir . delete ( ) ; 
if ( ! ok ) cacheLog . error ( "Unable to delete file " + dir . getAbsolutePath ( ) ) ; 
if ( sbuff != null ) sbuff . format ( " deleted %s %s lastModified= %s%n" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; 
} 
return ; 
} 
for ( File file : files ) { 
if ( file . isDirectory ( ) ) cleanCache ( file , sbuff , false ) ; 
else { 
long duration = now - file . lastModified ( ) ; 
duration /= 1000 * 60 ; 
if ( duration > persistMinutes ) { 
boolean ok = file . delete ( ) ; 
if ( ! ok ) cacheLog . error ( "Unable to delete file " + file . getAbsolutePath ( ) ) ; 
if ( sbuff != null ) sbuff . format ( " deleted %s %s lastModified= %s%n" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; 
} 
} 
} 
} 
} 

public class SourcePicture { 
public void loadPictureInThread ( URL imageUrl , int priority , double rotation ) { 
if ( pictureStatusCode == LOADING ) stopLoadingExcept ( imageUrl ) ; 
this . imageUrl = imageUrl ; 
this . rotation = rotation ; 
LoadThread t = new LoadThread ( this ) ; 
t . setPriority ( priority ) ; 
t . start ( ) ; 
} 
} 

public class SourcePicture { 
public void loadPicture ( URL imageUrl , double rotation ) { 
if ( pictureStatusCode == LOADING ) stopLoadingExcept ( imageUrl ) ; 
this . imageUrl = imageUrl ; 
this . rotation = rotation ; 
loadPicture ( ) ; 
} 
} 

public class SourcePicture { 
public void loadPicture ( ) { 
Tools . log ( "SourcePicture.loadPicture: " + imageUrl . toString ( ) + " loaded into SourcePicture object: " + Integer . toString ( this . hashCode ( ) ) ) ; 
setStatus ( LOADING , "Loading: " + imageUrl . toString ( ) ) ; 
abortFlag = false ; 
try { 
ImageInputStream iis = ImageIO . createImageInputStream ( imageUrl . openStream ( ) ) ; 
Iterator i = ImageIO . getImageReaders ( iis ) ; 
if ( ! i . hasNext ( ) ) throw new IOException ( "No Readers Available!" ) ; 
reader = ( ImageReader ) i . next ( ) ; 
reader . addIIOReadProgressListener ( imageProgressListener ) ; 
reader . setInput ( iis ) ; 
sourcePictureBufferedImage = null ; 
sourcePictureBufferedImage = reader . read ( 0 ) ; 
iis . close ( ) ; 
reader . removeIIOReadProgressListener ( imageProgressListener ) ; 
reader . dispose ( ) ; 
if ( ! abortFlag ) { 
if ( rotation != 0 ) { 
setStatus ( ROTATING , "Rotating: " + imageUrl . toString ( ) ) ; 
int xRot = sourcePictureBufferedImage . getWidth ( ) / 2 ; 
int yRot = sourcePictureBufferedImage . getHeight ( ) / 2 ; 
AffineTransform rotateAf = AffineTransform . getRotateInstance ( Math . toRadians ( rotation ) , xRot , yRot ) ; 
AffineTransformOp op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; 
Rectangle2D newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; 
double minX = newBounds . getMinX ( ) ; 
double minY = newBounds . getMinY ( ) ; 
AffineTransform translateAf = AffineTransform . getTranslateInstance ( minX * ( - 1 ) , minY * ( - 1 ) ) ; 
rotateAf . preConcatenate ( translateAf ) ; 
op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; 
newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; 
BufferedImage targetImage = new BufferedImage ( ( int ) newBounds . getWidth ( ) , ( int ) newBounds . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; 
sourcePictureBufferedImage = op . filter ( sourcePictureBufferedImage , targetImage ) ; 
} 
setStatus ( READY , "Loaded: " + imageUrl . toString ( ) ) ; 
PictureCache . add ( imageUrl , ( SourcePicture ) this . clone ( ) ) ; 
} 
else { 
setStatus ( ERROR , "Aborted: " + imageUrl . toString ( ) ) ; 
sourcePictureBufferedImage = null ; 
} 
} 
catch ( IOException e ) { 
setStatus ( ERROR , "Error while reading " + imageUrl . toString ( ) ) ; 
sourcePictureBufferedImage = null ; 
} 
} 
} 

public class DbaseFile { 
private int loadData ( ) { 
if ( ! headerLoaded ) return - 1 ; 
if ( dataLoaded ) return 0 ; 
InputStream s = stream ; 
if ( s == null ) return - 1 ; 
try { 
for ( int i = 0 ; 
i < nrecords ; 
i ++ ) { 
byte recbyte = ds . readByte ( ) ; 
if ( recbyte == 0x20 ) for ( int j = 0 ; 
j < nfields ; 
j ++ ) data [ j ] . readRowN ( ds , i ) ; 
else { 
nrecords -- ; 
i -- ; 
} 
} 
dataLoaded = true ; 
} 
catch ( java . io . IOException e ) { 
close ( s ) ; 
return - 1 ; 
} 
finally { 
close ( s ) ; 
} 
return 0 ; 
} 
} 

public class DbaseFile { 
public DbaseData getField ( String Name ) { 
for ( int i = 0 ; 
i < nfields ; 
i ++ ) if ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; 
return null ; 
} 
} 

public class DbaseFile { 
public double [ ] getDoublesByName ( String Name ) { 
DbaseData d ; 
if ( ( d = getField ( Name ) ) == null ) return null ; 
if ( d . getType ( ) == DbaseData . TYPE_CHAR ) { 
String [ ] s = d . getStrings ( ) ; 
double [ ] dd = new double [ s . length ] ; 
for ( int i = 0 ; 
i < s . length ; 
i ++ ) dd [ i ] = Double . valueOf ( s [ i ] ) ; 
return dd ; 
} 
if ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { 
boolean [ ] b = d . getBooleans ( ) ; 
double [ ] dd = new double [ b . length ] ; 
for ( int i = 0 ; 
i < b . length ; 
i ++ ) if ( b [ i ] ) dd [ i ] = 1 ; 
else dd [ i ] = 0 ; 
return dd ; 
} 
return d . getDoubles ( ) ; 
} 
} 

public class DbaseFile { 
public String getFieldName ( int i ) { 
if ( i >= nfields || i < 0 ) return null ; 
return ( FieldDesc [ i ] . Name ) ; 
} 
} 

public class DbaseFile { 
public String [ ] getFieldNames ( ) { 
String [ ] s = new String [ nfields ] ; 
for ( int i = 0 ; 
i < nfields ; 
i ++ ) s [ i ] = getFieldName ( i ) ; 
return s ; 
} 
} 

public class DbaseFile { 
public static void main ( String [ ] args ) { 
if ( args . length < 1 ) { 
System . out . println ( "filename or URL required" ) ; 
System . exit ( - 1 ) ; 
} 
for ( String s : args ) { 
System . out . println ( "*** Dump of Dbase " + s + ":" ) ; 
try { 
DbaseFile dbf = new DbaseFile ( s ) ; 
if ( dbf . loadHeader ( ) != 0 ) { 
System . out . println ( "Error loading header" + s ) ; 
System . exit ( - 1 ) ; 
} 
String [ ] fieldNames = dbf . getFieldNames ( ) ; 
System . out . print ( "[" ) ; 
int nf = dbf . getNumFields ( ) ; 
DbaseData [ ] dbd = new DbaseData [ nf ] ; 
for ( int field = 0 ; 
field < nf ; 
field ++ ) { 
dbd [ field ] = dbf . getField ( field ) ; 
switch ( dbd [ field ] . getType ( ) ) { 
case DbaseData . TYPE_BOOLEAN : System . out . print ( "boolean " ) ; 
break ; 
case DbaseData . TYPE_CHAR : System . out . print ( "String " ) ; 
break ; 
case DbaseData . TYPE_NUMERIC : System . out . print ( "double " ) ; 
break ; 
} 
System . out . print ( fieldNames [ field ] ) ; 
if ( field < nf - 1 ) System . out . print ( ", " ) ; 
} 
System . out . println ( "]" ) ; 
if ( dbf . loadData ( ) != 0 ) { 
System . out . println ( "Error loading data" + s ) ; 
System . exit ( - 1 ) ; 
} 
for ( int rec = 0 ; 
rec < dbf . getNumRecords ( ) ; 
rec ++ ) for ( int field = 0 ; 
field < nf ; 
field ++ ) { 
System . out . print ( dbd [ field ] . getData ( rec ) ) ; 
if ( field < nf - 1 ) System . out . print ( ", " ) ; 
else System . out . println ( ) ; 
} 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
break ; 
} 
} 
} 
} 

public class DapNode { 
public DapGroup getGroup ( ) { 
if ( this . sort == DapSort . DATASET ) return null ; 
DapNode group = parent ; 
while ( group != null ) switch ( group . getSort ( ) ) { 
case DATASET : case GROUP : return ( DapGroup ) group ; 
default : group = group . getParent ( ) ; 
break ; 
} 
return ( DapGroup ) group ; 
} 
} 

public class NcMLWriter { 
public Element makeDimensionElement ( Dimension dim ) throws IllegalArgumentException { 
if ( ! dim . isShared ( ) ) throw new IllegalArgumentException ( "Cannot create private dimension: " + "in NcML, <dimension> elements are always shared." ) ; 
Element dimElem = new Element ( "dimension" , namespace ) ; 
dimElem . setAttribute ( "name" , dim . getShortName ( ) ) ; 
dimElem . setAttribute ( "length" , Integer . toString ( dim . getLength ( ) ) ) ; 
if ( dim . isUnlimited ( ) ) dimElem . setAttribute ( "isUnlimited" , "true" ) ; 
return dimElem ; 
} 
} 

public class McIDASAreaTransformBuilder { 
public ProjectionCT makeCoordinateTransform ( AttributeContainer ctv , String units ) { 
int [ ] area = getIntArray ( ctv , McIDASAreaProjection . ATTR_AREADIR ) ; 
int [ ] nav = getIntArray ( ctv , McIDASAreaProjection . ATTR_NAVBLOCK ) ; 
int [ ] aux = null ; 
if ( ctv . findAttributeIgnoreCase ( McIDASAreaProjection . ATTR_AUXBLOCK ) != null ) aux = getIntArray ( ctv , McIDASAreaProjection . ATTR_AUXBLOCK ) ; 
McIDASAreaProjection proj = new McIDASAreaProjection ( area , nav , aux ) ; 
return new ProjectionCT ( ctv . getName ( ) , "FGDC" , proj ) ; 
} 
} 

public class McIDASAreaTransformBuilder { 
private int [ ] getIntArray ( AttributeContainer ctv , String attName ) { 
Attribute att = ctv . findAttribute ( attName ) ; 
if ( att == null ) throw new IllegalArgumentException ( "McIDASArea coordTransformVariable " + ctv . getName ( ) + " must have " + attName + " attribute" ) ; 
Array arr = att . getValues ( ) ; 
return ( int [ ] ) arr . get1DJavaArray ( int . class ) ; 
} 
} 

public class SI { 
public static synchronized SI instance ( ) throws UnitSystemException { 
if ( si == null ) try { 
si = new SI ( ) ; 
} 
catch ( final UnitException e ) { 
throw new UnitSystemException ( "Couldn't initialize class SI" , e ) ; 
} 
return si ; 
} 
} 

public class DataFactory { 
public static void annotate ( Dataset ds , NetcdfDataset ncDataset ) { 
ncDataset . setTitle ( ds . getName ( ) ) ; 
ncDataset . setId ( ds . getId ( ) ) ; 
for ( Property p : ds . getProperties ( ) ) { 
String name = p . getName ( ) ; 
if ( null == ncDataset . findGlobalAttribute ( name ) ) ncDataset . addAttribute ( null , new Attribute ( name , p . getValue ( ) ) ) ; 
} 
ncDataset . finish ( ) ; 
} 
} 

public class DMRPrinter { 
void printXMLAttributes ( DapNode node , CEConstraint ce , int flags ) throws IOException { 
if ( ( flags & PERLINE ) != 0 ) printer . indent ( 2 ) ; 
String name = node . getShortName ( ) ; 
if ( name != null && ( flags & NONAME ) == 0 ) { 
name = node . getShortName ( ) ; 
printXMLAttribute ( "name" , name , flags ) ; 
} 
switch ( node . getSort ( ) ) { 
case DATASET : DapDataset dataset = ( DapDataset ) node ; 
printXMLAttribute ( "dapVersion" , dataset . getDapVersion ( ) , flags ) ; 
printXMLAttribute ( "dmrVersion" , dataset . getDMRVersion ( ) , flags ) ; 
printXMLAttribute ( "xmlns" , "http://xml.opendap.org/ns/DAP/4.0#" , flags ) ; 
printXMLAttribute ( "xmlns:dap" , "http://xml.opendap.org/ns/DAP/4.0#" , flags ) ; 
break ; 
case DIMENSION : DapDimension orig = ( DapDimension ) node ; 
if ( orig . isShared ( ) ) { 
DapDimension actual = this . ce . getRedefDim ( orig ) ; 
if ( actual == null ) actual = orig ; 
long size = actual . getSize ( ) ; 
printXMLAttribute ( "size" , Long . toString ( size ) , flags ) ; 
} 
break ; 
case ENUMERATION : printXMLAttribute ( "basetype" , ( ( DapEnumeration ) node ) . getBaseType ( ) . getTypeName ( ) , flags ) ; 
break ; 
case VARIABLE : DapVariable var = ( DapVariable ) node ; 
DapType basetype = var . getBaseType ( ) ; 
if ( basetype . isEnumType ( ) ) printXMLAttribute ( "enum" , basetype . getTypeName ( ) , flags ) ; 
break ; 
case ATTRIBUTE : DapAttribute attr = ( DapAttribute ) node ; 
basetype = attr . getBaseType ( ) ; 
printXMLAttribute ( "type" , basetype . getTypeName ( ) , flags ) ; 
if ( attr . getBaseType ( ) . isEnumType ( ) ) printXMLAttribute ( "enum" , basetype . getTypeName ( ) , flags ) ; 
break ; 
default : break ; 
} 
if ( ! this . testing ) printReserved ( node ) ; 
if ( ( flags & PERLINE ) != 0 ) printer . outdent ( 2 ) ; 
} 
} 

public class DMRPrinter { 
static boolean isSpecial ( DapAttribute attr ) { 
if ( attr . getParent ( ) . getSort ( ) == DapSort . DATASET ) for ( String s : GROUPSPECIAL ) { 
if ( s . equals ( attr . getShortName ( ) ) ) return true ; 
} 
else if ( attr . getParent ( ) . getSort ( ) == DapSort . VARIABLE ) for ( String s : VARSPECIAL ) { 
if ( s . equals ( attr . getShortName ( ) ) ) return true ; 
} 
return false ; 
} 
} 

public class AreaReader { 
private void setAreaDirectoryAttributes ( Variable v ) { 
if ( ( dirBlock == null ) || ( ad == null ) ) return ; 
for ( int i = 1 ; 
i < 14 ; 
i ++ ) { 
if ( i == 7 ) continue ; 
v . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; 
} 
} 
} 

public class AreaReader { 
private void setNavBlockAttributes ( Variable v ) { 
if ( ( navBlock == null ) || ( ad == null ) ) return ; 
v . addAttribute ( new Attribute ( "navigation_type" , McIDASUtil . intBitsToString ( navBlock [ 0 ] ) ) ) ; 
} 
} 

public class AreaReader { 
private int getCalType ( String calName ) { 
int calTypeOut = Calibrator . CAL_NONE ; 
if ( calName . trim ( ) . equals ( "ALB" ) ) calTypeOut = Calibrator . CAL_ALB ; 
else if ( calName . trim ( ) . equals ( "BRIT" ) ) calTypeOut = Calibrator . CAL_BRIT ; 
else if ( calName . trim ( ) . equals ( "RAD" ) ) calTypeOut = Calibrator . CAL_RAD ; 
else if ( calName . trim ( ) . equals ( "RAW" ) ) calTypeOut = Calibrator . CAL_RAW ; 
else if ( calName . trim ( ) . equals ( "TEMP" ) ) calTypeOut = Calibrator . CAL_TEMP ; 
return calTypeOut ; 
} 
} 

public class AreaReader { 
private void setCalTypeAttributes ( Variable image , int calType ) { 
String longName = "image values" ; 
switch ( calType ) { 
case Calibrator . CAL_ALB : longName = "albedo" ; 
break ; 
case Calibrator . CAL_BRIT : longName = "brightness values" ; 
break ; 
case Calibrator . CAL_TEMP : longName = "temperature" ; 
break ; 
case Calibrator . CAL_RAD : longName = "pixel radiance values" ; 
break ; 
case Calibrator . CAL_RAW : longName = "raw image values" ; 
break ; 
default : break ; 
} 
image . addAttribute ( new Attribute ( "long_name" , longName ) ) ; 
if ( calUnit != null ) image . addAttribute ( new Attribute ( CDM . UNITS , calUnit ) ) ; 
if ( calScale != 1.f ) image . addAttribute ( new Attribute ( "scale_factor" , calScale ) ) ; 
} 
} 

public class CoordsSet { 
private CoverageCoordAxis1D findDependent ( CoverageCoordAxis independentAxis , AxisType axisType ) { 
for ( CoverageCoordAxis axis : axes ) { 
if ( axis . getDependenceType ( ) == CoverageCoordAxis . DependenceType . dependent ) for ( String axisName : axis . dependsOn ) { 
if ( axisName . equalsIgnoreCase ( independentAxis . getName ( ) ) && axis . getAxisType ( ) == axisType ) return ( CoverageCoordAxis1D ) axis ; 
} 
} 
return null ; 
} 
} 

public class DSequence { 
private void oldDeserialize ( DataInputStream source , ServerVersion sv , StatusUI statusUI ) throws IOException , DataReadException { 
try { 
for ( ; 
; 
) deserializeSingle ( source , sv , statusUI ) ; 
} 
catch ( EOFException e ) { 
} 
} 
} 

public class UnitDBImpl { 
public void addUnit ( final Unit unit ) throws UnitExistsException , NameException { 
if ( unit . getName ( ) == null ) throw new NameException ( "Unit name can't be null" ) ; 
addByName ( unit . getName ( ) , unit ) ; 
addByName ( unit . getPlural ( ) , unit ) ; 
addBySymbol ( unit . getSymbol ( ) , unit ) ; 
unitSet . add ( unit ) ; 
} 
} 

public class UnitDBImpl { 
public Unit get ( final String id ) { 
Unit unit = getBySymbol ( id ) ; 
if ( unit == null ) unit = getByName ( id ) ; 
return unit ; 
} 
} 

public class UnitDBImpl { 
private final void addByName ( final String name , final Unit newUnit ) throws UnitExistsException { 
if ( name != null ) addUnique ( nameMap , canonicalize ( name ) , newUnit ) ; 
} 
} 

public class UnitDBImpl { 
private final void addBySymbol ( final String symbol , final Unit newUnit ) throws UnitExistsException { 
if ( symbol != null ) addUnique ( symbolMap , symbol , newUnit ) ; 
} 
} 

public class UnitDBImpl { 
private static final void addUnique ( final Map < String , Unit > map , final String key , final Unit newUnit ) throws UnitExistsException { 
final Unit oldUnit = map . put ( key , newUnit ) ; 
if ( oldUnit != null && ! oldUnit . equals ( newUnit ) ) throw new UnitExistsException ( oldUnit , newUnit ) ; 
} 
} 

public class DoradePARM { 
public float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { 
if ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( "parameter name mismatch" ) ; 
byte [ ] paramData = rdat . getRawData ( ) ; 
int nCells = myRADD . getNCells ( ) ; 
float [ ] values ; 
if ( workingArray != null && workingArray . length == nCells ) values = workingArray ; 
else values = new float [ nCells ] ; 
short [ ] svalues = null ; 
if ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { 
if ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) throw new DescriptorException ( "Cannot unpack " + "compressed data with binary format " + binaryFormat ) ; 
svalues = uncompressHRD ( paramData , nCells ) ; 
} 
for ( int cell = 0 ; 
cell < nCells ; 
cell ++ ) switch ( binaryFormat ) { 
case DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; 
values [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; 
values [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; 
values [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; 
values [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( "can't unpack 16-bit " + "float data yet" ) ; 
default : throw new DescriptorException ( "bad binary format (" + binaryFormat + ")" ) ; 
} 
return values ; 
} 
} 

public class ThreddsDataFactory { 
public static void annotate ( InvDataset ds , NetcdfDataset ncDataset ) { 
ncDataset . setTitle ( ds . getName ( ) ) ; 
ncDataset . setId ( ds . getID ( ) ) ; 
for ( InvProperty p : ds . getProperties ( ) ) { 
String name = p . getName ( ) ; 
if ( null == ncDataset . findGlobalAttribute ( name ) ) ncDataset . addAttribute ( null , new Attribute ( name , p . getValue ( ) ) ) ; 
} 
ncDataset . finish ( ) ; 
} 
} 

public class H4iosp { 
private ucar . ma2 . ArrayStructure readStructureData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException , InvalidRangeException { 
H4header . Vinfo vinfo = ( H4header . Vinfo ) s . getSPobject ( ) ; 
vinfo . setLayoutInfo ( ) ; 
int recsize = vinfo . elemSize ; 
StructureMembers members = s . makeStructureMembers ( ) ; 
for ( StructureMembers . Member m : members . getMembers ( ) ) { 
Variable v2 = s . findVariable ( m . getName ( ) ) ; 
H4header . Minfo minfo = ( H4header . Minfo ) v2 . getSPobject ( ) ; 
m . setDataParam ( minfo . offset ) ; 
} 
members . setStructureSize ( recsize ) ; 
ArrayStructureBB structureArray = new ArrayStructureBB ( members , section . getShape ( ) ) ; 
byte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; 
if ( ! vinfo . isLinked && ! vinfo . isCompressed ) { 
Layout layout = new LayoutRegular ( vinfo . start , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( raf , layout , DataType . STRUCTURE , result , - 1 , true ) ; 
} 
else if ( vinfo . isLinked && ! vinfo . isCompressed ) { 
InputStream is = new LinkedInputStream ( vinfo ) ; 
PositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; 
Layout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; 
} 
else if ( ! vinfo . isLinked && vinfo . isCompressed ) { 
InputStream is = getCompressedInputStream ( vinfo ) ; 
PositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; 
Layout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; 
} 
else if ( vinfo . isLinked && vinfo . isCompressed ) { 
InputStream is = getLinkedCompressedInputStream ( vinfo ) ; 
PositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; 
Layout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; 
} 
else throw new IllegalStateException ( ) ; 
return structureArray ; 
} 
} 

public class PicturePane { 
public void zoomToFit ( ) { 
sclPic . setScaleSize ( getSize ( ) ) ; 
if ( sclPic . getStatusCode ( ) == sclPic . LOADED || sclPic . getStatusCode ( ) == sclPic . READY ) sclPic . createScaledPictureInThread ( Thread . MAX_PRIORITY ) ; 
} 
} 

public class PicturePane { 
public void paintComponent ( Graphics g ) { 
int WindowWidth = getSize ( ) . width ; 
int WindowHeight = getSize ( ) . height ; 
Tools . log ( "paintComponent called" ) ; 
if ( Dragging == false ) setCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; 
if ( sclPic . getScaledPicture ( ) != null ) { 
Graphics2D g2d = ( Graphics2D ) g ; 
int X_Offset = ( int ) ( ( double ) ( WindowWidth / 2 ) - ( focusPoint . x * sclPic . getScaleFactor ( ) ) ) ; 
int Y_Offset = ( int ) ( ( double ) ( WindowHeight / 2 ) - ( focusPoint . y * sclPic . getScaleFactor ( ) ) ) ; 
Rectangle clipBounds = g2d . getClipBounds ( ) ; 
g2d . setColor ( Color . black ) ; 
g2d . fillRect ( clipBounds . x , clipBounds . y , clipBounds . width , clipBounds . height ) ; 
g2d . drawRenderedImage ( sclPic . getScaledPicture ( ) , AffineTransform . getTranslateInstance ( X_Offset , Y_Offset ) ) ; 
if ( showInfo ) { 
g2d . setColor ( Color . white ) ; 
g2d . drawString ( legend , infoPoint . x , infoPoint . y ) ; 
g2d . drawString ( "Size: " + Integer . toString ( sclPic . getOriginalWidth ( ) ) + " x " + Integer . toString ( sclPic . getOriginalHeight ( ) ) + " Offset: " + X_Offset + " x " + Y_Offset + " Mid: " + Integer . toString ( focusPoint . x ) + " x " + Integer . toString ( focusPoint . y ) + " Scale: " + twoDecimalFormatter . format ( sclPic . getScaleFactor ( ) ) , infoPoint . x , infoPoint . y + lineSpacing ) ; 
} 
} 
else { 
g . setClip ( 0 , 0 , WindowWidth , WindowHeight ) ; 
g . setColor ( Color . black ) ; 
g . fillRect ( 0 , 0 , WindowWidth , WindowHeight ) ; 
} 
if ( Dragging == false ) setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; 
} 
} 

public class GempakUtil { 
public static String TG_ITOC ( int [ ] intdtf ) { 
String gdattim = "" ; 
if ( ( intdtf [ 0 ] == 0 ) && ( intdtf [ 1 ] == 0 ) && ( intdtf [ 2 ] == 0 ) ) return gdattim ; 
gdattim = TI_CDTM ( intdtf [ 0 ] , intdtf [ 1 ] ) ; 
if ( intdtf [ 2 ] != 0 ) { 
String [ ] timeType = TG_CFTM ( intdtf [ 2 ] ) ; 
String ftype = timeType [ 0 ] ; 
String ftime = timeType [ 1 ] ; 
gdattim = gdattim . substring ( 0 , 11 ) + ftype + ftime ; 
} 
return gdattim ; 
} 
} 

public class GempakUtil { 
public static int TI_DAYM ( int iyear , int imon ) { 
int iday = 0 ; 
if ( ( imon > 0 ) && ( imon < 13 ) ) { 
iday = month [ imon - 1 ] ; 
if ( ( imon == 2 ) && LEAP ( iyear ) ) iday = iday + 1 ; 
} 
return iday ; 
} 
} 

public class GempakUtil { 
public static String LV_CCRD ( int ivcord ) { 
String vcoord = "" ; 
if ( ( ivcord >= 0 ) && ( ivcord < vertCoords . length ) ) vcoord = vertCoords [ ivcord ] ; 
else if ( ivcord > 100 ) vcoord = ST_ITOC ( ivcord ) ; 
return vcoord ; 
} 
} 

public class GempakUtil { 
public static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { 
for ( int i = startIndex ; 
i < startIndex + number ; 
i ++ ) values [ i ] = Integer . reverseBytes ( values [ i ] ) ; 
return values ; 
} 
} 

public class DataDDS { 
public final void externalize ( OutputStream os , boolean compress , boolean headers ) throws IOException { 
if ( headers ) { 
PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os , Util . UTF8 ) ) ; 
pw . println ( "HTTP/1.0 200 OK" ) ; 
pw . println ( "XDAP: " + ServerVersion . DAP2_PROTOCOL_VERSION ) ; 
pw . println ( "XDODS-Server: DODS/" + ServerVersion . DAP2_PROTOCOL_VERSION ) ; 
pw . println ( "Content-type: application/octet-stream" ) ; 
pw . println ( "Content-Description: dods-data" ) ; 
if ( compress ) pw . println ( "Content-Encoding: deflate" ) ; 
pw . println ( ) ; 
pw . flush ( ) ; 
} 
OutputStream bufferedOS ; 
if ( compress ) bufferedOS = new BufferedOutputStream ( new DeflaterOutputStream ( os ) ) ; 
else bufferedOS = new BufferedOutputStream ( os ) ; 
PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bufferedOS , Util . UTF8 ) ) ; 
print ( pw ) ; 
pw . flush ( ) ; 
bufferedOS . write ( "\nData:\n" . getBytes ( CDM . utf8Charset ) ) ; 
bufferedOS . flush ( ) ; 
DataOutputStream dataOS = new DataOutputStream ( bufferedOS ) ; 
for ( Enumeration e = getVariables ( ) ; 
e . hasMoreElements ( ) ; 
) { 
ClientIO bt = ( ClientIO ) e . nextElement ( ) ; 
bt . externalize ( dataOS ) ; 
} 
dataOS . close ( ) ; 
} 
} 

public class FixedYearVariableMonthChronology { 
private static int sumArray ( int [ ] arr ) { 
if ( arr == null ) throw new NullPointerException ( "null array" ) ; 
if ( arr . length == 0 ) throw new IllegalArgumentException ( "Zero-length array" ) ; 
int sum = 0 ; 
for ( int i = 0 ; 
i < arr . length ; 
i ++ ) { 
if ( arr [ i ] <= 0 ) throw new IllegalArgumentException ( "All array values must be > 0" ) ; 
sum += arr [ i ] ; 
} 
return sum ; 
} 
} 

public class SpatialGrid { 
public Object findIntersection ( Rectangle2D rect ) { 
double centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; 
double centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; 
int indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; 
int indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; 
if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; 
for ( int y = Math . max ( 0 , indexY - 1 ) ; 
y <= Math . min ( countY - 1 , indexY + 1 ) ; 
y ++ ) for ( int x = Math . max ( 0 , indexX - 1 ) ; 
x <= Math . min ( countX - 1 , indexX + 1 ) ; 
x ++ ) { 
GridCell gtest = gridArray [ y ] [ x ] ; 
if ( ! gtest . used ) continue ; 
if ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; 
} 
return null ; 
} 
} 

public class SpatialGrid { 
public Object findIntersection ( Point2D p ) { 
int indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; 
int indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; 
if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; 
for ( int y = Math . max ( 0 , indexY - 1 ) ; 
y <= Math . min ( countY - 1 , indexY + 1 ) ; 
y ++ ) for ( int x = Math . max ( 0 , indexX - 1 ) ; 
x <= Math . min ( countX - 1 , indexX + 1 ) ; 
x ++ ) { 
GridCell gtest = gridArray [ y ] [ x ] ; 
if ( ! gtest . used ) continue ; 
if ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; 
} 
return null ; 
} 
} 

public class BaseUnit { 
public static synchronized BaseUnit getOrCreate ( final UnitName id , final BaseQuantity baseQuantity ) throws NameException , UnitExistsException { 
BaseUnit baseUnit ; 
final BaseUnit nameUnit = nameMap . get ( id ) ; 
final BaseUnit quantityUnit = quantityMap . get ( baseQuantity ) ; 
if ( nameUnit != null || quantityUnit != null ) { 
baseUnit = nameUnit != null ? nameUnit : quantityUnit ; 
if ( ( nameUnit != null && ! baseQuantity . equals ( nameUnit . getBaseQuantity ( ) ) ) || ( quantityUnit != null && ! id . equals ( quantityUnit . getUnitName ( ) ) ) ) throw new UnitExistsException ( "Attempt to incompatibly redefine base unit \"" + baseUnit + '"' ) ; 
} 
else { 
baseUnit = new BaseUnit ( id , baseQuantity ) ; 
quantityMap . put ( baseQuantity , baseUnit ) ; 
nameMap . put ( id , baseUnit ) ; 
} 
return baseUnit ; 
} 
} 

public class DatasetUrl { 
static private ServiceType searchFragment ( String fragment ) { 
if ( fragment . length ( ) == 0 ) return null ; 
Map < String , String > map = parseFragment ( fragment ) ; 
if ( map == null ) return null ; 
String protocol = map . get ( "protocol" ) ; 
if ( protocol == null ) for ( String p : FRAGPROTOCOLS ) { 
if ( map . get ( p ) != null ) { 
protocol = p ; 
break ; 
} 
} 
if ( protocol != null ) { 
if ( protocol . equalsIgnoreCase ( "dap" ) || protocol . equalsIgnoreCase ( "dods" ) ) return ServiceType . OPENDAP ; 
if ( protocol . equalsIgnoreCase ( "dap4" ) ) return ServiceType . DAP4 ; 
if ( protocol . equalsIgnoreCase ( "cdmremote" ) ) return ServiceType . CdmRemote ; 
if ( protocol . equalsIgnoreCase ( "thredds" ) ) return ServiceType . THREDDS ; 
if ( protocol . equalsIgnoreCase ( "ncml" ) ) return ServiceType . NCML ; 
} 
return null ; 
} 
} 

public class DatasetUrl { 
static private ServiceType searchPath ( String url ) { 
if ( false ) { 
if ( url == null || url . length ( ) == 0 ) return null ; 
url = url . toLowerCase ( ) ; 
for ( int i = 0 ; 
i < FRAGPROTOCOLS . length ; 
i ++ ) { 
String p = FRAGPROTOCOLS [ i ] ; 
if ( url . indexOf ( "/thredds/" + p . toLowerCase ( ) + "/" ) >= 0 ) return FRAGPROTOSVCTYPE [ i ] ; 
} 
} 
return null ; 
} 
} 

public class DapUtil { 
static public String locateFile ( String filename , String abspath , boolean wantdir ) { 
Deque < String > q = new ArrayDeque < String > ( ) ; 
filename = filename . trim ( ) . replace ( '\\' , '/' ) ; 
abspath = abspath . trim ( ) . replace ( '\\' , '/' ) ; 
if ( filename . charAt ( 0 ) == '/' ) filename = filename . substring ( 1 ) ; 
if ( filename . endsWith ( "/" ) ) filename = filename . substring ( 0 , filename . length ( ) - 1 ) ; 
if ( abspath . endsWith ( "/" ) ) abspath = abspath . substring ( 0 , abspath . length ( ) - 1 ) ; 
q . addFirst ( abspath ) ; 
for ( ; 
; 
) { 
String currentpath = q . poll ( ) ; 
if ( currentpath == null ) break ; 
File current = new File ( currentpath ) ; 
File [ ] contents = current . listFiles ( ) ; 
if ( contents != null ) { 
for ( File subfile : contents ) { 
if ( ! subfile . getName ( ) . equals ( filename ) ) continue ; 
if ( ( wantdir && subfile . isDirectory ( ) ) || ( ! wantdir && subfile . isFile ( ) ) ) return DapUtil . canonicalpath ( subfile . getAbsolutePath ( ) ) ; 
} 
for ( File subfile : contents ) { 
if ( subfile . isDirectory ( ) ) q . addFirst ( currentpath + "/" + subfile . getName ( ) ) ; 
} 
} 
} 
return null ; 
} 
} 

public class DapUtil { 
static public boolean hasDriveLetter ( String path ) { 
boolean hasdr = false ; 
if ( path != null && path . length ( ) >= 2 ) hasdr = ( DRIVELETTERS . indexOf ( path . charAt ( 0 ) ) >= 0 && path . charAt ( 1 ) == ':' ) ; 
return hasdr ; 
} 
} 

public class FeatureCollectionConfigBuilder { 
public FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { 
String catFilename ; 
String fcName = null ; 
int pos = catalogAndPath . indexOf ( "#" ) ; 
if ( pos > 0 ) { 
catFilename = catalogAndPath . substring ( 0 , pos ) ; 
fcName = catalogAndPath . substring ( pos + 1 ) ; 
} 
else catFilename = catalogAndPath ; 
File cat = new File ( catFilename ) ; 
org . jdom2 . Document doc ; 
try { 
SAXBuilder builder = new SAXBuilder ( ) ; 
doc = builder . build ( cat ) ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
return null ; 
} 
try { 
List < Element > fcElems = new ArrayList < > ( ) ; 
findFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; 
if ( fcElems . size ( ) > 0 ) return readConfig ( fcElems . get ( 0 ) ) ; 
} 
catch ( IllegalStateException e ) { 
e . printStackTrace ( ) ; 
} 
return null ; 
} 
} 

public class DapGroup { 
public void addDecl ( DapNode newdecl ) throws DapException { 
DapSort newsort = newdecl . getSort ( ) ; 
String newname = newdecl . getShortName ( ) ; 
boolean suppress = false ; 
if ( newsort != DapSort . DIMENSION || newname != null ) for ( DapNode decl : decls ) { 
if ( newsort == decl . getSort ( ) && newname . equals ( decl . getShortName ( ) ) ) throw new DapException ( "DapGroup: attempt to add duplicate decl: " + newname ) ; 
} 
else { 
DapDimension anon = ( DapDimension ) newdecl ; 
assert ( newsort == DapSort . DIMENSION && newname == null ) ; 
boolean found = false ; 
for ( DapDimension dim : dimensions ) { 
if ( ! dim . isShared ( ) && dim . getSize ( ) == anon . getSize ( ) ) { 
found = true ; 
break ; 
} 
} 
if ( ! found && ! isTopLevel ( ) ) getDataset ( ) . addDecl ( anon ) ; 
suppress = found || ! isTopLevel ( ) ; 
} 
if ( ! suppress ) { 
decls . add ( newdecl ) ; 
newdecl . setParent ( this ) ; 
} 
switch ( newdecl . getSort ( ) ) { 
case ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : super . addAttribute ( ( DapAttribute ) newdecl ) ; 
break ; 
case DIMENSION : if ( ! suppress ) dimensions . add ( ( DapDimension ) newdecl ) ; 
break ; 
case ENUMERATION : enums . add ( ( DapEnumeration ) newdecl ) ; 
break ; 
case ATOMICTYPE : break ; 
case STRUCTURE : case SEQUENCE : compounds . add ( ( DapStructure ) newdecl ) ; 
break ; 
case VARIABLE : variables . add ( ( DapVariable ) newdecl ) ; 
break ; 
case GROUP : case DATASET : if ( this != ( DapGroup ) newdecl ) groups . add ( ( DapGroup ) newdecl ) ; 
break ; 
default : throw new ClassCastException ( newdecl . getShortName ( ) ) ; 
} 
} 
} 

public class COARDSConvention { 
protected AxisType getAxisType ( NetcdfDataset ncDataset , VariableEnhanced v ) { 
String unit = v . getUnitsString ( ) ; 
if ( unit == null ) return null ; 
unit = unit . trim ( ) ; 
if ( unit . equalsIgnoreCase ( "degrees_east" ) || unit . equalsIgnoreCase ( "degrees_E" ) || unit . equalsIgnoreCase ( "degreesE" ) || unit . equalsIgnoreCase ( "degree_east" ) || unit . equalsIgnoreCase ( "degree_E" ) || unit . equalsIgnoreCase ( "degreeE" ) ) return AxisType . Lon ; 
if ( unit . equalsIgnoreCase ( "degrees_north" ) || unit . equalsIgnoreCase ( "degrees_N" ) || unit . equalsIgnoreCase ( "degreesN" ) || unit . equalsIgnoreCase ( "degree_north" ) || unit . equalsIgnoreCase ( "degree_N" ) || unit . equalsIgnoreCase ( "degreeN" ) ) return AxisType . Lat ; 
if ( SimpleUnit . isDateUnit ( unit ) ) return AxisType . Time ; 
if ( SimpleUnit . isCompatible ( "mbar" , unit ) ) return AxisType . Pressure ; 
if ( unit . equalsIgnoreCase ( "level" ) || unit . equalsIgnoreCase ( "layer" ) || unit . equalsIgnoreCase ( "sigma_level" ) ) return AxisType . GeoZ ; 
String positive = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . POSITIVE , null ) ; 
if ( positive != null ) if ( SimpleUnit . isCompatible ( "m" , unit ) ) return AxisType . Height ; 
else return AxisType . GeoZ ; 
return null ; 
} 
} 

public class HTTPSession { 
static synchronized protected void setDefaults ( Map < Prop , Object > props ) { 
if ( false ) props . put ( Prop . HANDLE_AUTHENTICATION , Boolean . TRUE ) ; 
props . put ( Prop . HANDLE_REDIRECTS , Boolean . TRUE ) ; 
props . put ( Prop . ALLOW_CIRCULAR_REDIRECTS , Boolean . TRUE ) ; 
props . put ( Prop . MAX_REDIRECTS , ( Integer ) DFALTREDIRECTS ) ; 
props . put ( Prop . SO_TIMEOUT , ( Integer ) DFALTSOTIMEOUT ) ; 
props . put ( Prop . CONN_TIMEOUT , ( Integer ) DFALTCONNTIMEOUT ) ; 
props . put ( Prop . CONN_REQ_TIMEOUT , ( Integer ) DFALTCONNREQTIMEOUT ) ; 
props . put ( Prop . USER_AGENT , DFALTUSERAGENT ) ; 
} 
} 

public class HTTPSession { 
synchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { 
cb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; 
AuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; 
CredentialsProvider cp = null ; 
if ( bestMatch != null ) cp = localcreds . get ( bestMatch ) ; 
else { 
bestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; 
if ( bestMatch != null ) { 
HTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; 
cp = factory . getProvider ( bestMatch ) ; 
} 
} 
Credentials proxycreds = null ; 
AuthScope proxyscope = null ; 
String user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; 
String pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; 
HttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; 
HttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; 
if ( user != null && ( httpproxy != null || httpsproxy != null ) ) { 
if ( httpproxy != null ) proxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; 
else proxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; 
proxycreds = new UsernamePasswordCredentials ( user , pwd ) ; 
} 
if ( cp == null && proxycreds != null && proxyscope != null ) { 
cp = new BasicCredentialsProvider ( ) ; 
cp . setCredentials ( proxyscope , proxycreds ) ; 
} 
else if ( cp != null && proxycreds != null && proxyscope != null ) cp . setCredentials ( proxyscope , proxycreds ) ; 
if ( cp != null ) this . sessioncontext . setCredentialsProvider ( cp ) ; 
} 
} 

public class Index { 
Index section ( List < Range > ranges ) throws InvalidRangeException { 
if ( ranges . size ( ) != rank ) throw new InvalidRangeException ( "Bad ranges [] length" ) ; 
for ( int ii = 0 ; 
ii < rank ; 
ii ++ ) { 
Range r = ranges . get ( ii ) ; 
if ( r == null ) continue ; 
if ( r == Range . VLEN ) continue ; 
if ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( "Bad range starting value at index " + ii + " == " + r . first ( ) ) ; 
if ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( "Bad range ending value at index " + ii + " == " + r . last ( ) ) ; 
} 
int reducedRank = rank ; 
for ( Range r : ranges ) { 
if ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; 
} 
Index newindex = Index . factory ( reducedRank ) ; 
newindex . offset = offset ; 
int newDim = 0 ; 
for ( int ii = 0 ; 
ii < rank ; 
ii ++ ) { 
Range r = ranges . get ( ii ) ; 
if ( r == null ) { 
newindex . shape [ newDim ] = shape [ ii ] ; 
newindex . stride [ newDim ] = stride [ ii ] ; 
newDim ++ ; 
} 
else if ( r . length ( ) != 1 ) { 
newindex . shape [ newDim ] = r . length ( ) ; 
newindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; 
newindex . offset += stride [ ii ] * r . first ( ) ; 
newDim ++ ; 
} 
else newindex . offset += stride [ ii ] * r . first ( ) ; 
} 
newindex . size = computeSize ( newindex . shape ) ; 
newindex . fastIterator = fastIterator && ( newindex . size == size ) ; 
newindex . precalc ( ) ; 
return newindex ; 
} 
} 

public class Index { 
Index reduce ( int dim ) { 
if ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( "illegal reduce dim " + dim ) ; 
if ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( "illegal reduce dim " + dim + " : length != 1" ) ; 
Index newindex = Index . factory ( rank - 1 ) ; 
newindex . offset = offset ; 
int count = 0 ; 
for ( int ii = 0 ; 
ii < rank ; 
ii ++ ) if ( ii != dim ) { 
newindex . shape [ count ] = shape [ ii ] ; 
newindex . stride [ count ] = stride [ ii ] ; 
count ++ ; 
} 
newindex . size = computeSize ( newindex . shape ) ; 
newindex . fastIterator = fastIterator ; 
newindex . precalc ( ) ; 
return newindex ; 
} 
} 

public class AbstractGempakStationFileReader { 
protected List < String > makeDateList ( boolean unique ) { 
Key date = dateTimeKeys . get ( 0 ) ; 
Key time = dateTimeKeys . get ( 1 ) ; 
List < int [ ] > toCheck ; 
if ( date . type . equals ( ROW ) ) toCheck = headers . rowHeaders ; 
else toCheck = headers . colHeaders ; 
List < String > fileDates = new ArrayList < > ( ) ; 
for ( int [ ] header : toCheck ) { 
if ( header [ 0 ] != IMISSD ) { 
int idate = header [ date . loc + 1 ] ; 
int itime = header [ time . loc + 1 ] ; 
String dateTime = GempakUtil . TI_CDTM ( idate , itime ) ; 
fileDates . add ( dateTime ) ; 
} 
} 
if ( unique && ! fileDates . isEmpty ( ) ) { 
SortedSet < String > uniqueTimes = Collections . synchronizedSortedSet ( new TreeSet < String > ( ) ) ; 
uniqueTimes . addAll ( fileDates ) ; 
fileDates . clear ( ) ; 
fileDates . addAll ( uniqueTimes ) ; 
} 
return fileDates ; 
} 
} 

public class AbstractGempakStationFileReader { 
private List < GempakParameter > makeParams ( DMPart part ) { 
List < GempakParameter > gemparms = new ArrayList < > ( part . kparms ) ; 
for ( DMParam param : part . params ) { 
String name = param . kprmnm ; 
GempakParameter parm = GempakParameters . getParameter ( name ) ; 
if ( parm == null ) parm = new GempakParameter ( 1 , name , name , "" , 0 ) ; 
gemparms . add ( parm ) ; 
} 
return gemparms ; 
} 
} 

public class AbstractGempakStationFileReader { 
private List < GempakStation > getStationList ( ) { 
Key slat = findKey ( GempakStation . SLAT ) ; 
if ( slat == null ) return null ; 
List < int [ ] > toCheck ; 
if ( slat . type . equals ( ROW ) ) toCheck = headers . rowHeaders ; 
else toCheck = headers . colHeaders ; 
List < GempakStation > fileStations = new ArrayList < > ( ) ; 
int i = 0 ; 
for ( int [ ] header : toCheck ) { 
if ( header [ 0 ] != IMISSD ) { 
GempakStation station = makeStation ( header ) ; 
if ( station != null ) { 
station . setIndex ( i + 1 ) ; 
fileStations . add ( station ) ; 
} 
} 
i ++ ; 
} 
return fileStations ; 
} 
} 

public class AbstractGempakStationFileReader { 
private GempakStation makeStation ( int [ ] header ) { 
if ( ( stationKeys == null ) || stationKeys . isEmpty ( ) ) return null ; 
GempakStation newStation = new GempakStation ( ) ; 
for ( Key key : stationKeys ) { 
int loc = key . loc + 1 ; 
switch ( key . name ) { 
case GempakStation . STID : newStation . setSTID ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . STNM : newStation . setSTNM ( header [ loc ] ) ; 
break ; 
case GempakStation . SLAT : newStation . setSLAT ( header [ loc ] ) ; 
break ; 
case GempakStation . SLON : newStation . setSLON ( header [ loc ] ) ; 
break ; 
case GempakStation . SELV : newStation . setSELV ( header [ loc ] ) ; 
break ; 
case GempakStation . SPRI : newStation . setSPRI ( header [ loc ] ) ; 
break ; 
case GempakStation . STAT : newStation . setSTAT ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . COUN : newStation . setCOUN ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . SWFO : newStation . setSWFO ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . WFO2 : newStation . setWFO2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . STD2 : newStation . setSTD2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
} 
} 
return newStation ; 
} 
} 

public class AbstractGempakStationFileReader { 
public List < String > getStationKeyNames ( ) { 
List < String > keys = new ArrayList < > ( ) ; 
if ( ( stationKeys != null ) && ! stationKeys . isEmpty ( ) ) for ( Key key : stationKeys ) { 
keys . add ( key . name ) ; 
} 
return keys ; 
} 
} 

public class AbstractGempakStationFileReader { 
public int findStationIndex ( String id ) { 
for ( GempakStation station : getStations ( ) ) { 
if ( station . getSTID ( ) . equals ( id ) ) return station . getIndex ( ) ; 
} 
return - 1 ; 
} 
} 

public class AbstractGempakStationFileReader { 
public String getFileType ( ) { 
String type = "Unknown" ; 
switch ( dmLabel . kftype ) { 
case MFSN : type = "Sounding" ; 
break ; 
case MFSF : type = "Surface" ; 
break ; 
default : } 
if ( ! subType . equals ( "" ) ) type = type + " (" + subType + ")" ; 
return type ; 
} 
} 

public class GribIndex { 
public static GribIndex readOrCreateIndexFromSingleFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType force , org . slf4j . Logger logger ) throws IOException { 
GribIndex index = isGrib1 ? new Grib1Index ( ) : new Grib2Index ( ) ; 
if ( ! index . readIndex ( mfile . getPath ( ) , mfile . getLastModified ( ) , force ) ) { 
index . makeIndex ( mfile . getPath ( ) , null ) ; 
logger . debug ( "  Index written: {} == {} records" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; 
} 
else if ( debug ) logger . debug ( "  Index read: {} == {} records" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; 
return index ; 
} 
} 

public class MFileCollectionManager { 
public void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { 
CompositeMFileFilter filters = new CompositeMFileFilter ( ) ; 
if ( null != regexpPatternString ) filters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; 
else if ( suffix != null ) filters . addIncludeFilter ( new WildcardMatchOnPath ( "*" + suffix + "$" ) ) ; 
if ( olderS != null ) try { 
TimeDuration tu = new TimeDuration ( olderS ) ; 
filters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; 
} 
catch ( Exception e ) { 
logger . error ( collectionName + ": Invalid time unit for olderThan = {}" , olderS ) ; 
} 
boolean wantSubdirs = true ; 
if ( ( subdirsS != null ) && subdirsS . equalsIgnoreCase ( "false" ) ) wantSubdirs = false ; 
CollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; 
StringBuilder sb = new StringBuilder ( dirName ) ; 
if ( wantSubdirs ) sb . append ( "**/" ) ; 
if ( null != regexpPatternString ) sb . append ( regexpPatternString ) ; 
else if ( suffix != null ) sb . append ( suffix ) ; 
else sb . append ( "noFilter" ) ; 
collectionName = sb . toString ( ) ; 
scanList . add ( mc ) ; 
} 
} 

public class FileWriter2 { 
public Variable addVariable ( Variable oldVar ) { 
List < Dimension > newDims = getNewDimensions ( oldVar ) ; 
Variable newVar ; 
if ( ( oldVar . getDataType ( ) . equals ( DataType . STRING ) ) && ( ! version . isExtendedModel ( ) ) ) newVar = writer . addStringVariable ( null , oldVar , newDims ) ; 
else newVar = writer . addVariable ( null , oldVar . getShortName ( ) , oldVar . getDataType ( ) , newDims ) ; 
varMap . put ( oldVar , newVar ) ; 
varList . add ( oldVar ) ; 
for ( Attribute orgAtt : oldVar . getAttributes ( ) ) writer . addVariableAttribute ( newVar , convertAttribute ( orgAtt ) ) ; 
return newVar ; 
} 
} 

public class MarshallingUtil { 
public static void validate ( XmlObject doc , boolean strict ) throws XmlException { 
Set < XmlError > validationErrors = new HashSet < > ( ) ; 
XmlOptions validationOptions = new XmlOptions ( ) ; 
validationOptions . setErrorListener ( validationErrors ) ; 
final boolean isValid = doc . validate ( validationOptions ) ; 
if ( ! isValid && ! strict ) validationErrors = filterToOnlySerious ( validationErrors ) ; 
if ( ! validationErrors . isEmpty ( ) ) throw new XmlException ( createErrorMessage ( validationErrors ) ) ; 
} 
} 

public class MultiSlice { 
@ Override public String toConstraintString ( ) throws DapException { 
assert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; 
StringBuilder buf = new StringBuilder ( ) ; 
buf . append ( "[" ) ; 
boolean first = true ; 
for ( Slice sub : this . subslices ) { 
if ( ! first ) buf . append ( "," ) ; 
first = false ; 
if ( ( sub . stop - sub . first ) == 0 ) buf . append ( "0" ) ; 
else if ( sub . stride == 1 ) if ( ( sub . stop - sub . first ) == 1 ) buf . append ( sub . first ) ; 
else buf . append ( String . format ( "%d:%d" , sub . first , sub . stop - 1 ) ) ; 
else buf . append ( String . format ( "%d:%d:%d" , sub . first , sub . stride , sub . stop - 1 ) ) ; 
} 
buf . append ( "]" ) ; 
return buf . toString ( ) ; 
} 
} 

public class StructureDS { 
@ Override public Array reallyRead ( Variable client , CancelTask cancelTask ) throws IOException { 
Array result ; 
if ( hasCachedData ( ) ) result = super . reallyRead ( client , cancelTask ) ; 
else if ( orgVar != null ) result = orgVar . read ( ) ; 
else throw new IllegalStateException ( "StructureDS has no way to get data" ) ; 
return convert ( result , null ) ; 
} 
} 

public class StructureDS { 
@ Override public Array reallyRead ( Variable client , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { 
if ( section . computeSize ( ) == getSize ( ) ) return _read ( ) ; 
Array result ; 
if ( hasCachedData ( ) ) result = super . reallyRead ( client , section , cancelTask ) ; 
else if ( orgVar != null ) result = orgVar . read ( section ) ; 
else throw new IllegalStateException ( "StructureDS has no way to get data" ) ; 
return convert ( result , section ) ; 
} 
} 

public class StructureDS { 
protected ArrayStructure convert ( Array data , Section section ) throws IOException { 
ArrayStructure orgAS = ( ArrayStructure ) data ; 
if ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { 
convertMemberInfo ( orgAS . getStructureMembers ( ) ) ; 
return orgAS ; 
} 
ArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; 
for ( StructureMembers . Member m : newAS . getMembers ( ) ) { 
VariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; 
if ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; 
if ( v2 == null ) continue ; 
if ( v2 instanceof VariableDS ) { 
VariableDS vds = ( VariableDS ) v2 ; 
if ( vds . needConvert ( ) ) { 
Array mdata = newAS . extractMemberArray ( m ) ; 
mdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; 
newAS . setMemberArray ( m , mdata ) ; 
} 
} 
else if ( v2 instanceof StructureDS ) { 
StructureDS innerStruct = ( StructureDS ) v2 ; 
if ( innerStruct . convertNeeded ( null ) ) if ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { 
ArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; 
ArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { 
( int ) seqArray . getSize ( ) } 
) ; 
m . setDataArray ( newSeq ) ; 
for ( int i = 0 ; 
i < seqArray . getSize ( ) ; 
i ++ ) { 
ArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; 
newSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; 
} 
} 
else { 
Array mdata = newAS . extractMemberArray ( m ) ; 
mdata = innerStruct . convert ( mdata , null ) ; 
newAS . setMemberArray ( m , mdata ) ; 
} 
innerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; 
} 
} 
StructureMembers sm = newAS . getStructureMembers ( ) ; 
convertMemberInfo ( sm ) ; 
for ( Variable v : getVariables ( ) ) { 
if ( ! varHasData ( v , sm ) ) try { 
Variable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; 
Array mdata = completeVar . read ( section ) ; 
StructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; 
newAS . setMemberArray ( m , mdata ) ; 
} 
catch ( InvalidRangeException e ) { 
throw new IOException ( e . getMessage ( ) ) ; 
} 
} 
return newAS ; 
} 
} 

public class StructureDS { 
private void convertMemberInfo ( StructureMembers wrapperSm ) { 
for ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { 
Variable v = findVariable ( m . getName ( ) ) ; 
if ( ( v == null ) && ( orgVar != null ) ) v = ( Variable ) findVariableFromOrgName ( m . getName ( ) ) ; 
if ( v != null ) m . setVariableInfo ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) ) ; 
if ( v instanceof StructureDS ) { 
StructureDS innerStruct = ( StructureDS ) v ; 
innerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; 
} 
} 
} 
} 

public class DatasetManager { 
public boolean resourceControlOk ( HttpServletRequest req , HttpServletResponse res , String reqPath ) { 
if ( null == reqPath ) reqPath = TdsPathUtils . extractPath ( req , null ) ; 
String rc = null ; 
DataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( reqPath ) ; 
if ( match != null ) rc = match . dataRoot . getRestrict ( ) ; 
if ( rc == null ) rc = datasetTracker . findResourceControl ( reqPath ) ; 
return resourceAuthorized ( req , res , rc ) ; 
} 
} 

public class GempakSoundingIOSP { 
private ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { 
if ( values == null ) return makeEmptySequence ( seq ) ; 
int numLevels = values . length / params . size ( ) ; 
StructureMembers members = seq . makeStructureMembers ( ) ; 
int offset = ArrayStructureBB . setOffsets ( members ) ; 
int size = offset * numLevels ; 
byte [ ] bytes = new byte [ size ] ; 
ByteBuffer buf = ByteBuffer . wrap ( bytes ) ; 
ArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { 
numLevels } 
, buf , 0 ) ; 
int var = 0 ; 
for ( int i = 0 ; 
i < numLevels ; 
i ++ ) for ( GempakParameter param : params ) { 
if ( members . findMember ( param . getName ( ) ) != null ) buf . putFloat ( values [ var ] ) ; 
var ++ ; 
} 
return new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; 
} 
} 

public class GempakSoundingIOSP { 
protected Sequence makeSequence ( Structure parent , String partName , boolean includeMissing ) { 
List < GempakParameter > params = gemreader . getParameters ( partName ) ; 
if ( params == null ) return null ; 
Sequence sVar = new Sequence ( ncfile , null , parent , partName ) ; 
sVar . setDimensions ( "" ) ; 
for ( GempakParameter param : params ) { 
Variable v = makeParamVariable ( param , null ) ; 
addVerticalCoordAttribute ( v ) ; 
sVar . addMemberVariable ( v ) ; 
} 
if ( includeMissing ) sVar . addMemberVariable ( makeMissingVariable ( ) ) ; 
return sVar ; 
} 
} 

public class GempakSoundingIOSP { 
private void addVerticalCoordAttribute ( Variable v ) { 
GempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; 
int vertType = gsfr . getVerticalCoordinate ( ) ; 
String pName = v . getFullName ( ) ; 
if ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) if ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( "PRES" ) ) v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; 
else if ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( "HGHT" ) || pName . equals ( "MHGT" ) || pName . equals ( "DHGT" ) ) ) v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; 
else if ( pName . equals ( "PRES" ) ) v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; 
} 
} 

public class DerivedUnitImpl { 
@ Override protected Unit myMultiplyBy ( final Unit that ) throws MultiplyException { 
Unit result ; 
if ( dimension . getRank ( ) == 0 ) result = that ; 
else if ( ! ( that instanceof DerivedUnit ) ) result = that . multiplyBy ( this ) ; 
else { 
final UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; 
result = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . multiplyBy ( thatDimension ) ) ; 
} 
return result ; 
} 
} 

public class DerivedUnitImpl { 
@ Override protected Unit myDivideBy ( final Unit that ) throws OperationException { 
Unit result ; 
if ( dimension . getRank ( ) == 0 ) result = that . raiseTo ( - 1 ) ; 
else if ( ! ( that instanceof DerivedUnit ) ) result = that . divideInto ( this ) ; 
else { 
final UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; 
result = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . divideBy ( thatDimension ) ) ; 
} 
return result ; 
} 
} 

public class DerivedUnitImpl { 
public final float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) { 
if ( input != output ) System . arraycopy ( input , 0 , output , 0 , input . length ) ; 
return output ; 
} 
} 

public class DOM4Parser { 
protected void parseresponse ( Node root ) throws ParseException { 
String elemname = root . getNodeName ( ) ; 
if ( elemname . equalsIgnoreCase ( "Error" ) ) parseerror ( root ) ; 
else if ( elemname . equalsIgnoreCase ( "Dataset" ) ) parsedataset ( root ) ; 
else throw new ParseException ( "Unexpected response root: " + elemname ) ; 
} 
} 

public class CFSimpleGeometryHelper { 
public static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { 
if ( var == null ) return null ; 
String subStr = "" ; 
List < Dimension > dimList = var . getDimensions ( ) ; 
if ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) return null ; 
for ( int i = 0 ; 
i < dimList . size ( ) ; 
i ++ ) { 
Dimension dim = dimList . get ( i ) ; 
if ( dim == null ) continue ; 
if ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) subStr += id ; 
else if ( beginInd < 0 || endInd < 0 ) subStr += ":" ; 
else subStr += ( beginInd + ":" + endInd ) ; 
if ( i < dimList . size ( ) - 1 ) subStr += "," ; 
} 
return subStr ; 
} 
} 

public class ArrayStructureMA { 
static public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { 
if ( from instanceof ArrayStructureMA ) return ( ArrayStructureMA ) from ; 
if ( from . getSize ( ) > 0 ) { 
ArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; 
for ( StructureMembers . Member m : from . getMembers ( ) ) { 
to . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; 
} 
return to ; 
} 
int numRecords = - 1 ; 
Map < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; 
for ( StructureMembers . Member m : from . getMembers ( ) ) { 
Array array = from . extractMemberArray ( m ) ; 
assert array . getSize ( ) > 0 : "array's size should have been computed in extractMemberArray()." ; 
int firstDimLen = array . getShape ( ) [ 0 ] ; 
if ( numRecords == - 1 ) numRecords = firstDimLen ; 
else assert numRecords == firstDimLen : String . format ( "Expected all structure members to have the same first" + "dimension length, but %d != %d." , numRecords , firstDimLen ) ; 
memberArrayMap . put ( m . getName ( ) , array ) ; 
} 
int [ ] shape ; 
if ( numRecords == - 1 ) shape = new int [ ] { 
0 } 
; 
else shape = new int [ ] { 
numRecords } 
; 
ArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; 
for ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { 
to . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
return to ; 
} 
} 

public class ArrayStructureMA { 
static public ArrayStructureMA factoryMA ( Structure from , int [ ] shape ) throws IOException { 
StructureMembers sm = from . makeStructureMembers ( ) ; 
for ( Variable v : from . getVariables ( ) ) { 
Array data ; 
if ( v instanceof Sequence ) data = Array . factory ( DataType . SEQUENCE , shape ) ; 
else if ( v instanceof Structure ) data = ArrayStructureMA . factoryMA ( ( Structure ) v , combine ( shape , v . getShape ( ) ) ) ; 
else data = Array . factory ( v . getDataType ( ) , combine ( shape , v . getShape ( ) ) ) ; 
StructureMembers . Member m = sm . findMember ( v . getShortName ( ) ) ; 
m . setDataArray ( data ) ; 
} 
return new ArrayStructureMA ( sm , shape ) ; 
} 
} 

public class CECompiler { 
public void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { 
if ( expr == null ) return ; 
if ( expr . sort == CEAST . Sort . SEGMENT ) { 
if ( expr . subnodes != null ) throw new DapException ( "compilefilter: Non-simple segment:" + expr . name ) ; 
DapVariable field = seq . findByName ( expr . name ) ; 
if ( field == null ) throw new DapException ( "compilefilter: Unknown filter variable:" + expr . name ) ; 
expr . field = field ; 
} 
else if ( expr . sort == CEAST . Sort . EXPR ) { 
if ( expr . lhs != null ) compilefilter ( var , seq , expr . lhs ) ; 
if ( expr . rhs != null ) compilefilter ( var , seq , expr . rhs ) ; 
if ( expr . lhs != null && expr . rhs != null ) { 
boolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; 
boolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; 
if ( rightvar && ! leftvar ) { 
CEAST tmp = expr . lhs ; 
expr . lhs = expr . rhs ; 
expr . rhs = tmp ; 
switch ( expr . op ) { 
case LT : expr . op = CEAST . Operator . GT ; 
break ; 
case LE : expr . op = CEAST . Operator . GE ; 
break ; 
case GT : expr . op = CEAST . Operator . LT ; 
break ; 
case GE : expr . op = CEAST . Operator . LE ; 
break ; 
default : break ; 
} 
} 
} 
} 
else if ( expr . sort == CEAST . Sort . CONSTANT ) return ; 
else throw new DapException ( "compilefilter: Unexpected node type:" + expr . sort ) ; 
} 
} 

public class LatLonRect { 
public void extend ( LatLonPoint p ) { 
if ( contains ( p ) ) return ; 
double lat = p . getLatitude ( ) ; 
double lon = p . getLongitude ( ) ; 
if ( lat > upperRight . getLatitude ( ) ) upperRight . setLatitude ( lat ) ; 
if ( lat < lowerLeft . getLatitude ( ) ) lowerLeft . setLatitude ( lat ) ; 
if ( allLongitude ) { 
} 
else if ( crossDateline ) { 
double d1 = lon - upperRight . getLongitude ( ) ; 
double d2 = lowerLeft . getLongitude ( ) - lon ; 
if ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) if ( d1 > d2 ) lowerLeft . setLongitude ( lon ) ; 
else upperRight . setLongitude ( lon ) ; 
} 
else if ( lon > upperRight . getLongitude ( ) ) if ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { 
crossDateline = true ; 
lowerLeft . setLongitude ( lon ) ; 
} 
else upperRight . setLongitude ( lon ) ; 
else if ( lon < lowerLeft . getLongitude ( ) ) if ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { 
crossDateline = true ; 
upperRight . setLongitude ( lon ) ; 
} 
else lowerLeft . setLongitude ( lon ) ; 
width = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; 
lon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; 
if ( crossDateline ) { 
width += 360 ; 
lon0 -= 180 ; 
} 
this . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; 
} 
} 

public class LatLonRect { 
public void extend ( LatLonRect r ) { 
Preconditions . checkNotNull ( r ) ; 
double latMin = r . getLatMin ( ) ; 
double latMax = r . getLatMax ( ) ; 
if ( latMax > upperRight . getLatitude ( ) ) upperRight . setLatitude ( latMax ) ; 
if ( latMin < lowerLeft . getLatitude ( ) ) lowerLeft . setLatitude ( latMin ) ; 
if ( allLongitude ) return ; 
double lonMin = getLonMin ( ) ; 
double lonMax = getLonMax ( ) ; 
double nlonMin = LatLonPointImpl . lonNormal ( r . getLonMin ( ) , lonMin ) ; 
double nlonMax = nlonMin + r . getWidth ( ) ; 
lonMin = Math . min ( lonMin , nlonMin ) ; 
lonMax = Math . max ( lonMax , nlonMax ) ; 
width = lonMax - lonMin ; 
allLongitude = width >= 360.0 ; 
if ( allLongitude ) { 
width = 360.0 ; 
lonMin = - 180.0 ; 
} 
else lonMin = LatLonPointImpl . lonNormal ( lonMin ) ; 
lowerLeft . setLongitude ( lonMin ) ; 
upperRight . setLongitude ( lonMin + width ) ; 
lon0 = lonMin + width / 2 ; 
crossDateline = lowerLeft . getLongitude ( ) > upperRight . getLongitude ( ) ; 
} 
} 

public class MAMath { 
public static Array add ( Array a , Array b ) throws IllegalArgumentException { 
Array result = Array . factory ( a . getDataType ( ) , a . getShape ( ) ) ; 
if ( a . getElementType ( ) == double . class ) addDouble ( result , a , b ) ; 
else throw new UnsupportedOperationException ( ) ; 
return result ; 
} 
} 

public class MAMath { 
public static void copy ( Array result , Array a ) throws IllegalArgumentException { 
Class classType = a . getElementType ( ) ; 
if ( classType == double . class ) copyDouble ( result , a ) ; 
else if ( classType == float . class ) copyFloat ( result , a ) ; 
else if ( classType == long . class ) copyLong ( result , a ) ; 
else if ( classType == int . class ) copyInt ( result , a ) ; 
else if ( classType == short . class ) copyShort ( result , a ) ; 
else if ( classType == char . class ) copyChar ( result , a ) ; 
else if ( classType == byte . class ) copyByte ( result , a ) ; 
else if ( classType == boolean . class ) copyBoolean ( result , a ) ; 
else copyObject ( result , a ) ; 
} 
} 

public class MAMath { 
public static void copyObject ( Array result , Array a ) throws IllegalArgumentException { 
if ( ! conformable ( a , result ) ) throw new IllegalArgumentException ( "copy arrays are not conformable" ) ; 
IndexIterator iterA = a . getIndexIterator ( ) ; 
IndexIterator iterR = result . getIndexIterator ( ) ; 
while ( iterA . hasNext ( ) ) iterR . setObjectNext ( iterA . getObjectNext ( ) ) ; 
} 
} 

public class MAMath { 
public static void setDouble ( Array result , double val ) { 
IndexIterator iter = result . getIndexIterator ( ) ; 
while ( iter . hasNext ( ) ) iter . setDoubleNext ( val ) ; 
} 
} 

public class ProjectionAdapter { 
static public ProjectionImpl factory ( Projection proj ) { 
if ( proj instanceof ProjectionImpl ) return ( ProjectionImpl ) proj ; 
return new ProjectionAdapter ( proj ) ; 
} 
} 

public class EscapeStrings { 
static public String backslashEscape ( String x , String reservedChars ) { 
if ( x == null ) return null ; 
else if ( reservedChars == null ) return x ; 
boolean ok = true ; 
for ( int pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( reservedChars . indexOf ( c ) >= 0 ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x ) ; 
for ( int pos = 0 ; 
pos < sb . length ( ) ; 
pos ++ ) { 
char c = sb . charAt ( pos ) ; 
if ( reservedChars . indexOf ( c ) < 0 ) continue ; 
sb . setCharAt ( pos , '\\' ) ; 
pos ++ ; 
sb . insert ( pos , c ) ; 
pos ++ ; 
} 
return sb . toString ( ) ; 
} 
} 

public class EscapeStrings { 
static public String backslashUnescape ( String x ) { 
if ( ! x . contains ( "\\" ) ) return x ; 
StringBuilder sb = new StringBuilder ( x . length ( ) ) ; 
for ( int pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( c == '\\' ) c = x . charAt ( ++ pos ) ; 
sb . append ( c ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class EscapeStrings { 
public static String backslashToDAP ( String bs ) { 
StringBuilder buf = new StringBuilder ( ) ; 
int len = bs . length ( ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c = bs . charAt ( i ) ; 
if ( i < ( len - 1 ) && c == '\\' ) c = bs . charAt ( ++ i ) ; 
if ( _allowableInDAP . indexOf ( c ) < 0 ) { 
buf . append ( _URIEscape ) ; 
String ashex = Integer . toHexString ( ( int ) c ) ; 
if ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; 
buf . append ( ashex ) ; 
} 
else buf . append ( c ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class Nc4Cursor { 
static List < Nc4Cursor > getCursorPath ( Nc4Cursor cursor ) { 
List < Nc4Cursor > path = new ArrayList < > ( ) ; 
for ( ; 
; 
) { 
if ( ! cursor . getScheme ( ) . isCompoundArray ( ) ) path . add ( 0 , cursor ) ; 
if ( cursor . getScheme ( ) == Scheme . SEQUENCE ) break ; 
Nc4Cursor next = ( Nc4Cursor ) cursor . getContainer ( ) ; 
if ( next == null ) { 
assert cursor . getTemplate ( ) . isTopLevel ( ) ; 
break ; 
} 
assert next . getTemplate ( ) . getSort ( ) == DapSort . VARIABLE ; 
cursor = next ; 
} 
return path ; 
} 
} 

public class SwingUtils { 
public static Object getUIDefaultOfClass ( Class clazz , String property ) { 
Object retVal = null ; 
UIDefaults defaults = getUIDefaultsOfClass ( clazz ) ; 
List < Object > listKeys = Collections . list ( defaults . keys ( ) ) ; 
for ( Object key : listKeys ) { 
if ( key . equals ( property ) ) return defaults . get ( key ) ; 
if ( key . toString ( ) . equalsIgnoreCase ( property ) ) retVal = defaults . get ( key ) ; 
} 
return retVal ; 
} 
} 

public class SwingUtils { 
public static < T extends JComponent > Class getJClass ( T component ) { 
Class < ? > clazz = component . getClass ( ) ; 
while ( ! clazz . getName ( ) . matches ( "javax.swing.J[^.]*$" ) ) clazz = clazz . getSuperclass ( ) ; 
return clazz ; 
} 
} 

public class DoradeRADD { 
public float getCellSpacing ( ) throws DescriptorException { 
float [ ] cellRanges = myCELV . getCellRanges ( ) ; 
float cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; 
for ( int i = 2 ; 
i < cellRanges . length ; 
i ++ ) { 
float space = cellRanges [ i ] - cellRanges [ i - 1 ] ; 
if ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) ) throw new DescriptorException ( "variable cell spacing" ) ; 
} 
return cellSpacing ; 
} 
} 

public class Dimension { 
protected Factor [ ] mult ( final Dimension that ) { 
final Factor [ ] factors1 = _factors ; 
final Factor [ ] factors2 = that . _factors ; 
int i1 = 0 ; 
int i2 = 0 ; 
int k = 0 ; 
Factor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; 
for ( ; 
; 
) { 
if ( i1 == factors1 . length ) { 
final int n = factors2 . length - i2 ; 
System . arraycopy ( factors2 , i2 , newFactors , k , n ) ; 
k += n ; 
break ; 
} 
if ( i2 == factors2 . length ) { 
final int n = factors1 . length - i1 ; 
System . arraycopy ( factors1 , i1 , newFactors , k , n ) ; 
k += n ; 
break ; 
} 
final Factor f1 = factors1 [ i1 ] ; 
final Factor f2 = factors2 [ i2 ] ; 
final int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; 
if ( comp < 0 ) { 
newFactors [ k ++ ] = f1 ; 
i1 ++ ; 
} 
else if ( comp == 0 ) { 
final int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; 
if ( exponent != 0 ) newFactors [ k ++ ] = new Factor ( f1 , exponent ) ; 
i1 ++ ; 
i2 ++ ; 
} 
else { 
newFactors [ k ++ ] = f2 ; 
i2 ++ ; 
} 
} 
if ( k < newFactors . length ) { 
final Factor [ ] tmp = new Factor [ k ] ; 
System . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; 
newFactors = tmp ; 
} 
return newFactors ; 
} 
} 

public class Dimension { 
protected Factor [ ] pow ( final int power ) { 
Factor [ ] factors ; 
if ( power == 0 ) factors = new Factor [ 0 ] ; 
else { 
factors = getFactors ( ) ; 
if ( power != 1 ) for ( int i = factors . length ; 
-- i >= 0 ; 
) factors [ i ] = factors [ i ] . pow ( power ) ; 
} 
return factors ; 
} 
} 

public class Dimension { 
public final boolean isReciprocalOf ( final Dimension that ) { 
final Factor [ ] theseFactors = _factors ; 
final Factor [ ] thoseFactors = that . _factors ; 
boolean isReciprocalOf ; 
if ( theseFactors . length != thoseFactors . length ) isReciprocalOf = false ; 
else { 
int i ; 
for ( i = theseFactors . length ; 
-- i >= 0 ; 
) if ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) break ; 
isReciprocalOf = i < 0 ; 
} 
return isReciprocalOf ; 
} 
} 

public class Dimension { 
public final boolean isDimensionless ( ) { 
for ( int i = _factors . length ; 
-- i >= 0 ; 
) if ( ! _factors [ i ] . isDimensionless ( ) ) return false ; 
return true ; 
} 
} 

public class LogarithmicUnit { 
@ Override protected Unit myRaiseTo ( final int power ) throws RaiseException { 
if ( power == 0 ) return DerivedUnitImpl . DIMENSIONLESS ; 
if ( power == 1 ) return this ; 
throw new RaiseException ( this ) ; 
} 
} 

public class LogarithmicUnit { 
public float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { 
for ( int i = input . length ; 
-- i >= 0 ; 
) output [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; 
return reference . toDerivedUnit ( output , output ) ; 
} 
} 

public class Vis5DIosp { 
private Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { 
String vert_unit = null ; 
String vert_type ; 
ArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; 
AxisType axisType = null ; 
switch ( vert_sys ) { 
case ( 0 ) : vert_unit = null ; 
vert_type = "height" ; 
break ; 
case ( 1 ) : case ( 2 ) : vert_unit = "km" ; 
vert_type = "altitude" ; 
axisType = AxisType . Height ; 
break ; 
case ( 3 ) : vert_unit = "mbar" ; 
vert_type = "pressure" ; 
axisType = AxisType . Pressure ; 
break ; 
default : throw new IOException ( "vert_sys unknown" ) ; 
} 
Variable vertVar = new Variable ( ncfile , null , null , vert_type ) ; 
vertVar . setDimensions ( LEVEL ) ; 
vertVar . setDataType ( DataType . FLOAT ) ; 
if ( vert_unit != null ) vertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; 
if ( axisType != null ) vertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; 
switch ( vert_sys ) { 
case ( 0 ) : case ( 1 ) : for ( int i = 0 ; 
i < n_levels ; 
i ++ ) data . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; 
break ; 
case ( 2 ) : for ( int i = 0 ; 
i < n_levels ; 
i ++ ) data . set ( i , vert_args [ i ] ) ; 
break ; 
case ( 3 ) : try { 
Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; 
float [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; 
System . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; 
for ( int i = 0 ; 
i < n_levels ; 
i ++ ) pressures [ 0 ] [ i ] *= 1000 ; 
pressures = vert_cs . fromReference ( pressures ) ; 
for ( int i = 0 ; 
i < n_levels ; 
i ++ ) data . set ( i , pressures [ 0 ] [ i ] ) ; 
} 
catch ( VisADException ve ) { 
throw new IOException ( "unable to make vertical system" ) ; 
} 
break ; 
} 
vertVar . setCachedData ( data , false ) ; 
return vertVar ; 
} 
} 

public class DoradeDescriptor { 
protected float grabFloat ( byte [ ] bytes , int offset ) throws DescriptorException { 
try { 
byte [ ] src ; 
if ( littleEndianData ) { 
src = new byte [ 4 ] ; 
src [ 0 ] = bytes [ offset + 3 ] ; 
src [ 1 ] = bytes [ offset + 2 ] ; 
src [ 2 ] = bytes [ offset + 1 ] ; 
src [ 3 ] = bytes [ offset ] ; 
offset = 0 ; 
} 
else src = bytes ; 
DataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 4 ) ) ; 
return stream . readFloat ( ) ; 
} 
catch ( Exception ex ) { 
throw new DescriptorException ( ex ) ; 
} 
} 
} 

public class DoradeDescriptor { 
protected double grabDouble ( byte [ ] bytes , int offset ) throws DescriptorException { 
try { 
byte [ ] src ; 
if ( littleEndianData ) { 
src = new byte [ 8 ] ; 
src [ 0 ] = bytes [ offset + 7 ] ; 
src [ 1 ] = bytes [ offset + 6 ] ; 
src [ 2 ] = bytes [ offset + 5 ] ; 
src [ 3 ] = bytes [ offset + 4 ] ; 
src [ 4 ] = bytes [ offset + 3 ] ; 
src [ 5 ] = bytes [ offset + 2 ] ; 
src [ 6 ] = bytes [ offset + 1 ] ; 
src [ 7 ] = bytes [ offset ] ; 
offset = 0 ; 
} 
else src = bytes ; 
DataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 8 ) ) ; 
return stream . readDouble ( ) ; 
} 
catch ( Exception ex ) { 
throw new DescriptorException ( ex ) ; 
} 
} 
} 

public class GisFeatureRenderer { 
protected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { 
if ( shapeList != null ) return shapeList . iterator ( ) ; 
if ( Debug . isSet ( "projection/LatLonShift" ) ) System . out . println ( "projection/LatLonShift GisFeatureRenderer.getShapes called" ) ; 
ProjectionImpl dataProject = getDataProjection ( ) ; 
List featList = getFeatures ( ) ; 
shapeList = new ArrayList ( featList . size ( ) ) ; 
Iterator iter = featList . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
AbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; 
Shape shape ; 
if ( dataProject == null ) shape = feature . getShape ( ) ; 
else if ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; 
else if ( dataProject == displayProject ) shape = feature . getShape ( ) ; 
else shape = feature . getProjectedShape ( dataProject , displayProject ) ; 
shapeList . add ( shape ) ; 
} 
return shapeList . iterator ( ) ; 
} 
} 

public class HeaderInputStream { 
private void getMoreBytes ( ) throws IOException { 
currentOffset = 0 ; 
int bytesRead = 0 ; 
int lookingFor = 0 ; 
for ( ; 
bytesRead < lineBuf . length ; 
bytesRead ++ ) { 
int c = in . read ( ) ; 
if ( c == - 1 ) break ; 
lineBuf [ bytesRead ] = ( byte ) c ; 
if ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { 
lookingFor ++ ; 
if ( lookingFor == endSequence . length ) { 
endFound = true ; 
break ; 
} 
} 
else if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) lookingFor = 1 ; 
else lookingFor = 0 ; 
} 
bytesRemaining = bytesRead ; 
} 
} 

public class HeaderInputStream { 
public int read ( byte b [ ] , int off , int len ) throws IOException { 
if ( len <= 0 ) return 0 ; 
int c = read ( ) ; 
if ( c == - 1 ) return - 1 ; 
b [ off ] = ( byte ) c ; 
int i = 1 ; 
try { 
for ( ; 
i < len ; 
i ++ ) { 
c = read ( ) ; 
if ( c == - 1 ) break ; 
b [ off + i ] = ( byte ) c ; 
} 
} 
catch ( IOException e ) { 
} 
return i ; 
} 
} 

public class GridVertCoord { 
private int coordIndex ( GridRecord record ) { 
double val = record . getLevel1 ( ) ; 
double val2 = record . getLevel2 ( ) ; 
if ( usesBounds && ( val > val2 ) ) { 
val = record . getLevel2 ( ) ; 
val2 = record . getLevel1 ( ) ; 
} 
for ( int i = 0 ; 
i < levels . size ( ) ; 
i ++ ) { 
LevelCoord lc = ( LevelCoord ) levels . get ( i ) ; 
if ( usesBounds ) if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) return i ; 
else if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) return i ; 
} 
return - 1 ; 
} 
} 

public class NOWRadiosp { 
public byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { 
int run ; 
byte [ ] bdata = new byte [ xt ] ; 
int nbin = 0 ; 
int total = 0 ; 
for ( run = 0 ; 
run < rLen ; 
run ++ ) { 
int drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; 
byte dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; 
for ( int i = 0 ; 
i < drun ; 
i ++ ) { 
bdata [ nbin ++ ] = dcode1 ; 
total ++ ; 
} 
} 
if ( total < xt ) for ( run = total ; 
run < xt ; 
run ++ ) bdata [ run ] = 0 ; 
return bdata ; 
} 
} 

public class NcDDS { 
private BaseType createVariable ( NetcdfFile ncfile , Variable v ) { 
BaseType bt ; 
if ( v . getRank ( ) == 0 ) bt = createScalarVariable ( ncfile , v ) ; 
else if ( v . getDataType ( ) == DataType . CHAR ) if ( v . getRank ( ) > 1 ) bt = new NcSDCharArray ( v ) ; 
else bt = new NcSDString ( v ) ; 
else if ( v . getDataType ( ) == DataType . STRING ) if ( v . getRank ( ) == 0 ) bt = new NcSDString ( v ) ; 
else bt = new NcSDArray ( v , new NcSDString ( v ) ) ; 
else bt = createArray ( ncfile , v ) ; 
return bt ; 
} 
} 

public class NavigatedPanel { 
public void setProjectionImpl ( ProjectionImpl p ) { 
if ( geoSelection != null ) { 
LatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; 
setGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; 
} 
project = p ; 
navigate . setMapArea ( project . getDefaultMapArea ( ) ) ; 
if ( Debug . isSet ( "projection/set" ) || debugNewProjection ) System . out . println ( "projection/set NP=" + project ) ; 
if ( hasReference ) refWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; 
} 
} 

public class NavigatedPanel { 
private void redrawLater ( int delay ) { 
boolean already = ( redrawTimer != null ) && ( redrawTimer . isRunning ( ) ) ; 
if ( debugThread ) System . out . println ( "redrawLater isRunning= " + already ) ; 
if ( already ) return ; 
if ( redrawTimer == null ) redrawTimer = new javax . swing . Timer ( 0 , new ActionListener ( ) { 
public void actionPerformed ( ActionEvent e ) { 
drawG ( ) ; 
redrawTimer . stop ( ) ; 
} 
} 
) ; 
redrawTimer . setDelay ( delay ) ; 
redrawTimer . start ( ) ; 
} 
} 

public class NavigatedPanel { 
private void newScreenSize ( Rectangle b ) { 
boolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; 
if ( debugBounds ) System . out . println ( "NavigatedPanel newScreenSize old= " + myBounds ) ; 
if ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; 
myBounds . setBounds ( b ) ; 
if ( sameSize ) return ; 
if ( debugBounds ) System . out . println ( "  newBounds = " + b ) ; 
if ( ( b . width > 0 ) && ( b . height > 0 ) ) bImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; 
else bImage = null ; 
navigate . setScreenSize ( b . width , b . height ) ; 
} 
} 

public class DatasetTreeView { 
public void setSelected ( VariableIF v ) { 
if ( v == null ) return ; 
final List < VariableIF > vchain = new ArrayList < > ( ) ; 
vchain . add ( v ) ; 
VariableIF vp = v ; 
while ( vp . isMemberOfStructure ( ) ) { 
vp = vp . getParentStructure ( ) ; 
vchain . add ( 0 , vp ) ; 
} 
final List < Group > gchain = new ArrayList < > ( ) ; 
Group gp = vp . getParentGroup ( ) ; 
gchain . add ( gp ) ; 
while ( gp . getParentGroup ( ) != null ) { 
gp = gp . getParentGroup ( ) ; 
gchain . add ( 0 , gp ) ; 
} 
final List < Object > pathList = new ArrayList < > ( ) ; 
GroupNode gnode = ( GroupNode ) model . getRoot ( ) ; 
pathList . add ( gnode ) ; 
Group parentGroup = gchain . get ( 0 ) ; 
for ( int i = 1 ; 
i < gchain . size ( ) ; 
i ++ ) { 
parentGroup = gchain . get ( i ) ; 
gnode = gnode . findNestedGroup ( parentGroup ) ; 
assert gnode != null ; 
pathList . add ( gnode ) ; 
} 
vp = vchain . get ( 0 ) ; 
VariableNode vnode = gnode . findNestedVariable ( vp ) ; 
if ( vnode == null ) return ; 
pathList . add ( vnode ) ; 
for ( int i = 1 ; 
i < vchain . size ( ) ; 
i ++ ) { 
vp = vchain . get ( i ) ; 
vnode = vnode . findNestedVariable ( vp ) ; 
if ( vnode == null ) return ; 
pathList . add ( vnode ) ; 
} 
final Object [ ] paths = pathList . toArray ( ) ; 
final TreePath treePath = new TreePath ( paths ) ; 
tree . setSelectionPath ( treePath ) ; 
tree . scrollPathToVisible ( treePath ) ; 
} 
} 

public class GradsDataDescriptorFile { 
private void swapByteOrder ( ) { 
String arch = System . getProperty ( "os.arch" ) ; 
if ( arch . equals ( "x86" ) || arch . equals ( "arm" ) || arch . equals ( "x86_64" ) || arch . equals ( "amd64" ) || arch . equals ( "alpha" ) ) bigEndian = true ; 
else bigEndian = false ; 
} 
} 

public class GradsDataDescriptorFile { 
public int [ ] getTimeStepsPerFile ( String filename ) { 
if ( chsubs != null ) for ( Chsub ch : chsubs ) { 
if ( filename . contains ( ch . subString ) ) return new int [ ] { 
ch . numTimes , ch . startTimeIndex } 
; 
} 
return new int [ ] { 
timeStepsPerFile , 0 } 
; 
} 
} 

public class GradsDataDescriptorFile { 
public String getFileName ( int eIndex , int tIndex ) { 
String dataFilePath = dataFile ; 
if ( ( getTemplateType ( ) == ENS_TEMPLATE ) || ( getTemplateType ( ) == ENS_TIME_TEMPLATE ) ) dataFilePath = getEnsembleDimension ( ) . replaceFileTemplate ( dataFilePath , eIndex ) ; 
dataFilePath = getTimeDimension ( ) . replaceFileTemplate ( dataFilePath , tIndex ) ; 
if ( ( chsubs != null ) && ( dataFilePath . contains ( CHSUB_TEMPLATE_ID ) ) ) for ( Chsub ch : chsubs ) { 
if ( ( tIndex >= ch . startTimeIndex ) && ( tIndex <= ch . endTimeIndex ) ) { 
dataFilePath = dataFilePath . replace ( CHSUB_TEMPLATE_ID , ch . subString ) ; 
break ; 
} 
} 
return getFullPath ( dataFilePath ) ; 
} 
} 

public class GradsDataDescriptorFile { 
private List < String > getFileNames ( ) throws IOException { 
if ( fileNames == null ) { 
fileNames = new ArrayList < > ( ) ; 
timeStepsPerFile = tDim . getSize ( ) ; 
if ( ! isTemplate ( ) ) fileNames . add ( getFullPath ( getDataFile ( ) ) ) ; 
else { 
long start = System . currentTimeMillis ( ) ; 
List < String > fileSet = new ArrayList < > ( ) ; 
String template = getDataFile ( ) ; 
if ( GradsTimeDimension . hasTimeTemplate ( template ) ) if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) templateType = ENS_TIME_TEMPLATE ; 
else templateType = TIME_TEMPLATE ; 
else if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) templateType = ENS_TEMPLATE ; 
else templateType = TIME_TEMPLATE ; 
if ( templateType == ENS_TEMPLATE ) for ( int e = 0 ; 
e < eDim . getSize ( ) ; 
e ++ ) fileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; 
else if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { 
int numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; 
for ( int t = 0 ; 
t < tDim . getSize ( ) ; 
t ++ ) for ( int e = 0 ; 
e < numens ; 
e ++ ) { 
String file = getFileName ( e , t ) ; 
if ( ! fileSet . contains ( file ) ) fileSet . add ( file ) ; 
} 
timeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; 
} 
fileNames . addAll ( fileSet ) ; 
} 
for ( String file : fileNames ) { 
File f = new File ( file ) ; 
if ( ! f . exists ( ) ) { 
log . error ( "File: " + f + " does not exist" ) ; 
throw new IOException ( "File: " + f + " does not exist" ) ; 
} 
} 
} 
return fileNames ; 
} 
} 

public class GradsDataDescriptorFile { 
private String getDDFPath ( ) { 
if ( pathToDDF == null ) { 
int lastSlash = ddFile . lastIndexOf ( "/" ) ; 
if ( lastSlash < 0 ) lastSlash = ddFile . lastIndexOf ( File . separator ) ; 
pathToDDF = ( lastSlash < 0 ) ? "" : ddFile . substring ( 0 , lastSlash + 1 ) ; 
} 
return pathToDDF ; 
} 
} 

public class GradsDataDescriptorFile { 
private String getFullPath ( String filename ) { 
String file ; 
String ddfPath = getDDFPath ( ) ; 
if ( filename . startsWith ( "^" ) ) { 
file = filename . replace ( "^" , "" ) ; 
file = ddfPath + file ; 
} 
else { 
File f = new File ( filename ) ; 
if ( ! f . isAbsolute ( ) ) file = ddfPath + filename ; 
else file = filename ; 
} 
return file ; 
} 
} 

public class GradsDataDescriptorFile { 
private void addChsub ( Chsub sub ) { 
if ( chsubs == null ) chsubs = new ArrayList < > ( ) ; 
chsubs . add ( sub ) ; 
} 
} 

public class TimeCoordIntvDateValue { 
public TimeCoordIntvValue convertReferenceDate ( CalendarDate refDate , CalendarPeriod timeUnit ) { 
if ( timeUnit == null ) throw new IllegalArgumentException ( "null time unit" ) ; 
int startOffset = timeUnit . getOffset ( refDate , start ) ; 
int endOffset = timeUnit . getOffset ( refDate , end ) ; 
return new TimeCoordIntvValue ( startOffset , endOffset ) ; 
} 
} 

public class Nidsheader { 
int readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { 
int pos = 0 ; 
raf . seek ( pos ) ; 
int readLen = 35 ; 
byte [ ] b = new byte [ readLen ] ; 
int rc = raf . read ( b ) ; 
if ( rc != readLen ) return 0 ; 
int iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; 
int iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; 
int iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; 
int iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; 
if ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { 
noHeader = true ; 
return 1 ; 
} 
String pib = new String ( b , CDM . utf8Charset ) ; 
if ( pib . indexOf ( "SDUS" ) != - 1 ) { 
noHeader = false ; 
return 1 ; 
} 
else if ( raf . getLocation ( ) . indexOf ( ".nids" ) != - 1 ) { 
noHeader = true ; 
return 1 ; 
} 
else return 0 ; 
} 
} 

public class Nidsheader { 
int pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { 
int vlen = 0 ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) vlen = vlen + dlen [ i ] ; 
ArrayList dims = new ArrayList ( ) ; 
Dimension sDim = new Dimension ( "graphicSymbolSize" , vlen ) ; 
ncfile . addDimension ( null , sDim ) ; 
dims . add ( sDim ) ; 
Structure dist = new Structure ( ncfile , null , null , structName ) ; 
dist . setDimensions ( dims ) ; 
ncfile . addVariable ( null , dist ) ; 
dist . addAttribute ( new Attribute ( CDM . LONG_NAME , "special graphic symbol for code " + code ) ) ; 
Variable i0 = new Variable ( ncfile , null , dist , "x_start" ) ; 
i0 . setDimensions ( ( String ) null ) ; 
i0 . setDataType ( DataType . FLOAT ) ; 
i0 . addAttribute ( new Attribute ( CDM . UNITS , "KM" ) ) ; 
dist . addMemberVariable ( i0 ) ; 
Variable j0 = new Variable ( ncfile , null , dist , "y_start" ) ; 
j0 . setDimensions ( ( String ) null ) ; 
j0 . setDataType ( DataType . FLOAT ) ; 
j0 . addAttribute ( new Attribute ( CDM . UNITS , "KM" ) ) ; 
dist . addMemberVariable ( j0 ) ; 
int [ ] pos1 = new int [ len ] ; 
int [ ] dlen1 = new int [ len ] ; 
System . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; 
System . arraycopy ( pos , 0 , pos1 , 0 , len ) ; 
dist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; 
return 1 ; 
} 
} 

public class Nidsheader { 
int checkMsgHeader ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { 
int rc ; 
long actualSize ; 
int readLen ; 
actualSize = raf . length ( ) ; 
int pos = 0 ; 
raf . seek ( pos ) ; 
readLen = ( int ) actualSize ; 
byte [ ] b = new byte [ readLen ] ; 
rc = raf . read ( b ) ; 
if ( rc != readLen ) log . warn ( " error reading nids product header " + raf . getLocation ( ) ) ; 
ByteBuffer bos = ByteBuffer . wrap ( b ) ; 
return read_msghead ( bos , 0 ) ; 
} 
} 

public class Nidsheader { 
int pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { 
ArrayList dims = new ArrayList ( ) ; 
Variable v ; 
int vlen = 0 ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) vlen = vlen + dlen [ i ] ; 
Dimension sDim = new Dimension ( "unlinkedVectorSize" , vlen ) ; 
ncfile . addDimension ( null , sDim ) ; 
dims . add ( sDim ) ; 
Structure dist = new Structure ( ncfile , null , null , "unlinkedVectorStruct" ) ; 
dist . setDimensions ( dims ) ; 
ncfile . addVariable ( null , dist ) ; 
dist . addAttribute ( new Attribute ( CDM . LONG_NAME , "Unlinked Vector Packet" ) ) ; 
v = new Variable ( ncfile , null , null , "iValue" ) ; 
v . setDataType ( DataType . SHORT ) ; 
v . setDimensions ( ( String ) null ) ; 
dist . addMemberVariable ( v ) ; 
Variable ii0 = new Variable ( ncfile , null , dist , "x_start" ) ; 
ii0 . setDimensions ( ( String ) null ) ; 
ii0 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( ii0 ) ; 
Variable ii1 = new Variable ( ncfile , null , dist , "y_start" ) ; 
ii1 . setDimensions ( ( String ) null ) ; 
ii1 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( ii1 ) ; 
Variable jj0 = new Variable ( ncfile , null , dist , "x_end" ) ; 
jj0 . setDimensions ( ( String ) null ) ; 
jj0 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( jj0 ) ; 
Variable jj1 = new Variable ( ncfile , null , dist , "y_end" ) ; 
jj1 . setDimensions ( ( String ) null ) ; 
jj1 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( jj1 ) ; 
int [ ] pos1 = new int [ len ] ; 
int [ ] dlen1 = new int [ len ] ; 
System . arraycopy ( pos , 0 , pos1 , 0 , len ) ; 
System . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; 
dist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; 
return 1 ; 
} 
} 

public class Nidsheader { 
public int [ ] getLevels ( int nlevel , short [ ] th ) { 
int [ ] levels = new int [ nlevel ] ; 
int ival ; 
int isign ; 
for ( int i = 0 ; 
i < nlevel ; 
i ++ ) { 
ival = convertShort2unsignedInt ( th [ i ] ) ; 
if ( ( ival & 0x00008000 ) == 0 ) { 
isign = - 1 ; 
if ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; 
levels [ i ] = isign * ( ival & 0x000000FF ) ; 
} 
else levels [ i ] = - 9999 + ( ival & 0x000000FF ) ; 
} 
return levels ; 
} 
} 

public class Nidsheader { 
public int [ ] getDualpolLevels ( short [ ] th ) { 
int inc = th . length ; 
int [ ] levels = new int [ inc ] ; 
for ( int i = 0 ; 
i < inc ; 
i ++ ) levels [ i ] = th [ i ] ; 
return levels ; 
} 
} 

public class Nidsheader { 
int getUInt ( byte [ ] b , int num ) { 
int base = 1 ; 
int i ; 
int word = 0 ; 
int bv [ ] = new int [ num ] ; 
for ( i = 0 ; 
i < num ; 
i ++ ) bv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; 
for ( i = num - 1 ; 
i >= 0 ; 
i -- ) { 
word += base * bv [ i ] ; 
base *= 256 ; 
} 
return word ; 
} 
} 

public class Nidsheader { 
int getInt ( byte [ ] b , int num ) { 
int base = 1 ; 
int i ; 
int word = 0 ; 
int bv [ ] = new int [ num ] ; 
for ( i = 0 ; 
i < num ; 
i ++ ) bv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; 
if ( bv [ 0 ] > 127 ) { 
bv [ 0 ] -= 128 ; 
base = - 1 ; 
} 
for ( i = num - 1 ; 
i >= 0 ; 
i -- ) { 
word += base * bv [ i ] ; 
base *= 256 ; 
} 
return word ; 
} 
} 

public class Nidsheader { 
protected Object convert ( byte [ ] barray , DataType dataType , int nelems , int byteOrder ) { 
if ( dataType == DataType . BYTE ) return barray ; 
if ( dataType == DataType . CHAR ) return IospHelper . convertByteToChar ( barray ) ; 
ByteBuffer bbuff = ByteBuffer . wrap ( barray ) ; 
if ( byteOrder >= 0 ) bbuff . order ( byteOrder == ucar . unidata . io . RandomAccessFile . LITTLE_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; 
if ( dataType == DataType . SHORT ) { 
ShortBuffer tbuff = bbuff . asShortBuffer ( ) ; 
short [ ] pa = new short [ nelems ] ; 
tbuff . get ( pa ) ; 
return pa ; 
} 
else if ( dataType == DataType . INT ) { 
IntBuffer tbuff = bbuff . asIntBuffer ( ) ; 
int [ ] pa = new int [ nelems ] ; 
tbuff . get ( pa ) ; 
return pa ; 
} 
else if ( dataType == DataType . FLOAT ) { 
FloatBuffer tbuff = bbuff . asFloatBuffer ( ) ; 
float [ ] pa = new float [ nelems ] ; 
tbuff . get ( pa ) ; 
return pa ; 
} 
else if ( dataType == DataType . DOUBLE ) { 
DoubleBuffer tbuff = bbuff . asDoubleBuffer ( ) ; 
double [ ] pa = new double [ nelems ] ; 
tbuff . get ( pa ) ; 
return pa ; 
} 
throw new IllegalStateException ( ) ; 
} 
} 

public class DapController { 
protected void senderror ( DapRequest drq , int httpcode , Throwable t ) throws IOException { 
if ( httpcode == 0 ) httpcode = HttpServletResponse . SC_BAD_REQUEST ; 
ErrorResponse err = new ErrorResponse ( ) ; 
err . setCode ( httpcode ) ; 
if ( t == null ) err . setMessage ( "Servlet error: " + drq . getURL ( ) ) ; 
else { 
StringWriter sw = new StringWriter ( ) ; 
PrintWriter p = new PrintWriter ( sw ) ; 
t . printStackTrace ( p ) ; 
p . close ( ) ; 
sw . close ( ) ; 
err . setMessage ( sw . toString ( ) ) ; 
} 
err . setContext ( drq . getURL ( ) ) ; 
String errormsg = err . buildXML ( ) ; 
drq . getResponse ( ) . sendError ( httpcode , errormsg ) ; 
} 
} 

public class Rubberband { 
public void stretch ( Point p ) { 
lastPt . x = stretchedPt . x ; 
lastPt . y = stretchedPt . y ; 
stretchedPt . x = p . x ; 
stretchedPt . y = p . y ; 
Graphics2D g = ( Graphics2D ) component . getGraphics ( ) ; 
if ( g != null ) try { 
g . setXORMode ( component . getBackground ( ) ) ; 
if ( firstStretch == true ) firstStretch = false ; 
else drawLast ( g ) ; 
drawNext ( g ) ; 
} 
finally { 
g . dispose ( ) ; 
} 
} 
} 

public class GribNumbers { 
public static float float4 ( int a , int b , int c , int d ) { 
int sgn , mant , exp ; 
mant = b << 16 | c << 8 | d ; 
if ( mant == 0 ) return 0.0f ; 
sgn = - ( ( ( a & 128 ) >> 6 ) - 1 ) ; 
exp = ( a & 127 ) - 64 ; 
return ( float ) ( sgn * Math . pow ( 16.0 , exp - 6 ) * mant ) ; 
} 
} 

public class DGrid { 
public int projectedComponents ( boolean constrained ) { 
int comp ; 
if ( constrained ) { 
comp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; 
Enumeration e = mapVars . elements ( ) ; 
while ( e . hasMoreElements ( ) ) if ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp ++ ; 
} 
else comp = 1 + mapVars . size ( ) ; 
return comp ; 
} 
} 

public class ConfigCatalogInitialization { 
private void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { 
if ( exceedLimit ) return ; 
for ( Dataset ds : datasets ) { 
if ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; 
if ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) exceedLimit = true ; 
String id = ds . getID ( ) ; 
if ( id != null ) if ( idMap . contains ( id ) ) logCatalogInit . error ( ERROR + "Duplicate id on  '" + ds . getName ( ) + "' id= '" + id + "'" ) ; 
else idMap . add ( id ) ; 
if ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; 
if ( ds instanceof CatalogScan ) continue ; 
if ( ds instanceof CatalogRef ) { 
CatalogRef catref = ( CatalogRef ) ds ; 
String href = catref . getXlinkHref ( ) ; 
if ( ! href . startsWith ( "http:" ) ) { 
if ( href . startsWith ( "./" ) ) href = href . substring ( 2 ) ; 
String path ; 
String contextPathPlus = this . contextPath + "/" ; 
if ( href . startsWith ( contextPathPlus ) ) path = href . substring ( contextPathPlus . length ( ) ) ; 
else if ( href . startsWith ( "/" ) ) { 
logCatalogInit . error ( ERROR + "Skipping catalogRef <xlink:href=" + href + ">. Reference is relative to the server outside the context path [" + contextPathPlus + "]. " + "Parent catalog info: Name=\"" + catref . getParentCatalog ( ) . getName ( ) + "\"; Base URI=\"" + catref . getParentCatalog ( ) . getUriString ( ) + "\"; dirPath=\"" + dirPath + "\"." ) ; 
continue ; 
} 
else path = dirPath + href ; 
CatalogExt ext = catalogTracker . get ( path ) ; 
long lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; 
checkCatalogToRead ( readMode , path , false , lastRead ) ; 
} 
} 
else processDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; 
} 
} 
} 

public class BaseQuantity { 
public int compareTo ( final BaseQuantity that ) { 
int comp ; 
if ( this == that ) comp = 0 ; 
else { 
comp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; 
if ( comp == 0 && getSymbol ( ) != null ) comp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; 
} 
return comp ; 
} 
} 

public class VlenIO { 
public void readChars ( char [ ] buffer , int start , int length ) throws IOException { 
final int end = start + length ; 
for ( int i = start ; 
i < end ; 
i ++ ) { 
byte b = readByte ( ) ; 
if ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; 
else if ( ( b & 0xE0 ) != 0xE0 ) buffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; 
else buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; 
} 
} 
} 

public class Grib1SectionBitMap { 
@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { 
if ( startingPosition <= 0 ) throw new IllegalStateException ( "Grib1 Bit map has bad starting position" ) ; 
raf . seek ( startingPosition ) ; 
int length = GribNumbers . uint3 ( raf ) ; 
raf . read ( ) ; 
int bm = raf . readShort ( ) ; 
if ( bm != 0 ) { 
logger . warn ( "Grib1 Bit map section pre-defined (provided by center) bitmap number = {}" , bm ) ; 
return null ; 
} 
if ( length <= 6 || length > 10e6 ) return null ; 
int n = length - 6 ; 
byte [ ] data = new byte [ n ] ; 
raf . readFully ( data ) ; 
return data ; 
} 
} 

public class GridVariable { 
void addProduct ( GridRecord record ) { 
records . add ( record ) ; 
if ( firstRecord == null ) firstRecord = record ; 
} 
} 

public class GridVariable { 
public int showMissingSummary ( Formatter f ) { 
int count = 0 ; 
int total = recordTracker . length ; 
for ( int i = 0 ; 
i < total ; 
i ++ ) if ( recordTracker [ i ] == null ) count ++ ; 
f . format ( "  MISSING= %d / %d for %s%n" , count , total , name ) ; 
return count ; 
} 
} 

public class GridVariable { 
public GridRecord findRecord ( int ens , int time , int level ) { 
if ( hasEnsemble ( ) ) return recordTracker [ ens * ( ntimes * nlevels ) + ( time * nlevels ) + level ] ; 
else return recordTracker [ time * nlevels + level ] ; 
} 
} 

public class NCheader { 
static boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { 
if ( b1 == b2 ) return true ; 
if ( b1 == null || b2 == null ) return false ; 
if ( b1 . length < len || b2 . length < len ) return false ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) if ( b1 [ i ] != b2 [ i ] ) return false ; 
return true ; 
} 
} 

public class GdsHorizCoordSys { 
public void setGaussianLats ( int nparallels , float la1 , float la2 ) { 
log . debug ( "la1 {}, la2 {}" , la1 , la2 ) ; 
if ( this . gaussLats != null ) throw new RuntimeException ( "Cant modify GdsHorizCoordSys" ) ; 
int nlats = ( 2 * nparallels ) ; 
GaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; 
int bestStartIndex = 0 , bestEndIndex = 0 ; 
double bestStartDiff = Double . MAX_VALUE ; 
double bestEndDiff = Double . MAX_VALUE ; 
for ( int i = 0 ; 
i < nlats ; 
i ++ ) { 
double diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; 
if ( diff < bestStartDiff ) { 
bestStartDiff = diff ; 
bestStartIndex = i ; 
} 
diff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; 
if ( diff < bestEndDiff ) { 
bestEndDiff = diff ; 
bestEndIndex = i ; 
} 
} 
log . debug ( "first pass: bestStartIndex {}, bestEndIndex {}" , bestStartIndex , bestEndIndex ) ; 
if ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { 
log . warn ( "GRIB gaussian lats: NP != NY, use NY" ) ; 
nlats = nyRaw ; 
gaussLats = GaussianLatitudes . factory ( nlats ) ; 
bestStartIndex = 0 ; 
bestEndIndex = nyRaw - 1 ; 
} 
boolean goesUp = bestEndIndex > bestStartIndex ; 
log . debug ( "bestStartIndex {}, bestEndIndex {}, goesUp {}" , bestStartIndex , bestEndIndex , goesUp ) ; 
int useIndex = bestStartIndex ; 
float [ ] data = new float [ nyRaw ] ; 
float [ ] gaussw = new float [ nyRaw ] ; 
for ( int i = 0 ; 
i < nyRaw ; 
i ++ ) { 
data [ i ] = ( float ) gaussLats . latd [ useIndex ] ; 
gaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; 
log . trace ( "i {}, useIndex {}, data {}, gaussw {}" , i , useIndex , data [ i ] , gaussw [ i ] ) ; 
if ( goesUp ) useIndex ++ ; 
else useIndex -- ; 
} 
this . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { 
nyRaw } 
, data ) ; 
this . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { 
nyRaw } 
, gaussw ) ; 
} 
} 

public class ParsedSectionSpec { 
private static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { 
String varNameEsc , indexSelect = null ; 
int pos1 = EscapeStrings . indexOf ( selector , '(' ) ; 
if ( pos1 < 0 ) varNameEsc = selector ; 
else { 
varNameEsc = selector . substring ( 0 , pos1 ) ; 
int pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; 
indexSelect = selector . substring ( pos1 , pos2 ) ; 
} 
if ( debugSelector ) System . out . println ( " parseVariableSection <" + selector + "> = <" + varNameEsc + ">, <" + indexSelect + ">" ) ; 
Variable v = null ; 
if ( parent instanceof NetcdfFile ) { 
NetcdfFile ncfile = ( NetcdfFile ) parent ; 
v = ncfile . findVariable ( varNameEsc ) ; 
} 
else if ( parent instanceof Structure ) { 
Structure s = ( Structure ) parent ; 
v = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; 
} 
if ( v == null ) throw new IllegalArgumentException ( " cant find variable: " + varNameEsc + " in selector=" + selector ) ; 
if ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; 
Section section ; 
if ( indexSelect != null ) { 
section = new Section ( indexSelect ) ; 
section = Section . fill ( section , v . getShape ( ) ) ; 
} 
else section = v . getShapeAsSection ( ) ; 
return new ParsedSectionSpec ( v , section ) ; 
} 
} 

public class HTTPMethod { 
public synchronized void close ( ) { 
if ( closed ) return ; 
closed = true ; 
if ( methodstream != null ) { 
try { 
this . methodstream . close ( ) ; 
} 
catch ( IOException ioe ) { 
} 
this . methodstream = null ; 
} 
if ( this . lastresponse != null ) { 
if ( false ) try { 
try { 
EntityUtils . consume ( this . lastresponse . getEntity ( ) ) ; 
} 
finally { 
HttpClientUtils . closeQuietly ( this . lastresponse ) ; 
} 
} 
catch ( IOException ignore ) { 
} 
else HttpClientUtils . closeQuietly ( this . lastresponse ) ; 
this . lastresponse = null ; 
} 
if ( session != null ) { 
session . removeMethod ( this ) ; 
if ( localsession ) { 
session . close ( ) ; 
session = null ; 
} 
} 
this . lastrequest = null ; 
} 
} 

public class CBZip2InputStream { 
public int read ( ) { 
if ( streamEnd ) return - 1 ; 
else { 
int retChar = currentChar ; 
switch ( currentState ) { 
case START_BLOCK_STATE : break ; 
case RAND_PART_A_STATE : break ; 
case RAND_PART_B_STATE : setupRandPartB ( ) ; 
break ; 
case RAND_PART_C_STATE : setupRandPartC ( ) ; 
break ; 
case NO_RAND_PART_A_STATE : break ; 
case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; 
break ; 
case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; 
break ; 
default : break ; 
} 
return retChar ; 
} 
} 
} 

public class ProgressMonitor { 
public void start ( java . awt . Component top , String taskName , int progressMaxCount ) { 
pm = new javax . swing . ProgressMonitor ( top , taskName , "" , 0 , progressMaxCount ) ; 
pm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; 
pm . setMillisToPopup ( millisToPopup ) ; 
taskThread = new Thread ( task ) ; 
taskThread . start ( ) ; 
ActionListener watcher = new ActionListener ( ) { 
public void actionPerformed ( ActionEvent evt ) { 
secs ++ ; 
if ( pm . isCanceled ( ) ) task . cancel ( ) ; 
else { 
String note = task . getNote ( ) ; 
pm . setNote ( note == null ? secs + " secs" : note ) ; 
int progress = task . getProgress ( ) ; 
pm . setProgress ( progress <= 0 ? secs : progress ) ; 
} 
if ( task . isDone ( ) ) { 
timer . stop ( ) ; 
pm . close ( ) ; 
if ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; 
if ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , "success" ) ) ; 
else if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , "error" ) ) ; 
else if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , "cancel" ) ) ; 
else fireEvent ( new ActionEvent ( this , 0 , "done" ) ) ; 
} 
} 
} 
; 
timer = new javax . swing . Timer ( 1000 , watcher ) ; 
timer . start ( ) ; 
} 
} 

public class GribCollectionMutable { 
void setIndexRaf ( RandomAccessFile indexRaf ) { 
this . indexRaf = indexRaf ; 
if ( indexRaf != null ) this . indexFilename = indexRaf . getLocation ( ) ; 
} 
} 

public class GempakSurfaceFileReader { 
protected void makeFileSubType ( ) { 
Key key = findKey ( GempakStation . SLAT ) ; 
if ( key == null ) throw new IllegalStateException ( "File does not have key=" + GempakStation . SLAT ) ; 
String latType = key . type ; 
Key dateKey = findKey ( DATE ) ; 
if ( dateKey != null && ! dateKey . type . equals ( latType ) ) if ( latType . equals ( ROW ) ) subType = CLIMATE ; 
else subType = STANDARD ; 
else subType = SHIP ; 
} 
} 

public class ChunkWriter { 
void sendDXR ( byte [ ] dxr8 ) throws IOException { 
if ( dxr8 == null || dxr8 . length == 0 ) return ; 
if ( mode == RequestMode . DMR || mode == RequestMode . DSR ) state = State . END ; 
else { 
int flags = DapUtil . CHUNK_DATA ; 
if ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; 
chunkheader ( dxr8 . length , flags , this . header ) ; 
output . write ( DapUtil . extract ( this . header ) ) ; 
state = State . DATA ; 
} 
output . write ( dxr8 ) ; 
output . flush ( ) ; 
} 
} 

public class ChunkWriter { 
public void writeError ( int httpcode , String msg , String cxt , String other ) throws IOException { 
dmr8 = null ; 
ErrorResponse response = new ErrorResponse ( httpcode , msg , cxt , other ) ; 
String errorbody = response . buildXML ( ) ; 
byte [ ] errbody8 = DapUtil . extract ( DapUtil . UTF8 . encode ( errorbody ) ) ; 
if ( mode == RequestMode . DMR ) sendDXR ( errbody8 ) ; 
else { 
chunk . clear ( ) ; 
int flags = DapUtil . CHUNK_ERROR | DapUtil . CHUNK_END ; 
chunkheader ( errbody8 . length , flags , header ) ; 
output . write ( DapUtil . extract ( header ) ) ; 
output . write ( errbody8 ) ; 
output . flush ( ) ; 
} 
state = State . ERROR ; 
} 
} 

public class ChunkWriter { 
public void close ( ) throws IOException { 
if ( closed ) return ; 
closed = true ; 
if ( dmr8 != null ) { 
sendDXR ( dmr8 ) ; 
dmr8 = null ; 
} 
if ( mode == RequestMode . DMR ) return ; 
if ( chunk == null || chunk . position ( ) == 0 ) return ; 
verifystate ( ) ; 
state = State . DATA ; 
int flags = DapUtil . CHUNK_END ; 
writeChunk ( flags ) ; 
state = State . END ; 
this . output . flush ( ) ; 
if ( this . saveoutput != null ) this . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; 
} 
} 

public class N3raf { 
protected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { 
long count = 0 ; 
if ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) while ( index . hasNext ( ) ) { 
Layout . Chunk chunk = index . next ( ) ; 
count += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; 
} 
else if ( dataType . getPrimitiveClassType ( ) == short . class ) while ( index . hasNext ( ) ) { 
Layout . Chunk chunk = index . next ( ) ; 
count += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; 
} 
else if ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) while ( index . hasNext ( ) ) { 
Layout . Chunk chunk = index . next ( ) ; 
count += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; 
} 
else if ( ( dataType == DataType . DOUBLE ) || dataType . getPrimitiveClassType ( ) == long . class ) while ( index . hasNext ( ) ) { 
Layout . Chunk chunk = index . next ( ) ; 
count += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; 
} 
return count ; 
} 
} 

public class DatasetTrackerChronicle { 
public static void cleanupBefore ( String pathname , long trackerNumber ) { 
for ( long tnum = trackerNumber - 1 ; 
tnum > 0 ; 
tnum -- ) { 
File oldDatabaseFile = new File ( pathname + datasetName + "." + tnum ) ; 
if ( ! oldDatabaseFile . exists ( ) ) break ; 
if ( oldDatabaseFile . delete ( ) ) catalogInitLog . info ( "DatasetTrackerChronicle deleted {} " , oldDatabaseFile . getAbsolutePath ( ) ) ; 
else catalogInitLog . error ( "DatasetTrackerChronicle not able to delete {} " , oldDatabaseFile . getAbsolutePath ( ) ) ; 
} 
} 
} 

public class McIDASAreaProjection { 
private double [ ] makeDoubleArray ( int [ ] ints ) { 
double [ ] newArray = new double [ ints . length ] ; 
for ( int i = 0 ; 
i < ints . length ; 
i ++ ) newArray [ i ] = ints [ i ] ; 
return newArray ; 
} 
} 

public class Dap4Controller { 
@ Override public String getResourcePath ( DapRequest drq , String location ) throws DapException { 
String realpath ; 
if ( TdsRequestedDataset . getDatasetManager ( ) != null ) realpath = TdsRequestedDataset . getLocationFromRequestPath ( location ) ; 
else { 
assert TdsRequestedDataset . getDatasetManager ( ) == null ; 
String prefix = drq . getResourceRoot ( ) ; 
assert ( prefix != null ) ; 
realpath = DapUtil . canonjoin ( prefix , location ) ; 
} 
if ( ! TESTING ) if ( ! TdsRequestedDataset . resourceControlOk ( drq . getRequest ( ) , drq . getResponse ( ) , realpath ) ) throw new DapException ( "Not authorized: " + location ) . setCode ( DapCodes . SC_FORBIDDEN ) ; 
File f = new File ( realpath ) ; 
if ( ! f . exists ( ) || ! f . canRead ( ) ) throw new DapException ( "Not found: " + location ) . setCode ( DapCodes . SC_NOT_FOUND ) ; 
return realpath ; 
} 
} 

public class GridIndexToNC { 
private void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { 
GridVertCoord gvcs0 = null ; 
int maxLevels = 0 ; 
for ( GridVertCoord gvcs : vertCoordList ) { 
if ( gvcs . getNLevels ( ) > maxLevels ) { 
gvcs0 = gvcs ; 
maxLevels = gvcs . getNLevels ( ) ; 
} 
} 
int seqno = 1 ; 
for ( GridVertCoord gvcs : vertCoordList ) { 
if ( gvcs != gvcs0 ) gvcs . setSequence ( seqno ++ ) ; 
gvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; 
} 
} 
} 

public class FysatHeader { 
boolean readPIB ( RandomAccessFile raf ) throws IOException { 
this . firstHeader = new AwxFileFirstHeader ( ) ; 
int pos = 0 ; 
raf . seek ( pos ) ; 
byte [ ] buf = new byte [ FY_AWX_PIB_LEN ] ; 
int count = raf . read ( buf ) ; 
EndianByteBuffer byteBuffer ; 
if ( count == FY_AWX_PIB_LEN ) { 
byteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; 
this . firstHeader . fillHeader ( byteBuffer ) ; 
} 
else return false ; 
if ( ! ( ( this . firstHeader . fileName . endsWith ( ".AWX" ) || this . firstHeader . fileName . endsWith ( ".awx" ) ) && this . firstHeader . firstHeaderLength == FY_AWX_PIB_LEN ) ) return false ; 
buf = new byte [ this . firstHeader . secondHeaderLength ] ; 
raf . readFully ( buf ) ; 
byteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; 
switch ( this . firstHeader . typeOfProduct ) { 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_UNDEFINED : throw new UnsupportedDatasetException ( ) ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_GEOSAT_IMAGE : secondHeader = new AwxFileGeoSatelliteSecondHeader ( ) ; 
secondHeader . fillHeader ( byteBuffer ) ; 
break ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_POLARSAT_IMAGE : throw new UnsupportedDatasetException ( ) ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRID : secondHeader = new AwxFileGridProductSecondHeader ( ) ; 
secondHeader . fillHeader ( byteBuffer ) ; 
break ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_DISCREET : throw new UnsupportedDatasetException ( ) ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRAPH_ANALIYSIS : throw new UnsupportedDatasetException ( ) ; 
} 
return true ; 
} 
} 

public class InvDatasetImpl { 
public boolean finish ( ) { 
boolean ok = true ; 
java . util . Iterator iter ; 
logger . debug ( "Now finish " + getName ( ) + " id= " + getID ( ) ) ; 
authorityName = null ; 
dataType = null ; 
dataFormatType = null ; 
defaultService = null ; 
gc = null ; 
tc = null ; 
docs = new ArrayList < > ( ) ; 
metadata = new ArrayList < > ( ) ; 
properties = new ArrayList < > ( ) ; 
creators = new ArrayList < > ( ) ; 
contributors = new ArrayList < > ( ) ; 
dates = new ArrayList < > ( ) ; 
keywords = new ArrayList < > ( ) ; 
projects = new ArrayList < > ( ) ; 
publishers = new ArrayList < > ( ) ; 
variables = new ArrayList < > ( ) ; 
canonicalize ( ) ; 
transfer2PublicMetadata ( tm , true ) ; 
transfer2PublicMetadata ( tmi , true ) ; 
transferInheritable2PublicMetadata ( ( InvDatasetImpl ) getParent ( ) ) ; 
access = new ArrayList < > ( ) ; 
if ( ( urlPath != null ) && ( getServiceDefault ( ) != null ) ) { 
InvAccessImpl a = new InvAccessImpl ( this , urlPath , getServiceDefault ( ) ) ; 
a . setSize ( size ) ; 
a . finish ( ) ; 
addExpandedAccess ( a ) ; 
} 
iter = accessLocal . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
InvAccessImpl a = ( InvAccessImpl ) iter . next ( ) ; 
a . finish ( ) ; 
addExpandedAccess ( a ) ; 
} 
if ( ! ( this instanceof InvCatalogRef ) ) for ( InvDataset invDataset : this . getDatasets ( ) ) { 
InvDatasetImpl curDs = ( InvDatasetImpl ) invDataset ; 
ok &= curDs . finish ( ) ; 
} 
return ok ; 
} 
} 

public class InvDatasetImpl { 
public boolean removeLocalMetadata ( InvMetadata metadata ) { 
InvDatasetImpl parentDataset = ( ( InvDatasetImpl ) metadata . getParentDataset ( ) ) ; 
List localMdata = parentDataset . getLocalMetadata ( ) . getMetadata ( ) ; 
if ( localMdata . contains ( metadata ) ) if ( localMdata . remove ( metadata ) ) { 
hashCode = 0 ; 
return ( true ) ; 
} 
return ( false ) ; 
} 
} 

public class DatasetNamer { 
boolean validate ( StringBuilder out ) { 
this . isValid = true ; 
if ( this . msgLog . length ( ) > 0 ) out . append ( this . msgLog ) ; 
if ( this . getName ( ) == null ) { 
this . isValid = false ; 
out . append ( " ** DatasetNamer (1): null value for name is not valid." ) ; 
} 
if ( this . getType ( ) == null ) { 
this . isValid = false ; 
out . append ( " ** DatasetNamer (3): null value for type is not valid (set with bad string?)." ) ; 
} 
if ( this . getType ( ) == DatasetNamerType . REGULAR_EXPRESSION && ( this . getMatchPattern ( ) == null || this . getSubstitutePattern ( ) == null ) ) { 
this . isValid = false ; 
out . append ( " ** DatasetNamer (4): invalid datasetNamer <" + this . getName ( ) + ">;" + " type is " + this . getType ( ) . toString ( ) + ": matchPattern(" + this . getMatchPattern ( ) + ") and substitutionPattern(" + this . getSubstitutePattern ( ) + ") " + "must not be null." ) ; 
} 
if ( this . getType ( ) == DatasetNamerType . DODS_ATTRIBUTE && ( this . getAttribContainer ( ) == null || this . getAttribName ( ) == null ) ) { 
this . isValid = false ; 
out . append ( " ** DatasetNamer (5): invalid datasetNamer <" + this . getName ( ) + ">;" + " type is " + this . getType ( ) . toString ( ) + ": attriuteContainer(" + this . getAttribContainer ( ) + ") and attributeName(" + this . getAttribName ( ) + ") must not be null." ) ; 
} 
return ( this . isValid ) ; 
} 
} 

public class WFSController { 
private WFSExceptionWriter getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName , String fullFtName ) { 
List < SimpleGeometry > geometryList = new ArrayList < SimpleGeometry > ( ) ; 
GeometryType geoT = sgcs . getGeometryType ( ftName ) ; 
if ( geoT == null ) return new WFSExceptionWriter ( "Feature Type of " + fullFtName + " not found." , "GetFeature" , "OperationProcessingFailed" ) ; 
try { 
switch ( geoT ) { 
case POINT : Point pt = sgcs . getPoint ( ftName , 0 ) ; 
int j = 0 ; 
while ( pt != null ) { 
geometryList . add ( pt ) ; 
j ++ ; 
pt = sgcs . getPoint ( ftName , j ) ; 
} 
break ; 
case LINE : Line line = sgcs . getLine ( ftName , 0 ) ; 
int k = 0 ; 
while ( line != null ) { 
geometryList . add ( line ) ; 
k ++ ; 
line = sgcs . getLine ( ftName , k ) ; 
} 
break ; 
case POLYGON : Polygon poly = sgcs . getPolygon ( ftName , 0 ) ; 
int i = 0 ; 
while ( poly != null ) { 
geometryList . add ( poly ) ; 
i ++ ; 
poly = sgcs . getPolygon ( ftName , i ) ; 
} 
break ; 
} 
} 
catch ( ArrayIndexOutOfBoundsException aout ) { 
} 
WFSGetFeatureWriter gfdw = new WFSGetFeatureWriter ( out , WFSController . constructServerPath ( hsreq ) , WFSController . getXMLNamespaceXMLNSValue ( hsreq ) , geometryList , ftName ) ; 
gfdw . startXML ( ) ; 
gfdw . writeMembers ( ) ; 
gfdw . finishXML ( ) ; 
return null ; 
} 
} 

public class WFSController { 
private WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { 
if ( service != null ) if ( ! service . equalsIgnoreCase ( "WFS" ) ) return new WFSExceptionWriter ( "WFS Server error. SERVICE parameter must be of value WFS." , "service" , "InvalidParameterValue" ) ; 
else return new WFSExceptionWriter ( "WFS server error. SERVICE parameter is required." , "request" , "MissingParameterValue" ) ; 
if ( request != null ) { 
if ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { 
if ( version != null ) { 
String [ ] versionParts = version . split ( "\\." ) ; 
for ( int ind = 0 ; 
ind < versionParts . length ; 
ind ++ ) try { 
Integer . valueOf ( versionParts [ ind ] ) ; 
} 
catch ( NumberFormatException excep ) { 
return new WFSExceptionWriter ( "WFS server error. VERSION parameter consists of invalid characters." , "version" , "InvalidParameterValue" ) ; 
} 
boolean validVersion = false ; 
if ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( "2" ) ) validVersion = true ; 
if ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( "2" ) && versionParts [ 1 ] . equals ( "0" ) ) validVersion = true ; 
if ( ! validVersion ) return new WFSExceptionWriter ( "WFS Server error. Version requested is not supported." , null , "VersionNegotiationFailed" ) ; 
} 
else return new WFSExceptionWriter ( "WFS server error. VERSION parameter is required." , "request" , "MissingParameterValue" ) ; 
if ( typeName == null ) return new WFSExceptionWriter ( "WFS server error. For the specifed request, parameter typename or typenames must be specified." , request , "MissingParameterValue" ) ; 
} 
WFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; 
if ( reqToProc == null ) return new WFSExceptionWriter ( "WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, " + "DescribeFeatureType, GetFeature" , "request" , "InvalidParameterValue" ) ; 
} 
else return new WFSExceptionWriter ( "WFS server error. REQUEST parameter is required." , "request" , "MissingParameterValue" ) ; 
return null ; 
} 
} 

public class WFSController { 
@ RequestMapping ( "**" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { 
try { 
PrintWriter wr = hsres . getWriter ( ) ; 
List < String > paramNames = new LinkedList < String > ( ) ; 
Enumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; 
while ( paramNamesE . hasMoreElements ( ) ) paramNames . add ( paramNamesE . nextElement ( ) ) ; 
String request = null ; 
String version = null ; 
String service = null ; 
String typeNames = null ; 
String datasetReqPath = null ; 
String actualPath = null ; 
String actualFTName = null ; 
NetcdfDataset dataset = null ; 
if ( hsreq . getServletPath ( ) . length ( ) > 4 ) datasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; 
actualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; 
if ( actualPath != null ) dataset = NetcdfDataset . openDataset ( actualPath ) ; 
else return ; 
List < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; 
SimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; 
for ( String paramName : paramNames ) { 
if ( paramName . equalsIgnoreCase ( "REQUEST" ) ) request = hsreq . getParameter ( paramName ) ; 
if ( paramName . equalsIgnoreCase ( "VERSION" ) ) version = hsreq . getParameter ( paramName ) ; 
if ( paramName . equalsIgnoreCase ( "SERVICE" ) ) service = hsreq . getParameter ( paramName ) ; 
if ( paramName . equalsIgnoreCase ( "TYPENAMES" ) || paramName . equalsIgnoreCase ( "TYPENAME" ) ) { 
typeNames = hsreq . getParameter ( paramName ) ; 
if ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) actualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; 
} 
} 
WFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; 
WFSExceptionWriter requestProcessingError = null ; 
if ( paramError == null ) { 
WFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; 
switch ( reqToProc ) { 
case GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; 
break ; 
case DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; 
break ; 
case GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; 
break ; 
} 
} 
else { 
paramError . write ( hsres ) ; 
return ; 
} 
if ( requestProcessingError != null ) { 
requestProcessingError . write ( hsres ) ; 
return ; 
} 
} 
catch ( IOException io ) { 
throw new RuntimeException ( "The writer may not have been able to been have retrieved" + " or the requested dataset was not found" , io ) ; 
} 
} 
} 

public class CrawlableDatasetAmazonS3 { 
@ Override public long length ( ) { 
S3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; 
if ( objectSummary != null ) return objectSummary . getSize ( ) ; 
ObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; 
if ( metadata != null ) return metadata . getContentLength ( ) ; 
else return 0 ; 
} 
} 

public class CrawlableDatasetAmazonS3 { 
@ Override public Date lastModified ( ) { 
S3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; 
if ( objectSummary != null ) return objectSummary . getLastModified ( ) ; 
ObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; 
if ( metadata != null ) return metadata . getLastModified ( ) ; 
else return null ; 
} 
} 

public class FeatureDatasetCapabilitiesWriter { 
public Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { 
List < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; 
DsgFeatureCollection fc = list . get ( 0 ) ; 
if ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) throw new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + " not a StationTimeSeriesFeatureCollection" ) ; 
StationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; 
Element rootElem = new Element ( "stationCollection" ) ; 
Document doc = new Document ( rootElem ) ; 
List < StationFeature > stations ; 
if ( bb != null ) stations = sobs . getStationFeatures ( bb ) ; 
else if ( names != null ) stations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; 
else stations = sobs . getStationFeatures ( ) ; 
for ( Station s : stations ) { 
Element sElem = new Element ( "station" ) ; 
sElem . setAttribute ( "name" , s . getName ( ) ) ; 
if ( s . getWmoId ( ) != null ) sElem . setAttribute ( "wmo_id" , s . getWmoId ( ) ) ; 
if ( ( s . getDescription ( ) != null ) && ( s . getDescription ( ) . length ( ) > 0 ) ) sElem . addContent ( new Element ( "description" ) . addContent ( s . getDescription ( ) ) ) ; 
sElem . addContent ( new Element ( "longitude" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; 
sElem . addContent ( new Element ( "latitide" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; 
if ( ! Double . isNaN ( s . getAltitude ( ) ) ) sElem . addContent ( new Element ( "altitude" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; 
rootElem . addContent ( sElem ) ; 
} 
return doc ; 
} 
} 

public class ComboBox { 
public void addItem ( Object item ) { 
if ( item == null ) return ; 
for ( int i = 0 ; 
i < getItemCount ( ) ; 
i ++ ) if ( item . equals ( getItemAt ( i ) ) ) { 
if ( i == 0 ) { 
setSelectedIndex ( 0 ) ; 
return ; 
} 
removeItemAt ( i ) ; 
} 
insertItemAt ( item , 0 ) ; 
setSelectedIndex ( 0 ) ; 
} 
} 

public class Odometer { 
public int step ( int firstpos , int lastpos ) { 
for ( int i = lastpos - 1 ; 
i >= firstpos ; 
i -- ) if ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; 
else { 
this . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; 
return i ; 
} 
return - 1 ; 
} 
} 

public class OptSwitch { 
public void SetHasValue ( int type ) { 
this . type = type ; 
if ( debug ) System . out . println ( "sw = " + ( char ) sw + "; type = " + type + "; set = " + set + "; val = " + val ) ; 
} 
} 

public class Grib1GdsPredefined { 
public static Grib1Gds factory ( int center , int gridNumber ) { 
if ( center == 7 ) return factoryNCEP ( gridNumber ) ; 
else throw new IllegalArgumentException ( "Dont have predefined GDS " + gridNumber + " from " + center ) ; 
} 
} 

public class IO { 
static public void copyDirTree ( String fromDirName , String toDirName ) throws IOException { 
File fromDir = new File ( fromDirName ) ; 
File toDir = new File ( toDirName ) ; 
if ( ! fromDir . exists ( ) ) return ; 
if ( ! toDir . exists ( ) ) if ( ! toDir . mkdirs ( ) ) throw new IOException ( "Could not create directory: " + toDir ) ; 
File [ ] files = fromDir . listFiles ( ) ; 
if ( files != null ) for ( File f : files ) { 
if ( f . isDirectory ( ) ) copyDirTree ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + "/" + f . getName ( ) ) ; 
else copyFile ( f . getAbsolutePath ( ) , toDir . getAbsolutePath ( ) + "/" + f . getName ( ) ) ; 
} 
} 
} 

public class DTSServlet { 
public void badURL ( HttpServletRequest request , HttpServletResponse response ) throws Exception { 
if ( Debug . isSet ( "showResponse" ) ) log . debug ( "Sending Bad URL Page." ) ; 
response . setContentType ( "text/html" ) ; 
response . setHeader ( "XDODS-Server" , getServerVersion ( ) ) ; 
response . setHeader ( "Content-Description" , "dods-error" ) ; 
PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( response . getOutputStream ( ) , Util . UTF8 ) ) ; 
printBadURLPage ( pw ) ; 
printHelpPage ( pw ) ; 
pw . flush ( ) ; 
response . setStatus ( HttpServletResponse . SC_OK ) ; 
} 
} 

public class StringUtil2 { 
static public String allow ( String x , String allowChars , char replaceChar ) { 
boolean ok = true ; 
for ( int pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x ) ; 
for ( int pos = 0 ; 
pos < sb . length ( ) ; 
pos ++ ) { 
char c = sb . charAt ( pos ) ; 
if ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) continue ; 
sb . setCharAt ( pos , replaceChar ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String filter ( String x , String okChars ) { 
boolean ok = true ; 
for ( int pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x . length ( ) ) ; 
for ( int pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) sb . append ( c ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String filter7bits ( String s ) { 
if ( s == null ) return null ; 
char [ ] bo = new char [ s . length ( ) ] ; 
int count = 0 ; 
for ( int i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\n' ) || ( c == '\t' ) ) ) bo [ count ++ ] = c ; 
} 
return new String ( bo , 0 , count ) ; 
} 
} 

public class StringUtil2 { 
static public int match ( String s1 , String s2 ) { 
int i = 0 ; 
while ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { 
if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) break ; 
i ++ ; 
} 
return i ; 
} 
} 

public class StringUtil2 { 
public static String padLeft ( String s , int desiredLength , String padString ) { 
while ( s . length ( ) < desiredLength ) s = padString + s ; 
return s ; 
} 
} 

public class StringUtil2 { 
public static String padRight ( String s , int desiredLength , String padString ) { 
StringBuilder ret = new StringBuilder ( s ) ; 
while ( ret . length ( ) < desiredLength ) ret . append ( padString ) ; 
return ret . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String remove ( String s , String sub ) { 
int len = sub . length ( ) ; 
int pos ; 
while ( 0 <= ( pos = s . indexOf ( sub ) ) ) s = s . substring ( 0 , pos ) + s . substring ( pos + len ) ; 
return s ; 
} 
} 

public class StringUtil2 { 
static public String remove ( String s , int c ) { 
if ( 0 > s . indexOf ( c ) ) return s ; 
StringBuilder buff = new StringBuilder ( s ) ; 
int i = 0 ; 
while ( i < buff . length ( ) ) if ( buff . charAt ( i ) == c ) buff . deleteCharAt ( i ) ; 
else i ++ ; 
return buff . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String collapseWhitespace ( String s ) { 
int len = s . length ( ) ; 
StringBuilder b = new StringBuilder ( len ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( ! Character . isWhitespace ( c ) ) b . append ( c ) ; 
else { 
b . append ( ' ' ) ; 
while ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) i ++ ; 
} 
} 
return b . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String replace ( String s , char out , String in ) { 
if ( s . indexOf ( out ) < 0 ) return s ; 
StringBuilder sb = new StringBuilder ( s ) ; 
replace ( sb , out , in ) ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { 
boolean ok = true ; 
for ( char aReplaceChar : replaceChar ) { 
int pos = x . indexOf ( aReplaceChar ) ; 
ok = ( pos < 0 ) ; 
if ( ! ok ) break ; 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x ) ; 
for ( int i = 0 ; 
i < replaceChar . length ; 
i ++ ) { 
int pos = x . indexOf ( replaceChar [ i ] ) ; 
if ( pos >= 0 ) replace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String substitute ( String original , String [ ] match , String [ ] subst ) { 
boolean ok = true ; 
for ( String aMatch : match ) { 
if ( original . contains ( aMatch ) ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) return original ; 
StringBuilder sb = new StringBuilder ( original ) ; 
for ( int i = 0 ; 
i < match . length ; 
i ++ ) substitute ( sb , match [ i ] , subst [ i ] ) ; 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public void remove ( StringBuilder sb , String out ) { 
int i = 0 ; 
while ( i < sb . length ( ) ) { 
int c = sb . charAt ( i ) ; 
boolean ok = true ; 
for ( int j = 0 ; 
j < out . length ( ) ; 
j ++ ) if ( out . charAt ( j ) == c ) { 
sb . delete ( i , i + 1 ) ; 
ok = false ; 
break ; 
} 
if ( ok ) i ++ ; 
} 
} 
} 

public class StringUtil2 { 
static public void replace ( StringBuilder sb , String out , String in ) { 
for ( int i = 0 ; 
i < sb . length ( ) ; 
i ++ ) { 
int c = sb . charAt ( i ) ; 
for ( int j = 0 ; 
j < out . length ( ) ; 
j ++ ) if ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; 
} 
} 
} 

public class StringUtil2 { 
static public String trim ( String s , int bad ) { 
int len = s . length ( ) ; 
int st = 0 ; 
while ( ( st < len ) && ( s . charAt ( st ) == bad ) ) st ++ ; 
while ( ( st < len ) && ( s . charAt ( len - 1 ) == bad ) ) len -- ; 
return ( ( st > 0 ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; 
} 
} 

public class TableAnalyzer { 
static public TableAnalyzer factory ( TableConfigurer tc , FeatureType wantFeatureType , NetcdfDataset ds ) throws IOException { 
TableAnalyzer analyzer = new TableAnalyzer ( ds , tc ) ; 
if ( tc != null ) { 
if ( tc . getConvName ( ) == null ) analyzer . userAdvice . format ( " No 'Conventions' global attribute.%n" ) ; 
else analyzer . userAdvice . format ( " Conventions global attribute = %s %n" , tc . getConvName ( ) ) ; 
if ( tc . getConvUsed ( ) != null ) { 
analyzer . setConventionUsed ( tc . getConvUsed ( ) ) ; 
if ( ! tc . getConvUsed ( ) . equals ( tc . getConvName ( ) ) ) analyzer . userAdvice . format ( " TableConfigurer used = " + tc . getConvUsed ( ) + ".%n" ) ; 
} 
} 
else analyzer . userAdvice . format ( " No TableConfigurer found, using default analysis.%n" ) ; 
analyzer . analyze ( wantFeatureType ) ; 
return analyzer ; 
} 
} 

public class McIDASGridServiceProvider { 
public boolean sync ( ) { 
try { 
if ( ! mcGridReader . init ( ) ) return false ; 
GridIndex index = mcGridReader . getGridIndex ( ) ; 
ncfile . empty ( ) ; 
open ( index , null ) ; 
return true ; 
} 
catch ( IOException ioe ) { 
return false ; 
} 
} 
} 

public class GradsUtil { 
public static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { 
double [ ] baseArray = null ; 
start -- ; 
if ( type . equalsIgnoreCase ( GAUST62 ) ) baseArray = gltst62 ; 
else if ( type . equalsIgnoreCase ( GAUSR15 ) ) baseArray = glts15 ; 
else if ( type . equalsIgnoreCase ( GAUSR20 ) ) baseArray = glts20 ; 
else if ( type . equalsIgnoreCase ( GAUSR30 ) ) baseArray = glts30 ; 
else if ( type . equalsIgnoreCase ( GAUSR40 ) ) baseArray = glats ; 
else throw new IllegalArgumentException ( "Unsupported type: " + type ) ; 
if ( start + num > baseArray . length ) throw new IllegalArgumentException ( "Maximum " + baseArray . length + " latitudes exceeded" ) ; 
double [ ] retVals = new double [ num ] ; 
for ( int i = 0 ; 
i < num ; 
i ++ ) retVals [ i ] = baseArray [ start + i ] ; 
return retVals ; 
} 
} 

public class CSMConvention { 
protected void findCoordinateAxes ( NetcdfDataset ds ) { 
for ( VarProcess vp : varList ) { 
if ( vp . coordAxes == null ) { 
String coordsString = ds . findAttValueIgnoreCase ( vp . v , CF . COORDINATES , null ) ; 
if ( coordsString != null ) vp . coordinates = coordsString ; 
} 
} 
super . findCoordinateAxes ( ds ) ; 
} 
} 

public class Group { 
public void addDimension ( Dimension dim ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
if ( ! dim . isShared ( ) ) throw new IllegalArgumentException ( "Dimensions added to a group must be shared." ) ; 
if ( findDimensionLocal ( dim . getShortName ( ) ) != null ) throw new IllegalArgumentException ( "Dimension name (" + dim . getShortName ( ) + ") must be unique within Group " + getShortName ( ) ) ; 
dimensions . add ( dim ) ; 
dim . setGroup ( this ) ; 
} 
} 

public class Group { 
public boolean addDimensionIfNotExists ( Dimension dim ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
if ( ! dim . isShared ( ) ) throw new IllegalArgumentException ( "Dimensions added to a group must be shared." ) ; 
if ( findDimensionLocal ( dim . getShortName ( ) ) != null ) return false ; 
dimensions . add ( dim ) ; 
dim . setGroup ( this ) ; 
return true ; 
} 
} 

public class Group { 
public void addVariable ( Variable v ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
if ( v == null ) return ; 
if ( findVariable ( v . getShortName ( ) ) != null ) throw new IllegalArgumentException ( "Variable name (" + v . getShortName ( ) + ") must be unique within Group " + getShortName ( ) ) ; 
variables . add ( v ) ; 
v . setParentGroup ( this ) ; 
} 
} 

public class DDS { 
private String convertDDSAliasFieldsToDASAliasFields ( String attribute ) throws MalformedAliasException { 
String prefix = "" ; 
Vector aNames = tokenizeAliasField ( attribute ) ; 
String topName = ( String ) aNames . get ( 1 ) ; 
boolean foundIt = false ; 
Enumeration e = getVariables ( ) ; 
while ( e . hasMoreElements ( ) ) { 
BaseType bt = ( BaseType ) e . nextElement ( ) ; 
String normName = normalize ( bt . getEncodedName ( ) ) ; 
if ( topName . equals ( normName ) ) foundIt = true ; 
} 
if ( ! foundIt ) prefix = "." + getLooseEndsTableName ( ) ; 
return ( prefix + attribute ) ; 
} 
} 

public class GeotiffWriter { 
public void writeGrid ( GridDataset dataset , GridDatatype grid , Array data , boolean greyScale ) throws IOException { 
GridCoordSystem gcs = grid . getCoordinateSystem ( ) ; 
if ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( "Must have 1D x and y axes for " + grid . getFullName ( ) ) ; 
CoordinateAxis1D xaxis = ( CoordinateAxis1D ) gcs . getXHorizAxis ( ) ; 
CoordinateAxis1D yaxis = ( CoordinateAxis1D ) gcs . getYHorizAxis ( ) ; 
double scaler = ( xaxis . getUnitsString ( ) . equalsIgnoreCase ( "km" ) ) ? 1000.0 : 1.0 ; 
double xStart = xaxis . getCoordEdge ( 0 ) * scaler ; 
double yStart = yaxis . getCoordEdge ( 0 ) * scaler ; 
double xInc = xaxis . getIncrement ( ) * scaler ; 
double yInc = Math . abs ( yaxis . getIncrement ( ) ) * scaler ; 
if ( yaxis . getCoordValue ( 0 ) < yaxis . getCoordValue ( 1 ) ) { 
data = data . flip ( 0 ) ; 
yStart = yaxis . getCoordEdge ( ( int ) yaxis . getSize ( ) ) * scaler ; 
} 
if ( ! xaxis . isRegular ( ) || ! yaxis . isRegular ( ) ) throw new IllegalArgumentException ( "Must be evenly spaced grid = " + grid . getFullName ( ) ) ; 
if ( pageNumber > 1 ) geotiff . initTags ( ) ; 
writeGrid ( grid , data , greyScale , xStart , yStart , xInc , yInc , pageNumber ) ; 
pageNumber ++ ; 
} 
} 

public class GeotiffWriter { 
private ArrayFloat replaceMissingValues ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { 
float minValue = ( float ) ( dataMinMax . min - 1.0 ) ; 
ArrayFloat floatArray = ( ArrayFloat ) Array . factory ( DataType . FLOAT , data . getShape ( ) ) ; 
IndexIterator dataIter = data . getIndexIterator ( ) ; 
IndexIterator floatIter = floatArray . getIndexIterator ( ) ; 
while ( dataIter . hasNext ( ) ) { 
float v = dataIter . getFloatNext ( ) ; 
if ( grid . isMissing ( ( double ) v ) ) v = minValue ; 
floatIter . setFloatNext ( v ) ; 
} 
return floatArray ; 
} 
} 

public class GeotiffWriter { 
private ArrayByte replaceMissingValuesAndScale ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { 
double scale = 254.0 / ( dataMinMax . max - dataMinMax . min ) ; 
ArrayByte byteArray = ( ArrayByte ) Array . factory ( DataType . BYTE , data . getShape ( ) ) ; 
IndexIterator dataIter = data . getIndexIterator ( ) ; 
IndexIterator resultIter = byteArray . getIndexIterator ( ) ; 
byte bv ; 
while ( dataIter . hasNext ( ) ) { 
double v = dataIter . getDoubleNext ( ) ; 
if ( grid . isMissing ( v ) ) bv = 0 ; 
else { 
int iv = ( int ) ( ( v - dataMinMax . min ) * scale + 1 ) ; 
bv = ( byte ) ( iv & 0xff ) ; 
} 
resultIter . setByteNext ( bv ) ; 
} 
return byteArray ; 
} 
} 

public class GeotiffWriter { 
private double geoShiftGetXstart ( Array lon , double inc ) { 
Index ilon = lon . getIndex ( ) ; 
int [ ] lonShape = lon . getShape ( ) ; 
IndexIterator lonIter = lon . getIndexIterator ( ) ; 
double xlon = 0.0 ; 
LatLonPoint p0 = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( 0 ) ) ) ; 
LatLonPoint pN = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( lonShape [ 0 ] - 1 ) ) ) ; 
xlon = p0 . getLongitude ( ) ; 
while ( lonIter . hasNext ( ) ) { 
float l = lonIter . getFloatNext ( ) ; 
LatLonPoint pn = new LatLonPointImpl ( 0 , l ) ; 
if ( pn . getLongitude ( ) < xlon ) xlon = pn . getLongitude ( ) ; 
} 
if ( p0 . getLongitude ( ) == pN . getLongitude ( ) ) xlon = xlon - inc ; 
return xlon ; 
} 
} 

public class GeotiffWriter { 
public void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { 
CoverageCoordSys gcs = array . getCoordSysForData ( ) ; 
if ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( "Must have 1D x and y axes for " + array . getCoverageName ( ) ) ; 
Projection proj = gcs . getProjection ( ) ; 
CoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; 
CoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; 
double scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( "km" ) ) ? 1000.0 : 1.0 ; 
double xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; 
double yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; 
double xInc = xaxis . getResolution ( ) * scaler ; 
double yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; 
Array data = array . getData ( ) . reduce ( ) ; 
if ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { 
data = data . flip ( 0 ) ; 
yStart = yaxis . getCoordEdgeLast ( ) ; 
} 
if ( pageNumber > 1 ) geotiff . initTags ( ) ; 
int nextStart = 0 ; 
MAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; 
if ( greyScale ) { 
ArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; 
nextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; 
} 
else { 
ArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; 
nextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; 
} 
int height = data . getShape ( ) [ 0 ] ; 
int width = data . getShape ( ) [ 1 ] ; 
writeMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; 
pageNumber ++ ; 
} 
} 

public class GribCdmIndex { 
public static boolean updateGribCollection ( FeatureCollectionConfig config , CollectionUpdateType updateType , Logger logger ) throws IOException { 
if ( logger == null ) logger = classLogger ; 
long start = System . currentTimeMillis ( ) ; 
Formatter errlog = new Formatter ( ) ; 
CollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; 
Path rootPath = Paths . get ( specp . getRootDir ( ) ) ; 
boolean isGrib1 = config . type == FeatureCollectionType . GRIB1 ; 
boolean changed ; 
if ( config . ptype == FeatureCollectionConfig . PartitionType . none || config . ptype == FeatureCollectionConfig . PartitionType . all ) try ( CollectionAbstract dcm = new CollectionPathMatcher ( config , specp , logger ) ) { 
changed = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . none , logger , errlog ) ; 
} 
else if ( config . ptype == FeatureCollectionConfig . PartitionType . timePeriod ) try ( TimePartition tp = new TimePartition ( config , specp , logger ) ) { 
changed = updateTimePartition ( isGrib1 , tp , updateType , logger ) ; 
} 
else if ( specp . wantSubdirs ( ) ) try ( DirectoryPartition dpart = new DirectoryPartition ( config , rootPath , true , new GribCdmIndex ( logger ) , NCX_SUFFIX , logger ) ) { 
dpart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; 
changed = updateDirectoryCollectionRecurse ( isGrib1 , dpart , config , updateType , logger ) ; 
} 
else changed = updateLeafCollection ( isGrib1 , config , updateType , true , logger , rootPath ) ; 
long took = System . currentTimeMillis ( ) - start ; 
logger . info ( "updateGribCollection {} changed {} took {} msecs" , config . collectionName , changed , took ) ; 
return changed ; 
} 
} 

public class GribCdmIndex { 
private static boolean updateLeafCollection ( boolean isGrib1 , FeatureCollectionConfig config , CollectionUpdateType updateType , boolean isTop , Logger logger , Path dirPath ) throws IOException { 
if ( config . ptype == FeatureCollectionConfig . PartitionType . file ) return updateFilePartition ( isGrib1 , config , updateType , isTop , logger , dirPath ) ; 
else { 
Formatter errlog = new Formatter ( ) ; 
CollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; 
try ( DirectoryCollection dcm = new DirectoryCollection ( config . collectionName , dirPath , isTop , config . olderThan , logger ) ) { 
dcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; 
if ( specp . getFilter ( ) != null ) dcm . setStreamFilter ( new StreamFilter ( specp . getFilter ( ) , specp . getFilterOnName ( ) ) ) ; 
boolean changed = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . directory , logger , errlog ) ; 
logger . debug ( "  GribCdmIndex.updateDirectoryPartition was updated=%s on %s%n" , changed , dirPath ) ; 
return changed ; 
} 
} 
} 
} 

public class GribCdmIndex { 
public static GribCollectionImmutable openGribCollectionFromRaf ( RandomAccessFile raf , FeatureCollectionConfig config , CollectionUpdateType updateType , org . slf4j . Logger logger ) throws IOException { 
GribCollectionImmutable result ; 
boolean isGrib1 = false ; 
boolean isGrib2 = Grib2RecordScanner . isValidFile ( raf ) ; 
if ( ! isGrib2 ) isGrib1 = Grib1RecordScanner . isValidFile ( raf ) ; 
if ( isGrib1 || isGrib2 ) { 
result = openGribCollectionFromDataFile ( isGrib1 , raf , config , updateType , null , logger ) ; 
raf . close ( ) ; 
} 
else result = openGribCollectionFromIndexFile ( raf , config , logger ) ; 
return result ; 
} 
} 

public class RC { 
static void setWellKnown ( ) { 
if ( dfaltRC . triplestore . size ( ) == 0 ) return ; 
for ( String key : dfaltRC . keySet ( ) ) { 
Triple triple = dfaltRC . lookup ( key ) ; 
if ( triple . url == null ) RC . set ( key , triple . value ) ; 
} 
} 
} 

public class RC { 
public boolean load ( String abspath ) { 
abspath = abspath . replace ( '\\' , '/' ) ; 
File rcFile = new File ( abspath ) ; 
if ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) return false ; 
if ( showlog ) log . debug ( "Loading rc file: " + abspath ) ; 
try ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { 
for ( int lineno = 1 ; 
; 
lineno ++ ) { 
URL url = null ; 
String line = rdr . readLine ( ) ; 
if ( line == null ) break ; 
line = line . trim ( ) ; 
if ( line . length ( ) == 0 ) continue ; 
if ( line . charAt ( 0 ) == '#' ) continue ; 
if ( line . charAt ( 0 ) == LTAG ) { 
int rindex = line . indexOf ( RTAG ) ; 
if ( rindex < 0 ) return false ; 
if ( showlog ) log . error ( "Malformed [url] at " + abspath + "." + lineno ) ; 
String surl = line . substring ( 1 , rindex ) ; 
try { 
url = new URL ( surl ) ; 
} 
catch ( MalformedURLException mue ) { 
if ( showlog ) log . error ( "Malformed [url] at " + abspath + "." + lineno ) ; 
} 
line = line . substring ( rindex + 1 ) ; 
line = line . trim ( ) ; 
} 
String [ ] pieces = line . split ( "\\s*=\\s*" ) ; 
assert ( pieces . length == 1 || pieces . length == 2 ) ; 
String value = "1" ; 
if ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; 
Triple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; 
List < Triple > list = triplestore . get ( triple . key ) ; 
if ( list == null ) list = new ArrayList < Triple > ( ) ; 
Triple prev = addtriple ( list , triple ) ; 
triplestore . put ( triple . key , list ) ; 
} 
} 
catch ( FileNotFoundException fe ) { 
if ( showlog ) log . debug ( "Loading rc file: " + abspath ) ; 
return false ; 
} 
catch ( IOException ioe ) { 
if ( showlog ) log . error ( "File " + abspath + ": IO exception: " + ioe . getMessage ( ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class GisFeatureRendererMulti { 
protected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { 
long startTime = System . currentTimeMillis ( ) ; 
if ( featSetList == null ) { 
initFeatSetList ( ) ; 
assert ! featSetList . isEmpty ( ) ; 
} 
FeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; 
if ( featSetList . size ( ) > 1 ) { 
double scale = 1.0 ; 
try { 
AffineTransform world2device = g . getTransform ( ) ; 
AffineTransform world2normal = normal2device . createInverse ( ) ; 
world2normal . concatenate ( world2device ) ; 
scale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; 
if ( Debug . isSet ( "GisFeature/showTransform" ) ) System . out . println ( "GisFeature/showTransform: " + world2normal + "\n scale = " + scale ) ; 
} 
catch ( java . awt . geom . NoninvertibleTransformException e ) { 
System . out . println ( " GisRenderFeature: NoninvertibleTransformException on " + normal2device ) ; 
} 
if ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; 
double minD = Double . MAX_VALUE ; 
for ( Object aFeatSetList : featSetList ) { 
FeatureSet tryfs = ( FeatureSet ) aFeatSetList ; 
double d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; 
if ( d < minD ) { 
minD = d ; 
fs = tryfs ; 
} 
} 
if ( Debug . isSet ( "GisFeature/MapResolution" ) ) System . out . println ( "GisFeature/MapResolution: scale = " + scale + " minDist = " + fs . minDist ) ; 
} 
if ( fs . featureList == null ) fs . createFeatures ( ) ; 
if ( ! displayProject . equals ( fs . project ) ) fs . setProjection ( displayProject ) ; 
else if ( fs . newProjection && displayProject . isLatLon ( ) ) fs . setProjection ( displayProject ) ; 
fs . newProjection = false ; 
if ( Debug . isSet ( "GisFeature/timing/getShapes" ) ) { 
long tookTime = System . currentTimeMillis ( ) - startTime ; 
System . out . println ( "timing.getShapes: " + tookTime * .001 + " seconds" ) ; 
} 
return fs . getShapes ( ) ; 
} 
} 

public class GisFeatureRendererMulti { 
private ArrayList makeShapes ( Iterator featList ) { 
Shape shape ; 
ArrayList shapeList = new ArrayList ( ) ; 
ProjectionImpl dataProject = getDataProjection ( ) ; 
if ( Debug . isSet ( "GisFeature/MapDraw" ) ) System . out . println ( "GisFeature/MapDraw: makeShapes with " + displayProject ) ; 
while ( featList . hasNext ( ) ) { 
AbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; 
if ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; 
else if ( dataProject == displayProject ) shape = feature . getShape ( ) ; 
else shape = feature . getProjectedShape ( dataProject , displayProject ) ; 
shapeList . add ( shape ) ; 
} 
return shapeList ; 
} 
} 

public class EnsCoord { 
static public void normalize ( EnsCoord result , List < EnsCoord > ecList ) { 
List < EnsCoord > extra = new ArrayList < > ( ) ; 
for ( EnsCoord ec : ecList ) { 
if ( ! result . equalsData ( ec ) ) extra . add ( ec ) ; 
} 
if ( extra . size ( ) == 0 ) return ; 
for ( EnsCoord ec : extra ) { 
if ( ec . getNEnsembles ( ) < result . getNEnsembles ( ) ) continue ; 
result = ec ; 
} 
} 
} 

public class ArrayStructure { 
public Object getScalarObject ( int recno , StructureMembers . Member m ) { 
DataType dataType = m . getDataType ( ) ; 
if ( dataType == DataType . DOUBLE ) return getScalarDouble ( recno , m ) ; 
else if ( dataType == DataType . FLOAT ) return getScalarFloat ( recno , m ) ; 
else if ( dataType . getPrimitiveClassType ( ) == byte . class ) return getScalarByte ( recno , m ) ; 
else if ( dataType . getPrimitiveClassType ( ) == short . class ) return getScalarShort ( recno , m ) ; 
else if ( dataType . getPrimitiveClassType ( ) == int . class ) return getScalarInt ( recno , m ) ; 
else if ( dataType . getPrimitiveClassType ( ) == long . class ) return getScalarLong ( recno , m ) ; 
else if ( dataType == DataType . CHAR ) return getScalarString ( recno , m ) ; 
else if ( dataType == DataType . STRING ) return getScalarString ( recno , m ) ; 
else if ( dataType == DataType . STRUCTURE ) return getScalarStructure ( recno , m ) ; 
else if ( dataType == DataType . OPAQUE ) { 
ArrayObject data = ( ArrayObject ) m . getDataArray ( ) ; 
return data . getObject ( recno * m . getSize ( ) ) ; 
} 
throw new RuntimeException ( "Dont have implementation for " + dataType ) ; 
} 
} 

public class CEConstraint { 
static public CEConstraint compile ( String sce , DapDataset dmr ) throws DapException { 
if ( sce == null || sce . length ( ) == 0 ) return CEConstraint . getUniversal ( dmr ) ; 
CEParserImpl ceparser = new CEParserImpl ( dmr ) ; 
if ( PARSEDEBUG ) ceparser . setDebugLevel ( 1 ) ; 
if ( DEBUG ) System . err . println ( "Dap4Servlet: parsing constraint: |" + sce + "|" ) ; 
boolean ok ; 
try { 
ok = ceparser . parse ( sce ) ; 
} 
catch ( ParseException pe ) { 
ok = false ; 
} 
if ( ! ok ) throw new DapException ( "Constraint parse failed: " + sce ) ; 
CEAST root = ceparser . getCEAST ( ) ; 
CECompiler compiler = new CECompiler ( ) ; 
CEConstraint ce = compiler . compile ( dmr , root ) ; 
ce . expand ( ) ; 
ce . finish ( ) ; 
return ce ; 
} 
} 

public class Grib2Iosp { 
@ Override public boolean isValidFile ( RandomAccessFile raf ) throws IOException { 
if ( raf instanceof HTTPRandomAccessFile ) if ( raf . length ( ) > raf . getBufferSize ( ) ) return false ; 
else { 
GribCdmIndex . GribCollectionType type = GribCdmIndex . getType ( raf ) ; 
if ( type == GribCdmIndex . GribCollectionType . GRIB2 ) return true ; 
if ( type == GribCdmIndex . GribCollectionType . Partition2 ) return true ; 
} 
return Grib2RecordScanner . isValidFile ( raf ) ; 
} 
} 

public class GempakFileReader { 
public int getByteOrder ( int kmachn ) { 
if ( ( kmachn == MTVAX ) || ( kmachn == MTULTX ) || ( kmachn == MTALPH ) || ( kmachn == MTLNUX ) || ( kmachn == MTIGPH ) ) return RandomAccessFile . LITTLE_ENDIAN ; 
return RandomAccessFile . BIG_ENDIAN ; 
} 
} 

public class GempakFileReader { 
void setByteOrder ( ) { 
String arch = System . getProperty ( "os.arch" ) ; 
if ( arch . equals ( "x86" ) || arch . equals ( "arm" ) || arch . equals ( "x86_64" ) || arch . equals ( "amd64" ) || arch . equals ( "alpha" ) ) MTMACH = RandomAccessFile . LITTLE_ENDIAN ; 
else MTMACH = RandomAccessFile . BIG_ENDIAN ; 
} 
} 

public class GempakFileReader { 
public Key findKey ( String name ) { 
if ( keys == null ) return null ; 
for ( Key key : keys . kkrow ) { 
if ( key . name . equals ( name ) ) return key ; 
} 
for ( Key key : keys . kkcol ) { 
if ( key . name . equals ( name ) ) return key ; 
} 
return null ; 
} 
} 

public class GempakFileReader { 
public DMFileHeaderInfo findFileHeader ( String name ) { 
if ( ( fileHeaderInfo == null ) || fileHeaderInfo . isEmpty ( ) ) return null ; 
for ( DMFileHeaderInfo fhi : fileHeaderInfo ) { 
if ( name . equals ( fhi . kfhnam ) ) return fhi ; 
} 
return null ; 
} 
} 

public class GempakFileReader { 
public float [ ] getFileHeader ( String name ) throws IOException { 
DMFileHeaderInfo fh = findFileHeader ( name ) ; 
if ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) return null ; 
int knt = fileHeaderInfo . indexOf ( fh ) ; 
int iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; 
for ( int i = 0 ; 
i < knt ; 
i ++ ) { 
DMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; 
iread = iread + fhi . kfhlen + 1 ; 
} 
int nword = DM_RINT ( iread ) ; 
if ( nword <= 0 ) { 
logError ( "Invalid header length for " + name ) ; 
return null ; 
} 
iread ++ ; 
float [ ] rheader = new float [ nword ] ; 
if ( name . equals ( "NAVB" ) && needToSwap ) { 
DM_RFLT ( iread , 1 , rheader , 0 ) ; 
needToSwap = false ; 
iread ++ ; 
DM_RFLT ( iread , 1 , rheader , 1 ) ; 
needToSwap = true ; 
iread ++ ; 
DM_RFLT ( iread , nword - 2 , rheader , 2 ) ; 
} 
else DM_RFLT ( iread , rheader ) ; 
return rheader ; 
} 
} 

public class GempakFileReader { 
public void printParts ( ) { 
if ( parts == null ) return ; 
for ( int i = 0 ; 
i < parts . size ( ) ; 
i ++ ) { 
System . out . println ( "\nParts[" + i + "]:" ) ; 
System . out . println ( parts . get ( i ) ) ; 
} 
} 
} 

public class GempakFileReader { 
public float DM_RFLT ( int word ) throws IOException { 
if ( rf == null ) throw new IOException ( "DM_RFLT: no file to read from" ) ; 
if ( dmLabel == null ) throw new IOException ( "DM_RFLT: reader not initialized" ) ; 
rf . seek ( getOffset ( word ) ) ; 
if ( needToSwap ) rf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; 
else rf . order ( RandomAccessFile . BIG_ENDIAN ) ; 
float rdata = rf . readFloat ( ) ; 
if ( RMISSD != dmLabel . smissd ) if ( Math . abs ( rdata - dmLabel . smissd ) < RDIFFD ) rdata = RMISSD ; 
rf . order ( RandomAccessFile . BIG_ENDIAN ) ; 
return rdata ; 
} 
} 

public class GempakFileReader { 
public String DM_RSTR ( int isword , int nchar ) throws IOException { 
if ( rf == null ) throw new IOException ( "DM_RSTR: no file to read from" ) ; 
rf . seek ( getOffset ( isword ) ) ; 
return rf . readString ( nchar ) ; 
} 
} 

public class GempakFileReader { 
public float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { 
int nparms = part . kparms ; 
int nwordp = part . kwordp ; 
int npack = ( ibitst . length - 1 ) / nwordp + 1 ; 
if ( npack * nwordp != ibitst . length ) return null ; 
float [ ] data = new float [ nparms * npack ] ; 
PackingInfo pkinf = part . packInfo ; 
int ir = 0 ; 
int ii = 0 ; 
for ( int pack = 0 ; 
pack < npack ; 
pack ++ ) { 
int [ ] jdata = new int [ nwordp ] ; 
System . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; 
for ( int idata = 0 ; 
idata < nparms ; 
idata ++ ) { 
int jbit = pkinf . nbitsc [ idata ] ; 
int jsbit = pkinf . isbitc [ idata ] ; 
int jshift = 1 - jsbit ; 
int jsword = pkinf . iswrdc [ idata ] ; 
int jword = jdata [ jsword ] ; 
int mask = mskpat >>> ( 32 - jbit ) ; 
int ifield = jword >>> Math . abs ( jshift ) ; 
ifield = ifield & mask ; 
if ( ( jsbit + jbit - 1 ) > 32 ) { 
jword = jdata [ jsword + 1 ] ; 
jshift = jshift + 32 ; 
int iword = jword << jshift ; 
iword = iword & mask ; 
ifield = ifield | iword ; 
} 
if ( ifield == pkinf . imissc [ idata ] ) data [ ir + idata ] = RMISSD ; 
else data [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; 
} 
ir += nparms ; 
ii += nwordp ; 
} 
return data ; 
} 
} 

public class GempakFileReader { 
protected static String getBits ( int b ) { 
Formatter s = new Formatter ( ) ; 
for ( int i = 31 ; 
i >= 0 ; 
i -- ) { 
if ( ( b & ( 1 << i ) ) != 0 ) s . format ( "1" ) ; 
else s . format ( "0" ) ; 
if ( i % 8 == 0 ) s . format ( "|" ) ; 
} 
return s . toString ( ) ; 
} 
} 

public class DDSXMLParser { 
private void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { 
parseLevel ++ ; 
String type = e . getName ( ) ; 
if ( type . equals ( "Attribute" ) ) { 
} 
else if ( type . equals ( "Alias" ) ) { 
} 
else if ( type . equals ( "dataBLOB" ) ) { 
org . jdom2 . Attribute hrefAttr = e . getAttribute ( "href" ) ; 
String contentID = hrefAttr . getValue ( ) ; 
if ( _Debug ) System . out . println ( "Found dataBLOB element. contentID=\"" + contentID + "\"" ) ; 
dds . setBlobContentID ( contentID ) ; 
} 
else { 
if ( _Debug ) System . out . println ( "Parsing new BaseType element. Parse level: " + parseLevel ) ; 
if ( _Debug ) showXMLElement ( e , indent ) ; 
BaseType bt = newBaseType ( e ) ; 
parentDC . addVariable ( bt ) ; 
if ( bt instanceof DConstructor ) { 
DConstructor myParentDC = parentDC ; 
parentDC = ( DConstructor ) bt ; 
try { 
if ( bt instanceof DGrid ) parseGrid ( e , indent ) ; 
else for ( Element child : e . getChildren ( ) ) { 
parseBase ( child , indent + "    " ) ; 
} 
} 
finally { 
parentDC = myParentDC ; 
} 
} 
else if ( bt instanceof DArray ) { 
if ( _Debug ) System . out . println ( "Parsing Array instance.  Array name: '" + bt . getClearName ( ) + "'" ) ; 
parseArray ( e , ( DArray ) bt , indent ) ; 
} 
} 
parseLevel -- ; 
} 
} 

public class DDSXMLParser { 
private void parseAliases ( Element e , String indent ) throws DASException { 
parseLevel ++ ; 
String subIndent = indent + "    " ; 
if ( _Debug ) System . out . println ( indent + "Parsing Aliases: " ) ; 
if ( _Debug ) System . out . println ( subIndent + "currentBT: " + currentBT . getTypeName ( ) + " " + currentBT . getClearName ( ) ) ; 
for ( Element aliasElement : e . getChildren ( "Alias" , opendapNameSpace ) ) { 
String name = null ; 
Attribute nameAttr = aliasElement . getAttribute ( "name" ) ; 
name = nameAttr . getValue ( ) ; 
String attributeName = null ; 
Attribute attributeAttr = aliasElement . getAttribute ( "Attribute" ) ; 
attributeName = attributeAttr . getValue ( ) ; 
if ( _Debug ) System . out . println ( subIndent + "The name '" + name + "' is aliased to dds attribute: '" + attributeName + "'" ) ; 
if ( currentAT == null ) currentBT . addAttributeAlias ( name , attributeName ) ; 
else currentAT . addAlias ( name , attributeName ) ; 
} 
parseLevel -- ; 
} 
} 

public class DataDescriptorTreeConstructor { 
private List < DataDescriptor > decode ( List < Short > keyDesc , BufrTableLookup lookup ) { 
if ( keyDesc == null ) return null ; 
List < DataDescriptor > keys = new ArrayList < DataDescriptor > ( ) ; 
for ( short id : keyDesc ) { 
DataDescriptor dd = new DataDescriptor ( id , lookup ) ; 
keys . add ( dd ) ; 
if ( dd . f == 3 ) { 
TableD . Descriptor tdd = lookup . getDescriptorTableD ( dd . fxy ) ; 
if ( tdd == null || tdd . getSequence ( ) == null ) dd . bad = true ; 
else { 
dd . name = tdd . getName ( ) ; 
dd . subKeys = decode ( tdd . getSequence ( ) , lookup ) ; 
} 
} 
} 
return keys ; 
} 
} 

public class DataDescriptorTreeConstructor { 
private List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { 
List < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; 
Iterator < DataDescriptor > dkIter = keys . iterator ( ) ; 
while ( dkIter . hasNext ( ) ) { 
DataDescriptor dk = dkIter . next ( ) ; 
if ( dk . f == 1 ) { 
dk . subKeys = new ArrayList < DataDescriptor > ( ) ; 
dk . replication = dk . y ; 
if ( dk . replication == 0 ) { 
root . isVarLength = true ; 
DataDescriptor replication = dkIter . next ( ) ; 
if ( replication . y == 0 ) dk . replicationCountSize = 1 ; 
else if ( replication . y == 1 ) dk . replicationCountSize = 8 ; 
else if ( replication . y == 2 ) dk . replicationCountSize = 16 ; 
else if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; 
else if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; 
else log . error ( "Unknown replication type= " + replication ) ; 
} 
for ( int j = 0 ; 
j < dk . x && dkIter . hasNext ( ) ; 
j ++ ) dk . subKeys . add ( dkIter . next ( ) ) ; 
dk . subKeys = replicate ( dk . subKeys ) ; 
} 
else if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) dk . subKeys = replicate ( dk . subKeys ) ; 
tree . add ( dk ) ; 
} 
return tree ; 
} 
} 

public class GempakSurfaceIOSP { 
public String getCFFeatureType ( ) { 
if ( gemreader . getFileSubType ( ) . equals ( GempakSurfaceFileReader . SHIP ) ) return CF . FeatureType . point . toString ( ) ; 
return CF . FeatureType . timeSeries . toString ( ) ; 
} 
} 

public class Tools { 
public static void probeObject ( Object o ) { 
Class c = o . getClass ( ) ; 
Class interfaces [ ] = c . getInterfaces ( ) ; 
Class parent = c . getSuperclass ( ) ; 
Method m [ ] = c . getMethods ( ) ; 
System . out . println ( "********* OBJECT PROBE *********" ) ; 
System . out . println ( "Class Name:  " + c . getName ( ) ) ; 
System . out . println ( "Super Class: " + parent . getName ( ) ) ; 
System . out . println ( "Interfaces: " ) ; 
for ( int i = 0 ; 
i < interfaces . length ; 
i ++ ) System . out . println ( "    " + interfaces [ i ] . getName ( ) ) ; 
System . out . println ( "Methods:" ) ; 
for ( int i = 0 ; 
i < m . length ; 
i ++ ) { 
Class params [ ] = m [ i ] . getParameterTypes ( ) ; 
Class excepts [ ] = m [ i ] . getExceptionTypes ( ) ; 
Class ret = m [ i ] . getReturnType ( ) ; 
System . out . print ( "    " + ret . getName ( ) + "  " + m [ i ] . getName ( ) + "(" ) ; 
for ( int j = 0 ; 
j < params . length ; 
j ++ ) { 
if ( j > 0 ) System . out . print ( ", " ) ; 
System . out . print ( params [ j ] . getName ( ) ) ; 
} 
System . out . print ( ")  throws " ) ; 
for ( int j = 0 ; 
j < excepts . length ; 
j ++ ) { 
if ( j > 0 ) System . out . print ( ", " ) ; 
System . out . print ( excepts [ j ] . getName ( ) ) ; 
} 
System . out . println ( "" ) ; 
} 
System . out . println ( "******************" ) ; 
} 
} 

public class CoordinateTimeAbstract { 
public CoordinateTimeAbstract makeBestFromComplete ( ) { 
int [ ] best = new int [ time2runtime . length ] ; 
int last = - 1 ; 
int count = 0 ; 
for ( int i = 0 ; 
i < time2runtime . length ; 
i ++ ) { 
int time = time2runtime [ i ] ; 
if ( time >= last ) { 
last = time ; 
best [ i ] = time ; 
count ++ ; 
} 
else best [ i ] = - 1 ; 
} 
return makeBestFromComplete ( best , count ) ; 
} 
} 

public class Attribute { 
protected void writeCDL ( Formatter f , boolean strict , String parentname ) { 
if ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( "string " ) ; 
if ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; 
f . format ( ":" ) ; 
f . format ( "%s" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; 
if ( isString ( ) ) { 
f . format ( " = " ) ; 
for ( int i = 0 ; 
i < getLength ( ) ; 
i ++ ) { 
if ( i != 0 ) f . format ( ", " ) ; 
String val = getStringValue ( i ) ; 
if ( val != null ) f . format ( "\"%s\"" , encodeString ( val ) ) ; 
} 
} 
else if ( getEnumType ( ) != null ) { 
f . format ( " = " ) ; 
for ( int i = 0 ; 
i < getLength ( ) ; 
i ++ ) { 
if ( i != 0 ) f . format ( ", " ) ; 
EnumTypedef en = getEnumType ( ) ; 
String econst = getStringValue ( i ) ; 
Integer ecint = en . lookupEnumInt ( econst ) ; 
if ( ecint == null ) throw new ForbiddenConversionException ( "Illegal enum constant: " + econst ) ; 
f . format ( "\"%s\"" , encodeString ( econst ) ) ; 
} 
} 
else { 
f . format ( " = " ) ; 
for ( int i = 0 ; 
i < getLength ( ) ; 
i ++ ) { 
if ( i != 0 ) f . format ( ", " ) ; 
Number number = getNumericValue ( i ) ; 
if ( dataType . isUnsigned ( ) ) number = DataType . widenNumber ( number ) ; 
f . format ( "%s" , number ) ; 
if ( dataType . isUnsigned ( ) ) f . format ( "U" ) ; 
if ( dataType == DataType . FLOAT ) f . format ( "f" ) ; 
else if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) f . format ( "S" ) ; 
else if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) f . format ( "B" ) ; 
else if ( dataType == DataType . LONG || dataType == DataType . ULONG ) f . format ( "L" ) ; 
} 
} 
} 
} 

public class Attribute { 
public void setValues ( List values ) { 
if ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( "Cannot determine attribute's type" ) ; 
int n = values . size ( ) ; 
Class c = values . get ( 0 ) . getClass ( ) ; 
Object pa ; 
if ( c == String . class ) { 
String [ ] va = new String [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( String ) values . get ( i ) ; 
} 
else if ( c == Integer . class ) { 
int [ ] va = new int [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Integer ) values . get ( i ) ; 
} 
else if ( c == Double . class ) { 
double [ ] va = new double [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Double ) values . get ( i ) ; 
} 
else if ( c == Float . class ) { 
float [ ] va = new float [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Float ) values . get ( i ) ; 
} 
else if ( c == Short . class ) { 
short [ ] va = new short [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Short ) values . get ( i ) ; 
} 
else if ( c == Byte . class ) { 
byte [ ] va = new byte [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Byte ) values . get ( i ) ; 
} 
else if ( c == Long . class ) { 
long [ ] va = new long [ n ] ; 
pa = va ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Long ) values . get ( i ) ; 
} 
else throw new IllegalArgumentException ( "Unknown type for Attribute = " + c . getName ( ) ) ; 
setValues ( Array . factory ( this . dataType , new int [ ] { 
n } 
, pa ) ) ; 
} 
} 

public class MessageWriter { 
void scheduleWrite ( Message m ) { 
q . add ( m ) ; 
if ( ! isScheduled . getAndSet ( true ) ) executor . submit ( this ) ; 
} 
} 

public class ToolsUI { 
private void jumptoThreddsDatatype ( thredds . client . catalog . Access invAccess ) { 
if ( invAccess == null ) return ; 
thredds . client . catalog . Service s = invAccess . getService ( ) ; 
if ( s . getType ( ) == ServiceType . HTTPServer ) { 
downloadFile ( invAccess . getStandardUrlName ( ) ) ; 
return ; 
} 
if ( s . getType ( ) == ServiceType . WMS ) { 
openWMSDataset ( invAccess . getStandardUrlName ( ) ) ; 
return ; 
} 
if ( s . getType ( ) == ServiceType . CdmrFeature ) { 
openCoverageDataset ( invAccess . getWrappedUrlName ( ) ) ; 
return ; 
} 
thredds . client . catalog . Dataset ds = invAccess . getDataset ( ) ; 
if ( ds . getFeatureType ( ) == null ) { 
try { 
openNetcdfFile ( threddsDataFactory . openDataset ( invAccess , true , null , null ) ) ; 
} 
catch ( IOException ioe ) { 
JOptionPane . showMessageDialog ( null , "Error on setThreddsDatatype = " + ioe . getMessage ( ) ) ; 
} 
return ; 
} 
DataFactory . Result threddsData = null ; 
try { 
threddsData = threddsDataFactory . openFeatureDataset ( invAccess , null ) ; 
if ( threddsData . fatalError ) { 
JOptionPane . showMessageDialog ( null , "Failed to open err=" + threddsData . errLog ) ; 
return ; 
} 
jumptoThreddsDatatype ( threddsData ) ; 
} 
catch ( IOException ioe ) { 
ioe . printStackTrace ( ) ; 
JOptionPane . showMessageDialog ( null , "Error on setThreddsDatatype = " + ioe . getMessage ( ) ) ; 
if ( threddsData != null ) try { 
threddsData . close ( ) ; 
} 
catch ( IOException ioe2 ) { 
} 
} 
} 
} 

public class ToolsUI { 
private void jumptoThreddsDatatype ( DataFactory . Result threddsData ) { 
if ( threddsData . fatalError ) { 
JOptionPane . showMessageDialog ( this , "Cant open dataset=" + threddsData . errLog ) ; 
try { 
threddsData . close ( ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
return ; 
} 
if ( threddsData . featureType . isCoverageFeatureType ( ) ) if ( threddsData . featureDataset instanceof FeatureDatasetCoverage ) { 
makeComponent ( ftTabPane , "Coverages" ) ; 
coveragePanel . setDataset ( threddsData . featureDataset ) ; 
tabbedPane . setSelectedComponent ( ftTabPane ) ; 
ftTabPane . setSelectedComponent ( coveragePanel ) ; 
} 
else if ( threddsData . featureDataset instanceof GridDataset ) { 
makeComponent ( ftTabPane , "Grids" ) ; 
gridPanel . setDataset ( ( GridDataset ) threddsData . featureDataset ) ; 
tabbedPane . setSelectedComponent ( ftTabPane ) ; 
ftTabPane . setSelectedComponent ( gridPanel ) ; 
} 
else if ( threddsData . featureType == FeatureType . IMAGE ) { 
makeComponent ( ftTabPane , "Images" ) ; 
imagePanel . setImageLocation ( threddsData . imageURL ) ; 
tabbedPane . setSelectedComponent ( ftTabPane ) ; 
ftTabPane . setSelectedComponent ( imagePanel ) ; 
} 
else if ( threddsData . featureType == FeatureType . RADIAL ) { 
makeComponent ( ftTabPane , "Radial" ) ; 
radialPanel . setDataset ( ( RadialDatasetSweep ) threddsData . featureDataset ) ; 
tabbedPane . setSelectedComponent ( ftTabPane ) ; 
ftTabPane . setSelectedComponent ( radialPanel ) ; 
} 
else if ( threddsData . featureType . isPointFeatureType ( ) ) { 
makeComponent ( ftTabPane , "PointFeature" ) ; 
pointFeaturePanel . setPointFeatureDataset ( ( PointDatasetImpl ) threddsData . featureDataset ) ; 
tabbedPane . setSelectedComponent ( ftTabPane ) ; 
ftTabPane . setSelectedComponent ( pointFeaturePanel ) ; 
} 
else if ( threddsData . featureType == FeatureType . STATION_RADIAL ) { 
makeComponent ( ftTabPane , "StationRadial" ) ; 
stationRadialPanel . setStationRadialDataset ( threddsData . featureDataset ) ; 
tabbedPane . setSelectedComponent ( ftTabPane ) ; 
ftTabPane . setSelectedComponent ( stationRadialPanel ) ; 
} 
} 
} 

public class ToolsUI { 
private static void prepareGui ( ) { 
final String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; 
final boolean isMacOs = osName . startsWith ( "mac os x" ) ; 
if ( isMacOs ) { 
System . setProperty ( "apple.laf.useScreenMenuBar" , "true" ) ; 
Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { 
@ Override public void run ( ) { 
doSavePrefsAndUI ( ) ; 
} 
} 
) ; 
} 
else try { 
for ( UIManager . LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { 
if ( "Nimbus" . equals ( info . getName ( ) ) ) { 
UIManager . setLookAndFeel ( info . getClassName ( ) ) ; 
break ; 
} 
} 
} 
catch ( Exception exc ) { 
log . warn ( "Unable to apply Nimbus look-and-feel due to {}" , exc . toString ( ) ) ; 
if ( log . isTraceEnabled ( ) ) exc . printStackTrace ( ) ; 
} 
BAMutil . setResourcePath ( "/resources/nj22/ui/icons/" ) ; 
SwingUtilities . invokeLater ( ( ) -> { 
final Toolkit tk = Toolkit . getDefaultToolkit ( ) ; 
final Font f = new Font ( "SansSerif" , Font . PLAIN , 12 ) ; 
@ SuppressWarnings ( "deprecation" ) final FontMetrics fm = tk . getFontMetrics ( f ) ; 
} 
) ; 
} 
} 

public class ToolsUI { 
private static void createToolsFrame ( ) { 
frame = new JFrame ( "NetCDF (" + DIALOG_VERSION + ") Tools" ) ; 
ui = new ToolsUI ( prefs , frame ) ; 
frame . setIconImage ( BAMutil . getImage ( "netcdfUI" ) ) ; 
frame . addWindowListener ( new WindowAdapter ( ) { 
@ Override public void windowActivated ( final WindowEvent e ) { 
ToolsSplashScreen . getSharedInstance ( ) . setVisible ( false ) ; 
} 
@ Override public void windowClosing ( final WindowEvent e ) { 
if ( ! done ) exit ( ) ; 
} 
} 
) ; 
frame . getContentPane ( ) . add ( ui ) ; 
final Rectangle have = frame . getGraphicsConfiguration ( ) . getBounds ( ) ; 
final Rectangle def = new Rectangle ( 50 , 50 , 800 , 800 ) ; 
Rectangle want = ( Rectangle ) prefs . getBean ( FRAME_SIZE , def ) ; 
if ( want . getX ( ) > have . getWidth ( ) - 25 ) want = def ; 
frame . setBounds ( want ) ; 
frame . pack ( ) ; 
frame . setBounds ( want ) ; 
if ( wantDataset != null ) setDataset ( ) ; 
} 
} 

public class BeanTable { 
protected void restoreState ( ) { 
if ( store == null ) return ; 
ArrayList propColObjs = ( ArrayList ) store . getBean ( "propertyCol" , new ArrayList ( ) ) ; 
HidableTableColumnModel tableColumnModel = ( HidableTableColumnModel ) jtable . getColumnModel ( ) ; 
int newViewIndex = 0 ; 
for ( Object propColObj : propColObjs ) { 
PropertyCol propCol = ( PropertyCol ) propColObj ; 
try { 
int currentViewIndex = tableColumnModel . getColumnIndex ( propCol . getName ( ) ) ; 
TableColumn column = tableColumnModel . getColumn ( currentViewIndex ) ; 
column . setPreferredWidth ( propCol . getWidth ( ) ) ; 
tableColumnModel . moveColumn ( currentViewIndex , newViewIndex ) ; 
assert tableColumnModel . getColumn ( newViewIndex ) == column : "tableColumn wasn't successfully moved." ; 
tableColumnModel . setColumnVisible ( column , propCol . isVisible ( ) ) ; 
if ( propCol . isVisible ( ) ) ++ newViewIndex ; 
} 
catch ( IllegalArgumentException e ) { 
logger . debug ( String . format ( "Column named \"%s\" was present in the preferences file but not the dataset." , propCol . getName ( ) ) , e ) ; 
} 
} 
} 
} 

public class NestedTable { 
private CoordVarExtractor findCoordinateAxis ( Table . CoordName coordName , Table t , int nestingLevel ) { 
if ( t == null ) return null ; 
String axisName = t . findCoordinateVariableName ( coordName ) ; 
if ( axisName != null ) { 
VariableDS v = t . findVariable ( axisName ) ; 
if ( v != null ) return new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; 
if ( t . extraJoins != null ) for ( Join j : t . extraJoins ) { 
v = j . findVariable ( axisName ) ; 
if ( v != null ) return new CoordVarExtractorVariable ( v , axisName , nestingLevel ) ; 
} 
if ( t instanceof Table . TableSingleton ) { 
Table . TableSingleton ts = ( Table . TableSingleton ) t ; 
return new CoordVarStructureData ( axisName , ts . sdata ) ; 
} 
if ( t instanceof Table . TableTop ) { 
v = ( VariableDS ) ds . findVariable ( axisName ) ; 
if ( v != null ) return new CoordVarTop ( v ) ; 
else return new CoordVarConstant ( coordName . toString ( ) , "" , axisName ) ; 
} 
errlog . format ( "NestedTable: cant find variable '%s' for coordinate type %s %n" , axisName , coordName ) ; 
} 
return findCoordinateAxis ( coordName , t . parent , nestingLevel + 1 ) ; 
} 
} 

public class ClauseFactory { 
public TopLevelClause newBoolFunctionClause ( String functionName , List children ) throws DAP2ServerSideException , NoSuchFunctionException { 
BoolFunction function = functionLibrary . getBoolFunction ( functionName ) ; 
if ( function == null ) if ( functionLibrary . getBTFunction ( functionName ) != null ) throw new NoSuchFunctionException ( "The function " + functionName + "() does not return a " + "boolean value, and must be used in a comparison or " + "as an argument to another function." ) ; 
else throw new NoSuchFunctionException ( "This server does not support a " + functionName + "() function" ) ; 
return new BoolFunctionClause ( function , children ) ; 
} 
} 

public class ClauseFactory { 
public SubClause newBTFunctionClause ( String functionName , List children ) throws DAP2ServerSideException , NoSuchFunctionException { 
BTFunction function = functionLibrary . getBTFunction ( functionName ) ; 
if ( function == null ) if ( functionLibrary . getBoolFunction ( functionName ) != null ) throw new NoSuchFunctionException ( "The function " + functionName + "() cannot be used as a " + "sub-expression in a constraint clause" ) ; 
else throw new NoSuchFunctionException ( "This server does not support a " + functionName + "() function" ) ; 
return new BTFunctionClause ( function , children ) ; 
} 
} 

public class CatalogCrawler { 
public void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { 
boolean isCatRef = ( ds instanceof InvCatalogRef ) ; 
if ( filter != null && filter . skipAll ( ds ) ) { 
if ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; 
return ; 
} 
boolean isDataScan = ds . findProperty ( "DatasetScan" ) != null ; 
if ( isCatRef ) { 
InvCatalogRef catref = ( InvCatalogRef ) ds ; 
if ( out != null ) out . println ( " **CATREF " + catref . getURI ( ) + " (" + ds . getName ( ) + ") " ) ; 
countCatrefs ++ ; 
if ( ! listen . getCatalogRef ( catref , context ) ) { 
if ( release ) catref . release ( ) ; 
return ; 
} 
} 
if ( ! isCatRef || isDataScan ) listen . getDataset ( ds , context ) ; 
List < InvDataset > dlist = ds . getDatasets ( ) ; 
if ( isCatRef ) { 
InvCatalogRef catref = ( InvCatalogRef ) ds ; 
if ( ! isDataScan ) listen . getDataset ( catref . getProxyDataset ( ) , context ) ; 
} 
for ( InvDataset dds : dlist ) { 
crawlDataset ( dds , task , out , context , release ) ; 
if ( ( task != null ) && task . isCancel ( ) ) break ; 
} 
if ( isCatRef && release ) { 
InvCatalogRef catref = ( InvCatalogRef ) ds ; 
catref . release ( ) ; 
} 
} 
} 

public class CatalogCrawler { 
public void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { 
boolean isCatRef = ( ds instanceof InvCatalogRef ) ; 
if ( filter != null && filter . skipAll ( ds ) ) { 
if ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; 
return ; 
} 
if ( isCatRef ) { 
InvCatalogRef catref = ( InvCatalogRef ) ds ; 
if ( out != null ) out . println ( " **CATREF " + catref . getURI ( ) + " (" + ds . getName ( ) + ") " ) ; 
countCatrefs ++ ; 
if ( ! listen . getCatalogRef ( catref , context ) ) { 
if ( release ) catref . release ( ) ; 
return ; 
} 
} 
List < InvDataset > dlist = ds . getDatasets ( ) ; 
List < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; 
for ( InvDataset dds : dlist ) { 
if ( dds . hasAccess ( ) ) leaves . add ( dds ) ; 
} 
if ( leaves . size ( ) > 0 ) if ( type == Type . first_direct ) { 
InvDataset dds = leaves . get ( 0 ) ; 
listen . getDataset ( dds , context ) ; 
} 
else if ( type == Type . random_direct ) listen . getDataset ( chooseRandom ( leaves ) , context ) ; 
else if ( type == Type . random_direct_middle ) listen . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; 
else for ( InvDataset dds : leaves ) { 
listen . getDataset ( dds , context ) ; 
if ( ( task != null ) && task . isCancel ( ) ) break ; 
} 
for ( InvDataset dds : dlist ) { 
if ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; 
if ( ( task != null ) && task . isCancel ( ) ) break ; 
} 
if ( ds instanceof InvCatalogRef && release ) { 
InvCatalogRef catref = ( InvCatalogRef ) ds ; 
catref . release ( ) ; 
} 
} 
} 

public class RandomAccessFile { 
public synchronized void close ( ) throws IOException { 
if ( cache != null ) if ( cacheState > 0 ) if ( cacheState == 1 ) { 
cacheState = 2 ; 
if ( cache . release ( this ) ) return ; 
cacheState = 0 ; 
} 
else return ; 
if ( debugLeaks ) { 
openFiles . remove ( location ) ; 
if ( showOpen ) System . out . println ( "  close " + location ) ; 
} 
if ( file == null ) return ; 
flush ( ) ; 
long fileSize = file . length ( ) ; 
if ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) file . setLength ( minLength ) ; 
file . close ( ) ; 
file = null ; 
} 
} 

public class RandomAccessFile { 
public int read ( ) throws IOException { 
if ( filePosition < dataEnd ) { 
int pos = ( int ) ( filePosition - bufferStart ) ; 
filePosition ++ ; 
return ( buffer [ pos ] & 0xff ) ; 
} 
else if ( endOfFile ) return - 1 ; 
else { 
seek ( filePosition ) ; 
return read ( ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void readShort ( short [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) pa [ start + i ] = readShort ( ) ; 
} 
} 

public class RandomAccessFile { 
public final int readIntUnbuffered ( long pos ) throws IOException { 
byte [ ] bb = new byte [ 4 ] ; 
read_ ( pos , bb , 0 , 4 ) ; 
int ch1 = bb [ 0 ] & 0xff ; 
int ch2 = bb [ 1 ] & 0xff ; 
int ch3 = bb [ 2 ] & 0xff ; 
int ch4 = bb [ 3 ] & 0xff ; 
if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) throw new EOFException ( ) ; 
if ( bigEndian ) return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; 
else return ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; 
} 
} 

public class RandomAccessFile { 
public final void readInt ( int [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) pa [ start + i ] = readInt ( ) ; 
} 
} 

public class RandomAccessFile { 
public final void readLong ( long [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) pa [ start + i ] = readLong ( ) ; 
} 
} 

public class RandomAccessFile { 
public final void readFloat ( float [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) pa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; 
} 
} 

public class RandomAccessFile { 
public final void readDouble ( double [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) pa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeBoolean ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeShort ( short [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeShort ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeChar ( char [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeChar ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeInt ( int [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeInt ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeLong ( long [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeLong ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeFloat ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { 
for ( int i = 0 ; 
i < n ; 
i ++ ) writeDouble ( pa [ start + i ] ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeBytes ( String s ) throws IOException { 
int len = s . length ( ) ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) write ( ( byte ) s . charAt ( i ) ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeBytes ( char b [ ] , int off , int len ) throws IOException { 
for ( int i = off ; 
i < len ; 
i ++ ) write ( ( byte ) b [ i ] ) ; 
} 
} 

public class DirectoryBuilder { 
static public MCollection factory ( FeatureCollectionConfig config , Path topDir , boolean isTop , IndexReader indexReader , String suffix , org . slf4j . Logger logger ) throws IOException { 
DirectoryBuilder builder = new DirectoryBuilder ( config . collectionName , topDir . toString ( ) , suffix ) ; 
DirectoryPartition dpart = new DirectoryPartition ( config , topDir , isTop , indexReader , suffix , logger ) ; 
if ( ! builder . isLeaf ( indexReader ) ) return dpart ; 
boolean hasIndex = builder . findIndex ( ) ; 
if ( hasIndex ) return dpart . makeChildCollection ( builder ) ; 
else { 
DirectoryCollection result = new DirectoryCollection ( config . collectionName , topDir , isTop , config . olderThan , logger ) ; 
return result ; 
} 
} 
} 

public class DirectoryBuilder { 
public List < DirectoryBuilder > constructChildren ( IndexReader indexReader , CollectionUpdateType forceCollection ) throws IOException { 
if ( childrenConstructed ) return children ; 
if ( index != null && forceCollection == CollectionUpdateType . nocheck ) constructChildrenFromIndex ( indexReader , false ) ; 
else scanForChildren ( ) ; 
partitionStatus = ( children . size ( ) > 0 ) ? PartitionStatus . isDirectoryPartition : PartitionStatus . isLeaf ; 
childrenConstructed = true ; 
return children ; 
} 
} 

public class FileCache { 
@ Override public boolean release ( FileCacheable ncfile ) throws IOException { 
if ( ncfile == null ) return false ; 
if ( disabled . get ( ) ) { 
ncfile . setFileCache ( null ) ; 
ncfile . close ( ) ; 
return false ; 
} 
CacheElement . CacheFile file = files . get ( ncfile ) ; 
if ( file != null ) { 
if ( ! file . isLocked . get ( ) ) cacheLog . warn ( "FileCache " + name + " release " + ncfile . getLocation ( ) + " not locked; hash= " + ncfile . hashCode ( ) ) ; 
file . lastAccessed = System . currentTimeMillis ( ) ; 
file . countAccessed ++ ; 
file . isLocked . set ( false ) ; 
file . ncfile . release ( ) ; 
if ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( "FileCache " + name + " release " + ncfile . getLocation ( ) + "; hash= " + ncfile . hashCode ( ) ) ; 
if ( debugPrint ) System . out . printf ( "  FileCache %s release %s lock=%s count=%d%n" , name , ncfile . getLocation ( ) , file . isLocked . get ( ) , countLocked ( ) ) ; 
return true ; 
} 
return false ; 
} 
} 

public class GridCoordSys { 
void makeVerticalTransform ( GridDataset gds , Formatter parseInfo ) { 
if ( vt != null ) return ; 
if ( vCT == null ) return ; 
vt = vCT . makeVerticalTransform ( gds . getNetcdfDataset ( ) , timeDim ) ; 
if ( vt == null ) if ( parseInfo != null ) parseInfo . format ( "  - ERR can't make VerticalTransform = %s%n" , vCT . getVerticalTransformType ( ) ) ; 
else if ( parseInfo != null ) parseInfo . format ( "  - VerticalTransform = %s%n" , vCT . getVerticalTransformType ( ) ) ; 
} 
} 

public class GridCoordSys { 
@ Override public boolean isZPositive ( ) { 
if ( vertZaxis == null ) return false ; 
if ( vertZaxis . getPositive ( ) != null ) return vertZaxis . getPositive ( ) . equalsIgnoreCase ( ucar . nc2 . constants . CF . POSITIVE_UP ) ; 
if ( vertZaxis . getAxisType ( ) == AxisType . Height ) return true ; 
return vertZaxis . getAxisType ( ) != AxisType . Pressure ; 
} 
} 

public class TdsDownloader { 
public void getRemoteFiles ( final CancelTask _cancel ) { 
this . cancel = _cancel ; 
String urls = config . getServerPrefix ( ) + "/thredds/admin/log/" + type + "/" ; 
ta . append ( String . format ( "Download URL = %s%n" , urls ) ) ; 
String contents = null ; 
try ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { 
int statusCode = method . execute ( ) ; 
if ( statusCode == 200 ) contents = method . getResponseAsString ( ) ; 
if ( ( contents == null ) || ( contents . length ( ) == 0 ) ) { 
ta . append ( String . format ( "Failed to get logs at URL = %s%n%n" , urls ) ) ; 
return ; 
} 
else ta . append ( String . format ( "Logs at URL = %s%n%s%n" , urls , contents ) ) ; 
} 
catch ( Throwable t ) { 
ta . append ( String . format ( "Failed to get logs at URL = %s error = %s%n%n" , urls , t . getMessage ( ) ) ) ; 
t . printStackTrace ( ) ; 
return ; 
} 
final String list = contents ; 
SwingWorker worker = new SwingWorker < String , Void > ( ) { 
@ Override protected String doInBackground ( ) throws Exception { 
try { 
ta . append ( String . format ( "Local log files stored in = %s%n%n" , localDir ) ) ; 
String [ ] lines = list . split ( "\n" ) ; 
for ( String line : lines ) { 
new RemoteLog ( line . trim ( ) ) ; 
if ( cancel . isCancel ( ) ) break ; 
} 
} 
catch ( Throwable t ) { 
t . printStackTrace ( ) ; 
} 
return null ; 
} 
public void done ( ) { 
if ( cancel . isCancel ( ) ) ta . append ( String . format ( "Download was cancelled for %s%n" , type ) ) ; 
else ta . append ( String . format ( "Download complete for %s%n" , type ) ) ; 
} 
} 
; 
worker . execute ( ) ; 
} 
} 

public class CalendarPeriod { 
public double getConvertFactor ( CalendarPeriod from ) { 
if ( field == CalendarPeriod . Field . Month || field == CalendarPeriod . Field . Year ) log . warn ( " CalendarDate.convert on Month or Year" ) ; 
return ( double ) from . millisecs ( ) / millisecs ( ) ; 
} 
} 

public class CoordinateSharerBest { 
public List < Integer > reindex ( List < Coordinate > coords ) { 
List < Integer > result = new ArrayList < > ( ) ; 
for ( Coordinate coord : coords ) { 
Coordinate sub = swap . get ( coord ) ; 
Coordinate use = ( sub == null ) ? coord : sub ; 
Integer idx = indexMap . get ( use ) ; 
if ( idx == null ) throw new IllegalStateException ( ) ; 
result . add ( idx ) ; 
} 
return result ; 
} 
} 

public class OffsetUnit { 
public double toDerivedUnit ( final double amount ) throws ConversionException { 
if ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( this , getDerivedUnit ( ) ) ; 
return ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( amount + getOffset ( ) ) ; 
} 
} 

public class OffsetUnit { 
public double fromDerivedUnit ( final double amount ) throws ConversionException { 
if ( ! ( _unit instanceof DerivableUnit ) ) throw new ConversionException ( getDerivedUnit ( ) , this ) ; 
return ( ( DerivableUnit ) getUnit ( ) ) . fromDerivedUnit ( amount ) - getOffset ( ) ; 
} 
} 

public class ConvertD2N { 
public Array convertTopVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV ) throws IOException , DAP2Exception { 
Array data = convert ( dataV ) ; 
if ( ( dataV . darray != null ) && ( dataV . bt instanceof DString ) ) if ( v . getDataType ( ) == DataType . STRING ) return convertStringArray ( data , v ) ; 
else if ( v . getDataType ( ) == DataType . CHAR ) return convertStringArrayToChar ( dataV . darray , v , section ) ; 
else { 
String mess = "DODSVariable convertArray String invalid dataType= " + v . getDataType ( ) ; 
logger . error ( mess ) ; 
throw new IllegalArgumentException ( mess ) ; 
} 
if ( ( dataV . bt instanceof DString ) && ( v . getDataType ( ) == DataType . CHAR ) ) return convertStringToChar ( data , v ) ; 
return data ; 
} 
} 

public class ConvertD2N { 
public Array convert ( DodsV dataV ) throws IOException , DAP2Exception { 
if ( dataV . darray == null ) if ( dataV . bt instanceof DStructure ) { 
ArrayStructure structArray = makeArrayStructure ( dataV ) ; 
iconvertDataStructure ( ( DStructure ) dataV . bt , structArray . getStructureMembers ( ) ) ; 
return structArray ; 
} 
else if ( dataV . bt instanceof DGrid ) throw new IllegalStateException ( "DGrid without a darray" ) ; 
else if ( dataV . bt instanceof DSequence ) { 
ArrayStructure structArray = makeArrayStructure ( dataV ) ; 
iconvertDataSequenceArray ( ( DSequence ) dataV . bt , structArray . getStructureMembers ( ) ) ; 
return structArray ; 
} 
else { 
DataType dtype = dataV . getDataType ( ) ; 
Array scalarData = Array . factory ( dtype , new int [ 0 ] ) ; 
IndexIterator scalarIndex = scalarData . getIndexIterator ( ) ; 
iconvertDataPrimitiveScalar ( dataV . bt , scalarIndex ) ; 
return scalarData ; 
} 
if ( dataV . darray != null ) if ( dataV . bt instanceof DStructure ) { 
ArrayStructure structArray = makeArrayStructure ( dataV ) ; 
iconvertDataStructureArray ( dataV . darray , structArray . getStructureMembers ( ) ) ; 
return structArray ; 
} 
else if ( dataV . bt instanceof DString ) return convertStringArray ( dataV . darray ) ; 
else { 
opendap . dap . PrimitiveVector pv = dataV . darray . getPrimitiveVector ( ) ; 
Object storage = pv . getInternalStorage ( ) ; 
DataType dtype = dataV . getDataType ( ) ; 
return Array . factory ( dtype , makeShape ( dataV . darray ) , storage ) ; 
} 
String mess = "Unknown baseType " + dataV . bt . getClass ( ) . getName ( ) + " name=" + dataV . getEncodedName ( ) ; 
logger . error ( mess ) ; 
throw new IllegalStateException ( mess ) ; 
} 
} 

public class MetadataManager { 
static synchronized public void closeAll ( ) { 
List < MetadataManager > closeDatabases = new ArrayList < > ( openDatabases ) ; 
for ( MetadataManager mm : closeDatabases ) { 
if ( debug ) System . out . println ( "  close database " + mm . collectionName ) ; 
mm . close ( ) ; 
} 
openDatabases = new ArrayList < > ( ) ; 
if ( myEnv != null ) try { 
myEnv . close ( ) ; 
myEnv = null ; 
logger . info ( "closed bdb caching" ) ; 
} 
catch ( DatabaseException dbe ) { 
logger . error ( "Error closing bdb: " , dbe ) ; 
} 
} 
} 

public class EcmwfLocalConcepts { 
private void storeConcept ( String tableVersion , String parameterNumber , String key , String value ) { 
HashMap < String , HashMap < String , String > > tmpTable ; 
if ( localConcepts . containsKey ( tableVersion ) ) { 
tmpTable = localConcepts . get ( tableVersion ) ; 
if ( tmpTable . containsKey ( parameterNumber ) ) { 
HashMap < String , String > tmpParam = tmpTable . get ( parameterNumber ) ; 
if ( ! tmpParam . containsKey ( key ) ) tmpParam . put ( key , value ) ; 
else System . out . println ( "already has key value pair: " + key + ":" + value ) ; 
} 
else { 
HashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; 
tmpParam . put ( key , value ) ; 
tmpTable . put ( parameterNumber , tmpParam ) ; 
} 
} 
else { 
tmpTable = new HashMap < > ( ) ; 
HashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; 
tmpParam . put ( key , value ) ; 
tmpTable . put ( parameterNumber , tmpParam ) ; 
} 
localConcepts . put ( tableVersion , tmpTable ) ; 
} 
} 

public class DatasetSource { 
private void nameDatasetList ( InvDatasetImpl dataset ) { 
InvDatasetImpl namedDs = new InvDatasetImpl ( dataset , "nameDatastList() temp dataset" , null , null , null ) ; 
dataset . addDataset ( namedDs ) ; 
DatasetNamer curNamer = null ; 
for ( int i = 0 ; 
i < this . datasetNamerList . size ( ) ; 
i ++ ) { 
curNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; 
logger . debug ( "nameDatasetList(): trying namer ({})" , curNamer . getName ( ) ) ; 
InvDatasetImpl addLevelDs = null ; 
if ( curNamer . getAddLevel ( ) ) addLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; 
InvDatasetImpl curDs = null ; 
java . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; 
while ( dsIter . hasNext ( ) ) { 
curDs = ( InvDatasetImpl ) dsIter . next ( ) ; 
logger . debug ( "nameDatasetList(): try namer on this ds ({}-{})" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; 
if ( curNamer . nameDataset ( curDs ) ) { 
logger . debug ( "nameDatasetList(): ds named ({})" , curDs . getName ( ) ) ; 
if ( curNamer . getAddLevel ( ) ) addLevelDs . addDataset ( curDs ) ; 
else namedDs . addDataset ( curDs ) ; 
dsIter . remove ( ) ; 
} 
} 
if ( curNamer . getAddLevel ( ) ) if ( addLevelDs . hasNestedDatasets ( ) ) namedDs . addDataset ( addLevelDs ) ; 
} 
namedDs . finish ( ) ; 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "nameDatasetList(): number of unnamed datasets is " + dataset . getDatasets ( ) . size ( ) + "." ) ; 
logger . debug ( "nameDatasetList(): add named datasets back to container." ) ; 
} 
for ( int i = 0 ; 
i < namedDs . getDatasets ( ) . size ( ) ; 
i ++ ) dataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; 
dataset . removeDataset ( namedDs ) ; 
return ; 
} 
} 

public class ScalablePicture { 
public void sourceLoadProgressNotification ( int statusCode , int percentage ) { 
Enumeration e = scalablePictureStatusListeners . elements ( ) ; 
while ( e . hasMoreElements ( ) ) ( ( ScalablePictureListener ) e . nextElement ( ) ) . sourceLoadProgressNotification ( statusCode , percentage ) ; 
} 
} 

public class GempakSoundingFileReader { 
private List < String > SN_CKUA ( ) { 
List < String > types = new ArrayList < > ( ) ; 
boolean above = false ; 
boolean done = false ; 
String partToCheck ; 
while ( ! done ) { 
for ( int group = 0 ; 
group < belowGroups . length ; 
group ++ ) { 
if ( above ) partToCheck = aboveGroups [ group ] ; 
else partToCheck = belowGroups [ group ] ; 
if ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) types . add ( partToCheck ) ; 
} 
if ( ! above ) above = true ; 
else done = true ; 
} 
return types ; 
} 
} 

public class GempakSoundingFileReader { 
private boolean checkForValidGroup ( String partToCheck , String [ ] params ) { 
DMPart part = getPart ( partToCheck ) ; 
if ( part == null ) return false ; 
int i = 0 ; 
for ( DMParam parm : part . params ) { 
if ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) return false ; 
} 
return true ; 
} 
} 

public class DiskCache { 
static public File getCacheFile ( String fileLocation ) { 
File f = new File ( makeCachePath ( fileLocation ) ) ; 
if ( f . exists ( ) ) if ( ! f . setLastModified ( System . currentTimeMillis ( ) ) ) logger . warn ( "Failed to setLastModified on " + f . getPath ( ) ) ; 
if ( ! checkExist ) { 
File dir = f . getParentFile ( ) ; 
if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) logger . warn ( "Failed to mkdirs on " + dir . getPath ( ) ) ; 
checkExist = true ; 
} 
return f ; 
} 
} 

public class DiskCache { 
static public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { 
if ( sbuff != null ) sbuff . append ( "DiskCache clean maxBytes= " ) . append ( maxBytes ) . append ( "on dir " ) . append ( root ) . append ( "\n" ) ; 
File dir = new File ( root ) ; 
long total = 0 , total_delete = 0 ; 
File [ ] files = dir . listFiles ( ) ; 
if ( files != null ) { 
List < File > fileList = Arrays . asList ( files ) ; 
Collections . sort ( fileList , fileComparator ) ; 
for ( File file : fileList ) { 
if ( file . length ( ) + total > maxBytes ) { 
total_delete += file . length ( ) ; 
if ( sbuff != null ) sbuff . append ( " delete " ) . append ( file ) . append ( " (" ) . append ( file . length ( ) ) . append ( ")\n" ) ; 
if ( ! file . delete ( ) && sbuff != null ) sbuff . append ( "Error deleting " ) . append ( file ) . append ( "\n" ) ; 
} 
else total += file . length ( ) ; 
} 
} 
if ( sbuff != null ) { 
sbuff . append ( "Total bytes deleted= " ) . append ( total_delete ) . append ( "\n" ) ; 
sbuff . append ( "Total bytes left in cache= " ) . append ( total ) . append ( "\n" ) ; 
} 
} 
} 

public class CoordinateAxis { 
static public CoordinateAxis factory ( NetcdfDataset ncd , VariableDS vds ) { 
if ( ( vds . getRank ( ) == 0 ) || ( vds . getRank ( ) == 1 ) || ( vds . getRank ( ) == 2 && vds . getDataType ( ) == DataType . CHAR ) ) return new CoordinateAxis1D ( ncd , vds ) ; 
else if ( vds . getRank ( ) == 2 ) return new CoordinateAxis2D ( ncd , vds ) ; 
else return new CoordinateAxis ( ncd , vds ) ; 
} 
} 

public class CoordinateAxis { 
public void getInfo ( Formatter buf ) { 
buf . format ( "%-30s" , getNameAndDimensions ( ) ) ; 
buf . format ( "%-20s" , getUnitsString ( ) ) ; 
if ( axisType != null ) buf . format ( "%-10s" , axisType . toString ( ) ) ; 
buf . format ( "%s" , getDescription ( ) ) ; 
} 
} 

public class CoordinateAxis { 
public ucar . nc2 . time . Calendar getCalendarFromAttribute ( ) { 
Attribute cal = findAttribute ( CF . CALENDAR ) ; 
String s = ( cal == null ) ? null : cal . getStringValue ( ) ; 
if ( s == null ) { 
Attribute convention = ( ncd == null ) ? null : ncd . getRootGroup ( ) . findAttribute ( CDM . CONVENTIONS ) ; 
if ( convention != null ) { 
String hasName = convention . getStringValue ( ) ; 
int version = CF1Convention . getVersion ( hasName ) ; 
if ( version >= 0 ) return Calendar . gregorian ; 
if ( COARDSConvention . isMine ( hasName ) ) return Calendar . gregorian ; 
} 
} 
return ucar . nc2 . time . Calendar . get ( s ) ; 
} 
} 

public class XMLStore { 
static public XMLStore createFromResource ( String resourceName , XMLStore storedDefaults ) throws java . io . IOException { 
Class c = XMLStore . class ; 
InputStream primIS = c . getResourceAsStream ( resourceName ) ; 
InputStream objIS = c . getResourceAsStream ( resourceName ) ; 
if ( primIS == null ) throw new java . io . IOException ( "XMLStore.createFromResource cant find <" + resourceName + ">" ) ; 
if ( debugWhichStore ) System . out . println ( "XMLStore read from resource " + resourceName ) ; 
return new XMLStore ( primIS , objIS , storedDefaults ) ; 
} 
} 

public class XMLStore { 
public void save ( ) throws java . io . IOException { 
if ( prefsFile == null ) throw new UnsupportedOperationException ( "XMLStore is read-only" ) ; 
File prefTemp ; 
String parentFilename = prefsFile . getParent ( ) ; 
if ( parentFilename == null ) prefTemp = File . createTempFile ( "pref" , ".xml" ) ; 
else { 
File parentFile = new File ( parentFilename ) ; 
prefTemp = File . createTempFile ( "pref" , ".xml" , parentFile ) ; 
} 
prefTemp . deleteOnExit ( ) ; 
FileOutputStream fos = new FileOutputStream ( prefTemp , false ) ; 
save ( fos ) ; 
fos . close ( ) ; 
Path xmlBackup = Paths . get ( prefsFile . getAbsolutePath ( ) + ".bak" ) ; 
Path prefsPath = prefsFile . toPath ( ) ; 
if ( Files . exists ( prefsPath ) ) Files . move ( prefsPath , xmlBackup , StandardCopyOption . REPLACE_EXISTING ) ; 
Files . move ( prefTemp . toPath ( ) , prefsFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; 
} 
} 

public class DapSerializer { 
protected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { 
DapVariable template = ( DapVariable ) data . getTemplate ( ) ; 
DapSequence ds = ( DapSequence ) template . getBaseType ( ) ; 
assert ( this . ce . references ( template ) ) ; 
List < Slice > slices = ce . getConstrainedSlices ( template ) ; 
Odometer odom = Odometer . factory ( slices ) ; 
if ( false ) while ( odom . hasNext ( ) ) { 
Index index = odom . next ( ) ; 
DataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; 
writeSequence1 ( instance [ 0 ] , dst ) ; 
} 
else { 
DataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; 
for ( int i = 0 ; 
i < instances . length ; 
i ++ ) writeSequence1 ( instances [ i ] , dst ) ; 
} 
} 
} 

public class GempakStation { 
public String getWmoId ( ) { 
String wmoID = "" ; 
if ( ! ( stnm == GempakConstants . IMISSD ) ) wmoID = String . valueOf ( ( int ) ( stnm / 10 ) ) ; 
return wmoID ; 
} 
} 

public class DbaseData { 
int readRowN ( DataInputStream ds , int n ) { 
if ( n > nrec ) return - 1 ; 
try { 
ds . readFully ( field , 0 , desc . FieldLength ) ; 
} 
catch ( java . io . IOException e ) { 
return - 1 ; 
} 
switch ( desc . Type ) { 
case 'C' : case 'D' : character [ n ] = new String ( field , CDM . utf8Charset ) ; 
break ; 
case 'N' : numeric [ n ] = Double . valueOf ( new String ( field , CDM . utf8Charset ) ) ; 
break ; 
case 'F' : if ( desc . FieldLength == 4 ) numeric [ n ] = ( double ) Swap . swapFloat ( field , 0 ) ; 
else numeric [ n ] = Swap . swapDouble ( field , 0 ) ; 
break ; 
case 'L' : switch ( field [ 0 ] ) { 
case 't' : case 'T' : case 'Y' : case 'y' : logical [ n ] = true ; 
break ; 
default : logical [ n ] = false ; 
break ; 
} 
default : return - 1 ; 
} 
return 0 ; 
} 
} 

public class Grib2DataReader { 
private float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { 
int nb = gdrs . numberOfBits ; 
int D = gdrs . decimalScaleFactor ; 
float DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; 
float R = gdrs . referenceValue ; 
int E = gdrs . binaryScaleFactor ; 
float EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; 
float [ ] data = new float [ totalNPoints ] ; 
BitReader reader = new BitReader ( raf , startPos + 5 ) ; 
if ( bitmap == null ) for ( int i = 0 ; 
i < totalNPoints ; 
i ++ ) data [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; 
else for ( int i = 0 ; 
i < totalNPoints ; 
i ++ ) if ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) data [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; 
else data [ i ] = staticMissingValue ; 
return data ; 
} 
} 

public class Grib2DataReader { 
private float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { 
int nb = gdrs . numberOfBits ; 
int D = gdrs . decimalScaleFactor ; 
float DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; 
float R = gdrs . referenceValue ; 
int E = gdrs . binaryScaleFactor ; 
float EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; 
float [ ] data = new float [ totalNPoints ] ; 
if ( nb == 0 ) { 
Arrays . fill ( data , R ) ; 
return data ; 
} 
byte [ ] buf = new byte [ dataLength - 5 ] ; 
raf . readFully ( buf ) ; 
InputStream in = new ByteArrayInputStream ( buf ) ; 
BufferedImage image = ImageIO . read ( in ) ; 
if ( nb != image . getColorModel ( ) . getPixelSize ( ) ) logger . debug ( "PNG pixel size disagrees with grib number of bits: " , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; 
DataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; 
if ( bitmap == null ) for ( int i = 0 ; 
i < dataNPoints ; 
i ++ ) data [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; 
else for ( int bitPt = 0 , dataPt = 0 ; 
bitPt < totalNPoints ; 
bitPt ++ ) if ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) data [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; 
else data [ bitPt ] = staticMissingValue ; 
return data ; 
} 
} 

public class CDMCursor { 
@ Override public Object read ( List < Slice > slices ) throws DapException { 
switch ( this . scheme ) { 
case ATOMIC : return readAtomic ( slices ) ; 
case STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( "Cannot slice a scalar variable" ) ; 
CDMCursor [ ] instances = new CDMCursor [ 1 ] ; 
instances [ 0 ] = this ; 
return instances ; 
case SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( "Cannot slice a scalar variable" ) ; 
instances = new CDMCursor [ 1 ] ; 
instances [ 0 ] = this ; 
return instances ; 
case STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; 
instances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; 
for ( int i = 0 ; 
odom . hasNext ( ) ; 
i ++ ) instances [ i ] = readStructure ( odom . next ( ) ) ; 
return instances ; 
case SEQARRAY : instances = readSequence ( slices ) ; 
return instances ; 
default : throw new DapException ( "Attempt to slice a scalar object" ) ; 
} 
} 
} 

public class StationRenderer { 
public void setSelectedStation ( String name ) { 
StationUI sui = ( StationUI ) stationHash . get ( name ) ; 
if ( sui != null ) setSelectedStation ( sui ) ; 
} 
} 

public class Grib1ParamTableReader { 
public Grib1Parameter getParameter ( int id ) { 
if ( parameters == null ) parameters = readParameterTable ( ) ; 
return parameters . get ( id ) ; 
} 
} 

public class Grib1ParamTableReader { 
public Grib1Parameter getLocalParameter ( int id ) { 
if ( parameters == null ) parameters = readParameterTable ( ) ; 
return parameters . get ( id ) ; 
} 
} 

public class PrefixDBImpl { 
private static Prefix getPrefix ( final String string , final Set < Prefix > set ) { 
for ( final Iterator < Prefix > iter = set . iterator ( ) ; 
iter . hasNext ( ) ; 
) { 
final Prefix prefix = iter . next ( ) ; 
final int comp = prefix . compareTo ( string ) ; 
if ( comp == 0 ) return prefix ; 
if ( comp > 0 ) break ; 
} 
return null ; 
} 
} 

public class WKTParser { 
public double getParameter ( String name ) { 
Double val = ( Double ) parameters . get ( name . toLowerCase ( ) ) ; 
if ( val == null ) throw new IllegalArgumentException ( "no parameter called " + name ) ; 
return val . doubleValue ( ) ; 
} 
} 

public class CFPolygon { 
public void setNext ( Polygon next ) { 
if ( next instanceof CFPolygon ) setNext ( ( CFPolygon ) next ) ; 
else this . next = next ; 
} 
} 

public class CFPolygon { 
public void setPrev ( Polygon prev ) { 
if ( prev instanceof CFPolygon ) setPrev ( ( CFPolygon ) prev ) ; 
else this . prev = prev ; 
} 
} 

public class NetcdfFile { 
protected Boolean makeRecordStructure ( ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
Boolean didit = false ; 
if ( ( spi != null ) && ( spi instanceof N3iosp ) && hasUnlimitedDimension ( ) ) didit = ( Boolean ) spi . sendIospMessage ( IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; 
return didit ; 
} 
} 

public class NetcdfFile { 
public Array readSection ( String variableSection ) throws IOException , InvalidRangeException { 
ParsedSectionSpec cer = ParsedSectionSpec . parseVariableSection ( this , variableSection ) ; 
if ( cer . child == null ) return cer . v . read ( cer . section ) ; 
if ( spi == null ) return IospHelper . readSection ( cer ) ; 
else return spi . readSection ( cer ) ; 
} 
} 

public class Attribute { 
private static final boolean checkByte ( String s ) throws AttributeBadValueException { 
try { 
short val = Short . parseShort ( s ) ; 
if ( DebugValueChecking ) log . debug ( "Attribute.checkByte() - string: '" + s + "'   value: " + val ) ; 
if ( val > 0xFF || val < 0 ) return false ; 
else return true ; 
} 
catch ( NumberFormatException e ) { 
throw new AttributeBadValueException ( "`" + s + "' is not a Byte value." ) ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkShort ( String s ) { 
try { 
short val = Short . parseShort ( s ) ; 
if ( DebugValueChecking ) DAPNode . log . debug ( "Attribute.checkShort() - string: '" + s + "'   value: " + val ) ; 
return true ; 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkInt ( String s ) { 
try { 
int val = Integer . parseInt ( s ) ; 
if ( DebugValueChecking ) DAPNode . log . debug ( "Attribute.checkInt() - string: '" + s + "'   value: " + val ) ; 
return true ; 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkUInt ( String s ) { 
try { 
long val = Long . parseLong ( s ) ; 
if ( DebugValueChecking ) DAPNode . log . debug ( "Attribute.checkUInt() - string: '" + s + "'   value: " + val ) ; 
if ( val > 0xFFFFFFFFL ) return false ; 
else return true ; 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkFloat ( String s ) { 
try { 
float val = Float . parseFloat ( s ) ; 
if ( DebugValueChecking ) DAPNode . log . debug ( "Attribute.checkFloat() - string: '" + s + "'   value: " + val ) ; 
return true ; 
} 
catch ( NumberFormatException e ) { 
if ( s . equalsIgnoreCase ( "nan" ) || s . equalsIgnoreCase ( "inf" ) ) return true ; 
return false ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkDouble ( String s ) { 
try { 
double val = Double . parseDouble ( s ) ; 
if ( DebugValueChecking ) DAPNode . log . debug ( "Attribute.checkDouble() - string: '" + s + "'   value: " + val ) ; 
return true ; 
} 
catch ( NumberFormatException e ) { 
if ( s . equalsIgnoreCase ( "nan" ) || s . equalsIgnoreCase ( "inf" ) ) return true ; 
return false ; 
} 
} 
} 

public class EnhanceScaleMissingUnsignedImpl { 
private DataType getAttributeDataType ( Attribute attribute ) { 
DataType dataType = attribute . getDataType ( ) ; 
if ( signedness == Signedness . UNSIGNED ) dataType = dataType . withSignedness ( signedness ) ; 
return dataType ; 
} 
} 

public class StringValidateEncodeUtils { 
@ SuppressWarnings ( { 
"UnnecessaryContinue" } 
) public static boolean descendOnlyFilePath ( String path ) { 
String [ ] pathSegments = path . split ( "/" ) ; 
int i = 0 ; 
for ( int indxOrigSegs = 0 ; 
indxOrigSegs < pathSegments . length ; 
indxOrigSegs ++ ) { 
String s = pathSegments [ indxOrigSegs ] ; 
if ( s . equals ( "." ) ) continue ; 
else if ( s . equals ( ".." ) ) { 
if ( i == 0 ) return false ; 
i -- ; 
} 
else i ++ ; 
} 
return true ; 
} 
} 

public class GridDefRecord { 
public final String getParam ( String key ) { 
String value = paramStr . get ( key ) ; 
if ( value == null ) { 
Double result = paramDbl . get ( key ) ; 
if ( result != null ) value = result . toString ( ) ; 
else { 
Integer intResult = paramInt . get ( key ) ; 
if ( intResult != null ) value = intResult . toString ( ) ; 
} 
if ( value != null ) paramStr . put ( key , value ) ; 
} 
if ( debug && value == null ) System . out . println ( key + " value not found" ) ; 
return value ; 
} 
} 

public class GridDefRecord { 
public static boolean compare ( GridDefRecord local , GridDefRecord other ) { 
java . util . Set < String > keys = local . getKeys ( ) ; 
java . util . Set < String > okeys = other . getKeys ( ) ; 
if ( keys . size ( ) != okeys . size ( ) ) return false ; 
for ( String key : keys ) { 
if ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) continue ; 
String val = local . getParam ( key ) ; 
String oval = other . getParam ( key ) ; 
if ( val . matches ( "^[0-9]+\\.[0-9]*" ) ) { 
double d = local . getDouble ( key ) ; 
double od = other . getDouble ( key ) ; 
if ( ! Misc . nearlyEquals ( d , od ) ) return false ; 
} 
else if ( val . matches ( "^[0-9]+" ) ) if ( ! val . equals ( oval ) ) return false ; 
else if ( ! val . equals ( oval ) ) return false ; 
} 
return true ; 
} 
} 

public class MessageBroker { 
private int process ( Buffer b , InputStream is ) throws IOException { 
int start = 0 ; 
while ( start < b . have ) { 
int matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; 
if ( matchPos < 0 ) if ( start == 0 ) return b . have - 3 ; 
else return start ; 
if ( matchPos + 6 >= b . have ) return start ; 
int b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; 
int b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; 
int b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; 
int messLen = b1 << 16 | b2 << 8 | b3 ; 
MessageTask task = new MessageTask ( messLen ) ; 
task . header = extractHeader ( start , matchPos , b ) ; 
int last = matchPos + messLen ; 
if ( last > b . have ) { 
task . have = b . have - matchPos ; 
System . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; 
if ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { 
System . out . println ( "Failed to read remaining BUFR message" ) ; 
break ; 
} 
} 
else { 
task . have = task . len ; 
System . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; 
} 
boolean ok = true ; 
for ( int i = task . len - 4 ; 
i < task . len ; 
i ++ ) { 
int bb = task . mess [ i ] ; 
if ( bb != 55 ) { 
ok = false ; 
bad_msgs ++ ; 
} 
} 
try { 
if ( ok ) messQ . put ( task ) ; 
total_msgs ++ ; 
} 
catch ( InterruptedException e ) { 
System . out . println ( " interrupted queue put - assume process exit" ) ; 
break ; 
} 
start = matchPos + messLen + 1 ; 
} 
return - 1 ; 
} 
} 

public class Ceparse { 
void markStackedVariables ( Stack s ) { 
Stack bts = new Stack ( ) ; 
while ( ! s . empty ( ) ) bts . push ( s . pop ( ) ) ; 
while ( bts . size ( ) > 1 ) { 
ServerMethods ct = ( ServerMethods ) bts . pop ( ) ; 
ct . setProject ( true , false ) ; 
} 
ServerMethods bt = ( ServerMethods ) bts . pop ( ) ; 
bt . setProject ( true , true ) ; 
} 
} 

public class NcmlEditor { 
boolean writeNcml ( String location ) { 
boolean err = false ; 
closeOpenFiles ( ) ; 
try { 
final String result ; 
ds = openDataset ( location , addCoords , null ) ; 
if ( ds == null ) editor . setText ( "Failed to open <" + location + ">" ) ; 
else { 
final NcMLWriter ncmlWriter = new NcMLWriter ( ) ; 
final Element netcdfElem = ncmlWriter . makeNetcdfElement ( ds , null ) ; 
result = ncmlWriter . writeToString ( netcdfElem ) ; 
editor . setText ( result ) ; 
editor . setCaretPosition ( 0 ) ; 
} 
} 
catch ( Exception e ) { 
final StringWriter sw = new StringWriter ( 10000 ) ; 
e . printStackTrace ( ) ; 
e . printStackTrace ( new PrintWriter ( sw ) ) ; 
editor . setText ( sw . toString ( ) ) ; 
err = true ; 
} 
return ! err ; 
} 
} 

public class StationCollectionStream { 
@ Override protected StationHelper createStationHelper ( ) throws IOException { 
StationHelper stationHelper = new StationHelper ( ) ; 
try ( InputStream in = CdmRemote . sendQuery ( null , uri , "req=stations" ) ) { 
PointStream . MessageType mtype = PointStream . readMagic ( in ) ; 
if ( mtype != PointStream . MessageType . StationList ) throw new RuntimeException ( "Station Request: bad response" ) ; 
int len = NcStream . readVInt ( in ) ; 
byte [ ] b = new byte [ len ] ; 
NcStream . readFully ( in , b ) ; 
PointStreamProto . StationList stationsp = PointStreamProto . StationList . parseFrom ( b ) ; 
for ( ucar . nc2 . ft . point . remote . PointStreamProto . Station sp : stationsp . getStationsList ( ) ) { 
stationHelper . addStation ( new StationFeatureStream ( null , null ) ) ; 
} 
return stationHelper ; 
} 
} 
} 

public class ResultService { 
protected boolean validate ( StringBuilder out ) { 
this . isValid = true ; 
if ( this . log . length ( ) > 0 ) out . append ( this . log ) ; 
if ( this . getAccessPointHeader ( ) == null ) { 
this . isValid = false ; 
out . append ( " ** ResultService (1): a null 'accessPointHeader' is invalid." ) ; 
} 
return ( this . isValid ) ; 
} 
} 

public class DoradeSWIB { 
public float [ ] getAzimuths ( ) { 
if ( azimuths == null ) { 
azimuths = new float [ nRays ] ; 
for ( int r = 0 ; 
r < nRays ; 
r ++ ) azimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; 
} 
return azimuths ; 
} 
} 

public class DoradeSWIB { 
public float [ ] getElevations ( ) { 
if ( elevations == null ) { 
elevations = new float [ nRays ] ; 
for ( int r = 0 ; 
r < nRays ; 
r ++ ) elevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; 
} 
return elevations ; 
} 
} 

public class Structure { 
@ Override public void setParentGroup ( Group group ) { 
if ( isImmutable ( ) ) throw new IllegalStateException ( "Cant modify" ) ; 
super . setParentGroup ( group ) ; 
if ( members != null ) for ( Variable v : members ) { 
v . setParentGroup ( group ) ; 
} 
} 
} 

public class Structure { 
public StructureData readStructure ( int index ) throws IOException , ucar . ma2 . InvalidRangeException { 
Section section = null ; 
if ( getRank ( ) == 1 ) section = new Section ( ) . appendRange ( index , index ) ; 
else if ( getRank ( ) > 1 ) { 
Index ii = Index . factory ( shape ) ; 
ii . setCurrentCounter ( index ) ; 
int [ ] origin = ii . getCurrentCounter ( ) ; 
section = new Section ( ) ; 
for ( int anOrigin : origin ) section . appendRange ( anOrigin , anOrigin ) ; 
} 
Array dataArray = read ( section ) ; 
ArrayStructure data = ( ArrayStructure ) dataArray ; 
return data . getStructureData ( 0 ) ; 
} 
} 

public class ProjectionImpl { 
public String getClassName ( ) { 
String className = getClass ( ) . getName ( ) ; 
int index = className . lastIndexOf ( "." ) ; 
if ( index >= 0 ) className = className . substring ( index + 1 ) ; 
return className ; 
} 
} 

public class TableAligner { 
public static void installInAllColumns ( JTable table , int alignment ) { 
for ( int colViewIndex = 0 ; 
colViewIndex < table . getColumnCount ( ) ; 
++ colViewIndex ) installInOneColumn ( table , colViewIndex , alignment ) ; 
} 
} 

public class CoreSocketFactory { 
private static List < String > listIpTypes ( String cloudSqlIpTypes ) { 
String [ ] rawTypes = cloudSqlIpTypes . split ( "," ) ; 
ArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; 
for ( int i = 0 ; 
i < rawTypes . length ; 
i ++ ) if ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( "PUBLIC" ) ) result . add ( i , "PRIMARY" ) ; 
else result . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; 
return result ; 
} 
} 

public class FluentLoggerFactory { 
protected synchronized void purgeLogger ( FluentLogger logger ) { 
Iterator < Entry < FluentLogger , String > > it = loggers . entrySet ( ) . iterator ( ) ; 
while ( it . hasNext ( ) ) if ( it . next ( ) . getKey ( ) == logger ) { 
it . remove ( ) ; 
return ; 
} 
} 
} 

public class InMemoryJavaCompiler { 
public Map < String , Class < ? > > compileAll ( ) throws Exception { 
if ( sourceCodes . size ( ) == 0 ) throw new CompilationException ( "No source code to compile" ) ; 
Collection < SourceCode > compilationUnits = sourceCodes . values ( ) ; 
CompiledCode [ ] code ; 
code = new CompiledCode [ compilationUnits . size ( ) ] ; 
Iterator < SourceCode > iter = compilationUnits . iterator ( ) ; 
for ( int i = 0 ; 
i < code . length ; 
i ++ ) code [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; 
DiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; 
ExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; 
JavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; 
boolean result = task . call ( ) ; 
if ( ! result || collector . getDiagnostics ( ) . size ( ) > 0 ) { 
StringBuffer exceptionMsg = new StringBuffer ( ) ; 
exceptionMsg . append ( "Unable to compile the source" ) ; 
boolean hasWarnings = false ; 
boolean hasErrors = false ; 
for ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { 
switch ( d . getKind ( ) ) { 
case NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; 
break ; 
case OTHER : case ERROR : default : hasErrors = true ; 
break ; 
} 
exceptionMsg . append ( "\n" ) . append ( "[kind=" ) . append ( d . getKind ( ) ) ; 
exceptionMsg . append ( ", " ) . append ( "line=" ) . append ( d . getLineNumber ( ) ) ; 
exceptionMsg . append ( ", " ) . append ( "message=" ) . append ( d . getMessage ( Locale . US ) ) . append ( "]" ) ; 
} 
if ( hasWarnings && ! ignoreWarnings || hasErrors ) throw new CompilationException ( exceptionMsg . toString ( ) ) ; 
} 
Map < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; 
for ( String className : sourceCodes . keySet ( ) ) { 
classes . put ( className , classLoader . loadClass ( className ) ) ; 
} 
return classes ; 
} 
} 

public class GifHeaderParser { 
private void readGraphicControlExt ( ) { 
read ( ) ; 
int packed = read ( ) ; 
header . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; 
if ( header . currentFrame . dispose == 0 ) header . currentFrame . dispose = 1 ; 
header . currentFrame . transparency = ( packed & 1 ) != 0 ; 
int delayInHundredthsOfASecond = readShort ( ) ; 
if ( delayInHundredthsOfASecond < MIN_FRAME_DELAY ) delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; 
header . currentFrame . delay = delayInHundredthsOfASecond * 10 ; 
header . currentFrame . transIndex = read ( ) ; 
read ( ) ; 
} 
} 

public class GifDecoder { 
synchronized Bitmap getNextFrame ( ) { 
if ( header . frameCount <= 0 || framePointer < 0 ) { 
if ( Log . isLoggable ( TAG , Log . DEBUG ) ) Log . d ( TAG , "unable to decode frame, frameCount=" + header . frameCount + " framePointer=" + framePointer ) ; 
status = STATUS_FORMAT_ERROR ; 
} 
if ( status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR ) { 
if ( Log . isLoggable ( TAG , Log . DEBUG ) ) Log . d ( TAG , "Unable to decode frame, status=" + status ) ; 
return null ; 
} 
status = STATUS_OK ; 
GifFrame currentFrame = header . frames . get ( framePointer ) ; 
GifFrame previousFrame = null ; 
int previousIndex = framePointer - 1 ; 
if ( previousIndex >= 0 ) previousFrame = header . frames . get ( previousIndex ) ; 
act = currentFrame . lct != null ? currentFrame . lct : header . gct ; 
if ( act == null ) { 
if ( Log . isLoggable ( TAG , Log . DEBUG ) ) Log . d ( TAG , "No Valid Color Table for frame #" + framePointer ) ; 
status = STATUS_FORMAT_ERROR ; 
return null ; 
} 
if ( currentFrame . transparency ) { 
System . arraycopy ( act , 0 , pct , 0 , act . length ) ; 
act = pct ; 
act [ currentFrame . transIndex ] = 0 ; 
} 
return setPixels ( currentFrame , previousFrame ) ; 
} 
} 

public class PersonLoginViewModel { 
public SelectableStringList selectablePersonsProperty ( ) { 
if ( selectablePersons == null ) selectablePersons = new SelectableItemList < > ( FXCollections . observableArrayList ( repository . getPersons ( ) ) , person -> person . getFirstName ( ) + " " + person . getLastName ( ) ) ; 
return selectablePersons ; 
} 
} 

public class ListTransformation { 
private void initListEvents ( ) { 
this . listChangeListener = new ListChangeListener < SourceType > ( ) { 
@ Override public void onChanged ( Change < ? extends SourceType > listEvent ) { 
List < TargetType > deleteStaging = new ArrayList < > ( ) ; 
while ( listEvent . next ( ) ) if ( listEvent . wasUpdated ( ) ) processUpdateEvent ( listEvent ) ; 
else if ( listEvent . wasReplaced ( ) ) processReplaceEvent ( listEvent , deleteStaging ) ; 
else if ( listEvent . wasAdded ( ) ) processAddEvent ( listEvent ) ; 
else if ( listEvent . wasRemoved ( ) ) processRemoveEvent ( listEvent , deleteStaging ) ; 
processStagingLists ( deleteStaging ) ; 
} 
} 
; 
modelListProperty ( ) . addListener ( new WeakListChangeListener < > ( listChangeListener ) ) ; 
} 
} 

public class Repository { 
public Person getPersonById ( final int id ) { 
for ( Person person : persons ) { 
if ( id == person . getId ( ) ) return person ; 
} 
return null ; 
} 
} 

public class CompositeValidationStatus { 
void addMessage ( Validator validator , List < ? extends ValidationMessage > messages ) { 
if ( messages . isEmpty ( ) ) return ; 
final int validatorHash = System . identityHashCode ( validator ) ; 
if ( ! validatorToMessagesMap . containsKey ( validatorHash ) ) validatorToMessagesMap . put ( validatorHash , new ArrayList < > ( ) ) ; 
final List < Integer > messageHashesOfThisValidator = validatorToMessagesMap . get ( validatorHash ) ; 
messages . stream ( ) . map ( System :: identityHashCode ) . forEach ( messageHashesOfThisValidator :: add ) ; 
getMessagesInternal ( ) . addAll ( messages ) ; 
} 
} 

public class ViewLoaderReflectionUtils { 
@ SuppressWarnings ( "unchecked" ) public static < V extends View < ? extends VM > , VM extends ViewModel > void createAndInjectViewModel ( final V view , Consumer < ViewModel > newVmConsumer ) { 
final Class < ? > viewModelType = TypeResolver . resolveRawArgument ( View . class , view . getClass ( ) ) ; 
if ( viewModelType == ViewModel . class ) { 
final List < Field > viewModelFields = ViewLoaderReflectionUtils . getViewModelFields ( view . getClass ( ) ) ; 
if ( ! viewModelFields . isEmpty ( ) ) throw new RuntimeException ( "The given view of type <" + view . getClass ( ) + "> has no generic viewModel type declared but tries to inject a viewModel." ) ; 
return ; 
} 
if ( viewModelType == TypeResolver . Unknown . class ) return ; 
final Optional < Field > fieldOptional = getViewModelField ( view . getClass ( ) , viewModelType ) ; 
if ( fieldOptional . isPresent ( ) ) { 
Field field = fieldOptional . get ( ) ; 
ReflectionUtils . accessMember ( field , ( ) -> { 
Object existingViewModel = field . get ( view ) ; 
if ( existingViewModel == null ) { 
final Object newViewModel = DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; 
field . set ( view , newViewModel ) ; 
newVmConsumer . accept ( ( ViewModel ) newViewModel ) ; 
} 
} 
, "Can't inject ViewModel of type <" + viewModelType + "> into the view <" + view + ">" ) ; 
} 
} 
} 

public class ViewLoaderReflectionUtils { 
@ SuppressWarnings ( "unchecked" ) public static < ViewType extends View < ? extends ViewModelType > , ViewModelType extends ViewModel > ViewModelType createViewModel ( ViewType view ) { 
final Class < ? > viewModelType = TypeResolver . resolveRawArgument ( View . class , view . getClass ( ) ) ; 
if ( viewModelType == ViewModel . class ) return null ; 
if ( TypeResolver . Unknown . class == viewModelType ) return null ; 
return ( ViewModelType ) DependencyInjector . getInstance ( ) . getInstanceOf ( viewModelType ) ; 
} 
} 

public class DataFxCountrySelector { 
void loadCountries ( ) { 
InputStream iso3166Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_LOCATION ) ; 
if ( iso3166Resource == null ) throw new IllegalStateException ( "Can't find the list of countries! Expected location was:" + ISO_3166_LOCATION ) ; 
XmlConverter < Country > countryConverter = new XmlConverter < > ( "iso_3166_entry" , Country . class ) ; 
try { 
DataReader < Country > dataSource = new InputStreamSource < > ( iso3166Resource , countryConverter ) ; 
ListDataProvider < Country > listDataProvider = new ListDataProvider < > ( dataSource ) ; 
listDataProvider . setResultObservableList ( countries ) ; 
Worker < ObservableList < Country > > worker = listDataProvider . retrieve ( ) ; 
worker . stateProperty ( ) . addListener ( obs -> { 
if ( worker . getState ( ) == Worker . State . SUCCEEDED ) loadSubdivisions ( ) ; 
} 
) ; 
} 
catch ( IOException e ) { 
LOG . error ( "A problem was detected while loading the XML file with the available countries." , e ) ; 
} 
} 
} 

public class DataFxCountrySelector { 
void loadSubdivisions ( ) { 
InputStream iso3166_2Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_2_LOCATION ) ; 
if ( iso3166_2Resource == null ) throw new IllegalStateException ( "Can't find the list of subdivisions! Expected location was:" + ISO_3166_2_LOCATION ) ; 
XmlConverter < ISO3166_2_CountryEntity > converter = new XmlConverter < > ( "iso_3166_country" , ISO3166_2_CountryEntity . class ) ; 
ObservableList < ISO3166_2_CountryEntity > subdivisionsEntities = FXCollections . observableArrayList ( ) ; 
try { 
DataReader < ISO3166_2_CountryEntity > dataSource = new InputStreamSource < > ( iso3166_2Resource , converter ) ; 
ListDataProvider < ISO3166_2_CountryEntity > listDataProvider = new ListDataProvider < > ( dataSource ) ; 
listDataProvider . setResultObservableList ( subdivisionsEntities ) ; 
Worker < ObservableList < ISO3166_2_CountryEntity > > worker = listDataProvider . retrieve ( ) ; 
worker . stateProperty ( ) . addListener ( obs -> { 
if ( worker . getState ( ) == Worker . State . SUCCEEDED ) { 
subdivisionsEntities . forEach ( entity -> { 
if ( entity . subsets != null && ! entity . subsets . isEmpty ( ) ) { 
Country country = findCountryByCode ( entity . code ) ; 
if ( ! countryCodeSubdivisionMap . containsKey ( country ) ) countryCodeSubdivisionMap . put ( country , new ArrayList < > ( ) ) ; 
List < Subdivision > subdivisionList = countryCodeSubdivisionMap . get ( country ) ; 
entity . subsets . forEach ( subset -> { 
subset . entryList . forEach ( entry -> { 
subdivisionList . add ( new Subdivision ( entry . name , entry . code , country ) ) ; 
} 
) ; 
} 
) ; 
String subdivisionName = entity . subsets . stream ( ) . map ( subset -> subset . subdivisionType ) . collect ( Collectors . joining ( "/" ) ) ; 
countryCodeSubdivisionNameMap . put ( country , subdivisionName ) ; 
} 
} 
) ; 
inProgress . set ( false ) ; 
} 
} 
) ; 
} 
catch ( IOException e ) { 
LOG . error ( "A problem was detected while loading the XML file with the available subdivisions." , e ) ; 
} 
} 
} 

public class SelectableItemList { 
private void createIndexEvents ( ) { 
selectionModel . selectedIndexProperty ( ) . addListener ( ( bean , oldVal , newVal ) -> { 
int index = newVal . intValue ( ) ; 
ListType item = index == - 1 ? null : modelListProperty ( ) . get ( index ) ; 
selectedItem . set ( item ) ; 
} 
) ; 
selectedItem . addListener ( ( observable , oldVal , newVal ) -> { 
if ( newVal == null ) { 
selectionModel . select ( - 1 ) ; 
selectedItem . set ( null ) ; 
} 
else { 
int index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; 
if ( index != - 1 ) selectionModel . select ( index ) ; 
else selectedItem . set ( oldVal ) ; 
} 
} 
) ; 
} 
} 

public class ReflectionUtils { 
public static < T > T accessMember ( final AccessibleObject member , final Callable < T > callable , String errorMessage ) { 
if ( callable == null ) return null ; 
return AccessController . doPrivileged ( ( PrivilegedAction < T > ) ( ) -> { 
boolean wasAccessible = member . isAccessible ( ) ; 
try { 
member . setAccessible ( true ) ; 
return callable . call ( ) ; 
} 
catch ( Exception exception ) { 
throw new IllegalStateException ( errorMessage , exception ) ; 
} 
finally { 
member . setAccessible ( wasAccessible ) ; 
} 
} 
) ; 
} 
} 

public class FxmlViewLoader { 
private String createFxmlPath ( Class < ? > viewType ) { 
final StringBuilder pathBuilder = new StringBuilder ( ) ; 
final FxmlPath pathAnnotation = viewType . getDeclaredAnnotation ( FxmlPath . class ) ; 
final String fxmlPath = Optional . ofNullable ( pathAnnotation ) . map ( FxmlPath :: value ) . map ( String :: trim ) . orElse ( "" ) ; 
if ( fxmlPath . isEmpty ( ) ) { 
pathBuilder . append ( "/" ) ; 
if ( viewType . getPackage ( ) != null ) { 
pathBuilder . append ( viewType . getPackage ( ) . getName ( ) . replaceAll ( "\\." , "/" ) ) ; 
pathBuilder . append ( "/" ) ; 
} 
pathBuilder . append ( viewType . getSimpleName ( ) ) ; 
pathBuilder . append ( ".fxml" ) ; 
} 
else pathBuilder . append ( fxmlPath ) ; 
return pathBuilder . toString ( ) ; 
} 
} 

public class StyleDao { 
public StyleRow queryForRow ( StyleMappingRow styleMappingRow ) { 
StyleRow styleRow = null ; 
AttributesRow attributesRow = queryForIdRow ( styleMappingRow . getRelatedId ( ) ) ; 
if ( attributesRow != null ) styleRow = getRow ( attributesRow ) ; 
return styleRow ; 
} 
} 

public class CoverageDataPng { 
public static void validateImageType ( PngReader reader ) { 
if ( reader == null ) throw new GeoPackageException ( "The image is null" ) ; 
if ( reader . imgInfo . channels != 1 || reader . imgInfo . bitDepth != 16 ) throw new GeoPackageException ( "The coverage data tile is expected to be a single channel 16 bit unsigned short, channels: " + reader . imgInfo . channels + ", bits: " + reader . imgInfo . bitDepth ) ; 
} 
} 

public class UserConnection { 
public TResult query ( UserQuery query ) { 
Cursor cursor = null ; 
String [ ] selectionArgs = query . getSelectionArgs ( ) ; 
String sql = query . getSql ( ) ; 
if ( sql != null ) cursor = database . rawQuery ( sql , selectionArgs ) ; 
else { 
String table = query . getTable ( ) ; 
String [ ] columns = query . getColumns ( ) ; 
String selection = query . getSelection ( ) ; 
String groupBy = query . getGroupBy ( ) ; 
String having = query . getHaving ( ) ; 
String orderBy = query . getOrderBy ( ) ; 
String [ ] columnsAs = query . getColumnsAs ( ) ; 
String limit = query . getLimit ( ) ; 
if ( columnsAs != null && limit != null ) cursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy , limit ) ; 
else if ( columnsAs != null ) cursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy ) ; 
else if ( limit != null ) cursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; 
else cursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; 
} 
TResult result = handleCursor ( cursor , query ) ; 
return result ; 
} 
} 

public class UserConnection { 
private TResult handleCursor ( Cursor cursor , UserQuery query ) { 
TResult result = convertCursor ( cursor ) ; 
result . setQuery ( query ) ; 
if ( table != null ) result . setTable ( table ) ; 
return result ; 
} 
} 

public class FeatureTableIndex { 
public FeatureRow getFeatureRow ( GeometryIndex geometryIndex ) { 
long geomId = geometryIndex . getGeomId ( ) ; 
FeatureRow row = featureRowSync . getRowOrLock ( geomId ) ; 
if ( row == null ) try { 
row = featureDao . queryForIdRow ( geomId ) ; 
} 
finally { 
featureRowSync . setRow ( geomId , row ) ; 
} 
return row ; 
} 
} 

public class CoverageData { 
public static CoverageData < ? > getCoverageData ( GeoPackage geoPackage , TileDao tileDao , Integer width , Integer height , Projection requestProjection ) { 
TileMatrixSet tileMatrixSet = tileDao . getTileMatrixSet ( ) ; 
GriddedCoverageDao griddedCoverageDao = geoPackage . getGriddedCoverageDao ( ) ; 
GriddedCoverage griddedCoverage = null ; 
try { 
if ( griddedCoverageDao . isTableExists ( ) ) griddedCoverage = griddedCoverageDao . query ( tileMatrixSet ) ; 
} 
catch ( SQLException e ) { 
throw new GeoPackageException ( "Failed to get Gridded Coverage for table name: " + tileMatrixSet . getTableName ( ) , e ) ; 
} 
CoverageData < ? > coverageData = null ; 
GriddedCoverageDataType dataType = griddedCoverage . getDataType ( ) ; 
switch ( dataType ) { 
case INTEGER : coverageData = new CoverageDataPng ( geoPackage , tileDao , width , height , requestProjection ) ; 
break ; 
case FLOAT : coverageData = new CoverageDataTiff ( geoPackage , tileDao , width , height , requestProjection ) ; 
break ; 
default : throw new GeoPackageException ( "Unsupported Gridded Coverage Data Type: " + dataType ) ; 
} 
return coverageData ; 
} 
} 

public class CoverageData { 
private CoverageDataTileMatrixResults getResults ( CoverageDataRequest request , BoundingBox requestProjectedBoundingBox , int overlappingPixels ) { 
TileMatrix tileMatrix = getTileMatrix ( request ) ; 
CoverageDataTileMatrixResults results = null ; 
if ( tileMatrix != null ) { 
results = getResults ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; 
if ( results == null ) results = getResultsZoom ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; 
} 
return results ; 
} 
} 

public class CoverageData { 
private CoverageDataTileMatrixResults getResultsZoom ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { 
CoverageDataTileMatrixResults results = null ; 
if ( zoomIn && zoomInBeforeOut ) results = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; 
if ( results == null && zoomOut ) results = getResultsZoomOut ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; 
if ( results == null && zoomIn && ! zoomInBeforeOut ) results = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; 
return results ; 
} 
} 

public class CoverageData { 
private CoverageDataTileMatrixResults getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { 
CoverageDataTileMatrixResults results = null ; 
for ( long zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; 
zoomLevel <= tileDao . getMaxZoom ( ) ; 
zoomLevel ++ ) { 
TileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; 
if ( zoomTileMatrix != null ) { 
results = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; 
if ( results != null ) break ; 
} 
} 
return results ; 
} 
} 

public class CoverageData { 
private CoverageDataTileMatrixResults getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { 
CoverageDataTileMatrixResults results = null ; 
for ( long zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; 
zoomLevel >= tileDao . getMinZoom ( ) ; 
zoomLevel -- ) { 
TileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; 
if ( zoomTileMatrix != null ) { 
results = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; 
if ( results != null ) break ; 
} 
} 
return results ; 
} 
} 

public class CoverageData { 
private TileMatrix getTileMatrix ( CoverageDataRequest request ) { 
TileMatrix tileMatrix = null ; 
if ( request . overlap ( coverageBoundingBox ) != null ) { 
BoundingBox projectedBoundingBox = request . getProjectedBoundingBox ( ) ; 
double distanceWidth = projectedBoundingBox . getMaxLongitude ( ) - projectedBoundingBox . getMinLongitude ( ) ; 
double distanceHeight = projectedBoundingBox . getMaxLatitude ( ) - projectedBoundingBox . getMinLatitude ( ) ; 
Long zoomLevel = tileDao . getClosestZoomLevel ( distanceWidth , distanceHeight ) ; 
if ( zoomLevel != null ) tileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; 
} 
return tileMatrix ; 
} 
} 

public class Icons { 
public void setIcon ( IconRow iconRow , GeometryType geometryType ) { 
if ( geometryType != null ) if ( iconRow != null ) icons . put ( geometryType , iconRow ) ; 
else icons . remove ( geometryType ) ; 
else defaultIcon = iconRow ; 
} 
} 

public class Icons { 
public IconRow getIcon ( GeometryType geometryType ) { 
IconRow iconRow = null ; 
if ( geometryType != null && ! icons . isEmpty ( ) ) { 
List < GeometryType > geometryTypes = GeometryUtils . parentHierarchy ( geometryType ) ; 
geometryTypes . add ( 0 , geometryType ) ; 
for ( GeometryType type : geometryTypes ) { 
iconRow = icons . get ( type ) ; 
if ( iconRow != null ) break ; 
} 
} 
if ( iconRow == null ) iconRow = defaultIcon ; 
if ( iconRow == null && geometryType == null && icons . size ( ) == 1 ) iconRow = icons . values ( ) . iterator ( ) . next ( ) ; 
return iconRow ; 
} 
} 

public class GeoPackageDatabase { 
public org . sqlite . database . sqlite . SQLiteDatabase openOrGetBindingsDb ( ) { 
if ( bindingsDb == null ) synchronized ( db ) { 
if ( bindingsDb == null ) { 
System . loadLibrary ( "sqliteX" ) ; 
bindingsDb = org . sqlite . database . sqlite . SQLiteDatabase . openDatabase ( db . getPath ( ) , null , org . sqlite . database . sqlite . SQLiteDatabase . OPEN_READWRITE ) ; 
} 
} 
return bindingsDb ; 
} 
} 

public class TableMetadataDataSource { 
public void create ( TableMetadata metadata ) { 
ContentValues values = new ContentValues ( ) ; 
values . put ( TableMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; 
values . put ( TableMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; 
values . put ( TableMetadata . COLUMN_LAST_INDEXED , metadata . getLastIndexed ( ) ) ; 
long insertId = db . insert ( TableMetadata . TABLE_NAME , null , values ) ; 
if ( insertId == - 1 ) throw new GeoPackageException ( "Failed to insert table metadata. GeoPackage Id: " + metadata . getGeoPackageId ( ) + ", Table Name: " + metadata . getTableName ( ) + ", Last Indexed: " + metadata . getLastIndexed ( ) ) ; 
} 
} 

public class TableMetadataDataSource { 
public long getGeoPackageId ( String geoPackage ) { 
long id = - 1 ; 
GeoPackageMetadataDataSource ds = new GeoPackageMetadataDataSource ( db ) ; 
GeoPackageMetadata metadata = ds . get ( geoPackage ) ; 
if ( metadata != null ) id = metadata . getId ( ) ; 
return id ; 
} 
} 

public class TableMetadataDataSource { 
private TableMetadata createTableMetadata ( Cursor cursor ) { 
TableMetadata metadata = new TableMetadata ( ) ; 
metadata . setGeoPackageId ( cursor . getLong ( 0 ) ) ; 
metadata . setTableName ( cursor . getString ( 1 ) ) ; 
if ( ! cursor . isNull ( 2 ) ) metadata . setLastIndexed ( cursor . getLong ( 2 ) ) ; 
return metadata ; 
} 
} 

public class RTreeIndexTableDao { 
public Extensions create ( ) { 
Extensions extension = null ; 
if ( ! has ( ) ) { 
extension = rTree . create ( featureDao . getTable ( ) ) ; 
if ( progress != null ) progress . addProgress ( count ( ) ) ; 
} 
return extension ; 
} 
} 

public class ManualFeatureQuery { 
public ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { 
List < Long > featureIds = new ArrayList < > ( ) ; 
long offset = 0 ; 
boolean hasResults = true ; 
minX -= tolerance ; 
maxX += tolerance ; 
minY -= tolerance ; 
maxY += tolerance ; 
while ( hasResults ) { 
hasResults = false ; 
FeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; 
try { 
while ( featureCursor . moveToNext ( ) ) { 
hasResults = true ; 
FeatureRow featureRow = featureCursor . getRow ( ) ; 
GeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; 
if ( envelope != null ) { 
double minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; 
double maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; 
double minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; 
double maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; 
if ( minXMax <= maxXMin && minYMax <= maxYMin ) featureIds . add ( featureRow . getId ( ) ) ; 
} 
} 
} 
finally { 
featureCursor . close ( ) ; 
} 
offset += chunkLimit ; 
} 
ManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; 
return results ; 
} 
} 

public class TileGenerator { 
public void setBitmapCompressionConfig ( Config config ) { 
if ( options == null ) options = new Options ( ) ; 
options . inPreferredConfig = config ; 
} 
} 

public class TileGenerator { 
public int getTileCount ( ) { 
if ( tileCount == null ) { 
long count = 0 ; 
boolean degrees = projection . isUnit ( Units . DEGREES ) ; 
ProjectionTransform transformToWebMercator = null ; 
if ( ! degrees ) transformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; 
for ( int zoom = minZoom ; 
zoom <= maxZoom ; 
zoom ++ ) { 
BoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; 
TileGrid tileGrid = null ; 
if ( degrees ) tileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; 
else tileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; 
count += tileGrid . count ( ) ; 
tileGrids . put ( zoom , tileGrid ) ; 
tileBounds . put ( zoom , expandedBoundingBox ) ; 
} 
tileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; 
} 
return tileCount ; 
} 
} 

public class TileGenerator { 
private void adjustBounds ( BoundingBox boundingBox , int zoom ) { 
if ( googleTiles ) adjustGoogleBounds ( ) ; 
else if ( projection . isUnit ( Units . DEGREES ) ) adjustGeoPackageBoundsWGS84 ( boundingBox , zoom ) ; 
else adjustGeoPackageBounds ( boundingBox , zoom ) ; 
} 
} 

public class TileDao { 
public TileGrid getTileGrid ( long zoomLevel ) { 
TileGrid tileGrid = null ; 
TileMatrix tileMatrix = getTileMatrix ( zoomLevel ) ; 
if ( tileMatrix != null ) tileGrid = new TileGrid ( 0 , 0 , tileMatrix . getMatrixWidth ( ) - 1 , tileMatrix . getMatrixHeight ( ) - 1 ) ; 
return tileGrid ; 
} 
} 

public class TileDao { 
public TileRow queryForTile ( long column , long row , long zoomLevel ) { 
Map < String , Object > fieldValues = new HashMap < String , Object > ( ) ; 
fieldValues . put ( TileTable . COLUMN_TILE_COLUMN , column ) ; 
fieldValues . put ( TileTable . COLUMN_TILE_ROW , row ) ; 
fieldValues . put ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; 
TileCursor cursor = queryForFieldValues ( fieldValues ) ; 
TileRow tileRow = null ; 
try { 
if ( cursor . moveToNext ( ) ) tileRow = cursor . getRow ( ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return tileRow ; 
} 
} 

public class TileDao { 
public TileGrid queryForTileGrid ( long zoomLevel ) { 
String where = buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; 
String [ ] whereArgs = buildWhereArgs ( new Object [ ] { 
zoomLevel } 
) ; 
Integer minX = min ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; 
Integer maxX = max ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; 
Integer minY = min ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; 
Integer maxY = max ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; 
TileGrid tileGrid = null ; 
if ( minX != null && maxX != null && minY != null && maxY != null ) tileGrid = new TileGrid ( minX , minY , maxX , maxY ) ; 
return tileGrid ; 
} 
} 

public class CoverageDataTiff { 
public float [ ] getPixelValues ( byte [ ] imageBytes ) { 
TIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; 
FileDirectory directory = tiffImage . getFileDirectory ( ) ; 
validateImageType ( directory ) ; 
Rasters rasters = directory . readRasters ( ) ; 
float [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; 
for ( int y = 0 ; 
y < rasters . getHeight ( ) ; 
y ++ ) for ( int x = 0 ; 
x < rasters . getWidth ( ) ; 
x ++ ) { 
int index = rasters . getSampleIndex ( x , y ) ; 
pixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; 
} 
return pixels ; 
} 
} 

public class CoverageDataTiff { 
public static void validateImageType ( FileDirectory directory ) { 
if ( directory == null ) throw new GeoPackageException ( "The image is null" ) ; 
int samplesPerPixel = directory . getSamplesPerPixel ( ) ; 
Integer bitsPerSample = null ; 
if ( directory . getBitsPerSample ( ) != null && ! directory . getBitsPerSample ( ) . isEmpty ( ) ) bitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; 
Integer sampleFormat = null ; 
if ( directory . getSampleFormat ( ) != null && ! directory . getSampleFormat ( ) . isEmpty ( ) ) sampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; 
if ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null || sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) throw new GeoPackageException ( "The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: " + samplesPerPixel + ", Bits Per Sample: " + bitsPerSample + ", Sample Format: " + sampleFormat ) ; 
} 
} 

public class GeoPackageCache { 
private GeoPackage getOrOpen ( String name , boolean writable , boolean cache ) { 
GeoPackage geoPackage = get ( name ) ; 
if ( geoPackage == null ) { 
geoPackage = manager . open ( name , writable ) ; 
if ( cache ) add ( geoPackage ) ; 
} 
return geoPackage ; 
} 
} 

public class UserCursor { 
private TRow getCurrentRow ( ) { 
TRow row = null ; 
if ( table != null ) { 
int [ ] columnTypes = new int [ table . columnCount ( ) ] ; 
Object [ ] values = new Object [ table . columnCount ( ) ] ; 
boolean valid = true ; 
for ( TColumn column : table . getColumns ( ) ) { 
int index = column . getIndex ( ) ; 
int columnType = getType ( index ) ; 
if ( column . isPrimaryKey ( ) && columnType == FIELD_TYPE_NULL ) valid = false ; 
columnTypes [ index ] = columnType ; 
values [ index ] = getValue ( column ) ; 
} 
row = getRow ( columnTypes , values ) ; 
if ( ! valid ) { 
invalidPositions . add ( getPosition ( ) ) ; 
row . setValid ( false ) ; 
} 
} 
return row ; 
} 
} 

public class UserCursor { 
private boolean moveToNextInvalid ( ) { 
boolean hasNext = false ; 
if ( invalidCursor == null && dao != null && hasInvalidPositions ( ) ) { 
super . close ( ) ; 
List < TColumn > blobColumns = dao . getTable ( ) . columnsOfType ( GeoPackageDataType . BLOB ) ; 
String [ ] columnsAs = dao . buildColumnsAsNull ( blobColumns ) ; 
query . set ( UserQueryParamType . COLUMNS_AS , columnsAs ) ; 
UserCursor < TColumn , TTable , TRow > requeryCursor = dao . query ( query ) ; 
invalidCursor = createInvalidCursor ( dao , requeryCursor , getInvalidPositions ( ) , blobColumns ) ; 
} 
if ( invalidCursor != null ) hasNext = invalidCursor . moveToNext ( ) ; 
return hasNext ; 
} 
} 

public class StyleMappingDao { 
public List < StyleMappingRow > queryByBaseFeatureId ( long id ) { 
List < StyleMappingRow > rows = new ArrayList < > ( ) ; 
UserCustomCursor cursor = queryByBaseId ( id ) ; 
try { 
while ( cursor . moveToNext ( ) ) rows . add ( getRow ( cursor ) ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return rows ; 
} 
} 

public class StyleMappingDao { 
public int deleteByBaseId ( long id , GeometryType geometryType ) { 
String geometryTypeName = null ; 
if ( geometryType != null ) geometryTypeName = geometryType . getName ( ) ; 
StringBuilder where = new StringBuilder ( ) ; 
where . append ( buildWhere ( StyleMappingTable . COLUMN_BASE_ID , id ) ) ; 
where . append ( " AND " ) ; 
where . append ( buildWhere ( StyleMappingTable . COLUMN_GEOMETRY_TYPE_NAME , geometryTypeName ) ) ; 
List < Object > whereArguments = new ArrayList < > ( ) ; 
whereArguments . add ( id ) ; 
if ( geometryTypeName != null ) whereArguments . add ( geometryTypeName ) ; 
String [ ] whereArgs = buildWhereArgs ( whereArguments ) ; 
int deleted = delete ( where . toString ( ) , whereArgs ) ; 
return deleted ; 
} 
} 

public class GeoPackageManagerImpl { 
private List < String > deleteMissingDatabases ( List < String > databases ) { 
List < String > filesExist = new ArrayList < > ( ) ; 
for ( String database : databases ) { 
if ( exists ( database ) ) filesExist . add ( database ) ; 
} 
return filesExist ; 
} 
} 

public class GeoPackageManagerImpl { 
private void validateDatabase ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity , boolean close , boolean closeOnError ) { 
try { 
if ( validateHeader ) validateDatabaseHeader ( sqliteDatabase ) ; 
if ( validateIntegrity ) validateDatabaseIntegrity ( sqliteDatabase ) ; 
} 
catch ( Exception e ) { 
if ( closeOnError ) sqliteDatabase . close ( ) ; 
throw e ; 
} 
if ( close ) sqliteDatabase . close ( ) ; 
} 
} 

public class GeoPackageManagerImpl { 
private void validateDatabaseHeader ( SQLiteDatabase sqliteDatabase ) { 
boolean validHeader = isDatabaseHeaderValid ( sqliteDatabase ) ; 
if ( ! validHeader ) throw new GeoPackageException ( "GeoPackage SQLite header is not valid: " + sqliteDatabase . getPath ( ) ) ; 
} 
} 

public class GeoPackageManagerImpl { 
private boolean isDatabaseHeaderValid ( SQLiteDatabase sqliteDatabase ) { 
boolean validHeader = false ; 
FileInputStream fis = null ; 
try { 
fis = new FileInputStream ( sqliteDatabase . getPath ( ) ) ; 
byte [ ] headerBytes = new byte [ 16 ] ; 
if ( fis . read ( headerBytes ) == 16 ) { 
ByteReader byteReader = new ByteReader ( headerBytes ) ; 
String header = byteReader . readString ( headerBytes . length ) ; 
String headerPrefix = header . substring ( 0 , GeoPackageConstants . SQLITE_HEADER_PREFIX . length ( ) ) ; 
validHeader = headerPrefix . equalsIgnoreCase ( GeoPackageConstants . SQLITE_HEADER_PREFIX ) ; 
} 
} 
catch ( Exception e ) { 
Log . e ( GeoPackageManagerImpl . class . getSimpleName ( ) , "Failed to retrieve database header" , e ) ; 
} 
finally { 
if ( fis != null ) try { 
fis . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
return validHeader ; 
} 
} 

public class GeoPackageManagerImpl { 
private void addInternalDatabases ( Collection < String > databases ) { 
String [ ] databaseArray = context . databaseList ( ) ; 
for ( String database : databaseArray ) { 
if ( ! isTemporary ( database ) && ! database . equalsIgnoreCase ( GeoPackageMetadataDb . DATABASE_NAME ) ) databases . add ( database ) ; 
} 
} 
} 

public class GeoPackageManagerImpl { 
private void addExternalDatabases ( Collection < String > databases ) { 
List < GeoPackageMetadata > externalGeoPackages = getExternalGeoPackages ( ) ; 
for ( GeoPackageMetadata external : externalGeoPackages ) { 
if ( new File ( external . getExternalPath ( ) ) . exists ( ) ) databases . add ( external . getName ( ) ) ; 
else delete ( external . getName ( ) ) ; 
} 
} 
} 

public class GeoPackageManagerImpl { 
private boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { 
try { 
if ( exists ( database ) ) if ( override ) if ( ! delete ( database ) ) throw new GeoPackageException ( "Failed to delete existing database: " + database ) ; 
else throw new GeoPackageException ( "GeoPackage database already exists: " + database ) ; 
File newDbFile = context . getDatabasePath ( database ) ; 
try { 
SQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; 
db . close ( ) ; 
GeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; 
} 
catch ( IOException e ) { 
throw new GeoPackageException ( "Failed to import GeoPackage database: " + database , e ) ; 
} 
} 
finally { 
GeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; 
} 
if ( progress == null || progress . isActive ( ) ) { 
try { 
SQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { 
@ Override public void onCorruption ( SQLiteDatabase dbObj ) { 
} 
} 
) ; 
validateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; 
GeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; 
metadataDb . open ( ) ; 
try { 
GeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; 
GeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; 
metadata . setName ( database ) ; 
dataSource . create ( metadata ) ; 
} 
finally { 
metadataDb . close ( ) ; 
} 
} 
catch ( Exception e ) { 
delete ( database ) ; 
throw new GeoPackageException ( "Invalid GeoPackage database file" , e ) ; 
} 
GeoPackage geoPackage = open ( database , false ) ; 
if ( geoPackage != null ) try { 
if ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { 
delete ( database ) ; 
throw new GeoPackageException ( "Invalid GeoPackage database file. Does not contain required tables: " + SpatialReferenceSystem . TABLE_NAME + " & " + Contents . TABLE_NAME + ", Database: " + database ) ; 
} 
} 
catch ( SQLException e ) { 
delete ( database ) ; 
throw new GeoPackageException ( "Invalid GeoPackage database file. Could not verify existence of required tables: " + SpatialReferenceSystem . TABLE_NAME + " & " + Contents . TABLE_NAME + ", Database: " + database ) ; 
} 
finally { 
geoPackage . close ( ) ; 
} 
else { 
delete ( database ) ; 
throw new GeoPackageException ( "Unable to open GeoPackage database. Database: " + database ) ; 
} 
} 
return exists ( database ) ; 
} 
} 

public class GeometryMetadataDataSource { 
public long create ( GeometryMetadata metadata ) { 
ContentValues values = new ContentValues ( ) ; 
values . put ( GeometryMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_ID , metadata . getId ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; 
long insertId = db . insert ( GeometryMetadata . TABLE_NAME , null , values ) ; 
if ( insertId == - 1 ) throw new GeoPackageException ( "Failed to insert geometry metadata. GeoPackage Id: " + metadata . getGeoPackageId ( ) + ", Table Name: " + metadata . getTableName ( ) + ", Geometry Id: " + metadata . getId ( ) ) ; 
metadata . setId ( insertId ) ; 
return insertId ; 
} 
} 

public class GeometryMetadataDataSource { 
public boolean createOrUpdate ( GeometryMetadata metadata ) { 
boolean success = false ; 
if ( exists ( metadata ) ) success = update ( metadata ) ; 
else { 
create ( metadata ) ; 
success = true ; 
} 
return success ; 
} 
} 

public class GeometryMetadataDataSource { 
public static GeometryMetadata createGeometryMetadata ( Cursor cursor ) { 
GeometryMetadata metadata = new GeometryMetadata ( ) ; 
metadata . setGeoPackageId ( cursor . getLong ( 0 ) ) ; 
metadata . setTableName ( cursor . getString ( 1 ) ) ; 
metadata . setId ( cursor . getLong ( 2 ) ) ; 
metadata . setMinX ( cursor . getDouble ( 3 ) ) ; 
metadata . setMaxX ( cursor . getDouble ( 4 ) ) ; 
metadata . setMinY ( cursor . getDouble ( 5 ) ) ; 
metadata . setMaxY ( cursor . getDouble ( 6 ) ) ; 
if ( ! cursor . isNull ( 7 ) ) metadata . setMinZ ( cursor . getDouble ( 7 ) ) ; 
if ( ! cursor . isNull ( 8 ) ) metadata . setMaxZ ( cursor . getDouble ( 8 ) ) ; 
if ( ! cursor . isNull ( 9 ) ) metadata . setMinM ( cursor . getDouble ( 9 ) ) ; 
if ( ! cursor . isNull ( 10 ) ) metadata . setMaxM ( cursor . getDouble ( 10 ) ) ; 
return metadata ; 
} 
} 

public class NumberFeaturesTile { 
private Bitmap drawTile ( int tileWidth , int tileHeight , String text ) { 
Bitmap bitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; 
Canvas canvas = new Canvas ( bitmap ) ; 
if ( tileFillPaint != null ) canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileFillPaint ) ; 
if ( tileBorderPaint != null ) canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileBorderPaint ) ; 
Rect textBounds = new Rect ( ) ; 
textPaint . getTextBounds ( text , 0 , text . length ( ) , textBounds ) ; 
int centerX = ( int ) ( bitmap . getWidth ( ) / 2.0f ) ; 
int centerY = ( int ) ( bitmap . getHeight ( ) / 2.0f ) ; 
if ( circlePaint != null || circleFillPaint != null ) { 
int diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; 
float radius = diameter / 2.0f ; 
radius = radius + ( diameter * circlePaddingPercentage ) ; 
if ( circleFillPaint != null ) canvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; 
if ( circlePaint != null ) canvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; 
} 
canvas . drawText ( text , centerX - textBounds . exactCenterX ( ) , centerY - textBounds . exactCenterY ( ) , textPaint ) ; 
return bitmap ; 
} 
} 

public class SimpleAttributesDao { 
public List < SimpleAttributesRow > getRows ( List < Long > ids ) { 
List < SimpleAttributesRow > simpleAttributesRows = new ArrayList < > ( ) ; 
for ( long id : ids ) { 
UserCustomRow userCustomRow = queryForIdRow ( id ) ; 
if ( userCustomRow != null ) simpleAttributesRows . add ( getRow ( userCustomRow ) ) ; 
} 
return simpleAttributesRows ; 
} 
} 

public class TileCreator { 
public GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { 
GeoPackageTile tile = null ; 
ProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; 
BoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; 
List < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; 
for ( int i = 0 ; 
tile == null && i < tileMatrices . size ( ) ; 
i ++ ) { 
TileMatrix tileMatrix = tileMatrices . get ( i ) ; 
TileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; 
if ( tileResults != null ) try { 
if ( tileResults . getCount ( ) > 0 ) { 
BoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; 
int requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; 
int requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; 
int tileWidth = requestedTileWidth ; 
int tileHeight = requestedTileHeight ; 
if ( ! sameProjection ) { 
tileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; 
tileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; 
} 
Bitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; 
if ( tileBitmap != null ) { 
if ( ! sameProjection ) { 
Bitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; 
tileBitmap . recycle ( ) ; 
tileBitmap = reprojectTile ; 
} 
try { 
byte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; 
tileBitmap . recycle ( ) ; 
tile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; 
} 
catch ( IOException e ) { 
Log . e ( TileCreator . class . getSimpleName ( ) , "Failed to create tile. min lat: " + requestBoundingBox . getMinLatitude ( ) + ", max lat: " + requestBoundingBox . getMaxLatitude ( ) + ", min lon: " + requestBoundingBox . getMinLongitude ( ) + ", max lon: " + requestBoundingBox . getMaxLongitude ( ) , e ) ; 
} 
} 
} 
} 
finally { 
tileResults . close ( ) ; 
} 
} 
return tile ; 
} 
} 

public class TileCreator { 
private Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { 
final double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; 
final double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; 
final double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; 
final double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; 
final int width = tile . getWidth ( ) ; 
final int height = tile . getHeight ( ) ; 
int [ ] pixels = new int [ width * height ] ; 
tile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; 
int [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; 
for ( int y = 0 ; 
y < requestedTileHeight ; 
y ++ ) for ( int x = 0 ; 
x < requestedTileWidth ; 
x ++ ) { 
double longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; 
double latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; 
ProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; 
ProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; 
double projectedLongitude = toCoord . x ; 
double projectedLatitude = toCoord . y ; 
int xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; 
int yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; 
xPixel = Math . max ( 0 , xPixel ) ; 
xPixel = Math . min ( width - 1 , xPixel ) ; 
yPixel = Math . max ( 0 , yPixel ) ; 
yPixel = Math . min ( height - 1 , yPixel ) ; 
int color = pixels [ ( yPixel * width ) + xPixel ] ; 
projectedPixels [ ( y * requestedTileWidth ) + x ] = color ; 
} 
Bitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; 
projectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; 
return projectedTileBitmap ; 
} 
} 

public class FeatureTiles { 
public void calculateDrawOverlap ( ) { 
if ( pointIcon != null ) { 
heightOverlap = this . density * pointIcon . getHeight ( ) ; 
widthOverlap = this . density * pointIcon . getWidth ( ) ; 
} 
else { 
heightOverlap = this . density * pointRadius ; 
widthOverlap = this . density * pointRadius ; 
} 
float linePaintHalfStroke = this . density * lineStrokeWidth / 2.0f ; 
heightOverlap = Math . max ( heightOverlap , linePaintHalfStroke ) ; 
widthOverlap = Math . max ( widthOverlap , linePaintHalfStroke ) ; 
float polygonPaintHalfStroke = this . density * polygonStrokeWidth / 2.0f ; 
heightOverlap = Math . max ( heightOverlap , polygonPaintHalfStroke ) ; 
widthOverlap = Math . max ( widthOverlap , polygonPaintHalfStroke ) ; 
if ( featureTableStyles != null && featureTableStyles . has ( ) ) { 
Set < Long > styleRowIds = new HashSet < > ( ) ; 
List < Long > tableStyleIds = featureTableStyles . getAllTableStyleIds ( ) ; 
if ( tableStyleIds != null ) styleRowIds . addAll ( tableStyleIds ) ; 
List < Long > styleIds = featureTableStyles . getAllStyleIds ( ) ; 
if ( styleIds != null ) styleRowIds . addAll ( styleIds ) ; 
StyleDao styleDao = featureTableStyles . getStyleDao ( ) ; 
for ( long styleRowId : styleRowIds ) { 
StyleRow styleRow = styleDao . getRow ( styleDao . queryForIdRow ( styleRowId ) ) ; 
float styleHalfWidth = this . density * ( float ) ( styleRow . getWidthOrDefault ( ) / 2.0f ) ; 
widthOverlap = Math . max ( widthOverlap , styleHalfWidth ) ; 
heightOverlap = Math . max ( heightOverlap , styleHalfWidth ) ; 
} 
Set < Long > iconRowIds = new HashSet < > ( ) ; 
List < Long > tableIconIds = featureTableStyles . getAllTableIconIds ( ) ; 
if ( tableIconIds != null ) iconRowIds . addAll ( tableIconIds ) ; 
List < Long > iconIds = featureTableStyles . getAllIconIds ( ) ; 
if ( iconIds != null ) iconRowIds . addAll ( iconIds ) ; 
IconDao iconDao = featureTableStyles . getIconDao ( ) ; 
for ( long iconRowId : iconRowIds ) { 
IconRow iconRow = iconDao . getRow ( iconDao . queryForIdRow ( iconRowId ) ) ; 
double [ ] iconDimensions = iconRow . getDerivedDimensions ( ) ; 
float iconWidth = this . density * ( float ) Math . ceil ( iconDimensions [ 0 ] ) ; 
float iconHeight = this . density * ( float ) Math . ceil ( iconDimensions [ 1 ] ) ; 
widthOverlap = Math . max ( widthOverlap , iconWidth ) ; 
heightOverlap = Math . max ( heightOverlap , iconHeight ) ; 
} 
} 
} 
} 

public class FeatureTiles { 
public void setLinePaint ( Paint linePaint ) { 
if ( linePaint == null ) throw new AssertionError ( "Line Paint can not be null" ) ; 
this . linePaint = linePaint ; 
setLineStrokeWidth ( linePaint . getStrokeWidth ( ) ) ; 
} 
} 

public class FeatureTiles { 
public void setPolygonPaint ( Paint polygonPaint ) { 
if ( polygonPaint == null ) throw new AssertionError ( "Polygon Paint can not be null" ) ; 
this . polygonPaint = polygonPaint ; 
setPolygonStrokeWidth ( polygonPaint . getStrokeWidth ( ) ) ; 
} 
} 

public class FeatureTiles { 
public byte [ ] drawTileBytes ( int x , int y , int zoom ) { 
Bitmap bitmap = drawTile ( x , y , zoom ) ; 
byte [ ] tileData = null ; 
if ( bitmap != null ) try { 
tileData = BitmapConverter . toBytes ( bitmap , compressFormat ) ; 
} 
catch ( IOException e ) { 
Log . e ( FeatureTiles . class . getSimpleName ( ) , "Failed to create tile. x: " + x + ", y: " + y + ", zoom: " + zoom , e ) ; 
} 
finally { 
bitmap . recycle ( ) ; 
} 
return tileData ; 
} 
} 

public class FeatureTiles { 
public Bitmap drawTile ( int x , int y , int zoom ) { 
Bitmap bitmap ; 
if ( isIndexQuery ( ) ) bitmap = drawTileQueryIndex ( x , y , zoom ) ; 
else bitmap = drawTileQueryAll ( x , y , zoom ) ; 
return bitmap ; 
} 
} 

public class FeatureTiles { 
public Bitmap drawTileQueryIndex ( int x , int y , int zoom ) { 
BoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; 
Bitmap bitmap = null ; 
FeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; 
try { 
long tileCount = results . count ( ) ; 
if ( tileCount > 0 ) if ( maxFeaturesPerTile == null || tileCount <= maxFeaturesPerTile . longValue ( ) ) bitmap = drawTile ( zoom , webMercatorBoundingBox , results ) ; 
else if ( maxFeaturesTileDraw != null ) bitmap = maxFeaturesTileDraw . drawTile ( tileWidth , tileHeight , tileCount , results ) ; 
} 
finally { 
results . close ( ) ; 
} 
return bitmap ; 
} 
} 

public class FeatureTiles { 
public Bitmap drawTileQueryAll ( int x , int y , int zoom ) { 
BoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; 
Bitmap bitmap = null ; 
FeatureCursor cursor = featureDao . queryForAll ( ) ; 
try { 
int totalCount = cursor . getCount ( ) ; 
if ( totalCount > 0 ) if ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) bitmap = drawTile ( zoom , boundingBox , cursor ) ; 
else if ( maxFeaturesTileDraw != null ) bitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return bitmap ; 
} 
} 

public class FeatureTiles { 
protected List < Point > simplifyPoints ( double simplifyTolerance , List < Point > points ) { 
List < Point > simplifiedPoints = null ; 
if ( simplifyGeometries ) { 
if ( projection != null && ! projection . isUnit ( Units . METRES ) ) { 
ProjectionTransform toWebMercator = projection . getTransformation ( WEB_MERCATOR_PROJECTION ) ; 
points = toWebMercator . transform ( points ) ; 
} 
simplifiedPoints = GeometryUtils . simplifyPoints ( points , simplifyTolerance ) ; 
if ( projection != null && ! projection . isUnit ( Units . METRES ) ) { 
ProjectionTransform fromWebMercator = WEB_MERCATOR_PROJECTION . getTransformation ( projection ) ; 
simplifiedPoints = fromWebMercator . transform ( simplifiedPoints ) ; 
} 
} 
else simplifiedPoints = points ; 
return simplifiedPoints ; 
} 
} 

public class FeatureTiles { 
protected Paint getPointPaint ( FeatureStyle featureStyle ) { 
Paint paint = getFeatureStylePaint ( featureStyle , FeatureDrawType . CIRCLE ) ; 
if ( paint == null ) paint = pointPaint ; 
return paint ; 
} 
} 

public class FeatureTiles { 
protected Paint getLinePaint ( FeatureStyle featureStyle ) { 
Paint paint = getFeatureStylePaint ( featureStyle , FeatureDrawType . STROKE ) ; 
if ( paint == null ) paint = linePaint ; 
return paint ; 
} 
} 

public class FeatureTiles { 
protected Paint getPolygonPaint ( FeatureStyle featureStyle ) { 
Paint paint = getFeatureStylePaint ( featureStyle , FeatureDrawType . STROKE ) ; 
if ( paint == null ) paint = polygonPaint ; 
return paint ; 
} 
} 

public class FeatureTiles { 
protected Paint getPolygonFillPaint ( FeatureStyle featureStyle ) { 
Paint paint = null ; 
boolean hasStyleColor = false ; 
if ( featureStyle != null ) { 
StyleRow style = featureStyle . getStyle ( ) ; 
if ( style != null ) if ( style . hasFillColor ( ) ) paint = getStylePaint ( style , FeatureDrawType . FILL ) ; 
else hasStyleColor = style . hasColor ( ) ; 
} 
if ( paint == null && ! hasStyleColor && fillPolygon ) paint = polygonFillPaint ; 
return paint ; 
} 
} 

public class FeatureTiles { 
private Paint getFeatureStylePaint ( FeatureStyle featureStyle , FeatureDrawType drawType ) { 
Paint paint = null ; 
if ( featureStyle != null ) { 
StyleRow style = featureStyle . getStyle ( ) ; 
if ( style != null && style . hasColor ( ) ) paint = getStylePaint ( style , drawType ) ; 
} 
return paint ; 
} 
} 

public class FeatureTiles { 
private Paint getStylePaint ( StyleRow style , FeatureDrawType drawType ) { 
Paint paint = featurePaintCache . getPaint ( style , drawType ) ; 
if ( paint == null ) { 
Color color = null ; 
Style paintStyle = null ; 
Float strokeWidth = null ; 
switch ( drawType ) { 
case CIRCLE : color = style . getColorOrDefault ( ) ; 
paintStyle = Style . FILL ; 
break ; 
case STROKE : color = style . getColorOrDefault ( ) ; 
paintStyle = Style . STROKE ; 
strokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; 
break ; 
case FILL : color = style . getFillColor ( ) ; 
paintStyle = Style . FILL ; 
strokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; 
break ; 
default : throw new GeoPackageException ( "Unsupported Draw Type: " + drawType ) ; 
} 
Paint stylePaint = new Paint ( ) ; 
stylePaint . setAntiAlias ( true ) ; 
stylePaint . setStyle ( paintStyle ) ; 
stylePaint . setColor ( color . getColorWithAlpha ( ) ) ; 
if ( strokeWidth != null ) stylePaint . setStrokeWidth ( strokeWidth ) ; 
synchronized ( featurePaintCache ) { 
paint = featurePaintCache . getPaint ( style , drawType ) ; 
if ( paint == null ) { 
featurePaintCache . setPaint ( style , drawType , stylePaint ) ; 
paint = stylePaint ; 
} 
} 
} 
return paint ; 
} 
} 

public class FeaturePaintCache { 
public Paint getPaint ( long styleId , FeatureDrawType type ) { 
Paint paint = null ; 
FeaturePaint featurePaint = getFeaturePaint ( styleId ) ; 
if ( featurePaint != null ) paint = featurePaint . getPaint ( type ) ; 
return paint ; 
} 
} 

public class IconCache { 
public static Bitmap createIcon ( IconRow icon , float density , IconCache iconCache ) { 
Bitmap iconImage = null ; 
if ( icon != null ) { 
if ( iconCache != null ) iconImage = iconCache . get ( icon . getId ( ) ) ; 
if ( iconImage == null ) { 
BitmapFactory . Options options = icon . getDataBounds ( ) ; 
int dataWidth = options . outWidth ; 
int dataHeight = options . outHeight ; 
double styleWidth = dataWidth ; 
double styleHeight = dataHeight ; 
double widthDensity = DisplayMetrics . DENSITY_DEFAULT ; 
double heightDensity = DisplayMetrics . DENSITY_DEFAULT ; 
if ( icon . getWidth ( ) != null ) { 
styleWidth = icon . getWidth ( ) ; 
double widthRatio = dataWidth / styleWidth ; 
widthDensity *= widthRatio ; 
if ( icon . getHeight ( ) == null ) heightDensity = widthDensity ; 
} 
if ( icon . getHeight ( ) != null ) { 
styleHeight = icon . getHeight ( ) ; 
double heightRatio = dataHeight / styleHeight ; 
heightDensity *= heightRatio ; 
if ( icon . getWidth ( ) == null ) widthDensity = heightDensity ; 
} 
options = new BitmapFactory . Options ( ) ; 
options . inDensity = ( int ) ( Math . min ( widthDensity , heightDensity ) + 0.5f ) ; 
options . inTargetDensity = ( int ) ( DisplayMetrics . DENSITY_DEFAULT * density + 0.5f ) ; 
iconImage = icon . getDataBitmap ( options ) ; 
if ( widthDensity != heightDensity ) { 
int width = ( int ) ( styleWidth * density + 0.5f ) ; 
int height = ( int ) ( styleHeight * density + 0.5f ) ; 
if ( width != iconImage . getWidth ( ) || height != iconImage . getHeight ( ) ) { 
Bitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; 
iconImage . recycle ( ) ; 
iconImage = scaledBitmap ; 
} 
} 
if ( iconCache != null ) iconCache . put ( icon . getId ( ) , iconImage ) ; 
} 
} 
return iconImage ; 
} 
} 

public class FeatureStyleExtension { 
private StyleMappingDao getMappingDao ( String tablePrefix , String featureTable ) { 
String tableName = tablePrefix + featureTable ; 
StyleMappingDao dao = null ; 
if ( geoPackage . isTable ( tableName ) ) dao = new StyleMappingDao ( relatedTables . getUserDao ( tableName ) ) ; 
return dao ; 
} 
} 

public class FeatureStyleExtension { 
public FeatureStyles getTableFeatureStyles ( String featureTable ) { 
FeatureStyles featureStyles = null ; 
Long id = contentsId . getId ( featureTable ) ; 
if ( id != null ) { 
Styles styles = getTableStyles ( featureTable , id ) ; 
Icons icons = getTableIcons ( featureTable , id ) ; 
if ( styles != null || icons != null ) featureStyles = new FeatureStyles ( styles , icons ) ; 
} 
return featureStyles ; 
} 
} 

public class FeatureStyleExtension { 
public Styles getTableStyles ( String featureTable ) { 
Styles styles = null ; 
Long id = contentsId . getId ( featureTable ) ; 
if ( id != null ) styles = getTableStyles ( featureTable , id ) ; 
return styles ; 
} 
} 

public class FeatureStyleExtension { 
public StyleRow getTableStyle ( String featureTable , GeometryType geometryType ) { 
StyleRow styleRow = null ; 
Styles tableStyles = getTableStyles ( featureTable ) ; 
if ( tableStyles != null ) styleRow = tableStyles . getStyle ( geometryType ) ; 
return styleRow ; 
} 
} 

public class FeatureStyleExtension { 
public Icons getTableIcons ( String featureTable ) { 
Icons icons = null ; 
Long id = contentsId . getId ( featureTable ) ; 
if ( id != null ) icons = getTableIcons ( featureTable , id ) ; 
return icons ; 
} 
} 

public class FeatureStyleExtension { 
public IconRow getTableIcon ( String featureTable , GeometryType geometryType ) { 
IconRow iconRow = null ; 
Icons tableIcons = getTableIcons ( featureTable ) ; 
if ( tableIcons != null ) iconRow = tableIcons . getIcon ( geometryType ) ; 
return iconRow ; 
} 
} 

public class FeatureStyleExtension { 
public FeatureStyles getFeatureStyles ( String featureTable , long featureId ) { 
Styles styles = getStyles ( featureTable , featureId ) ; 
Icons icons = getIcons ( featureTable , featureId ) ; 
FeatureStyles featureStyles = null ; 
if ( styles != null || icons != null ) featureStyles = new FeatureStyles ( styles , icons ) ; 
return featureStyles ; 
} 
} 

public class FeatureStyleExtension { 
private Styles getStyles ( long featureId , StyleMappingDao mappingDao ) { 
Styles styles = null ; 
if ( mappingDao != null ) { 
StyleDao styleDao = getStyleDao ( ) ; 
if ( styleDao != null ) { 
List < StyleMappingRow > styleMappingRows = mappingDao . queryByBaseFeatureId ( featureId ) ; 
if ( ! styleMappingRows . isEmpty ( ) ) for ( StyleMappingRow styleMappingRow : styleMappingRows ) { 
StyleRow styleRow = styleDao . queryForRow ( styleMappingRow ) ; 
if ( styleRow != null ) { 
if ( styles == null ) styles = new Styles ( ) ; 
styles . setStyle ( styleRow , styleMappingRow . getGeometryType ( ) ) ; 
} 
} 
} 
} 
return styles ; 
} 
} 

public class FeatureStyleExtension { 
private Icons getIcons ( long featureId , StyleMappingDao mappingDao ) { 
Icons icons = null ; 
if ( mappingDao != null ) { 
IconDao iconDao = getIconDao ( ) ; 
if ( iconDao != null ) { 
List < StyleMappingRow > styleMappingRows = mappingDao . queryByBaseFeatureId ( featureId ) ; 
if ( ! styleMappingRows . isEmpty ( ) ) for ( StyleMappingRow styleMappingRow : styleMappingRows ) { 
IconRow iconRow = iconDao . queryForRow ( styleMappingRow ) ; 
if ( iconRow != null ) { 
if ( icons == null ) icons = new Icons ( ) ; 
icons . setIcon ( iconRow , styleMappingRow . getGeometryType ( ) ) ; 
} 
} 
} 
} 
return icons ; 
} 
} 

public class FeatureStyleExtension { 
public void setTableFeatureStyles ( String featureTable , FeatureStyles featureStyles ) { 
if ( featureStyles != null ) { 
setTableStyles ( featureTable , featureStyles . getStyles ( ) ) ; 
setTableIcons ( featureTable , featureStyles . getIcons ( ) ) ; 
} 
else deleteTableFeatureStyles ( featureTable ) ; 
} 
} 

public class FeatureStyleExtension { 
public void setTableStyles ( String featureTable , Styles styles ) { 
deleteTableStyles ( featureTable ) ; 
if ( styles != null ) { 
if ( styles . getDefault ( ) != null ) setTableStyleDefault ( featureTable , styles . getDefault ( ) ) ; 
for ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { 
setTableStyle ( featureTable , style . getKey ( ) , style . getValue ( ) ) ; 
} 
} 
} 
} 

public class FeatureStyleExtension { 
public void setTableIcons ( String featureTable , Icons icons ) { 
deleteTableIcons ( featureTable ) ; 
if ( icons != null ) { 
if ( icons . getDefault ( ) != null ) setTableIconDefault ( featureTable , icons . getDefault ( ) ) ; 
for ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { 
setTableIcon ( featureTable , icon . getKey ( ) , icon . getValue ( ) ) ; 
} 
} 
} 
} 

public class FeatureStyleExtension { 
public void setStyles ( String featureTable , long featureId , Styles styles ) { 
deleteStyles ( featureTable , featureId ) ; 
if ( styles != null ) { 
if ( styles . getDefault ( ) != null ) setStyleDefault ( featureTable , featureId , styles . getDefault ( ) ) ; 
for ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { 
setStyle ( featureTable , featureId , style . getKey ( ) , style . getValue ( ) ) ; 
} 
} 
} 
} 

public class FeatureStyleExtension { 
public void setIcons ( String featureTable , long featureId , Icons icons ) { 
deleteIcons ( featureTable , featureId ) ; 
if ( icons != null ) { 
if ( icons . getDefault ( ) != null ) setIconDefault ( featureTable , featureId , icons . getDefault ( ) ) ; 
for ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { 
setIcon ( featureTable , featureId , icon . getKey ( ) , icon . getValue ( ) ) ; 
} 
} 
} 
} 

public class FeatureStyleExtension { 
private long getOrInsertStyle ( StyleRow style ) { 
long styleId ; 
if ( style . hasId ( ) ) styleId = style . getId ( ) ; 
else { 
StyleDao styleDao = getStyleDao ( ) ; 
styleId = styleDao . create ( style ) ; 
} 
return styleId ; 
} 
} 

public class FeatureStyleExtension { 
private long getOrInsertIcon ( IconRow icon ) { 
long iconId ; 
if ( icon . hasId ( ) ) iconId = icon . getId ( ) ; 
else { 
IconDao iconDao = getIconDao ( ) ; 
iconId = iconDao . create ( icon ) ; 
} 
return iconId ; 
} 
} 

public class FeatureStyleExtension { 
private void deleteTableMappings ( StyleMappingDao mappingDao , String featureTable ) { 
if ( mappingDao != null ) { 
Long featureContentsId = contentsId . getId ( featureTable ) ; 
if ( featureContentsId != null ) mappingDao . deleteByBaseId ( featureContentsId ) ; 
} 
} 
} 

public class FeatureStyleExtension { 
private void deleteTableMapping ( StyleMappingDao mappingDao , String featureTable , GeometryType geometryType ) { 
if ( mappingDao != null ) { 
Long featureContentsId = contentsId . getId ( featureTable ) ; 
if ( featureContentsId != null ) mappingDao . deleteByBaseId ( featureContentsId , geometryType ) ; 
} 
} 
} 

public class FeatureStyleExtension { 
private void deleteMapping ( StyleMappingDao mappingDao , long featureId , GeometryType geometryType ) { 
if ( mappingDao != null ) mappingDao . deleteByBaseId ( featureId , geometryType ) ; 
} 
} 

public class FeatureStyleExtension { 
public List < Long > getAllTableStyleIds ( String featureTable ) { 
List < Long > styleIds = null ; 
StyleMappingDao mappingDao = getTableStyleMappingDao ( featureTable ) ; 
if ( mappingDao != null ) styleIds = mappingDao . uniqueRelatedIds ( ) ; 
return styleIds ; 
} 
} 

public class FeatureStyleExtension { 
public List < Long > getAllTableIconIds ( String featureTable ) { 
List < Long > iconIds = null ; 
StyleMappingDao mappingDao = getTableIconMappingDao ( featureTable ) ; 
if ( mappingDao != null ) iconIds = mappingDao . uniqueRelatedIds ( ) ; 
return iconIds ; 
} 
} 

public class FeatureStyleExtension { 
public List < Long > getAllStyleIds ( String featureTable ) { 
List < Long > styleIds = null ; 
StyleMappingDao mappingDao = getStyleMappingDao ( featureTable ) ; 
if ( mappingDao != null ) styleIds = mappingDao . uniqueRelatedIds ( ) ; 
return styleIds ; 
} 
} 

public class FeatureStyleExtension { 
public List < Long > getAllIconIds ( String featureTable ) { 
List < Long > iconIds = null ; 
StyleMappingDao mappingDao = getIconMappingDao ( featureTable ) ; 
if ( mappingDao != null ) iconIds = mappingDao . uniqueRelatedIds ( ) ; 
return iconIds ; 
} 
} 

public class CoverageDataPngImage { 
public byte [ ] getImageBytes ( ) { 
byte [ ] bytes = null ; 
if ( imageBytes != null ) bytes = imageBytes ; 
else if ( outputStream != null ) bytes = outputStream . toByteArray ( ) ; 
return bytes ; 
} 
} 

public class CoverageDataPngImage { 
public void flushStream ( ) { 
if ( outputStream != null ) { 
if ( imageBytes == null ) imageBytes = outputStream . toByteArray ( ) ; 
try { 
outputStream . close ( ) ; 
} 
catch ( IOException e ) { 
Log . w ( CoverageDataPngImage . class . getSimpleName ( ) , "Failed to close output stream" , e ) ; 
} 
} 
} 
} 

public class CoverageDataPngImage { 
public int getPixel ( int x , int y ) { 
int pixel = - 1 ; 
if ( pixels == null ) readPixels ( ) ; 
if ( pixels != null ) pixel = pixels [ y ] [ x ] ; 
else throw new GeoPackageException ( "Could not retrieve pixel value" ) ; 
return pixel ; 
} 
} 

public class DefaultFeatureTiles { 
private void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { 
List < Point > points = lineString . getPoints ( ) ; 
if ( points . size ( ) >= 2 ) { 
points = simplifyPoints ( simplifyTolerance , points ) ; 
for ( int i = 0 ; 
i < points . size ( ) ; 
i ++ ) { 
Point point = points . get ( i ) ; 
Point webMercatorPoint = transform . transform ( point ) ; 
float x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; 
float y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; 
if ( i == 0 ) path . moveTo ( x , y ) ; 
else path . lineTo ( x , y ) ; 
} 
} 
} 
} 

public class DefaultFeatureTiles { 
private void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { 
List < LineString > rings = polygon . getRings ( ) ; 
if ( ! rings . isEmpty ( ) ) { 
LineString polygonLineString = rings . get ( 0 ) ; 
List < Point > polygonPoints = polygonLineString . getPoints ( ) ; 
if ( polygonPoints . size ( ) >= 2 ) { 
addRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; 
for ( int i = 1 ; 
i < rings . size ( ) ; 
i ++ ) { 
LineString holeLineString = rings . get ( i ) ; 
List < Point > holePoints = holeLineString . getPoints ( ) ; 
if ( holePoints . size ( ) >= 2 ) addRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; 
} 
} 
} 
} 
} 

public class FeatureTableStyles { 
public Styles getCachedTableStyles ( ) { 
Styles styles = cachedTableFeatureStyles . getStyles ( ) ; 
if ( styles == null ) synchronized ( cachedTableFeatureStyles ) { 
styles = cachedTableFeatureStyles . getStyles ( ) ; 
if ( styles == null ) { 
styles = getTableStyles ( ) ; 
if ( styles == null ) styles = new Styles ( ) ; 
cachedTableFeatureStyles . setStyles ( styles ) ; 
} 
} 
if ( styles . isEmpty ( ) ) styles = null ; 
return styles ; 
} 
} 

public class FeatureTableStyles { 
public Icons getCachedTableIcons ( ) { 
Icons icons = cachedTableFeatureStyles . getIcons ( ) ; 
if ( icons == null ) synchronized ( cachedTableFeatureStyles ) { 
icons = cachedTableFeatureStyles . getIcons ( ) ; 
if ( icons == null ) { 
icons = getTableIcons ( ) ; 
if ( icons == null ) icons = new Icons ( ) ; 
cachedTableFeatureStyles . setIcons ( icons ) ; 
} 
} 
if ( icons . isEmpty ( ) ) icons = null ; 
return icons ; 
} 
} 

public class IconRow { 
public void setWidth ( Double width ) { 
if ( width != null && width < 0.0 ) throw new GeoPackageException ( "Width must be greater than or equal to 0.0, invalid value: " + width ) ; 
setValue ( getWidthColumnIndex ( ) , width ) ; 
} 
} 

public class IconRow { 
public void setHeight ( Double height ) { 
if ( height != null && height < 0.0 ) throw new GeoPackageException ( "Height must be greater than or equal to 0.0, invalid value: " + height ) ; 
setValue ( getHeightColumnIndex ( ) , height ) ; 
} 
} 

public class IconRow { 
public double [ ] getDerivedDimensions ( ) { 
Double width = getWidth ( ) ; 
Double height = getHeight ( ) ; 
if ( width == null || height == null ) { 
BitmapFactory . Options options = getDataBounds ( ) ; 
int dataWidth = options . outWidth ; 
int dataHeight = options . outHeight ; 
if ( width == null ) { 
width = ( double ) dataWidth ; 
if ( height != null ) width *= ( height / dataHeight ) ; 
} 
if ( height == null ) { 
height = ( double ) dataHeight ; 
if ( width != null ) height *= ( width / dataWidth ) ; 
} 
} 
return new double [ ] { 
width , height } 
; 
} 
} 

public class UserInvalidCursor { 
private void readBlobValue ( UserRow row , UserColumn column ) { 
ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; 
try { 
byte [ ] blobChunk = new byte [ ] { 
0 } 
; 
for ( int i = 1 ; 
blobChunk . length > 0 ; 
i += CHUNK_SIZE ) { 
if ( i > 1 ) byteStream . write ( blobChunk ) ; 
blobChunk = new byte [ ] { 
} 
; 
String query = "select substr(" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + ", " + i + ", " + CHUNK_SIZE + ") from " + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + " where " + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + " = " + row . getId ( ) ; 
Cursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; 
try { 
if ( blobCursor . moveToNext ( ) ) blobChunk = blobCursor . getBlob ( 0 ) ; 
} 
finally { 
blobCursor . close ( ) ; 
} 
} 
byte [ ] blob = byteStream . toByteArray ( ) ; 
row . setValue ( column . getIndex ( ) , blob ) ; 
} 
catch ( IOException e ) { 
Log . e ( UserInvalidCursor . class . getSimpleName ( ) , "Failed to read large blob value. Table: " + dao . getTableName ( ) + ", Column: " + column . getName ( ) + ", Position: " + getPosition ( ) , e ) ; 
} 
finally { 
IOUtils . closeQuietly ( byteStream ) ; 
} 
} 
} 

public class StyleRow { 
public Color getColorOrDefault ( ) { 
Color color = getColor ( ) ; 
if ( color == null ) color = new Color ( ) ; 
return color ; 
} 
} 

public class StyleRow { 
private String validateColor ( String color ) { 
String validated = color ; 
if ( color != null ) { 
if ( ! color . startsWith ( "#" ) ) validated = "#" + color ; 
if ( ! colorPattern . matcher ( validated ) . matches ( ) ) throw new GeoPackageException ( "Color must be in hex format #RRGGBB or #RGB, invalid value: " + color ) ; 
validated = validated . toUpperCase ( ) ; 
} 
return validated ; 
} 
} 

public class StyleRow { 
private Color createColor ( String hexColor , Double opacity ) { 
Color color = null ; 
if ( hexColor != null || opacity != null ) { 
color = new Color ( ) ; 
if ( hexColor != null ) color . setColor ( hexColor ) ; 
if ( opacity != null ) color . setOpacity ( opacity . floatValue ( ) ) ; 
} 
return color ; 
} 
} 

public class FeatureIndexManager { 
public boolean index ( FeatureRow row , List < FeatureIndexType > types ) { 
boolean indexed = false ; 
for ( FeatureIndexType type : types ) { 
if ( index ( type , row ) ) indexed = true ; 
} 
return indexed ; 
} 
} 

public class FeatureIndexManager { 
public boolean deleteIndex ( Collection < FeatureIndexType > types ) { 
boolean deleted = false ; 
for ( FeatureIndexType type : types ) { 
if ( deleteIndex ( type ) ) deleted = true ; 
} 
return deleted ; 
} 
} 

public class FeatureIndexManager { 
public boolean deleteIndex ( FeatureRow row , List < FeatureIndexType > types ) { 
boolean deleted = false ; 
for ( FeatureIndexType type : types ) { 
if ( deleteIndex ( type , row ) ) deleted = true ; 
} 
return deleted ; 
} 
} 

public class FeatureIndexManager { 
public boolean deleteIndex ( long geomId , List < FeatureIndexType > types ) { 
boolean deleted = false ; 
for ( FeatureIndexType type : types ) { 
if ( deleteIndex ( type , geomId ) ) deleted = true ; 
} 
return deleted ; 
} 
} 

public class FeatureIndexManager { 
public boolean deleteIndex ( FeatureIndexType type , long geomId ) { 
if ( type == null ) throw new GeoPackageException ( "FeatureIndexType is required to delete index" ) ; 
boolean deleted = false ; 
switch ( type ) { 
case GEOPACKAGE : deleted = featureTableIndex . deleteIndex ( geomId ) > 0 ; 
break ; 
case METADATA : deleted = featureIndexer . deleteIndex ( geomId ) ; 
break ; 
case RTREE : deleted = true ; 
break ; 
default : throw new GeoPackageException ( "Unsupported FeatureIndexType: " + type ) ; 
} 
return deleted ; 
} 
} 

public class FeatureIndexManager { 
public boolean isIndexed ( ) { 
boolean indexed = false ; 
for ( FeatureIndexType type : indexLocationQueryOrder ) { 
indexed = isIndexed ( type ) ; 
if ( indexed ) break ; 
} 
return indexed ; 
} 
} 

public class FeatureIndexManager { 
public List < FeatureIndexType > getIndexedTypes ( ) { 
List < FeatureIndexType > indexed = new ArrayList < > ( ) ; 
for ( FeatureIndexType type : indexLocationQueryOrder ) { 
if ( isIndexed ( type ) ) indexed . add ( type ) ; 
} 
return indexed ; 
} 
} 

public class ContextIOUtils { 
public static File getInternalFile ( Context context , String filePath ) { 
File internalFile = null ; 
if ( filePath != null ) internalFile = new File ( context . getFilesDir ( ) , filePath ) ; 
else internalFile = context . getFilesDir ( ) ; 
return internalFile ; 
} 
} 

public class StyleMappingRow { 
public GeometryType getGeometryType ( ) { 
GeometryType geometryType = null ; 
String geometryTypeName = getGeometryTypeName ( ) ; 
if ( geometryTypeName != null ) geometryType = GeometryType . fromName ( geometryTypeName ) ; 
return geometryType ; 
} 
} 

public class StyleMappingRow { 
public void setGeometryType ( GeometryType geometryType ) { 
String geometryTypeName = null ; 
if ( geometryType != null ) geometryTypeName = geometryType . getName ( ) ; 
setValue ( getGeometryTypeNameColumnIndex ( ) , geometryTypeName ) ; 
} 
} 

public class FeatureCursor { 
public GeoPackageGeometryData getGeometry ( ) { 
GeoPackageGeometryData geometry = null ; 
int columnIndex = getTable ( ) . getGeometryColumnIndex ( ) ; 
int type = getType ( columnIndex ) ; 
if ( type != FIELD_TYPE_NULL ) { 
byte [ ] geometryBytes = getBlob ( columnIndex ) ; 
if ( geometryBytes != null ) geometry = new GeoPackageGeometryData ( geometryBytes ) ; 
} 
return geometry ; 
} 
} 

public class FeatureIndexer { 
private boolean index ( long geoPackageId , FeatureRow row , boolean possibleUpdate ) { 
boolean indexed = false ; 
GeoPackageGeometryData geomData = row . getGeometry ( ) ; 
if ( geomData != null ) { 
GeometryEnvelope envelope = geomData . getEnvelope ( ) ; 
if ( envelope == null ) { 
Geometry geometry = geomData . getGeometry ( ) ; 
if ( geometry != null ) envelope = GeometryEnvelopeBuilder . buildEnvelope ( geometry ) ; 
} 
if ( envelope != null ) { 
GeometryMetadata metadata = geometryMetadataDataSource . populate ( geoPackageId , featureDao . getTableName ( ) , row . getId ( ) , envelope ) ; 
if ( possibleUpdate ) geometryMetadataDataSource . createOrUpdate ( metadata ) ; 
else geometryMetadataDataSource . create ( metadata ) ; 
indexed = true ; 
} 
} 
return indexed ; 
} 
} 

public class FeatureIndexer { 
private void updateLastIndexed ( GeoPackageMetadataDb db , long geoPackageId ) { 
long indexedTime = ( new Date ( ) ) . getTime ( ) ; 
TableMetadataDataSource ds = new TableMetadataDataSource ( db ) ; 
if ( ! ds . updateLastIndexed ( geoPackageId , featureDao . getTableName ( ) , indexedTime ) ) throw new GeoPackageException ( "Failed to update last indexed time. Table: GeoPackage Id: " + geoPackageId + ", Table: " + featureDao . getTableName ( ) + ", Last Indexed: " + indexedTime ) ; 
} 
} 

public class FeatureIndexer { 
public FeatureRow getFeatureRow ( GeometryMetadata geometryMetadata ) { 
long geomId = geometryMetadata . getId ( ) ; 
FeatureRow row = featureRowSync . getRowOrLock ( geomId ) ; 
if ( row == null ) try { 
row = featureDao . queryForIdRow ( geomId ) ; 
} 
finally { 
featureRowSync . setRow ( geomId , row ) ; 
} 
return row ; 
} 
} 

public class FeatureTileGenerator { 
private static BoundingBox getBoundingBox ( GeoPackage geoPackage , FeatureTiles featureTiles , BoundingBox boundingBox , Projection projection ) { 
String tableName = featureTiles . getFeatureDao ( ) . getTableName ( ) ; 
boolean manualQuery = boundingBox == null ; 
BoundingBox featureBoundingBox = geoPackage . getBoundingBox ( projection , tableName , manualQuery ) ; 
if ( featureBoundingBox != null ) if ( boundingBox == null ) boundingBox = featureBoundingBox ; 
else boundingBox = boundingBox . overlap ( featureBoundingBox ) ; 
if ( boundingBox != null ) boundingBox = featureTiles . expandBoundingBox ( boundingBox , projection ) ; 
return boundingBox ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public void create ( GeoPackageMetadata metadata ) { 
ContentValues values = new ContentValues ( ) ; 
values . put ( GeoPackageMetadata . COLUMN_NAME , metadata . getName ( ) ) ; 
values . put ( GeoPackageMetadata . COLUMN_EXTERNAL_PATH , metadata . getExternalPath ( ) ) ; 
long insertId = db . insert ( GeoPackageMetadata . TABLE_NAME , null , values ) ; 
if ( insertId == - 1 ) throw new GeoPackageException ( "Failed to insert GeoPackage metadata. Name: " + metadata . getName ( ) + ", External Path: " + metadata . getExternalPath ( ) ) ; 
metadata . setId ( insertId ) ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public boolean rename ( GeoPackageMetadata metadata , String newName ) { 
boolean renamed = rename ( metadata . getName ( ) , newName ) ; 
if ( renamed ) metadata . setName ( newName ) ; 
return renamed ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public GeoPackageMetadata get ( String database ) { 
GeoPackageMetadata metadata = null ; 
String selection = GeoPackageMetadata . COLUMN_NAME + " = ?" ; 
String [ ] selectionArgs = new String [ ] { 
database } 
; 
Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; 
try { 
if ( cursor . moveToNext ( ) ) metadata = createGeoPackageMetadata ( cursor ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return metadata ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public GeoPackageMetadata get ( long id ) { 
GeoPackageMetadata metadata = null ; 
String selection = GeoPackageMetadata . COLUMN_ID + " = ?" ; 
String [ ] selectionArgs = new String [ ] { 
String . valueOf ( id ) } 
; 
Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; 
try { 
if ( cursor . moveToNext ( ) ) metadata = createGeoPackageMetadata ( cursor ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return metadata ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public GeoPackageMetadata getExternalAtPath ( String path ) { 
GeoPackageMetadata metadata = null ; 
String selection = GeoPackageMetadata . COLUMN_EXTERNAL_PATH + " = ?" ; 
String [ ] selectionArgs = new String [ ] { 
path } 
; 
Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; 
try { 
if ( cursor . moveToNext ( ) ) metadata = createGeoPackageMetadata ( cursor ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return metadata ; 
} 
} 

public class GeoPackageMetadataDataSource { 
private List < String > getMetadataWhereNameLike ( String like , String sortColumn , boolean notLike ) { 
List < String > names = new ArrayList < > ( ) ; 
StringBuilder where = new StringBuilder ( GeoPackageMetadata . COLUMN_NAME ) ; 
if ( notLike ) where . append ( " not" ) ; 
where . append ( " like ?" ) ; 
String [ ] whereArgs = new String [ ] { 
like } 
; 
Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , new String [ ] { 
GeoPackageMetadata . COLUMN_NAME } 
, where . toString ( ) , whereArgs , null , null , sortColumn ) ; 
try { 
while ( cursor . moveToNext ( ) ) names . add ( cursor . getString ( 0 ) ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return names ; 
} 
} 

public class ParallaxFactory { 
public View onViewCreated ( View view , Context context , AttributeSet attrs ) { 
if ( view == null ) return null ; 
view = onViewCreatedInternal ( view , context , attrs ) ; 
for ( OnViewCreatedListener listener : otherListeners ) { 
if ( listener != null ) view = listener . onViewCreated ( view , context , attrs ) ; 
} 
return view ; 
} 
} 

public class ParallaxContainer { 
private void addParallaxView ( View view , int pageIndex ) { 
if ( view instanceof ViewGroup ) { 
ViewGroup viewGroup = ( ViewGroup ) view ; 
for ( int i = 0 , childCount = viewGroup . getChildCount ( ) ; 
i < childCount ; 
i ++ ) addParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; 
} 
ParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; 
if ( tag != null ) { 
tag . index = pageIndex ; 
parallaxViews . add ( view ) ; 
} 
} 
} 

public class ParallaxLayoutInflater { 
@ Override protected View onCreateView ( String name , AttributeSet attrs ) throws ClassNotFoundException { 
View view = null ; 
for ( String prefix : sClassPrefixList ) { 
try { 
view = createView ( name , prefix , attrs ) ; 
} 
catch ( ClassNotFoundException ignored ) { 
} 
} 
if ( view == null ) view = super . onCreateView ( name , attrs ) ; 
return mParallaxFactory . onViewCreated ( view , view . getContext ( ) , attrs ) ; 
} 
} 

public class ParallaxLayoutInflater { 
private View createCustomViewInternal ( View parent , View view , String name , Context context , AttributeSet attrs ) { 
if ( view == null && name . indexOf ( '.' ) > - 1 ) { 
if ( mConstructorArgs == null ) mConstructorArgs = ReflectionUtils . getField ( LayoutInflater . class , "mConstructorArgs" ) ; 
final Object [ ] mConstructorArgsArr = ( Object [ ] ) ReflectionUtils . getValue ( mConstructorArgs , this ) ; 
final Object lastContext = mConstructorArgsArr [ 0 ] ; 
mConstructorArgsArr [ 0 ] = parent != null ? parent . getContext ( ) : context ; 
ReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; 
try { 
view = createView ( name , null , attrs ) ; 
} 
catch ( ClassNotFoundException ignored ) { 
} 
finally { 
mConstructorArgsArr [ 0 ] = lastContext ; 
ReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; 
} 
} 
return view ; 
} 
} 

public class SMTPAppender { 
protected void subAppend ( CyclicBuffer < ILoggingEvent > cb , ILoggingEvent event ) { 
if ( includeCallerData ) event . getCallerData ( ) ; 
event . prepareForDeferredProcessing ( ) ; 
cb . add ( event ) ; 
} 
} 

public class ContextInitializer { 
private URL findConfigFileFromSystemProperties ( boolean updateStatus ) { 
String logbackConfigFile = OptionHelper . getSystemProperty ( CONFIG_FILE_PROPERTY ) ; 
if ( logbackConfigFile != null ) { 
URL result = null ; 
try { 
File file = new File ( logbackConfigFile ) ; 
if ( file . exists ( ) && file . isFile ( ) ) { 
if ( updateStatus ) statusOnResourceSearch ( logbackConfigFile , this . classLoader , logbackConfigFile ) ; 
result = file . toURI ( ) . toURL ( ) ; 
} 
else result = new URL ( logbackConfigFile ) ; 
return result ; 
} 
catch ( MalformedURLException e ) { 
result = Loader . getResource ( logbackConfigFile , this . classLoader ) ; 
if ( result != null ) return result ; 
} 
finally { 
if ( updateStatus ) statusOnResourceSearch ( logbackConfigFile , this . classLoader , result != null ? result . toString ( ) : null ) ; 
} 
} 
return null ; 
} 
} 

public class ContextInitializer { 
private URL getResource ( String filename , ClassLoader myClassLoader , boolean updateStatus ) { 
URL url = myClassLoader . getResource ( filename ) ; 
if ( updateStatus ) { 
String resourcePath = null ; 
if ( url != null ) resourcePath = filename ; 
statusOnResourceSearch ( filename , myClassLoader , resourcePath ) ; 
} 
return url ; 
} 
} 

public class ContextInitializer { 
private void statusOnResourceSearch ( String resourceName , ClassLoader classLoader , String path ) { 
StatusManager sm = loggerContext . getStatusManager ( ) ; 
if ( path == null ) sm . add ( new InfoStatus ( "Could NOT find resource [" + resourceName + "]" , loggerContext ) ) ; 
else sm . add ( new InfoStatus ( "Found resource [" + resourceName + "] at [" + path + "]" , loggerContext ) ) ; 
} 
} 

public class ServerSocketListener { 
private String socketAddressToString ( SocketAddress address ) { 
String addr = address . toString ( ) ; 
int i = addr . indexOf ( "/" ) ; 
if ( i >= 0 ) addr = addr . substring ( i + 1 ) ; 
return addr ; 
} 
} 

public class RollingFileAppender { 
@ Override protected void subAppend ( E event ) { 
synchronized ( triggeringPolicy ) { 
if ( triggeringPolicy . isTriggeringEvent ( currentlyActiveFile , event ) ) rollover ( ) ; 
} 
super . subAppend ( event ) ; 
} 
} 

public class InterpretationContext { 
public void addSubstitutionProperty ( String key , String value ) { 
if ( key == null || value == null ) return ; 
value = value . trim ( ) ; 
propertiesMap . put ( key , value ) ; 
} 
} 

public class InterpretationContext { 
public String getProperty ( String key ) { 
String v = propertiesMap . get ( key ) ; 
if ( v != null ) return v ; 
else return context . getProperty ( key ) ; 
} 
} 

public class Parser { 
Node E ( ) throws ScanException { 
Node t = T ( ) ; 
if ( t == null ) return null ; 
Node eOpt = Eopt ( ) ; 
if ( eOpt != null ) t . setNext ( eOpt ) ; 
return t ; 
} 
} 

public class Parser { 
Node T ( ) throws ScanException { 
Token t = getCurentToken ( ) ; 
expectNotNull ( t , "a LITERAL or '%'" ) ; 
switch ( t . getType ( ) ) { 
case Token . LITERAL : advanceTokenPointer ( ) ; 
return new Node ( Node . LITERAL , t . getValue ( ) ) ; 
case Token . PERCENT : advanceTokenPointer ( ) ; 
FormatInfo fi ; 
Token u = getCurentToken ( ) ; 
FormattingNode c ; 
expectNotNull ( u , "a FORMAT_MODIFIER, SIMPLE_KEYWORD or COMPOUND_KEYWORD" ) ; 
if ( u . getType ( ) == Token . FORMAT_MODIFIER ) { 
fi = FormatInfo . valueOf ( ( String ) u . getValue ( ) ) ; 
advanceTokenPointer ( ) ; 
c = C ( ) ; 
c . setFormatInfo ( fi ) ; 
} 
else c = C ( ) ; 
return c ; 
default : return null ; 
} 
} 
} 

public class FileNamePattern { 
public String toRegexForFixedDate ( Date date ) { 
StringBuilder buf = new StringBuilder ( ) ; 
Converter < Object > p = headTokenConverter ; 
while ( p != null ) { 
if ( p instanceof LiteralConverter ) buf . append ( p . convert ( null ) ) ; 
else if ( p instanceof IntegerTokenConverter ) buf . append ( FileFinder . regexEscapePath ( "(\\d+)" ) ) ; 
else if ( p instanceof DateTokenConverter ) { 
DateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; 
if ( dtc . isPrimary ( ) ) buf . append ( p . convert ( date ) ) ; 
else buf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; 
} 
p = p . getNext ( ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class AbstractEventEvaluatorAction { 
@ SuppressWarnings ( "unchecked" ) public void end ( InterpretationContext ec , String e ) { 
if ( inError ) return ; 
if ( evaluator instanceof LifeCycle ) { 
( ( LifeCycle ) evaluator ) . start ( ) ; 
addInfo ( "Starting evaluator named [" + evaluator . getName ( ) + "]" ) ; 
} 
Object o = ec . peekObject ( ) ; 
if ( o != evaluator ) addWarn ( "The object on the top the of the stack is not the evaluator pushed earlier." ) ; 
else { 
ec . popObject ( ) ; 
try { 
Map < String , EventEvaluator < ? > > evaluatorMap = ( Map < String , EventEvaluator < ? > > ) context . getObject ( CoreConstants . EVALUATOR_MAP ) ; 
if ( evaluatorMap == null ) addError ( "Could not find EvaluatorMap" ) ; 
else evaluatorMap . put ( evaluator . getName ( ) , evaluator ) ; 
} 
catch ( Exception ex ) { 
addError ( "Could not set evaluator named [" + evaluator + "]." , ex ) ; 
} 
} 
} 
} 

public class ContextSelectorStaticBinder { 
public void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { 
if ( this . key == null ) this . key = key ; 
else if ( this . key != key ) throw new IllegalAccessException ( "Only certain classes can access this method." ) ; 
String contextSelectorStr = OptionHelper . getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; 
if ( contextSelectorStr == null ) contextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; 
else if ( contextSelectorStr . equals ( "JNDI" ) ) throw new RuntimeException ( "JNDI not supported" ) ; 
else contextSelector = dynamicalContextSelector ( defaultLoggerContext , contextSelectorStr ) ; 
} 
} 

public class AndroidContextUtil { 
public void setupProperties ( LoggerContext context ) { 
Properties props = new Properties ( ) ; 
props . setProperty ( CoreConstants . DATA_DIR_KEY , getFilesDirectoryPath ( ) ) ; 
final String extDir = getMountedExternalStorageDirectoryPath ( ) ; 
if ( extDir != null ) props . setProperty ( CoreConstants . EXT_DIR_KEY , extDir ) ; 
props . setProperty ( CoreConstants . PACKAGE_NAME_KEY , getPackageName ( ) ) ; 
props . setProperty ( CoreConstants . VERSION_CODE_KEY , getVersionCode ( ) ) ; 
props . setProperty ( CoreConstants . VERSION_NAME_KEY , getVersionName ( ) ) ; 
context . putProperties ( props ) ; 
} 
} 

public class AndroidContextUtil { 
public String getMountedExternalStorageDirectoryPath ( ) { 
String path = null ; 
String state = Environment . getExternalStorageState ( ) ; 
if ( state . equals ( Environment . MEDIA_MOUNTED ) || state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) path = absPath ( Environment . getExternalStorageDirectory ( ) ) ; 
return path ; 
} 
} 

public class MDCBasedDiscriminator { 
public String getDiscriminatingValue ( ILoggingEvent event ) { 
Map < String , String > mdcMap = event . getMDCPropertyMap ( ) ; 
if ( mdcMap == null ) return defaultValue ; 
String mdcValue = mdcMap . get ( key ) ; 
if ( mdcValue == null ) return defaultValue ; 
else return mdcValue ; 
} 
} 

public class ReconfigureOnChangeFilter { 
private void updateMaskIfNecessary ( long now ) { 
final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; 
lastMaskCheck = now ; 
if ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) mask = ( mask << 1 ) | 1 ; 
else if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) mask = mask >>> 2 ; 
} 
} 

public class FilterAttachableImpl { 
public FilterReply getFilterChainDecision ( E event ) { 
final Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; 
final int len = filterArrray . length ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
final FilterReply r = filterArrray [ i ] . decide ( event ) ; 
if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) return r ; 
} 
return FilterReply . NEUTRAL ; 
} 
} 

public class SSLContextFactoryBean { 
private String locationFromSystemProperty ( String name ) { 
String location = System . getProperty ( name ) ; 
if ( location != null && ! location . startsWith ( "file:" ) ) location = "file:" + location ; 
return location ; 
} 
} 

public class LocationUtil { 
public static URL urlForResource ( String location ) throws MalformedURLException , FileNotFoundException { 
if ( location == null ) throw new NullPointerException ( "location is required" ) ; 
URL url = null ; 
if ( ! location . matches ( SCHEME_PATTERN ) ) url = Loader . getResourceBySelfClassLoader ( location ) ; 
else if ( location . startsWith ( CLASSPATH_SCHEME ) ) { 
String path = location . substring ( CLASSPATH_SCHEME . length ( ) ) ; 
if ( path . startsWith ( "/" ) ) path = path . substring ( 1 ) ; 
if ( path . length ( ) == 0 ) throw new MalformedURLException ( "path is required" ) ; 
url = Loader . getResourceBySelfClassLoader ( path ) ; 
} 
else url = new URL ( location ) ; 
if ( url == null ) throw new FileNotFoundException ( location ) ; 
return url ; 
} 
} 

public class EnsureExceptionHandling { 
public boolean chainHandlesThrowable ( Converter < ILoggingEvent > head ) { 
Converter < ILoggingEvent > c = head ; 
while ( c != null ) { 
if ( c instanceof ThrowableHandlingConverter ) return true ; 
c = c . getNext ( ) ; 
} 
return false ; 
} 
} 

public class StatusPrinter { 
public static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { 
if ( context == null ) throw new IllegalArgumentException ( "Context argument cannot be null" ) ; 
StatusManager sm = context . getStatusManager ( ) ; 
if ( sm == null ) ps . println ( "WARN: Context named \"" + context . getName ( ) + "\" has no status manager" ) ; 
else { 
StatusUtil statusUtil = new StatusUtil ( context ) ; 
if ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) print ( sm , threshold ) ; 
} 
} 
} 

public class StatusPrinter { 
public static void printIfErrorsOccured ( Context context ) { 
if ( context == null ) throw new IllegalArgumentException ( "Context argument cannot be null" ) ; 
StatusManager sm = context . getStatusManager ( ) ; 
if ( sm == null ) ps . println ( "WARN: Context named \"" + context . getName ( ) + "\" has no status manager" ) ; 
else { 
StatusUtil statusUtil = new StatusUtil ( context ) ; 
if ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) print ( sm ) ; 
} 
} 
} 

public class StatusPrinter { 
public static void print ( Context context , long threshold ) { 
if ( context == null ) throw new IllegalArgumentException ( "Context argument cannot be null" ) ; 
StatusManager sm = context . getStatusManager ( ) ; 
if ( sm == null ) ps . println ( "WARN: Context named \"" + context . getName ( ) + "\" has no status manager" ) ; 
else print ( sm , threshold ) ; 
} 
} 

public class SyslogAppender { 
private void handleThrowableFirstLine ( OutputStream sw , IThrowableProxy tp , String stackTracePrefix , boolean isRootException ) throws IOException { 
StringBuilder sb = new StringBuilder ( ) . append ( stackTracePrefix ) ; 
if ( ! isRootException ) sb . append ( CoreConstants . CAUSED_BY ) ; 
sb . append ( tp . getClassName ( ) ) . append ( ": " ) . append ( tp . getMessage ( ) ) ; 
sw . write ( sb . toString ( ) . getBytes ( ) ) ; 
sw . flush ( ) ; 
} 
} 

public class AbstractComponentTracker { 
private Entry < C > getFromEitherMap ( String key ) { 
Entry < C > entry = liveMap . get ( key ) ; 
if ( entry != null ) return entry ; 
else return lingerersMap . get ( key ) ; 
} 
} 

public class FormatInfo { 
public static FormatInfo valueOf ( String str ) throws IllegalArgumentException { 
if ( str == null ) throw new NullPointerException ( "Argument cannot be null" ) ; 
FormatInfo fi = new FormatInfo ( ) ; 
int indexOfDot = str . indexOf ( '.' ) ; 
String minPart = null ; 
String maxPart = null ; 
if ( indexOfDot != - 1 ) { 
minPart = str . substring ( 0 , indexOfDot ) ; 
if ( indexOfDot + 1 == str . length ( ) ) throw new IllegalArgumentException ( "Formatting string [" + str + "] should not end with '.'" ) ; 
else maxPart = str . substring ( indexOfDot + 1 ) ; 
} 
else minPart = str ; 
if ( minPart != null && minPart . length ( ) > 0 ) { 
int min = Integer . parseInt ( minPart ) ; 
if ( min >= 0 ) fi . min = min ; 
else { 
fi . min = - min ; 
fi . leftPad = false ; 
} 
} 
if ( maxPart != null && maxPart . length ( ) > 0 ) { 
int max = Integer . parseInt ( maxPart ) ; 
if ( max >= 0 ) fi . max = max ; 
else { 
fi . max = - max ; 
fi . leftTruncate = false ; 
} 
} 
return fi ; 
} 
} 

public class RenameUtil { 
public void rename ( String src , String target ) throws RolloverFailure { 
if ( src . equals ( target ) ) { 
addWarn ( "Source and target files are the same [" + src + "]. Skipping." ) ; 
return ; 
} 
File srcFile = new File ( src ) ; 
if ( srcFile . exists ( ) ) { 
File targetFile = new File ( target ) ; 
createMissingTargetDirsIfNecessary ( targetFile ) ; 
addInfo ( "Renaming file [" + srcFile + "] to [" + targetFile + "]" ) ; 
boolean result = srcFile . renameTo ( targetFile ) ; 
if ( ! result ) { 
addWarn ( "Failed to rename file [" + srcFile + "] as [" + targetFile + "]." ) ; 
Boolean areOnDifferentVolumes = areOnDifferentVolumes ( srcFile , targetFile ) ; 
if ( Boolean . TRUE . equals ( areOnDifferentVolumes ) ) { 
addWarn ( "Detected different file systems for source [" + src + "] and target [" + target + "]. Attempting rename by copying." ) ; 
renameByCopying ( src , target ) ; 
return ; 
} 
else { 
addWarn ( "Please consider leaving the [file] option of " + RollingFileAppender . class . getSimpleName ( ) + " empty." ) ; 
addWarn ( "See also " + RENAMING_ERROR_URL ) ; 
} 
} 
} 
else throw new RolloverFailure ( "File [" + src + "] does not exist." ) ; 
} 
} 

public class RenameUtil { 
Boolean areOnDifferentVolumes ( File srcFile , File targetFile ) throws RolloverFailure { 
if ( ! EnvUtil . isJDK7OrHigher ( ) ) return false ; 
File parentOfTarget = targetFile . getAbsoluteFile ( ) . getParentFile ( ) ; 
if ( parentOfTarget == null ) { 
addWarn ( "Parent of target file [" + targetFile + "] is null" ) ; 
return null ; 
} 
if ( ! parentOfTarget . exists ( ) ) { 
addWarn ( "Parent of target file [" + targetFile + "] does not exist" ) ; 
return null ; 
} 
try { 
boolean onSameFileStore = FileStoreUtil . areOnSameFileStore ( srcFile , parentOfTarget ) ; 
return ! onSameFileStore ; 
} 
catch ( RolloverFailure rf ) { 
addWarn ( "Error while checking file store equality" , rf ) ; 
return null ; 
} 
} 
} 

public class LoggingEvent { 
public void setMDCPropertyMap ( Map < String , String > map ) { 
if ( mdcPropertyMap != null ) throw new IllegalStateException ( "The MDCPropertyMap has been already set for this event." ) ; 
this . mdcPropertyMap = map ; 
} 
} 

public class MDCConverter { 
private String outputMDCForAllKeys ( Map < String , String > mdcPropertyMap ) { 
StringBuilder buf = new StringBuilder ( ) ; 
boolean first = true ; 
for ( Map . Entry < String , String > entry : mdcPropertyMap . entrySet ( ) ) { 
if ( first ) first = false ; 
else buf . append ( ", " ) ; 
buf . append ( entry . getKey ( ) ) . append ( '=' ) . append ( entry . getValue ( ) ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class CallerData { 
public static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { 
if ( t == null ) return null ; 
StackTraceElement [ ] steArray = t . getStackTrace ( ) ; 
StackTraceElement [ ] callerDataArray ; 
int found = LINE_NA ; 
for ( int i = 0 ; 
i < steArray . length ; 
i ++ ) if ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) found = i + 1 ; 
else if ( found != LINE_NA ) break ; 
if ( found == LINE_NA ) return EMPTY_CALLER_DATA_ARRAY ; 
int availableDepth = steArray . length - found ; 
int desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; 
callerDataArray = new StackTraceElement [ desiredDepth ] ; 
for ( int i = 0 ; 
i < desiredDepth ; 
i ++ ) callerDataArray [ i ] = steArray [ found + i ] ; 
return callerDataArray ; 
} 
} 

public class BasicStatusManager { 
public void add ( Status newStatus ) { 
fireStatusAddEvent ( newStatus ) ; 
count ++ ; 
if ( newStatus . getLevel ( ) > level ) level = newStatus . getLevel ( ) ; 
synchronized ( statusListLock ) { 
if ( statusList . size ( ) < MAX_HEADER_COUNT ) statusList . add ( newStatus ) ; 
else tailBuffer . add ( newStatus ) ; 
} 
} 
} 

public class BasicStatusManager { 
public boolean add ( StatusListener listener ) { 
synchronized ( statusListenerListLock ) { 
if ( listener instanceof OnConsoleStatusListener ) { 
boolean alreadyPresent = checkForPresence ( statusListenerList , listener . getClass ( ) ) ; 
if ( alreadyPresent ) return false ; 
} 
statusListenerList . add ( listener ) ; 
} 
return true ; 
} 
} 

public class Interpreter { 
List < Action > getApplicableActionList ( ElementPath elementPath , Attributes attributes ) { 
List < Action > applicableActionList = ruleStore . matchActions ( elementPath ) ; 
if ( applicableActionList == null ) applicableActionList = lookupImplicitAction ( elementPath , attributes , interpretationContext ) ; 
return applicableActionList ; 
} 
} 

public class SystemPropertiesProxy { 
public String get ( String key , String def ) throws IllegalArgumentException { 
if ( SystemProperties == null || getString == null ) return null ; 
String ret = null ; 
try { 
ret = ( String ) getString . invoke ( SystemProperties , new Object [ ] { 
key , def } 
) ; 
} 
catch ( IllegalArgumentException e ) { 
throw e ; 
} 
catch ( Exception e ) { 
} 
if ( ret == null || ret . length ( ) == 0 ) ret = def ; 
return ret ; 
} 
} 

public class Introspector { 
static public String decapitalize ( String name ) { 
if ( name == null || name . length ( ) == 0 ) return name ; 
else { 
String nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; 
if ( name . length ( ) > 1 ) nm += name . substring ( 1 ) ; 
return nm ; 
} 
} 
} 

public class Introspector { 
static public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { 
final String SETTER_PREFIX = "set" ; 
final String GETTER_PREFIX = "get" ; 
final int LEN_PREFIX = SETTER_PREFIX . length ( ) ; 
Map < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; 
for ( Method m : clazz . getMethods ( ) ) { 
PropertyDescriptor pd = null ; 
String mName = m . getName ( ) ; 
boolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; 
boolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; 
if ( isGet || isSet ) { 
String propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; 
pd = map . get ( propName ) ; 
if ( pd == null ) { 
pd = new PropertyDescriptor ( propName ) ; 
map . put ( propName , pd ) ; 
} 
Class < ? > [ ] parmTypes = m . getParameterTypes ( ) ; 
if ( isSet ) if ( parmTypes . length == 1 ) { 
pd . setWriteMethod ( m ) ; 
pd . setPropertyType ( parmTypes [ 0 ] ) ; 
} 
else if ( isGet ) if ( parmTypes . length == 0 ) { 
pd . setReadMethod ( m ) ; 
if ( pd . getPropertyType ( ) == null ) pd . setPropertyType ( m . getReturnType ( ) ) ; 
} 
} 
} 
return map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; 
} 
} 

public class OutputStreamAppender { 
public void start ( ) { 
int errors = 0 ; 
if ( this . encoder == null ) { 
addStatus ( new ErrorStatus ( "No encoder set for the appender named \"" + name + "\"." , this ) ) ; 
errors ++ ; 
} 
if ( this . outputStream == null ) { 
addStatus ( new ErrorStatus ( "No output stream set for the appender named \"" + name + "\"." , this ) ) ; 
errors ++ ; 
} 
if ( errors == 0 ) super . start ( ) ; 
} 
} 

public class StatusListenerConfigHelper { 
static public void addOnConsoleListenerInstance ( Context context , OnConsoleStatusListener onConsoleStatusListener ) { 
onConsoleStatusListener . setContext ( context ) ; 
boolean effectivelyAdded = context . getStatusManager ( ) . add ( onConsoleStatusListener ) ; 
if ( effectivelyAdded ) onConsoleStatusListener . start ( ) ; 
} 
} 

public class DefinePropertyAction { 
public void end ( InterpretationContext ec , String name ) { 
if ( inError ) return ; 
Object o = ec . peekObject ( ) ; 
if ( o != definer ) addWarn ( "The object at the of the stack is not the property definer for property named [" + propertyName + "] pushed earlier." ) ; 
else { 
addInfo ( "Popping property definer for property named [" + propertyName + "] from the object stack" ) ; 
ec . popObject ( ) ; 
String propertyValue = definer . getPropertyValue ( ) ; 
if ( propertyValue != null ) ActionUtil . setProperty ( ec , propertyName , propertyValue , scope ) ; 
} 
} 
} 

public class ContextBasedDiscriminator { 
public String getDiscriminatingValue ( ILoggingEvent event ) { 
String contextName = event . getLoggerContextVO ( ) . getName ( ) ; 
if ( contextName == null ) return defaultValue ; 
else return contextName ; 
} 
} 

public class ShutdownHookAction { 
@ Override public void end ( InterpretationContext ic , String name ) throws ActionException { 
if ( inError ) return ; 
Object o = ic . peekObject ( ) ; 
if ( o != hook ) addWarn ( "The object at the of the stack is not the hook pushed earlier." ) ; 
else { 
ic . popObject ( ) ; 
Thread hookThread = new Thread ( hook , "Logback shutdown hook [" + context . getName ( ) + "]" ) ; 
addInfo ( "Registering shutdown hook with JVM runtime" ) ; 
context . putObject ( CoreConstants . SHUTDOWN_HOOK_THREAD , hookThread ) ; 
Runtime . getRuntime ( ) . addShutdownHook ( hookThread ) ; 
} 
} 
} 

public class SSLParametersConfiguration { 
private String [ ] enabledProtocols ( String [ ] supportedProtocols , String [ ] defaultProtocols ) { 
if ( enabledProtocols == null ) { 
if ( OptionHelper . isEmpty ( getIncludedProtocols ( ) ) && OptionHelper . isEmpty ( getExcludedProtocols ( ) ) ) enabledProtocols = Arrays . copyOf ( defaultProtocols , defaultProtocols . length ) ; 
else enabledProtocols = includedStrings ( supportedProtocols , getIncludedProtocols ( ) , getExcludedProtocols ( ) ) ; 
for ( String protocol : enabledProtocols ) { 
addInfo ( "enabled protocol: " + protocol ) ; 
} 
} 
return enabledProtocols ; 
} 
} 

public class SSLParametersConfiguration { 
private String [ ] enabledCipherSuites ( String [ ] supportedCipherSuites , String [ ] defaultCipherSuites ) { 
if ( enabledCipherSuites == null ) { 
if ( OptionHelper . isEmpty ( getIncludedCipherSuites ( ) ) && OptionHelper . isEmpty ( getExcludedCipherSuites ( ) ) ) enabledCipherSuites = Arrays . copyOf ( defaultCipherSuites , defaultCipherSuites . length ) ; 
else enabledCipherSuites = includedStrings ( supportedCipherSuites , getIncludedCipherSuites ( ) , getExcludedCipherSuites ( ) ) ; 
for ( String cipherSuite : enabledCipherSuites ) { 
addInfo ( "enabled cipher suite: " + cipherSuite ) ; 
} 
} 
return enabledCipherSuites ; 
} 
} 

public class SSLParametersConfiguration { 
private String [ ] includedStrings ( String [ ] defaults , String included , String excluded ) { 
List < String > values = new ArrayList < String > ( defaults . length ) ; 
values . addAll ( Arrays . asList ( defaults ) ) ; 
if ( included != null ) StringCollectionUtil . retainMatching ( values , stringToArray ( included ) ) ; 
if ( excluded != null ) StringCollectionUtil . removeMatching ( values , stringToArray ( excluded ) ) ; 
return values . toArray ( new String [ values . size ( ) ] ) ; 
} 
} 

public class AppenderAttachableImpl { 
public void addAppender ( Appender < E > newAppender ) { 
if ( newAppender == null ) throw new IllegalArgumentException ( "Null argument disallowed" ) ; 
appenderList . addIfAbsent ( newAppender ) ; 
} 
} 

public class AppenderAttachableImpl { 
public boolean detachAppender ( Appender < E > appender ) { 
if ( appender == null ) return false ; 
boolean result ; 
result = appenderList . remove ( appender ) ; 
return result ; 
} 
} 

public class AppenderAttachableImpl { 
public boolean detachAppender ( String name ) { 
if ( name == null ) return false ; 
boolean removed = false ; 
for ( Appender < E > a : appenderList ) { 
if ( name . equals ( ( a ) . getName ( ) ) ) { 
removed = appenderList . remove ( a ) ; 
break ; 
} 
} 
return removed ; 
} 
} 

public class Logger { 
public void callAppenders ( ILoggingEvent event ) { 
int writes = 0 ; 
for ( Logger l = this ; 
l != null ; 
l = l . parent ) { 
writes += l . appendLoopOnAppenders ( event ) ; 
if ( ! l . additive ) break ; 
} 
if ( writes == 0 ) loggerContext . noAppenderDefinedWarning ( this ) ; 
} 
} 

public class Logger { 
public boolean detachAppender ( Appender < ILoggingEvent > appender ) { 
if ( aai == null ) return false ; 
return aai . detachAppender ( appender ) ; 
} 
} 

public class Logger { 
Logger createChildByLastNamePart ( final String lastPart ) { 
int i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; 
if ( i_index != - 1 ) throw new IllegalArgumentException ( "Child name [" + lastPart + " passed as parameter, may not include [" + CoreConstants . DOT + "]" ) ; 
if ( childrenList == null ) childrenList = new CopyOnWriteArrayList < Logger > ( ) ; 
Logger childLogger ; 
if ( this . isRootLogger ( ) ) childLogger = new Logger ( lastPart , this , this . loggerContext ) ; 
else childLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , this . loggerContext ) ; 
childrenList . add ( childLogger ) ; 
childLogger . effectiveLevelInt = this . effectiveLevelInt ; 
return childLogger ; 
} 
} 

public class FileUtil { 
static public boolean createMissingParentDirectories ( File file ) { 
File parent = file . getParentFile ( ) ; 
if ( parent == null ) return true ; 
parent . mkdirs ( ) ; 
return parent . exists ( ) ; 
} 
} 

public class Loader { 
public static ClassLoader getClassLoaderOfObject ( Object o ) { 
if ( o == null ) throw new NullPointerException ( "Argument cannot be null" ) ; 
return getClassLoaderOfClass ( o . getClass ( ) ) ; 
} 
} 

public class Loader { 
public static ClassLoader getClassLoaderOfClass ( final Class < ? > clazz ) { 
ClassLoader cl = clazz . getClassLoader ( ) ; 
if ( cl == null ) return ClassLoader . getSystemClassLoader ( ) ; 
else return cl ; 
} 
} 

public class LogcatAppender { 
protected String getTag ( ILoggingEvent event ) { 
String tag = ( this . tagEncoder != null ) ? this . tagEncoder . getLayout ( ) . doLayout ( event ) : event . getLoggerName ( ) ; 
if ( checkLoggable && ( tag . length ( ) > MAX_TAG_LENGTH ) ) tag = tag . substring ( 0 , MAX_TAG_LENGTH - 1 ) + "*" ; 
return tag ; 
} 
} 

public class PropertyAction { 
public void begin ( InterpretationContext ec , String localName , Attributes attributes ) { 
if ( "substitutionProperty" . equals ( localName ) ) addWarn ( "[substitutionProperty] element has been deprecated. Please use the [property] element instead." ) ; 
String name = attributes . getValue ( NAME_ATTRIBUTE ) ; 
String value = attributes . getValue ( VALUE_ATTRIBUTE ) ; 
String scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; 
Scope scope = ActionUtil . stringToScope ( scopeStr ) ; 
if ( checkFileAttributeSanity ( attributes ) ) { 
String file = attributes . getValue ( FILE_ATTRIBUTE ) ; 
file = ec . subst ( file ) ; 
try { 
FileInputStream istream = new FileInputStream ( file ) ; 
loadAndSetProperties ( ec , istream , scope ) ; 
} 
catch ( FileNotFoundException e ) { 
addError ( "Could not find properties file [" + file + "]." ) ; 
} 
catch ( IOException e1 ) { 
addError ( "Could not read properties file [" + file + "]." , e1 ) ; 
} 
} 
else if ( checkResourceAttributeSanity ( attributes ) ) { 
String resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; 
resource = ec . subst ( resource ) ; 
URL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; 
if ( resourceURL == null ) addError ( "Could not find resource [" + resource + "]." ) ; 
else try { 
InputStream istream = resourceURL . openStream ( ) ; 
loadAndSetProperties ( ec , istream , scope ) ; 
} 
catch ( IOException e ) { 
addError ( "Could not read resource file [" + resource + "]." , e ) ; 
} 
} 
else if ( checkValueNameAttributesSanity ( attributes ) ) { 
value = RegularEscapeUtil . basicEscape ( value ) ; 
value = value . trim ( ) ; 
value = ec . subst ( value ) ; 
ActionUtil . setProperty ( ec , name , value , scope ) ; 
} 
else addError ( INVALID_ATTRIBUTES ) ; 
} 
} 

public class OnMarkerEvaluator { 
public boolean evaluate ( ILoggingEvent event ) throws NullPointerException , EvaluationException { 
Marker eventsMarker = event . getMarker ( ) ; 
if ( eventsMarker == null ) return false ; 
for ( String markerStr : markerList ) { 
if ( eventsMarker . contains ( markerStr ) ) return true ; 
} 
return false ; 
} 
} 

public class FileStoreUtil { 
static public boolean areOnSameFileStore ( File a , File b ) throws RolloverFailure { 
if ( ! a . exists ( ) ) throw new IllegalArgumentException ( "File [" + a + "] does not exist." ) ; 
if ( ! b . exists ( ) ) throw new IllegalArgumentException ( "File [" + b + "] does not exist." ) ; 
try { 
Class < ? > pathClass = Class . forName ( PATH_CLASS_STR ) ; 
Class < ? > filesClass = Class . forName ( FILES_CLASS_STR ) ; 
Method toPath = File . class . getMethod ( "toPath" ) ; 
Method getFileStoreMethod = filesClass . getMethod ( "getFileStore" , pathClass ) ; 
Object pathA = toPath . invoke ( a ) ; 
Object pathB = toPath . invoke ( b ) ; 
Object fileStoreA = getFileStoreMethod . invoke ( null , pathA ) ; 
Object fileStoreB = getFileStoreMethod . invoke ( null , pathB ) ; 
return fileStoreA . equals ( fileStoreB ) ; 
} 
catch ( Exception e ) { 
throw new RolloverFailure ( "Failed to check file store equality for [" + a + "] and [" + b + "]" , e ) ; 
} 
} 
} 

public class SMTPAppenderBase { 
public void start ( ) { 
if ( cbTracker == null ) cbTracker = new CyclicBufferTracker < E > ( ) ; 
session = buildSessionFromProperties ( ) ; 
if ( session == null ) { 
addError ( "Failed to obtain javax.mail.Session. Cannot start." ) ; 
return ; 
} 
subjectLayout = makeSubjectLayout ( subjectStr ) ; 
started = true ; 
} 
} 

public class SMTPAppenderBase { 
protected void append ( E eventObject ) { 
if ( ! checkEntryConditions ( ) ) return ; 
String key = discriminator . getDiscriminatingValue ( eventObject ) ; 
long now = System . currentTimeMillis ( ) ; 
final CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; 
subAppend ( cb , eventObject ) ; 
try { 
if ( eventEvaluator . evaluate ( eventObject ) ) { 
CyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; 
cb . clear ( ) ; 
if ( asynchronousSending ) { 
SenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; 
context . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; 
} 
else sendBuffer ( cbClone , eventObject ) ; 
} 
} 
catch ( EvaluationException ex ) { 
errorCount ++ ; 
if ( errorCount < CoreConstants . MAX_ERROR_COUNT ) addError ( "SMTPAppender's EventEvaluator threw an Exception-" , ex ) ; 
} 
if ( eventMarksEndOfLife ( eventObject ) ) cbTracker . endOfLife ( key ) ; 
cbTracker . removeStaleComponents ( now ) ; 
if ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { 
addInfo ( "SMTPAppender [" + name + "] is tracking [" + cbTracker . getComponentCount ( ) + "] buffers" ) ; 
lastTrackerStatusPrint = now ; 
if ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) delayBetweenStatusMessages *= 4 ; 
} 
} 
} 

public class SMTPAppenderBase { 
protected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { 
try { 
MimeBodyPart part = new MimeBodyPart ( ) ; 
StringBuffer sbuf = new StringBuffer ( ) ; 
String header = layout . getFileHeader ( ) ; 
if ( header != null ) sbuf . append ( header ) ; 
String presentationHeader = layout . getPresentationHeader ( ) ; 
if ( presentationHeader != null ) sbuf . append ( presentationHeader ) ; 
fillBuffer ( cb , sbuf ) ; 
String presentationFooter = layout . getPresentationFooter ( ) ; 
if ( presentationFooter != null ) sbuf . append ( presentationFooter ) ; 
String footer = layout . getFileFooter ( ) ; 
if ( footer != null ) sbuf . append ( footer ) ; 
String subjectStr = "Undefined subject" ; 
if ( subjectLayout != null ) { 
subjectStr = subjectLayout . doLayout ( lastEventObject ) ; 
int newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\n' ) : - 1 ; 
if ( newLinePos > - 1 ) subjectStr = subjectStr . substring ( 0 , newLinePos ) ; 
} 
MimeMessage mimeMsg = new MimeMessage ( session ) ; 
if ( from != null ) mimeMsg . setFrom ( getAddress ( from ) ) ; 
else mimeMsg . setFrom ( ) ; 
mimeMsg . setSubject ( subjectStr , charsetEncoding ) ; 
List < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; 
if ( destinationAddresses . isEmpty ( ) ) { 
addInfo ( "Empty destination address. Aborting email transmission" ) ; 
return ; 
} 
InternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; 
mimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; 
String contentType = layout . getContentType ( ) ; 
if ( ContentTypeUtil . isTextual ( contentType ) ) part . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; 
else part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; 
Multipart mp = new MimeMultipart ( ) ; 
mp . addBodyPart ( part ) ; 
mimeMsg . setContent ( mp ) ; 
updateMimeMsg ( mimeMsg , cb , lastEventObject ) ; 
mimeMsg . setSentDate ( new Date ( ) ) ; 
addInfo ( "About to send out SMTP message \"" + subjectStr + "\" to " + Arrays . toString ( toAddressArray ) ) ; 
Transport . send ( mimeMsg ) ; 
} 
catch ( Exception e ) { 
addError ( "Error occurred while sending e-mail notification." , e ) ; 
} 
} 
} 

public class DynamicThresholdFilter { 
public void addMDCValueLevelPair ( MDCValueLevelPair mdcValueLevelPair ) { 
if ( valueLevelMap . containsKey ( mdcValueLevelPair . getValue ( ) ) ) addError ( mdcValueLevelPair . getValue ( ) + " has been already set" ) ; 
else valueLevelMap . put ( mdcValueLevelPair . getValue ( ) , mdcValueLevelPair . getLevel ( ) ) ; 
} 
} 

public class Compiler { 
@ SuppressWarnings ( "unchecked" ) DynamicConverter < E > createConverter ( SimpleKeywordNode kn ) { 
String keyword = ( String ) kn . getValue ( ) ; 
String converterClassStr = ( String ) converterMap . get ( keyword ) ; 
if ( converterClassStr != null ) try { 
return ( DynamicConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , DynamicConverter . class , context ) ; 
} 
catch ( Exception e ) { 
addError ( "Failed to instantiate converter class [" + converterClassStr + "] for keyword [" + keyword + "]" , e ) ; 
return null ; 
} 
else { 
addError ( "There is no conversion class registered for conversion word [" + keyword + "]" ) ; 
return null ; 
} 
} 
} 

public class Compiler { 
@ SuppressWarnings ( "unchecked" ) CompositeConverter < E > createCompositeConverter ( CompositeNode cn ) { 
String keyword = ( String ) cn . getValue ( ) ; 
String converterClassStr = ( String ) converterMap . get ( keyword ) ; 
if ( converterClassStr != null ) try { 
return ( CompositeConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , CompositeConverter . class , context ) ; 
} 
catch ( Exception e ) { 
addError ( "Failed to instantiate converter class [" + converterClassStr + "] as a composite converter for keyword [" + keyword + "]" , e ) ; 
return null ; 
} 
else { 
addError ( "There is no conversion class registered for composite conversion word [" + keyword + "]" ) ; 
return null ; 
} 
} 
} 

public class ContextBase { 
public void setName ( String name ) throws IllegalStateException { 
if ( name != null && name . equals ( this . name ) ) return ; 
if ( this . name == null || CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) this . name = name ; 
else throw new IllegalStateException ( "Context has been already given a name" ) ; 
} 
} 

public class StatusUtil { 
public long timeOfLastReset ( ) { 
List < Status > statusList = sm . getCopyOfStatusList ( ) ; 
if ( statusList == null ) return - 1 ; 
int len = statusList . size ( ) ; 
for ( int i = len - 1 ; 
i >= 0 ; 
i -- ) { 
Status s = statusList . get ( i ) ; 
if ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) return s . getDate ( ) ; 
} 
return - 1 ; 
} 
} 

public class HTMLLayoutBase { 
@ Override public void start ( ) { 
int errorCount = 0 ; 
try { 
Parser < E > p = new Parser < E > ( pattern ) ; 
p . setContext ( getContext ( ) ) ; 
Node t = p . parse ( ) ; 
this . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; 
ConverterUtil . startConverters ( this . head ) ; 
} 
catch ( ScanException ex ) { 
addError ( "Incorrect pattern found" , ex ) ; 
errorCount ++ ; 
} 
if ( errorCount == 0 ) super . started = true ; 
} 
} 

public class HTMLLayoutBase { 
public Map < String , String > getEffectiveConverterMap ( ) { 
Map < String , String > effectiveMap = new HashMap < String , String > ( ) ; 
Map < String , String > defaultMap = getDefaultConverterMap ( ) ; 
if ( defaultMap != null ) effectiveMap . putAll ( defaultMap ) ; 
Context context = getContext ( ) ; 
if ( context != null ) { 
@ SuppressWarnings ( "unchecked" ) Map < String , String > contextMap = ( Map < String , String > ) context . getObject ( CoreConstants . PATTERN_RULE_REGISTRY ) ; 
if ( contextMap != null ) effectiveMap . putAll ( contextMap ) ; 
} 
return effectiveMap ; 
} 
} 

public class AppenderAction { 
@ SuppressWarnings ( "unchecked" ) public void begin ( InterpretationContext ec , String localName , Attributes attributes ) throws ActionException { 
appender = null ; 
inError = false ; 
String className = attributes . getValue ( CLASS_ATTRIBUTE ) ; 
if ( OptionHelper . isEmpty ( className ) ) { 
addError ( "Missing class name for appender. Near [" + localName + "] line " + getLineNumber ( ec ) ) ; 
inError = true ; 
return ; 
} 
try { 
addInfo ( "About to instantiate appender of type [" + className + "]" ) ; 
warnDeprecated ( className ) ; 
appender = ( Appender < E > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . Appender . class , context ) ; 
appender . setContext ( context ) ; 
String appenderName = ec . subst ( attributes . getValue ( NAME_ATTRIBUTE ) ) ; 
if ( OptionHelper . isEmpty ( appenderName ) ) addWarn ( "No appender name given for appender of type " + className + "]." ) ; 
else { 
appender . setName ( appenderName ) ; 
addInfo ( "Naming appender as [" + appenderName + "]" ) ; 
} 
HashMap < String , Appender < E > > appenderBag = ( HashMap < String , Appender < E > > ) ec . getObjectMap ( ) . get ( ActionConst . APPENDER_BAG ) ; 
appenderBag . put ( appenderName , appender ) ; 
ec . pushObject ( appender ) ; 
} 
catch ( Exception oops ) { 
inError = true ; 
addError ( "Could not create an Appender of type [" + className + "]." , oops ) ; 
throw new ActionException ( oops ) ; 
} 
} 
} 

public class AppenderAction { 
public void end ( InterpretationContext ec , String name ) { 
if ( inError ) return ; 
if ( appender instanceof LifeCycle ) ( ( LifeCycle ) appender ) . start ( ) ; 
Object o = ec . peekObject ( ) ; 
if ( o != appender ) addWarn ( "The object at the of the stack is not the appender named [" + appender . getName ( ) + "] pushed earlier." ) ; 
else ec . popObject ( ) ; 
} 
} 

public class LogbackMDCAdapter { 
public Map < String , String > getCopyOfContextMap ( ) { 
Map < String , String > hashMap = copyOnThreadLocal . get ( ) ; 
if ( hashMap == null ) return null ; 
else return new HashMap < String , String > ( hashMap ) ; 
} 
} 

public class TurboFilterList { 
public FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { 
final int size = size ( ) ; 
if ( size == 1 ) try { 
TurboFilter tf = get ( 0 ) ; 
return tf . decide ( marker , logger , level , format , params , t ) ; 
} 
catch ( IndexOutOfBoundsException iobe ) { 
return FilterReply . NEUTRAL ; 
} 
Object [ ] tfa = toArray ( ) ; 
final int len = tfa . length ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
final TurboFilter tf = ( TurboFilter ) tfa [ i ] ; 
final FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; 
if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) return r ; 
} 
return FilterReply . NEUTRAL ; 
} 
} 

public class StaticLoggerBinder { 
void init ( ) { 
try { 
try { 
new ContextInitializer ( defaultLoggerContext ) . autoConfig ( ) ; 
} 
catch ( JoranException je ) { 
Util . report ( "Failed to auto configure default logger context" , je ) ; 
} 
if ( ! StatusUtil . contextHasStatusListener ( defaultLoggerContext ) ) StatusPrinter . printInCaseOfErrorsOrWarnings ( defaultLoggerContext ) ; 
contextSelectorBinder . init ( defaultLoggerContext , KEY ) ; 
initialized = true ; 
} 
catch ( Exception t ) { 
Util . report ( "Failed to instantiate [" + LoggerContext . class . getName ( ) + "]" , t ) ; 
} 
} 
} 

public class FileFilterUtil { 
public static File [ ] filesInFolderMatchingStemRegex ( File file , final String stemRegex ) { 
if ( file == null ) return new File [ 0 ] ; 
if ( ! file . exists ( ) || ! file . isDirectory ( ) ) return new File [ 0 ] ; 
return file . listFiles ( new FilenameFilter ( ) { 
public boolean accept ( File dir , String name ) { 
return name . matches ( stemRegex ) ; 
} 
} 
) ; 
} 
} 

public class OnPrintStreamStatusListenerBase { 
private void retrospectivePrint ( ) { 
if ( context == null ) return ; 
long now = System . currentTimeMillis ( ) ; 
StatusManager sm = context . getStatusManager ( ) ; 
List < Status > statusList = sm . getCopyOfStatusList ( ) ; 
for ( Status status : statusList ) { 
long timestampOfStatusMesage = status . getDate ( ) ; 
if ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) print ( status ) ; 
} 
} 
} 

public class SyslogAppenderBase { 
static public int facilityStringToint ( String facilityStr ) { 
if ( "KERN" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_KERN ; 
else if ( "USER" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_USER ; 
else if ( "MAIL" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_MAIL ; 
else if ( "DAEMON" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_DAEMON ; 
else if ( "AUTH" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_AUTH ; 
else if ( "SYSLOG" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_SYSLOG ; 
else if ( "LPR" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LPR ; 
else if ( "NEWS" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_NEWS ; 
else if ( "UUCP" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_UUCP ; 
else if ( "CRON" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_CRON ; 
else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_AUTHPRIV ; 
else if ( "FTP" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_FTP ; 
else if ( "NTP" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_NTP ; 
else if ( "AUDIT" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_AUDIT ; 
else if ( "ALERT" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_ALERT ; 
else if ( "CLOCK" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_CLOCK ; 
else if ( "LOCAL0" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL0 ; 
else if ( "LOCAL1" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL1 ; 
else if ( "LOCAL2" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL2 ; 
else if ( "LOCAL3" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL3 ; 
else if ( "LOCAL4" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL4 ; 
else if ( "LOCAL5" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL5 ; 
else if ( "LOCAL6" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL6 ; 
else if ( "LOCAL7" . equalsIgnoreCase ( facilityStr ) ) return SyslogConstants . LOG_LOCAL7 ; 
else throw new IllegalArgumentException ( facilityStr + " is not a valid syslog facility string" ) ; 
} 
} 

public class SQLiteAppender { 
public File getDatabaseFile ( String filename ) { 
File dbFile = null ; 
if ( filename != null && filename . trim ( ) . length ( ) > 0 ) dbFile = new File ( filename ) ; 
if ( dbFile == null || dbFile . isDirectory ( ) ) dbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( "logback.db" ) ) ; 
return dbFile ; 
} 
} 

public class SQLiteAppender { 
private void secondarySubAppend ( ILoggingEvent event , long eventId ) throws SQLException { 
Map < String , String > mergedMap = mergePropertyMaps ( event ) ; 
insertProperties ( mergedMap , eventId ) ; 
if ( event . getThrowableProxy ( ) != null ) insertThrowable ( event . getThrowableProxy ( ) , eventId ) ; 
} 
} 

public class SQLiteAppender { 
private String asStringTruncatedTo254 ( Object o ) { 
String s = null ; 
if ( o != null ) s = o . toString ( ) ; 
if ( s != null && s . length ( ) > 254 ) s = s . substring ( 0 , 254 ) ; 
return s == null ? "" : s ; 
} 
} 

public class SQLiteAppender { 
private static short computeReferenceMask ( ILoggingEvent event ) { 
short mask = 0 ; 
int mdcPropSize = 0 ; 
if ( event . getMDCPropertyMap ( ) != null ) mdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; 
int contextPropSize = 0 ; 
if ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) contextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; 
if ( mdcPropSize > 0 || contextPropSize > 0 ) mask = PROPERTIES_EXIST ; 
if ( event . getThrowableProxy ( ) != null ) mask |= EXCEPTION_EXISTS ; 
return mask ; 
} 
} 

public class SQLiteAppender { 
private Map < String , String > mergePropertyMaps ( ILoggingEvent event ) { 
Map < String , String > mergedMap = new HashMap < String , String > ( ) ; 
Map < String , String > loggerContextMap = event . getLoggerContextVO ( ) . getPropertyMap ( ) ; 
if ( loggerContextMap != null ) mergedMap . putAll ( loggerContextMap ) ; 
Map < String , String > mdcMap = event . getMDCPropertyMap ( ) ; 
if ( mdcMap != null ) mergedMap . putAll ( mdcMap ) ; 
return mergedMap ; 
} 
} 

public class ElementSelector { 
public int getPrefixMatchLength ( ElementPath p ) { 
if ( p == null ) return 0 ; 
int lSize = this . partList . size ( ) ; 
int rSize = p . partList . size ( ) ; 
if ( ( lSize == 0 ) || ( rSize == 0 ) ) return 0 ; 
int minLen = ( lSize <= rSize ) ? lSize : rSize ; 
int match = 0 ; 
for ( int i = 0 ; 
i < minLen ; 
i ++ ) { 
String l = this . partList . get ( i ) ; 
String r = p . partList . get ( i ) ; 
if ( equalityCheck ( l , r ) ) match ++ ; 
else break ; 
} 
return match ; 
} 
} 

public class StatusBase { 
public synchronized int getEffectiveLevel ( ) { 
int result = level ; 
int effLevel ; 
Iterator it = iterator ( ) ; 
Status s ; 
while ( it . hasNext ( ) ) { 
s = ( Status ) it . next ( ) ; 
effLevel = s . getEffectiveLevel ( ) ; 
if ( effLevel > result ) result = effLevel ; 
} 
return result ; 
} 
} 

public class PropertySetter { 
public void setProperty ( String name , String value ) { 
if ( value == null ) return ; 
name = Introspector . decapitalize ( name ) ; 
PropertyDescriptor prop = getPropertyDescriptor ( name ) ; 
if ( prop == null ) addWarn ( "No such property [" + name + "] in " + objClass . getName ( ) + "." ) ; 
else try { 
setProperty ( prop , name , value ) ; 
} 
catch ( PropertySetterException ex ) { 
addWarn ( "Failed to set property [" + name + "] to value \"" + value + "\". " , ex ) ; 
} 
} 
} 

public class PropertySetter { 
private boolean isUnequivocallyInstantiable ( Class < ? > clazz ) { 
if ( clazz . isInterface ( ) ) return false ; 
Object o ; 
try { 
o = clazz . getDeclaredConstructor ( ) . newInstance ( ) ; 
if ( o != null ) return true ; 
else return false ; 
} 
catch ( InstantiationException e ) { 
return false ; 
} 
catch ( IllegalAccessException e ) { 
return false ; 
} 
catch ( NoSuchMethodException e ) { 
return false ; 
} 
catch ( InvocationTargetException e ) { 
return false ; 
} 
} 
} 

public class CopyOnInheritThreadLocal { 
@ Override protected HashMap < String , String > childValue ( HashMap < String , String > parentValue ) { 
if ( parentValue == null ) return null ; 
else return new HashMap < String , String > ( parentValue ) ; 
} 
} 

public class IncludeAction { 
private void trimHeadAndTail ( SaxEventRecorder recorder ) { 
List < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; 
if ( saxEventList . size ( ) == 0 ) return ; 
boolean includedTagFound = false ; 
boolean configTagFound = false ; 
SaxEvent first = saxEventList . get ( 0 ) ; 
if ( first != null ) { 
String elemName = getEventName ( first ) ; 
includedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; 
configTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; 
} 
if ( includedTagFound || configTagFound ) { 
saxEventList . remove ( 0 ) ; 
final int listSize = saxEventList . size ( ) ; 
if ( listSize == 0 ) return ; 
final int lastIndex = listSize - 1 ; 
SaxEvent last = saxEventList . get ( lastIndex ) ; 
if ( last != null ) { 
String elemName = getEventName ( last ) ; 
if ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) saxEventList . remove ( lastIndex ) ; 
} 
} 
} 
} 

public class AlgoliaException { 
public boolean isTransient ( ) { 
Throwable cause = getCause ( ) ; 
if ( cause == null ) return isServerError ( statusCode ) ; 
else if ( cause instanceof AlgoliaException ) return ( ( AlgoliaException ) cause ) . isTransient ( ) ; 
else if ( cause instanceof IOException ) return true ; 
else return false ; 
} 
} 

public class MirroredIndex { 
private synchronized void ensureLocalIndex ( ) { 
if ( localIndex == null ) localIndex = new LocalIndex ( getClient ( ) . getRootDataDir ( ) . getAbsolutePath ( ) , getClient ( ) . getApplicationID ( ) , getRawIndexName ( ) ) ; 
} 
} 

public class MirroredIndex { 
public void sync ( ) { 
if ( getDataSelectionQueries ( ) . length == 0 ) throw new IllegalStateException ( "Cannot sync with empty data selection queries" ) ; 
synchronized ( this ) { 
if ( syncing ) return ; 
syncing = true ; 
} 
getClient ( ) . localBuildExecutorService . submit ( new Runnable ( ) { 
@ Override public void run ( ) { 
_sync ( ) ; 
} 
} 
) ; 
} 
} 

public class MirroredIndex { 
public void syncIfNeeded ( ) { 
long currentDate = System . currentTimeMillis ( ) ; 
if ( currentDate - mirrorSettings . getLastSyncDate ( ) . getTime ( ) > delayBetweenSyncs || mirrorSettings . getQueriesModificationDate ( ) . compareTo ( mirrorSettings . getLastSyncDate ( ) ) > 0 ) sync ( ) ; 
} 
} 

public class Index { 
public JSONObject waitTask ( String taskID , long timeToWait ) throws AlgoliaException { 
try { 
while ( true ) { 
JSONObject obj = client . getRequest ( "/1/indexes/" + encodedIndexName + "/task/" + URLEncoder . encode ( taskID , "UTF-8" ) , null , false , null ) ; 
if ( obj . getString ( "status" ) . equals ( "published" ) ) return obj ; 
try { 
Thread . sleep ( timeToWait >= MAX_TIME_MS_TO_WAIT ? MAX_TIME_MS_TO_WAIT : timeToWait ) ; 
} 
catch ( InterruptedException e ) { 
continue ; 
} 
final long newTimeout = timeToWait * 2 ; 
timeToWait = ( newTimeout <= 0 || newTimeout >= MAX_TIME_MS_TO_WAIT ) ? MAX_TIME_MS_TO_WAIT : newTimeout ; 
} 
} 
catch ( JSONException e ) { 
throw new AlgoliaException ( e . getMessage ( ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class OfflineClient { 
private JSONObject listIndexesOfflineSync ( ) throws AlgoliaException { 
try { 
final String rootDataPath = getRootDataDir ( ) . getAbsolutePath ( ) ; 
final File appDir = getAppDir ( ) ; 
final File [ ] directories = appDir . listFiles ( new FileFilter ( ) { 
@ Override public boolean accept ( File pathname ) { 
return pathname . isDirectory ( ) ; 
} 
} 
) ; 
JSONObject response = new JSONObject ( ) ; 
JSONArray items = new JSONArray ( ) ; 
if ( directories != null ) for ( File directory : directories ) { 
final String name = directory . getName ( ) ; 
if ( hasOfflineData ( name ) ) items . put ( new JSONObject ( ) . put ( "name" , name ) ) ; 
} 
response . put ( "items" , items ) ; 
return response ; 
} 
catch ( JSONException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class AbstractClient { 
private static byte [ ] _toByteArray ( InputStream stream ) throws AlgoliaException { 
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
int read ; 
byte [ ] buffer = new byte [ 1024 ] ; 
try { 
while ( ( read = stream . read ( buffer , 0 , buffer . length ) ) != - 1 ) out . write ( buffer , 0 , read ) ; 
out . flush ( ) ; 
return out . toByteArray ( ) ; 
} 
catch ( IOException e ) { 
throw new AlgoliaException ( "Error while reading stream: " + e . getMessage ( ) ) ; 
} 
} 
} 

public class AbstractClient { 
private static void consumeQuietly ( final HttpURLConnection connection ) { 
try { 
int read = 0 ; 
while ( read != - 1 ) read = connection . getInputStream ( ) . read ( ) ; 
connection . getInputStream ( ) . close ( ) ; 
read = 0 ; 
while ( read != - 1 ) read = connection . getErrorStream ( ) . read ( ) ; 
connection . getErrorStream ( ) . close ( ) ; 
connection . disconnect ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
} 

public class AbstractClient { 
private List < String > hostsThatAreUp ( List < String > hosts ) { 
List < String > upHosts = new ArrayList < > ( ) ; 
for ( String host : hosts ) { 
if ( isUpOrCouldBeRetried ( host ) ) upHosts . add ( host ) ; 
} 
return upHosts . isEmpty ( ) ? hosts : upHosts ; 
} 
} 

public class PlacesQuery { 
public @ NonNull PlacesQuery setType ( Type type ) { 
if ( type == null ) set ( KEY_TYPE , null ) ; 
else switch ( type ) { 
case CITY : set ( KEY_TYPE , "city" ) ; 
break ; 
case COUNTRY : set ( KEY_TYPE , "country" ) ; 
break ; 
case ADDRESS : set ( KEY_TYPE , "address" ) ; 
break ; 
case BUS_STOP : set ( KEY_TYPE , "busStop" ) ; 
break ; 
case TRAIN_STATION : set ( KEY_TYPE , "trainStation" ) ; 
break ; 
case TOWN_HALL : set ( KEY_TYPE , "townhall" ) ; 
break ; 
case AIRPORT : set ( KEY_TYPE , "airport" ) ; 
break ; 
} 
return this ; 
} 
} 

public class BrowseIterator { 
public void start ( ) { 
if ( started ) throw new IllegalStateException ( ) ; 
started = true ; 
request = index . browseAsync ( query , requestOptions , completionHandler ) ; 
} 
} 

public class ExpiringCache { 
public V put ( K key , V value ) { 
V previous = null ; 
synchronized ( this ) { 
long timeout = System . currentTimeMillis ( ) + TimeUnit . MILLISECONDS . convert ( expirationTimeout , expirationTimeUnit ) ; 
final Pair < V , Long > previousPair = lruCache . put ( key , new Pair < > ( value , timeout ) ) ; 
if ( previousPair != null ) previous = previousPair . first ; 
} 
return previous ; 
} 
} 

public class ExpiringCache { 
synchronized public V get ( K key ) { 
final Pair < V , Long > cachePair = lruCache . get ( key ) ; 
if ( cachePair != null && cachePair . first != null ) if ( cachePair . second > System . currentTimeMillis ( ) ) return cachePair . first ; 
else lruCache . remove ( key ) ; 
return null ; 
} 
} 

public class ThreadSpawner { 
public void awaitCompletion ( ) { 
for ( Thread thread : threads ) { 
try { 
thread . join ( ) ; 
} 
catch ( InterruptedException e ) { 
throw rethrow ( e ) ; 
} 
} 
if ( caughtException != null ) throw rethrow ( caughtException ) ; 
} 
} 

public class VersionUtils { 
public static int versionCompare ( String firstVersionString , String secondVersionString ) { 
String [ ] firstVersion = parseVersionString ( firstVersionString ) ; 
String [ ] secondVersion = parseVersionString ( secondVersionString ) ; 
int i = 0 ; 
while ( i < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) i ++ ; 
if ( i < firstVersion . length && i < secondVersion . length ) { 
int diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; 
return Integer . signum ( diff ) ; 
} 
else return Integer . signum ( firstVersion . length - secondVersion . length ) ; 
} 
} 

public class ExceptionReporter { 
public static void report ( String testId , Throwable cause ) { 
if ( cause == null ) { 
LOGGER . fatal ( "Can't call report with a null exception" ) ; 
return ; 
} 
long exceptionCount = FAILURE_ID . incrementAndGet ( ) ; 
if ( exceptionCount > MAX_EXCEPTION_COUNT ) { 
LOGGER . warn ( "Exception #" + exceptionCount + " detected. The maximum number of exceptions has been exceeded, so it" + " won't be reported to the Agent." , cause ) ; 
return ; 
} 
LOGGER . warn ( "Exception #" + exceptionCount + " detected" , cause ) ; 
String targetFileName = exceptionCount + ".exception" ; 
File dir = getUserDir ( ) ; 
File tmpFile = new File ( dir , targetFileName + ".tmp" ) ; 
try { 
if ( ! tmpFile . createNewFile ( ) ) throw new IOException ( "Could not create tmp file: " + tmpFile . getAbsolutePath ( ) ) ; 
} 
catch ( IOException e ) { 
LOGGER . fatal ( "Could not report exception; this means that this exception is not visible to the coordinator" , e ) ; 
return ; 
} 
writeText ( testId + NEW_LINE + throwableToString ( cause ) , tmpFile ) ; 
File file = new File ( dir , targetFileName ) ; 
LOGGER . info ( file . getAbsolutePath ( ) ) ; 
rename ( tmpFile , file ) ; 
} 
} 

public class FileUtils { 
public static void copyDirectory ( File src , File target ) { 
checkNotNull ( src , "src can't be null" ) ; 
checkNotNull ( target , "target can't be null" ) ; 
File [ ] files = src . listFiles ( ) ; 
if ( files == null ) return ; 
for ( File srcFile : files ) { 
if ( srcFile . isDirectory ( ) ) { 
File targetChild = new File ( target , srcFile . getName ( ) ) ; 
ensureExistingDirectory ( targetChild ) ; 
copyDirectory ( srcFile , targetChild ) ; 
} 
else copyFileToDirectory ( srcFile , target ) ; 
} 
} 
} 

public class ReflectionUtils { 
public static < E > E getStaticFieldValue ( Class clazz , String fieldName , Class fieldType ) { 
Field field = getField ( clazz , fieldName , fieldType ) ; 
if ( field == null ) throw new ReflectionException ( format ( "Field %s.%s is not found" , clazz . getName ( ) , fieldName ) ) ; 
field . setAccessible ( true ) ; 
return getFieldValue0 ( null , field , clazz . getName ( ) , fieldName ) ; 
} 
} 

public class ReflectionUtils { 
public static Method getMethodByName ( Class clazz , String methodName ) { 
for ( Method method : clazz . getDeclaredMethods ( ) ) { 
if ( method . getName ( ) . equals ( methodName ) ) return method ; 
} 
return null ; 
} 
} 

public class JsonProtocol { 
protected void readJsonSyntaxChar ( byte [ ] b ) throws IOException { 
byte ch = reader . read ( ) ; 
if ( ch != b [ 0 ] ) throw new ProtocolException ( "Unexpected character:" + ( char ) ch ) ; 
} 
} 

public class JsonProtocol { 
private static byte hexVal ( byte ch ) throws IOException { 
if ( ( ch >= '0' ) && ( ch <= '9' ) ) return ( byte ) ( ( char ) ch - '0' ) ; 
else if ( ( ch >= 'a' ) && ( ch <= 'f' ) ) return ( byte ) ( ( char ) ch - 'a' + 10 ) ; 
else throw new ProtocolException ( "Expected hex character" ) ; 
} 
} 

public class JsonProtocol { 
private void writeJsonString ( byte [ ] b ) throws IOException { 
context . write ( ) ; 
transport . write ( QUOTE ) ; 
int len = b . length ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) if ( ( b [ i ] & 0x00FF ) >= 0x30 ) if ( b [ i ] == BACKSLASH [ 0 ] ) { 
transport . write ( BACKSLASH ) ; 
transport . write ( BACKSLASH ) ; 
} 
else transport . write ( b , i , 1 ) ; 
else { 
tmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; 
if ( tmpbuf [ 0 ] == 1 ) transport . write ( b , i , 1 ) ; 
else if ( tmpbuf [ 0 ] > 1 ) { 
transport . write ( BACKSLASH ) ; 
transport . write ( tmpbuf , 0 , 1 ) ; 
} 
else { 
transport . write ( ESCSEQ ) ; 
tmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; 
tmpbuf [ 1 ] = hexChar ( b [ i ] ) ; 
transport . write ( tmpbuf , 0 , 2 ) ; 
} 
} 
transport . write ( QUOTE ) ; 
} 
} 

public class JsonProtocol { 
private void writeJsonInteger ( long num ) throws IOException { 
context . write ( ) ; 
String str = Long . toString ( num ) ; 
boolean escapeNum = context . escapeNum ( ) ; 
if ( escapeNum ) transport . write ( QUOTE ) ; 
try { 
byte [ ] buf = str . getBytes ( "UTF-8" ) ; 
transport . write ( buf ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new AssertionError ( e ) ; 
} 
if ( escapeNum ) transport . write ( QUOTE ) ; 
} 
} 

public class JsonProtocol { 
private void writeJsonDouble ( double num ) throws IOException { 
context . write ( ) ; 
String str = Double . toString ( num ) ; 
boolean special = false ; 
switch ( str . charAt ( 0 ) ) { 
case 'N' : case 'I' : special = true ; 
break ; 
case '-' : if ( str . charAt ( 1 ) == 'I' ) special = true ; 
break ; 
default : break ; 
} 
boolean escapeNum = special || context . escapeNum ( ) ; 
if ( escapeNum ) transport . write ( QUOTE ) ; 
try { 
byte [ ] b = str . getBytes ( "UTF-8" ) ; 
transport . write ( b , 0 , b . length ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new AssertionError ( e ) ; 
} 
if ( escapeNum ) transport . write ( QUOTE ) ; 
} 
} 

public class JsonProtocol { 
private ByteString readJsonString ( boolean skipContext ) throws IOException { 
Buffer buffer = new Buffer ( ) ; 
ArrayList < Character > codeunits = new ArrayList < > ( ) ; 
if ( ! skipContext ) context . read ( ) ; 
readJsonSyntaxChar ( QUOTE ) ; 
while ( true ) { 
byte ch = reader . read ( ) ; 
if ( ch == QUOTE [ 0 ] ) break ; 
if ( ch == ESCSEQ [ 0 ] ) { 
ch = reader . read ( ) ; 
if ( ch == ESCSEQ [ 1 ] ) { 
transport . read ( tmpbuf , 0 , 4 ) ; 
short cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; 
try { 
if ( Character . isHighSurrogate ( ( char ) cu ) ) { 
if ( codeunits . size ( ) > 0 ) throw new ProtocolException ( "Expected low surrogate char" ) ; 
codeunits . add ( ( char ) cu ) ; 
} 
else if ( Character . isLowSurrogate ( ( char ) cu ) ) { 
if ( codeunits . size ( ) == 0 ) throw new ProtocolException ( "Expected high surrogate char" ) ; 
codeunits . add ( ( char ) cu ) ; 
buffer . write ( new String ( new int [ ] { 
codeunits . get ( 0 ) , codeunits . get ( 1 ) } 
, 0 , 2 ) . getBytes ( "UTF-8" ) ) ; 
codeunits . clear ( ) ; 
} 
else buffer . write ( new String ( new int [ ] { 
cu } 
, 0 , 1 ) . getBytes ( "UTF-8" ) ) ; 
continue ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new AssertionError ( e ) ; 
} 
catch ( IOException ex ) { 
throw new ProtocolException ( "Invalid unicode sequence" ) ; 
} 
} 
else { 
int off = ESCAPE_CHARS . indexOf ( ch ) ; 
if ( off == - 1 ) throw new ProtocolException ( "Expected control char" ) ; 
ch = ESCAPE_CHAR_VALS [ off ] ; 
} 
} 
buffer . write ( new byte [ ] { 
ch } 
) ; 
} 
return buffer . readByteString ( ) ; 
} 
} 

public class JsonProtocol { 
private String readJsonNumericChars ( ) throws IOException { 
StringBuilder strbld = new StringBuilder ( ) ; 
while ( true ) { 
byte ch = reader . peek ( ) ; 
if ( ! isJsonNumeric ( ch ) ) break ; 
strbld . append ( ( char ) reader . read ( ) ) ; 
} 
return strbld . toString ( ) ; 
} 
} 

public class JsonProtocol { 
private long readJsonInteger ( ) throws IOException { 
context . read ( ) ; 
if ( context . escapeNum ( ) ) readJsonSyntaxChar ( QUOTE ) ; 
String str = readJsonNumericChars ( ) ; 
if ( context . escapeNum ( ) ) readJsonSyntaxChar ( QUOTE ) ; 
try { 
return Long . valueOf ( str ) ; 
} 
catch ( NumberFormatException ex ) { 
throw new ProtocolException ( "Bad data encountered in numeric data" ) ; 
} 
} 
} 

public class JsonProtocol { 
private double readJsonDouble ( ) throws IOException { 
context . read ( ) ; 
if ( reader . peek ( ) == QUOTE [ 0 ] ) { 
ByteString str = readJsonString ( true ) ; 
double dub = Double . valueOf ( str . utf8 ( ) ) ; 
if ( ! context . escapeNum ( ) && ! Double . isNaN ( dub ) && ! Double . isInfinite ( dub ) ) throw new ProtocolException ( "Numeric data unexpectedly quoted" ) ; 
return dub ; 
} 
else { 
if ( context . escapeNum ( ) ) readJsonSyntaxChar ( QUOTE ) ; 
try { 
return Double . valueOf ( readJsonNumericChars ( ) ) ; 
} 
catch ( NumberFormatException ex ) { 
throw new ProtocolException ( "Bad data encountered in numeric data" ) ; 
} 
} 
} 
} 

public class ClientBase { 
protected final Object execute ( MethodCall < ? > methodCall ) throws Exception { 
if ( ! running . get ( ) ) throw new IllegalStateException ( "Cannot write to a closed service client" ) ; 
try { 
return invokeRequest ( methodCall ) ; 
} 
catch ( ServerException e ) { 
throw e . thriftException ; 
} 
} 
} 

public class ClientBase { 
final Object invokeRequest ( MethodCall < ? > call ) throws Exception { 
boolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; 
int sid = seqId . incrementAndGet ( ) ; 
protocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; 
call . send ( protocol ) ; 
protocol . writeMessageEnd ( ) ; 
protocol . flush ( ) ; 
if ( isOneWay ) return null ; 
MessageMetadata metadata = protocol . readMessageBegin ( ) ; 
if ( metadata . seqId != sid ) throw new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , "Unrecognized sequence ID" ) ; 
if ( metadata . type == TMessageType . EXCEPTION ) { 
ThriftException e = ThriftException . read ( protocol ) ; 
protocol . readMessageEnd ( ) ; 
throw new ServerException ( e ) ; 
} 
else if ( metadata . type != TMessageType . REPLY ) throw new ThriftException ( ThriftException . Kind . INVALID_MESSAGE_TYPE , "Invalid message type: " + metadata . type ) ; 
if ( metadata . seqId != seqId . get ( ) ) throw new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , "Out-of-order response" ) ; 
if ( ! metadata . name . equals ( call . name ) ) throw new ThriftException ( ThriftException . Kind . WRONG_METHOD_NAME , "Unexpected method name in reply; expected " + call . name + " but received " + metadata . name ) ; 
try { 
Object result = call . receive ( protocol , metadata ) ; 
protocol . readMessageEnd ( ) ; 
return result ; 
} 
catch ( Exception e ) { 
if ( e instanceof Struct ) protocol . readMessageEnd ( ) ; 
throw e ; 
} 
} 
} 

public class AsyncClientBase { 
protected void enqueue ( MethodCall < ? > methodCall ) { 
if ( ! running . get ( ) ) throw new IllegalStateException ( "Cannot write to a closed service client" ) ; 
if ( ! pendingCalls . offer ( methodCall ) ) throw new IllegalStateException ( "Call queue is full" ) ; 
} 
} 

public class PlatformUtils { 
public static void refreshRepositoryView ( ) { 
IWorkbenchWindow activeWindow = Activator . getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
if ( activeWindow == null ) return ; 
IWorkbenchPage page = activeWindow . getActivePage ( ) ; 
if ( page == null ) return ; 
RepositoryView view = ( RepositoryView ) page . findView ( IGuvnorConstants . REPVIEW_ID ) ; 
if ( view != null ) view . refresh ( ) ; 
} 
} 

public class PlatformUtils { 
public static ResourceHistoryView getResourceHistoryView ( ) throws Exception { 
IWorkbenchWindow activeWindow = Activator . getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
if ( activeWindow == null ) return null ; 
IWorkbenchPage page = activeWindow . getActivePage ( ) ; 
if ( page == null ) return null ; 
return ( ResourceHistoryView ) page . showView ( IGuvnorConstants . RESHISTORYVIEW_ID ) ; 
} 
} 

public class PlatformUtils { 
public static void openEditor ( String contents , String name ) { 
IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
IStorage storage = new StringStorage ( contents , name ) ; 
IStorageEditorInput input = new StringInput ( storage ) ; 
IWorkbenchPage page = window . getActivePage ( ) ; 
IEditorDescriptor desc = PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . getDefaultEditor ( name ) ; 
String editorId = desc != null ? desc . getId ( ) : "org.eclipse.ui.DefaultTextEditor" ; 
try { 
if ( page != null ) page . openEditor ( input , editorId ) ; 
} 
catch ( Exception e ) { 
Activator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; 
} 
} 
} 

public class KieNavigatorView { 
protected void startThread ( ) { 
if ( animationActive ) return ; 
stopAnimation = false ; 
final Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; 
final int SLEEP = 200 ; 
final Runnable [ ] animator = new Runnable [ 1 ] ; 
animator [ 0 ] = new Runnable ( ) { 
public void run ( ) { 
if ( ! stopAnimation ) { 
try { 
int size = 0 ; 
String [ ] servers ; 
synchronized ( starting ) { 
size = starting . size ( ) ; 
servers = new String [ size ] ; 
starting . toArray ( servers ) ; 
} 
for ( int i = 0 ; 
i < size ; 
i ++ ) { 
IServer server = ServerCore . findServer ( servers [ i ] ) ; 
if ( server != null ) treeViewer . update ( server , new String [ ] { 
"ICON" } 
) ; 
} 
} 
catch ( Exception e ) { 
} 
display . timerExec ( SLEEP , animator [ 0 ] ) ; 
} 
} 
} 
; 
Display . getDefault ( ) . asyncExec ( new Runnable ( ) { 
public void run ( ) { 
display . timerExec ( SLEEP , animator [ 0 ] ) ; 
} 
} 
) ; 
} 
} 

public class PropertyBehavior { 
public void setIsKeepAllAlive ( boolean isKeepAllAlive ) { 
Element child = getFirstChild ( root , childNames ) ; 
boolean isAlreadyKeepAllAlive = false ; 
if ( isDAVElement ( child , "keepalive" ) ) isAlreadyKeepAllAlive = "*" . equals ( getFirstText ( child ) ) ; 
if ( isKeepAllAlive ) if ( ! isAlreadyKeepAllAlive ) { 
if ( child != null ) root . removeChild ( child ) ; 
appendChild ( root , "keepalive" , "*" ) ; 
} 
else if ( isAlreadyKeepAllAlive ) root . removeChild ( child ) ; 
} 
} 

public class PropertyBehavior { 
public void setIsOmit ( boolean isOmit ) { 
Element child = getFirstChild ( root , childNames ) ; 
boolean isAlreadyOmit = isDAVElement ( child , "omit" ) ; 
if ( isOmit ) if ( ! isAlreadyOmit ) { 
if ( child != null ) root . removeChild ( child ) ; 
appendChild ( root , "omit" ) ; 
} 
else if ( isAlreadyOmit ) root . removeChild ( child ) ; 
} 
} 

public class ConditionTerm { 
public boolean matches ( ConditionTerm conditionTerm ) { 
int numberOfItemsToMatch = 0 ; 
boolean match = true ; 
Enumeration factors = getConditionFactors ( ) ; 
while ( match && factors . hasMoreElements ( ) ) { 
ConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; 
if ( factor . not ( ) ) match = ! conditionTerm . contains ( factor ) ; 
else { 
match = conditionTerm . contains ( factor ) ; 
numberOfItemsToMatch ++ ; 
} 
} 
match = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; 
return match ; 
} 
} 

public class DSLAdapter { 
public static Reader getDSLContent ( String ruleSource , IResource input ) throws CoreException { 
String dslFileName = findDSLConfigName ( ruleSource , input ) ; 
if ( dslFileName == null ) return null ; 
IResource res = findDSLResource ( input , dslFileName ) ; 
if ( res instanceof IFile ) { 
IFile dslConf = ( IFile ) res ; 
if ( dslConf . exists ( ) ) return new InputStreamReader ( dslConf . getContents ( ) ) ; 
} 
return null ; 
} 
} 

public class DebugUtil { 
public static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { 
IStatusHandler handler = getStackFrameProvider ( ) ; 
if ( handler != null ) { 
IJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; 
if ( stackFrame != null ) return stackFrame ; 
} 
IDebugTarget target = value . getDebugTarget ( ) ; 
IJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; 
if ( javaTarget != null ) { 
IThread [ ] threads = javaTarget . getThreads ( ) ; 
for ( int i = 0 ; 
i < threads . length ; 
i ++ ) { 
IThread thread = threads [ i ] ; 
if ( thread . isSuspended ( ) ) return ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; 
} 
} 
return null ; 
} 
} 

public class RuleCompletionProcessor { 
private boolean isSubtypeOf ( String class1 , String class2 ) { 
if ( class1 == null || class2 == null ) return false ; 
class1 = convertToNonPrimitiveClass ( class1 ) ; 
class2 = convertToNonPrimitiveClass ( class2 ) ; 
ClassTypeResolver resolver = new ClassTypeResolver ( getUniqueImports ( ) , ProjectClassLoader . getProjectClassLoader ( getEditor ( ) ) ) ; 
try { 
Class < ? > clazz1 = resolver . resolveType ( class1 ) ; 
Class < ? > clazz2 = resolver . resolveType ( class2 ) ; 
if ( clazz1 == null || clazz2 == null ) return false ; 
return clazz2 . isAssignableFrom ( clazz1 ) ; 
} 
catch ( ClassNotFoundException exc ) { 
return false ; 
} 
} 
} 

public class RuleCompletionProcessor { 
public static boolean containsProposal ( final Collection < ICompletionProposal > proposals , String newProposal ) { 
for ( ICompletionProposal prop : proposals ) { 
String displayString = prop . getDisplayString ( ) ; 
String [ ] existings = displayString . split ( " " ) ; 
if ( existings . length == 0 ) continue ; 
String [ ] newProposals = newProposal . split ( " " ) ; 
if ( newProposals . length == 0 ) continue ; 
if ( existings [ 0 ] . equals ( newProposals [ 0 ] ) ) return true ; 
} 
return false ; 
} 
} 

public class RequestInputStream { 
public void reset ( ) throws IOException { 
if ( file == null ) ( ( ByteArrayInputStream ) is ) . reset ( ) ; 
else { 
if ( fos != null ) { 
while ( skip ( 4096 ) > 0 ) ; 
fos . close ( ) ; 
fos = null ; 
if ( length == - 1 ) length = totalBytesRead ; 
} 
is . close ( ) ; 
is = new FileInputStream ( file ) ; 
} 
totalBytesRead = 0 ; 
} 
} 

public class GraphicalVertex { 
public void addConnection ( Connection conn ) { 
if ( conn == null || conn . getSource ( ) == conn . getTarget ( ) ) throw new IllegalArgumentException ( ) ; 
if ( conn . getSource ( ) == this ) { 
sourceConnections . add ( conn ) ; 
firePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; 
} 
else if ( conn . getTarget ( ) == this ) { 
targetConnections . add ( conn ) ; 
firePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; 
} 
} 
} 

public class GraphicalVertex { 
public Object getPropertyValue ( Object propertyId ) { 
if ( XPOS_PROP . equals ( propertyId ) ) return Integer . toString ( location . x ) ; 
if ( YPOS_PROP . equals ( propertyId ) ) return Integer . toString ( location . y ) ; 
if ( HEIGHT_PROP . equals ( propertyId ) ) return Integer . toString ( size . height ) ; 
if ( WIDTH_PROP . equals ( propertyId ) ) return Integer . toString ( size . width ) ; 
return null ; 
} 
} 

public class GraphicalVertex { 
public void removeConnection ( Connection conn ) { 
if ( conn == null ) throw new IllegalArgumentException ( ) ; 
if ( conn . getSource ( ) == this ) { 
sourceConnections . remove ( conn ) ; 
firePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; 
} 
else if ( conn . getTarget ( ) == this ) { 
targetConnections . remove ( conn ) ; 
firePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; 
} 
} 
} 

public class GraphicalVertex { 
public void setLocation ( Point newLocation ) { 
if ( newLocation == null ) throw new IllegalArgumentException ( ) ; 
location . setLocation ( newLocation ) ; 
firePropertyChange ( LOCATION_PROP , null , location ) ; 
} 
} 

public class GraphicalVertex { 
public static String dumpConstraints ( final Constraint [ ] constraints ) { 
if ( constraints == null ) return null ; 
final StringBuffer buffer = new StringBuffer ( ) ; 
for ( int i = 0 , length = constraints . length ; 
i < length ; 
i ++ ) buffer . append ( constraints [ i ] . toString ( ) + "<br>" ) ; 
return buffer . toString ( ) ; 
} 
} 

public class DroolsEclipsePlugin { 
public void start ( BundleContext context ) throws Exception { 
super . start ( context ) ; 
IPreferenceStore preferenceStore = getPreferenceStore ( ) ; 
useCachePreference = preferenceStore . getBoolean ( IDroolsConstants . CACHE_PARSED_RULES ) ; 
preferenceStore . addPropertyChangeListener ( new IPropertyChangeListener ( ) { 
public void propertyChange ( PropertyChangeEvent event ) { 
if ( IDroolsConstants . CACHE_PARSED_RULES . equals ( event . getProperty ( ) ) ) { 
useCachePreference = ( ( Boolean ) event . getNewValue ( ) ) . booleanValue ( ) ; 
if ( ! useCachePreference ) clearCache ( ) ; 
} 
} 
} 
) ; 
} 
} 

public class DateTime { 
public void setDateTime ( String date ) { 
String [ ] patterns = { 
RFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } 
; 
for ( int i = 0 ; 
i < patterns . length ; 
i ++ ) if ( setDateTime ( date , patterns [ i ] ) ) break ; 
} 
} 

public class FieldEditorPropertyPage { 
protected void addField ( FieldEditor editor ) { 
if ( fields == null ) fields = new ArrayList < FieldEditor > ( ) ; 
String name = editor . getPreferenceName ( ) ; 
editor . setPreferenceName ( getPreferenceName ( name ) ) ; 
fields . add ( editor ) ; 
} 
} 

public class FieldEditorPropertyPage { 
protected void adjustGridLayout ( ) { 
int numColumns = calcNumberOfColumns ( ) ; 
( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; 
if ( fields != null ) for ( int i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
FieldEditor fieldEditor = fields . get ( i ) ; 
fieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; 
} 
} 
} 

public class FieldEditorPropertyPage { 
protected void applyFont ( ) { 
if ( fields != null ) { 
Iterator < FieldEditor > e = fields . iterator ( ) ; 
while ( e . hasNext ( ) ) FieldEditor pe = e . next ( ) ; 
} 
} 
} 

public class CompletionContext { 
private void determineDialect ( String backText ) { 
dialect = null ; 
boolean mvel = MVEL_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; 
boolean java = JAVA_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; 
if ( mvel ) dialect = MVEL_DIALECT ; 
else if ( java ) dialect = JAVA_DIALECT ; 
} 
} 

public class Node { 
public Node addChild ( Node n ) { 
if ( ! this . children . containsKey ( n . getToken ( ) ) ) { 
this . children . put ( n . getToken ( ) , n ) ; 
n . setParent ( this ) ; 
return n ; 
} 
else return ( Node ) this . children . get ( n . getToken ( ) ) ; 
} 
} 

public class Precondition { 
public void addCondition ( Condition condition ) throws WebDAVException { 
Enumeration conditions = getConditions ( ) ; 
if ( condition . getResourceURI ( ) != null ) while ( conditions . hasMoreElements ( ) ) { 
Condition existingCondition = ( Condition ) conditions . nextElement ( ) ; 
if ( existingCondition . getResourceURI ( ) != null && existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMultipleSpecification" , condition . getResourceURI ( ) ) ) ; 
} 
this . conditions . addElement ( condition ) ; 
} 
} 

public class DSLRuleCompletionProcessor { 
public String getLastLine ( String backText ) { 
BufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; 
String last = "" ; 
String line = null ; 
try { 
while ( ( line = breader . readLine ( ) ) != null ) if ( line . length ( ) > 0 ) last = line ; 
} 
catch ( IOException e ) { 
DroolsEclipsePlugin . log ( e ) ; 
} 
if ( last . indexOf ( "(" ) > - 1 ) last = last . substring ( last . lastIndexOf ( "(" ) + 1 ) ; 
if ( last . indexOf ( "," ) > - 1 ) last = last . substring ( last . lastIndexOf ( "," ) + 1 ) ; 
if ( last . endsWith ( ")" ) ) last = "" ; 
return last ; 
} 
} 

public class DSLRuleCompletionProcessor { 
public String getLastNonDashLine ( String backText ) { 
BufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; 
String last = "" ; 
String line = null ; 
try { 
while ( ( line = breader . readLine ( ) ) != null ) { 
line = line . trim ( ) ; 
if ( line . length ( ) > 0 && ! line . startsWith ( "-" ) ) last = line ; 
} 
} 
catch ( IOException e ) { 
DroolsEclipsePlugin . log ( e ) ; 
} 
if ( last . indexOf ( "(" ) > - 1 && ! last . endsWith ( ")" ) ) last = last . substring ( 0 , last . indexOf ( "(" ) ) ; 
else if ( last . indexOf ( "(" ) > - 1 && last . endsWith ( ")" ) ) last = "" ; 
return last ; 
} 
} 

public class NewJBPMProjectWizard { 
private void createProcess ( IJavaProject project , IProgressMonitor monitor , String exampleType ) throws CoreException , IOException { 
String fileName = "org/jbpm/eclipse/wizard/project/" + exampleType + ".bpmn.template" ; 
IFolder folder = null ; 
folder = project . getProject ( ) . getFolder ( "src/main/resources/com/sample" ) ; 
FileUtils . createFolder ( folder , monitor ) ; 
IFile file = folder . getFile ( "sample.bpmn" ) ; 
InputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; 
if ( ! file . exists ( ) ) file . create ( inputstream , true , monitor ) ; 
else file . setContents ( inputstream , true , false , monitor ) ; 
fileName = "org/jbpm/eclipse/wizard/project/ProcessMain-" + exampleType + ".java" ; 
IRuntime runtime = startPage . getRuntime ( ) ; 
if ( runtime . getVersion ( ) . getMajor ( ) == 5 ) fileName += ".v5.template" ; 
else fileName += ".template" ; 
folder = project . getProject ( ) . getFolder ( "src/main/java" ) ; 
IPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; 
IPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( "com.sample" , true , monitor ) ; 
inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; 
packageFragment . createCompilationUnit ( "ProcessMain.java" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; 
if ( runtime . getVersion ( ) . getMajor ( ) == 5 ) if ( "advanced" . equals ( exampleType ) ) { 
folder = project . getProject ( ) . getFolder ( "src/main/resources/META-INF" ) ; 
FileUtils . createFolder ( folder , monitor ) ; 
inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( "org/jbpm/eclipse/wizard/project/ProcessLauncher-advanced-persistence.xml.template" ) ; 
file = folder . getFile ( "persistence.xml" ) ; 
if ( ! file . exists ( ) ) file . create ( inputstream , true , monitor ) ; 
else file . setContents ( inputstream , true , false , monitor ) ; 
} 
} 
} 

public class NewJBPMProjectWizard { 
private void createProcessSampleJUnit ( IJavaProject project , String exampleType , IProgressMonitor monitor ) throws JavaModelException , IOException { 
String s = "org/jbpm/eclipse/wizard/project/ProcessJUnit-" + exampleType + ".java" ; 
IRuntime runtime = startPage . getRuntime ( ) ; 
if ( runtime . getVersion ( ) . getMajor ( ) == 5 ) s += ".v5.template" ; 
else s += ".template" ; 
IFolder folder = project . getProject ( ) . getFolder ( "src/main/java" ) ; 
IPackageFragmentRoot packageFragmentRoot = project . getPackageFragmentRoot ( folder ) ; 
IPackageFragment packageFragment = packageFragmentRoot . createPackageFragment ( "com.sample" , true , monitor ) ; 
InputStream inputstream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( s ) ; 
packageFragment . createCompilationUnit ( "ProcessTest.java" , new String ( FileUtils . readStream ( inputstream ) ) , true , monitor ) ; 
} 
} 

public class KieServiceDelegate { 
protected String httpDelete ( String request ) throws IOException { 
String host = getKieRESTUrl ( ) ; 
URL url = new URL ( host + "/" + request ) ; 
Activator . println ( "[DELETE] " + url . toString ( ) ) ; 
HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; 
conn . setRequestMethod ( "DELETE" ) ; 
conn . setRequestProperty ( "Content" , "application/json" ) ; 
setHttpCredentials ( conn ) ; 
String response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; 
Activator . println ( "[DELETE] response: " + response ) ; 
if ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) throw new IOException ( "HTTP DELETE failed : HTTP error code : " + conn . getResponseCode ( ) ) ; 
JsonObject jo = JsonObject . readFrom ( response ) ; 
String status = jo . get ( "status" ) . asString ( ) ; 
if ( status != null && ! status . isEmpty ( ) ) if ( ! "APPROVED" . equals ( status ) ) throw new IOException ( "HTTP DELETE failed : Request status code : " + status ) ; 
String jobId = jo . get ( "jobId" ) . asString ( ) ; 
if ( jobId != null && ! jobId . isEmpty ( ) ) return jobId ; 
return response ; 
} 
} 

public class KieServiceDelegate { 
protected String httpPost ( String request , JsonObject body ) throws IOException , RuntimeException { 
String host = getKieRESTUrl ( ) ; 
URL url = new URL ( host + "/" + request ) ; 
Activator . println ( "[POST] " + url . toString ( ) + " body: " + body ) ; 
HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; 
conn . setDoOutput ( body != null ) ; 
conn . setRequestMethod ( "POST" ) ; 
conn . setRequestProperty ( "Content-Type" , "application/json" ) ; 
setHttpCredentials ( conn ) ; 
if ( body != null ) { 
java . io . OutputStream os = conn . getOutputStream ( ) ; 
Writer writer = new OutputStreamWriter ( os , "UTF-8" ) ; 
body . writeTo ( writer ) ; 
writer . close ( ) ; 
os . flush ( ) ; 
} 
String response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; 
Activator . println ( "[POST] response: " + response ) ; 
if ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) throw new IOException ( "HTTP POST failed : HTTP error code : " + conn . getResponseCode ( ) ) ; 
JsonObject jo = JsonObject . readFrom ( response ) ; 
String status = jo . get ( "status" ) . asString ( ) ; 
if ( status != null && ! status . isEmpty ( ) ) if ( ! "APPROVED" . equals ( status ) ) throw new IOException ( "HTTP POST failed : Request status code : " + status ) ; 
String jobId = jo . get ( "jobId" ) . asString ( ) ; 
if ( jobId != null && ! jobId . isEmpty ( ) ) return jobId ; 
return response ; 
} 
} 

public class KieServiceDelegate { 
public String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { 
final AtomicReference < String > ar = new AtomicReference < String > ( ) ; 
IWorkbench wb = PlatformUI . getWorkbench ( ) ; 
IProgressService ps = wb . getProgressService ( ) ; 
try { 
ps . busyCursorWhile ( new IRunnableWithProgress ( ) { 
public void run ( IProgressMonitor pm ) throws InterruptedException { 
pm . beginTask ( "Waiting for Job " + jobId + ":\n\n" + title , STATUS_REQUEST_TIMEOUT ) ; 
pm . subTask ( title ) ; 
long startTime = System . currentTimeMillis ( ) ; 
long stopTime = startTime ; 
do { 
try { 
Thread . sleep ( STATUS_REQUEST_DELAY ) ; 
String response = httpGet ( "jobs/" + jobId ) ; 
JsonObject jo = JsonObject . readFrom ( response ) ; 
String status = jo . get ( "status" ) . asString ( ) ; 
String result = jo . get ( "result" ) . asString ( ) ; 
if ( "null" . equals ( result ) ) if ( ! "SUCCESS" . equals ( status ) ) result = null ; 
if ( status != null && result != null ) ar . set ( status + ":" + result ) ; 
stopTime = System . currentTimeMillis ( ) ; 
pm . worked ( STATUS_REQUEST_DELAY ) ; 
Activator . println ( "status=" + status ) ; 
Activator . println ( "result=" + result ) ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
} 
if ( pm . isCanceled ( ) ) throw new InterruptedException ( "Operation canceled" ) ; 
} 
while ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; 
pm . done ( ) ; 
Activator . println ( "\n----------------------------------\n" + "Job " + jobId + "\n" + title + "\ncompleted in " + ( stopTime - startTime ) / 1000.0 + " sec\n" + "Status: " + ar . get ( ) + "\n----------------------------------\n" ) ; 
} 
} 
) ; 
} 
catch ( InvocationTargetException e ) { 
e . printStackTrace ( ) ; 
return null ; 
} 
return ar . get ( ) ; 
} 
} 

public class AbstractCompletionProcessor { 
protected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { 
if ( prefix != null && prefix . trim ( ) . length ( ) > 0 ) { 
Iterator < ICompletionProposal > iterator = props . iterator ( ) ; 
String prefixLc = prefix . toLowerCase ( ) ; 
while ( iterator . hasNext ( ) ) { 
ICompletionProposal item = iterator . next ( ) ; 
String content = item . getDisplayString ( ) . toLowerCase ( ) ; 
if ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) iterator . remove ( ) ; 
} 
} 
} 
} 

public class VertexEditPartFactory { 
private EditPart getPartForElement ( Object modelElement ) { 
if ( modelElement instanceof ReteGraph ) return new DiagramEditPart ( ) ; 
if ( modelElement instanceof BaseVertex ) return new VertexEditPart ( ) ; 
if ( modelElement instanceof Connection ) return new ConnectionEditPart ( ) ; 
DroolsEclipsePlugin . log ( new Exception ( "Can't create part for model element: " + ( ( modelElement != null ) ? modelElement . getClass ( ) . getName ( ) : "null" ) ) ) ; 
return null ; 
} 
} 

public class RowList { 
public void add ( final int depth , final BaseVertex vertex ) { 
if ( this . rows . size ( ) < ( depth + 1 ) ) { 
final int addRows = depth - this . rows . size ( ) + 1 ; 
for ( int i = 0 ; 
i < addRows ; 
++ i ) this . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; 
} 
( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; 
} 
} 

public class RowList { 
public int getRow ( final BaseVertex vertex ) { 
final int numRows = this . rows . size ( ) ; 
for ( int i = 0 ; 
i < numRows ; 
++ i ) if ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) return i ; 
return - 1 ; 
} 
} 

public class RowList { 
public int getWidth ( ) { 
int width = 0 ; 
for ( final Iterator < Row > rowIter = this . rows . iterator ( ) ; 
rowIter . hasNext ( ) ; 
) { 
final Row row = rowIter . next ( ) ; 
final int rowWidth = row . getWidth ( ) ; 
if ( rowWidth > width ) width = rowWidth ; 
} 
return width ; 
} 
} 

public class RowList { 
public void dump ( ) { 
final int numRows = this . rows . size ( ) ; 
for ( int i = 0 ; 
i < numRows ; 
++ i ) System . err . println ( i + ": " + get ( i ) . getVertices ( ) ) ; 
} 
} 

public class RowList { 
public void optimize ( ) { 
final int numRows = this . rows . size ( ) ; 
for ( int i = 0 ; 
i < numRows ; 
++ i ) get ( i ) . optimize ( ) ; 
} 
} 

public class ReteViewer { 
public ReteGraph loadReteModel ( IProgressMonitor monitor , String contents ) throws Throwable { 
if ( relayoutRequired == false ) return diagram ; 
ReteGraph newDiagram = new ReteGraph ( ) ; 
try { 
monitor . beginTask ( "Loading RETE Tree" , 100 ) ; 
monitor . subTask ( "Loading Rule Base" ) ; 
InternalKnowledgeBase ruleBase = null ; 
try { 
IResource resource = drlEditor . getResource ( ) ; 
ClassLoader newLoader = DroolsBuilder . class . getClassLoader ( ) ; 
if ( resource . getProject ( ) . getNature ( "org.eclipse.jdt.core.javanature" ) != null ) { 
IJavaProject project = JavaCore . create ( resource . getProject ( ) ) ; 
newLoader = ProjectClassLoader . getProjectClassLoader ( project ) ; 
} 
DRLInfo drlInfo = DroolsEclipsePlugin . getDefault ( ) . parseResource ( drlEditor , true , true ) ; 
if ( drlInfo == null ) throw new Exception ( "Could not find DRL info" ) ; 
if ( drlInfo . getBuilderErrors ( ) . length > 0 ) throw new Exception ( drlInfo . getBuilderErrors ( ) . length + " build errors" ) ; 
if ( drlInfo . getParserErrors ( ) . size ( ) > 0 ) throw new Exception ( drlInfo . getParserErrors ( ) . size ( ) + " parser errors" ) ; 
InternalKnowledgePackage pkg = drlInfo . getPackage ( ) ; 
RuleBaseConfiguration config = new RuleBaseConfiguration ( ) ; 
config . setClassLoader ( newLoader ) ; 
ruleBase = KnowledgeBaseFactory . newKnowledgeBase ( config ) ; 
if ( pkg != null ) ruleBase . addPackage ( pkg ) ; 
} 
catch ( Throwable t ) { 
DroolsEclipsePlugin . log ( t ) ; 
throw new Exception ( MSG_PARSE_ERROR + " " + t . getMessage ( ) ) ; 
} 
monitor . worked ( 50 ) ; 
if ( monitor . isCanceled ( ) ) throw new InterruptedException ( ) ; 
monitor . subTask ( "Building RETE Tree" ) ; 
final ReteooVisitor visitor = new ReteooVisitor ( newDiagram ) ; 
visitor . visitInternalKnowledgeBase ( ruleBase ) ; 
monitor . worked ( 30 ) ; 
if ( monitor . isCanceled ( ) ) throw new InterruptedException ( ) ; 
monitor . subTask ( "Calculating RETE Tree Layout" ) ; 
BaseVertex rootVertex = visitor . getRootVertex ( ) ; 
RowList rowList = ReteooLayoutFactory . calculateReteRows ( rootVertex ) ; 
ReteooLayoutFactory . layoutRowList ( newDiagram , rowList ) ; 
zeroBaseDiagram ( newDiagram ) ; 
monitor . worked ( 20 ) ; 
if ( monitor . isCanceled ( ) ) throw new InterruptedException ( ) ; 
monitor . done ( ) ; 
} 
catch ( Throwable t ) { 
if ( ! ( t instanceof InterruptedException ) ) DroolsEclipsePlugin . log ( t ) ; 
throw t ; 
} 
relayoutRequired = false ; 
return newDiagram ; 
} 
} 

public class ReteViewer { 
public void drawGraph ( ReteGraph newGraph ) { 
LayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; 
ConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; 
if ( getGraphicalViewer ( ) . getContents ( ) == null ) getGraphicalViewer ( ) . setContents ( getModel ( ) ) ; 
final boolean isNewDiagram = newGraph != null && newGraph != diagram ; 
if ( isNewDiagram ) diagram . removeAll ( ) ; 
ConnectionRouter router ; 
if ( ( isNewDiagram && newGraph . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) || ( ! isNewDiagram && getModel ( ) . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) ) router = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; 
else router = ConnectionRouter . NULL ; 
connLayer . setConnectionRouter ( router ) ; 
if ( newGraph != null && newGraph != diagram ) diagram . addAll ( newGraph . getChildren ( ) ) ; 
} 
} 

public class DroolsDebugTarget { 
public DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { 
if ( source == null ) return null ; 
Iterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
IJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; 
if ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( "mvel" ) ) { 
DroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; 
try { 
int matchLine = l . getLineNumber ( ) ; 
String matchSource = l . getRuleName ( ) ; 
if ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) return l ; 
} 
catch ( CoreException e ) { 
logError ( e ) ; 
} 
} 
} 
return null ; 
} 
} 

public class AbstractResourceHandle { 
public void move ( ILocator destination , boolean overwrite , Enumeration names ) throws DAVException { 
IContext context = newContext ( ) ; 
context . setOverwrite ( overwrite ) ; 
Document document = newDocument ( ) ; 
PropertyBehavior propertyBehavior = PropertyBehavior . create ( document ) ; 
if ( names == null ) propertyBehavior . setIsKeepAllAlive ( true ) ; 
else while ( names . hasMoreElements ( ) ) { 
Object obj = names . nextElement ( ) ; 
Assert . isTrue ( obj instanceof QualifiedName , Policy . bind ( "assert.propNameMustBeEnumOverQual" ) ) ; 
propertyBehavior . addProperty ( ( ( QualifiedName ) obj ) . getLocalName ( ) ) ; 
} 
IResponse response = null ; 
try { 
response = davClient . move ( locator , destination , context , document ) ; 
examineResponse ( response ) ; 
examineMultiStatusResponse ( response ) ; 
} 
catch ( IOException e ) { 
throw new SystemException ( e ) ; 
} 
finally { 
closeResponse ( response ) ; 
} 
} 
} 

public class Request { 
public void write ( OutputStream os ) throws IOException { 
if ( requestBodyWriter == null ) { 
if ( inputRead ) { 
is . reset ( ) ; 
inputRead = false ; 
} 
super . write ( os ) ; 
} 
else requestBodyWriter . writeRequestBody ( os ) ; 
} 
} 

public class PropFind { 
public void setIsAllProp ( boolean isAllProp ) { 
Element child = getFirstChild ( root , childNames ) ; 
boolean isAlreadyAllProp = isDAVElement ( child , "allprop" ) ; 
if ( isAllProp ) if ( ! isAlreadyAllProp ) { 
if ( child != null ) root . removeChild ( child ) ; 
appendChild ( root , "allprop" ) ; 
} 
else if ( isAlreadyAllProp ) root . removeChild ( child ) ; 
} 
} 

public class PropFind { 
public void setIsPropName ( boolean isPropName ) { 
Element child = getFirstChild ( root , childNames ) ; 
boolean isAlreadyPropName = isDAVElement ( child , "propname" ) ; 
if ( isPropName ) if ( ! isAlreadyPropName ) { 
if ( child != null ) root . removeChild ( child ) ; 
appendChild ( root , "propname" ) ; 
} 
else if ( isAlreadyPropName ) root . removeChild ( child ) ; 
} 
} 

public class CompletionUtil { 
public static String stripLastWord ( String prefix ) { 
if ( "" . equals ( prefix ) ) return prefix ; 
if ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) return "" ; 
else { 
char [ ] c = prefix . toCharArray ( ) ; 
int start = 0 ; 
for ( int i = c . length - 1 ; 
i >= 0 ; 
i -- ) if ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { 
start = i + 1 ; 
break ; 
} 
prefix = prefix . substring ( start , prefix . length ( ) ) ; 
return prefix ; 
} 
} 
} 

public class Message { 
public void write ( OutputStream os ) throws IOException { 
Assert . isTrue ( ! inputRead ) ; 
Assert . isTrue ( ! hasInputStream ) ; 
int bytesRead = 0 ; 
int totalBytesRead = 0 ; 
byte [ ] buffer = bufferPool . getBuffer ( ) ; 
long contentLength = getContentLength ( ) ; 
try { 
while ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { 
if ( contentLength == - 1 ) bytesRead = is . read ( buffer ) ; 
else bytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; 
if ( bytesRead == - 1 ) if ( contentLength >= 0 ) throw new IOException ( Policy . bind ( "exception.unexpectedEndStream" ) ) ; 
else { 
totalBytesRead += bytesRead ; 
os . write ( buffer , 0 , bytesRead ) ; 
} 
} 
} 
finally { 
bufferPool . putBuffer ( buffer ) ; 
inputRead = true ; 
} 
} 
} 

public class DroolsThread { 
public synchronized void stepOver ( ) throws DebugException { 
if ( ! ( getTopStackFrame ( ) instanceof MVELStackFrame ) ) { 
super . stepOver ( ) ; 
return ; 
} 
MVELStackFrame mvelStack = ( MVELStackFrame ) getTopStackFrame ( ) ; 
if ( ! canStepOver ( ) || ! mvelStack . canStepOver ( ) ) return ; 
if ( ! setRemoteOnBreakReturn ( Debugger . STEP ) ) return ; 
setRunning ( true ) ; 
preserveStackFrames ( ) ; 
fireEvent ( new DebugEvent ( this , DebugEvent . RESUME , DebugEvent . STEP_OVER ) ) ; 
try { 
getUnderlyingThread ( ) . resume ( ) ; 
} 
catch ( RuntimeException e ) { 
targetRequestFailed ( MessageFormat . format ( JDIDebugModelMessages . JDIThread_exception_stepping , e . toString ( ) ) , e ) ; 
} 
} 
} 

public class DroolsBuilder { 
protected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { 
for ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; 
iter . hasNext ( ) ; 
) { 
Object error = iter . next ( ) ; 
if ( error instanceof ParserError ) { 
ParserError err = ( ParserError ) error ; 
markers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; 
} 
else if ( error instanceof KnowledgeBuilderResult ) { 
KnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; 
int [ ] errorLines = res . getLines ( ) ; 
markers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; 
} 
else if ( error instanceof ExpanderException ) { 
ExpanderException exc = ( ExpanderException ) error ; 
markers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; 
} 
else markers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; 
} 
} 
} 

public class GuvnorMetadataUtils { 
public static boolean addResourceToGuvnor ( String repLoc , String targetLoc , IFile selectedFile ) { 
boolean res = false ; 
try { 
String fullPath = targetLoc + selectedFile . getName ( ) ; 
IWebDavClient client = WebDavServerCache . getWebDavClient ( repLoc ) ; 
if ( client == null ) { 
client = WebDavClientFactory . createClient ( new URL ( repLoc ) ) ; 
WebDavServerCache . cacheWebDavClient ( repLoc , client ) ; 
} 
try { 
res = client . createResource ( fullPath , new ByteArrayInputStream ( new byte [ 0 ] ) , false ) ; 
if ( res ) client . putResource ( fullPath , selectedFile . getContents ( ) ) ; 
} 
catch ( WebDavException wde ) { 
if ( wde . getErrorCode ( ) != IResponse . SC_UNAUTHORIZED ) throw wde ; 
boolean retry = PlatformUtils . getInstance ( ) . authenticateForServer ( repLoc , client ) ; 
if ( retry ) { 
res = client . createResource ( fullPath , new ByteArrayInputStream ( new byte [ 0 ] ) , false ) ; 
if ( res ) client . putResource ( fullPath , selectedFile . getContents ( ) ) ; 
} 
} 
if ( res ) { 
GuvnorMetadataUtils . markCurrentGuvnorResource ( selectedFile ) ; 
ResourceProperties resProps = client . queryProperties ( fullPath ) ; 
GuvnorMetadataProps mdProps = new GuvnorMetadataProps ( selectedFile . getName ( ) , repLoc , fullPath , resProps . getLastModifiedDate ( ) , resProps . getRevision ( ) ) ; 
GuvnorMetadataUtils . setGuvnorMetadataProps ( selectedFile . getFullPath ( ) , mdProps ) ; 
} 
} 
catch ( Exception e ) { 
Activator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; 
} 
return res ; 
} 
} 

public class GuvnorMetadataUtils { 
public static void commitFileChanges ( IFile selectedFile ) { 
try { 
GuvnorMetadataProps props = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; 
IWebDavClient client = WebDavServerCache . getWebDavClient ( props . getRepository ( ) ) ; 
if ( client == null ) { 
client = WebDavClientFactory . createClient ( new URL ( props . getRepository ( ) ) ) ; 
WebDavServerCache . cacheWebDavClient ( props . getRepository ( ) , client ) ; 
} 
ResourceProperties remoteProps = null ; 
try { 
remoteProps = client . queryProperties ( props . getFullpath ( ) ) ; 
} 
catch ( WebDavException wde ) { 
if ( wde . getErrorCode ( ) != IResponse . SC_UNAUTHORIZED ) throw wde ; 
boolean retry = PlatformUtils . getInstance ( ) . authenticateForServer ( props . getRepository ( ) , client ) ; 
if ( retry ) remoteProps = client . queryProperties ( props . getFullpath ( ) ) ; 
} 
if ( remoteProps == null ) throw new Exception ( "Could not retrieve server version of " + props . getFullpath ( ) ) ; 
boolean proceed = true ; 
if ( ! props . getRevision ( ) . equals ( remoteProps . getRevision ( ) ) ) { 
String msg = MessageFormat . format ( Messages . getString ( "overwrite.confirmation" ) , new Object [ ] { 
selectedFile . getName ( ) , remoteProps . getRevision ( ) , props . getRevision ( ) } 
) ; 
Display display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; 
proceed = MessageDialog . openQuestion ( display . getActiveShell ( ) , Messages . getString ( "overwrite.confirmation.caption" ) , msg ) ; 
} 
if ( proceed ) { 
client . putResource ( props . getFullpath ( ) , selectedFile . getContents ( ) ) ; 
GuvnorMetadataUtils . markCurrentGuvnorResource ( selectedFile ) ; 
ResourceProperties resProps = client . queryProperties ( props . getFullpath ( ) ) ; 
GuvnorMetadataProps mdProps = GuvnorMetadataUtils . getGuvnorMetadata ( selectedFile ) ; 
mdProps . setVersion ( resProps . getLastModifiedDate ( ) ) ; 
mdProps . setRevision ( resProps . getRevision ( ) ) ; 
GuvnorMetadataUtils . setGuvnorMetadataProps ( selectedFile . getFullPath ( ) , mdProps ) ; 
} 
} 
catch ( Exception e ) { 
Activator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; 
} 
} 
} 

public class DSLTree { 
protected String getObjMetadata ( String text ) { 
if ( text . startsWith ( "[" ) ) return text . substring ( 1 , text . lastIndexOf ( "]" ) ) ; 
else return "" ; 
} 
} 

public class DSLTree { 
protected String stripObjMetadata ( String text ) { 
if ( text . startsWith ( "[" ) ) return text . substring ( text . lastIndexOf ( "]" ) + 1 ) ; 
else return text ; 
} 
} 

public class DSLTree { 
public Node [ ] getConditionChildren ( String text ) { 
Node thenode = this . rootCond ; 
if ( text . length ( ) > 0 ) { 
StringTokenizer tokenz = new StringTokenizer ( text ) ; 
this . last = this . current ; 
while ( tokenz . hasMoreTokens ( ) ) { 
String strtk = tokenz . nextToken ( ) ; 
Node ch = thenode . getChild ( strtk ) ; 
if ( ch != null ) thenode = ch ; 
else break ; 
} 
if ( thenode != this . rootCond ) this . current = thenode ; 
} 
Collection < Node > children = thenode . getChildren ( ) ; 
Node [ ] nchild = new Node [ children . size ( ) ] ; 
return children . toArray ( nchild ) ; 
} 
} 

public class DSLTree { 
public Node [ ] getChildren ( String obj , String text ) { 
Node thenode = this . rootCond . getChild ( obj ) ; 
if ( thenode == null ) for ( Node child : this . rootCond . getChildren ( ) ) { 
String tokenText = child . getToken ( ) ; 
if ( tokenText != null ) { 
int index = tokenText . indexOf ( "{" ) ; 
if ( index != - 1 ) { 
String substring = tokenText . substring ( 0 , index ) ; 
if ( obj != null && obj . startsWith ( substring ) ) thenode = child ; 
} 
} 
} 
if ( thenode != null && text . length ( ) > 0 ) { 
StringTokenizer tokenz = new StringTokenizer ( text ) ; 
this . last = this . current ; 
while ( tokenz . hasMoreTokens ( ) ) { 
String strtk = tokenz . nextToken ( ) ; 
Node ch = thenode . getChild ( strtk ) ; 
if ( ch != null ) thenode = ch ; 
else break ; 
} 
if ( thenode != this . rootCond ) this . current = thenode ; 
} 
if ( thenode == null ) return null ; 
Collection < Node > children = thenode . getChildren ( ) ; 
Node [ ] nchild = new Node [ children . size ( ) ] ; 
return children . toArray ( nchild ) ; 
} 
} 

public class DSLTree { 
public void addChildToList ( Node n , String prefix , ArrayList < String > list ) { 
if ( n . getChildren ( ) . size ( ) > 0 ) for ( Node child : n . getChildren ( ) ) { 
if ( prefix != null && "-" . equals ( child . getToken ( ) ) ) { 
if ( ! list . contains ( prefix ) ) list . add ( prefix ) ; 
return ; 
} 
String text = ( prefix == null ? "" : prefix + " " ) + child . getToken ( ) ; 
addChildToList ( child , text , list ) ; 
} 
else if ( ! list . contains ( prefix ) ) list . add ( prefix ) ; 
} 
} 

public class DSLTree { 
protected void printTabs ( int count ) { 
for ( int idx = 0 ; 
idx < count ; 
idx ++ ) System . out . print ( tab ) ; 
} 
} 

public class HttpClient { 
public Response invoke ( Request request ) throws IOException { 
Assert . isNotNull ( request ) ; 
try { 
open ( ) ; 
URL resourceUrl = request . getResourceUrl ( ) ; 
URL originServerUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , "/" ) ; 
URL proxyServerUrl = getProxyServerUrl ( originServerUrl ) ; 
if ( proxyServerUrl == null && ! matchesProxyServerException ( originServerUrl ) ) proxyServerUrl = getDefaultProxyServerUrl ( ) ; 
IContext context = webDAVFactory . newContext ( request . getContext ( ) ) ; 
IContext defaultContext = getContext ( originServerUrl ) ; 
if ( defaultContext == null ) defaultContext = getDefaultContext ( ) ; 
if ( defaultContext != null ) { 
Enumeration e = defaultContext . keys ( ) ; 
while ( e . hasMoreElements ( ) ) { 
String key = ( String ) e . nextElement ( ) ; 
context . put ( key , defaultContext . get ( key ) ) ; 
} 
} 
if ( authority != null ) { 
authority . authorize ( request , null , context , proxyServerUrl , true ) ; 
authority . authorize ( request , null , context , proxyServerUrl , false ) ; 
} 
return invoke1 ( request , context , proxyServerUrl , originServerUrl , 0 , 0 ) ; 
} 
finally { 
request . close ( ) ; 
} 
} 
} 

public class NewDroolsProjectWizard { 
private void createRuleSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { 
Version version = startPage . getRuntime ( ) . getVersion ( ) ; 
if ( version . getMajor ( ) == 4 ) createProjectJavaFile ( project , "org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template" , "DroolsTest.java" ) ; 
else if ( version . getMajor ( ) == 5 ) createProjectJavaFile ( project , "org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template" , "DroolsTest.java" ) ; 
else if ( version . getMajor ( ) >= 6 ) createProjectJavaFile ( project , "org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template" , "DroolsTest.java" ) ; 
} 
} 

public class NewDroolsProjectWizard { 
private void createRule ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { 
if ( startPage . getRuntime ( ) . getVersion ( ) . getMajor ( ) >= 6 ) { 
FileUtils . createFolder ( project , "src/main/resources/com/sample/rules" , monitor ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/Sample.drl.template" , "src/main/resources/com/sample/rules" , "Sample.drl" ) ; 
} 
else createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/Sample.drl.template" , "src/main/rules" , "Sample.drl" ) ; 
} 
} 

public class NewDroolsProjectWizard { 
private void createRuleFlow ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { 
Version version = startPage . getRuntime ( ) . getVersion ( ) ; 
if ( version . getMajor ( ) == 4 ) { 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow_4.rf.template" , "src/main/rules" , "ruleflow.rf" ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow_4.rfm.template" , "src/main/rules" , "ruleflow.rfm" ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow_4.drl.template" , "src/main/rules" , "ruleflow.drl" ) ; 
} 
else if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/ruleflow.rf.template" , "src/main/rules" , "ruleflow.rf" ) ; 
else if ( version . getMajor ( ) == 5 ) createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/sample.bpmn.template" , "src/main/rules" , "sample.bpmn" ) ; 
else { 
FileUtils . createFolder ( project , "src/main/resources/com/sample/process" , monitor ) ; 
createProjectFile ( project , monitor , "org/drools/eclipse/wizard/project/sample.bpmn.template" , "src/main/resources/com/sample/process" , "sample.bpmn" ) ; 
} 
} 
} 

public class NewDroolsProjectWizard { 
private void createRuleFlowSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { 
String s ; 
Version version = startPage . getRuntime ( ) . getVersion ( ) ; 
if ( version . getMajor ( ) == 4 ) s = "org/drools/eclipse/wizard/project/RuleFlowLauncherSample_4.java.template" ; 
else if ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) s = "org/drools/eclipse/wizard/project/RuleFlowLauncherSample.java.template" ; 
else if ( version . getMajor ( ) == 5 ) s = "org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_5.java.template" ; 
else s = "org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_6.java.template" ; 
createProjectJavaFile ( project , s , "ProcessTest.java" ) ; 
} 
} 

public class GenericModelEditor { 
public void createImage ( OutputStream stream , int format ) { 
SWTGraphics g = null ; 
GC gc = null ; 
Image image = null ; 
LayerManager layerManager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; 
IFigure figure = layerManager . getLayer ( LayerConstants . PRINTABLE_LAYERS ) ; 
Rectangle r = figure . getBounds ( ) ; 
try { 
image = new Image ( Display . getDefault ( ) , r . width , r . height ) ; 
gc = new GC ( image ) ; 
g = new SWTGraphics ( gc ) ; 
g . translate ( r . x * - 1 , r . y * - 1 ) ; 
figure . paint ( g ) ; 
ImageLoader imageLoader = new ImageLoader ( ) ; 
imageLoader . data = new ImageData [ ] { 
image . getImageData ( ) } 
; 
imageLoader . save ( stream , format ) ; 
} 
catch ( Throwable t ) { 
DroolsEclipsePlugin . log ( t ) ; 
} 
finally { 
if ( g != null ) g . dispose ( ) ; 
if ( gc != null ) gc . dispose ( ) ; 
if ( image != null ) image . dispose ( ) ; 
} 
} 
} 

public class AlphaNodeVertex { 
public String getFieldName ( ) { 
AlphaNodeFieldConstraint constraint = this . node . getConstraint ( ) ; 
if ( constraint instanceof MvelConstraint ) { 
MvelConstraint mvelConstraint = ( MvelConstraint ) constraint ; 
InternalReadAccessor accessor = mvelConstraint . getFieldExtractor ( ) ; 
if ( accessor instanceof ClassFieldReader ) return ( ( ClassFieldReader ) accessor ) . getFieldName ( ) ; 
} 
return null ; 
} 
} 

public class WebDavClient { 
private void addGuvnorResourceProperties ( ResourceProperties props , String filename , String resource ) throws Exception { 
if ( props == null ) return ; 
IResponse response = null ; 
try { 
String path = resource . substring ( 0 , resource . lastIndexOf ( '/' ) ) ; 
String apiVer = changeToAPICall ( path ) ; 
Properties guvProps = new Properties ( ) ; 
response = getResourceInputStream ( apiVer ) ; 
guvProps . load ( response . getInputStream ( ) ) ; 
String val = guvProps . getProperty ( filename ) ; 
if ( val != null ) { 
StringTokenizer tokens = new StringTokenizer ( val , "," ) ; 
if ( tokens . hasMoreElements ( ) ) props . setLastModifiedDate ( tokens . nextToken ( ) ) ; 
if ( tokens . hasMoreElements ( ) ) props . setRevision ( tokens . nextToken ( ) ) ; 
} 
else { 
Exception nfe = new Exception ( "Failed to get Guvnor properties for " + filename ) ; 
Activator . getDefault ( ) . writeLog ( IStatus . WARNING , nfe . getMessage ( ) , nfe ) ; 
} 
} 
finally { 
if ( response != null ) response . close ( ) ; 
} 
} 
} 

public class Row { 
public void optimize ( ) { 
final List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; 
Collections . sort ( sorted , new Comparator < BaseVertex > ( ) { 
public int compare ( final BaseVertex v1 , final BaseVertex v2 ) { 
int v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; 
int v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; 
if ( v1OutDegree < v2OutDegree ) return 1 ; 
if ( v1OutDegree > v2OutDegree ) return - 1 ; 
return 0 ; 
} 
} 
) ; 
final LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; 
boolean front = false ; 
for ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; 
vertexIter . hasNext ( ) ; 
) { 
final BaseVertex vertex = vertexIter . next ( ) ; 
if ( front ) optimized . addFirst ( vertex ) ; 
else optimized . addLast ( vertex ) ; 
front = ! front ; 
} 
this . vertices = optimized ; 
} 
} 

public class ExportImageDialog { 
private void initializeControls ( ) { 
if ( originalFile != null ) { 
resourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; 
String fileName = originalFile . getName ( ) ; 
int index = fileName . lastIndexOf ( "." ) ; 
if ( index != - 1 ) fileName = fileName . substring ( 0 , index ) ; 
fileName += "-image.png" ; 
resourceGroup . setResource ( fileName ) ; 
} 
else if ( originalName != null ) resourceGroup . setResource ( originalName ) ; 
setDialogComplete ( validatePage ( ) ) ; 
} 
} 

public class ExportImageDialog { 
private boolean validatePage ( ) { 
if ( ! resourceGroup . areAllValuesValid ( ) ) { 
if ( ! resourceGroup . getResource ( ) . equals ( "" ) ) setErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; 
else setErrorMessage ( null ) ; 
return false ; 
} 
String resourceName = resourceGroup . getResource ( ) ; 
IWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; 
IPath fullPath = resourceGroup . getContainerFullPath ( ) ; 
if ( fullPath != null ) { 
String projectName = fullPath . segment ( 0 ) ; 
IStatus isValidProjectName = workspace . validateName ( projectName , IResource . PROJECT ) ; 
if ( isValidProjectName . isOK ( ) ) { 
IProject project = workspace . getRoot ( ) . getProject ( projectName ) ; 
if ( ! project . isOpen ( ) ) { 
setErrorMessage ( IDEWorkbenchMessages . SaveAsDialog_closedProjectMessage ) ; 
return false ; 
} 
} 
} 
IStatus result = workspace . validateName ( resourceName , IResource . FILE ) ; 
if ( ! result . isOK ( ) ) { 
setErrorMessage ( result . getMessage ( ) ) ; 
return false ; 
} 
setErrorMessage ( null ) ; 
return true ; 
} 
} 

public class Connection { 
public BaseVertex getOpposite ( BaseVertex vertex ) { 
if ( vertex == null || ( ! vertex . equals ( getSource ( ) ) && ! vertex . equals ( getTarget ( ) ) ) ) return null ; 
if ( vertex . equals ( getSource ( ) ) ) return getTarget ( ) ; 
return getSource ( ) ; 
} 
} 

public class YubikeyLoginModule { 
private boolean validate_otps ( List < String > otps , NameCallback nameCb ) throws LoginException { 
boolean validated = false ; 
for ( String otp : otps ) { 
log . trace ( "Checking OTP {}" , otp ) ; 
VerificationResponse ykr ; 
try { 
ykr = this . yc . verify ( otp ) ; 
} 
catch ( YubicoVerificationException e ) { 
log . warn ( "Errors during validation: " , e ) ; 
throw new LoginException ( "Errors during validation: " + e . getMessage ( ) ) ; 
} 
catch ( YubicoValidationFailure e ) { 
log . warn ( "Something went very wrong during authentication: " , e ) ; 
throw new LoginException ( "Something went very wrong during authentication: " + e . getMessage ( ) ) ; 
} 
if ( ykr != null ) { 
log . trace ( "OTP {} verify result : {}" , otp , ykr . getStatus ( ) . toString ( ) ) ; 
if ( ykr . getStatus ( ) == ResponseStatus . OK ) { 
String publicId = YubicoClient . getPublicId ( otp ) ; 
log . info ( "OTP verified successfully (YubiKey id {})" , publicId ) ; 
if ( is_right_user ( nameCb . getName ( ) , publicId ) ) { 
this . principals . add ( new YubikeyPrincipal ( publicId , this . idRealm ) ) ; 
validated = true ; 
} 
} 
else log . debug ( "OTP validation returned {}" , ykr . getStatus ( ) . toString ( ) ) ; 
} 
} 
return validated ; 
} 
} 

public class YubikeyToUserMapImpl { 
private String get_username_for_id ( String publicId , String filename ) throws FileNotFoundException { 
Scanner sc = null ; 
File file = new File ( filename ) ; 
try { 
sc = new Scanner ( file ) ; 
while ( sc . hasNextLine ( ) ) { 
String line = sc . nextLine ( ) ; 
if ( line . startsWith ( "yk." + publicId + ".user" ) ) { 
String ykuser = line . split ( "=" ) [ 1 ] . trim ( ) ; 
return ykuser ; 
} 
} 
} 
finally { 
if ( sc != null ) sc . close ( ) ; 
} 
return null ; 
} 
} 

public class HttpOathOtpLoginModule { 
boolean verify_otp ( String userName , String otp ) { 
try { 
String authString = userName + ":" + otp ; 
String authStringEnc = Base64 . encodeBase64URLSafeString ( authString . getBytes ( ) ) ; 
BufferedReader in = attemptAuthentication ( authStringEnc ) ; 
String inputLine ; 
while ( ( inputLine = in . readLine ( ) ) != null ) if ( inputLine . contains ( expectedOutput ) ) return true ; 
} 
catch ( Exception ex ) { 
log . error ( "Failed verifying OATH OTP :" , ex ) ; 
} 
return false ; 
} 
} 

public class MultiValuePasswordCallback { 
public void clearPassword ( ) { 
for ( char pw [ ] : this . secrets ) { 
for ( int i = 0 ; 
i < pw . length ; 
i ++ ) pw [ i ] = 0 ; 
} 
this . secrets = new ArrayList < char [ ] > ( ) ; 
} 
} 

public class YubicoClient { 
public static String getPublicId ( String otp ) { 
if ( ( otp == null ) || ( otp . length ( ) < OTP_MIN_LEN ) ) throw new IllegalArgumentException ( "The OTP is too short to be valid" ) ; 
Integer len = otp . length ( ) ; 
return otp . substring ( 0 , len - 32 ) . toLowerCase ( ) ; 
} 
} 

public class YubicoClient { 
public static boolean isValidOTPFormat ( String otp ) { 
if ( otp == null ) return false ; 
int len = otp . length ( ) ; 
for ( char c : otp . toCharArray ( ) ) { 
if ( c < 0x20 || c > 0x7E ) return false ; 
} 
return OTP_MIN_LEN <= len && len <= OTP_MAX_LEN ; 
} 
} 

public class OgnlRuntime { 
public static String getUniqueDescriptor ( Object object , boolean fullyQualified ) { 
StringBuffer result = new StringBuffer ( ) ; 
if ( object != null ) { 
if ( object instanceof Proxy ) { 
Class interfaceClass = object . getClass ( ) . getInterfaces ( ) [ 0 ] ; 
result . append ( getClassName ( interfaceClass , fullyQualified ) ) ; 
result . append ( '^' ) ; 
object = Proxy . getInvocationHandler ( object ) ; 
} 
result . append ( getClassName ( object , fullyQualified ) ) ; 
result . append ( '@' ) ; 
result . append ( getPointerString ( object ) ) ; 
} 
else result . append ( NULL_OBJECT_STRING ) ; 
return new String ( result ) ; 
} 
} 

public class OgnlRuntime { 
public static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { 
Method result = null ; 
if ( methods != null ) { 
Class typeClass = target != null ? target . getClass ( ) : null ; 
if ( typeClass == null && source != null && Class . class . isInstance ( source ) ) typeClass = ( Class ) source ; 
Class [ ] argClasses = getArgClasses ( args ) ; 
MatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; 
if ( mm != null ) { 
result = mm . mMethod ; 
Class [ ] mParameterTypes = mm . mParameterTypes ; 
System . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; 
for ( int j = 0 ; 
j < mParameterTypes . length ; 
j ++ ) { 
Class type = mParameterTypes [ j ] ; 
if ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) actualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; 
} 
} 
} 
if ( result == null ) result = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; 
return result ; 
} 
} 

public class OgnlRuntime { 
public static final Object getMethodValue ( OgnlContext context , Object target , String propertyName , boolean checkAccessAndExistence ) throws OgnlException , IllegalAccessException , NoSuchMethodException , IntrospectionException { 
Object result = null ; 
Method m = getGetMethod ( context , ( target == null ) ? null : target . getClass ( ) , propertyName ) ; 
if ( m == null ) m = getReadMethod ( ( target == null ) ? null : target . getClass ( ) , propertyName , null ) ; 
if ( checkAccessAndExistence ) if ( ( m == null ) || ! context . getMemberAccess ( ) . isAccessible ( context , target , m , propertyName ) ) result = NotFound ; 
if ( result == null ) if ( m != null ) try { 
result = invokeMethod ( target , m , NoArguments ) ; 
} 
catch ( InvocationTargetException ex ) { 
throw new OgnlException ( propertyName , ex . getTargetException ( ) ) ; 
} 
else throw new NoSuchMethodException ( propertyName ) ; 
return result ; 
} 
} 

public class OgnlRuntime { 
public static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { 
Map result ; 
if ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) synchronized ( _propertyDescriptorCache ) { 
if ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { 
PropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; 
result = new HashMap ( 101 ) ; 
for ( int i = 0 , icount = pda . length ; 
i < icount ; 
i ++ ) { 
if ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) pda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; 
if ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) pda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; 
result . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; 
} 
findObjectIndexedPropertyDescriptors ( targetClass , result ) ; 
_propertyDescriptorCache . put ( targetClass , result ) ; 
} 
} 
return result ; 
} 
} 

public class OgnlRuntime { 
public static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { 
PropertyDescriptor result = null ; 
PropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; 
for ( int i = 0 , icount = pda . length ; 
( result == null ) && ( i < icount ) ; 
i ++ ) if ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) result = pda [ i ] ; 
return result ; 
} 
} 

public class OgnlParser { 
final public void projection ( ) throws ParseException { 
ASTProject jjtn000 = new ASTProject ( JJTPROJECT ) ; 
boolean jjtc000 = true ; 
jjtree . openNodeScope ( jjtn000 ) ; 
try { 
jj_consume_token ( 54 ) ; 
expression ( ) ; 
jj_consume_token ( 55 ) ; 
} 
catch ( Throwable jjte000 ) { 
if ( jjtc000 ) { 
jjtree . clearNodeScope ( jjtn000 ) ; 
jjtc000 = false ; 
} 
else jjtree . popNode ( ) ; 
if ( jjte000 instanceof RuntimeException ) { 
if ( true ) throw ( RuntimeException ) jjte000 ; 
} 
if ( jjte000 instanceof ParseException ) { 
if ( true ) throw ( ParseException ) jjte000 ; 
} 
{ 
if ( true ) throw ( Error ) jjte000 ; 
} 
} 
finally { 
if ( jjtc000 ) jjtree . closeNodeScope ( jjtn000 , true ) ; 
} 
} 
} 

public class OgnlParser { 
final public void selectAll ( ) throws ParseException { 
ASTSelect jjtn000 = new ASTSelect ( JJTSELECT ) ; 
boolean jjtc000 = true ; 
jjtree . openNodeScope ( jjtn000 ) ; 
try { 
jj_consume_token ( 54 ) ; 
jj_consume_token ( 3 ) ; 
expression ( ) ; 
jj_consume_token ( 55 ) ; 
} 
catch ( Throwable jjte000 ) { 
if ( jjtc000 ) { 
jjtree . clearNodeScope ( jjtn000 ) ; 
jjtc000 = false ; 
} 
else jjtree . popNode ( ) ; 
if ( jjte000 instanceof RuntimeException ) { 
if ( true ) throw ( RuntimeException ) jjte000 ; 
} 
if ( jjte000 instanceof ParseException ) { 
if ( true ) throw ( ParseException ) jjte000 ; 
} 
{ 
if ( true ) throw ( Error ) jjte000 ; 
} 
} 
finally { 
if ( jjtc000 ) jjtree . closeNodeScope ( jjtn000 , true ) ; 
} 
} 
} 

public class OgnlOps { 
public static String stringValue ( Object value , boolean trim ) { 
String result ; 
if ( value == null ) result = OgnlRuntime . NULL_STRING ; 
else { 
result = value . toString ( ) ; 
if ( trim ) result = result . trim ( ) ; 
} 
return result ; 
} 
} 

public class OgnlOps { 
public static int getIntValue ( Object value ) { 
try { 
if ( value == null ) return - 1 ; 
if ( Number . class . isInstance ( value ) ) return ( ( Number ) value ) . intValue ( ) ; 
String str = String . class . isInstance ( value ) ? ( String ) value : value . toString ( ) ; 
return Integer . parseInt ( str ) ; 
} 
catch ( Throwable t ) { 
throw new RuntimeException ( "Error converting " + value + " to integer:" , t ) ; 
} 
} 
} 

public class OgnlOps { 
public static Number newInteger ( int type , long value ) { 
switch ( type ) { 
case BOOL : case CHAR : case INT : return new Integer ( ( int ) value ) ; 
case FLOAT : if ( ( long ) ( float ) value == value ) return new Float ( ( float ) value ) ; 
case DOUBLE : if ( ( long ) ( double ) value == value ) return new Double ( ( double ) value ) ; 
case LONG : return new Long ( value ) ; 
case BYTE : return new Byte ( ( byte ) value ) ; 
case SHORT : return new Short ( ( short ) value ) ; 
default : return BigInteger . valueOf ( value ) ; 
} 
} 
} 

public class SimpleNode { 
protected void flattenTree ( ) { 
boolean shouldFlatten = false ; 
int newSize = 0 ; 
for ( int i = 0 ; 
i < _children . length ; 
++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { 
shouldFlatten = true ; 
newSize += _children [ i ] . jjtGetNumChildren ( ) ; 
} 
else ++ newSize ; 
if ( shouldFlatten ) { 
Node [ ] newChildren = new Node [ newSize ] ; 
int j = 0 ; 
for ( int i = 0 ; 
i < _children . length ; 
++ i ) { 
Node c = _children [ i ] ; 
if ( c . getClass ( ) == getClass ( ) ) for ( int k = 0 ; 
k < c . jjtGetNumChildren ( ) ; 
++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; 
else newChildren [ j ++ ] = c ; 
} 
if ( j != newSize ) throw new Error ( "Assertion error: " + j + " != " + newSize ) ; 
_children = newChildren ; 
} 
} 
} 

public class FileWatchServices { 
public static String getDefaultWatchServiceId ( ) { 
String result = "polling" ; 
String osName = System . getProperty ( "os.name" ) ; 
if ( osName != null ) { 
osName = osName . toLowerCase ( Locale . ENGLISH ) ; 
if ( osName . contains ( "windows" ) || osName . contains ( "linux" ) ) result = isAtLeastJava7 ( ) ? "jdk7" : "jnotify" ; 
else if ( osName . contains ( "mac" ) ) result = "jnotify" ; 
} 
return result ; 
} 
} 

public class AbstractPlay2StartServerMojo { 
protected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { 
long endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; 
boolean started = false ; 
URL connectUrl = new URL ( rootUrl ) ; 
int verifyWaitDelay = 1000 ; 
while ( ! started ) { 
if ( startTimeout > 0 && endTimeMillis - System . currentTimeMillis ( ) < 0L ) { 
if ( spawned ) { 
InternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; 
internalStop . project = project ; 
try { 
internalStop . execute ( ) ; 
} 
catch ( MojoExecutionException e ) { 
} 
catch ( MojoFailureException e ) { 
} 
} 
throw new MojoExecutionException ( String . format ( "Failed to start Play! server in %d ms" , Integer . valueOf ( startTimeout ) ) ) ; 
} 
BuildException runnerException = runner . getException ( ) ; 
if ( runnerException != null ) throw new MojoExecutionException ( "Play! server start exception" , runnerException ) ; 
try { 
URLConnection conn = connectUrl . openConnection ( ) ; 
if ( startTimeout > 0 ) { 
int connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; 
if ( connectTimeOut > 0 ) conn . setConnectTimeout ( connectTimeOut ) ; 
} 
connectUrl . openConnection ( ) . getContent ( ) ; 
started = true ; 
} 
catch ( Exception e ) { 
} 
if ( ! started ) { 
long sleepTime = verifyWaitDelay ; 
if ( startTimeout > 0 ) sleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; 
if ( sleepTime > 0 ) try { 
Thread . sleep ( sleepTime ) ; 
} 
catch ( InterruptedException e ) { 
throw new MojoExecutionException ( "?" , e ) ; 
} 
} 
} 
} 
} 

public class AbstractArchivingMojo { 
protected void checkArchiverForProblems ( Archiver archiver ) { 
for ( ResourceIterator iter = archiver . getResources ( ) ; 
iter . hasNext ( ) ; 
) iter . next ( ) ; 
} 
} 

public class DirectoryChooserFragment { 
private void changeDirectory ( final File dir ) { 
if ( dir == null ) debug ( "Could not change folder: dir was null" ) ; 
else if ( ! dir . isDirectory ( ) ) debug ( "Could not change folder: dir is no directory" ) ; 
else { 
final File [ ] contents = dir . listFiles ( ) ; 
if ( contents != null ) { 
int numDirectories = 0 ; 
for ( final File f : contents ) { 
if ( f . isDirectory ( ) ) numDirectories ++ ; 
} 
mFilesInDir = new File [ numDirectories ] ; 
mFilenames . clear ( ) ; 
for ( int i = 0 , counter = 0 ; 
i < numDirectories ; 
counter ++ ) if ( contents [ counter ] . isDirectory ( ) ) { 
mFilesInDir [ i ] = contents [ counter ] ; 
mFilenames . add ( contents [ counter ] . getName ( ) ) ; 
i ++ ; 
} 
Arrays . sort ( mFilesInDir ) ; 
Collections . sort ( mFilenames ) ; 
mSelectedDir = dir ; 
mTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; 
mListDirectoriesAdapter . notifyDataSetChanged ( ) ; 
mFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; 
mFileObserver . startWatching ( ) ; 
debug ( "Changed directory to %s" , dir . getAbsolutePath ( ) ) ; 
} 
else debug ( "Could not change folder: contents of dir were null" ) ; 
} 
refreshButtonState ( ) ; 
} 
} 

public class DirectoryChooserFragment { 
private FileObserver createFileObserver ( final String path ) { 
return new FileObserver ( path , FileObserver . CREATE | FileObserver . DELETE | FileObserver . MOVED_FROM | FileObserver . MOVED_TO ) { 
@ Override public void onEvent ( final int event , final String path ) { 
debug ( "FileObserver received event %d" , event ) ; 
final Activity activity = getActivity ( ) ; 
if ( activity != null ) activity . runOnUiThread ( new Runnable ( ) { 
@ Override public void run ( ) { 
refreshDirectory ( ) ; 
} 
} 
) ; 
} 
} 
; 
} 
} 

public class DirectoryChooserFragment { 
private void returnSelectedFolder ( ) { 
if ( mSelectedDir != null ) { 
debug ( "Returning %s as result" , mSelectedDir . getAbsolutePath ( ) ) ; 
mListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { 
@ Override public void apply ( final OnFragmentInteractionListener f ) { 
f . onSelectDirectory ( mSelectedDir . getAbsolutePath ( ) ) ; 
} 
} 
) ; 
} 
else mListener . foreach ( new UnitFunction < OnFragmentInteractionListener > ( ) { 
@ Override public void apply ( final OnFragmentInteractionListener f ) { 
f . onCancelChooser ( ) ; 
} 
} 
) ; 
} 
} 

public class DirectoryChooserFragment { 
private int createFolder ( ) { 
if ( mNewDirectoryName != null && mSelectedDir != null && mSelectedDir . canWrite ( ) ) { 
final File newDir = new File ( mSelectedDir , mNewDirectoryName ) ; 
if ( newDir . exists ( ) ) return R . string . create_folder_error_already_exists ; 
else { 
final boolean result = newDir . mkdir ( ) ; 
if ( result ) return R . string . create_folder_success ; 
else return R . string . create_folder_error ; 
} 
} 
else if ( mSelectedDir != null && ! mSelectedDir . canWrite ( ) ) return R . string . create_folder_error_no_write_access ; 
else return R . string . create_folder_error ; 
} 
} 

public class ConverterHtmlToSpanned { 
private void endList ( boolean orderedList ) { 
if ( ! mParagraphStyles . isEmpty ( ) ) { 
AccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; 
ParagraphType type = style . getType ( ) ; 
if ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { 
int indent = style . getRelativeIndent ( ) ; 
if ( indent > 1 ) { 
style . setRelativeIndent ( indent - 1 ) ; 
style . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; 
} 
else mParagraphStyles . pop ( ) ; 
} 
else { 
mParagraphStyles . pop ( ) ; 
endList ( orderedList ) ; 
} 
} 
} 
} 

public class HighlightView { 
void handleMotion ( int edge , float dx , float dy ) { 
Rect r = computeLayout ( ) ; 
if ( edge == GROW_NONE ) return ; 
else if ( edge == MOVE ) moveBy ( dx * ( mCropRect . width ( ) / r . width ( ) ) , dy * ( mCropRect . height ( ) / r . height ( ) ) ) ; 
else { 
if ( ( ( GROW_LEFT_EDGE | GROW_RIGHT_EDGE ) & edge ) == 0 ) dx = 0 ; 
if ( ( ( GROW_TOP_EDGE | GROW_BOTTOM_EDGE ) & edge ) == 0 ) dy = 0 ; 
float xDelta = dx * ( mCropRect . width ( ) / r . width ( ) ) ; 
float yDelta = dy * ( mCropRect . height ( ) / r . height ( ) ) ; 
growBy ( ( ( ( edge & GROW_LEFT_EDGE ) != 0 ) ? - 1 : 1 ) * xDelta , ( ( ( edge & GROW_TOP_EDGE ) != 0 ) ? - 1 : 1 ) * yDelta ) ; 
} 
} 
} 

public class RTEditText { 
private void addSpanWatcher ( ) { 
Spannable spannable = getText ( ) ; 
if ( spannable . getSpans ( 0 , spannable . length ( ) , getClass ( ) ) != null ) spannable . setSpan ( this , 0 , spannable . length ( ) , Spanned . SPAN_INCLUSIVE_INCLUSIVE ) ; 
} 
} 

public class MediaUtils { 
public static String determineOriginalFile ( Context context , Uri uri ) throws IllegalArgumentException { 
String originalFile = null ; 
if ( uri != null ) { 
if ( uri . getScheme ( ) . startsWith ( "content" ) ) originalFile = getPathFromUri ( context , uri ) ; 
if ( uri . toString ( ) . matches ( "https?://\\w+\\.googleusercontent\\.com/.+" ) ) originalFile = uri . toString ( ) ; 
if ( uri . getScheme ( ) . startsWith ( "file" ) ) originalFile = uri . toString ( ) . substring ( 7 ) ; 
if ( isNullOrEmpty ( originalFile ) ) throw new IllegalArgumentException ( "File path was null" ) ; 
} 
else throw new IllegalArgumentException ( "Image Uri was null!" ) ; 
return originalFile ; 
} 
} 

public class ElementType { 
public String namespace ( String name , boolean attribute ) { 
int colon = name . indexOf ( ':' ) ; 
if ( colon == - 1 ) return attribute ? "" : theSchema . getURI ( ) ; 
String prefix = name . substring ( 0 , colon ) ; 
if ( prefix . equals ( "xml" ) ) return "http://www.w3.org/XML/1998/namespace" ; 
else return ( "urn:x-prefix:" + prefix ) . intern ( ) ; 
} 
} 

public class ElementType { 
public String localName ( String name ) { 
int colon = name . indexOf ( ':' ) ; 
if ( colon == - 1 ) return name ; 
else return name . substring ( colon + 1 ) . intern ( ) ; 
} 
} 

public class ElementType { 
public void setAttribute ( AttributesImpl atts , String name , String type , String value ) { 
if ( name . equals ( "xmlns" ) || name . startsWith ( "xmlns:" ) ) return ; 
; 
String namespace = namespace ( name , true ) ; 
String localName = localName ( name ) ; 
int i = atts . getIndex ( name ) ; 
if ( i == - 1 ) { 
name = name . intern ( ) ; 
if ( type == null ) type = "CDATA" ; 
if ( ! type . equals ( "CDATA" ) ) value = normalize ( value ) ; 
atts . addAttribute ( namespace , localName , name , type , value ) ; 
} 
else { 
if ( type == null ) type = atts . getType ( i ) ; 
if ( ! type . equals ( "CDATA" ) ) value = normalize ( value ) ; 
atts . setAttribute ( i , namespace , localName , name , type , value ) ; 
} 
} 
} 

public class ByteArrayOutputStream { 
@ Override public void write ( byte [ ] b , int off , int len ) { 
if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) throw new IndexOutOfBoundsException ( ) ; 
else if ( len == 0 ) return ; 
synchronized ( this ) { 
int newcount = count + len ; 
int remaining = len ; 
int inBufferPos = count - filledBufferSum ; 
while ( remaining > 0 ) { 
int part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; 
System . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; 
remaining -= part ; 
if ( remaining > 0 ) { 
needNewBuffer ( newcount ) ; 
inBufferPos = 0 ; 
} 
} 
count = newcount ; 
} 
} 
} 

public class ByteArrayOutputStream { 
public synchronized void writeTo ( OutputStream out ) throws IOException { 
int remaining = count ; 
for ( byte [ ] buf : buffers ) { 
int c = Math . min ( buf . length , remaining ) ; 
out . write ( buf , 0 , c ) ; 
remaining -= c ; 
if ( remaining == 0 ) break ; 
} 
} 
} 

public class ByteArrayOutputStream { 
public synchronized byte [ ] toByteArray ( ) { 
int remaining = count ; 
if ( remaining == 0 ) return EMPTY_BYTE_ARRAY ; 
byte newbuf [ ] = new byte [ remaining ] ; 
int pos = 0 ; 
for ( byte [ ] buf : buffers ) { 
int c = Math . min ( buf . length , remaining ) ; 
System . arraycopy ( buf , 0 , newbuf , pos , c ) ; 
pos += c ; 
remaining -= c ; 
if ( remaining == 0 ) break ; 
} 
return newbuf ; 
} 
} 

public class HorizontalRTToolbar { 
@ Override public void setFontSize ( int size ) { 
if ( mFontSize != null ) if ( size <= 0 ) { 
mFontSizeAdapter . updateSpinnerTitle ( "" ) ; 
mFontSizeAdapter . setSelectedItem ( 0 ) ; 
mFontSize . setSelection ( 0 ) ; 
} 
else { 
size = Helper . convertSpToPx ( size ) ; 
mFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; 
for ( int pos = 0 ; 
pos < mFontSizeAdapter . getCount ( ) ; 
pos ++ ) { 
FontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; 
if ( size == item . getFontSize ( ) ) { 
mFontSizeAdapter . setSelectedItem ( pos ) ; 
mFontSize . setSelection ( pos ) ; 
break ; 
} 
} 
} 
} 
} 

public class FilenameUtils { 
public static String separatorsToUnix ( String path ) { 
if ( path == null || path . indexOf ( WINDOWS_SEPARATOR ) == - 1 ) return path ; 
return path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; 
} 
} 

public class CropImageView { 
private void ensureVisible ( HighlightView hv ) { 
Rect r = hv . mDrawRect ; 
int panDeltaX1 = Math . max ( 0 , mLeft - r . left ) ; 
int panDeltaX2 = Math . min ( 0 , mRight - r . right ) ; 
int panDeltaY1 = Math . max ( 0 , mTop - r . top ) ; 
int panDeltaY2 = Math . min ( 0 , mBottom - r . bottom ) ; 
int panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2 ; 
int panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2 ; 
if ( panDeltaX != 0 || panDeltaY != 0 ) panBy ( panDeltaX , panDeltaY ) ; 
} 
} 

public class RegexValidator { 
public String validate ( String value ) { 
if ( value == null ) return null ; 
for ( int i = 0 ; 
i < patterns . length ; 
i ++ ) { 
Matcher matcher = patterns [ i ] . matcher ( value ) ; 
if ( matcher . matches ( ) ) { 
int count = matcher . groupCount ( ) ; 
if ( count == 1 ) return matcher . group ( 1 ) ; 
StringBuffer buffer = new StringBuffer ( ) ; 
for ( int j = 0 ; 
j < count ; 
j ++ ) { 
String component = matcher . group ( j + 1 ) ; 
if ( component != null ) buffer . append ( component ) ; 
} 
return buffer . toString ( ) ; 
} 
} 
return null ; 
} 
} 

public class Schema { 
public void attribute ( String elemName , String attrName , String type , String value ) { 
ElementType e = getElementType ( elemName ) ; 
if ( e == null ) throw new Error ( "Attribute " + attrName + " specified for unknown element type " + elemName ) ; 
e . setAttribute ( attrName , type , value ) ; 
} 
} 

public class Schema { 
public void parent ( String name , String parentName ) { 
ElementType child = getElementType ( name ) ; 
ElementType parent = getElementType ( parentName ) ; 
if ( child == null ) throw new Error ( "No child " + name + " for parent " + parentName ) ; 
if ( parent == null ) throw new Error ( "No parent " + parentName + " for child " + name ) ; 
child . setParent ( parent ) ; 
} 
} 

public class CharacterEffect { 
public void applyToSelection ( RTEditText editor , V value ) { 
Selection selection = getSelection ( editor ) ; 
int flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; 
Spannable str = editor . getText ( ) ; 
for ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { 
boolean sameSpan = span . getValue ( ) . equals ( value ) ; 
int spanStart = str . getSpanStart ( span ) ; 
if ( spanStart < selection . start ( ) ) if ( sameSpan ) { 
flags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; 
selection . offset ( selection . start ( ) - spanStart , 0 ) ; 
} 
else str . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; 
int spanEnd = str . getSpanEnd ( span ) ; 
if ( spanEnd > selection . end ( ) ) if ( sameSpan ) selection . offset ( 0 , spanEnd - selection . end ( ) ) ; 
else str . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; 
str . removeSpan ( span ) ; 
} 
if ( value != null ) { 
RTSpan < V > newSpan = newSpan ( value ) ; 
if ( newSpan != null ) str . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; 
} 
} 
} 

public class ConverterTextToHtml { 
private static String replaceAll ( String source , String search , String replace ) { 
if ( USE_REPLACE_ALL ) return source . replaceAll ( search , replace ) ; 
else { 
Pattern p = Pattern . compile ( search ) ; 
Matcher m = p . matcher ( source ) ; 
StringBuffer sb = new StringBuffer ( ) ; 
boolean atLeastOneFound = false ; 
while ( m . find ( ) ) { 
m . appendReplacement ( sb , replace ) ; 
atLeastOneFound = true ; 
} 
if ( atLeastOneFound ) { 
m . appendTail ( sb ) ; 
return sb . toString ( ) ; 
} 
else return source ; 
} 
} 
} 

public class BitmapManager { 
public synchronized boolean canThreadDecoding ( Thread t ) { 
ThreadStatus status = mThreadStatus . get ( t ) ; 
if ( status == null ) return true ; 
return ( status . mState != State . CANCEL ) ; 
} 
} 

public class BitmapManager { 
public Bitmap decodeFileDescriptor ( FileDescriptor fd , BitmapFactory . Options options ) { 
if ( options . mCancel ) return null ; 
Thread thread = Thread . currentThread ( ) ; 
if ( ! canThreadDecoding ( thread ) ) return null ; 
setDecodingOptions ( thread , options ) ; 
Bitmap b = BitmapFactory . decodeFileDescriptor ( fd , null , options ) ; 
removeDecodingOptions ( thread ) ; 
return b ; 
} 
} 

public class FontManager { 
public static SortedSet < RTTypeface > getFonts ( Context context ) { 
Map < String , String > assetFonts = getAssetFonts ( context ) ; 
AssetManager assets = context . getResources ( ) . getAssets ( ) ; 
for ( String fontName : assetFonts . keySet ( ) ) { 
String filePath = assetFonts . get ( fontName ) ; 
if ( ! ALL_FONTS . contains ( fontName ) ) try { 
Typeface typeface = Typeface . createFromAsset ( assets , filePath ) ; 
ALL_FONTS . add ( new RTTypeface ( fontName , typeface ) ) ; 
} 
catch ( Exception e ) { 
} 
} 
Map < String , String > systemFonts = getSystemFonts ( ) ; 
for ( String fontName : systemFonts . keySet ( ) ) { 
String filePath = systemFonts . get ( fontName ) ; 
if ( ! ALL_FONTS . contains ( fontName ) ) try { 
Typeface typeface = Typeface . createFromFile ( filePath ) ; 
ALL_FONTS . add ( new RTTypeface ( fontName , typeface ) ) ; 
} 
catch ( Exception e ) { 
} 
} 
return ALL_FONTS ; 
} 
} 

public class FontManager { 
private static Map < String , String > getAssetFonts ( Context context ) { 
synchronized ( ASSET_FONTS_BY_NAME ) { 
if ( ASSET_FONTS_BY_NAME . isEmpty ( ) ) { 
AssetManager assets = context . getResources ( ) . getAssets ( ) ; 
Collection < String > fontFiles = AssetIndex . getAssetIndex ( context ) ; 
if ( fontFiles == null || fontFiles . isEmpty ( ) ) fontFiles = listFontFiles ( context . getResources ( ) ) ; 
for ( String filePath : fontFiles ) { 
if ( filePath . toLowerCase ( Locale . getDefault ( ) ) . endsWith ( "ttf" ) ) { 
String fontName = TTFAnalyzer . getFontName ( assets , filePath ) ; 
if ( fontName == null ) fontName = getFileName ( filePath ) ; 
ASSET_FONTS_BY_NAME . put ( fontName , filePath ) ; 
} 
} 
} 
return ASSET_FONTS_BY_NAME ; 
} 
} 
} 

public class FontManager { 
private static Map < String , String > getSystemFonts ( ) { 
synchronized ( SYSTEM_FONTS_BY_NAME ) { 
for ( String fontDir : FONT_DIRS ) { 
File dir = new File ( fontDir ) ; 
if ( ! dir . exists ( ) ) continue ; 
File [ ] files = dir . listFiles ( ) ; 
if ( files == null ) continue ; 
for ( File file : files ) { 
String filePath = file . getAbsolutePath ( ) ; 
if ( ! SYSTEM_FONTS_BY_PATH . containsKey ( filePath ) ) { 
String fontName = TTFAnalyzer . getFontName ( file . getAbsolutePath ( ) ) ; 
if ( fontName == null ) fontName = getFileName ( filePath ) ; 
SYSTEM_FONTS_BY_PATH . put ( filePath , fontName ) ; 
SYSTEM_FONTS_BY_NAME . put ( fontName , filePath ) ; 
} 
} 
} 
return SYSTEM_FONTS_BY_NAME ; 
} 
} 
} 

public class Parser { 
private void setup ( ) { 
if ( theSchema == null ) theSchema = new HTMLSchema ( ) ; 
if ( theScanner == null ) theScanner = new HTMLScanner ( ) ; 
if ( theAutoDetector == null ) theAutoDetector = new AutoDetector ( ) { 
public Reader autoDetectingReader ( InputStream i ) { 
return new InputStreamReader ( i ) ; 
} 
} 
; 
theStack = new Element ( theSchema . getElementType ( "<root>" ) , defaultAttributes ) ; 
thePCDATA = new Element ( theSchema . getElementType ( "<pcdata>" ) , defaultAttributes ) ; 
theNewElement = null ; 
theAttributeName = null ; 
thePITarget = null ; 
theSaved = null ; 
theEntity = 0 ; 
virginStack = true ; 
theDoctypeName = theDoctypePublicId = theDoctypeSystemId = null ; 
} 
} 

public class Parser { 
private Reader getReader ( InputSource s ) throws SAXException , IOException { 
Reader r = s . getCharacterStream ( ) ; 
InputStream i = s . getByteStream ( ) ; 
String encoding = s . getEncoding ( ) ; 
String publicid = s . getPublicId ( ) ; 
String systemid = s . getSystemId ( ) ; 
if ( r == null ) { 
if ( i == null ) i = getInputStream ( publicid , systemid ) ; 
if ( encoding == null ) r = theAutoDetector . autoDetectingReader ( i ) ; 
else try { 
r = new InputStreamReader ( i , encoding ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
r = new InputStreamReader ( i ) ; 
} 
} 
return r ; 
} 
} 

public class Parser { 
private String expandEntities ( String src ) { 
int refStart = - 1 ; 
int len = src . length ( ) ; 
char [ ] dst = new char [ len ] ; 
int dstlen = 0 ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) { 
char ch = src . charAt ( i ) ; 
dst [ dstlen ++ ] = ch ; 
if ( ch == '&' && refStart == - 1 ) refStart = dstlen ; 
else if ( refStart == - 1 ) { 
} 
else if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { 
} 
else if ( ch == ';' ) { 
int ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; 
if ( ent > 0xFFFF ) { 
ent -= 0x10000 ; 
dst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; 
dst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; 
dstlen = refStart + 1 ; 
} 
else if ( ent != 0 ) { 
dst [ refStart - 1 ] = ( char ) ent ; 
dstlen = refStart ; 
} 
refStart = - 1 ; 
} 
else refStart = - 1 ; 
} 
return new String ( dst , 0 , dstlen ) ; 
} 
} 

public class Parser { 
private int lookupEntity ( char [ ] buff , int offset , int length ) { 
int result = 0 ; 
if ( length < 1 ) return result ; 
if ( buff [ offset ] == '#' ) { 
if ( length > 1 && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) try { 
return Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; 
} 
catch ( NumberFormatException e ) { 
return 0 ; 
} 
try { 
return Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; 
} 
catch ( NumberFormatException e ) { 
return 0 ; 
} 
} 
return theSchema . getEntity ( new String ( buff , offset , length ) ) ; 
} 
} 

public class Parser { 
private void pop ( ) throws SAXException { 
if ( theStack == null ) return ; 
String name = theStack . name ( ) ; 
String localName = theStack . localName ( ) ; 
String namespace = theStack . namespace ( ) ; 
String prefix = prefixOf ( name ) ; 
if ( ! namespaces ) namespace = localName = "" ; 
theContentHandler . endElement ( namespace , localName , name ) ; 
if ( foreign ( prefix , namespace ) ) theContentHandler . endPrefixMapping ( prefix ) ; 
Attributes atts = theStack . atts ( ) ; 
for ( int i = atts . getLength ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
String attNamespace = atts . getURI ( i ) ; 
String attPrefix = prefixOf ( atts . getQName ( i ) ) ; 
if ( foreign ( attPrefix , attNamespace ) ) theContentHandler . endPrefixMapping ( attPrefix ) ; 
} 
theStack = theStack . next ( ) ; 
} 
} 

public class Parser { 
private static String trimquotes ( String in ) { 
if ( in == null ) return in ; 
int length = in . length ( ) ; 
if ( length == 0 ) return in ; 
char s = in . charAt ( 0 ) ; 
char e = in . charAt ( length - 1 ) ; 
if ( s == e && ( s == '\'' || s == '"' ) ) in = in . substring ( 1 , in . length ( ) - 1 ) ; 
return in ; 
} 
} 

public class Parser { 
private static String [ ] split ( String val ) throws IllegalArgumentException { 
val = val . trim ( ) ; 
if ( val . length ( ) == 0 ) return new String [ 0 ] ; 
else { 
ArrayList < String > l = new ArrayList < String > ( ) ; 
int s = 0 ; 
int e = 0 ; 
boolean sq = false ; 
boolean dq = false ; 
char lastc = 0 ; 
int len = val . length ( ) ; 
for ( e = 0 ; 
e < len ; 
e ++ ) { 
char c = val . charAt ( e ) ; 
if ( ! dq && c == '\'' && lastc != '\\' ) { 
sq = ! sq ; 
if ( s < 0 ) s = e ; 
} 
else if ( ! sq && c == '\"' && lastc != '\\' ) { 
dq = ! dq ; 
if ( s < 0 ) s = e ; 
} 
else if ( ! sq && ! dq ) if ( Character . isWhitespace ( c ) ) { 
if ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; 
s = - 1 ; 
} 
else if ( s < 0 && c != ' ' ) s = e ; 
lastc = c ; 
} 
l . add ( val . substring ( s , e ) ) ; 
return ( String [ ] ) l . toArray ( new String [ 0 ] ) ; 
} 
} 
} 

public class Parser { 
private void rectify ( Element e ) throws SAXException { 
Element sp ; 
while ( true ) { 
for ( sp = theStack ; 
sp != null ; 
sp = sp . next ( ) ) if ( sp . canContain ( e ) ) break ; 
if ( sp != null ) break ; 
ElementType parentType = e . parent ( ) ; 
if ( parentType == null ) break ; 
Element parent = new Element ( parentType , defaultAttributes ) ; 
parent . setNext ( e ) ; 
e = parent ; 
} 
if ( sp == null ) return ; 
while ( theStack != sp ) { 
if ( theStack == null || theStack . next ( ) == null || theStack . next ( ) . next ( ) == null ) break ; 
restartablyPop ( ) ; 
} 
while ( e != null ) { 
Element nexte = e . next ( ) ; 
if ( ! e . name ( ) . equals ( "<pcdata>" ) ) push ( e ) ; 
e = nexte ; 
restart ( e ) ; 
} 
theNewElement = null ; 
} 
} 

public class RTManager { 
public void onSaveInstanceState ( Bundle outState ) { 
outState . putString ( "mToolbarVisibility" , mToolbarVisibility . name ( ) ) ; 
outState . putBoolean ( "mToolbarIsVisible" , mToolbarIsVisible ) ; 
outState . putInt ( "mActiveEditor" , mActiveEditor ) ; 
if ( mLinkSelection != null ) outState . putSerializable ( "mLinkSelection" , mLinkSelection ) ; 
} 
} 

public class ImageViewTouchBase { 
protected float maxZoom ( ) { 
if ( mBitmapDisplayed . getBitmap ( ) == null ) return 1F ; 
float fw = ( float ) mBitmapDisplayed . getWidth ( ) / ( float ) mThisWidth ; 
float fh = ( float ) mBitmapDisplayed . getHeight ( ) / ( float ) mThisHeight ; 
float max = Math . max ( fw , fh ) * 4 ; 
return max ; 
} 
} 

public class Helper { 
public static String encodeUrl ( String url ) { 
Uri uri = Uri . parse ( url ) ; 
try { 
Map < String , List < String > > splitQuery = splitQuery ( uri ) ; 
StringBuilder encodedQuery = new StringBuilder ( ) ; 
for ( String key : splitQuery . keySet ( ) ) { 
for ( String value : splitQuery . get ( key ) ) { 
if ( encodedQuery . length ( ) > 0 ) encodedQuery . append ( "&" ) ; 
encodedQuery . append ( key + "=" + URLEncoder . encode ( value , "UTF-8" ) ) ; 
} 
} 
String queryString = encodedQuery != null && encodedQuery . length ( ) > 0 ? "?" + encodedQuery : "" ; 
URI baseUri = new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , uri . getPath ( ) , null , uri . getFragment ( ) ) ; 
return baseUri + queryString ; 
} 
catch ( UnsupportedEncodingException ignore ) { 
} 
catch ( URISyntaxException ignore ) { 
} 
return uri . toString ( ) ; 
} 
} 

public class HTMLWriter { 
public void setOutput ( Writer writer ) { 
if ( writer == null ) output = new OutputStreamWriter ( System . out ) ; 
else output = writer ; 
} 
} 

public class HTMLWriter { 
private boolean booleanAttribute ( String localName , String qName , String value ) { 
String name = localName ; 
if ( name == null ) { 
int i = qName . indexOf ( ':' ) ; 
if ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; 
} 
if ( ! name . equals ( value ) ) return false ; 
for ( int j = 0 ; 
j < booleans . length ; 
j ++ ) if ( name . equals ( booleans [ j ] ) ) return true ; 
return false ; 
} 
} 

public class HTMLWriter { 
@ SuppressWarnings ( "unchecked" ) private void writeNSDecls ( ) throws SAXException { 
Enumeration < String > prefixes = ( Enumeration < String > ) nsSupport . getDeclaredPrefixes ( ) ; 
while ( prefixes . hasMoreElements ( ) ) { 
String prefix = ( String ) prefixes . nextElement ( ) ; 
String uri = nsSupport . getURI ( prefix ) ; 
if ( uri == null ) uri = "" ; 
write ( ' ' ) ; 
if ( "" . equals ( prefix ) ) write ( "xmlns=\"" ) ; 
else { 
write ( "xmlns:" ) ; 
write ( prefix ) ; 
write ( "=\"" ) ; 
} 
writeEscUTF16 ( uri , 0 , uri . length ( ) , true ) ; 
write ( '\"' ) ; 
} 
} 
} 

public class HTMLWriter { 
private void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { 
String prefix = doPrefix ( uri , qName , isElement ) ; 
if ( prefix != null && ! "" . equals ( prefix ) ) { 
write ( prefix ) ; 
write ( ':' ) ; 
} 
if ( localName != null && ! "" . equals ( localName ) ) write ( localName ) ; 
else { 
int i = qName . indexOf ( ':' ) ; 
write ( qName . substring ( i + 1 , qName . length ( ) ) ) ; 
} 
} 
} 

public class AwsKinesisUtils { 
private static void waitStreamActivation ( AmazonKinesis consumer , String streamName , long streamCreationTimeoutMillis ) { 
DescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; 
DescribeStreamResult describeStreamResult = null ; 
String streamStatus = null ; 
long endTime = System . currentTimeMillis ( ) + streamCreationTimeoutMillis ; 
do { 
try { 
describeStreamResult = consumer . describeStream ( describeStreamRequest ) ; 
streamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; 
if ( ACTIVE_STREAM_STATUS . equals ( streamStatus ) ) break ; 
Thread . sleep ( 100 ) ; 
} 
catch ( ResourceNotFoundException | LimitExceededException ignored ) { 
} 
catch ( InterruptedException e ) { 
Thread . currentThread ( ) . interrupt ( ) ; 
throw new AwsKinesisException ( "Thread interrupted while waiting for stream activation" , args -> args . add ( "streamName" , streamName ) , e ) ; 
} 
} 
while ( System . currentTimeMillis ( ) < endTime ) ; 
if ( describeStreamResult == null || streamStatus == null || ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) throw new AwsKinesisException ( "Stream never went active" , args -> args . add ( "streamName" , streamName ) . add ( "streamCreationTimeoutMillis" , streamCreationTimeoutMillis ) ) ; 
} 
} 

public class IronMigration { 
private static void completeStoreSnapshotWithMissingInstanceSnapshots ( Path targetStoresPath ) { 
String transactionIdRegexAlone = "\"transactionId\"\\s*:\\s*\\d+\\s*," ; 
String transactionIdRegexReplace = "(.*\"transactionId\"\\s*:\\s*)\\d+(\\s*,.*)" ; 
Pattern transactionIdPattern = compile ( transactionIdRegexAlone ) ; 
Set < File > previousSnapshots = new HashSet < > ( ) ; 
Arrays . stream ( targetStoresPath . resolve ( SNAPSHOT_DIRECTORY_NAME ) . toFile ( ) . listFiles ( ) ) . sorted ( ) . forEach ( snapshot -> { 
Set < String > snapshotNames = Arrays . stream ( snapshot . listFiles ( ) ) . map ( File :: getName ) . collect ( toSet ( ) ) ; 
previousSnapshots . stream ( ) . filter ( previousSnapshot -> ! snapshotNames . contains ( previousSnapshot . getName ( ) ) ) . forEach ( previousSnapshot -> { 
try { 
Path targetPath = snapshot . toPath ( ) . resolve ( previousSnapshot . getName ( ) ) ; 
Path sourcePath = previousSnapshot . toPath ( ) ; 
long count = countTransactionId ( transactionIdPattern , sourcePath ) ; 
if ( count != 1L ) throw new StoreException ( "transactionId not found once" , args -> args . add ( "found count" , count ) ) ; 
BigInteger newTransactionId = new BigInteger ( snapshot . getName ( ) ) ; 
replaceTransactionIdValue ( transactionIdRegexReplace , sourcePath , targetPath , newTransactionId . toString ( ) ) ; 
} 
catch ( IOException e ) { 
throw new UncheckedIOException ( e ) ; 
} 
} 
) ; 
previousSnapshots . clear ( ) ; 
previousSnapshots . addAll ( Arrays . stream ( snapshot . listFiles ( ) ) . collect ( toSet ( ) ) ) ; 
} 
) ; 
} 
} 

public class AwsKinesisTransactionStore { 
private boolean waitTheMinimalDurationToExecuteTheNextProvisioningRequest ( ) { 
if ( m_lastGetShardIteratorRequestTime != null ) { 
long delay = m_durationBetweenRequests . get ( ) - ( System . currentTimeMillis ( ) - m_lastGetShardIteratorRequestTime ) ; 
if ( delay > 0 ) try { 
Thread . sleep ( delay ) ; 
} 
catch ( InterruptedException e ) { 
Thread . currentThread ( ) . interrupt ( ) ; 
return false ; 
} 
} 
m_lastGetShardIteratorRequestTime = System . currentTimeMillis ( ) ; 
return true ; 
} 
} 

public class StorePersistence { 
Optional < BigInteger > loadStores ( Function < String , EntityStores > entityStoresByStoreName , BiFunction < SerializableSnapshot , String , SerializableSnapshot > snapshotPostProcessor ) { 
Optional < BigInteger > latestSnapshotTxId ; 
try { 
latestSnapshotTxId = m_snapshotStore . listSnapshots ( ) . stream ( ) . max ( BigInteger :: compareTo ) ; 
} 
catch ( IOException e ) { 
throw new UnrecoverableStoreException ( "Error occurred when recovering from latest snapshot" , e ) ; 
} 
latestSnapshotTxId . ifPresent ( lastTx -> { 
LOG . info ( "Recovering store from snapshot" , args -> args . add ( "transactionId" , lastTx ) ) ; 
var postProcess = new SnapshotPostProcessor ( snapshotPostProcessor ) ; 
try { 
Flowable . fromPublisher ( m_snapshotStore . createSnapshotReader ( lastTx ) ) . blockingForEach ( reader -> { 
String storeName = reader . storeName ( ) ; 
EntityStores entityStores = entityStoresByStoreName . apply ( storeName ) ; 
SerializableSnapshot serializableSnapshot ; 
try ( InputStream is = reader . inputStream ( ) ) { 
serializableSnapshot = m_snapshotSerializer . deserializeSnapshot ( storeName , is ) ; 
} 
if ( serializableSnapshot . getSnapshotModelVersion ( ) != SNAPSHOT_MODEL_VERSION ) throw new UnrecoverableStoreException ( "Snapshot serializable model version is not supported" , args -> args . add ( "version" , serializableSnapshot . getSnapshotModelVersion ( ) ) . add ( "expectedVersion" , SNAPSHOT_MODEL_VERSION ) ) ; 
if ( ! lastTx . equals ( serializableSnapshot . getTransactionId ( ) ) ) throw new UnrecoverableStoreException ( "Snapshot transaction id  mismatch with request transaction id" , args -> args . add ( "snapshotTransactionId" , serializableSnapshot . getTransactionId ( ) ) . add ( "requestTransactionId" , lastTx ) ) ; 
SerializableSnapshot finalSnapshot = postProcess . apply ( storeName , serializableSnapshot ) ; 
finalSnapshot . getEntities ( ) . forEach ( serializableEntityInstances -> { 
String entityName = serializableEntityInstances . getEntityName ( ) ; 
EntityStore < ? > entityStore = entityStores . getEntityStore ( entityName ) ; 
checkArgument ( entityStore != null , "Entity has not be registered in the store" , args -> args . add ( "entityName" , entityName ) ) ; 
entityStore . recover ( serializableEntityInstances ) ; 
} 
) ; 
} 
) ; 
} 
catch ( Exception e ) { 
throw new UnrecoverableStoreException ( "Error occurred when recovering from latest snapshot" , e ) ; 
} 
m_applicationModelVersion = postProcess . getConsistentApplicationModelVersion ( ) ; 
} 
) ; 
if ( ! latestSnapshotTxId . isPresent ( ) ) LOG . info ( "Store has no snapshot, store is empty, creating it's first snapshot" ) ; 
return latestSnapshotTxId ; 
} 
} 

public class DefaultWildcardStreamLocator { 
void triggerWildcardExpander ( final Collection < File > allFiles , final WildcardContext wildcardContext ) throws IOException { 
LOG . debug ( "wildcard resources: {}" , allFiles ) ; 
if ( allFiles . isEmpty ( ) ) { 
final String message = String . format ( "No resource found for wildcard: %s" , wildcardContext . getWildcard ( ) ) ; 
LOG . warn ( message ) ; 
throw new IOException ( message ) ; 
} 
if ( wildcardExpanderHandler != null ) try { 
wildcardExpanderHandler . apply ( allFiles ) ; 
} 
catch ( final IOException e ) { 
throw e ; 
} 
catch ( final Exception e ) { 
LOG . debug ( "wildcard expanding error. Reporting original exception" , e ) ; 
throw new IOException ( "Exception during expanding wildcard: " + e . getMessage ( ) ) ; 
} 
} 
} 

public class StringUtils { 
private static String replace ( final String inString , final String oldPattern , final String newPattern ) { 
if ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) return inString ; 
final StringBuffer sbuf = new StringBuffer ( ) ; 
int pos = 0 ; 
int index = inString . indexOf ( oldPattern ) ; 
final int patLen = oldPattern . length ( ) ; 
while ( index >= 0 ) { 
sbuf . append ( inString . substring ( pos , index ) ) ; 
sbuf . append ( newPattern ) ; 
pos = index + patLen ; 
index = inString . indexOf ( oldPattern , pos ) ; 
} 
sbuf . append ( inString . substring ( pos ) ) ; 
return sbuf . toString ( ) ; 
} 
} 

public class StringUtils { 
private static String deleteAny ( final String inString , final String charsToDelete ) { 
if ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) return inString ; 
final StringBuffer out = new StringBuffer ( ) ; 
for ( int i = 0 ; 
i < inString . length ( ) ; 
i ++ ) { 
final char c = inString . charAt ( i ) ; 
if ( charsToDelete . indexOf ( c ) == - 1 ) out . append ( c ) ; 
} 
return out . toString ( ) ; 
} 
} 

public class ConfigurableWroManagerFactory { 
private void updatePropertiesWithConfiguration ( final Properties props , final String key ) { 
final FilterConfig filterConfig = Context . get ( ) . getFilterConfig ( ) ; 
final String valuesAsString = filterConfig . getInitParameter ( key ) ; 
if ( valuesAsString != null ) props . setProperty ( key , valuesAsString ) ; 
else { 
final String value = getConfigProperties ( ) . getProperty ( key ) ; 
if ( value != null ) props . setProperty ( key , value ) ; 
} 
} 
} 

public class ConfigurableWroManagerFactory { 
private Properties getConfigProperties ( ) { 
if ( configProperties == null ) { 
configProperties = newConfigProperties ( ) ; 
if ( additionalConfigProperties != null ) configProperties . putAll ( additionalConfigProperties ) ; 
} 
return configProperties ; 
} 
} 

public class SmartWroModelFactory { 
private InputStream createAutoDetectedStream ( final String defaultFileName ) throws IOException { 
try { 
Validate . notNull ( wroFile , "Cannot call this method if wroFile is null!" ) ; 
if ( autoDetectWroFile ) { 
final File file = new File ( wroFile . getParentFile ( ) , defaultFileName ) ; 
LOG . debug ( "\tloading autodetected wro file: " + file ) ; 
return new FileInputStream ( file ) ; 
} 
LOG . debug ( "loading wroFile: " + wroFile ) ; 
return new FileInputStream ( wroFile ) ; 
} 
catch ( final FileNotFoundException e ) { 
if ( autoDetectWroFile ) throw e ; 
throw new WroRuntimeException ( "The wroFile doesn't exist. Skip trying with other wro model factories" , e ) ; 
} 
} 
} 

public class WildcardExpanderModelTransformer { 
public Function < Collection < File > , Void > createExpanderHandler ( final Group group , final Resource resource , final String baseNameFolder ) { 
LOG . debug ( "createExpanderHandler using baseNameFolder: {}\n for resource {}" , baseNameFolder , resource ) ; 
return new Function < Collection < File > , Void > ( ) { 
public Void apply ( final Collection < File > files ) { 
if ( baseNameFolder == null ) { 
LOG . warn ( "The resource {} is probably invalid, removing it from the group." , resource ) ; 
group . replace ( resource , new ArrayList < Resource > ( ) ) ; 
} 
else { 
final List < Resource > expandedResources = new ArrayList < Resource > ( ) ; 
LOG . debug ( "baseNameFolder: {}" , baseNameFolder ) ; 
for ( final File file : files ) { 
final String resourcePath = getFullPathNoEndSeparator ( resource ) ; 
LOG . debug ( "\tresourcePath: {}" , resourcePath ) ; 
LOG . debug ( "\tfile path: {}" , file . getPath ( ) ) ; 
final String computedResourceUri = resourcePath + StringUtils . removeStart ( file . getPath ( ) , baseNameFolder ) . replace ( '\\' , '/' ) ; 
final Resource expandedResource = Resource . create ( computedResourceUri , resource . getType ( ) ) ; 
LOG . debug ( "\texpanded resource: {}" , expandedResource ) ; 
expandedResources . add ( expandedResource ) ; 
} 
LOG . debug ( "\treplace resource {}" , resource ) ; 
group . replace ( resource , expandedResources ) ; 
} 
return null ; 
} 
private String getFullPathNoEndSeparator ( final Resource resource1 ) { 
final String result = FilenameUtils . getFullPathNoEndSeparator ( resource1 . getUri ( ) ) ; 
if ( result != null && 1 == result . length ( ) && 0 == FilenameUtils . indexOfLastSeparator ( result ) ) return "" ; 
return result ; 
} 
} 
; 
} 
} 

public class AbstractUriLocatorFactory { 
public final InputStream locate ( final String uri ) throws IOException { 
final UriLocator uriLocator = getInstance ( uri ) ; 
if ( uriLocator == null ) throw new WroRuntimeException ( "No locator is capable of handling uri: " + uri ) ; 
LOG . debug ( "[OK] locating {} using locator: {}" , uri , uriLocator . getClass ( ) . getSimpleName ( ) ) ; 
return new AutoCloseInputStream ( uriLocator . locate ( uri ) ) ; 
} 
} 

public class WroFilter { 
private WroConfiguration createConfiguration ( ) { 
final WroConfiguration configAttribute = ServletContextAttributeHelper . create ( filterConfig ) . getWroConfiguration ( ) ; 
if ( configAttribute != null ) setConfiguration ( configAttribute ) ; 
return getWroConfigurationFactory ( ) . create ( ) ; 
} 
} 

public class WroModel { 
private void identifyDuplicateGroupNames ( final Collection < Group > groups ) { 
LOG . debug ( "identifyDuplicateGroupNames" ) ; 
final List < String > groupNames = new ArrayList < String > ( ) ; 
for ( final Group group : groups ) { 
if ( groupNames . contains ( group . getName ( ) ) ) throw new WroRuntimeException ( "Duplicate group name detected: " + group . getName ( ) ) ; 
groupNames . add ( group . getName ( ) ) ; 
} 
} 
} 

public class WroModel { 
public void merge ( final WroModel importedModel ) { 
Validate . notNull ( importedModel , "imported model cannot be null!" ) ; 
LOG . debug ( "merging importedModel: {}" , importedModel ) ; 
for ( final String groupName : new WroModelInspector ( importedModel ) . getGroupNames ( ) ) { 
if ( new WroModelInspector ( this ) . getGroupNames ( ) . contains ( groupName ) ) throw new WroRuntimeException ( "Duplicate group name detected: " + groupName ) ; 
final Group importedGroup = new WroModelInspector ( importedModel ) . getGroupByName ( groupName ) ; 
addGroup ( importedGroup ) ; 
} 
} 
} 

public class InjectableUriLocatorFactoryDecorator { 
public InputStream locate ( final String uri ) throws IOException { 
final UriLocator locator = getInstance ( uri ) ; 
if ( locator == null ) return getDecoratedObject ( ) . locate ( uri ) ; 
return locator . locate ( uri ) ; 
} 
} 

public class GroupsProcessor { 
private String applyPostProcessors ( final CacheKey cacheKey , final String content ) throws IOException { 
final Collection < ResourcePostProcessor > processors = processorsFactory . getPostProcessors ( ) ; 
LOG . debug ( "appying post processors: {}" , processors ) ; 
if ( processors . isEmpty ( ) ) return content ; 
final Resource resource = Resource . create ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; 
Reader reader = new StringReader ( content . toString ( ) ) ; 
Writer writer = null ; 
for ( final ResourcePostProcessor processor : processors ) { 
final ResourcePreProcessor decoratedProcessor = decorateProcessor ( processor , cacheKey . isMinimize ( ) ) ; 
writer = new StringWriter ( ) ; 
decoratedProcessor . process ( resource , reader , writer ) ; 
reader = new StringReader ( writer . toString ( ) ) ; 
} 
return writer . toString ( ) ; 
} 
} 

public class AbstractProcessorsFilter { 
private void doProcess ( final String requestUri , final Reader reader , final Writer writer ) throws IOException { 
Reader input = reader ; 
Writer output = null ; 
LOG . debug ( "processing resource: {}" , requestUri ) ; 
try { 
final StopWatch stopWatch = new StopWatch ( ) ; 
final Injector injector = InjectorBuilder . create ( new BaseWroManagerFactory ( ) ) . build ( ) ; 
final List < ResourcePreProcessor > processors = getProcessorsList ( ) ; 
if ( processors == null || processors . isEmpty ( ) ) IOUtils . copy ( reader , writer ) ; 
else { 
for ( final ResourcePreProcessor processor : processors ) { 
stopWatch . start ( "Using " + processor . getClass ( ) . getSimpleName ( ) ) ; 
injector . inject ( processor ) ; 
output = new StringWriter ( ) ; 
LOG . debug ( "Using {} processor" , processor ) ; 
processor . process ( createResource ( requestUri ) , input , output ) ; 
input = new StringReader ( output . toString ( ) ) ; 
stopWatch . stop ( ) ; 
} 
LOG . debug ( stopWatch . prettyPrint ( ) ) ; 
if ( output != null ) writer . write ( output . toString ( ) ) ; 
} 
} 
finally { 
reader . close ( ) ; 
writer . close ( ) ; 
} 
} 
} 

public class AbstractWro4jMojo { 
private void persistResourceFingerprints ( final List < String > groupNames ) { 
final WroModelInspector modelInspector = new WroModelInspector ( getModel ( ) ) ; 
for ( final String groupName : groupNames ) { 
final Group group = modelInspector . getGroupByName ( groupName ) ; 
if ( group != null ) for ( final Resource resource : group . getResources ( ) ) { 
getResourceChangeHandler ( ) . remember ( resource ) ; 
} 
} 
} 
} 

public class AbstractWroModelFactory { 
protected InputStream getModelResourceAsStream ( ) throws IOException { 
final ServletContext servletContext = context . getServletContext ( ) ; 
if ( servletContext == null ) throw new WroRuntimeException ( "No servletContext is available. Probably you are running this code outside of the request cycle!" ) ; 
final String resourceLocation = "/WEB-INF/" + getDefaultModelFilename ( ) ; 
final InputStream stream = servletContext . getResourceAsStream ( resourceLocation ) ; 
if ( stream == null ) throw new IOException ( "Invalid resource requested: " + resourceLocation ) ; 
return stream ; 
} 
} 

public class DefaultWroManagerFactory { 
private WroManagerFactory initFactory ( final Properties properties ) { 
WroManagerFactory factory = null ; 
final String wroManagerClassName = properties . getProperty ( ConfigConstants . managerFactoryClassName . name ( ) ) ; 
if ( StringUtils . isEmpty ( wroManagerClassName ) ) factory = newManagerFactory ( ) ; 
else { 
Class < ? > factoryClass = null ; 
try { 
factoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( wroManagerClassName ) ; 
factory = ( WroManagerFactory ) factoryClass . newInstance ( ) ; 
} 
catch ( final Exception e ) { 
throw new WroRuntimeException ( "Exception while loading WroManagerFactory class:" + wroManagerClassName , e ) ; 
} 
} 
if ( factory instanceof ConfigurableWroManagerFactory ) ( ( ConfigurableWroManagerFactory ) factory ) . addConfigProperties ( properties ) ; 
return factory ; 
} 
} 

public class PreProcessorExecutor { 
public String processAndMerge ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { 
notNull ( criteria ) ; 
LOG . debug ( "criteria: {}" , criteria ) ; 
callbackRegistry . onBeforeMerge ( ) ; 
try { 
notNull ( resources ) ; 
LOG . debug ( "process and merge resources: {}" , resources ) ; 
final StringBuffer result = new StringBuffer ( ) ; 
if ( shouldRunInParallel ( resources ) ) result . append ( runInParallel ( resources , criteria ) ) ; 
else for ( final Resource resource : resources ) { 
LOG . debug ( "\tmerging resource: {}" , resource ) ; 
result . append ( applyPreProcessors ( resource , criteria ) ) ; 
} 
return result . toString ( ) ; 
} 
finally { 
callbackRegistry . onAfterMerge ( ) ; 
} 
} 
} 

public class PreProcessorExecutor { 
private String runInParallel ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { 
LOG . debug ( "Running preProcessing in Parallel" ) ; 
final StringBuffer result = new StringBuffer ( ) ; 
final List < Callable < String > > callables = new ArrayList < Callable < String > > ( ) ; 
for ( final Resource resource : resources ) { 
callables . add ( new Callable < String > ( ) { 
public String call ( ) throws Exception { 
LOG . debug ( "Callable started for resource: {} ..." , resource ) ; 
return applyPreProcessors ( resource , criteria ) ; 
} 
} 
) ; 
} 
final ExecutorService exec = getExecutorService ( ) ; 
final List < Future < String > > futures = new ArrayList < Future < String > > ( ) ; 
for ( final Callable < String > callable : callables ) { 
final Callable < String > decoratedCallable = new ContextPropagatingCallable < String > ( callable ) ; 
futures . add ( exec . submit ( decoratedCallable ) ) ; 
} 
for ( final Future < String > future : futures ) { 
try { 
result . append ( future . get ( ) ) ; 
} 
catch ( final Exception e ) { 
final Throwable cause = e . getCause ( ) ; 
if ( cause instanceof WroRuntimeException ) throw ( WroRuntimeException ) cause ; 
else if ( cause instanceof IOException ) throw ( IOException ) cause ; 
else throw new WroRuntimeException ( "Problem during parallel pre processing" , e ) ; 
} 
} 
return result . toString ( ) ; 
} 
} 

public class PreProcessorExecutor { 
private String applyPreProcessors ( final Resource resource , final ProcessingCriteria criteria ) throws IOException { 
final Collection < ResourcePreProcessor > processors = processorsFactory . getPreProcessors ( ) ; 
LOG . debug ( "applying preProcessors: {}" , processors ) ; 
String resourceContent = null ; 
try { 
resourceContent = getResourceContent ( resource ) ; 
} 
catch ( final IOException e ) { 
LOG . debug ( "Invalid resource found: {}" , resource ) ; 
if ( Context . get ( ) . getConfig ( ) . isIgnoreMissingResources ( ) ) return StringUtils . EMPTY ; 
else { 
LOG . error ( "Cannot ignore missing resource:  {}" , resource ) ; 
throw e ; 
} 
} 
if ( ! processors . isEmpty ( ) ) { 
Writer writer = null ; 
for ( final ResourcePreProcessor processor : processors ) { 
final ResourcePreProcessor decoratedProcessor = decoratePreProcessor ( processor , criteria ) ; 
writer = new StringWriter ( ) ; 
final Reader reader = new StringReader ( resourceContent ) ; 
decoratedProcessor . process ( resource , reader , writer ) ; 
resourceContent = writer . toString ( ) ; 
} 
} 
return String . format ( "%s%n" , resourceContent ) ; 
} 
} 

public class ImageUrlRewriter { 
public String rewrite ( final String cssUri , final String imageUrl ) { 
notNull ( cssUri ) ; 
notNull ( imageUrl ) ; 
if ( StringUtils . isEmpty ( imageUrl ) ) return imageUrl ; 
if ( ServletContextUriLocator . isValid ( cssUri ) ) { 
if ( ServletContextUriLocator . isValid ( imageUrl ) ) return prependContextPath ( imageUrl ) ; 
if ( ServletContextUriLocator . isProtectedResource ( cssUri ) ) return context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; 
final String aggregatedPathPrefix = computeAggregationPathPrefix ( context . aggregatedFolderPath ) ; 
LOG . debug ( "computed aggregatedPathPrefix {}" , aggregatedPathPrefix ) ; 
String newImageLocation = computeNewImageLocation ( aggregatedPathPrefix + cssUri , imageUrl ) ; 
if ( newImageLocation . startsWith ( ServletContextUriLocator . PREFIX ) ) newImageLocation = prependContextPath ( newImageLocation ) ; 
LOG . debug ( "newImageLocation: {}" , newImageLocation ) ; 
return newImageLocation ; 
} 
if ( ClasspathUriLocator . isValid ( cssUri ) ) { 
final String proxyUrl = context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; 
final String contextRelativeUrl = prependContextPath ( imageUrl ) ; 
return ( ServletContextUriLocator . isValid ( imageUrl ) ? contextRelativeUrl : proxyUrl ) ; 
} 
if ( UrlUriLocator . isValid ( cssUri ) ) { 
final String computedCssUri = ServletContextUriLocator . isValid ( imageUrl ) ? computeCssUriForExternalServer ( cssUri ) : cssUri ; 
return computeNewImageLocation ( computedCssUri , imageUrl ) ; 
} 
throw new WroRuntimeException ( "Could not replace imageUrl: " + imageUrl + ", contained at location: " + cssUri ) ; 
} 
} 

public class ImageUrlRewriter { 
private String computeNewImageLocation ( final String cssUri , final String imageUrl ) { 
LOG . debug ( "cssUri: {}, imageUrl {}" , cssUri , imageUrl ) ; 
final String cleanImageUrl = cleanImageUrl ( imageUrl ) ; 
int idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; 
if ( idxLastSeparator == - 1 ) { 
if ( ClasspathUriLocator . isValid ( cssUri ) ) { 
idxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; 
if ( idxLastSeparator >= 0 ) idxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; 
} 
if ( idxLastSeparator < 0 ) throw new IllegalStateException ( "Invalid cssUri: " + cssUri + ". Should contain at least one '/' character!" ) ; 
} 
final String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; 
final String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; 
final String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; 
LOG . debug ( "computedImageLocation: {}" , computedImageLocation ) ; 
return computedImageLocation ; 
} 
} 

public class BaseWroManagerFactory { 
public BaseWroManagerFactory addModelTransformer ( final Transformer < WroModel > modelTransformer ) { 
if ( modelTransformers == null ) modelTransformers = new ArrayList < Transformer < WroModel > > ( ) ; 
this . modelTransformers . add ( modelTransformer ) ; 
return this ; 
} 
} 

public class ResourceBundleProcessor { 
public void serveProcessedBundle ( ) throws IOException { 
final WroConfiguration configuration = context . getConfig ( ) ; 
final HttpServletRequest request = context . getRequest ( ) ; 
final HttpServletResponse response = context . getResponse ( ) ; 
OutputStream os = null ; 
try { 
final CacheKey cacheKey = getSafeCacheKey ( request ) ; 
initAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; 
final CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; 
final String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; 
final String etagValue = String . format ( "\"%s\"" , cacheValue . getHash ( ) ) ; 
if ( etagValue != null && etagValue . equals ( ifNoneMatch ) ) { 
LOG . debug ( "ETag hash detected: {}. Sending {} status code" , etagValue , HttpServletResponse . SC_NOT_MODIFIED ) ; 
response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; 
return ; 
} 
response . setContentType ( cacheKey . getType ( ) . getContentType ( ) + "; charset=" + configuration . getEncoding ( ) ) ; 
response . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; 
os = response . getOutputStream ( ) ; 
if ( cacheValue . getRawContent ( ) != null ) if ( isGzipAllowed ( ) ) { 
response . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; 
response . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , "gzip" ) ; 
response . setHeader ( "Vary" , "Accept-Encoding" ) ; 
IOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; 
} 
else { 
response . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; 
IOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; 
} 
} 
finally { 
if ( os != null ) IOUtils . closeQuietly ( os ) ; 
} 
} 
} 

public class CssVariablesProcessor { 
private Map < String , String > extractVariables ( final String variablesBody ) { 
final Map < String , String > map = new HashMap < String , String > ( ) ; 
final Matcher m = PATTERN_VARIABLES_BODY . matcher ( variablesBody ) ; 
LOG . debug ( "parsing variables body" ) ; 
while ( m . find ( ) ) { 
final String key = m . group ( 1 ) ; 
final String value = m . group ( 2 ) ; 
if ( map . containsKey ( key ) ) LOG . warn ( "A duplicate variable name found with name: {} and value: {}." , key , value ) ; 
map . put ( key , value ) ; 
} 
return map ; 
} 
} 

public class CssVariablesProcessor { 
private String replaceVariables ( final String css , final Map < String , String > variables ) { 
final StringBuffer sb = new StringBuffer ( ) ; 
final Matcher m = PATTERN_VARIABLE_HOLDER . matcher ( css ) ; 
while ( m . find ( ) ) { 
final String oldMatch = m . group ( ) ; 
final String variableName = m . group ( 1 ) ; 
final String variableValue = variables . get ( variableName ) ; 
if ( variableValue != null ) { 
final String newReplacement = oldMatch . replace ( oldMatch , variableValue ) ; 
m . appendReplacement ( sb , newReplacement . trim ( ) ) ; 
} 
else LOG . warn ( "No variable with name " + variableName + " was found!" ) ; 
} 
m . appendTail ( sb ) ; 
return sb . toString ( ) ; 
} 
} 

public class GzipFilter { 
private void doGzipResponse ( final HttpServletRequest req , final HttpServletResponse response , final FilterChain chain ) throws IOException , ServletException { 
LOG . debug ( "Applying gzip on resource: " + req . getRequestURI ( ) ) ; 
response . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , "gzip" ) ; 
final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
final CountingOutputStream countingStream = new CountingOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( baos ) ) ) ; 
final HttpServletResponseWrapper wrappedResponse = new RedirectedStreamServletResponseWrapper ( countingStream , response ) ; 
chain . doFilter ( req , wrappedResponse ) ; 
countingStream . close ( ) ; 
response . setContentLength ( countingStream . getCount ( ) ) ; 
if ( countingStream . getCount ( ) > 0 ) IOUtils . write ( baos . toByteArray ( ) , response . getOutputStream ( ) ) ; 
} 
} 

public class ResourceChangeHandler { 
public void remember ( final Resource resource ) { 
final WroManager manager = getManagerFactory ( ) . create ( ) ; 
final HashStrategy hashStrategy = manager . getHashStrategy ( ) ; 
final UriLocatorFactory locatorFactory = manager . getUriLocatorFactory ( ) ; 
if ( rememberedSet . contains ( resource . getUri ( ) ) ) getLog ( ) . debug ( "Resource with uri '" + resource . getUri ( ) + "' has already been updated in this run." ) ; 
else try { 
final String fingerprint = hashStrategy . getHash ( locatorFactory . locate ( resource . getUri ( ) ) ) ; 
getBuildContextHolder ( ) . setValue ( resource . getUri ( ) , fingerprint ) ; 
rememberedSet . add ( resource . getUri ( ) ) ; 
getLog ( ) . debug ( "Persist fingerprint for resource '" + resource . getUri ( ) + "' : " + fingerprint ) ; 
if ( resource . getType ( ) == ResourceType . CSS ) { 
final Reader reader = new InputStreamReader ( locatorFactory . locate ( resource . getUri ( ) ) ) ; 
getLog ( ) . debug ( "Check @import directive from " + resource ) ; 
persistFingerprintsForCssImports ( resource , reader ) ; 
} 
} 
catch ( final IOException e ) { 
getLog ( ) . debug ( "could not check fingerprint of resource: " + resource ) ; 
} 
} 
} 

public class ResourceLintReport { 
private List < T > filter ( final Collection < T > collection ) { 
final List < T > nullFreeList = new ArrayList < T > ( ) ; 
if ( collection != null ) for ( final T item : collection ) { 
if ( item != null ) nullFreeList . add ( item ) ; 
} 
return nullFreeList ; 
} 
} 

public class AbstractCssImportPreProcessor { 
private List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) throws IOException { 
final List < Resource > imports = new ArrayList < Resource > ( ) ; 
final String css = cssContent ; 
final List < String > foundImports = findImports ( css ) ; 
for ( final String importUrl : foundImports ) { 
final Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; 
if ( imports . contains ( importedResource ) ) LOG . debug ( "[WARN] Duplicate imported resource: {}" , importedResource ) ; 
else { 
imports . add ( importedResource ) ; 
onImportDetected ( importedResource . getUri ( ) ) ; 
} 
} 
return imports ; 
} 
} 

public class AbstractConfigurableMultipleStrategy { 
public static String createItemsAsString ( final String ... items ) { 
final StringBuffer sb = new StringBuffer ( ) ; 
for ( int i = 0 ; 
i < items . length ; 
i ++ ) { 
sb . append ( items [ i ] ) ; 
if ( i < items . length - 1 ) sb . append ( TOKEN_DELIMITER ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class RhinoScriptBuilder { 
public Object evaluate ( final String script , final String sourceName ) { 
notNull ( script ) ; 
try { 
return getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; 
} 
catch ( final RhinoException e ) { 
final String message = RhinoUtils . createExceptionMessage ( e ) ; 
LOG . error ( "JavaScriptException occured: {}" , message ) ; 
throw new WroRuntimeException ( message ) ; 
} 
finally { 
if ( Context . getCurrentContext ( ) != null ) Context . exit ( ) ; 
} 
} 
} 

public class Wro4jMojo { 
private File computeDestinationFolder ( final ResourceType resourceType ) throws MojoExecutionException { 
File folder = destinationFolder ; 
if ( resourceType == ResourceType . JS ) if ( jsDestinationFolder != null ) folder = jsDestinationFolder ; 
if ( resourceType == ResourceType . CSS ) if ( cssDestinationFolder != null ) folder = cssDestinationFolder ; 
getLog ( ) . info ( "folder: " + folder ) ; 
if ( folder == null ) throw new MojoExecutionException ( "Couldn't compute destination folder for resourceType: " + resourceType + ". That means that you didn't define one of the following parameters: " + "destinationFolder, cssDestinationFolder, jsDestinationFolder" ) ; 
if ( ! folder . exists ( ) ) folder . mkdirs ( ) ; 
return folder ; 
} 
} 

public class Wro4jMojo { 
private void processGroup ( final String group , final File parentFoder ) throws Exception { 
ByteArrayOutputStream resultOutputStream = null ; 
InputStream resultInputStream = null ; 
try { 
getLog ( ) . info ( "processing group: " + group ) ; 
final HttpServletRequest request = Mockito . mock ( HttpServletRequest . class ) ; 
Mockito . when ( request . getContextPath ( ) ) . thenReturn ( normalizeContextPath ( contextPath ) ) ; 
Mockito . when ( request . getRequestURI ( ) ) . thenReturn ( group ) ; 
final HttpServletResponse response = Mockito . mock ( HttpServletResponse . class ) ; 
resultOutputStream = new ByteArrayOutputStream ( ) ; 
Mockito . when ( response . getOutputStream ( ) ) . thenReturn ( new DelegatingServletOutputStream ( resultOutputStream ) ) ; 
final WroConfiguration config = Context . get ( ) . getConfig ( ) ; 
config . setIgnoreEmptyGroup ( true ) ; 
Context . set ( Context . webContext ( request , response , Mockito . mock ( FilterConfig . class ) ) , config ) ; 
Context . get ( ) . setAggregatedFolderPath ( getAggregatedPathResolver ( ) . resolve ( ) ) ; 
getManagerFactory ( ) . create ( ) . process ( ) ; 
resultInputStream = new UnclosableBufferedInputStream ( resultOutputStream . toByteArray ( ) ) ; 
final File destinationFile = new File ( parentFoder , rename ( group , resultInputStream ) ) ; 
final File parentFolder = destinationFile . getParentFile ( ) ; 
if ( ! parentFolder . exists ( ) ) parentFolder . mkdirs ( ) ; 
destinationFile . createNewFile ( ) ; 
resultInputStream . reset ( ) ; 
getLog ( ) . debug ( "Created file: " + destinationFile . getName ( ) ) ; 
final OutputStream fos = new FileOutputStream ( destinationFile ) ; 
IOUtils . copy ( resultInputStream , fos ) ; 
fos . close ( ) ; 
if ( destinationFile . length ( ) == 0 ) { 
getLog ( ) . debug ( "No content found for group: " + group ) ; 
destinationFile . delete ( ) ; 
} 
else { 
getLog ( ) . info ( "file size: " + destinationFile . getName ( ) + " -> " + destinationFile . length ( ) + " bytes" ) ; 
getLog ( ) . info ( destinationFile . getAbsolutePath ( ) + " (" + destinationFile . length ( ) + " bytes" + ")" ) ; 
} 
} 
finally { 
if ( getBuildContext ( ) != null ) getBuildContext ( ) . refresh ( parentFoder ) ; 
if ( resultOutputStream != null ) resultOutputStream . close ( ) ; 
if ( resultInputStream != null ) resultInputStream . close ( ) ; 
} 
} 
} 

public class JarWildcardStreamLocator { 
@ Override public InputStream locateStream ( final String uri , final File folder ) throws IOException { 
notNull ( folder ) ; 
final File jarPath = getJarFile ( folder ) ; 
if ( isSupported ( jarPath ) ) return locateStreamFromJar ( uri , jarPath ) ; 
return super . locateStream ( uri , folder ) ; 
} 
} 

public class RubySassEngine { 
public void addRequire ( final String require ) { 
if ( require != null && require . trim ( ) . length ( ) > 0 ) requires . add ( require . trim ( ) ) ; 
} 
} 

public class RubySassEngine { 
public String process ( final String content ) { 
if ( isEmpty ( content ) ) return StringUtils . EMPTY ; 
try { 
synchronized ( this ) { 
return engineInitializer . get ( ) . eval ( buildUpdateScript ( content ) ) . toString ( ) ; 
} 
} 
catch ( final ScriptException e ) { 
throw new WroRuntimeException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class Selector { 
private Property [ ] parseProperties ( final String contents ) { 
final String [ ] parts = contents . split ( ";" ) ; 
final List < Property > resultsAsList = new ArrayList < Property > ( ) ; 
for ( String part : parts ) { 
try { 
if ( ! StringUtils . isEmpty ( part . trim ( ) ) ) resultsAsList . add ( new Property ( part ) ) ; 
} 
catch ( final Exception e ) { 
LOG . warn ( e . getMessage ( ) , e ) ; 
} 
} 
return resultsAsList . toArray ( new Property [ resultsAsList . size ( ) ] ) ; 
} 
} 

public class StopWatch { 
public TaskInfo [ ] getTaskInfo ( ) { 
if ( ! this . keepTaskList ) throw new UnsupportedOperationException ( "Task info is not being kept!" ) ; 
return ( TaskInfo [ ] ) this . taskList . toArray ( new TaskInfo [ this . taskList . size ( ) ] ) ; 
} 
} 

public class WroUtil { 
public static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { 
if ( StringUtils . isEmpty ( location ) ) throw new IllegalArgumentException ( "Location cannot be empty string!" ) ; 
final String contextPath = request . getContextPath ( ) ; 
if ( contextPath != null ) if ( startsWithIgnoreCase ( location , contextPath ) ) return location . substring ( contextPath . length ( ) ) ; 
else return location ; 
final String noSlash = location . substring ( 1 ) ; 
final int nextSlash = noSlash . indexOf ( '/' ) ; 
if ( nextSlash == - 1 ) return "" ; 
return noSlash . substring ( nextSlash ) ; 
} 
} 

public class Context { 
public static void unset ( ) { 
final String correlationId = CORRELATION_ID . get ( ) ; 
if ( correlationId != null ) CONTEXT_MAP . remove ( correlationId ) ; 
CORRELATION_ID . remove ( ) ; 
} 
} 

public class Group { 
public final boolean hasResourcesOfType ( final ResourceType resourceType ) { 
notNull ( resourceType , "ResourceType cannot be null!" ) ; 
for ( final Resource resource : resources ) { 
if ( resourceType . equals ( resource . getType ( ) ) ) return true ; 
} 
return false ; 
} 
} 

public class XmlModelFactory { 
private Collection < Resource > parseGroup ( final Element element ) { 
final String name = element . getAttribute ( ATTR_GROUP_NAME ) ; 
final String isAbstractAsString = element . getAttribute ( ATTR_GROUP_ABSTRACT ) ; 
final boolean isAbstractGroup = StringUtils . isNotEmpty ( isAbstractAsString ) && Boolean . valueOf ( isAbstractAsString ) ; 
if ( groupsInProcess . contains ( name ) ) throw new RecursiveGroupDefinitionException ( "Infinite Recursion detected for the group: " + name + ". Recursion path: " + groupsInProcess ) ; 
LOG . debug ( "\tadding group: {}" , name ) ; 
groupsInProcess . add ( name ) ; 
final Group parsedGroup = new WroModelInspector ( model ) . getGroupByName ( name ) ; 
if ( parsedGroup != null ) { 
groupsInProcess . remove ( name ) ; 
return parsedGroup . getResources ( ) ; 
} 
final Group group = createGroup ( element ) ; 
groupsInProcess . remove ( name ) ; 
if ( ! isAbstractGroup ) model . addGroup ( group ) ; 
return group . getResources ( ) ; 
} 
} 

public class XmlModelFactory { 
private void parseResource ( final Element resourceElement , final Collection < Resource > resources ) { 
final String tagName = resourceElement . getTagName ( ) ; 
final String uri = resourceElement . getTextContent ( ) ; 
if ( TAG_GROUP_REF . equals ( tagName ) ) resources . addAll ( getResourcesForGroup ( uri ) ) ; 
if ( getResourceType ( resourceElement ) != null ) { 
final Resource resource = createResource ( resourceElement ) ; 
LOG . debug ( "\t\tadding resource: {}" , resource ) ; 
resources . add ( resource ) ; 
} 
} 
} 

public class XmlModelFactory { 
private Collection < Resource > getResourcesForGroup ( final String groupName ) { 
final WroModelInspector modelInspector = new WroModelInspector ( model ) ; 
final Group foundGroup = modelInspector . getGroupByName ( groupName ) ; 
if ( foundGroup == null ) { 
final Element groupElement = allGroupElements . get ( groupName ) ; 
if ( groupElement == null ) throw new WroRuntimeException ( "Invalid group-ref: " + groupName ) ; 
return parseGroup ( groupElement ) ; 
} 
return foundGroup . getResources ( ) ; 
} 
} 

public class ElkTimer { 
public void log ( Logger logger , LogLevel priority ) { 
if ( LoggerWrap . isEnabledFor ( logger , priority ) ) { 
String timerLabel ; 
if ( threadId != 0 ) timerLabel = name + " (thread " + threadId + ")" ; 
else if ( threadCount > 1 ) timerLabel = name + " (over " + threadCount + " threads)" ; 
else timerLabel = name ; 
if ( todoFlags == RECORD_NONE ) LoggerWrap . log ( logger , priority , "Timer " + timerLabel + " recorded " + measurements + " run(s), no times taken" ) ; 
else { 
String labels = "" ; 
String values = "" ; 
String separator ; 
if ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { 
labels += "CPU" ; 
values += totalCpuTime / 1000000 ; 
separator = "/" ; 
} 
else separator = "" ; 
if ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { 
labels += separator + "Wall" ; 
values += separator + totalWallTime / 1000000 ; 
} 
if ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { 
labels += "/CPU avg" ; 
values += "/" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; 
} 
if ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { 
labels += "/Wall avg" ; 
values += "/" + ( float ) ( totalWallTime ) / measurements / 1000000 ; 
} 
if ( threadCount > 1 ) { 
if ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { 
labels += "/CPU per thread" ; 
values += "/" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; 
} 
if ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { 
labels += "/Wall per thread" ; 
values += "/" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; 
} 
} 
LoggerWrap . log ( logger , priority , "Time for " + timerLabel + " for " + measurements + " run(s) " + labels + " (ms): " + values ) ; 
} 
if ( isRunning ) logger . warn ( "Timer " + timerLabel + " logged while it was still running" ) ; 
} 
} 
} 

public class ElkTimer { 
public static long stopNamedTimer ( String timerName , int todoFlags , long threadId ) { 
ElkTimer key = new ElkTimer ( timerName , todoFlags , threadId ) ; 
if ( registeredTimers . containsKey ( key ) ) return registeredTimers . get ( key ) . stop ( ) ; 
else return - 1 ; 
} 
} 

public class ElkTimer { 
public static ElkTimer getNamedTimer ( String timerName , int todoFlags , long threadId ) { 
ElkTimer key = new ElkTimer ( timerName , todoFlags , threadId ) ; 
ElkTimer previous = registeredTimers . putIfAbsent ( key , key ) ; 
if ( previous != null ) return previous ; 
return key ; 
} 
} 

public class ClassExpressionSaturationFactory { 
private void wakeUpWorkers ( ) { 
if ( ! workersWaiting_ ) return ; 
stopWorkersLock_ . lock ( ) ; 
try { 
workersWaiting_ = false ; 
thereAreContextsToProcess_ . signalAll ( ) ; 
} 
finally { 
stopWorkersLock_ . unlock ( ) ; 
} 
} 
} 

public class ClassExpressionSaturationFactory { 
private void updateProcessedCounters ( int snapshotFinishedWorkers ) { 
if ( isInterrupted ( ) ) { 
wakeUpWorkers ( ) ; 
return ; 
} 
if ( countStartedWorkers_ . get ( ) > snapshotFinishedWorkers ) return ; 
int snapshotCountJobsSubmitted = countJobsSubmittedUpper_ . get ( ) ; 
int snapshotCountContextNonSaturated = saturationState_ . getContextMarkNonSaturatedCount ( ) ; 
int snapshotCountStartedWorkers = countStartedWorkers_ . get ( ) ; 
if ( snapshotCountStartedWorkers > snapshotFinishedWorkers ) return ; 
if ( updateIfSmaller ( countContextsSaturatedLower_ , snapshotCountContextNonSaturated ) ) wakeUpWorkers ( ) ; 
updateIfSmaller ( countJobsProcessedLower_ , snapshotCountJobsSubmitted ) ; 
} 
} 

public class ClassExpressionSaturationFactory { 
private void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { 
int snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; 
for ( ; 
; 
) { 
int snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; 
saturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; 
if ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) return ; 
int updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; 
if ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) break ; 
snapshotJobsProcessed = updatedSnapshotJobsProcessed ; 
} 
for ( ; 
; 
) { 
int snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; 
if ( snapshotJobsFinished >= snapshotJobsProcessed ) break ; 
if ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) continue ; 
J nextJob = jobsInProgress_ . poll ( ) ; 
IndexedContextRoot root = nextJob . getInput ( ) ; 
Context rootSaturation = saturationState_ . getContext ( root ) ; 
if ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) LOGGER_ . error ( "{}: context for a finished job not saturated!" , rootSaturation ) ; 
nextJob . setOutput ( rootSaturation ) ; 
LOGGER_ . trace ( "{}: saturation finished" , root ) ; 
localStatistics . jobsProcessedNo ++ ; 
listener_ . notifyFinished ( nextJob ) ; 
} 
} 
} 

public class DummyRuleVisitor { 
protected < P > O defaultVisit ( Rule < P > rule , P premise , ContextPremises premises , ClassInferenceProducer producer ) { 
if ( LOGGER_ . isTraceEnabled ( ) ) LOGGER_ . trace ( "ignore {} by {} in {}" , premise , rule , premises ) ; 
return null ; 
} 
} 

public class ObjectPropertyTaxonomyComputationFactory { 
private void instertIntoTaxonomy ( final IndexedObjectProperty property ) { 
final Map < IndexedObjectProperty , ElkObjectProperty > equivalent = collectEquivalent ( property ) ; 
if ( equivalent == null ) return ; 
final Map < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > subEquivalent = new ArrayHashMap < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > ( ) ; 
final Set < IndexedObjectProperty > indirect = new ArrayHashSet < IndexedObjectProperty > ( ) ; 
for ( final IndexedObjectProperty subProperty : property . getSaturated ( ) . getSubProperties ( ) ) { 
if ( equivalent . containsKey ( subProperty ) ) continue ; 
final Map < IndexedObjectProperty , ElkObjectProperty > subEq = collectEquivalent ( subProperty ) ; 
subEquivalent . put ( subProperty , subEq . values ( ) ) ; 
for ( final IndexedObjectProperty subSubProperty : subProperty . getSaturated ( ) . getSubProperties ( ) ) { 
if ( ! subEq . containsKey ( subSubProperty ) ) indirect . add ( subSubProperty ) ; 
} 
} 
if ( subEquivalent . isEmpty ( ) && ( indexedBottomProperty_ == null || ! equivalent . containsKey ( indexedBottomProperty_ ) ) ) { 
outputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , defaultDirectSubproperties_ ) ) ; 
return ; 
} 
final Collection < Collection < ? extends ElkObjectProperty > > direct = Operations . map ( subEquivalent . entrySet ( ) , new Operations . Transformation < Map . Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > , Collection < ? extends ElkObjectProperty > > ( ) { 
@ Override public Collection < ? extends ElkObjectProperty > transform ( final Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > element ) { 
if ( indirect . contains ( element . getKey ( ) ) ) return null ; 
else return element . getValue ( ) ; 
} 
} 
) ; 
outputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , direct ) ) ; 
} 
} 

public class AbstractReasonerState { 
public synchronized void ensureLoading ( ) throws ElkException { 
if ( ! isLoadingFinished ( ) ) { 
if ( isIncrementalMode ( ) ) if ( ! stageManager . incrementalAdditionStage . isCompleted ( ) ) complete ( stageManager . incrementalAdditionStage ) ; 
else if ( ! stageManager . contextInitializationStage . isCompleted ( ) ) complete ( stageManager . contextInitializationStage ) ; 
LOGGER_ . trace ( "Reset axiom loading" ) ; 
stageManager . inputLoadingStage . invalidateRecursive ( ) ; 
stageManager . contextInitializationStage . invalidateRecursive ( ) ; 
stageManager . incrementalCompletionStage . invalidateRecursive ( ) ; 
} 
complete ( stageManager . inputLoadingStage ) ; 
} 
} 

public class AbstractReasonerState { 
private void restoreSaturation ( ) throws ElkException { 
ensureLoading ( ) ; 
final boolean changed ; 
if ( isIncrementalMode ( ) ) { 
changed = ! stageManager . incrementalTaxonomyCleaningStage . isCompleted ( ) ; 
complete ( stageManager . incrementalTaxonomyCleaningStage ) ; 
} 
else { 
changed = ! stageManager . contextInitializationStage . isCompleted ( ) ; 
complete ( stageManager . contextInitializationStage ) ; 
} 
if ( changed ) stageManager . consistencyCheckingStage . invalidateRecursive ( ) ; 
} 
} 

public class AbstractReasonerState { 
public synchronized boolean isInconsistent ( ) throws ElkException { 
restoreConsistencyCheck ( ) ; 
if ( ! consistencyCheckingState . isInconsistent ( ) ) incompleteness_ . log ( incompleteness_ . getIncompletenessMonitorForClassification ( ) ) ; 
return consistencyCheckingState . isInconsistent ( ) ; 
} 
} 

public class AbstractReasonerState { 
protected Taxonomy < ElkClass > restoreTaxonomy ( ) throws ElkInconsistentOntologyException , ElkException { 
ruleAndConclusionStats . reset ( ) ; 
restoreConsistencyCheck ( ) ; 
if ( consistencyCheckingState . isInconsistent ( ) ) throw new ElkInconsistentOntologyException ( ) ; 
complete ( stageManager . classTaxonomyComputationStage ) ; 
return classTaxonomyState . getTaxonomy ( ) ; 
} 
} 

public class AbstractReasonerState { 
protected InstanceTaxonomy < ElkClass , ElkNamedIndividual > restoreInstanceTaxonomy ( ) throws ElkInconsistentOntologyException , ElkException { 
ruleAndConclusionStats . reset ( ) ; 
restoreConsistencyCheck ( ) ; 
if ( consistencyCheckingState . isInconsistent ( ) ) throw new ElkInconsistentOntologyException ( ) ; 
complete ( stageManager . instanceTaxonomyComputationStage ) ; 
return instanceTaxonomyState . getTaxonomy ( ) ; 
} 
} 

public class ConsistencyCheckingState { 
public Proof < ? extends EntailmentInference > getEvidence ( final boolean atMostOne ) { 
return new Proof < EntailmentInference > ( ) { 
@ SuppressWarnings ( "unchecked" ) @ Override public Collection < OntologyInconsistencyEntailmentInference > getInferences ( final Object conclusion ) { 
if ( ! OntologyInconsistencyImpl . INSTANCE . equals ( conclusion ) ) return Collections . emptyList ( ) ; 
final Collection < ? extends IndexedIndividual > inconsistentIndividuals = getInconsistentIndividuals ( ) ; 
Iterable < OntologyInconsistencyEntailmentInference > result = Operations . map ( inconsistentIndividuals , INDIVIDUAL_TO_ENTAILMENT_INFERENCE ) ; 
int size = inconsistentIndividuals . size ( ) ; 
if ( isTopObjectPropertyInBottom_ ) { 
result = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new TopObjectPropertyInBottomEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getSubPropertyChain ( topProperty_ , bottomProperty_ ) ) ) , result ) ; 
size ++ ; 
} 
if ( isOwlThingInconsistent_ ) { 
result = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new OwlThingInconsistencyEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getContradiction ( owlThing_ ) ) ) , result ) ; 
size ++ ; 
} 
if ( atMostOne ) { 
final Iterator < OntologyInconsistencyEntailmentInference > iter = result . iterator ( ) ; 
if ( ! iter . hasNext ( ) ) return Collections . emptyList ( ) ; 
return Collections . singleton ( iter . next ( ) ) ; 
} 
return Operations . getCollection ( result , size ) ; 
} 
} 
; 
} 
} 

public class AbstractReasonerStage { 
public void invalidateRecursive ( ) { 
Queue < AbstractReasonerStage > toInvalidate_ = new LinkedList < AbstractReasonerStage > ( ) ; 
toInvalidate_ . add ( this ) ; 
AbstractReasonerStage next ; 
while ( ( next = toInvalidate_ . poll ( ) ) != null ) if ( next . invalidate ( ) ) for ( AbstractReasonerStage postStage : next . postStages_ ) { 
toInvalidate_ . add ( postStage ) ; 
} 
} 
} 

public class InstanceTaxonomyState { 
Collection < IndexedIndividual > getToAdd ( ) { 
if ( taxonomy_ == null ) return toAdd_ ; 
final int size = pruneToAdd ( ) ; 
return Operations . getCollection ( toAdd_ , size ) ; 
} 
} 

public class OreTaxonomyPrinter { 
protected static void printDeclarations ( Taxonomy < ElkClass > classTaxonomy , ElkObject . Factory objectFactory , Appendable writer ) throws IOException { 
List < ElkClass > classes = new ArrayList < ElkClass > ( classTaxonomy . getNodes ( ) . size ( ) * 2 ) ; 
for ( TaxonomyNode < ElkClass > classNode : classTaxonomy . getNodes ( ) ) { 
for ( ElkClass clazz : classNode ) { 
if ( ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_THING ) && ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_NOTHING ) ) classes . add ( clazz ) ; 
} 
} 
Collections . sort ( classes , CLASS_COMPARATOR ) ; 
for ( ElkClass clazz : classes ) { 
ElkDeclarationAxiom decl = objectFactory . getDeclarationAxiom ( clazz ) ; 
OwlFunctionalStylePrinter . append ( writer , decl , true ) ; 
writer . append ( '\n' ) ; 
} 
} 
} 

public class HashGenerator { 
public static int combineMultisetHash ( boolean finalize , int ... hashes ) { 
int hash = 0 ; 
for ( int h : hashes ) { 
hash = hash + h ; 
} 
if ( finalize ) hash = combineListHash ( hash ) ; 
return hash ; 
} 
} 

public class IncompletenessManager { 
public IncompletenessMonitor getReasonerIncompletenessMonitor ( final IncompletenessMonitor ... additionalMonitors ) { 
final List < IncompletenessMonitor > monitors = new ArrayList < IncompletenessMonitor > ( additionalMonitors . length + 1 ) ; 
monitors . add ( getIncompletenessDueToStatedAxiomsMonitor ( ) ) ; 
monitors . addAll ( Arrays . asList ( additionalMonitors ) ) ; 
return new DelegatingIncompletenessMonitor ( monitors ) { 
@ Override public boolean logNewIncompletenessReasons ( final Logger logger ) { 
final boolean result = super . logNewIncompletenessReasons ( logger ) ; 
if ( result ) LoggerWrap . log ( logger , LogLevel . WARN , MARKER_ , "Reasoning may be incomplete! See log level INFO for more details." ) ; 
return result ; 
} 
} 
; 
} 
} 

public class TaxonomyPrinter { 
protected static < T extends ElkEntity > void processTaxomomy ( final Taxonomy < T > taxonomy , final Appendable writer ) throws IOException { 
final ElkObject . Factory factory = new ElkObjectEntityRecyclingFactory ( ) ; 
final List < T > members = new ArrayList < T > ( taxonomy . getNodes ( ) . size ( ) * 2 ) ; 
for ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { 
for ( final T member : node ) { 
if ( ! member . getIri ( ) . equals ( taxonomy . getTopNode ( ) . getCanonicalMember ( ) . getIri ( ) ) && ! member . getIri ( ) . equals ( taxonomy . getBottomNode ( ) . getCanonicalMember ( ) . getIri ( ) ) ) members . add ( member ) ; 
} 
} 
Collections . sort ( members , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; 
printDeclarations ( members , factory , writer ) ; 
final TreeSet < T > canonicalMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; 
for ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { 
canonicalMembers . add ( node . getCanonicalMember ( ) ) ; 
} 
for ( final T canonicalMember : canonicalMembers ) { 
final TaxonomyNode < T > node = taxonomy . getNode ( canonicalMember ) ; 
final ArrayList < T > orderedEquivalentMembers = new ArrayList < T > ( node . size ( ) ) ; 
for ( final T member : node ) { 
orderedEquivalentMembers . add ( member ) ; 
} 
Collections . sort ( orderedEquivalentMembers , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; 
final TreeSet < T > orderedSuperMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; 
for ( final TaxonomyNode < T > superNode : node . getDirectSuperNodes ( ) ) { 
orderedSuperMembers . add ( superNode . getCanonicalMember ( ) ) ; 
} 
printMemberAxioms ( canonicalMember , orderedEquivalentMembers , orderedSuperMembers , taxonomy , factory , writer ) ; 
} 
} 
} 

public class ClassExpressionQueryState { 
private QueryState markNotComputed ( final IndexedClassExpression queryClass ) { 
final QueryState state = indexed_ . get ( queryClass ) ; 
if ( state == null || ! state . isComputed ) return null ; 
state . isComputed = false ; 
if ( state . node != null ) { 
removeAllRelated ( queryClass , state . node ) ; 
state . node = null ; 
} 
return state ; 
} 
} 

public class AbstractMatch { 
protected static void checkChainMatch ( final ElkSubObjectPropertyExpression fullChain , final int startPos ) { 
fullChain . accept ( new ElkSubObjectPropertyExpressionVisitor < Void > ( ) { 
void fail ( ) { 
throw new IllegalArgumentException ( fullChain + ", " + startPos ) ; 
} 
Void defaultVisit ( ElkObjectPropertyExpression expression ) { 
if ( startPos != 0 ) fail ( ) ; 
return null ; 
} 
@ Override public Void visit ( ElkObjectPropertyChain expression ) { 
if ( startPos < 0 || startPos >= expression . getObjectPropertyExpressions ( ) . size ( ) ) fail ( ) ; 
return null ; 
} 
@ Override public Void visit ( ElkObjectInverseOf expression ) { 
return defaultVisit ( expression ) ; 
} 
@ Override public Void visit ( ElkObjectProperty expression ) { 
return defaultVisit ( expression ) ; 
} 
} 
) ; 
} 
} 

public class Reasoner { 
public synchronized boolean shutdown ( long timeout , TimeUnit unit ) throws InterruptedException { 
boolean success = true ; 
if ( success ) LOGGER_ . info ( "ELK reasoner has shut down" ) ; 
else LOGGER_ . error ( "ELK reasoner failed to shut down!" ) ; 
return success ; 
} 
} 

public class StatisticsPrinter { 
static String getString ( char c , int n ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) sb . append ( c ) ; 
return sb . toString ( ) ; 
} 
} 

public class XhtmlResourceMessageConverter { 
private void writeResource ( XhtmlWriter writer , Object object ) { 
if ( object == null ) return ; 
try { 
if ( object instanceof Resource ) { 
Resource < ? > resource = ( Resource < ? > ) object ; 
writer . beginListItem ( ) ; 
writeResource ( writer , resource . getContent ( ) ) ; 
writer . writeLinks ( resource . getLinks ( ) ) ; 
writer . endListItem ( ) ; 
} 
else if ( object instanceof Resources ) { 
Resources < ? > resources = ( Resources < ? > ) object ; 
writer . beginListItem ( ) ; 
writer . beginUnorderedList ( ) ; 
Collection < ? > content = resources . getContent ( ) ; 
writeResource ( writer , content ) ; 
writer . endUnorderedList ( ) ; 
writer . writeLinks ( resources . getLinks ( ) ) ; 
writer . endListItem ( ) ; 
} 
else if ( object instanceof ResourceSupport ) { 
ResourceSupport resource = ( ResourceSupport ) object ; 
writer . beginListItem ( ) ; 
writeObject ( writer , resource ) ; 
writer . writeLinks ( resource . getLinks ( ) ) ; 
writer . endListItem ( ) ; 
} 
else if ( object instanceof Collection ) { 
Collection < ? > collection = ( Collection < ? > ) object ; 
for ( Object item : collection ) { 
writeResource ( writer , item ) ; 
} 
} 
else writeObject ( writer , object ) ; 
} 
catch ( Exception ex ) { 
throw new RuntimeException ( "failed to transform object " + object , ex ) ; 
} 
} 
} 

public class SpringActionDescriptor { 
@ Override public ActionInputParameter getActionInputParameter ( String name ) { 
ActionInputParameter ret = requestParams . get ( name ) ; 
if ( ret == null ) ret = pathVariables . get ( name ) ; 
if ( ret == null ) for ( ActionInputParameter annotatedParameter : getInputParameters ( ) ) { 
PropertyDescriptor pd = getPropertyDescriptorForPropertyPath ( name , annotatedParameter . getParameterType ( ) ) ; 
if ( pd != null ) { 
if ( pd . getWriteMethod ( ) != null ) { 
Object callValue = annotatedParameter . getValue ( ) ; 
Object propertyValue = null ; 
if ( callValue != null ) { 
BeanWrapper beanWrapper = PropertyAccessorFactory . forBeanPropertyAccess ( callValue ) ; 
propertyValue = beanWrapper . getPropertyValue ( name ) ; 
} 
ret = new SpringActionInputParameter ( new MethodParameter ( pd . getWriteMethod ( ) , 0 ) , propertyValue ) ; 
} 
break ; 
} 
} 
return ret ; 
} 
} 

public class SpringActionDescriptor { 
PropertyDescriptor getPropertyDescriptorForPropertyPath ( String propertyPath , Class < ? > propertyType ) { 
int pos = PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath ) ; 
if ( pos > - 1 ) { 
String nestedProperty = propertyPath . substring ( 0 , pos ) ; 
String nestedPath = propertyPath . substring ( pos + 1 ) ; 
PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( propertyType , nestedProperty ) ; 
return getPropertyDescriptorForPropertyPath ( nestedPath , propertyDescriptor . getPropertyType ( ) ) ; 
} 
else return BeanUtils . getPropertyDescriptor ( propertyType , propertyPath ) ; 
} 
} 

public class SpringActionDescriptor { 
@ Override public Map < String , ActionInputParameter > getRequiredParameters ( ) { 
Map < String , ActionInputParameter > ret = new HashMap < String , ActionInputParameter > ( ) ; 
for ( Map . Entry < String , ActionInputParameter > entry : requestParams . entrySet ( ) ) { 
ActionInputParameter annotatedParameter = entry . getValue ( ) ; 
if ( annotatedParameter . isRequired ( ) ) ret . put ( entry . getKey ( ) , annotatedParameter ) ; 
} 
for ( Map . Entry < String , ActionInputParameter > entry : pathVariables . entrySet ( ) ) { 
ActionInputParameter annotatedParameter = entry . getValue ( ) ; 
ret . put ( entry . getKey ( ) , annotatedParameter ) ; 
} 
return ret ; 
} 
} 

public class DataType { 
public static boolean isSingleValueType ( Class < ? > clazz ) { 
boolean ret ; 
if ( isNumber ( clazz ) || isBoolean ( clazz ) || isString ( clazz ) || isEnum ( clazz ) || isDate ( clazz ) || isCalendar ( clazz ) || isCurrency ( clazz ) ) ret = true ; 
else ret = false ; 
return ret ; 
} 
} 

public class Affordance { 
@ JsonIgnore public boolean hasUnsatisfiedRequiredVariables ( ) { 
for ( ActionDescriptor actionDescriptor : actionDescriptors ) { 
Map < String , ActionInputParameter > requiredParameters = actionDescriptor . getRequiredParameters ( ) ; 
for ( ActionInputParameter annotatedParameter : requiredParameters . values ( ) ) { 
if ( ! annotatedParameter . hasValue ( ) ) return true ; 
} 
} 
return false ; 
} 
} 

public class SpringActionInputParameter { 
public String getValueFormatted ( ) { 
String ret ; 
if ( value == null ) ret = null ; 
else ret = ( String ) conversionService . convert ( value , typeDescriptor , TypeDescriptor . valueOf ( String . class ) ) ; 
return ret ; 
} 
} 

public class SpringActionInputParameter { 
public boolean isRequired ( ) { 
boolean ret ; 
if ( isRequestBody ( ) ) ret = requestBody . required ( ) ; 
else if ( isRequestParam ( ) ) ret = ! ( isDefined ( requestParam . defaultValue ( ) ) || ! requestParam . required ( ) ) ; 
else if ( isRequestHeader ( ) ) ret = ! ( isDefined ( requestHeader . defaultValue ( ) ) || ! requestHeader . required ( ) ) ; 
else ret = true ; 
return ret ; 
} 
} 

public class SpringActionInputParameter { 
public String getDefaultValue ( ) { 
String ret ; 
if ( isRequestParam ( ) ) ret = isDefined ( requestParam . defaultValue ( ) ) ? requestParam . defaultValue ( ) : null ; 
else if ( isRequestHeader ( ) ) ret = ! ( ValueConstants . DEFAULT_NONE . equals ( requestHeader . defaultValue ( ) ) ) ? requestHeader . defaultValue ( ) : null ; 
else ret = null ; 
return ret ; 
} 
} 

public class SpringActionInputParameter { 
@ Override public String getParameterName ( ) { 
String ret = null ; 
if ( requestParam != null ) { 
String requestParamName = requestParam . value ( ) ; 
if ( ! requestParamName . isEmpty ( ) ) ret = requestParamName ; 
} 
if ( pathVariable != null ) { 
String pathVariableName = pathVariable . value ( ) ; 
if ( ! pathVariableName . isEmpty ( ) ) ret = pathVariableName ; 
} 
if ( ret == null ) { 
String parameterName = methodParameter . getParameterName ( ) ; 
if ( parameterName == null ) { 
methodParameter . initParameterNameDiscovery ( new LocalVariableTableParameterNameDiscoverer ( ) ) ; 
ret = methodParameter . getParameterName ( ) ; 
} 
else ret = parameterName ; 
} 
return ret ; 
} 
} 

public class LinkListSerializer { 
private String getExposedPropertyOrParamName ( ActionInputParameter inputParameter ) { 
final Expose expose = inputParameter . getAnnotation ( Expose . class ) ; 
String property ; 
if ( expose != null ) property = expose . value ( ) ; 
else property = inputParameter . getParameterName ( ) ; 
return property ; 
} 
} 

public class LdContextFactory { 
public String getVocab ( MixinSource mixinSource , Object bean , Class < ? > mixInClass ) { 
if ( proxyUnwrapper != null ) bean = proxyUnwrapper . unwrapProxy ( bean ) ; 
String classVocab = bean == null ? null : vocabFromClassOrPackage ( bean . getClass ( ) ) ; 
final Vocab mixinVocab = findAnnotation ( mixInClass , Vocab . class ) ; 
Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin ( mixinSource , bean , mixInClass ) ; 
String contextProviderVocab = null ; 
if ( nestedContextProviderFromMixin != null ) contextProviderVocab = getVocab ( mixinSource , nestedContextProviderFromMixin , null ) ; 
String vocab ; 
if ( mixinVocab != null ) vocab = mixinVocab . value ( ) ; 
else if ( classVocab != null ) vocab = classVocab ; 
else if ( contextProviderVocab != null ) vocab = contextProviderVocab ; 
else vocab = HTTP_SCHEMA_ORG ; 
return vocab ; 
} 
} 

public class PartialUriTemplateComponents { 
public String getQuery ( ) { 
StringBuilder query = new StringBuilder ( ) ; 
if ( queryTail . length ( ) > 0 ) if ( queryHead . length ( ) == 0 ) query . append ( "{?" ) . append ( queryTail ) . append ( "}" ) ; 
else if ( queryHead . length ( ) > 0 ) query . append ( queryHead ) . append ( "{&" ) . append ( queryTail ) . append ( "}" ) ; 
else query . append ( queryHead ) ; 
return query . toString ( ) ; 
} 
} 

public class XhtmlWriter { 
private void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { 
String formName = actionDescriptor . getActionName ( ) ; 
RequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; 
String actionUrl = affordance . expand ( ) . getHref ( ) ; 
beginForm ( OptionalAttributes . attr ( "action" , actionUrl ) . and ( "method" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( "name" , formName ) ) ; 
write ( "<h4>" ) ; 
write ( "Form " + formName ) ; 
write ( "</h4>" ) ; 
writeHiddenHttpMethodField ( httpMethod ) ; 
if ( actionDescriptor . hasRequestBody ( ) ) { 
ActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; 
Class < ? > parameterType = requestBody . getParameterType ( ) ; 
recurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , "" ) ; 
} 
else { 
Collection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; 
for ( String requestParamName : requestParams ) { 
ActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; 
Object [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; 
if ( possibleValues . length > 0 ) if ( actionInputParameter . isArrayOrCollection ( ) ) appendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; 
else appendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; 
else if ( actionInputParameter . isArrayOrCollection ( ) ) { 
Object [ ] callValues = actionInputParameter . getValues ( ) ; 
int items = callValues . length ; 
for ( int i = 0 ; 
i < items ; 
i ++ ) { 
Object value ; 
if ( i < callValues . length ) value = callValues [ i ] ; 
else value = null ; 
appendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; 
} 
} 
else { 
String callValueFormatted = actionInputParameter . getValueFormatted ( ) ; 
appendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; 
} 
} 
} 
inputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; 
endForm ( ) ; 
} 
} 

public class XhtmlWriter { 
private void appendInputOrSelect ( ActionInputParameter parentInputParameter , String paramName , ActionInputParameter childInputParameter , Object [ ] possibleValues ) throws IOException { 
if ( possibleValues . length > 0 ) if ( childInputParameter . isArrayOrCollection ( ) ) appendSelectMulti ( paramName , possibleValues , childInputParameter ) ; 
else appendSelectOne ( paramName , possibleValues , childInputParameter ) ; 
else appendInput ( paramName , childInputParameter , childInputParameter . getValue ( ) , parentInputParameter . isReadOnly ( paramName ) ) ; 
} 
} 

public class AbstractUberNode { 
public UberNode getFirstByRel ( String rel ) { 
for ( UberNode node : data ) { 
List < String > myRels = node . getRel ( ) ; 
if ( myRels != null ) for ( String myRel : myRels ) { 
if ( rel . equals ( myRel ) ) return node ; 
} 
} 
return null ; 
} 
} 

public class AbstractUberNode { 
@ Override public Iterator < UberNode > iterator ( ) { 
return new Iterator < UberNode > ( ) { 
int index = 0 ; 
@ Override public void remove ( ) { 
throw new UnsupportedOperationException ( "removing from uber node is not supported" ) ; 
} 
@ Override public UberNode next ( ) { 
index = findNextChildWithData ( ) ; 
return data . get ( index ++ ) ; 
} 
@ Override public boolean hasNext ( ) { 
return findNextChildWithData ( ) != - 1 ; 
} 
private int findNextChildWithData ( ) { 
for ( int i = index ; 
i < data . size ( ) ; 
i ++ ) if ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) return i ; 
return - 1 ; 
} 
} 
; 
} 
} 

public class PersistentHashMap { 
@ SuppressWarnings ( "WeakerAccess" ) public static < K , V > PersistentHashMap < K , V > ofEq ( Equator < K > eq , Iterable < Map . Entry < K , V > > es ) { 
if ( es == null ) return empty ( eq ) ; 
MutableHashMap < K , V > map = emptyMutable ( eq ) ; 
for ( Map . Entry < K , V > entry : es ) { 
if ( entry != null ) map . assoc ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
return map . immutable ( ) ; 
} 
} 

public class PersistentTreeMap { 
public static < K extends Comparable < K > , V > PersistentTreeMap < K , V > of ( Iterable < Map . Entry < K , V > > es ) { 
if ( es == null ) return empty ( ) ; 
PersistentTreeMap < K , V > map = new PersistentTreeMap < > ( Equator . defaultComparator ( ) , null , 0 ) ; 
for ( Map . Entry < K , V > entry : es ) { 
if ( entry != null ) map = map . assoc ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
return map ; 
} 
} 

public class PersistentTreeMap { 
@ Override public K lastKey ( ) { 
UnEntry < K , V > max = last ( ) ; 
if ( max == null ) throw new NoSuchElementException ( "this map is empty" ) ; 
return max . getKey ( ) ; 
} 
} 

public class Xform { 
public static < T > Xform < T > of ( Iterable < ? extends T > list ) { 
if ( list == null ) return empty ( ) ; 
return new SourceProviderIterableDesc < > ( list ) ; 
} 
} 

public class Xform { 
@ SuppressWarnings ( "unchecked" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { 
Object ret = ident ; 
sourceLoop : for ( Object o : source ) { 
for ( int j = opIdx ; 
j < ops . length ; 
j ++ ) { 
Operation op = ops [ j ] ; 
if ( ( op . filter != null ) && ! op . filter . apply ( o ) ) continue sourceLoop ; 
if ( op . map != null ) { 
o = op . map . apply ( o ) ; 
if ( o == TERMINATE ) return ( H ) ret ; 
} 
else if ( op . flatMap != null ) { 
ret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; 
continue sourceLoop ; 
} 
} 
ret = reducer . apply ( ret , o ) ; 
} 
return ( H ) ret ; 
} 
} 

public class Xform { 
@ Override public Xform < A > dropWhile ( Fn1 < ? super A , Boolean > predicate ) { 
if ( predicate == null ) throw new IllegalArgumentException ( "Can't dropWhile without a function." ) ; 
return new DropWhileDesc < > ( this , predicate ) ; 
} 
} 

public class Xform { 
@ Override public < B > B fold ( B ident , Fn2 < ? super B , ? super A , B > reducer ) { 
if ( reducer == null ) throw new IllegalArgumentException ( "Can't fold with a null reduction function." ) ; 
RunList runList = toRunList ( ) ; 
return _fold ( runList , runList . opArray ( ) , 0 , ident , reducer ) ; 
} 
} 

public class Tuple2 { 
public static < K , V > Tuple2 < K , V > of ( Map . Entry < K , V > entry ) { 
if ( entry instanceof Tuple2 ) return ( Tuple2 < K , V > ) entry ; 
return new Tuple2 < > ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
} 

public class OneOf3 { 
@ SuppressWarnings ( "unchecked" ) public < R > R match ( Fn1 < A , R > fa , Fn1 < B , R > fb , Fn1 < C , R > fc ) { 
if ( sel == 0 ) return fa . apply ( ( A ) item ) ; 
else if ( sel == 1 ) return fb . apply ( ( B ) item ) ; 
else return fc . apply ( ( C ) item ) ; 
} 
} 

public class RuntimeTypes { 
public static ImList < Class > registerClasses ( Class ... cs ) { 
if ( cs == null ) throw new IllegalArgumentException ( "Can't register a null type array" ) ; 
if ( cs . length == 0 ) throw new IllegalArgumentException ( "Can't register a zero-length type array" ) ; 
for ( Class c : cs ) { 
if ( c == null ) throw new IllegalArgumentException ( "There shouldn't be any null types in this array!" ) ; 
} 
ArrayHolder < Class > ah = new ArrayHolder < > ( cs ) ; 
ImList < Class > registeredTypes ; 
synchronized ( Lock . INSTANCE ) { 
registeredTypes = typeMap . get ( ah ) ; 
if ( registeredTypes == null ) { 
ImList < Class > vecCs = vec ( cs ) ; 
typeMap . put ( ah , vecCs ) ; 
registeredTypes = vecCs ; 
} 
} 
return registeredTypes ; 
} 
} 

public class PersistentVector { 
@ SuppressWarnings ( "unchecked" ) @ Override public PersistentVector < E > append ( E val ) { 
if ( size - tailoff ( ) < MAX_NODE_LENGTH ) { 
E [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; 
System . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; 
newTail [ tail . length ] = val ; 
return new PersistentVector < > ( size + 1 , shift , root , newTail ) ; 
} 
Node newroot ; 
Node tailnode = new Node ( root . edit , tail ) ; 
int newshift = shift ; 
if ( ( size >>> NODE_LENGTH_POW_2 ) > ( 1 << shift ) ) { 
newroot = new Node ( root . edit ) ; 
newroot . array [ 0 ] = root ; 
newroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; 
newshift += NODE_LENGTH_POW_2 ; 
} 
else newroot = pushTail ( shift , root , tailnode ) ; 
return new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { 
val } 
) ; 
} 
} 

public class StaticImports { 
@ SafeVarargs public static < T > MutableSet < T > mutableSet ( T ... items ) { 
MutableSet < T > ret = PersistentHashSet . emptyMutable ( ) ; 
if ( items == null ) return ret ; 
for ( T t : items ) { 
ret . put ( t ) ; 
} 
return ret ; 
} 
} 

public class StaticImports { 
@ SafeVarargs public static < T > MutableList < T > mutableVec ( T ... items ) { 
MutableList < T > ret = PersistentVector . emptyMutable ( ) ; 
if ( items == null ) return ret ; 
for ( T t : items ) { 
ret . append ( t ) ; 
} 
return ret ; 
} 
} 

public class StaticImports { 
@ SafeVarargs public static < T > ImSet < T > set ( T ... items ) { 
if ( ( items == null ) || ( items . length < 1 ) ) return PersistentHashSet . empty ( ) ; 
return PersistentHashSet . of ( Arrays . asList ( items ) ) ; 
} 
} 

public class StaticImports { 
@ SafeVarargs static public < T > ImList < T > vec ( T ... items ) { 
if ( ( items == null ) || ( items . length < 1 ) ) return PersistentVector . empty ( ) ; 
return mutableVec ( items ) . immutable ( ) ; 
} 
} 

public class IndentUtils { 
public static StringBuilder indentSpace ( int len ) { 
StringBuilder sB = new StringBuilder ( ) ; 
if ( len < 1 ) return sB ; 
while ( len > SPACES_LENGTH_MINUS_ONE ) { 
sB . append ( SPACES [ SPACES_LENGTH_MINUS_ONE ] ) ; 
len = len - SPACES_LENGTH_MINUS_ONE ; 
} 
return sB . append ( SPACES [ len ] ) ; 
} 
} 

public class IndentUtils { 
public static < T > String arrayString ( T [ ] items ) { 
StringBuilder sB = new StringBuilder ( "A[" ) ; 
boolean isFirst = true ; 
for ( T item : items ) { 
if ( isFirst ) isFirst = false ; 
else sB . append ( " " ) ; 
if ( item instanceof String ) sB . append ( "\"" ) . append ( item ) . append ( "\"" ) ; 
else sB . append ( item ) ; 
} 
return sB . append ( "]" ) . toString ( ) ; 
} 
} 

public class LazyRef { 
public static < T > LazyRef < T > of ( Fn0 < T > producer ) { 
if ( producer == null ) throw new IllegalArgumentException ( "The producer function cannot be null (the value it returns can)" ) ; 
return new LazyRef < > ( producer ) ; 
} 
} 

public class Cowry { 
public static < T > T [ ] insertIntoArrayAt ( T item , T [ ] items , int idx , Class < T > tClass ) { 
@ SuppressWarnings ( "unchecked" ) T [ ] newItems = ( T [ ] ) ( ( tClass == null ) ? new Object [ items . length + 1 ] : Array . newInstance ( tClass , items . length + 1 ) ) ; 
if ( idx > 0 ) System . arraycopy ( items , 0 , newItems , 0 , idx ) ; 
newItems [ idx ] = item ; 
if ( idx < items . length ) System . arraycopy ( items , idx , newItems , idx + 1 , items . length - idx ) ; 
return newItems ; 
} 
} 

public class Cowry { 
public static < T > T [ ] arrayCopy ( T [ ] items , int length , Class < T > tClass ) { 
@ SuppressWarnings ( "unchecked" ) T [ ] newItems = ( T [ ] ) ( ( tClass == null ) ? new Object [ length ] : Array . newInstance ( tClass , length ) ) ; 
if ( length > 0 ) System . arraycopy ( items , 0 , newItems , 0 , items . length < length ? items . length : length ) ; 
return newItems ; 
} 
} 

public class SleeTransactionImpl { 
private void suspendIfAssoaciatedWithThread ( ) throws SystemException { 
final SleeTransaction currentThreadTransaction = transactionManager . getSleeTransaction ( ) ; 
if ( currentThreadTransaction != null && currentThreadTransaction . equals ( this ) ) transactionManager . getRealTransactionManager ( ) . suspend ( ) ; 
} 
} 

public class SleeTransactionImpl { 
private void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { 
try { 
int status = transaction . getStatus ( ) ; 
if ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) ) throw new IllegalStateException ( "There is no active tx, tx is in state: " + status ) ; 
suspendIfAssoaciatedWithThread ( ) ; 
} 
catch ( SystemException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class DeployableUnitServiceComponentBuilder { 
public List < ServiceComponentImpl > buildComponents ( String serviceDescriptorFileName , JarFile deployableUnitJar ) throws DeploymentException { 
JarEntry componentDescriptor = deployableUnitJar . getJarEntry ( serviceDescriptorFileName ) ; 
InputStream componentDescriptorInputStream = null ; 
List < ServiceComponentImpl > result = new ArrayList < ServiceComponentImpl > ( ) ; 
try { 
componentDescriptorInputStream = deployableUnitJar . getInputStream ( componentDescriptor ) ; 
ServiceDescriptorFactoryImpl descriptorFactory = componentManagement . getComponentDescriptorFactory ( ) . getServiceDescriptorFactory ( ) ; 
for ( ServiceDescriptorImpl descriptor : descriptorFactory . parse ( componentDescriptorInputStream ) ) { 
result . add ( new ServiceComponentImpl ( descriptor ) ) ; 
} 
} 
catch ( IOException e ) { 
throw new DeploymentException ( "failed to parse service descriptor from " + componentDescriptor . getName ( ) , e ) ; 
} 
finally { 
if ( componentDescriptorInputStream != null ) try { 
componentDescriptorInputStream . close ( ) ; 
} 
catch ( IOException e ) { 
logger . error ( "failed to close inputstream of descriptor for jar " + componentDescriptor . getName ( ) ) ; 
} 
} 
return result ; 
} 
} 

public class ConcreteClassGeneratorUtils { 
static private void validateDirectory ( File aDirectory ) throws FileNotFoundException { 
if ( aDirectory == null ) throw new IllegalArgumentException ( "Directory should not be null." ) ; 
if ( ! aDirectory . exists ( ) ) throw new FileNotFoundException ( "Directory does not exist: " + aDirectory ) ; 
if ( ! aDirectory . isDirectory ( ) ) throw new IllegalArgumentException ( "Is not a directory: " + aDirectory ) ; 
if ( ! aDirectory . canRead ( ) ) throw new IllegalArgumentException ( "Directory cannot be read: " + aDirectory ) ; 
} 
} 

public class ConcreteClassGeneratorUtils { 
public static void copyMethods ( CtMethod [ ] methods , CtClass destination , CtClass [ ] exceptions ) { 
CtMethod methodCopy = null ; 
for ( CtMethod method : methods ) { 
try { 
methodCopy = new CtMethod ( method , destination , null ) ; 
if ( exceptions != null ) try { 
methodCopy . setExceptionTypes ( exceptions ) ; 
} 
catch ( NotFoundException e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
destination . addMethod ( methodCopy ) ; 
} 
catch ( CannotCompileException e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
} 
} 
} 

public class LogStructureTreePanel { 
private TreeItem doTree ( FQDNNode localRoot ) { 
TreeItem localLeaf = new TreeItem ( ) ; 
LogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; 
localLeaf . setWidget ( logTreeNode ) ; 
if ( localRoot . getChildren ( ) . size ( ) > 0 ) { 
Tree t = new Tree ( ) ; 
ArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; 
Collections . sort ( names ) ; 
Iterator it = names . iterator ( ) ; 
while ( it . hasNext ( ) ) t . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; 
localLeaf . addItem ( t ) ; 
} 
return localLeaf ; 
} 
} 

public class UsageNotificationManagerMBeanImpl { 
public boolean getNotificationsEnabled ( String paramName ) { 
Boolean areNotificationsEnabled = paramNames . get ( paramName ) ; 
if ( ! isSlee11 ) if ( areNotificationsEnabled == null || areNotificationsEnabled . booleanValue ( ) ) return true ; 
else return false ; 
else if ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) return true ; 
else return false ; 
} 
} 

public class ServiceManagementImpl { 
public Set < String > getReferencedRAEntityLinksWhichNotExists ( ServiceComponent serviceComponent ) { 
Set < String > result = new HashSet < String > ( ) ; 
Set < String > raLinkNames = sleeContainer . getResourceManagement ( ) . getLinkNamesSet ( ) ; 
for ( String raLink : serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) ) { 
if ( ! raLinkNames . contains ( raLink ) ) result . add ( raLink ) ; 
} 
return result ; 
} 
} 

public class ServiceManagementImpl { 
public void installService ( final ServiceComponent serviceComponent ) throws Exception { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Installing Service " + serviceComponent ) ; 
final ServiceUsageMBean serviceUsageMBean = sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
try { 
serviceUsageMBean . remove ( ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
; 
final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; 
for ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { 
{ 
traceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
action = new TransactionalAction ( ) { 
public void execute ( ) { 
traceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
} 
} 
; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
} 
NotificationSourceWrapperImpl sbbMNotificationSource = new NotificationSourceWrapperImpl ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
serviceComponent . getAlarmNotificationSources ( ) . putIfAbsent ( sbbID , sbbMNotificationSource ) ; 
} 
sleeContainer . getSbbManagement ( ) . serviceInstall ( serviceComponent ) ; 
} 
} 

public class ServiceManagementImpl { 
public void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Uninstalling service with id " + serviceComponent . getServiceID ( ) ) ; 
if ( serviceComponent . getServiceState ( ) . isStopping ( ) ) for ( int i = 0 ; 
i < 15 ; 
i ++ ) try { 
Thread . sleep ( 1000 ) ; 
logger . info ( "Waiting for " + serviceComponent . getServiceID ( ) + " to stop, current state is " + serviceComponent . getServiceState ( ) ) ; 
if ( serviceComponent . getServiceState ( ) . isInactive ( ) ) break ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
if ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) throw new InvalidStateException ( serviceComponent . toString ( ) + " is not inactive" ) ; 
final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Closing Usage MBean of service " + serviceComponent . getServiceID ( ) ) ; 
ServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; 
if ( serviceUsageMBean != null ) { 
serviceUsageMBean . remove ( ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
try { 
sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
} 
final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; 
for ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { 
{ 
traceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
traceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
} 
} 
; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
} 
} 
sleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; 
} 
} 

public class ServiceManagementImpl { 
public boolean isRAEntityLinkNameReferenced ( String raLinkName ) { 
if ( raLinkName == null ) throw new NullPointerException ( "null ra link name" ) ; 
boolean b = false ; 
try { 
b = transactionManager . requireTransaction ( ) ; 
for ( ServiceID serviceID : componentRepositoryImpl . getServiceIDs ( ) ) { 
ServiceComponent serviceComponent = componentRepositoryImpl . getComponentByID ( serviceID ) ; 
if ( serviceComponent . getServiceState ( ) != ServiceState . INACTIVE && serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) . contains ( raLinkName ) ) return true ; 
} 
return false ; 
} 
finally { 
try { 
transactionManager . requireTransactionEnd ( b , false ) ; 
} 
catch ( Throwable ex ) { 
throw new SLEEException ( ex . getMessage ( ) , ex ) ; 
} 
} 
} 
} 

public class ServiceUsageMBeanImpl { 
public synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) throws NullPointerException , UnrecognizedSbbException , InvalidArgumentException , ManagementException { 
if ( sbbId == null ) throw new NullPointerException ( "Sbb ID is null!" ) ; 
SbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbId ) ; 
if ( sbbComponent == null ) throw new UnrecognizedSbbException ( sbbId . toString ( ) ) ; 
else if ( sbbComponent . getUsageParametersInterface ( ) == null ) throw new InvalidArgumentException ( "no usage parameter interface for " + sbbId ) ; 
ServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; 
if ( ! serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) throw new UnrecognizedSbbException ( sbbId . toString ( ) + " is not part of " + getService ( ) ) ; 
Set < String > resultSet = new HashSet < String > ( ) ; 
for ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { 
if ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) . getSbb ( ) . equals ( sbbId ) ) { 
String name = usageMBeanImpl . getUsageParameterSet ( ) ; 
if ( name != null ) resultSet . add ( name ) ; 
} 
} 
return resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; 
} 
} 

public class ProfileFacilityImpl { 
public Collection < ProfileID > getProfiles ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , TransactionRolledbackLocalException , FacilityException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "getProfiles( profileTableName = " + profileTableName + " )" ) ; 
profileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; 
try { 
return profileManagement . getProfileTable ( profileTableName ) . getProfiles ( ) ; 
} 
catch ( NullPointerException e ) { 
throw e ; 
} 
catch ( UnrecognizedProfileTableNameException e ) { 
throw e ; 
} 
catch ( Throwable e ) { 
throw new FacilityException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class ProfileFacilityImpl { 
public ProfileTableActivity getProfileTableActivity ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , TransactionRolledbackLocalException , FacilityException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "getProfileTableActivity( profileTableName = " + profileTableName + " )" ) ; 
final SleeTransactionManager sleeTransactionManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; 
boolean terminateTx = sleeTransactionManager . requireTransaction ( ) ; 
try { 
return profileManagement . getProfileTable ( profileTableName ) . getActivity ( ) ; 
} 
catch ( NullPointerException e ) { 
throw e ; 
} 
catch ( UnrecognizedProfileTableNameException e ) { 
throw e ; 
} 
catch ( Throwable e ) { 
throw new FacilityException ( "Failed to obtain profile table." , e ) ; 
} 
finally { 
try { 
sleeTransactionManager . requireTransactionEnd ( terminateTx , false ) ; 
} 
catch ( Throwable e ) { 
throw new FacilityException ( e . getMessage ( ) , e ) ; 
} 
} 
} 
} 

public class ProfileFacilityImpl { 
public ProfileID getProfileByIndexedAttribute ( java . lang . String profileTableName , java . lang . String attributeName , java . lang . Object attributeValue ) throws NullPointerException , UnrecognizedProfileTableNameException , UnrecognizedAttributeException , AttributeNotIndexedException , AttributeTypeMismatchException , TransactionRolledbackLocalException , FacilityException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "getProfileByIndexedAttribute( profileTableName = " + profileTableName + " , attributeName = " + attributeName + " , attributeValue = " + attributeValue + " )" ) ; 
profileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; 
try { 
ProfileTableImpl profileTable = profileManagement . getProfileTable ( profileTableName ) ; 
if ( profileTable . getProfileSpecificationComponent ( ) . isSlee11 ( ) ) throw new FacilityException ( "JAIN SLEE 1.1 Specs forbidden the usage of this method on SLEE 1.1 Profile Tables" ) ; 
Collection < ProfileID > profileIDs = profileTable . getProfilesByAttribute ( attributeName , attributeValue , false ) ; 
if ( profileIDs . isEmpty ( ) ) return null ; 
else return profileIDs . iterator ( ) . next ( ) ; 
} 
catch ( NullPointerException e ) { 
throw e ; 
} 
catch ( UnrecognizedProfileTableNameException e ) { 
throw e ; 
} 
catch ( UnrecognizedAttributeException e ) { 
throw e ; 
} 
catch ( AttributeNotIndexedException e ) { 
throw e ; 
} 
catch ( AttributeTypeMismatchException e ) { 
throw e ; 
} 
catch ( Throwable e ) { 
throw new FacilityException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class AbstractOperation { 
protected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { 
StringBuffer sb = new StringBuffer ( "[" ) ; 
for ( int index = 0 ; 
index < array . length ; 
index ++ ) { 
if ( editor != null ) { 
editor . setValue ( array [ index ] ) ; 
sb . append ( editor . getAsText ( ) ) ; 
} 
else sb . append ( array [ index ] . toString ( ) ) ; 
if ( index < array . length - 1 ) sb . append ( CID_SEPARATOR ) ; 
} 
sb . append ( "]" ) ; 
return sb . toString ( ) ; 
} 
} 

public class SleeEndpointFireEventNotTransactedExecutor { 
void execute ( final ActivityHandle realHandle , final ActivityHandle refHandle , final FireableEventType eventType , final Object event , final Address address , final ReceivableService receivableService , final int eventFlags ) throws ActivityIsEndingException , FireEventException , SLEEException , UnrecognizedActivityHandleException { 
final SleeTransaction tx = super . suspendTransaction ( ) ; 
try { 
sleeEndpoint . _fireEvent ( realHandle , refHandle , eventType , event , address , receivableService , eventFlags , tx ) ; 
} 
finally { 
if ( tx != null ) super . resumeTransaction ( tx ) ; 
} 
} 
} 

public class ActivityContextNamingFacilityCacheData { 
public void bindName ( Object ach , String name ) throws NameAlreadyBoundException { 
final Node node = getNode ( ) ; 
if ( node . hasChild ( name ) ) throw new NameAlreadyBoundException ( "name already bound" ) ; 
else node . addChild ( Fqn . fromElements ( name ) ) . put ( CACHE_NODE_MAP_KEY , ach ) ; 
} 
} 

public class ActivityContextNamingFacilityCacheData { 
public Object unbindName ( String name ) throws NameNotBoundException { 
final Node node = getNode ( ) ; 
final Node childNode = node . getChild ( name ) ; 
if ( childNode == null ) throw new NameNotBoundException ( "name not bound" ) ; 
else { 
final Object ach = childNode . get ( CACHE_NODE_MAP_KEY ) ; 
node . removeChild ( name ) ; 
return ach ; 
} 
} 
} 

public class ActivityContextNamingFacilityCacheData { 
public Object lookupName ( String name ) { 
final Node childNode = getNode ( ) . getChild ( name ) ; 
if ( childNode == null ) return null ; 
else return childNode . get ( CACHE_NODE_MAP_KEY ) ; 
} 
} 

public class NextSbbEntityFinder { 
public Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { 
SbbEntityID sbbEntityId = null ; 
SbbEntity sbbEntity = null ; 
EventEntryDescriptor mEventEntry = null ; 
for ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; 
iter . hasNext ( ) ; 
) { 
sbbEntityId = iter . next ( ) ; 
sbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; 
if ( sbbEntity == null ) continue ; 
if ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) continue ; 
if ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) if ( ! sleeEvent . isActivityEndEvent ( ) ) continue ; 
else return new Result ( sbbEntity , false ) ; 
mEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; 
if ( mEventEntry != null && mEventEntry . isReceived ( ) ) return new Result ( sbbEntity , true ) ; 
else if ( ! sleeEvent . isActivityEndEvent ( ) ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Event is not received by sbb descriptor of entity " + sbbEntityId + ", will not deliver event to sbb entity ..." ) ; 
continue ; 
} 
else return new Result ( sbbEntity , false ) ; 
} 
return null ; 
} 
} 

public class DeployableUnitJarComponentBuilder { 
private void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { 
JarInputStream jarIs = null ; 
try { 
jarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; 
for ( JarEntry entry = jarIs . getNextJarEntry ( ) ; 
jarIs . available ( ) > 0 && entry != null ; 
entry = jarIs . getNextJarEntry ( ) ) { 
logger . trace ( "jar entry = " + entry . getName ( ) ) ; 
if ( entry . isDirectory ( ) ) { 
File dir = new File ( dstDir , entry . getName ( ) ) ; 
if ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) { 
logger . debug ( "Failed to create directory " + dir . getAbsolutePath ( ) ) ; 
throw new IOException ( "Failed to create directory " + dir . getAbsolutePath ( ) ) ; 
} 
else logger . trace ( "Created directory" + dir . getAbsolutePath ( ) ) ; 
} 
else { 
File file = new File ( dstDir , entry . getName ( ) ) ; 
File dir = file . getParentFile ( ) ; 
if ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) { 
logger . debug ( "Failed to create directory " + dir . getAbsolutePath ( ) ) ; 
throw new IOException ( "Failed to create directory " + dir . getAbsolutePath ( ) ) ; 
} 
else logger . trace ( "Created directory" + dir . getAbsolutePath ( ) ) ; 
pipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; 
} 
} 
} 
catch ( Exception e ) { 
throw new DeploymentException ( "failed to extract jar file " + jarFile . getName ( ) ) ; 
} 
finally { 
if ( jarIs != null ) try { 
jarIs . close ( ) ; 
} 
catch ( IOException e ) { 
logger . error ( "failed to close jar input stream" , e ) ; 
} 
} 
} 
} 

public class ActivityContextCacheData { 
public boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { 
final Node node = getAttachedSbbsNode ( true ) ; 
if ( ! node . hasChild ( sbbEntityId ) ) { 
node . addChild ( Fqn . fromElements ( sbbEntityId ) ) ; 
return true ; 
} 
else return false ; 
} 
} 

public class ActivityContextCacheData { 
public boolean attachTimer ( TimerID timerID ) { 
final Node node = getAttachedTimersNode ( true ) ; 
if ( ! node . hasChild ( timerID ) ) { 
node . addChild ( Fqn . fromElements ( timerID ) ) ; 
return true ; 
} 
else return false ; 
} 
} 

public class ActivityContextCacheData { 
public void nameBound ( String name ) { 
final Node node = getNamesBoundNode ( true ) ; 
if ( ! node . hasChild ( name ) ) node . addChild ( Fqn . fromElements ( name ) ) ; 
} 
} 

public class ActivityContextCacheData { 
@ SuppressWarnings ( "unchecked" ) public void setCmpAttribute ( String attrName , Object attrValue ) { 
final Node node = getCmpAttributesNode ( true ) ; 
Node cmpNode = node . getChild ( attrName ) ; 
if ( cmpNode == null ) cmpNode = node . addChild ( Fqn . fromElements ( attrName ) ) ; 
cmpNode . put ( CMP_ATTRIBUTES_NODE_MAP_KEY , attrValue ) ; 
} 
} 

public class ActivityContextCacheData { 
@ SuppressWarnings ( "unchecked" ) public Object getCmpAttribute ( String attrName ) { 
final Node node = getCmpAttributesNode ( false ) ; 
if ( node == null ) return null ; 
else { 
final Node cmpNode = node . getChild ( attrName ) ; 
if ( cmpNode != null ) return cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ; 
else return null ; 
} 
} 
} 

public class ActivityContextCacheData { 
@ SuppressWarnings ( "unchecked" ) public Map getCmpAttributesCopy ( ) { 
final Node node = getCmpAttributesNode ( false ) ; 
if ( node == null ) return Collections . emptyMap ( ) ; 
else { 
Map result = new HashMap ( ) ; 
Node cmpNode = null ; 
for ( Object obj : node . getChildren ( ) ) { 
cmpNode = ( Node ) obj ; 
result . put ( cmpNode . getFqn ( ) . getLastElement ( ) , cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ) ; 
} 
return result ; 
} 
} 
} 

public class UsageMBeanImpl { 
public void sendUsageNotification ( long value , long seqno , String usageParameterSetName , String usageParameterName , boolean isCounter ) { 
UsageNotificationManagerMBeanImpl notificationManager = parent . getUsageNotificationManagerMBean ( notificationSource ) ; 
if ( notificationManager == null || notificationManager . getNotificationsEnabled ( usageParameterName ) ) { 
UsageNotification notification = createUsageNotification ( value , seqno , usageParameterSetName , usageParameterName , isCounter ) ; 
for ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { 
if ( triplet . notificationFilter == null || triplet . notificationFilter . isNotificationEnabled ( notification ) ) triplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; 
} 
} 
} 
} 

public class DeploymentManagerMBeanImpl { 
private File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { 
InputStream in = null ; 
OutputStream out = null ; 
try { 
String filename = new File ( duURL . getPath ( ) ) . getName ( ) ; 
File tempFile = new File ( deploymentRoot , filename ) ; 
out = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; 
URLConnection conn = duURL . openConnection ( ) ; 
in = conn . getInputStream ( ) ; 
byte [ ] buffer = new byte [ 1024 ] ; 
int numRead ; 
while ( ( numRead = in . read ( buffer ) ) != - 1 ) out . write ( buffer , 0 , numRead ) ; 
return tempFile ; 
} 
finally { 
try { 
if ( in != null ) { 
in . close ( ) ; 
in = null ; 
} 
if ( out != null ) { 
out . close ( ) ; 
out = null ; 
} 
} 
catch ( IOException ioe ) { 
} 
} 
} 
} 

public class DeploymentManager { 
public void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { 
updateDeployedComponents ( ) ; 
if ( ! du . isInstalled ( ) ) if ( waitingForInstallDUs . remove ( du ) ) logger . info ( du . getDeploymentInfoShortName ( ) + " wasn't deployed. Removing from waiting list." ) ; 
else if ( ! du . areComponentsStillPresent ( ) ) { 
logger . info ( du . getDeploymentInfoShortName ( ) + " components already removed. Removing DU info." ) ; 
processInternalUndeploy ( du ) ; 
} 
else if ( du . isReadyToUninstall ( ) ) { 
sciAction ( du . getUninstallActions ( ) , du ) ; 
processInternalUndeploy ( du ) ; 
} 
else { 
if ( ! waitingForUninstallDUs . contains ( du ) ) { 
waitingForUninstallDUs . add ( du ) ; 
logger . warn ( "Unable to UNINSTALL " + du . getDeploymentInfoShortName ( ) + " right now. Waiting for dependents to be removed." ) ; 
} 
throw new DependencyException ( "Unable to undeploy " + du . getDeploymentInfoShortName ( ) ) ; 
} 
} 
} 

public class MobicentsLogFilter { 
public boolean isLoggable ( LogRecord record ) { 
Logger logger = getLogger ( record ) ; 
if ( record . getThrown ( ) != null ) logWithThrowable ( logger , record ) ; 
else logWithoutThrowable ( logger , record ) ; 
return false ; 
} 
} 

public class ComponentRepositoryImpl { 
public Set < SleeComponent > getReferringComponents ( SleeComponent component ) { 
Set < SleeComponent > result = new HashSet < SleeComponent > ( ) ; 
for ( EventTypeComponent otherComponent : eventTypeComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
for ( LibraryComponent otherComponent : libraryComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
for ( ProfileSpecificationComponent otherComponent : profileSpecificationComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
for ( ResourceAdaptorComponent otherComponent : resourceAdaptorComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
for ( ResourceAdaptorTypeComponent otherComponent : resourceAdaptorTypeComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
for ( SbbComponent otherComponent : sbbComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
for ( ServiceComponent otherComponent : serviceComponents . values ( ) ) { 
if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) result . add ( otherComponent ) ; 
} 
return result ; 
} 
} 

public class SbbEntityFactoryCacheData { 
public Set < SbbEntityID > getSbbEntities ( ) { 
final Node node = getNode ( ) ; 
if ( node == null ) return Collections . emptySet ( ) ; 
HashSet < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; 
ServiceID serviceID = null ; 
for ( Object obj : node . getChildrenNames ( ) ) { 
serviceID = ( ServiceID ) obj ; 
for ( SbbEntityID sbbEntityID : getRootSbbEntityIDs ( serviceID ) ) { 
result . add ( sbbEntityID ) ; 
collectSbbEntities ( sbbEntityID , result ) ; 
} 
} 
return result ; 
} 
} 

public class ProfileTableImpl { 
public boolean profileExists ( String profileName ) { 
boolean result = component . getProfileEntityFramework ( ) . findProfile ( this . getProfileTableName ( ) , profileName ) != null ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Profile named " + profileName + ( result ? "" : " does not" ) + " exists on table named " + this . getProfileTableName ( ) ) ; 
return result ; 
} 
} 

public class ProfileTableImpl { 
public void remove ( boolean isUninstall ) throws SLEEException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "removeProfileTable: removing profileTable=" + profileTableName ) ; 
for ( ProfileID profileID : getProfiles ( ) ) { 
this . removeProfile ( profileID . getProfileName ( ) , false , isUninstall ) ; 
} 
if ( getDefaultProfileEntity ( ) != null ) this . removeProfile ( null , false , false ) ; 
TransactionalAction commitAction = new TransactionalAction ( ) { 
public void execute ( ) { 
final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; 
traceMBeanImpl . deregisterNotificationSource ( new ProfileTableNotification ( profileTableName ) ) ; 
closeUncommittedProfileMBeans ( ) ; 
} 
} 
; 
sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( commitAction ) ; 
if ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) endActivity ( ) ; 
unregisterUsageMBean ( ) ; 
profileManagement . getObjectPoolManagement ( ) . removeObjectPool ( this , sleeContainer . getTransactionManager ( ) ) ; 
} 
} 

public class ResourceAdaptorEntityImpl { 
public void updateConfigurationProperties ( ConfigProperties properties ) throws InvalidConfigurationException , InvalidStateException { 
if ( ! component . getDescriptor ( ) . getSupportsActiveReconfiguration ( ) && ( sleeContainer . getSleeState ( ) != SleeState . STOPPED ) && ( state == ResourceAdaptorEntityState . ACTIVE || state == ResourceAdaptorEntityState . STOPPING ) ) throw new InvalidStateException ( "the value of the supports-active-reconfiguration attribute of the resource-adaptor-class element in the deployment descriptor of the Resource Adaptor of the resource adaptor entity is False and the resource adaptor entity is in the Active or Stopping state and the SLEE is in the Starting, Running, or Stopping state" ) ; 
else object . raConfigurationUpdate ( properties ) ; 
} 
} 

public class ResourceAdaptorEntityImpl { 
@ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) public void sleeRunning ( ) throws InvalidStateException { 
if ( this . state . isActive ( ) ) { 
if ( setFTContext ) { 
setFTContext = false ; 
if ( object . isFaultTolerant ( ) ) try { 
this . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; 
object . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; 
} 
catch ( Throwable t ) { 
logger . error ( "Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity " + name , t ) ; 
} 
} 
try { 
object . raActive ( ) ; 
} 
catch ( Throwable t ) { 
logger . error ( "Got exception invoking raActive() for entity " + name , t ) ; 
} 
} 
} 
} 

public class ResourceAdaptorEntityImpl { 
@ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) public void activate ( ) throws InvalidStateException { 
if ( ! this . state . isInactive ( ) ) throw new InvalidStateException ( "entity " + name + " is in state: " + this . state ) ; 
this . state = ResourceAdaptorEntityState . ACTIVE ; 
if ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { 
if ( setFTContext ) { 
setFTContext = false ; 
if ( object . isFaultTolerant ( ) ) try { 
this . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; 
object . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; 
} 
catch ( Throwable t ) { 
logger . error ( "Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity " + name , t ) ; 
} 
} 
try { 
object . raActive ( ) ; 
} 
catch ( Throwable t ) { 
logger . error ( "Got exception invoking raActive() for entity " + name , t ) ; 
} 
} 
} 
} 

public class ResourceAdaptorEntityImpl { 
public void deactivate ( ) throws InvalidStateException , TransactionRequiredLocalException { 
if ( ! this . state . isActive ( ) ) throw new InvalidStateException ( "entity " + name + " is in state: " + this . state ) ; 
this . state = ResourceAdaptorEntityState . STOPPING ; 
if ( object . getState ( ) == ResourceAdaptorObjectState . ACTIVE ) object . raStopping ( ) ; 
TimerTask t = new TimerTask ( ) { 
@ Override public void run ( ) { 
try { 
cancel ( ) ; 
if ( state == ResourceAdaptorEntityState . STOPPING ) if ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) scheduleAllActivitiesEnd ( ) ; 
else allActivitiesEnded ( ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
; 
resourceAdaptorContext . getTimer ( ) . schedule ( t , 500 ) ; 
} 
} 

public class ResourceAdaptorEntityImpl { 
private void scheduleAllActivitiesEnd ( ) throws TransactionRequiredLocalException { 
boolean skipActivityEnding = ! sleeContainer . getCluster ( ) . isSingleMember ( ) ; 
if ( ! skipActivityEnding && hasActivities ( ) ) { 
logger . info ( "RA entity " + name + " activities end scheduled." ) ; 
timerTask = new EndAllActivitiesRAEntityTimerTask ( this , sleeContainer ) ; 
} 
else allActivitiesEnded ( ) ; 
} 
} 

public class ResourceAdaptorEntityImpl { 
public void remove ( ) throws InvalidStateException { 
if ( ! this . state . isInactive ( ) ) throw new InvalidStateException ( "entity " + name + " is in state: " + this . state ) ; 
object . raUnconfigure ( ) ; 
if ( object . isFaultTolerant ( ) ) { 
object . unsetFaultTolerantResourceAdaptorContext ( ) ; 
ftResourceAdaptorContext . shutdown ( ) ; 
} 
object . unsetResourceAdaptorContext ( ) ; 
this . sleeContainer . getTraceManagement ( ) . deregisterNotificationSource ( this . getNotificationSource ( ) ) ; 
state = null ; 
} 
} 

public class ResourceAdaptorEntityImpl { 
public void serviceActive ( ServiceID serviceID ) { 
try { 
ReceivableService receivableService = resourceAdaptorContext . getServiceLookupFacility ( ) . getReceivableService ( serviceID ) ; 
if ( receivableService . getReceivableEvents ( ) . length > 0 ) object . serviceActive ( receivableService ) ; 
} 
catch ( Throwable e ) { 
logger . warn ( "invocation resulted in unchecked exception" , e ) ; 
} 
} 
} 

public class ResourceAdaptorEntityImpl { 
ActivityHandle derreferActivityHandle ( ActivityHandle handle ) { 
ActivityHandle ah = null ; 
if ( resourceManagement . getHandleReferenceFactory ( ) != null && handle . getClass ( ) == ActivityHandleReference . class ) { 
ActivityHandleReference ahReference = ( ActivityHandleReference ) handle ; 
ah = resourceManagement . getHandleReferenceFactory ( ) . getActivityHandle ( ahReference ) ; 
} 
else ah = handle ; 
return ah ; 
} 
} 

public class ResourceAdaptorEntityImpl { 
public void activityEnded ( final ActivityHandle handle , int activityFlags ) { 
logger . trace ( "activityEnded( handle = " + handle + " )" ) ; 
ActivityHandle ah = null ; 
if ( handle instanceof ActivityHandleReference ) ah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; 
else ah = handle ; 
if ( ah != null && ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) object . activityEnded ( ah ) ; 
if ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) synchronized ( this ) { 
if ( ! hasActivities ( ) ) { 
if ( timerTask != null ) timerTask . cancel ( ) ; 
allActivitiesEnded ( ) ; 
} 
} 
} 
} 

public class ResourceAdaptorObjectImpl { 
public void raConfigurationUpdate ( ConfigProperties properties ) throws InvalidConfigurationException { 
if ( doTraceLogs ) logger . trace ( "raConfigurationUpdate( properties = " + properties + " )" ) ; 
verifyConfigProperties ( properties ) ; 
object . raConfigurationUpdate ( configProperties ) ; 
} 
} 

public class ResourceAdaptorObjectImpl { 
private void verifyConfigProperties ( ConfigProperties newProperties ) throws InvalidConfigurationException { 
if ( doTraceLogs ) logger . trace ( "verifyConfigProperties( newProperties = " + newProperties + " )" ) ; 
for ( ConfigProperties . Property configProperty : configProperties . getProperties ( ) ) { 
if ( newProperties . getProperty ( configProperty . getName ( ) ) == null ) newProperties . addProperty ( configProperty ) ; 
} 
for ( ConfigProperties . Property entityProperty : newProperties . getProperties ( ) ) { 
if ( entityProperty . getValue ( ) == null ) throw new InvalidConfigurationException ( "the property " + entityProperty . getName ( ) + " has null value" ) ; 
} 
object . raVerifyConfiguration ( newProperties ) ; 
configProperties = newProperties ; 
} 
} 

public class ResourceAdaptorObjectImpl { 
public void raStopping ( ) throws InvalidStateException { 
if ( doTraceLogs ) logger . trace ( "raStopping()" ) ; 
if ( state == ResourceAdaptorObjectState . ACTIVE ) { 
state = ResourceAdaptorObjectState . STOPPING ; 
object . raStopping ( ) ; 
} 
else throw new InvalidStateException ( "ra object is in state " + state ) ; 
} 
} 

public class ResourceAdaptorObjectImpl { 
public void raInactive ( ) throws InvalidStateException { 
if ( doTraceLogs ) logger . trace ( "raInactive()" ) ; 
if ( state == ResourceAdaptorObjectState . STOPPING ) { 
state = ResourceAdaptorObjectState . INACTIVE ; 
object . raInactive ( ) ; 
} 
else throw new InvalidStateException ( "ra object is in state " + state ) ; 
} 
} 

public class ResourceAdaptorObjectImpl { 
public void raUnconfigure ( ) throws InvalidStateException { 
if ( doTraceLogs ) logger . trace ( "raUnconfigure()" ) ; 
if ( state == ResourceAdaptorObjectState . INACTIVE ) { 
state = ResourceAdaptorObjectState . UNCONFIGURED ; 
object . raUnconfigure ( ) ; 
} 
else throw new InvalidStateException ( "ra object is in state " + state ) ; 
} 
} 

public class ResourceAdaptorObjectImpl { 
public void unsetResourceAdaptorContext ( ) throws InvalidStateException { 
if ( doTraceLogs ) logger . trace ( "unsetResourceAdaptorContext()" ) ; 
if ( state == ResourceAdaptorObjectState . UNCONFIGURED ) { 
object . unsetResourceAdaptorContext ( ) ; 
state = null ; 
} 
else throw new InvalidStateException ( "ra object is in state " + state ) ; 
} 
} 

public class ResourceAdaptorObjectImpl { 
@ SuppressWarnings ( "unchecked" ) public void unsetFaultTolerantResourceAdaptorContext ( ) throws IllegalArgumentException { 
if ( doTraceLogs ) logger . trace ( "unsetFaultTolerantResourceAdaptorContext()" ) ; 
if ( isFaultTolerant ( ) ) ( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) . unsetFaultTolerantResourceAdaptorContext ( ) ; 
else throw new IllegalArgumentException ( "RA Object is not fault tolerant!" ) ; 
} 
} 

public class ProfileSpecificationComponentImpl { 
private void buildProfileAttributeMap ( ) throws DeploymentException { 
HashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; 
Class < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; 
String attributeGetterMethodPrefix = "get" ; 
for ( Method method : cmpInterface . getMethods ( ) ) { 
if ( ! method . getDeclaringClass ( ) . equals ( Object . class ) && method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { 
String attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; 
switch ( attributeName . length ( ) ) { 
case 0 : throw new DeploymentException ( "the profile cmp interface class has an invalid attribute getter method name > " + method . getName ( ) ) ; 
case 1 : attributeName = attributeName . toLowerCase ( ) ; 
break ; 
default : attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; 
break ; 
} 
ProfileAttributeImpl profileAttribute = null ; 
try { 
profileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; 
} 
catch ( Throwable e ) { 
throw new DeploymentException ( "Invalid profile cmp interface attribute getter method definition ( name = " + attributeName + " , type = " + method . getReturnType ( ) + " )" , e ) ; 
} 
if ( isSlee11 ( ) ) for ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { 
if ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) profileAttribute . setUnique ( cmpField . isUnique ( ) ) ; 
} 
else for ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { 
if ( profileIndex . getName ( ) . equals ( attributeName ) ) { 
profileAttribute . setIndex ( true ) ; 
profileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; 
} 
} 
map . put ( attributeName , profileAttribute ) ; 
} 
} 
profileAttributeMap = Collections . unmodifiableMap ( map ) ; 
} 
} 

public class EventContextSuspensionHandler { 
private void resume ( ) { 
Runnable runnable = new Runnable ( ) { 
public void run ( ) { 
if ( scheduledFuture == null ) return ; 
scheduledFuture . cancel ( false ) ; 
scheduledFuture = null ; 
for ( EventContext ec : barriedEvents ) { 
ec . getLocalActivityContext ( ) . getExecutorService ( ) . routeEvent ( ec ) ; 
} 
barriedEvents = null ; 
event . getLocalActivityContext ( ) . getEventQueueManager ( ) . removeBarrier ( transaction ) ; 
suspended = false ; 
event . getLocalActivityContext ( ) . getCurrentEventRoutingTask ( ) . run ( ) ; 
} 
} 
; 
event . getLocalActivityContext ( ) . getExecutorService ( ) . execute ( runnable ) ; 
} 
} 

public class AbstractUsageMBeanImplParent { 
public void remove ( ) { 
Logger logger = getLogger ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Closing " + toString ( ) ) ; 
final MBeanServer mbeanServer = sleeContainer . getMBeanServer ( ) ; 
try { 
mbeanServer . unregisterMBean ( getObjectName ( ) ) ; 
} 
catch ( Exception e ) { 
logger . error ( "failed to remove " + toString ( ) , e ) ; 
} 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Removing all named usage parameters of " + toString ( ) ) ; 
for ( String name : usageMBeans . keySet ( ) ) { 
try { 
_removeUsageParameterSet ( name , false ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
try { 
removeUsageParameterSet ( ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class ProfileAbstractClassDecorator { 
public boolean decorateAbstractClass ( ) throws DeploymentException { 
ClassPool pool = component . getClassPool ( ) ; 
ProfileAbstractClassDescriptor abstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; 
if ( abstractClass == null ) return false ; 
String abstractClassName = abstractClass . getProfileAbstractClassName ( ) ; 
try { 
ctClass = pool . get ( abstractClassName ) ; 
} 
catch ( NotFoundException nfe ) { 
throw new DeploymentException ( "Could not find Abstract Class: " + abstractClassName , nfe ) ; 
} 
decorateClassJNDIAddToEnvironmentCalls ( ) ; 
if ( isAbstractClassDecorated ) { 
try { 
String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
ctClass . writeFile ( deployDir ) ; 
ctClass . detach ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Modified Abstract Class " + ctClass . getName ( ) + " generated in the following path " + deployDir ) ; 
} 
catch ( Throwable e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
finally { 
ctClass . defrost ( ) ; 
} 
return true ; 
} 
else return false ; 
} 
} 

public class SbbAbstractMethodHandler { 
public static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address , ServiceID serviceID ) { 
if ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) throw new SLEEException ( "congestion control refused event" ) ; 
if ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null || sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( "SbbObject not assigned!" ) ; 
if ( eventObject == null ) throw new NullPointerException ( "JAIN SLEE (TM) specs - Section 8.4.1: The event ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException." ) ; 
if ( aci == null ) throw new NullPointerException ( "JAIN SLEE (TM) specs - Section 8.4.1: The activity ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException." ) ; 
final SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; 
txManager . mandateTransaction ( ) ; 
ActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) . getActivityContext ( ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "invoke(): firing event on " + ac ) ; 
if ( ac . isEnding ( ) ) throw new IllegalStateException ( "activity context " + ac . getActivityContextHandle ( ) + " is ending" ) ; 
final EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; 
if ( transactionData != null ) { 
final EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; 
if ( eventBeingDelivered != null && eventBeingDelivered . getEvent ( ) == eventObject ) { 
ac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; 
return ; 
} 
} 
ac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; 
} 
} 

public class SbbAbstractMethodHandler { 
public static Object getProfileCMPMethod ( SbbEntity sbbEntity , String getProfileCMPMethodName , ProfileID profileID ) throws UnrecognizedProfileTableNameException , UnrecognizedProfileNameException { 
GetProfileCMPMethodDescriptor mGetProfileCMPMethod = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getGetProfileCMPMethods ( ) . get ( getProfileCMPMethodName ) ; 
if ( mGetProfileCMPMethod == null ) throw new AbstractMethodError ( "Profile CMP Method not found" ) ; 
if ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( "Could not invoke getProfileCMP Method, Sbb Object is not in the READY state!" ) ; 
ProfileManagement sleeProfileManager = sleeContainer . getSleeProfileTableManager ( ) ; 
ProfileTable profileTable = sleeProfileManager . getProfileTable ( profileID . getProfileTableName ( ) ) ; 
if ( ! profileTable . profileExists ( profileID . getProfileName ( ) ) ) throw new UnrecognizedProfileNameException ( profileID . toString ( ) ) ; 
return profileTable . getProfile ( profileID . getProfileName ( ) ) . getProfileCmpSlee10Wrapper ( ) ; 
} 
} 

public class SbbAbstractMethodHandler { 
public static Object getSbbUsageParameterSet ( SbbEntity sbbEntity , String name ) throws UnrecognizedUsageParameterSetNameException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "getSbbUsageParameterSet(): serviceId = " + sbbEntity . getSbbEntityId ( ) . getServiceID ( ) + " , sbbID = " + sbbEntity . getSbbId ( ) + " , name = " + name ) ; 
return getServiceUsageMBeanImpl ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) . getInstalledUsageParameterSet ( sbbEntity . getSbbId ( ) , name ) ; 
} 
} 

public class ClassUtils { 
public static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { 
HashMap abstractMethods = new HashMap ( ) ; 
CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) if ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) abstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; 
return abstractMethods ; 
} 
} 

public class ClassUtils { 
public static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { 
HashMap interfaceMethods = new HashMap ( ) ; 
CtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) if ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { 
ConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; 
interfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
} 
Map temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; 
for ( Iterator i = temp . keySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
String key = ( String ) i . next ( ) ; 
if ( ! exceptMethods . containsKey ( key ) ) interfaceMethods . put ( key , temp . get ( key ) ) ; 
} 
return interfaceMethods ; 
} 
} 

public class ProfileObjectPoolManagement { 
public void createObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Creating Pool for " + profileTable ) ; 
createObjectPool ( profileTable ) ; 
if ( sleeTransactionManager != null ) { 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Due to tx rollback, removing pool for " + profileTable ) ; 
try { 
removeObjectPool ( profileTable ) ; 
} 
catch ( Throwable e ) { 
logger . error ( "Failed to remove table's " + profileTable + " object pool" , e ) ; 
} 
} 
} 
; 
sleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; 
} 
} 
} 

public class ProfileObjectPoolManagement { 
public void removeObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Removing Pool for " + profileTable ) ; 
removeObjectPool ( profileTable ) ; 
} 
} 
; 
if ( sleeTransactionManager != null ) sleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action ) ; 
else action . execute ( ) ; 
} 
} 

public class AlarmMBeanImpl { 
public String raiseAlarm ( NotificationSourceWrapper notificationSource , String alarmType , String instanceID , AlarmLevel level , String message , Throwable cause ) { 
synchronized ( notificationSource ) { 
if ( isAlarmAlive ( notificationSource , alarmType , instanceID ) ) { 
Alarm a = null ; 
try { 
AlarmPlaceHolder localAPH = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID ) ; 
for ( Map . Entry < String , AlarmPlaceHolder > e : this . alarmIdToAlarm . entrySet ( ) ) { 
if ( e . getValue ( ) . equals ( localAPH ) ) { 
a = e . getValue ( ) . getAlarm ( ) ; 
break ; 
} 
} 
} 
catch ( Exception e ) { 
} 
if ( a != null ) return a . getAlarmID ( ) ; 
else return this . raiseAlarm ( notificationSource , alarmType , instanceID , level , message , cause ) ; 
} 
else { 
Alarm a = new Alarm ( UUID . randomUUID ( ) . toString ( ) , notificationSource . getNotificationSource ( ) , alarmType , instanceID , level , message , cause , System . currentTimeMillis ( ) ) ; 
AlarmPlaceHolder aph = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID , a ) ; 
this . alarmIdToAlarm . put ( a . getAlarmID ( ) , aph ) ; 
this . placeHolderToNotificationSource . put ( aph , aph . getNotificationSource ( ) . getNotificationSource ( ) ) ; 
generateNotification ( aph , false ) ; 
return a . getAlarmID ( ) ; 
} 
} 
} 
} 

public class ProfileManagementHandler { 
public static Object getUsageParameterSet ( ProfileObjectImpl profileObject , String name ) throws UnrecognizedUsageParameterSetNameException { 
if ( logger . isDebugEnabled ( ) ) logger . info ( "[getUsageParameterSet(" + name + ")] @ " + profileObject ) ; 
if ( name == null ) throw new NullPointerException ( "UsageParameterSet name must not be null." ) ; 
ProfileTableImpl profileTable = profileObject . getProfileTable ( ) ; 
Object result = profileTable . getProfileTableUsageMBean ( ) . getInstalledUsageParameterSet ( name ) ; 
if ( result == null ) throw new UnrecognizedUsageParameterSetNameException ( ) ; 
else return result ; 
} 
} 

public class EventTypeComponentImpl { 
public javax . slee . management . EventTypeDescriptor getSpecsDescriptor ( ) { 
if ( specsDescriptor == null ) specsDescriptor = new javax . slee . management . EventTypeDescriptor ( getEventTypeID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , descriptor . getLibraryRefs ( ) . toArray ( new LibraryID [ descriptor . getLibraryRefs ( ) . size ( ) ] ) , getDescriptor ( ) . getEventClassName ( ) ) ; 
return specsDescriptor ; 
} 
} 

public class SLEESubDeployer { 
public boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { 
DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; 
URL url = du . getUrl ( ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Method accepts called for " + url + " [DU: " + deployableUnitName + "]" ) ; 
try { 
String fullPath = url . getFile ( ) ; 
String fileName = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 , fullPath . length ( ) ) ; 
if ( toAccept . containsKey ( fileName ) ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Accepting " + url . toString ( ) + "." ) ; 
return true ; 
} 
else if ( fileName . endsWith ( ".jar" ) ) { 
JarFile duJarFile = null ; 
try { 
if ( du . getEntry ( "META-INF/deployable-unit.xml" ) != null ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Accepting " + url . toString ( ) + "." ) ; 
return true ; 
} 
} 
finally { 
if ( duJarFile != null ) try { 
duJarFile . close ( ) ; 
} 
catch ( IOException ignore ) { 
} 
finally { 
duJarFile = null ; 
} 
} 
} 
} 
catch ( Exception ignore ) { 
} 
return false ; 
} 
} 

public class SLEESubDeployer { 
public void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
URL url = deployableUnitURL ; 
DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Method init called for " + deployableUnitURL + " [DU: " + deployableUnitName + "]" ) ; 
String fullPath = du . getFullPath ( ) ; 
String fileName = du . getFileName ( ) ; 
try { 
DeployableUnitWrapper duWrapper = null ; 
if ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { 
DeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; 
DeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; 
for ( DeployableComponent subDC : dc . getSubComponents ( ) ) { 
deployerDU . addComponent ( subDC ) ; 
} 
} 
else if ( fileName . endsWith ( ".jar" ) ) { 
JarFile duJarFile = null ; 
try { 
duJarFile = new JarFile ( fullPath ) ; 
JarEntry duXmlEntry = duJarFile . getJarEntry ( "META-INF/deployable-unit.xml" ) ; 
if ( duXmlEntry != null ) { 
DeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; 
DeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; 
DeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; 
while ( deployableUnits . containsKey ( fileName ) ) Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; 
deployableUnits . put ( fileName , deployerDU ) ; 
for ( String componentJarName : duDesc . getJarEntries ( ) ) { 
int beginIndex ; 
if ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\' ) ; 
beginIndex ++ ; 
componentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; 
toAccept . put ( componentJarName , du ) ; 
} 
for ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { 
int beginIndex ; 
if ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\' ) ; 
beginIndex ++ ; 
serviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; 
toAccept . put ( serviceXMLName , du ) ; 
} 
} 
} 
finally { 
if ( duJarFile != null ) try { 
duJarFile . close ( ) ; 
} 
catch ( IOException ignore ) { 
} 
finally { 
duJarFile = null ; 
} 
} 
} 
} 
catch ( Exception e ) { 
logger . error ( "Deployment of " + fileName + " failed. " , e ) ; 
return ; 
} 
} 
} 

public class SLEESubDeployer { 
public void start ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Method start called for " + du . getUrl ( ) + " [DU: " + deployableUnitName + "]" ) ; 
try { 
DeployableUnit realDU = deployableUnits . get ( du . getFileName ( ) ) ; 
if ( realDU != null ) { 
while ( isInUndeployList ( du . getFileName ( ) ) ) Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; 
sleeContainerDeployer . getDeploymentManager ( ) . installDeployableUnit ( realDU ) ; 
} 
} 
catch ( Exception e ) { 
logger . error ( "" , e ) ; 
} 
} 
} 

public class SLEESubDeployer { 
public void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "stop( deployableUnitURL = : " + deployableUnitURL + " )" ) ; 
DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; 
DeployableUnit realDU = null ; 
String fileName = du . getFileName ( ) ; 
if ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Got DU: " + realDU . getDeploymentInfoShortName ( ) ) ; 
if ( ! isInUndeployList ( fileName ) ) addToUndeployList ( fileName ) ; 
try { 
sleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; 
deployableUnits . remove ( fileName ) ; 
removeFromUndeployList ( fileName ) ; 
} 
catch ( DependencyException e ) { 
} 
catch ( Exception e ) { 
Throwable cause = e . getCause ( ) ; 
if ( cause instanceof InvalidStateException ) logger . warn ( cause . getLocalizedMessage ( ) + "... WAITING ..." ) ; 
else if ( e instanceof DeploymentException ) throw new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; 
else logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
} 

public class TransactionContextImpl { 
protected void executeAfterCommitActions ( ) { 
if ( afterCommitActions != null ) { 
if ( trace ) logger . trace ( "Executing after commit actions" ) ; 
executeActions ( afterCommitActions , trace ) ; 
afterCommitActions = null ; 
} 
} 
} 

public class TransactionContextImpl { 
protected void executeAfterCommitPriorityActions ( ) { 
if ( afterCommitPriorityActions != null ) { 
if ( trace ) logger . trace ( "Executing after commit priority actions" ) ; 
executeActions ( afterCommitPriorityActions , trace ) ; 
afterCommitPriorityActions = null ; 
} 
} 
} 

public class TransactionContextImpl { 
protected void executeAfterRollbackActions ( ) { 
if ( afterRollbackActions != null ) { 
if ( trace ) logger . trace ( "Executing rollback actions" ) ; 
executeActions ( afterRollbackActions , trace ) ; 
afterRollbackActions = null ; 
} 
} 
} 

public class TransactionContextImpl { 
protected void executeBeforeCommitActions ( ) { 
if ( beforeCommitActions != null ) { 
if ( trace ) logger . trace ( "Executing before commit actions" ) ; 
executeActions ( beforeCommitActions , trace ) ; 
beforeCommitActions = null ; 
} 
} 
} 

public class TransactionContextImpl { 
protected void executeBeforeCommitPriorityActions ( ) { 
if ( beforeCommitPriorityActions != null ) { 
if ( trace ) logger . trace ( "Executing before commit priority actions" ) ; 
executeActions ( beforeCommitPriorityActions , trace ) ; 
beforeCommitPriorityActions = null ; 
} 
} 
} 

public class TracerStorage { 
public Tracer createTracer ( String tracerName , boolean requestedBySource ) { 
TracerImpl tparent = null ; 
TracerImpl t = tracers . get ( tracerName ) ; 
if ( t == null ) { 
String [ ] split = tracerName . split ( "\\." ) ; 
String currentName = "" ; 
for ( String s : split ) { 
if ( tparent == null ) { 
tparent = rootTracer ; 
currentName = s ; 
} 
else currentName = currentName + "." + s ; 
t = tracers . get ( currentName ) ; 
if ( t == null ) { 
t = new TracerImpl ( currentName , tparent , this . notificationSource , this . traceFacility ) ; 
final TracerImpl u = tracers . putIfAbsent ( t . getTracerName ( ) , t ) ; 
if ( u != null ) t = u ; 
} 
tparent = t ; 
} 
} 
if ( requestedBySource ) t . setRequestedBySource ( requestedBySource ) ; 
return t ; 
} 
} 

public class SleeComponentWithUsageParametersClassCodeGenerator { 
public void process ( SleeComponentWithUsageParametersInterface component ) throws DeploymentException { 
ClassPool classPool = component . getClassPool ( ) ; 
String deploymentDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
Class < ? > usageParametersInterface = component . getUsageParametersInterface ( ) ; 
if ( usageParametersInterface != null ) try { 
component . setUsageParametersConcreteClass ( new ConcreteUsageParameterClassGenerator ( usageParametersInterface . getName ( ) , deploymentDir , classPool ) . generateConcreteUsageParameterClass ( ) ) ; 
if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "Generated usage parameter impl class for " + component ) ; 
new ConcreteUsageParameterMBeanGenerator ( component ) . generateConcreteUsageParameterMBean ( ) ; 
if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "Generated usage mbean (interface and impl) for " + component ) ; 
} 
catch ( DeploymentException ex ) { 
throw ex ; 
} 
catch ( Exception ex ) { 
throw new DeploymentException ( "Failed to generate " + component + " usage parameter class" , ex ) ; 
} 
} 
} 

public class SbbObjectPoolManagementImpl { 
public void createObjectPool ( final ServiceID serviceID , final SbbComponent sbbComponent , final SleeTransactionManager sleeTransactionManager ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Creating Pool for  " + serviceID + " and " + sbbComponent ) ; 
createObjectPool ( serviceID , sbbComponent ) ; 
if ( sleeTransactionManager != null && sleeTransactionManager . getTransactionContext ( ) != null ) { 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Due to tx rollback, removing pool for " + serviceID + " and " + sbbComponent ) ; 
try { 
removeObjectPool ( serviceID , sbbComponent . getSbbID ( ) ) ; 
} 
catch ( Throwable e ) { 
logger . error ( "Failed to remove " + serviceID + " and " + sbbComponent + " object pool" , e ) ; 
} 
} 
} 
; 
sleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; 
} 
} 
} 

public class SleeEndpointEndActivityNotTransactedExecutor { 
void execute ( final ActivityHandle handle ) throws UnrecognizedActivityHandleException { 
final SleeTransaction tx = super . suspendTransaction ( ) ; 
try { 
sleeEndpoint . _endActivity ( handle , tx ) ; 
} 
finally { 
if ( tx != null ) super . resumeTransaction ( tx ) ; 
} 
} 
} 

public class SleeEndpointImpl { 
ActivityContextHandle _startActivity ( ActivityHandle handle , int activityFlags , final SleeTransaction barrierTx ) { 
ActivityContext ac = null ; 
if ( raEntity . getHandleReferenceFactory ( ) != null && ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) { 
final ActivityHandleReference reference = raEntity . getHandleReferenceFactory ( ) . createActivityHandleReference ( handle ) ; 
try { 
ac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , reference ) , activityFlags ) ; 
} 
catch ( ActivityAlreadyExistsException e ) { 
throw e ; 
} 
catch ( RuntimeException e ) { 
raEntity . getHandleReferenceFactory ( ) . removeActivityHandleReference ( reference ) ; 
throw e ; 
} 
} 
else ac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) , activityFlags ) ; 
if ( barrierTx != null && ac != null ) { 
final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; 
aeqm . createBarrier ( barrierTx ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
aeqm . removeBarrier ( barrierTx ) ; 
} 
} 
; 
final TransactionContext tc = barrierTx . getTransactionContext ( ) ; 
tc . getAfterCommitActions ( ) . add ( action ) ; 
tc . getAfterRollbackActions ( ) . add ( action ) ; 
} 
return ac . getActivityContextHandle ( ) ; 
} 
} 

public class SleeEndpointImpl { 
void _endActivity ( ActivityHandle handle , final SleeTransaction barrierTx ) throws UnrecognizedActivityHandleException { 
final ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; 
final ActivityContext ac = acFactory . getActivityContext ( ach ) ; 
if ( ac != null ) { 
if ( barrierTx != null ) { 
final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; 
aeqm . createBarrier ( barrierTx ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
aeqm . removeBarrier ( barrierTx ) ; 
} 
} 
; 
final TransactionContext tc = barrierTx . getTransactionContext ( ) ; 
tc . getAfterCommitActions ( ) . add ( action ) ; 
tc . getAfterRollbackActions ( ) . add ( action ) ; 
} 
ac . endActivity ( ) ; 
} 
else throw new UnrecognizedActivityHandleException ( handle . toString ( ) ) ; 
} 
} 

public class SleeEndpointImpl { 
private void checkFireEventPreconditions ( ActivityHandle handle , FireableEventType eventType , Object event ) throws NullPointerException , IllegalEventException , IllegalStateException { 
if ( event == null ) throw new NullPointerException ( "event is null" ) ; 
if ( handle == null ) throw new NullPointerException ( "handle is null" ) ; 
if ( eventType == null ) throw new NullPointerException ( "eventType is null" ) ; 
final EventTypeComponent eventTypeComponent = componentRepository . getComponentByID ( eventType . getEventType ( ) ) ; 
if ( eventTypeComponent == null ) throw new IllegalEventException ( "event type not installed (more on SLEE 1.1 specs 15.14.8)" ) ; 
if ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) throw new IllegalEventException ( "the class of the event object fired is not assignable to the event class of the event type (more on SLEE 1.1 specs 15.14.8) " ) ; 
if ( eventType . getClass ( ) != FireableEventTypeImpl . class ) throw new IllegalEventException ( "unknown implementation of FireableEventType" ) ; 
if ( raEntity . getAllowedEventTypes ( ) != null && ! raEntity . getAllowedEventTypes ( ) . contains ( eventType . getEventType ( ) ) ) throw new IllegalEventException ( "Resource Adaptor configured to not ignore ra type event checking and the event " + eventType . getEventType ( ) + " does not belongs to any of the ra types implemented by the resource adaptor" ) ; 
} 
} 

public class SleeEndpointImpl { 
void _fireEvent ( ActivityHandle realHandle , ActivityHandle refHandle , FireableEventType eventType , Object event , Address address , ReceivableService receivableService , int eventFlags , final SleeTransaction barrierTx ) throws ActivityIsEndingException , SLEEException { 
final ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , refHandle ) ; 
final ActivityContext ac = acFactory . getActivityContext ( ach ) ; 
if ( ac == null ) throw new UnrecognizedActivityHandleException ( "Unable to fire " + eventType . getEventType ( ) + " on activity handle " + realHandle + " , the handle is not mapped to an activity context" ) ; 
else { 
if ( barrierTx != null ) { 
final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; 
aeqm . createBarrier ( barrierTx ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
aeqm . removeBarrier ( barrierTx ) ; 
} 
} 
; 
final TransactionContext tc = barrierTx . getTransactionContext ( ) ; 
tc . getAfterCommitActions ( ) . add ( action ) ; 
tc . getAfterRollbackActions ( ) . add ( action ) ; 
} 
final EventProcessingCallbacks callbacks = new EventProcessingCallbacks ( realHandle , eventType , event , address , receivableService , eventFlags , raEntity ) ; 
final EventProcessingSucceedCallback succeedCallback = EventFlags . hasRequestProcessingSuccessfulCallback ( eventFlags ) ? callbacks : null ; 
final EventProcessingFailedCallback failedCallback = EventFlags . hasRequestProcessingFailedCallback ( eventFlags ) ? callbacks : null ; 
final EventUnreferencedCallback unreferencedCallback = EventFlags . hasRequestEventReferenceReleasedCallback ( eventFlags ) ? callbacks : null ; 
ac . fireEvent ( eventType . getEventType ( ) , event , address , receivableService == null ? null : receivableService . getService ( ) , succeedCallback , failedCallback , unreferencedCallback ) ; 
} 
} 
} 

public class ConcreteSbbLocalObjectGenerator { 
public Class generateSbbLocalObjectConcreteClass ( ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "generateSbbLocalObjectConcreteClass: sbbLocalObjectInterface = " + sbbLocalObjectName + " deployPath = " + deployPath ) ; 
try { 
concreteSbbLocalObject = pool . makeClass ( ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_PREFIX + sbbLocalObjectName + ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_SUFFIX ) ; 
try { 
sleeSbbLocalObject = pool . get ( SbbLocalObjectImpl . class . getName ( ) ) ; 
sbbLocalObjectInterface = pool . get ( sbbLocalObjectName ) ; 
} 
catch ( NotFoundException nfe ) { 
nfe . printStackTrace ( ) ; 
String s = "Problem with pool " ; 
logger . error ( s , nfe ) ; 
throw new RuntimeException ( s , nfe ) ; 
} 
CtClass concreteClassInterface ; 
try { 
concreteClassInterface = pool . get ( SbbLocalObjectConcrete . class . getName ( ) ) ; 
} 
catch ( NotFoundException nfe ) { 
nfe . printStackTrace ( ) ; 
String s = "Problem with the pool! " ; 
logger . error ( s , nfe ) ; 
throw new RuntimeException ( s , nfe ) ; 
} 
ConcreteClassGeneratorUtils . createInterfaceLinks ( concreteSbbLocalObject , new CtClass [ ] { 
sbbLocalObjectInterface , concreteClassInterface } 
) ; 
ConcreteClassGeneratorUtils . createInheritanceLink ( concreteSbbLocalObject , sleeSbbLocalObject ) ; 
Map interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( sbbLocalObjectInterface ) ; 
generateConcreteMethods ( interfaceMethods , sbbAbstractClassName ) ; 
try { 
concreteSbbLocalObject . writeFile ( deployPath ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Concrete Class " + concreteSbbLocalObject . getName ( ) + " generated in the following path " + deployPath ) ; 
} 
catch ( CannotCompileException e ) { 
String s = " Unexpected exception ! " ; 
logger . fatal ( s , e ) ; 
throw new RuntimeException ( s , e ) ; 
} 
catch ( IOException e ) { 
String s = "IO Exception!" ; 
logger . error ( s , e ) ; 
return null ; 
} 
try { 
return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteSbbLocalObject . getName ( ) ) ; 
} 
catch ( ClassNotFoundException e ) { 
logger . error ( "unable to load sbb local object impl class" , e ) ; 
return null ; 
} 
} 
finally { 
if ( this . concreteSbbLocalObject != null ) this . concreteSbbLocalObject . defrost ( ) ; 
} 
} 
} 

public class AccessorOperation { 
protected void makeGetter ( ) { 
if ( fieldClass . equals ( boolean . class ) || fieldClass . equals ( Boolean . class ) ) super . operationName = "is" + this . beanFieldName ; 
else super . operationName = "get" + this . beanFieldName ; 
} 
} 

public class AccessorOperation { 
protected Object convert ( String optArg ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException , CommandException { 
if ( fieldClass . isPrimitive ( ) ) { 
if ( fieldClass . equals ( int . class ) ) return new Integer ( optArg ) ; 
else if ( fieldClass . equals ( long . class ) ) return new Long ( optArg ) ; 
else if ( fieldClass . equals ( int . class ) ) return new Integer ( optArg ) ; 
else if ( fieldClass . equals ( byte . class ) ) return new Byte ( optArg ) ; 
else if ( fieldClass . equals ( short . class ) ) return new Short ( optArg ) ; 
else if ( fieldClass . equals ( float . class ) ) return new Float ( optArg ) ; 
else if ( fieldClass . equals ( double . class ) ) return new Double ( optArg ) ; 
else if ( fieldClass . equals ( boolean . class ) ) return new Boolean ( optArg ) ; 
else if ( fieldClass . equals ( char . class ) ) return new Character ( optArg . charAt ( 0 ) ) ; 
throw new CommandException ( "Unpredicted place. Please report." ) ; 
} 
else if ( isClassNumber ( ) ) { 
Constructor < ? > con = fieldClass . getConstructor ( String . class ) ; 
return con . newInstance ( optArg ) ; 
} 
return optArg ; 
} 
} 

public class DeployableUnitInstallPanel { 
private String extractMessage ( String result ) { 
String startPreTag = "<pre>" ; 
String endPreTag = "</pre>" ; 
result = result . trim ( ) ; 
if ( result . startsWith ( startPreTag ) && result . endsWith ( endPreTag ) ) result = result . substring ( startPreTag . length ( ) , result . length ( ) - endPreTag . length ( ) ) ; 
return result ; 
} 
} 

public class ChildRelationImpl { 
public boolean contains ( Object object ) { 
if ( ! ( object instanceof SbbLocalObject ) ) return false ; 
final SbbLocalObjectImpl sbblocal = ( SbbLocalObjectImpl ) object ; 
final SbbEntityID sbbEntityId = sbblocal . getSbbEntityId ( ) ; 
if ( ! idBelongsToChildRelation ( sbbEntityId ) ) return false ; 
return new SbbEntityCacheData ( sbbEntityId , sleeContainer . getCluster ( ) . getMobicentsCache ( ) ) . exists ( ) ; 
} 
} 

public class ChildRelationImpl { 
@ SuppressWarnings ( "rawtypes" ) public boolean containsAll ( Collection c ) { 
if ( c == null ) throw new NullPointerException ( "null collection!" ) ; 
for ( Iterator it = c . iterator ( ) ; 
it . hasNext ( ) ; 
) if ( ! contains ( it . next ( ) ) ) return false ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "containsAll : collection = " + c + " > all in child relation" ) ; 
return true ; 
} 
} 

public class ChildRelationImpl { 
@ SuppressWarnings ( "rawtypes" ) public boolean removeAll ( Collection c ) { 
boolean flag = true ; 
if ( c == null ) throw new NullPointerException ( " null collection ! " ) ; 
for ( Iterator it = c . iterator ( ) ; 
it . hasNext ( ) ; 
) flag &= this . remove ( it . next ( ) ) ; 
return flag ; 
} 
} 

public class ClassPool { 
public void clean ( ) { 
for ( ClassPath classPath : classPaths ) { 
classPool . removeClassPath ( classPath ) ; 
} 
for ( String classMade : classesMade ) { 
try { 
classPool . get ( classMade ) . detach ( ) ; 
} 
catch ( NotFoundException e ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Failed to detach class " + classMade + " from class pool" , e ) ; 
} 
} 
} 
} 

public class ProfileCallRecorderTransactionData { 
@ SuppressWarnings ( "unchecked" ) public static void addProfileCall ( ProfileObjectImpl po ) throws SLEEException { 
SleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; 
try { 
if ( sleeTransactionManager . getTransaction ( ) == null ) return ; 
} 
catch ( SystemException se ) { 
throw new SLEEException ( "Unable to verify SLEE Transaction." , se ) ; 
} 
String key = makeKey ( po ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Recording call to profile. Key[" + key + "]" ) ; 
final TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; 
ProfileCallRecorderTransactionData data = ( ProfileCallRecorderTransactionData ) txContext . getData ( ) . get ( TRANSACTION_CONTEXT_KEY ) ; 
if ( data == null ) { 
data = new ProfileCallRecorderTransactionData ( ) ; 
txContext . getData ( ) . put ( TRANSACTION_CONTEXT_KEY , data ) ; 
} 
if ( ! po . isProfileReentrant ( ) ) { 
if ( data . invokedProfiles . contains ( key ) && data . invokedProfiles . getLast ( ) . compareTo ( key ) != 0 ) throw new SLEEException ( "Detected loopback call. Call sequence: " + data . invokedProfiles ) ; 
data . invokedProfiles . add ( key ) ; 
data . invokedProfileTablesNames . add ( po . getProfileTable ( ) . getProfileTableName ( ) ) ; 
} 
} 
} 

public class ProfileTableTransactionView { 
public static void passivateProfileObjectOnTxEnd ( SleeTransactionManager txManager , final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { 
TransactionalAction afterRollbackAction = new TransactionalAction ( ) { 
public void execute ( ) { 
profileObject . invalidateObject ( ) ; 
pool . returnObject ( profileObject ) ; 
} 
} 
; 
TransactionalAction beforeCommitAction = new TransactionalAction ( ) { 
public void execute ( ) { 
if ( profileObject . getState ( ) == ProfileObjectState . READY ) { 
if ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) { 
profileObject . fireAddOrUpdatedEventIfNeeded ( ) ; 
profileObject . profilePassivate ( ) ; 
} 
else profileObject . profileRemove ( true , false ) ; 
pool . returnObject ( profileObject ) ; 
} 
} 
} 
; 
final TransactionContext txContext = txManager . getTransactionContext ( ) ; 
txContext . getAfterRollbackActions ( ) . add ( afterRollbackAction ) ; 
txContext . getBeforeCommitActions ( ) . add ( beforeCommitAction ) ; 
} 
} 

public class ComponentIDArrayPropertyEditor { 
public void setAsText ( String text ) { 
if ( text == null || text . equals ( "" ) ) super . setValue ( new ComponentID [ 0 ] ) ; 
else { 
java . util . ArrayList results = new java . util . ArrayList ( ) ; 
java . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; 
ComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; 
while ( st . hasMoreTokens ( ) ) { 
cidPropEditor . setAsText ( st . nextToken ( ) ) ; 
if ( st . hasMoreTokens ( ) ) st . nextToken ( ) ; 
results . add ( cidPropEditor . getValue ( ) ) ; 
} 
ComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; 
results . toArray ( cid ) ; 
this . setValue ( cid ) ; 
} 
} 
} 

public class ConcreteActivityContextInterfaceGenerator { 
public Class generateActivityContextInterfaceConcreteClass ( ) throws DeploymentException { 
String tmpClassName = ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_PREFIX + activityContextInterfaceName + ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_SUFFIX ; 
concreteActivityContextInterface = pool . makeClass ( tmpClassName ) ; 
CtClass sbbActivityContextInterface = null ; 
try { 
activityContextInterface = pool . get ( activityContextInterfaceName ) ; 
sbbActivityContextInterface = pool . get ( SbbActivityContextInterfaceImpl . class . getName ( ) ) ; 
} 
catch ( NotFoundException nfe ) { 
throw new DeploymentException ( "Could not find aci " + activityContextInterfaceName , nfe ) ; 
} 
ConcreteClassGeneratorUtils . createInheritanceLink ( concreteActivityContextInterface , sbbActivityContextInterface ) ; 
ConcreteClassGeneratorUtils . createInterfaceLinks ( concreteActivityContextInterface , new CtClass [ ] { 
activityContextInterface } 
) ; 
Map interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( activityContextInterface ) ; 
generateConcreteMethods ( interfaceMethods ) ; 
String sbbDeploymentPathStr = deployDir ; 
try { 
concreteActivityContextInterface . writeFile ( sbbDeploymentPathStr ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Concrete Class " + tmpClassName + " generated in the following path " + sbbDeploymentPathStr ) ; 
} 
catch ( Exception e ) { 
logger . error ( "problem generating concrete class" , e ) ; 
throw new DeploymentException ( "problem generating concrete class! " , e ) ; 
} 
Class clazz = null ; 
try { 
clazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( tmpClassName ) ; 
} 
catch ( Exception e1 ) { 
logger . error ( "problem loading generated class" , e1 ) ; 
throw new DeploymentException ( "problem loading the generated class! " , e1 ) ; 
} 
this . concreteActivityContextInterface . defrost ( ) ; 
return clazz ; 
} 
} 

public class ConcreteActivityContextInterfaceGenerator { 
private void generateConcreteMethods ( Map interfaceMethods ) { 
if ( interfaceMethods == null ) return ; 
Iterator it = interfaceMethods . values ( ) . iterator ( ) ; 
while ( it . hasNext ( ) ) { 
CtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; 
if ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; 
try { 
CtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; 
String fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; 
fieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; 
String concreteMethodBody = null ; 
if ( interfaceMethod . getName ( ) . startsWith ( "get" ) ) concreteMethodBody = "{ return ($r)getFieldValue(\"" + fieldName + "\"," + concreteMethod . getReturnType ( ) . getName ( ) + ".class); }" ; 
else if ( interfaceMethod . getName ( ) . startsWith ( "set" ) ) concreteMethodBody = "{ setFieldValue(\"" + fieldName + "\",$1); }" ; 
else throw new SLEEException ( "unexpected method name <" + interfaceMethod . getName ( ) + "> to implement in sbb aci interface" ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Generated method " + interfaceMethod . getName ( ) + " , body = " + concreteMethodBody ) ; 
concreteMethod . setBody ( concreteMethodBody ) ; 
concreteActivityContextInterface . addMethod ( concreteMethod ) ; 
} 
catch ( Exception cce ) { 
throw new SLEEException ( "Cannot compile method " + interfaceMethod . getName ( ) , cce ) ; 
} 
} 
} 
} 

public class ActivityContextImpl { 
public void setDataAttribute ( String key , Object newValue ) { 
cacheData . setCmpAttribute ( key , newValue ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Activity context with handle " + getActivityContextHandle ( ) + " set cmp attribute named " + key + " to value " + newValue ) ; 
} 
} 

public class ActivityContextImpl { 
public void addNameBinding ( String aciName ) { 
cacheData . nameBound ( aciName ) ; 
if ( acReferencesHandler != null ) acReferencesHandler . nameReferenceCreated ( ) ; 
} 
} 

public class ActivityContextImpl { 
public boolean removeNameBinding ( String aciName ) { 
boolean removed = cacheData . nameUnbound ( aciName ) ; 
if ( removed && acReferencesHandler != null ) acReferencesHandler . nameReferenceRemoved ( ) ; 
return removed ; 
} 
} 

public class ActivityContextImpl { 
public boolean attachTimer ( TimerID timerID ) { 
if ( cacheData . attachTimer ( timerID ) ) { 
if ( acReferencesHandler != null ) acReferencesHandler . timerReferenceCreated ( ) ; 
return true ; 
} 
else return false ; 
} 
} 

public class ActivityContextImpl { 
public boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { 
boolean attached = cacheData . attachSbbEntity ( sbbEntityId ) ; 
if ( attached ) if ( acReferencesHandler != null ) acReferencesHandler . sbbeReferenceCreated ( false ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Attachement from sbb entity " + sbbEntityId + " to AC " + getActivityContextHandle ( ) + " result: " + attached ) ; 
return attached ; 
} 
} 

public class ActivityContextImpl { 
public void detachSbbEntity ( SbbEntityID sbbEntityId ) throws javax . slee . TransactionRequiredLocalException { 
boolean detached = cacheData . detachSbbEntity ( sbbEntityId ) ; 
if ( detached && acReferencesHandler != null && ! isEnding ( ) ) { 
acReferencesHandler . sbbeReferenceRemoved ( ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Detached sbb entity " + sbbEntityId + " from AC with handle " + getActivityContextHandle ( ) ) ; 
} 
} 
} 

public class ActivityContextImpl { 
public Set < SbbEntityID > getSortedSbbAttachmentSet ( Set < SbbEntityID > excludeSet ) { 
final Set < SbbEntityID > sbbAttachementSet = cacheData . getSbbEntitiesAttached ( ) ; 
Set < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; 
for ( SbbEntityID sbbEntityId : sbbAttachementSet ) { 
if ( ! excludeSet . contains ( sbbEntityId ) ) result . add ( sbbEntityId ) ; 
} 
if ( result . size ( ) > 1 ) result = sleeContainer . getSbbEntityFactory ( ) . sortByPriority ( result ) ; 
return result ; 
} 
} 

public class ActivityContextImpl { 
public void endActivity ( ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Ending activity context with handle " + getActivityContextHandle ( ) ) ; 
if ( cacheData . setEnding ( true ) ) fireEvent ( sleeContainer . getEventContextFactory ( ) . createActivityEndEventContext ( this , new ActivityEndEventUnreferencedCallback ( getActivityContextHandle ( ) , factory ) ) , sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ) ; 
} 
} 

public class DeployableUnit { 
public void addComponent ( DeployableComponent dc ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Adding Component " + dc . getComponentKey ( ) ) ; 
components . add ( dc ) ; 
componentIDs . add ( dc . getComponentKey ( ) ) ; 
dependencies . addAll ( dc . getDependencies ( ) ) ; 
installActions . addAll ( dc . getInstallActions ( ) ) ; 
Collection < ManagementAction > postInstallActionsStrings = postInstallActions . remove ( dc . getComponentKey ( ) ) ; 
if ( postInstallActionsStrings != null && ! postInstallActionsStrings . isEmpty ( ) ) installActions . addAll ( postInstallActionsStrings ) ; 
Collection < ManagementAction > preUninstallActionsStrings = preUninstallActions . remove ( dc . getComponentKey ( ) ) ; 
if ( preUninstallActionsStrings != null ) uninstallActions . addAll ( preUninstallActionsStrings ) ; 
uninstallActions . addAll ( dc . getUninstallActions ( ) ) ; 
} 
} 

public class DeployableUnit { 
public boolean hasDuplicates ( ) { 
ArrayList < String > duplicates = new ArrayList < String > ( ) ; 
for ( String componentId : componentIDs ) { 
if ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) . contains ( componentId ) ) duplicates . add ( componentId ) ; 
} 
if ( ! duplicates . isEmpty ( ) ) { 
logger . warn ( "The deployable unit '" + this . diShortName + "' contains components that are already deployed. The following are already installed:" ) ; 
for ( String dupComponent : duplicates ) { 
logger . warn ( " - " + dupComponent ) ; 
} 
return true ; 
} 
return false ; 
} 
} 

public class DeployableUnit { 
public Collection < ManagementAction > getInstallActions ( ) { 
ArrayList < ManagementAction > iActions = new ArrayList < ManagementAction > ( ) ; 
if ( ! postInstallActions . values ( ) . isEmpty ( ) ) for ( String componentId : postInstallActions . keySet ( ) ) { 
iActions . addAll ( postInstallActions . get ( componentId ) ) ; 
} 
iActions . addAll ( installActions ) ; 
return iActions ; 
} 
} 

public class DeployableUnit { 
public Collection < ManagementAction > getUninstallActions ( ) { 
Collection < ManagementAction > uActions = new ArrayList < ManagementAction > ( uninstallActions ) ; 
uActions . add ( new UninstallDeployableUnitAction ( diURL . toString ( ) , sleeContainerDeployer . getDeploymentMBean ( ) ) ) ; 
if ( ! preUninstallActions . values ( ) . isEmpty ( ) ) for ( String componentId : preUninstallActions . keySet ( ) ) { 
uActions . addAll ( preUninstallActions . get ( componentId ) ) ; 
} 
return uActions ; 
} 
} 

public class DeployableUnit { 
private boolean hasReferringDU ( ) throws Exception { 
SleeContainer sC = SleeContainer . lookupFromJndi ( ) ; 
for ( String componentIdString : this . getComponents ( ) ) { 
ComponentIDPropertyEditor cidpe = new ComponentIDPropertyEditor ( ) ; 
cidpe . setAsText ( componentIdString ) ; 
ComponentID componentId = ( ComponentID ) cidpe . getValue ( ) ; 
for ( ComponentID referringComponentId : sC . getComponentRepository ( ) . getReferringComponents ( componentId ) ) { 
ComponentIDPropertyEditor rcidpe = new ComponentIDPropertyEditor ( ) ; 
rcidpe . setValue ( referringComponentId ) ; 
String referringComponentIdString = rcidpe . getAsText ( ) ; 
if ( ! this . getComponents ( ) . contains ( referringComponentIdString ) ) return true ; 
} 
} 
return false ; 
} 
} 

public class AbstractProfileMBeanImpl { 
private void writeMode ( ) throws SLEEException , ManagementException { 
if ( ! isProfileWriteable ( ) ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Changing state to read-write, for profile mbean with name " + profileName + ", from table with name " + this . profileTable . getProfileTableName ( ) ) ; 
ProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; 
profileObject . getProfileEntity ( ) . setReadOnly ( false ) ; 
state = State . write ; 
} 
else if ( logger . isDebugEnabled ( ) ) logger . debug ( "Already in write state, for profile mbean with name " + profileName + ", from table with name " + this . profileTable . getProfileTableName ( ) ) ; 
} 
} 

public class AbstractProfileMBeanImpl { 
protected void beforeSetCmpField ( ) throws ManagementException , InvalidStateException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "beforeSetCmpField() on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; 
if ( isProfileWriteable ( ) ) try { 
sleeContainer . getTransactionManager ( ) . resume ( transaction ) ; 
} 
catch ( Throwable e ) { 
throw new ManagementException ( e . getMessage ( ) , e ) ; 
} 
else throw new InvalidStateException ( ) ; 
} 
} 

public class AbstractProfileMBeanImpl { 
protected void afterSetCmpField ( ) throws ManagementException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "afterSetCmpField() on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; 
try { 
sleeContainer . getTransactionManager ( ) . suspend ( ) ; 
} 
catch ( Throwable e ) { 
throw new ManagementException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class AbstractProfileMBeanImpl { 
protected boolean beforeGetCmpField ( ) throws ManagementException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "beforeGetCmpField() on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; 
return beforeNonSetCmpField ( ) ; 
} 
} 

public class AbstractProfileMBeanImpl { 
protected void afterGetCmpField ( boolean activatedTransaction ) throws ManagementException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "afterGetCmpField( activatedTransaction = " + activatedTransaction + " ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; 
afterNonSetCmpField ( activatedTransaction ) ; 
} 
} 

public class AbstractProfileMBeanImpl { 
protected boolean beforeManagementMethodInvocation ( ) throws ManagementException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "beforeManagementMethodInvocation() on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; 
jndiManagement = sleeContainer . getJndiManagement ( ) ; 
jndiManagement . pushJndiContext ( profileTable . getProfileSpecificationComponent ( ) ) ; 
return beforeNonSetCmpField ( ) ; 
} 
} 

public class AbstractProfileMBeanImpl { 
protected void afterManagementMethodInvocation ( boolean activatedTransaction ) throws ManagementException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "afterManagementMethodInvocation( activatedTransaction = " + activatedTransaction + " ) on profile with name " + profileName + " of table " + profileTable . getProfileTableName ( ) ) ; 
afterNonSetCmpField ( activatedTransaction ) ; 
jndiManagement . popJndiContext ( ) ; 
} 
} 

public class DeployableUnitImpl { 
private void deletePath ( File path ) { 
if ( path . isDirectory ( ) ) { 
File [ ] files = path . listFiles ( ) ; 
if ( files != null ) for ( File file : files ) { 
deletePath ( file ) ; 
} 
} 
path . delete ( ) ; 
} 
} 

public class ConcreteSbbGenerator { 
private void createDefaultUsageParameterGetter ( CtClass sbbConcrete ) throws DeploymentException { 
String methodName = "getDefaultSbbUsageParameterSet" ; 
CtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; 
if ( method == null ) method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; 
if ( method != null ) try { 
CtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; 
String concreteMethodBody = "{ return ($r)" + SbbAbstractMethodHandler . class . getName ( ) + ".getDefaultSbbUsageParameterSet(sbbEntity); }" ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Generated method " + methodName + " , body = " + concreteMethodBody ) ; 
concreteMethod . setBody ( concreteMethodBody ) ; 
sbbConcreteClass . addMethod ( concreteMethod ) ; 
} 
catch ( CannotCompileException cce ) { 
throw new SLEEException ( "Cannot compile method " + method . getName ( ) , cce ) ; 
} 
} 
} 

public class ConcreteSbbGenerator { 
protected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { 
if ( mEventEntries == null ) return ; 
for ( EventEntryDescriptor mEventEntry : mEventEntries ) { 
if ( mEventEntry . isFired ( ) ) { 
String methodName = "fire" + mEventEntry . getEventName ( ) ; 
CtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; 
if ( method == null ) method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; 
if ( method != null ) try { 
CtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; 
String concreteMethodBody = "{" ; 
concreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; 
concreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + ".fireEvent(sbbEntity,eventTypeID" ; 
for ( int i = 0 ; 
i < method . getParameterTypes ( ) . length ; 
i ++ ) concreteMethodBody += ",$" + ( i + 1 ) ; 
concreteMethodBody += ");}" ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Generated method " + methodName + " , body = " + concreteMethodBody ) ; 
concreteMethod . setBody ( concreteMethodBody ) ; 
sbbConcreteClass . addMethod ( concreteMethod ) ; 
} 
catch ( Exception e ) { 
throw new SLEEException ( "Cannot compile method " + method . getName ( ) , e ) ; 
} 
} 
} 
} 
} 

public class ConcreteSbbGenerator { 
protected void createGetSbbActivityContextInterfaceMethod ( CtClass activityContextInterface , Class < ? > concreteActivityContextInterfaceClass ) throws DeploymentException { 
String methodToAdd = "public " + activityContextInterface . getName ( ) + " asSbbActivityContextInterface(javax.slee.ActivityContextInterface aci) {" + "if(aci==null)" + "     throw new " + IllegalStateException . class . getName ( ) + "(\"Passed argument can not be of null value.\");" + " if(sbbEntity == null || sbbEntity.getSbbObject().getState() != " + SbbObjectState . class . getName ( ) + ".READY) { throw new " + IllegalStateException . class . getName ( ) + "(\"Cannot call asSbbActivityContextInterface\"); } " + "else if ( aci instanceof " + concreteActivityContextInterfaceClass . getName ( ) + ") return aci;" + "else return  new " + concreteActivityContextInterfaceClass . getName ( ) + " ( (" + ActivityContextInterface . class . getName ( ) + ") $1, " + "sbbEntity.getSbbComponent());" + "}" ; 
CtMethod methodTest ; 
try { 
methodTest = CtNewMethod . make ( methodToAdd , sbbConcreteClass ) ; 
sbbConcreteClass . addMethod ( methodTest ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Method " + methodToAdd + " added" ) ; 
} 
catch ( CannotCompileException e ) { 
throw new DeploymentException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class CompositeQueryExpression { 
protected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { 
if ( expr == null ) throw new NullPointerException ( "expr is null" ) ; 
if ( expr instanceof CompositeQueryExpression ) ( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; 
else if ( expr instanceof Not ) ( ( Not ) expr ) . checkForCycles ( this ) ; 
exprs . add ( expr ) ; 
} 
} 

public class SbbAbstractClassDecorator { 
public boolean decorateAbstractSbb ( ) throws DeploymentException { 
ClassPool pool = component . getClassPool ( ) ; 
String sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; 
try { 
sbbAbstractClass = pool . get ( sbbAbstractClassName ) ; 
} 
catch ( NotFoundException nfe ) { 
throw new DeploymentException ( "Could not find Abstract Sbb Class: " + sbbAbstractClassName , nfe ) ; 
} 
concreteMethods = new HashMap ( ) ; 
CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) { 
int mods = methods [ i ] . getModifiers ( ) ; 
if ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) concreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; 
} 
decorateENCBindCalls ( ) ; 
decorateNewThreadCalls ( ) ; 
if ( isAbstractSbbClassDecorated ) { 
try { 
String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
sbbAbstractClass . writeFile ( deployDir ) ; 
sbbAbstractClass . detach ( ) ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Modified Abstract Class " + sbbAbstractClass . getName ( ) + " generated in the following path " + deployDir ) ; 
} 
catch ( Throwable e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
finally { 
sbbAbstractClass . defrost ( ) ; 
} 
return true ; 
} 
else return false ; 
} 
} 

public class SbbActivityContextInterfaceImpl { 
public Object getFieldValue ( String fieldName , Class < ? > returnType ) { 
String realFieldName = getRealFieldName ( fieldName ) ; 
Object value = aciImpl . getActivityContext ( ) . getDataAttribute ( realFieldName ) ; 
if ( value == null ) if ( returnType . isPrimitive ( ) ) if ( returnType . equals ( Integer . TYPE ) ) return Integer . valueOf ( 0 ) ; 
else if ( returnType . equals ( Boolean . TYPE ) ) return Boolean . FALSE ; 
else if ( returnType . equals ( Long . TYPE ) ) return Long . valueOf ( 0 ) ; 
else if ( returnType . equals ( Double . TYPE ) ) return Double . valueOf ( 0 ) ; 
else if ( returnType . equals ( Float . TYPE ) ) return Float . valueOf ( 0 ) ; 
return value ; 
} 
} 

public class ProfileObjectImpl { 
public void setProfileContext ( ProfileContextImpl profileContext ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "[setProfileContext] " + this ) ; 
if ( profileContext == null ) throw new NullPointerException ( "Passed context must not be null." ) ; 
if ( state != ProfileObjectState . DOES_NOT_EXIST ) throw new IllegalStateException ( "Wrong state: " + this . state + ",on profile set context operation, for profile table: " + this . profileTable . getProfileTableName ( ) + " with specification: " + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ) ; 
this . profileContext = profileContext ; 
this . profileContext . setProfileObject ( this ) ; 
if ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { 
final ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; 
try { 
final ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; 
if ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { 
public Object run ( ) { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
return null ; 
} 
} 
) ; 
else Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
try { 
if ( isSlee11 ) try { 
profileConcrete . setProfileContext ( profileContext ) ; 
} 
catch ( RuntimeException e ) { 
runtimeExceptionOnProfileInvocation ( e ) ; 
} 
} 
catch ( Exception e ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Exception encountered while setting profile context for profile table: " + this . profileTable . getProfileTableName ( ) + " with specification: " + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) , e ) ; 
} 
} 
finally { 
if ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { 
public Object run ( ) { 
Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; 
return null ; 
} 
} 
) ; 
else Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; 
} 
} 
state = ProfileObjectState . POOLED ; 
} 
} 

public class ProfileObjectImpl { 
private void profileInitialize ( String profileName ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "[profileInitialize] " + this + " , profileName = " + profileName ) ; 
if ( this . state != ProfileObjectState . POOLED ) throw new SLEEException ( this . toString ( ) ) ; 
if ( profileName == null ) { 
profileEntity = profileEntityFramework . getProfileEntityFactory ( ) . newInstance ( profileTable . getProfileTableName ( ) , null ) ; 
this . state = ProfileObjectState . PROFILE_INITIALIZATION ; 
if ( profileConcreteClassInfo . isInvokeProfileInitialize ( ) ) try { 
profileConcrete . profileInitialize ( ) ; 
} 
catch ( RuntimeException e ) { 
runtimeExceptionOnProfileInvocation ( e ) ; 
} 
} 
else { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Copying state from default profile on object " + this ) ; 
profileEntity = cloneEntity ( profileTable . getDefaultProfileEntity ( ) ) ; 
profileEntity . setProfileName ( profileName ) ; 
} 
profileEntity . create ( ) ; 
profileEntity . setDirty ( true ) ; 
} 
} 

public class ProfileObjectImpl { 
public void unsetProfileContext ( ) { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "[unsetProfileContext] " + this ) ; 
if ( state == ProfileObjectState . POOLED && profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { 
final ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; 
try { 
final ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; 
if ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { 
public Object run ( ) { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
return null ; 
} 
} 
) ; 
else Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
if ( isSlee11 ) try { 
profileConcrete . unsetProfileContext ( ) ; 
} 
catch ( RuntimeException e ) { 
runtimeExceptionOnProfileInvocation ( e ) ; 
} 
profileContext . setProfileObject ( null ) ; 
state = ProfileObjectState . DOES_NOT_EXIST ; 
} 
finally { 
if ( System . getSecurityManager ( ) != null ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { 
public Object run ( ) { 
Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; 
return null ; 
} 
} 
) ; 
else Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; 
} 
} 
} 
} 

public class ProfileObjectImpl { 
public ProfileLocalObject getProfileLocalObject ( ) { 
final Class < ? > profileLocalObjectConcreteClass = profileTable . getProfileSpecificationComponent ( ) . getProfileLocalObjectConcreteClass ( ) ; 
ProfileLocalObject profileLocalObject = null ; 
if ( profileLocalObjectConcreteClass == null ) profileLocalObject = new ProfileLocalObjectImpl ( this ) ; 
else try { 
profileLocalObject = ( ProfileLocalObject ) profileLocalObjectConcreteClass . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; 
} 
catch ( Throwable e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
return profileLocalObject ; 
} 
} 

public class ProfileObjectImpl { 
public void fireAddOrUpdatedEventIfNeeded ( ) { 
if ( state == ProfileObjectState . READY ) if ( profileEntity . isDirty ( ) ) if ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { 
ActivityContext ac = profileTable . getActivityContext ( ) ; 
AbstractProfileEvent event = null ; 
if ( profileEntity . isCreate ( ) ) if ( persisted ) { 
event = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; 
persisted = false ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "firing profile added event for profile named " + profileEntity ) ; 
} 
else return ; 
else { 
event = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "firing profile updated event for profile named " + profileEntity ) ; 
} 
ac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; 
} 
} 
} 

public class ProfileObjectImpl { 
public AbstractProfileCmpSlee10Wrapper getProfileCmpSlee10Wrapper ( ) { 
if ( profileCmpSlee10Wrapper == null ) try { 
profileCmpSlee10Wrapper = ( AbstractProfileCmpSlee10Wrapper ) profileTable . getProfileSpecificationComponent ( ) . getProfileCmpSlee10WrapperClass ( ) . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; 
} 
catch ( Throwable e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
return profileCmpSlee10Wrapper ; 
} 
} 

public class ClassGeneratorUtils { 
public static CtClass createClass ( String className , String [ ] interfaces ) throws Exception { 
if ( className == null ) throw new NullPointerException ( "Class name cannot be null" ) ; 
CtClass clazz = classPool . makeClass ( className ) ; 
if ( interfaces != null && interfaces . length > 0 ) clazz . setInterfaces ( classPool . get ( interfaces ) ) ; 
return clazz ; 
} 
} 

public class ClassGeneratorUtils { 
public static void createInheritanceLink ( CtClass concreteClass , String superClassName ) { 
if ( superClassName != null && superClassName . length ( ) >= 0 ) try { 
concreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; 
} 
catch ( CannotCompileException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( NotFoundException e ) { 
e . printStackTrace ( ) ; 
} 
} 
} 

public class ClassGeneratorUtils { 
public static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) { 
if ( toAnnotate instanceof CtClass ) { 
CtClass classToAnnotate = ( CtClass ) toAnnotate ; 
ClassFile cf = classToAnnotate . getClassFile ( ) ; 
ConstPool cp = cf . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
if ( attr == null ) attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; 
Annotation a = new Annotation ( annotation , cp ) ; 
if ( memberValues != null ) addMemberValuesToAnnotation ( a , cp , memberValues ) ; 
attr . addAnnotation ( a ) ; 
cf . addAttribute ( attr ) ; 
} 
else if ( toAnnotate instanceof CtMethod ) { 
CtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; 
MethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; 
ConstPool cp = mi . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
if ( attr == null ) attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; 
Annotation a = new Annotation ( annotation , cp ) ; 
if ( memberValues != null ) addMemberValuesToAnnotation ( a , cp , memberValues ) ; 
attr . addAnnotation ( a ) ; 
mi . addAttribute ( attr ) ; 
} 
else if ( toAnnotate instanceof CtField ) { 
CtField fieldToAnnotate = ( CtField ) toAnnotate ; 
FieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; 
ConstPool cp = fi . getConstPool ( ) ; 
AnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; 
if ( attr == null ) attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; 
Annotation a = new Annotation ( annotation , cp ) ; 
if ( memberValues != null ) addMemberValuesToAnnotation ( a , cp , memberValues ) ; 
attr . addAnnotation ( a ) ; 
fi . addAttribute ( attr ) ; 
} 
else throw new UnsupportedOperationException ( "Unknown object type: " + toAnnotate . getClass ( ) ) ; 
} 
} 

public class AbstractActivityContextInterfaceFactory { 
protected ActivityContextInterface getACI ( Object activity ) throws NullPointerException , UnrecognizedActivityException , FactoryException { 
if ( activity == null ) throw new NullPointerException ( "null activity object" ) ; 
ActivityHandle handle = null ; 
for ( ResourceAdaptorEntity raEntity : sleeContainer . getResourceManagement ( ) . getResourceAdaptorEntitiesPerType ( resourceAdaptorTypeID ) ) { 
handle = raEntity . getResourceAdaptorObject ( ) . getActivityHandle ( activity ) ; 
if ( handle != null ) { 
ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; 
ActivityContext ac = sleeContainer . getActivityContextFactory ( ) . getActivityContext ( ach ) ; 
if ( ac != null ) return ac . getActivityContextInterface ( ) ; 
break ; 
} 
} 
throw new UnrecognizedActivityException ( activity . toString ( ) ) ; 
} 
} 

public class AbstractSleeComponent { 
public ClassPool getClassPool ( ) { 
if ( classPool == null ) { 
if ( classLoader == null ) throw new IllegalStateException ( "can't init javassit classpool, there is no class loader set for the component" ) ; 
classPool = new ClassPool ( ) ; 
classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain ) ) ; 
for ( ClassLoader domainDependencies : classLoaderDomain . getAllDependencies ( ) ) { 
classPool . appendClassPath ( new LoaderClassPath ( domainDependencies ) ) ; 
} 
classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain . getParent ( ) ) ) ; 
} 
return classPool ; 
} 
} 

public class AbstractSleeComponent { 
public void setDeployableUnit ( DeployableUnit deployableUnit ) throws AlreadyDeployedException { 
if ( this . deployableUnit != null ) throw new IllegalStateException ( "deployable unit already set. du = " + this . deployableUnit ) ; 
this . deployableUnit = deployableUnit ; 
if ( ! addToDeployableUnit ( ) ) throw new AlreadyDeployedException ( "unable to install du having multiple components with id " + getComponentID ( ) ) ; 
} 
} 

public class SleeEndpointStartActivityNotTransactedExecutor { 
void execute ( final ActivityHandle handle , final int activityFlags , boolean suspendActivity ) throws SLEEException { 
final SleeTransaction tx = super . suspendTransaction ( ) ; 
ActivityContextHandle ach = null ; 
try { 
ach = sleeEndpoint . _startActivity ( handle , activityFlags , suspendActivity ? tx : null ) ; 
} 
finally { 
if ( tx != null ) { 
super . resumeTransaction ( tx ) ; 
if ( ach != null && ActivityFlags . hasRequestSleeActivityGCCallback ( activityFlags ) ) acFactory . getActivityContext ( ach ) ; 
} 
} 
} 
} 

public class ClassUtils { 
public static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { 
Class returnValue = null ; 
if ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) return classOrInterfaceWithInterfaces ; 
for ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { 
if ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) returnValue = iface ; 
else returnValue = checkInterfaces ( iface , interfaceSearched ) ; 
if ( returnValue != null ) break ; 
} 
if ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { 
Class superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; 
if ( superClass != null ) returnValue = checkInterfaces ( superClass , interfaceSearched ) ; 
} 
return returnValue ; 
} 
} 

public class ClassUtils { 
public static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { 
HashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; 
Method [ ] methods = null ; 
Class [ ] superInterfaces ; 
superInterfaces = xInterfaceClass . getInterfaces ( ) ; 
for ( Class superInterface : superInterfaces ) { 
if ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; 
} 
methods = xInterfaceClass . getDeclaredMethods ( ) ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) abstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
return abstractMethods ; 
} 
} 

public class TraceMBeanImpl { 
public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { 
if ( tracerName . compareTo ( "" ) == 0 ) return ; 
StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , "." , true ) ; 
int fqdnPartIndex = 0 ; 
String lastToken = null ; 
while ( stringTokenizer . hasMoreTokens ( ) ) { 
String token = stringTokenizer . nextToken ( ) ; 
if ( lastToken == null ) lastToken = token ; 
if ( lastToken . compareTo ( token ) == 0 && token . compareTo ( "." ) == 0 ) throw new IllegalArgumentException ( "Passed tracer:" + tracerName + ", name for source: " + notificationSource + ", is illegal" ) ; 
if ( token . compareTo ( "." ) != 0 ) { 
for ( int charIndex = 0 ; 
charIndex < token . length ( ) ; 
charIndex ++ ) { 
Character c = token . charAt ( charIndex ) ; 
if ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { 
} 
else throw new IllegalArgumentException ( "Passed tracer:" + tracerName + " Token[" + token + "], name for source: " + notificationSource + ", is illegal, contains illegal character: " + charIndex ) ; 
} 
fqdnPartIndex ++ ; 
} 
lastToken = token ; 
} 
if ( lastToken . compareTo ( "." ) == 0 ) throw new IllegalArgumentException ( "Passed tracer:" + tracerName + ", name for source: " + notificationSource + ", is illegal" ) ; 
} 
} 

public class DeployableUnitBuilderImpl { 
private void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { 
for ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { 
if ( componentID instanceof EventTypeID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) throw new DependencyException ( "Component " + sleeComponent . getComponentID ( ) + " depends on " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
else if ( componentID instanceof LibraryID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) throw new DependencyException ( "Component " + sleeComponent . getComponentID ( ) + " depends on " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
else if ( componentID instanceof ProfileSpecificationID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) throw new DependencyException ( "Component " + sleeComponent . getComponentID ( ) + " depends on " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
else if ( componentID instanceof ResourceAdaptorID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) throw new DependencyException ( "Component " + sleeComponent . getComponentID ( ) + " depends on " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
else if ( componentID instanceof ResourceAdaptorTypeID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) throw new DependencyException ( "Component " + sleeComponent . getComponentID ( ) + " depends on " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
else if ( componentID instanceof SbbID ) if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) throw new DependencyException ( "Component " + sleeComponent . getComponentID ( ) + " depends on " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
else if ( componentID instanceof ServiceID ) throw new SLEEException ( "Component " + sleeComponent . getComponentID ( ) + " depends on a service component " + componentID + " which is not available in the component repository or in the deployable unit" ) ; 
} 
} 
} 

public class DeployableUnitBuilderImpl { 
private File createTempDUDeploymentDir ( File deploymentRoot , DeployableUnitID deployableUnitID ) { 
try { 
File tempFile = File . createTempFile ( "restcomm-slee-du-" , "" , deploymentRoot ) ; 
File tempDUDeploymentDir = new File ( tempFile . getAbsolutePath ( ) + "-contents" ) ; 
if ( ! tempDUDeploymentDir . exists ( ) ) tempDUDeploymentDir . mkdirs ( ) ; 
else throw new SLEEException ( "Dir " + tempDUDeploymentDir + " already exists, unable to create deployment dir for DU " + deployableUnitID ) ; 
tempFile . delete ( ) ; 
return tempDUDeploymentDir ; 
} 
catch ( IOException e ) { 
throw new SLEEException ( "Failed to create deployment dir for DU " + deployableUnitID , e ) ; 
} 
} 
} 

public class JPAProfileEntityFramework { 
@ SuppressWarnings ( "unchecked" ) private EntityManager getEntityManager ( ) { 
if ( txDataKey == null ) txDataKey = new StringBuilder ( "jpapef.em." ) . append ( component . getProfileSpecificationID ( ) ) . toString ( ) ; 
final TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; 
Map transactionContextData = txContext . getData ( ) ; 
EntityManager result = ( EntityManager ) transactionContextData . get ( txDataKey ) ; 
if ( result == null ) { 
result = entityManagerFactory . createEntityManager ( ) ; 
transactionContextData . put ( txDataKey , result ) ; 
} 
return result ; 
} 
} 

public class SleeManagementMBeanImpl { 
public void start ( ) throws InvalidStateException , ManagementException { 
try { 
final SleeStateChangeRequest startingRequest = new SleeStateChangeRequest ( ) { 
@ Override public void stateChanged ( SleeState oldState ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( generateMessageWithLogo ( "starting" ) ) ; 
notifyStateChange ( oldState , getNewState ( ) ) ; 
} 
@ Override public void requestCompleted ( ) { 
final SleeStateChangeRequest runningRequest = new SleeStateChangeRequest ( ) { 
private SleeState oldState ; 
@ Override public void stateChanged ( SleeState oldState ) { 
logger . info ( generateMessageWithLogo ( "started" ) ) ; 
this . oldState = oldState ; 
} 
@ Override public void requestCompleted ( ) { 
notifyStateChange ( oldState , getNewState ( ) ) ; 
} 
@ Override public boolean isBlockingRequest ( ) { 
return true ; 
} 
@ Override public SleeState getNewState ( ) { 
return SleeState . RUNNING ; 
} 
} 
; 
try { 
sleeContainer . setSleeState ( runningRequest ) ; 
} 
catch ( Throwable e ) { 
logger . error ( "Failed to set container in RUNNING state" , e ) ; 
try { 
stop ( false ) ; 
} 
catch ( Throwable f ) { 
logger . error ( "Failed to set container in STOPPED state, after failure to set in RUNNING state" , e ) ; 
} 
} 
} 
@ Override public boolean isBlockingRequest ( ) { 
return true ; 
} 
@ Override public SleeState getNewState ( ) { 
return SleeState . STARTING ; 
} 
} 
; 
sleeContainer . setSleeState ( startingRequest ) ; 
} 
catch ( InvalidStateException ex ) { 
throw ex ; 
} 
catch ( Exception ex ) { 
throw new ManagementException ( ex . getMessage ( ) , ex ) ; 
} 
} 
} 

public class Utility { 
public static ClassLoader switchSafelyClassLoader ( final ClassLoader cl , final ProfileObject po ) { 
ClassLoader _cl = null ; 
if ( System . getSecurityManager ( ) != null ) _cl = ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
public Object run ( ) { 
return _switchSafelyClassLoader ( cl , po ) ; 
} 
} 
) ; 
else _cl = _switchSafelyClassLoader ( cl , po ) ; 
return _cl ; 
} 
} 

public class ProfileLocalObjectImpl { 
protected void checkTransaction ( ) throws IllegalStateException { 
try { 
if ( ! sleeContainer . getTransactionManager ( ) . getTransaction ( ) . equals ( this . transaction ) ) throw new IllegalStateException ( ) ; 
} 
catch ( SystemException e ) { 
throw new IllegalStateException ( ) ; 
} 
} 
} 

public class AbstractProfileEvent { 
ProfileObjectImpl getProfileObjectValidInCurrentTransaction ( ProfileEntity profileEntity ) throws TransactionRequiredLocalException { 
final SleeTransactionManager txManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; 
txManager . mandateTransaction ( ) ; 
if ( txData == null ) txData = new HashMap < ProfileEntity , ProfileObjectImpl > ( ) ; 
ProfileObjectImpl profileObject = ( ProfileObjectImpl ) txData . get ( profileEntity ) ; 
if ( profileObject == null ) { 
profileEntity . setReadOnly ( true ) ; 
profileEntity . setDirty ( false ) ; 
ProfileObjectPool pool = profileManagement . getObjectPoolManagement ( ) . getObjectPool ( profileEntity . getTableName ( ) ) ; 
profileObject = pool . borrowObject ( ) ; 
profileObject . profileActivate ( profileEntity ) ; 
ProfileTableTransactionView . passivateProfileObjectOnTxEnd ( txManager , profileObject , pool ) ; 
txData . put ( profileEntity , profileObject ) ; 
} 
return profileObject ; 
} 
} 

public class TracerImpl { 
private String tracerNameToLog4JLoggerName ( String tracerName , NotificationSource notificationSource ) { 
final StringBuilder sb = new StringBuilder ( "javax.slee." ) . append ( notificationSource . toString ( ) ) ; 
if ( ! tracerName . equals ( ROOT_TRACER_NAME ) ) sb . append ( '.' ) . append ( tracerName ) ; 
return sb . toString ( ) ; 
} 
} 

public class TracerImpl { 
void syncLevelWithLog4j ( ) { 
Level log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; 
if ( level == null ) assignLog4JLevel ( log4jLevel ) ; 
else if ( tracerToLog4JLevel ( level ) != log4jLevel ) assignLog4JLevel ( log4jLevel ) ; 
if ( parent == null && level == null ) { 
logger . setLevel ( Level . INFO ) ; 
level = TraceLevel . INFO ; 
} 
resetCacheFlags ( false ) ; 
} 
} 

public class TracerImpl { 
private void assignLog4JLevel ( Level log4jLevel ) { 
if ( log4jLevel == null ) return ; 
if ( log4jLevel == Level . DEBUG ) level = TraceLevel . FINE ; 
else if ( log4jLevel == Level . INFO ) level = TraceLevel . INFO ; 
else if ( log4jLevel == Level . WARN ) level = TraceLevel . WARNING ; 
else if ( log4jLevel == Level . ERROR ) level = TraceLevel . SEVERE ; 
else if ( log4jLevel == Level . TRACE ) level = TraceLevel . FINEST ; 
else if ( log4jLevel == Level . OFF ) level = TraceLevel . OFF ; 
} 
} 

public class TracerImpl { 
void resetCacheFlags ( boolean resetChilds ) { 
if ( isTraceable ( TraceLevel . FINEST ) ) { 
finestEnabled = true ; 
finerEnabled = true ; 
fineEnabled = true ; 
configEnabled = true ; 
infoEnabled = true ; 
warningEnabled = true ; 
severeEnabled = true ; 
} 
else { 
finestEnabled = false ; 
if ( isTraceable ( TraceLevel . FINER ) ) { 
finerEnabled = true ; 
fineEnabled = true ; 
configEnabled = true ; 
infoEnabled = true ; 
warningEnabled = true ; 
severeEnabled = true ; 
} 
else { 
finerEnabled = false ; 
if ( isTraceable ( TraceLevel . FINE ) ) { 
fineEnabled = true ; 
configEnabled = true ; 
infoEnabled = true ; 
warningEnabled = true ; 
severeEnabled = true ; 
} 
else { 
fineEnabled = false ; 
if ( isTraceable ( TraceLevel . CONFIG ) ) { 
configEnabled = true ; 
infoEnabled = true ; 
warningEnabled = true ; 
severeEnabled = true ; 
} 
else if ( isTraceable ( TraceLevel . INFO ) ) { 
infoEnabled = true ; 
warningEnabled = true ; 
severeEnabled = true ; 
} 
else { 
infoEnabled = false ; 
if ( isTraceable ( TraceLevel . WARNING ) ) { 
warningEnabled = true ; 
severeEnabled = true ; 
} 
else { 
warningEnabled = false ; 
if ( isTraceable ( TraceLevel . SEVERE ) ) severeEnabled = true ; 
else severeEnabled = false ; 
} 
} 
} 
} 
} 
if ( resetChilds ) for ( TracerImpl child : childs ) { 
if ( child . level == null ) child . resetCacheFlags ( true ) ; 
} 
} 
} 

public class TracerImpl { 
void sendNotification ( javax . slee . facilities . TraceLevel level , String message , Throwable t ) { 
if ( ! isTraceable ( level ) ) return ; 
traceMBean . sendNotification ( new TraceNotification ( notificationSource . getNotificationSource ( ) . getTraceNotificationType ( ) , traceMBean , notificationSource . getNotificationSource ( ) , getTracerName ( ) , level , message , t , notificationSource . getNextSequence ( ) , System . currentTimeMillis ( ) ) ) ; 
} 
} 

public class TracerImpl { 
public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { 
if ( tracerName . equals ( "" ) ) return ; 
StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , "." , true ) ; 
String lastToken = null ; 
while ( stringTokenizer . hasMoreTokens ( ) ) { 
String token = stringTokenizer . nextToken ( ) ; 
if ( lastToken == null ) lastToken = token ; 
if ( lastToken . equals ( token ) && token . equals ( "." ) ) throw new InvalidArgumentException ( "Passed tracer:" + tracerName + ", name for source: " + notificationSource + ", is illegal" ) ; 
lastToken = token ; 
} 
if ( lastToken . equals ( "." ) ) throw new IllegalArgumentException ( "Passed tracer:" + tracerName + ", name for source: " + notificationSource + ", is illegal" ) ; 
} 
} 

public class URLClassLoaderDomainImpl { 
protected Class < ? > findClassLocally ( String name ) throws ClassNotFoundException { 
if ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + " findClassLocally: " + name ) ; 
final boolean acquiredLock = acquireGlobalLock ( ) ; 
try { 
return findClassLocallyLocked ( name ) ; 
} 
finally { 
if ( acquiredLock ) releaseGlobalLock ( ) ; 
} 
} 
} 

public class ProfileProvisioningMBeanImpl { 
private AbstractProfileMBeanImpl createAndRegisterProfileMBean ( String profileName , ProfileTableImpl profileTable ) throws ManagementException { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "createAndRegisterProfileMBean( profileTable = " + profileTable + " , profileName = " + profileName + " )" ) ; 
try { 
ProfileSpecificationComponent component = profileTable . getProfileSpecificationComponent ( ) ; 
Constructor < ? > constructor = component . getProfileMBeanConcreteImplClass ( ) . getConstructor ( Class . class , String . class , ProfileTableImpl . class ) ; 
final AbstractProfileMBeanImpl profileMBean = ( AbstractProfileMBeanImpl ) constructor . newInstance ( component . getProfileMBeanConcreteInterfaceClass ( ) , profileName , profileTable ) ; 
profileMBean . register ( ) ; 
TransactionalAction rollbackAction = new TransactionalAction ( ) { 
public void execute ( ) { 
try { 
profileMBean . unregister ( ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
; 
sleeTransactionManagement . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( rollbackAction ) ; 
return profileMBean ; 
} 
catch ( Throwable e ) { 
throw new ManagementException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class SleeEndpointOperationNotTransactedExecutor { 
void resumeTransaction ( SleeTransaction transaction ) throws SLEEException { 
if ( transaction != null ) try { 
txManager . resume ( transaction ) ; 
} 
catch ( Throwable e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class SleeContainer { 
public void initSlee ( ) throws InvalidStateException { 
if ( sleeState != null ) throw new InvalidStateException ( "slee in " + sleeState + " state" ) ; 
beforeModulesInitialization ( ) ; 
for ( Iterator < SleeContainerModule > i = modules . iterator ( ) ; 
i . hasNext ( ) ; 
) i . next ( ) . sleeInitialization ( ) ; 
afterModulesInitialization ( ) ; 
sleeState = SleeState . STOPPED ; 
} 
} 

public class SleeContainer { 
public void shutdownSlee ( ) throws InvalidStateException { 
if ( sleeState != SleeState . STOPPED ) throw new InvalidStateException ( "slee in " + sleeState + " state" ) ; 
beforeModulesShutdown ( ) ; 
for ( Iterator < SleeContainerModule > i = modules . descendingIterator ( ) ; 
i . hasNext ( ) ; 
) i . next ( ) . sleeShutdown ( ) ; 
afterModulesShutdown ( ) ; 
sleeState = null ; 
} 
} 

public class SleeContainer { 
private void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { 
if ( oldState == SleeState . STOPPED ) if ( newState == SleeState . STARTING ) return ; 
else if ( oldState == SleeState . STARTING ) if ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) return ; 
else if ( oldState == SleeState . RUNNING ) if ( newState == SleeState . STOPPING ) return ; 
else if ( oldState == SleeState . STOPPING ) if ( newState == SleeState . STOPPED ) return ; 
throw new InvalidStateException ( "illegal slee state transition: " + oldState + " -> " + newState ) ; 
} 
} 

public class ConcreteProfileGenerator { 
private void generateNamedUsageParameterGetter ( CtClass profileConcreteClass ) { 
String methodName = "getUsageParameterSet" ; 
for ( CtMethod ctMethod : profileConcreteClass . getMethods ( ) ) { 
if ( ctMethod . getName ( ) . equals ( methodName ) ) try { 
CtMethod ctMethodCopy = CtNewMethod . copy ( ctMethod , profileConcreteClass , null ) ; 
String methodBody = "{ return ($r)" + ClassGeneratorUtils . MANAGEMENT_HANDLER + ".getUsageParameterSet(profileObject,$1); }" ; 
if ( logger . isTraceEnabled ( ) ) logger . trace ( "Implemented method " + methodName + " , body = " + methodBody ) ; 
ctMethodCopy . setBody ( methodBody ) ; 
profileConcreteClass . addMethod ( ctMethodCopy ) ; 
} 
catch ( CannotCompileException e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
} 
} 
} 

public class PolyJDBCBuilder { 
public PolyJDBC build ( ) { 
TransactionManager manager ; 
if ( dataSource != null ) manager = new DataSourceTransactionManager ( dataSource ) ; 
else manager = new ExternalTransactionManager ( connectionProvider ) ; 
return new DefaultPolyJDBC ( dialect , schemaName , new ColumnTypeMapper ( customMappings ) , manager ) ; 
} 
} 

public class RegionRequest { 
@ JsonCreator public static RegionRequest fromString ( String str ) throws ResolvingException { 
if ( str . equals ( "full" ) ) return new RegionRequest ( ) ; 
if ( str . equals ( "square" ) ) return new RegionRequest ( true ) ; 
Matcher matcher = PARSE_PAT . matcher ( str ) ; 
if ( ! matcher . matches ( ) ) throw new ResolvingException ( "Bad format: " + str ) ; 
if ( matcher . group ( 1 ) == null ) return new RegionRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , Integer . valueOf ( matcher . group ( 4 ) ) , Integer . valueOf ( matcher . group ( 5 ) ) ) ; 
else return new RegionRequest ( new BigDecimal ( matcher . group ( 2 ) ) , new BigDecimal ( matcher . group ( 3 ) ) , new BigDecimal ( matcher . group ( 4 ) ) , new BigDecimal ( matcher . group ( 5 ) ) ) ; 
} 
} 

public class RegionRequest { 
public Rectangle2D getRegion ( ) { 
if ( isRelative ( ) ) return new Rectangle2D . Double ( relativeBox . x . doubleValue ( ) , relativeBox . y . doubleValue ( ) , relativeBox . w . doubleValue ( ) , relativeBox . h . doubleValue ( ) ) ; 
else return absoluteBox ; 
} 
} 

public class RegionRequest { 
public Rectangle resolve ( Dimension imageDims ) throws ResolvingException { 
if ( square ) if ( imageDims . width > imageDims . height ) return new Rectangle ( ( imageDims . width - imageDims . height ) / 2 , 0 , imageDims . height , imageDims . height ) ; 
else if ( imageDims . height > imageDims . width ) return new Rectangle ( 0 , ( imageDims . height - imageDims . width ) / 2 , imageDims . width , imageDims . width ) ; 
if ( absoluteBox == null && relativeBox == null ) return new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; 
Rectangle rect ; 
if ( isRelative ( ) ) rect = new Rectangle ( ( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , ( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; 
else rect = absoluteBox ; 
if ( rect . x >= imageDims . width || rect . y >= imageDims . height ) throw new ResolvingException ( "X and Y must be smaller than the native width/height" ) ; 
if ( rect . x + rect . width > imageDims . width ) rect . width = imageDims . width - rect . x ; 
if ( rect . y + rect . height > imageDims . height ) rect . height = imageDims . height - rect . y ; 
return rect ; 
} 
} 

public class ResourceDeserializer { 
private String getOnType ( DeserializationContext ctxt ) { 
Object curVal = ctxt . getParser ( ) . getCurrentValue ( ) ; 
boolean isPaintingAnno = ( curVal != null && curVal instanceof Annotation && ( ( Annotation ) curVal ) . getMotivation ( ) != null && ( ( Annotation ) curVal ) . getMotivation ( ) . equals ( Motivation . PAINTING ) ) ; 
if ( isPaintingAnno ) return "sc:Canvas" ; 
JsonStreamContext parent = ctxt . getParser ( ) . getParsingContext ( ) . getParent ( ) ; 
while ( parent != null && ( parent . getCurrentValue ( ) == null || ! ( parent . getCurrentValue ( ) instanceof Resource ) ) ) parent = parent . getParent ( ) ; 
if ( parent != null ) { 
Resource parentObj = ( Resource ) parent . getCurrentValue ( ) ; 
return parentObj . getType ( ) ; 
} 
return null ; 
} 
} 

public class Resource { 
public void setViewingHints ( List < ViewingHint > viewingHints ) throws IllegalArgumentException { 
for ( ViewingHint hint : viewingHints ) { 
boolean supportsHint = ( hint . getType ( ) == ViewingHint . Type . OTHER || this . getSupportedViewingHintTypes ( ) . contains ( hint . getType ( ) ) ) ; 
if ( ! supportsHint ) throw new IllegalArgumentException ( String . format ( "Resources of type '%s' do not support the '%s' viewing hint." , this . getType ( ) , hint . toString ( ) ) ) ; 
} 
this . viewingHints = viewingHints ; 
} 
} 

public class Resource { 
public Resource addViewingHint ( ViewingHint first , ViewingHint ... rest ) throws IllegalArgumentException { 
List < ViewingHint > hints = this . viewingHints ; 
if ( hints == null ) hints = new ArrayList < > ( ) ; 
hints . addAll ( Lists . asList ( first , rest ) ) ; 
this . setViewingHints ( hints ) ; 
return this ; 
} 
} 

public class Resource { 
public Resource addRendering ( OtherContent first , OtherContent ... rest ) { 
if ( renderings == null ) this . renderings = new ArrayList < > ( ) ; 
List < OtherContent > renderingsToAdd = Lists . asList ( first , rest ) ; 
renderingsToAdd . forEach ( this :: verifyRendering ) ; 
this . renderings . addAll ( renderingsToAdd ) ; 
return this ; 
} 
} 

public class ImageApiProfile { 
public ImageApiProfile merge ( ImageApiProfile other ) { 
ImageApiProfile merged = new ImageApiProfile ( ) ; 
streamNotNull ( this . features ) . forEach ( merged :: addFeature ) ; 
streamNotNull ( other . features ) . forEach ( merged :: addFeature ) ; 
streamNotNull ( this . formats ) . forEach ( merged :: addFormat ) ; 
streamNotNull ( other . formats ) . forEach ( merged :: addFormat ) ; 
streamNotNull ( this . qualities ) . forEach ( merged :: addQuality ) ; 
streamNotNull ( other . qualities ) . forEach ( merged :: addQuality ) ; 
if ( this . maxWidth != null && other . maxWidth == null ) merged . maxWidth = this . maxWidth ; 
else if ( this . maxWidth == null && other . maxWidth != null ) merged . maxWidth = other . maxWidth ; 
else if ( this . maxWidth != null ) merged . maxWidth = Math . min ( this . maxWidth , other . maxWidth ) ; 
if ( this . maxHeight != null && other . maxHeight == null ) merged . maxHeight = this . maxHeight ; 
else if ( this . maxHeight == null && other . maxHeight != null ) merged . maxHeight = other . maxHeight ; 
else if ( this . maxHeight != null ) merged . maxHeight = Math . min ( this . maxHeight , other . maxHeight ) ; 
if ( this . maxArea != null && other . maxArea == null ) merged . maxArea = this . maxArea ; 
else if ( this . maxArea == null && other . maxArea != null ) merged . maxArea = other . maxArea ; 
else if ( this . maxArea != null ) merged . maxArea = Math . min ( this . maxArea , other . maxArea ) ; 
return merged ; 
} 
} 

public class RotationRequest { 
@ JsonCreator public static RotationRequest fromString ( String str ) throws ResolvingException { 
Matcher matcher = PATTERN . matcher ( str ) ; 
if ( ! matcher . matches ( ) ) throw new ResolvingException ( "Bad format: " + str ) ; 
return new RotationRequest ( new BigDecimal ( matcher . group ( 2 ) ) , ! ( matcher . group ( 1 ) == null ) ) ; 
} 
} 

public class SizeRequest { 
@ JsonCreator public static SizeRequest fromString ( String str ) throws ResolvingException { 
if ( str . equals ( "full" ) ) return new SizeRequest ( ) ; 
if ( str . equals ( "max" ) ) return new SizeRequest ( true ) ; 
Matcher matcher = PARSE_PAT . matcher ( str ) ; 
if ( ! matcher . matches ( ) ) throw new ResolvingException ( "Bad format: " + str ) ; 
if ( matcher . group ( 1 ) != null ) if ( matcher . group ( 1 ) . equals ( "!" ) ) return new SizeRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , true ) ; 
else if ( matcher . group ( 1 ) . equals ( "pct:" ) ) return new SizeRequest ( new BigDecimal ( matcher . group ( 4 ) ) ) ; 
Integer width = null ; 
Integer height = null ; 
if ( matcher . group ( 2 ) != null ) width = Integer . parseInt ( matcher . group ( 2 ) ) ; 
if ( matcher . group ( 3 ) != null ) height = Integer . parseInt ( matcher . group ( 3 ) ) ; 
return new SizeRequest ( width , height ) ; 
} 
} 

public class AndroidDeviceStore { 
protected void initializeAdbConnection ( ) { 
try { 
AndroidDebugBridge . init ( true ) ; 
} 
catch ( IllegalStateException e ) { 
if ( ! shouldKeepAdbAlive ) { 
logger . error ( "The IllegalStateException is not a show " + "stopper. It has been handled. This is just debug spew. Please proceed." , e ) ; 
throw new NestedException ( "ADB init failed" , e ) ; 
} 
} 
bridge = AndroidDebugBridge . getBridge ( ) ; 
if ( bridge == null ) bridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; 
long timeout = System . currentTimeMillis ( ) + 60000 ; 
while ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) try { 
Thread . sleep ( 50 ) ; 
} 
catch ( InterruptedException e ) { 
throw new RuntimeException ( e ) ; 
} 
IDevice [ ] devices = bridge . getDevices ( ) ; 
logger . info ( "initialDeviceList size {}" , devices . length ) ; 
for ( int i = 0 ; 
i < devices . length ; 
i ++ ) { 
logger . info ( "devices state: {},{} " , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; 
connectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; 
} 
bridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; 
} 
} 

public class AbstractDevice { 
public String getDump ( ) { 
pushAutomator2Device ( ) ; 
runtest ( ) ; 
String path = pullDump2PC ( ) ; 
String xml = "" ; 
try { 
FileInputStream fileInputStream = new FileInputStream ( path ) ; 
@ SuppressWarnings ( "resource" ) BufferedReader in = new BufferedReader ( new InputStreamReader ( fileInputStream ) ) ; 
StringBuffer buffer = new StringBuffer ( ) ; 
String line = "" ; 
while ( ( line = in . readLine ( ) ) != null ) buffer . append ( line ) ; 
xml = buffer . toString ( ) ; 
} 
catch ( FileNotFoundException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
return xml ; 
} 
} 

public class AbstractDevice { 
public boolean handlePopBox ( String deviceBrand ) { 
pushHandleGps2Device ( ) ; 
CommandLine exeCommand = null ; 
if ( deviceBrand . contains ( "HTC" ) ) exeCommand = adbCommand ( "shell" , "uiautomator" , "runtest" , "/data/local/tmp/handlePopBox.jar" , "-c" , "com.test.device.gps.HTCGPSTest" ) ; 
else if ( deviceBrand . contains ( "Meizu" ) ) exeCommand = adbCommand ( "shell" , "uiautomator" , "runtest" , "/data/local/tmp/handlePopBox.jar" , "-c" , "com.test.device.gps.MeizuGPSTest" ) ; 
String output = executeCommandQuietly ( exeCommand ) ; 
log . debug ( "run test {}" , output ) ; 
try { 
Thread . sleep ( 1000 ) ; 
} 
catch ( InterruptedException ie ) { 
throw new RuntimeException ( ie ) ; 
} 
return output . contains ( "OK" ) ; 
} 
} 

public class AbstractDevice { 
public String getCrashLog ( ) { 
String crashLogFileName = null ; 
File crashLogFile = new File ( getExternalStoragePath ( ) , crashLogFileName ) ; 
CommandLine directoryListCommand = adbCommand ( "shell" , "ls" , crashLogFile . getParentFile ( ) . getAbsolutePath ( ) ) ; 
String directoryList = executeCommandQuietly ( directoryListCommand ) ; 
if ( directoryList . contains ( crashLogFileName ) ) return executeCommandQuietly ( adbCommand ( "shell" , "cat" , crashLogFile . getAbsolutePath ( ) ) ) ; 
return "" ; 
} 
} 

public class TextEditor { 
public TextEditor indent ( int spaces ) { 
StringBuilder sb = new StringBuilder ( spaces ) ; 
for ( int i = 0 ; 
i < spaces ; 
i ++ ) sb . append ( ' ' ) ; 
return replaceAll ( "^" , sb . toString ( ) ) ; 
} 
} 

public class TextEditor { 
public Collection < HTMLToken > tokenizeHTML ( ) { 
List < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; 
String nestedTags = nestedTagsRegex ( 6 ) ; 
Pattern p = Pattern . compile ( "" + "(?s:<!(--.*?--\\s*)+>)" + "|" + "(?s:<\\?.*?\\?>)" + "|" + nestedTags + "" , Pattern . CASE_INSENSITIVE ) ; 
Matcher m = p . matcher ( text ) ; 
int lastPos = 0 ; 
while ( m . find ( ) ) { 
if ( lastPos < m . start ( ) ) tokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; 
tokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; 
lastPos = m . end ( ) ; 
} 
if ( lastPos < text . length ( ) ) tokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; 
return tokens ; 
} 
} 

public class MarkdownProcessor { 
public String markdown ( String txt ) { 
if ( txt == null ) txt = "" ; 
TextEditor text = new TextEditor ( txt ) ; 
text . replaceAll ( "\\r\\n" , "\n" ) ; 
text . replaceAll ( "\\r" , "\n" ) ; 
text . replaceAll ( "^[ \\t]+$" , "" ) ; 
text . append ( "\n\n" ) ; 
text . detabify ( ) ; 
text . deleteAll ( "^[ ]+$" ) ; 
hashHTMLBlocks ( text ) ; 
stripLinkDefinitions ( text ) ; 
text = runBlockGamut ( text ) ; 
unEscapeSpecialChars ( text ) ; 
text . append ( "\n" ) ; 
return text . toString ( ) ; 
} 
} 

public class ExceptionCollector { 
final void addException ( SQLException exception ) { 
if ( ! ( exception instanceof SQLTimeoutException ) && ! ( exception instanceof SQLTransactionRollbackException ) ) getOrInit ( ) . offer ( exception ) ; 
} 
} 

public class ClhmStatementCache { 
@ Override public void close ( ) { 
if ( closed . getAndSet ( true ) ) return ; 
for ( Map . Entry < StatementMethod , StatementHolder > entry : statementCache . entrySet ( ) ) { 
StatementHolder value = entry . getValue ( ) ; 
statementCache . remove ( entry . getKey ( ) , value ) ; 
quietClose ( value . rawStatement ( ) ) ; 
} 
} 
} 

public class BarberProcessor { 
private String findParentFqcn ( TypeElement typeElement , Set < String > parents ) { 
TypeMirror type ; 
while ( true ) { 
type = typeElement . getSuperclass ( ) ; 
if ( type . getKind ( ) == TypeKind . NONE ) return null ; 
typeElement = ( TypeElement ) ( ( DeclaredType ) type ) . asElement ( ) ; 
if ( parents . contains ( typeElement . toString ( ) ) ) { 
String packageName = getPackageName ( typeElement ) ; 
return packageName + "." + getClassName ( typeElement , packageName ) ; 
} 
} 
} 
} 

public class Barbershop { 
void writeToFiler ( Filer filer ) throws IOException { 
ClassName targetClassName = ClassName . get ( classPackage , targetClass ) ; 
TypeSpec . Builder barberShop = TypeSpec . classBuilder ( className ) . addModifiers ( Modifier . PUBLIC ) . addTypeVariable ( TypeVariableName . get ( "T" , targetClassName ) ) . addMethod ( generateStyleMethod ( ) ) . addMethod ( generateCheckParentMethod ( ) ) ; 
if ( parentBarbershop == null ) { 
barberShop . addSuperinterface ( ParameterizedTypeName . get ( ClassName . get ( Barber . IBarbershop . class ) , TypeVariableName . get ( "T" ) ) ) ; 
barberShop . addField ( FieldSpec . builder ( WeakHashSet . class , "lastStyledTargets" , Modifier . PROTECTED ) . initializer ( "new $T()" , WeakHashSet . class ) . build ( ) ) ; 
} 
else barberShop . superclass ( ParameterizedTypeName . get ( ClassName . bestGuess ( parentBarbershop ) , TypeVariableName . get ( "T" ) ) ) ; 
JavaFile javaFile = JavaFile . builder ( classPackage , barberShop . build ( ) ) . build ( ) ; 
javaFile . writeTo ( filer ) ; 
} 
} 

public class MTGAPI { 
private static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { 
String url = String . format ( "%s/%s" , ENDPOINT , path ) ; 
Request request = new Request . Builder ( ) . url ( url ) . build ( ) ; 
Response response ; 
try { 
response = CLIENT . newCall ( request ) . execute ( ) ; 
ArrayList < JsonObject > objectList = new ArrayList < > ( ) ; 
String linkHeader = response . headers ( ) . get ( "Link" ) ; 
if ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( "page=" ) ) { 
objectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; 
return objectList ; 
} 
else { 
int numberOfPages = 0 ; 
String [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; 
List < String [ ] > paramList = new ArrayList < > ( ) ; 
for ( String link : linkStrings ) { 
paramList . add ( link . split ( DELIM_LINK_PARAM ) ) ; 
} 
for ( String [ ] params : paramList ) { 
if ( params [ 1 ] . contains ( "last" ) ) { 
Matcher matcher = Pattern . compile ( "page=[0-9]+" ) . matcher ( params [ 0 ] ) ; 
numberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; 
} 
} 
objectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; 
if ( ! url . contains ( "?" ) ) url += "?" ; 
for ( int i = 1 ; 
i <= numberOfPages ; 
i ++ ) { 
request = new Request . Builder ( ) . url ( url + "&page=" + i ) . build ( ) ; 
response = CLIENT . newCall ( request ) . execute ( ) ; 
objectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; 
} 
return objectList ; 
} 
} 
catch ( IOException e ) { 
throw new HttpRequestFailedException ( e ) ; 
} 
} 
} 

public class ExtentCucumberFormatter { 
private static synchronized void setKlovReport ( ) { 
if ( extentReports == null ) return ; 
ExtentProperties extentProperties = ExtentProperties . INSTANCE ; 
if ( klovReporter != null ) return ; 
if ( extentProperties . getKlovServerUrl ( ) != null ) { 
String hostname = extentProperties . getMongodbHost ( ) ; 
int port = extentProperties . getMongodbPort ( ) ; 
String database = extentProperties . getMongodbDatabase ( ) ; 
String username = extentProperties . getMongodbUsername ( ) ; 
String password = extentProperties . getMongodbPassword ( ) ; 
try { 
klovReporter = new KlovReporter ( ) ; 
if ( username != null && password != null ) { 
MongoClientURI uri = new MongoClientURI ( "mongodb://" + username + ":" + password + "@" + hostname + ":" + port + "/?authSource=" + database ) ; 
klovReporter . initMongoDbConnection ( uri ) ; 
} 
else klovReporter . initMongoDbConnection ( hostname , port ) ; 
klovReporter . setProjectName ( extentProperties . getKlovProjectName ( ) ) ; 
klovReporter . setReportName ( extentProperties . getKlovReportName ( ) ) ; 
klovReporter . setKlovUrl ( extentProperties . getKlovServerUrl ( ) ) ; 
extentReports . attachReporter ( klovReporter ) ; 
} 
catch ( Exception ex ) { 
klovReporter = null ; 
throw new IllegalArgumentException ( "Error setting up Klov Reporter" , ex ) ; 
} 
} 
} 
} 

public class Reporter { 
public static void setSystemInfo ( String key , String value ) { 
if ( systemInfoKeyMap . isEmpty ( ) || ! systemInfoKeyMap . containsKey ( key ) ) systemInfoKeyMap . put ( key , false ) ; 
if ( systemInfoKeyMap . get ( key ) ) return ; 
getExtentReport ( ) . setSystemInfo ( key , value ) ; 
systemInfoKeyMap . put ( key , true ) ; 
} 
} 

public class Selector { 
public static Selector selectAs ( final String propName , final String alias , final Function transform ) { 
return new Selector ( propName , alias ) { 
@ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { 
if ( ! path && fields != null ) row . put ( this . name , transform . apply ( fields . get ( this . name ) . getValue ( item ) ) ) ; 
else row . put ( alias , transform . apply ( BeanUtils . atIndex ( item , propName ) ) ) ; 
} 
@ Override public void handleStart ( Collection < ? > results ) { 
} 
@ Override public void handleComplete ( List < Map < String , Object > > rows ) { 
} 
} 
; 
} 
} 

public class Annotations { 
public static List < AnnotationData > extractValidationAnnotationData ( Annotation [ ] annotations , Set < String > allowedPackages ) { 
List < AnnotationData > annotationsList = new ArrayList < > ( ) ; 
for ( Annotation annotation : annotations ) { 
AnnotationData annotationData = new AnnotationData ( annotation , allowedPackages ) ; 
if ( annotationData . isAllowed ( ) ) annotationsList . add ( annotationData ) ; 
} 
return annotationsList ; 
} 
} 

public class Annotations { 
private static Annotation [ ] extractAllAnnotationsForProperty ( Class < ? > clazz , String propertyName , boolean useRead ) { 
try { 
Annotation [ ] annotations = findPropertyAnnotations ( clazz , propertyName , useRead ) ; 
if ( annotations . length == 0 ) annotations = findPropertyAnnotations ( clazz . getSuperclass ( ) , propertyName , useRead ) ; 
return annotations ; 
} 
catch ( Exception ex ) { 
return Exceptions . handle ( Annotation [ ] . class , sputs ( "Unable to extract annotation for property" , propertyName , " of class " , clazz , "  useRead " , useRead ) , ex ) ; 
} 
} 
} 

public class Annotations { 
private static Annotation [ ] findPropertyAnnotations ( Class < ? > clazz , String propertyName , boolean useRead ) throws IntrospectionException { 
PropertyDescriptor propertyDescriptor = getPropertyDescriptor ( clazz , propertyName ) ; 
if ( propertyDescriptor == null ) return new Annotation [ ] { 
} 
; 
Method accessMethod = null ; 
if ( useRead ) accessMethod = propertyDescriptor . getReadMethod ( ) ; 
else accessMethod = propertyDescriptor . getWriteMethod ( ) ; 
if ( accessMethod != null ) { 
Annotation [ ] annotations = accessMethod . getAnnotations ( ) ; 
return annotations ; 
} 
else return new Annotation [ ] { 
} 
; 
} 
} 

public class Annotations { 
private static PropertyDescriptor doGetPropertyDescriptor ( final Class < ? > type , final String propertyName ) { 
try { 
BeanInfo beanInfo = Introspector . getBeanInfo ( type ) ; 
PropertyDescriptor [ ] propertyDescriptors = beanInfo . getPropertyDescriptors ( ) ; 
for ( PropertyDescriptor pd : propertyDescriptors ) { 
if ( pd . getName ( ) . equals ( propertyName ) ) return pd ; 
} 
Class < ? > superclass = type . getSuperclass ( ) ; 
if ( superclass != null ) return doGetPropertyDescriptor ( superclass , propertyName ) ; 
return null ; 
} 
catch ( Exception ex ) { 
throw new RuntimeException ( "Unable to get property " + propertyName + " for class " + type , ex ) ; 
} 
} 
} 

public class BoonExpressionContext { 
private Object doLookup ( String objectExpression , Object defaultValue , boolean searchChildren ) { 
if ( Str . isEmpty ( objectExpression ) ) return defaultValue ; 
char firstChar = Str . idx ( objectExpression , 0 ) ; 
char secondChar = Str . idx ( objectExpression , 1 ) ; 
char lastChar = Str . idx ( objectExpression , - 1 ) ; 
boolean escape = false ; 
switch ( firstChar ) { 
case '$' : if ( lastChar == '}' ) objectExpression = slc ( objectExpression , 2 , - 1 ) ; 
else objectExpression = slc ( objectExpression , 1 ) ; 
break ; 
case '{' : if ( secondChar == '{' && lastChar == '}' ) { 
char thirdChar = Str . idx ( objectExpression , 2 ) ; 
if ( thirdChar == '{' ) { 
escape = true ; 
objectExpression = slc ( objectExpression , 3 , - 3 ) ; 
} 
else objectExpression = slc ( objectExpression , 2 , - 2 ) ; 
} 
else if ( lastChar == '}' ) return jsonParser . parse ( objectExpression ) ; 
else { 
escape = true ; 
objectExpression = slc ( objectExpression , 1 ) ; 
} 
break ; 
case '[' : return jsonParser . parse ( objectExpression ) ; 
case '.' : if ( secondChar == '.' ) { 
String newExp = slc ( objectExpression , 2 ) ; 
return parent . doLookup ( newExp , newExp , false ) ; 
} 
} 
Object value ; 
lastChar = Str . idx ( objectExpression , - 1 ) ; 
if ( lastChar == ')' ) value = handleFunction ( objectExpression , searchChildren ) ; 
else { 
value = findProperty ( objectExpression , searchChildren ) ; 
value = value == null ? defaultValue : value ; 
} 
if ( ! escape ) return value ; 
else return StandardFunctions . escapeXml ( value ) ; 
} 
} 

public class AnnotationData { 
Map < String , Object > doGetValues ( Annotation annotation ) { 
Map < String , Object > values = new HashMap < String , Object > ( ) ; 
Method [ ] methods = annotation . annotationType ( ) . getDeclaredMethods ( ) ; 
final Object [ ] noargs = ( Object [ ] ) null ; 
for ( Method method : methods ) { 
if ( method . getParameterTypes ( ) . length == 0 ) try { 
Object value = method . invoke ( annotation , noargs ) ; 
if ( value instanceof Enum ) { 
Enum enumVal = ( Enum ) value ; 
value = enumVal . name ( ) ; 
} 
values . put ( method . getName ( ) , value ) ; 
} 
catch ( Exception ex ) { 
throw new RuntimeException ( ex ) ; 
} 
} 
return values ; 
} 
} 

public class RecursiveDescentPropertyValidator { 
private void ifPropertyBlankRemove ( Map < String , Object > properties , String property ) { 
Object object = properties . get ( property ) ; 
if ( object == null ) properties . remove ( property ) ; 
else if ( object instanceof String ) { 
String string = ( String ) object ; 
if ( "" . equals ( string . trim ( ) ) ) properties . remove ( property ) ; 
} 
} 
} 

public class LevelDBKeyValueStore { 
@ Override public void putAll ( Map < byte [ ] , byte [ ] > values ) { 
WriteBatch batch = database . createWriteBatch ( ) ; 
try { 
for ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { 
batch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
if ( putAllWriteCount . addAndGet ( values . size ( ) ) > 10_000 ) { 
putAllWriteCount . set ( 0 ) ; 
database . write ( batch , flush ) ; 
} 
else database . write ( batch , writeOptions ) ; 
} 
finally { 
closeBatch ( batch ) ; 
} 
} 
} 

public class LevelDBKeyValueStore { 
@ Override public Map < byte [ ] , byte [ ] > loadAllByKeys ( Collection < byte [ ] > keys ) { 
if ( keys == null || keys . size ( ) == 0 ) return Collections . EMPTY_MAP ; 
Map < byte [ ] , byte [ ] > results = new LinkedHashMap < > ( keys . size ( ) ) ; 
DBIterator iterator = null ; 
try { 
iterator = database . iterator ( ) ; 
iterator . seek ( keys . iterator ( ) . next ( ) ) ; 
while ( iterator . hasNext ( ) ) { 
final Map . Entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; 
results . put ( next . getKey ( ) , next . getValue ( ) ) ; 
} 
} 
finally { 
try { 
if ( iterator != null ) iterator . close ( ) ; 
} 
catch ( IOException e ) { 
Exceptions . handle ( e ) ; 
} 
} 
return results ; 
} 
} 

public class Dbl { 
public static < T > double reduceBy ( final double [ ] array , T object ) { 
if ( object . getClass ( ) . isAnonymousClass ( ) ) return reduceByR ( array , object ) ; 
try { 
ConstantCallSite callSite = Invoker . invokeReducerLongIntReturnLongMethodHandle ( object ) ; 
MethodHandle methodHandle = callSite . dynamicInvoker ( ) ; 
try { 
double sum = 0 ; 
for ( double v : array ) { 
sum = ( double ) methodHandle . invokeExact ( sum , v ) ; 
} 
return sum ; 
} 
catch ( Throwable throwable ) { 
return handle ( Long . class , throwable , "Unable to perform reduceBy" ) ; 
} 
} 
catch ( Exception ex ) { 
return reduceByR ( array , object ) ; 
} 
} 
} 

public class ObjectFilter { 
public static Criterion notIn ( final Object name , final Object ... values ) { 
return new Criterion < Object > ( name . toString ( ) , Operator . NOT_IN , values ) { 
@ Override public boolean resolve ( Object owner ) { 
Object fieldValue = fieldValue ( ) ; 
if ( value == null ) return false ; 
return ! valueSet ( ) . contains ( fieldValue ) ; 
} 
} 
; 
} 
} 

public class ObjectFilter { 
public static Criteria criteriaFromList ( List < ? > list ) { 
List < Object > args = new ArrayList ( list ) ; 
Object o = atIndex ( args , - 1 ) ; 
if ( ! ( o instanceof List ) ) atIndex ( args , - 1 , Collections . singletonList ( o ) ) ; 
return ( Criteria ) Invoker . invokeFromList ( ObjectFilter . class , "createCriteriaFromClass" , args ) ; 
} 
} 

public class DoubleList { 
public boolean addArray ( double ... integers ) { 
if ( end + integers . length >= values . length ) values = grow ( values , ( values . length + integers . length ) * 2 ) ; 
System . arraycopy ( integers , 0 , values , end , integers . length ) ; 
end += integers . length ; 
return true ; 
} 
} 

public class Ordering { 
public static < T > T max ( T [ ] array ) { 
if ( array . length > 1 ) { 
Sorting . sortDesc ( array ) ; 
return array [ 0 ] ; 
} 
else return null ; 
} 
} 

public class Ordering { 
public static < T > List < T > firstOf ( List < T > list , int count , Sort ... sorts ) { 
if ( list . size ( ) > 1 ) { 
Sorting . sort ( list , sorts ) ; 
return Lists . sliceOf ( list , 0 , count ) ; 
} 
else return null ; 
} 
} 

public class Ordering { 
public static < T > T lastOf ( List < T > list , Sort ... sorts ) { 
if ( list . size ( ) > 1 ) { 
Sorting . sort ( list , sorts ) ; 
return list . get ( list . size ( ) - 1 ) ; 
} 
else return null ; 
} 
} 

public class Ordering { 
public static < T > List < T > lastOf ( List < T > list , int count , Sort ... sorts ) { 
if ( list . size ( ) > 1 ) { 
Sorting . sort ( list , sorts ) ; 
return Lists . endSliceOf ( list , count * - 1 ) ; 
} 
else return null ; 
} 
} 

public class Ordering { 
public static < T > List < T > least ( List < T > list , int count ) { 
if ( list . size ( ) > 1 ) { 
Sorting . sort ( list ) ; 
return Lists . sliceOf ( list , 0 , count ) ; 
} 
else return null ; 
} 
} 

public class Ordering { 
public static < T > T min ( List < T > list ) { 
if ( list . size ( ) > 1 ) { 
Sorting . sort ( list ) ; 
return list . get ( 0 ) ; 
} 
else return null ; 
} 
} 

public class Ordering { 
public static < T > T min ( T [ ] array , String sortBy ) { 
if ( array . length > 1 ) { 
Sorting . sort ( array , sortBy ) ; 
return array [ 0 ] ; 
} 
else return null ; 
} 
} 

public class MessageUtils { 
public static String generateLabelValue ( final String fieldName ) { 
final StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; 
class GenerationCommand { 
boolean capNextChar = false ; 
boolean lastCharWasUpperCase = false ; 
boolean lastCharWasNumber = false ; 
boolean lastCharWasSpecial = false ; 
boolean shouldContinue = true ; 
char [ ] chars = fieldName . toCharArray ( ) ; 
void processFieldName ( ) { 
for ( int index = 0 ; 
index < chars . length ; 
index ++ ) { 
char cchar = chars [ index ] ; 
shouldContinue = true ; 
processCharWasNumber ( buffer , index , cchar ) ; 
if ( ! shouldContinue ) continue ; 
processCharWasUpperCase ( buffer , index , cchar ) ; 
if ( ! shouldContinue ) continue ; 
processSpecialChars ( buffer , cchar ) ; 
if ( ! shouldContinue ) continue ; 
cchar = processCapitalizeCommand ( cchar ) ; 
cchar = processFirstCharacterCheck ( buffer , index , cchar ) ; 
if ( ! shouldContinue ) continue ; 
buffer . append ( cchar ) ; 
} 
} 
private void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { 
if ( lastCharWasSpecial ) return ; 
if ( Character . isDigit ( cchar ) ) { 
if ( index != 0 && ! lastCharWasNumber ) buffer . append ( ' ' ) ; 
lastCharWasNumber = true ; 
buffer . append ( cchar ) ; 
this . shouldContinue = false ; 
} 
else lastCharWasNumber = false ; 
} 
private char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { 
if ( index == 0 ) { 
cchar = Character . toUpperCase ( cchar ) ; 
buffer . append ( cchar ) ; 
this . shouldContinue = false ; 
} 
return cchar ; 
} 
private char processCapitalizeCommand ( char cchar ) { 
if ( capNextChar ) { 
capNextChar = false ; 
cchar = Character . toUpperCase ( cchar ) ; 
} 
return cchar ; 
} 
private void processSpecialChars ( final StringBuilder buffer , char cchar ) { 
lastCharWasSpecial = false ; 
if ( cchar == '.' || cchar == '_' ) { 
buffer . append ( ' ' ) ; 
capNextChar = true ; 
lastCharWasSpecial = false ; 
this . shouldContinue = false ; 
} 
} 
private void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { 
if ( Character . isUpperCase ( cchar ) ) { 
if ( index != 0 && ! lastCharWasUpperCase ) buffer . append ( ' ' ) ; 
lastCharWasUpperCase = true ; 
buffer . append ( cchar ) ; 
this . shouldContinue = false ; 
} 
else lastCharWasUpperCase = false ; 
} 
} 
GenerationCommand gc = new GenerationCommand ( ) ; 
gc . processFieldName ( ) ; 
return buffer . toString ( ) . replace ( "  " , " " ) ; 
} 
} 

public class BaseDataStore { 
private void processReadQueue ( ) throws InterruptedException { 
ReadStatus readStatus = new ReadStatus ( ) ; 
while ( true ) { 
DataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; 
while ( request != null ) { 
readStatus . tracker . addCall ( request , outputDataQueue ) ; 
readOperationsBatch . add ( request ) ; 
if ( readOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) break ; 
request = readOperationsQueue . poll ( ) ; 
} 
if ( readOperationsBatch . size ( ) > 0 ) try { 
recievedReadBatch ( new ArrayList < > ( readOperationsBatch ) ) ; 
} 
finally { 
readOperationsBatch . clear ( ) ; 
} 
else flushReadsIfNeeded ( ) ; 
if ( readStatus . readBatchSize . size ( ) > 1_000 ) { 
StatCount count ; 
final long now = Timer . timer ( ) . time ( ) ; 
count = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , "Thread TIME USER  BaseDataStore " + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; 
this . outputDataQueue . put ( count ) ; 
count = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , "Thread TIME CPU  BaseDataStore " + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; 
this . outputDataQueue . put ( count ) ; 
count = new StatCount ( now , source , Action . GET , "BaseDataStore readStatus.readBatchSize.max" , readStatus . readBatchSize . max ( ) ) ; 
outputDataQueue . put ( count ) ; 
count = new StatCount ( now , source , Action . GET , "BaseDataStore readStatus.readBatchSize.min" , readStatus . readBatchSize . min ( ) ) ; 
outputDataQueue . put ( count ) ; 
count = new StatCount ( now , source , Action . GET , "BaseDataStore readStatus.readBatchSize.median" , readStatus . readBatchSize . median ( ) ) ; 
outputDataQueue . put ( count ) ; 
count = new StatCount ( now , source , Action . GET , "BaseDataStore readStatus.readBatchSize.mean" , readStatus . readBatchSize . mean ( ) ) ; 
outputDataQueue . put ( count ) ; 
count = new StatCount ( now , source , Action . GET , "BaseDataStore readStatus.readBatchSize.standardDeviation" , readStatus . readBatchSize . standardDeviation ( ) ) ; 
outputDataQueue . put ( count ) ; 
count = new StatCount ( now , source , Action . GET , "BaseDataStore readStatus.readBatchSize.variance" , readStatus . readBatchSize . variance ( ) ) ; 
outputDataQueue . put ( count ) ; 
readStatus . readBatchSize . clear ( ) ; 
} 
} 
} 
} 

public class BaseDataStore { 
private void processWriteQueue ( ) throws InterruptedException { 
WriteStatus status = new WriteStatus ( ) ; 
while ( true ) { 
DataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; 
while ( operation != null ) { 
status . tracker . addCall ( operation , outputDataQueue ) ; 
writeOperationsBatch . add ( operation ) ; 
if ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) break ; 
operation = writeOperationsQueue . poll ( ) ; 
} 
if ( writeOperationsBatch . size ( ) > 0 ) try { 
status . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; 
recievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; 
} 
finally { 
writeOperationsBatch . clear ( ) ; 
} 
else flushWritesIfNeeded ( ) ; 
if ( status . writeBatchSize . size ( ) > 1000 ) status . sendBatchSize ( source , outputDataQueue ) ; 
} 
} 
} 

public class BaseDataStore { 
public void start ( ) { 
scheduledExecutorService = Executors . newScheduledThreadPool ( 2 , new ThreadFactory ( ) { 
@ Override public Thread newThread ( Runnable runnable ) { 
Thread thread = new Thread ( runnable ) ; 
thread . setName ( " DataQueue Process " + source ) ; 
return thread ; 
} 
} 
) ; 
future = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { 
@ Override public void run ( ) { 
if ( stop . get ( ) ) return ; 
try { 
processWriteQueue ( ) ; 
} 
catch ( InterruptedException ex ) { 
} 
catch ( Exception ex ) { 
logger . fatal ( ex ) ; 
} 
} 
} 
, 0 , dataStoreConfig . threadErrorResumeTimeMS ( ) , TimeUnit . MILLISECONDS ) ; 
future = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { 
@ Override public void run ( ) { 
if ( stop . get ( ) ) return ; 
try { 
processReadQueue ( ) ; 
} 
catch ( InterruptedException ex ) { 
} 
catch ( Exception ex ) { 
logger . fatal ( ex , "Problem with base data store running scheduled job" ) ; 
} 
} 
} 
, 0 , dataStoreConfig . threadErrorResumeTimeMS ( ) , TimeUnit . MILLISECONDS ) ; 
} 
} 

public class Str { 
public static String addObjects ( Object ... objects ) { 
int length = 0 ; 
for ( Object obj : objects ) { 
if ( obj == null ) continue ; 
length += obj . toString ( ) . length ( ) ; 
} 
CharBuf builder = CharBuf . createExact ( length ) ; 
for ( Object str : objects ) { 
if ( str == null ) continue ; 
builder . add ( str . toString ( ) ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class Str { 
public static String num ( Number count ) { 
if ( count == null ) return "" ; 
if ( count instanceof Double || count instanceof BigDecimal ) { 
String s = count . toString ( ) ; 
if ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { 
s = slc ( s , 0 , 5 ) ; 
return s ; 
} 
else return s ; 
} 
else if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { 
String s = count . toString ( ) ; 
s = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; 
CharBuf buf = CharBuf . create ( s . length ( ) ) ; 
int index = 0 ; 
for ( char c : s . toCharArray ( ) ) { 
index ++ ; 
buf . add ( c ) ; 
if ( index % 3 == 0 ) buf . add ( ',' ) ; 
} 
if ( buf . lastChar ( ) == ',' ) buf . removeLastChar ( ) ; 
s = buf . toString ( ) ; 
s = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; 
return s ; 
} 
return count . toString ( ) ; 
} 
} 

public class Sort { 
public static Sort sorts ( Sort ... sorts ) { 
if ( sorts == null || sorts . length == 0 ) return null ; 
Sort main = sorts [ 0 ] ; 
for ( int index = 1 ; 
index < sorts . length ; 
index ++ ) main . then ( sorts [ index ] ) ; 
return main ; 
} 
} 

public class Sort { 
public Comparator comparator ( Map < String , FieldAccess > fields ) { 
if ( comparator == null ) comparator = universalComparator ( this . getName ( ) , fields , this . getType ( ) , this . childComparators ( fields ) ) ; 
return comparator ; 
} 
} 

public class Int { 
public static boolean equalsOrDie ( int expected , int got ) { 
if ( expected != got ) return die ( Boolean . class , "Expected was" , expected , "but we got " , got ) ; 
return true ; 
} 
} 

public class Int { 
public static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { 
if ( expected . length != got . length ) die ( "Lengths did not match, expected length" , expected . length , "but got" , got . length ) ; 
for ( int index = 0 ; 
index < expected . length ; 
index ++ ) if ( expected [ index ] != got [ index ] ) die ( "value at index did not match index" , index , "expected value" , expected [ index ] , "but got" , got [ index ] ) ; 
return true ; 
} 
} 

public class Int { 
public static int sum ( int [ ] values , int start , int length ) { 
long sum = 0 ; 
for ( int index = start ; 
index < length ; 
index ++ ) sum += values [ index ] ; 
if ( sum < Integer . MIN_VALUE ) die ( "overflow the sum is too small" , sum ) ; 
if ( sum > Integer . MAX_VALUE ) die ( "overflow the sum is too big" , sum ) ; 
return ( int ) sum ; 
} 
} 

public class SortingInternal { 
public static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending , boolean nullsFirst ) { 
try { 
if ( list == null || list . size ( ) == 0 ) return ; 
Object o = list . get ( 0 ) ; 
if ( sortBy . equals ( "this" ) ) { 
Collections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; 
return ; 
} 
final FieldAccess field = fields . get ( sortBy ) ; 
if ( field != null ) Collections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; 
} 
catch ( Exception ex ) { 
Exceptions . handle ( ex , "list" , list , "\nsortBy" , sortBy , "fields" , fields , "ascending" , ascending , "nullFirst" , nullsFirst ) ; 
} 
} 
} 

public class MapperComplex { 
private void setFieldValueFromMap ( final Object parentObject , final FieldAccess field , final Map mapInner ) { 
Class < ? > fieldClassType = field . type ( ) ; 
Object value = null ; 
if ( ! Typ . isMap ( fieldClassType ) ) if ( ! fieldClassType . isInterface ( ) && ! Typ . isAbstract ( fieldClassType ) ) value = fromMap ( mapInner , field . type ( ) ) ; 
else { 
Object oClassName = mapInner . get ( "class" ) ; 
if ( oClassName != null ) value = fromMap ( mapInner , Reflection . loadClass ( oClassName . toString ( ) ) ) ; 
else value = null ; 
} 
else if ( Typ . isMap ( fieldClassType ) ) { 
Class keyType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 0 ] ; 
Class valueType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 1 ] ; 
Set < Map . Entry > set = mapInner . entrySet ( ) ; 
Map newMap = new LinkedHashMap ( ) ; 
for ( Map . Entry entry : set ) { 
Object evalue = entry . getValue ( ) ; 
Object key = entry . getKey ( ) ; 
if ( evalue instanceof ValueContainer ) evalue = ( ( ValueContainer ) evalue ) . toValue ( ) ; 
key = Conversions . coerce ( keyType , key ) ; 
evalue = Conversions . coerce ( valueType , evalue ) ; 
newMap . put ( key , evalue ) ; 
} 
value = newMap ; 
} 
field . setValue ( parentObject , value ) ; 
} 
} 

public class MapperComplex { 
@ Override public List < ? > toList ( Object object ) { 
TypeType instanceType = TypeType . getInstanceType ( object ) ; 
switch ( instanceType ) { 
case NULL : return Lists . list ( ( Object ) null ) ; 
case ARRAY : case ARRAY_INT : case ARRAY_BYTE : case ARRAY_SHORT : case ARRAY_FLOAT : case ARRAY_DOUBLE : case ARRAY_LONG : case ARRAY_STRING : case ARRAY_OBJECT : return Conversions . toList ( object ) ; 
case INSTANCE : if ( Reflection . respondsTo ( object , "toList" ) ) return ( List < ? > ) Reflection . invoke ( object , "toList" ) ; 
break ; 
} 
return Lists . list ( object ) ; 
} 
} 

public class Lists { 
@ Universal public static < V > List < V > deepCopy ( List < V > list ) { 
if ( list instanceof LinkedList ) return deepCopyToList ( list , new LinkedList < V > ( ) ) ; 
else if ( list instanceof CopyOnWriteArrayList ) return deepCopyToList ( list , new CopyOnWriteArrayList < V > ( ) ) ; 
else return deepCopy ( ( Collection ) list ) ; 
} 
} 

public class Fields { 
public static boolean classHasStringField ( Class < ? > clz , String name ) { 
List < Field > fields = Reflection . getAllFields ( clz ) ; 
for ( Field field : fields ) { 
if ( field . getType ( ) . equals ( Typ . string ) && field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) return true ; 
} 
return false ; 
} 
} 

public class Fields { 
public static boolean classHasField ( Class < ? > clz , String name ) { 
List < Field > fields = Reflection . getAllFields ( clz ) ; 
for ( Field field : fields ) { 
if ( field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) return true ; 
} 
return false ; 
} 
} 

public class Fields { 
public static String getFirstComparableOrPrimitiveFromClass ( Class < ? > clz ) { 
List < Field > fields = Reflection . getAllFields ( clz ) ; 
for ( Field field : fields ) { 
if ( ( field . getType ( ) . isPrimitive ( ) || Typ . isComparable ( field . getType ( ) ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) ) return field . getName ( ) ; 
} 
return null ; 
} 
} 

public class Fields { 
public static String getSortableField ( Object value1 ) { 
if ( value1 instanceof Map ) return getSortableFieldFromMap ( ( Map < String , ? > ) value1 ) ; 
else return getSortableFieldFromClass ( value1 . getClass ( ) ) ; 
} 
} 

public class CacheEntry { 
private final int compareTime ( CacheEntry other ) { 
if ( time > other . time ) return 1 ; 
else if ( time < other . time ) return - 1 ; 
else if ( time == other . time ) return 0 ; 
die ( ) ; 
return 0 ; 
} 
} 

public class Sorting { 
public static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { 
if ( list == null || list . size ( ) == 0 ) return ; 
if ( sortBy . equals ( "this" ) ) { 
Collections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; 
return ; 
} 
Iterator iterator = list . iterator ( ) ; 
Object object = iterator . next ( ) ; 
Map < String , FieldAccess > fields = null ; 
if ( object != null ) fields = BeanUtils . getFieldsFromObject ( object ) ; 
else while ( iterator . hasNext ( ) ) { 
object = iterator . next ( ) ; 
if ( object != null ) { 
fields = BeanUtils . getFieldsFromObject ( object ) ; 
break ; 
} 
} 
if ( fields != null ) { 
final FieldAccess field = fields . get ( sortBy ) ; 
if ( field != null ) Collections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; 
} 
} 
} 

public class Sorting { 
public static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { 
if ( array == null || array . length == 0 ) return ; 
if ( sortBy . equals ( "this" ) ) { 
Arrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; 
return ; 
} 
Object object = array [ 0 ] ; 
Map < String , FieldAccess > fields = null ; 
if ( object != null ) fields = BeanUtils . getFieldsFromObject ( object ) ; 
else for ( int index = 1 ; 
index < array . length ; 
index ++ ) { 
object = array [ index ] ; 
if ( object != null ) { 
fields = BeanUtils . getFieldsFromObject ( object ) ; 
break ; 
} 
} 
if ( fields != null ) { 
final FieldAccess field = fields . get ( sortBy ) ; 
if ( field != null ) Arrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; 
} 
} 
} 

public class FastConcurrentReadLruLfuFifoCache { 
public VALUE get ( KEY key ) { 
CacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; 
if ( cacheEntry != null ) { 
cacheEntry . readCount . incrementAndGet ( ) ; 
return cacheEntry . value ; 
} 
else return null ; 
} 
} 

public class FastConcurrentReadLruLfuFifoCache { 
public VALUE getSilent ( KEY key ) { 
CacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; 
if ( cacheEntry != null ) return cacheEntry . value ; 
else return null ; 
} 
} 

public class FastConcurrentReadLruLfuFifoCache { 
private final int order ( ) { 
int order = count . incrementAndGet ( ) ; 
if ( order > Integer . MAX_VALUE - 100 ) count . set ( 0 ) ; 
return order ; 
} 
} 

public class LongRangeValidator { 
private void dynamicallyInitIfNeeded ( Object value ) { 
if ( ! isInitialized ( ) ) if ( value instanceof Integer ) init ( new Integer ( min . intValue ( ) ) , new Integer ( max . intValue ( ) ) ) ; 
else if ( value instanceof Byte ) init ( new Byte ( min . byteValue ( ) ) , new Byte ( max . byteValue ( ) ) ) ; 
else if ( value instanceof Short ) init ( new Short ( min . shortValue ( ) ) , new Short ( max . shortValue ( ) ) ) ; 
else init ( min , max ) ; 
} 
} 

public class CollectorManager { 
public final ByteBuffer allocateBuffer ( int size ) { 
if ( RECYCLE_BUFFER ) { 
ByteBuffer spentBuffer = recycleChannel . poll ( ) ; 
if ( spentBuffer == null ) spentBuffer = ByteBuffer . allocateDirect ( size ) ; 
spentBuffer . clear ( ) ; 
return spentBuffer ; 
} 
else return ByteBuffer . allocateDirect ( size ) ; 
} 
} 

public class CollectorManager { 
private boolean determineIfWeShouldExit ( ) { 
boolean shouldStop = stop . get ( ) ; 
if ( ! shouldStop ) Thread . interrupted ( ) ; 
else { 
System . out . println ( "Exiting processing loop as requested" ) ; 
return true ; 
} 
return false ; 
} 
} 

public class CollectorManager { 
private void manageInputWriterChannel ( ) throws InterruptedException { 
try { 
ByteBuffer dataToWriteToFile ; 
dataToWriteToFile = inputChannel . poll ( ) ; 
if ( dataToWriteToFile == null ) { 
queueEmptyMaybeFlush ( ) ; 
dataToWriteToFile = inputChannel . poll ( ) ; 
} 
if ( dataToWriteToFile == null ) dataToWriteToFile = waitForNextDataToWrite ( ) ; 
if ( dataToWriteToFile != null ) { 
writer . nextBufferToWrite ( dataToWriteToFile ) ; 
if ( RECYCLE_BUFFER ) recycleChannel . offer ( dataToWriteToFile ) ; 
} 
} 
catch ( InterruptedException ex ) { 
throw ex ; 
} 
catch ( Exception ex ) { 
ex . printStackTrace ( ) ; 
ex . printStackTrace ( System . err ) ; 
} 
} 
} 

public class CollectorManager { 
private void queueEmptyMaybeFlush ( ) { 
if ( PERIODIC_FORCE_FLUSH ) { 
long currentTime = time . get ( ) ; 
if ( ( currentTime - lastFlushTime ) > FORCE_FLUSH_AFTER_THIS_MANY_MILI_SECONDS ) { 
if ( writer . syncToDisk ( ) ) this . numberOfFlushesTotal . incrementAndGet ( ) ; 
lastFlushTime = time . get ( ) ; 
} 
} 
} 
} 

public class CollectorManager { 
public void start ( final TimeAware receiver ) { 
writerFuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { 
@ Override public void run ( ) { 
processWrites ( ) ; 
} 
} 
, 0 , 500 , TimeUnit . MILLISECONDS ) ; 
startMonitor ( ) ; 
tickTock = this . scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { 
@ Override public void run ( ) { 
long time = System . nanoTime ( ) / 1_000_000 ; 
if ( receiver != null ) receiver . tick ( time ) ; 
tick ( time ) ; 
} 
} 
, 0 , 20 , TimeUnit . MILLISECONDS ) ; 
} 
} 

public class LazyValueMap { 
@ Override public final Object get ( Object key ) { 
Object object = null ; 
if ( map == null ) buildMap ( ) ; 
object = map . get ( key ) ; 
lazyChopIfNeeded ( object ) ; 
return object ; 
} 
} 

public class FilterDefault { 
private ResultSet mainQueryPlan ( Criteria [ ] expressions ) { 
ResultSetInternal results = new ResultSetImpl ( this . fields ) ; 
if ( expressions == null || expressions . length == 0 ) results . addResults ( searchableCollection . all ( ) ) ; 
Group group = expressions . length == 1 && expressions [ 0 ] instanceof Group ? ( Group ) expressions [ 0 ] : ObjectFilter . and ( expressions ) ; 
doFilterGroup ( group , results ) ; 
return results ; 
} 
} 

public class FilterDefault { 
private void doFilterGroup ( Group group , ResultSetInternal results ) { 
if ( group . getGrouping ( ) == Grouping . OR ) or ( group . getExpressions ( ) , fields , results ) ; 
else { 
ResultSetInternal resultsForAnd = new ResultSetImpl ( fields ) ; 
and ( group . getExpressions ( ) , fields , resultsForAnd ) ; 
results . addResults ( resultsForAnd . asList ( ) ) ; 
} 
} 
} 

public class BatchFileWriter { 
public void tick ( long time ) { 
this . time . set ( time ) ; 
long startTime = fileStartTime . get ( ) ; 
long duration = time - startTime ; 
if ( duration > FILE_TIMEOUT_MILISECONDS ) fileTimeOut . set ( true ) ; 
} 
} 

public class BatchFileWriter { 
public boolean syncToDisk ( ) { 
if ( outputStream != null && dirty ) try { 
if ( outputStream instanceof FileChannel ) { 
FileChannel channel = ( FileChannel ) outputStream ; 
channel . force ( true ) ; 
} 
dirty = false ; 
return true ; 
} 
catch ( Exception ex ) { 
cleanupOutputStream ( ) ; 
return false ; 
} 
else return false ; 
} 
} 

public class BatchFileWriter { 
private void cleanupOutputStream ( ) { 
if ( outputStream != null ) try { 
outputStream . close ( ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( System . err ) ; 
} 
finally { 
outputStream = null ; 
} 
} 
} 

public class BatchFileWriter { 
public void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { 
dirty = true ; 
final int size = bufferOut . limit ( ) ; 
write ( bufferOut ) ; 
if ( ! error . get ( ) ) { 
totalBytesTransferred += size ; 
bytesTransferred += size ; 
bytesSinceLastFlush += size ; 
buffersSent ++ ; 
} 
if ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) try { 
outputStream . close ( ) ; 
} 
catch ( IOException e ) { 
cleanupOutputStream ( ) ; 
e . printStackTrace ( System . err ) ; 
} 
finally { 
outputStream = null ; 
} 
} 
} 

public class BatchFileWriter { 
private void write ( final ByteBuffer bufferOut ) throws InterruptedException { 
initOutputStream ( ) ; 
try { 
if ( outputStream != null ) outputStream . write ( bufferOut ) ; 
else error . set ( true ) ; 
if ( bytesSinceLastFlush > FLUSH_EVERY_N_BYTES ) { 
syncToDisk ( ) ; 
bytesSinceLastFlush = 0 ; 
} 
} 
catch ( ClosedByInterruptException cbie ) { 
throw new InterruptedException ( "File closed by interruption" ) ; 
} 
catch ( Exception e ) { 
cleanupOutputStream ( ) ; 
error . set ( true ) ; 
e . printStackTrace ( System . err ) ; 
diagnose ( ) ; 
Exceptions . handle ( e ) ; 
} 
} 
} 

public class BatchFileWriter { 
private void initOutputStream ( ) { 
long time = this . time . get ( ) ; 
if ( error . get ( ) || this . totalBytesTransferred == 0 ) { 
cleanupOutputStream ( ) ; 
error . set ( false ) ; 
time = System . nanoTime ( ) / 1_000_000 ; 
} 
if ( outputStream != null ) return ; 
fileName = LogFilesConfig . getLogFileName ( FORMAT_PATTERN , outputDirPath ( ) , numFiles , time , SERVER_NAME ) ; 
try { 
fileTimeOut . set ( false ) ; 
outputStream = streamCreator ( ) ; 
fileStartTime . set ( time ) ; 
bytesTransferred = 0 ; 
bytesSinceLastFlush = 0 ; 
} 
catch ( Exception ex ) { 
cleanupOutputStream ( ) ; 
error . set ( true ) ; 
Exceptions . handle ( ex ) ; 
} 
finally { 
numFiles ++ ; 
} 
} 
} 

public class BeanUtils { 
public static Object getPropByPath ( Object item , String ... path ) { 
Object o = item ; 
for ( int index = 0 ; 
index < path . length ; 
index ++ ) { 
String propName = path [ index ] ; 
if ( o == null ) return null ; 
else if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { 
o = getCollectionProp ( o , propName , index , path ) ; 
break ; 
} 
else o = getProp ( o , propName ) ; 
} 
return Conversions . unifyListOrArray ( o ) ; 
} 
} 

public class BeanUtils { 
public static Map < String , FieldAccess > getFieldsFromObject ( Object object ) { 
try { 
Map < String , FieldAccess > fields ; 
if ( object instanceof Map ) fields = getFieldsFromMap ( ( Map < String , Object > ) object ) ; 
else fields = getPropertyFieldAccessMap ( object . getClass ( ) ) ; 
return fields ; 
} 
catch ( Exception ex ) { 
requireNonNull ( object , "Item cannot be null" ) ; 
return handle ( Map . class , ex , "Unable to get fields from object" , className ( object ) ) ; 
} 
} 
} 

public class BeanUtils { 
private static Object getCollectionProp ( Object o , String propName , int index , String [ ] path ) { 
o = _getFieldValuesFromCollectionOrArray ( o , propName ) ; 
if ( index + 1 == path . length ) return o ; 
else { 
index ++ ; 
return getCollectionProp ( o , path [ index ] , index , path ) ; 
} 
} 
} 

public class BeanUtils { 
public static Object getProp ( Object object , final String property ) { 
if ( object == null ) return null ; 
if ( isDigits ( property ) ) object = idx ( object , StringScanner . parseInt ( property ) ) ; 
Class < ? > cls = object . getClass ( ) ; 
Map < String , FieldAccess > fields = Reflection . getPropertyFieldAccessors ( cls ) ; 
if ( ! fields . containsKey ( property ) ) fields = Reflection . getAllAccessorFields ( cls ) ; 
if ( ! fields . containsKey ( property ) ) return null ; 
else return fields . get ( property ) . getValue ( object ) ; 
} 
} 

public class BeanUtils { 
public static int getPropertyInt ( final Object root , final String ... properties ) { 
final String lastProperty = properties [ properties . length - 1 ] ; 
if ( isDigits ( lastProperty ) ) return Conversions . toInt ( getPropertyValue ( root , properties ) ) ; 
Object object = baseForGetProperty ( root , properties ) ; 
Map < String , FieldAccess > fields = getFieldsFromObject ( object ) ; 
FieldAccess field = fields . get ( lastProperty ) ; 
if ( field . type ( ) == Typ . intgr ) return field . getInt ( object ) ; 
else return Conversions . toInt ( field . getValue ( object ) ) ; 
} 
} 

public class MessageSpecification { 
public String createMessage ( String key , List < String > argKeys , Object ... args ) { 
String message = getMessage ( key ) ; 
Object [ ] actualArgs ; 
if ( args . length > 0 ) actualArgs = args ; 
else if ( argKeys != null ) actualArgs = keysToValues ( argKeys ) ; 
else actualArgs = new Object [ ] { 
} 
; 
return doCreateMessage ( message , actualArgs ) ; 
} 
} 

public class JsonSlurper { 
public Object parseText ( String text ) { 
if ( text == null || text . length ( ) == 0 ) throw new IllegalArgumentException ( "The JSON input text should neither be null nor empty." ) ; 
return JsonFactory . create ( ) . fromJson ( text ) ; 
} 
} 

public class EtcdClient { 
private void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { 
final HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; 
final Runnable runnable = new Runnable ( ) { 
@ Override public void run ( ) { 
if ( ! request . getMethod ( ) . equals ( "GET" ) ) httpClientRequest . putHeader ( "Content-Type" , "application/x-www-form-urlencoded" ) . end ( request . paramBody ( ) ) ; 
else httpClientRequest . end ( ) ; 
} 
} 
; 
if ( closed . get ( ) ) this . scheduledExecutorService . schedule ( new Runnable ( ) { 
@ Override public void run ( ) { 
connect ( ) ; 
int retry = 0 ; 
while ( closed . get ( ) ) { 
Sys . sleep ( 1000 ) ; 
if ( ! closed . get ( ) ) break ; 
retry ++ ; 
if ( retry > 10 ) break ; 
if ( retry % 3 == 0 ) connect ( ) ; 
} 
if ( ! closed . get ( ) ) runnable . run ( ) ; 
else responseHandler . handle ( new Response ( "TIMEOUT" , - 1 , new Error ( - 1 , "Timeout" , "Timeout" , - 1L ) ) ) ; 
} 
} 
, 10 , TimeUnit . MILLISECONDS ) ; 
else runnable . run ( ) ; 
} 
} 

public class CouchDbUtil { 
public static List < String > listResources ( String path ) { 
try { 
Class < CouchDbUtil > clazz = CouchDbUtil . class ; 
URL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; 
if ( dirURL != null && dirURL . getProtocol ( ) . equals ( "file" ) ) return Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; 
if ( dirURL != null && dirURL . getProtocol ( ) . equals ( "jar" ) ) { 
String jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( "!" ) ) ; 
JarFile jar = new JarFile ( URLDecoder . decode ( jarPath , "UTF-8" ) ) ; 
Enumeration < JarEntry > entries = jar . entries ( ) ; 
Set < String > result = new HashSet < String > ( ) ; 
while ( entries . hasMoreElements ( ) ) { 
String name = entries . nextElement ( ) . getName ( ) ; 
if ( name . startsWith ( SPRING_BOOT_DIR ) ) name = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; 
if ( name . startsWith ( path ) ) { 
String entry = name . substring ( path . length ( ) ) ; 
int checkSubdir = entry . indexOf ( "/" ) ; 
if ( checkSubdir >= 0 ) entry = entry . substring ( 0 , checkSubdir ) ; 
if ( entry . length ( ) > 0 ) result . add ( entry ) ; 
} 
} 
close ( jar ) ; 
return new ArrayList < String > ( result ) ; 
} 
return null ; 
} 
catch ( Exception e ) { 
throw new CouchDbException ( e ) ; 
} 
} 
} 

public class Replication { 
public ReplicationResult trigger ( ) { 
assertNotEmpty ( source , "Source" ) ; 
assertNotEmpty ( target , "Target" ) ; 
HttpResponse response = null ; 
try { 
JsonObject json = createJson ( ) ; 
if ( log . isDebugEnabled ( ) ) log . debug ( json ) ; 
final URI uri = buildUri ( dbc . getBaseUri ( ) ) . path ( "_replicate" ) . build ( ) ; 
response = dbc . post ( uri , json . toString ( ) ) ; 
final InputStreamReader reader = new InputStreamReader ( getStream ( response ) , Charsets . UTF_8 ) ; 
return dbc . getGson ( ) . fromJson ( reader , ReplicationResult . class ) ; 
} 
finally { 
close ( response ) ; 
} 
} 
} 

public class View { 
private < V > V queryValue ( Class < V > classOfV ) { 
InputStream instream = null ; 
try { 
Reader reader = new InputStreamReader ( instream = queryForStream ( ) , Charsets . UTF_8 ) ; 
JsonArray array = new JsonParser ( ) . parse ( reader ) . getAsJsonObject ( ) . get ( "rows" ) . getAsJsonArray ( ) ; 
if ( array . size ( ) != 1 ) throw new NoDocumentException ( "Expecting a single result but was: " + array . size ( ) ) ; 
return JsonToObject ( gson , array . get ( 0 ) , "value" , classOfV ) ; 
} 
finally { 
close ( instream ) ; 
} 
} 
} 

public class CouchDbDesign { 
public DesignDocument getFromDesk ( String id ) { 
assertNotEmpty ( id , "id" ) ; 
final DesignDocument dd = new DesignDocument ( ) ; 
final String rootPath = format ( "%s/%s/" , DESIGN_DOCS_DIR , id ) ; 
final List < String > elements = listResources ( rootPath ) ; 
if ( elements == null ) throw new IllegalArgumentException ( "Design docs directory cannot be empty." ) ; 
Map < String , MapReduce > views = null ; 
if ( elements . contains ( VIEWS ) ) { 
views = new HashMap < String , MapReduce > ( ) ; 
final String viewsPath = format ( "%s%s/" , rootPath , VIEWS ) ; 
for ( String viewDirName : listResources ( viewsPath ) ) { 
final MapReduce mr = new MapReduce ( ) ; 
final String viewPath = format ( "%s%s/" , viewsPath , viewDirName ) ; 
final List < String > dirList = listResources ( viewPath ) ; 
for ( String fileName : dirList ) { 
final String def = readFile ( format ( "/%s%s" , viewPath , fileName ) ) ; 
if ( MAP_JS . equals ( fileName ) ) mr . setMap ( def ) ; 
else if ( REDUCE_JS . equals ( fileName ) ) mr . setReduce ( def ) ; 
} 
views . put ( viewDirName , mr ) ; 
} 
} 
dd . setId ( DESIGN_PREFIX + id ) ; 
dd . setLanguage ( JAVASCRIPT ) ; 
dd . setViews ( views ) ; 
dd . setFilters ( populateMap ( rootPath , elements , FILTERS ) ) ; 
dd . setShows ( populateMap ( rootPath , elements , SHOWS ) ) ; 
dd . setLists ( populateMap ( rootPath , elements , LISTS ) ) ; 
dd . setUpdates ( populateMap ( rootPath , elements , UPDATES ) ) ; 
dd . setValidateDocUpdate ( readContent ( elements , rootPath , VALIDATE_DOC ) ) ; 
dd . setRewrites ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , REWRITES ) , JsonArray . class ) ) ; 
dd . setFulltext ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , FULLTEXT ) , JsonObject . class ) ) ; 
dd . setIndexes ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , INDEXES ) , JsonObject . class ) ) ; 
return dd ; 
} 
} 

public class CouchDbClientBase { 
void validate ( HttpResponse response ) throws IOException { 
final int code = response . getStatusLine ( ) . getStatusCode ( ) ; 
if ( code == 200 || code == 201 || code == 202 ) return ; 
String reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; 
switch ( code ) { 
case HttpStatus . SC_NOT_FOUND : { 
throw new NoDocumentException ( reason ) ; 
} 
case HttpStatus . SC_CONFLICT : { 
throw new DocumentConflictException ( reason ) ; 
} 
default : { 
throw new CouchDbException ( reason += EntityUtils . toString ( response . getEntity ( ) ) ) ; 
} 
} 
} 
} 

public class MoneyToStr { 
public String convert ( Double theMoney ) { 
if ( theMoney == null ) throw new IllegalArgumentException ( "theMoney is null" ) ; 
Long intPart = theMoney . longValue ( ) ; 
Long fractPart = Math . round ( ( theMoney - intPart ) * NUM100 ) ; 
if ( currency == Currency . PER1000 ) fractPart = Math . round ( ( theMoney - intPart ) * NUM1000 ) ; 
return convert ( intPart , fractPart ) ; 
} 
} 

public class LockManager { 
public void shutdown ( ) { 
try { 
locksExecutor . shutdown ( ) ; 
locksExecutor . awaitTermination ( 5 , TimeUnit . SECONDS ) ; 
CountDownLatch latch = new CountDownLatch ( 1 ) ; 
activeLocksLock . writeLock ( ) . lock ( ) ; 
Observable . from ( activeLocks . entrySet ( ) ) . map ( Map . Entry :: getValue ) . flatMap ( lock -> releaseLock ( lock . getName ( ) , lock . getValue ( ) ) . map ( released -> new Lock ( lock . getName ( ) , lock . getValue ( ) , lock . getExpiration ( ) , lock . getRenewalRate ( ) , ! released ) ) ) . subscribe ( lock -> { 
if ( lock . isLocked ( ) ) logger . infof ( "Failed to release lock %s" , lock . getName ( ) ) ; 
} 
, t -> { 
logger . info ( "There was an error while releasing locks" , t ) ; 
latch . countDown ( ) ; 
} 
, latch :: countDown ) ; 
latch . await ( ) ; 
logger . info ( "Shutdown complete" ) ; 
} 
catch ( InterruptedException e ) { 
logger . debug ( "Shutdown was interrupted. Some locks may not have been released but they will still expire." ) ; 
} 
} 
} 

public class TokenAuthenticator { 
private boolean isQuery ( HttpServerExchange serverExchange ) { 
if ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( "GET" ) || serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( "HEAD" ) ) return true ; 
else if ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( "POST" ) ) if ( postQuery != null && postQuery . matcher ( serverExchange . getRelativePath ( ) ) . find ( ) ) return true ; 
else return false ; 
else return false ; 
} 
} 

public class TokenAuthenticator { 
private void sendAuthenticationRequest ( HttpServerExchange serverExchange , PooledConnection connection ) { 
AuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; 
String verb = getVerb ( serverExchange ) ; 
String resource ; 
if ( ! isQuery ( serverExchange ) ) if ( USER_WRITE_ACCESS . equalsIgnoreCase ( "true" ) ) resource = RESOURCE ; 
else resource = resourceName ; 
else resource = RESOURCE ; 
context . subjectAccessReview = generateSubjectAccessReview ( context . tenant , verb , resource ) ; 
ClientRequest request = buildClientRequest ( context ) ; 
context . clientRequestStarting ( ) ; 
connection . sendRequest ( request , new RequestReadyCallback ( serverExchange , connection ) ) ; 
} 
} 

public class TokenAuthenticator { 
private String getVerb ( HttpServerExchange serverExchange ) { 
if ( isQuery ( serverExchange ) ) return VERBS . get ( GET ) ; 
else { 
String verb = VERBS . get ( serverExchange . getRequestMethod ( ) ) ; 
if ( verb == null ) { 
log . debugf ( "Unhandled http method '%s'. Checking for read access." , serverExchange . getRequestMethod ( ) ) ; 
verb = VERBS_DEFAULT ; 
} 
return verb ; 
} 
} 
} 

public class TokenAuthenticator { 
private void onRequestResult ( HttpServerExchange serverExchange , PooledConnection connection , boolean allowed ) { 
connectionPools . get ( serverExchange . getIoThread ( ) ) . release ( connection ) ; 
AuthContext context = serverExchange . removeAttachment ( AUTH_CONTEXT_KEY ) ; 
apiLatency . update ( context . getClientResponseTime ( ) , NANOSECONDS ) ; 
authLatency . update ( context . getLatency ( ) , NANOSECONDS ) ; 
if ( allowed ) serverExchange . dispatch ( containerHandler ) ; 
else endExchange ( serverExchange , FORBIDDEN ) ; 
} 
} 

public class TokenAuthenticator { 
private void onRequestFailure ( HttpServerExchange serverExchange , PooledConnection connection , IOException e , boolean retry ) { 
log . debug ( "Client request failure" , e ) ; 
IoUtils . safeClose ( connection ) ; 
ConnectionPool connectionPool = connectionPools . get ( serverExchange . getIoThread ( ) ) ; 
connectionPool . release ( connection ) ; 
AuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; 
if ( context . retries < MAX_RETRY && retry ) { 
context . retries ++ ; 
PooledConnectionWaiter waiter = createWaiter ( serverExchange ) ; 
if ( ! connectionPool . offer ( waiter ) ) endExchange ( serverExchange , INTERNAL_SERVER_ERROR , TOO_MANY_PENDING_REQUESTS ) ; 
} 
else endExchange ( serverExchange , INTERNAL_SERVER_ERROR , CLIENT_REQUEST_FAILURE ) ; 
} 
} 

public class JobsService { 
public Observable < JobDetails > findScheduledJobs ( Date timeSlice , rx . Scheduler scheduler ) { 
return session . executeAndFetch ( findAllScheduled . bind ( ) , scheduler ) . filter ( filterNullJobs ) . filter ( row -> row . getTimestamp ( 0 ) . compareTo ( timeSlice ) <= 0 ) . map ( row -> createJobDetails ( row . getUUID ( 1 ) , row . getString ( 2 ) , row . getString ( 3 ) , row . getMap ( 4 , String . class , String . class ) , getTrigger ( row . getUDTValue ( 5 ) ) , JobStatus . fromCode ( row . getByte ( 6 ) ) , timeSlice ) ) . collect ( HashMap :: new , ( Map < UUID , SortedSet < JobDetails > > map , JobDetails details ) -> { 
SortedSet < JobDetails > set = map . get ( details . getJobId ( ) ) ; 
if ( set == null ) set = new TreeSet < > ( ( JobDetails d1 , JobDetails d2 ) -> Long . compare ( d1 . getTrigger ( ) . getTriggerTime ( ) , d2 . getTrigger ( ) . getTriggerTime ( ) ) ) ; 
set . add ( details ) ; 
map . put ( details . getJobId ( ) , set ) ; 
} 
) . flatMap ( map -> Observable . from ( map . entrySet ( ) ) ) . map ( entry -> entry . getValue ( ) . first ( ) ) ; 
} 
} 

public class Utils { 
public static void endExchange ( HttpServerExchange exchange , int statusCode , String reasonPhrase ) { 
exchange . setStatusCode ( statusCode ) ; 
if ( reasonPhrase != null ) exchange . setReasonPhrase ( reasonPhrase ) ; 
exchange . endExchange ( ) ; 
} 
} 

public class DataAccessImpl { 
@ Override public Observable < Observable < Row > > findAllDataFromBucket ( long timestamp , int pageSize , int maxConcurrency ) { 
PreparedStatement ts = getTempStatement ( MetricType . UNDEFINED , TempStatement . SCAN_WITH_TOKEN_RANGES , timestamp ) ; 
if ( ts == null || prepMap . floorKey ( timestamp ) == 0L ) return Observable . empty ( ) ; 
return Observable . from ( getTokenRanges ( ) ) . map ( tr -> rxSession . executeAndFetch ( ts . bind ( ) . setToken ( 0 , tr . getStart ( ) ) . setToken ( 1 , tr . getEnd ( ) ) . setFetchSize ( pageSize ) ) ) ; 
} 
} 

public class Buckets { 
public static Buckets fromStep ( long start , long end , long step ) { 
checkTimeRange ( start , end ) ; 
checkArgument ( step > 0 , "step is not positive: %s" , step ) ; 
if ( step > ( end - start ) ) return new Buckets ( start , step , 1 ) ; 
long quotient = ( end - start ) / step ; 
long remainder = ( end - start ) % step ; 
long count ; 
if ( remainder == 0 ) count = quotient ; 
else count = quotient + 1 ; 
checkArgument ( count <= Integer . MAX_VALUE , "Computed number of buckets is too big: %s" , count ) ; 
return new Buckets ( start , step , ( int ) count ) ; 
} 
} 

public class MockJedis { 
@ Override public ScanResult < String > scan ( String cursor , ScanParams params ) { 
Collection < byte [ ] > rawParams = params . getParams ( ) ; 
boolean isKey = true ; 
String match = null ; 
boolean foundMatchKey = false ; 
for ( byte [ ] raw : rawParams ) { 
if ( isKey ) { 
String key = new String ( raw ) ; 
if ( key . equals ( new String ( MATCH . raw ) ) ) foundMatchKey = true ; 
} 
else if ( foundMatchKey ) { 
match = new String ( raw ) ; 
break ; 
} 
isKey = ! isKey ; 
} 
return new ScanResult < String > ( "0" , new ArrayList < String > ( keys ( match ) ) ) ; 
} 
} 

public class ZipBuilder { 
public File build ( ) throws IOException { 
if ( entries . isEmpty ( ) ) throw new EmptyZipException ( ) ; 
String fileName = "import_configuration" + System . currentTimeMillis ( ) + ".zip" ; 
File result = new File ( TEMP_DIR . toFile ( ) , fileName ) ; 
try ( ZipOutputStream zip = new ZipOutputStream ( Files . newOutputStream ( result . toPath ( ) , StandardOpenOption . CREATE_NEW ) ) ) { 
customization . init ( entries . values ( ) , this :: streamFor ) ; 
for ( Entry < Object , String > entry : entries . entrySet ( ) ) { 
try ( InputStream input = toInputStream ( entry . getKey ( ) ) ) { 
addEntry ( ExtraZipEntry . of ( entry . getValue ( ) , customization . customize ( entry . getValue ( ) , input ) ) , zip ) ; 
} 
} 
customization . extraEntries ( ) . forEach ( entry -> addEntry ( entry , zip ) ) ; 
zip . closeEntry ( ) ; 
} 
return result ; 
} 
} 

public class UniqueDirectory { 
public static File in ( File parentDir ) { 
File result = new File ( parentDir , UUID . randomUUID ( ) . toString ( ) ) ; 
if ( ! result . mkdirs ( ) ) throw new RuntimeIoException ( new IOException ( "Could not create directory: " + result ) ) ; 
return result ; 
} 
} 

public class BatchSipAssembler { 
public synchronized void add ( D domainObject ) throws IOException { 
if ( shouldStartNewSip ( domainObject ) ) startSip ( ) ; 
assembler . add ( domainObject ) ; 
} 
} 

public class IOStreams { 
public static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { 
byte [ ] buffer = new byte [ bufferSize ] ; 
int numRead = Objects . requireNonNull ( in , "Missing input" ) . read ( buffer ) ; 
if ( numRead == 0 ) throw new IllegalArgumentException ( "Missing content" ) ; 
Objects . requireNonNull ( out , "Missing output" ) ; 
while ( numRead > 0 ) { 
out . write ( buffer , 0 , numRead ) ; 
hashAssembler . add ( buffer , numRead ) ; 
numRead = in . read ( buffer ) ; 
} 
} 
} 

public class XmlUtil { 
public static Document parse ( File file ) { 
if ( ! file . isFile ( ) ) throw new IllegalArgumentException ( "Missing file: " + file . getAbsolutePath ( ) ) ; 
try { 
try ( InputStream stream = Files . newInputStream ( file . toPath ( ) , StandardOpenOption . READ ) ) { 
return parse ( stream ) ; 
} 
} 
catch ( IOException e ) { 
throw new IllegalArgumentException ( "Failed to parse " + file . getAbsolutePath ( ) , e ) ; 
} 
} 
} 

public class FileArchiver { 
public static void main ( String [ ] args ) { 
try { 
Arguments arguments = new Arguments ( args ) ; 
File root = new File ( arguments . next ( "content" ) ) ; 
if ( ! root . isDirectory ( ) ) root = new File ( "." ) ; 
String rootPath = root . getCanonicalPath ( ) ; 
String sip = arguments . next ( "build/files.zip" ) ; 
new FileArchiver ( ) . run ( rootPath , sip ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( System . out ) ; 
System . exit ( 1 ) ; 
} 
} 
} 

public class QSStringUtil { 
public static String asciiCharactersEncoding ( String str ) throws QSException { 
if ( QSStringUtil . isEmpty ( str ) ) return "" ; 
try { 
String encoded = URLEncoder . encode ( str , QSConstant . ENCODING_UTF8 ) ; 
encoded = encoded . replace ( "%2F" , "/" ) ; 
encoded = encoded . replace ( "%3D" , "=" ) ; 
encoded = encoded . replace ( "+" , "%20" ) ; 
encoded = encoded . replace ( "%3A" , ":" ) ; 
return encoded ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new QSException ( "UnsupportedEncodingException:" , e ) ; 
} 
} 
} 

public class Base64 { 
private static int removeWhiteSpace ( char [ ] data ) { 
if ( data == null ) return 0 ; 
int newSize = 0 ; 
int len = data . length ; 
for ( int i = 0 ; 
i < len ; 
i ++ ) if ( ! isWhiteSpace ( data [ i ] ) ) data [ newSize ++ ] = data [ i ] ; 
return newSize ; 
} 
} 

public class UploadManager { 
private void completeMultiUpload ( String objectKey , String fileName , String eTag , String uploadID , long length ) throws QSException { 
CompleteMultipartUploadInput completeMultipartUploadInput = new CompleteMultipartUploadInput ( uploadID , partCounts , 0 ) ; 
completeMultipartUploadInput . setContentLength ( length ) ; 
if ( ! QSStringUtil . isEmpty ( fileName ) ) try { 
String keyName = QSStringUtil . percentEncode ( fileName , "UTF-8" ) ; 
completeMultipartUploadInput . setContentDisposition ( String . format ( "attachment; filename=\"%s\"; filename*=utf-8''%s" , keyName , keyName ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
e . printStackTrace ( ) ; 
} 
if ( ! QSStringUtil . isEmpty ( eTag ) ) completeMultipartUploadInput . setETag ( eTag ) ; 
RequestHandler requestHandler = bucket . completeMultipartUploadRequest ( objectKey , completeMultipartUploadInput ) ; 
sign ( requestHandler ) ; 
Bucket . CompleteMultipartUploadOutput send = ( Bucket . CompleteMultipartUploadOutput ) requestHandler . send ( ) ; 
if ( send . getStatueCode ( ) == 200 || send . getStatueCode ( ) == 201 ) { 
uploadModel . setUploadComplete ( true ) ; 
setData ( objectKey , recorder ) ; 
} 
if ( callBack != null ) callBack . onAPIResponse ( objectKey , send ) ; 
} 
} 

public class FavoriteAction { 
@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { 
final NotificationEntry entry = getTarget ( ) ; 
final String notificationId = entry . getId ( ) ; 
final Set < String > favoriteNotices = this . getFavoriteNotices ( req ) ; 
if ( favoriteNotices . contains ( notificationId ) ) favoriteNotices . remove ( notificationId ) ; 
else favoriteNotices . add ( notificationId ) ; 
setFavoriteNotices ( req , favoriteNotices ) ; 
} 
} 

public class JpaNotificationService { 
public void addEntryState ( PortletRequest req , String entryId , NotificationState state ) { 
if ( usernameFinder . isAuthenticated ( req ) ) { 
final String username = usernameFinder . findUsername ( req ) ; 
String idStr = entryId . replaceAll ( ID_PREFIX , "" ) ; 
JpaEntry jpaEntry = notificationDao . getEntry ( Long . parseLong ( idStr ) ) ; 
if ( jpaEntry != null ) { 
JpaEvent event = new JpaEvent ( ) ; 
event . setEntry ( jpaEntry ) ; 
event . setState ( state ) ; 
event . setTimestamp ( new Timestamp ( new Date ( ) . getTime ( ) ) ) ; 
event . setUsername ( username ) ; 
notificationDao . createOrUpdateEvent ( event ) ; 
} 
else throw new IllegalArgumentException ( "JpaEntry not found" ) ; 
} 
} 
} 

public class SSPToken { 
public boolean hasExpired ( ) { 
long now = System . currentTimeMillis ( ) ; 
if ( created + ( expiresIn * 1000 ) + TIMEOUT_BUFFER > now ) return false ; 
return true ; 
} 
} 

public class SSPApi { 
private synchronized SSPToken getAuthenticationToken ( boolean forceUpdate ) throws MalformedURLException , RestClientException { 
if ( authenticationToken != null && ! authenticationToken . hasExpired ( ) && ! forceUpdate ) return authenticationToken ; 
String authString = getClientId ( ) + ":" + getClientSecret ( ) ; 
String authentication = new Base64 ( ) . encodeToString ( authString . getBytes ( ) ) ; 
HttpHeaders headers = new HttpHeaders ( ) ; 
headers . add ( AUTHORIZATION , BASIC + " " + authentication ) ; 
MultiValueMap < String , String > form = new LinkedMultiValueMap < > ( ) ; 
form . add ( GRANT_TYPE , CLIENT_CREDENTIALS ) ; 
HttpEntity < MultiValueMap < String , String > > request = new HttpEntity < > ( form , headers ) ; 
URL authURL = getAuthenticationURL ( ) ; 
authenticationToken = restTemplate . postForObject ( authURL . toExternalForm ( ) , request , SSPToken . class ) ; 
return authenticationToken ; 
} 
} 

public class NotificationResponse { 
private void addCategories ( List < NotificationCategory > newCategories ) { 
if ( newCategories == null ) return ; 
newCategories = newCategories . parallelStream ( ) . map ( NotificationCategory :: cloneNoExceptions ) . collect ( Collectors . toList ( ) ) ; 
Map < String , NotificationCategory > catsByName = this . categories . parallelStream ( ) . collect ( toMap ( c -> c . getTitle ( ) . toLowerCase ( ) , c -> c ) ) ; 
Map < Boolean , List < NotificationCategory > > matchingNewCats = newCategories . stream ( ) . collect ( partitioningBy ( c -> catsByName . containsKey ( c . getTitle ( ) . toLowerCase ( ) ) ) ) ; 
matchingNewCats . get ( Boolean . TRUE ) . stream ( ) . forEachOrdered ( c -> catsByName . get ( c . getTitle ( ) . toLowerCase ( ) ) . addEntries ( c . getEntries ( ) ) ) ; 
this . categories . addAll ( matchingNewCats . get ( Boolean . FALSE ) ) ; 
} 
} 

public class SSPTaskNotificationService { 
@ Override public NotificationResponse fetch ( PortletRequest req ) { 
PortletPreferences preferences = req . getPreferences ( ) ; 
String enabled = preferences . getValue ( SSP_NOTIFICATIONS_ENABLED , "false" ) ; 
if ( ! "true" . equalsIgnoreCase ( enabled ) ) return new NotificationResponse ( ) ; 
String personId = getPersonId ( req ) ; 
if ( personId == null ) return new NotificationResponse ( ) ; 
String urlFragment = getActiveTaskUrl ( ) ; 
SSPApiRequest < String > request = new SSPApiRequest < > ( urlFragment , String . class ) . addUriParameter ( "personId" , personId ) ; 
ResponseEntity < String > response ; 
try { 
response = sspApi . doRequest ( request ) ; 
} 
catch ( Exception e ) { 
log . error ( "Error reading SSP Notifications: " + e . getMessage ( ) ) ; 
return notificationError ( e . getMessage ( ) ) ; 
} 
if ( response . getStatusCode ( ) . series ( ) != HttpStatus . Series . SUCCESSFUL ) { 
log . error ( "Error reading SSP Notifications: " + response ) ; 
return notificationError ( response . getBody ( ) ) ; 
} 
NotificationResponse notification = mapToNotificationResponse ( req , response ) ; 
return notification ; 
} 
} 

public class SSPTaskNotificationService { 
private NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { 
Configuration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; 
ReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; 
String success = readContext . read ( SUCCESS_QUERY ) ; 
if ( ! "true" . equalsIgnoreCase ( success ) ) { 
String error = readContext . read ( MESSAGE_QUERY ) ; 
return notificationError ( error ) ; 
} 
Object rows = readContext . read ( ROWS_QUERY ) ; 
if ( ! ( rows instanceof JSONArray ) ) throw new RuntimeException ( "Expected 'rows' to be an array of tasks" ) ; 
String source = getNotificationSource ( request ) ; 
List < NotificationEntry > list = new ArrayList < > ( ) ; 
for ( int i = 0 ; 
i < ( ( JSONArray ) rows ) . size ( ) ; 
i ++ ) { 
NotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; 
if ( entry != null ) { 
attachActions ( request , entry ) ; 
list . add ( entry ) ; 
} 
} 
NotificationResponse notification = new NotificationResponse ( ) ; 
if ( ! list . isEmpty ( ) ) { 
NotificationCategory category = getNotificationCategory ( request ) ; 
category . addEntries ( list ) ; 
notification . setCategories ( Arrays . asList ( category ) ) ; 
} 
return notification ; 
} 
} 

public class SSPTaskNotificationService { 
private NotificationEntry mapNotificationEntry ( ReadContext readContext , int index , String source ) { 
boolean completed = readContext . read ( format ( ROW_COMPLETED_QUERY_FMT , index ) , Boolean . class ) ; 
if ( completed ) return null ; 
NotificationEntry entry = new NotificationEntry ( ) ; 
entry . setSource ( source ) ; 
String id = readContext . read ( format ( ROW_ID_QUERY_FMT , index ) ) ; 
entry . setId ( id ) ; 
String title = readContext . read ( format ( ROW_NAME_QUERY_FMT , index ) ) ; 
entry . setTitle ( title ) ; 
String desc = readContext . read ( format ( ROW_DESCRIPTION_QUERY_FMT , index ) ) ; 
entry . setBody ( desc ) ; 
String link = readContext . read ( format ( ROW_LINK_QUERY_FMT , index ) ) ; 
URL fixedLink = normalizeLink ( link ) ; 
if ( fixedLink != null ) entry . setUrl ( fixedLink . toExternalForm ( ) ) ; 
Date createDate = readContext . read ( format ( "$.rows[%d].createdDate" , index ) , Date . class ) ; 
Map < NotificationState , Date > states = new HashMap < > ( ) ; 
states . put ( NotificationState . ISSUED , createDate ) ; 
try { 
String dateStr = readContext . read ( format ( ROW_DUE_DATE_QUERY_FMT , index ) ) ; 
if ( ! StringUtils . isBlank ( dateStr ) ) synchronized ( dateFormat ) { 
Date dueDate = dateFormat . parse ( dateStr ) ; 
entry . setDueDate ( dueDate ) ; 
} 
} 
catch ( Exception e ) { 
log . warn ( "Error parsing due date.  Ignoring" , e ) ; 
} 
return entry ; 
} 
} 

public class SSPTaskNotificationService { 
private URL normalizeLink ( String link ) { 
try { 
if ( StringUtils . isEmpty ( link ) ) return null ; 
if ( link . startsWith ( "/" ) ) return sspApi . getSSPUrl ( link , true ) ; 
if ( link . startsWith ( "http://" ) || link . startsWith ( "https://" ) ) return new URL ( link ) ; 
return new URL ( "http://" + link ) ; 
} 
catch ( MalformedURLException e ) { 
log . warn ( "Bad URL from SSP Entry: " + link , e ) ; 
return null ; 
} 
} 
} 

public class ReadAction { 
@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { 
final NotificationEntry entry = getTarget ( ) ; 
final String notificationId = entry . getId ( ) ; 
final Set < String > readNotices = this . getReadNotices ( req ) ; 
if ( readNotices . contains ( notificationId ) ) readNotices . remove ( notificationId ) ; 
else readNotices . add ( notificationId ) ; 
setReadNotices ( req , readNotices ) ; 
} 
} 

public class ClassLoaderResourceNotificationService { 
private NotificationResponse readFromFile ( String filename ) { 
NotificationResponse rslt ; 
logger . debug ( "Preparing to read from file:  {}" , filename ) ; 
URL location = getClass ( ) . getClassLoader ( ) . getResource ( filename ) ; 
if ( location != null ) try { 
File f = new File ( location . toURI ( ) ) ; 
rslt = mapper . readValue ( f , NotificationResponse . class ) ; 
} 
catch ( Exception e ) { 
String msg = "Failed to read the data file:  " + location ; 
logger . error ( msg , e ) ; 
rslt = prepareErrorResponse ( getName ( ) , msg ) ; 
} 
else { 
String msg = "Data file not found:  " + filename ; 
rslt = prepareErrorResponse ( getName ( ) , msg ) ; 
} 
return rslt ; 
} 
} 

public class SSPSchoolIdPersonLookup { 
private String getSchoolId ( PortletRequest request ) { 
PortletPreferences prefs = request . getPreferences ( ) ; 
String schoolIdAttributeName = prefs . getValue ( "SSPTaskNotificationService.schoolIdAttribute" , "schoolId" ) ; 
Map < String , String > userInfo = ( Map < String , String > ) request . getAttribute ( PortletRequest . USER_INFO ) ; 
String studentId = userInfo . get ( schoolIdAttributeName ) ; 
if ( ! StringUtils . isEmpty ( studentId ) ) return studentId ; 
studentId = userInfo . get ( USERNAME_ATTRIBUTE ) ; 
return studentId ; 
} 
} 

public class SSPSchoolIdPersonLookup { 
private String extractUserId ( String studentId , ResponseEntity < String > response ) { 
Configuration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; 
ReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; 
String success = readContext . read ( SUCCESS_QUERY ) ; 
if ( ! "true" . equalsIgnoreCase ( success ) ) return null ; 
int count = readContext . read ( RESULTS_QUERY , Integer . class ) ; 
if ( count != 1 ) { 
log . warn ( "Expected a single unique result for " + studentId + ".  Found " + count ) ; 
return null ; 
} 
String id = readContext . read ( STUDENT_ID_QUERY ) ; 
return id ; 
} 
} 

public class HideAction { 
@ Override public void invoke ( final ActionRequest req , final ActionResponse res ) throws IOException { 
final NotificationEntry entry = getTarget ( ) ; 
if ( ! isEntrySnoozed ( entry , req ) ) hide ( entry , req ) ; 
else unhide ( entry , req ) ; 
} 
} 

public class DistancePointTriangle3D_F64 { 
public void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { 
GeometryMath_F64 . sub ( B , P , D ) ; 
a = E0 . dot ( E0 ) ; 
b = E0 . dot ( E1 ) ; 
c = E1 . dot ( E1 ) ; 
d = E0 . dot ( D ) ; 
e = E1 . dot ( D ) ; 
double det = a * c - b * b ; 
s = b * e - c * d ; 
t = b * d - a * e ; 
if ( s + t <= det ) if ( s < 0 ) if ( t < 0 ) region4 ( ) ; 
else region3 ( ) ; 
else if ( t < 0 ) region5 ( ) ; 
else region0 ( det ) ; 
else if ( s < 0 ) region2 ( ) ; 
else if ( t < 0 ) region6 ( ) ; 
else region1 ( ) ; 
closestPt . x = B . x + s * E0 . x + t * E1 . x ; 
closestPt . y = B . y + s * E0 . y + t * E1 . y ; 
closestPt . z = B . z + s * E0 . z + t * E1 . z ; 
} 
} 

public class UtilPolygons2D_F64 { 
public static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { 
rectangle . p0 . set ( polygon . get ( 0 ) ) ; 
rectangle . p1 . set ( polygon . get ( 0 ) ) ; 
for ( int i = 0 ; 
i < polygon . size ( ) ; 
i ++ ) { 
Point2D_F64 p = polygon . get ( i ) ; 
if ( p . x < rectangle . p0 . x ) rectangle . p0 . x = p . x ; 
else if ( p . x > rectangle . p1 . x ) rectangle . p1 . x = p . x ; 
if ( p . y < rectangle . p0 . y ) rectangle . p0 . y = p . y ; 
else if ( p . y > rectangle . p1 . y ) rectangle . p1 . y = p . y ; 
} 
} 
} 

public class UtilPolygons2D_F64 { 
public static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { 
Point2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; 
for ( int i = 0 ; 
i < points . size ( ) ; 
i ++ ) array [ i ] = points . get ( i ) ; 
AndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; 
andrew . process ( array , array . length , hull ) ; 
} 
} 

public class UtilPolygons2D_F64 { 
public static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { 
for ( int i = 0 ; 
i < polygon . vertexes . size ( ) ; 
) { 
int j = ( i + 1 ) % polygon . vertexes . size ( ) ; 
int k = ( i + 2 ) % polygon . vertexes . size ( ) ; 
Point2D_F64 p0 = polygon . vertexes . get ( i ) ; 
Point2D_F64 p1 = polygon . vertexes . get ( j ) ; 
Point2D_F64 p2 = polygon . vertexes . get ( k ) ; 
double angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; 
if ( angle <= tol ) { 
polygon . vertexes . remove ( j ) ; 
if ( j < i ) i = polygon . vertexes . size ( ) - 1 ; 
} 
else i ++ ; 
} 
} 
} 

public class UtilPolygons2D_F64 { 
public static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { 
LineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; 
double cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; 
double totalLength = 0 ; 
for ( int i = 0 ; 
i < target . size ( ) ; 
i ++ ) { 
Point2D_F64 b0 = target . get ( i % target . size ( ) ) ; 
Point2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; 
cornerLocationsB [ i ] = totalLength ; 
totalLength += b0 . distance ( b1 ) ; 
} 
cornerLocationsB [ target . size ( ) ] = totalLength ; 
Point2D_F64 pointOnB = new Point2D_F64 ( ) ; 
double error = 0 ; 
int cornerB = 0 ; 
for ( int k = 0 ; 
k < numberOfSamples ; 
k ++ ) { 
double location = totalLength * k / numberOfSamples ; 
while ( location > cornerLocationsB [ cornerB + 1 ] ) cornerB ++ ; 
Point2D_F64 b0 = target . get ( cornerB ) ; 
Point2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; 
double locationCornerB = cornerLocationsB [ cornerB ] ; 
double fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; 
pointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; 
pointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; 
double best = Double . MAX_VALUE ; 
for ( int i = 0 ; 
i < model . size ( ) + 1 ; 
i ++ ) { 
line . a = model . get ( i % model . size ( ) ) ; 
line . b = model . get ( ( i + 1 ) % model . size ( ) ) ; 
double d = Distance2D_F64 . distance ( line , pointOnB ) ; 
if ( d < best ) best = d ; 
} 
error += best ; 
} 
return error / numberOfSamples ; 
} 
} 

public class Intersection2D_F64 { 
public static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , Point2D_F64 ret ) { 
double a0 = l_0 . b . x - l_0 . a . x ; 
double b0 = l_0 . b . y - l_0 . a . y ; 
double a1 = l_1 . b . x - l_1 . a . x ; 
double b1 = l_1 . b . y - l_1 . a . y ; 
double top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; 
double bottom = a0 * b1 - b0 * a1 ; 
if ( bottom == 0 ) return null ; 
double t_1 = top / bottom ; 
if ( t_1 < 0 || t_1 > 1 ) return null ; 
top = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; 
bottom = a1 * b0 - b1 * a0 ; 
double t_0 = top / bottom ; 
if ( t_0 < 0 || t_0 > 1 ) return null ; 
if ( ret == null ) ret = new Point2D_F64 ( ) ; 
ret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; 
return ret ; 
} 
} 

public class ConvertRotation3D_F64 { 
private static double get ( DMatrixRMaj M , int index ) { 
if ( index < 0 ) return - M . data [ - index - 1 ] ; 
else return M . data [ index - 1 ] ; 
} 
} 

public class Polygon2D_F64 { 
public boolean isInside ( Point2D_F64 p ) { 
if ( isConvex ( ) ) return Intersection2D_F64 . containConvex ( this , p ) ; 
else return Intersection2D_F64 . containConcave ( this , p ) ; 
} 
} 

public class InterpolateLinearSe2_F64 { 
public static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { 
double w0 = 1.0 - where ; 
output . T . x = a . T . x * w0 + b . T . x * where ; 
output . T . y = a . T . y * w0 + b . T . y * where ; 
double yaw0 = a . getYaw ( ) ; 
double yaw1 = b . getYaw ( ) ; 
double cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; 
double ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; 
double yaw ; 
if ( cw > ccw ) yaw = yaw0 + ccw * where ; 
else yaw = yaw0 - cw * where ; 
output . setYaw ( yaw ) ; 
} 
} 

public class AndrewMonotoneConvexHull_F64 { 
public void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { 
if ( length == 2 ) { 
hull . vertexes . resize ( length ) ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) hull . get ( i ) . set ( input [ i ] ) ; 
return ; 
} 
sorter . sort ( input , length ) ; 
work . reset ( ) ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) { 
Point2D_F64 p = input [ i ] ; 
while ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) work . removeTail ( ) ; 
work . add ( p ) ; 
} 
work . removeTail ( ) ; 
int minSize = work . size + 2 ; 
for ( int i = length - 1 ; 
i >= 0 ; 
i -- ) { 
Point2D_F64 p = input [ i ] ; 
while ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) work . removeTail ( ) ; 
work . add ( p ) ; 
} 
work . removeTail ( ) ; 
hull . vertexes . resize ( work . size ) ; 
for ( int i = 0 ; 
i < work . size ( ) ; 
i ++ ) hull . vertexes . data [ i ] . set ( work . get ( i ) ) ; 
} 
} 

public class SpecialEuclideanOps_F64 { 
public static Se3_F64 axisXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , Se3_F64 se ) { 
if ( se == null ) se = new Se3_F64 ( ) ; 
double theta = Math . sqrt ( rotX * rotX + rotY + rotY + rotZ * rotZ ) ; 
if ( theta == 0 ) CommonOps_DDRM . setIdentity ( se . R ) ; 
else ConvertRotation3D_F64 . rodriguesToMatrix ( rotX / theta , rotY / theta , rotZ / theta , theta , se . getR ( ) ) ; 
Vector3D_F64 T = se . getT ( ) ; 
T . x = dx ; 
T . y = dy ; 
T . z = dz ; 
return se ; 
} 
} 

public class ClosestPoint3D_F64 { 
public static Point3D_F64 closestPoint ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 , Point3D_F64 ret ) { 
if ( ret == null ) ret = new Point3D_F64 ( ) ; 
ret . x = l0 . p . x - l1 . p . x ; 
ret . y = l0 . p . y - l1 . p . y ; 
ret . z = l0 . p . z - l1 . p . z ; 
double dv01v1 = MiscOps . dot ( ret , l1 . slope ) ; 
double dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; 
double dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; 
double t0 = dv01v1 * dv1v0 - MiscOps . dot ( ret , l0 . slope ) * dv1v1 ; 
double bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; 
if ( bottom == 0 ) return null ; 
t0 /= bottom ; 
double t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; 
ret . x = ( double ) 0.5 * ( ( l0 . p . x + t0 * l0 . slope . x ) + ( l1 . p . x + t1 * l1 . slope . x ) ) ; 
ret . y = ( double ) 0.5 * ( ( l0 . p . y + t0 * l0 . slope . y ) + ( l1 . p . y + t1 * l1 . slope . y ) ) ; 
ret . z = ( double ) 0.5 * ( ( l0 . p . z + t0 * l0 . slope . z ) + ( l1 . p . z + t1 * l1 . slope . z ) ) ; 
return ret ; 
} 
} 

public class ClosestPoint3D_F64 { 
public static Point3D_F64 closestPoint ( LineParametric3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { 
if ( ret == null ) ret = new Point3D_F64 ( ) ; 
double dx = pt . x - line . p . x ; 
double dy = pt . y - line . p . y ; 
double dz = pt . z - line . p . z ; 
double n2 = line . slope . normSq ( ) ; 
double d = ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) ; 
ret . x = line . p . x + d * line . slope . x / n2 ; 
ret . y = line . p . y + d * line . slope . y / n2 ; 
ret . z = line . p . z + d * line . slope . z / n2 ; 
return ret ; 
} 
} 

public class ClosestPoint3D_F64 { 
public static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { 
if ( ret == null ) ret = new Point3D_F64 ( ) ; 
double dx = pt . x - line . a . x ; 
double dy = pt . y - line . a . y ; 
double dz = pt . z - line . a . z ; 
double slope_x = line . b . x - line . a . x ; 
double slope_y = line . b . y - line . a . y ; 
double slope_z = line . b . z - line . a . z ; 
double n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; 
double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; 
if ( d <= 0 ) ret . set ( line . a ) ; 
else if ( d >= n ) ret . set ( line . b ) ; 
else { 
ret . x = line . a . x + d * slope_x / n ; 
ret . y = line . a . y + d * slope_y / n ; 
ret . z = line . a . z + d * slope_z / n ; 
} 
return ret ; 
} 
} 

public class ClosestPoint3D_F64 { 
public static Point3D_F64 closestPoint ( Point3D_F64 vertexA , Point3D_F64 vertexB , Point3D_F64 vertexC , Point3D_F64 point , Point3D_F64 ret ) { 
if ( ret == null ) ret = new Point3D_F64 ( ) ; 
DistancePointTriangle3D_F64 alg = new DistancePointTriangle3D_F64 ( ) ; 
alg . setTriangle ( vertexA , vertexB , vertexC ) ; 
alg . closestPoint ( point , ret ) ; 
return ret ; 
} 
} 

public class SePointOps_F64 { 
public static Point2D_F64 transform ( Se2_F64 se , Point2D_F64 orig , Point2D_F64 result ) { 
if ( result == null ) result = new Point2D_F64 ( ) ; 
final double c = se . getCosineYaw ( ) ; 
final double s = se . getSineYaw ( ) ; 
double x = orig . x ; 
double y = orig . y ; 
result . x = se . getX ( ) + x * c - y * s ; 
result . y = se . getY ( ) + x * s + y * c ; 
return result ; 
} 
} 

public class UtilLine2D_F64 { 
public static LineGeneral2D_F64 convert ( LineParametric2D_F64 src , LineGeneral2D_F64 ret ) { 
if ( ret == null ) ret = new LineGeneral2D_F64 ( ) ; 
ret . A = - src . slope . y ; 
ret . B = src . slope . x ; 
ret . C = - ret . A * src . p . x - ret . B * src . p . y ; 
return ret ; 
} 
} 

public class UtilLine2D_F64 { 
public static LineParametric2D_F64 convert ( LineGeneral2D_F64 src , LineParametric2D_F64 ret ) { 
if ( ret == null ) ret = new LineParametric2D_F64 ( ) ; 
ret . slope . x = src . B ; 
ret . slope . y = - src . A ; 
if ( Math . abs ( src . B ) > Math . abs ( src . A ) ) { 
ret . p . y = - src . C / src . B ; 
ret . p . x = 0 ; 
} 
else { 
ret . p . x = - src . C / src . A ; 
ret . p . y = 0 ; 
} 
return ret ; 
} 
} 

public class GeoTuple_F64 { 
@ Override public T copy ( ) { 
T ret = createNewInstance ( ) ; 
int N = getDimension ( ) ; 
for ( int i = 0 ; 
i < N ; 
i ++ ) ret . setIdx ( i , getIdx ( i ) ) ; 
return ret ; 
} 
} 

public class UtilLine3D_F64 { 
public static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { 
double dx = pointOnLine . x - line . p . x ; 
double dy = pointOnLine . y - line . p . y ; 
double dz = pointOnLine . z - line . p . z ; 
double adx = Math . abs ( dx ) ; 
double ady = Math . abs ( dy ) ; 
double adz = Math . abs ( dz ) ; 
double t ; 
if ( adx > ady ) if ( adx > adz ) t = dx / line . slope . x ; 
else t = dz / line . slope . z ; 
else if ( ady > adz ) t = dy / line . slope . y ; 
else t = dz / line . slope . z ; 
return t ; 
} 
} 

public class UtilVector2D_F64 { 
public static boolean identicalSign ( double xa , double ya , double xb , double yb , double tol ) { 
double dx0 = xb - xa ; 
double dy0 = yb - ya ; 
double dx1 = xb + xa ; 
double dy1 = yb + ya ; 
double error0 = dx0 * dx0 + dy0 * dy0 ; 
double error1 = dx1 * dx1 + dy1 * dy1 ; 
if ( error0 < error1 ) return error0 <= tol * tol ; 
else return error1 <= tol * tol ; 
} 
} 

public class BoxLength3D_F64 { 
public Point3D_F64 getCorner ( int index , Point3D_F64 corner ) { 
if ( corner == null ) corner = new Point3D_F64 ( ) ; 
corner . set ( p ) ; 
if ( ( index & 0x01 ) != 0 ) corner . x += lengthX ; 
if ( ( index & 0x02 ) != 0 ) corner . y += lengthY ; 
if ( ( index & 0x04 ) != 0 ) corner . z += lengthZ ; 
return corner ; 
} 
} 

public class Distance3D_F64 { 
public static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { 
double x = l0 . p . x - l1 . p . x ; 
double y = l0 . p . y - l1 . p . y ; 
double z = l0 . p . z - l1 . p . z ; 
double dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; 
double dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; 
double dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; 
double bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; 
double t0 ; 
if ( bottom == 0 ) t0 = 0 ; 
else t0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; 
double t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; 
double dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; 
double dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; 
double dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; 
double distanceSq = dx * dx + dy * dy + dz * dz ; 
if ( distanceSq < 0 ) return 0 ; 
else return Math . sqrt ( distanceSq ) ; 
} 
} 

public class Distance3D_F64 { 
public static double distance ( LineParametric3D_F64 l , Point3D_F64 p ) { 
double x = l . p . x - p . x ; 
double y = l . p . y - p . y ; 
double z = l . p . z - p . z ; 
double cc = x * x + y * y + z * z ; 
double b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; 
double distanceSq = cc - b * b ; 
if ( distanceSq < 0 ) return 0 ; 
else return Math . sqrt ( distanceSq ) ; 
} 
} 

public class Distance3D_F64 { 
public static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { 
double dx = p . x - l . a . x ; 
double dy = p . y - l . a . y ; 
double dz = p . z - l . a . z ; 
double cc = dx * dx + dy * dy + dz * dz ; 
double slope_x = l . b . x - l . a . x ; 
double slope_y = l . b . y - l . a . y ; 
double slope_z = l . b . z - l . a . z ; 
double n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; 
double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; 
if ( d <= 0 ) return p . distance ( l . a ) ; 
else if ( d >= n ) return p . distance ( l . b ) ; 
double distanceSq = cc - d * d ; 
if ( distanceSq < 0 ) return 0 ; 
else return Math . sqrt ( distanceSq ) ; 
} 
} 

public class FitPolynomialSolverTall_F64 { 
public boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { 
int N = length / 2 ; 
int numCoefs = output . size ( ) ; 
A . reshape ( N , numCoefs ) ; 
b . reshape ( N , 1 ) ; 
x . reshape ( numCoefs , 1 ) ; 
int end = offset + length ; 
for ( int i = offset , idxA = 0 ; 
i < end ; 
i += 2 ) { 
double x = data [ i ] ; 
double y = data [ i + 1 ] ; 
double pow = 1.0 ; 
for ( int j = 0 ; 
j < numCoefs ; 
j ++ ) { 
A . data [ idxA ++ ] = pow ; 
pow *= x ; 
} 
b . data [ i / 2 ] = y ; 
} 
if ( ! solver . setA ( A ) ) return false ; 
solver . solve ( b , x ) ; 
for ( int i = 0 ; 
i < numCoefs ; 
i ++ ) output . set ( i , x . data [ i ] ) ; 
return true ; 
} 
} 

public class UtilVector3D_F64 { 
public static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { 
if ( output == null ) output = new Vector3D_F64 ( ) ; 
double scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; 
if ( scale == 0 ) output . set ( 0 , 0 , 0 ) ; 
else { 
double x = A . x / scale ; 
double y = A . y / scale ; 
double z = A . z / scale ; 
if ( Math . abs ( x ) > Math . abs ( y ) ) output . set ( z , 0 , - x ) ; 
else output . set ( 0 , z , - y ) ; 
} 
return output ; 
} 
} 

public class UtilVector3D_F64 { 
public static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { 
if ( R == null ) R = new DMatrixRMaj ( 3 , v . length ) ; 
for ( int i = 0 ; 
i < v . length ; 
i ++ ) { 
R . set ( 0 , i , v [ i ] . x ) ; 
R . set ( 1 , i , v [ i ] . y ) ; 
R . set ( 2 , i , v [ i ] . z ) ; 
} 
return R ; 
} 
} 

public class Area2D_F64 { 
public static double quadrilateral ( Quadrilateral_F64 quad ) { 
double bx = quad . b . x - quad . a . x ; 
double by = quad . b . y - quad . a . y ; 
double cx = quad . c . x - quad . a . x ; 
double cy = quad . c . y - quad . a . y ; 
double dx = quad . d . x - quad . a . x ; 
double dy = quad . d . y - quad . a . y ; 
if ( ( bx * cy - by * cx >= 0 ) == ( cx * dy - cy * dx >= 0 ) ) return triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; 
else return triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; 
} 
} 

public class UtilPoint2D_F64 { 
public static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { 
Point2D_F64 center = mean ( points , null ) ; 
double angles [ ] = new double [ points . size ( ) ] ; 
for ( int i = 0 ; 
i < angles . length ; 
i ++ ) { 
Point2D_F64 p = points . get ( i ) ; 
double dx = p . x - center . x ; 
double dy = p . y - center . y ; 
angles [ i ] = Math . atan2 ( dy , dx ) ; 
} 
int order [ ] = new int [ points . size ( ) ] ; 
QuickSort_F64 sorter = new QuickSort_F64 ( ) ; 
sorter . sort ( angles , 0 , points . size ( ) , order ) ; 
List < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; 
for ( int i = 0 ; 
i < points . size ( ) ; 
i ++ ) out . add ( points . get ( order [ i ] ) ) ; 
return out ; 
} 
} 

public class UtilPoint2D_F64 { 
public static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { 
if ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) if ( covariance instanceof ReshapeMatrix ) ( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; 
else throw new IllegalArgumentException ( "Must be a 2x2 matrix" ) ; 
mean ( points , mean ) ; 
double xx = 0 , xy = 0 , yy = 0 ; 
for ( int i = 0 ; 
i < points . size ( ) ; 
i ++ ) { 
Point2D_F64 p = points . get ( i ) ; 
double dx = p . x - mean . x ; 
double dy = p . y - mean . y ; 
xx += dx * dx ; 
xy += dx * dy ; 
yy += dy * dy ; 
} 
xx /= points . size ( ) ; 
xy /= points . size ( ) ; 
yy /= points . size ( ) ; 
covariance . unsafe_set ( 0 , 0 , xx ) ; 
covariance . unsafe_set ( 0 , 1 , xy ) ; 
covariance . unsafe_set ( 1 , 0 , xy ) ; 
covariance . unsafe_set ( 1 , 1 , yy ) ; 
} 
} 

public class InstallFeatureUtil { 
@ SafeVarargs public static Set < String > combineToSet ( Collection < String > ... collections ) { 
Set < String > result = new HashSet < String > ( ) ; 
Set < String > lowercaseSet = new HashSet < String > ( ) ; 
for ( Collection < String > collection : collections ) { 
if ( collection != null ) for ( String value : collection ) { 
if ( ! lowercaseSet . contains ( value . toLowerCase ( ) ) ) { 
lowercaseSet . add ( value . toLowerCase ( ) ) ; 
result . add ( value ) ; 
} 
} 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private Set < String > getConfigDropinsFeatures ( Set < String > origResult , File serverDirectory , String folderName ) { 
Set < String > result = origResult ; 
File configDropinsFolder ; 
try { 
configDropinsFolder = new File ( new File ( serverDirectory , "configDropins" ) , folderName ) . getCanonicalFile ( ) ; 
} 
catch ( IOException e ) { 
warn ( "The " + serverDirectory + "/configDropins/" + folderName + " directory cannot be accessed. Skipping its server features." ) ; 
debug ( e ) ; 
return result ; 
} 
File [ ] configDropinsXmls = configDropinsFolder . listFiles ( new FilenameFilter ( ) { 
@ Override public boolean accept ( File dir , String name ) { 
return name . endsWith ( ".xml" ) ; 
} 
} 
) ; 
if ( configDropinsXmls == null || configDropinsXmls . length == 0 ) return result ; 
Comparator < File > comparator = new Comparator < File > ( ) { 
@ Override public int compare ( File left , File right ) { 
return left . getAbsolutePath ( ) . toLowerCase ( ) . compareTo ( right . getAbsolutePath ( ) . toLowerCase ( ) ) ; 
} 
} 
; 
Collections . sort ( Arrays . asList ( configDropinsXmls ) , comparator ) ; 
for ( File xml : configDropinsXmls ) { 
Set < String > features = getServerXmlFeatures ( result , xml , null ) ; 
if ( features != null ) result = features ; 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { 
Set < String > result = origResult ; 
List < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; 
File canonicalServerFile ; 
try { 
canonicalServerFile = serverFile . getCanonicalFile ( ) ; 
} 
catch ( IOException e ) { 
warn ( "The server file " + serverFile + " cannot be accessed. Skipping its features." ) ; 
debug ( e ) ; 
return result ; 
} 
updatedParsedXmls . add ( canonicalServerFile ) ; 
if ( canonicalServerFile . exists ( ) ) try { 
Document doc = new XmlDocument ( ) { 
public Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { 
createDocument ( file ) ; 
return doc ; 
} 
} 
. getDocument ( canonicalServerFile ) ; 
Element root = doc . getDocumentElement ( ) ; 
NodeList nodes = root . getChildNodes ( ) ; 
for ( int i = 0 ; 
i < nodes . getLength ( ) ; 
i ++ ) if ( nodes . item ( i ) instanceof Element ) { 
Element child = ( Element ) nodes . item ( i ) ; 
if ( "featureManager" . equals ( child . getNodeName ( ) ) ) { 
if ( result == null ) result = new HashSet < String > ( ) ; 
result . addAll ( parseFeatureManagerNode ( child ) ) ; 
} 
else if ( "include" . equals ( child . getNodeName ( ) ) ) result = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; 
} 
} 
catch ( IOException | ParserConfigurationException | SAXException e ) { 
warn ( "The server file " + serverFile + " cannot be parsed. Skipping its features." ) ; 
debug ( e ) ; 
return result ; 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private Set < String > parseIncludeNode ( Set < String > origResult , File serverFile , Element node , List < File > updatedParsedXmls ) { 
Set < String > result = origResult ; 
String includeFileName = node . getAttribute ( "location" ) ; 
if ( includeFileName == null || includeFileName . trim ( ) . isEmpty ( ) ) return result ; 
File includeFile = null ; 
if ( isURL ( includeFileName ) ) try { 
File tempFile = File . createTempFile ( "serverFromURL" , ".xml" ) ; 
FileUtils . copyURLToFile ( new URL ( includeFileName ) , tempFile , COPY_FILE_TIMEOUT_MILLIS , COPY_FILE_TIMEOUT_MILLIS ) ; 
includeFile = tempFile ; 
} 
catch ( IOException e ) { 
warn ( "The server file " + serverFile + " includes a URL " + includeFileName + " that cannot be accessed. Skipping the included features." ) ; 
debug ( e ) ; 
return result ; 
} 
else includeFile = new File ( includeFileName ) ; 
try { 
if ( ! includeFile . isAbsolute ( ) ) includeFile = new File ( serverFile . getParentFile ( ) . getAbsolutePath ( ) , includeFileName ) . getCanonicalFile ( ) ; 
else includeFile = includeFile . getCanonicalFile ( ) ; 
} 
catch ( IOException e ) { 
warn ( "The server file " + serverFile + " includes a file " + includeFileName + " that cannot be accessed. Skipping the included features." ) ; 
debug ( e ) ; 
return result ; 
} 
if ( ! updatedParsedXmls . contains ( includeFile ) ) { 
String onConflict = node . getAttribute ( "onConflict" ) ; 
Set < String > features = getServerXmlFeatures ( null , includeFile , updatedParsedXmls ) ; 
result = handleOnConflict ( result , onConflict , features ) ; 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private static Set < String > parseFeatureManagerNode ( Element node ) { 
Set < String > result = new HashSet < String > ( ) ; 
NodeList features = node . getElementsByTagName ( "feature" ) ; 
if ( features != null ) for ( int j = 0 ; 
j < features . getLength ( ) ; 
j ++ ) { 
String content = features . item ( j ) . getTextContent ( ) ; 
if ( content != null ) if ( content . contains ( ":" ) ) { 
String [ ] split = content . split ( ":" , 2 ) ; 
result . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; 
} 
else result . add ( content . trim ( ) . toLowerCase ( ) ) ; 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
public static Set < String > getOpenLibertyFeatureSet ( Set < File > jsons ) throws PluginExecutionException { 
Set < String > libertyFeatures = new HashSet < String > ( ) ; 
for ( File file : jsons ) { 
Scanner s = null ; 
try { 
s = new Scanner ( file ) ; 
while ( s . findWithinHorizon ( OPEN_LIBERTY_GROUP_ID + ":([^:]*):" , 0 ) != null ) { 
MatchResult match = s . match ( ) ; 
if ( match . groupCount ( ) >= 1 ) libertyFeatures . add ( match . group ( 1 ) ) ; 
} 
} 
catch ( FileNotFoundException e ) { 
throw new PluginExecutionException ( "The JSON file is not found at " + file . getAbsolutePath ( ) , e ) ; 
} 
finally { 
if ( s != null ) s . close ( ) ; 
} 
} 
return libertyFeatures ; 
} 
} 

public class InstallFeatureUtil { 
public static String getNextProductVersion ( String version ) throws PluginExecutionException { 
String result = null ; 
int versionSplittingIndex = version . lastIndexOf ( "." ) + 1 ; 
if ( versionSplittingIndex == 0 ) throw new PluginExecutionException ( "Product version " + version + " is not in the expected format. It must have period separated version segments." ) ; 
String quarterVersion = version . substring ( versionSplittingIndex ) ; 
int nextQuarterSpecifier ; 
try { 
nextQuarterSpecifier = Integer . parseInt ( quarterVersion ) + 1 ; 
} 
catch ( NumberFormatException e ) { 
throw new PluginExecutionException ( "Product version " + version + " is not in the expected format. Its last segment is expected to be an integer." , e ) ; 
} 
result = version . substring ( 0 , versionSplittingIndex ) + nextQuarterSpecifier ; 
return result ; 
} 
} 

public class InstallFeatureUtil { 
public static String extractSymbolicName ( File jar ) throws PluginExecutionException { 
JarFile jarFile = null ; 
try { 
jarFile = new JarFile ( jar ) ; 
return jarFile . getManifest ( ) . getMainAttributes ( ) . getValue ( "Bundle-SymbolicName" ) ; 
} 
catch ( IOException e ) { 
throw new PluginExecutionException ( "Could not load the jar " + jar . getAbsolutePath ( ) , e ) ; 
} 
finally { 
if ( jarFile != null ) try { 
jarFile . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
} 
} 

public class InstallFeatureUtil { 
public static File getMapBasedInstallKernelJar ( File dir ) { 
File [ ] installMapJars = dir . listFiles ( new FilenameFilter ( ) { 
@ Override public boolean accept ( File dir , String name ) { 
return name . startsWith ( INSTALL_MAP_PREFIX ) && name . endsWith ( INSTALL_MAP_SUFFIX ) ; 
} 
} 
) ; 
File result = null ; 
if ( installMapJars != null ) for ( File jar : installMapJars ) { 
if ( isReplacementJar ( result , jar ) ) result = jar ; 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private static boolean isReplacementJar ( File file1 , File file2 ) { 
if ( file1 == null ) return true ; 
else if ( file2 == null ) return false ; 
else { 
String version1 = extractVersion ( file1 . getName ( ) ) ; 
String version2 = extractVersion ( file2 . getName ( ) ) ; 
return compare ( version1 , version2 ) < 0 ; 
} 
} 
} 

public class InstallFeatureUtil { 
private static String extractVersion ( String fileName ) { 
int startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; 
int endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; 
if ( startIndex < endIndex ) return fileName . substring ( startIndex , endIndex ) ; 
else return null ; 
} 
} 

public class InstallFeatureUtil { 
private static int compare ( String version1 , String version2 ) { 
if ( version1 == null && version2 == null ) return 0 ; 
else if ( version1 == null && version2 != null ) return - 1 ; 
else if ( version1 != null && version2 == null ) return 1 ; 
String [ ] components1 = version1 . split ( "\\." ) ; 
String [ ] components2 = version2 . split ( "\\." ) ; 
for ( int i = 0 ; 
i < components1 . length && i < components2 . length ; 
i ++ ) { 
int comparison ; 
try { 
comparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; 
} 
catch ( NumberFormatException e ) { 
comparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; 
} 
if ( comparison != 0 ) return comparison ; 
} 
return components1 . length - components2 . length ; 
} 
} 

public class InstallFeatureUtil { 
public static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { 
Process pr = null ; 
InputStream is = null ; 
Scanner s = null ; 
Worker worker = null ; 
try { 
String command ; 
if ( OSUtil . isWindows ( ) ) command = installDirectory + "\\bin\\productInfo.bat " + action ; 
else command = installDirectory + "/bin/productInfo " + action ; 
pr = Runtime . getRuntime ( ) . exec ( command ) ; 
worker = new Worker ( pr ) ; 
worker . start ( ) ; 
worker . join ( 300000 ) ; 
if ( worker . exit == null ) throw new PluginExecutionException ( "productInfo command timed out" ) ; 
int exitValue = pr . exitValue ( ) ; 
if ( exitValue != 0 ) throw new PluginExecutionException ( "productInfo exited with return code " + exitValue ) ; 
is = pr . getInputStream ( ) ; 
s = new Scanner ( is ) ; 
s . useDelimiter ( "\\A" ) ; 
if ( s . hasNext ( ) ) return s . next ( ) ; 
return null ; 
} 
catch ( IOException ex ) { 
throw new PluginExecutionException ( "productInfo error: " + ex ) ; 
} 
catch ( InterruptedException ex ) { 
worker . interrupt ( ) ; 
Thread . currentThread ( ) . interrupt ( ) ; 
throw new PluginExecutionException ( "productInfo error: " + ex ) ; 
} 
finally { 
if ( s != null ) s . close ( ) ; 
if ( is != null ) try { 
is . close ( ) ; 
} 
catch ( IOException e ) { 
} 
if ( pr != null ) pr . destroy ( ) ; 
} 
} 
} 

public class SpringBootUtil { 
public static boolean isSpringBootUberJar ( File artifact ) { 
if ( artifact == null || ! artifact . exists ( ) || ! artifact . isFile ( ) ) return false ; 
try ( JarFile jarFile = new JarFile ( artifact ) ) { 
Manifest manifest = jarFile . getManifest ( ) ; 
if ( manifest != null ) { 
Attributes attributes = manifest . getMainAttributes ( ) ; 
if ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null && attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) return true ; 
else { 
Enumeration < JarEntry > entries = jarFile . entries ( ) ; 
while ( entries . hasMoreElements ( ) ) { 
JarEntry entry = entries . nextElement ( ) ; 
String entryName = entry . getName ( ) ; 
if ( ! entryName . startsWith ( "org" ) && ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) ) return true ; 
} 
} 
} 
} 
catch ( IOException e ) { 
} 
return false ; 
} 
} 

public class LibertyProperty { 
private static LibertyPropertyI getArquillianProperty ( String key , Class < ? > cls ) throws ArquillianConfigurationException { 
try { 
if ( cls == LibertyManagedObject . LibertyManagedProperty . class ) return LibertyManagedObject . LibertyManagedProperty . valueOf ( key ) ; 
else if ( cls == LibertyRemoteObject . LibertyRemoteProperty . class ) return LibertyRemoteObject . LibertyRemoteProperty . valueOf ( key ) ; 
} 
catch ( IllegalArgumentException e ) { 
throw new ArquillianConfigurationException ( "Property \"" + key + "\" in arquillianProperties does not exist. You probably have a typo." ) ; 
} 
throw new ArquillianConfigurationException ( "This should never happen." ) ; 
} 
} 

public class Puzzle { 
public int getDistanceToGoal ( ) { 
int distance = 0 ; 
for ( int i = 0 ; 
i < cells . length ; 
i ++ ) distance += getDistance ( i , cells [ i ] ) ; 
return distance ; 
} 
} 

public class MySystem { 
public synchronized static void variable ( String name , Object value ) { 
if ( ! variable ) return ; 
System . out . println ( timeStamp ( ) + "*=> " + name + " = '" + ( value == null ? null : value . toString ( ) ) + "'" ) ; 
} 
} 

public class FileAssetServlet { 
private String fixPath ( String path ) { 
if ( ! path . isEmpty ( ) ) if ( ! path . endsWith ( "/" ) ) return path + '/' ; 
else return path ; 
else return path ; 
} 
} 

public class HqlUtil { 
public static String joinToString ( CriteriaJoin criteriaJoin ) { 
StringBuilder builder = new StringBuilder ( "LEFT OUTER JOIN " ) . append ( criteriaJoin . getEntityClass ( ) . getName ( ) ) . append ( " " ) . append ( criteriaJoin . getAlias ( ) ) . append ( " " ) . append ( " ON " ) ; 
if ( criteriaJoin . getJoinRelations ( ) . size ( ) == 0 ) throw new RuntimeException ( "Not found any Join Relations in " + criteriaJoin . getAlias ( ) + " Join Criteria ! " ) ; 
StringJoiner joiner = new StringJoiner ( " AND " ) ; 
List < JoinRelation > relationList = criteriaJoin . getJoinRelations ( ) ; 
for ( JoinRelation joinRelation : relationList ) { 
StringBuilder relationBuilder = new StringBuilder ( "\n" ) . append ( joinRelation . getRelationCriteria ( ) . getAlias ( ) ) . append ( "." ) . append ( joinRelation . getRelationField ( ) ) . append ( "=" ) . append ( joinRelation . getJoinedCriteria ( ) . getAlias ( ) ) . append ( "." ) . append ( joinRelation . getJoinedField ( ) ) ; 
joiner . add ( relationBuilder . toString ( ) ) ; 
} 
if ( joiner . length ( ) > 0 ) builder . append ( joiner . toString ( ) ) ; 
return builder . toString ( ) ; 
} 
} 

public class TokenBasedAuthResponseFilter { 
@ Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { 
String authToken = extractAuthTokenFromCookieList ( requestContext . getHeaders ( ) . getFirst ( "Cookie" ) ) ; 
if ( authToken != null && authToken . length ( ) != 0 ) try { 
BasicToken token = new BasicToken ( authToken ) ; 
if ( token . isExpired ( ) ) { 
LOGGER . debug ( "ExpireDate : " + token . getExpirationDate ( ) . toString ( ) ) ; 
LOGGER . debug ( "Now: " + DateTime . now ( ) . toDate ( ) . toString ( ) ) ; 
responseContext . getHeaders ( ) . putSingle ( "Set-Cookie" , getTokenSentence ( null ) ) ; 
responseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; 
responseContext . setEntity ( "Token expired. Please login again." ) ; 
LOGGER . info ( "Token expired. Please login again." ) ; 
} 
else { 
token . setExpiration ( token . getMaxAge ( ) ) ; 
if ( ! logoutPath . equals ( requestContext . getUriInfo ( ) . getPath ( ) ) ) { 
String cookie = getTokenSentence ( token ) ; 
responseContext . getHeaders ( ) . putSingle ( "Set-Cookie" , cookie ) ; 
} 
} 
} 
catch ( Exception e ) { 
LOGGER . error ( "Token re-creation failed" , e . getMessage ( ) ) ; 
responseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; 
} 
} 
} 

public class TokenBasedAuthResponseFilter { 
private String extractAuthTokenFromCookieList ( String cookieList ) { 
if ( cookieList == null || cookieList . length ( ) == 0 ) return null ; 
String [ ] cookies = cookieList . split ( ";" ) ; 
for ( String cookie : cookies ) { 
if ( cookie . trim ( ) . startsWith ( tokenKey ) ) return cookie . trim ( ) . substring ( tokenKey . length ( ) + 1 ) ; 
} 
return null ; 
} 
} 

public class JerseyUtil { 
public static void registerGuiceBound ( Injector injector , final JerseyEnvironment environment ) { 
while ( injector != null ) { 
for ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { 
Type type = key . getTypeLiteral ( ) . getType ( ) ; 
if ( type instanceof Class ) { 
Class < ? > c = ( Class ) type ; 
if ( isProviderClass ( c ) ) { 
logger . info ( "Registering {} as a provider class" , c . getName ( ) ) ; 
environment . register ( c ) ; 
} 
else if ( isRootResourceClass ( c ) ) if ( Resource . isAcceptable ( c ) ) { 
logger . info ( "Registering {} as a root resource class" , c . getName ( ) ) ; 
environment . register ( c ) ; 
} 
else logger . warn ( "Class {} was not registered as a resource. Bind a concrete implementation instead." , c . getName ( ) ) ; 
} 
} 
injector = injector . getParent ( ) ; 
} 
} 
} 

public class RobeExceptionMapper { 
@ Override public Response toResponse ( Exception e ) { 
String id = System . nanoTime ( ) + "" ; 
LOGGER . error ( id , e ) ; 
if ( e instanceof RobeRuntimeException ) return ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; 
else if ( e instanceof ConstraintViolationException ) { 
ConstraintViolationException exception = ( ConstraintViolationException ) e ; 
RobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; 
int i = 0 ; 
for ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { 
errors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; 
} 
return Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
else if ( e instanceof WebApplicationException ) { 
WebApplicationException we = ( WebApplicationException ) e ; 
RobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; 
return Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
else { 
if ( e . getClass ( ) . getName ( ) . equals ( "org.hibernate.exception.ConstraintViolationException" ) ) if ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { 
RobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( "for" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; 
return Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
RobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; 
return Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
} 
} 

public class BasicToken { 
public static void configure ( TokenBasedAuthConfiguration configuration ) { 
encryptor . setPoolSize ( configuration . getPoolSize ( ) ) ; 
if ( configuration . getServerPassword ( ) . equals ( "auto" ) ) encryptor . setPassword ( UUID . randomUUID ( ) . toString ( ) ) ; 
else encryptor . setPassword ( configuration . getServerPassword ( ) ) ; 
encryptor . setAlgorithm ( configuration . getAlgorithm ( ) ) ; 
encryptor . initialize ( ) ; 
BasicToken . defaultMaxAge = configuration . getMaxage ( ) ; 
cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( defaultMaxAge , TimeUnit . SECONDS ) . expireAfterWrite ( defaultMaxAge , TimeUnit . SECONDS ) . build ( ) ; 
} 
} 

public class MailSender { 
public void sendMessage ( MailItem item ) throws MessagingException { 
checkNotNull ( item . getReceivers ( ) ) ; 
checkNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; 
checkNotNull ( item . getTitle ( ) ) ; 
checkNotNull ( item . getBody ( ) ) ; 
Message msg = new MimeMessage ( session ) ; 
if ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) item . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; 
InternetAddress from = new InternetAddress ( item . getSender ( ) ) ; 
msg . setFrom ( from ) ; 
InternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; 
for ( int i = 0 ; 
i < item . getReceivers ( ) . size ( ) ; 
i ++ ) to [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; 
msg . setRecipients ( Message . RecipientType . TO , to ) ; 
msg . setSubject ( item . getTitle ( ) ) ; 
MimeBodyPart body = new MimeBodyPart ( ) ; 
body . setContent ( item . getBody ( ) , "text/html; charset=UTF-8" ) ; 
Multipart content = new MimeMultipart ( ) ; 
content . addBodyPart ( body ) ; 
if ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) for ( DataSource attachment : item . getAttachments ( ) ) { 
BodyPart itemBodyPart = new MimeBodyPart ( ) ; 
itemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; 
itemBodyPart . setFileName ( attachment . getName ( ) ) ; 
content . addBodyPart ( itemBodyPart ) ; 
} 
msg . setContent ( content ) ; 
msg . saveChanges ( ) ; 
Transport . send ( msg ) ; 
for ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { 
String [ ] value = msg . getHeader ( entry . getKey ( ) ) ; 
if ( value != null ) entry . setValue ( value ) ; 
} 
} 
} 

public class AbstractAuthResource { 
public void changePassword ( T user , String currentPassword , String newPassword , String newPassword2 ) throws AuthenticationException { 
verifyPassword ( user , currentPassword ) ; 
if ( ! newPassword . equals ( newPassword2 ) ) throw new AuthenticationException ( user . getUsername ( ) + ": New password and re-type password must be same" ) ; 
else if ( newPassword . equals ( currentPassword ) ) throw new AuthenticationException ( user . getUsername ( ) + ": New password and old password must be different" ) ; 
verifyPasswordStrength ( currentPassword , newPassword , user ) ; 
Optional < ? extends UserEntry > optional = userStore . changePassword ( user . getUsername ( ) , newPassword ) ; 
if ( ! optional . isPresent ( ) ) throw new AuthenticationException ( user . getUsername ( ) + ": Can't update UserEntry Password" ) ; 
} 
} 

public class AbstractAuthResource { 
public T getUser ( String accountName ) { 
Optional < T > optional = ( Optional < T > ) userStore . findByUsername ( accountName ) ; 
if ( optional . isPresent ( ) ) return optional . get ( ) ; 
else return null ; 
} 
} 

public class AbstractAuthResource { 
public void verifyAccountNameStrength ( String accountName ) throws AuthenticationException { 
Matcher matcher = PATTERN . matcher ( accountName ) ; 
if ( ! matcher . matches ( ) ) throw new AuthenticationException ( accountName + " is not a valid email" ) ; 
} 
} 

public class SearchFactory { 
@ Override public SearchModel provide ( ) { 
SearchModel searchModel = new SearchModel ( ) ; 
searchModel . setResponse ( response ) ; 
String method = getMethod ( ) ; 
if ( "GET" . equals ( method ) ) { 
MultivaluedMap < String , String > queryParameters = getUriInfo ( ) . getQueryParameters ( ) ; 
for ( Map . Entry < String , List < String > > param : queryParameters . entrySet ( ) ) { 
if ( param . getValue ( ) . get ( 0 ) == null ) continue ; 
if ( "_q" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setQ ( param . getValue ( ) . get ( 0 ) ) ; 
else if ( "_limit" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setLimit ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; 
else if ( "_offset" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setOffset ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; 
else if ( "_fields" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setFields ( param . getValue ( ) . get ( 0 ) . split ( "," ) ) ; 
else if ( "_sort" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setSort ( param . getValue ( ) . get ( 0 ) . split ( "," ) ) ; 
else if ( "_filter" . equalsIgnoreCase ( param . getKey ( ) ) ) searchModel . setFilterExpression ( param . getValue ( ) . get ( 0 ) ) ; 
} 
} 
return searchModel ; 
} 
} 

public class Transaction { 
private void success ( ) { 
org . hibernate . Transaction txn = session . getTransaction ( ) ; 
if ( txn != null && txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) txn . commit ( ) ; 
} 
} 

public class Transaction { 
private void error ( ) { 
org . hibernate . Transaction txn = session . getTransaction ( ) ; 
if ( txn != null && txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) txn . rollback ( ) ; 
} 
} 

public class Transaction { 
private void start ( ) { 
try { 
before ( ) ; 
transactionWrapper . wrap ( ) ; 
success ( ) ; 
} 
catch ( Exception e ) { 
error ( ) ; 
if ( exceptionHandler != null ) exceptionHandler . onException ( e ) ; 
else throw e ; 
} 
finally { 
finish ( ) ; 
} 
} 
} 

public class Query { 
public static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { 
if ( Validations . isEmptyOrNull ( name ) ) return null ; 
String [ ] names = name . split ( "\\." ) ; 
String currentName ; 
int step = 0 ; 
CriteriaParent < E > currentCriteria = criteria ; 
FieldMeta currentFieldMeta ; 
StringJoiner aliasJoiner = new StringJoiner ( "$" ) ; 
do { 
currentName = names [ step ] ; 
if ( Validations . isEmptyOrNull ( currentName ) ) throw new RuntimeException ( currentName + " defined name is wrong ! " ) ; 
currentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; 
step ++ ; 
aliasJoiner . add ( currentCriteria . getAlias ( ) ) ; 
if ( step >= names . length ) break ; 
if ( currentFieldMeta . getReference ( ) == null ) throw new RuntimeException ( "" + currentName + " join field of " + name + "'s reference target information must defined ! " ) ; 
CriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; 
if ( criteriaJoin == null ) currentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; 
currentCriteria = criteriaJoin ; 
} 
while ( step >= names . length ) ; 
Holder < E > holder = new Holder < > ( ) ; 
holder . currentFieldName = currentName ; 
holder . currentCriteria = currentCriteria ; 
holder . currentFieldMeta = currentFieldMeta ; 
return holder ; 
} 
} 

public class ParseDate { 
@ Override public Date parse ( Object o , Field field ) { 
if ( ! isValid ( o ) ) return null ; 
JsonFormat formatAnn = field . getAnnotation ( JsonFormat . class ) ; 
if ( formatAnn == null ) throw new RuntimeException ( "JsonFormat with pattern needed for: " + field . getName ( ) ) ; 
try { 
return new SimpleDateFormat ( formatAnn . pattern ( ) , Locale . getDefault ( ) ) . parse ( o . toString ( ) ) ; 
} 
catch ( ParseException e ) { 
throw new RuntimeException ( "JsonFormat with pattern is wrong for: " + field . getName ( ) + " pattern: " + formatAnn . pattern ( ) ) ; 
} 
} 
} 

public class NamespaceManager { 
public NamespaceManager withNamespace ( String namespace , String href ) { 
if ( namespaces . containsKey ( namespace ) ) throw new RepresentationException ( format ( "Duplicate namespace '%s' found for representation factory" , namespace ) ) ; 
if ( ! href . contains ( "{rel}" ) ) throw new RepresentationException ( format ( "Namespace '%s' does not include {rel} URI template argument." , namespace ) ) ; 
return new NamespaceManager ( namespaces . put ( namespace , href ) ) ; 
} 
} 

public class ResourceRepresentation { 
public ResourceRepresentation < V > withRel ( Rel rel ) { 
if ( rels . containsKey ( rel . rel ( ) ) ) throw new IllegalStateException ( String . format ( "Rel %s is already declared." , rel . rel ( ) ) ) ; 
final TreeMap < String , Rel > updatedRels = rels . put ( rel . rel ( ) , rel ) ; 
return new ResourceRepresentation < > ( content , links , updatedRels , namespaceManager , value , resources ) ; 
} 
} 

public class ResourceRepresentation { 
public ResourceRepresentation < V > withNamespace ( String namespace , String href ) { 
if ( ! rels . containsKey ( "curies" ) ) rels = rels . put ( "curies" , Rels . collection ( "curies" ) ) ; 
final NamespaceManager updatedNamespaceManager = namespaceManager . withNamespace ( namespace , href ) ; 
return new ResourceRepresentation < > ( content , links , rels , updatedNamespaceManager , value , resources ) ; 
} 
} 

public class CharStreams { 
public static boolean equal ( Reader in1 , Reader in2 ) throws IOException { 
if ( in1 == in2 ) return true ; 
if ( in1 == null || in2 == null ) return false ; 
in1 = buffer ( in1 ) ; 
in2 = buffer ( in2 ) ; 
int c1 = in1 . read ( ) ; 
int c2 = in2 . read ( ) ; 
while ( c1 != - 1 && c2 != - 1 && c1 == c2 ) { 
c1 = in1 . read ( ) ; 
c2 = in2 . read ( ) ; 
} 
return in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; 
} 
} 

public class XFiles { 
public static void touch ( File ... files ) throws IOException { 
long now = System . currentTimeMillis ( ) ; 
for ( File f : files ) { 
if ( ! f . createNewFile ( ) && ! f . setLastModified ( now ) ) throw new IOException ( "Failed to touch " + f ) ; 
} 
} 
} 

public class MD4 { 
private void addPadding ( ) { 
int len = BLOCK_LENGTH - bufferLen ; 
if ( len < 9 ) len += BLOCK_LENGTH ; 
byte [ ] buf = new byte [ len ] ; 
buf [ 0 ] = ( byte ) 0x80 ; 
for ( int i = 1 ; 
i < len - 8 ; 
i ++ ) buf [ i ] = ( byte ) 0x00 ; 
counter = ( counter + ( long ) bufferLen ) * 8L ; 
LittleEndian . encode ( counter , buf , len - 8 ) ; 
update ( buf ) ; 
} 
} 

public class Classes { 
public static String getShortName ( Class < ? > c ) { 
String qname = getQualifiedName ( c ) ; 
int start = qname . lastIndexOf ( '$' ) ; 
if ( start == - 1 ) start = qname . lastIndexOf ( '.' ) ; 
return qname . substring ( start + 1 ) ; 
} 
} 

public class Passwords { 
public static boolean verify ( String password , byte [ ] hash ) { 
byte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; 
int n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; 
int r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; 
int p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; 
if ( n > N || n < N_MIN || r > R || r < R_MIN || p > P || p < P_MIN ) { 
n = N ; 
r = R ; 
p = P ; 
} 
byte [ ] salt = new byte [ SALT_LENGTH ] ; 
System . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; 
byte [ ] expected = hash ( password , salt , r , n , p ) ; 
int result = 0 ; 
for ( int i = 0 ; 
i < h . length ; 
i ++ ) result |= h [ i ] ^ expected [ i ] ; 
return result == 0 ; 
} 
} 

public class Fraction { 
public Fraction dividedBy ( Fraction f ) { 
if ( ZERO . equals ( f ) ) throw new ArithmeticException ( "Division by zero" ) ; 
return new Fraction ( n . multiply ( f . d ) , d . multiply ( f . n ) ) . reduced ( ) ; 
} 
} 

public class Numbers { 
public static long max ( long ... values ) { 
Parameters . checkCondition ( values . length > 0 ) ; 
long max = values [ 0 ] ; 
for ( int i = 1 ; 
i < values . length ; 
i ++ ) max = Math . max ( max , values [ i ] ) ; 
return max ; 
} 
} 

public class Numbers { 
public static long min ( long ... values ) { 
Parameters . checkCondition ( values . length > 0 ) ; 
long min = values [ 0 ] ; 
for ( int i = 1 ; 
i < values . length ; 
i ++ ) min = Math . min ( min , values [ i ] ) ; 
return min ; 
} 
} 

public class Parameters { 
public static void checkCondition ( boolean condition , String msg , Object ... args ) { 
if ( ! condition ) throw new IllegalArgumentException ( format ( msg , args ) ) ; 
} 
} 

public class LocationForecastHelper { 
public Optional < MeteoExtrasForecast > findNearestForecast ( ZonedDateTime dateTime ) { 
ZonedDateTime dt = toZeroMSN ( dateTime . withZoneSameInstant ( METZONE ) ) ; 
PointForecast chosenForecast = null ; 
for ( Forecast forecast : getLocationForecast ( ) . getForecasts ( ) ) { 
if ( forecast instanceof PointForecast ) { 
PointForecast pointForecast = ( PointForecast ) forecast ; 
if ( isDateMatch ( dt , cloneZonedDateTime ( pointForecast . getFrom ( ) ) ) ) { 
chosenForecast = pointForecast ; 
break ; 
} 
else if ( chosenForecast == null ) chosenForecast = pointForecast ; 
else if ( isNearerDate ( pointForecast . getFrom ( ) , dt , chosenForecast . getFrom ( ) ) ) chosenForecast = pointForecast ; 
} 
} 
if ( chosenForecast == null ) return Optional . empty ( ) ; 
return Optional . of ( new MeteoExtrasForecast ( chosenForecast , getIndexer ( ) . getWidestFitPeriodForecast ( chosenForecast . getFrom ( ) ) . orElse ( null ) ) ) ; 
} 
} 

public class LongtermForecastHelper { 
public MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { 
List < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; 
ZonedDateTime dt = getNow ( ) ; 
for ( int i = 0 ; 
i <= 6 ; 
i ++ ) { 
ZonedDateTime dti = dt . plusDays ( i ) ; 
if ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { 
MeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; 
if ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) forecastDays . add ( mefd ) ; 
} 
} 
return new MeteoExtrasLongTermForecast ( forecastDays ) ; 
} 
} 

public class LongtermForecastHelper { 
public MeteoExtrasLongTermForecast createLongTermForecast ( ) { 
List < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; 
ZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; 
for ( int i = 0 ; 
i < series . getSeries ( ) . size ( ) ; 
i ++ ) createLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; 
return new MeteoExtrasLongTermForecast ( forecastDays ) ; 
} 
} 

public class Location { 
public static Location fromCoordinates ( String coordinates ) { 
if ( coordinates == null ) throw new IllegalArgumentException ( "Cannot create Location from null input." ) ; 
Matcher m = P . matcher ( coordinates ) ; 
if ( ! m . matches ( ) ) throw new IllegalArgumentException ( coordinates + " must be on the pattern (longitude,latitude,altitude) : " + P . pattern ( ) ) ; 
try { 
Double longitude = Double . valueOf ( m . group ( 1 ) ) ; 
Double latitude = Double . valueOf ( m . group ( 2 ) ) ; 
Integer altitude = 0 ; 
if ( m . group ( 3 ) != null ) altitude = Integer . valueOf ( m . group ( 3 ) . substring ( 1 ) ) ; 
return new Location ( longitude , latitude , altitude , "" ) ; 
} 
catch ( NumberFormatException e ) { 
throw new IllegalArgumentException ( coordinates + " must be on the pattern (longitude,latitude,altitude) : " + P . pattern ( ) ) ; 
} 
} 
} 

public class WindSymbolHelper { 
public static Optional < String > createWindSymbolName ( PointForecast pointForecast ) { 
if ( pointForecast == null || pointForecast . getWindDirection ( ) == null || pointForecast . getWindSpeed ( ) == null ) return Optional . empty ( ) ; 
return Optional . of ( pointForecast . getWindDirection ( ) . getName ( ) . toLowerCase ( ) + idFormat . format ( pointForecast . getWindSpeed ( ) . getBeaufort ( ) ) ) ; 
} 
} 

public class WindSymbolHelper { 
public static Optional < BeaufortLevel > findBeaufortLevel ( PointForecast pointForecast ) { 
if ( pointForecast == null || pointForecast . getWindSpeed ( ) == null ) return Optional . empty ( ) ; 
return Optional . ofNullable ( findUnitById ( pointForecast . getWindSpeed ( ) . getBeaufort ( ) ) ) ; 
} 
} 

public class MeteoNetUtils { 
public static URI createUri ( String uri ) throws MeteoException { 
if ( uri == null ) throw new MeteoException ( "URI is null" ) ; 
try { 
return new URI ( uri ) ; 
} 
catch ( URISyntaxException e ) { 
throw new MeteoException ( e ) ; 
} 
} 
} 

public class SunriseDate { 
public boolean isSun ( ZonedDateTime currentDate ) { 
if ( getSun ( ) . getNeverRise ( ) ) return false ; 
else if ( getSun ( ) . getNeverSet ( ) ) return true ; 
return timeWithinPeriod ( currentDate ) ; 
} 
} 

public class MeteoForecastIndexer { 
Optional < PointForecast > getPointForecast ( ZonedDateTime dateTime ) { 
for ( Forecast forecast : forecasts ) { 
if ( forecast instanceof PointForecast ) { 
PointForecast pointForecast = ( PointForecast ) forecast ; 
if ( createHourIndexKey ( dateTime ) . equals ( createHourIndexKey ( cloneZonedDateTime ( pointForecast . getFrom ( ) ) ) ) ) return Optional . of ( pointForecast ) ; 
} 
} 
return Optional . empty ( ) ; 
} 
} 

public class MeteoForecastIndexer { 
Optional < PeriodForecast > getBestFitPeriodForecast ( ZonedDateTime from , ZonedDateTime to ) { 
if ( from == null || to == null ) return Optional . empty ( ) ; 
ZonedDateTime requestFrom = toZeroMSN ( from ) ; 
ZonedDateTime requestTo = toZeroMSN ( to ) ; 
List < PeriodForecast > forecastsList = dayIndex . get ( new DayIndexKey ( requestFrom ) ) ; 
if ( forecastsList == null ) return Optional . empty ( ) ; 
PeriodForecast chosenForecast = null ; 
long score = 0 ; 
long tmpScore = 0 ; 
for ( PeriodForecast forecast : forecastsList ) { 
ZonedDateTime actualFrom = cloneZonedDateTime ( forecast . getFrom ( ) ) ; 
ZonedDateTime actualTo = cloneZonedDateTime ( forecast . getTo ( ) ) ; 
if ( requestFrom . equals ( actualFrom ) && requestTo . equals ( actualTo ) ) return Optional . of ( forecast ) ; 
else if ( ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualFrom ) ) || ( requestFrom . isAfter ( actualTo ) && requestTo . isAfter ( actualTo ) ) || actualTo . isEqual ( actualFrom ) ) continue ; 
else if ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualTo ) ) tmpScore = hoursBetween ( requestTo , actualFrom ) ; 
else if ( ( actualFrom . isBefore ( requestFrom ) || actualFrom . isEqual ( requestFrom ) ) && actualTo . isBefore ( requestTo ) ) tmpScore = hoursBetween ( actualTo , requestFrom ) ; 
else if ( actualFrom . isAfter ( requestFrom ) && ( actualTo . isBefore ( requestTo ) || actualTo . isEqual ( requestTo ) ) ) tmpScore = hoursBetween ( actualTo , actualFrom ) ; 
else if ( actualFrom . isBefore ( requestFrom ) && actualTo . isAfter ( requestTo ) ) tmpScore = hoursBetween ( requestTo , requestFrom ) ; 
else { 
DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( "yyyy-MM-dd:HH:mm" ) ; 
log . warn ( "Unhandled forecast Requested period:" + requestFrom . format ( formatter ) + "--" + requestTo . format ( formatter ) + ", Actual period: " + actualFrom . format ( formatter ) + "--" + actualTo . format ( formatter ) ) ; 
} 
tmpScore = Math . abs ( tmpScore ) ; 
if ( ( score == 0 && tmpScore > 0 ) || tmpScore > score ) { 
score = tmpScore ; 
chosenForecast = forecast ; 
} 
} 
return Optional . ofNullable ( chosenForecast ) ; 
} 
} 

public class Application { 
private void updateDB ( ) throws SQLException , LiquibaseException { 
System . out . println ( "About to perform DB update." ) ; 
try ( BasicDataSource dataSource = new BasicDataSource ( ) ) { 
dataSource . setUrl ( fullConnectionString ) ; 
dataSource . setUsername ( username ) ; 
dataSource . setPassword ( password ) ; 
try ( java . sql . Connection c = dataSource . getConnection ( ) ) { 
Database database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; 
Liquibase liquibase = null ; 
ClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; 
try { 
if ( accessor . getResourcesAsStream ( "changelog-master.xml" ) != null ) liquibase = new Liquibase ( "changelog-master.xml" , new ClassLoaderResourceAccessor ( ) , database ) ; 
else if ( accessor . getResourcesAsStream ( "changelog.xml" ) != null ) liquibase = new Liquibase ( "changelog.xml" , new ClassLoaderResourceAccessor ( ) , database ) ; 
else { 
String errorMessage = "No liquibase changelog-master.xml or changelog.xml could be located" ; 
Logger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; 
throw new RuntimeException ( errorMessage ) ; 
} 
} 
catch ( final IOException ioe ) { 
Logger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; 
} 
liquibase . getLog ( ) . setLogLevel ( logLevel ) ; 
liquibase . update ( new Contexts ( ) ) ; 
System . out . println ( "DB update finished." ) ; 
} 
} 
} 
} 

public class ReferencedObject { 
public synchronized T acquire ( final DataSource source ) throws DataSourceException { 
if ( object == null ) if ( getReference ( ) == null ) throw new IllegalStateException ( "No reference or object present" ) ; 
else object = source . getObject ( getReference ( ) , objectClass ) ; 
return object ; 
} 
} 

public class CafConfigurationSource { 
private < T > T getConfig ( final Class < T > configClass ) throws ConfigurationException { 
Iterator < Name > it = getServicePath ( ) . descendingPathIterator ( ) ; 
while ( it . hasNext ( ) ) try ( InputStream in = getConfigurationStream ( configClass , it . next ( ) ) ) { 
return decoder . deserialise ( in , configClass ) ; 
} 
catch ( final ConfigurationException e ) { 
LOG . trace ( "No configuration at this path level" , e ) ; 
} 
catch ( final CodecException | IOException e ) { 
incrementErrors ( ) ; 
throw new ConfigurationException ( "Failed to get configuration for " + configClass . getSimpleName ( ) , e ) ; 
} 
incrementErrors ( ) ; 
throw new ConfigurationException ( "No configuration found for " + configClass . getSimpleName ( ) ) ; 
} 
} 

public class CafConfigurationSource { 
private static boolean getIsSubstitutorEnabled ( final BootstrapConfiguration bootstrapConfig ) { 
final String ENABLE_SUBSTITUTOR_CONFIG_KEY = "CAF_CONFIG_ENABLE_SUBSTITUTOR" ; 
final boolean ENABLE_SUBSTITUTOR_CONFIG_DEFAULT = true ; 
if ( ! bootstrapConfig . isConfigurationPresent ( ENABLE_SUBSTITUTOR_CONFIG_KEY ) ) return ENABLE_SUBSTITUTOR_CONFIG_DEFAULT ; 
try { 
return bootstrapConfig . getConfigurationBoolean ( ENABLE_SUBSTITUTOR_CONFIG_KEY ) ; 
} 
catch ( final ConfigurationException ex ) { 
throw new RuntimeException ( ex ) ; 
} 
} 
} 

public class CafConfigurationDecoderProvider { 
@ Override public Decoder getDecoder ( final BootstrapConfiguration bootstrap , final Decoder defaultDecoder ) { 
final String DECODER_CONFIG_KEY = "CAF_CONFIG_DECODER" ; 
final String decoder ; 
try { 
if ( ! bootstrap . isConfigurationPresent ( DECODER_CONFIG_KEY ) ) return defaultDecoder ; 
decoder = bootstrap . getConfiguration ( DECODER_CONFIG_KEY ) ; 
} 
catch ( final ConfigurationException ex ) { 
throw new RuntimeException ( ex ) ; 
} 
try { 
return ModuleProvider . getInstance ( ) . getModule ( Decoder . class , decoder ) ; 
} 
catch ( final NullPointerException ex ) { 
throw new RuntimeException ( "Unable to get Decoder using " + DECODER_CONFIG_KEY + " value: " + decoder , ex ) ; 
} 
} 
} 

public class ReferencedData { 
public synchronized InputStream acquire ( final DataSource source ) throws DataSourceException { 
InputStream ret ; 
if ( data == null ) if ( getReference ( ) == null ) throw new IllegalStateException ( "No data or reference present" ) ; 
else ret = source . getStream ( getReference ( ) ) ; 
else ret = new ByteArrayInputStream ( data ) ; 
return ret ; 
} 
} 

public class ReferencedData { 
public synchronized long size ( final DataSource source ) throws DataSourceException { 
if ( data == null ) if ( getReference ( ) == null ) throw new IllegalStateException ( "No data or reference present" ) ; 
else return source . getDataSize ( getReference ( ) ) ; 
else return data . length ; 
} 
} 

public class Name { 
public String getIndex ( final int index ) { 
if ( index < 0 || index >= components . size ( ) ) throw new IllegalArgumentException ( "Index out of bounds" ) ; 
return components . get ( index ) ; 
} 
} 

public class Name { 
public Name getPrefix ( final int upperIndex ) { 
if ( upperIndex < 0 || upperIndex > components . size ( ) ) throw new IllegalArgumentException ( "Index out of bounds" ) ; 
return new Name ( components . subList ( 0 , upperIndex ) ) ; 
} 
} 

public class Runtime { 
boolean exec ( HsrePattern re , CharSequence data , EnumSet < ExecFlags > execFlags ) throws RegexException { 
if ( 0 != ( re . guts . info & Flags . REG_UIMPOSSIBLE ) ) throw new RegexException ( "Regex marked impossible" ) ; 
eflags = 0 ; 
for ( ExecFlags ef : execFlags ) { 
switch ( ef ) { 
case NOTBOL : eflags |= Flags . REG_NOTBOL ; 
break ; 
case NOTEOL : eflags |= Flags . REG_NOTEOL ; 
break ; 
case LOOKING_AT : eflags |= Flags . REG_LOOKING_AT ; 
break ; 
default : throw new RuntimeException ( "impossible exec flag" ) ; 
} 
} 
this . re = re ; 
this . g = re . guts ; 
this . data = data ; 
this . dataLength = this . data . length ( ) ; 
if ( this . match != null ) this . match . clear ( ) ; 
else this . match = Lists . newArrayList ( ) ; 
match . add ( null ) ; 
if ( 0 != ( g . info & Flags . REG_UBACKREF ) ) while ( match . size ( ) < g . nsub + 1 ) match . add ( null ) ; 
if ( mem != null && mem . length >= g . ntree ) Arrays . fill ( mem , 0 ) ; 
else mem = new int [ g . ntree ] ; 
assert g . tree != null ; 
if ( 0 != ( g . info & Flags . REG_UBACKREF ) ) return cfind ( g . tree . machine ) ; 
else return find ( g . tree . machine ) ; 
} 
} 

public class Runtime { 
private boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { 
int begin ; 
int end ; 
int cold ; 
int open ; 
int close ; 
int estart ; 
int estop ; 
boolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; 
boolean hitend [ ] = new boolean [ 1 ] ; 
boolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; 
assert d != null && s != null ; 
close = 0 ; 
do { 
int [ ] cold0 = new int [ 1 ] ; 
if ( lookingAt ) { 
close = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; 
cold = 0 ; 
} 
else { 
close = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; 
cold = cold0 [ 0 ] ; 
} 
if ( close == - 1 ) break ; 
assert cold != - 1 ; 
open = cold ; 
cold = - 1 ; 
for ( begin = open ; 
begin <= close ; 
begin ++ ) { 
if ( begin > 0 && lookingAt ) return false ; 
estart = begin ; 
estop = data . length ( ) ; 
for ( ; 
; 
) { 
if ( shorter ) end = d . shortest ( begin , estart , estop , null , hitend ) ; 
else end = d . longest ( begin , estop , hitend ) ; 
if ( hitend [ 0 ] && cold == - 1 ) cold = begin ; 
if ( end == - 1 ) break ; 
for ( int x = 0 ; 
x < match . size ( ) ; 
x ++ ) match . set ( x , null ) ; 
int maxsubno = getMaxSubno ( g . tree , 0 ) ; 
mem = new int [ maxsubno + 1 ] ; 
boolean matched = cdissect ( g . tree , begin , end ) ; 
if ( matched ) { 
match . set ( 0 , new RegMatch ( begin , end ) ) ; 
coldp [ 0 ] = cold ; 
return true ; 
} 
if ( shorter ? end == estop : end == begin ) { 
coldp [ 0 ] = cold ; 
return false ; 
} 
if ( shorter ) estart = end + 1 ; 
else estop = end - 1 ; 
} 
} 
} 
while ( close < data . length ( ) ) ; 
coldp [ 0 ] = cold ; 
return false ; 
} 
} 

public class Runtime { 
private void subset ( RuntimeSubexpression sub , int begin , int end ) { 
int n = sub . number ; 
assert n > 0 ; 
while ( match . size ( ) < ( n + 1 ) ) match . add ( null ) ; 
match . set ( n , new RegMatch ( begin , end ) ) ; 
} 
} 

public class Runtime { 
private boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { 
Dfa d ; 
Dfa d2 ; 
int mid ; 
assert t . op == '.' ; 
assert t . left != null && t . left . machine . states . length > 0 ; 
assert t . right != null && t . right . machine . states . length > 0 ; 
assert 0 != ( t . left . flags & Subre . SHORTER ) ; 
d = new Dfa ( this , t . left . machine ) ; 
d2 = new Dfa ( this , t . right . machine ) ; 
if ( mem [ t . retry ] == 0 ) { 
mid = d . shortest ( begin , begin , end , null , null ) ; 
if ( mid == - 1 ) return false ; 
mem [ t . retry ] = ( mid - begin ) + 1 ; 
} 
else mid = begin + ( mem [ t . retry ] - 1 ) ; 
for ( ; 
; 
) { 
boolean cdmatch = cdissect ( t . left , begin , mid ) ; 
if ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) break ; 
if ( mid == end ) return false ; 
mid = d . shortest ( begin , mid + 1 , end , null , null ) ; 
if ( mid == - 1 ) return false ; 
mem [ t . retry ] = ( mid - begin ) + 1 ; 
zapmem ( t . left ) ; 
zapmem ( t . right ) ; 
} 
return true ; 
} 
} 

public class Runtime { 
private boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { 
int i ; 
int n = t . number ; 
int len ; 
int paren ; 
int p ; 
int stop ; 
int min = t . min ; 
int max = t . max ; 
assert t . op == 'b' ; 
assert n >= 0 ; 
if ( match . get ( n ) == null ) return false ; 
paren = match . get ( n ) . start ; 
len = match . get ( n ) . end - match . get ( n ) . start ; 
if ( 0 != mem [ t . retry ] ) return false ; 
mem [ t . retry ] = 1 ; 
if ( len == 0 ) return begin == end ; 
assert end >= begin ; 
if ( ( end - begin ) < len ) return false ; 
stop = end - len ; 
i = 0 ; 
for ( p = begin ; 
p <= stop && ( i < max || max == Compiler . INFINITY ) ; 
p += len ) { 
if ( g . compare . compare ( data , paren , p , len ) != 0 ) break ; 
i ++ ; 
} 
if ( p != end ) return false ; 
return min <= i && ( i <= max || max == Compiler . INFINITY ) ; 
} 
} 

public class Compiler { 
private void cloneouts ( Nfa nfa , State old , State from , State to , int type ) { 
Arc a ; 
assert old != from ; 
for ( a = old . outs ; 
a != null ; 
a = a . outchain ) nfa . newarc ( type , a . co , from , to ) ; 
} 
} 

public class Compiler { 
private void optst ( Subre t ) { 
if ( t == null ) return ; 
if ( t . left != null ) optst ( t . left ) ; 
if ( t . right != null ) optst ( t . right ) ; 
} 
} 

public class Compiler { 
private void markst ( Subre t ) { 
assert t != null ; 
t . flags |= Subre . INUSE ; 
if ( t . left != null ) markst ( t . left ) ; 
if ( t . right != null ) markst ( t . right ) ; 
} 
} 

public class Compiler { 
private long nfanode ( Subre t ) throws RegexException { 
long ret ; 
assert t . begin != null ; 
if ( LOG . isDebugEnabled ( ) && IS_DEBUG ) LOG . debug ( String . format ( "========= TREE NODE %s ==========" , t . shortId ( ) ) ) ; 
Nfa newNfa = new Nfa ( nfa ) ; 
newNfa . dupnfa ( t . begin , t . end , newNfa . init , newNfa . finalState ) ; 
newNfa . specialcolors ( ) ; 
ret = newNfa . optimize ( ) ; 
t . cnfa = newNfa . compact ( ) ; 
return ret ; 
} 
} 

public class Compiler { 
private Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { 
State left ; 
State right ; 
Subre branches ; 
Subre branch ; 
Subre t ; 
int firstbranch ; 
assert stopper == ')' || stopper == EOS ; 
branches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; 
branch = branches ; 
firstbranch = 1 ; 
do { 
if ( 0 == firstbranch ) { 
branch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; 
branch = branch . right ; 
} 
firstbranch = 0 ; 
left = nfa . newstate ( ) ; 
right = nfa . newstate ( ) ; 
nfa . emptyarc ( initState , left ) ; 
nfa . emptyarc ( right , finalState ) ; 
branch . left = parsebranch ( stopper , type , left , right , false ) ; 
branch . flags |= up ( branch . flags | branch . left . flags ) ; 
if ( ( branch . flags & ~ branches . flags ) != 0 ) for ( t = branches ; 
t != branch ; 
t = t . right ) t . flags |= branch . flags ; 
} 
while ( eat ( '|' ) ) ; 
assert see ( stopper ) || see ( EOS ) ; 
if ( ! see ( stopper ) ) { 
assert stopper == ')' && see ( EOS ) ; 
throw new RegexException ( "Unbalanced parentheses." ) ; 
} 
if ( branch == branches ) { 
assert branch . right == null ; 
t = branch . left ; 
branch . left = null ; 
branches = t ; 
} 
else if ( ! messy ( branches . flags ) ) { 
branches . left = null ; 
branches . right = null ; 
branches . op = '=' ; 
} 
return branches ; 
} 
} 

public class Compiler { 
private void deltraverse ( Nfa nfa , State leftend , State s ) { 
Arc a ; 
State to ; 
if ( s . nouts == 0 ) return ; 
if ( s . tmp != null ) return ; 
s . tmp = s ; 
while ( ( a = s . outs ) != null ) { 
to = a . to ; 
deltraverse ( nfa , leftend , to ) ; 
assert to . nouts == 0 || to . tmp != null ; 
nfa . freearc ( a ) ; 
if ( to . nins == 0 && to . tmp == null ) { 
assert to . nouts == 0 ; 
nfa . freestate ( to ) ; 
} 
} 
assert s . no != State . FREESTATE ; 
assert s == leftend || s . nins != 0 ; 
assert s . nouts == 0 ; 
s . tmp = null ; 
} 
} 

public class Compiler { 
private int scannum ( ) throws RegexException { 
int n = 0 ; 
while ( see ( DIGIT ) && n < DUPMAX ) { 
n = n * 10 + nextvalue ; 
lex . next ( ) ; 
} 
if ( see ( DIGIT ) || n > DUPMAX ) throw new RegexException ( "Unvalid reference number." ) ; 
return n ; 
} 
} 

public class Compiler { 
private void bracket ( State lp , State rp ) throws RegexException { 
assert see ( '[' ) ; 
lex . next ( ) ; 
while ( ! see ( ']' ) && ! see ( EOS ) ) brackpart ( lp , rp ) ; 
assert see ( ']' ) ; 
cm . okcolors ( nfa ) ; 
} 
} 

public class Compiler { 
private int newlacon ( State begin , State end , int pos ) { 
if ( lacons . size ( ) == 0 ) lacons . add ( null ) ; 
Subre sub = new Subre ( ( char ) 0 , 0 , begin , end ) ; 
sub . subno = pos ; 
lacons . add ( sub ) ; 
return lacons . size ( ) - 1 ; 
} 
} 

public class Compiler { 
private void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { 
int rangeCount = set . getRangeCount ( ) ; 
for ( int rx = 0 ; 
rx < rangeCount ; 
rx ++ ) { 
int rangeStart = set . getRangeStart ( rx ) ; 
int rangeEnd = set . getRangeEnd ( rx ) ; 
if ( LOG . isDebugEnabled ( ) && IS_DEBUG ) LOG . debug ( String . format ( "%s %d %4x %4x" , set , rx , rangeStart , rangeEnd ) ) ; 
if ( rangeStart == rangeEnd ) nfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; 
cm . subrange ( rangeStart , rangeEnd , lp , rp ) ; 
} 
} 
} 

public class ColorMap { 
void subrange ( int from , int to , State lp , State rp ) throws RegexException { 
Map < Range < Integer > , Short > curColors = map . subRangeMap ( Range . closed ( from , to ) ) . asMapOfRanges ( ) ; 
List < Range < Integer > > ranges = Lists . newArrayList ( curColors . keySet ( ) ) ; 
for ( Range < Integer > rangeToProcess : ranges ) { 
int start = rangeToProcess . lowerEndpoint ( ) ; 
if ( rangeToProcess . lowerBoundType ( ) == BoundType . OPEN ) start ++ ; 
int end = rangeToProcess . upperEndpoint ( ) ; 
if ( rangeToProcess . upperBoundType ( ) == BoundType . CLOSED ) end ++ ; 
short color = subcolor ( start , end - start ) ; 
compiler . getNfa ( ) . newarc ( Compiler . PLAIN , color , lp , rp ) ; 
} 
} 
} 

public class ColorMap { 
void okcolors ( Nfa nfa ) { 
ColorDesc cd ; 
ColorDesc scd ; 
Arc a ; 
short sco ; 
for ( short co = 0 ; 
co < colorDescs . size ( ) ; 
co ++ ) { 
cd = colorDescs . get ( co ) ; 
if ( cd == null ) continue ; 
sco = cd . sub ; 
if ( sco == Constants . NOSUB ) { 
} 
else if ( sco == co ) { 
} 
else if ( cd . getNChars ( ) == 0 ) { 
cd . sub = Constants . NOSUB ; 
scd = colorDescs . get ( sco ) ; 
assert scd . getNChars ( ) > 0 ; 
assert scd . sub == sco ; 
scd . sub = Constants . NOSUB ; 
while ( ( a = cd . arcs ) != null ) { 
assert a . co == co ; 
cd . arcs = a . colorchain ; 
a . setColor ( sco ) ; 
a . colorchain = scd . arcs ; 
scd . arcs = a ; 
} 
freecolor ( co ) ; 
} 
else { 
cd . sub = Constants . NOSUB ; 
scd = colorDescs . get ( sco ) ; 
assert scd . getNChars ( ) > 0 ; 
assert scd . sub == sco ; 
scd . sub = Constants . NOSUB ; 
for ( a = cd . arcs ; 
a != null ; 
a = a . colorchain ) { 
assert a . co == co ; 
nfa . newarc ( a . type , sco , a . from , a . to ) ; 
} 
} 
} 
} 
} 

public class ColorMap { 
void uncolorchain ( Arc a ) { 
ColorDesc cd = colorDescs . get ( a . co ) ; 
Arc aa ; 
aa = cd . arcs ; 
if ( aa == a ) cd . arcs = a . colorchain ; 
else { 
for ( ; 
aa != null && aa . colorchain != a ; 
aa = aa . colorchain ) { 
} 
assert aa != null ; 
aa . colorchain = a . colorchain ; 
} 
a . colorchain = null ; 
} 
} 

public class ColorMap { 
void dumpcolors ( ) { 
for ( int co = 0 ; 
co < colorDescs . size ( ) ; 
co ++ ) { 
ColorDesc cd = colorDescs . get ( co ) ; 
if ( cd != null ) dumpcolor ( co , cd ) ; 
} 
} 
} 

public class Lex { 
void prefixes ( ) throws RegexException { 
if ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) return ; 
if ( have ( 4 ) && next3 ( '*' , '*' , '*' ) ) switch ( charAtNowPlus ( 3 ) ) { 
case '?' : throw new RegexException ( "REG_BADPAT" ) ; 
case '=' : v . note ( Flags . REG_UNONPOSIX ) ; 
v . cflags |= Flags . REG_QUOTE ; 
v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; 
v . now += 4 ; 
return ; 
case ':' : v . note ( Flags . REG_UNONPOSIX ) ; 
v . cflags |= Flags . REG_ADVANCED ; 
v . now += 4 ; 
break ; 
default : throw new RegexException ( "REG_BADRPT" ) ; 
} 
if ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) return ; 
if ( have ( 3 ) && next2 ( '(' , '?' ) && iscalpha ( charAtNowPlus ( 2 ) ) ) { 
v . note ( Flags . REG_UNONPOSIX ) ; 
v . now += 2 ; 
for ( ; 
! ateos ( ) && iscalpha ( charAtNow ( ) ) ; 
v . now ++ ) switch ( charAtNow ( ) ) { 
case 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; 
break ; 
case 'c' : v . cflags &= ~ Flags . REG_ICASE ; 
break ; 
case 'e' : v . cflags |= Flags . REG_EXTENDED ; 
v . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; 
break ; 
case 'i' : v . cflags |= Flags . REG_ICASE ; 
break ; 
case 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; 
break ; 
case 'p' : v . cflags |= Flags . REG_NLSTOP ; 
v . cflags &= ~ Flags . REG_NLANCH ; 
break ; 
case 'q' : v . cflags |= Flags . REG_QUOTE ; 
v . cflags &= ~ Flags . REG_ADVANCED ; 
break ; 
case 's' : v . cflags &= ~ Flags . REG_NEWLINE ; 
break ; 
case 't' : v . cflags &= ~ Flags . REG_EXPANDED ; 
break ; 
case 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; 
v . cflags |= Flags . REG_NLANCH ; 
break ; 
case 'x' : v . cflags |= Flags . REG_EXPANDED ; 
break ; 
default : throw new RegexException ( "REG_BADOPT" ) ; 
} 
if ( ! next1 ( ')' ) ) throw new RegexException ( "REG_BADOPT" ) ; 
v . now ++ ; 
if ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) v . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; 
} 
} 
} 

public class Dfa { 
int lastcold ( ) { 
int nopr = 0 ; 
for ( StateSet ss : stateSets . values ( ) ) { 
if ( ss . noprogress && nopr < ss . getLastSeen ( ) ) nopr = ss . getLastSeen ( ) ; 
} 
return nopr ; 
} 
} 

public class Locale { 
static UnicodeSet eclass ( char c , boolean cases ) { 
if ( cases ) return allcases ( c ) ; 
else { 
UnicodeSet set = new UnicodeSet ( ) ; 
set . add ( c ) ; 
return set ; 
} 
} 
} 

public class Locale { 
public static UnicodeSet cclass ( String cclassName , boolean casefold ) throws RegexException { 
try { 
if ( casefold ) return KNOWN_SETS_CI . get ( cclassName ) ; 
else return KNOWN_SETS_CS . get ( cclassName ) ; 
} 
catch ( ExecutionException e ) { 
Throwables . propagateIfInstanceOf ( e . getCause ( ) , RegexException . class ) ; 
throw new RegexRuntimeException ( e . getCause ( ) ) ; 
} 
} 
} 

public class CnfaBuilder { 
void carcsort ( int first , int last ) { 
int p ; 
int q ; 
long tmp ; 
if ( last - first <= 1 ) return ; 
for ( p = first ; 
p <= last ; 
p ++ ) for ( q = p ; 
q <= last ; 
q ++ ) { 
short pco = Cnfa . carcColor ( arcs [ p ] ) ; 
short qco = Cnfa . carcColor ( arcs [ q ] ) ; 
int pto = Cnfa . carcTarget ( arcs [ p ] ) ; 
int qto = Cnfa . carcTarget ( arcs [ q ] ) ; 
if ( pco > qco || ( pco == qco && pto > qto ) ) { 
assert p != q ; 
tmp = arcs [ p ] ; 
arcs [ p ] = arcs [ q ] ; 
arcs [ q ] = tmp ; 
} 
} 
} 
} 

public class Subre { 
String dumpst ( boolean nfapresent ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( String . format ( "%s. `%c'" , shortId ( ) , op ) ) ; 
if ( 0 != ( flags & LONGER ) ) sb . append ( " longest" ) ; 
if ( 0 != ( flags & SHORTER ) ) sb . append ( " shortest" ) ; 
if ( 0 != ( flags & MIXED ) ) sb . append ( " hasmixed" ) ; 
if ( 0 != ( flags & CAP ) ) sb . append ( " hascapture" ) ; 
if ( 0 != ( flags & BACKR ) ) sb . append ( " hasbackref" ) ; 
if ( 0 == ( flags & INUSE ) ) sb . append ( " UNUSED" ) ; 
if ( subno != 0 ) sb . append ( String . format ( " (#%d)" , subno ) ) ; 
if ( min != 1 || max != 1 ) { 
sb . append ( String . format ( " {%d," , min ) ) ; 
if ( max != Compiler . INFINITY ) sb . append ( String . format ( "%d" , max ) ) ; 
sb . append ( "}" ) ; 
} 
if ( nfapresent ) sb . append ( String . format ( " %d-%d" , begin . no , end . no ) ) ; 
if ( left != null ) sb . append ( String . format ( " L:%s" , left . toString ( ) ) ) ; 
if ( right != null ) sb . append ( String . format ( " R:%s" , right . toString ( ) ) ) ; 
sb . append ( "\n" ) ; 
if ( left != null ) left . dumpst ( nfapresent ) ; 
if ( right != null ) right . dumpst ( nfapresent ) ; 
return sb . toString ( ) ; 
} 
} 

public class Nfa { 
State newstate ( int flag ) { 
State newState = new State ( ) ; 
newState . no = nstates ++ ; 
if ( states == null ) states = newState ; 
if ( slast != null ) { 
assert slast . next == null ; 
slast . next = newState ; 
} 
newState . prev = slast ; 
slast = newState ; 
newState . flag = flag ; 
return newState ; 
} 
} 

public class Nfa { 
void copyins ( State old , State newState ) { 
Arc a ; 
assert old != newState ; 
for ( a = old . ins ; 
a != null ; 
a = a . inchain ) cparc ( a , a . from , newState ) ; 
} 
} 

public class Nfa { 
void copyouts ( State old , State newState ) { 
Arc a ; 
assert old != newState ; 
for ( a = old . outs ; 
a != null ; 
a = a . outchain ) cparc ( a , newState , a . to ) ; 
} 
} 

public class Nfa { 
void dropstate ( State s ) { 
Arc a ; 
while ( ( a = s . ins ) != null ) freearc ( a ) ; 
while ( ( a = s . outs ) != null ) freearc ( a ) ; 
freestate ( s ) ; 
} 
} 

public class Nfa { 
void freestate ( State s ) { 
assert s != null ; 
assert s . nins == 0 ; 
assert s . nouts == 0 ; 
if ( s . next != null ) s . next . prev = s . prev ; 
else { 
assert s == slast ; 
slast = s . prev ; 
} 
if ( s . prev != null ) s . prev . next = s . next ; 
else { 
assert s == states ; 
states = s . next ; 
} 
} 
} 

public class Nfa { 
void duptraverse ( State s , State stmp ) { 
Arc a ; 
if ( s . tmp != null ) return ; 
s . tmp = ( stmp == null ) ? newstate ( ) : stmp ; 
if ( s . tmp == null ) return ; 
for ( a = s . outs ; 
a != null ; 
a = a . outchain ) { 
duptraverse ( a . to , null ) ; 
assert a . to . tmp != null ; 
cparc ( a , s . tmp , a . to . tmp ) ; 
} 
} 
} 

public class Nfa { 
void dumpnfa ( ) { 
if ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) return ; 
LOG . debug ( "dump nfa" ) ; 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( String . format ( "pre %d, post %d init %d final %d" , pre . no , post . no , init . no , finalState . no ) ) ; 
if ( bos [ 0 ] != Constants . COLORLESS ) sb . append ( String . format ( ", bos [%d]" , bos [ 0 ] ) ) ; 
if ( bos [ 1 ] != Constants . COLORLESS ) sb . append ( String . format ( ", bol [%d]" , bos [ 1 ] ) ) ; 
if ( eos [ 0 ] != Constants . COLORLESS ) sb . append ( String . format ( ", eos [%d]" , eos [ 0 ] ) ) ; 
if ( eos [ 1 ] != Constants . COLORLESS ) sb . append ( String . format ( ", eol [%d]" , eos [ 1 ] ) ) ; 
LOG . debug ( sb . toString ( ) ) ; 
for ( State s = states ; 
s != null ; 
s = s . next ) dumpstate ( s ) ; 
if ( parent == null ) cm . dumpcolors ( ) ; 
} 
} 

public class Nfa { 
void dumpstate ( State s ) { 
Arc a ; 
if ( ! LOG . isDebugEnabled ( ) || ! IS_DEBUG ) return ; 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( String . format ( "State %d%s%c" , s . no , ( s . tmp != null ) ? "T" : "" , ( s . flag != 0 ) ? ( char ) s . flag : '.' ) ) ; 
if ( s . prev != null && s . prev . next != s ) sb . append ( String . format ( "\tstate chain bad" ) ) ; 
if ( s . nouts == 0 ) sb . append ( "\tno out arcs" ) ; 
else dumparcs ( s , sb ) ; 
LOG . debug ( sb . toString ( ) ) ; 
for ( a = s . ins ; 
a != null ; 
a = a . inchain ) if ( a . to != s ) LOG . debug ( String . format ( "\tlink from %d to %d on %d's in-chain" , a . from . no , a . to . no , s . no ) ) ; 
} 
} 

public class Nfa { 
int dumprarcs ( Arc a , State s , int pos , StringBuilder sb ) { 
if ( a . outchain != null ) pos = dumprarcs ( a . outchain , s , pos , sb ) ; 
dumparc ( a , s , sb ) ; 
if ( pos == 5 ) { 
sb . append ( "\n" ) ; 
pos = 1 ; 
} 
else pos ++ ; 
return pos ; 
} 
} 

public class Nfa { 
void dumparc ( Arc a , State s , StringBuilder sb ) { 
sb . append ( "\t" ) ; 
switch ( a . type ) { 
case Compiler . PLAIN : sb . append ( String . format ( "[%d]" , a . co ) ) ; 
break ; 
case Compiler . AHEAD : sb . append ( String . format ( ">%d>" , a . co ) ) ; 
break ; 
case Compiler . BEHIND : sb . append ( String . format ( "<%d<" , a . co ) ) ; 
break ; 
case Compiler . LACON : sb . append ( String . format ( ":%d:" , a . co ) ) ; 
break ; 
case '^' : case '$' : sb . append ( String . format ( "%c%d" , ( char ) a . type , a . co ) ) ; 
break ; 
case Compiler . EMPTY : break ; 
default : sb . append ( String . format ( "0x%x/0%d" , a . type , a . co ) ) ; 
break ; 
} 
if ( a . from != s ) sb . append ( String . format ( "?%d?" , a . from . no ) ) ; 
sb . append ( "->" ) ; 
if ( a . to == null ) { 
sb . append ( "null" ) ; 
Arc aa ; 
for ( aa = a . to . ins ; 
aa != null ; 
aa = aa . inchain ) if ( aa == a ) break ; 
if ( aa == null ) LOG . debug ( "?!?" ) ; 
} 
else sb . append ( String . format ( "%d" , a . to . no ) ) ; 
} 
} 

public class Nfa { 
long analyze ( ) { 
Arc a ; 
Arc aa ; 
if ( pre . outs == null ) return Flags . REG_UIMPOSSIBLE ; 
for ( a = pre . outs ; 
a != null ; 
a = a . outchain ) for ( aa = a . to . outs ; 
aa != null ; 
aa = aa . outchain ) if ( aa . to == post ) return Flags . REG_UEMPTYMATCH ; 
return 0 ; 
} 
} 

public class Nfa { 
int combine ( Arc con , Arc a ) throws RegexException { 
switch ( ( con . type << 8 ) | a . type ) { 
case '^' << 8 | Compiler . PLAIN : case '$' << 8 | Compiler . PLAIN : return INCOMPATIBLE ; 
case Compiler . AHEAD << 8 | Compiler . PLAIN : case Compiler . BEHIND << 8 | Compiler . PLAIN : if ( con . co == a . co ) return SATISFIED ; 
return INCOMPATIBLE ; 
case '^' << 8 | '^' : case '$' << 8 | '$' : case Compiler . AHEAD << 8 | Compiler . AHEAD : case Compiler . BEHIND << 8 | Compiler . BEHIND : if ( con . co == a . co ) return SATISFIED ; 
return INCOMPATIBLE ; 
case '^' << 8 | Compiler . BEHIND : case Compiler . BEHIND << 8 | '^' : case '$' << 8 | Compiler . AHEAD : case Compiler . AHEAD << 8 | '$' : return INCOMPATIBLE ; 
case '^' << 8 | Compiler . AHEAD : case Compiler . BEHIND << 8 | '$' : case Compiler . BEHIND << 8 | Compiler . AHEAD : case '$' << 8 | '^' : case '$' << 8 | Compiler . BEHIND : case Compiler . AHEAD << 8 | '^' : case Compiler . AHEAD << 8 | Compiler . BEHIND : case '^' << 8 | Compiler . LACON : case Compiler . BEHIND << 8 | Compiler . LACON : case '$' << 8 | Compiler . LACON : case Compiler . AHEAD << 8 | Compiler . LACON : return COMPATIBLE ; 
default : throw new RuntimeException ( "Impossible arc" ) ; 
} 
} 
} 

public class Nfa { 
void cleanup ( ) { 
State s ; 
State nexts ; 
int n ; 
markreachable ( pre , null , pre ) ; 
markcanreach ( post , pre , post ) ; 
for ( s = states ; 
s != null ; 
s = nexts ) { 
nexts = s . next ; 
if ( s . tmp != post && 0 == s . flag ) dropstate ( s ) ; 
} 
assert post . nins == 0 || post . tmp == post ; 
cleartraverse ( pre ) ; 
assert post . nins == 0 || post . tmp == null ; 
n = 0 ; 
for ( s = states ; 
s != null ; 
s = s . next ) s . no = n ++ ; 
nstates = n ; 
} 
} 

public class Nfa { 
void markreachable ( State s , State okay , State mark ) { 
Arc a ; 
if ( s . tmp != okay ) return ; 
s . tmp = mark ; 
for ( a = s . outs ; 
a != null ; 
a = a . outchain ) markreachable ( a . to , okay , mark ) ; 
} 
} 

public class Nfa { 
void markcanreach ( State s , State okay , State mark ) { 
Arc a ; 
if ( s . tmp != okay ) return ; 
s . tmp = mark ; 
for ( a = s . ins ; 
a != null ; 
a = a . inchain ) markcanreach ( a . from , okay , mark ) ; 
} 
} 

public class Nfa { 
void fixempties ( ) { 
State s ; 
State nexts ; 
Arc a ; 
Arc nexta ; 
boolean progress ; 
do { 
progress = false ; 
for ( s = states ; 
s != null ; 
s = nexts ) { 
nexts = s . next ; 
for ( a = s . outs ; 
a != null ; 
a = nexta ) { 
nexta = a . outchain ; 
if ( a . type == Compiler . EMPTY && unempty ( a ) ) progress = true ; 
assert nexta == null || s . no != State . FREESTATE ; 
} 
} 
if ( progress ) dumpnfa ( ) ; 
} 
while ( progress ) ; 
} 
} 

public class Nfa { 
boolean unempty ( Arc a ) { 
State from = a . from ; 
State to = a . to ; 
boolean usefrom ; 
assert a . type == Compiler . EMPTY ; 
assert from != pre && to != post ; 
if ( from == to ) { 
freearc ( a ) ; 
return true ; 
} 
usefrom = true ; 
if ( from . nouts > to . nins ) usefrom = false ; 
else if ( from . nouts == to . nins ) if ( from . nins > to . nouts ) usefrom = false ; 
freearc ( a ) ; 
if ( usefrom ) if ( from . nouts == 0 ) { 
moveins ( from , to ) ; 
freestate ( from ) ; 
} 
else copyins ( from , to ) ; 
else if ( to . nins == 0 ) { 
moveouts ( to , from ) ; 
freestate ( to ) ; 
} 
else copyouts ( to , from ) ; 
return true ; 
} 
} 

public class AnalyzeTask { 
private Map < String , String > getRuleParameters ( ) throws CliExecutionException { 
Map < String , String > ruleParameters ; 
if ( ruleParametersFile == null ) ruleParameters = Collections . emptyMap ( ) ; 
else { 
Properties properties = new Properties ( ) ; 
try { 
properties . load ( new FileInputStream ( ruleParametersFile ) ) ; 
} 
catch ( IOException e ) { 
throw new CliExecutionException ( "Cannot read rule parameters file '" + ruleParametersFile . getPath ( ) + "'." ) ; 
} 
ruleParameters = new TreeMap < > ( ) ; 
for ( String name : properties . stringPropertyNames ( ) ) { 
ruleParameters . put ( name , properties . getProperty ( name ) ) ; 
} 
} 
return ruleParameters ; 
} 
} 

public class Main { 
private void interpretCommandLine ( CommandLine commandLine , Options options , TaskFactory taskFactory ) throws CliExecutionException { 
if ( commandLine . hasOption ( OPTION_HELP ) ) { 
printUsage ( options , null ) ; 
System . exit ( 1 ) ; 
} 
List < String > taskNames = commandLine . getArgList ( ) ; 
if ( taskNames . isEmpty ( ) ) { 
printUsage ( options , "A task must be specified, i.e. one  of " + gatherTaskNames ( taskFactory ) ) ; 
System . exit ( 1 ) ; 
} 
List < Task > tasks = new ArrayList < > ( ) ; 
for ( String taskName : taskNames ) { 
Task task = taskFactory . fromName ( taskName ) ; 
if ( task == null ) printUsage ( options , "Unknown task " + taskName ) ; 
tasks . add ( task ) ; 
} 
Map < String , Object > properties = readProperties ( commandLine ) ; 
PluginRepository pluginRepository = getPluginRepository ( ) ; 
try { 
executeTasks ( tasks , options , commandLine , pluginRepository , properties ) ; 
} 
catch ( PluginRepositoryException e ) { 
throw new CliExecutionException ( "Unexpected plugin repository problem while executing tasks." , e ) ; 
} 
} 
} 

public class Main { 
private Map < String , Object > readProperties ( CommandLine commandLine ) throws CliConfigurationException { 
final Properties properties = new Properties ( ) ; 
InputStream propertiesStream ; 
if ( commandLine . hasOption ( "p" ) ) { 
File propertyFile = new File ( commandLine . getOptionValue ( "p" ) ) ; 
if ( ! propertyFile . exists ( ) ) throw new CliConfigurationException ( "Property file given by command line does not exist: " + propertyFile . getAbsolutePath ( ) ) ; 
try { 
propertiesStream = new FileInputStream ( propertyFile ) ; 
} 
catch ( FileNotFoundException e ) { 
throw new CliConfigurationException ( "Cannot open property file." , e ) ; 
} 
} 
else propertiesStream = Main . class . getResourceAsStream ( "/jqassistant.properties" ) ; 
Map < String , Object > result = new HashMap < > ( ) ; 
if ( propertiesStream != null ) { 
try { 
properties . load ( propertiesStream ) ; 
} 
catch ( IOException e ) { 
throw new CliConfigurationException ( "Cannot load properties from file." , e ) ; 
} 
for ( String name : properties . stringPropertyNames ( ) ) { 
result . put ( name , properties . getProperty ( name ) ) ; 
} 
} 
return result ; 
} 
} 

public class Main { 
private void printUsage ( final Options options , final String errorMessage ) { 
if ( errorMessage != null ) System . out . println ( "Error: " + errorMessage ) ; 
final HelpFormatter formatter = new HelpFormatter ( ) ; 
formatter . printHelp ( Main . class . getCanonicalName ( ) + " <task> [options]" , options ) ; 
System . out . println ( "Tasks are: " + gatherTaskNames ( taskFactory ) ) ; 
System . out . println ( "Example: " + Main . class . getCanonicalName ( ) + " scan -f java:classpath::target/classes java:classpath::target/test-classes" ) ; 
} 
} 

public class Main { 
private ClassLoader createPluginClassLoader ( ) throws CliExecutionException { 
ClassLoader parentClassLoader = Task . class . getClassLoader ( ) ; 
File homeDirectory = getHomeDirectory ( ) ; 
if ( homeDirectory != null ) { 
File pluginDirectory = new File ( homeDirectory , DIRECTORY_PLUGINS ) ; 
if ( pluginDirectory . exists ( ) ) { 
final List < URL > urls = new ArrayList < > ( ) ; 
final Path pluginDirectoryPath = pluginDirectory . toPath ( ) ; 
SimpleFileVisitor < Path > visitor = new SimpleFileVisitor < Path > ( ) { 
@ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { 
if ( file . toFile ( ) . getName ( ) . endsWith ( ".jar" ) ) urls . add ( file . toFile ( ) . toURI ( ) . toURL ( ) ) ; 
return FileVisitResult . CONTINUE ; 
} 
} 
; 
try { 
Files . walkFileTree ( pluginDirectoryPath , visitor ) ; 
} 
catch ( IOException e ) { 
throw new CliExecutionException ( "Cannot read plugin directory." , e ) ; 
} 
LOGGER . debug ( "Using plugin URLs: " + urls ) ; 
return new com . buschmais . jqassistant . commandline . PluginClassLoader ( urls , parentClassLoader ) ; 
} 
} 
return parentClassLoader ; 
} 
} 

public class CountryBoundaries { 
public Set < String > getContainingIds ( double minLongitude , double minLatitude , double maxLongitude , double maxLatitude ) { 
Set < String > ids = new HashSet < > ( ) ; 
forCellsIn ( minLongitude , minLatitude , maxLongitude , maxLatitude , cell -> { 
if ( ids . isEmpty ( ) ) ids . addAll ( cell . getContainingIds ( ) ) ; 
else ids . retainAll ( cell . getContainingIds ( ) ) ; 
} 
) ; 
return ids ; 
} 
} 

public class Router { 
public String uri ( HttpMethod method , T target , Object ... params ) { 
MethodlessRouter < T > router = ( method == null ) ? anyMethodRouter : routers . get ( method ) ; 
if ( router == null ) router = anyMethodRouter ; 
String ret = router . uri ( target , params ) ; 
if ( ret != null ) return ret ; 
return ( router != anyMethodRouter ) ? anyMethodRouter . uri ( target , params ) : null ; 
} 
} 

public class OrderlessRouter { 
public OrderlessRouter < T > addRoute ( String pathPattern , T target ) { 
PathPattern p = new PathPattern ( pathPattern ) ; 
if ( routes . containsKey ( p ) ) return this ; 
routes . put ( p , target ) ; 
addReverseRoute ( target , p ) ; 
return this ; 
} 
} 

public class HibernateBookmarkStore { 
private Criterion smartEqual ( String property , Object value ) { 
if ( value == null ) return Restrictions . isNull ( property ) ; 
else return Restrictions . eq ( property , value ) ; 
} 
} 

public class DefaultBookmarksComparator { 
protected int compareFolders ( final Entry e1 , final Entry e2 ) { 
final boolean f1 = e1 instanceof Folder ; 
final boolean f2 = e2 instanceof Folder ; 
if ( f1 && ! f2 ) return - 1 ; 
else if ( ! f1 && f2 ) return 1 ; 
else return 0 ; 
} 
} 

public class DefaultBookmarksComparator { 
protected int compareBookmarks ( final Entry e1 , final Entry e2 ) { 
if ( e1 instanceof Bookmark && e2 instanceof Bookmark ) { 
final Bookmark b1 = ( Bookmark ) e1 ; 
final Bookmark b2 = ( Bookmark ) e2 ; 
return new CompareToBuilder ( ) . append ( b1 . getUrl ( ) , b2 . getUrl ( ) ) . append ( b1 . isNewWindow ( ) , b2 . isNewWindow ( ) ) . toComparison ( ) ; 
} 
else return 0 ; 
} 
} 

public class JspServletWrapper { 
public void setServletClassLastModifiedTime ( long lastModified ) { 
if ( this . servletClassLastModifiedTime < lastModified ) synchronized ( this ) { 
if ( this . servletClassLastModifiedTime < lastModified ) { 
this . servletClassLastModifiedTime = lastModified ; 
reload = true ; 
} 
} 
} 
} 

public class JspServletWrapper { 
public java . util . List < String > getDependants ( ) { 
try { 
Object target ; 
if ( isTagFile ) { 
if ( reload ) tagHandlerClass = ctxt . load ( ) ; 
target = tagHandlerClass . newInstance ( ) ; 
} 
else target = getServlet ( ) ; 
if ( target != null && target instanceof JspSourceDependent ) return ( ( JspSourceDependent ) target ) . getDependants ( ) ; 
} 
catch ( Throwable ex ) { 
} 
return null ; 
} 
} 

public class JasperLoader { 
public Class findClass ( String className ) throws ClassNotFoundException { 
byte [ ] cdata = this . bytecodes . get ( className ) ; 
String path = className . replace ( '.' , '/' ) + ".class" ; 
if ( cdata == null ) { 
cdata = loadClassDataFromFile ( path ) ; 
if ( cdata == null ) throw new ClassNotFoundException ( className ) ; 
} 
Class clazz = null ; 
if ( securityManager != null ) { 
ProtectionDomain pd = new ProtectionDomain ( codeSource , permissionCollection ) ; 
clazz = defineClass ( className , cdata , 0 , cdata . length , pd ) ; 
} 
else clazz = defineClass ( className , cdata , 0 , cdata . length ) ; 
return clazz ; 
} 
} 

public class BasicAuthentication { 
public static String [ ] parseAuthorization ( final HttpServletRequest request ) { 
final String auth = request . getHeader ( "Authorization" ) ; 
logger . debug ( "Auth header: {}" , auth ) ; 
if ( auth == null || auth . isEmpty ( ) ) return null ; 
final String [ ] toks = auth . split ( "\\s" ) ; 
if ( toks . length < 2 ) return null ; 
if ( ! "Basic" . equalsIgnoreCase ( toks [ 0 ] ) ) return null ; 
final byte [ ] authData = Base64 . getDecoder ( ) . decode ( toks [ 1 ] ) ; 
final String authStr = StandardCharsets . ISO_8859_1 . decode ( ByteBuffer . wrap ( authData ) ) . toString ( ) ; 
logger . debug ( "Auth String: {}" , authStr ) ; 
final String [ ] authToks = authStr . split ( ":" , 2 ) ; 
logger . debug ( "Auth tokens: {}" , new Object [ ] { 
authToks } 
) ; 
if ( authToks . length != 2 ) return null ; 
return authToks ; 
} 
} 

public class ProtectedFunctionMapper { 
public static ProtectedFunctionMapper getInstance ( ) { 
ProtectedFunctionMapper funcMapper ; 
if ( SecurityUtil . isPackageProtectionEnabled ( ) ) funcMapper = AccessController . doPrivileged ( new PrivilegedAction < ProtectedFunctionMapper > ( ) { 
public ProtectedFunctionMapper run ( ) { 
return new ProtectedFunctionMapper ( ) ; 
} 
} 
) ; 
else funcMapper = new ProtectedFunctionMapper ( ) ; 
funcMapper . fnmap = new java . util . HashMap < String , Method > ( ) ; 
return funcMapper ; 
} 
} 

public class ProtectedFunctionMapper { 
public void mapFunction ( String fnQName , final Class < ? > c , final String methodName , final Class < ? > [ ] args ) { 
java . lang . reflect . Method method ; 
if ( SecurityUtil . isPackageProtectionEnabled ( ) ) try { 
method = AccessController . doPrivileged ( new PrivilegedExceptionAction < Method > ( ) { 
public Method run ( ) throws Exception { 
return c . getDeclaredMethod ( methodName , args ) ; 
} 
} 
) ; 
} 
catch ( PrivilegedActionException ex ) { 
throw new RuntimeException ( "Invalid function mapping - no such method: " + ex . getException ( ) . getMessage ( ) ) ; 
} 
else try { 
method = c . getDeclaredMethod ( methodName , args ) ; 
} 
catch ( NoSuchMethodException e ) { 
throw new RuntimeException ( "Invalid function mapping - no such method: " + e . getMessage ( ) ) ; 
} 
this . fnmap . put ( fnQName , method ) ; 
} 
} 

public class ProtectedFunctionMapper { 
public Method resolveFunction ( String prefix , String localName ) { 
if ( this . fnmap != null ) return this . fnmap . get ( prefix + ":" + localName ) ; 
return theMethod ; 
} 
} 

public class ParserController { 
private Node . Nodes doParse ( String inFileName , Node parent , URL jarFileUrl ) throws FileNotFoundException , JasperException , IOException { 
Node . Nodes parsedPage = null ; 
isEncodingSpecifiedInProlog = false ; 
isDefaultPageEncoding = false ; 
hasBom = false ; 
JarFile jarFile = getJarFile ( jarFileUrl ) ; 
String absFileName = resolveFileName ( inFileName ) ; 
String jspConfigPageEnc = getJspConfigPageEncoding ( absFileName ) ; 
determineSyntaxAndEncoding ( absFileName , jarFile , jspConfigPageEnc ) ; 
if ( parent != null ) compiler . getPageInfo ( ) . addDependant ( absFileName ) ; 
comparePageEncodings ( jspConfigPageEnc ) ; 
if ( isXml ) parsedPage = JspDocumentParser . parse ( this , absFileName , jarFile , parent , isTagFile , directiveOnly , sourceEnc , jspConfigPageEnc , isEncodingSpecifiedInProlog ) ; 
else { 
InputStreamReader inStreamReader = null ; 
try { 
inStreamReader = JspUtil . getReader ( absFileName , sourceEnc , jarFile , ctxt , err ) ; 
JspReader jspReader = new JspReader ( ctxt , absFileName , sourceEnc , inStreamReader , err ) ; 
parsedPage = Parser . parse ( this , absFileName , jspReader , parent , isTagFile , directiveOnly , jarFileUrl , sourceEnc , jspConfigPageEnc , isDefaultPageEncoding , hasBom ) ; 
} 
finally { 
if ( inStreamReader != null ) try { 
inStreamReader . close ( ) ; 
} 
catch ( Exception any ) { 
} 
} 
} 
if ( jarFile != null ) try { 
jarFile . close ( ) ; 
} 
catch ( Throwable t ) { 
} 
baseDirStack . pop ( ) ; 
return parsedPage ; 
} 
} 

public class JspCompilationContext { 
public Compiler createCompiler ( boolean jspcMode ) throws JasperException { 
if ( jspCompiler != null ) return jspCompiler ; 
jspCompiler = new Compiler ( this , jsw , jspcMode ) ; 
return jspCompiler ; 
} 
} 

public class OsgiSitemapGenerator { 
private Optional < Instant > calcLastMod ( ) { 
Instant globalLastMod = null ; 
for ( final ChannelInformation ci : this . channelService . list ( ) ) { 
final Optional < Instant > lastMod = ofNullable ( ci . getState ( ) . getModificationTimestamp ( ) ) ; 
if ( globalLastMod == null || lastMod . get ( ) . isAfter ( globalLastMod ) ) globalLastMod = lastMod . get ( ) ; 
} 
return Optional . ofNullable ( globalLastMod ) ; 
} 
} 

public class JSPContextFinder { 
ArrayList basicFindClassLoaders ( ) { 
Class [ ] stack = contextFinder . getClassContext ( ) ; 
ArrayList result = new ArrayList ( 1 ) ; 
ClassLoader previousLoader = null ; 
for ( int i = 1 ; 
i < stack . length ; 
i ++ ) { 
ClassLoader tmp = stack [ i ] . getClassLoader ( ) ; 
if ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { 
if ( checkClassLoader ( tmp ) ) if ( previousLoader != tmp ) { 
result . add ( tmp ) ; 
previousLoader = tmp ; 
} 
if ( Activator . getBundle ( stack [ i ] ) != null ) break ; 
} 
} 
return result ; 
} 
} 

public class Pagination { 
public static < T > PaginationResult < T > paginate ( final Integer startPage , final int pageSize , final List < T > fullDataSet ) { 
return paginate ( startPage , pageSize , ( start , length ) -> { 
final int len = fullDataSet . size ( ) ; 
if ( start > len ) return Collections . emptyList ( ) ; 
return fullDataSet . subList ( start , Math . min ( start + length , len ) ) ; 
} 
) ; 
} 
} 

public class MetaKey { 
public static MetaKey fromString ( final String string ) { 
final int idx = string . indexOf ( ':' ) ; 
if ( idx < 1 ) return null ; 
if ( idx + 1 >= string . length ( ) ) return null ; 
return new MetaKey ( string . substring ( 0 , idx ) , string . substring ( idx + 1 ) , true ) ; 
} 
} 

public class RpmBuilder { 
private void fillRequirements ( ) throws IOException { 
this . requirements . add ( new Dependency ( "rpmlib(CompressedFileNames)" , "3.0.4-1" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; 
if ( ! this . options . getFileDigestAlgorithm ( ) . equals ( DigestAlgorithm . MD5 ) ) this . requirements . add ( new Dependency ( "rpmlib(FileDigests)" , "4.6.0-1" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; 
this . requirements . add ( new Dependency ( "rpmlib(PayloadFilesHavePrefix)" , "4.0-1" , RpmDependencyFlags . LESS , RpmDependencyFlags . EQUAL , RpmDependencyFlags . RPMLIB ) ) ; 
this . options . getPayloadCoding ( ) . createProvider ( ) . fillRequirements ( this . requirements :: add ) ; 
} 
} 

public class ImplicitTagLibraryInfo { 
public TagFileInfo getTagFile ( String shortName ) { 
TagFileInfo tagFile = super . getTagFile ( shortName ) ; 
if ( tagFile == null ) { 
String path = tagFileMap . get ( shortName ) ; 
if ( path == null ) return null ; 
TagInfo tagInfo = null ; 
try { 
tagInfo = TagFileProcessor . parseTagFileDirectives ( pc , shortName , path , this ) ; 
} 
catch ( JasperException je ) { 
throw new RuntimeException ( je . toString ( ) ) ; 
} 
tagFile = new TagFileInfo ( shortName , path , tagInfo ) ; 
vec . add ( tagFile ) ; 
this . tagFiles = vec . toArray ( new TagFileInfo [ vec . size ( ) ] ) ; 
} 
return tagFile ; 
} 
} 

public class ImplicitTagLibraryInfo { 
private void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { 
InputStream is = null ; 
TreeNode tld = null ; 
try { 
URL uri = ctxt . getResource ( path ) ; 
if ( uri == null ) return ; 
is = uri . openStream ( ) ; 
tld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; 
} 
catch ( Exception ex ) { 
throw new JasperException ( ex ) ; 
} 
finally { 
if ( is != null ) try { 
is . close ( ) ; 
} 
catch ( Throwable t ) { 
} 
} 
this . jspversion = tld . findAttribute ( "version" ) ; 
Iterator list = tld . findChildren ( ) ; 
while ( list . hasNext ( ) ) { 
TreeNode element = ( TreeNode ) list . next ( ) ; 
String tname = element . getName ( ) ; 
if ( "tlibversion" . equals ( tname ) || "tlib-version" . equals ( tname ) ) this . tlibversion = element . getBody ( ) ; 
else if ( "jspversion" . equals ( tname ) || "jsp-version" . equals ( tname ) ) this . jspversion = element . getBody ( ) ; 
else if ( ! "shortname" . equals ( tname ) && ! "short-name" . equals ( tname ) ) err . jspError ( "jsp.error.implicitTld.additionalElements" , path , tname ) ; 
} 
Double jspVersionDouble = Double . valueOf ( this . jspversion ) ; 
if ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) err . jspError ( "jsp.error.implicitTld.jspVersion" , path , this . jspversion ) ; 
} 
} 

public class OutputSpooler { 
public String getChecksum ( final String fileName , final String algorithm ) { 
if ( ! this . digests . contains ( algorithm ) ) return null ; 
final String result = this . checksums . get ( fileName + ":" + algorithm ) ; 
if ( result == null ) throw new IllegalStateException ( String . format ( "Stream '%s' not closed." , fileName ) ) ; 
return result ; 
} 
} 

public class OutputSpooler { 
public long getSize ( final String fileName ) { 
final Long result = this . sizes . get ( fileName ) ; 
if ( result == null ) throw new IllegalStateException ( String . format ( "Stream '%s' not closed or was not added" , fileName ) ) ; 
return result ; 
} 
} 

public class ChannelController { 
private static void validateChannelName ( final String name , final ValidationContext ctx ) { 
if ( name == null || name . isEmpty ( ) ) return ; 
final Matcher m = ChannelService . NAME_PATTERN . matcher ( name ) ; 
if ( ! m . matches ( ) ) ctx . error ( "names" , String . format ( "The channel name '%s' must match the pattern '%s'" , name , ChannelService . NAME_PATTERN . pattern ( ) ) ) ; 
} 
} 

public class UnzipServlet { 
protected static List < MavenVersionedArtifact > getMavenArtifacts ( final String channelId , final Supplier < Collection < ArtifactInformation > > artifactsSupplier , final String groupId , final String artifactId , final boolean snapshot , final Predicate < ComparableVersion > versionFilter ) { 
final List < MavenVersionedArtifact > arts = new ArrayList < > ( ) ; 
for ( final ArtifactInformation ai : artifactsSupplier . get ( ) ) { 
if ( ! isZip ( ai ) ) continue ; 
final String mvnGroupId = ai . getMetaData ( ) . get ( MK_GROUP_ID ) ; 
final String mvnArtifactId = ai . getMetaData ( ) . get ( MK_ARTIFACT_ID ) ; 
final String classifier = ai . getMetaData ( ) . get ( MK_CLASSIFIER ) ; 
final String mvnVersion = ai . getMetaData ( ) . get ( MK_VERSION ) ; 
final String mvnSnapshotVersion = ai . getMetaData ( ) . get ( MK_SNAPSHOT_VERSION ) ; 
if ( mvnGroupId == null || mvnArtifactId == null || mvnVersion == null ) continue ; 
if ( classifier != null && ! classifier . isEmpty ( ) ) continue ; 
if ( ! mvnGroupId . equals ( groupId ) || ! mvnArtifactId . equals ( artifactId ) ) continue ; 
if ( ! snapshot && ( mvnSnapshotVersion != null || mvnVersion . endsWith ( "-SNAPSHOT" ) ) ) continue ; 
final ComparableVersion v = parseVersion ( mvnVersion ) ; 
final ComparableVersion sv = parseVersion ( mvnSnapshotVersion ) ; 
if ( v == null ) continue ; 
if ( versionFilter == null ) arts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; 
else if ( versionFilter . test ( v ) ) arts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; 
else if ( sv != null && versionFilter . test ( sv ) ) arts . add ( new MavenVersionedArtifact ( sv , channelId , ai ) ) ; 
} 
return arts ; 
} 
} 

public class LZMAEncoderNormal { 
private void updateOptStateAndReps ( ) { 
int optPrev = opts [ optCur ] . optPrev ; 
assert optPrev < optCur ; 
if ( opts [ optCur ] . prev1IsLiteral ) { 
-- optPrev ; 
if ( opts [ optCur ] . hasPrev2 ) { 
opts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; 
if ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; 
else opts [ optCur ] . state . updateMatch ( ) ; 
} 
else opts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; 
opts [ optCur ] . state . updateLiteral ( ) ; 
} 
else opts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; 
if ( optPrev == optCur - 1 ) { 
assert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; 
if ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; 
else opts [ optCur ] . state . updateLiteral ( ) ; 
System . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; 
} 
else { 
int back ; 
if ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { 
optPrev = opts [ optCur ] . optPrev2 ; 
back = opts [ optCur ] . backPrev2 ; 
opts [ optCur ] . state . updateLongRep ( ) ; 
} 
else { 
back = opts [ optCur ] . backPrev ; 
if ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; 
else opts [ optCur ] . state . updateMatch ( ) ; 
} 
if ( back < REPS ) { 
opts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; 
int rep ; 
for ( rep = 1 ; 
rep <= back ; 
++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; 
for ( ; 
rep < REPS ; 
++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; 
} 
else { 
opts [ optCur ] . reps [ 0 ] = back - REPS ; 
System . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; 
} 
} 
} 
} 

public class TldScanner { 
private TldInfo scanTld ( String resourcePath , String entryName , InputStream stream ) throws JasperException { 
try { 
TreeNode tld = new ParserUtils ( ) . parseXMLDocument ( resourcePath , stream , isValidationEnabled ) ; 
String uri = null ; 
TreeNode uriNode = tld . findChild ( "uri" ) ; 
if ( uriNode != null ) uri = uriNode . getBody ( ) ; 
ArrayList < String > listeners = new ArrayList < String > ( ) ; 
Iterator < TreeNode > listenerNodes = tld . findChildren ( "listener" ) ; 
while ( listenerNodes . hasNext ( ) ) { 
TreeNode listener = listenerNodes . next ( ) ; 
TreeNode listenerClass = listener . findChild ( "listener-class" ) ; 
if ( listenerClass != null ) { 
String listenerClassName = listenerClass . getBody ( ) ; 
if ( listenerClassName != null ) listeners . add ( listenerClassName ) ; 
} 
} 
return new TldInfo ( uri , entryName , listeners . toArray ( new String [ listeners . size ( ) ] ) ) ; 
} 
finally { 
if ( stream != null ) try { 
stream . close ( ) ; 
} 
catch ( Throwable t ) { 
} 
} 
} 
} 

public class JspRuntimeContext { 
public ClassLoader getParentClassLoader ( ) { 
ClassLoader parentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
if ( parentClassLoader == null ) parentClassLoader = this . getClass ( ) . getClassLoader ( ) ; 
return parentClassLoader ; 
} 
} 

public class JspRuntimeContext { 
public void saveBytecode ( String className , String classFileName ) { 
byte [ ] bytecode = getBytecode ( className ) ; 
if ( bytecode != null ) try { 
FileOutputStream fos = new FileOutputStream ( classFileName ) ; 
fos . write ( bytecode ) ; 
fos . close ( ) ; 
} 
catch ( IOException ex ) { 
context . log ( "Error in saving bytecode for " + className + " to " + classFileName , ex ) ; 
} 
} 
} 

public class JspRuntimeContext { 
private void checkCompile ( ) { 
for ( JspServletWrapper jsw : jsps . values ( ) ) { 
if ( jsw . isTagFile ( ) ) continue ; 
JspCompilationContext ctxt = jsw . getJspEngineContext ( ) ; 
synchronized ( jsw ) { 
try { 
ctxt . compile ( ) ; 
} 
catch ( FileNotFoundException ex ) { 
ctxt . incrementRemoved ( ) ; 
} 
catch ( Throwable t ) { 
jsw . getServletContext ( ) . log ( Localizer . getMessage ( "jsp.error.background.compile" ) , t ) ; 
} 
} 
} 
} 
} 

public class JspRuntimeContext { 
private void initClassPath ( ) { 
StringBuilder cpath = new StringBuilder ( ) ; 
String sep = System . getProperty ( "path.separator" ) ; 
cpath . append ( options . getScratchDir ( ) + sep ) ; 
String cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; 
if ( cp == null || cp . equals ( "" ) ) cp = options . getClassPath ( ) ; 
if ( cp != null ) classpath = cpath . toString ( ) + cp ; 
if ( classpath != null ) try { 
classpath = URLDecoder . decode ( classpath , "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
if ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , "Exception decoding classpath : " + classpath , e ) ; 
} 
} 
} 

public class JspRuntimeContext { 
protected void threadStart ( ) { 
if ( thread != null ) return ; 
threadDone = false ; 
thread = new Thread ( this , threadName ) ; 
thread . setDaemon ( true ) ; 
thread . start ( ) ; 
} 
} 

public class JspRuntimeContext { 
protected void threadStop ( ) { 
if ( thread == null ) return ; 
threadDone = true ; 
thread . interrupt ( ) ; 
try { 
thread . join ( ) ; 
} 
catch ( InterruptedException e ) { 
; 
} 
thread = null ; 
} 
} 

public class ChannelServiceImpl { 
private Optional < ChannelInstance > findByName ( final String name ) { 
if ( name == null ) return empty ( ) ; 
final String id = this . manager . accessCall ( KEY_STORAGE , ChannelServiceAccess . class , channels -> { 
return channels . mapToId ( name ) ; 
} 
) ; 
return findById ( id ) ; 
} 
} 

public class ChannelServiceImpl { 
private ChannelInstance findChannel ( final By by ) { 
final Optional < ChannelInstance > channel ; 
try ( Locked l = lock ( this . readLock ) ) { 
channel = find ( by ) ; 
} 
if ( ! channel . isPresent ( ) ) throw new ChannelNotFoundException ( by . toString ( ) ) ; 
return channel . get ( ) ; 
} 
} 

public class Parser { 
public static Node . Nodes parse ( ParserController pc , String path , JspReader reader , Node parent , boolean isTagFile , boolean directivesOnly , URL jarFileUrl , String pageEnc , String jspConfigPageEnc , boolean isDefaultPageEncoding , boolean hasBom ) throws JasperException { 
Parser parser = new Parser ( pc , reader , isTagFile , directivesOnly , jarFileUrl , hasBom ) ; 
Node . Root root = new Node . Root ( reader . mark ( ) , parent , false ) ; 
root . setPageEncoding ( pageEnc ) ; 
root . setJspConfigPageEncoding ( jspConfigPageEnc ) ; 
root . setIsDefaultPageEncoding ( isDefaultPageEncoding ) ; 
root . setHasBom ( hasBom ) ; 
if ( hasBom ) { 
char bomChar = ( char ) reader . nextChar ( ) ; 
if ( bomChar != 0xFEFF ) parser . err . jspError ( reader . mark ( ) , "jsp.error.invalidBom" , Integer . toHexString ( bomChar ) . toUpperCase ( ) ) ; 
} 
if ( directivesOnly ) { 
parser . parseTagFileDirectives ( root ) ; 
return new Node . Nodes ( root ) ; 
} 
PageInfo pageInfo = pc . getCompiler ( ) . getPageInfo ( ) ; 
if ( parent == null ) parser . addInclude ( root , pageInfo . getIncludePrelude ( ) ) ; 
while ( reader . hasMoreInput ( ) ) parser . parseElements ( root ) ; 
if ( parent == null ) { 
parser . addInclude ( root , pageInfo . getIncludeCoda ( ) ) ; 
parser . pageInfo . setRootPath ( path ) ; 
} 
Node . Nodes page = new Node . Nodes ( root ) ; 
return page ; 
} 
} 

public class Parser { 
private String parseQuoted ( String tx ) { 
StringBuilder buf = new StringBuilder ( ) ; 
int size = tx . length ( ) ; 
int i = 0 ; 
while ( i < size ) { 
char ch = tx . charAt ( i ) ; 
if ( ch == '&' ) if ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { 
buf . append ( '\'' ) ; 
i += 6 ; 
} 
else if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { 
buf . append ( '"' ) ; 
i += 6 ; 
} 
else { 
buf . append ( ch ) ; 
++ i ; 
} 
else if ( ch == '\\' && i + 1 < size ) { 
ch = tx . charAt ( i + 1 ) ; 
if ( ch == '\\' || ch == '\"' || ch == '\'' || ch == '>' ) { 
buf . append ( ch ) ; 
i += 2 ; 
} 
else { 
buf . append ( '\\' ) ; 
++ i ; 
} 
} 
else { 
buf . append ( ch ) ; 
++ i ; 
} 
} 
return buf . toString ( ) ; 
} 
} 

public class Parser { 
private boolean parseJspAttributeAndBody ( Node parent , String tag , String bodyType ) throws JasperException { 
boolean result = false ; 
if ( reader . matchesOptionalSpacesFollowedBy ( "<jsp:attribute" ) ) { 
parseNamedAttributes ( parent ) ; 
result = true ; 
} 
if ( reader . matchesOptionalSpacesFollowedBy ( "<jsp:body" ) ) { 
parseJspBody ( parent , bodyType ) ; 
reader . skipSpaces ( ) ; 
if ( ! reader . matchesETag ( tag ) ) err . jspError ( reader . mark ( ) , "jsp.error.unterminated" , "&lt;" + tag ) ; 
result = true ; 
} 
else if ( result && ! reader . matchesETag ( tag ) ) err . jspError ( reader . mark ( ) , "jsp.error.jspbody.required" , "&lt;" + tag ) ; 
return result ; 
} 
} 

public class MavenCoordinates { 
public MavenCoordinates toBase ( ) { 
if ( this . classifier == null && this . extension == null ) return this ; 
return new MavenCoordinates ( this . groupId , this . artifactId , this . version ) ; 
} 
} 

public class JspContextWrapper { 
private String findAlias ( String varName ) { 
if ( aliases == null ) return varName ; 
String alias = aliases . get ( varName ) ; 
if ( alias == null ) return varName ; 
return alias ; 
} 
} 

public class SystemLogHandler { 
public static String unsetThread ( ) { 
ByteArrayOutputStream baos = ( ByteArrayOutputStream ) data . get ( ) ; 
if ( baos == null ) return null ; 
streams . set ( null ) ; 
data . set ( null ) ; 
return baos . toString ( ) ; 
} 
} 

public class SystemLogHandler { 
protected PrintStream findStream ( ) { 
PrintStream ps = ( PrintStream ) streams . get ( ) ; 
if ( ps == null ) ps = wrapped ; 
return ps ; 
} 
} 

public class RepoBuilder { 
protected static void writeOptional ( final StringWriter writer , final String fieldName , final String value ) { 
if ( value != null ) write ( writer , fieldName , value ) ; 
} 
} 

public class BodyContentImpl { 
public void writeOut ( Writer out ) throws IOException { 
if ( writer == null ) out . write ( cb , 0 , nextChar ) ; 
} 
} 

public class BodyContentImpl { 
void setWriter ( Writer writer ) { 
this . writer = writer ; 
if ( writer != null ) if ( bufferSize != 0 ) { 
bufferSizeSave = bufferSize ; 
bufferSize = 0 ; 
} 
else { 
bufferSize = bufferSizeSave ; 
clearBody ( ) ; 
} 
} 
} 

public class BodyContentImpl { 
private void reAllocBuff ( int len ) { 
if ( bufferSize + len <= cb . length ) { 
bufferSize = cb . length ; 
return ; 
} 
if ( len < cb . length ) len = cb . length ; 
bufferSize = cb . length + len ; 
char [ ] tmp = new char [ bufferSize ] ; 
System . arraycopy ( cb , 0 , tmp , 0 , cb . length ) ; 
cb = tmp ; 
tmp = null ; 
} 
} 

public class StorageManager { 
private static State getSameParent ( final State parent , final MetaKey key ) { 
State current = parent ; 
while ( current != null ) { 
if ( current . key . equals ( key ) ) return current ; 
current = current . parent ; 
} 
return null ; 
} 
} 

public class StorageManager { 
public StorageRegistration registerModel ( final long lockPriority , final MetaKey key , final StorageModelProvider < ? , ? > storageProvider ) throws ModelInitializationException { 
this . modelLock . writeLock ( ) . lock ( ) ; 
try { 
testClosed ( ) ; 
if ( this . modelKeyMap . containsKey ( key ) ) throw new IllegalArgumentException ( String . format ( "A provider for '%s' is already registered" , key ) ) ; 
try { 
storageProvider . start ( this . context ) ; 
} 
catch ( final Exception e ) { 
throw new ModelInitializationException ( "Failed to start model provider: " + key , e ) ; 
} 
final long id = this . counter ++ ; 
final Entry entry = new Entry ( id , lockPriority , key , storageProvider ) ; 
this . modelIdMap . put ( id , entry ) ; 
this . modelKeyMap . put ( key , entry ) ; 
return new StorageRegistration ( ) { 
@ Override public void unregister ( ) { 
unregisterModel ( id ) ; 
} 
} 
; 
} 
finally { 
this . modelLock . writeLock ( ) . unlock ( ) ; 
} 
} 
} 

public class JobController { 
@ RequestMapping ( "/{id}/monitor" ) public ModelAndView monitor ( @ PathVariable ( "id" ) final String id ) { 
final JobHandle job = this . manager . getJob ( id ) ; 
if ( job != null ) logger . debug ( "Job: {} - {}" , job . getId ( ) , job . getState ( ) ) ; 
else logger . debug ( "No job: {}" , id ) ; 
final Map < String , Object > model = new HashMap < > ( 1 ) ; 
model . put ( "job" , job ) ; 
return new ModelAndView ( "monitor" , model ) ; 
} 
} 

public class AbstractChannelServiceServlet { 
protected boolean isAuthenticated ( final By by , final HttpServletRequest request ) { 
final String [ ] authToks = parseAuthorization ( request ) ; 
if ( authToks == null ) return false ; 
final String deployKey = authToks [ 1 ] ; 
logger . debug ( "Deploy key: '{}'" , deployKey ) ; 
final ChannelService service = getService ( request ) ; 
if ( service == null ) { 
logger . info ( "Called 'isAuthenticated' without service" ) ; 
return false ; 
} 
return service . getChannelDeployKeyStrings ( by ) . orElse ( Collections . emptySet ( ) ) . contains ( deployKey ) ; 
} 
} 

public class ChannelData { 
public static Gson makeGson ( final boolean pretty ) { 
final GsonBuilder gb = new GsonBuilder ( ) ; 
if ( pretty ) gb . setPrettyPrinting ( ) ; 
gb . registerTypeAdapter ( Node . class , new NodeAdapter ( ) ) ; 
gb . registerTypeAdapter ( byte [ ] . class , new ByteArrayAdapter ( ) ) ; 
return gb . create ( ) ; 
} 
} 

public class MetaKeys { 
public static Map < MetaKey , String > union ( final Map < MetaKey , String > providedMetaData , final Map < MetaKey , String > extractedMetaData ) { 
final int size1 = providedMetaData != null ? providedMetaData . size ( ) : 0 ; 
final int size2 = extractedMetaData != null ? extractedMetaData . size ( ) : 0 ; 
if ( size1 + size2 == 0 ) return Collections . emptyMap ( ) ; 
final Map < MetaKey , String > result = new HashMap < > ( size1 + size2 ) ; 
if ( extractedMetaData != null ) result . putAll ( extractedMetaData ) ; 
if ( providedMetaData != null ) result . putAll ( providedMetaData ) ; 
return Collections . unmodifiableMap ( result ) ; 
} 
} 

public class JspRuntimeLibrary { 
public static Throwable getThrowable ( ServletRequest request ) { 
Throwable error = ( Throwable ) request . getAttribute ( SERVLET_EXCEPTION ) ; 
if ( error == null ) { 
error = ( Throwable ) request . getAttribute ( JSP_EXCEPTION ) ; 
if ( error != null ) request . setAttribute ( SERVLET_EXCEPTION , error ) ; 
} 
return error ; 
} 
} 

public class Uploader { 
private String isCheckSum ( final Coordinates c ) { 
final String cext = c . getExtension ( ) ; 
if ( cext == null ) return null ; 
for ( final String ext : this . options . getChecksumExtensions ( ) ) { 
if ( cext . endsWith ( "." + ext ) ) return ext ; 
} 
return null ; 
} 
} 

public class PageContextImpl { 
public Exception getException ( ) { 
Throwable t = JspRuntimeLibrary . getThrowable ( request ) ; 
if ( ( t != null ) && ( ! ( t instanceof Exception ) ) ) t = new JspException ( t ) ; 
return ( Exception ) t ; 
} 
} 

public class PageContextImpl { 
public static Object evaluateExpression ( final String expression , final Class expectedType , final PageContext pageContext , final ProtectedFunctionMapper functionMap ) throws ELException { 
Object retValue ; 
if ( SecurityUtil . isPackageProtectionEnabled ( ) ) try { 
retValue = AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { 
public Object run ( ) throws Exception { 
ELContextImpl elContext = ( ELContextImpl ) pageContext . getELContext ( ) ; 
elContext . setFunctionMapper ( functionMap ) ; 
ExpressionFactory expFactory = getExpressionFactory ( pageContext ) ; 
ValueExpression expr = expFactory . createValueExpression ( elContext , expression , expectedType ) ; 
return expr . getValue ( elContext ) ; 
} 
} 
) ; 
} 
catch ( PrivilegedActionException ex ) { 
Exception realEx = ex . getException ( ) ; 
if ( realEx instanceof ELException ) throw ( ELException ) realEx ; 
else throw new ELException ( realEx ) ; 
} 
else { 
ELContextImpl elContext = ( ELContextImpl ) pageContext . getELContext ( ) ; 
elContext . setFunctionMapper ( functionMap ) ; 
ExpressionFactory expFactory = getExpressionFactory ( pageContext ) ; 
ValueExpression expr = expFactory . createValueExpression ( elContext , expression , expectedType ) ; 
retValue = expr . getValue ( elContext ) ; 
} 
return retValue ; 
} 
} 

public class SystemServiceImpl { 
protected String makePrefixFromOsgiProperties ( ) { 
final String port = System . getProperty ( "org.osgi.service.http.port" ) ; 
if ( port == null ) return null ; 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( "http://" ) . append ( discoverHostname ( ) ) ; 
if ( ! "80" . equals ( port ) ) sb . append ( ':' ) . append ( port ) ; 
return sb . toString ( ) ; 
} 
} 

public class TagFileProcessor { 
private Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { 
JspCompilationContext ctxt = compiler . getCompilationContext ( ) ; 
JspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; 
synchronized ( rctxt ) { 
JspServletWrapper wrapper = ( JspServletWrapper ) rctxt . getWrapper ( tagFilePath ) ; 
if ( wrapper == null ) { 
wrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; 
rctxt . addWrapper ( tagFilePath , wrapper ) ; 
wrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; 
wrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; 
} 
else wrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; 
Class tagClazz ; 
int tripCount = wrapper . incTripCount ( ) ; 
try { 
if ( tripCount > 0 ) { 
JspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; 
tagClazz = tempWrapper . loadTagFilePrototype ( ) ; 
tempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; 
} 
else tagClazz = wrapper . loadTagFile ( ) ; 
} 
finally { 
wrapper . decTripCount ( ) ; 
} 
try { 
Object tagIns = tagClazz . newInstance ( ) ; 
if ( tagIns instanceof JspSourceDependent ) for ( String dependant : ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) { 
parentPageInfo . addDependant ( dependant ) ; 
} 
} 
catch ( Exception e ) { 
} 
return tagClazz ; 
} 
} 
} 

public class TagFileProcessor { 
public void removeProtoTypeFiles ( String classFileName ) { 
Iterator < Compiler > iter = tempVector . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
Compiler c = iter . next ( ) ; 
if ( classFileName == null ) c . removeGeneratedClassFiles ( ) ; 
else if ( classFileName . equals ( c . getCompilationContext ( ) . getClassFileName ( ) ) ) { 
c . removeGeneratedClassFiles ( ) ; 
tempVector . remove ( c ) ; 
return ; 
} 
} 
} 
} 

public class JspC { 
public static void main ( String arg [ ] ) { 
if ( arg . length == 0 ) System . out . println ( Localizer . getMessage ( "jspc.usage" ) ) ; 
else { 
JspC jspc = new JspC ( ) ; 
try { 
jspc . setArgs ( arg ) ; 
if ( jspc . helpNeeded ) System . out . println ( Localizer . getMessage ( "jspc.usage" ) ) ; 
else jspc . execute ( ) ; 
} 
catch ( JasperException je ) { 
System . err . println ( je ) ; 
if ( jspc . getDieLevel ( ) != NO_DIE_LEVEL ) System . exit ( jspc . getDieLevel ( ) ) ; 
} 
} 
} 
} 

public class JspC { 
public void setUriroot ( String s ) { 
uriRoot = s ; 
if ( s != null ) try { 
uriRoot = new File ( s ) . getCanonicalPath ( ) ; 
} 
catch ( Exception ex ) { 
uriRoot = s ; 
} 
} 
} 

public class JspC { 
public void scanFiles ( File base ) throws JasperException { 
Stack < String > dirs = new Stack < String > ( ) ; 
dirs . push ( base . toString ( ) ) ; 
if ( extensions == null ) { 
extensions = new ArrayList < String > ( ) ; 
extensions . add ( "jsp" ) ; 
extensions . add ( "jspx" ) ; 
} 
while ( ! dirs . isEmpty ( ) ) { 
String s = dirs . pop ( ) ; 
File f = new File ( s ) ; 
if ( f . exists ( ) && f . isDirectory ( ) ) { 
String [ ] files = f . list ( ) ; 
String ext ; 
for ( int i = 0 ; 
( files != null ) && i < files . length ; 
i ++ ) { 
File f2 = new File ( s , files [ i ] ) ; 
if ( f2 . isDirectory ( ) ) dirs . push ( f2 . getPath ( ) ) ; 
else { 
String path = f2 . getPath ( ) ; 
String uri = path . substring ( uriRoot . length ( ) ) ; 
ext = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; 
if ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) pages . add ( path ) ; 
} 
} 
} 
} 
} 
} 

public class JspC { 
private void locateUriRoot ( File f ) { 
String tUriBase = uriBase ; 
if ( tUriBase == null ) tUriBase = "/" ; 
try { 
if ( f . exists ( ) ) { 
f = new File ( f . getCanonicalPath ( ) ) ; 
while ( f != null ) { 
File g = new File ( f , "WEB-INF" ) ; 
if ( g . exists ( ) && g . isDirectory ( ) ) { 
uriRoot = f . getCanonicalPath ( ) ; 
uriBase = tUriBase ; 
if ( log . isLoggable ( Level . INFO ) ) log . info ( Localizer . getMessage ( "jspc.implicit.uriRoot" , uriRoot ) ) ; 
break ; 
} 
if ( f . exists ( ) && f . isDirectory ( ) ) tUriBase = "/" + f . getName ( ) + "/" + tUriBase ; 
String fParent = f . getParent ( ) ; 
if ( fParent == null ) break ; 
else f = new File ( fParent ) ; 
} 
if ( uriRoot != null ) { 
File froot = new File ( uriRoot ) ; 
uriRoot = froot . getCanonicalPath ( ) ; 
} 
} 
} 
catch ( IOException ioe ) { 
} 
} 
} 

public class JspC { 
private ClassLoader initSystemClassLoader ( ) throws IOException { 
String sysClassPath = getSystemClassPath ( ) ; 
if ( sysClassPath == null ) return null ; 
ArrayList < URL > urls = new ArrayList < URL > ( ) ; 
StringTokenizer tokenizer = new StringTokenizer ( sysClassPath , File . pathSeparator ) ; 
while ( tokenizer . hasMoreTokens ( ) ) urls . add ( new File ( tokenizer . nextToken ( ) ) . toURL ( ) ) ; 
if ( urls . size ( ) == 0 ) return null ; 
URL urlsArray [ ] = new URL [ urls . size ( ) ] ; 
urls . toArray ( urlsArray ) ; 
return new URLClassLoader ( urlsArray , this . getClass ( ) . getClassLoader ( ) ) ; 
} 
} 

public class JspReader { 
boolean matchesOptionalSpacesFollowedBy ( String s ) throws JasperException { 
Mark mark = mark ( ) ; 
skipSpaces ( ) ; 
boolean result = matches ( s ) ; 
if ( ! result ) reset ( mark ) ; 
return result ; 
} 
} 

public class JspReader { 
Mark skipUntil ( String limit ) throws JasperException { 
Mark ret = null ; 
int limlen = limit . length ( ) ; 
int ch ; 
skip : for ( ret = mark ( ) , ch = nextChar ( ) ; 
ch != - 1 ; 
ret = mark ( ) , ch = nextChar ( ) ) if ( ch == limit . charAt ( 0 ) ) { 
Mark restart = mark ( ) ; 
for ( int i = 1 ; 
i < limlen ; 
i ++ ) if ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; 
else { 
reset ( restart ) ; 
continue skip ; 
} 
return ret ; 
} 
return null ; 
} 
} 

public class JspReader { 
Mark skipUntilIgnoreEsc ( String limit ) throws JasperException { 
Mark ret = null ; 
int limlen = limit . length ( ) ; 
int ch ; 
int prev = 'x' ; 
skip : for ( ret = mark ( ) , ch = nextChar ( ) ; 
ch != - 1 ; 
ret = mark ( ) , prev = ch , ch = nextChar ( ) ) if ( ch == '\\' && prev == '\\' ) ch = 0 ; 
else if ( ch == limit . charAt ( 0 ) && prev != '\\' ) { 
for ( int i = 1 ; 
i < limlen ; 
i ++ ) if ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; 
else continue skip ; 
return ret ; 
} 
return null ; 
} 
} 

public class JspReader { 
String parseToken ( boolean quoted ) throws JasperException { 
StringBuilder stringBuffer = new StringBuilder ( ) ; 
skipSpaces ( ) ; 
stringBuffer . setLength ( 0 ) ; 
if ( ! hasMoreInput ( ) ) return "" ; 
int ch = peekChar ( ) ; 
if ( quoted ) if ( ch == '"' || ch == '\'' ) { 
char endQuote = ch == '"' ? '"' : '\'' ; 
ch = nextChar ( ) ; 
for ( ch = nextChar ( ) ; 
ch != - 1 && ch != endQuote ; 
ch = nextChar ( ) ) { 
if ( ch == '\\' ) ch = nextChar ( ) ; 
stringBuffer . append ( ( char ) ch ) ; 
} 
if ( ch == - 1 ) err . jspError ( mark ( ) , "jsp.error.quotes.unterminated" ) ; 
} 
else err . jspError ( mark ( ) , "jsp.error.attr.quoted" ) ; 
else if ( ! isDelimiter ( ) ) do { 
ch = nextChar ( ) ; 
if ( ch == '\\' ) if ( peekChar ( ) == '"' || peekChar ( ) == '\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; 
stringBuffer . append ( ( char ) ch ) ; 
} 
while ( ! isDelimiter ( ) ) ; 
return stringBuffer . toString ( ) ; 
} 
} 

public class JspReader { 
private boolean popFile ( ) throws JasperException { 
if ( current == null || currFileId < 0 ) return false ; 
String fName = getFile ( currFileId ) ; 
currFileId = unregisterSourceFile ( fName ) ; 
if ( currFileId < - 1 ) err . jspError ( "jsp.error.file.not.registered" , fName ) ; 
Mark previous = current . popStream ( ) ; 
if ( previous != null ) { 
master = current . baseDir ; 
current = previous ; 
return true ; 
} 
return false ; 
} 
} 

public class Coordinates { 
public Coordinates makeUnclassified ( ) { 
if ( this . classifier == null ) return this ; 
return new Coordinates ( this . groupId , this . artifactId , this . version , this . qualifiedVersion , null , this . extension ) ; 
} 
} 

public class AspectInformation { 
public static List < AspectInformation > filterIds ( final List < AspectInformation > list , final Predicate < String > predicate ) { 
if ( list == null ) return null ; 
return list . stream ( ) . filter ( ( i ) -> predicate . test ( i . getFactoryId ( ) ) ) . collect ( Collectors . toList ( ) ) ; 
} 
} 

public class ParserUtils { 
public static void setSchemaResourcePrefix ( String prefix ) { 
if ( prefix != null && prefix . startsWith ( "file:" ) ) { 
schemaResourcePrefix = uencode ( prefix ) ; 
isSchemaResourcePrefixFileUrl = true ; 
} 
else { 
schemaResourcePrefix = prefix ; 
isSchemaResourcePrefixFileUrl = false ; 
} 
for ( int i = 0 ; 
i < CACHED_SCHEMA_RESOURCE_PATHS . length ; 
i ++ ) { 
String path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; 
int index = path . lastIndexOf ( '/' ) ; 
if ( index != - 1 ) CACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; 
} 
} 
} 

public class ParserUtils { 
public static void setDtdResourcePrefix ( String prefix ) { 
if ( prefix != null && prefix . startsWith ( "file:" ) ) { 
dtdResourcePrefix = uencode ( prefix ) ; 
isDtdResourcePrefixFileUrl = true ; 
} 
else { 
dtdResourcePrefix = prefix ; 
isDtdResourcePrefixFileUrl = false ; 
} 
for ( int i = 0 ; 
i < CACHED_DTD_RESOURCE_PATHS . length ; 
i ++ ) { 
String path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; 
int index = path . lastIndexOf ( '/' ) ; 
if ( index != - 1 ) CACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; 
} 
} 
} 

public class ParserUtils { 
private static String uencode ( String prefix ) { 
if ( prefix != null && prefix . startsWith ( "file:" ) ) { 
StringTokenizer tokens = new StringTokenizer ( prefix , "/\\:" , true ) ; 
StringBuilder stringBuilder = new StringBuilder ( ) ; 
while ( tokens . hasMoreElements ( ) ) { 
String token = tokens . nextToken ( ) ; 
if ( "/" . equals ( token ) || "\\" . equals ( token ) || ":" . equals ( token ) ) stringBuilder . append ( token ) ; 
else try { 
stringBuilder . append ( URLEncoder . encode ( token , "UTF-8" ) ) ; 
} 
catch ( java . io . UnsupportedEncodingException ex ) { 
} 
} 
return stringBuilder . toString ( ) ; 
} 
else return prefix ; 
} 
} 

public class ParserUtils { 
protected TreeNode convert ( TreeNode parent , Node node ) { 
TreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; 
NamedNodeMap attributes = node . getAttributes ( ) ; 
if ( attributes != null ) { 
int n = attributes . getLength ( ) ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) { 
Node attribute = attributes . item ( i ) ; 
treeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; 
} 
} 
NodeList children = node . getChildNodes ( ) ; 
if ( children != null ) { 
int n = children . getLength ( ) ; 
for ( int i = 0 ; 
i < n ; 
i ++ ) { 
Node child = children . item ( i ) ; 
if ( child instanceof Comment ) continue ; 
if ( child instanceof Text ) { 
String body = ( ( Text ) child ) . getData ( ) ; 
if ( body != null ) { 
body = body . trim ( ) ; 
if ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; 
} 
} 
else TreeNode treeChild = convert ( treeNode , child ) ; 
} 
} 
return ( treeNode ) ; 
} 
} 

public class BindingManager { 
private static void mergeErrors ( final BindingResult bindingResult , final BindingResult result ) { 
if ( bindingResult == null ) return ; 
result . addErrors ( bindingResult . getLocalErrors ( ) ) ; 
for ( final Map . Entry < String , BindingResult > child : bindingResult . getChildren ( ) . entrySet ( ) ) { 
mergeErrors ( child . getValue ( ) , result . getChildOrAdd ( child . getKey ( ) ) ) ; 
} 
} 
} 

public class BindingManager { 
private void initializeBinder ( final Binder binder ) { 
for ( final Method m : binder . getClass ( ) . getMethods ( ) ) { 
if ( ! m . isAnnotationPresent ( Binder . Initializer . class ) ) continue ; 
final Call call = bind ( m , binder ) ; 
try { 
call . invoke ( ) ; 
} 
catch ( final Exception e ) { 
throw new RuntimeException ( String . format ( "Failed to initialze binder: %s # %s" , binder , m ) , e ) ; 
} 
} 
} 
} 

public class ChannelAspectProcessor { 
public static Map < String , ChannelAspectInformation > scanAspectInformations ( final BundleContext context ) { 
Collection < ServiceReference < ChannelAspectFactory > > refs ; 
try { 
refs = context . getServiceReferences ( ChannelAspectFactory . class , null ) ; 
} 
catch ( final InvalidSyntaxException e ) { 
return Collections . emptyMap ( ) ; 
} 
if ( refs == null ) return Collections . emptyMap ( ) ; 
final Map < String , ChannelAspectInformation > result = new HashMap < > ( refs . size ( ) ) ; 
for ( final ServiceReference < ChannelAspectFactory > ref : refs ) { 
final ChannelAspectInformation info = makeInformation ( ref ) ; 
result . put ( info . getFactoryId ( ) , info ) ; 
} 
return result ; 
} 
} 

public class TagPluginManager { 
private void invokePlugin ( Node . CustomTag n ) { 
TagPlugin tagPlugin = tagPlugins . get ( n . getTagHandlerClass ( ) . getName ( ) ) ; 
if ( tagPlugin == null ) return ; 
TagPluginContext tagPluginContext = new TagPluginContextImpl ( n , pageInfo ) ; 
n . setTagPluginContext ( tagPluginContext ) ; 
tagPlugin . doTag ( tagPluginContext ) ; 
} 
} 

public class AetherImporter { 
public static AetherResult asResult ( final Collection < ArtifactResult > results , final ImportConfiguration cfg , final Optional < DependencyResult > dependencyResult ) { 
final AetherResult result = new AetherResult ( ) ; 
final Set < String > requested = new HashSet < > ( cfg . getCoordinates ( ) . size ( ) ) ; 
for ( final MavenCoordinates mc : cfg . getCoordinates ( ) ) { 
requested . add ( mc . toString ( ) ) ; 
} 
final Map < String , Boolean > optionalDeps = new HashMap < > ( ) ; 
fillOptionalDependenciesMap ( dependencyResult , optionalDeps ) ; 
for ( final ArtifactResult ar : results ) { 
final AetherResult . Entry entry = new AetherResult . Entry ( ) ; 
final MavenCoordinates coordinates = MavenCoordinates . fromResult ( ar ) ; 
final String key = coordinates . toBase ( ) . toString ( ) ; 
entry . setCoordinates ( coordinates ) ; 
entry . setResolved ( ar . isResolved ( ) ) ; 
entry . setRequested ( requested . contains ( key ) ) ; 
entry . setOptional ( optionalDeps . getOrDefault ( key , Boolean . FALSE ) ) ; 
if ( ar . getExceptions ( ) != null && ! ar . getExceptions ( ) . isEmpty ( ) ) { 
final StringBuilder sb = new StringBuilder ( ar . getExceptions ( ) . get ( 0 ) . getMessage ( ) ) ; 
if ( ar . getExceptions ( ) . size ( ) > 1 ) sb . append ( " ..." ) ; 
entry . setError ( sb . toString ( ) ) ; 
} 
result . getArtifacts ( ) . add ( entry ) ; 
} 
Collections . sort ( result . getArtifacts ( ) , Comparator . comparing ( AetherResult . Entry :: getCoordinates ) ) ; 
result . setRepositoryUrl ( cfg . getRepositoryUrl ( ) ) ; 
return result ; 
} 
} 

public class TagLibraryInfoImpl { 
private InputStream getResourceAsStream ( String uri ) throws JasperException { 
try { 
String real = ctxt . getRealPath ( uri ) ; 
if ( real == null ) return ctxt . getResourceAsStream ( uri ) ; 
else return new FileInputStream ( real ) ; 
} 
catch ( FileNotFoundException ex ) { 
return ctxt . getResourceAsStream ( uri ) ; 
} 
} 
} 

public class TagLibraryInfoImpl { 
public ValidationMessage [ ] validate ( PageData thePage ) { 
TagLibraryValidator tlv = getTagLibraryValidator ( ) ; 
if ( tlv == null ) return null ; 
String uri = getURI ( ) ; 
if ( uri . startsWith ( "/" ) ) uri = URN_JSPTLD + uri ; 
ValidationMessage [ ] messages = tlv . validate ( getPrefixString ( ) , uri , thePage ) ; 
tlv . release ( ) ; 
return messages ; 
} 
} 

public class XMLEncodingDetector { 
private void scanXMLDecl ( ) throws IOException , JasperException { 
if ( skipString ( "<?xml" ) ) { 
fMarkupDepth ++ ; 
if ( XMLChar . isName ( peekChar ( ) ) ) { 
fStringBuffer . clear ( ) ; 
fStringBuffer . append ( "xml" ) ; 
while ( XMLChar . isName ( peekChar ( ) ) ) fStringBuffer . append ( ( char ) scanChar ( ) ) ; 
String target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; 
scanPIData ( target , fString ) ; 
} 
else scanXMLDeclOrTextDecl ( false ) ; 
} 
} 
} 

public class JspCServletContext { 
public URL getResource ( String path ) throws MalformedURLException { 
if ( ! path . startsWith ( "/" ) ) throw new MalformedURLException ( "Path '" + path + "' does not start with '/'" ) ; 
URL url = new URL ( myResourceBaseURL , path . substring ( 1 ) ) ; 
InputStream is = null ; 
try { 
is = url . openStream ( ) ; 
} 
catch ( Throwable t ) { 
url = null ; 
} 
finally { 
if ( is != null ) try { 
is . close ( ) ; 
} 
catch ( Throwable t2 ) { 
} 
} 
return url ; 
} 
} 

public class LZEncoder { 
int movePos ( int requiredForFlushing , int requiredForFinishing ) { 
assert requiredForFlushing >= requiredForFinishing ; 
++ readPos ; 
int avail = writePos - readPos ; 
if ( avail < requiredForFlushing ) if ( avail < requiredForFinishing || ! finishing ) { 
++ pendingSize ; 
avail = 0 ; 
} 
return avail ; 
} 
} 

public class JspWriterImpl { 
public void flush ( ) throws IOException { 
flushBuffer ( ) ; 
if ( out != null ) out . flush ( ) ; 
else { 
response . setCharacterEncoding ( response . getCharacterEncoding ( ) ) ; 
response . flushBuffer ( ) ; 
} 
} 
} 

public class JspWriterImpl { 
private void allocateCharBuffer ( ) { 
if ( bufferSize == 0 ) return ; 
if ( bufferSize > MAX_BUFFER_SIZE ) buf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; 
else buf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; 
} 
} 

public class Aggregator { 
public List < String > makeKey ( final Map < MetaKey , String > metaData , final boolean requireAll ) { 
final List < String > result = new ArrayList < > ( this . fields . size ( ) ) ; 
for ( final MetaKey field : this . fields ) { 
final String value = metaData . get ( field ) ; 
if ( requireAll && value == null ) return null ; 
result . add ( value ) ; 
} 
return result ; 
} 
} 

public class Compiler { 
private void generateClass ( ) throws FileNotFoundException , JasperException , Exception { 
long t1 = 0 ; 
if ( log . isLoggable ( Level . FINE ) ) t1 = System . currentTimeMillis ( ) ; 
String javaFileName = ctxt . getServletJavaFileName ( ) ; 
setJavaCompilerOptions ( ) ; 
JavacErrorDetail [ ] javacErrors = javaCompiler . compile ( ctxt . getFullClassName ( ) , pageNodes ) ; 
if ( javacErrors != null ) { 
javaCompiler . doJavaFile ( true ) ; 
log . severe ( "Error compiling file: " + javaFileName ) ; 
errDispatcher . javacError ( javacErrors ) ; 
} 
if ( log . isLoggable ( Level . FINE ) ) { 
long t2 = System . currentTimeMillis ( ) ; 
log . fine ( "Compiled " + javaFileName + " " + ( t2 - t1 ) + "ms" ) ; 
} 
javaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; 
if ( ! ctxt . isPrototypeMode ( ) && ! options . isSmapSuppressed ( ) ) smapUtil . installSmap ( ) ; 
if ( jsw != null && jsw . getServletClassLastModifiedTime ( ) <= 0 ) jsw . setServletClassLastModifiedTime ( javaCompiler . getClassLastModified ( ) ) ; 
if ( options . getSaveBytecode ( ) ) javaCompiler . saveClassFile ( ctxt . getFullClassName ( ) , ctxt . getClassFileName ( ) ) ; 
ctxt . getRuntimeContext ( ) . adjustBytecodeTime ( ctxt . getFullClassName ( ) , jspModTime ) ; 
} 
} 

public class Compiler { 
public void compile ( boolean compileClass ) throws FileNotFoundException , JasperException , Exception { 
try { 
ctxt . makeOutputDir ( ctxt . getOutputDir ( ) ) ; 
if ( errDispatcher == null ) errDispatcher = new ErrorDispatcher ( jspcMode ) ; 
generateJava ( ) ; 
if ( compileClass ) generateClass ( ) ; 
else javaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; 
} 
finally { 
if ( tfp != null ) tfp . removeProtoTypeFiles ( null ) ; 
javaCompiler . release ( ) ; 
tfp = null ; 
errDispatcher = null ; 
if ( ! jspcMode ) pageInfo = null ; 
pageNodes = null ; 
if ( ctxt . getWriter ( ) != null ) { 
ctxt . getWriter ( ) . close ( ) ; 
ctxt . setWriter ( null ) ; 
} 
} 
} 
} 

public class Compiler { 
private void initJavaCompiler ( ) throws JasperException { 
boolean disablejsr199 = Boolean . TRUE . toString ( ) . equals ( System . getProperty ( "org.apache.jasper.compiler.disablejsr199" ) ) ; 
Double version = Double . valueOf ( System . getProperty ( "java.specification.version" ) ) ; 
if ( ! disablejsr199 && ( version >= 1.6 || getClassFor ( "javax.tools.Tool" ) != null ) ) javaCompiler = new Jsr199JavaCompiler ( ) ; 
else { 
Class c = getClassFor ( "org.eclipse.jdt.internal.compiler.Compiler" ) ; 
if ( c != null ) { 
c = getClassFor ( "org.apache.jasper.compiler.JDTJavaCompiler" ) ; 
if ( c != null ) try { 
javaCompiler = ( JavaCompiler ) c . newInstance ( ) ; 
} 
catch ( Exception ex ) { 
} 
} 
} 
if ( javaCompiler == null ) { 
Class c = getClassFor ( "org.apache.tools.ant.taskdefs.Javac" ) ; 
if ( c != null ) { 
c = getClassFor ( "org.apache.jasper.compiler.AntJavaCompiler" ) ; 
if ( c != null ) try { 
javaCompiler = ( JavaCompiler ) c . newInstance ( ) ; 
} 
catch ( Exception ex ) { 
} 
} 
} 
if ( javaCompiler == null ) errDispatcher . jspError ( "jsp.error.nojavac" ) ; 
javaCompiler . init ( ctxt , errDispatcher , jspcMode ) ; 
} 
} 

public class Compiler { 
private boolean systemJarInWebinf ( String path ) { 
if ( path . indexOf ( "/WEB-INF/" ) < 0 ) return false ; 
Boolean useMyFaces = ( Boolean ) ctxt . getServletContext ( ) . getAttribute ( "com.sun.faces.useMyFaces" ) ; 
if ( useMyFaces == null || ! useMyFaces ) for ( String jar : systemJsfJars ) { 
if ( path . indexOf ( jar ) > 0 ) return true ; 
} 
for ( String jar : systemJars ) { 
if ( path . indexOf ( jar ) > 0 ) return true ; 
} 
return false ; 
} 
} 

public class Generator { 
private void generateDeclarations ( Node . Nodes page ) throws JasperException { 
class DeclarationVisitor extends Node . Visitor { 
private boolean getServletInfoGenerated = false ; 
public void visit ( Node . PageDirective n ) throws JasperException { 
if ( getServletInfoGenerated ) return ; 
String info = n . getAttributeValue ( "info" ) ; 
if ( info == null ) return ; 
getServletInfoGenerated = true ; 
out . printil ( "public String getServletInfo() {" ) ; 
out . pushIndent ( ) ; 
out . printin ( "return " ) ; 
out . print ( quote ( info ) ) ; 
out . println ( ";" ) ; 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
out . println ( ) ; 
} 
public void visit ( Node . Declaration n ) throws JasperException { 
n . setBeginJavaLine ( out . getJavaLine ( ) ) ; 
out . printMultiLn ( n . getText ( ) ) ; 
out . println ( ) ; 
n . setEndJavaLine ( out . getJavaLine ( ) ) ; 
} 
public void visit ( Node . CustomTag n ) throws JasperException { 
if ( n . useTagPlugin ( ) ) { 
if ( n . getAtSTag ( ) != null ) n . getAtSTag ( ) . visit ( this ) ; 
visitBody ( n ) ; 
if ( n . getAtETag ( ) != null ) n . getAtETag ( ) . visit ( this ) ; 
} 
else visitBody ( n ) ; 
} 
} 
out . println ( ) ; 
page . visit ( new DeclarationVisitor ( ) ) ; 
} 
} 

public class Generator { 
private void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { 
class TagHandlerPoolVisitor extends Node . Visitor { 
private Set < String > names = new HashSet < String > ( ) ; 
TagHandlerPoolVisitor ( Set < String > v ) { 
names = v ; 
} 
public void visit ( Node . CustomTag n ) throws JasperException { 
if ( ! n . implementsSimpleTag ( ) ) { 
String name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; 
n . setTagHandlerPoolName ( name ) ; 
if ( ! names . contains ( name ) ) names . add ( name ) ; 
} 
visitBody ( n ) ; 
} 
private String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { 
String poolName = null ; 
poolName = "_jspx_tagPool_" + prefix + "_" + shortName ; 
if ( attrs != null ) { 
String [ ] attrNames = new String [ attrs . getLength ( ) ] ; 
for ( int i = 0 ; 
i < attrNames . length ; 
i ++ ) attrNames [ i ] = attrs . getQName ( i ) ; 
Arrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; 
for ( int i = 0 ; 
i < attrNames . length ; 
i ++ ) poolName = poolName + "_" + attrNames [ i ] ; 
} 
if ( hasEmptyBody ) poolName = poolName + "_nobody" ; 
return JspUtil . makeXmlJavaIdentifier ( poolName ) ; 
} 
} 
page . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; 
} 
} 

public class Generator { 
private void generateXmlProlog ( Node . Nodes page ) { 
String omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; 
if ( ( omitXmlDecl != null && ! JspUtil . booleanValue ( omitXmlDecl ) ) || ( omitXmlDecl == null && page . getRoot ( ) . isXmlSyntax ( ) && ! pageInfo . hasJspRoot ( ) && ! ctxt . isTagFile ( ) ) ) { 
String cType = pageInfo . getContentType ( ) ; 
String charSet = cType . substring ( cType . indexOf ( "charset=" ) + 8 ) ; 
out . printil ( "out.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"" + charSet + "\\\"?>\\n\");" ) ; 
} 
String doctypeName = pageInfo . getDoctypeName ( ) ; 
if ( doctypeName != null ) { 
String doctypePublic = pageInfo . getDoctypePublic ( ) ; 
String doctypeSystem = pageInfo . getDoctypeSystem ( ) ; 
out . printin ( "out.write(\"<!DOCTYPE " ) ; 
out . print ( doctypeName ) ; 
if ( doctypePublic == null ) out . print ( " SYSTEM \\\"" ) ; 
else { 
out . print ( " PUBLIC \\\"" ) ; 
out . print ( doctypePublic ) ; 
out . print ( "\\\" \\\"" ) ; 
} 
out . print ( doctypeSystem ) ; 
out . println ( "\\\">\\n\");" ) ; 
} 
} 
} 

public class Generator { 
private void genCommonPostamble ( ) { 
for ( int i = 0 ; 
i < methodsBuffered . size ( ) ; 
i ++ ) { 
GenBuffer methodBuffer = methodsBuffered . get ( i ) ; 
methodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; 
out . printMultiLn ( methodBuffer . toString ( ) ) ; 
} 
if ( fragmentHelperClass . isUsed ( ) ) { 
fragmentHelperClass . generatePostamble ( ) ; 
fragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; 
out . printMultiLn ( fragmentHelperClass . toString ( ) ) ; 
} 
if ( arrayBuffer != null ) out . printMultiLn ( arrayBuffer . toString ( ) ) ; 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
} 
} 

public class Generator { 
public static void generate ( ServletWriter out , Compiler compiler , Node . Nodes page ) throws JasperException { 
Generator gen = new Generator ( out , compiler ) ; 
if ( gen . isPoolingEnabled ) gen . compileTagHandlerPoolList ( page ) ; 
if ( gen . ctxt . isTagFile ( ) ) { 
JasperTagInfo tagInfo = ( JasperTagInfo ) gen . ctxt . getTagInfo ( ) ; 
gen . generateTagHandlerPreamble ( tagInfo , page ) ; 
if ( gen . ctxt . isPrototypeMode ( ) ) return ; 
gen . generateXmlProlog ( page ) ; 
gen . fragmentHelperClass . generatePreamble ( ) ; 
page . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; 
gen . generateTagHandlerPostamble ( tagInfo ) ; 
} 
else { 
gen . generatePreamble ( page ) ; 
gen . generateXmlProlog ( page ) ; 
gen . fragmentHelperClass . generatePreamble ( ) ; 
page . visit ( gen . new GenerateVisitor ( gen . ctxt . isTagFile ( ) , out , gen . methodsBuffered , gen . fragmentHelperClass ) ) ; 
gen . generatePostamble ( page ) ; 
} 
} 
} 

public class Generator { 
private void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { 
if ( tagInfo . hasDynamicAttributes ( ) ) out . printil ( "private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();" ) ; 
TagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; 
for ( int i = 0 ; 
i < attrInfos . length ; 
i ++ ) { 
out . printin ( "private " ) ; 
if ( attrInfos [ i ] . isFragment ( ) ) out . print ( "javax.servlet.jsp.tagext.JspFragment " ) ; 
else { 
out . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; 
out . print ( " " ) ; 
} 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ";" ) ; 
} 
out . println ( ) ; 
for ( int i = 0 ; 
i < attrInfos . length ; 
i ++ ) { 
out . printin ( "public " ) ; 
if ( attrInfos [ i ] . isFragment ( ) ) out . print ( "javax.servlet.jsp.tagext.JspFragment " ) ; 
else { 
out . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; 
out . print ( " " ) ; 
} 
out . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; 
out . println ( " {" ) ; 
out . pushIndent ( ) ; 
out . printin ( "return this." ) ; 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ";" ) ; 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
out . println ( ) ; 
out . printin ( "public void " ) ; 
out . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; 
if ( attrInfos [ i ] . isFragment ( ) ) out . print ( "(javax.servlet.jsp.tagext.JspFragment " ) ; 
else { 
out . print ( "(" ) ; 
out . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; 
out . print ( " " ) ; 
} 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ") {" ) ; 
out . pushIndent ( ) ; 
out . printin ( "this." ) ; 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . print ( " = " ) ; 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ";" ) ; 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
out . println ( ) ; 
} 
} 
} 

public class TransferServiceImpl { 
private Map < MetaKey , String > readProperties ( final InputStream stream ) throws IOException { 
try { 
final Document doc = this . xmlToolsFactory . newDocumentBuilder ( ) . parse ( new FilterInputStream ( stream ) { 
@ Override public void close ( ) { 
} 
} 
) ; 
final Element root = doc . getDocumentElement ( ) ; 
if ( ! "properties" . equals ( root . getNodeName ( ) ) ) throw new IllegalStateException ( String . format ( "Root element must be of type '%s'" , "properties" ) ) ; 
final Map < MetaKey , String > result = new HashMap < > ( ) ; 
for ( final Element ele : XmlHelper . iterElement ( root , "property" ) ) { 
final String namespace = ele . getAttribute ( "namespace" ) ; 
final String key = ele . getAttribute ( "key" ) ; 
final String value = ele . getTextContent ( ) ; 
if ( namespace . isEmpty ( ) || key . isEmpty ( ) ) continue ; 
result . put ( new MetaKey ( namespace , key ) , value ) ; 
} 
return result ; 
} 
catch ( final Exception e ) { 
throw new IOException ( "Failed to read properties" , e ) ; 
} 
} 
} 

public class Validator { 
private static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { 
StringBuilder errMsg = null ; 
ErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; 
for ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; 
iter . hasNext ( ) ; 
) { 
TagLibraryInfo o = iter . next ( ) ; 
if ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; 
TagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; 
ValidationMessage [ ] errors = tli . validate ( xmlView ) ; 
if ( ( errors != null ) && ( errors . length != 0 ) ) { 
if ( errMsg == null ) errMsg = new StringBuilder ( ) ; 
errMsg . append ( "<h3>" ) ; 
errMsg . append ( Localizer . getMessage ( "jsp.error.tlv.invalid.page" , tli . getShortName ( ) ) ) ; 
errMsg . append ( "</h3>" ) ; 
for ( int i = 0 ; 
i < errors . length ; 
i ++ ) if ( errors [ i ] != null ) { 
errMsg . append ( "<p>" ) ; 
errMsg . append ( errors [ i ] . getId ( ) ) ; 
errMsg . append ( ": " ) ; 
errMsg . append ( errors [ i ] . getMessage ( ) ) ; 
errMsg . append ( "</p>" ) ; 
} 
} 
} 
if ( errMsg != null ) errDisp . jspError ( errMsg . toString ( ) ) ; 
} 
} 

public class TagHandlerPool { 
public < T extends JspTag > JspTag get ( Class < T > handlerClass ) throws JspException { 
synchronized ( this ) { 
if ( current >= 0 ) return handlers [ current -- ] ; 
} 
JspTag tagHandler = null ; 
try { 
if ( resourceInjector != null ) tagHandler = resourceInjector . createTagHandlerInstance ( handlerClass ) ; 
else tagHandler = handlerClass . newInstance ( ) ; 
} 
catch ( Exception e ) { 
throw new JspException ( e . getMessage ( ) , e ) ; 
} 
return tagHandler ; 
} 
} 

public class ELParser { 
public static ELNode . Nodes parse ( String expression ) { 
ELParser parser = new ELParser ( expression ) ; 
while ( parser . hasNextChar ( ) ) { 
String text = parser . skipUntilEL ( ) ; 
if ( text . length ( ) > 0 ) parser . expr . add ( new ELNode . Text ( text ) ) ; 
ELNode . Nodes elexpr = parser . parseEL ( ) ; 
if ( ! elexpr . isEmpty ( ) ) parser . expr . add ( new ELNode . Root ( elexpr , parser . isDollarExpr ) ) ; 
} 
return parser . expr ; 
} 
} 

public class JspConfig { 
private JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { 
if ( prev == null ) return curr ; 
if ( prev . getExtension ( ) == null ) return prev ; 
if ( curr . getExtension ( ) == null ) return curr ; 
String prevPath = prev . getPath ( ) ; 
String currPath = curr . getPath ( ) ; 
if ( prevPath == null && currPath == null ) return prev ; 
if ( prevPath == null && currPath != null ) return curr ; 
if ( prevPath != null && currPath == null ) return prev ; 
if ( prevPath . length ( ) >= currPath . length ( ) ) return prev ; 
return curr ; 
} 
} 

public class JspConfig { 
public boolean isJspPage ( String uri ) throws JasperException { 
init ( ) ; 
if ( jspProperties == null ) return false ; 
String uriPath = null ; 
int index = uri . lastIndexOf ( '/' ) ; 
if ( index >= 0 ) uriPath = uri . substring ( 0 , index + 1 ) ; 
String uriExtension = null ; 
index = uri . lastIndexOf ( '.' ) ; 
if ( index >= 0 ) uriExtension = uri . substring ( index + 1 ) ; 
for ( JspPropertyGroup jpg : jspProperties ) { 
JspProperty jp = jpg . getJspProperty ( ) ; 
String extension = jpg . getExtension ( ) ; 
String path = jpg . getPath ( ) ; 
if ( extension == null ) if ( uri . equals ( path ) ) return true ; 
else if ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( "*" ) || extension . equals ( uriExtension ) ) ) return true ; 
} 
return false ; 
} 
} 

public class JspUtil { 
public static String getExprInXml ( String expression ) { 
String returnString ; 
int length = expression . length ( ) ; 
if ( expression . startsWith ( OPEN_EXPR ) && expression . endsWith ( CLOSE_EXPR ) ) returnString = expression . substring ( 1 , length - 1 ) ; 
else returnString = expression ; 
return escapeXml ( returnString ) ; 
} 
} 

public class JspUtil { 
public static void checkScope ( String scope , Node n , ErrorDispatcher err ) throws JasperException { 
if ( scope != null && ! scope . equals ( "page" ) && ! scope . equals ( "request" ) && ! scope . equals ( "session" ) && ! scope . equals ( "application" ) ) err . jspError ( n , "jsp.error.invalid.scope" , scope ) ; 
} 
} 

public class JspUtil { 
public static String escapeXml ( String s ) { 
if ( s == null ) return null ; 
StringBuilder sb = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( c == '<' ) sb . append ( "&lt;" ) ; 
else if ( c == '>' ) sb . append ( "&gt;" ) ; 
else if ( c == '\'' ) sb . append ( "&apos;" ) ; 
else if ( c == '&' ) sb . append ( "&amp;" ) ; 
else if ( c == '"' ) sb . append ( "&quot;" ) ; 
else sb . append ( c ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class JspUtil { 
public static String getTagHandlerClassName ( String path , ErrorDispatcher err ) throws JasperException { 
String className = null ; 
int begin = 0 ; 
int index ; 
index = path . lastIndexOf ( ".tag" ) ; 
if ( index == - 1 ) err . jspError ( "jsp.error.tagfile.badSuffix" , path ) ; 
index = path . indexOf ( WEB_INF_TAGS ) ; 
if ( index != - 1 ) { 
className = "org.apache.jsp.tag.web." ; 
begin = index + WEB_INF_TAGS . length ( ) ; 
} 
else { 
index = path . indexOf ( META_INF_TAGS ) ; 
if ( index != - 1 ) { 
className = "org.apache.jsp.tag.meta." ; 
begin = index + META_INF_TAGS . length ( ) ; 
} 
else err . jspError ( "jsp.error.tagfile.illegalPath" , path ) ; 
} 
className += makeJavaPackage ( path . substring ( begin ) ) ; 
return className ; 
} 
} 

public class JspUtil { 
public static final String makeJavaPackage ( String path ) { 
String classNameComponents [ ] = split ( path , "/" ) ; 
StringBuilder legalClassNames = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < classNameComponents . length ; 
i ++ ) { 
legalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; 
if ( i < classNameComponents . length - 1 ) legalClassNames . append ( '.' ) ; 
} 
return legalClassNames . toString ( ) ; 
} 
} 

public class JspUtil { 
private static final String [ ] split ( String path , String pat ) { 
ArrayList < String > comps = new ArrayList < String > ( ) ; 
int pos = path . indexOf ( pat ) ; 
int start = 0 ; 
while ( pos >= 0 ) { 
if ( pos > start ) { 
String comp = path . substring ( start , pos ) ; 
comps . add ( comp ) ; 
} 
start = pos + pat . length ( ) ; 
pos = path . indexOf ( pat , start ) ; 
} 
if ( start < path . length ( ) ) comps . add ( path . substring ( start ) ) ; 
String [ ] result = new String [ comps . size ( ) ] ; 
for ( int i = 0 ; 
i < comps . size ( ) ; 
i ++ ) result [ i ] = comps . get ( i ) ; 
return result ; 
} 
} 

public class JspUtil { 
public static final String makeJavaIdentifier ( String identifier ) { 
StringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; 
if ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) modifiedIdentifier . append ( '_' ) ; 
for ( int i = 0 ; 
i < identifier . length ( ) ; 
i ++ ) { 
char ch = identifier . charAt ( i ) ; 
if ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) modifiedIdentifier . append ( ch ) ; 
else if ( ch == '.' ) modifiedIdentifier . append ( '_' ) ; 
else modifiedIdentifier . append ( mangleChar ( ch ) ) ; 
} 
if ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) modifiedIdentifier . append ( '_' ) ; 
return modifiedIdentifier . toString ( ) ; 
} 
} 

public class JspUtil { 
public static boolean isJavaKeyword ( String key ) { 
int i = 0 ; 
int j = javaKeywords . length ; 
while ( i < j ) { 
int k = ( i + j ) / 2 ; 
int result = javaKeywords [ k ] . compareTo ( key ) ; 
if ( result == 0 ) return true ; 
if ( result < 0 ) i = k + 1 ; 
else j = k ; 
} 
return false ; 
} 
} 

public class InstallableUnit { 
private static void addProperty ( final Map < String , String > props , final String key , final String value ) { 
if ( value == null ) return ; 
props . put ( key , value ) ; 
} 
} 

public class Functions { 
public static String modifier ( final String prefix , final Modifier modifier ) { 
if ( modifier == null ) return "" ; 
String value = null ; 
switch ( modifier ) { 
case DEFAULT : value = "default" ; 
break ; 
case PRIMARY : value = "primary" ; 
break ; 
case SUCCESS : value = "success" ; 
break ; 
case INFO : value = "info" ; 
break ; 
case WARNING : value = "warning" ; 
break ; 
case DANGER : value = "danger" ; 
break ; 
case LINK : value = "link" ; 
break ; 
} 
if ( value != null && prefix != null ) return prefix + value ; 
else return value != null ? value : "" ; 
} 
} 

public class Functions { 
public static SortedSet < String > metadata ( final Map < MetaKey , String > metadata , String namespace , String key ) { 
final SortedSet < String > result = new TreeSet < > ( ) ; 
if ( namespace . isEmpty ( ) ) namespace = null ; 
if ( key . isEmpty ( ) ) key = null ; 
for ( final Map . Entry < MetaKey , String > entry : metadata . entrySet ( ) ) { 
if ( namespace != null && ! namespace . equals ( entry . getKey ( ) . getNamespace ( ) ) ) continue ; 
if ( key != null && ! key . equals ( entry . getKey ( ) . getKey ( ) ) ) continue ; 
result . add ( entry . getValue ( ) ) ; 
} 
return result ; 
} 
} 

public class DatabaseUserService { 
@ Override public void run ( ) throws Exception { 
this . storageManager . modifyRun ( MODEL_KEY , UserWriteModel . class , users -> { 
final Date timeout = new Date ( System . currentTimeMillis ( ) - getTimeout ( ) ) ; 
final Collection < UserEntity > updates = new LinkedList < > ( ) ; 
final Collection < String > removals = new LinkedList < > ( ) ; 
for ( final UserEntity user : users . asCollection ( ) ) { 
if ( user . getEmailTokenDate ( ) == null || user . getEmailTokenDate ( ) . after ( timeout ) ) continue ; 
if ( user . isEmailVerified ( ) ) { 
user . setEmailToken ( null ) ; 
user . setEmailTokenDate ( null ) ; 
user . setEmailTokenSalt ( null ) ; 
updates . add ( user ) ; 
} 
else removals . add ( user . getId ( ) ) ; 
} 
updates . forEach ( users :: putUser ) ; 
removals . forEach ( users :: removeUser ) ; 
} 
) ; 
} 
} 

public class FileNames { 
public static String getBasename ( final String name ) { 
if ( name == null ) return null ; 
final String [ ] toks = name . split ( "/" ) ; 
if ( toks . length < 1 ) return name ; 
return toks [ toks . length - 1 ] ; 
} 
} 

public class MetadataCache { 
public boolean put ( Locator locator , String key , String value ) throws CacheException { 
if ( value == null ) return false ; 
Timer . Context cachePutTimerContext = MetadataCache . cachePutTimer . time ( ) ; 
boolean dbWrite = false ; 
try { 
CacheKey cacheKey = new CacheKey ( locator , key ) ; 
String oldValue = cache . getIfPresent ( cacheKey ) ; 
cache . put ( cacheKey , value ) ; 
if ( oldValue == null || ! oldValue . equals ( value ) ) dbWrite = true ; 
if ( dbWrite ) { 
updatedMetricMeter . mark ( ) ; 
if ( ! batchedWrites ) databasePut ( locator , key , value ) ; 
else databaseLazyWrite ( locator , key ) ; 
} 
return dbWrite ; 
} 
finally { 
cachePutTimerContext . stop ( ) ; 
} 
} 
} 

public class PreaggregateConversions { 
public static Number resolveNumber ( Number n ) { 
if ( n instanceof LazilyParsedNumber ) try { 
return n . longValue ( ) ; 
} 
catch ( NumberFormatException ex ) { 
return n . doubleValue ( ) ; 
} 
else return n ; 
} 
} 

public class ScheduleContext { 
void scheduleEligibleSlots ( long maxAgeMillis , long rollupDelayForMetricsWithShortDelay , long rollupWaitForMetricsWithLongDelay ) { 
long now = scheduleTime ; 
ArrayList < Integer > shardKeys = new ArrayList < Integer > ( shardStateManager . getManagedShards ( ) ) ; 
Collections . shuffle ( shardKeys ) ; 
for ( int shard : shardKeys ) { 
for ( Granularity g : Granularity . rollupGranularities ( ) ) { 
synchronized ( scheduledSlots ) { 
synchronized ( runningSlots ) { 
List < Integer > slotsToWorkOn = shardStateManager . getSlotStateManager ( shard , g ) . getSlotsEligibleForRollup ( now , maxAgeMillis , rollupDelayForMetricsWithShortDelay , rollupWaitForMetricsWithLongDelay ) ; 
if ( slotsToWorkOn . size ( ) == 0 ) continue ; 
if ( ! canWorkOnShard ( shard ) ) continue ; 
for ( Integer slot : slotsToWorkOn ) { 
SlotKey slotKey = SlotKey . of ( g , slot , shard ) ; 
if ( areChildKeysOrSelfKeyScheduledOrRunning ( slotKey ) ) continue ; 
SlotKey key = SlotKey . of ( g , slot , shard ) ; 
scheduledSlots . add ( key ) ; 
orderedScheduledSlots . add ( key ) ; 
recentlyScheduledShards . put ( shard , scheduleTime ) ; 
} 
} 
} 
} 
} 
} 
} 

public class Emitter { 
public Emitter on ( String event , Listener fn ) { 
ConcurrentLinkedQueue < Listener > callbacks = this . callbacks . get ( event ) ; 
if ( callbacks == null ) { 
callbacks = new ConcurrentLinkedQueue < Listener > ( ) ; 
ConcurrentLinkedQueue < Listener > _callbacks = this . callbacks . putIfAbsent ( event , callbacks ) ; 
if ( _callbacks != null ) callbacks = _callbacks ; 
} 
callbacks . add ( fn ) ; 
return this ; 
} 
} 

public class Emitter { 
public Emitter off ( String event ) { 
ConcurrentLinkedQueue < Listener > callbacks = this . callbacks . remove ( event ) ; 
if ( callbacks != null ) for ( Listener fn : callbacks ) { 
this . onceCallbacks . remove ( fn ) ; 
} 
return this ; 
} 
} 

public class ZKShardLockManager { 
private void registerMetrics ( final ObjectName nameObj , MetricRegistry reg ) { 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Lock Disinterested Time Millis" ) , new JmxAttributeGauge ( nameObj , "LockDisinterestedTimeMillis" ) ) ; 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Min Lock Hold Time Millis" ) , new JmxAttributeGauge ( nameObj , "MinLockHoldTimeMillis" ) ) ; 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Seconds Since Last Scavenge" ) , new JmxAttributeGauge ( nameObj , "SecondsSinceLastScavenge" ) ) ; 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Zk Connection Status" ) , new JmxAttributeGauge ( nameObj , "ZkConnectionStatus" ) { 
@ Override public Object getValue ( ) { 
Object val = super . getValue ( ) ; 
if ( val . equals ( "connected" ) ) return 1 ; 
return 0 ; 
} 
} 
) ; 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Held Shards" ) , new Gauge < Integer > ( ) { 
@ Override public Integer getValue ( ) { 
return getHeldShards ( ) . size ( ) ; 
} 
} 
) ; 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Unheld Shards" ) , new Gauge < Integer > ( ) { 
@ Override public Integer getValue ( ) { 
return getUnheldShards ( ) . size ( ) ; 
} 
} 
) ; 
reg . register ( MetricRegistry . name ( ZKShardLockManager . class , "Error Shards" ) , new Gauge < Integer > ( ) { 
@ Override public Integer getValue ( ) { 
return getErrorShards ( ) . size ( ) ; 
} 
} 
) ; 
} 
} 

public class ThreadPoolBuilder { 
public ThreadPoolBuilder withName ( String name ) { 
if ( ! name . contains ( "%d" ) ) name = name + "-%d" ; 
nameMap . putIfAbsent ( name , new AtomicInteger ( 0 ) ) ; 
int id = nameMap . get ( name ) . incrementAndGet ( ) ; 
this . poolName = String . format ( name , id ) ; 
if ( id > 1 ) this . threadNameFormat = name . replace ( "%d" , id + "-%d" ) ; 
else this . threadNameFormat = name ; 
return this ; 
} 
} 

public class MetricIndexData { 
public void add ( String metricIndex , long docCount ) { 
final String [ ] tokens = metricIndex . split ( METRIC_TOKEN_SEPARATOR_REGEX ) ; 
switch ( tokens . length - baseLevel ) { 
case 1 : if ( baseLevel > 0 ) metricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . lastIndexOf ( "." ) ) ) ; 
else metricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . indexOf ( "." ) ) ) ; 
addChildrenDocCount ( metricNameBaseLevelMap , metricIndex . substring ( 0 , metricIndex . lastIndexOf ( "." ) ) , docCount ) ; 
break ; 
case 0 : setActualDocCount ( metricNameBaseLevelMap , metricIndex , docCount ) ; 
break ; 
default : break ; 
} 
} 
} 

public class MetricIndexData { 
private Set < String > getCompleteMetricNames ( Map < String , MetricIndexDocCount > metricIndexMap ) { 
Set < String > completeMetricNames = new HashSet < String > ( ) ; 
for ( Map . Entry < String , MetricIndexDocCount > entry : metricIndexMap . entrySet ( ) ) { 
MetricIndexDocCount metricIndexDocCount = entry . getValue ( ) ; 
if ( metricIndexDocCount != null ) if ( metricIndexDocCount . actualDocCount > 0 && metricIndexDocCount . actualDocCount > metricIndexDocCount . childrenTotalDocCount ) completeMetricNames . add ( entry . getKey ( ) ) ; 
} 
return Collections . unmodifiableSet ( completeMetricNames ) ; 
} 
} 

public class Granularity { 
public static Granularity granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , long assumedIntervalMillis , Clock ttlComparisonClock ) { 
if ( from >= to ) throw new RuntimeException ( "Invalid interval specified for fromPointsInInterval" ) ; 
double requestedDuration = to - from ; 
if ( algorithm . startsWith ( "GEOMETRIC" ) ) return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; 
else if ( algorithm . startsWith ( "LINEAR" ) ) return granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; 
else if ( algorithm . startsWith ( "LESSTHANEQUAL" ) ) return granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; 
return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; 
} 
} 

public class Granularity { 
private static Granularity granularityFromPointsLessThanEqual ( double requestedDuration , int points , long assumedIntervalMillis ) { 
Granularity gran = granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; 
if ( requestedDuration / gran . milliseconds ( ) > points ) try { 
gran = gran . coarser ( ) ; 
} 
catch ( GranularityException e ) { 
} 
return gran ; 
} 
} 

public class LocatorFetchRunnable { 
protected Set < Locator > getLocators ( RollupExecutionContext executionContext , boolean isReroll , Granularity delayedMetricsRerollGranularity , Granularity delayedMetricsStorageGranularity ) { 
Set < Locator > locators = new HashSet < Locator > ( ) ; 
if ( RECORD_DELAYED_METRICS && isReroll && ! getGranularity ( ) . isCoarser ( delayedMetricsRerollGranularity ) ) if ( getGranularity ( ) . isCoarser ( delayedMetricsStorageGranularity ) ) for ( SlotKey slotKey : parentSlotKey . getChildrenKeys ( delayedMetricsStorageGranularity ) ) { 
locators . addAll ( getDelayedLocators ( executionContext , slotKey ) ) ; 
} 
else locators = getDelayedLocators ( executionContext , parentSlotKey . extrapolate ( delayedMetricsStorageGranularity ) ) ; 
else locators = getLocators ( executionContext ) ; 
return locators ; 
} 
} 

public class AbstractElasticIO { 
protected String regexToGrabCurrentAndNextLevel ( final String query ) { 
if ( StringUtils . isEmpty ( query ) ) throw new IllegalArgumentException ( "Query(glob) string cannot be null/empty" ) ; 
String queryRegex = getRegex ( query ) ; 
int totalQueryTokens = getTotalTokens ( query ) ; 
if ( totalQueryTokens == 1 ) { 
String baseRegex = convertRegexToCaptureUptoNextToken ( queryRegex ) ; 
return baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN ; 
} 
else { 
String [ ] queryRegexParts = queryRegex . split ( "\\\\." ) ; 
String queryRegexUptoPrevLevel = StringUtils . join ( queryRegexParts , METRIC_TOKEN_SEPARATOR_REGEX , 0 , totalQueryTokens - 1 ) ; 
String baseRegex = convertRegexToCaptureUptoNextToken ( queryRegexUptoPrevLevel ) ; 
String queryRegexLastLevel = queryRegexParts [ totalQueryTokens - 1 ] ; 
String lastTokenRegex = convertRegexToCaptureUptoNextToken ( queryRegexLastLevel ) ; 
return baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + lastTokenRegex + "(" + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN + ")" + "{0,1}" ; 
} 
} 
} 

public class StorageManager { 
public synchronized void start ( ) { 
if ( uploaderThread != null ) throw new RuntimeException ( "StorageManager is already started" ) ; 
fileUploader = new DoneFileUploader ( ) ; 
uploaderThread = new Thread ( fileUploader , "StorageManager uploader" ) ; 
uploaderThread . start ( ) ; 
} 
} 

public class StorageManager { 
public synchronized void stop ( ) throws IOException { 
if ( uploaderThread == null ) throw new RuntimeException ( "Not running" ) ; 
uploaderThread . interrupt ( ) ; 
uploaderThread = null ; 
fileUploader . shutdown ( ) ; 
} 
} 

public class Range { 
public static Iterable < Range > rangesForInterval ( Granularity g , final long from , final long to ) { 
if ( g == Granularity . FULL ) return Arrays . asList ( new Range ( from , to ) ) ; 
final long snappedStartMillis = g . snapMillis ( from ) ; 
final long snappedStopMillis = g . snapMillis ( to + g . milliseconds ( ) ) ; 
return new IntervalRangeIterator ( g , snappedStartMillis , snappedStopMillis ) ; 
} 
} 

public class AstyanaxWriter { 
public void insertFull ( Collection < ? extends IMetric > metrics , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { 
Timer . Context ctx = Instrumentation . getWriteTimerContext ( CassandraModel . CF_METRICS_FULL_NAME ) ; 
try { 
MutationBatch mutationBatch = keyspace . prepareMutationBatch ( ) ; 
for ( IMetric metric : metrics ) { 
final Locator locator = metric . getLocator ( ) ; 
if ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { 
if ( mutationBatch != null ) insertLocator ( locator , mutationBatch ) ; 
LocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; 
} 
if ( isRecordingDelayedMetrics ) if ( mutationBatch != null ) insertLocatorIfDelayed ( metric , mutationBatch , clock ) ; 
insertMetric ( metric , mutationBatch ) ; 
Instrumentation . markFullResMetricWritten ( ) ; 
} 
try { 
mutationBatch . execute ( ) ; 
} 
catch ( ConnectionException e ) { 
Instrumentation . markWriteError ( e ) ; 
log . error ( "Connection exception during insertFull" , e ) ; 
throw e ; 
} 
} 
finally { 
ctx . stop ( ) ; 
} 
} 
} 

public class AstyanaxWriter { 
public void insertMetrics ( Collection < IMetric > metrics , ColumnFamily cf , boolean isRecordingDelayedMetrics , Clock clock ) throws ConnectionException { 
Timer . Context ctx = Instrumentation . getWriteTimerContext ( cf . getName ( ) ) ; 
Multimap < Locator , IMetric > map = asMultimap ( metrics ) ; 
MutationBatch batch = keyspace . prepareMutationBatch ( ) ; 
try { 
for ( Locator locator : map . keySet ( ) ) { 
ColumnListMutation < Long > mutation = batch . withRow ( cf , locator ) ; 
for ( IMetric metric : map . get ( locator ) ) { 
mutation . putColumn ( metric . getCollectionTime ( ) , metric . getMetricValue ( ) , ( AbstractSerializer ) ( Serializers . serializerFor ( metric . getMetricValue ( ) . getClass ( ) ) ) , metric . getTtlInSeconds ( ) ) ; 
if ( cf . getName ( ) . equals ( CassandraModel . CF_METRICS_PREAGGREGATED_FULL_NAME ) ) Instrumentation . markFullResPreaggregatedMetricWritten ( ) ; 
if ( isRecordingDelayedMetrics ) insertLocatorIfDelayed ( metric , batch , clock ) ; 
} 
if ( ! LocatorCache . getInstance ( ) . isLocatorCurrentInBatchLayer ( locator ) ) { 
insertLocator ( locator , batch ) ; 
LocatorCache . getInstance ( ) . setLocatorCurrentInBatchLayer ( locator ) ; 
} 
} 
try { 
batch . execute ( ) ; 
} 
catch ( ConnectionException e ) { 
Instrumentation . markWriteError ( e ) ; 
log . error ( "Connection exception persisting data" , e ) ; 
throw e ; 
} 
} 
finally { 
ctx . stop ( ) ; 
} 
} 
} 

public class DownloadService { 
private void doCheck ( ) { 
if ( ! running ) return ; 
if ( fileManager == null ) return ; 
if ( unexpectedErrors > MAX_UNEXPECTED_ERRORS ) { 
log . info ( "Terminating because of errors" ) ; 
terminate ( false ) ; 
return ; 
} 
Timer . Context waitTimerContext = waitingTimer . time ( ) ; 
while ( downloadDir . listFiles ( ) . length != 0 ) { 
log . debug ( "Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely" ) ; 
try { 
Thread . sleep ( 60000 ) ; 
} 
catch ( Exception ex ) { 
} 
} 
waitTimerContext . stop ( ) ; 
if ( downloadLock . tryLock ( ) ) try { 
if ( fileManager . hasNewFiles ( ) ) fileManager . downloadNewFiles ( downloadDir ) ; 
} 
catch ( Throwable unexpected ) { 
unexpectedErrors += 1 ; 
log . error ( "UNEXPECTED; WILL TRY TO RECOVER" ) ; 
log . error ( unexpected . getMessage ( ) , unexpected ) ; 
if ( Thread . interrupted ( ) ) try { 
thread . sleep ( 60000 ) ; 
} 
catch ( Exception ex ) { 
log . error ( ex . getMessage ( ) , ex ) ; 
} 
} 
finally { 
downloadLock . unlock ( ) ; 
} 
else log . debug ( "Download in progress" ) ; 
} 
} 

public class ExtractorFactory { 
public Extractor getNewInstance ( ) { 
Extractor extractor = new BasicExtractor ( config ) ; 
if ( config . shouldCachedDownload ( ) ) extractor = new CachedExtractor ( extractor , config ) ; 
return extractor ; 
} 
} 

public class EmbeddedRabbitMq { 
public void start ( ) throws ErlangVersionException , DownloadException , ExtractionException , StartupException { 
if ( rabbitMqProcess != null ) throw new IllegalStateException ( "Start shouldn't be called more than once unless stop() has been called before." ) ; 
check ( ) ; 
download ( ) ; 
extract ( ) ; 
run ( ) ; 
} 
} 

public class EmbeddedRabbitMq { 
public void stop ( ) throws ShutDownException { 
if ( rabbitMqProcess == null ) throw new IllegalStateException ( "Stop shouldn't be called unless 'start()' was successful." ) ; 
new ShutdownHelper ( config , rabbitMqProcess ) . run ( ) ; 
rabbitMqProcess = null ; 
} 
} 

public class PnSignalingParams { 
public void addIceServers ( List < PeerConnection . IceServer > iceServers ) { 
if ( this . iceServers != null ) iceServers . addAll ( this . iceServers ) ; 
this . iceServers = iceServers ; 
} 
} 

public class PnSignalingParams { 
public void addIceServers ( PeerConnection . IceServer iceServers ) { 
if ( this . iceServers == null ) this . iceServers = new ArrayList < PeerConnection . IceServer > ( ) ; 
this . iceServers . add ( 0 , iceServers ) ; 
} 
} 

public class Immobilie { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < WeitereAdresse > getWeitereAdresse ( ) { 
if ( weitereAdresse == null ) weitereAdresse = new ArrayList < WeitereAdresse > ( ) ; 
return this . weitereAdresse ; 
} 
} 

public class Immobilie { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < UserDefinedSimplefield > getUserDefinedSimplefield ( ) { 
if ( userDefinedSimplefield == null ) userDefinedSimplefield = new ArrayList < UserDefinedSimplefield > ( ) ; 
return this . userDefinedSimplefield ; 
} 
} 

public class Immobilie { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < UserDefinedAnyfield > getUserDefinedAnyfield ( ) { 
if ( userDefinedAnyfield == null ) userDefinedAnyfield = new ArrayList < UserDefinedAnyfield > ( ) ; 
return this . userDefinedAnyfield ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public List < MultimediaAnhangTyp > getMultimediaAnhang ( ) { 
if ( multimediaAnhang == null ) multimediaAnhang = new ArrayList < MultimediaAnhangTyp > ( ) ; 
return this . multimediaAnhang ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public StatusTyp getStatusVBM ( ) { 
if ( statusVBM == null ) return StatusTyp . AKTIV ; 
else return statusVBM ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public StatusTyp getStatusIS24 ( ) { 
if ( statusIS24 == null ) return StatusTyp . AKTIV ; 
else return statusIS24 ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public StatusTyp getStatusHP ( ) { 
if ( statusHP == null ) return StatusTyp . AKTIV ; 
else return statusHP ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public AktionsTyp getImportmodus ( ) { 
if ( importmodus == null ) return AktionsTyp . IMPORTIEREN ; 
else return importmodus ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public Boolean getAdressdruck ( ) { 
if ( adressdruck == null ) return false ; 
else return adressdruck ; 
} 
} 

public class ImmobilieBaseTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public WaehrungTyp getWaehrung ( ) { 
if ( waehrung == null ) return WaehrungTyp . EUR ; 
else return waehrung ; 
} 
} 

public class SonstigeGewerbeTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public BodenbelagTyp getBodenbelag ( ) { 
if ( bodenbelag == null ) return BodenbelagTyp . KEINE_ANGABE ; 
else return bodenbelag ; 
} 
} 

public class NumberUtils { 
public static boolean isNumeric ( String value , Locale locale ) { 
if ( value == null ) return false ; 
int start = 0 ; 
final DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; 
if ( value . startsWith ( "+" ) || value . startsWith ( "-" ) ) start ++ ; 
boolean fraction = false ; 
for ( int i = start ; 
i < value . length ( ) ; 
i ++ ) { 
final char c = value . charAt ( i ) ; 
if ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { 
fraction = true ; 
continue ; 
} 
if ( c == symbols . getGroupingSeparator ( ) && ! fraction ) continue ; 
if ( ! Character . isDigit ( c ) ) return false ; 
} 
return true ; 
} 
} 

public class Root { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T01:43:04+02:00" , comments = "JAXB RI v2.2.11" ) public List < PropertyType > getProperty ( ) { 
if ( property == null ) property = new ArrayList < PropertyType > ( ) ; 
return this . property ; 
} 
} 

public class Kontaktperson { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < UserDefinedExtend > getUserDefinedExtend ( ) { 
if ( userDefinedExtend == null ) userDefinedExtend = new ArrayList < UserDefinedExtend > ( ) ; 
return this . userDefinedExtend ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Zimmer > getZimmer ( ) { 
if ( zimmer == null ) zimmer = new ArrayList < Zimmer > ( ) ; 
return this . zimmer ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Haus > getHaus ( ) { 
if ( haus == null ) haus = new ArrayList < Haus > ( ) ; 
return this . haus ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < BueroPraxen > getBueroPraxen ( ) { 
if ( bueroPraxen == null ) bueroPraxen = new ArrayList < BueroPraxen > ( ) ; 
return this . bueroPraxen ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Gastgewerbe > getGastgewerbe ( ) { 
if ( gastgewerbe == null ) gastgewerbe = new ArrayList < Gastgewerbe > ( ) ; 
return this . gastgewerbe ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < LandUndForstwirtschaft > getLandUndForstwirtschaft ( ) { 
if ( landUndForstwirtschaft == null ) landUndForstwirtschaft = new ArrayList < LandUndForstwirtschaft > ( ) ; 
return this . landUndForstwirtschaft ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Sonstige > getSonstige ( ) { 
if ( sonstige == null ) sonstige = new ArrayList < Sonstige > ( ) ; 
return this . sonstige ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < ZinshausRenditeobjekt > getZinshausRenditeobjekt ( ) { 
if ( zinshausRenditeobjekt == null ) zinshausRenditeobjekt = new ArrayList < ZinshausRenditeobjekt > ( ) ; 
return this . zinshausRenditeobjekt ; 
} 
} 

public class Terrains { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:48:12+02:00" , comments = "JAXB RI v2.2.11" ) public List < TerrainType > getTerrain ( ) { 
if ( terrain == null ) terrain = new ArrayList < TerrainType > ( ) ; 
return this . terrain ; 
} 
} 

public class LocaleUtils { 
public static String getCountryISO2FromISO3 ( String iso3Code ) { 
iso3Code = StringUtils . trimToNull ( iso3Code ) ; 
if ( iso3Code == null ) return null ; 
if ( iso3Code . length ( ) == 3 ) for ( String iso2Code : Locale . getISOCountries ( ) ) { 
Locale countryLocale = new Locale ( iso2Code , iso2Code ) ; 
String countryISO3 = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; 
if ( countryISO3 != null && countryISO3 . equalsIgnoreCase ( iso3Code ) ) return iso2Code ; 
} 
return null ; 
} 
} 

public class Immoxml { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Anbieter > getAnbieter ( ) { 
if ( anbieter == null ) anbieter = new ArrayList < Anbieter > ( ) ; 
return this . anbieter ; 
} 
} 

public class PdfsType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:41:42+02:00" , comments = "JAXB RI v2.2.11" ) public List < URI > getPdf ( ) { 
if ( pdf == null ) pdf = new ArrayList < URI > ( ) ; 
return this . pdf ; 
} 
} 

public class UserDefinedAnyfield { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Object > getContent ( ) { 
if ( content == null ) content = new ArrayList < Object > ( ) ; 
return this . content ; 
} 
} 

public class WazTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public StellplatzKategorieTyp getParkplatz ( ) { 
if ( parkplatz == null ) return StellplatzKategorieTyp . KEINE_ANGABE ; 
else return parkplatz ; 
} 
} 

public class Bewertung { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Bewertung . Feld > getFeld ( ) { 
if ( feld == null ) feld = new ArrayList < Bewertung . Feld > ( ) ; 
return this . feld ; 
} 
} 

public class CsvRecord { 
protected Iterable < String > print ( ) { 
final int length = this . getRecordLenth ( ) ; 
List < String > row = new ArrayList < > ( ) ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) row . add ( this . get ( i ) ) ; 
return row ; 
} 
} 

public class ZustandAngaben { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Energiepass > getEnergiepass ( ) { 
if ( energiepass == null ) energiepass = new ArrayList < Energiepass > ( ) ; 
return this . energiepass ; 
} 
} 

public class VersteigerungsterminTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public Boolean getWiederholungstermin ( ) { 
if ( wiederholungstermin == null ) return false ; 
else return wiederholungstermin ; 
} 
} 

public class VersteigerungsterminTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public Boolean getTeilungsversteigerung ( ) { 
if ( teilungsversteigerung == null ) return false ; 
else return teilungsversteigerung ; 
} 
} 

public class Interessent { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Interessent . Bevorzugt > getBevorzugt ( ) { 
if ( bevorzugt == null ) bevorzugt = new ArrayList < Interessent . Bevorzugt > ( ) ; 
return this . bevorzugt ; 
} 
} 

public class Interessent { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Interessent . Wunsch > getWunsch ( ) { 
if ( wunsch == null ) wunsch = new ArrayList < Interessent . Wunsch > ( ) ; 
return this . wunsch ; 
} 
} 

public class WeitereAdresse { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < EmailSonstige > getEmailSonstige ( ) { 
if ( emailSonstige == null ) emailSonstige = new ArrayList < EmailSonstige > ( ) ; 
return this . emailSonstige ; 
} 
} 

public class WeitereAdresse { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < TelSonstige > getTelSonstige ( ) { 
if ( telSonstige == null ) telSonstige = new ArrayList < TelSonstige > ( ) ; 
return this . telSonstige ; 
} 
} 

public class ResultSetType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:42:33+02:00" , comments = "JAXB RI v2.2.11" ) public List < ResultSetType . ROW > getROW ( ) { 
if ( row == null ) row = new ArrayList < ResultSetType . ROW > ( ) ; 
return this . row ; 
} 
} 

public class Anhaenge { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Anhang > getAnhang ( ) { 
if ( anhang == null ) anhang = new ArrayList < Anhang > ( ) ; 
return this . anhang ; 
} 
} 

public class GarageTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public GaragenKategorieTyp getObjektKategorie2 ( ) { 
if ( objektKategorie2 == null ) return GaragenKategorieTyp . KEINE_ANGABE ; 
else return objektKategorie2 ; 
} 
} 

public class GarageTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public ObjektZustandTyp getObjektzustand ( ) { 
if ( objektzustand == null ) return ObjektZustandTyp . KEINE_ANGABE ; 
else return objektzustand ; 
} 
} 

public class HausTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public HausKategorienTyp getHausKategorie ( ) { 
if ( hausKategorie == null ) return HausKategorienTyp . KEINE_ANGABE ; 
else return hausKategorie ; 
} 
} 

public class HausTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public AusstattungsqualitaetsTyp getAusstattungsqualitaet ( ) { 
if ( ausstattungsqualitaet == null ) return AusstattungsqualitaetsTyp . KEINE_ANGABE ; 
else return ausstattungsqualitaet ; 
} 
} 

public class Objekt { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < String > getVermarktungsart ( ) { 
if ( vermarktungsart == null ) vermarktungsart = new ArrayList < String > ( ) ; 
return this . vermarktungsart ; 
} 
} 

public class Objekt { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Interessent > getInteressent ( ) { 
if ( interessent == null ) interessent = new ArrayList < Interessent > ( ) ; 
return this . interessent ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Wohnung > getWohnung ( ) { 
if ( wohnung == null ) wohnung = new ArrayList < Wohnung > ( ) ; 
return this . wohnung ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Grundstueck > getGrundstueck ( ) { 
if ( grundstueck == null ) grundstueck = new ArrayList < Grundstueck > ( ) ; 
return this . grundstueck ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Einzelhandel > getEinzelhandel ( ) { 
if ( einzelhandel == null ) einzelhandel = new ArrayList < Einzelhandel > ( ) ; 
return this . einzelhandel ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < HallenLagerProd > getHallenLagerProd ( ) { 
if ( hallenLagerProd == null ) hallenLagerProd = new ArrayList < HallenLagerProd > ( ) ; 
return this . hallenLagerProd ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Parken > getParken ( ) { 
if ( parken == null ) parken = new ArrayList < Parken > ( ) ; 
return this . parken ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < FreizeitimmobilieGewerblich > getFreizeitimmobilieGewerblich ( ) { 
if ( freizeitimmobilieGewerblich == null ) freizeitimmobilieGewerblich = new ArrayList < FreizeitimmobilieGewerblich > ( ) ; 
return this . freizeitimmobilieGewerblich ; 
} 
} 

public class Objektart { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < String > getObjektartZusatz ( ) { 
if ( objektartZusatz == null ) objektartZusatz = new ArrayList < String > ( ) ; 
return this . objektartZusatz ; 
} 
} 

public class Ausstattung { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Stellplatzart > getStellplatzart ( ) { 
if ( stellplatzart == null ) stellplatzart = new ArrayList < Stellplatzart > ( ) ; 
return this . stellplatzart ; 
} 
} 

public class FeaturesType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:41:42+02:00" , comments = "JAXB RI v2.2.11" ) public List < String > getFeature ( ) { 
if ( feature == null ) feature = new ArrayList < String > ( ) ; 
return this . feature ; 
} 
} 

public class OpenImmo_1_2_5 { 
@ Override @ SuppressWarnings ( "Duplicates" ) public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { 
doc . setDocumentVersion ( OpenImmoVersion . V1_2_5 ) ; 
if ( doc instanceof OpenImmoTransferDocument ) try { 
this . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; 
} 
catch ( Exception ex ) { 
LOGGER . error ( "Can't upgrade <energiepass> elements!" ) ; 
LOGGER . error ( "> " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class WohnungTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public WohnungKategorienTyp getWohnungKategorie ( ) { 
if ( wohnungKategorie == null ) return WohnungKategorienTyp . KEINE_ANGABE ; 
else return wohnungKategorie ; 
} 
} 

public class Feedindex { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:41:42+02:00" , comments = "JAXB RI v2.2.11" ) public List < Feedindex . Feed > getFeed ( ) { 
if ( feed == null ) feed = new ArrayList < Feedindex . Feed > ( ) ; 
return this . feed ; 
} 
} 

public class Ausstattung { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Serviceleistungen > getServiceleistungen ( ) { 
if ( serviceleistungen == null ) serviceleistungen = new ArrayList < Serviceleistungen > ( ) ; 
return this . serviceleistungen ; 
} 
} 

public class OpenImmo_1_2_1 { 
@ Override @ SuppressWarnings ( "Duplicates" ) public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { 
doc . setDocumentVersion ( OpenImmoVersion . V1_2_1 ) ; 
if ( doc instanceof OpenImmoTransferDocument ) try { 
this . upgradeEnergiepassElements ( doc . getDocument ( ) ) ; 
} 
catch ( Exception ex ) { 
LOGGER . error ( "Can't upgrade <energiepass> elements!" ) ; 
LOGGER . error ( "> " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
try { 
this . upgradeXmlNamespace ( doc . getDocument ( ) ) ; 
} 
catch ( Exception ex ) { 
LOGGER . error ( "Can't upgrade the XML namespace!" ) ; 
LOGGER . error ( "> " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class MetaDataType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:42:33+02:00" , comments = "JAXB RI v2.2.11" ) public List < MetaDataType . FIELD > getFIELD ( ) { 
if ( field == null ) field = new ArrayList < MetaDataType . FIELD > ( ) ; 
return this . field ; 
} 
} 

public class OpenImmo_1_2_0 { 
@ Override public void upgradeFromPreviousVersion ( OpenImmoDocument doc ) { 
doc . setDocumentVersion ( OpenImmoVersion . V1_2_0 ) ; 
if ( doc instanceof OpenImmoTransferDocument ) try { 
this . upgradeMieteinnahmenElements ( doc . getDocument ( ) ) ; 
} 
catch ( Exception ex ) { 
LOGGER . error ( "Can't upgrade <mieteinnahmen_ist> and <mieteinnahmen_soll> elements!" ) ; 
LOGGER . error ( "> " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class Trovit { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:55:25+02:00" , comments = "JAXB RI v2.2.11" ) public List < AdType > getAd ( ) { 
if ( ad == null ) ad = new ArrayList < AdType > ( ) ; 
return this . ad ; 
} 
} 

public class BueroPraxisTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public DatenVerkabelungsTyp getDatenVerkabelung ( ) { 
if ( datenVerkabelung == null ) return DatenVerkabelungsTyp . KEINE_ANGABE ; 
else return datenVerkabelung ; 
} 
} 

public class BueroPraxisTyp { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:52:47+02:00" , comments = "JAXB RI v2.2.11" ) public JaNeinVereinbarungTyp getKlimaanlage ( ) { 
if ( klimaanlage == null ) return JaNeinVereinbarungTyp . KEINE_ANGABE ; 
else return klimaanlage ; 
} 
} 

public class ImagesType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T01:43:04+02:00" , comments = "JAXB RI v2.2.11" ) public List < ImagesType . Image > getImage ( ) { 
if ( image == null ) image = new ArrayList < ImagesType . Image > ( ) ; 
return this . image ; 
} 
} 

public class Fehlerliste { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Fehlerliste . Fehler > getFehler ( ) { 
if ( fehler == null ) fehler = new ArrayList < Fehlerliste . Fehler > ( ) ; 
return this . fehler ; 
} 
} 

public class Preise { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < StpSonstige > getStpSonstige ( ) { 
if ( stpSonstige == null ) stpSonstige = new ArrayList < StpSonstige > ( ) ; 
return this . stpSonstige ; 
} 
} 

public class ValueListsType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:42:33+02:00" , comments = "JAXB RI v2.2.11" ) public List < ValueListsType . VALUELIST > getVALUELIST ( ) { 
if ( valuelist == null ) valuelist = new ArrayList < ValueListsType . VALUELIST > ( ) ; 
return this . valuelist ; 
} 
} 

public class PhotosType { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:41:42+02:00" , comments = "JAXB RI v2.2.11" ) public List < URI > getPhoto ( ) { 
if ( photo == null ) photo = new ArrayList < URI > ( ) ; 
return this . photo ; 
} 
} 

public class Anbieter { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:50:55+02:00" , comments = "JAXB RI v2.2.11" ) public List < Immobilie > getImmobilie ( ) { 
if ( immobilie == null ) immobilie = new ArrayList < Immobilie > ( ) ; 
return this . immobilie ; 
} 
} 

public class OpenimmoFeedback { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Objekt > getObjekt ( ) { 
if ( objekt == null ) objekt = new ArrayList < Objekt > ( ) ; 
return this . objekt ; 
} 
} 

public class OpenimmoFeedback { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Fehlerliste > getFehlerliste ( ) { 
if ( fehlerliste == null ) fehlerliste = new ArrayList < Fehlerliste > ( ) ; 
return this . fehlerliste ; 
} 
} 

public class OpenimmoFeedback { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Status > getStatus ( ) { 
if ( status == null ) status = new ArrayList < Status > ( ) ; 
return this . status ; 
} 
} 

public class Infrastruktur { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < Distanzen > getDistanzen ( ) { 
if ( distanzen == null ) distanzen = new ArrayList < Distanzen > ( ) ; 
return this . distanzen ; 
} 
} 

public class Infrastruktur { 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2018-10-12T02:54:50+02:00" , comments = "JAXB RI v2.2.11" ) public List < DistanzenSport > getDistanzenSport ( ) { 
if ( distanzenSport == null ) distanzenSport = new ArrayList < DistanzenSport > ( ) ; 
return this . distanzenSport ; 
} 
} 

public class ObjectUtils { 
public static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { 
if ( ! isCheckedException ( ex ) ) return true ; 
if ( declaredExceptions != null ) { 
int i = 0 ; 
while ( i < declaredExceptions . length ) { 
if ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) return true ; 
i ++ ; 
} 
} 
return false ; 
} 
} 

public class SimpleNamespaceContext { 
public void bindNamespaceUri ( String prefix , String namespaceUri ) { 
Assert . notNull ( prefix , "No prefix given" ) ; 
Assert . notNull ( namespaceUri , "No namespaceUri given" ) ; 
if ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) defaultNamespaceUri = namespaceUri ; 
else { 
prefixToNamespaceUri . put ( prefix , namespaceUri ) ; 
getPrefixesInternal ( namespaceUri ) . add ( prefix ) ; 
} 
} 
} 

public class SimpleNamespaceContext { 
public void removeBinding ( String prefix ) { 
if ( XMLConstants . DEFAULT_NS_PREFIX . equals ( prefix ) ) defaultNamespaceUri = "" ; 
else { 
String namespaceUri = prefixToNamespaceUri . remove ( prefix ) ; 
List < String > prefixes = getPrefixesInternal ( namespaceUri ) ; 
prefixes . remove ( prefix ) ; 
} 
} 
} 

public class XmlValidationModeDetector { 
private boolean hasOpeningTag ( String content ) { 
if ( this . inComment ) return false ; 
int openTagIndex = content . indexOf ( '<' ) ; 
return ( openTagIndex > - 1 && content . length ( ) > openTagIndex && Character . isLetter ( content . charAt ( openTagIndex + 1 ) ) ) ; 
} 
} 

public class XmlValidationModeDetector { 
private String consumeCommentTokens ( String line ) { 
if ( line . indexOf ( START_COMMENT ) == - 1 && line . indexOf ( END_COMMENT ) == - 1 ) return line ; 
while ( ( line = consume ( line ) ) != null ) if ( ! this . inComment && ! line . trim ( ) . startsWith ( START_COMMENT ) ) return line ; 
return line ; 
} 
} 

public class XmlValidationModeDetector { 
private int commentToken ( String line , String token , boolean inCommentIfPresent ) { 
int index = line . indexOf ( token ) ; 
if ( index > - 1 ) this . inComment = inCommentIfPresent ; 
return ( index == - 1 ? index : index + token . length ( ) ) ; 
} 
} 

public class Log4jConfigurer { 
public static void initLogging ( String location ) throws FileNotFoundException { 
String resolvedLocation = SystemPropertyUtils . resolvePlaceholders ( location ) ; 
URL url = ResourceUtils . getURL ( resolvedLocation ) ; 
if ( resolvedLocation . toLowerCase ( ) . endsWith ( XML_FILE_EXTENSION ) ) DOMConfigurator . configure ( url ) ; 
else PropertyConfigurator . configure ( url ) ; 
} 
} 

public class CompositeIterator { 
public void add ( Iterator < E > iterator ) { 
Assert . state ( ! inUse , "You can no longer add iterator to a composite iterator that's already in use" ) ; 
if ( iterators . contains ( iterator ) ) throw new IllegalArgumentException ( "You cannot add the same iterator twice" ) ; 
iterators . add ( iterator ) ; 
} 
} 

public class CmdLineParser { 
public final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { 
Vector otherArgs = new Vector ( ) ; 
int position = 0 ; 
this . values = new Hashtable ( 10 ) ; 
while ( position < argv . length ) { 
String curArg = argv [ position ] ; 
if ( curArg . startsWith ( "-" ) ) { 
if ( curArg . equals ( "--" ) ) { 
position += 1 ; 
break ; 
} 
String valueArg = null ; 
if ( curArg . startsWith ( "--" ) ) { 
int equalsPos = curArg . indexOf ( "=" ) ; 
if ( equalsPos != - 1 ) { 
valueArg = curArg . substring ( equalsPos + 1 ) ; 
curArg = curArg . substring ( 0 , equalsPos ) ; 
} 
} 
else if ( curArg . length ( ) > 2 ) { 
for ( int i = 1 ; 
i < curArg . length ( ) ; 
i ++ ) { 
Option opt = ( Option ) this . options . get ( "-" + curArg . charAt ( i ) ) ; 
if ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; 
if ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; 
addValue ( opt , opt . getValue ( null , locale ) ) ; 
} 
position ++ ; 
continue ; 
} 
Option opt = ( Option ) this . options . get ( curArg ) ; 
if ( opt == null ) throw new UnknownOptionException ( curArg ) ; 
Object value = null ; 
if ( opt . wantsValue ( ) ) { 
if ( valueArg == null ) { 
position += 1 ; 
if ( position < argv . length ) valueArg = argv [ position ] ; 
} 
value = opt . getValue ( valueArg , locale ) ; 
} 
else value = opt . getValue ( null , locale ) ; 
addValue ( opt , value ) ; 
position += 1 ; 
} 
else { 
otherArgs . addElement ( curArg ) ; 
position += 1 ; 
} 
} 
for ( ; 
position < argv . length ; 
++ position ) otherArgs . addElement ( argv [ position ] ) ; 
this . remainingArgs = new String [ otherArgs . size ( ) ] ; 
otherArgs . copyInto ( remainingArgs ) ; 
} 
} 

public class SingletonLoader { 
public Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { 
Object ret = null ; 
Method [ ] methods = c . getDeclaredMethods ( ) ; 
Method m ; 
int modifiers ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) { 
m = methods [ i ] ; 
modifiers = m . getModifiers ( ) ; 
if ( ( modifiers & Modifier . STATIC ) != 0 ) if ( ( modifiers & Modifier . PUBLIC ) != 0 ) if ( m . getParameterTypes ( ) . length == 0 ) if ( m . getReturnType ( ) == c ) if ( m . getName ( ) . toLowerCase ( ) . indexOf ( "instance" ) != - 1 ) try { 
ret = m . invoke ( null , dummyParameters ) ; 
} 
catch ( IllegalArgumentException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( IllegalAccessException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( InvocationTargetException e ) { 
e . printStackTrace ( ) ; 
} 
} 
if ( ret == null ) { 
Constructor [ ] constructors = c . getConstructors ( ) ; 
Constructor con = null ; 
for ( int i = 0 ; 
i < constructors . length ; 
i ++ ) { 
con = constructors [ i ] ; 
if ( con . getParameterTypes ( ) . length == 0 ) { 
modifiers = con . getModifiers ( ) ; 
try { 
if ( ( modifiers & Modifier . PUBLIC ) == 0 ) con . setAccessible ( true ) ; 
ret = c . newInstance ( ) ; 
} 
catch ( SecurityException se ) { 
} 
} 
} 
} 
if ( ret == null ) System . err . println ( "Unable to instantiate: " + c . getName ( ) + ": no singleton method, no public default constructor." ) ; 
return ret ; 
} 
} 

public class ConcurrencyThrottleSupport { 
protected void afterAccess ( ) { 
if ( this . concurrencyLimit >= 0 ) synchronized ( this . monitor ) { 
this . concurrencyCount -- ; 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Returning from throttle at concurrency count " + this . concurrencyCount ) ; 
this . monitor . notify ( ) ; 
} 
} 
} 

public class MethodInvoker { 
public void setTargetObject ( Object targetObject ) { 
this . targetObject = targetObject ; 
if ( targetObject != null ) this . targetClass = targetObject . getClass ( ) ; 
} 
} 

public class MethodInvoker { 
public void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { 
if ( this . staticMethod != null ) { 
int lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; 
if ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) throw new IllegalArgumentException ( "staticMethod must be a fully qualified class plus method name: " + "e.g. 'example.MyExampleClass.myExampleMethod'" ) ; 
String className = this . staticMethod . substring ( 0 , lastDotIndex ) ; 
String methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; 
this . targetClass = resolveClassName ( className ) ; 
this . targetMethod = methodName ; 
} 
Class < ? > targetClass = getTargetClass ( ) ; 
String targetMethod = getTargetMethod ( ) ; 
if ( targetClass == null ) throw new IllegalArgumentException ( "Either 'targetClass' or 'targetObject' is required" ) ; 
if ( targetMethod == null ) throw new IllegalArgumentException ( "Property 'targetMethod' is required" ) ; 
Object [ ] arguments = getArguments ( ) ; 
Class < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; 
for ( int i = 0 ; 
i < arguments . length ; 
++ i ) argTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; 
try { 
this . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; 
} 
catch ( NoSuchMethodException ex ) { 
this . methodObject = findMatchingMethod ( ) ; 
if ( this . methodObject == null ) throw ex ; 
} 
} 
} 

public class SerializationUtils { 
public static byte [ ] serialize ( Object object ) { 
if ( object == null ) return null ; 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
try { 
ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; 
oos . writeObject ( object ) ; 
oos . flush ( ) ; 
} 
catch ( IOException ex ) { 
throw new IllegalArgumentException ( "Failed to serialize object of type: " + object . getClass ( ) , ex ) ; 
} 
return baos . toByteArray ( ) ; 
} 
} 

public class SerializationUtils { 
public static Object deserialize ( byte [ ] bytes ) { 
if ( bytes == null ) return null ; 
try { 
ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; 
return ois . readObject ( ) ; 
} 
catch ( IOException ex ) { 
throw new IllegalArgumentException ( "Failed to deserialize object" , ex ) ; 
} 
catch ( ClassNotFoundException ex ) { 
throw new IllegalStateException ( "Failed to deserialize object type" , ex ) ; 
} 
} 
} 

public class DomUtils { 
public static Element getChildElementByTagName ( Element ele , String childEleName ) { 
Assert . notNull ( ele , "Element must not be null" ) ; 
Assert . notNull ( childEleName , "Element name must not be null" ) ; 
NodeList nl = ele . getChildNodes ( ) ; 
for ( int i = 0 ; 
i < nl . getLength ( ) ; 
i ++ ) { 
Node node = nl . item ( i ) ; 
if ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) return ( Element ) node ; 
} 
return null ; 
} 
} 

public class DomUtils { 
public static List < Element > getChildElements ( Element ele ) { 
Assert . notNull ( ele , "Element must not be null" ) ; 
NodeList nl = ele . getChildNodes ( ) ; 
List < Element > childEles = new ArrayList < Element > ( ) ; 
for ( int i = 0 ; 
i < nl . getLength ( ) ; 
i ++ ) { 
Node node = nl . item ( i ) ; 
if ( node instanceof Element ) childEles . add ( ( Element ) node ) ; 
} 
return childEles ; 
} 
} 

public class StringUtil { 
public static final String setSize ( final String s , final int length ) { 
String result = s ; 
int oldlen = s . length ( ) ; 
if ( oldlen > length ) System . err . println ( "greenpeace.util.setSize(String s,int length): length (" + length + ") is smaller than s.length(" + oldlen + ") : " + s ) ; 
else { 
int tofill = length - oldlen ; 
result = StringUtil . appendSpaces ( s , tofill ) ; 
} 
return result ; 
} 
} 

public class WeakReferenceMonitor { 
public static void monitor ( Object handle , ReleaseListener listener ) { 
if ( logger . isDebugEnabled ( ) ) logger . debug ( "Monitoring handle [" + handle + "] with release listener [" + listener + "]" ) ; 
WeakReference < Object > weakRef = new WeakReference < Object > ( handle , handleQueue ) ; 
addEntry ( weakRef , listener ) ; 
} 
} 

public class WeakReferenceMonitor { 
private static boolean keepMonitoringThreadAlive ( ) { 
synchronized ( WeakReferenceMonitor . class ) { 
if ( ! trackedEntries . isEmpty ( ) ) return true ; 
else { 
logger . debug ( "No entries left to track - stopping reference monitor thread" ) ; 
monitoringThread = null ; 
return false ; 
} 
} 
} 
} 

public class PhoneNumberAddress { 
public static String calcMobileCity ( String mobileNumber ) throws MalformedURLException { 
ObjectMapper objectMapper = new ObjectMapper ( ) ; 
String jsonString = null ; 
String urlString = "http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=" + mobileNumber ; 
StringBuffer sb = new StringBuffer ( ) ; 
BufferedReader buffer ; 
URL url = new URL ( urlString ) ; 
try { 
InputStream in = url . openStream ( ) ; 
buffer = new BufferedReader ( new InputStreamReader ( in , "gb2312" ) ) ; 
String line = null ; 
while ( ( line = buffer . readLine ( ) ) != null ) sb . append ( line ) ; 
in . close ( ) ; 
buffer . close ( ) ; 
jsonString = sb . toString ( ) ; 
EntityHelper . print ( jsonString ) ; 
jsonString = jsonString . replaceAll ( "^[__]\\w{14}+[_ = ]+" , "[" ) ; 
String jsonString2 = jsonString + "]" ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
} 
return null ; 
} 
} 

public class AbstractStaxXMLReader { 
protected void startPrefixMapping ( String prefix , String namespace ) throws SAXException { 
if ( getContentHandler ( ) != null ) { 
if ( prefix == null ) prefix = "" ; 
if ( ! StringUtils . hasLength ( namespace ) ) return ; 
if ( ! namespace . equals ( namespaces . get ( prefix ) ) ) { 
getContentHandler ( ) . startPrefixMapping ( prefix , namespace ) ; 
namespaces . put ( prefix , namespace ) ; 
} 
} 
} 
} 

public class AbstractStaxXMLReader { 
protected void endPrefixMapping ( String prefix ) throws SAXException { 
if ( getContentHandler ( ) != null ) if ( namespaces . containsKey ( prefix ) ) { 
getContentHandler ( ) . endPrefixMapping ( prefix ) ; 
namespaces . remove ( prefix ) ; 
} 
} 
} 

public class HorizontalPicker { 
private int getTextColor ( int item ) { 
int scrollX = getScrollX ( ) ; 
int color = textColor . getDefaultColor ( ) ; 
int itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; 
if ( scrollX > itemWithPadding * item - itemWithPadding / 2 && scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) { 
int position = scrollX - itemWithPadding / 2 ; 
color = getColor ( position , item ) ; 
} 
else if ( item == pressedItem ) color = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_pressed } 
, color ) ; 
return color ; 
} 
} 

public class HorizontalPicker { 
public void setValues ( CharSequence [ ] values ) { 
if ( this . values != values ) { 
this . values = values ; 
if ( this . values != null ) { 
layouts = new BoringLayout [ this . values . length ] ; 
for ( int i = 0 ; 
i < layouts . length ; 
i ++ ) layouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; 
} 
else layouts = new BoringLayout [ 0 ] ; 
if ( getWidth ( ) > 0 ) startMarqueeIfNeeded ( ) ; 
requestLayout ( ) ; 
invalidate ( ) ; 
} 
} 
} 

public class HorizontalPicker { 
private int getColor ( int scrollX , int position ) { 
int itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; 
float proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; 
if ( proportion > .5 ) proportion = ( proportion - .5f ) ; 
else proportion = .5f - proportion ; 
proportion *= 2 ; 
int defaultColor ; 
int selectedColor ; 
if ( pressedItem == position ) { 
defaultColor = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_pressed } 
, textColor . getDefaultColor ( ) ) ; 
selectedColor = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_pressed , android . R . attr . state_selected } 
, defaultColor ) ; 
} 
else { 
defaultColor = textColor . getDefaultColor ( ) ; 
selectedColor = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_selected } 
, defaultColor ) ; 
} 
return ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; 
} 
} 

public class HorizontalPicker { 
private int getInBoundsX ( int x ) { 
if ( x < 0 ) x = 0 ; 
else if ( x > ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ) x = ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ; 
return x ; 
} 
} 

public class ServerMethods { 
public String [ ] get_keyword_arguments ( String keyword ) { 
if ( keyword . equalsIgnoreCase ( "stop_remote_server" ) ) return new String [ 0 ] ; 
try { 
String [ ] args = servlet . getLibrary ( ) . getKeywordArguments ( keyword ) ; 
return args == null ? new String [ 0 ] : args ; 
} 
catch ( Throwable e ) { 
log . warn ( "" , e ) ; 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class ServerMethods { 
public String get_keyword_documentation ( String keyword ) { 
if ( keyword . equalsIgnoreCase ( "stop_remote_server" ) ) return "Stops the remote server.\n\nThe server may be configured so that users cannot stop it." ; 
try { 
String doc = servlet . getLibrary ( ) . getKeywordDocumentation ( keyword ) ; 
return doc == null ? "" : doc ; 
} 
catch ( Throwable e ) { 
log . warn ( "" , e ) ; 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class RemoteServer { 
public static void main ( String [ ] args ) throws Exception { 
configureLogging ( ) ; 
CommandLineHelper helper = new CommandLineHelper ( args ) ; 
if ( helper . getHelpRequested ( ) ) { 
System . out . print ( helper . getUsage ( ) ) ; 
System . exit ( 0 ) ; 
} 
RemoteServer remoteServer = new RemoteServer ( ) ; 
String error = helper . getError ( ) ; 
if ( error == null ) try { 
for ( String path : helper . getLibraryMap ( ) . keySet ( ) ) remoteServer . putLibrary ( path , helper . getLibraryMap ( ) . get ( path ) ) ; 
} 
catch ( IllegalPathException e ) { 
error = e . getMessage ( ) ; 
} 
if ( error != null ) { 
System . out . println ( "Error: " + error ) ; 
System . out . println ( ) ; 
System . out . println ( helper . getUsage ( ) ) ; 
System . exit ( 1 ) ; 
} 
remoteServer . setPort ( helper . getPort ( ) ) ; 
remoteServer . setAllowStop ( helper . getAllowStop ( ) ) ; 
remoteServer . setHost ( helper . getHost ( ) ) ; 
remoteServer . start ( ) ; 
} 
} 

public class RemoteServer { 
public void stop ( int timeoutMS ) throws Exception { 
log . info ( "Robot Framework remote server stopping" ) ; 
if ( timeoutMS > 0 ) { 
server . setGracefulShutdown ( timeoutMS ) ; 
Thread stopper = new Thread ( ) { 
@ Override public void run ( ) { 
try { 
server . stop ( ) ; 
} 
catch ( Throwable e ) { 
log . error ( String . format ( "Failed to stop the server: %s" , e . getMessage ( ) ) , e ) ; 
} 
} 
} 
; 
stopper . start ( ) ; 
} 
else server . stop ( ) ; 
} 
} 

public class PropertiesToJsonConverter { 
public String convertToJson ( Properties properties ) throws ParsePropertiesException { 
for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { 
if ( ! ( entry . getKey ( ) instanceof String ) ) throw new ParsePropertiesException ( format ( PROPERTY_KEY_NEEDS_TO_BE_STRING_TYPE , entry . getKey ( ) . getClass ( ) , entry . getKey ( ) == null ? "null" : entry . getKey ( ) ) ) ; 
} 
return convertFromValuesAsObjectMap ( propertiesToMap ( properties ) ) ; 
} 
} 

public class MdPageGeneratorMojo { 
@ SuppressWarnings ( "UnusedReturnValue" ) private boolean preprocessMarkdownFiles ( File inputDirectory ) throws MojoExecutionException { 
getLog ( ) . debug ( "Read files from: " + inputDirectory ) ; 
try { 
if ( ! inputDirectory . exists ( ) ) { 
getLog ( ) . info ( "There is no input folder for the project. Skipping." ) ; 
return false ; 
} 
int baseDepth = StringUtils . countMatches ( inputDirectory . getAbsolutePath ( ) , File . separator ) ; 
List < File > markdownFiles = getFilesAsArray ( FileUtils . iterateFiles ( inputDirectory , getInputFileExtensions ( ) , recursiveInput ) ) ; 
for ( File file : markdownFiles ) { 
getLog ( ) . debug ( "File getName() " + file . getName ( ) ) ; 
getLog ( ) . debug ( "File getAbsolutePath() " + file . getAbsolutePath ( ) ) ; 
getLog ( ) . debug ( "File getPath() " + file . getPath ( ) ) ; 
MarkdownDTO dto = new MarkdownDTO ( ) ; 
dto . markdownFile = file ; 
dto . folderDepth = StringUtils . countMatches ( file . getAbsolutePath ( ) , File . separator ) - ( baseDepth + 1 ) ; 
if ( alwaysUseDefaultTitle ) dto . title = defaultTitle ; 
else { 
List < String > raw = FileUtils . readLines ( file , getInputEncoding ( ) ) ; 
dto . title = getTitle ( raw ) ; 
} 
if ( applyFiltering ) for ( String line : FileUtils . readLines ( file , getInputEncoding ( ) ) ) { 
if ( isVariableLine ( line ) ) { 
String key = line . replaceAll ( "(^\\{)|(=.*)" , "" ) ; 
String value = line . replaceAll ( "(^\\{(.*?)=)|(}$)" , "" ) ; 
getLog ( ) . debug ( "Substitute: '" + key + "' -> '" + value + "'" ) ; 
dto . substitutes . put ( key , value ) ; 
} 
} 
String inputFileExtension = FilenameUtils . getExtension ( file . getName ( ) ) ; 
dto . htmlFile = new File ( recursiveInput ? outputDirectory + File . separator + file . getParentFile ( ) . getPath ( ) . substring ( inputDirectory . getPath ( ) . length ( ) ) + File . separator + file . getName ( ) . replaceAll ( "." + inputFileExtension , ".html" ) : outputDirectory + File . separator + file . getName ( ) . replaceAll ( "." + inputFileExtension , ".html" ) ) ; 
getLog ( ) . debug ( "File htmlFile() " + dto . htmlFile ) ; 
markdownDTOs . add ( dto ) ; 
} 
} 
catch ( IOException e ) { 
throw new MojoExecutionException ( "Unable to load file " + e . getMessage ( ) , e ) ; 
} 
return true ; 
} 
} 

public class MdPageGeneratorMojo { 
private String substituteVariables ( String template , String patternString , Map < String , String > variables ) { 
Pattern pattern = Pattern . compile ( patternString ) ; 
Matcher matcher = pattern . matcher ( template ) ; 
StringBuffer buffer = new StringBuffer ( ) ; 
while ( matcher . find ( ) ) if ( variables . containsKey ( matcher . group ( 1 ) ) ) { 
String replacement = variables . get ( matcher . group ( 1 ) ) ; 
matcher . appendReplacement ( buffer , replacement != null ? Matcher . quoteReplacement ( replacement ) : "null" ) ; 
} 
matcher . appendTail ( buffer ) ; 
return buffer . toString ( ) ; 
} 
} 

public class MdPageGeneratorMojo { 
private String getTitle ( List < String > raw ) { 
if ( raw == null ) return defaultTitle ; 
String previousLine = "" ; 
for ( String line : raw ) { 
line = line . trim ( ) ; 
if ( line . startsWith ( "#" ) ) { 
line = line . replace ( "#" , "" ) ; 
return line ; 
} 
if ( ( line . startsWith ( "=" ) && StringUtils . countMatches ( line , "=" ) == previousLine . length ( ) && line . matches ( "^=+$" ) ) || ( line . startsWith ( "-" ) && StringUtils . countMatches ( line , "-" ) == previousLine . length ( ) && line . matches ( "^-+$" ) ) ) return previousLine ; 
previousLine = line ; 
} 
return defaultTitle ; 
} 
} 

public class MdPageGeneratorMojo { 
private String addTitleToHtmlFile ( String html , String title ) { 
if ( html == null ) return html ; 
if ( title != null ) { 
getLog ( ) . debug ( "Setting the title in the HTML file to: " + title ) ; 
return html . replaceFirst ( "titleToken" , title ) ; 
} 
else { 
getLog ( ) . debug ( "Title was null, setting the title in the HTML file to an empty string" ) ; 
return html . replaceFirst ( "titleToken" , "" ) ; 
} 
} 
} 

public class MdPageGeneratorMojo { 
private String replaceVariables ( String initialContent , Map < String , String > variables ) { 
String newContent = initialContent ; 
if ( applyFiltering && newContent != null ) { 
newContent = newContent . replaceAll ( "\\{\\w*=.*}" , "" ) ; 
if ( variables != null ) newContent = substituteVariables ( newContent , "\\$\\{(.+?)\\}" , variables ) ; 
} 
return newContent ; 
} 
} 

public class MdPageGeneratorMojo { 
private String updateRelativePaths ( String html , int folderDepth ) { 
if ( html == null ) return html ; 
getLog ( ) . debug ( "Updating relative paths in html includes (css, js)." ) ; 
return html . replaceAll ( "##SITE_BASE##" , getSiteBasePrefix ( folderDepth ) ) ; 
} 
} 

public class MdPageGeneratorMojo { 
private void copyFiles ( String fromDir , String toDir ) throws MojoExecutionException { 
getLog ( ) . debug ( "fromDir=" + fromDir + "; toDir=" + toDir ) ; 
try { 
File fromDirFile = new File ( fromDir ) ; 
if ( fromDirFile . exists ( ) ) { 
Iterator < File > files = FileUtils . iterateFiles ( new File ( fromDir ) , null , false ) ; 
while ( files . hasNext ( ) ) { 
File file = files . next ( ) ; 
if ( file . exists ( ) ) FileUtils . copyFileToDirectory ( file , new File ( toDir ) ) ; 
else getLog ( ) . error ( "File '" + file . getAbsolutePath ( ) + "' does not exist. Skipping copy" ) ; 
} 
} 
} 
catch ( IOException e ) { 
throw new MojoExecutionException ( "Unable to copy file " + e . getMessage ( ) , e ) ; 
} 
} 
} 

public class CrossfadeDrawerLayout { 
private void overlapViews ( int width ) { 
if ( width == mWidth ) return ; 
mWidth = width ; 
float percentage = calculatePercentage ( width ) ; 
float alpha = percentage / 100 ; 
mSmallView . setAlpha ( 1 ) ; 
mSmallView . setClickable ( false ) ; 
mLargeView . bringToFront ( ) ; 
mLargeView . setAlpha ( alpha ) ; 
mLargeView . setClickable ( true ) ; 
mLargeView . setVisibility ( alpha > 0.01f ? View . VISIBLE : View . GONE ) ; 
if ( mCrossfadeListener != null ) mCrossfadeListener . onCrossfade ( mContainer , calculatePercentage ( width ) , width ) ; 
} 
} 

public class ApiClient { 
private Client buildHttpClient ( boolean debugging ) { 
final ClientConfig clientConfig = new ClientConfig ( ) ; 
clientConfig . register ( MultiPartFeature . class ) ; 
clientConfig . register ( json ) ; 
clientConfig . register ( JacksonFeature . class ) ; 
if ( debugging ) clientConfig . register ( LoggingFilter . class ) ; 
return ClientBuilder . newClient ( clientConfig ) ; 
} 
} 

public class ModelsApi { 
public DataModelUpdateResponse updateDataModel ( DataModel body , Boolean force , String workspaceId ) throws ApiException { 
Object localVarPostBody = body ; 
if ( body == null ) throw new ApiException ( 400 , "Missing the required parameter 'body' when calling updateDataModel" ) ; 
String localVarPath = "/models/dataModel" . replaceAll ( "\\{format\\}" , "json" ) ; 
List < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; 
Map < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; 
localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "force" , force ) ) ; 
localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "workspaceId" , workspaceId ) ) ; 
final String [ ] localVarAccepts = { 
"application/json" } 
; 
final String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; 
final String [ ] localVarContentTypes = { 
"application/json" } 
; 
final String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; 
String [ ] localVarAuthNames = new String [ ] { 
"token" } 
; 
GenericType < DataModelUpdateResponse > localVarReturnType = new GenericType < DataModelUpdateResponse > ( ) { 
} 
; 
return apiClient . invokeAPI ( localVarPath , "PUT" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; 
} 
} 

public class GraphqlApi { 
public GraphQLResult processGraphQLMultipart ( String graphQLRequest , File file ) throws ApiException { 
Object localVarPostBody = null ; 
if ( graphQLRequest == null ) throw new ApiException ( 400 , "Missing the required parameter 'graphQLRequest' when calling processGraphQLMultipart" ) ; 
if ( file == null ) throw new ApiException ( 400 , "Missing the required parameter 'file' when calling processGraphQLMultipart" ) ; 
String localVarPath = "/graphql/upload" . replaceAll ( "\\{format\\}" , "json" ) ; 
List < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; 
Map < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; 
if ( graphQLRequest != null ) localVarFormParams . put ( "graphQLRequest" , graphQLRequest ) ; 
if ( file != null ) localVarFormParams . put ( "file" , file ) ; 
final String [ ] localVarAccepts = { 
"application/json" } 
; 
final String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; 
final String [ ] localVarContentTypes = { 
"multipart/form-data" } 
; 
final String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; 
String [ ] localVarAuthNames = new String [ ] { 
"token" } 
; 
GenericType < GraphQLResult > localVarReturnType = new GenericType < GraphQLResult > ( ) { 
} 
; 
return apiClient . invokeAPI ( localVarPath , "POST" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; 
} 
} 

public class BookmarksApi { 
public BookmarkListResponse getBookmarks ( String bookmarkType , String groupKey , String sharingType ) throws ApiException { 
Object localVarPostBody = null ; 
if ( bookmarkType == null ) throw new ApiException ( 400 , "Missing the required parameter 'bookmarkType' when calling getBookmarks" ) ; 
String localVarPath = "/bookmarks" . replaceAll ( "\\{format\\}" , "json" ) ; 
List < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; 
Map < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; 
Map < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; 
localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "bookmarkType" , bookmarkType ) ) ; 
localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "groupKey" , groupKey ) ) ; 
localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "sharingType" , sharingType ) ) ; 
final String [ ] localVarAccepts = { 
"application/json" } 
; 
final String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; 
final String [ ] localVarContentTypes = { 
"application/json" } 
; 
final String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; 
String [ ] localVarAuthNames = new String [ ] { 
"token" } 
; 
GenericType < BookmarkListResponse > localVarReturnType = new GenericType < BookmarkListResponse > ( ) { 
} 
; 
return apiClient . invokeAPI ( localVarPath , "GET" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; 
} 
} 

public class MarkLogicDatasetGraph { 
public MarkLogicDatasetGraph withRulesets ( SPARQLRuleset ... rulesets ) { 
if ( this . rulesets == null ) this . rulesets = rulesets ; 
else { 
Collection < SPARQLRuleset > collection = new ArrayList < SPARQLRuleset > ( ) ; 
collection . addAll ( Arrays . asList ( this . rulesets ) ) ; 
collection . addAll ( Arrays . asList ( rulesets ) ) ; 
this . rulesets = collection . toArray ( new SPARQLRuleset [ ] { 
} 
) ; 
} 
return this ; 
} 
} 

public class JenaDatabaseClient { 
public void close ( ) { 
if ( writeBuffer != null ) writeBuffer . cancel ( ) ; 
if ( timer != null ) timer . cancel ( ) ; 
client = null ; 
} 
} 

public class JenaDatabaseClient { 
public synchronized InputStreamHandle executeSelect ( SPARQLQueryDefinition qdef , InputStreamHandle handle , Long offset , Long limit ) { 
if ( limit == null ) this . sparqlQueryManager . clearPageLength ( ) ; 
else this . sparqlQueryManager . setPageLength ( limit ) ; 
if ( offset != null ) return this . sparqlQueryManager . executeSelect ( qdef , handle , offset , currentTransaction ) ; 
else return this . sparqlQueryManager . executeSelect ( qdef , handle , currentTransaction ) ; 
} 
} 

public class GMOperation { 
public GMOperation rotate ( final double degrees , final RotationAnnotation annotation ) { 
if ( annotation == null ) throw new IllegalArgumentException ( "Rotation annotation must be defined" ) ; 
final List < String > args = getCmdArgs ( ) ; 
args . add ( "-rotate" ) ; 
args . add ( String . format ( Locale . ENGLISH , "%.1f%s" , degrees , annotation . asAnnotation ( ) ) ) ; 
return this ; 
} 
} 

public class GMOperation { 
public GMOperation gravity ( final Gravity value ) { 
if ( value == null ) throw new IllegalArgumentException ( "Gravity value must be defined" ) ; 
gravity ( value . toString ( ) ) ; 
return this ; 
} 
} 

public class GMOperation { 
public GMOperation font ( final String style , final int size , final String color ) { 
if ( isBlank ( style ) ) throw new IllegalArgumentException ( "Text font style must be defined" ) ; 
if ( isBlank ( color ) ) throw new IllegalArgumentException ( "Text font color must be defined" ) ; 
font ( style ) ; 
pointsize ( size ) ; 
fill ( color ) ; 
return this ; 
} 
} 

public class GMOperation { 
public GMOperation source ( final File file , @ CheckForNull final Integer width , @ CheckForNull final Integer height ) throws IOException { 
if ( file != null && ! file . exists ( ) ) throw new IOException ( "Source file '" + file + "' does not exist" ) ; 
if ( ( width != null ) && ( height != null ) && ( width > 0 ) && ( height > 0 ) ) size ( width , height ) ; 
return addImage ( file ) ; 
} 
} 

public class GMOperation { 
public GMOperation addImage ( final File file ) { 
if ( file == null ) throw new IllegalArgumentException ( "file must be defined" ) ; 
getCmdArgs ( ) . add ( file . getPath ( ) ) ; 
return this ; 
} 
} 

public class Args { 
public static List < String > parse ( Object target , String [ ] args ) { 
List < String > arguments = new ArrayList < String > ( ) ; 
arguments . addAll ( Arrays . asList ( args ) ) ; 
Class < ? > clazz ; 
if ( target instanceof Class ) clazz = ( Class ) target ; 
else { 
clazz = target . getClass ( ) ; 
try { 
BeanInfo info = Introspector . getBeanInfo ( clazz ) ; 
for ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { 
processProperty ( target , pd , arguments ) ; 
} 
} 
catch ( IntrospectionException e ) { 
} 
} 
for ( Class < ? > currentClazz = clazz ; 
currentClazz != null ; 
currentClazz = currentClazz . getSuperclass ( ) ) for ( Field field : currentClazz . getDeclaredFields ( ) ) { 
processField ( target , field , arguments ) ; 
} 
for ( String argument : arguments ) { 
if ( argument . startsWith ( "-" ) ) throw new IllegalArgumentException ( "Invalid argument: " + argument ) ; 
} 
return arguments ; 
} 
} 

public class Args { 
public static void usage ( PrintStream errStream , Object target ) { 
Class < ? > clazz ; 
if ( target instanceof Class ) clazz = ( Class ) target ; 
else clazz = target . getClass ( ) ; 
errStream . println ( "Usage: " + clazz . getName ( ) ) ; 
for ( Class < ? > currentClazz = clazz ; 
currentClazz != null ; 
currentClazz = currentClazz . getSuperclass ( ) ) for ( Field field : currentClazz . getDeclaredFields ( ) ) { 
fieldUsage ( errStream , target , field ) ; 
} 
try { 
BeanInfo info = Introspector . getBeanInfo ( clazz ) ; 
for ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { 
propertyUsage ( errStream , target , pd ) ; 
} 
} 
catch ( IntrospectionException e ) { 
} 
} 
} 

public class UnitConverter { 
public static TimeUnit extractTimeUnitFromString ( String timeString ) { 
timeString = timeString . toLowerCase ( ) ; 
if ( timeString . contains ( "minute" ) ) return TimeUnit . MINUTES ; 
else if ( timeString . contains ( "microsecond" ) ) return TimeUnit . MICROSECONDS ; 
else if ( timeString . contains ( "millisecond" ) ) return TimeUnit . MILLISECONDS ; 
else if ( timeString . contains ( "second" ) ) return TimeUnit . SECONDS ; 
else if ( timeString . contains ( "hour" ) ) return TimeUnit . HOURS ; 
else if ( timeString . toLowerCase ( ) . contains ( "day" ) ) return TimeUnit . DAYS ; 
else return null ; 
} 
} 

public class PropertiesArgs { 
public static void parse ( Object target , Properties arguments ) { 
Class clazz ; 
if ( target instanceof Class ) clazz = ( Class ) target ; 
else clazz = target . getClass ( ) ; 
for ( Field field : clazz . getDeclaredFields ( ) ) { 
processField ( target , field , arguments ) ; 
} 
try { 
BeanInfo info = Introspector . getBeanInfo ( clazz ) ; 
for ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { 
processProperty ( target , pd , arguments ) ; 
} 
} 
catch ( IntrospectionException e ) { 
} 
} 
} 

public class Selector { 
public Selector overlapVerticallyWith ( final SlideElement element , final float minOverlapRatio ) { 
checkNotNull ( element ) ; 
final Rectangle r1 = element . getBounds ( ) ; 
r1 . x = 0 ; 
r1 . width = 1 ; 
elements = Collections2 . filter ( elements , new Predicate < SlideElement > ( ) { 
@ Override public boolean apply ( SlideElement e ) { 
if ( e == element ) return false ; 
if ( r1 . height == 0 ) return false ; 
Rectangle r2 = e . getBounds ( ) ; 
r2 . x = 0 ; 
r2 . width = 1 ; 
Rectangle intersection = r1 . intersection ( r2 ) ; 
float yOverlapRatio = 1f * intersection . height / r1 . height ; 
return yOverlapRatio > minOverlapRatio ; 
} 
} 
) ; 
return this ; 
} 
} 

public class SqsExecutor { 
public Object executeOutboundOperation ( final Message < ? > message ) { 
try { 
String serializedMessage = messageMarshaller . serialize ( message ) ; 
if ( queue == null ) { 
SendMessageRequest request = new SendMessageRequest ( queueUrl , serializedMessage ) ; 
SendMessageResult result = sqsClient . sendMessage ( request ) ; 
log . debug ( "Message sent, Id:" + result . getMessageId ( ) ) ; 
} 
else queue . add ( serializedMessage ) ; 
} 
catch ( MessageMarshallerException e ) { 
log . error ( e . getMessage ( ) , e ) ; 
throw new MessagingException ( e . getMessage ( ) , e . getCause ( ) ) ; 
} 
return message . getPayload ( ) ; 
} 
} 

public class SnsExecutor { 
public Object executeOutboundOperation ( final Message < ? > message ) { 
try { 
String serializedMessage = messageMarshaller . serialize ( message ) ; 
if ( snsTestProxy == null ) { 
PublishRequest request = new PublishRequest ( ) ; 
PublishResult result = client . publish ( request . withTopicArn ( topicArn ) . withMessage ( serializedMessage ) ) ; 
log . debug ( "Published message to topic: " + result . getMessageId ( ) ) ; 
} 
else snsTestProxy . dispatchMessage ( serializedMessage ) ; 
} 
catch ( MessageMarshallerException e ) { 
log . error ( e . getMessage ( ) , e ) ; 
throw new MessagingException ( e . getMessage ( ) , e . getCause ( ) ) ; 
} 
return message . getPayload ( ) ; 
} 
} 

public class JNE { 
synchronized static public File requireFile ( String name , Options options ) throws IOException { 
File file = findFile ( name , options ) ; 
if ( file == null ) throw new ResourceNotFoundException ( "Resource file " + name + " not found" ) ; 
return file ; 
} 
} 

public class JNE { 
static private File getOrCreateTempDirectory ( boolean deleteOnExit ) throws ExtractException { 
if ( ( TEMP_DIRECTORY != null ) && TEMP_DIRECTORY . exists ( ) ) return TEMP_DIRECTORY ; 
try { 
Path baseDir = Paths . get ( System . getProperty ( "java.io.tmpdir" ) ) ; 
Path tempDirectory = baseDir . resolve ( "jne." + UUID . randomUUID ( ) . toString ( ) ) ; 
Files . createDirectories ( tempDirectory ) ; 
File tempDirectoryAsFile = tempDirectory . toFile ( ) ; 
if ( deleteOnExit ) tempDirectoryAsFile . deleteOnExit ( ) ; 
TEMP_DIRECTORY = tempDirectoryAsFile ; 
return TEMP_DIRECTORY ; 
} 
catch ( IOException e ) { 
throw new ExtractException ( "Unable to create temporary dir" , e ) ; 
} 
} 
} 

public class StenoSerializationHelper { 
public static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { 
if ( keys != null ) { 
final int contextValuesLength = values == null ? 0 : values . size ( ) ; 
for ( int i = 0 ; 
i < keys . size ( ) ; 
++ i ) { 
final String key = keys . get ( i ) ; 
if ( i >= contextValuesLength ) jsonGenerator . writeObjectField ( key , null ) ; 
else { 
final Object value = values . get ( i ) ; 
if ( isSimpleType ( value ) ) jsonGenerator . writeObjectField ( key , value ) ; 
else { 
jsonGenerator . writeFieldName ( key ) ; 
objectMapper . writeValue ( jsonGenerator , value ) ; 
} 
} 
} 
} 
} 
} 

public class AbstractStenoCallerConverter { 
protected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { 
final StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; 
if ( callerData != null ) for ( int i = 0 ; 
i < callerData . length ; 
++ i ) { 
final String callerClassName = callerData [ i ] . getClassName ( ) ; 
if ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) return callerData [ i ] ; 
} 
return null ; 
} 
} 

public class SafeSerializationHelper { 
public static void safeEncodeValue ( final StringBuilder encoder , @ Nullable final Object value ) { 
if ( value == null ) encoder . append ( "null" ) ; 
else if ( value instanceof Map ) safeEncodeMap ( encoder , ( Map < ? , ? > ) value ) ; 
else if ( value instanceof List ) safeEncodeList ( encoder , ( List < ? > ) value ) ; 
else if ( value . getClass ( ) . isArray ( ) ) safeEncodeArray ( encoder , value ) ; 
else if ( value instanceof LogValueMapFactory . LogValueMap ) safeEncodeLogValueMap ( encoder , ( LogValueMapFactory . LogValueMap ) value ) ; 
else if ( value instanceof Throwable ) safeEncodeThrowable ( encoder , ( Throwable ) value ) ; 
else if ( StenoSerializationHelper . isSimpleType ( value ) ) if ( value instanceof Boolean ) encoder . append ( BooleanNode . valueOf ( ( Boolean ) value ) . toString ( ) ) ; 
else if ( value instanceof Double ) encoder . append ( DoubleNode . valueOf ( ( Double ) value ) . toString ( ) ) ; 
else if ( value instanceof Float ) encoder . append ( FloatNode . valueOf ( ( Float ) value ) . toString ( ) ) ; 
else if ( value instanceof Long ) encoder . append ( LongNode . valueOf ( ( Long ) value ) . toString ( ) ) ; 
else if ( value instanceof Integer ) encoder . append ( IntNode . valueOf ( ( Integer ) value ) . toString ( ) ) ; 
else encoder . append ( new TextNode ( value . toString ( ) ) . toString ( ) ) ; 
else safeEncodeValue ( encoder , LogReferenceOnly . of ( value ) . toLogValue ( ) ) ; 
} 
} 

public class AbsObjectPool { 
protected void checkMappings ( int arrayPosition ) { 
final int index = positions . indexOfValue ( arrayPosition ) ; 
if ( index >= 0 ) positions . removeAt ( index ) ; 
} 
} 

public class SaveAttrsUtility { 
public static String parseSaveAttr ( final Cell cell , final Map < String , String > saveCommentsMap ) { 
if ( cell != null ) { 
String key = cell . getSheet ( ) . getSheetName ( ) + "!" + CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , cell . getRowIndex ( ) ) ; 
String saveAttr = null ; 
if ( saveCommentsMap != null ) saveAttr = ParserUtility . getStringBetweenBracket ( saveCommentsMap . get ( key ) ) ; 
if ( ( saveAttr == null ) && ( cell . getCellTypeEnum ( ) == CellType . STRING ) ) saveAttr = SaveAttrsUtility . parseSaveAttrString ( cell . getStringCellValue ( ) ) ; 
if ( ( saveAttr != null ) && ( ! saveAttr . isEmpty ( ) ) ) return TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + "=" + saveAttr + "," ; 
} 
return "" ; 
} 
} 

public class SaveAttrsUtility { 
public static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { 
if ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) return ; 
int ipos = fullSaveAttr . indexOf ( '=' ) ; 
if ( ipos > 0 ) { 
String columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; 
String saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; 
Cell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; 
if ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) CommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; 
} 
} 
} 

public class SaveAttrsUtility { 
public static String parseSaveAttrString ( final String strValue ) { 
if ( strValue != null ) { 
int first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; 
int last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; 
int end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; 
if ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) return strValue . substring ( first + 2 , end ) ; 
} 
return "" ; 
} 
} 

public class SaveAttrsUtility { 
public static String getSaveAttrListFromRow ( final Row row ) { 
if ( row != null ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; 
if ( cell != null ) { 
String str = cell . getStringCellValue ( ) ; 
if ( ( str != null ) && ( ! str . isEmpty ( ) ) ) return str ; 
} 
} 
return null ; 
} 
} 

public class SaveAttrsUtility { 
public static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { 
if ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { 
String str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + "=" ; 
int istart = saveAttrs . indexOf ( str ) ; 
if ( istart >= 0 ) { 
int iend = saveAttrs . indexOf ( ',' , istart ) ; 
if ( iend > istart ) return saveAttrs . substring ( istart + str . length ( ) , iend ) ; 
} 
} 
return null ; 
} 
} 

public class SaveAttrsUtility { 
public static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { 
for ( Row row : sheet ) { 
int rowIndex = row . getRowNum ( ) ; 
if ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) setSaveAttrsForRow ( row , saveCommentsMap ) ; 
} 
} 
} 

public class SaveAttrsUtility { 
public static void setSaveAttrsForRow ( final Row row , final Map < String , String > saveCommentsMap ) { 
StringBuilder saveAttr = new StringBuilder ( ) ; 
for ( Cell cell : row ) { 
String sAttr = parseSaveAttr ( cell , saveCommentsMap ) ; 
if ( ! sAttr . isEmpty ( ) ) saveAttr . append ( sAttr ) ; 
} 
if ( saveAttr . length ( ) > 0 ) SaveAttrsUtility . setSaveObjectsInHiddenColumn ( row , saveAttr . toString ( ) ) ; 
} 
} 

public class SaveAttrsUtility { 
public static String prepareContextAndAttrsForCell ( Cell poiCell , String fullName , CellHelper cellHelper ) { 
if ( fullName == null ) return null ; 
String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( poiCell . getRow ( ) ) ; 
if ( saveAttrList != null ) { 
String saveAttr = SaveAttrsUtility . getSaveAttrFromList ( poiCell . getColumnIndex ( ) , saveAttrList ) ; 
if ( saveAttr != null ) { 
cellHelper . restoreDataContext ( fullName ) ; 
return saveAttr ; 
} 
} 
return null ; 
} 
} 

public class TieSheetNumberConverter { 
private String fmtNumber ( final double d ) { 
if ( Double . compare ( d % 1 , 0 ) == 0 ) return String . format ( "%d" , ( int ) d ) ; 
else return String . format ( "%.2f" , d ) ; 
} 
} 

public class TieWebSheetBean { 
public XSSFEvaluationWorkbook getWbWrapper ( ) { 
if ( ( this . wbWrapper == null ) && ( this . getWb ( ) != null ) ) this . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) this . getWb ( ) ) ; 
return wbWrapper ; 
} 
} 

public class TieWebSheetBean { 
public FormulaEvaluator getFormulaEvaluator ( ) { 
if ( ( this . formulaEvaluator == null ) && ( this . getWb ( ) != null ) ) this . formulaEvaluator = this . getWb ( ) . getCreationHelper ( ) . createFormulaEvaluator ( ) ; 
return formulaEvaluator ; 
} 
} 

public class TieWebSheetBean { 
public void reCalcMaxColCounts ( ) { 
if ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { 
this . maxColCounts = 0 ; 
return ; 
} 
int maxColumns = 0 ; 
for ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { 
int counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; 
if ( maxColumns < counts ) maxColumns = counts ; 
} 
this . maxColCounts = maxColumns ; 
} 
} 

public class TieWebSheetBean { 
public SheetConfiguration getCurrentSheetConfig ( ) { 
String currentTabName = this . getCurrent ( ) . getCurrentTabName ( ) ; 
if ( currentTabName == null ) return null ; 
return this . getSheetConfigMap ( ) . get ( currentTabName ) ; 
} 
} 

public class DateTimeCustomConverter { 
private Locale getLocale ( final FacesContext context , final UIComponent component ) { 
String localeStr = ( String ) component . getAttributes ( ) . get ( TieConstants . COMPONENT_ATTR_LOCALE ) ; 
if ( localeStr == null ) return context . getViewRoot ( ) . getLocale ( ) ; 
return Locale . forLanguageTag ( localeStr ) ; 
} 
} 

public class TieWebSheetBeanHelper { 
public final CellHelper getCellHelper ( ) { 
if ( ( this . cellHelper == null ) && ( this . parent != null ) ) this . cellHelper = new CellHelper ( parent ) ; 
return cellHelper ; 
} 
} 

public class TieWebSheetBeanHelper { 
public final PicturesHelper getPicHelper ( ) { 
if ( ( this . picHelper == null ) && ( this . parent != null ) ) this . picHelper = new PicturesHelper ( parent ) ; 
return picHelper ; 
} 
} 

public class TieWebSheetBeanHelper { 
public final ValidationHandler getValidationHandler ( ) { 
if ( ( this . validationHandler == null ) && ( this . parent != null ) ) this . validationHandler = new ValidationHandler ( parent ) ; 
return validationHandler ; 
} 
} 

public class TieWebSheetBeanHelper { 
public final ChartHelper getChartHelper ( ) { 
if ( ( this . chartHelper == null ) && ( this . parent != null ) ) this . chartHelper = new ChartHelper ( parent ) ; 
return chartHelper ; 
} 
} 

public class ShiftFormulaUtility { 
private static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { 
byte originalOperandClass = - 1 ; 
if ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) originalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; 
int currentRow ; 
currentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; 
if ( ( currentRow >= 0 ) && shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) return convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; 
if ( ( ptg instanceof AttrPtg ) && ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) ) { 
AttrPtg newPtg = ( AttrPtg ) ptg ; 
if ( newPtg . isSum ( ) ) { 
FuncVarPtg fptg = FuncVarPtg . create ( "sum" , shiftFormulaRef . getFormulaChanged ( ) ) ; 
return singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; 
} 
} 
return singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; 
} 
} 

public class ShiftFormulaUtility { 
private static Ptg [ ] convertPtgForWatchList ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg , final byte originalOperandClass , final int currentRow ) { 
List < SerialRow > rowlist = getRowsList ( currentRow , shiftFormulaRef . getCurrentRowsMappingList ( ) ) ; 
if ( ( rowlist == null ) || ( rowlist . isEmpty ( ) ) ) return singlePtg ( ptg , originalOperandClass , - 1 ) ; 
shiftFormulaRef . setFormulaChanged ( 1 ) ; 
if ( ( rowlist . size ( ) == 1 ) || ( ( position + 1 ) >= ptgs . length ) || ! ( ptgs [ position + 1 ] instanceof ParenthesisPtg ) ) return singlePtg ( fixupRefRelativeRowOneToOne ( ptg , rowlist . get ( 0 ) . getRow ( ) ) , originalOperandClass , - 1 ) ; 
shiftFormulaRef . setFormulaChanged ( rowlist . size ( ) ) ; 
return fixupRefRelativeRowOneToMany ( ptg , originalOperandClass , rowlist , ptgs , position ) ; 
} 
} 

public class ShiftFormulaUtility { 
private static Ptg [ ] singlePtg ( final Object ptg , final byte originalOperandClass , final int formulaChanged ) { 
Ptg [ ] newPtg = new Ptg [ 1 ] ; 
if ( originalOperandClass != ( - 1 ) ) ( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; 
Object ptgAfter = ptg ; 
if ( ptg instanceof FuncVarPtg ) { 
FuncVarPtg fptg = ( FuncVarPtg ) ptg ; 
if ( ( formulaChanged > 0 ) && ( fptg . getNumberOfOperands ( ) != formulaChanged ) ) ptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , formulaChanged ) ; 
} 
newPtg [ 0 ] = ( Ptg ) ptgAfter ; 
return newPtg ; 
} 
} 

public class ShiftFormulaUtility { 
private static List < SerialRow > getRowsList ( final int currentRow , final List < RowsMapping > currentRowsMappingList ) { 
List < SerialRow > all = null ; 
int size = currentRowsMappingList . size ( ) ; 
for ( RowsMapping rowsmapping : currentRowsMappingList ) { 
List < SerialRow > current = rowsmapping . get ( currentRow ) ; 
if ( current != null ) { 
if ( size == 1 ) return current ; 
all = assembleRowsListFromRowsMapping ( all , current ) ; 
} 
} 
return all ; 
} 
} 

public class ShiftFormulaUtility { 
private static List < SerialRow > assembleRowsListFromRowsMapping ( final List < SerialRow > all , final List < SerialRow > current ) { 
List < SerialRow > list ; 
if ( all == null ) { 
list = new ArrayList < > ( ) ; 
list . addAll ( current ) ; 
} 
else { 
list = all ; 
for ( SerialRow row : current ) { 
if ( ! all . contains ( row ) ) list . add ( row ) ; 
} 
} 
return list ; 
} 
} 

public class ShiftFormulaUtility { 
protected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { 
if ( ptg instanceof RefPtgBase ) if ( ptg instanceof Ref3DPxg ) { 
Ref3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; 
Ref3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; 
new3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; 
new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; 
new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; 
return new3dpxg ; 
} 
else { 
RefPtgBase refPtgBase = ( RefPtgBase ) ptg ; 
return new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; 
} 
else if ( ptg instanceof Area3DPxg ) { 
Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; 
Area3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; 
new3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; 
new3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; 
new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; 
int shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; 
new3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; 
new3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; 
new3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; 
new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; 
return new3dpxg ; 
} 
else { 
AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; 
int shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; 
return new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; 
} 
} 
} 

public class ShiftFormulaUtility { 
private static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { 
RefPtgBase refPtg = ( RefPtgBase ) ptg ; 
int unitSize = 1 ; 
if ( includeParenthesis ) unitSize = 2 ; 
for ( int i = 0 ; 
i < rowList . size ( ) ; 
i ++ ) { 
Row row = rowList . get ( i ) . getRow ( ) ; 
if ( refPtg instanceof Ref3DPxg ) { 
Ref3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; 
Ref3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; 
new3dpxg . setClass ( originalOperandClass ) ; 
new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; 
new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; 
newPtg [ i * unitSize ] = new3dpxg ; 
} 
else { 
RefPtgBase refPtgBase = refPtg ; 
newPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; 
} 
if ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; 
} 
} 
} 

public class ShiftFormulaUtility { 
private static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { 
AreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; 
int originFirstRow = areaPtg . getFirstRow ( ) ; 
int originLastRow = areaPtg . getLastRow ( ) ; 
int unitSize = 2 ; 
for ( int i = 0 ; 
i < rowList . size ( ) ; 
i ++ ) { 
Row row = rowList . get ( i ) . getRow ( ) ; 
int shiftRow = row . getRowNum ( ) - originFirstRow ; 
if ( ptg instanceof Area3DPxg ) { 
Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; 
Area3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; 
new3dpxg . setClass ( originalOperandClass ) ; 
new3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; 
new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; 
new3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; 
new3dpxg . setLastRow ( originLastRow + shiftRow ) ; 
new3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; 
new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; 
newPtg [ i * unitSize ] = new3dpxg ; 
} 
else { 
AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; 
newPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; 
} 
if ( i < ( rowList . size ( ) - 1 ) ) newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; 
} 
} 
} 

public class ColorUtility { 
public static XColor getBgColor ( final CTPlotArea ctPlot , final ThemesTable themeTable ) { 
CTSolidColorFillProperties colorFill = null ; 
try { 
colorFill = ctPlot . getSpPr ( ) . getSolidFill ( ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "No entry in bgcolor for solidFill" , ex ) ; 
} 
XColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; 
if ( xcolor != null ) return xcolor ; 
else return new XColor ( new XSSFColor ( Color . WHITE ) ) ; 
} 
} 

public class ColorUtility { 
public static XColor geColorFromSpPr ( final int index , final CTShapeProperties ctSpPr , final ThemesTable themeTable , final boolean isLineColor ) { 
CTSolidColorFillProperties colorFill = null ; 
try { 
if ( isLineColor ) colorFill = ctSpPr . getLn ( ) . getSolidFill ( ) ; 
else colorFill = ctSpPr . getSolidFill ( ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "No entry for solidFill" , ex ) ; 
} 
XColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; 
if ( xcolor != null ) return xcolor ; 
else return getXColorWithAutomaticFill ( index , themeTable ) ; 
} 
} 

public class ColorUtility { 
private static XColor findAutomaticFillColor ( final ThemesTable themeTable , final CTSolidColorFillProperties colorFill ) { 
if ( colorFill == null ) return null ; 
CTSchemeColor ctsColor = colorFill . getSchemeClr ( ) ; 
if ( ctsColor != null ) return getXColorFromSchemeClr ( ctsColor , themeTable ) ; 
else { 
CTSRgbColor ctrColor = colorFill . getSrgbClr ( ) ; 
if ( ctrColor != null ) return getXColorFromRgbClr ( ctrColor ) ; 
} 
return null ; 
} 
} 

public class ColorUtility { 
private static XColor getXColorFromSchemeClr ( final CTSchemeColor ctsColor , final ThemesTable themeTable ) { 
if ( ctsColor . getVal ( ) != null ) return getXColorWithSchema ( ctsColor . getVal ( ) . toString ( ) , 0 , ctsColor , themeTable ) ; 
return null ; 
} 
} 

public class ColorUtility { 
private static XColor getXColorWithAutomaticFill ( final int index , final ThemesTable themeTable ) { 
int reminder = ( index + 1 ) % AUTOCOLORSIZE ; 
if ( reminder == 0 ) reminder = AUTOCOLORSIZE ; 
String schema = AUTOCOLORNAME + reminder ; 
double tint = getAutomaticTint ( index ) ; 
return getXColorWithSchema ( schema , tint , null , themeTable ) ; 
} 
} 

public class ColorUtility { 
public static short [ ] getTripletFromXSSFColor ( final XSSFColor xssfColor ) { 
short [ ] rgbfix = { 
RGB8BITS , RGB8BITS , RGB8BITS } 
; 
if ( xssfColor != null ) { 
byte [ ] rgb = xssfColor . getRGBWithTint ( ) ; 
if ( rgb == null ) rgb = xssfColor . getRGB ( ) ; 
rgbfix [ 0 ] = ( short ) ( ( rgb [ 0 ] < 0 ) ? ( rgb [ 0 ] + RGB8BITS ) : rgb [ 0 ] ) ; 
rgbfix [ 1 ] = ( short ) ( ( rgb [ 1 ] < 0 ) ? ( rgb [ 1 ] + RGB8BITS ) : rgb [ 1 ] ) ; 
rgbfix [ 2 ] = ( short ) ( ( rgb [ 2 ] < 0 ) ? ( rgb [ 2 ] + RGB8BITS ) : rgb [ 2 ] ) ; 
} 
return rgbfix ; 
} 
} 

public class ColorUtility { 
static String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { 
String style = "" ; 
if ( poiCell instanceof HSSFCell ) { 
int bkColorIndex = cellStyle . getFillForegroundColor ( ) ; 
HSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; 
if ( color != null ) { 
HSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; 
HSSFColor color2 = palette . getColor ( bkColorIndex ) ; 
if ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) color = color2 ; 
style = "background-color:rgb(" + FacesUtility . strJoin ( color . getTriplet ( ) , "," ) + ");" ; 
} 
} 
else if ( poiCell instanceof XSSFCell ) { 
XSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; 
if ( color != null ) style = "background-color:rgb(" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , "," ) + ");" ; 
} 
return style ; 
} 
} 

public class CellControlsUtility { 
private static String findComponentNameFromClass ( final UIComponent component ) { 
String cname = component . getClass ( ) . getSimpleName ( ) ; 
if ( supportComponents . contains ( cname ) ) return cname ; 
return null ; 
} 
} 

public class CellControlsUtility { 
public static void populateAttributes ( final UIComponent component , final FacesCell fcell , final Map < String , Map < String , String > > defaultControlMap ) { 
List < CellFormAttributes > inputAttrs = fcell . getInputAttrs ( ) ; 
String cname = findComponentNameFromClass ( component ) ; 
if ( cname == null ) return ; 
Map < String , String > defaultMap = defaultControlMap . get ( cname ) ; 
if ( defaultMap == null ) { 
defaultMap = new HashMap < > ( ) ; 
defaultControlMap . put ( cname , defaultMap ) ; 
} 
for ( Map . Entry < String , String > entry : defaultMap . entrySet ( ) ) { 
setObjectProperty ( component , entry . getKey ( ) , entry . getValue ( ) , true ) ; 
} 
for ( CellFormAttributes attr : inputAttrs ) { 
String propertyName = attr . getType ( ) ; 
String propertyValue = attr . getValue ( ) ; 
if ( ! defaultMap . containsKey ( propertyName ) ) { 
String defaultValue = getObjectPropertyValue ( component , propertyName , true ) ; 
defaultMap . put ( propertyName , defaultValue ) ; 
} 
setObjectProperty ( component , propertyName , propertyValue , true ) ; 
} 
} 
} 

public class CellControlsUtility { 
public static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { 
try { 
String methodName = "set" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; 
AttributesType parameterType = matchParaMeterOfMethod ( obj , methodName ) ; 
if ( parameterType != null ) { 
Method method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { 
parameterType . clazz } 
) ; 
method . invoke ( obj , convertToObject ( parameterType , propertyValue ) ) ; 
} 
} 
catch ( Exception e ) { 
String msg = "failed to set property '" + propertyName + "' to value '" + propertyValue + "' for object " + obj ; 
if ( ignoreNonExisting ) LOG . log ( Level . FINE , msg , e ) ; 
else { 
LOG . warning ( msg ) ; 
throw new IllegalArgumentException ( e ) ; 
} 
} 
} 
} 

public class CellControlsUtility { 
public static String getObjectPropertyValue ( final Object obj , final String propertyName , final boolean ignoreNonExisting ) { 
try { 
Method method = obj . getClass ( ) . getMethod ( "get" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ) ; 
return ( String ) method . invoke ( obj ) ; 
} 
catch ( Exception e ) { 
String msg = "failed to get property '" + propertyName + "' for object " + obj ; 
if ( ignoreNonExisting ) LOG . log ( Level . FINE , msg , e ) ; 
else { 
LOG . warning ( msg ) ; 
throw new IllegalArgumentException ( e ) ; 
} 
} 
return null ; 
} 
} 

public class CellControlsUtility { 
public static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { 
int rowIndex = originRowIndex ; 
if ( rowIndex < 0 ) rowIndex = poiCell . getRowIndex ( ) ; 
String skey = poiCell . getSheet ( ) . getSheetName ( ) + "!" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; 
Map < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( "$$" ) ; 
if ( commentMap != null ) { 
String comment = commentMap . get ( skey ) ; 
if ( comment != null ) CommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; 
} 
String widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; 
if ( widgetType != null ) { 
fcell . setControl ( widgetType . toLowerCase ( ) ) ; 
fcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; 
fcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; 
fcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; 
} 
} 
} 

public class PicturesHelper { 
public final void setupFacesCellPictureCharts ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { 
if ( parent . getPicturesMap ( ) != null ) setupFacesCellPicture ( sheet1 , fcell , cell , fId ) ; 
if ( parent . getCharsData ( ) . getChartsMap ( ) != null ) setupFacesCellCharts ( sheet1 , fcell , cell , fId ) ; 
} 
} 

public class ChartHelper { 
private void initChartsMap ( final Workbook wb ) { 
try { 
if ( wb instanceof XSSFWorkbook ) initXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "getChartsMap Error Exception = " + e . getLocalizedMessage ( ) , e ) ; 
} 
} 
} 

public class ChartHelper { 
private String getPieTitle ( final ChartData chartData ) { 
for ( ChartSeries chartSeries : chartData . getSeriesList ( ) ) { 
if ( chartSeries != null ) return getParsedCellValue ( chartSeries . getSeriesLabel ( ) ) ; 
} 
return "" ; 
} 
} 

public class ChartHelper { 
public final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { 
if ( chart != null && style != null ) { 
BasicStroke stroke = ChartUtility . toStroke ( style ) ; 
Plot plot = chart . getPlot ( ) ; 
if ( plot instanceof CategoryPlot ) { 
CategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; 
CategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; 
try { 
cir . setSeriesStroke ( seriesIndex , stroke ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "Error setting style '" + style + "' for series '" + Integer . toString ( seriesIndex ) + "' of chart '" + chart . toString ( ) + "': " + e . getLocalizedMessage ( ) , e ) ; 
} 
} 
else if ( plot instanceof XYPlot ) { 
XYPlot xyPlot = chart . getXYPlot ( ) ; 
XYItemRenderer xyir = xyPlot . getRenderer ( ) ; 
try { 
xyir . setSeriesStroke ( seriesIndex , stroke ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "Error setting style '" + style + "' for series '" + Integer . toString ( seriesIndex ) + "' of chart '" + chart . toString ( ) + "': " + e . getLocalizedMessage ( ) , e ) ; 
} 
} 
else LOG . log ( Level . FINE , "setSeriesColor() unsupported plot: {}" , plot . toString ( ) ) ; 
} 
} 
} 

public class ChartHelper { 
private void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { 
initAnchorsMap ( wb , chartsData ) ; 
Map < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; 
Map < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; 
Map < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; 
chartMap . clear ( ) ; 
chartDataMap . clear ( ) ; 
for ( int i = 0 ; 
i < wb . getNumberOfSheets ( ) ; 
i ++ ) { 
XSSFSheet sheet = wb . getSheetAt ( i ) ; 
XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; 
List < XSSFChart > charts = drawing . getCharts ( ) ; 
if ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) for ( XSSFChart chart : charts ) { 
generateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; 
} 
} 
} 
} 

public class ChartHelper { 
private String getChartIdFromParent ( final XSSFChart chart , final String sheetName ) { 
if ( chart . getParent ( ) != null ) for ( RelationPart rp : chart . getParent ( ) . getRelationParts ( ) ) { 
if ( rp . getDocumentPart ( ) == chart ) return sheetName + "!" + rp . getRelationship ( ) . getId ( ) ; 
} 
return null ; 
} 
} 

public class ChartHelper { 
private void initAnchorsMap ( final Workbook wb , final ChartsData chartsData ) { 
try { 
if ( wb instanceof XSSFWorkbook ) ChartUtility . initXSSFAnchorsMap ( ( XSSFWorkbook ) wb , chartsData ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "Web Form getAnchorsMap Error Exception = " + e . getLocalizedMessage ( ) , e ) ; 
} 
} 
} 

public class ConfigurationUtility { 
@ SuppressWarnings ( "rawtypes" ) public static Collection transformToCollectionObject ( final ExpressionEngine engine , final String collectionName , final Map < String , Object > context ) { 
Object collectionObject = engine . evaluate ( collectionName , context ) ; 
if ( ! ( collectionObject instanceof Collection ) ) throw new EvaluationException ( collectionName + " expression is not a collection" ) ; 
return ( Collection ) collectionObject ; 
} 
} 

public class ConfigurationUtility { 
public static String getFullNameFromRow ( final Row row ) { 
if ( row != null ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; 
if ( cell != null ) return cell . getStringCellValue ( ) ; 
} 
return null ; 
} 
} 

public class ConfigurationUtility { 
public static void reBuildUpperLevelFormula ( final ConfigBuildRef configBuildRef , final String actionFullName ) { 
Map < Cell , String > cachedMap = configBuildRef . getCachedCells ( ) ; 
Map < String , List < RowsMapping > > rowsMap = new HashMap < > ( ) ; 
for ( Map . Entry < Cell , String > entry : cachedMap . entrySet ( ) ) { 
Cell cell = entry . getKey ( ) ; 
String originFormula = entry . getValue ( ) ; 
if ( originFormula != null ) setupUpperLevelFormula ( cell , originFormula , actionFullName , rowsMap , configBuildRef ) ; 
} 
} 
} 

public class ConfigurationUtility { 
private static void setupUpperLevelFormula ( final Cell cell , final String originFormula , final String actionFullName , final Map < String , List < RowsMapping > > rowsMap , final ConfigBuildRef configBuildRef ) { 
String fullName = getFullNameFromRow ( cell . getRow ( ) ) ; 
if ( actionFullName . startsWith ( fullName + ":" ) ) { 
List < RowsMapping > currentRowsMappingList = rowsMap . get ( fullName ) ; 
if ( currentRowsMappingList == null ) { 
currentRowsMappingList = gatherRowsMappingByFullName ( configBuildRef , fullName ) ; 
rowsMap . put ( fullName , currentRowsMappingList ) ; 
} 
ShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef ( configBuildRef . getWatchList ( ) , currentRowsMappingList ) ; 
shiftFormulaRef . setFormulaChanged ( 0 ) ; 
buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , originFormula ) ; 
if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; 
} 
} 
} 

public class ConfigurationUtility { 
public static void buildCellFormulaForShiftedRows ( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final Cell cell , final String originFormula ) { 
if ( ( shiftFormulaRef . getWatchList ( ) != null ) && ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { 
Ptg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; 
Ptg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; 
if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) cell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; 
} 
} 
} 

public class ConfigurationUtility { 
public static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { 
String [ ] parts = addedFullName . split ( ":" ) ; 
StringBuilder fname = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < ( parts . length - 1 ) ; 
i ++ ) { 
if ( i == 0 ) fname . append ( parts [ i ] ) ; 
else fname . append ( ":" ) . append ( parts [ i ] ) ; 
String sname = fname . toString ( ) ; 
shiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; 
} 
} 
} 

public class ConfigurationUtility { 
public static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { 
String searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; 
Sheet sheet = configBuildRef . getSheet ( ) ; 
for ( int i = startRowIndex ; 
i <= sheet . getLastRowNum ( ) ; 
i ++ ) { 
Row row = sheet . getRow ( i ) ; 
String fname = getFullNameFromRow ( row ) ; 
if ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { 
int sindex = fname . indexOf ( searchName ) ; 
String snum = fname . substring ( sindex + searchName . length ( ) ) ; 
int sufindex = snum . indexOf ( ':' ) ; 
String suffix = "" ; 
if ( sufindex > 0 ) { 
snum = snum . substring ( 0 , sufindex ) ; 
suffix = ":" ; 
} 
int increaseNum = Integer . parseInt ( snum ) + steps ; 
String realFullName = fname . substring ( sindex ) ; 
String changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; 
if ( changeMap . get ( realFullName ) == null ) changeMap . put ( realFullName , changeName . substring ( sindex ) ) ; 
setFullNameInHiddenColumn ( row , changeName ) ; 
} 
else return ; 
} 
} 
} 

public class ConfigurationUtility { 
public static int getOriginalRowNumInHiddenColumn ( final Row row ) { 
if ( row != null ) { 
Cell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
String rowNum = cell . getStringCellValue ( ) ; 
try { 
if ( ( rowNum != null ) && ( ! rowNum . isEmpty ( ) ) && ( WebSheetUtility . isNumeric ( rowNum ) ) ) return Integer . parseInt ( rowNum ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "getOriginalRowNumInHiddenColumn rowNum = " + rowNum + " error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
return - 1 ; 
} 
} 

public class ConfigurationUtility { 
public static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { 
StringBuilder fullName = new StringBuilder ( ) ; 
List < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; 
for ( int i = 1 ; 
i < parts . length - 1 ; 
i ++ ) { 
String part = parts [ i ] ; 
if ( fullName . length ( ) == 0 ) fullName . append ( part ) ; 
else fullName . append ( ":" + part ) ; 
if ( fullName . length ( ) > 0 ) { 
ConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; 
if ( rangeAttrs != null ) rowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; 
} 
} 
return rowsMappingList ; 
} 
} 

public class ConfigurationUtility { 
public static List < RowsMapping > findChildRowsMappingFromShiftMap ( final String fullName , final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { 
List < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; 
NavigableMap < String , ConfigRangeAttrs > tailmap = shiftMap . tailMap ( fullName , false ) ; 
for ( Map . Entry < String , ConfigRangeAttrs > entry : tailmap . entrySet ( ) ) { 
String key = entry . getKey ( ) ; 
if ( key . startsWith ( fullName ) ) rowsMappingList . add ( entry . getValue ( ) . getUnitRowsMapping ( ) ) ; 
else break ; 
} 
return rowsMappingList ; 
} 
} 

public class ConfigurationUtility { 
@ SuppressWarnings ( "rawtypes" ) public static Object findItemInCollection ( final Collection collection , final int index ) { 
if ( index >= 0 ) { 
if ( collection instanceof List ) { 
List list = ( List ) collection ; 
return list . get ( index ) ; 
} 
int i = 0 ; 
for ( Object object : collection ) { 
if ( i == index ) return object ; 
i ++ ; 
} 
} 
return null ; 
} 
} 

public class ConfigurationUtility { 
public static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) for ( int i = 0 ; 
i < sourceConfigRange . getCommandList ( ) . size ( ) ; 
i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
if ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) return false ; 
} 
return true ; 
} 
} 

public class ConfigurationUtility { 
public static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) for ( int i = 0 ; 
i < sourceConfigRange . getCommandList ( ) . size ( ) ; 
i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
int rowIndex = row . getRowNum ( ) ; 
if ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) return false ; 
} 
return true ; 
} 
} 

public class ConfigurationUtility { 
public static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { 
int ibegin = 0 ; 
int ifind ; 
int inameEnd ; 
String tempStr ; 
String findStr ; 
String replaceStr ; 
String returnStr = attrValue ; 
while ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ) { 
inameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; 
if ( inameEnd > 0 ) findStr = attrValue . substring ( ifind , inameEnd ) ; 
else findStr = attrValue . substring ( ifind ) ; 
if ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) tempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; 
else tempStr = findStr ; 
replaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; 
if ( replaceStr == null ) replaceStr = "" ; 
returnStr = attrValue . replace ( findStr , replaceStr ) ; 
ibegin = ifind + 1 ; 
} 
return returnStr ; 
} 
} 

public class ConfigurationUtility { 
public static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { 
int numRegions = sheet1 . getNumMergedRegions ( ) ; 
Map < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; 
for ( int i = 0 ; 
i < numRegions ; 
i ++ ) { 
CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; 
if ( caddress != null ) cellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; 
} 
return cellRangeMap ; 
} 
} 

public class ConfigurationUtility { 
public static List < String > skippedRegionCells ( final Sheet sheet1 ) { 
int numRegions = sheet1 . getNumMergedRegions ( ) ; 
List < String > skipCellList = new ArrayList < > ( ) ; 
for ( int i = 0 ; 
i < numRegions ; 
i ++ ) { 
CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; 
if ( caddress != null ) addSkipCellToListInTheRegion ( skipCellList , caddress ) ; 
} 
return skipCellList ; 
} 
} 

public class ConfigurationUtility { 
private static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { 
for ( int col = caddress . getFirstColumn ( ) ; 
col <= caddress . getLastColumn ( ) ; 
col ++ ) for ( int row = caddress . getFirstRow ( ) ; 
row <= caddress . getLastRow ( ) ; 
row ++ ) { 
if ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) continue ; 
skipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; 
} 
} 
} 

public class ConfigurationUtility { 
public static void buildSheetCommentFromAlias ( Sheet sheet , List < TieCommandAlias > tieCommandAliasList ) { 
if ( ( tieCommandAliasList == null ) || ( tieCommandAliasList . isEmpty ( ) ) ) return ; 
for ( Row row : sheet ) { 
for ( Cell cell : row ) { 
buildCellCommentFromalias ( tieCommandAliasList , cell ) ; 
} 
} 
} 
} 

public class ConfigurationUtility { 
private static void buildCellCommentFromalias ( List < TieCommandAlias > tieCommandAliasList , Cell cell ) { 
String value = CellUtility . getCellValueWithoutFormat ( cell ) ; 
if ( ( value != null ) && ( ! value . isEmpty ( ) ) ) for ( TieCommandAlias alias : tieCommandAliasList ) { 
Matcher matcher = alias . getPattern ( ) . matcher ( value ) ; 
if ( matcher . find ( ) ) { 
CellUtility . createOrInsertComment ( cell , alias . getCommand ( ) ) ; 
if ( alias . isRemove ( ) ) CellUtility . setCellValue ( cell , ParserUtility . removeCharsFromString ( value , matcher . start ( ) , matcher . end ( ) ) ) ; 
} 
} 
} 
} 

public class ConfigurationHandler { 
public final Map < String , SheetConfiguration > buildConfiguration ( ) { 
Map < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; 
List < String > sheetNames = new ArrayList < > ( ) ; 
String sname ; 
for ( int i = 0 ; 
i < parent . getWb ( ) . getNumberOfSheets ( ) ; 
i ++ ) { 
sname = parent . getWb ( ) . getSheetName ( i ) ; 
if ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) sheetNames . add ( sname ) ; 
} 
for ( String sheetName : sheetNames ) { 
Sheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; 
ConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; 
buildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; 
} 
return sheetConfigMap ; 
} 
} 

public class ConfigurationHandler { 
private SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { 
SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; 
sheetConfig . setFormName ( formName ) ; 
sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; 
int leftCol = sheet . getLeftCol ( ) ; 
int lastRow = sheet . getLastRowNum ( ) ; 
int firstRow = sheet . getFirstRowNum ( ) ; 
int rightCol = 0 ; 
int maxRow = 0 ; 
for ( Row row : sheet ) { 
if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) break ; 
maxRow = row . getRowNum ( ) ; 
int firstCellNum = row . getFirstCellNum ( ) ; 
if ( firstCellNum >= 0 && firstCellNum < leftCol ) leftCol = firstCellNum ; 
if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { 
int verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; 
if ( verifiedcol > rightCol ) rightCol = verifiedcol ; 
} 
} 
if ( maxRow < lastRow ) lastRow = maxRow ; 
String tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + "0 : " + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + "0" ; 
sheetConfig . setFormHeaderRange ( tempStr ) ; 
sheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; 
tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + " : " + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; 
sheetConfig . setFormBodyRange ( tempStr ) ; 
sheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; 
sheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; 
sheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; 
int sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; 
if ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) sheetConfig . setHidden ( true ) ; 
return sheetConfig ; 
} 
} 

public class ConfigurationHandler { 
private FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { 
int firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
int leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
int rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
int lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; 
Cell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
FormCommand fcommand = new FormCommand ( ) ; 
fcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; 
if ( sheetConfig . isHidden ( ) ) fcommand . setHidden ( TieConstants . TRUE_STRING ) ; 
else fcommand . setHidden ( TieConstants . FALSE_STRING ) ; 
fcommand . setName ( sheetConfig . getFormName ( ) ) ; 
fcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; 
fcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; 
fcommand . setHeaderLength ( "0" ) ; 
fcommand . setFooterLength ( "0" ) ; 
fcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; 
return fcommand ; 
} 
} 

public class ConfigurationHandler { 
private int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { 
int lastCol = sheetRightCol ; 
int col ; 
for ( col = lastCol ; 
col >= stoppoint ; 
col -- ) { 
Cell cell = row . getCell ( col ) ; 
if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) break ; 
} 
return col ; 
} 
} 

public class ConfigurationHandler { 
public final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { 
if ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) return ; 
checkAndRepairLastRow ( sheet ) ; 
int sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; 
List < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; 
boolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; 
List < String > formList = new ArrayList < > ( ) ; 
buildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; 
matchParentCommand ( commandList ) ; 
matchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; 
initTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; 
} 
} 

public class ConfigurationHandler { 
private final void checkAndRepairLastRow ( final Sheet sheet ) { 
Row lastrow = sheet . getRow ( sheet . getLastRowNum ( ) ) ; 
if ( lastrow != null ) { 
for ( Cell cell : lastrow ) { 
if ( ( cell . getCellTypeEnum ( ) != CellType . _NONE ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) return ; 
} 
sheet . removeRow ( lastrow ) ; 
} 
} 
} 

public class ConfigurationHandler { 
private List < ConfigCommand > buildCommandListFromSheetComment ( final XSSFSheet sheet , final int sheetRightCol , final CellAttributesMap cellAttributesMap ) { 
List < ConfigCommand > commandList = new ArrayList < > ( ) ; 
if ( parent . isSkipConfiguration ( ) ) return commandList ; 
Map < CellAddress , ? extends Comment > comments = null ; 
try { 
comments = sheet . getCellComments ( ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "Null exception throwed when no comment exists: " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
if ( comments == null ) return commandList ; 
SortedSet < CellAddress > keys = new TreeSet < > ( comments . keySet ( ) ) ; 
for ( CellAddress key : keys ) { 
Cell cell = sheet . getRow ( key . getRow ( ) ) . getCell ( key . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
buildCommandList ( sheet , sheetRightCol , cell , commandList , cellAttributesMap ) ; 
} 
return commandList ; 
} 
} 

public class ConfigurationHandler { 
private void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { 
int matchIndex = - 1 ; 
ConfigRange matchRange = null ; 
for ( int j = 0 ; 
j < commandList . size ( ) ; 
j ++ ) if ( j != i ) { 
Command commandParent = commandList . get ( j ) ; 
if ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { 
matchRange = commandParent . getConfigRange ( ) ; 
matchIndex = j ; 
} 
} 
if ( matchIndex >= 0 ) { 
commandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; 
child . setParentFound ( true ) ; 
} 
} 
} 

public class ConfigurationHandler { 
private boolean hasEachCommandInTheList ( final List < ConfigCommand > commandList ) { 
if ( commandList != null ) for ( ConfigCommand command : commandList ) { 
if ( command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_EACH ) ) return true ; 
} 
return false ; 
} 
} 

public class ConfigurationHandler { 
private void copyTemplateForTieCommands ( final Sheet sheet ) { 
if ( parent . isSkipConfiguration ( ) ) return ; 
Workbook wb = sheet . getWorkbook ( ) ; 
String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; 
if ( wb . getSheet ( copyName ) == null ) { 
Sheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; 
int sheetIndex = wb . getSheetIndex ( newSheet ) ; 
wb . setSheetName ( sheetIndex , copyName ) ; 
wb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; 
} 
} 
} 

public class ConfigurationHandler { 
private List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { 
Comment comment = cell . getCellComment ( ) ; 
String text = comment . getString ( ) . getString ( ) ; 
String [ ] commentLines = text . split ( "\\n" ) ; 
StringBuilder newComment = new StringBuilder ( ) ; 
boolean changed = false ; 
for ( String commentLine : commentLines ) { 
String line = commentLine . trim ( ) ; 
if ( ParserUtility . isCommandString ( line ) ) { 
processCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; 
changed = true ; 
} 
else if ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { 
processMethodLine ( cell , line , cellAttributesMap ) ; 
changed = true ; 
} 
else if ( newComment . length ( ) > 0 ) newComment . append ( "\\n" + commentLine ) ; 
else newComment . append ( commentLine ) ; 
} 
if ( ! changed ) moveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; 
else if ( newComment . length ( ) > 0 ) { 
moveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; 
CreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; 
RichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; 
comment . setString ( str ) ; 
} 
else cell . removeCellComment ( ) ; 
return cList ; 
} 
} 

public class ConfigurationHandler { 
private void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { 
if ( ParserUtility . isWidgetMethodString ( line ) ) ParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; 
else if ( ParserUtility . isValidateMethodString ( line ) ) ParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; 
else moveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; 
} 
} 

public class ConfigurationHandler { 
private void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { 
int nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; 
if ( nameEndIndex < 0 ) { 
String errMsg = "Failed to parse command line [" + line + "]. Expected '" + TieConstants . ATTR_PREFIX + "' symbol." ; 
LOG . severe ( errMsg ) ; 
throw new IllegalStateException ( errMsg ) ; 
} 
String commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; 
Map < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; 
ConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; 
if ( configCommand != null ) cList . add ( configCommand ) ; 
} 
} 

public class ConfigurationHandler { 
private SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { 
SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; 
sheetConfig . setFormName ( fcommand . getName ( ) ) ; 
sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; 
int leftCol = fcommand . getLeftCol ( ) ; 
int lastRow = fcommand . getLastRow ( ) ; 
int rightCol = 0 ; 
int maxRow = 0 ; 
for ( Row row : sheet ) { 
if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) break ; 
maxRow = row . getRowNum ( ) ; 
if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { 
int verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; 
if ( verifiedcol > rightCol ) rightCol = verifiedcol ; 
} 
} 
if ( maxRow < lastRow ) lastRow = maxRow ; 
setHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; 
setBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; 
setFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; 
String hidden = fcommand . getHidden ( ) ; 
if ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) sheetConfig . setHidden ( true ) ; 
String fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; 
if ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) sheetConfig . setFixedWidthStyle ( true ) ; 
sheetConfig . setFormCommand ( fcommand ) ; 
return sheetConfig ; 
} 
} 

public class ConfigurationHandler { 
private void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { 
String tempStr ; 
if ( fcommand . calcFooterLength ( ) == 0 ) tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + " : " + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; 
else tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + fcommand . calcBodyLength ( ) ) + " : " + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; 
sheetConfig . setFormFooterRange ( tempStr ) ; 
sheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; 
} 
} 

public class ConfigurationHandler { 
private void setHeaderOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { 
String tempStr ; 
if ( fcommand . calcHeaderLength ( ) == 0 ) tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + " : " + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; 
else tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + 1 ) + " : " + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; 
sheetConfig . setFormHeaderRange ( tempStr ) ; 
sheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; 
} 
} 

public class CommandUtility { 
@ SuppressWarnings ( { 
"rawtypes" } 
) public static int deleteRow ( final ConfigBuildRef configBuildRef , final int rowIndex , final Map < String , Object > dataContext , final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; 
configBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; 
CollectionObject collect = configBuildRef . getCellHelper ( ) . getLastCollect ( fullName ) ; 
Collection lastCollection = collect . getLastCollection ( ) ; 
int lastCollectionIndex = collect . getLastCollectionIndex ( ) ; 
EachCommand eachCommand = collect . getEachCommand ( ) ; 
if ( lastCollectionIndex < 0 ) throw new DeleteRowException ( "No each command found." ) ; 
if ( lastCollection . size ( ) <= 1 ) throw new DeleteRowException ( "Cannot delete the last record in the group." ) ; 
CommandUtility . deleteObjectInContext ( lastCollection , eachCommand , lastCollectionIndex , dataContext ) ; 
ConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) . get ( fullName ) ; 
if ( currentRangeAttrs == null ) throw new DeleteRowException ( "Cannot find delete range." ) ; 
int startRow = currentRangeAttrs . getFirstRowIndex ( ) ; 
int length = currentRangeAttrs . getFinalLength ( ) ; 
int endRow = startRow + length - 1 ; 
List < String > removeFullNameList = findRemoveFullNameList ( configBuildRef . getSheet ( ) , startRow , endRow ) ; 
removeRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , removeFullNameList ) ; 
String var = eachCommand . getVar ( ) ; 
CommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , startRow , endRow , configBuildRef . getCachedCells ( ) ) ; 
CommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , endRow ) ; 
Map < String , String > changeMap = new TreeMap < > ( ) ; 
ConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , startRow , fullName , changeMap , - 1 ) ; 
ConfigurationUtility . changeIndexNumberInShiftMap ( configBuildRef . getShiftMap ( ) , changeMap ) ; 
ConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , fullName ) ; 
ConfigurationUtility . changeUpperLevelFinalLength ( configBuildRef . getShiftMap ( ) , fullName , - length ) ; 
dataContext . remove ( var ) ; 
return length ; 
} 
} 

public class CommandUtility { 
private static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { 
List < String > list = new ArrayList < > ( ) ; 
for ( int rowIndex = startRow ; 
rowIndex <= endRow ; 
rowIndex ++ ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; 
if ( ! list . contains ( fullName ) ) list . add ( fullName ) ; 
} 
return list ; 
} 
} 

public class CommandUtility { 
public static EachCommand getEachCommandFromPartsName ( final Map < String , Command > commandIndexMap , final String [ ] varparts ) { 
if ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) return ( EachCommand ) commandIndexMap . get ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX + varparts [ 1 ] ) ; 
return null ; 
} 
} 

public class CommandUtility { 
@ SuppressWarnings ( { 
"rawtypes" , "unchecked" } 
) private static String insertEmptyObjectInContext ( final String fullName , final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { 
if ( ! ( lastCollection instanceof List ) ) throw new EvaluationException ( "Collection must be list in order to insert/delete." ) ; 
List collectionList = ( List ) lastCollection ; 
Object currentObj = collectionList . get ( lastCollectionIndex ) ; 
Object insertObj ; 
try { 
insertObj = currentObj . getClass ( ) . newInstance ( ) ; 
collectionList . add ( lastCollectionIndex + 1 , insertObj ) ; 
dataContext . put ( eachCommand . getVar ( ) , insertObj ) ; 
return fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) + ( lastCollectionIndex + 1 ) ; 
} 
catch ( InstantiationException | IllegalAccessException e ) { 
throw new EvaluationException ( e ) ; 
} 
} 
} 

public class CommandUtility { 
@ SuppressWarnings ( { 
"rawtypes" } 
) private static void deleteObjectInContext ( final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { 
if ( ! ( lastCollection instanceof List ) ) throw new EvaluationException ( eachCommand . getVar ( ) + TieConstants . EACH_COMMAND_INVALID_MSG ) ; 
List collectionList = ( List ) lastCollection ; 
collectionList . remove ( lastCollectionIndex ) ; 
dataContext . remove ( eachCommand . getVar ( ) ) ; 
} 
} 

public class CommandUtility { 
public static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) for ( int i = 0 ; 
i < sourceConfigRange . getCommandList ( ) . size ( ) ; 
i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
indexMap . put ( command . getCommandName ( ) , command ) ; 
command . getConfigRange ( ) . indexCommandRange ( indexMap ) ; 
} 
} 
} 

public class CommandUtility { 
public static boolean isRowAllowAdd ( final Row row , final SheetConfiguration sheetConfig ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; 
if ( fullName != null ) { 
ConfigRangeAttrs attrs = sheetConfig . getShiftMap ( ) . get ( fullName ) ; 
if ( ( attrs != null ) && ( attrs . isAllowAdd ( ) ) && ( row . getRowNum ( ) == attrs . getFirstRowRef ( ) . getRowIndex ( ) ) ) return true ; 
} 
return false ; 
} 
} 

public class CommandUtility { 
public static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { 
int srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; 
int srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; 
Sheet sheet = configBuildRef . getSheet ( ) ; 
Workbook wb = sheet . getWorkbook ( ) ; 
String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; 
if ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) copyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; 
Sheet srcSheet = wb . getSheet ( copyName ) ; 
if ( index > 0 ) CellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; 
for ( int rowIndex = srcStartRow ; 
rowIndex <= srcEndRow ; 
rowIndex ++ ) if ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) unitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; 
} 
} 

public class CommandUtility { 
public static void evaluateNormalCells ( final Cell cell , final String strValue , final Map < String , Object > context , final ExpressionEngine engine ) { 
if ( strValue . contains ( TieConstants . METHOD_PREFIX ) ) { 
Object evaluationResult = evaluate ( strValue , context , engine ) ; 
if ( evaluationResult == null ) evaluationResult = "" ; 
CellUtility . setCellValue ( cell , evaluationResult . toString ( ) ) ; 
createTieCell ( cell , context , engine ) ; 
} 
} 
} 

public class CommandUtility { 
private static void evaluateUserFormula ( final Cell cell , final String strValue ) { 
String formulaStr = strValue . substring ( 2 , strValue . length ( ) - 1 ) ; 
if ( ( formulaStr != null ) && ( ! formulaStr . isEmpty ( ) ) ) cell . setCellFormula ( formulaStr ) ; 
} 
} 

public class CommandUtility { 
public static void createCellComment ( final Cell cell , final String newComment , final Map < Cell , String > finalCommentMap ) { 
if ( newComment != null ) finalCommentMap . put ( cell , newComment ) ; 
} 
} 

public class CommandUtility { 
public static boolean evalBoolExpression ( final ExpressionEngine expEngine , final String pscript ) { 
Object result = null ; 
String script = "( " + pscript + " )" ; 
script = script . toUpperCase ( ) . replace ( "AND" , "&&" ) ; 
script = script . toUpperCase ( ) . replace ( "OR" , "||" ) ; 
try { 
result = expEngine . evaluate ( script ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "WebForm WebFormHelper evalBoolExpression script = " + script + "; error = " + e . getLocalizedMessage ( ) , e ) ; 
} 
if ( result != null ) return ( ( Boolean ) result ) . booleanValue ( ) ; 
else return false ; 
} 
} 

public class CommandUtility { 
public static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { 
for ( int irow = rowIndexStart ; 
irow <= rowIndexEnd ; 
irow ++ ) removeCachedCellForRow ( sheet , irow , cachedMap ) ; 
int irows = rowIndexEnd - rowIndexStart + 1 ; 
if ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) return ; 
int lastRowNum = sheet . getLastRowNum ( ) ; 
if ( rowIndexEnd < lastRowNum ) sheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; 
if ( rowIndexEnd == lastRowNum ) for ( int i = rowIndexEnd ; 
i >= rowIndexStart ; 
i -- ) removeSingleRowInSheet ( sheet , rowIndexStart ) ; 
} 
} 

public class CommandUtility { 
private static void removeSingleRowInSheet ( final Sheet sheet , final int rowIndexStart ) { 
Row removingRow = sheet . getRow ( rowIndexStart ) ; 
if ( removingRow != null ) sheet . removeRow ( removingRow ) ; 
} 
} 

public class CommandUtility { 
private static void removeCachedCellForRow ( final Sheet sheet , final int rowIndexStart , final Map < Cell , String > cachedMap ) { 
Row removingRow = sheet . getRow ( rowIndexStart ) ; 
if ( removingRow != null ) for ( Cell cell : removingRow ) { 
cachedMap . remove ( cell ) ; 
} 
} 
} 

public class CommandUtility { 
public static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { 
int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
if ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) return ; 
int irows = rowIndexEnd - rowIndexStart + 1 ; 
for ( int rowIndex = rowIndexEnd ; 
rowIndex >= rowIndexStart ; 
rowIndex -- ) bodyRows . remove ( rowIndex - top ) ; 
for ( int irow = rowIndexStart - top ; 
irow < bodyRows . size ( ) ; 
irow ++ ) { 
FacesRow facesrow = bodyRows . get ( irow ) ; 
facesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; 
} 
} 
} 

public class CellMap { 
private String loadPicture ( final int rowIndex , final int colIndex ) { 
FacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; 
if ( facesCell != null && facesCell . isContainPic ( ) ) { 
FacesContext context = FacesContext . getCurrentInstance ( ) ; 
String pictureId = facesCell . getPictureId ( ) ; 
String pictureViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + pictureId ; 
Map < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; 
if ( sessionMap . get ( pictureViewId ) == null ) sessionMap . put ( pictureViewId , parent . getPicturesMap ( ) . get ( pictureId ) . getPictureData ( ) ) ; 
return pictureViewId ; 
} 
else return null ; 
} 
} 

public class CellMap { 
private String loadChart ( final int rowIndex , final int colIndex ) { 
FacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; 
if ( facesCell != null && facesCell . isContainChart ( ) ) { 
FacesContext context = FacesContext . getCurrentInstance ( ) ; 
String chartId = facesCell . getChartId ( ) ; 
String chartViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + chartId ; 
if ( context != null ) { 
Map < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; 
if ( sessionMap . get ( chartViewId ) == null ) sessionMap . put ( chartViewId , parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ) ; 
} 
return chartViewId ; 
} 
else return null ; 
} 
} 

public class CellMap { 
private String assembleNewValue ( final Object value , final FacesCell facesCell ) { 
String newValue ; 
if ( value instanceof java . util . Date ) { 
String datePattern = facesCell . getDatePattern ( ) ; 
if ( datePattern == null || datePattern . isEmpty ( ) ) datePattern = parent . getDefaultDatePattern ( ) ; 
Format formatter = new SimpleDateFormat ( datePattern ) ; 
newValue = formatter . format ( value ) ; 
} 
else newValue = ( String ) value ; 
if ( "textarea" . equalsIgnoreCase ( facesCell . getInputType ( ) ) && ( newValue != null ) ) newValue = newValue . replace ( "\r\n" , "\n" ) ; 
return newValue ; 
} 
} 

public class CellUtility { 
@ SuppressWarnings ( "deprecation" ) public static String getCellValueWithFormat ( final Cell poiCell , final FormulaEvaluator formulaEvaluator , final DataFormatter dataFormatter ) { 
if ( poiCell == null ) return null ; 
String result ; 
try { 
CellType cellType = poiCell . getCellTypeEnum ( ) ; 
if ( cellType == CellType . FORMULA ) cellType = formulaEvaluator . evaluate ( poiCell ) . getCellTypeEnum ( ) ; 
if ( cellType == CellType . ERROR ) result = "" ; 
else result = dataFormatter . formatCellValue ( poiCell , formulaEvaluator ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "Web Form WebFormHelper getCellValue Error row = " + poiCell . getRowIndex ( ) + " column = " + poiCell . getColumnIndex ( ) + " error = " + e . getLocalizedMessage ( ) + "; Change return result to blank" , e ) ; 
result = "" ; 
} 
return result ; 
} 
} 

public class CellUtility { 
@ SuppressWarnings ( "deprecation" ) public static String getCellValueWithoutFormat ( final Cell poiCell ) { 
if ( poiCell == null ) return null ; 
if ( poiCell . getCellTypeEnum ( ) == CellType . FORMULA ) return getCellStringValueWithType ( poiCell , poiCell . getCachedFormulaResultTypeEnum ( ) ) ; 
else return getCellStringValueWithType ( poiCell , poiCell . getCellTypeEnum ( ) ) ; 
} 
} 

public class CellUtility { 
private static String getCellStringValueWithNumberType ( final Cell poiCell ) { 
String result ; 
if ( DateUtil . isCellDateFormatted ( poiCell ) ) result = poiCell . getDateCellValue ( ) . toString ( ) ; 
else { 
result = BigDecimal . valueOf ( poiCell . getNumericCellValue ( ) ) . toPlainString ( ) ; 
if ( result . endsWith ( ".0" ) ) result = result . substring ( 0 , result . length ( ) - 2 ) ; 
} 
return result ; 
} 
} 

public class CellUtility { 
@ SuppressWarnings ( "deprecation" ) public static Cell setCellValue ( final Cell c , final String value ) { 
try { 
if ( value . length ( ) == 0 ) c . setCellType ( CellType . BLANK ) ; 
else if ( WebSheetUtility . isNumeric ( value ) ) setCellValueNumber ( c , value ) ; 
else if ( WebSheetUtility . isDate ( value ) ) setCellValueDate ( c , value ) ; 
else if ( c . getCellTypeEnum ( ) == CellType . BOOLEAN ) setCellValueBoolean ( c , value ) ; 
else setCellValueString ( c , value ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , " error in setCellValue of CellUtility = " + e . getLocalizedMessage ( ) , e ) ; 
setCellValueString ( c , value ) ; 
} 
return c ; 
} 
} 

public class CellUtility { 
private static void setCellValueBoolean ( final Cell c , final String value ) { 
if ( "Y" . equalsIgnoreCase ( value ) || "Yes" . equalsIgnoreCase ( value ) || "True" . equalsIgnoreCase ( value ) ) c . setCellValue ( true ) ; 
else c . setCellValue ( false ) ; 
} 
} 

public class CellUtility { 
public static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { 
int length = srcRowEnd - srcRowStart + 1 ; 
if ( length <= 0 ) return ; 
destSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) copySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; 
for ( int i = 0 ; 
i < srcSheet . getNumMergedRegions ( ) ; 
i ++ ) { 
CellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; 
if ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { 
int targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; 
int targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; 
CellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; 
destSheet . addMergedRegion ( newCellRangeAddress ) ; 
} 
} 
} 
} 

public class CellUtility { 
private static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { 
Row newRow = destSheet . getRow ( destinationRowNum ) ; 
Row sourceRow = srcSheet . getRow ( sourceRowNum ) ; 
if ( newRow == null ) newRow = destSheet . createRow ( destinationRowNum ) ; 
newRow . setHeight ( sourceRow . getHeight ( ) ) ; 
for ( int i = 0 ; 
i < sourceRow . getLastCellNum ( ) ; 
i ++ ) copyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; 
if ( setHiddenColumn ) ConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; 
return ; 
} 
} 

public class CellUtility { 
public static Cell copyCell ( final Sheet destSheet , final Row sourceRow , final Row newRow , final int cellIndex , final boolean checkLock ) { 
Cell sourceCell = sourceRow . getCell ( cellIndex ) ; 
if ( sourceCell == null ) return null ; 
boolean refreshCell = false ; 
if ( sourceRow . equals ( newRow ) && ( sourceCell . getColumnIndex ( ) == cellIndex ) ) { 
sourceRow . removeCell ( sourceCell ) ; 
refreshCell = true ; 
} 
Cell newCell = newRow . createCell ( cellIndex ) ; 
try { 
if ( ! refreshCell && ( sourceCell . getCellComment ( ) != null ) ) cloneComment ( sourceCell , newCell ) ; 
copyCellSetStyle ( destSheet , sourceCell , newCell ) ; 
copyCellSetValue ( sourceCell , newCell , checkLock ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "copy cell set error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
return newCell ; 
} 
} 

public class CellUtility { 
@ SuppressWarnings ( "deprecation" ) private static void copyCellSetStyle ( final Sheet destSheet , final Cell sourceCell , final Cell newCell ) { 
CellStyle newCellStyle = getCellStyleFromSourceCell ( destSheet , sourceCell ) ; 
newCell . setCellStyle ( newCellStyle ) ; 
if ( sourceCell . getHyperlink ( ) != null ) newCell . setHyperlink ( sourceCell . getHyperlink ( ) ) ; 
newCell . setCellType ( sourceCell . getCellTypeEnum ( ) ) ; 
} 
} 

public class CellUtility { 
public static void createOrInsertComment ( final Cell cell , final String commentStr ) { 
XSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; 
CreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; 
Drawing drawing = sheet . createDrawingPatriarch ( ) ; 
Comment comment = cell . getCellComment ( ) ; 
String originStr = "" ; 
if ( comment == null ) { 
ClientAnchor anchor = createCommentAnchor ( cell , factory ) ; 
comment = drawing . createCellComment ( anchor ) ; 
} 
else originStr = comment . getString ( ) . getString ( ) + "\n" ; 
originStr += commentStr ; 
RichTextString str = factory . createRichTextString ( originStr ) ; 
comment . setString ( str ) ; 
comment . setAuthor ( "" ) ; 
cell . setCellComment ( comment ) ; 
comment . setColumn ( cell . getColumnIndex ( ) ) ; 
comment . setRow ( cell . getRowIndex ( ) ) ; 
} 
} 

public class CellUtility { 
private static XSSFVMLDrawing getVmlDrawingFromCell ( final Cell cell ) { 
XSSFSheet sourceSheet = ( XSSFSheet ) cell . getSheet ( ) ; 
for ( POIXMLDocumentPart sourcePart : sourceSheet . getRelations ( ) ) { 
if ( ( sourcePart != null ) && ( sourcePart instanceof XSSFVMLDrawing ) ) return ( XSSFVMLDrawing ) sourcePart ; 
} 
return null ; 
} 
} 

public class CellUtility { 
public static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { 
int initRows = 1 ; 
if ( "Repeat" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { 
initRows = sheetConfig . getBodyInitialRows ( ) ; 
if ( initRows < 1 ) initRows = 1 ; 
} 
return initRows ; 
} 
} 

public class CellUtility { 
public static Cell getPoiCellFromSheet ( final int rowIndex , final int colIndex , final Sheet sheet1 ) { 
if ( ( sheet1 != null ) && ( sheet1 . getRow ( rowIndex ) != null ) ) return sheet1 . getRow ( rowIndex ) . getCell ( colIndex ) ; 
return null ; 
} 
} 

public class TieWebSheetBeanCurrent { 
public final String getCurrentDataContextName ( ) { 
if ( currentDataContextName == null ) { 
StringBuilder sb = new StringBuilder ( ) ; 
List < String > list = this . getCurrentDataContextNameList ( ) ; 
for ( int i = 0 ; 
i < list . size ( ) ; 
i ++ ) if ( i > 0 ) sb . append ( ":" + list . get ( i ) ) ; 
else sb . append ( list . get ( i ) ) ; 
this . setCurrentDataContextName ( sb . toString ( ) ) ; 
} 
return currentDataContextName ; 
} 
} 

public class RowsMapping { 
public final void mergeMap ( final RowsMapping addMap ) { 
Map < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; 
for ( Map . Entry < Integer , List < SerialRow > > entry : map . entrySet ( ) ) { 
List < SerialRow > entryRowList = entry . getValue ( ) ; 
if ( ( entryRowList != null ) && ( ! entryRowList . isEmpty ( ) ) ) for ( SerialRow row : entryRowList ) { 
this . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; 
} 
} 
} 
} 

public class ChartUtility { 
public static ChartType getChartType ( final CTChart ctChart ) { 
CTPlotArea plotArea = ctChart . getPlotArea ( ) ; 
for ( ChartType chartType : ChartType . values ( ) ) { 
if ( chartType . isThisType ( plotArea ) ) return chartType ; 
} 
return null ; 
} 
} 

public class ChartUtility { 
public static BasicStroke toStroke ( final String style ) { 
BasicStroke result = null ; 
if ( style != null ) { 
float lineWidth = STROKE_DEFAULT_LINE_WIDTH ; 
float [ ] dash = { 
STROKE_DEFAULT_DASH_WIDTH } 
; 
float [ ] dot = { 
lineWidth } 
; 
if ( style . equalsIgnoreCase ( STYLE_LINE ) ) result = new BasicStroke ( lineWidth ) ; 
else if ( style . equalsIgnoreCase ( STYLE_DASH ) ) result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DASH , dash , STROKE_DEFAULT_DASHPHASE ) ; 
else if ( style . equalsIgnoreCase ( STYLE_DOT ) ) result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DOT , dot , STROKE_DEFAULT_DASHPHASE ) ; 
} 
return result ; 
} 
} 

public class ChartUtility { 
public static ChartData initChartDataFromXSSFChart ( final String chartId , final XSSFChart chart , final XSSFWorkbook wb ) { 
ThemesTable themeTable = wb . getStylesSource ( ) . getTheme ( ) ; 
ChartData chartData = new ChartData ( ) ; 
XSSFRichTextString chartTitle = chart . getTitle ( ) ; 
if ( chartTitle != null ) chartData . setTitle ( chartTitle . toString ( ) ) ; 
CTChart ctChart = chart . getCTChart ( ) ; 
ChartType chartType = ChartUtility . getChartType ( ctChart ) ; 
if ( chartType == null ) throw new IllegalChartException ( "Unknown chart type" ) ; 
chartData . setBgColor ( ColorUtility . getBgColor ( ctChart . getPlotArea ( ) , themeTable ) ) ; 
chartData . setId ( chartId ) ; 
chartData . setType ( chartType ) ; 
List < CTCatAx > ctCatAxList = ctChart . getPlotArea ( ) . getCatAxList ( ) ; 
if ( ( ctCatAxList != null ) && ( ! ctCatAxList . isEmpty ( ) ) ) chartData . setCatAx ( new ChartAxis ( ctCatAxList . get ( 0 ) ) ) ; 
List < CTValAx > ctValAxList = ctChart . getPlotArea ( ) . getValAxList ( ) ; 
if ( ( ctValAxList != null ) && ( ! ctValAxList . isEmpty ( ) ) ) chartData . setValAx ( new ChartAxis ( ctValAxList . get ( 0 ) ) ) ; 
ChartObject ctObj = chartType . createChartObject ( ) ; 
if ( ctObj == null ) throw new IllegalChartException ( "Cannot create chart object." ) ; 
setUpChartData ( chartData , ctChart , themeTable , ctObj ) ; 
return chartData ; 
} 
} 

public class ChartUtility { 
public static void setUpChartData ( final ChartData chartData , final CTChart ctChart , final ThemesTable themeTable , final ChartObject ctObj ) { 
Object chartObj = null ; 
@ SuppressWarnings ( "rawtypes" ) List plotCharts = ctObj . getChartListFromCtChart ( ctChart ) ; 
if ( plotCharts != null && ( ! plotCharts . isEmpty ( ) ) ) chartObj = plotCharts . get ( 0 ) ; 
if ( chartObj != null ) { 
@ SuppressWarnings ( "rawtypes" ) List bsers = ctObj . getSerListFromCtObjChart ( chartObj ) ; 
if ( ! AppUtils . emptyList ( bsers ) ) { 
chartData . buildCategoryList ( ctObj . getCtAxDataSourceFromSerList ( bsers ) ) ; 
chartData . buildSeriesList ( bsers , themeTable , ctObj ) ; 
} 
} 
} 
} 

public class ChartUtility { 
public static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { 
Map < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; 
Map < String , String > positionMap = charsData . getChartPositionMap ( ) ; 
anchortMap . clear ( ) ; 
positionMap . clear ( ) ; 
for ( int i = 0 ; 
i < wb . getNumberOfSheets ( ) ; 
i ++ ) initXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; 
} 
} 

public class ChartUtility { 
private static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { 
XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; 
CTDrawing ctDrawing = drawing . getCTDrawing ( ) ; 
if ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) return ; 
List < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; 
for ( int j = 0 ; 
j < alist . size ( ) ; 
j ++ ) { 
CTTwoCellAnchor ctanchor = alist . get ( j ) ; 
String singleChartId = getAnchorAssociateChartId ( ctanchor ) ; 
if ( singleChartId != null ) { 
String chartId = sheet . getSheetName ( ) + "!" + singleChartId ; 
int dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; 
int dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; 
int dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; 
int dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; 
int col1 = ctanchor . getFrom ( ) . getCol ( ) ; 
int row1 = ctanchor . getFrom ( ) . getRow ( ) ; 
int col2 = ctanchor . getTo ( ) . getCol ( ) ; 
int row2 = ctanchor . getTo ( ) . getRow ( ) ; 
anchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; 
positionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; 
} 
} 
} 
} 

public class ChartUtility { 
private static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { 
if ( ctanchor . getGraphicFrame ( ) == null ) return null ; 
Node parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; 
NodeList childNodes = parentNode . getChildNodes ( ) ; 
for ( int i = 0 ; 
i < childNodes . getLength ( ) ; 
i ++ ) { 
Node childNode = childNodes . item ( i ) ; 
if ( ( childNode != null ) && ( "c:chart" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { 
String rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; 
if ( rId != null ) return rId ; 
} 
} 
return null ; 
} 
} 

public class ChartUtility { 
private static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { 
for ( int j = 0 ; 
j < attrs . getLength ( ) ; 
j ++ ) { 
Attr attribute = ( Attr ) attrs . item ( j ) ; 
if ( "r:id" . equalsIgnoreCase ( attribute . getName ( ) ) ) return attribute . getValue ( ) ; 
} 
return null ; 
} 
} 

public class CellHelper { 
public final Cell getPoiCellWithRowColFromTab ( final int rowIndex , final int colIndex , final String tabName ) { 
if ( parent . getWb ( ) != null ) return CellUtility . getPoiCellFromSheet ( rowIndex , colIndex , parent . getWb ( ) . getSheet ( parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ) ) ; 
return null ; 
} 
} 

public class CellHelper { 
public final void restoreDataContext ( final String fullName ) { 
String [ ] parts = fullName . split ( ":" ) ; 
if ( ! isNeedRestore ( fullName , parts ) ) return ; 
boolean stopSkip = false ; 
List < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; 
int listSize = list . size ( ) ; 
for ( int i = 0 ; 
i < parts . length ; 
i ++ ) { 
String part = parts [ i ] ; 
boolean skip = false ; 
if ( ( ! stopSkip ) && ( i < listSize ) ) { 
String listPart = list . get ( i ) ; 
if ( part . equalsIgnoreCase ( listPart ) ) skip = true ; 
} 
if ( ! skip ) { 
stopSkip = true ; 
startRestoreDataContext ( part ) ; 
} 
} 
if ( stopSkip ) parent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; 
return ; 
} 
} 

public class CellHelper { 
private boolean isNeedRestore ( final String fullName , final String [ ] parts ) { 
if ( fullName == null ) return false ; 
if ( ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) && ( parent . getCurrent ( ) . getCurrentDataContextName ( ) . toLowerCase ( ) . startsWith ( fullName . toLowerCase ( ) ) ) ) return false ; 
return ( ( parts != null ) && ( parts . length > 1 ) ) ; 
} 
} 

public class ConfigRange { 
public final void shiftRowRef ( final Sheet sheet , final int shiftnum ) { 
try { 
this . setFirstRowRef ( sheet . getRow ( attrs . getFirstRowAddr ( ) . getRow ( ) + shiftnum ) . getCell ( attrs . getFirstRowAddr ( ) . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) , false ) ; 
this . setLastRowPlusRef ( sheet , attrs . getLastRowPlusAddr ( ) . getColumn ( ) , attrs . getLastRowPlusAddr ( ) . getRow ( ) + shiftnum - 1 , false ) ; 
if ( commandList != null ) for ( ConfigCommand command : commandList ) { 
command . shiftRowRef ( sheet , shiftnum ) ; 
} 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "shiftRowRef error =" + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class ConfigRange { 
public final void setFirstRowRef ( final Cell pFirstRowRef , final boolean alsoCreateAddr ) { 
this . attrs . setFirstRowRef ( pFirstRowRef ) ; 
if ( alsoCreateAddr ) this . setFirstRowAddr ( new SerialCellAddress ( pFirstRowRef ) ) ; 
} 
} 

public class ConfigRange { 
public final void setLastRowPlusRef ( final Sheet sheet , final int rightCol , final int lastRow , final boolean alsoSetAddr ) { 
if ( ( lastRow >= 0 ) && ( sheet != null ) && ( rightCol >= 0 ) ) { 
Row row = sheet . getRow ( lastRow + 1 ) ; 
if ( row == null ) row = sheet . createRow ( lastRow + 1 ) ; 
Cell cell = row . getCell ( rightCol ) ; 
if ( cell == null ) { 
cell = row . getCell ( rightCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
this . attrs . setLastCellCreated ( true ) ; 
} 
else this . attrs . setLastCellCreated ( false ) ; 
this . attrs . setLastRowPlusRef ( cell ) ; 
if ( alsoSetAddr ) this . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; 
} 
else { 
this . attrs . setLastRowPlusRef ( null ) ; 
if ( alsoSetAddr ) this . attrs . setLastRowPlusAddr ( null ) ; 
} 
} 
} 

public class ConfigRange { 
private void buildCellsForRow ( final Row row , final String fullName , final Map < String , Object > context , final ConfigBuildRef configBuildRef , ShiftFormulaRef shiftFormulaRef ) { 
if ( ( row == null ) || ! ConfigurationUtility . isStaticRowRef ( this , row ) ) return ; 
for ( Cell cell : row ) { 
buildSingleCell ( cell , context , configBuildRef , shiftFormulaRef ) ; 
} 
ConfigurationUtility . setFullNameInHiddenColumn ( row , fullName ) ; 
} 
} 

public class ConfigRange { 
private void buildSingleCell ( final Cell cell , final Map < String , Object > context , final ConfigBuildRef configBuildRef , final ShiftFormulaRef shiftFormulaRef ) { 
try { 
CommandUtility . evaluate ( context , cell , configBuildRef . getEngine ( ) ) ; 
if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { 
String originFormula = cell . getCellFormula ( ) ; 
shiftFormulaRef . setFormulaChanged ( 0 ) ; 
ConfigurationUtility . buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , cell . getCellFormula ( ) ) ; 
if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; 
} 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "build cell ( row = " + cell . getRowIndex ( ) + " column = " + cell . getColumnIndex ( ) + " error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class ChartData { 
public final void buildCategoryList ( final CTAxDataSource ctAxDs ) { 
List < ParsedCell > cells = new ArrayList < > ( ) ; 
try { 
String fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; 
String sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; 
CellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; 
for ( int row = region . getFirstRow ( ) ; 
row <= region . getLastRow ( ) ; 
row ++ ) for ( int col = region . getFirstColumn ( ) ; 
col <= region . getLastColumn ( ) ; 
col ++ ) cells . add ( new ParsedCell ( sheetName , row , col ) ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "failed in buildCategoryList" , ex ) ; 
} 
this . setCategoryList ( cells ) ; 
} 
} 

public class ChartData { 
private ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { 
ChartSeries ctSer = new ChartSeries ( ) ; 
ctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; 
ctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; 
List < ParsedCell > cells = new ArrayList < > ( ) ; 
String fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; 
String sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; 
CellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; 
for ( int row = region . getFirstRow ( ) ; 
row <= region . getLastRow ( ) ; 
row ++ ) for ( int col = region . getFirstColumn ( ) ; 
col <= region . getLastColumn ( ) ; 
col ++ ) cells . add ( new ParsedCell ( sheetName , row , col ) ) ; 
ctSer . setValueList ( cells ) ; 
ctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; 
return ctSer ; 
} 
} 

public class ChartData { 
private List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { 
List < XColor > colors = new ArrayList < > ( ) ; 
if ( ( dptList != null ) && ( cells != null ) ) for ( int index = 0 ; 
index < cells . size ( ) ; 
index ++ ) { 
CTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; 
CTShapeProperties ctSpPr = null ; 
if ( dpt != null ) ctSpPr = dpt . getSpPr ( ) ; 
colors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; 
} 
return colors ; 
} 
} 

public class ChartData { 
private CTDPt getDPtFromListWithIndex ( final List < CTDPt > dptList , final int index ) { 
if ( dptList != null ) for ( CTDPt dpt : dptList ) { 
if ( dpt . getIdx ( ) . getVal ( ) == index ) return dpt ; 
} 
return null ; 
} 
} 

public class SheetConfiguration { 
public final void setCommandIndexMap ( final Map < String , Command > pcommandIndexMap ) { 
if ( pcommandIndexMap instanceof HashMap ) this . commandIndexMap = ( HashMap < String , Command > ) pcommandIndexMap ; 
else { 
this . commandIndexMap = new HashMap < > ( ) ; 
this . commandIndexMap . putAll ( pcommandIndexMap ) ; 
} 
} 
} 

public class PicturesUtility { 
public static void getPictruesMap ( final Workbook wb , final Map < String , Picture > picMap ) { 
if ( wb instanceof XSSFWorkbook ) getXSSFPictruesMap ( ( XSSFWorkbook ) wb , picMap ) ; 
return ; 
} 
} 

public class PicturesUtility { 
private static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { 
picMap . clear ( ) ; 
List < XSSFPictureData > pictures = wb . getAllPictures ( ) ; 
if ( pictures . isEmpty ( ) ) return ; 
for ( int i = 0 ; 
i < wb . getNumberOfSheets ( ) ; 
i ++ ) { 
XSSFSheet sheet = wb . getSheetAt ( i ) ; 
for ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { 
try { 
indexPictureInMap ( picMap , sheet , dr ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "Load Picture error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 
return ; 
} 
} 

public class PicturesUtility { 
public static String generatePictureStyle ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final Picture pic ) { 
ClientAnchor anchor = pic . getClientAnchor ( ) ; 
if ( anchor != null ) { 
AnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , anchor ) ; 
if ( anchorSize != null ) return "MARGIN-LEFT:" + String . format ( "%.2f" , anchorSize . getPercentLeft ( ) ) + "%;MARGIN-TOP:" + String . format ( "%.2f" , anchorSize . getPercentTop ( ) ) + "%;width:" + String . format ( "%.2f" , anchorSize . getPercentWidth ( ) ) + "%;" ; 
} 
return "" ; 
} 
} 

public class PicturesUtility { 
public static String generateChartStyle ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String chartId , final Map < String , ClientAnchor > anchorsMap ) { 
ClientAnchor anchor = anchorsMap . get ( chartId ) ; 
if ( anchor != null ) { 
AnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , anchor ) ; 
if ( anchorSize != null ) return "MARGIN-LEFT:" + String . format ( "%.2f" , anchorSize . getPercentLeft ( ) ) + "%;MARGIN-TOP:" + String . format ( "%.2f" , anchorSize . getPercentTop ( ) ) + "%;width:" + String . format ( "%.2f" , anchorSize . getPercentWidth ( ) ) + "%;height:135%;" ; 
} 
return "" ; 
} 
} 

public class PicturesUtility { 
public static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { 
if ( ! ( sheet1 instanceof XSSFSheet ) ) return null ; 
double picWidth = 0.0 ; 
double picHeight = 0.0 ; 
int left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; 
int top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; 
int right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; 
int bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; 
double cellWidth = 0.0 ; 
double cellHeight = 0.0 ; 
if ( ( cell != null ) && ( fcell != null ) ) { 
for ( int col = cell . getColumnIndex ( ) ; 
col < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; 
col ++ ) cellWidth += sheet1 . getColumnWidthInPixels ( col ) ; 
double lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; 
for ( int rowIndex = cell . getRowIndex ( ) ; 
rowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; 
rowIndex ++ ) cellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; 
double lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; 
picWidth = cellWidth - lastCellWidth + right - left ; 
picHeight = cellHeight - lastCellHeight + bottom - top ; 
} 
else { 
for ( short col = anchor . getCol1 ( ) ; 
col < anchor . getCol2 ( ) ; 
col ++ ) picWidth += sheet1 . getColumnWidthInPixels ( col ) ; 
for ( int rowindex = anchor . getRow1 ( ) ; 
rowindex < anchor . getRow2 ( ) ; 
rowindex ++ ) { 
Row row = sheet1 . getRow ( rowindex ) ; 
if ( row != null ) picHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; 
} 
} 
return new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; 
} 
} 

public class TieCommandAlias { 
public Pattern getPattern ( ) { 
if ( ( this . pattern == null ) && ( alias != null ) ) this . pattern = Pattern . compile ( "\\s*" + ParserUtility . wildcardToRegex ( alias ) ) ; 
return pattern ; 
} 
} 

public class SerialCell { 
public final void recover ( final Sheet sheet ) { 
if ( this . cellAddr != null ) this . setCell ( sheet . getRow ( this . cellAddr . getRow ( ) ) . getCell ( this . cellAddr . getColumn ( ) ) ) ; 
} 
} 

public class CellStyleUtility { 
public static String getRowStyle ( final Workbook wb , final Cell poiCell , final String inputType , final float rowHeight , final int rowspan ) { 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
if ( ( cellStyle != null ) && ( rowspan == 1 ) ) { 
short fontIdx = cellStyle . getFontIndex ( ) ; 
Font font = wb . getFontAt ( fontIdx ) ; 
float maxHeight = rowHeight ; 
if ( ! inputType . isEmpty ( ) ) maxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , rowHeight ) ; 
return "height:" + WebSheetUtility . pointsToPixels ( maxHeight ) + "px;" ; 
} 
return "" ; 
} 
} 

public class CellStyleUtility { 
public static String getCellFontStyle ( final Workbook wb , final Cell poiCell ) { 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
StringBuilder webStyle = new StringBuilder ( ) ; 
if ( cellStyle != null ) { 
short fontIdx = cellStyle . getFontIndex ( ) ; 
Font font = wb . getFontAt ( fontIdx ) ; 
if ( font . getItalic ( ) ) webStyle . append ( "font-style: italic;" ) ; 
if ( font . getBold ( ) ) webStyle . append ( "font-weight: bold;" ) ; 
webStyle . append ( "font-size: " + font . getFontHeightInPoints ( ) + "pt;" ) ; 
String decoration = getCellFontDecoration ( font ) ; 
if ( decoration . length ( ) > 0 ) webStyle . append ( "text-decoration:" + decoration + ";" ) ; 
webStyle . append ( getCellFontColor ( font ) ) ; 
} 
return webStyle . toString ( ) ; 
} 
} 

public class CellStyleUtility { 
private static String getCellFontColor ( final Font font ) { 
short [ ] rgbfix = { 
TieConstants . RGB_MAX , TieConstants . RGB_MAX , TieConstants . RGB_MAX } 
; 
if ( font instanceof XSSFFont ) { 
XSSFColor color = ( ( XSSFFont ) font ) . getXSSFColor ( ) ; 
if ( color != null ) rgbfix = ColorUtility . getTripletFromXSSFColor ( color ) ; 
} 
if ( rgbfix [ 0 ] != TieConstants . RGB_MAX ) return "color:rgb(" + FacesUtility . strJoin ( rgbfix , "," ) + ");" ; 
return "" ; 
} 
} 

public class CellStyleUtility { 
private static String getCellFontDecoration ( final Font font ) { 
StringBuilder decoration = new StringBuilder ( ) ; 
if ( font . getUnderline ( ) != 0 ) decoration . append ( " underline" ) ; 
if ( font . getStrikeout ( ) ) decoration . append ( " line-through" ) ; 
return decoration . toString ( ) ; 
} 
} 

public class CellStyleUtility { 
public static String getColumnStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { 
String inputType = fcell . getInputType ( ) ; 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
StringBuilder webStyle = new StringBuilder ( ) ; 
if ( cellStyle != null ) { 
if ( fcell . isContainPic ( ) || fcell . isContainChart ( ) ) webStyle . append ( "vertical-align: top;" ) ; 
else { 
webStyle . append ( getAlignmentFromCell ( poiCell , cellStyle ) ) ; 
webStyle . append ( getVerticalAlignmentFromCell ( cellStyle ) ) ; 
} 
webStyle . append ( ColorUtility . getBgColorFromCell ( wb , poiCell , cellStyle ) ) ; 
webStyle . append ( getRowStyle ( wb , poiCell , inputType , rowHeight , fcell . getRowspan ( ) ) ) ; 
} 
else webStyle . append ( getAlignmentFromCellType ( poiCell ) ) ; 
return webStyle . toString ( ) ; 
} 
} 

public class CellStyleUtility { 
public static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { 
int totalHeight = additionalHeight ; 
for ( int i = firstRow ; 
i <= lastRow ; 
i ++ ) totalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; 
return totalHeight ; 
} 
} 

public class CellStyleUtility { 
public static void setupCellStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
if ( ( cellStyle != null ) && ( ! cellStyle . getLocked ( ) ) ) { 
if ( fcell . getInputType ( ) . isEmpty ( ) ) fcell . setInputType ( CellStyleUtility . getInputTypeFromCellType ( poiCell ) ) ; 
if ( fcell . getControl ( ) . isEmpty ( ) && ( ! fcell . getInputType ( ) . isEmpty ( ) ) ) fcell . setControl ( "text" ) ; 
setInputStyleBaseOnInputType ( fcell , poiCell ) ; 
} 
String webStyle = getCellStyle ( wb , poiCell , fcell . getInputType ( ) ) + getCellFontStyle ( wb , poiCell ) + getRowStyle ( wb , poiCell , fcell . getInputType ( ) , rowHeight , fcell . getRowspan ( ) ) ; 
fcell . setStyle ( webStyle ) ; 
fcell . setColumnStyle ( getColumnStyle ( wb , fcell , poiCell , rowHeight ) ) ; 
} 
} 

public class CellStyleUtility { 
@ SuppressWarnings ( "deprecation" ) private static String getInputTypeFromCellType ( final Cell cell ) { 
String inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; 
if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) inputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; 
CellStyle style = cell . getCellStyle ( ) ; 
if ( style != null ) { 
int formatIndex = style . getDataFormat ( ) ; 
String formatString = style . getDataFormatString ( ) ; 
if ( DateUtil . isADateFormat ( formatIndex , formatString ) ) inputType = TieConstants . CELL_INPUT_TYPE_DATE ; 
else if ( isAPercentageCell ( formatString ) ) inputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; 
} 
return inputType ; 
} 
} 

public class FacesUtility { 
public static String removePrefixPath ( final String prefix , final String resource ) { 
String normalizedResource = resource ; 
if ( normalizedResource . startsWith ( prefix ) ) normalizedResource = normalizedResource . substring ( prefix . length ( ) - 1 ) ; 
return normalizedResource ; 
} 
} 

public class FacesUtility { 
public static boolean evalInputType ( final String input , final String type ) { 
Scanner scanner = new Scanner ( input ) ; 
boolean ireturn = false ; 
if ( "Integer" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextInt ( ) ; 
else if ( "Double" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextDouble ( ) ; 
else if ( "Boolean" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextBoolean ( ) ; 
else if ( "Byte" . equalsIgnoreCase ( type ) ) ireturn = scanner . hasNextByte ( ) ; 
else if ( type . toLowerCase ( ) . startsWith ( "text" ) ) ireturn = true ; 
scanner . close ( ) ; 
return ireturn ; 
} 
} 

public class FacesUtility { 
public static String strJoin ( final short [ ] aArr , final String sSep ) { 
StringBuilder sbStr = new StringBuilder ( ) ; 
for ( int i = 0 , il = aArr . length ; 
i < il ; 
i ++ ) { 
if ( i > 0 ) sbStr . append ( sSep ) ; 
sbStr . append ( aArr [ i ] ) ; 
} 
return sbStr . toString ( ) ; 
} 
} 

public class FacesUtility { 
public static double round ( final double value , final int places ) { 
if ( places < 0 ) throw new IllegalArgumentException ( ) ; 
BigDecimal bd = BigDecimal . valueOf ( value ) ; 
bd = bd . setScale ( places , RoundingMode . HALF_UP ) ; 
return bd . doubleValue ( ) ; 
} 
} 

public class TieWebSheetView { 
public String getTabType ( ) { 
int sheetId = webFormTabView . getActiveIndex ( ) ; 
if ( ( sheetId >= 0 ) && ( tabs != null ) ) { 
if ( sheetId >= tabs . size ( ) ) sheetId = 0 ; 
tabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; 
} 
else tabType = TieConstants . TAB_TYPE_NONE ; 
return tabType ; 
} 
} 

public class TieWebSheetView { 
public String getTabStyle ( ) { 
String tabStyle = TieConstants . TAB_STYLE_VISIBLE ; 
int sheetId = webFormTabView . getActiveIndex ( ) ; 
if ( ( sheetId >= 0 ) && ( sheetId < tabs . size ( ) ) ) tabStyle = TieConstants . TAB_STYLE_INVISIBLE ; 
return tabStyle ; 
} 
} 

public class FormCommand { 
private List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { 
List < Integer > watchList = new ArrayList < > ( ) ; 
ConfigRange cRange = this . getConfigRange ( ) ; 
List < ConfigCommand > commandList = cRange . getCommandList ( ) ; 
if ( commandList . isEmpty ( ) ) return watchList ; 
int lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; 
if ( lastStaticRow < 0 ) lastStaticRow = this . getTopRow ( ) ; 
int sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; 
for ( int i = this . getTopRow ( ) ; 
i <= this . getLastRow ( ) ; 
i ++ ) { 
Row row = sheet . getRow ( i ) ; 
for ( Cell cell : row ) { 
if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) buildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; 
} 
} 
return watchList ; 
} 
} 

public class FormCommand { 
private void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { 
String formula = cell . getCellFormula ( ) ; 
Ptg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; 
for ( int k = 0 ; 
k < ptgs . length ; 
k ++ ) { 
Object ptg = ptgs [ k ] ; 
int areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; 
if ( areaInt >= 0 ) addToWatchList ( areaInt , lastStaticRow , watchList ) ; 
} 
cell . setCellType ( CellType . STRING ) ; 
cell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; 
} 
} 

public class FormCommand { 
private void addToWatchList ( final int addRow , final int lastStaticRow , final List < Integer > watchList ) { 
if ( ( addRow > lastStaticRow ) && ! ( watchList . contains ( addRow ) ) ) watchList . add ( addRow ) ; 
} 
} 

public class ParserUtility { 
public static boolean isCommandString ( final String str ) { 
if ( str == null ) return false ; 
return str . startsWith ( TieConstants . COMMAND_PREFIX ) ; 
} 
} 

public class ParserUtility { 
public static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { 
if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) return ; 
int widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; 
int elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; 
if ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) return ; 
String type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; 
String values = getStringBetweenBracket ( newComment ) ; 
if ( values == null ) return ; 
String key = getAttributeKeyInMapByCell ( cell ) ; 
cellAttributesMap . getCellInputType ( ) . put ( key , type ) ; 
List < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; 
if ( inputs == null ) { 
inputs = new ArrayList < > ( ) ; 
cellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; 
} 
parseInputAttributes ( inputs , values ) ; 
parseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; 
} 
} 

public class ParserUtility { 
public static String getAttributeKeyInMapByCell ( final Cell cell ) { 
if ( cell == null ) return null ; 
return cell . getSheet ( ) . getSheetName ( ) + "!" + CellUtility . getCellIndexNumberKey ( cell ) ; 
} 
} 

public class ParserUtility { 
public static void parseValidateAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { 
if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) return ; 
if ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ) return ; 
String values = getStringBetweenBracket ( newComment ) ; 
if ( values == null ) return ; 
String key = getAttributeKeyInMapByCell ( cell ) ; 
List < CellFormAttributes > attrs = cellAttributesMap . getCellValidateAttributes ( ) . get ( key ) ; 
if ( attrs == null ) { 
attrs = new ArrayList < > ( ) ; 
cellAttributesMap . getCellValidateAttributes ( ) . put ( key , attrs ) ; 
} 
parseValidateAttributes ( attrs , values ) ; 
} 
} 

public class ParserUtility { 
private static int findPairBracketPosition ( final String str , final int startPos ) { 
int bracketNum = 0 ; 
for ( int i = startPos ; 
i < str . length ( ) ; 
i ++ ) { 
char current = str . charAt ( i ) ; 
if ( current == TieConstants . EL_START_BRACKET ) bracketNum ++ ; 
else if ( current == TieConstants . EL_END ) { 
bracketNum -- ; 
if ( bracketNum <= 0 ) return i ; 
} 
} 
return - 1 ; 
} 
} 

public class ParserUtility { 
public static void parseValidateAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { 
if ( controlAttrs == null ) return ; 
String [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; 
CellFormAttributes attr = new CellFormAttributes ( ) ; 
for ( String cattr : cattrs ) { 
extractValidationAttributes ( attr , cattr ) ; 
} 
if ( ( attr . getValue ( ) != null ) && ( ! attr . getValue ( ) . isEmpty ( ) ) ) clist . add ( attr ) ; 
} 
} 

public class ParserUtility { 
private static String [ ] splitByEualSign ( final String attrData ) { 
int attrNameEndIndex = attrData . indexOf ( '=' ) ; 
if ( attrNameEndIndex < 0 ) return new String [ 0 ] ; 
String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; 
String attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; 
String [ ] rlist = new String [ 2 ] ; 
rlist [ 0 ] = attrName ; 
rlist [ 1 ] = attrValue ; 
return rlist ; 
} 
} 

public class ParserUtility { 
public static void parseSpecialAttributes ( final String key , final String type , final List < CellFormAttributes > inputs , final CellAttributesMap cellAttributesMap ) { 
SpecialAttributes sAttr = new SpecialAttributes ( ) ; 
for ( CellFormAttributes attr : inputs ) { 
gatherSpecialAttributes ( type , sAttr , attr ) ; 
} 
if ( sAttr . selectLabels != null ) processSelectItemAttributes ( key , cellAttributesMap , sAttr ) ; 
if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) processCalendarAttributes ( key , cellAttributesMap , sAttr ) ; 
} 
} 

public class ParserUtility { 
private static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { 
if ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) sAttr . selectValues = sAttr . selectLabels ; 
Map < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; 
if ( smap == null ) smap = new LinkedHashMap < > ( ) ; 
smap . clear ( ) ; 
if ( sAttr . defaultSelectLabel != null ) smap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; 
for ( int i = 0 ; 
i < sAttr . selectLabels . length ; 
i ++ ) smap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; 
cellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; 
} 
} 

public class ParserUtility { 
private static void gatherSpecialAttributes ( final String type , final SpecialAttributes sAttr , final CellFormAttributes attr ) { 
String attrKey = attr . getType ( ) ; 
if ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_LABELS ) ) sAttr . selectLabels = attr . getValue ( ) . split ( ";" ) ; 
if ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_VALUES ) ) sAttr . selectValues = attr . getValue ( ) . split ( ";" ) ; 
if ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_LABEL ) ) sAttr . defaultSelectLabel = attr . getValue ( ) ; 
if ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_VALUE ) ) sAttr . defaultSelectValue = attr . getValue ( ) ; 
if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) && attrKey . equalsIgnoreCase ( TieConstants . WIDGET_ATTR_PATTERN ) ) sAttr . defaultDatePattern = attr . getValue ( ) ; 
} 
} 

public class ParserUtility { 
public static void parseCommentToMap ( final String cellKey , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { 
if ( ( newComment != null ) && ( ! newComment . trim ( ) . isEmpty ( ) ) ) { 
String commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; 
if ( ! normalComment ) commentKey = newComment . substring ( 0 , newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; 
Map < String , String > map = sheetCommentMap . get ( commentKey ) ; 
if ( map == null ) map = new HashMap < > ( ) ; 
map . put ( cellKey , newComment ) ; 
sheetCommentMap . put ( commentKey , map ) ; 
} 
} 
} 

public class ParserUtility { 
public static int findFirstNonCellNamePosition ( String input , int startPosition ) { 
char c ; 
for ( int i = startPosition ; 
i < input . length ( ) ; 
i ++ ) { 
c = input . charAt ( i ) ; 
if ( c != '$' && ! Character . isLetterOrDigit ( c ) ) return i ; 
} 
return - 1 ; 
} 
} 

public class WebSheetUtility { 
public static Cell getCellByReference ( final String cellRef , final Sheet sheet ) { 
Cell c = null ; 
try { 
CellReference ref = new CellReference ( cellRef ) ; 
Row r = sheet . getRow ( ref . getRow ( ) ) ; 
if ( r != null ) c = r . getCell ( ref . getCol ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "WebForm WebFormHelper getCellByReference cellRef = " + cellRef + "; error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
return c ; 
} 
} 

public class WebSheetUtility { 
public static boolean isDate ( final String s ) { 
Pattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; 
String [ ] terms = s . split ( " " ) ; 
Matcher matcher ; 
for ( String term : terms ) { 
matcher = pattern . matcher ( term ) ; 
if ( matcher . matches ( ) ) return true ; 
} 
pattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; 
terms = s . split ( " " ) ; 
for ( String term : terms ) { 
matcher = pattern . matcher ( term ) ; 
if ( matcher . matches ( ) ) return true ; 
} 
return false ; 
} 
} 

public class WebSheetUtility { 
public static String parseDate ( final String entry ) { 
Pattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; 
String [ ] terms = entry . split ( " " ) ; 
Matcher matcher ; 
for ( String term : terms ) { 
matcher = pattern . matcher ( term ) ; 
if ( matcher . matches ( ) ) return matcher . group ( ) ; 
} 
pattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; 
terms = entry . split ( " " ) ; 
for ( String term : terms ) { 
matcher = pattern . matcher ( term ) ; 
if ( matcher . matches ( ) ) return matcher . group ( ) ; 
} 
return "" ; 
} 
} 

public class WebSheetUtility { 
public static boolean isNumeric ( final String str ) { 
String s = str ; 
if ( s . startsWith ( "-" ) ) s = s . substring ( 1 ) ; 
char c ; 
int i ; 
int sLen = s . length ( ) ; 
ShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; 
for ( i = 0 ; 
i < sLen ; 
i ++ ) { 
c = s . charAt ( i ) ; 
if ( c < '0' || c > '9' ) if ( ! shouldContinue ( c , sPara ) ) return false ; 
else if ( sPara . isCommaHit ( ) ) sPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; 
} 
return true ; 
} 
} 

public class WebSheetUtility { 
private static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { 
if ( c == '.' && ! para . isDecimalHit ( ) ) { 
para . setDecimalHit ( true ) ; 
if ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) return false ; 
return true ; 
} 
else if ( c == ',' && ! para . isDecimalHit ( ) ) { 
if ( para . isCommaHit ( ) ) { 
if ( para . getSinceLastComma ( ) != 3 ) return false ; 
para . setSinceLastComma ( 0 ) ; 
} 
para . setCommaHit ( true ) ; 
return true ; 
} 
return false ; 
} 
} 

public class WebSheetUtility { 
public static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { 
try { 
Method method = obj . getClass ( ) . getMethod ( "set" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) , new Class [ ] { 
String . class } 
) ; 
method . invoke ( obj , propertyValue ) ; 
} 
catch ( Exception e ) { 
String msg = "failed to set property '" + propertyName + "' to value '" + propertyValue + "' for object " + obj ; 
if ( ignoreNonExisting ) LOG . info ( msg ) ; 
else { 
LOG . warning ( msg ) ; 
throw new IllegalArgumentException ( e ) ; 
} 
} 
} 
} 

public class WebSheetUtility { 
public static int cellCompareTo ( final Cell thisCell , final Cell otherCell ) { 
int r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; 
if ( r != 0 ) return r ; 
r = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; 
if ( r != 0 ) return r ; 
return 0 ; 
} 
} 

public class WebSheetUtility { 
public static void clearHiddenColumns ( final Sheet sheet ) { 
for ( Row row : sheet ) { 
if ( row . getLastCellNum ( ) > TieConstants . MAX_COLUMNS_IN_SHEET ) deleteHiddenColumnsInRow ( row ) ; 
} 
} 
} 

public class WebSheetUtility { 
private static void deleteCellFromRow ( final Row row , final int cellNum ) { 
Cell cell = row . getCell ( cellNum ) ; 
if ( cell != null ) row . removeCell ( cell ) ; 
} 
} 

public class ValidationHandler { 
private void refreshAfterStatusChanged ( final boolean oldStatus , final boolean newStatus , final int formRow , final int formCol , final FacesCell cell , final boolean updateGui ) { 
if ( ! newStatus ) cell . setErrormsg ( "" ) ; 
cell . setInvalid ( newStatus ) ; 
if ( updateGui && ( oldStatus != newStatus ) && ( parent . getWebFormClientId ( ) != null ) ) RequestContext . getCurrentInstance ( ) . update ( parent . getWebFormClientId ( ) + ":" + ( formRow ) + ":group" + ( formCol ) ) ; 
} 
} 

public class ValidationHandler { 
public boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { 
boolean submitMode = parent . getSubmitMode ( ) ; 
boolean passEmptyCheck = ! submitMode ; 
int topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
int leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
boolean pass = true ; 
FacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; 
if ( fRow == null ) return pass ; 
FacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; 
if ( cell == null ) return pass ; 
Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; 
boolean oldStatus = cell . isInvalid ( ) ; 
String value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; 
if ( value == null ) value = "" ; 
else value = value . trim ( ) ; 
if ( passEmptyCheck && value . isEmpty ( ) ) { 
refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; 
return pass ; 
} 
if ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) return false ; 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; 
List < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; 
if ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) return false ; 
if ( cellAttributes != null ) pass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; 
if ( pass ) refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; 
return pass ; 
} 
} 

public class ValidationHandler { 
private boolean validateAllRulesForSingleCell ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , final List < CellFormAttributes > cellAttributes , boolean updateGui ) { 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; 
for ( CellFormAttributes attr : cellAttributes ) { 
boolean pass = doValidation ( value , attr , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , sheet1 ) ; 
if ( ! pass ) { 
String errmsg = attr . getMessage ( ) ; 
if ( errmsg == null ) errmsg = TieConstants . DEFALT_MSG_INVALID_INPUT ; 
cell . setErrormsg ( errmsg ) ; 
LOG . log ( Level . INFO , "Validation failed for sheet {0} row {1} column {2} : {3}" , new Object [ ] { 
poiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errmsg } 
) ; 
refreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; 
return false ; 
} 
} 
return true ; 
} 
} 

public class ValidationHandler { 
private boolean doValidation ( final Object value , final CellFormAttributes attr , final int rowIndex , final int colIndex , final Sheet sheet ) { 
boolean pass ; 
String attrValue = attr . getValue ( ) ; 
attrValue = attrValue . replace ( "$value" , value . toString ( ) + "" ) . replace ( "$rowIndex" , rowIndex + "" ) . replace ( "$colIndex" , colIndex + "" ) . replace ( "$sheetName" , sheet . getSheetName ( ) ) ; 
attrValue = ConfigurationUtility . replaceExpressionWithCellValue ( attrValue , rowIndex , sheet ) ; 
if ( attrValue . contains ( TieConstants . EL_START ) ) { 
Object returnObj = FacesUtility . evaluateExpression ( attrValue , Object . class ) ; 
attrValue = returnObj . toString ( ) ; 
pass = Boolean . parseBoolean ( attrValue ) ; 
} 
else pass = parent . getCellHelper ( ) . evalBoolExpression ( attrValue ) ; 
return pass ; 
} 
} 

public class ValidationHandler { 
public final boolean validateCurrentPage ( ) { 
boolean allpass = true ; 
int top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
for ( int irow = 0 ; 
irow < parent . getBodyRows ( ) . size ( ) ; 
irow ++ ) if ( ! validateRowInCurrentPage ( irow + top , false ) ) allpass = false ; 
return allpass ; 
} 
} 

public class ValidationHandler { 
private boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { 
boolean pass = true ; 
if ( sheetConfig == null ) return pass ; 
int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
List < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; 
for ( int index = 0 ; 
index < cellRow . size ( ) ; 
index ++ ) { 
FacesCell fcell = cellRow . get ( index ) ; 
if ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) pass = false ; 
} 
return pass ; 
} 
} 

public class ValidationHandler { 
private void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { 
UIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; 
if ( s == null ) return ; 
DataTable webDataTable = ( DataTable ) s ; 
int first = webDataTable . getFirst ( ) ; 
int rowsToRender = webDataTable . getRowsToRender ( ) ; 
int rowCounts = webDataTable . getRowCount ( ) ; 
int top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
int left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
for ( int i = first ; 
i <= ( first + rowsToRender ) ; 
i ++ ) if ( i < rowCounts ) refreshCachedCellsInRow ( tblName , top , left , i ) ; 
} 
} 

public class ValidationHandler { 
private void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { 
FacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; 
int isize = dataRow . getCells ( ) . size ( ) ; 
for ( int index = 0 ; 
index < isize ; 
index ++ ) { 
FacesCell fcell = dataRow . getCells ( ) . get ( index ) ; 
Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; 
if ( poiCell != null ) parent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; 
} 
} 
} 

public class ValidationHandler { 
public void setSubmitModeInView ( final Boolean fullflag ) { 
if ( FacesContext . getCurrentInstance ( ) != null ) { 
Map < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; 
if ( viewMap != null ) { 
Boolean flag = ( Boolean ) viewMap . get ( TieConstants . SUBMITMODE ) ; 
if ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) viewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; 
} 
} 
} 
} 

public class ValidationHandler { 
public boolean preValidation ( ) { 
String currentTabName = parent . getCurrent ( ) . getCurrentTabName ( ) ; 
String tabName = null ; 
String firstInvalidTabName = null ; 
boolean reload = false ; 
for ( Map . Entry < String , SheetConfiguration > entry : parent . getSheetConfigMap ( ) . entrySet ( ) ) { 
tabName = entry . getKey ( ) ; 
if ( reload || ( ! tabName . equals ( currentTabName ) ) ) { 
parent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; 
reload = true ; 
} 
if ( ! parent . getValidationHandler ( ) . validateCurrentPage ( ) && ( firstInvalidTabName == null ) ) firstInvalidTabName = tabName ; 
} 
if ( firstInvalidTabName != null ) { 
if ( ! tabName . equals ( firstInvalidTabName ) ) parent . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( firstInvalidTabName ) ; 
return false ; 
} 
return true ; 
} 
} 

public class CellAttributesMap { 
public final void clear ( ) { 
if ( this . templateCommentMap != null ) this . templateCommentMap . clear ( ) ; 
if ( this . cellDatePattern != null ) this . cellDatePattern . clear ( ) ; 
if ( this . cellInputAttributes != null ) this . cellInputAttributes . clear ( ) ; 
if ( this . cellInputType != null ) this . cellInputType . clear ( ) ; 
if ( this . cellSelectItemsAttributes != null ) this . cellSelectItemsAttributes . clear ( ) ; 
} 
} 

public class WebSheetLoader { 
private void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
int top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; 
int bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; 
int left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; 
int right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; 
String sheetName = sheetConfig . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
int totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; 
RangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; 
if ( sheetConfig . isFixedWidthStyle ( ) ) parent . setTableWidthStyle ( "table-layout: fixed; width:" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + "px;" ) ; 
parent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; 
parent . setAddRowColumnWidthStyle ( "width:" + parent . getAddRowColumnWidth ( ) + "px;" ) ; 
parent . getHeaderRows ( ) . clear ( ) ; 
if ( top < 0 ) { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; 
parent . setShowLineNumber ( true ) ; 
} 
else { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; 
for ( int i = top ; 
i <= bottom ; 
i ++ ) parent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; 
parent . setShowLineNumber ( false ) ; 
} 
} 
} 

public class WebSheetLoader { 
private List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { 
int firstCol = rangeBuildRef . getLeft ( ) ; 
int lastCol = rangeBuildRef . getRight ( ) ; 
double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; 
Sheet sheet1 = rangeBuildRef . getSheet ( ) ; 
List < HeaderCell > headercells = new ArrayList < > ( ) ; 
for ( int i = firstCol ; 
i <= lastCol ; 
i ++ ) if ( ! sheet1 . isColumnHidden ( i ) ) { 
String style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; 
headercells . add ( new HeaderCell ( "1" , "1" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; 
} 
fillToMaxColumns ( headercells ) ; 
return headercells ; 
} 
} 

public class WebSheetLoader { 
private void fillToMaxColumns ( final List < HeaderCell > headercells ) { 
if ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { 
int fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; 
for ( int s = 0 ; 
s < fills ; 
s ++ ) headercells . add ( new HeaderCell ( "1" , "1" , "" , "" , "" , false , false ) ) ; 
} 
} 
} 

public class WebSheetLoader { 
private String getHeaderColumnStyle ( final Workbook wb , final Cell cell , final double colWidth , final double totalWidth ) { 
String columnstyle = "" ; 
if ( cell != null ) columnstyle += CellStyleUtility . getCellStyle ( wb , cell , "" ) + CellStyleUtility . getCellFontStyle ( wb , cell ) ; 
columnstyle = columnstyle + getWidthStyle ( colWidth , totalWidth ) ; 
return columnstyle ; 
} 
} 

public class WebSheetLoader { 
private List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
Sheet sheet1 = rangeBuildRef . getSheet ( ) ; 
int left = rangeBuildRef . getLeft ( ) ; 
int right = rangeBuildRef . getRight ( ) ; 
double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; 
Row row = sheet1 . getRow ( currentRow ) ; 
List < HeaderCell > headercells = new ArrayList < > ( ) ; 
for ( int cindex = left ; 
cindex <= right ; 
cindex ++ ) { 
String cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; 
if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { 
Cell cell = null ; 
if ( row != null ) cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
int originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; 
if ( cell != null ) { 
FacesCell fcell = new FacesCell ( ) ; 
CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; 
parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; 
CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; 
fcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; 
fcell . setColumnIndex ( cindex ) ; 
headercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; 
} 
} 
} 
fillToMaxColumns ( headercells ) ; 
return headercells ; 
} 
} 

public class WebSheetLoader { 
private String getColumnWidthStyle ( final Sheet sheet1 , final Map < String , CellRangeAddress > cellRangeMap , final String cellindex , final int cindex , final double totalWidth ) { 
CellRangeAddress caddress = cellRangeMap . get ( cellindex ) ; 
double colWidth ; 
if ( caddress != null ) colWidth = CellStyleUtility . calcTotalWidth ( sheet1 , caddress . getFirstColumn ( ) , caddress . getLastColumn ( ) , 0 ) ; 
else colWidth = sheet1 . getColumnWidth ( cindex ) ; 
return getWidthStyle ( colWidth , totalWidth ) ; 
} 
} 

public class WebSheetLoader { 
private void initTabs ( ) { 
parent . setTabs ( new ArrayList < TabModel > ( ) ) ; 
if ( parent . getSheetConfigMap ( ) != null ) for ( String key : parent . getSheetConfigMap ( ) . keySet ( ) ) { 
parent . getTabs ( ) . add ( new TabModel ( "form_" + key , key , "form" ) ) ; 
} 
} 
} 

public class WebSheetLoader { 
private void loadData ( ) { 
if ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) return ; 
if ( parent . isAdvancedContext ( ) ) parent . getSerialDataContext ( ) . getDataContext ( ) . put ( "tiecells" , new HashMap < String , TieCell > ( ) ) ; 
for ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { 
List < RowsMapping > currentRowsMappingList = null ; 
ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; 
int length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , currentRowsMappingList ) ; 
sheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; 
sheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; 
sheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; 
sheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; 
sheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; 
sheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; 
sheetConfig . setBodyPopulated ( true ) ; 
} 
parent . getCellHelper ( ) . reCalc ( ) ; 
} 
} 

public class WebSheetLoader { 
public void refreshData ( ) { 
if ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) return ; 
for ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { 
for ( int irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; 
irow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ; 
irow ++ ) refreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; 
} 
parent . getCellHelper ( ) . reCalc ( ) ; 
} 
} 

public class WebSheetLoader { 
private void refreshDataForRow ( Row row ) { 
if ( row == null ) return ; 
String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; 
if ( saveAttrList != null ) { 
String [ ] saveAttrs = saveAttrList . split ( "," ) ; 
for ( String fullSaveAttr : saveAttrs ) { 
refreshDataForCell ( row , fullSaveAttr ) ; 
} 
} 
} 
} 

public class WebSheetLoader { 
private void refreshDataForCell ( Row row , String fullSaveAttr ) { 
if ( fullSaveAttr != null ) try { 
String fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; 
if ( fullName != null ) { 
parent . getCellHelper ( ) . restoreDataContext ( fullName ) ; 
SaveAttrsUtility . refreshSheetRowFromContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , fullSaveAttr , row , parent . getExpEngine ( ) ) ; 
} 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "refreshDataForCell with fullAaveAttr =" + fullSaveAttr + " error = " + ex . getMessage ( ) , ex ) ; 
} 
} 
} 

public class WebSheetLoader { 
public final int findTabIndexWithName ( final String tabname ) { 
for ( int i = 0 ; 
i < parent . getTabs ( ) . size ( ) ; 
i ++ ) if ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) return i ; 
return - 1 ; 
} 
} 

public class WebSheetLoader { 
public final void loadWorkSheet ( final String tabName ) { 
prepareWorkShee ( tabName ) ; 
parent . getValidationHandler ( ) . validateCurrentPage ( ) ; 
createDynamicColumns ( tabName ) ; 
setDataTablePage ( 0 ) ; 
parent . getCurrent ( ) . setCurrentDataContextName ( null ) ; 
saveObjs ( ) ; 
if ( ( RequestContext . getCurrentInstance ( ) != null ) && ( parent . getClientId ( ) != null ) ) RequestContext . getCurrentInstance ( ) . update ( parent . getClientId ( ) + ":websheettab" ) ; 
} 
} 

public class WebSheetLoader { 
public final void prepareWorkShee ( final String tabName ) { 
int tabIndex = findTabIndexWithName ( tabName ) ; 
if ( parent . getWebFormTabView ( ) != null ) parent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; 
parent . getCurrent ( ) . setCurrentTabName ( tabName ) ; 
String sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
parent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; 
parent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; 
parent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; 
Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; 
List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; 
loadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; 
loadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; 
} 
} 

public class WebSheetLoader { 
private void setDataTablePage ( final int first ) { 
if ( parent . getWebFormClientId ( ) != null ) { 
final DataTable d = ( DataTable ) FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . findComponent ( parent . getWebFormClientId ( ) ) ; 
if ( d != null ) d . setFirst ( first ) ; 
} 
} 
} 

public class WebSheetLoader { 
private void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
int bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; 
int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
String sheetName = sheetConfig . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
parent . getBodyRows ( ) . clear ( ) ; 
clearCache ( ) ; 
for ( int i = top ; 
i <= bottom ; 
i ++ ) parent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; 
sheetConfig . setBodyPopulated ( true ) ; 
parent . getCurrent ( ) . setCurrentTopRow ( top ) ; 
parent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; 
} 
} 

public class WebSheetLoader { 
private FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
FacesRow facesRow = new FacesRow ( rowIndex ) ; 
Row row = sheet1 . getRow ( rowIndex ) ; 
setupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; 
String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; 
List < FacesCell > bodycells = new ArrayList < > ( ) ; 
for ( int cindex = left ; 
cindex <= right ; 
cindex ++ ) { 
String cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; 
if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { 
Cell cell = null ; 
if ( row != null ) cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
if ( cell != null ) { 
FacesCell fcell = new FacesCell ( ) ; 
CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; 
parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; 
CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; 
fcell . setColumnIndex ( cindex ) ; 
bodycells . add ( fcell ) ; 
addCache ( cell ) ; 
} 
else bodycells . add ( null ) ; 
} 
else bodycells . add ( null ) ; 
} 
facesRow . setCells ( bodycells ) ; 
return facesRow ; 
} 
} 

public class WebSheetLoader { 
public final void refreshCachedCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { 
if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) && ( tblName != null ) ) try { 
processRefreshCell ( tblName , i , index , cell , fcell ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "refresh Cached Cell error : " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class WebSheetLoader { 
private void processRefreshCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { 
String newValue = CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) ; 
if ( parent . getCachedCells ( ) . isValueChanged ( cell , newValue ) ) { 
if ( fcell . isHasSaveAttr ( ) ) parent . getCellHelper ( ) . saveDataInContext ( cell , newValue ) ; 
RequestContext . getCurrentInstance ( ) . update ( tblName + ":" + i + ":cocalc" + index ) ; 
parent . getCachedCells ( ) . put ( cell , CellType . FORMULA ) ; 
} 
} 
} 

public class WebSheetLoader { 
private void createDynamicColumns ( final String tabName ) { 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; 
int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
parent . getColumns ( ) . clear ( ) ; 
for ( int i = left ; 
i <= right ; 
i ++ ) parent . getColumns ( ) . add ( "column" + ( i - left ) ) ; 
} 
} 

public class WebSheetLoader { 
private void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { 
Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; 
List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; 
int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
for ( int irow = insertPosition ; 
irow < ( insertPosition + length ) ; 
irow ++ ) parent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; 
for ( int irow = insertPosition + length - top ; 
irow < parent . getBodyRows ( ) . size ( ) ; 
irow ++ ) { 
FacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; 
facesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; 
} 
} 
} 

public class WebSheetLoader { 
public final Boolean isUnsavedStatus ( ) { 
Map < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; 
Boolean flag = ( Boolean ) viewMap . get ( TieConstants . UNSAVEDSTATE ) ; 
if ( flag == null ) return false ; 
return flag ; 
} 
} 

public class Utils { 
public static < T > Constructor < T > commonConstructor ( Class < T > type ) throws NoMethodForDependency { 
Constructor < ? > [ ] cs = type . getDeclaredConstructors ( ) ; 
if ( cs . length == 0 ) throw new NoMethodForDependency ( raw ( type ) ) ; 
Constructor < ? > mostParamsConstructor = null ; 
for ( Constructor < ? > c : cs ) { 
if ( ! arrayContains ( c . getParameterTypes ( ) , type , ( a , b ) -> a == b ) && ( mostParamsConstructor == null || ( moreVisible ( c , mostParamsConstructor ) == c && ( moreVisible ( mostParamsConstructor , c ) == c || c . getParameterCount ( ) > mostParamsConstructor . getParameterCount ( ) ) ) ) ) mostParamsConstructor = c ; 
} 
if ( mostParamsConstructor == null ) throw new NoMethodForDependency ( raw ( type ) ) ; 
@ SuppressWarnings ( "unchecked" ) Constructor < T > c = ( Constructor < T > ) mostParamsConstructor ; 
return c ; 
} 
} 

public class CacheEntry { 
protected final void writeString ( final Writer writer , final String line ) throws IOException { 
if ( line != null ) writer . write ( line + '\n' ) ; 
else writer . write ( '\n' ) ; 
} 
} 

public class BaseRequestBuilder { 
protected void setConvertedTrafficStatsTag ( final String tag ) { 
result . statsTag = Utils . getTrafficStatsTag ( tag ) ; 
if ( config . isDebugRest ( ) ) Log . d ( TAG , "TrafficStats tag <" + tag + ">=" + Integer . toHexString ( result . statsTag ) ) ; 
} 
} 

public class BaseRequestBuilder { 
protected Parameter removeParameter ( final String name ) { 
if ( name == null ) throw new IllegalArgumentException ( "Parameter name cannot be null" ) ; 
final Iterator < Parameter > iter = result . simpleParameters . getChildren ( ) . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
final Parameter p = iter . next ( ) ; 
if ( name . equals ( p . name ) ) { 
iter . remove ( ) ; 
return p ; 
} 
} 
return null ; 
} 
} 

public class StreamingPlaybackController { 
protected final void bind ( ) { 
if ( bindRequested ) return ; 
final boolean result = context . bindService ( createBindIntent ( ) , serviceConnection , 0 ) ; 
if ( DEBUG ) Log . v ( TAG , "Bind to streaming service: " + result ) ; 
bindRequested = result ; 
onBind ( result ) ; 
} 
} 

public class StreamingPlaybackController { 
protected final void unbind ( ) { 
if ( streamingPlayback != null ) dropListener ( ) ; 
try { 
context . unbindService ( serviceConnection ) ; 
} 
catch ( final RuntimeException e ) { 
if ( DEBUG ) Log . w ( TAG , "Cannot unbind radio" , e ) ; 
} 
bindRequested = false ; 
} 
} 

public class StreamingPlaybackController { 
protected final void dropListener ( ) { 
if ( DEBUG ) Log . v ( TAG , "Drop listener" ) ; 
if ( streamingPlayback != null ) { 
try { 
streamingPlayback . removeListener ( ) ; 
} 
catch ( final RemoteException e ) { 
Log . e ( TAG , "Cannot remove listener" , e ) ; 
} 
bindRequested = false ; 
} 
} 
} 

public class ImageRequest { 
public void storeToDisk ( ) throws IOException { 
if ( manager . isPresentOnDisk ( url ) ) return ; 
if ( ! hasAllowedSize ( ) ) { 
IoUtils . consumeStream ( getRemoteInputStream ( ) , manager . getBuffersPool ( ) ) ; 
return ; 
} 
ImageResult result = decodeStream ( getRemoteInputStream ( ) , true ) ; 
if ( result . getType ( ) == ImageSourceType . NETWORK && result . getBitmap ( ) != null ) writeBitmapToDisk ( result . getBitmap ( ) ) ; 
} 
} 

public class StringPart { 
@ Override protected void sendData ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendData(OutputStream)" ) ; 
out . write ( getContent ( ) ) ; 
} 
} 

public class PoolableBufferedInputStream { 
@ Override public synchronized int available ( ) throws IOException { 
final InputStream localIn = in ; 
if ( buf == null || localIn == null ) throw new IOException ( "Stream is closed" ) ; 
return count - pos + localIn . available ( ) ; 
} 
} 

public class PoolableBufferedInputStream { 
@ Override public void close ( ) throws IOException { 
final byte [ ] localBuf = buf ; 
buf = null ; 
final InputStream localIn = in ; 
in = null ; 
pool . release ( localBuf ) ; 
if ( localIn != null ) localIn . close ( ) ; 
} 
} 

public class PoolableBufferedInputStream { 
@ Override public synchronized int read ( ) throws IOException { 
byte [ ] localBuf = buf ; 
final InputStream localIn = in ; 
if ( localBuf == null || localIn == null ) throw new IOException ( "Stream is closed" ) ; 
if ( pos >= count && fillbuf ( localIn , localBuf ) == - 1 ) return - 1 ; 
if ( localBuf != buf ) { 
localBuf = buf ; 
if ( localBuf == null ) throw new IOException ( "Stream is closed" ) ; 
} 
final int mask = 0xFF ; 
if ( count - pos > 0 ) return localBuf [ pos ++ ] & mask ; 
return - 1 ; 
} 
} 

public class PoolableBufferedInputStream { 
@ Override public synchronized void reset ( ) throws IOException { 
if ( buf == null ) throw new IOException ( "Stream is closed" ) ; 
if ( - 1 == markpos ) throw new IOException ( "Mark has been invalidated." ) ; 
pos = markpos ; 
} 
} 

public class Part { 
protected void sendStart ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendStart(OutputStream out)" ) ; 
out . write ( EXTRA_BYTES ) ; 
out . write ( getPartBoundary ( ) ) ; 
out . write ( CRLF_BYTES ) ; 
} 
} 

public class Part { 
protected void sendDispositionHeader ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendDispositionHeader(OutputStream out)" ) ; 
out . write ( CONTENT_DISPOSITION_BYTES ) ; 
out . write ( QUOTE_BYTES ) ; 
out . write ( EncodingUtils . getAsciiBytes ( getName ( ) ) ) ; 
out . write ( QUOTE_BYTES ) ; 
} 
} 

public class Part { 
protected void sendContentTypeHeader ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendContentTypeHeader(OutputStream out)" ) ; 
final String contentType = getContentType ( ) ; 
if ( contentType != null ) { 
out . write ( CRLF_BYTES ) ; 
out . write ( CONTENT_TYPE_BYTES ) ; 
out . write ( EncodingUtils . getAsciiBytes ( contentType ) ) ; 
final String charSet = getCharSet ( ) ; 
if ( charSet != null ) { 
out . write ( CHARSET_BYTES ) ; 
out . write ( EncodingUtils . getAsciiBytes ( charSet ) ) ; 
} 
} 
} 
} 

public class Part { 
protected void sendTransferEncodingHeader ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendTransferEncodingHeader(OutputStream out)" ) ; 
final String transferEncoding = getTransferEncoding ( ) ; 
if ( transferEncoding != null ) { 
out . write ( CRLF_BYTES ) ; 
out . write ( CONTENT_TRANSFER_ENCODING_BYTES ) ; 
out . write ( EncodingUtils . getAsciiBytes ( transferEncoding ) ) ; 
} 
} 
} 

public class Part { 
protected void sendEndOfHeader ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendEndOfHeader(OutputStream out)" ) ; 
out . write ( CRLF_BYTES ) ; 
out . write ( CRLF_BYTES ) ; 
} 
} 

public class Part { 
protected void sendEnd ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendEnd(OutputStream out)" ) ; 
out . write ( CRLF_BYTES ) ; 
} 
} 

public class Part { 
public static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { 
if ( parts == null ) throw new IllegalArgumentException ( "Parts may not be null" ) ; 
if ( partBoundary == null || partBoundary . length == 0 ) throw new IllegalArgumentException ( "partBoundary may not be empty" ) ; 
for ( int i = 0 ; 
i < parts . length ; 
i ++ ) { 
parts [ i ] . setPartBoundary ( partBoundary ) ; 
parts [ i ] . send ( out ) ; 
} 
out . write ( EXTRA_BYTES ) ; 
out . write ( partBoundary ) ; 
out . write ( EXTRA_BYTES ) ; 
out . write ( CRLF_BYTES ) ; 
} 
} 

public class Part { 
public static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "getLengthOfParts(Parts[])" ) ; 
if ( parts == null ) throw new IllegalArgumentException ( "Parts may not be null" ) ; 
long total = 0 ; 
for ( int i = 0 ; 
i < parts . length ; 
i ++ ) { 
parts [ i ] . setPartBoundary ( partBoundary ) ; 
final long l = parts [ i ] . length ( ) ; 
if ( l < 0 ) return - 1 ; 
total += l ; 
} 
total += EXTRA_BYTES . length ; 
total += partBoundary . length ; 
total += EXTRA_BYTES . length ; 
total += CRLF_BYTES . length ; 
return total ; 
} 
} 

public class WebsockifyProxyHandler { 
static void closeOnFlush ( Channel ch ) { 
if ( ch . isConnected ( ) ) ch . write ( ChannelBuffers . EMPTY_BUFFER ) . addListener ( ChannelFutureListener . CLOSE ) ; 
} 
} 

public class FilePart { 
@ Override protected void sendDispositionHeader ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( "FilePart" , "enter sendDispositionHeader(OutputStream out)" ) ; 
super . sendDispositionHeader ( out ) ; 
final String filename = this . source . getFileName ( ) ; 
if ( filename != null ) { 
out . write ( FILE_NAME_BYTES ) ; 
out . write ( QUOTE_BYTES ) ; 
out . write ( EncodingUtils . getAsciiBytes ( filename ) ) ; 
out . write ( QUOTE_BYTES ) ; 
} 
} 
} 

public class FilePart { 
@ Override protected void sendData ( final OutputStream out ) throws IOException { 
if ( DEBUG ) Log . v ( TAG , "enter sendData(OutputStream out)" ) ; 
if ( lengthOfData ( ) == 0 ) { 
if ( DEBUG ) Log . d ( TAG , "No data to send." ) ; 
return ; 
} 
final int size = 4096 ; 
final byte [ ] tmp = new byte [ size ] ; 
final InputStream instream = source . createInputStream ( ) ; 
try { 
int len ; 
while ( ( len = instream . read ( tmp ) ) >= 0 ) out . write ( tmp , 0 , len ) ; 
} 
finally { 
instream . close ( ) ; 
} 
} 
} 

public class BaseFileResponseCache { 
protected void install ( final int version ) throws IOException { 
if ( buffersPool == null ) throw new IllegalStateException ( "Buffers pool is not resolved" ) ; 
diskCache = DiskLruCache . open ( ensureWorkingDirectory ( ) , version , ENTRIES_COUNT , getMaxSize ( ) ) ; 
onCacheInstalled ( ) ; 
} 
} 

public class BaseFileResponseCache { 
private synchronized File ensureWorkingDirectory ( ) throws IOException { 
File directory = getWorkingDirectory ( ) ; 
if ( ! directory . exists ( ) ) if ( ! directory . mkdirs ( ) ) throw new IOException ( "Working directory " + directory + " cannot be created" ) ; 
else if ( ! directory . isDirectory ( ) ) { 
if ( ! directory . delete ( ) ) throw new IOException ( directory + " is not a directory and cannot be deleted" ) ; 
if ( ! directory . mkdirs ( ) ) throw new IOException ( "Working directory " + directory + " cannot be recreated" ) ; 
} 
return directory ; 
} 
} 

public class BaseFileResponseCache { 
protected CacheResponse get ( final CacheEntry requestInfo ) { 
if ( ! checkDiskCache ( ) ) return null ; 
final CacheEntry entry = newCacheEntry ( ) ; 
final DiskLruCache . Snapshot snapshot = readCacheInfo ( requestInfo , entry ) ; 
if ( snapshot == null ) return null ; 
if ( ! entry . matches ( requestInfo ) || ! entry . canBeUsed ( ) ) { 
snapshot . close ( ) ; 
return null ; 
} 
hitCount . incrementAndGet ( ) ; 
final InputStream body = newBodyInputStream ( snapshot ) ; 
return entry . newCacheResponse ( body ) ; 
} 
} 

public class BufferBitmapDecorator { 
protected void reset ( final int width , final int height ) { 
Bitmap bitmap = this . bitmap ; 
if ( bitmap != null ) bitmap . recycle ( ) ; 
bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; 
this . bitmap = bitmap ; 
this . bitmapCanvas = new Canvas ( bitmap ) ; 
} 
} 

public class LocationBinder { 
public void stopListening ( ) { 
if ( locationManager == null ) return ; 
if ( DEBUG ) Log . d ( TAG , "Stop location listening..." ) ; 
if ( listener != null ) listener . onLocationStop ( ) ; 
myHandler . removeMessages ( MSG_STOP_FINE_PROVIDER ) ; 
locationManager . removeUpdates ( coarseListener ) ; 
locationManager . removeUpdates ( fineListener ) ; 
locationManager = null ; 
} 
} 

public class RequestMethod { 
protected void disconnect ( final URLConnection connection ) { 
final URLConnection http = UrlConnectionWrapper . unwrap ( connection ) ; 
if ( http instanceof HttpURLConnection ) ( ( HttpURLConnection ) http ) . disconnect ( ) ; 
} 
} 

public class ApplicationServiceSupport { 
public void bind ( ) { 
if ( serviceObject != null ) return ; 
final Context context = contextRef . get ( ) ; 
if ( context == null ) return ; 
final Intent intent = new Intent ( context , GoroService . class ) ; 
intent . setAction ( getInterfaceClass ( ) . getName ( ) ) ; 
if ( DEBUG_CALLS ) Log . v ( TAG , "Attempt to bind to service " + this + "/" + context , new RuntimeException ( ) ) ; 
context . startService ( intent ) ; 
final boolean bindResult = context . bindService ( intent , this , 0 ) ; 
if ( DEBUG ) Log . v ( TAG , "Binded to service: " + bindResult + ", " + context + ", interface: " + getInterfaceClass ( ) ) ; 
} 
} 

public class ApplicationServiceSupport { 
public void unbind ( ) { 
if ( serviceObject == null ) return ; 
serviceObject = null ; 
final Context context = contextRef . get ( ) ; 
if ( DEBUG ) Log . v ( TAG , "Unbind " + context + " from " + getInterfaceClass ( ) ) ; 
if ( context == null ) return ; 
try { 
context . unbindService ( this ) ; 
} 
catch ( final Exception e ) { 
if ( DEBUG ) Log . e ( TAG , "Cannot unbind from application service" , e ) ; 
} 
} 
} 

public class ViewImageConsumer { 
public void notifyAboutViewChanges ( ) { 
final T view = this . view ; 
if ( view != null && view instanceof ImagesLoadListenerProvider ) this . listener = ( ( ImagesLoadListenerProvider ) view ) . getImagesLoadListener ( ) ; 
} 
} 

public class RequestBuilderLoader { 
@ Override protected void onReset ( ) { 
if ( DEBUG ) Log . v ( TAG , "onReset " + this ) ; 
super . onReset ( ) ; 
onStopLoading ( ) ; 
if ( receivedResponse != null ) { 
onReleaseData ( receivedResponse ) ; 
receivedResponse = null ; 
} 
} 
} 

public class GUIUtils { 
public static void setTextOrHide ( final TextView view , final CharSequence text , final int hvisibility ) { 
if ( TextUtils . isEmpty ( text ) ) view . setVisibility ( hvisibility ) ; 
else { 
view . setText ( text ) ; 
view . setVisibility ( View . VISIBLE ) ; 
} 
} 
} 

public class ImagesManager { 
public void populateImage ( final View view , final String url ) { 
final Object tag = view . getTag ( ) ; 
ImageConsumer consumer = null ; 
if ( tag == null ) { 
consumer = createImageConsumer ( view ) ; 
view . setTag ( consumer ) ; 
} 
else { 
if ( ! ( tag instanceof ImageConsumer ) ) throw new IllegalStateException ( "View already has a tag " + tag + ". Cannot store consumer" ) ; 
consumer = ( ImageConsumer ) tag ; 
} 
populateImage ( consumer , url ) ; 
} 
} 

public class ImagesManager { 
public void cancelImageLoading ( final View view ) { 
checkThread ( ) ; 
final Object tag = view . getTag ( ) ; 
if ( tag != null && tag instanceof ImageConsumer ) cancelImageLoading ( ( ImageConsumer ) tag ) ; 
} 
} 

public class ImagesManager { 
protected ImageConsumer createImageConsumer ( final View view ) { 
if ( this . consumerFactory == null ) throw new IllegalStateException ( "Image consumers factory bean not found in container. Take a look at DefaultBeansManager.edit().images() method in assist package." ) ; 
return consumerFactory . createConsumer ( view ) ; 
} 
} 

public class ImagesManager { 
private void setLoadingImage ( final ImageConsumer consumer ) { 
if ( ! consumer . skipLoadingImage ( ) ) { 
Drawable d = getLoadingDrawable ( consumer ) ; 
if ( ! consumer . hasUndefinedSize ( ) || ( d . getIntrinsicWidth ( ) != 0 && d . getIntrinsicHeight ( ) != 0 ) ) consumer . setLoadingImage ( d ) ; 
} 
} 
} 

public class ImagesManager { 
private void startImageLoaderTask ( final ImageConsumer consumer , final ImageRequest request ) { 
final String key = request . getKey ( ) ; 
if ( debug ) Log . d ( TAG , "Key " + key ) ; 
ImageLoader loader = currentLoads . get ( key ) ; 
if ( loader != null ) { 
final boolean added = loader . addTarget ( consumer ) ; 
if ( ! added ) loader = null ; 
} 
if ( loader == null ) { 
if ( debug ) Log . d ( TAG , "Start a new task" ) ; 
loader = new ImageLoader ( request , this ) ; 
if ( ! loader . addTarget ( consumer ) ) throw new IllegalStateException ( "Cannot add target to the new loader" ) ; 
currentLoads . put ( key , loader ) ; 
if ( debug ) Log . d ( TAG , "Current loaders count: " + currentLoads . size ( ) ) ; 
final Executor executor = getImageTaskExecutor ( ) ; 
executor . execute ( loader . future ) ; 
} 
else if ( debug ) Log . d ( TAG , "Joined to the existing task " + key ) ; 
} 
} 

public class ImagesManager { 
protected void memCacheImage ( final String url , final Bitmap bitmap ) { 
if ( debug ) Log . d ( TAG , "Memcache for " + url ) ; 
memCache . putElement ( url , bitmap ) ; 
} 
} 

public class BuffersPool { 
public void release ( final byte [ ] buffer ) { 
if ( buffer == null ) return ; 
final int capacity = buffer . length ; 
if ( capacity == 0 ) return ; 
synchronized ( lock ) { 
List < Object > bList = buffers . get ( capacity ) ; 
if ( bList == null ) { 
bList = new LinkedList < Object > ( ) ; 
buffers . put ( capacity , bList ) ; 
} 
bList . add ( buffer ) ; 
usedBuffersCount -- ; 
} 
} 
} 

public class RequestDescription { 
protected void onURLConnectionPrepared ( final Context context , final URLConnection urlConnection ) { 
if ( contentType != null ) urlConnection . addRequestProperty ( "Content-Type" , contentType ) ; 
if ( contentLanguage != null ) urlConnection . addRequestProperty ( "Accept-Language" , contentLanguage ) ; 
urlConnection . addRequestProperty ( "Accept-Encoding" , IoUtils . ENCODING_GZIP ) ; 
urlConnection . addRequestProperty ( "User-Agent" , buildUserAgent ( context ) ) ; 
if ( headers != null ) for ( String name : headers . keySet ( ) ) { 
urlConnection . addRequestProperty ( name , headers . getString ( name ) ) ; 
} 
} 
} 

public class CacheControlUrlConnection { 
private void connectWithWorkaround ( ) throws IOException { 
if ( Build . VERSION . SDK_INT > Build . VERSION_CODES . GINGERBREAD_MR1 ) { 
super . connect ( ) ; 
return ; 
} 
URLConnection coreConnection = UrlConnectionWrapper . unwrap ( getCore ( ) ) ; 
if ( coreConnection instanceof HttpsURLConnection ) try { 
super . connect ( ) ; 
} 
catch ( NullPointerException e ) { 
} 
else super . connect ( ) ; 
} 
} 

public class JCublas2 { 
private static int checkResult ( int result ) { 
if ( exceptionsEnabled && result != cublasStatus . CUBLAS_STATUS_SUCCESS ) throw new CudaException ( cublasStatus . stringFor ( result ) ) ; 
return result ; 
} 
} 

public class JCublas { 
private static void checkResultBLAS ( ) { 
if ( exceptionsEnabled ) { 
lastResult = cublasGetErrorNative ( ) ; 
if ( lastResult != cublasStatus . CUBLAS_STATUS_SUCCESS ) throw new CudaException ( cublasStatus . stringFor ( lastResult ) ) ; 
} 
} 
} 

public class MetricDataRequest { 
public List < MetricData > get ( ) throws RequestException , UnauthorizedException { 
HttpResponse < String > response ; 
try { 
response = Unirest . get ( this . appdURL + "/controller/rest/applications/" + appName + "/metric-data" ) . header ( "accept" , "application/json" ) . basicAuth ( this . appdUsername , this . appdPassword ) . queryString ( getQueryString ( ) ) . queryString ( "output" , "json" ) . asString ( ) ; 
} 
catch ( UnirestException e ) { 
throw new RequestException ( "Something was wrong with sending request." , e ) ; 
} 
if ( response == null ) throw new RequestException ( "Response is empty." ) ; 
switch ( response . getStatus ( ) ) { 
case 200 : { 
return process ( new JsonNode ( response . getBody ( ) ) ) ; 
} 
case 401 : { 
throw new UnauthorizedException ( "Authentication failed" ) ; 
} 
default : { 
throw new RequestException ( "Unhandled response code " + response . getStatus ( ) ) ; 
} 
} 
} 
} 

public class MetricDataRequest { 
protected Map < String , Object > getQueryString ( ) { 
Map < String , Object > qs = new HashMap < > ( ) ; 
if ( timeParams != null ) { 
qs . put ( "time-range-type" , timeParams . type ) ; 
if ( timeParams . duration > 0 ) qs . put ( "duration-in-mins" , timeParams . duration ) ; 
if ( timeParams . startTime > 0 ) qs . put ( "start-time" , timeParams . startTime ) ; 
if ( timeParams . endTime > 0 ) qs . put ( "end-time" , timeParams . endTime ) ; 
} 
qs . put ( "rollup" , false ) ; 
if ( metricPath != null ) qs . put ( "metric-path" , metricPath ) ; 
return qs ; 
} 
} 

public class Config { 
public static ConnectionConfig getConnectionConfig ( ) { 
boolean isValid = true ; 
String appdUsername = getPropertyOrEnv ( "com.signalfx.appd.username" , "APPD_USERNAME" ) ; 
if ( StringUtils . isEmpty ( appdUsername ) ) { 
log . error ( "AppDynamics username not specified." ) ; 
isValid = false ; 
} 
String appdPassword = getPropertyOrEnv ( "com.signalfx.appd.password" , "APPD_PASSWORD" ) ; 
if ( StringUtils . isEmpty ( appdPassword ) ) { 
log . error ( "AppDynamics password not specified." ) ; 
isValid = false ; 
} 
String appdURL = getPropertyOrEnv ( "com.signalfx.appd.host" , "APPD_HOST" ) ; 
if ( StringUtils . isEmpty ( appdURL ) ) { 
log . error ( "AppDynamics host not specified." ) ; 
isValid = false ; 
} 
String fxToken = getPropertyOrEnv ( "com.signalfx.api.token" , "SIGNALFX_TOKEN" ) ; 
if ( StringUtils . isEmpty ( fxToken ) ) { 
log . error ( "SignalFx token not specified." ) ; 
isValid = false ; 
} 
if ( isValid ) return new ConnectionConfig ( appdUsername , appdPassword , appdURL , fxToken ) ; 
else return null ; 
} 
} 

public class ReportAppD { 
public void perform ( List < AppInfo > apps , MetricDataRequest . TimeParams timeParams ) { 
List < SignalFxProtocolBuffers . DataPoint > dataPoints = new LinkedList < > ( ) ; 
for ( AppInfo app : apps ) { 
dataRequest . setAppName ( app . name ) ; 
for ( MetricInfo metricInfo : app . metrics ) { 
dataRequest . setTimeParams ( timeParams ) ; 
dataRequest . setMetricPath ( metricInfo . metricPathQuery ) ; 
List < MetricData > metricDataList ; 
try { 
metricDataList = dataRequest . get ( ) ; 
} 
catch ( RequestException e ) { 
log . error ( "Metric query failure for \"{}\"" , metricInfo . metricPathQuery ) ; 
counterAppDRequestFailure . inc ( ) ; 
continue ; 
} 
catch ( UnauthorizedException e ) { 
log . error ( "AppDynamics authentication failed" ) ; 
return ; 
} 
if ( metricDataList != null && metricDataList . size ( ) > 0 ) for ( MetricData metricData : metricDataList ) { 
MetricTimeSeries mts = metricInfo . getMetricTimeSeries ( metricData . metricPath ) ; 
List < SignalFxProtocolBuffers . DataPoint > mtsDataPoints = processor . process ( mts , metricData . metricValues ) ; 
dataPoints . addAll ( mtsDataPoints ) ; 
if ( ! mtsDataPoints . isEmpty ( ) ) counterMtsReported . inc ( ) ; 
else counterMtsEmpty . inc ( ) ; 
} 
else log . warn ( "No metric found for query \"{}\"" , metricInfo . metricPathQuery ) ; 
} 
} 
if ( ! dataPoints . isEmpty ( ) ) try { 
reporter . report ( dataPoints ) ; 
counterDataPointsReported . inc ( dataPoints . size ( ) ) ; 
} 
catch ( Reporter . ReportException e ) { 
log . error ( "There were errors reporting metric" ) ; 
} 
} 
} 

public class SendAppFeedback { 
protected static void sendLogsToServer ( boolean setSentTime ) { 
long timeSent = new Date ( ) . getTime ( ) ; 
String appFeedBackSummary = Utility . convertFileToString ( "AppFeedBackSummary.json" ) ; 
if ( "" . equals ( appFeedBackSummary ) || "{}" . equals ( appFeedBackSummary ) ) return ; 
else try { 
JSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; 
JSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( "saved" ) ; 
HashMap < String , String > timeSentMap = new HashMap < > ( ) ; 
for ( int i = 0 ; 
i < savedArray . length ( ) ; 
i ++ ) { 
String instanceName = ( String ) savedArray . get ( i ) ; 
String screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; 
String actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; 
if ( actualTimeSent != null ) timeSentMap . put ( instanceName , actualTimeSent ) ; 
} 
for ( int i = 0 ; 
i < savedArray . length ( ) ; 
i ++ ) { 
String instanceName = ( String ) savedArray . get ( i ) ; 
String screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; 
String actualTimeSent = timeSentMap . get ( instanceName ) ; 
String zipFile = Utility . storageDirectory + instanceName + "_" + actualTimeSent + ".zip" ; 
List < String > fileList = new ArrayList < > ( ) ; 
fileList . add ( Utility . getImageFileName ( instanceName ) ) ; 
fileList . add ( screenFeedBackJsonFile ) ; 
Utility . createZipArchive ( fileList , zipFile ) ; 
LogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; 
} 
} 
catch ( JSONException je ) { 
} 
} 
} 

public class LogPersister { 
static public void setContext ( final Context context ) { 
if ( null == LogPersister . context ) { 
LogManager . getLogManager ( ) . getLogger ( "" ) . addHandler ( julHandler ) ; 
java . util . logging . Logger . getLogger ( "" ) . setLevel ( Level . ALL ) ; 
LogPersister . context = context ; 
if ( fileLoggerInstance == null || fileLoggerInstance instanceof FileLogger ) { 
FileLogger . setContext ( context ) ; 
fileLoggerInstance = FileLogger . getInstance ( ) ; 
} 
SharedPreferences prefs = LogPersister . context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; 
if ( null != level ) setLevelSync ( level ) ; 
else setLevelSync ( Logger . LEVEL . fromString ( prefs . getString ( SHARED_PREF_KEY_level , getLevelDefault ( ) . toString ( ) ) ) ) ; 
if ( null != logFileMaxSize ) setMaxLogStoreSize ( logFileMaxSize ) ; 
else setMaxLogStoreSize ( prefs . getInt ( SHARED_PREF_KEY_logFileMaxSize , DEFAULT_logFileMaxSize ) ) ; 
if ( null != capture ) setCaptureSync ( capture ) ; 
else setCaptureSync ( prefs . getBoolean ( SHARED_PREF_KEY_logPersistence , DEFAULT_capture ) ) ; 
uncaughtExceptionHandler = new UncaughtExceptionHandler ( ) ; 
Thread . setDefaultUncaughtExceptionHandler ( uncaughtExceptionHandler ) ; 
} 
} 
} 

public class LogPersister { 
static public void setMaxLogStoreSize ( final int bytes ) { 
if ( bytes >= 10000 ) logFileMaxSize = bytes ; 
if ( null != context ) { 
SharedPreferences prefs = context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; 
prefs . edit ( ) . putInt ( SHARED_PREF_KEY_logFileMaxSize , logFileMaxSize ) . commit ( ) ; 
} 
} 
} 

public class LogPersister { 
protected static String prependMetadata ( String message , JSONObject metadata ) { 
try { 
if ( null != metadata ) { 
String clazz = "" ; 
String method = "" ; 
String file = "" ; 
String line = "" ; 
if ( metadata . has ( "$class" ) ) { 
clazz = metadata . getString ( "$class" ) ; 
clazz = clazz . substring ( clazz . lastIndexOf ( '.' ) + 1 , clazz . length ( ) ) ; 
} 
if ( metadata . has ( "$method" ) ) method = metadata . getString ( "$method" ) ; 
if ( metadata . has ( "$file" ) ) file = metadata . getString ( "$file" ) ; 
if ( metadata . has ( "$line" ) ) line = metadata . getString ( "$line" ) ; 
if ( ! ( clazz + method + file + line ) . equals ( "" ) ) message = clazz + "." + method + " in " + file + ":" + line + " :: " + message ; 
} 
} 
catch ( Exception e ) { 
} 
return message ; 
} 
} 

public class LogPersister { 
protected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { 
JSONObject jsonMetadata ; 
if ( additionalMetadata != null ) jsonMetadata = additionalMetadata ; 
else jsonMetadata = new JSONObject ( ) ; 
try { 
StackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; 
int index = 0 ; 
while ( ! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ) index ++ ; 
while ( stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ) index ++ ; 
jsonMetadata . put ( "$class" , stackTraceElements [ index ] . getClassName ( ) ) ; 
jsonMetadata . put ( "$file" , stackTraceElements [ index ] . getFileName ( ) ) ; 
jsonMetadata . put ( "$method" , stackTraceElements [ index ] . getMethodName ( ) ) ; 
jsonMetadata . put ( "$line" , stackTraceElements [ index ] . getLineNumber ( ) ) ; 
jsonMetadata . put ( "$src" , "java" ) ; 
} 
catch ( Exception e ) { 
Log . e ( LOG_TAG_NAME , "Could not generate jsonMetadata object." , e ) ; 
} 
return jsonMetadata ; 
} 
} 

public class LogPersister { 
private static JSONObject createJSONObject ( final Logger . LEVEL level , final String pkg , final String message , long timestamp , final JSONObject jsonMetadata , final Throwable t ) { 
JSONObject jsonObject = new JSONObject ( ) ; 
try { 
jsonObject . put ( "timestamp" , timestamp ) ; 
jsonObject . put ( "level" , level . toString ( ) ) ; 
jsonObject . put ( "pkg" , pkg ) ; 
jsonObject . put ( "msg" , message ) ; 
jsonObject . put ( "threadid" , Thread . currentThread ( ) . getId ( ) ) ; 
if ( null != jsonMetadata ) jsonObject . put ( "metadata" , jsonMetadata ) ; 
if ( null != t ) jsonObject . put ( "metadata" , appendFullStackTrace ( jsonMetadata , t ) ) ; 
} 
catch ( JSONException e ) { 
Log . e ( LOG_TAG_NAME , "Error adding JSONObject key/value pairs" , e ) ; 
} 
return jsonObject ; 
} 
} 

public class BMSAnalytics { 
private static void setUserIdentity ( final String user , boolean isInitialCtx ) { 
if ( ! isInitialCtx && ! BMSAnalytics . hasUserContext ) { 
logger . error ( "Cannot set user identity with anonymous user collection enabled." ) ; 
return ; 
} 
JSONObject metadata = new JSONObject ( ) ; 
DEFAULT_USER_ID = user ; 
String hashedUserID = UUID . nameUUIDFromBytes ( user . getBytes ( ) ) . toString ( ) ; 
try { 
if ( isInitialCtx ) metadata . put ( CATEGORY , INITIAL_CTX_CATEGORY ) ; 
else metadata . put ( CATEGORY , USER_SWITCH_CATEGORY ) ; 
if ( BMSAnalytics . collectLocation ) if ( locationService . getInitLocationRequests ( ) ) { 
metadata . put ( LONGITUDE_KEY , locationService . getLongitude ( ) ) ; 
metadata . put ( LATITUDE_KEY , locationService . getLatitude ( ) ) ; 
} 
metadata . put ( TIMESTAMP_KEY , ( new Date ( ) ) . getTime ( ) ) ; 
metadata . put ( APP_SESSION_ID_KEY , MFPAnalyticsActivityLifecycleListener . getAppSessionID ( ) ) ; 
metadata . put ( USER_ID_KEY , hashedUserID ) ; 
} 
catch ( JSONException e ) { 
logger . debug ( "JSONException encountered logging change in user context: " + e . getMessage ( ) ) ; 
} 
MFPInAppFeedBackListner . setUserIdentity ( user ) ; 
log ( metadata ) ; 
} 
} 

public class FileLogger { 
private byte [ ] getByteArrayFromFile ( final String file ) throws UnsupportedEncodingException { 
String ret = "" ; 
File fl = new File ( context . getFilesDir ( ) , file ) ; 
if ( fl . exists ( ) ) try { 
FileInputStream fin = new FileInputStream ( fl ) ; 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ( int ) fl . length ( ) ) ; 
copyStream ( fin , baos ) ; 
return baos . toByteArray ( ) ; 
} 
catch ( IOException e ) { 
Log . e ( LogPersister . LOG_TAG_NAME , "problem reading file " + fl . toString ( ) , e ) ; 
} 
return ret . getBytes ( "UTF-8" ) ; 
} 
} 

public class MFPAnalyticsLocationListener { 
protected void startLocationUpdates ( ) { 
if ( ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_FINE_LOCATION ) != PackageManager . PERMISSION_GRANTED && ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_COARSE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) return ; 
LocationServices . FusedLocationApi . requestLocationUpdates ( mGoogleApiClient , mLocationRequest , this ) ; 
} 
} 

public class ObjectSizing { 
public void sizeRegion ( Region < ? , ? > region , int numEntries ) { 
if ( region == null ) throw new IllegalArgumentException ( "Region is null." ) ; 
if ( region instanceof PartitionedRegion ) sizePartitionedRegion ( region , numEntries ) ; 
else sizeReplicatedOrLocalRegion ( region , numEntries ) ; 
} 
} 

public class ObjectSizing { 
private void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { 
Region < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; 
int regionSize = primaryDataSet . size ( ) ; 
if ( numEntries == 0 ) numEntries = primaryDataSet . size ( ) ; 
else if ( numEntries > regionSize ) numEntries = regionSize ; 
int count = 0 ; 
for ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
if ( count == numEntries ) break ; 
EntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; 
RegionEntry re = entry . getRegionEntry ( ) ; 
dumpSizes ( entry , re ) ; 
} 
dumpTotalAndAverageSizes ( numEntries ) ; 
clearTotals ( ) ; 
} 
} 

public class ObjectSizing { 
private void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { 
Set < ? > entries = region . entrySet ( ) ; 
int regionSize = entries . size ( ) ; 
if ( numEntries == 0 ) numEntries = entries . size ( ) ; 
else if ( numEntries > regionSize ) numEntries = regionSize ; 
int count = 0 ; 
for ( Iterator < ? > i = entries . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
if ( count == numEntries ) break ; 
LocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; 
RegionEntry re = entry . getRegionEntry ( ) ; 
dumpSizes ( entry , re ) ; 
} 
dumpTotalAndAverageSizes ( numEntries ) ; 
clearTotals ( ) ; 
} 
} 

public class SnapshotRecordReader { 
public SnapshotRecord readSnapshotRecord ( ) throws IOException , ClassNotFoundException { 
byte [ ] key = DataSerializer . readByteArray ( dis ) ; 
if ( key == null ) return null ; 
byte [ ] value = DataSerializer . readByteArray ( dis ) ; 
return new SnapshotRecord ( key , value ) ; 
} 
} 

public class TimeStampSeries { 
void dump ( PrintWriter stream ) { 
stream . print ( "[size=" + count ) ; 
for ( int i = 0 ; 
i < count ; 
i ++ ) if ( i != 0 ) { 
stream . print ( ", " ) ; 
stream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; 
} 
else stream . print ( " " + timeStamps [ i ] ) ; 
stream . println ( "]" ) ; 
} 
} 

public class TimeStampSeries { 
double [ ] getTimeValuesSinceIdx ( int idx ) { 
int resultSize = this . count - idx ; 
double [ ] result = new double [ resultSize ] ; 
for ( int i = 0 ; 
i < resultSize ; 
i ++ ) result [ i ] = getMilliTimeStamp ( idx + i ) ; 
return result ; 
} 
} 

public class GemFireJmxClient { 
public static Collection < String > listHosts ( JMX jmx ) { 
Set < ObjectName > objectNames = jmx . searchObjectNames ( "GemFire:type=Member,member=*" ) ; 
if ( objectNames == null || objectNames . isEmpty ( ) ) return null ; 
HashSet < String > hostLists = new HashSet < String > ( objectNames . size ( ) ) ; 
MemberMXBean memberMXBean = null ; 
for ( ObjectName objectName : objectNames ) { 
memberMXBean = jmx . newBean ( MemberMXBean . class , objectName ) ; 
hostLists . add ( memberMXBean . getHost ( ) ) ; 
} 
return hostLists ; 
} 
} 

public class Querier { 
@ SuppressWarnings ( "unchecked" ) public static < ReturnType > Collection < ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException { 
SelectResults < ReturnType > selectResults ; 
if ( rfc == null || JvmRegionFunctionContext . class . isAssignableFrom ( rfc . getClass ( ) ) ) { 
if ( params == null || params . length == 0 ) selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( ) ; 
else selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( params ) ; 
if ( selectResults == null || selectResults . isEmpty ( ) ) return null ; 
ArrayList < ReturnType > results = new ArrayList < ReturnType > ( selectResults . size ( ) ) ; 
results . addAll ( selectResults . asList ( ) ) ; 
return results ; 
} 
else { 
if ( params == null || params . length == 0 ) selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; 
else selectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; 
if ( selectResults == null || selectResults . isEmpty ( ) ) return null ; 
return selectResults ; 
} 
} 
} 

public class ReadExportFunction { 
@ Override public void execute ( FunctionContext < Object > functionContext ) { 
ResultSender < Object > sender = functionContext . getResultSender ( ) ; 
Cache cache = CacheFactory . getAnyInstance ( ) ; 
Logger logWriter = LogManager . getLogger ( getClass ( ) ) ; 
try { 
String [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; 
if ( args == null || args . length != 2 ) throw new FunctionException ( "Required array args: [region,extension]" ) ; 
String extensionArg = args [ 0 ] ; 
if ( extensionArg == null || extensionArg . length ( ) == 0 ) throw new IllegalArgumentException ( "File extension required" ) ; 
ExportFileType extension = ExportFileType . valueOf ( extensionArg ) ; 
String regionName = args [ 1 ] ; 
Region < Object , Object > region = cache . getRegion ( regionName ) ; 
if ( region == null ) { 
sender . lastResult ( null ) ; 
return ; 
} 
File file = new File ( new StringBuilder ( directoryPath ) . append ( "/" ) . append ( regionName ) . append ( "." ) . append ( extensionArg ) . toString ( ) ) ; 
String serverName = cache . getDistributedSystem ( ) . getDistributedMember ( ) . getName ( ) ; 
switch ( extension ) { 
case gfd : new GfdExportFunction ( ) . exportRegion ( region ) ; 
break ; 
default : throw new IllegalArgumentException ( "Unsupported extension file type:" + extension ) ; 
} 
Serializable content = readContent ( file , extension , logWriter ) ; 
Serializable [ ] arrayResults = { 
serverName , content , file . getAbsolutePath ( ) } 
; 
sender . lastResult ( arrayResults ) ; 
} 
catch ( Exception e ) { 
String stackTrace = Debugger . stackTrace ( e ) ; 
logWriter . error ( stackTrace ) ; 
throw new FunctionException ( stackTrace ) ; 
} 
} 
} 

public class GemFireInspector { 
public static Set < String > listHosts ( JMX jmx ) { 
Set < ObjectName > memberObjects = jmx . searchObjectNames ( "GemFire:type=Member,member=*" ) ; 
if ( memberObjects == null || memberObjects . isEmpty ( ) ) return null ; 
HashSet < String > hostList = new HashSet < String > ( memberObjects . size ( ) ) ; 
MemberMXBean bean = null ; 
for ( ObjectName objectName : memberObjects ) { 
bean = jmx . newBean ( MemberMXBean . class , objectName ) ; 
try { 
hostList . add ( bean . getHost ( ) ) ; 
} 
catch ( UndeclaredThrowableException e ) { 
} 
} 
return hostList ; 
} 
} 

public class LuceneSearchFunction { 
@ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) @ Override public void execute ( FunctionContext functionContext ) { 
Cache cache = CacheFactory . getAnyInstance ( ) ; 
try { 
if ( ! ( functionContext instanceof RegionFunctionContext ) ) throw new FunctionException ( "Execute on a region" ) ; 
Object args = functionContext . getArguments ( ) ; 
if ( args == null ) throw new FunctionException ( "arguments is required" ) ; 
TextPageCriteria criteria = null ; 
if ( args instanceof PdxInstance ) { 
PdxInstance pdxInstance = ( PdxInstance ) args ; 
try { 
criteria = ( TextPageCriteria ) ( pdxInstance . getObject ( ) ) ; 
} 
catch ( PdxSerializationException e ) { 
throw new FunctionException ( e . getMessage ( ) + " JSON:" + JSONFormatter . toJSON ( pdxInstance ) ) ; 
} 
} 
else criteria = ( TextPageCriteria ) args ; 
Region < String , Collection < Object > > pagingRegion = cache . getRegion ( criteria . getPageRegionName ( ) ) ; 
Region < ? , ? > region = cache . getRegion ( criteria . getRegionName ( ) ) ; 
GeodePagination pagination = new GeodePagination ( ) ; 
TextPolicySearchStrategy geodeSearch = new TextPolicySearchStrategy ( cache ) ; 
geodeSearch . saveSearchResultsWithPageKeys ( criteria , criteria . getQuery ( ) , null , ( Region < String , Collection < Object > > ) pagingRegion ) ; 
Collection < Object > collection = pagination . readResultsByPageValues ( criteria . getId ( ) , criteria . getSortField ( ) , criteria . isSortDescending ( ) , criteria . getBeginIndex ( ) , ( Region < Object , Object > ) region , ( Region ) pagingRegion ) ; 
if ( collection == null ) { 
functionContext . getResultSender ( ) . lastResult ( null ) ; 
return ; 
} 
PagingCollection < Object > pageCollection = new PagingCollection < Object > ( collection , criteria ) ; 
functionContext . getResultSender ( ) . lastResult ( pageCollection ) ; 
} 
catch ( RuntimeException e ) { 
Logger logger = LogManager . getLogger ( LuceneSearchFunction . class ) ; 
logger . error ( Debugger . stackTrace ( e ) ) ; 
throw e ; 
} 
} 
} 

public class GeodeClient { 
@ SuppressWarnings ( "unchecked" ) public < K , V > Region < K , V > getRegion ( String regionName ) { 
if ( regionName == null || regionName . length ( ) == 0 ) return null ; 
Region < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; 
if ( region != null ) return ( Region < K , V > ) region ; 
region = ( Region < K , V > ) this . createRegion ( regionName ) ; 
if ( cachingProxy ) region . registerInterestRegex ( ".*" ) ; 
return region ; 
} 
} 

public class RegionDiffDirector { 
public void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) { 
if ( sourceChecksumMap == null ) { 
if ( targetMap != null && ! targetMap . isEmpty ( ) ) this . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; 
return ; 
} 
if ( targetMap == null ) { 
this . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; 
return ; 
} 
BigInteger targetBi = null ; 
BigInteger sourceBi = null ; 
for ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) { 
targetBi = targetMap . get ( entrySource . getKey ( ) ) ; 
sourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; 
if ( targetBi == null ) keysMissingOnTarget . add ( entrySource . getKey ( ) ) ; 
else if ( ! targetBi . equals ( sourceBi ) ) keysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; 
} 
Set < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; 
for ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) { 
if ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) keysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; 
} 
} 
} 

public class GfStatsReader { 
public void close ( ) throws IOException { 
if ( ! this . closed ) { 
this . closed = true ; 
this . is . close ( ) ; 
this . dataIn . close ( ) ; 
this . is = null ; 
this . dataIn = null ; 
int typeCount = 0 ; 
if ( this . resourceTypeTable != null ) { 
for ( int i = 0 ; 
i < this . resourceTypeTable . length ; 
i ++ ) if ( this . resourceTypeTable [ i ] != null ) if ( this . resourceTypeTable [ i ] . close ( ) ) this . resourceTypeTable [ i ] = null ; 
else typeCount ++ ; 
ResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; 
typeCount = 0 ; 
for ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { 
if ( aResourceTypeTable != null ) { 
newTypeTable [ typeCount ] = aResourceTypeTable ; 
typeCount ++ ; 
} 
} 
this . resourceTypeTable = newTypeTable ; 
} 
if ( this . resourceInstTable != null ) { 
int instCount = 0 ; 
for ( int i = 0 ; 
i < this . resourceInstTable . length ; 
i ++ ) if ( this . resourceInstTable [ i ] != null ) if ( this . resourceInstTable [ i ] . close ( ) ) this . resourceInstTable [ i ] = null ; 
else instCount ++ ; 
ResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; 
instCount = 0 ; 
for ( ResourceInst aResourceInstTable : this . resourceInstTable ) { 
if ( aResourceInstTable != null ) { 
newInstTable [ instCount ] = aResourceInstTable ; 
instCount ++ ; 
} 
} 
this . resourceInstTable = newInstTable ; 
this . resourceInstSize = instCount ; 
} 
this . timeSeries . shrink ( ) ; 
this . filters = null ; 
} 
} 
} 

public class SingletonGemFireJmx { 
public synchronized static JMX reconnect ( ) { 
try { 
ClientCache cache = null ; 
cache = ClientCacheFactory . getAnyInstance ( ) ; 
if ( cache != null && ! cache . isClosed ( ) ) cache . close ( ) ; 
} 
catch ( Exception e ) { 
System . out . println ( "Cache was closed" ) ; 
} 
if ( jmx != null ) { 
jmx . dispose ( ) ; 
jmx = null ; 
} 
return getJmx ( ) ; 
} 
} 

public class GemFireMgmt { 
public static int stopMembersOnHost ( String hostName ) { 
JMX jmx = SingletonGemFireJmx . getJmx ( ) ; 
String objectNamePattern = "GemFire:type=Member,member=*" ; 
QueryExp queryExp = null ; 
ValueExp [ ] values = null ; 
try { 
InetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; 
InetAddress address = null ; 
if ( addresses != null ) { 
values = new ValueExp [ addresses . length ] ; 
for ( int i = 0 ; 
i < addresses . length ; 
i ++ ) { 
address = addresses [ i ] ; 
values [ i ] = Query . value ( address . getHostAddress ( ) ) ; 
} 
} 
} 
catch ( UnknownHostException e ) { 
Debugger . println ( e . getMessage ( ) ) ; 
} 
if ( values != null ) queryExp = Query . or ( Query . eq ( Query . attr ( "Host" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( "Host" ) , values ) ) ; 
else queryExp = Query . eq ( Query . attr ( "Host" ) , Query . value ( hostName ) ) ; 
Set < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; 
if ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; 
int memberCount = memberObjectNames . size ( ) ; 
MemberMXBean member = null ; 
Collection < String > locators = new ArrayList < String > ( ) ; 
for ( ObjectName objectName : memberObjectNames ) { 
member = GemFireJmxClient . getMember ( objectName . getKeyProperty ( "member" ) , SingletonGemFireJmx . getJmx ( ) ) ; 
if ( member . isLocator ( ) ) locators . add ( member . getName ( ) ) ; 
else shutDownMember ( member . getName ( ) ) ; 
} 
for ( String locatorName : locators ) { 
shutDownMember ( locatorName ) ; 
} 
return memberCount ; 
} 
} 

public class GemFireMgmt { 
public static void shutDownMember ( String name ) { 
try { 
ObjectName serverName = new ObjectName ( "GemFire:type=Member,member=" + name ) ; 
JMX jmx = SingletonGemFireJmx . getJmx ( ) ; 
MemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; 
bean . shutDownMember ( ) ; 
System . out . println ( "Waiting for member:" + name + "  to shutdown" ) ; 
while ( GemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ) Thread . sleep ( shutDownDelay ) ; 
} 
catch ( MalformedObjectNameException e ) { 
throw new RuntimeException ( "Unable to shutdown member " + name + " ERROR:" + e . getMessage ( ) , e ) ; 
} 
catch ( Exception e ) { 
System . out . println ( e . getMessage ( ) ) ; 
} 
} 
} 

public class GemFireNetworking { 
public static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { 
if ( remoteLocators == null || remoteLocators . length ( ) == 0 ) return false ; 
if ( remoteLocators . equalsIgnoreCase ( locators ) ) return true ; 
String [ ] remoteLocatorsArray = remoteLocators . split ( "," ) ; 
if ( locators == null || locators . length ( ) == 0 ) return false ; 
String [ ] locatorsArray = locators . split ( "," ) ; 
String remoteLocatorHost , locatorHost ; 
int remoteLocatorPort , locatorPort ; 
for ( String remoteLocator : remoteLocatorsArray ) { 
if ( remoteLocator == null || remoteLocator . length ( ) == 0 ) continue ; 
for ( String locator : locatorsArray ) { 
if ( locator == null || locator . length ( ) == 0 ) continue ; 
try { 
remoteLocatorHost = parseLocatorHost ( remoteLocator ) ; 
locatorHost = parseLocatorHost ( locator ) ; 
remoteLocatorPort = parseLocatorPort ( remoteLocator ) ; 
locatorPort = parseLocatorPort ( locator ) ; 
if ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) return true ; 
else { 
} 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
catch ( IllegalArgumentException e ) { 
throw new IllegalArgumentException ( "remoteLocator:" + remoteLocator + " locator:" + locator + " ERROR:" + e . getMessage ( ) , e ) ; 
} 
} 
} 
return false ; 
} 
} 

public class GetEntriesChecksumFunction { 
HashMap < Serializable , BigInteger > buildCheckSumMap ( Region < Serializable , Object > region ) { 
if ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) region = PartitionRegionHelper . getLocalData ( region ) ; 
Set < Serializable > keySet = region . keySet ( ) ; 
if ( keySet == null || keySet . isEmpty ( ) ) return null ; 
HashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; 
Object object = null ; 
Object tmp = null ; 
for ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) { 
object = entry . getValue ( ) ; 
if ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) { 
tmp = ( ( PdxInstance ) object ) . getObject ( ) ; 
if ( Serializable . class . isAssignableFrom ( tmp . getClass ( ) ) ) object = tmp ; 
} 
if ( ! ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) ) regionCheckSumMap . put ( entry . getKey ( ) , MD . checksum ( object ) ) ; 
else regionCheckSumMap . put ( entry . getKey ( ) , BigInteger . valueOf ( object . hashCode ( ) ) ) ; 
} 
return regionCheckSumMap ; 
} 
} 

public class SqliteInteger { 
boolean isTypeOf ( TypeMirror typeMirror ) { 
if ( integerKinds . contains ( typeMirror . getKind ( ) ) ) return true ; 
if ( integerObjects . contains ( typeMirror . toString ( ) ) ) return true ; 
return false ; 
} 
} 

public class ShillelaghUtil { 
@ SuppressWarnings ( "unchecked" ) public static < T > T createInstance ( Class < T > clazz ) { 
if ( clazz . isInterface ( ) ) { 
if ( clazz == List . class ) return ( T ) new ArrayList ( ) ; 
else if ( clazz == Map . class ) return ( T ) new HashMap ( ) ; 
throw new UnsupportedOperationException ( "Interface types can not be instantiated." ) ; 
} 
ObjectInstantiator instantiator = OBJENESIS . getInstantiatorOf ( clazz ) ; 
return ( T ) instantiator . newInstance ( ) ; 
} 
} 

public class ShillelaghProcessor { 
private void checkForTableId ( TableObject tableObject , Element element ) { 
Id idAnnotation = element . getAnnotation ( Id . class ) ; 
if ( idAnnotation != null ) { 
if ( element . asType ( ) . getKind ( ) != TypeKind . LONG && ! ( "java.lang.Long" . equals ( element . asType ( ) . toString ( ) ) ) ) logger . e ( "@Id must be on a long" ) ; 
String columnName = Strings . isBlank ( idAnnotation . name ( ) ) ? element . getSimpleName ( ) . toString ( ) : idAnnotation . name ( ) ; 
final TableColumn idColumn = new TableColumn ( columnName , element . getSimpleName ( ) . toString ( ) , element . asType ( ) . toString ( ) , SqliteType . INTEGER ) ; 
tableObject . setIdColumn ( idColumn ) ; 
} 
} 
} 

public class ShillelaghProcessor { 
private void checkForFields ( TableObject tableObject , Element columnElement ) { 
Column columnAnnotation = columnElement . getAnnotation ( Column . class ) ; 
if ( columnAnnotation == null ) return ; 
final Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; 
final String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; 
TableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; 
if ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { 
String columnType = columnElement . asType ( ) . toString ( ) ; 
logger . d ( "Column Element Type: " + columnType ) ; 
if ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( "java.lang.Byte[]" ) && ! columnType . startsWith ( "java.util.Map" ) && ! columnType . startsWith ( "java.util.List" ) ) logger . e ( String . format ( "%s in %s is not Serializable and will not be able to be converted to a byte array" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; 
} 
else if ( tableColumn . isOneToMany ( ) ) { 
TypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; 
if ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) logger . e ( "One to many relationship in class %s where %s is not annotated with @Table" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; 
oneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; 
TypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; 
tableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; 
} 
else if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { 
@ SuppressWarnings ( "ConstantConditions" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; 
if ( annotation == null ) logger . e ( String . format ( "%s in %s needs to be marked as a blob or should be " + "annotated with @Table" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; 
tableColumn . setOneToOne ( true ) ; 
} 
tableObject . addColumn ( tableColumn ) ; 
} 
} 

public class ShillelaghProcessor { 
private boolean checkForSuperType ( Element element , Class type ) { 
List < ? extends TypeMirror > superTypes = typeUtils . directSupertypes ( element . asType ( ) ) ; 
for ( TypeMirror superType : superTypes ) { 
if ( superType . toString ( ) . equals ( type . getName ( ) ) ) return true ; 
} 
return false ; 
} 
} 

public class TableObject { 
private String getSchema ( ) { 
StringBuilder sb = new StringBuilder ( ) ; 
Iterator < TableColumn > iterator = columns . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
TableColumn column = iterator . next ( ) ; 
if ( column . isOneToMany ( ) ) { 
if ( ! iterator . hasNext ( ) ) { 
int length = sb . length ( ) ; 
sb . replace ( length - 2 , length , "" ) ; 
} 
continue ; 
} 
sb . append ( column ) ; 
if ( iterator . hasNext ( ) ) sb . append ( ", " ) ; 
} 
String idCol = idColumn == null ? "id_missing" : idColumn . getColumnName ( ) ; 
return String . format ( CREATE_TABLE_DEFAULT , getTableName ( ) , idCol , sb . toString ( ) ) ; 
} 
} 

public class Builder { 
public final Observable < T > toObservable ( ) { 
if ( ! HAS_RX_JAVA ) throw new RuntimeException ( "RxJava not available! Add RxJava to your build to use this feature" ) ; 
return shillelagh . getObservable ( tableObject , new CursorLoader ( ) { 
@ Override public Cursor getCursor ( ) { 
return shillelagh . rawQuery ( query . toString ( ) ) ; 
} 
} 
) ; 
} 
} 

public class Strings { 
static String capitalize ( String string ) { 
if ( isBlank ( string ) ) return "" ; 
char first = string . charAt ( 0 ) ; 
if ( Character . isUpperCase ( first ) ) return string ; 
else return Character . toUpperCase ( first ) + string . substring ( 1 ) ; 
} 
} 

public class SqliteReal { 
boolean isTypeOf ( TypeMirror typeMirror ) { 
if ( realKinds . contains ( typeMirror . getKind ( ) ) ) return true ; 
if ( realObjects . contains ( typeMirror . toString ( ) ) ) return true ; 
return false ; 
} 
} 

public class OneWireTemperatureSensor { 
public float readTemperature ( ) throws IOException { 
byte [ ] encoded = Files . readAllBytes ( new File ( deviceFile , "w1_slave" ) . toPath ( ) ) ; 
String tmp = new String ( encoded ) ; 
int tmpIndex = tmp . indexOf ( "t=" ) ; 
if ( tmpIndex < 0 ) throw new IOException ( "Could not read temperature!" ) ; 
return Integer . parseInt ( tmp . substring ( tmpIndex + 2 ) . trim ( ) ) / 1000f ; 
} 
} 

public class ColumnVector { 
protected void set ( final float values [ ] ) { 
this . m_nRows = values . length ; 
this . m_nCols = 1 ; 
this . m_aValues = new float [ m_nRows ] [ 1 ] ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) this . m_aValues [ r ] [ 0 ] = values [ r ] ; 
} 
} 

public class BigFunctions { 
public static BigDecimal intPower ( @ Nonnull final BigDecimal px , final long pexponent , final int scale ) { 
BigDecimal x = px ; 
long exponent = pexponent ; 
if ( exponent < 0 ) return BigDecimal . ONE . divide ( intPower ( x , - exponent , scale ) , scale , RoundingMode . HALF_EVEN ) ; 
BigDecimal power = BigDecimal . ONE ; 
while ( exponent > 0 ) { 
if ( ( exponent & 1 ) == 1 ) power = power . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
x = x . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
exponent >>= 1 ; 
Thread . yield ( ) ; 
} 
return power ; 
} 
} 

public class BigFunctions { 
public static BigDecimal intRoot ( @ Nonnull final BigDecimal px , final long index , final int scale ) { 
BigDecimal x = px ; 
if ( x . signum ( ) < 0 ) throw new IllegalArgumentException ( "x < 0: " + x ) ; 
final int sp1 = scale + 1 ; 
final BigDecimal n = x ; 
final BigDecimal i = BigDecimal . valueOf ( index ) ; 
final BigDecimal im1 = BigDecimal . valueOf ( index - 1 ) ; 
final BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; 
BigDecimal xPrev ; 
x = x . divide ( i , scale , RoundingMode . HALF_EVEN ) ; 
do { 
final BigDecimal xToIm1 = intPower ( x , index - 1 , sp1 ) ; 
final BigDecimal xToI = x . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
final BigDecimal numerator = n . add ( im1 . multiply ( xToI ) ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
final BigDecimal denominator = i . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
xPrev = x ; 
x = numerator . divide ( denominator , sp1 , RoundingMode . DOWN ) ; 
Thread . yield ( ) ; 
} 
while ( x . subtract ( xPrev ) . abs ( ) . compareTo ( tolerance ) > 0 ) ; 
return x ; 
} 
} 

public class BigFunctions { 
public static BigDecimal ln ( @ Nonnull final BigDecimal x , final int scale ) { 
if ( x . signum ( ) <= 0 ) throw new IllegalArgumentException ( "x <= 0: " + x ) ; 
final int magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; 
if ( magnitude < 3 ) return _lnNewton ( x , scale ) ; 
final BigDecimal root = intRoot ( x , magnitude , scale ) ; 
final BigDecimal lnRoot = _lnNewton ( root , scale ) ; 
return BigDecimal . valueOf ( magnitude ) . multiply ( lnRoot ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} 
} 

public class BigFunctions { 
public static BigDecimal arctan ( @ Nonnull final BigDecimal x , final int scale ) { 
if ( x . abs ( ) . compareTo ( BigDecimal . ONE ) >= 0 ) throw new IllegalArgumentException ( "|x| >= 1: " + x ) ; 
if ( x . signum ( ) == - 1 ) return arctan ( x . negate ( ) , scale ) . negate ( ) ; 
return _arctanTaylor ( x , scale ) ; 
} 
} 

public class BigFunctions { 
public static BigDecimal sqrt ( @ Nonnull final BigDecimal x , final int scale ) { 
if ( x . signum ( ) < 0 ) throw new IllegalArgumentException ( "x < 0: " + x ) ; 
final BigInteger n = x . movePointRight ( scale << 1 ) . toBigInteger ( ) ; 
final int bits = ( n . bitLength ( ) + 1 ) >> 1 ; 
BigInteger ix = n . shiftRight ( bits ) ; 
BigInteger ixPrev ; 
do { 
ixPrev = ix ; 
ix = ix . add ( n . divide ( ix ) ) . shiftRight ( 1 ) ; 
Thread . yield ( ) ; 
} 
while ( ix . compareTo ( ixPrev ) != 0 ) ; 
return new BigDecimal ( ix , scale ) ; 
} 
} 

public class AbstractPiFormula { 
protected void printPi ( final String piString ) { 
System . out . print ( "\npi = " + piString . substring ( 0 , 2 ) ) ; 
int index = 2 ; 
int line = 0 ; 
int group = 0 ; 
final int length = piString . length ( ) ; 
while ( index + 5 < length ) { 
System . out . print ( piString . substring ( index , index + 5 ) + " " ) ; 
index += 5 ; 
if ( ++ group == 10 ) { 
System . out . println ( ) ; 
if ( ++ line == 10 ) { 
System . out . println ( ) ; 
line = 0 ; 
} 
System . out . print ( "       " ) ; 
group = 0 ; 
} 
} 
if ( index < length ) System . out . println ( piString . substring ( index ) ) ; 
} 
} 

public class Buckets { 
public void print ( ) { 
int maxCount = 0 ; 
for ( int i = 0 ; 
i < m_n ; 
++ i ) maxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; 
final float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; 
for ( int i = 0 ; 
i < m_n ; 
++ i ) { 
final int b = m_aCounters [ i ] ; 
m_aAlignRight . print ( i , 2 ) ; 
m_aAlignRight . print ( b , 7 ) ; 
System . out . print ( ": " ) ; 
final int length = Math . round ( factor * b ) ; 
for ( int j = 0 ; 
j < length ; 
++ j ) System . out . print ( "*" ) ; 
System . out . println ( ) ; 
} 
} 
} 

public class Matrix { 
public RowVector getRow ( final int r ) throws MatrixException { 
if ( ( r < 0 ) || ( r >= m_nRows ) ) throw new MatrixException ( MatrixException . INVALID_INDEX ) ; 
final RowVector rv = new RowVector ( m_nCols ) ; 
for ( int c = 0 ; 
c < m_nCols ; 
++ c ) rv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; 
return rv ; 
} 
} 

public class Matrix { 
public ColumnVector getColumn ( final int c ) throws MatrixException { 
if ( ( c < 0 ) || ( c >= m_nCols ) ) throw new MatrixException ( MatrixException . INVALID_INDEX ) ; 
final ColumnVector cv = new ColumnVector ( m_nRows ) ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) cv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; 
return cv ; 
} 
} 

public class Matrix { 
protected void set ( final float values [ ] [ ] ) { 
m_nRows = values . length ; 
m_nCols = values [ 0 ] . length ; 
m_aValues = values ; 
for ( int r = 1 ; 
r < m_nRows ; 
++ r ) m_nCols = Math . min ( m_nCols , values [ r ] . length ) ; 
} 
} 

public class Matrix { 
public Matrix transpose ( ) { 
final float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) for ( int c = 0 ; 
c < m_nCols ; 
++ c ) tv [ c ] [ r ] = m_aValues [ r ] [ c ] ; 
return new Matrix ( tv ) ; 
} 
} 

public class Matrix { 
public Matrix add ( final Matrix m ) throws MatrixException { 
if ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
final float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) for ( int c = 0 ; 
c < m_nCols ; 
++ c ) sv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; 
return new Matrix ( sv ) ; 
} 
} 

public class Matrix { 
public Matrix subtract ( final Matrix m ) throws MatrixException { 
if ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
final float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) for ( int c = 0 ; 
c < m_nCols ; 
++ c ) dv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; 
return new Matrix ( dv ) ; 
} 
} 

public class Matrix { 
public Matrix multiply ( final float k ) { 
final float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) for ( int c = 0 ; 
c < m_nCols ; 
++ c ) pv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; 
return new Matrix ( pv ) ; 
} 
} 

public class Matrix { 
public Matrix multiply ( final Matrix m ) throws MatrixException { 
if ( m_nCols != m . m_nRows ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
final float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) for ( int c = 0 ; 
c < m . m_nCols ; 
++ c ) { 
float dot = 0 ; 
for ( int k = 0 ; 
k < m_nCols ; 
++ k ) dot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; 
pv [ r ] [ c ] = dot ; 
} 
return new Matrix ( pv ) ; 
} 
} 

public class Matrix { 
public void print ( final int width , @ Nonnull final PrintStream aPS ) { 
final SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) { 
ar . print ( "Row " , 0 ) ; 
ar . print ( r + 1 , 2 ) ; 
ar . print ( ":" , 0 ) ; 
for ( int c = 0 ; 
c < m_nCols ; 
++ c ) ar . print ( m_aValues [ r ] [ c ] , width ) ; 
ar . println ( ) ; 
} 
} 
} 

public class RegressionLine { 
private void _validateCoefficients ( ) { 
if ( m_bCoefsValid ) return ; 
if ( m_nDataPoints >= 2 ) { 
final float xBar = ( float ) m_dSumX / m_nDataPoints ; 
final float yBar = ( float ) m_dSumY / m_nDataPoints ; 
m_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; 
m_fA0 = yBar - m_fA1 * xBar ; 
} 
else m_fA0 = m_fA1 = Float . NaN ; 
m_bCoefsValid = true ; 
} 
} 

public class InMemorySldServiceImpl { 
public RawSld toXml ( StyledLayerDescriptorInfo sldi ) throws SldException { 
try { 
if ( sldi . getVersion ( ) == null ) sldi . setVersion ( "1.0.0" ) ; 
return parseSldI ( sldi ) ; 
} 
catch ( JiBXException e ) { 
throw new SldException ( "Validation error" , e ) ; 
} 
} 
} 

public class InvertibleMatrix { 
public float norm ( ) { 
float sum = 0 ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) for ( int c = 0 ; 
c < m_nCols ; 
++ c ) { 
final float v = m_aValues [ r ] [ c ] ; 
sum += v * v ; 
} 
return ( float ) Math . sqrt ( sum ) ; 
} 
} 

public class LinearSystem { 
public ColumnVector solve ( final ColumnVector b , final boolean improve ) throws MatrixException { 
if ( b . m_nRows != m_nRows ) throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
decompose ( ) ; 
final ColumnVector y = _forwardSubstitution ( b ) ; 
final ColumnVector x = _backSubstitution ( y ) ; 
if ( improve ) _improve ( b , x ) ; 
return x ; 
} 
} 

public class LinearSystem { 
public void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { 
decompose ( ) ; 
final SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) { 
final int pr = m_aPermutation [ r ] ; 
ar . print ( "Row " , 0 ) ; 
ar . print ( r + 1 , 2 ) ; 
ar . print ( ":" , 0 ) ; 
for ( int c = 0 ; 
c < m_nCols ; 
++ c ) ar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; 
ar . println ( ) ; 
} 
} 
} 

public class LinearSystem { 
private void _forwardElimination ( final float scales [ ] ) throws MatrixException { 
for ( int rPivot = 0 ; 
rPivot < m_nRows - 1 ; 
++ rPivot ) { 
float largestScaledElmt = 0 ; 
int rLargest = 0 ; 
for ( int r = rPivot ; 
r < m_nRows ; 
++ r ) { 
final int pr = m_aPermutation [ r ] ; 
final float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; 
final float scaledElmt = absElmt * scales [ pr ] ; 
if ( largestScaledElmt < scaledElmt ) { 
largestScaledElmt = scaledElmt ; 
rLargest = r ; 
} 
} 
if ( largestScaledElmt == 0 ) throw new MatrixException ( MatrixException . SINGULAR ) ; 
if ( rLargest != rPivot ) { 
final int temp = m_aPermutation [ rPivot ] ; 
m_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; 
m_aPermutation [ rLargest ] = temp ; 
++ m_nExchangeCount ; 
} 
final int prPivot = m_aPermutation [ rPivot ] ; 
final float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; 
for ( int r = rPivot + 1 ; 
r < m_nRows ; 
++ r ) { 
final int pr = m_aPermutation [ r ] ; 
final float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; 
m_aLU . set ( pr , rPivot , multiple ) ; 
if ( multiple != 0 ) for ( int c = rPivot + 1 ; 
c < m_nCols ; 
++ c ) { 
float elmt = m_aLU . at ( pr , c ) ; 
elmt -= multiple * m_aLU . at ( prPivot , c ) ; 
m_aLU . set ( pr , c , elmt ) ; 
} 
} 
} 
} 
} 

public class LinearSystem { 
private ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { 
final ColumnVector y = new ColumnVector ( m_nRows ) ; 
for ( int r = 0 ; 
r < m_nRows ; 
++ r ) { 
final int pr = m_aPermutation [ r ] ; 
float dot = 0 ; 
for ( int c = 0 ; 
c < r ; 
++ c ) dot += m_aLU . at ( pr , c ) * y . at ( c ) ; 
y . set ( r , b . at ( pr ) - dot ) ; 
} 
return y ; 
} 
} 

public class LinearSystem { 
private ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { 
final ColumnVector x = new ColumnVector ( m_nRows ) ; 
for ( int r = m_nRows - 1 ; 
r >= 0 ; 
-- r ) { 
final int pr = m_aPermutation [ r ] ; 
float dot = 0 ; 
for ( int c = r + 1 ; 
c < m_nRows ; 
++ c ) dot += m_aLU . at ( pr , c ) * x . at ( c ) ; 
x . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; 
} 
return x ; 
} 
} 

public class IdentityMatrix { 
public static void convert ( final SquareMatrix sm ) { 
for ( int r = 0 ; 
r < sm . m_nRows ; 
++ r ) for ( int c = 0 ; 
c < sm . m_nCols ; 
++ c ) sm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; 
} 
} 

public class RandomExponential { 
public float nextVonNeumann ( ) { 
int n ; 
int k = 0 ; 
float u1 ; 
for ( ; 
; 
) { 
n = 1 ; 
u1 = GENERATOR . nextFloat ( ) ; 
float u = u1 ; 
float uPrev = Float . NaN ; 
for ( ; 
; 
) { 
uPrev = u ; 
u = GENERATOR . nextFloat ( ) ; 
if ( u > uPrev ) { 
if ( ( n & 1 ) == 0 ) return u1 + k ; 
++ k ; 
break ; 
} 
++ n ; 
} 
} 
} 
} 

public class RegulaFalsiRootFinder { 
@ Override protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException { 
if ( EqualsHelper . equals ( m_fXFalse , m_fPrevXFalse ) ) throw new AbstractRootFinder . PositionUnchangedException ( ) ; 
} 
} 

public class ImprovedRegulaFalsiRootFinder { 
@ Override protected void computeNextPosition ( ) { 
m_fPrevXFalse = m_fXFalse ; 
m_fPrevFFalse = m_fFalse ; 
m_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; 
m_fFalse = m_aFunction . at ( m_fXFalse ) ; 
m_bDecreasePos = m_bDecreaseNeg = false ; 
if ( Float . isNaN ( m_fPrevFFalse ) || ( m_fPrevFFalse * m_fFalse > 0 ) ) if ( m_fFalse < 0 ) m_bDecreasePos = true ; 
else m_bDecreaseNeg = true ; 
} 
} 

public class ModuloArithmetic { 
public static int raise ( final int pbase , final int pexponent , final int m ) { 
int base = pbase ; 
int exponent = pexponent ; 
int power = 1 ; 
while ( exponent > 0 ) { 
if ( ( exponent & 1 ) == 1 ) power = multiply ( power , base , m ) ; 
base = multiply ( base , base , m ) ; 
exponent >>= 1 ; 
} 
return power ; 
} 
} 

public class SldEditor { 
public SldManager getSldManager ( ) { 
if ( sldManager == null ) sldManager = new SldManagerImpl ( getEventBus ( ) , getSldEditorServiceFactory ( ) . createSldGwtServiceAsync ( ) ) ; 
return sldManager ; 
} 
} 

public class IEEE754 { 
public static void validateFloatBiasedExponent ( final int biased ) throws IEEE754Exception { 
if ( ( biased < 0 ) || ( biased > IEEE754Constants . FLOAT_EXPONENT_RESERVED ) ) throw new IEEE754Exception ( "The biased exponent value should be " + "0 through " + IEEE754Constants . FLOAT_EXPONENT_RESERVED + "." ) ; 
} 
} 

public class IEEE754 { 
public static void validateFloatUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { 
if ( ( unbiased < - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . FLOAT_EXPONENT_BIAS ) ) throw new IEEE754Exception ( "The unbiased exponent value should be " + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + " through " + IEEE754Constants . FLOAT_EXPONENT_BIAS + "." ) ; 
} 
} 

public class IEEE754 { 
public static void validateDoubleBiasedExponent ( final int biased ) throws IEEE754Exception { 
if ( ( biased < 0 ) || ( biased > IEEE754Constants . DOUBLE_EXPONENT_RESERVED ) ) throw new IEEE754Exception ( "The biased exponent value should be " + "0 through " + IEEE754Constants . DOUBLE_EXPONENT_RESERVED + "." ) ; 
} 
} 

public class IEEE754 { 
public static void validateDoubleUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { 
if ( ( unbiased < - IEEE754Constants . DOUBLE_EXPONENT_BIAS + 1 ) || ( unbiased > IEEE754Constants . DOUBLE_EXPONENT_BIAS ) ) throw new IEEE754Exception ( "The unbiased exponent value should be " + - ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + " through " + IEEE754Constants . DOUBLE_EXPONENT_BIAS + "." ) ; 
} 
} 

public class PrimeFactors { 
public static int [ ] factorsOf ( final int pn ) { 
int n = pn ; 
final boolean isPrime [ ] = primeSieve ( n ) ; 
final ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; 
for ( int factor = 2 ; 
n > 1 ; 
++ factor ) if ( isPrime [ factor ] && ( n % factor == 0 ) ) { 
v . add ( Integer . valueOf ( factor ) ) ; 
do { 
n /= factor ; 
} 
while ( n % factor == 0 ) ; 
} 
final int factors [ ] = new int [ v . size ( ) ] ; 
for ( int i = 0 ; 
i < v . size ( ) ; 
++ i ) factors [ i ] = v . get ( i ) . intValue ( ) ; 
return factors ; 
} 
} 

public class BisectionRootFinder { 
@ Override protected void checkPosition ( ) throws AbstractRootFinder . PositionUnchangedException { 
if ( EqualsHelper . equals ( m_fXMid , m_fPrevXMid ) ) throw new AbstractRootFinder . PositionUnchangedException ( ) ; 
} 
} 

public class JavaFXExtension { 
public static void setJavaFxApplication ( final CdiApplication javaFxApplication ) { 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
Platform . runLater ( ( ) -> { 
JAVA_FX_APPLICATION . set ( javaFxApplication ) ; 
latch . countDown ( ) ; 
} 
) ; 
if ( ! Platform . isFxApplicationThread ( ) ) try { 
latch . await ( ) ; 
} 
catch ( InterruptedException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class CdiFXMLLoaderFactory { 
static void initializeFXMLLoader ( final FXMLLoader fxmlLoader , final Class < ? > targetClass , final String location , final String resources , final String charset ) { 
checkAndSetLocation ( fxmlLoader , targetClass , location ) ; 
if ( charset != null && ! charset . equals ( CHARSET_UNSPECIFIED ) ) fxmlLoader . setCharset ( Charset . forName ( charset ) ) ; 
if ( resources != null && ! resources . equals ( RESOURCES_UNSPECIFIED ) ) fxmlLoader . setResources ( ResourceBundle . getBundle ( resources ) ) ; 
} 
} 

public class AttrbuteFilterExpressionCollectionEvaluator { 
protected AttributeDefinition getApplicableAttributeDefinition ( final UUID attributeDefinitionUuid , final List < AttributeDefinition > attributeDefinitions ) { 
if ( LOG . isTraceEnabled ( ) ) LOG . entry ( attributeDefinitionUuid , attributeDefinitions ) ; 
AttributeDefinition attributeDefinition = null ; 
for ( AttributeDefinition anAttributeDefinition : attributeDefinitions ) { 
if ( anAttributeDefinition . getUUID ( ) . equals ( attributeDefinitionUuid ) ) { 
attributeDefinition = anAttributeDefinition ; 
break ; 
} 
} 
if ( LOG . isTraceEnabled ( ) ) LOG . exit ( attributeDefinition ) ; 
return attributeDefinition ; 
} 
} 

public class AttrbuteFilterExpressionCollectionEvaluator { 
protected boolean evaluate ( final UUID attributeDefinitionUuid , final AttributeFilterExpression attributeFilter , final Map < UUID , String > eventAttributes , final List < AttributeDefinition > attributeDefinitions ) throws ParseException { 
if ( LOG . isTraceEnabled ( ) ) LOG . entry ( attributeDefinitionUuid , attributeFilter , eventAttributes , attributeDefinitions ) ; 
final String attributeValue = eventAttributes . get ( attributeDefinitionUuid ) ; 
if ( attributeValue == null ) { 
if ( LOG . isTraceEnabled ( ) ) { 
LOG . trace ( "An attributeValue was not specified for this attribute definition." ) ; 
LOG . exit ( false ) ; 
} 
return false ; 
} 
final AttributeDefinition attributeDefinition = getApplicableAttributeDefinition ( attributeDefinitionUuid , attributeDefinitions ) ; 
if ( attributeDefinition == null ) { 
if ( LOG . isTraceEnabled ( ) ) { 
LOG . trace ( "The attributeDefinition did not exist." ) ; 
LOG . exit ( false ) ; 
} 
return false ; 
} 
final Unit unit = attributeDefinition . getUnits ( ) ; 
try { 
boolean result = unit . evaluate ( attributeFilter . getOperator ( ) , attributeValue , attributeFilter . getOperand ( ) ) ; 
if ( LOG . isTraceEnabled ( ) ) LOG . exit ( result ) ; 
return result ; 
} 
catch ( ParseException e ) { 
if ( LOG . isTraceEnabled ( ) ) LOG . throwing ( e ) ; 
throw e ; 
} 
} 
} 

public class Utils { 
public static String sanitizeTag ( String s ) { 
if ( s . length ( ) > MAX_TAG_LENGTH ) s = s . substring ( s . length ( ) - MAX_TAG_LENGTH ) ; 
return s ; 
} 
} 

public class RSRServiceDiscoveryImpl { 
public Collection < String > queryForNames ( ) throws Exception { 
Set < String > names = new HashSet < String > ( ) ; 
Iterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; 
while ( services . hasNext ( ) ) { 
Service service = services . next ( ) ; 
if ( ! service . getTags ( ) . contains ( typeTag ) ) continue ; 
String name = service . getMetadata ( ) . get ( ServiceTracker . NAME ) ; 
if ( ! names . contains ( name ) ) names . add ( name ) ; 
} 
return names ; 
} 
} 

public class RSRServiceDiscoveryImpl { 
public Collection < ServiceInstance < T > > queryForInstances ( String name ) throws Exception { 
List < ServiceInstance < T > > serviceInstances = new ArrayList < ServiceInstance < T > > ( ) ; 
Iterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; 
while ( services . hasNext ( ) ) { 
Service service = services . next ( ) ; 
if ( service . getTags ( ) . contains ( typeTag ) && service . getMetadata ( ) . get ( ServiceTracker . NAME ) . equals ( name ) ) serviceInstances . add ( convert ( service ) ) ; 
} 
return serviceInstances ; 
} 
} 

public class CollaborationClient { 
public List < Collaboration > getAllToByLoggedIn ( ) { 
CollaborationListing collaborationListing = new CollaborationListing ( ) ; 
if ( this . serviceTicket != null ) collaborationListing . setServiceTicket ( this . serviceTicket ) ; 
return new CollaborationListing ( this . postJson ( collaborationListing , WS . Path . Collaboration . Version1 . getAllToByLoggedIn ( ) ) ) . getListing ( ) ; 
} 
} 

public class ABaseFieldClient { 
protected String getMetaDataForDecimalAs ( String metaDataPrefixParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { 
StringBuffer returnBuffer = new StringBuffer ( ) ; 
if ( metaDataPrefixParam != null && ! metaDataPrefixParam . isEmpty ( ) ) returnBuffer . append ( metaDataPrefixParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . MIN ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; 
returnBuffer . append ( minParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . MAX ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; 
returnBuffer . append ( maxParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . STEP_FACTOR ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; 
returnBuffer . append ( stepFactorParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; 
String prefix = ( prefixParam == null ) ? "" : prefixParam ; 
returnBuffer . append ( FieldMetaData . Decimal . PREFIX ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; 
returnBuffer . append ( prefix ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; 
return returnBuffer . toString ( ) ; 
} 
} 

public class UserClient { 
public User changePasswordForLoggedInUser ( String existingPasswordParam , String newPasswordParam , String confirmNewPasswordParam ) { 
User toChangePasswordFor = new User ( ) ; 
if ( this . serviceTicket != null ) toChangePasswordFor . setServiceTicket ( this . serviceTicket ) ; 
String existingPassword = existingPasswordParam == null ? UtilGlobal . EMPTY : existingPasswordParam ; 
String newPassword = newPasswordParam == null ? UtilGlobal . EMPTY : newPasswordParam ; 
String confirmNewPassword = confirmNewPasswordParam == null ? UtilGlobal . EMPTY : confirmNewPasswordParam ; 
JSONObject passwordClear = new JSONObject ( ) ; 
passwordClear . put ( "existing" , existingPassword ) ; 
passwordClear . put ( "new" , newPassword ) ; 
passwordClear . put ( "confirm_new" , confirmNewPassword ) ; 
toChangePasswordFor . setPasswordClear ( passwordClear . toString ( ) ) ; 
return new User ( this . postJson ( toChangePasswordFor , WS . Path . User . Version1 . changePassword ( ) ) ) ; 
} 
} 

public class UserClient { 
public UserListing getAllUsers ( ) { 
UserListing userToGetInfoFor = new UserListing ( ) ; 
if ( this . serviceTicket != null ) userToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
try { 
return new UserListing ( this . postJson ( userToGetInfoFor , WS . Path . User . Version1 . getAllUsers ( ) ) ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class UserClient { 
public byte [ ] getGravatarForEmail ( String emailAddressParam , int sizeParam ) { 
try { 
JSONObject gravatarJSONObj = this . getJson ( WS . Path . User . Version1 . getGravatarByEmail ( emailAddressParam , sizeParam ) ) ; 
String base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , "" ) ; 
if ( base64Text == null || base64Text . isEmpty ( ) ) return null ; 
return UtilGlobal . decodeBase64 ( base64Text ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
catch ( UnsupportedEncodingException unsEncExcept ) { 
throw new FluidClientException ( unsEncExcept . getMessage ( ) , unsEncExcept , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
} 
} 

public class UserClient { 
public byte [ ] getGravatarForUser ( User userParam , int sizeParam ) { 
if ( userParam == null ) return null ; 
try { 
JSONObject gravatarJSONObj = this . postJson ( userParam , WS . Path . User . Version1 . getGravatarByUser ( sizeParam ) ) ; 
String base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , "" ) ; 
if ( base64Text == null || base64Text . isEmpty ( ) ) return null ; 
return UtilGlobal . decodeBase64 ( base64Text ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class Field { 
@ XmlTransient public String getElasticSearchFieldType ( ) { 
Type fieldType = this . getTypeAsEnum ( ) ; 
if ( fieldType == null ) return null ; 
switch ( fieldType ) { 
case ParagraphText : return ElasticSearchType . TEXT ; 
case Text : String metaData = this . getTypeMetaData ( ) ; 
if ( metaData == null || metaData . isEmpty ( ) ) return ElasticSearchType . TEXT ; 
if ( LATITUDE_AND_LONGITUDE . equals ( metaData ) ) return ElasticSearchType . GEO_POINT ; 
return ElasticSearchType . TEXT ; 
case TrueFalse : return ElasticSearchType . BOOLEAN ; 
case DateTime : return ElasticSearchType . DATE ; 
case Decimal : return ElasticSearchType . DOUBLE ; 
case MultipleChoice : return ElasticSearchType . KEYWORD ; 
} 
return null ; 
} 
} 

public class FlowStepClient { 
public FlowStep createFlowStep ( FlowStep flowStepParam ) { 
if ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . putJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepCreate ( ) ) ) ; 
} 
} 

public class FlowStepClient { 
public FlowStep updateFlowStep ( FlowStep flowStepParam ) { 
if ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepUpdate ( ) ) ) ; 
} 
} 

public class FlowStepClient { 
public FlowStep getFlowStepById ( Long flowStepIdParam , String flowStepTypeParam ) { 
FlowStep flowStep = new FlowStep ( flowStepIdParam ) ; 
flowStep . setFlowStepType ( flowStepTypeParam ) ; 
if ( this . serviceTicket != null ) flowStep . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStep , WS . Path . FlowStep . Version1 . getById ( ) ) ) ; 
} 
} 

public class FlowStepClient { 
public FlowStep getFlowStepByStep ( FlowStep flowStepParam ) { 
if ( this . serviceTicket != null && flowStepParam != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . getByStep ( ) ) ) ; 
} 
} 

public class FlowStepClient { 
public FlowStepListing getStepsByFlow ( Flow flowParam ) { 
if ( this . serviceTicket != null && flowParam != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepListing ( this . postJson ( flowParam , WS . Path . FlowStep . Version1 . getAllStepsByFlow ( ) ) ) ; 
} 
} 

public class FlowStepClient { 
public FlowStep deleteFlowStep ( FlowStep flowStepParam ) { 
if ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( ) ) ) ; 
} 
} 

public class FlowStepClient { 
public FlowStep forceDeleteFlowStep ( FlowStep flowStepParam ) { 
if ( flowStepParam != null && this . serviceTicket != null ) flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( true ) ) ) ; 
} 
} 

public class ABaseESUtil { 
protected final List < Form > populateTableFields ( boolean addAllTableRecordsForReturnParam , boolean includeFieldDataParam , List < Field > formFieldsParam ) { 
if ( formFieldsParam == null || formFieldsParam . isEmpty ( ) ) return null ; 
List < Form > allTableRecordsFromAllFields = addAllTableRecordsForReturnParam ? new ArrayList ( ) : null ; 
for ( Field descendantField : formFieldsParam ) { 
if ( ! ( descendantField . getFieldValue ( ) instanceof TableField ) ) continue ; 
TableField tableField = ( TableField ) descendantField . getFieldValue ( ) ; 
List < Form > tableRecordWithIdOnly = tableField . getTableRecords ( ) ; 
if ( tableRecordWithIdOnly == null || tableRecordWithIdOnly . isEmpty ( ) ) continue ; 
List < Long > formIdsOnly = new ArrayList ( ) ; 
for ( Form tableRecord : tableRecordWithIdOnly ) { 
formIdsOnly . add ( tableRecord . getId ( ) ) ; 
} 
List < Form > populatedTableRecords = this . getFormsByIds ( Index . TABLE_RECORD , formIdsOnly , includeFieldDataParam , DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS ) ; 
if ( addAllTableRecordsForReturnParam && populatedTableRecords != null ) allTableRecordsFromAllFields . addAll ( populatedTableRecords ) ; 
tableField . setTableRecords ( populatedTableRecords ) ; 
descendantField . setFieldValue ( tableField ) ; 
} 
return allTableRecordsFromAllFields ; 
} 
} 

public class AGenericListMessageHandler { 
@ Override public void handleMessage ( Object objectToProcess ) { 
if ( objectToProcess instanceof Error ) { 
Error fluidError = ( ( Error ) objectToProcess ) ; 
this . errors . add ( fluidError ) ; 
if ( this . messageReceivedCallback != null ) this . messageReceivedCallback . errorMessageReceived ( fluidError ) ; 
if ( this . completableFuture != null ) this . completableFuture . completeExceptionally ( new FluidClientException ( fluidError . getErrorMessage ( ) , fluidError . getErrorCode ( ) ) ) ; 
} 
else { 
JSONObject jsonObject = ( JSONObject ) objectToProcess ; 
if ( this . compressedResponse ) { 
CompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; 
byte [ ] compressedJsonList = UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; 
byte [ ] uncompressedJson = null ; 
try { 
uncompressedJson = this . uncompress ( compressedJsonList ) ; 
} 
catch ( IOException eParam ) { 
throw new FluidClientException ( "I/O issue with uncompress. " + eParam . getMessage ( ) , eParam , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
jsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; 
} 
T messageForm = this . getNewInstanceBy ( jsonObject ) ; 
this . returnValue . add ( messageForm ) ; 
if ( this . completableFuture != null ) { 
String echo = messageForm . getEcho ( ) ; 
if ( echo != null && ! echo . trim ( ) . isEmpty ( ) ) this . expectedEchoMessagesBeforeComplete . remove ( echo ) ; 
if ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) this . completableFuture . complete ( this . returnValue ) ; 
} 
if ( this . messageReceivedCallback != null ) this . messageReceivedCallback . messageReceived ( messageForm ) ; 
} 
} 
} 

public class AGenericListMessageHandler { 
@ Override public void connectionClosed ( ) { 
this . isConnectionClosed = true ; 
if ( this . completableFuture != null ) if ( this . getErrors ( ) . isEmpty ( ) ) this . completableFuture . complete ( this . returnValue ) ; 
else { 
Error firstFluidError = this . getErrors ( ) . get ( 0 ) ; 
this . completableFuture . completeExceptionally ( new FluidClientException ( firstFluidError . getErrorMessage ( ) , firstFluidError . getErrorCode ( ) ) ) ; 
} 
} 
} 

public class AGenericListMessageHandler { 
private List < String > getEchoMessagesFromReturnValue ( ) { 
List < String > returnListing = new ArrayList ( ) ; 
if ( this . returnValue == null ) return returnListing ; 
Iterator < T > iterForReturnVal = this . returnValue . iterator ( ) ; 
while ( iterForReturnVal . hasNext ( ) ) { 
T returnVal = iterForReturnVal . next ( ) ; 
if ( returnVal . getEcho ( ) == null ) continue ; 
returnListing . add ( returnVal . getEcho ( ) ) ; 
} 
return returnListing ; 
} 
} 

public class PersonalInventoryClient { 
public List < FluidItem > getPersonalInventoryItems ( ) { 
User loggedInUser = new User ( ) ; 
if ( this . serviceTicket != null ) loggedInUser . setServiceTicket ( this . serviceTicket ) ; 
try { 
return new FluidItemListing ( this . postJson ( loggedInUser , WS . Path . PersonalInventory . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class FormContainerClient { 
public TableRecord createTableRecord ( TableRecord tableRecordParam ) { 
if ( tableRecordParam != null && this . serviceTicket != null ) tableRecordParam . setServiceTicket ( this . serviceTicket ) ; 
return new TableRecord ( this . putJson ( tableRecordParam , WS . Path . FormContainerTableRecord . Version1 . formContainerTableRecordCreate ( ) ) ) ; 
} 
} 

public class FormContainerClient { 
public Form deleteFormContainer ( Form formContainerParam ) { 
if ( formContainerParam != null && this . serviceTicket != null ) formContainerParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( formContainerParam , WS . Path . FormContainer . Version1 . formContainerDelete ( ) ) ) ; 
} 
} 

public class FormContainerClient { 
public List < FormFlowHistoricData > getFormFlowHistoricData ( Form formParam ) { 
if ( formParam != null && this . serviceTicket != null ) formParam . setServiceTicket ( this . serviceTicket ) ; 
return new FormFlowHistoricDataListing ( this . postJson ( formParam , WS . Path . FlowItemHistory . Version1 . getByFormContainer ( ) ) ) . getListing ( ) ; 
} 
} 

public class FormContainerClient { 
public List < FormHistoricData > getFormAndFieldHistoricData ( Form formParam , boolean includeCurrentParam ) { 
if ( formParam != null && this . serviceTicket != null ) formParam . setServiceTicket ( this . serviceTicket ) ; 
return new FormHistoricDataListing ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByFormContainer ( includeCurrentParam ) ) ) . getListing ( ) ; 
} 
} 

public class FormContainerClient { 
public FormHistoricData getMostRecentFormAndFieldHistoricData ( Form formParam ) { 
if ( formParam != null && this . serviceTicket != null ) formParam . setServiceTicket ( this . serviceTicket ) ; 
return new FormHistoricData ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByMostRecentByFormContainer ( ) ) ) ; 
} 
} 

public class FormContainerClient { 
public Form unLockFormContainer ( Form formParam , User userToUnLockAsParam , boolean unlockAsyncParam , boolean removeFromPersonalInventoryParam ) { 
if ( this . serviceTicket != null && formParam != null ) formParam . setServiceTicket ( this . serviceTicket ) ; 
Long unLockAsUserId = ( userToUnLockAsParam == null ) ? null : userToUnLockAsParam . getId ( ) ; 
try { 
return new Form ( this . postJson ( formParam , WS . Path . FormContainer . Version1 . unLockFormContainer ( unLockAsUserId , unlockAsyncParam , removeFromPersonalInventoryParam ) ) ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class SQLFormUtil { 
private Form mapFormContainerTo ( Map < Long , String > definitionAndTitleParam , ResultSet resultSetParam ) throws SQLException { 
Long formId = resultSetParam . getLong ( SQLColumnIndex . _01_FORM_ID ) ; 
String formType = definitionAndTitleParam . get ( resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) ) ; 
String title = resultSetParam . getString ( SQLColumnIndex . _03_TITLE ) ; 
Date created = resultSetParam . getDate ( SQLColumnIndex . _04_CREATED ) ; 
Date lastUpdated = resultSetParam . getDate ( SQLColumnIndex . _05_LAST_UPDATED ) ; 
Long currentUserId = resultSetParam . getLong ( SQLColumnIndex . _06_CURRENT_USER_ID ) ; 
if ( formType == null ) throw new SQLException ( "No mapping found for Form Type '" + resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) + "'." ) ; 
Form toAdd = new Form ( formType ) ; 
toAdd . setId ( formId ) ; 
toAdd . setTitle ( title ) ; 
if ( created != null ) toAdd . setDateCreated ( new Date ( created . getTime ( ) ) ) ; 
if ( lastUpdated != null ) toAdd . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; 
if ( currentUserId != null && currentUserId . longValue ( ) > 0 ) { 
User currentUser = new User ( ) ; 
currentUser . setId ( currentUserId ) ; 
toAdd . setCurrentUser ( currentUser ) ; 
} 
return toAdd ; 
} 
} 

public class Role { 
@ XmlTransient public static List < Role > convertToObjects ( String roleListingParam ) { 
if ( roleListingParam == null || roleListingParam . trim ( ) . isEmpty ( ) ) return null ; 
String [ ] listOfRoles = roleListingParam . split ( UtilGlobal . REG_EX_COMMA ) ; 
List < Role > returnVal = new ArrayList < > ( ) ; 
for ( String roleName : listOfRoles ) { 
Role roleToAdd = new Role ( ) ; 
roleToAdd . setName ( roleName . trim ( ) ) ; 
returnVal . add ( roleToAdd ) ; 
} 
return returnVal ; 
} 
} 

public class FormDefinitionClient { 
public Form createFormDefinition ( Form formDefinitionParam ) { 
if ( formDefinitionParam != null && this . serviceTicket != null ) formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . putJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionCreate ( ) ) ) ; 
} 
} 

public class FormDefinitionClient { 
public Form updateFormDefinition ( Form formDefinitionParam ) { 
if ( formDefinitionParam != null && this . serviceTicket != null ) formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionUpdate ( ) ) ) ; 
} 
} 

public class FormDefinitionClient { 
public Form getFormDefinitionById ( Long formDefinitionIdParam ) { 
Form form = new Form ( formDefinitionIdParam ) ; 
if ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getById ( ) ) ) ; 
} 
} 

public class FormDefinitionClient { 
public Form getFormDefinitionByName ( String formDefinitionNameParam ) { 
Form form = new Form ( formDefinitionNameParam ) ; 
if ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getByName ( ) ) ) ; 
} 
} 

public class FormDefinitionClient { 
public List < Form > getAllByLoggedInUser ( boolean includeTableRecordTypesParam ) { 
Form form = new Form ( ) ; 
if ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; 
if ( includeTableRecordTypesParam ) return new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUserIncludeTableTypes ( ) ) ) . getListing ( ) ; 
else return new FormListing ( this . postJson ( form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; 
} 
} 

public class FormDefinitionClient { 
public Form deleteFormDefinition ( Form formDefinitionParam ) { 
if ( formDefinitionParam != null && this . serviceTicket != null ) formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionDelete ( ) ) ) ; 
} 
} 

public class CacheUtil { 
private String getStorageKeyFrom ( Long formDefIdParam , Long formContIdParam , Long formFieldIdParam ) { 
StringBuilder stringBuff = new StringBuilder ( ) ; 
if ( formDefIdParam == null ) stringBuff . append ( NULL ) ; 
else stringBuff . append ( formDefIdParam . toString ( ) ) ; 
stringBuff . append ( DASH ) ; 
if ( formContIdParam == null ) stringBuff . append ( NULL ) ; 
else stringBuff . append ( formContIdParam . toString ( ) ) ; 
stringBuff . append ( DASH ) ; 
if ( formFieldIdParam == null ) stringBuff . append ( NULL ) ; 
else stringBuff . append ( formFieldIdParam . toString ( ) ) ; 
return stringBuff . toString ( ) ; 
} 
} 

public class CacheUtil { 
private MemcachedClient initXMemcachedClient ( ) { 
if ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) return this . memcachedClient ; 
try { 
this . memcachedClient = new XMemcachedClient ( this . cacheHost , this . cachePort ) ; 
return this . memcachedClient ; 
} 
catch ( IOException e ) { 
throw new FluidCacheException ( "Unable to create MemCache client. " + e . getMessage ( ) , e ) ; 
} 
} 
} 

public class CacheUtil { 
public void shutdown ( ) { 
if ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) try { 
this . memcachedClient . shutdown ( ) ; 
} 
catch ( IOException eParam ) { 
throw new FluidCacheException ( "Unable to create shutdown MemCache client. " + eParam . getMessage ( ) , eParam ) ; 
} 
} 
} 

public class ABaseUtil { 
protected long toLongSafe ( String toParseParam ) { 
if ( toParseParam == null || toParseParam . trim ( ) . isEmpty ( ) ) return - 1 ; 
try { 
return Long . parseLong ( toParseParam . trim ( ) ) ; 
} 
catch ( NumberFormatException e ) { 
return - 1 ; 
} 
} 
} 

public class DocumentToPDFConvert { 
public File convertDocumentToPDF ( File inputDocumentParam ) { 
if ( inputDocumentParam == null || ! inputDocumentParam . exists ( ) ) throw new UtilException ( "Input document to convert not provided or does not exist." , UtilException . ErrorCode . COMMAND ) ; 
if ( ! inputDocumentParam . isFile ( ) ) throw new UtilException ( "Input document '' is not a file." , UtilException . ErrorCode . COMMAND ) ; 
File parentFolder = inputDocumentParam . getParentFile ( ) ; 
String inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; 
int indexOfDot = - 1 ; 
if ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) inputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; 
File generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( ".pdf" ) ) ; 
String completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; 
try { 
CommandUtil . CommandResult commandResult = this . commandUtil . executeCommand ( CommandUtil . FLUID_CLI , COMMAND_CONVERT_DOC_TO_PDF , "-i" , inputDocumentParam . getAbsolutePath ( ) , "-o" , completeOutputPath ) ; 
if ( commandResult . getExitCode ( ) != 0 ) throw new UtilException ( "Unable to convert '" + inputDocumentParam . getName ( ) + "' to PDF. " + commandResult . toString ( ) , UtilException . ErrorCode . COMMAND ) ; 
File returnVal = new File ( completeOutputPath ) ; 
if ( ! returnVal . exists ( ) ) throw new UtilException ( "Command executed, but no output file. Expected PDF at '" + completeOutputPath + "'." , UtilException . ErrorCode . GENERAL ) ; 
return returnVal ; 
} 
catch ( IOException eParam ) { 
throw new UtilException ( "Problem executing command. " + eParam . getMessage ( ) , eParam , UtilException . ErrorCode . GENERAL ) ; 
} 
} 
} 

public class SQLUtilWebSocketRESTWrapper { 
private List < Field > getFieldValuesForFormFromCache ( Long formIdParam , List < FormFieldListing > listingReturnFieldValsPopulatedParam , Form [ ] formsToFetchForLocalCacheArrParam ) { 
if ( formIdParam == null || formIdParam . longValue ( ) < 1 ) return null ; 
if ( listingReturnFieldValsPopulatedParam == null || listingReturnFieldValsPopulatedParam . isEmpty ( ) ) return null ; 
if ( formsToFetchForLocalCacheArrParam == null || formsToFetchForLocalCacheArrParam . length == 0 ) return null ; 
for ( Form formIter : formsToFetchForLocalCacheArrParam ) { 
if ( formIdParam . equals ( formIter . getId ( ) ) ) { 
String echoToUse = formIter . getEcho ( ) ; 
for ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { 
if ( echoToUse . equals ( fieldListing . getEcho ( ) ) ) return fieldListing . getListing ( ) ; 
} 
} 
} 
return null ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule createFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleEntryCreate ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule createFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleExitCreate ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule createFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleViewCreate ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule updateFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateEntry ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule updateFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateExit ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule updateFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateView ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule moveFlowStepEntryRuleUp ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryUp ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule moveFlowStepEntryRuleDown ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryDown ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStepRule deleteFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteEntry ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStep deleteFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteExit ( ) ) ) ; 
} 
} 

public class FlowStepRuleClient { 
public FlowStep deleteFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { 
if ( flowStepRuleParam != null && this . serviceTicket != null ) flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteView ( ) ) ) ; 
} 
} 

public class LoginClient { 
private AuthEncryptedData initializeSession ( String passwordParam , AuthResponse authResponseParam ) { 
byte [ ] ivBytes = UtilGlobal . decodeBase64 ( authResponseParam . getIvBase64 ( ) ) ; 
byte [ ] seedBytes = UtilGlobal . decodeBase64 ( authResponseParam . getSeedBase64 ( ) ) ; 
byte [ ] encryptedData = UtilGlobal . decodeBase64 ( authResponseParam . getEncryptedDataBase64 ( ) ) ; 
byte [ ] hMacFromResponse = UtilGlobal . decodeBase64 ( authResponseParam . getEncryptedDataHmacBase64 ( ) ) ; 
byte [ ] localGeneratedHMac = AES256Local . generateLocalHMAC ( encryptedData , passwordParam , authResponseParam . getSalt ( ) , seedBytes ) ; 
if ( ! Arrays . equals ( hMacFromResponse , localGeneratedHMac ) ) throw new FluidClientException ( "Login attempt failure." , FluidClientException . ErrorCode . LOGIN_FAILURE ) ; 
byte [ ] decryptedEncryptedData = AES256Local . decryptInitPacket ( encryptedData , passwordParam , authResponseParam . getSalt ( ) , ivBytes , seedBytes ) ; 
try { 
JSONObject jsonObj = new JSONObject ( new String ( decryptedEncryptedData ) ) ; 
return new AuthEncryptedData ( jsonObj ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class UserQueryClient { 
public UserQueryListing getAllUserQueries ( ) { 
UserQuery userQueryToGetInfoFor = new UserQuery ( ) ; 
if ( this . serviceTicket != null ) userQueryToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
try { 
return new UserQueryListing ( this . postJson ( userQueryToGetInfoFor , WS . Path . UserQuery . Version1 . getAllUserQueries ( ) ) ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class RoleClient { 
public RoleListing getAllRoles ( ) { 
RoleListing roleToGetInfoFor = new RoleListing ( ) ; 
if ( this . serviceTicket != null ) roleToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
try { 
return new RoleListing ( this . postJson ( roleToGetInfoFor , WS . Path . Role . Version1 . getAllRoles ( ) ) ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class ABaseFluidVO { 
public String getServiceTicketAsHexUpper ( ) { 
String serviceTicket = this . getServiceTicket ( ) ; 
if ( serviceTicket == null ) return null ; 
if ( serviceTicket . isEmpty ( ) ) return serviceTicket ; 
byte [ ] base64Bytes = Base64 . getDecoder ( ) . decode ( serviceTicket ) ; 
return this . bytesToHex ( base64Bytes ) ; 
} 
} 

public class FormFieldClient { 
public Field createFieldTextMasked ( Field formFieldParam , String maskValueParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( maskValueParam == null || maskValueParam . trim ( ) . isEmpty ( ) ) maskValueParam = "" ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; 
} 
return new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field createFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( barcodeTypeParam == null || barcodeTypeParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( "Barcode type cannot be empty." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; 
} 
return new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field createFieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
formFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; 
} 
return new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field createFieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
formFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; 
} 
return new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field createFieldTable ( Field formFieldParam , Form formDefinitionParam , boolean sumDecimalsParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Table ) ; 
formFieldParam . setTypeMetaData ( this . getMetaDataForTableField ( formDefinitionParam , sumDecimalsParam ) ) ; 
} 
return new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field updateFieldTextMasked ( Field formFieldParam , String maskValueParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( maskValueParam == null || maskValueParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( "Masked value cannot be empty." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; 
} 
return new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field updateFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( barcodeTypeParam == null || barcodeTypeParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( "Barcode type cannot be empty." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; 
} 
return new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field updateFieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
formFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; 
} 
return new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field updateFieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
formFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; 
} 
return new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field updateFieldTable ( Field formFieldParam , Form formDefinitionParam , boolean sumDecimalsParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( formFieldParam != null ) { 
formFieldParam . setTypeAsEnum ( Field . Type . Table ) ; 
formFieldParam . setTypeMetaData ( this . getMetaDataForTableField ( formDefinitionParam , sumDecimalsParam ) ) ; 
} 
return new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field getFieldByName ( String fieldNameParam ) { 
Field field = new Field ( ) ; 
field . setFieldName ( fieldNameParam ) ; 
if ( this . serviceTicket != null ) field . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( field , WS . Path . FormField . Version1 . getByName ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public FormFieldListing getFieldsByFormNameAndLoggedInUser ( String formNameParam , boolean editOnlyFieldsParam ) { 
Form form = new Form ( ) ; 
form . setFormType ( formNameParam ) ; 
if ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; 
return new FormFieldListing ( this . postJson ( form , WS . Path . FormField . Version1 . getByFormDefinitionAndLoggedInUser ( editOnlyFieldsParam ) ) ) ; 
} 
} 

public class FormFieldClient { 
public FormFieldListing getFieldsByFormTypeIdAndLoggedInUser ( Long formTypeIdParam , boolean editOnlyFieldsParam ) { 
Form form = new Form ( ) ; 
form . setFormTypeId ( formTypeIdParam ) ; 
if ( this . serviceTicket != null ) form . setServiceTicket ( this . serviceTicket ) ; 
return new FormFieldListing ( this . postJson ( form , WS . Path . FormField . Version1 . getByFormDefinitionAndLoggedInUser ( editOnlyFieldsParam ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field deleteField ( Field fieldParam ) { 
if ( fieldParam != null && this . serviceTicket != null ) fieldParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( ) ) ) ; 
} 
} 

public class FormFieldClient { 
public Field forceDeleteField ( Field fieldParam ) { 
if ( fieldParam != null && this . serviceTicket != null ) fieldParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( true ) ) ) ; 
} 
} 

public class UserFieldClient { 
public Field updateFieldValue ( Field userFieldValueParam ) { 
if ( userFieldValueParam != null && this . serviceTicket != null ) userFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( userFieldValueParam , WS . Path . UserField . Version1 . userFieldUpdateValue ( ) ) ) ; 
} 
} 

public class ESFormFieldMappingUtil { 
public GetIndexResponse getOrCreateIndex ( String indexParam ) { 
if ( this . doesIndexExist ( indexParam ) ) return this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; 
else { 
CreateIndexRequestBuilder createIndexRequestBuilder = this . client . admin ( ) . indices ( ) . prepareCreate ( indexParam ) ; 
CreateIndexResponse mappingCreateResponse = createIndexRequestBuilder . execute ( ) . actionGet ( ) ; 
if ( ! mappingCreateResponse . isAcknowledged ( ) ) throw new FluidElasticSearchException ( "Index Creation for '" + indexParam + "' not acknowledged by ElasticSearch." ) ; 
return this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; 
} 
} 
} 

public class FlowClient { 
public Flow createFlow ( Flow flowParam ) { 
if ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; 
return new Flow ( this . putJson ( flowParam , WS . Path . Flow . Version1 . flowCreate ( ) ) ) ; 
} 
} 

public class FlowClient { 
public Flow updateFlow ( Flow flowParam ) { 
if ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowUpdate ( ) ) ) ; 
} 
} 

public class FlowClient { 
public Flow getFlowById ( Long flowIdParam ) { 
Flow flow = new Flow ( flowIdParam ) ; 
if ( this . serviceTicket != null ) flow . setServiceTicket ( this . serviceTicket ) ; 
return new Flow ( this . postJson ( flow , WS . Path . Flow . Version1 . getById ( ) ) ) ; 
} 
} 

public class FlowClient { 
public Flow getFlowByName ( String flowNameParam ) { 
Flow flow = new Flow ( ) ; 
flow . setName ( flowNameParam ) ; 
if ( this . serviceTicket != null ) flow . setServiceTicket ( this . serviceTicket ) ; 
return new Flow ( this . postJson ( flow , WS . Path . Flow . Version1 . getByName ( ) ) ) ; 
} 
} 

public class FlowClient { 
public Flow deleteFlow ( Flow flowParam ) { 
if ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( ) ) ) ; 
} 
} 

public class FlowClient { 
public Flow forceDeleteFlow ( Flow flowParam ) { 
if ( flowParam != null && this . serviceTicket != null ) flowParam . setServiceTicket ( this . serviceTicket ) ; 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( true ) ) ) ; 
} 
} 

public class GlobalFieldClient { 
public Field updateFieldValue ( Field globalFieldValueParam ) { 
if ( globalFieldValueParam != null && this . serviceTicket != null ) globalFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( globalFieldValueParam , Version1 . globalFieldUpdateValue ( ) ) ) ; 
} 
} 

public class GlobalFieldClient { 
public List < Field > getAllGlobalFieldValues ( ) { 
Field field = new Field ( ) ; 
field . setFieldValue ( new MultiChoice ( ) ) ; 
if ( this . serviceTicket != null ) field . setServiceTicket ( this . serviceTicket ) ; 
return new GlobalFieldListing ( this . postJson ( field , Version1 . getAllValues ( ) ) ) . getListing ( ) ; 
} 
} 

public class SQLFormDefinitionUtil { 
public Map < Long , String > getFormDefinitionIdAndTitle ( ) { 
if ( ! LOCAL_MAPPING . isEmpty ( ) ) { 
Map < Long , String > returnVal = new HashMap < > ( LOCAL_MAPPING ) ; 
if ( System . currentTimeMillis ( ) > timeToUpdateAgain ) synchronized ( LOCAL_MAPPING ) { 
LOCAL_MAPPING . clear ( ) ; 
} 
return returnVal ; 
} 
synchronized ( LOCAL_MAPPING ) { 
if ( ! LOCAL_MAPPING . isEmpty ( ) ) return new HashMap < > ( LOCAL_MAPPING ) ; 
PreparedStatement preparedStatement = null ; 
ResultSet resultSet = null ; 
try { 
ISyntax syntax = SyntaxFactory . getInstance ( ) . getSyntaxFor ( this . getSQLTypeFromConnection ( ) , ISyntax . ProcedureMapping . FormDefinition . GetFormDefinitions ) ; 
preparedStatement = this . getConnection ( ) . prepareStatement ( syntax . getPreparedStatement ( ) ) ; 
resultSet = preparedStatement . executeQuery ( ) ; 
while ( resultSet . next ( ) ) { 
Long id = resultSet . getLong ( 1 ) ; 
String title = resultSet . getString ( 2 ) ; 
LOCAL_MAPPING . put ( id , title ) ; 
} 
timeToUpdateAgain = ( System . currentTimeMillis ( ) + TimeUnit . MINUTES . toMillis ( 10 ) ) ; 
} 
catch ( SQLException sqlError ) { 
throw new FluidSQLException ( sqlError ) ; 
} 
finally { 
this . closeStatement ( preparedStatement , resultSet ) ; 
} 
return new HashMap < > ( LOCAL_MAPPING ) ; 
} 
} 
} 

public class ABaseClientWebSocket { 
protected String getExceptionMessageVerbose ( String prefixParam , String uniqueReqIdParam , int numberOfSentItemsParam ) { 
StringBuilder formFieldsCombined = new StringBuilder ( ) ; 
int returnValSize = - 1 ; 
RespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; 
if ( respHandler instanceof AGenericListMessageHandler ) { 
List < ? extends ABaseFluidJSONObject > returnValue = ( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; 
if ( returnValue != null ) { 
returnValSize = returnValue . size ( ) ; 
returnValue . forEach ( listingItm -> { 
if ( listingItm instanceof ABaseListing ) { 
ABaseListing castedToListing = ( ABaseListing ) listingItm ; 
if ( castedToListing != null ) castedToListing . getListing ( ) . forEach ( formItm -> { 
formFieldsCombined . append ( formItm . toString ( ) ) ; 
} 
) ; 
} 
else formFieldsCombined . append ( listingItm . toString ( ) ) ; 
} 
) ; 
} 
} 
return ( prefixParam + ": " + "Timeout while waiting for all return data. There were '" + returnValSize + "' items after a Timeout of " + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + " seconds on req-ref-nr '" + uniqueReqIdParam + "'. Expected a total of '" + numberOfSentItemsParam + "' forms. Returned-Data '" + formFieldsCombined . toString ( ) + "'." ) ; 
} 
} 

public class Auth0Client { 
public AccessToken getAccessToken ( String clientIdParam , String clientSecretParam , String codeParam , String redirectUrlParam ) { 
if ( clientIdParam == null || clientIdParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( "Client Id must be provided." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( clientSecretParam == null || clientSecretParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( "Client Secret must be provided." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( codeParam == null || codeParam . trim ( ) . isEmpty ( ) ) throw new FluidClientException ( "Code must be provided." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
AccessTokenRequest tokenRequest = new AccessTokenRequest ( ) ; 
tokenRequest . setClientId ( clientIdParam ) ; 
tokenRequest . setClientSecret ( clientSecretParam ) ; 
tokenRequest . setGrantType ( AUTHORIZATION_CODE ) ; 
tokenRequest . setCode ( codeParam ) ; 
tokenRequest . setRedirectUri ( redirectUrlParam ) ; 
return new AccessToken ( this . postJson ( false , tokenRequest , WS . Path . Auth0 . Version1 . userToken ( ) ) ) ; 
} 
} 

public class Auth0Client { 
public NormalizedUserProfile getUserProfileInfo ( AccessToken accessTokenParam ) { 
if ( accessTokenParam == null || ( accessTokenParam . getAccessToken ( ) == null || accessTokenParam . getAccessToken ( ) . trim ( ) . isEmpty ( ) ) ) throw new FluidClientException ( "Code must be provided." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
try { 
String accessToken = accessTokenParam . getAccessToken ( ) ; 
List < HeaderNameValue > headerListing = new ArrayList < HeaderNameValue > ( ) ; 
headerListing . add ( new HeaderNameValue ( NormalizedUserProfile . HeaderMapping . AUTHORIZATION , "Bearer " + accessToken ) ) ; 
return new NormalizedUserProfile ( this . getJson ( true , WS . Path . Auth0 . Version1 . userInfo ( ) , headerListing ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new FluidClientException ( "Unable to Encode (Not Supported). " + e . getMessage ( ) , FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; 
} 
} 
} 

public class ABaseClientWS { 
protected JSONObject executeJson ( HttpMethod httpMethodParam , List < HeaderNameValue > headerNameValuesParam , boolean checkConnectionValidParam , ABaseFluidJSONObject baseDomainParam , ContentType contentTypeParam , String postfixUrlParam ) { 
if ( baseDomainParam == null ) throw new FluidClientException ( "No JSON body to post." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
String bodyJsonString = baseDomainParam . toJsonObject ( ) . toString ( ) ; 
return this . executeString ( httpMethodParam , headerNameValuesParam , checkConnectionValidParam , bodyJsonString , contentTypeParam , postfixUrlParam ) ; 
} 
} 

public class ABaseClientWS { 
protected JSONObject executeForm ( HttpMethod httpMethodParam , List < HeaderNameValue > headerNameValuesParam , boolean checkConnectionValidParam , List < FormNameValue > formNameValuesParam , ContentType contentTypeParam , String postfixUrlParam ) { 
if ( formNameValuesParam == null || formNameValuesParam . isEmpty ( ) ) throw new FluidClientException ( "No 'Name and Value' body to post." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
StringBuilder strBuilder = new StringBuilder ( ) ; 
for ( FormNameValue nameValue : formNameValuesParam ) { 
if ( nameValue . getName ( ) == null || nameValue . getName ( ) . trim ( ) . isEmpty ( ) ) continue ; 
if ( nameValue . getValue ( ) == null ) continue ; 
strBuilder . append ( nameValue . getName ( ) ) ; 
strBuilder . append ( EQUALS ) ; 
strBuilder . append ( nameValue . getValue ( ) ) ; 
strBuilder . append ( AMP ) ; 
} 
String bodyJsonString = strBuilder . toString ( ) ; 
bodyJsonString = bodyJsonString . substring ( 0 , bodyJsonString . length ( ) - 1 ) ; 
return this . executeString ( httpMethodParam , headerNameValuesParam , checkConnectionValidParam , bodyJsonString , contentTypeParam , postfixUrlParam ) ; 
} 
} 

public class ABaseClientWS { 
private ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { 
ResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { 
public String handleResponse ( final HttpResponse responseParam ) throws IOException { 
int status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; 
if ( status == 404 ) throw new FluidClientException ( "Endpoint for Service not found. URL [" + urlCalledParam + "]." , FluidClientException . ErrorCode . CONNECT_ERROR ) ; 
else if ( status >= 200 && status < 300 ) { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; 
return responseJsonString ; 
} 
else if ( status == 400 ) { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; 
return responseJsonString ; 
} 
else { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; 
throw new FluidClientException ( "Unexpected response status: " + status + ". " + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + ". \nResponse Text [" + responseString + "]" , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
} 
} 
; 
return responseHandler ; 
} 
} 

public class ABaseClientWS { 
public boolean isConnectionValid ( ) { 
try { 
this . getJson ( false , WS . Path . Test . Version1 . testConnection ( ) ) ; 
} 
catch ( FluidClientException flowJobExcept ) { 
if ( flowJobExcept . getErrorCode ( ) == FluidClientException . ErrorCode . CONNECT_ERROR ) return false ; 
throw flowJobExcept ; 
} 
return true ; 
} 
} 

public class ABaseClientWS { 
private CloseableHttpClient getClient ( ) { 
if ( this . closeableHttpClient != null ) return this . closeableHttpClient ; 
String pathToFluidTrustStore = this . getPathToFluidSpecificTrustStore ( ) ; 
if ( IS_IN_JUNIT_TEST_MODE || pathToFluidTrustStore != null ) { 
SSLContextBuilder builder = new SSLContextBuilder ( ) ; 
try { 
if ( pathToFluidTrustStore == null ) builder . loadTrustMaterial ( new SSLTrustAll ( ) ) ; 
else { 
String password = this . getFluidSpecificTrustStorePassword ( ) ; 
if ( password == null ) password = UtilGlobal . EMPTY ; 
if ( IS_IN_JUNIT_TEST_MODE ) builder . loadTrustMaterial ( new File ( pathToFluidTrustStore ) , password . toCharArray ( ) , new SSLTrustAll ( ) ) ; 
else builder . loadTrustMaterial ( new File ( pathToFluidTrustStore ) , password . toCharArray ( ) ) ; 
} 
SSLContext sslContext = builder . build ( ) ; 
this . closeableHttpClient = HttpClients . custom ( ) . setSSLSocketFactory ( new SSLConnectionSocketFactory ( sslContext ) ) . build ( ) ; 
} 
catch ( NoSuchAlgorithmException e ) { 
throw new FluidClientException ( "NoSuchAlgorithm: Unable to load self signed trust material. " + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} 
catch ( KeyManagementException e ) { 
throw new FluidClientException ( "KeyManagement: Unable to load self signed trust material. " + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} 
catch ( KeyStoreException e ) { 
throw new FluidClientException ( "KeyStore: Unable to load self signed trust material. " + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} 
catch ( CertificateException e ) { 
throw new FluidClientException ( "Certificate: Unable to load self signed trust material. " + e . getMessage ( ) , e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} 
catch ( IOException ioError ) { 
throw new FluidClientException ( "IOError: Unable to load self signed trust material. " + ioError . getMessage ( ) , ioError , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} 
} 
else this . closeableHttpClient = HttpClients . createDefault ( ) ; 
return this . closeableHttpClient ; 
} 
} 

public class ABaseClientWS { 
private String getPathToFluidSpecificTrustStore ( ) { 
String fluidSystemTrustStore = System . getProperty ( SYSTEM_PROP_FLUID_TRUST_STORE ) ; 
if ( fluidSystemTrustStore == null || fluidSystemTrustStore . trim ( ) . isEmpty ( ) ) return null ; 
File certFile = new File ( fluidSystemTrustStore ) ; 
if ( certFile . exists ( ) && certFile . isFile ( ) ) return fluidSystemTrustStore ; 
return null ; 
} 
} 

public class ABaseSQLUtil { 
public void closeConnection ( ) { 
if ( this . connection == null ) return ; 
try { 
if ( this . connection . isClosed ( ) ) return ; 
this . connection . close ( ) ; 
} 
catch ( SQLException sqlExcept ) { 
throw new FluidSQLException ( sqlExcept ) ; 
} 
} 
} 

public class FlowItemClient { 
public FluidItemListing getFluidItemsForView ( JobView jobViewParam , int queryLimitParam , int offsetParam , String sortFieldParam , String sortOrderParam ) { 
if ( this . serviceTicket != null && jobViewParam != null ) jobViewParam . setServiceTicket ( this . serviceTicket ) ; 
try { 
return new FluidItemListing ( this . postJson ( jobViewParam , WS . Path . FlowItem . Version1 . getByJobView ( queryLimitParam , offsetParam , sortFieldParam , sortOrderParam ) ) ) ; 
} 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class FlowItemClient { 
public FluidItem sendFormToFlow ( Form formToSendToFlowParam , String flowParam ) { 
FluidItem itemToSend = new FluidItem ( ) ; 
itemToSend . setForm ( formToSendToFlowParam ) ; 
itemToSend . setFlow ( flowParam ) ; 
if ( this . serviceTicket != null ) itemToSend . setServiceTicket ( this . serviceTicket ) ; 
try { 
return new FluidItem ( this . postJson ( itemToSend , WS . Path . FlowItem . Version1 . sendFlowItemToFlow ( ) ) ) ; 
} 
catch ( JSONException e ) { 
throw new FluidClientException ( e . getMessage ( ) , e , FluidClientException . ErrorCode . JSON_PARSING ) ; 
} 
} 
} 

public class WebSocketClient { 
@ OnClose public void onClose ( Session userSessionParam , CloseReason reasonParam ) { 
this . userSession = null ; 
if ( this . messageHandlers != null ) this . messageHandlers . values ( ) . forEach ( handle -> { 
handle . connectionClosed ( ) ; 
} 
) ; 
} 
} 

public class WebSocketClient { 
@ OnMessage public void onMessage ( String messageParam ) { 
boolean handlerFoundForMsg = false ; 
for ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { 
Object qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; 
if ( qualifyObj instanceof Error ) handler . handleMessage ( qualifyObj ) ; 
else if ( qualifyObj instanceof JSONObject ) { 
handler . handleMessage ( qualifyObj ) ; 
handlerFoundForMsg = true ; 
break ; 
} 
} 
if ( ! handlerFoundForMsg ) throw new FluidClientException ( "No handler found for message;\n" + messageParam , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
} 

public class WebSocketClient { 
public void sendMessage ( ABaseFluidJSONObject aBaseFluidJSONObjectParam ) { 
if ( aBaseFluidJSONObjectParam == null ) throw new FluidClientException ( "No JSON Object to send." , FluidClientException . ErrorCode . IO_ERROR ) ; 
else this . sendMessage ( aBaseFluidJSONObjectParam . toJsonObject ( ) . toString ( ) ) ; 
} 
} 

public class WebSocketClient { 
public void sendMessage ( String messageToSendParam ) { 
if ( this . userSession == null ) throw new FluidClientException ( "User Session is not set. Check if connection is open." , FluidClientException . ErrorCode . IO_ERROR ) ; 
RemoteEndpoint . Async asyncRemote = null ; 
if ( ( asyncRemote = this . userSession . getAsyncRemote ( ) ) == null ) throw new FluidClientException ( "Remote Session is not set. Check if connection is open." , FluidClientException . ErrorCode . IO_ERROR ) ; 
asyncRemote . sendText ( messageToSendParam ) ; 
} 
} 

public class WebSocketClient { 
public void closeSession ( ) { 
if ( this . userSession == null ) return ; 
try { 
this . userSession . close ( ) ; 
} 
catch ( IOException e ) { 
throw new FluidClientException ( "Unable to close session. " + e . getMessage ( ) , e , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
} 
} 

public class SQLUtilWebSocketExecuteNativeSQLClient { 
public List < SQLResultSet > executeNativeSQLSynchronized ( NativeSQLQuery nativeSQLQueryParam ) { 
if ( nativeSQLQueryParam == null ) return null ; 
if ( nativeSQLQueryParam . getDatasourceName ( ) == null || nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) throw new FluidClientException ( "No data-source name provided. Not allowed." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( ( nativeSQLQueryParam . getQuery ( ) == null || nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) && ( nativeSQLQueryParam . getStoredProcedure ( ) == null || nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) ) return null ; 
this . setEchoIfNotSet ( nativeSQLQueryParam ) ; 
String uniqueReqId = this . initNewRequest ( ) ; 
this . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; 
try { 
List < SQLResultSet > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( this . getTimeoutInMillis ( ) , TimeUnit . MILLISECONDS ) ; 
if ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) throw new FluidClientException ( "SQLUtil-WebSocket-ExecuteNativeSQL: " + "The connection was closed by the server prior to the response received." , FluidClientException . ErrorCode . IO_ERROR ) ; 
return returnValue ; 
} 
catch ( InterruptedException exceptParam ) { 
throw new FluidClientException ( "SQLUtil-WebSocket-ExecuteNativeSQL: " + exceptParam . getMessage ( ) , exceptParam , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; 
} 
catch ( ExecutionException executeProblem ) { 
Throwable cause = executeProblem . getCause ( ) ; 
if ( cause instanceof FluidClientException ) throw ( FluidClientException ) cause ; 
else throw new FluidClientException ( "SQLUtil-WebSocket-ExecuteNativeSQL: " + cause . getMessage ( ) , cause , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; 
} 
catch ( TimeoutException eParam ) { 
throw new FluidClientException ( "SQLUtil-WebSocket-ExecuteNativeSQL: Timeout while waiting for all return data. There were '" + this . getHandler ( uniqueReqId ) . getReturnValue ( ) . size ( ) + "' items after a Timeout of " + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + " seconds." , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
finally { 
this . removeHandler ( uniqueReqId ) ; 
} 
} 
} 

public class FluidLicenseClient { 
public String requestLicense ( LicenseRequest licenseRequestParam ) { 
if ( licenseRequestParam != null && this . serviceTicket != null ) licenseRequestParam . setServiceTicket ( this . serviceTicket ) ; 
return this . executeTxtReceiveTxt ( HttpMethod . POST , null , false , ( licenseRequestParam == null ) ? null : licenseRequestParam . toJsonObject ( ) . toString ( ) , ContentType . APPLICATION_JSON , Version1 . licenseRequest ( ) ) ; 
} 
} 

public class FluidLicenseClient { 
public LicenseRequest applyLicense ( String licenseToApplyParam ) { 
LicenseRequest liceReq = new LicenseRequest ( ) ; 
liceReq . setLicenseCipherText ( licenseToApplyParam ) ; 
if ( this . serviceTicket != null ) liceReq . setServiceTicket ( this . serviceTicket ) ; 
return new LicenseRequest ( this . postJson ( liceReq , Version1 . licenseApply ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field createFieldTextPlain ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; 
} 
return new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field createFieldParagraphTextPlain ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; 
} 
return new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field createFieldParagraphTextHTML ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; 
} 
return new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field createFieldMultiChoiceSelectMany ( Field routeFieldParam , List < String > multiChoiceValuesParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( multiChoiceValuesParam == null || multiChoiceValuesParam . isEmpty ( ) ) throw new FluidClientException ( "No Multi-choice values provided." , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . SELECT_MANY ) ; 
routeFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; 
} 
return new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field createFieldDateTimeDate ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; 
} 
return new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field updateFieldTextPlain ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; 
} 
return new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field updateFieldParagraphTextHTML ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; 
} 
return new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field updateFieldDateTimeDateAndTime ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; 
} 
return new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field updateFieldDecimalPlain ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; 
} 
return new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field updateFieldValue ( Field routeFieldValueParam ) { 
if ( routeFieldValueParam != null && this . serviceTicket != null ) routeFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( routeFieldValueParam , Version1 . routeFieldUpdateValue ( ) ) ) ; 
} 
} 

public class RouteFieldClient { 
public Field createFieldValue ( Field routeFieldValueToCreateParam , FluidItem fluidItemParam ) { 
if ( routeFieldValueToCreateParam != null && this . serviceTicket != null ) routeFieldValueToCreateParam . setServiceTicket ( this . serviceTicket ) ; 
Long fluidItmId = ( fluidItemParam == null ) ? null : fluidItemParam . getId ( ) ; 
return new Field ( this . putJson ( routeFieldValueToCreateParam , Version1 . routeFieldCreateValue ( fluidItmId ) ) ) ; 
} 
} 

public class ConfigurationClient { 
public Configuration getConfigurationByKey ( String configurationKeyParam ) { 
Configuration configuration = new Configuration ( ) ; 
configuration . setKey ( configurationKeyParam ) ; 
if ( this . serviceTicket != null ) configuration . setServiceTicket ( this . serviceTicket ) ; 
return new Configuration ( this . postJson ( configuration , WS . Path . Configuration . Version1 . getByKey ( ) ) ) ; 
} 
} 

public class ConfigurationClient { 
public ConfigurationListing getAllConfigurations ( ) { 
Configuration configuration = new Configuration ( ) ; 
if ( this . serviceTicket != null ) configuration . setServiceTicket ( this . serviceTicket ) ; 
return new ConfigurationListing ( this . postJson ( configuration , WS . Path . Configuration . Version1 . getAllConfigurations ( ) ) ) ; 
} 
} 

public class AttachmentClient { 
public Attachment createAttachment ( Attachment attachmentParam ) { 
if ( attachmentParam != null && this . serviceTicket != null ) attachmentParam . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . putJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentCreate ( ) ) ) ; 
} 
} 

public class AttachmentClient { 
public Attachment getAttachmentById ( Long attachmentIdParam , boolean includeAttachmentDataParam ) { 
Attachment attachment = new Attachment ( attachmentIdParam ) ; 
if ( this . serviceTicket != null ) attachment . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . postJson ( attachment , WS . Path . Attachment . Version1 . getById ( includeAttachmentDataParam ) ) ) ; 
} 
} 

public class AttachmentClient { 
public Attachment deleteAttachment ( Attachment attachmentParam ) { 
if ( attachmentParam != null && this . serviceTicket != null ) attachmentParam . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . postJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( ) ) ) ; 
} 
} 

public class AttachmentClient { 
public Attachment forceDeleteAttachment ( Attachment attachmentParam ) { 
if ( attachmentParam != null && this . serviceTicket != null ) attachmentParam . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . postJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( true ) ) ) ; 
} 
} 

public class XsdParserJar { 
private void parseJarFile ( InputStream inputStream ) { 
try { 
Node schemaNode = getSchemaNode ( inputStream ) ; 
if ( isXsdSchema ( schemaNode ) ) XsdSchema . parse ( this , schemaNode ) ; 
else throw new ParsingException ( "The top level element of a XSD file should be the xsd:schema node." ) ; 
} 
catch ( SAXException | IOException | ParserConfigurationException e ) { 
Logger . getAnonymousLogger ( ) . log ( Level . SEVERE , "Exception while parsing." , e ) ; 
} 
} 
} 

public class XsdParserJar { 
private void setClassLoader ( String jarPath ) { 
if ( ! jarPath . endsWith ( ".jar" ) ) throw new ParsingException ( "The jarPath received doesn't represent a jar file." ) ; 
ClassLoader originalCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
URL url = originalCl . getResource ( jarPath ) ; 
if ( url == null ) try { 
url = new URL ( "file:/" + jarPath ) ; 
} 
catch ( MalformedURLException e ) { 
throw new ParsingException ( "Invalid jar name." ) ; 
} 
ClassLoader urlCl = URLClassLoader . newInstance ( new URL [ ] { 
url } 
, originalCl ) ; 
Thread . currentThread ( ) . setContextClassLoader ( urlCl ) ; 
classLoader = urlCl ; 
} 
} 

public class XsdGroup { 
private void rule2 ( ) { 
if ( ! ( parent instanceof XsdSchema ) && name != null ) throw new ParsingException ( XSD_TAG + " element: The " + NAME_TAG + " should only be used when the parent of the " + XSD_TAG + " is the " + XsdSchema . XSD_TAG + " element." ) ; 
} 
} 

public class XsdGroup { 
private void rule3 ( ) { 
if ( parent instanceof XsdSchema && name == null ) throw new ParsingException ( XSD_TAG + " element: The " + NAME_TAG + " should is required the parent of the " + XSD_TAG + " is the " + XsdSchema . XSD_TAG + " element." ) ; 
} 
} 

public class XsdAttribute { 
private void rule3 ( ) { 
if ( attributesMap . containsKey ( REF_TAG ) && ( simpleType != null || form != null || type != null ) ) throw new ParsingException ( XSD_TAG + " element: If " + REF_TAG + " attribute is present, simpleType element, form attribute and type attribute cannot be present at the same time." ) ; 
} 
} 

public class XsdElement { 
private void rule7 ( ) { 
if ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) throw new ParsingException ( XSD_TAG + " element: The " + FORM_TAG + " attribute can only be present when the parent of the " + xsdElementIsXsdSchema ) ; 
} 
} 

public class XsdElement { 
private void rule3 ( ) { 
if ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) throw new ParsingException ( XSD_TAG + " element: The " + REF_TAG + " attribute cannot be present when the parent of the " + xsdElementIsXsdSchema ) ; 
} 
} 

public class ConvertTypeOfObject { 
@ Override public T convert ( final Object value ) { 
if ( value == null ) return null ; 
else if ( isIterable ( ) && Iterable . class . isAssignableFrom ( value . getClass ( ) ) ) return convertIterable ( value ) ; 
else if ( reflectedKlass . assignableFromObject ( value ) ) return ( T ) value ; 
else if ( reflectedKlass . canBeUnboxed ( value . getClass ( ) ) ) return ( T ) value ; 
else if ( reflectedKlass . canBeBoxed ( value . getClass ( ) ) ) return ( T ) value ; 
FluentClass < ? > klassToCreate ; 
if ( reflectedKlass . isPrimitive ( ) ) klassToCreate = reflectedKlass . boxedType ( ) ; 
else klassToCreate = reflectedKlass ; 
return ( T ) convertValueTo ( value , klassToCreate ) ; 
} 
} 

public class DiscoveryApi { 
Builder urlBuilder ( String path ) { 
Builder builder = baseUrlBuilder ( ) . addPathSegment ( configuration . getApiPackage ( ) ) . addPathSegment ( configuration . getApiVersion ( ) ) . addPathSegment ( path ) ; 
if ( configuration . getPathModifier ( ) != DiscoveryApiConfiguration . PathModifier . NONE ) builder . addPathSegment ( configuration . getPathModifier ( ) . getModifier ( ) ) ; 
return builder ; 
} 
} 

public class Line { 
public double getValue ( double p ) { 
if ( module == null ) throw new NoModuleException ( ) ; 
double x = ( x1 - x0 ) * p + x0 ; 
double y = ( y1 - y0 ) * p + y0 ; 
double z = ( z1 - z0 ) * p + z0 ; 
double value = module . getValue ( x , y , z ) ; 
if ( attenuate ) return p * ( 1.0 - p ) * 4 * value ; 
else return value ; 
} 
} 

public class Range { 
public void setBounds ( double currentLower , double currentUpper , double newLower , double newUpper ) { 
if ( currentLower == currentUpper ) throw new IllegalArgumentException ( "currentLower must not equal currentUpper. Both are " + currentUpper ) ; 
if ( newLower == newUpper ) throw new IllegalArgumentException ( "newLowerBound must not equal newUpperBound. Both are " + newUpper ) ; 
currentLowerBound = currentLower ; 
currentUpperBound = currentUpper ; 
newLowerBound = newLower ; 
newUpperBound = newUpper ; 
recalculateScaleBias ( ) ; 
} 
} 

public class RestoreContext { 
public void restore ( ) { 
for ( String propertyName : propertyNames ) { 
if ( restoreProperties . containsKey ( propertyName ) ) System . setProperty ( propertyName , restoreProperties . get ( propertyName ) ) ; 
else System . clearProperty ( propertyName ) ; 
} 
} 
} 

public class SoftSet { 
private void processQueue ( ) { 
ComparableSoftReference cr ; 
while ( ( cr = ( ComparableSoftReference ) gcqueue . poll ( ) ) != null ) map . remove ( cr . getKey ( ) ) ; 
} 
} 

public class NestedRuntimeException { 
public void printStackTrace ( final PrintStream stream ) { 
if ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) super . printStackTrace ( stream ) ; 
NestedThrowable . Util . print ( nested , stream ) ; 
} 
} 

public class NestedRuntimeException { 
public void printStackTrace ( final PrintWriter writer ) { 
if ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) super . printStackTrace ( writer ) ; 
NestedThrowable . Util . print ( nested , writer ) ; 
} 
} 

public class BasicTaskWrapper { 
public void run ( ) { 
this . runThread = Thread . currentThread ( ) ; 
long runTime = getElapsedTime ( ) ; 
if ( startTimeout > 0l && runTime >= startTimeout ) { 
taskRejected ( new StartTimeoutException ( "Start Timeout exceeded for task " + taskString ) ) ; 
return ; 
} 
boolean stopped = false ; 
synchronized ( stateLock ) { 
if ( state == TASK_STOPPED ) stopped = true ; 
else { 
state = TASK_STARTED ; 
taskStarted ( ) ; 
if ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; 
} 
} 
if ( stopped ) { 
taskRejected ( new TaskStoppedException ( "Task stopped for task " + taskString ) ) ; 
return ; 
} 
Throwable throwable = null ; 
try { 
task . execute ( ) ; 
} 
catch ( Throwable t ) { 
throwable = t ; 
} 
taskCompleted ( throwable ) ; 
synchronized ( stateLock ) { 
state = TASK_COMPLETED ; 
if ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; 
} 
} 
} 

public class WorkerQueue { 
protected Executable getJobImpl ( ) throws InterruptedException { 
while ( m_currentJob == null ) wait ( ) ; 
JobItem item = m_currentJob ; 
m_currentJob = m_currentJob . m_next ; 
return item . m_job ; 
} 
} 

public class WorkerQueue { 
protected void putJobImpl ( Executable job ) { 
JobItem posted = new JobItem ( job ) ; 
if ( m_currentJob == null ) { 
m_currentJob = posted ; 
notifyAll ( ) ; 
} 
else { 
JobItem item = m_currentJob ; 
while ( item . m_next != null ) item = item . m_next ; 
item . m_next = posted ; 
} 
} 
} 

public class BlockingMode { 
public static final BlockingMode toBlockingMode ( String name ) { 
BlockingMode mode = null ; 
if ( name == null ) mode = null ; 
else if ( name . equalsIgnoreCase ( "run" ) ) mode = RUN ; 
else if ( name . equalsIgnoreCase ( "wait" ) ) mode = WAIT ; 
else if ( name . equalsIgnoreCase ( "discard" ) ) mode = DISCARD ; 
else if ( name . equalsIgnoreCase ( "discardOldest" ) ) mode = DISCARD_OLDEST ; 
else if ( name . equalsIgnoreCase ( "abort" ) ) mode = ABORT ; 
return mode ; 
} 
} 

public class Catalog { 
protected void copyReaders ( Catalog newCatalog ) { 
Vector mapArr = new Vector ( readerMap . size ( ) ) ; 
for ( int count = 0 ; 
count < readerMap . size ( ) ; 
count ++ ) mapArr . add ( null ) ; 
Enumeration enumt = readerMap . keys ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
String mimeType = ( String ) enumt . nextElement ( ) ; 
Integer pos = ( Integer ) readerMap . get ( mimeType ) ; 
mapArr . set ( pos . intValue ( ) , mimeType ) ; 
} 
for ( int count = 0 ; 
count < mapArr . size ( ) ; 
count ++ ) { 
String mimeType = ( String ) mapArr . get ( count ) ; 
Integer pos = ( Integer ) readerMap . get ( mimeType ) ; 
newCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; 
} 
} 
} 

public class Catalog { 
public void loadSystemCatalogs ( ) throws MalformedURLException , IOException { 
Vector catalogs = catalogManager . getCatalogFiles ( ) ; 
if ( catalogs != null ) for ( int count = 0 ; 
count < catalogs . size ( ) ; 
count ++ ) catalogFiles . addElement ( catalogs . elementAt ( count ) ) ; 
if ( catalogFiles . size ( ) > 0 ) { 
String catfile = ( String ) catalogFiles . lastElement ( ) ; 
catalogFiles . removeElement ( catfile ) ; 
parseCatalog ( catfile ) ; 
} 
} 
} 

public class Catalog { 
public synchronized void parseCatalog ( URL aUrl ) throws IOException { 
catalogCwd = aUrl ; 
base = aUrl ; 
default_override = catalogManager . getPreferPublic ( ) ; 
catalogManager . debug . message ( 4 , "Parse catalog: " + aUrl . toString ( ) ) ; 
DataInputStream inStream = null ; 
boolean parsed = false ; 
for ( int count = 0 ; 
! parsed && count < readerArr . size ( ) ; 
count ++ ) { 
CatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; 
try { 
inStream = new DataInputStream ( aUrl . openStream ( ) ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
break ; 
} 
try { 
reader . readCatalog ( this , inStream ) ; 
parsed = true ; 
} 
catch ( CatalogException ce ) { 
if ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) break ; 
else { 
} 
} 
try { 
inStream . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
if ( parsed ) parsePendingCatalogs ( ) ; 
} 
} 

public class Catalog { 
protected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { 
if ( ! localCatalogFiles . isEmpty ( ) ) { 
Vector newQueue = new Vector ( ) ; 
Enumeration q = localCatalogFiles . elements ( ) ; 
while ( q . hasMoreElements ( ) ) newQueue . addElement ( q . nextElement ( ) ) ; 
for ( int curCat = 0 ; 
curCat < catalogFiles . size ( ) ; 
curCat ++ ) { 
String catfile = ( String ) catalogFiles . elementAt ( curCat ) ; 
newQueue . addElement ( catfile ) ; 
} 
catalogFiles = newQueue ; 
localCatalogFiles . clear ( ) ; 
} 
if ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { 
Enumeration e = localDelegate . elements ( ) ; 
while ( e . hasMoreElements ( ) ) catalogEntries . addElement ( e . nextElement ( ) ) ; 
localDelegate . clear ( ) ; 
} 
while ( ! catalogFiles . isEmpty ( ) ) { 
String catfile = ( String ) catalogFiles . elementAt ( 0 ) ; 
try { 
catalogFiles . remove ( 0 ) ; 
} 
catch ( ArrayIndexOutOfBoundsException e ) { 
} 
if ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) try { 
parseCatalogFile ( catfile ) ; 
} 
catch ( CatalogException ce ) { 
System . out . println ( "FIXME: " + ce . toString ( ) ) ; 
} 
else catalogs . addElement ( catfile ) ; 
if ( ! localCatalogFiles . isEmpty ( ) ) { 
Vector newQueue = new Vector ( ) ; 
Enumeration q = localCatalogFiles . elements ( ) ; 
while ( q . hasMoreElements ( ) ) newQueue . addElement ( q . nextElement ( ) ) ; 
for ( int curCat = 0 ; 
curCat < catalogFiles . size ( ) ; 
curCat ++ ) { 
catfile = ( String ) catalogFiles . elementAt ( curCat ) ; 
newQueue . addElement ( catfile ) ; 
} 
catalogFiles = newQueue ; 
localCatalogFiles . clear ( ) ; 
} 
if ( ! localDelegate . isEmpty ( ) ) { 
Enumeration e = localDelegate . elements ( ) ; 
while ( e . hasMoreElements ( ) ) catalogEntries . addElement ( e . nextElement ( ) ) ; 
localDelegate . clear ( ) ; 
} 
} 
catalogFiles . clear ( ) ; 
} 
} 

public class Catalog { 
protected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { 
try { 
String userdir = fixSlashes ( System . getProperty ( "user.dir" ) ) ; 
catalogCwd = new URL ( "file:" + userdir + "/basename" ) ; 
} 
catch ( MalformedURLException e ) { 
String userdir = fixSlashes ( System . getProperty ( "user.dir" ) ) ; 
catalogManager . debug . message ( 1 , "Malformed URL on cwd" , userdir ) ; 
catalogCwd = null ; 
} 
try { 
base = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; 
} 
catch ( MalformedURLException e ) { 
try { 
base = new URL ( "file:" + fixSlashes ( fileName ) ) ; 
} 
catch ( MalformedURLException e2 ) { 
catalogManager . debug . message ( 1 , "Malformed URL on catalog filename" , fixSlashes ( fileName ) ) ; 
base = null ; 
} 
} 
catalogManager . debug . message ( 2 , "Loading catalog" , fileName ) ; 
catalogManager . debug . message ( 4 , "Default BASE" , base . toString ( ) ) ; 
fileName = base . toString ( ) ; 
DataInputStream inStream = null ; 
boolean parsed = false ; 
boolean notFound = false ; 
for ( int count = 0 ; 
! parsed && count < readerArr . size ( ) ; 
count ++ ) { 
CatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; 
try { 
notFound = false ; 
inStream = new DataInputStream ( base . openStream ( ) ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
notFound = true ; 
break ; 
} 
try { 
reader . readCatalog ( this , inStream ) ; 
parsed = true ; 
} 
catch ( CatalogException ce ) { 
if ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) break ; 
else { 
} 
} 
try { 
inStream . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
if ( ! parsed ) if ( notFound ) catalogManager . debug . message ( 3 , "Catalog does not exist" , fileName ) ; 
else catalogManager . debug . message ( 1 , "Failed to parse catalog" , fileName ) ; 
} 
} 

public class Catalog { 
public String resolveDoctype ( String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { 
String resolved = null ; 
catalogManager . debug . message ( 3 , "resolveDoctype(" + entityName + "," + publicId + "," + systemId + ")" ) ; 
systemId = normalizeURI ( systemId ) ; 
if ( publicId != null && publicId . startsWith ( "urn:publicid:" ) ) publicId = PublicId . decodeURN ( publicId ) ; 
if ( systemId != null && systemId . startsWith ( "urn:publicid:" ) ) { 
systemId = PublicId . decodeURN ( systemId ) ; 
if ( publicId != null && ! publicId . equals ( systemId ) ) { 
catalogManager . debug . message ( 1 , "urn:publicid: system identifier differs from public identifier; using public identifier" ) ; 
systemId = null ; 
} 
else { 
publicId = systemId ; 
systemId = null ; 
} 
} 
if ( systemId != null ) { 
resolved = resolveLocalSystem ( systemId ) ; 
if ( resolved != null ) return resolved ; 
} 
if ( publicId != null ) { 
resolved = resolveLocalPublic ( DOCTYPE , entityName , publicId , systemId ) ; 
if ( resolved != null ) return resolved ; 
} 
boolean over = default_override ; 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == OVERRIDE ) { 
over = e . getEntryArg ( 0 ) . equalsIgnoreCase ( "YES" ) ; 
continue ; 
} 
if ( e . getEntryType ( ) == DOCTYPE && e . getEntryArg ( 0 ) . equals ( entityName ) ) if ( over || systemId == null ) return e . getEntryArg ( 1 ) ; 
} 
return resolveSubordinateCatalogs ( DOCTYPE , entityName , publicId , systemId ) ; 
} 
} 

public class Catalog { 
public String resolveDocument ( ) throws MalformedURLException , IOException { 
catalogManager . debug . message ( 3 , "resolveDocument" ) ; 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == DOCUMENT ) return e . getEntryArg ( 1 ) ; 
} 
return resolveSubordinateCatalogs ( DOCUMENT , null , null , null ) ; 
} 
} 

public class Catalog { 
public String resolveSystem ( String systemId ) throws MalformedURLException , IOException { 
catalogManager . debug . message ( 3 , "resolveSystem(" + systemId + ")" ) ; 
systemId = normalizeURI ( systemId ) ; 
if ( systemId != null && systemId . startsWith ( "urn:publicid:" ) ) { 
systemId = PublicId . decodeURN ( systemId ) ; 
return resolvePublic ( systemId , null ) ; 
} 
if ( systemId != null ) { 
String resolved = resolveLocalSystem ( systemId ) ; 
if ( resolved != null ) return resolved ; 
} 
return resolveSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; 
} 
} 

public class Catalog { 
protected String resolveLocalURI ( String uri ) throws MalformedURLException , IOException { 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == URI && ( e . getEntryArg ( 0 ) . equals ( uri ) ) ) return e . getEntryArg ( 1 ) ; 
} 
enumt = catalogEntries . elements ( ) ; 
String startString = null ; 
String prefix = null ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == REWRITE_URI ) { 
String p = e . getEntryArg ( 0 ) ; 
if ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) if ( startString == null || p . length ( ) > startString . length ( ) ) { 
startString = p ; 
prefix = e . getEntryArg ( 1 ) ; 
} 
} 
if ( prefix != null ) return prefix + uri . substring ( startString . length ( ) ) ; 
} 
enumt = catalogEntries . elements ( ) ; 
Vector delCats = new Vector ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == DELEGATE_URI ) { 
String p = e . getEntryArg ( 0 ) ; 
if ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) delCats . addElement ( e . getEntryArg ( 1 ) ) ; 
} 
} 
if ( delCats . size ( ) > 0 ) { 
Enumeration enumCats = delCats . elements ( ) ; 
if ( catalogManager . debug . getDebug ( ) > 1 ) { 
catalogManager . debug . message ( 2 , "Switching to delegated catalog(s):" ) ; 
while ( enumCats . hasMoreElements ( ) ) { 
String delegatedCatalog = ( String ) enumCats . nextElement ( ) ; 
catalogManager . debug . message ( 2 , "\t" + delegatedCatalog ) ; 
} 
} 
Catalog dcat = newCatalog ( ) ; 
enumCats = delCats . elements ( ) ; 
while ( enumCats . hasMoreElements ( ) ) { 
String delegatedCatalog = ( String ) enumCats . nextElement ( ) ; 
dcat . parseCatalog ( delegatedCatalog ) ; 
} 
return dcat . resolveURI ( uri ) ; 
} 
return null ; 
} 
} 

public class Catalog { 
protected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { 
for ( int catPos = 0 ; 
catPos < catalogs . size ( ) ; 
catPos ++ ) { 
Catalog c = null ; 
try { 
c = ( Catalog ) catalogs . elementAt ( catPos ) ; 
} 
catch ( ClassCastException e ) { 
String catfile = ( String ) catalogs . elementAt ( catPos ) ; 
c = newCatalog ( ) ; 
try { 
c . parseCatalog ( catfile ) ; 
} 
catch ( MalformedURLException mue ) { 
catalogManager . debug . message ( 1 , "Malformed Catalog URL" , catfile ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, file not found" , catfile ) ; 
} 
catch ( IOException ioe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, I/O error" , catfile ) ; 
} 
catalogs . setElementAt ( c , catPos ) ; 
} 
String resolved = null ; 
if ( entityType == DOCTYPE ) resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; 
else if ( entityType == DOCUMENT ) resolved = c . resolveDocument ( ) ; 
else if ( entityType == ENTITY ) resolved = c . resolveEntity ( entityName , publicId , systemId ) ; 
else if ( entityType == NOTATION ) resolved = c . resolveNotation ( entityName , publicId , systemId ) ; 
else if ( entityType == PUBLIC ) resolved = c . resolvePublic ( publicId , systemId ) ; 
else if ( entityType == SYSTEM ) resolved = c . resolveSystem ( systemId ) ; 
else if ( entityType == URI ) resolved = c . resolveURI ( systemId ) ; 
if ( resolved != null ) return resolved ; 
} 
return null ; 
} 
} 

public class Catalog { 
protected String makeAbsolute ( String sysid ) { 
URL local = null ; 
sysid = fixSlashes ( sysid ) ; 
try { 
local = new URL ( base , sysid ) ; 
} 
catch ( MalformedURLException e ) { 
catalogManager . debug . message ( 1 , "Malformed URL on system identifier" , sysid ) ; 
} 
if ( local != null ) return local . toString ( ) ; 
else return sysid ; 
} 
} 

public class Catalog { 
protected String normalizeURI ( String uriref ) { 
String newRef = "" ; 
byte [ ] bytes ; 
if ( uriref == null ) return null ; 
try { 
bytes = uriref . getBytes ( "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException uee ) { 
catalogManager . debug . message ( 1 , "UTF-8 is an unsupported encoding!?" ) ; 
return uriref ; 
} 
for ( int count = 0 ; 
count < bytes . length ; 
count ++ ) { 
int ch = bytes [ count ] & 0xFF ; 
if ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) newRef += encodedByte ( ch ) ; 
else newRef += ( char ) bytes [ count ] ; 
} 
return newRef ; 
} 
} 

public class Catalog { 
protected String encodedByte ( int b ) { 
String hex = Integer . toHexString ( b ) . toUpperCase ( ) ; 
if ( hex . length ( ) < 2 ) return "%0" + hex ; 
else return "%" + hex ; 
} 
} 

public class Catalog { 
protected void addDelegate ( CatalogEntry entry ) { 
int pos = 0 ; 
String partial = entry . getEntryArg ( 0 ) ; 
Enumeration local = localDelegate . elements ( ) ; 
while ( local . hasMoreElements ( ) ) { 
CatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; 
String dp = dpe . getEntryArg ( 0 ) ; 
if ( dp . equals ( partial ) ) return ; 
if ( dp . length ( ) > partial . length ( ) ) pos ++ ; 
if ( dp . length ( ) < partial . length ( ) ) break ; 
} 
if ( localDelegate . size ( ) == 0 ) localDelegate . addElement ( entry ) ; 
else localDelegate . insertElementAt ( entry , pos ) ; 
} 
} 

public class ThrowableHandler { 
protected static void fireOnThrowable ( int type , Throwable t ) { 
Object [ ] list = listeners . toArray ( ) ; 
for ( int i = 0 ; 
i < list . length ; 
i ++ ) ( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; 
} 
} 

public class InetAddressEditor { 
public Object getValue ( ) { 
try { 
String text = getAsText ( ) ; 
if ( text == null ) return null ; 
if ( text . startsWith ( "/" ) ) text = text . substring ( 1 ) ; 
return InetAddress . getByName ( StringPropertyReplacer . replaceProperties ( text ) ) ; 
} 
catch ( UnknownHostException e ) { 
throw new NestedRuntimeException ( e ) ; 
} 
} 
} 

public class CachedList { 
private void maintain ( ) { 
SoftObject obj ; 
int count = 0 ; 
while ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { 
count ++ ; 
list . remove ( obj ) ; 
} 
if ( count != 0 ) System . err . println ( "vm reclaimed " + count + " objects" ) ; 
} 
} 

public class CatalogEntry { 
public static int getEntryType ( String name ) throws CatalogException { 
if ( ! entryTypes . containsKey ( name ) ) throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; 
Integer iType = ( Integer ) entryTypes . get ( name ) ; 
if ( iType == null ) throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; 
return iType . intValue ( ) ; 
} 
} 

public class URLStreamHandlerFactory { 
@ SuppressWarnings ( "unused" ) public static void preload ( ) { 
for ( int i = 0 ; 
i < PROTOCOLS . length ; 
i ++ ) try { 
URL url = new URL ( PROTOCOLS [ i ] , "" , - 1 , "" ) ; 
log . trace ( "Loaded protocol: " + PROTOCOLS [ i ] ) ; 
} 
catch ( Exception e ) { 
log . warn ( "Failed to load protocol: " + PROTOCOLS [ i ] , e ) ; 
} 
} 
} 

public class URLStreamHandlerFactory { 
public URLStreamHandler createURLStreamHandler ( final String protocol ) { 
URLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; 
if ( handler != null ) return handler ; 
String prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; 
if ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; 
createURLStreamHandlerProtocol . set ( protocol ) ; 
checkHandlerPkgs ( ) ; 
ClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
for ( int p = 0 ; 
p < handlerPkgs . length ; 
p ++ ) try { 
String classname = handlerPkgs [ p ] + "." + protocol + ".Handler" ; 
Class < ? > type = null ; 
try { 
type = ctxLoader . loadClass ( classname ) ; 
} 
catch ( ClassNotFoundException e ) { 
type = Class . forName ( classname ) ; 
} 
if ( type != null ) { 
handler = ( URLStreamHandler ) type . newInstance ( ) ; 
handlerMap . put ( protocol , handler ) ; 
log . trace ( "Found protocol:" + protocol + " handler:" + handler ) ; 
} 
} 
catch ( Throwable ignore ) { 
} 
createURLStreamHandlerProtocol . set ( null ) ; 
return handler ; 
} 
} 

public class LongCounter { 
public static LongCounter makeDirectional ( final LongCounter counter , final boolean increasing ) { 
LongCounter temp ; 
if ( increasing ) temp = new Wrapper ( counter ) { 
private static final long serialVersionUID = - 8902748795144754375L ; 
public long decrement ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
public void reset ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
else temp = new Wrapper ( counter ) { 
private static final long serialVersionUID = 2584758778978644599L ; 
public long increment ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
return temp ; 
} 
} 

public class OASISXMLCatalogReader { 
protected boolean inExtensionNamespace ( ) { 
boolean inExtension = false ; 
Enumeration elements = namespaceStack . elements ( ) ; 
while ( ! inExtension && elements . hasMoreElements ( ) ) { 
String ns = ( String ) elements . nextElement ( ) ; 
if ( ns == null ) inExtension = true ; 
else inExtension = ( ! ns . equals ( tr9401NamespaceName ) && ! ns . equals ( namespaceName ) ) ; 
} 
return inExtension ; 
} 
} 

public class Strings { 
public static String [ ] split ( final String string , final String delim , final int limit ) { 
int count = count ( string , delim ) + 1 ; 
if ( limit > 0 && count > limit ) count = limit ; 
String strings [ ] = new String [ count ] ; 
int begin = 0 ; 
for ( int i = 0 ; 
i < count ; 
i ++ ) { 
int end = string . indexOf ( delim , begin ) ; 
if ( end == - 1 || i + 1 == count ) end = string . length ( ) ; 
if ( end == 0 ) strings [ i ] = EMPTY ; 
else strings [ i ] = string . substring ( begin , end ) ; 
begin = end + 1 ; 
} 
return strings ; 
} 
} 

public class Strings { 
public static String join ( final byte array [ ] ) { 
Byte bytes [ ] = new Byte [ array . length ] ; 
for ( int i = 0 ; 
i < bytes . length ; 
i ++ ) bytes [ i ] = new Byte ( array [ i ] ) ; 
return join ( bytes , null ) ; 
} 
} 

public class TimedCachePolicy { 
public Object get ( Object key ) { 
TimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; 
if ( entry == null ) return null ; 
if ( entry . isCurrent ( now ) == false ) if ( entry . refresh ( ) == false ) { 
entry . destroy ( ) ; 
entryMap . remove ( key ) ; 
return null ; 
} 
Object value = entry . getValue ( ) ; 
return value ; 
} 
} 

public class XmlHelper { 
public static Iterator getChildrenByTagName ( Element element , String tagName ) { 
if ( element == null ) return null ; 
NodeList children = element . getChildNodes ( ) ; 
ArrayList goodChildren = new ArrayList ( ) ; 
for ( int i = 0 ; 
i < children . getLength ( ) ; 
i ++ ) { 
Node currentChild = children . item ( i ) ; 
if ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) goodChildren . add ( currentChild ) ; 
} 
return goodChildren . iterator ( ) ; 
} 
} 

public class XmlHelper { 
public static Element getUniqueChild ( Element element , String tagName ) throws Exception { 
Iterator goodChildren = getChildrenByTagName ( element , tagName ) ; 
if ( goodChildren != null && goodChildren . hasNext ( ) ) { 
Element child = ( Element ) goodChildren . next ( ) ; 
if ( goodChildren . hasNext ( ) ) throw new Exception ( "expected only one " + tagName + " tag" ) ; 
return child ; 
} 
else throw new Exception ( "expected one " + tagName + " tag" ) ; 
} 
} 

public class XmlHelper { 
public static String getElementContent ( Element element , String defaultStr ) throws Exception { 
if ( element == null ) return defaultStr ; 
NodeList children = element . getChildNodes ( ) ; 
String result = "" ; 
for ( int i = 0 ; 
i < children . getLength ( ) ; 
i ++ ) if ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) result += children . item ( i ) . getNodeValue ( ) ; 
else if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { 
} 
return result . trim ( ) ; 
} 
} 

public class Resolver { 
public String resolveSystem ( String systemId ) throws MalformedURLException , IOException { 
String resolved = super . resolveSystem ( systemId ) ; 
if ( resolved != null ) return resolved ; 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == RESOLVER ) { 
resolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; 
if ( resolved != null ) return resolved ; 
} 
else if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { 
String suffix = e . getEntryArg ( 0 ) ; 
String result = e . getEntryArg ( 1 ) ; 
if ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) return result ; 
} 
} 
return resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; 
} 
} 

public class Resolver { 
public String resolvePublic ( String publicId , String systemId ) throws MalformedURLException , IOException { 
String resolved = super . resolvePublic ( publicId , systemId ) ; 
if ( resolved != null ) return resolved ; 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == RESOLVER ) { 
if ( systemId != null ) { 
resolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; 
if ( resolved != null ) return resolved ; 
} 
resolved = resolveExternalPublic ( publicId , e . getEntryArg ( 0 ) ) ; 
if ( resolved != null ) return resolved ; 
} 
} 
return resolveSubordinateCatalogs ( Catalog . PUBLIC , null , publicId , systemId ) ; 
} 
} 

public class Resolver { 
protected String resolveExternalSystem ( String systemId , String resolver ) throws MalformedURLException , IOException { 
Resolver r = queryResolver ( resolver , "i2l" , systemId , null ) ; 
if ( r != null ) return r . resolveSystem ( systemId ) ; 
else return null ; 
} 
} 

public class Resolver { 
protected String resolveExternalPublic ( String publicId , String resolver ) throws MalformedURLException , IOException { 
Resolver r = queryResolver ( resolver , "fpi2l" , publicId , null ) ; 
if ( r != null ) return r . resolvePublic ( publicId , null ) ; 
else return null ; 
} 
} 

public class Resolver { 
protected Resolver queryResolver ( String resolver , String command , String arg1 , String arg2 ) { 
String RFC2483 = resolver + "?command=" + command + "&format=tr9401&uri=" + arg1 + "&uri2=" + arg2 ; 
try { 
URL url = new URL ( RFC2483 ) ; 
URLConnection urlCon = url . openConnection ( ) ; 
urlCon . setUseCaches ( false ) ; 
Resolver r = ( Resolver ) newCatalog ( ) ; 
String cType = urlCon . getContentType ( ) ; 
if ( cType . indexOf ( ";" ) > 0 ) cType = cType . substring ( 0 , cType . indexOf ( ";" ) ) ; 
r . parseCatalog ( cType , urlCon . getInputStream ( ) ) ; 
return r ; 
} 
catch ( CatalogException cex ) { 
if ( cex . getExceptionType ( ) == CatalogException . UNPARSEABLE ) catalogManager . debug . message ( 1 , "Unparseable catalog: " + RFC2483 ) ; 
else if ( cex . getExceptionType ( ) == CatalogException . UNKNOWN_FORMAT ) catalogManager . debug . message ( 1 , "Unknown catalog format: " + RFC2483 ) ; 
return null ; 
} 
catch ( MalformedURLException mue ) { 
catalogManager . debug . message ( 1 , "Malformed resolver URL: " + RFC2483 ) ; 
return null ; 
} 
catch ( IOException ie ) { 
catalogManager . debug . message ( 1 , "I/O Exception opening resolver: " + RFC2483 ) ; 
return null ; 
} 
} 
} 

public class Resolver { 
private Vector appendVector ( Vector vec , Vector appvec ) { 
if ( appvec != null ) for ( int count = 0 ; 
count < appvec . size ( ) ; 
count ++ ) vec . addElement ( appvec . elementAt ( count ) ) ; 
return vec ; 
} 
} 

public class Resolver { 
public String resolveSystemReverse ( String systemId ) throws MalformedURLException , IOException { 
Vector resolved = resolveAllSystemReverse ( systemId ) ; 
if ( resolved != null && resolved . size ( ) > 0 ) return ( String ) resolved . elementAt ( 0 ) ; 
else return null ; 
} 
} 

public class Resolver { 
public Vector resolveAllSystem ( String systemId ) throws MalformedURLException , IOException { 
Vector resolutions = new Vector ( ) ; 
if ( systemId != null ) { 
Vector localResolutions = resolveAllLocalSystem ( systemId ) ; 
resolutions = appendVector ( resolutions , localResolutions ) ; 
} 
Vector subResolutions = resolveAllSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; 
resolutions = appendVector ( resolutions , subResolutions ) ; 
if ( resolutions . size ( ) > 0 ) return resolutions ; 
else return null ; 
} 
} 

public class Resolver { 
private Vector resolveAllLocalSystem ( String systemId ) { 
Vector map = new Vector ( ) ; 
String osname = System . getProperty ( "os.name" ) ; 
boolean windows = ( osname . indexOf ( "Windows" ) >= 0 ) ; 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == SYSTEM && ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) ) map . addElement ( e . getEntryArg ( 1 ) ) ; 
} 
if ( map . size ( ) == 0 ) return null ; 
else return map ; 
} 
} 

public class Resolver { 
private synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { 
Vector resolutions = new Vector ( ) ; 
for ( int catPos = 0 ; 
catPos < catalogs . size ( ) ; 
catPos ++ ) { 
Resolver c = null ; 
try { 
c = ( Resolver ) catalogs . elementAt ( catPos ) ; 
} 
catch ( ClassCastException e ) { 
String catfile = ( String ) catalogs . elementAt ( catPos ) ; 
c = ( Resolver ) newCatalog ( ) ; 
try { 
c . parseCatalog ( catfile ) ; 
} 
catch ( MalformedURLException mue ) { 
catalogManager . debug . message ( 1 , "Malformed Catalog URL" , catfile ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, file not found" , catfile ) ; 
} 
catch ( IOException ioe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, I/O error" , catfile ) ; 
} 
catalogs . setElementAt ( c , catPos ) ; 
} 
String resolved = null ; 
if ( entityType == DOCTYPE ) { 
resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == DOCUMENT ) { 
resolved = c . resolveDocument ( ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == ENTITY ) { 
resolved = c . resolveEntity ( entityName , publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == NOTATION ) { 
resolved = c . resolveNotation ( entityName , publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == PUBLIC ) { 
resolved = c . resolvePublic ( publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == SYSTEM ) { 
Vector localResolutions = c . resolveAllSystem ( systemId ) ; 
resolutions = appendVector ( resolutions , localResolutions ) ; 
break ; 
} 
else if ( entityType == SYSTEMREVERSE ) { 
Vector localResolutions = c . resolveAllSystemReverse ( systemId ) ; 
resolutions = appendVector ( resolutions , localResolutions ) ; 
} 
} 
if ( resolutions != null ) return resolutions ; 
else return null ; 
} 
} 

public class SAXCatalogReader { 
public void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { 
if ( parserFactory == null && parserClass == null ) { 
debug . message ( 1 , "Cannot read SAX catalog without a parser" ) ; 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
debug = catalog . getCatalogManager ( ) . debug ; 
EntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; 
this . catalog = catalog ; 
try { 
if ( parserFactory != null ) { 
SAXParser parser = parserFactory . newSAXParser ( ) ; 
SAXParserHandler spHandler = new SAXParserHandler ( ) ; 
spHandler . setContentHandler ( this ) ; 
if ( bResolver != null ) spHandler . setEntityResolver ( bResolver ) ; 
parser . parse ( new InputSource ( is ) , spHandler ) ; 
} 
else { 
Parser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; 
parser . setDocumentHandler ( this ) ; 
if ( bResolver != null ) parser . setEntityResolver ( bResolver ) ; 
parser . parse ( new InputSource ( is ) ) ; 
} 
} 
catch ( ClassNotFoundException cnfe ) { 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
catch ( IllegalAccessException iae ) { 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
catch ( InstantiationException ie ) { 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
catch ( ParserConfigurationException pce ) { 
throw new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; 
} 
catch ( SAXException se ) { 
Exception e = se . getException ( ) ; 
UnknownHostException uhe = new UnknownHostException ( ) ; 
FileNotFoundException fnfe = new FileNotFoundException ( ) ; 
if ( e != null ) if ( e . getClass ( ) == uhe . getClass ( ) ) throw new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; 
else if ( e . getClass ( ) == fnfe . getClass ( ) ) throw new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; 
throw new CatalogException ( se ) ; 
} 
} 
} 

public class FileURLConnection { 
public void connect ( ) throws IOException { 
if ( connected ) return ; 
if ( ! file . exists ( ) ) throw new FileNotFoundException ( file . getPath ( ) ) ; 
connected = true ; 
} 
} 

public class Node { 
void helpDelete ( Node < K , V > b , Node < K , V > f ) { 
if ( f == next && this == b . next ) if ( f == null || f . value != f ) appendMarker ( f ) ; 
else b . casNext ( this , f . next ) ; 
} 
} 

public class JBossObject { 
public static void list ( JBossStringBuilder buffer , Collection objects ) { 
if ( objects == null ) return ; 
buffer . append ( '[' ) ; 
if ( objects . isEmpty ( ) == false ) for ( Iterator i = objects . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
Object object = i . next ( ) ; 
if ( object instanceof JBossObject ) ( ( JBossObject ) object ) . toShortString ( buffer ) ; 
else buffer . append ( object . toString ( ) ) ; 
if ( i . hasNext ( ) ) buffer . append ( ", " ) ; 
} 
buffer . append ( ']' ) ; 
} 
} 

public class Objects { 
public static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { 
try { 
return type . getConstructor ( new Class [ ] { 
valueType } 
) ; 
} 
catch ( Exception ignore ) { 
Class [ ] types = type . getClasses ( ) ; 
for ( int i = 0 ; 
i < types . length ; 
i ++ ) try { 
return type . getConstructor ( new Class [ ] { 
types [ i ] } 
) ; 
} 
catch ( Exception ignore2 ) { 
} 
} 
return null ; 
} 
} 

public class PropertyMap { 
public boolean removePropertyListener ( PropertyListener listener ) { 
if ( listener == null ) throw new NullArgumentException ( "listener" ) ; 
boolean removed = false ; 
if ( listener instanceof BoundPropertyListener ) removed = removePropertyListener ( ( BoundPropertyListener ) listener ) ; 
else removed = unboundListeners . remove ( listener ) ; 
return removed ; 
} 
} 

public class PropertyMap { 
protected void firePropertyChanged ( PropertyEvent event ) { 
if ( boundListeners != null ) { 
List list = ( List ) boundListeners . get ( event . getPropertyName ( ) ) ; 
if ( list != null ) firePropertyChanged ( list , event ) ; 
} 
firePropertyChanged ( unboundListeners , event ) ; 
} 
} 

public class JBossEntityResolver { 
protected InputSource resolveSystemID ( String systemId , boolean trace ) { 
if ( systemId == null ) return null ; 
if ( trace ) log . trace ( "resolveSystemID, systemId=" + systemId ) ; 
InputSource inputSource = null ; 
String filename = null ; 
if ( localEntities != null ) filename = ( String ) localEntities . get ( systemId ) ; 
if ( filename == null ) filename = ( String ) entities . get ( systemId ) ; 
if ( filename != null ) { 
if ( trace ) log . trace ( "Found entity systemId=" + systemId + " fileName=" + filename ) ; 
InputStream ins = loadClasspathResource ( filename , trace ) ; 
if ( ins != null ) { 
inputSource = new InputSource ( ins ) ; 
inputSource . setSystemId ( systemId ) ; 
} 
else log . warn ( "Cannot load systemId from resource: " + filename ) ; 
} 
return inputSource ; 
} 
} 

public class JBossEntityResolver { 
protected InputSource resolveSystemIDasURL ( String systemId , boolean trace ) { 
if ( systemId == null ) return null ; 
if ( trace ) log . trace ( "resolveSystemIDasURL, systemId=" + systemId ) ; 
InputSource inputSource = null ; 
try { 
if ( trace ) log . trace ( "Trying to resolve systemId as a URL" ) ; 
if ( isReplaceSystemProperties ( ) ) systemId = StringPropertyReplacer . replaceProperties ( systemId ) ; 
URL url = new URL ( systemId ) ; 
if ( warnOnNonFileURLs && url . getProtocol ( ) . equalsIgnoreCase ( "file" ) == false && url . getProtocol ( ) . equalsIgnoreCase ( "vfszip" ) == false ) log . warn ( "Trying to resolve systemId as a non-file URL: " + systemId ) ; 
InputStream ins = url . openStream ( ) ; 
if ( ins != null ) { 
inputSource = new InputSource ( ins ) ; 
inputSource . setSystemId ( systemId ) ; 
} 
else log . warn ( "Cannot load systemId as URL: " + systemId ) ; 
if ( trace ) log . trace ( "Resolved systemId as a URL" ) ; 
} 
catch ( MalformedURLException ignored ) { 
if ( trace ) log . trace ( "SystemId is not a url: " + systemId , ignored ) ; 
} 
catch ( IOException e ) { 
if ( trace ) log . trace ( "Failed to obtain URL.InputStream from systemId: " + systemId , e ) ; 
} 
return inputSource ; 
} 
} 

public class PublicId { 
public static String normalize ( String publicId ) { 
String normal = publicId . replace ( '\t' , ' ' ) ; 
normal = normal . replace ( '\r' , ' ' ) ; 
normal = normal . replace ( '\n' , ' ' ) ; 
normal = normal . trim ( ) ; 
int pos ; 
while ( ( pos = normal . indexOf ( "  " ) ) >= 0 ) normal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; 
return normal ; 
} 
} 

public class PublicId { 
public static String decodeURN ( String urn ) { 
String publicId = "" ; 
if ( urn . startsWith ( "urn:publicid:" ) ) publicId = urn . substring ( 13 ) ; 
else return urn ; 
publicId = PublicId . stringReplace ( publicId , "%2F" , "/" ) ; 
publicId = PublicId . stringReplace ( publicId , ":" , "//" ) ; 
publicId = PublicId . stringReplace ( publicId , "%3A" , ":" ) ; 
publicId = PublicId . stringReplace ( publicId , ";" , "::" ) ; 
publicId = PublicId . stringReplace ( publicId , "+" , " " ) ; 
publicId = PublicId . stringReplace ( publicId , "%2B" , "+" ) ; 
publicId = PublicId . stringReplace ( publicId , "%23" , "#" ) ; 
publicId = PublicId . stringReplace ( publicId , "%3F" , "?" ) ; 
publicId = PublicId . stringReplace ( publicId , "%27" , "'" ) ; 
publicId = PublicId . stringReplace ( publicId , "%3B" , ";" ) ; 
publicId = PublicId . stringReplace ( publicId , "%25" , "%" ) ; 
return publicId ; 
} 
} 

public class HashCode { 
public static int generate ( final Object array [ ] , final boolean deep ) { 
int hashcode = 0 ; 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) if ( deep && ( array [ i ] instanceof Object [ ] ) ) hashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; 
else hashcode ^= array [ i ] . hashCode ( ) ; 
return hashcode ; 
} 
} 

public class TextCatalogReader { 
protected String nextToken ( ) throws IOException { 
String token = "" ; 
int ch , nextch ; 
if ( ! tokenStack . empty ( ) ) return ( String ) tokenStack . pop ( ) ; 
while ( true ) { 
ch = catfile . read ( ) ; 
while ( ch <= ' ' ) { 
ch = catfile . read ( ) ; 
if ( ch < 0 ) return null ; 
} 
nextch = catfile . read ( ) ; 
if ( nextch < 0 ) return null ; 
if ( ch == '-' && nextch == '-' ) { 
ch = ' ' ; 
nextch = nextChar ( ) ; 
while ( ch != '-' || nextch != '-' ) { 
ch = nextch ; 
nextch = nextChar ( ) ; 
} 
} 
else { 
stack [ ++ top ] = nextch ; 
stack [ ++ top ] = ch ; 
break ; 
} 
} 
ch = nextChar ( ) ; 
if ( ch == '"' || ch == '\'' ) { 
int quote = ch ; 
while ( ( ch = nextChar ( ) ) != quote ) { 
char [ ] chararr = new char [ 1 ] ; 
chararr [ 0 ] = ( char ) ch ; 
String s = new String ( chararr ) ; 
token = token . concat ( s ) ; 
} 
return token ; 
} 
else { 
while ( ch > ' ' ) { 
nextch = nextChar ( ) ; 
if ( ch == '-' && nextch == '-' ) { 
stack [ ++ top ] = ch ; 
stack [ ++ top ] = nextch ; 
return token ; 
} 
else { 
char [ ] chararr = new char [ 1 ] ; 
chararr [ 0 ] = ( char ) ch ; 
String s = new String ( chararr ) ; 
token = token . concat ( s ) ; 
ch = nextch ; 
} 
} 
return token ; 
} 
} 
} 

public class DateEditor { 
public static void initialize ( ) { 
PrivilegedAction action = new PrivilegedAction ( ) { 
public Object run ( ) { 
String defaultFormat = System . getProperty ( "org.jboss.util.propertyeditor.DateEditor.format" , "MMM d, yyyy" ) ; 
String defaultLocale = System . getProperty ( "org.jboss.util.propertyeditor.DateEditor.locale" ) ; 
DateFormat defaultDateFormat ; 
if ( defaultLocale == null || defaultLocale . length ( ) == 0 ) defaultDateFormat = new SimpleDateFormat ( defaultFormat ) ; 
else defaultDateFormat = new SimpleDateFormat ( defaultFormat , Strings . parseLocaleString ( defaultLocale ) ) ; 
formats = new DateFormat [ ] { 
defaultDateFormat , new SimpleDateFormat ( "EEE MMM d HH:mm:ss z yyyy" ) , new SimpleDateFormat ( "EEE, d MMM yyyy HH:mm:ss Z" ) } 
; 
return null ; 
} 
} 
; 
AccessController . doPrivileged ( action ) ; 
} 
} 

public class DOMUtils { 
public static QName resolveQName ( Element el , String qualifiedName ) { 
QName qname ; 
String prefix = "" ; 
String namespaceURI = "" ; 
String localPart = qualifiedName ; 
int colIndex = qualifiedName . indexOf ( ":" ) ; 
if ( colIndex > 0 ) { 
prefix = qualifiedName . substring ( 0 , colIndex ) ; 
localPart = qualifiedName . substring ( colIndex + 1 ) ; 
if ( "xmlns" . equals ( prefix ) ) namespaceURI = "URI:XML_PREDEFINED_NAMESPACE" ; 
else { 
Element nsElement = el ; 
while ( namespaceURI . equals ( "" ) && nsElement != null ) { 
namespaceURI = nsElement . getAttribute ( "xmlns:" + prefix ) ; 
if ( namespaceURI . equals ( "" ) ) nsElement = getParentElement ( nsElement ) ; 
} 
} 
if ( namespaceURI . equals ( "" ) ) throw new IllegalArgumentException ( "Cannot find namespace uri for: " + qualifiedName ) ; 
} 
qname = new QName ( namespaceURI , localPart , prefix ) ; 
return qname ; 
} 
} 

public class DOMUtils { 
public static void copyAttributes ( Element destElement , Element srcElement ) { 
NamedNodeMap attribs = srcElement . getAttributes ( ) ; 
for ( int i = 0 ; 
i < attribs . getLength ( ) ; 
i ++ ) { 
Attr attr = ( Attr ) attribs . item ( i ) ; 
String uri = attr . getNamespaceURI ( ) ; 
String qname = attr . getName ( ) ; 
String value = attr . getNodeValue ( ) ; 
if ( uri == null && qname . startsWith ( "xmlns" ) ) log . trace ( "Ignore attribute: [uri=" + uri + ",qname=" + qname + ",value=" + value + "]" ) ; 
else destElement . setAttributeNS ( uri , qname , value ) ; 
} 
} 
} 

public class DOMCatalogReader { 
public void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { 
DocumentBuilderFactory factory = null ; 
DocumentBuilder builder = null ; 
factory = DocumentBuilderFactory . newInstance ( ) ; 
factory . setNamespaceAware ( false ) ; 
factory . setValidating ( false ) ; 
try { 
builder = factory . newDocumentBuilder ( ) ; 
} 
catch ( ParserConfigurationException pce ) { 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
Document doc = null ; 
try { 
doc = builder . parse ( is ) ; 
} 
catch ( SAXException se ) { 
throw new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; 
} 
Element root = doc . getDocumentElement ( ) ; 
String namespaceURI = Namespaces . getNamespaceURI ( root ) ; 
String localName = Namespaces . getLocalName ( root ) ; 
String domParserClass = getCatalogParser ( namespaceURI , localName ) ; 
if ( domParserClass == null ) { 
if ( namespaceURI == null ) catalog . getCatalogManager ( ) . debug . message ( 1 , "No Catalog parser for " + localName ) ; 
else catalog . getCatalogManager ( ) . debug . message ( 1 , "No Catalog parser for " + "{" + namespaceURI + "}" + localName ) ; 
return ; 
} 
DOMCatalogParser domParser = null ; 
try { 
domParser = ( DOMCatalogParser ) Class . forName ( domParserClass ) . newInstance ( ) ; 
} 
catch ( ClassNotFoundException cnfe ) { 
catalog . getCatalogManager ( ) . debug . message ( 1 , "Cannot load XML Catalog Parser class" , domParserClass ) ; 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
catch ( InstantiationException ie ) { 
catalog . getCatalogManager ( ) . debug . message ( 1 , "Cannot instantiate XML Catalog Parser class" , domParserClass ) ; 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
catch ( IllegalAccessException iae ) { 
catalog . getCatalogManager ( ) . debug . message ( 1 , "Cannot access XML Catalog Parser class" , domParserClass ) ; 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
catch ( ClassCastException cce ) { 
catalog . getCatalogManager ( ) . debug . message ( 1 , "Cannot cast XML Catalog Parser class" , domParserClass ) ; 
throw new CatalogException ( CatalogException . UNPARSEABLE ) ; 
} 
Node node = root . getFirstChild ( ) ; 
while ( node != null ) { 
domParser . parseCatalogEntry ( catalog , node ) ; 
node = node . getNextSibling ( ) ; 
} 
} 
} 

public class CatalogLocation { 
public InputSource resolveEntity ( String publicId , String systemId ) throws MalformedURLException , IOException { 
String resolvedURI = catologResolver . resolveSystem ( systemId ) ; 
if ( resolvedURI == null ) resolvedURI = catologResolver . resolvePublic ( publicId , systemId ) ; 
if ( resolvedURI != null ) { 
final InputSource is = new InputSource ( ) ; 
is . setPublicId ( publicId ) ; 
is . setSystemId ( systemId ) ; 
is . setByteStream ( this . loadResource ( resolvedURI ) ) ; 
this . isLastEntityResolved = true ; 
return is ; 
} 
else { 
this . isLastEntityResolved = false ; 
return null ; 
} 
} 
} 

public class Classes { 
public static void forceLoad ( final Class type ) { 
if ( type == null ) throw new NullArgumentException ( "type" ) ; 
if ( type . isPrimitive ( ) ) return ; 
String packageName = Classes . getPackageName ( type ) ; 
if ( packageName . startsWith ( "java." ) || packageName . startsWith ( "javax." ) ) return ; 
try { 
Method methods [ ] = type . getDeclaredMethods ( ) ; 
Method method = null ; 
for ( int i = 0 ; 
i < methods . length ; 
i ++ ) { 
int modifiers = methods [ i ] . getModifiers ( ) ; 
if ( Modifier . isStatic ( modifiers ) ) { 
method = methods [ i ] ; 
break ; 
} 
} 
if ( method != null ) method . invoke ( null , ( Object [ ] ) null ) ; 
else type . newInstance ( ) ; 
} 
catch ( Exception ignore ) { 
ThrowableHandler . add ( ignore ) ; 
} 
} 
} 

public class Classes { 
public static Class getPrimitiveWrapper ( final Class type ) { 
if ( ! type . isPrimitive ( ) ) throw new IllegalArgumentException ( "type is not a primitive class" ) ; 
for ( int i = 0 ; 
i < PRIMITIVE_WRAPPER_MAP . length ; 
i += 2 ) if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; 
throw new UnreachableStatementException ( ) ; 
} 
} 

public class Classes { 
public static void getAllInterfaces ( List allIfaces , Class c ) { 
while ( c != null ) { 
Class [ ] ifaces = c . getInterfaces ( ) ; 
for ( int n = 0 ; 
n < ifaces . length ; 
n ++ ) allIfaces . add ( ifaces [ n ] ) ; 
c = c . getSuperclass ( ) ; 
} 
} 
} 

public class Classes { 
public static Class [ ] getAllUniqueInterfaces ( Class c ) { 
Set uniqueIfaces = new HashSet ( ) ; 
while ( c != null ) { 
Class [ ] ifaces = c . getInterfaces ( ) ; 
for ( int n = 0 ; 
n < ifaces . length ; 
n ++ ) uniqueIfaces . add ( ifaces [ n ] ) ; 
c = c . getSuperclass ( ) ; 
} 
return ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; 
} 
} 

public class Classes { 
public static boolean isPrimitiveWrapper ( final Class type ) { 
for ( int i = 0 ; 
i < PRIMITIVE_WRAPPER_MAP . length ; 
i += 2 ) if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) return true ; 
return false ; 
} 
} 

public class Classes { 
public final static Method getAttributeGetter ( Class cls , String attr ) throws NoSuchMethodException { 
StringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; 
buf . append ( "get" ) ; 
if ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) buf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; 
else buf . append ( attr ) ; 
try { 
return cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; 
} 
catch ( NoSuchMethodException e ) { 
buf . replace ( 0 , 3 , "is" ) ; 
return cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; 
} 
} 
} 

public class Classes { 
public final static Method getAttributeSetter ( Class cls , String attr , Class type ) throws NoSuchMethodException { 
StringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; 
buf . append ( "set" ) ; 
if ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) buf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; 
else buf . append ( attr ) ; 
return cls . getMethod ( buf . toString ( ) , new Class [ ] { 
type } 
) ; 
} 
} 

public class Classes { 
private final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { 
int arraySize = 0 ; 
while ( name . endsWith ( "[]" ) ) { 
name = name . substring ( 0 , name . length ( ) - 2 ) ; 
arraySize ++ ; 
} 
Class c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; 
if ( c == null ) try { 
c = cl . loadClass ( name ) ; 
} 
catch ( ClassNotFoundException cnfe ) { 
throw new ClassNotFoundException ( "Parameter class not found: " + name ) ; 
} 
if ( arraySize > 0 ) { 
int [ ] dims = new int [ arraySize ] ; 
for ( int i = 0 ; 
i < arraySize ; 
i ++ ) dims [ i ] = 1 ; 
c = Array . newInstance ( c , dims ) . getClass ( ) ; 
} 
return c ; 
} 
} 

public class DefaultPropertyReader { 
public static String [ ] getFilenames ( final String propertyName ) throws PropertyException { 
String filenames [ ] ; 
Object filename = PropertyManager . getProperty ( propertyName ) ; 
if ( filename != null ) filenames = new String [ ] { 
String . valueOf ( filename ) } 
; 
else filenames = PropertyManager . getArrayProperty ( propertyName ) ; 
return filenames ; 
} 
} 

public class WeakSet { 
protected final void maintain ( ) { 
WeakObject weak ; 
while ( ( weak = ( WeakObject ) queue . poll ( ) ) != null ) set . remove ( weak ) ; 
} 
} 

public class WeakSet { 
public Iterator iterator ( ) { 
return new Iterator ( ) { 
Iterator iter = set . iterator ( ) ; 
Object UNKNOWN = new Object ( ) ; 
Object next = UNKNOWN ; 
public boolean hasNext ( ) { 
if ( next != UNKNOWN ) return true ; 
while ( iter . hasNext ( ) ) { 
WeakObject weak = ( WeakObject ) iter . next ( ) ; 
Object obj = null ; 
if ( weak != null && ( obj = weak . get ( ) ) == null ) continue ; 
next = obj ; 
return true ; 
} 
return false ; 
} 
public Object next ( ) { 
if ( ( next == UNKNOWN ) && ! hasNext ( ) ) throw new NoSuchElementException ( ) ; 
Object obj = next ; 
next = UNKNOWN ; 
return obj ; 
} 
public void remove ( ) { 
iter . remove ( ) ; 
} 
} 
; 
} 
} 

public class URLListerFactory { 
public URLLister createURLLister ( String protocol ) throws MalformedURLException { 
try { 
String className = ( String ) classes . get ( protocol ) ; 
if ( className == null ) throw new MalformedURLException ( "No lister class defined for protocol " + protocol ) ; 
Class < ? > clazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; 
return ( URLLister ) clazz . newInstance ( ) ; 
} 
catch ( ClassNotFoundException e ) { 
throw new MalformedURLException ( e . getMessage ( ) ) ; 
} 
catch ( InstantiationException e ) { 
throw new MalformedURLException ( e . getMessage ( ) ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new MalformedURLException ( e . getMessage ( ) ) ; 
} 
} 
} 

public class PropertyGroup { 
@ SuppressWarnings ( "unchecked" ) public Set entrySet ( ) { 
final Set superSet = super . entrySet ( true ) ; 
return new java . util . AbstractSet ( ) { 
private boolean isInGroup ( Map . Entry entry ) { 
String key = ( String ) entry . getKey ( ) ; 
return key . startsWith ( basename ) ; 
} 
public int size ( ) { 
Iterator iter = superSet . iterator ( ) ; 
int count = 0 ; 
while ( iter . hasNext ( ) ) { 
Map . Entry entry = ( Map . Entry ) iter . next ( ) ; 
if ( isInGroup ( entry ) ) count ++ ; 
} 
return count ; 
} 
public Iterator iterator ( ) { 
return new Iterator ( ) { 
private Iterator iter = superSet . iterator ( ) ; 
private Object next ; 
public boolean hasNext ( ) { 
if ( next != null ) return true ; 
while ( next == null ) if ( iter . hasNext ( ) ) { 
Map . Entry entry = ( Map . Entry ) iter . next ( ) ; 
if ( isInGroup ( entry ) ) { 
next = entry ; 
return true ; 
} 
} 
else break ; 
return false ; 
} 
public Object next ( ) { 
if ( next == null ) throw new java . util . NoSuchElementException ( ) ; 
Object obj = next ; 
next = null ; 
return obj ; 
} 
public void remove ( ) { 
iter . remove ( ) ; 
} 
} 
; 
} 
} 
; 
} 
} 

public class PropertyEditors { 
public static Object convertValue ( String text , String typeName ) throws ClassNotFoundException , IntrospectionException { 
Class < ? > typeClass = Classes . getPrimitiveTypeForName ( typeName ) ; 
if ( typeClass == null ) { 
ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
typeClass = loader . loadClass ( typeName ) ; 
} 
PropertyEditor editor = PropertyEditorManager . findEditor ( typeClass ) ; 
if ( editor == null ) throw new IntrospectionException ( "No property editor for type=" + typeClass ) ; 
editor . setAsText ( text ) ; 
return editor . getValue ( ) ; 
} 
} 

public class ApplicationDeadlockException { 
public static ApplicationDeadlockException isADE ( Throwable t ) { 
while ( t != null ) if ( t instanceof ApplicationDeadlockException ) return ( ApplicationDeadlockException ) t ; 
else t = t . getCause ( ) ; 
return null ; 
} 
} 

public class CatalogManager { 
private synchronized void readProperties ( ) { 
try { 
propertyFileURI = CatalogManager . class . getResource ( "/" + propertyFile ) ; 
InputStream in = CatalogManager . class . getResourceAsStream ( "/" + propertyFile ) ; 
if ( in == null ) { 
if ( ! ignoreMissingProperties ) { 
System . err . println ( "Cannot find " + propertyFile ) ; 
ignoreMissingProperties = true ; 
} 
return ; 
} 
resources = new PropertyResourceBundle ( in ) ; 
} 
catch ( MissingResourceException mre ) { 
if ( ! ignoreMissingProperties ) System . err . println ( "Cannot read " + propertyFile ) ; 
} 
catch ( java . io . IOException e ) { 
if ( ! ignoreMissingProperties ) System . err . println ( "Failure trying to read " + propertyFile ) ; 
} 
if ( verbosity == null ) try { 
String verbStr = resources . getString ( "verbosity" ) ; 
int verb = Integer . parseInt ( verbStr . trim ( ) ) ; 
debug . setDebug ( verb ) ; 
verbosity = new Integer ( verb ) ; 
} 
catch ( Exception e ) { 
} 
} 
} 

public class CatalogManager { 
private String queryCatalogFiles ( ) { 
String catalogList = System . getProperty ( pFiles ) ; 
fromPropertiesFile = false ; 
if ( catalogList == null ) { 
if ( resources == null ) readProperties ( ) ; 
if ( resources != null ) try { 
catalogList = resources . getString ( "catalogs" ) ; 
fromPropertiesFile = true ; 
} 
catch ( MissingResourceException e ) { 
System . err . println ( propertyFile + ": catalogs not found." ) ; 
catalogList = null ; 
} 
} 
if ( catalogList == null ) catalogList = defaultCatalogFiles ; 
return catalogList ; 
} 
} 

public class CatalogManager { 
public Vector getCatalogFiles ( ) { 
if ( catalogFiles == null ) catalogFiles = queryCatalogFiles ( ) ; 
StringTokenizer files = new StringTokenizer ( catalogFiles , ";" ) ; 
Vector catalogs = new Vector ( ) ; 
while ( files . hasMoreTokens ( ) ) { 
String catalogFile = files . nextToken ( ) ; 
URL absURI = null ; 
if ( fromPropertiesFile && ! relativeCatalogs ( ) ) try { 
absURI = new URL ( propertyFileURI , catalogFile ) ; 
catalogFile = absURI . toString ( ) ; 
} 
catch ( MalformedURLException mue ) { 
absURI = null ; 
} 
catalogs . add ( catalogFile ) ; 
} 
return catalogs ; 
} 
} 

public class CatalogManager { 
private boolean queryPreferPublic ( ) { 
String prefer = System . getProperty ( pPrefer ) ; 
if ( prefer == null ) { 
if ( resources == null ) readProperties ( ) ; 
if ( resources == null ) return defaultPreferPublic ; 
try { 
prefer = resources . getString ( "prefer" ) ; 
} 
catch ( MissingResourceException e ) { 
return defaultPreferPublic ; 
} 
} 
if ( prefer == null ) return defaultPreferPublic ; 
return ( prefer . equalsIgnoreCase ( "public" ) ) ; 
} 
} 

public class CatalogManager { 
private boolean queryUseStaticCatalog ( ) { 
String staticCatalog = System . getProperty ( pStatic ) ; 
if ( useStaticCatalog == null ) { 
if ( resources == null ) readProperties ( ) ; 
if ( resources == null ) return defaultUseStaticCatalog ; 
try { 
staticCatalog = resources . getString ( "static-catalog" ) ; 
} 
catch ( MissingResourceException e ) { 
return defaultUseStaticCatalog ; 
} 
} 
if ( staticCatalog == null ) return defaultUseStaticCatalog ; 
return ( staticCatalog . equalsIgnoreCase ( "true" ) || staticCatalog . equalsIgnoreCase ( "yes" ) || staticCatalog . equalsIgnoreCase ( "1" ) ) ; 
} 
} 

public class BootstrapResolver { 
public InputSource resolveEntity ( String publicId , String systemId ) { 
String resolved = null ; 
if ( systemId != null && systemMap . containsKey ( systemId ) ) resolved = ( String ) systemMap . get ( systemId ) ; 
else if ( publicId != null && publicMap . containsKey ( publicId ) ) resolved = ( String ) publicMap . get ( publicId ) ; 
if ( resolved != null ) try { 
InputSource iSource = new InputSource ( resolved ) ; 
iSource . setPublicId ( publicId ) ; 
URL url = new URL ( resolved ) ; 
InputStream iStream = url . openStream ( ) ; 
iSource . setByteStream ( iStream ) ; 
return iSource ; 
} 
catch ( Exception e ) { 
return null ; 
} 
return null ; 
} 
} 

public class BootstrapResolver { 
public Source resolve ( String href , String base ) throws TransformerException { 
String uri = href ; 
int hashPos = href . indexOf ( "#" ) ; 
if ( hashPos >= 0 ) uri = href . substring ( 0 , hashPos ) ; 
String result = null ; 
if ( href != null && uriMap . containsKey ( href ) ) result = ( String ) uriMap . get ( href ) ; 
if ( result == null ) try { 
URL url = null ; 
if ( base == null ) { 
url = new URL ( uri ) ; 
result = url . toString ( ) ; 
} 
else { 
URL baseURL = new URL ( base ) ; 
url = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; 
result = url . toString ( ) ; 
} 
} 
catch ( java . net . MalformedURLException mue ) { 
String absBase = makeAbsolute ( base ) ; 
if ( ! absBase . equals ( base ) ) return resolve ( href , absBase ) ; 
else throw new TransformerException ( "Malformed URL " + href + "(base " + base + ")" , mue ) ; 
} 
SAXSource source = new SAXSource ( ) ; 
source . setInputSource ( new InputSource ( result ) ) ; 
return source ; 
} 
} 

public class BootstrapResolver { 
private String makeAbsolute ( String uri ) { 
if ( uri == null ) uri = "" ; 
try { 
URL url = new URL ( uri ) ; 
return url . toString ( ) ; 
} 
catch ( MalformedURLException mue ) { 
String dir = System . getProperty ( "user.dir" ) ; 
String file = "" ; 
if ( dir . endsWith ( "/" ) ) file = "file://" + dir + uri ; 
else file = "file://" + dir + "/" + uri ; 
try { 
URL fileURL = new URL ( file ) ; 
return fileURL . toString ( ) ; 
} 
catch ( MalformedURLException mue2 ) { 
return uri ; 
} 
} 
} 
} 

public class MethodBoundPropertyListener { 
protected void invokeSetter ( String value ) { 
try { 
Class < ? > type = descriptor . getPropertyType ( ) ; 
PropertyEditor editor = PropertyEditors . findEditor ( type ) ; 
editor . setAsText ( value ) ; 
Object coerced = editor . getValue ( ) ; 
setter . invoke ( instance , new Object [ ] { 
coerced } 
) ; 
} 
catch ( InvocationTargetException e ) { 
Throwable target = e . getTargetException ( ) ; 
if ( target instanceof PropertyException ) throw ( PropertyException ) target ; 
else throw new PropertyException ( target ) ; 
} 
catch ( Exception e ) { 
throw new PropertyException ( e ) ; 
} 
} 
} 

public class Namespaces { 
public static String getLocalName ( Element element ) { 
String name = element . getTagName ( ) ; 
if ( name . indexOf ( ':' ) > 0 ) name = name . substring ( name . indexOf ( ':' ) + 1 ) ; 
return name ; 
} 
} 

public class Namespaces { 
public static String getNamespaceURI ( Node node , String prefix ) { 
if ( node == null || node . getNodeType ( ) != Node . ELEMENT_NODE ) return null ; 
if ( prefix . equals ( "" ) ) if ( ( ( Element ) node ) . hasAttribute ( "xmlns" ) ) return ( ( Element ) node ) . getAttribute ( "xmlns" ) ; 
else { 
String nsattr = "xmlns:" + prefix ; 
if ( ( ( Element ) node ) . hasAttribute ( nsattr ) ) return ( ( Element ) node ) . getAttribute ( nsattr ) ; 
} 
return getNamespaceURI ( node . getParentNode ( ) , prefix ) ; 
} 
} 

public class FilePropertyReader { 
public Map readProperties ( ) throws PropertyException , IOException { 
Properties props = new Properties ( ) ; 
for ( int i = 0 ; 
i < filenames . length ; 
i ++ ) loadProperties ( props , filenames [ i ] ) ; 
return props ; 
} 
} 

public class JarUtils { 
private static void jar ( File src , String prefix , JarInfo info ) throws IOException { 
JarOutputStream jout = info . out ; 
if ( src . isDirectory ( ) ) { 
prefix = prefix + src . getName ( ) + "/" ; 
ZipEntry entry = new ZipEntry ( prefix ) ; 
entry . setTime ( src . lastModified ( ) ) ; 
entry . setMethod ( JarOutputStream . STORED ) ; 
entry . setSize ( 0L ) ; 
entry . setCrc ( 0L ) ; 
jout . putNextEntry ( entry ) ; 
jout . closeEntry ( ) ; 
File [ ] files = src . listFiles ( info . filter ) ; 
for ( int i = 0 ; 
i < files . length ; 
i ++ ) jar ( files [ i ] , prefix , info ) ; 
} 
else if ( src . isFile ( ) ) { 
byte [ ] buffer = info . buffer ; 
ZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; 
entry . setTime ( src . lastModified ( ) ) ; 
jout . putNextEntry ( entry ) ; 
FileInputStream in = new FileInputStream ( src ) ; 
int len ; 
while ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) jout . write ( buffer , 0 , len ) ; 
in . close ( ) ; 
jout . closeEntry ( ) ; 
} 
} 
} 

public class CompoundIterator { 
public boolean hasNext ( ) { 
for ( ; 
index < iters . length ; 
index ++ ) if ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) return true ; 
return false ; 
} 
} 

public class TinyMachine { 
public void fireEvent ( Object event ) { 
if ( event == null ) throw new IllegalArgumentException ( "Event must not be null." ) ; 
mTaskQueue . offer ( Task . obtainTask ( Task . CODE_FIRE_EVENT , event , - 1 ) ) ; 
if ( ! mQueueProcessed ) processTaskQueue ( ) ; 
} 
} 

public class StructsBatchCompiler { 
private void internalInstallJvmTypeProvider ( XtextResourceSet resourceSet , File tmpClassDirectory , boolean skipIndexLookup ) { 
Iterable < String > classPathEntries = concat ( getClassPathEntries ( ) , getSourcePathDirectories ( ) , asList ( tmpClassDirectory . toString ( ) ) ) ; 
classPathEntries = filter ( classPathEntries , new Predicate < String > ( ) { 
public boolean apply ( String input ) { 
return ! Strings . isEmpty ( input . trim ( ) ) ; 
} 
} 
) ; 
Function < String , URL > toUrl = new Function < String , URL > ( ) { 
public URL apply ( String from ) { 
try { 
return new File ( from ) . toURI ( ) . toURL ( ) ; 
} 
catch ( MalformedURLException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 
; 
Iterable < URL > classPathUrls = Iterables . transform ( classPathEntries , toUrl ) ; 
log . debug ( "classpath used for Struct compilation : " + classPathUrls ) ; 
ClassLoader parentClassLoader ; 
if ( useCurrentClassLoaderAsParent ) parentClassLoader = currentClassLoader ; 
else if ( isEmpty ( bootClassPath ) ) parentClassLoader = ClassLoader . getSystemClassLoader ( ) . getParent ( ) ; 
else { 
Iterable < URL > bootClassPathUrls = Iterables . transform ( getBootClassPathEntries ( ) , toUrl ) ; 
parentClassLoader = new BootClassLoader ( toArray ( bootClassPathUrls , URL . class ) ) ; 
} 
ClassLoader urlClassLoader = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , parentClassLoader ) ; 
new ClasspathTypeProvider ( urlClassLoader , resourceSet , skipIndexLookup ? null : indexedJvmTypeAccess ) ; 
resourceSet . setClasspathURIContext ( urlClassLoader ) ; 
URLClassLoader urlClassLoaderForAnnotationProcessing = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , currentClassLoader ) ; 
resourceSet . eAdapters ( ) . add ( new ProcessorClassloaderAdapter ( urlClassLoaderForAnnotationProcessing ) ) ; 
} 
} 

public class StructsBatchCompiler { 
protected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { 
if ( ! parentFolder . exists ( ) ) return true ; 
if ( filter == null ) filter = ACCEPT_ALL_FILTER ; 
log . debug ( "Cleaning folder " + parentFolder . toString ( ) ) ; 
final File [ ] contents = parentFolder . listFiles ( filter ) ; 
for ( int j = 0 ; 
j < contents . length ; 
j ++ ) { 
final File file = contents [ j ] ; 
if ( file . isDirectory ( ) ) if ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; 
else if ( ! file . delete ( ) ) { 
log . warn ( "Couldn't delete " + file . getAbsolutePath ( ) ) ; 
if ( ! continueOnError ) return false ; 
} 
} 
if ( deleteParentFolder ) if ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { 
log . warn ( "Couldn't delete " + parentFolder . getAbsolutePath ( ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class Dispatcher { 
public void dispatchOnFxThread ( Action action ) { 
if ( Platform . isFxApplicationThread ( ) ) actionStream . push ( action ) ; 
else Platform . runLater ( ( ) -> actionStream . push ( action ) ) ; 
} 
} 

public class Effect { 
public static void main ( String [ ] args ) throws Exception { 
int n = 1 ; 
if ( args . length < 1 ) { 
usage ( ) ; 
return ; 
} 
Properties analyzers = new Properties ( ) ; 
analyzers . load ( new FileInputStream ( new File ( "analyzer.properties" ) ) ) ; 
String mode = System . getProperty ( "mode" , "complex" ) ; 
String a = System . getProperty ( "analyzer" , "mmseg4j" ) ; 
Analyzer analyzer = null ; 
String an = ( String ) analyzers . get ( a ) ; 
if ( an != null ) { 
analyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; 
mode = a ; 
} 
else { 
usage ( ) ; 
return ; 
} 
if ( args . length > 1 ) try { 
n = Integer . parseInt ( args [ 1 ] ) ; 
} 
catch ( NumberFormatException e ) { 
} 
File path = new File ( args [ 0 ] ) ; 
System . out . println ( "analyzer=" + analyzer . getClass ( ) . getName ( ) ) ; 
Effect ef = new Effect ( path , analyzer ) ; 
ef . run ( mode , n ) ; 
} 
} 

public class Performance { 
public static void main ( String [ ] args ) throws IOException { 
if ( args . length < 1 ) { 
System . out . println ( "Usage:" ) ; 
System . out . println ( "\t-Dmode=simple, defalut is complex" ) ; 
System . out . println ( "\tPerformance <txt path> - is a directory that contain *.txt" ) ; 
return ; 
} 
String mode = System . getProperty ( "mode" , "complex" ) ; 
Seg seg = null ; 
Dictionary dic = Dictionary . getInstance ( ) ; 
if ( "simple" . equals ( mode ) ) seg = new SimpleSeg ( dic ) ; 
else seg = new ComplexSeg ( dic ) ; 
File path = new File ( args [ 0 ] ) ; 
File [ ] txts = path . listFiles ( new FilenameFilter ( ) { 
public boolean accept ( File dir , String name ) { 
return name . endsWith ( ".txt" ) ; 
} 
} 
) ; 
long time = 0 ; 
for ( File txt : txts ) { 
MMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; 
Word word = null ; 
OutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + "." + mode + ".word" ) ) ) ; 
BufferedWriter bw = new BufferedWriter ( osw ) ; 
long start = System . currentTimeMillis ( ) ; 
while ( ( word = mmSeg . next ( ) ) != null ) bw . append ( new String ( word . getString ( ) ) ) . append ( "\r\n" ) ; 
time += System . currentTimeMillis ( ) - start ; 
bw . close ( ) ; 
} 
System . out . println ( "use " + time + "ms" ) ; 
} 
} 

public class Chunk { 
public int getSumDegree ( ) { 
if ( sumDegree < 0 ) { 
int sum = 0 ; 
for ( Word word : words ) { 
if ( word != null && word . getDegree ( ) > - 1 ) sum += word . getDegree ( ) ; 
} 
sumDegree = sum ; 
} 
return sumDegree ; 
} 
} 

public class JdbcStemmerOverrideFilterFactory { 
private static Map < String , String > superclassArgs ( Map < String , String > args ) { 
Map < String , String > result = new HashMap < > ( ) ; 
if ( ! result . containsKey ( "dictionary" ) ) result . put ( "dictionary" , JdbcResourceLoader . DATABASE ) ; 
for ( String arg : ImmutableList . of ( "dictionary" , "ignoreCase" ) ) { 
String value = args . get ( arg ) ; 
if ( value != null ) result . put ( arg , value ) ; 
} 
return result ; 
} 
} 

public class SimpleJdbcReader { 
protected final void checkDatasource ( ) { 
if ( dataSource != null ) try ( Connection connection = dataSource . getConnection ( ) ) { 
} 
catch ( SQLException e ) { 
dataSource = null ; 
logger . error ( "Failed to connect to database of data source: {}." , e . getMessage ( ) ) ; 
if ( ! ignore ) throw new IllegalArgumentException ( "Failed to connect to the database." , e ) ; 
} 
} 
} 

public class JdbcFixture { 
public String queryInWithSql ( String database , String sql ) { 
JdbcTemplate template = getDatabaseJdbcTemplate ( database ) ; 
if ( sql != null && ! sql . trim ( ) . toUpperCase ( ) . startsWith ( JdbcFixture . SELECT_COMMAND_PREFIX ) ) return Objects . toString ( template . update ( sql ) ) ; 
List < String > results = template . queryForList ( sql , String . class ) ; 
if ( results == null || results . isEmpty ( ) ) return null ; 
return results . get ( 0 ) ; 
} 
} 

public class UBValue { 
public boolean [ ] asBoolArray ( ) { 
boolean [ ] retval ; 
UBArray array = asArray ( ) ; 
switch ( array . getStrongType ( ) ) { 
case Int8 : { 
byte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) retval [ i ] = data [ i ] > 0 ; 
break ; 
} 
case Int16 : { 
short [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) retval [ i ] = data [ i ] > 0 ; 
break ; 
} 
case Int32 : { 
int [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) retval [ i ] = data [ i ] > 0 ; 
break ; 
} 
case Int64 : { 
long [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) retval [ i ] = data [ i ] > 0 ; 
break ; 
} 
case Float32 : { 
float [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) retval [ i ] = data [ i ] > 0 ; 
break ; 
} 
case Float64 : { 
double [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( int i = 0 ; 
i < data . length ; 
i ++ ) retval [ i ] = data [ i ] > 0 ; 
break ; 
} 
default : throw new RuntimeException ( "not an int32[] type" ) ; 
} 
return retval ; 
} 
} 

public class Query { 
public Query < T > byExample ( T obj ) { 
if ( obj != null ) return dao . getTableHelper ( ) . buildFilter ( this , obj ) ; 
return this ; 
} 
} 

public class TableHelper { 
public boolean backup ( SQLiteDatabase db , Context ctx , String suffix ) { 
try { 
new CsvTableWriter ( this ) . dumpToCsv ( ctx , db , suffix ) ; 
} 
catch ( SQLException e ) { 
if ( e . getMessage ( ) . contains ( "no such table" ) ) Log . w ( TAG , "Table " + this . getTableName ( ) + " doesn't exist. This is expected if the table is new in this db version." ) ; 
} 
catch ( FileNotFoundException e ) { 
e . printStackTrace ( ) ; 
return false ; 
} 
return true ; 
} 
} 

public class ContactActivity { 
public void setEmptyText ( CharSequence emptyText ) { 
if ( mListView != null ) { 
View emptyView = mListView . getEmptyView ( ) ; 
if ( emptyText instanceof TextView ) ( ( TextView ) emptyView ) . setText ( emptyText ) ; 
} 
} 
} 

public class StringUtils { 
public static String join ( final List < String > list ) { 
if ( list == null ) return null ; 
else if ( list . size ( ) == 0 ) return "" ; 
else if ( list . size ( ) == 1 ) return list . get ( 0 ) ; 
final StringBuilder builder = new StringBuilder ( ) ; 
for ( String item : list ) { 
if ( builder . length ( ) > 0 ) builder . append ( ", " ) ; 
builder . append ( item ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String join ( final String [ ] list ) { 
if ( list == null ) return null ; 
else if ( list . length == 0 ) return "" ; 
else if ( list . length == 1 ) return list [ 0 ] ; 
final StringBuilder builder = new StringBuilder ( ) ; 
for ( String item : list ) { 
if ( builder . length ( ) > 0 ) builder . append ( ", " ) ; 
builder . append ( item ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class EntityProcessor { 
private void inspectId ( ) { 
if ( entityModel . getIdField ( ) == null ) { 
List < FieldModel > fields = entityModel . getFields ( ) ; 
for ( FieldModel f : fields ) { 
if ( EntityModel . DEFAULT_ID_FIELD . equals ( f . getFieldName ( ) ) ) entityModel . setIdField ( f ) ; 
} 
} 
FieldModel idField = entityModel . getIdField ( ) ; 
if ( idField != null && "long" . equals ( idField . getJavaType ( ) ) ) return ; 
else abort ( "Entity must contain a field named id or annotated with @Id of type long" ) ; 
} 
} 

public class QueryBuilder { 
public Query createQuery ( final EntityManager manager ) { 
if ( manager == null ) throw new NullPointerException ( "Entity Manager required" ) ; 
final Query query = manager . createQuery ( render ( ) ) ; 
for ( Parameter < ? > parameter : parameters ) { 
parameter . apply ( query ) ; 
} 
return query ; 
} 
} 

public class QueryBuilder { 
public < T > TypedQuery < T > createQuery ( final EntityManager manager , Class < T > type ) { 
if ( manager == null ) throw new NullPointerException ( "Entity Manager required" ) ; 
TypedQuery < T > result = manager . createQuery ( render ( ) , type ) ; 
for ( Parameter < ? > parameter : parameters ) { 
parameter . apply ( result ) ; 
} 
return result ; 
} 
} 

public class SQLiteDao { 
public int delete ( Long id ) { 
if ( id != null ) return getWritableDb ( ) . delete ( th . getTableName ( ) , th . getIdCol ( ) + "=?" , new String [ ] { 
id . toString ( ) } 
) ; 
return 0 ; 
} 
} 

public class SQLiteDao { 
public long save ( T obj ) { 
if ( th . getId ( obj ) == 0 ) return insert ( obj ) ; 
long updated = update ( obj ) ; 
if ( updated == 1 ) return 0 ; 
return - 1 ; 
} 
} 

public class IntentionStacks { 
Stack255 getEmptyIntentionStack ( ) { 
if ( ! stacks . isEmpty ( ) && getActiveStack ( ) . isEmpty ( ) ) return getActiveStack ( ) ; 
Stack255 stack = new Stack255 ( ( byte ) 8 , ( byte ) 2 ) ; 
stacks . push ( stack ) ; 
return stack ; 
} 
} 

public class PlanBindings { 
public void add ( Plan plan , Set < Belief > planBindings ) { 
if ( plan == null ) return ; 
if ( this . bindings . containsKey ( plan ) ) { 
Set < Belief > oldBindings = this . bindings . remove ( plan ) ; 
if ( oldBindings == null || oldBindings . isEmpty ( ) ) cachedsize -- ; 
else cachedsize -= oldBindings . size ( ) ; 
} 
this . bindings . put ( plan , planBindings ) ; 
if ( planBindings == null || planBindings . isEmpty ( ) ) cachedsize ++ ; 
else cachedsize += planBindings . size ( ) ; 
} 
} 

public class PlanBindings { 
private final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { 
if ( agent == null || planInstance == null ) return ; 
Belief belief = getResultAtIndex ( results , choice ) ; 
if ( belief == null ) return ; 
Object [ ] tuple = belief . getTuple ( ) ; 
if ( tuple == null ) return ; 
int index = 0 ; 
HashMap < String , Object > vars = new HashMap < String , Object > ( ) ; 
for ( Object o : belief . getTuple ( ) ) { 
try { 
String fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; 
vars . put ( fieldname , o ) ; 
} 
catch ( BeliefBaseException e ) { 
Log . error ( "Agent " + agent . getId ( ) + " could not retrive belief set field: " + e . getMessage ( ) ) ; 
} 
index ++ ; 
} 
planInstance . setPlanVariables ( vars ) ; 
} 
} 

public class GoalPlanType { 
public byte [ ] getParents ( ) { 
if ( parents == null ) return null ; 
byte [ ] arr = new byte [ parents . length ] ; 
System . arraycopy ( parents , 0 , arr , 0 , arr . length ) ; 
return arr ; 
} 
} 

public class GoalPlanType { 
public byte [ ] getChildren ( ) { 
if ( children == null ) return null ; 
byte [ ] arr = new byte [ children . length ] ; 
System . arraycopy ( children , 0 , arr , 0 , arr . length ) ; 
return arr ; 
} 
} 

public class GoalPlanType { 
public static byte [ ] grow ( byte [ ] bytes , int increment ) { 
if ( bytes == null ) return new byte [ 1 ] ; 
byte [ ] temp = new byte [ bytes . length + increment ] ; 
System . arraycopy ( bytes , 0 , temp , 0 , bytes . length ) ; 
return temp ; 
} 
} 

public class Plan { 
public void step ( ) { 
if ( body == null || body . length == 0 || index < 0 || index >= body . length ) return ; 
body [ index ++ ] . step ( ) ; 
} 
} 

public class Program { 
static void initIntentionSelectionThreads ( Config config ) { 
int ncores = config . getNumThreads ( ) ; 
Main . intentionSelectors = new IntentionSelector [ ncores ] ; 
for ( int i = 0 ; 
i < Main . npools ; 
i ++ ) Main . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; 
} 
} 

public class Program { 
static void shutdownIntentionSelectionThreads ( ) { 
for ( int i = 0 ; 
i < Main . npools ; 
i ++ ) Main . intentionSelectors [ i ] . shutdown ( ) ; 
} 
} 

public class Program { 
public static void registerExtension ( JillExtension extension ) { 
if ( extension != null ) { 
GlobalState . eventHandlers . add ( extension ) ; 
Main . logger . info ( "Registered Jill extension: " + extension ) ; 
} 
else Main . logger . warn ( "Cannot register null extension; will ignore." ) ; 
} 
} 

public class ProgramLoader { 
public static boolean loadAgent ( String className , int num , AObjectCatalog agents ) { 
Class < ? > aclass = loadClass ( className , Agent . class ) ; 
if ( aclass == null ) return false ; 
AgentType atype = new AgentType ( className ) ; 
atype . setAgentClass ( aclass ) ; 
GlobalState . agentTypes . push ( atype ) ; 
String [ ] goals = getGoalsFromAgentInfoAnnotation ( aclass ) ; 
if ( goals . length == 0 ) return false ; 
loadGoalPlanNodes ( atype , goals ) ; 
completeGoalPlanHierarchy ( ) ; 
createAgentsInCatalog ( agents , atype , aclass , num ) ; 
return true ; 
} 
} 

public class ProgramLoader { 
private static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { 
for ( int j = 0 ; 
j < plans . length ; 
j ++ ) { 
Class < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; 
if ( pclass == null ) return false ; 
logger . info ( "Found Plan " + pclass . getName ( ) + " that handles Goal " + gtype . getName ( ) ) ; 
PlanType ptype = new PlanType ( pclass . getName ( ) ) ; 
ptype . setPlanClass ( pclass ) ; 
GlobalState . planTypes . push ( ptype ) ; 
ptype . addParent ( ( byte ) gtype . getId ( ) ) ; 
gtype . addChild ( ( byte ) ptype . getId ( ) ) ; 
} 
return true ; 
} 
} 

public class AObject { 
public static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { 
if ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) return false ; 
for ( int i = 0 ; 
i < obj1 . name . length ; 
i ++ ) if ( obj1 . name [ i ] != obj2 . name [ i ] ) return false ; 
return true ; 
} 
} 

public class ArgumentsLoader { 
public static void parse ( String [ ] args ) { 
for ( int i = 0 ; 
args != null && i < args . length ; 
i ++ ) { 
if ( "--help" . equals ( args [ i ] ) ) abort ( null ) ; 
if ( i + 1 < args . length ) parseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; 
} 
if ( config == null ) abort ( "Configuration file or string was not given" ) ; 
else if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) abort ( "Configuration is missing agents specification" ) ; 
} 
} 

public class AObjectCatalog { 
public AObject get ( int index ) { 
if ( index >= 0 && index < objects . length ) return objects [ index ] ; 
return null ; 
} 
} 

public class AObjectCatalog { 
public AObject find ( String name ) { 
for ( int i = 0 ; 
i < nextid ; 
i ++ ) if ( objects [ i ] . getName ( ) . equals ( name ) ) return objects [ i ] ; 
return null ; 
} 
} 

public class AObjectCatalog { 
public void push ( AObject obj ) { 
if ( obj == null || obj . getId ( ) != GlobalConstant . NULLID ) return ; 
if ( nextid == objects . length ) grow ( ) ; 
obj . setId ( nextid ) ; 
objects [ nextid ++ ] = obj ; 
} 
} 

public class Stack255 { 
public Object get ( int idx ) { 
int index = idx & 0xff ; 
if ( isEmpty ( ) ) return null ; 
else if ( index < 0 || index >= size ) return null ; 
return objects [ index ] ; 
} 
} 

public class Stack255 { 
public boolean push ( Object obj ) { 
if ( isFull ( ) ) return false ; 
if ( size == objects . length ) grow ( ) ; 
objects [ size ++ ] = obj ; 
return true ; 
} 
} 

public class Stack255 { 
public Object pop ( ) { 
if ( isEmpty ( ) ) return null ; 
size -- ; 
Object obj = objects [ size ] ; 
objects [ size ] = null ; 
return obj ; 
} 
} 

public class ABeliefStore { 
public static String getType ( Object obj ) { 
if ( obj == null ) return null ; 
String type = null ; 
if ( obj instanceof String || obj instanceof Integer || obj instanceof Double || obj instanceof Boolean ) type = obj . getClass ( ) . getName ( ) ; 
return type ; 
} 
} 

public class ABeliefStore { 
private static boolean match ( Belief belief , AQuery query ) { 
assert ( belief != null ) ; 
assert ( query != null ) ; 
if ( belief . getBeliefset ( ) != query . getBeliefset ( ) ) return false ; 
switch ( query . getOp ( ) ) { 
case EQ : Object lhs = belief . getTuple ( ) [ query . getField ( ) ] ; 
Object rhs = query . getValue ( ) ; 
return "*" . equals ( rhs ) || lhs . equals ( rhs ) ; 
case GT : case LT : default : break ; 
} 
return false ; 
} 
} 

public class ABeliefStore { 
public static void main ( String [ ] args ) throws BeliefBaseException { 
BeliefBase bb = new ABeliefStore ( 100 , 4 ) ; 
bb . eval ( 0 , "neighbour.age < 31" ) ; 
Console console = System . console ( ) ; 
if ( console == null ) { 
System . err . println ( "No console." ) ; 
System . exit ( 1 ) ; 
} 
while ( true ) { 
Pattern pattern = Pattern . compile ( console . readLine ( "%nEnter your regex: " ) ) ; 
Matcher matcher = pattern . matcher ( console . readLine ( "Enter input string to search: " ) ) ; 
boolean found = false ; 
while ( matcher . find ( ) ) { 
console . format ( "I found the text" + " \"%s\" starting at " + "index %d and ending at index %d.%n" , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; 
found = true ; 
} 
if ( ! found ) console . format ( "No match found.%n" ) ; 
} 
} 
} 

public class AString { 
public static byte [ ] toBytes ( String str ) { 
if ( str == null ) return new byte [ 0 ] ; 
byte [ ] val = null ; 
try { 
val = str . getBytes ( CHARSET ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
} 
return val ; 
} 
} 

public class BeliefSet { 
public BeliefSetField getFieldByName ( String name ) { 
BeliefSetField field = null ; 
for ( int i = 0 ; 
i < fields . length ; 
i ++ ) if ( name . equals ( fields [ i ] . getName ( ) ) ) { 
field = fields [ i ] ; 
break ; 
} 
return field ; 
} 
} 

public class IntentionSelector { 
public void run ( ) { 
Set < Integer > toRemove = new HashSet < Integer > ( ) ; 
do { 
boolean idle = true ; 
removeInactiveAgents ( ) ; 
addActiveAgents ( ) ; 
for ( Integer i : activeAgents ) { 
Agent agent = ( Agent ) GlobalState . agents . get ( i ) ; 
Stack255 agentExecutionStack = ( Stack255 ) ( agent ) . getExecutionStack ( ) ; 
if ( ! isStackValid ( agent , agentExecutionStack ) ) { 
toRemove . add ( i ) ; 
continue ; 
} 
idle = false ; 
Object node = ( Object ) agentExecutionStack . get ( ( byte ) ( agentExecutionStack . size ( ) - 1 ) ) ; 
if ( node instanceof Plan ) managePlan ( i , agentExecutionStack , ( Plan ) node , toRemove ) ; 
else if ( node instanceof Goal ) manageGoal ( i , agent , agentExecutionStack , ( Goal ) node ) ; 
agent . nextActiveStack ( ) ; 
} 
removeFinishedAgents ( toRemove ) ; 
if ( idle ) { 
waitOnExternalMessage ( ) ; 
if ( shutdown ) break ; 
} 
} 
while ( true ) ; 
logger . debug ( "Pool {} is exiting" , poolid ) ; 
} 
} 

public class IntentionSelector { 
private boolean isStackValid ( Agent agent , Stack255 agentExecutionStack ) { 
if ( agentExecutionStack == null ) return false ; 
final int esSize = agentExecutionStack . size ( ) ; 
logger . trace ( "{} execution stack is {}/255 full" , Log . logPrefix ( agent . getId ( ) ) , esSize ) ; 
if ( esSize == 0 ) return false ; 
if ( esSize >= 255 ) { 
logger . error ( "{} execution stack reached size limit of 255. Cannot continue." , Log . logPrefix ( agent . getId ( ) ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class IntentionSelector { 
public void setAgentIdle ( int agentId , boolean idle ) { 
if ( ! idle ) synchronized ( extToAdd ) { 
extToAdd . add ( agentId ) ; 
} 
if ( idle ) synchronized ( extToRemove ) { 
extToRemove . add ( agentId ) ; 
} 
} 
} 

public class Main { 
public static boolean init ( Config config ) { 
if ( config . isDoPauseForUserInput ( ) ) Program . pauseForUserInput ( ) ; 
Log . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; 
logger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; 
int numAgents = 0 ; 
for ( Config . AgentTypeData agentType : config . getAgents ( ) ) { 
numAgents += agentType . getCount ( ) ; 
} 
final int increment = 10000 ; 
GlobalState . reset ( ) ; 
GlobalState . agents = new AObjectCatalog ( "agents" , numAgents , increment ) ; 
GlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; 
long t0 ; 
t0 = System . currentTimeMillis ( ) ; 
for ( Config . AgentTypeData agentType : config . getAgents ( ) ) { 
if ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) return false ; 
} 
long t1 = System . currentTimeMillis ( ) ; 
logger . info ( "Created " + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; 
Program . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; 
if ( config . getProgramOutputFile ( ) != null ) try { 
writer = new PrintStream ( config . getProgramOutputFile ( ) , "UTF-8" ) ; 
} 
catch ( FileNotFoundException | UnsupportedEncodingException e ) { 
logger . error ( "Could not open program outout file " + config . getProgramOutputFile ( ) , e ) ; 
} 
else writer = System . out ; 
Program . initIntentionSelectionThreads ( config ) ; 
return true ; 
} 
} 

public class Main { 
public static void waitUntilIdle ( ) { 
long t0 = System . currentTimeMillis ( ) ; 
synchronized ( poolsIdle ) { 
while ( ! arePoolsIdle ( ) ) try { 
poolsIdle . wait ( ) ; 
} 
catch ( InterruptedException e ) { 
logger . error ( "Failed to wait on termination condition: " + e . getMessage ( ) ) ; 
} 
} 
long t1 = System . currentTimeMillis ( ) ; 
logger . info ( "Finished running " + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; 
} 
} 

public class Main { 
public static void finish ( ) { 
for ( JillExtension extension : GlobalState . eventHandlers ) { 
extension . finish ( ) ; 
} 
Program . shutdownIntentionSelectionThreads ( ) ; 
long t0 = System . currentTimeMillis ( ) ; 
for ( int i = 0 ; 
i < GlobalState . agents . size ( ) ; 
i ++ ) { 
Agent agent = ( Agent ) GlobalState . agents . get ( i ) ; 
agent . finish ( ) ; 
} 
if ( writer != null ) writer . close ( ) ; 
long t1 = System . currentTimeMillis ( ) ; 
logger . info ( "Terminated " + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; 
} 
} 

public class Main { 
public static boolean arePoolsIdle ( ) { 
boolean idle = true ; 
for ( int i = 0 ; 
i < npools ; 
i ++ ) idle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; 
return idle ; 
} 
} 

public class Main { 
public static int poolid ( int agentid ) { 
int poolid = agentid / poolsize ; 
if ( poolid + 1 > npools ) poolid = npools - 1 ; 
return poolid ; 
} 
} 

public class JpaUtils { 
public static Expression < ? > join ( String attribute , From < ? , ? > from ) { 
Expression < ? > path ; 
try { 
String [ ] properties = attribute . split ( "\\." ) ; 
if ( properties . length > 1 ) path = joinRecursively ( properties , findOrCreateJoin ( properties [ 0 ] , from ) , 1 ) . get ( properties [ properties . length - 1 ] ) ; 
else path = from . get ( properties [ 0 ] ) ; 
} 
catch ( IllegalArgumentException e ) { 
throw SeedException . wrap ( e , JpaErrorCode . UNABLE_TO_CREATE_JPA_JOIN_FOR_SPECIFICATION ) . put ( "property" , attribute ) ; 
} 
return path ; 
} 
} 

public class JpaUtils { 
private static Join < ? , ? > joinRecursively ( String [ ] properties , Join < ? , ? > join , int index ) { 
if ( index < properties . length - 1 ) return joinRecursively ( properties , findOrCreateJoin ( properties [ index ] , join ) , index + 1 ) ; 
else return join ; 
} 
} 

public class JpaUtils { 
private static Join < ? , ? > findOrCreateJoin ( String property , From < ? , ? > from ) { 
for ( Join < ? , ? > rootJoin : from . getJoins ( ) ) { 
if ( rootJoin . getAttribute ( ) . getName ( ) . equals ( property ) ) return rootJoin ; 
} 
return from . join ( property ) ; 
} 
} 

public class PartialResponse { 
public boolean isEndReached ( ) { 
if ( to == null || from == null ) return true ; 
if ( length == null ) return false ; 
return to == length - 1 ; 
} 
} 

public class MultipartFormArgumentsReader { 
private static UploadStream getUploadStream ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException { 
FormIterator form = new FormIteratorImpl ( httpRequest ) ; 
if ( ! form . hasNext ( ) ) throw new IllegalArgumentException ( "Empty form." ) ; 
Part part = form . next ( ) ; 
if ( ! ( part instanceof UploadStream ) ) throw new IllegalArgumentException ( "Illegal form. Expected uploaded stream but got field |%s|." , part . getName ( ) ) ; 
return ( UploadStream ) part ; 
} 
} 

public class RestServlet { 
@ Override protected void handleRequest ( RequestContext context ) throws IOException { 
HttpServletRequest httpRequest = context . getRequest ( ) ; 
HttpServletResponse httpResponse = context . getResponse ( ) ; 
ArgumentsReader argumentsReader = null ; 
Object value = null ; 
ManagedMethodSPI method = null ; 
try { 
method = restMethods . get ( key ( httpRequest . getPathInfo ( ) ) ) ; 
if ( method == null ) throw new NoSuchMethodException ( ) ; 
Type [ ] formalParameters = method . getParameterTypes ( ) ; 
argumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; 
Object [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; 
Object instance = container . getInstance ( method . getDeclaringClass ( ) ) ; 
value = method . invoke ( instance , arguments ) ; 
} 
catch ( AuthorizationException e ) { 
sendUnauthorized ( context ) ; 
return ; 
} 
catch ( NoSuchMethodException e ) { 
sendNotFound ( context , e ) ; 
return ; 
} 
catch ( IllegalArgumentException e ) { 
sendBadRequest ( context ) ; 
return ; 
} 
catch ( InvocationException e ) { 
sendError ( context , e ) ; 
return ; 
} 
finally { 
if ( argumentsReader != null ) argumentsReader . clean ( ) ; 
} 
httpResponse . setCharacterEncoding ( "UTF-8" ) ; 
if ( method . isVoid ( ) ) { 
httpResponse . setStatus ( HttpServletResponse . SC_NO_CONTENT ) ; 
return ; 
} 
ContentType contentType = valueWriterFactory . getContentTypeForValue ( value ) ; 
httpResponse . setStatus ( HttpServletResponse . SC_OK ) ; 
httpResponse . setContentType ( contentType . getValue ( ) ) ; 
ValueWriter valueWriter = valueWriterFactory . getValueWriter ( contentType ) ; 
valueWriter . write ( httpResponse , value ) ; 
} 
} 

public class ContentType { 
private static Map < String , String > parseParameters ( String expression ) { 
Map < String , String > parameters = new HashMap < > ( ) ; 
int parametersSeparatorIndex = 0 ; 
for ( ; 
; 
) { 
int valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; 
if ( valueSeparatorIndex == - 1 ) break ; 
String name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; 
++ valueSeparatorIndex ; 
parametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; 
if ( parametersSeparatorIndex == - 1 ) parametersSeparatorIndex = expression . length ( ) ; 
if ( valueSeparatorIndex == parametersSeparatorIndex ) throw new SyntaxException ( "Invalid content type parameters |%s|. Value is empty." , expression ) ; 
if ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) throw new SyntaxException ( "Invalid content type parameters |%s|. Name override |%s|." , expression , name ) ; 
++ parametersSeparatorIndex ; 
} 
if ( parameters . isEmpty ( ) ) throw new SyntaxException ( "Invalid content type parameters |%s|. Missing name/value separator." , expression ) ; 
return parameters ; 
} 
} 

public class AbstractGenerator { 
protected final GeneratedFile getTargetFile ( final String artifactName , final String filename , final String logInfo ) { 
final Folder folder = getGeneratorConfig ( ) . findTargetFolder ( artifactName ) ; 
final File dir = folder . getCanonicalDir ( ) ; 
final File file = new File ( dir , filename ) ; 
if ( ! dir . exists ( ) ) if ( folder . isCreate ( ) ) dir . mkdirs ( ) ; 
else throw new IllegalStateException ( "Directory '" + dir + "' does not exist, but configuration does not allow creation: " + "<folder name=\"" + folder . getName ( ) + "\" create=\"false\" ... />" ) ; 
if ( ! file . getParentFile ( ) . exists ( ) ) file . getParentFile ( ) . mkdirs ( ) ; 
if ( file . exists ( ) && ! folder . overrideAllowed ( file ) ) return new GeneratedFile ( file , logInfo , true ) ; 
return new GeneratedFile ( file , logInfo ) ; 
} 
} 

public class AbstractGenerator { 
protected final void write ( @ NotNull final GeneratedArtifact artifact ) throws GenerateException { 
Contract . requireArgNotNull ( "artifact" , artifact ) ; 
final GeneratedFile genFile = getTargetFile ( artifact . getName ( ) , artifact . getPathAndName ( ) , null ) ; 
if ( genFile . isSkip ( ) ) LOG . debug ( "Omitted already existing file: {} [{}]" , genFile , artifact ) ; 
else { 
LOG . debug ( "Writing file:  {} [{}]" , genFile , artifact ) ; 
try { 
final OutputStream out = new BufferedOutputStream ( new FileOutputStream ( genFile . getTmpFile ( ) ) ) ; 
try { 
out . write ( artifact . getData ( ) ) ; 
} 
finally { 
out . close ( ) ; 
} 
genFile . persist ( ) ; 
} 
catch ( final IOException ex ) { 
throw new GenerateException ( "Error writing artifact '" + artifact + "' to '" + artifact . getPathAndName ( ) + "'!" , ex ) ; 
} 
} 
} 
} 

public class InstanceFieldsInitializationProcessor { 
@ Override public void postProcessInstance ( ManagedClassSPI managedClass , Object instance ) { 
Config config = managedClass . getConfig ( ) ; 
if ( config == null ) return ; 
List < Config > fields = config . findChildren ( "instance-field" ) ; 
if ( ! fields . isEmpty ( ) && ! InstanceType . POJO . equals ( managedClass . getInstanceType ( ) ) ) throw new BugError ( "Cannot assign instance field on non %s type." , InstanceType . POJO ) ; 
for ( Config field : fields ) { 
Classes . setFieldValue ( instance , field . getAttribute ( "name" ) , field . getAttribute ( "value" ) ) ; 
} 
} 
} 

public class ManagedClass { 
private static Constructor < ? > getDeclaredConstructor ( Class < ? > implementationClass ) { 
if ( implementationClass == null ) return null ; 
Constructor < ? > [ ] declaredConstructors = ( Constructor < ? > [ ] ) implementationClass . getDeclaredConstructors ( ) ; 
if ( declaredConstructors . length == 0 ) throw new BugError ( "Invalid implementation class |%s|. Missing constructor." , implementationClass ) ; 
Constructor < ? > constructor = null ; 
for ( Constructor < ? > declaredConstructor : declaredConstructors ) { 
if ( declaredConstructor . isSynthetic ( ) ) continue ; 
if ( declaredConstructor . getParameterTypes ( ) . length == 0 ) continue ; 
if ( declaredConstructor . getAnnotation ( Test . class ) != null ) continue ; 
if ( constructor != null ) throw new BugError ( "Implementation class |%s| has not a single constructor with parameters." , implementationClass ) ; 
constructor = declaredConstructor ; 
} 
if ( constructor == null ) constructor = declaredConstructors [ 0 ] ; 
constructor . setAccessible ( true ) ; 
return constructor ; 
} 
} 

public class FormObject { 
private static Class < ? > type ( Field field ) { 
if ( Types . isKindOf ( field . getType ( ) , List . class ) ) return ( Class < ? > ) ( ( ParameterizedType ) field . getGenericType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; 
return field . getType ( ) ; 
} 
} 

public class DependencyProcessor { 
@ SuppressWarnings ( "unchecked" ) protected static Object getDependencyValue ( ManagedClassSPI hostManagedClass , Class < ? > type ) { 
Stack < Class < ? > > stackTrace = dependenciesStack . get ( ) ; 
if ( stackTrace == null ) { 
stackTrace = new Stack < > ( ) ; 
dependenciesStack . set ( stackTrace ) ; 
} 
ContainerSPI container = hostManagedClass . getContainer ( ) ; 
if ( stackTrace . contains ( type ) ) try { 
stackTrace . add ( type ) ; 
StringBuilder builder = new StringBuilder ( ) ; 
builder . append ( "Circular dependency. Dependencies trace follows:\r\n" ) ; 
for ( Class < ? > stackTraceClass : stackTrace ) { 
builder . append ( "\t- " ) ; 
builder . append ( stackTraceClass . getName ( ) ) ; 
builder . append ( "\r\n" ) ; 
} 
log . error ( builder . toString ( ) ) ; 
throw new BugError ( "Circular dependency for |%s|." , type . getName ( ) ) ; 
} 
finally { 
dependenciesStack . remove ( ) ; 
} 
stackTrace . push ( type ) ; 
try { 
ManagedClassSPI dependencyManagedClass = container . getManagedClass ( type ) ; 
if ( isProxyRequired ( hostManagedClass , dependencyManagedClass ) ) { 
ScopeProxyHandler < ? > handler = new ScopeProxyHandler < > ( container , type ) ; 
return Proxy . newProxyInstance ( dependencyManagedClass . getImplementationClass ( ) . getClassLoader ( ) , dependencyManagedClass . getInterfaceClasses ( ) , handler ) ; 
} 
Object value = container . getOptionalInstance ( ( Class < ? super Object > ) type ) ; 
if ( value != null ) return value ; 
if ( Types . isKindOf ( type , AppFactory . class ) ) return container ; 
if ( Classes . isInstantiable ( type ) ) return Classes . newInstance ( type ) ; 
throw new BugError ( "Dependency |%s| not resolved for |%s|." , type . getName ( ) , hostManagedClass ) ; 
} 
finally { 
stackTrace . pop ( ) ; 
} 
} 
} 

public class GeneratedFile { 
public final void persist ( ) { 
if ( persisted ) return ; 
try { 
if ( FileUtils . contentEquals ( tmpFile , file ) ) { 
LOG . debug ( "Omitted: {} {}" , getPath ( ) , logInfo ) ; 
if ( ! tmpFile . delete ( ) ) tmpFile . deleteOnExit ( ) ; 
} 
else { 
if ( file . exists ( ) && ! file . delete ( ) ) throw new IOException ( "Wasn't able to delete file " + file ) ; 
if ( ! tmpFile . renameTo ( file ) ) throw new IOException ( "Wasn't able to rename temporary file " + tmpFile + " to " + file ) ; 
LOG . info ( "Generated: {} {}" , getPath ( ) , logInfo ) ; 
} 
persisted = true ; 
} 
catch ( final IOException ex ) { 
throw new RuntimeException ( "Error comparing content: tmp=" + tmpFile + ", target=" + file + logInfo , ex ) ; 
} 
} 
} 

public class AbstractEndpoint { 
public final void setDefaultLink ( String rel , String ... hrefs ) { 
if ( hrefs == null || hrefs . length == 0 ) defaultLinks . remove ( rel ) ; 
else defaultLinks . put ( rel , stream ( hrefs ) . map ( uri :: resolve ) . collect ( toSet ( ) ) ) ; 
} 
} 

public class AbstractEndpoint { 
public final void setDefaultLinkTemplate ( String rel , String href ) { 
if ( href == null ) defaultLinkTemplates . remove ( rel ) ; 
else defaultLinkTemplates . put ( rel , href ) ; 
} 
} 

public class AbstractEndpoint { 
@ SuppressWarnings ( "LocalVariableHidesMemberVariable" ) private void handleLinks ( HttpResponse response ) { 
Map < String , Map < URI , String > > links = new HashMap < > ( ) ; 
Map < String , String > linkTemplates = new HashMap < > ( ) ; 
handleHeaderLinks ( response , links , linkTemplates ) ; 
HttpEntity entity = response . getEntity ( ) ; 
if ( entity != null ) { 
Header contentType = entity . getContentType ( ) ; 
if ( ( contentType != null ) && contentType . getValue ( ) . startsWith ( "application/json" ) ) try { 
handleBodyLinks ( serializer . readTree ( entity . getContent ( ) ) , links , linkTemplates ) ; 
} 
catch ( IOException ex ) { 
throw new RuntimeException ( ) ; 
} 
} 
this . links = unmodifiableMap ( links ) ; 
this . linkTemplates = unmodifiableMap ( linkTemplates ) ; 
} 
} 

public class AbstractEndpoint { 
protected void handleHeaderLinks ( HttpResponse response , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { 
getLinkHeaders ( response ) . forEach ( header -> { 
if ( header . getRel ( ) == null ) return ; 
if ( header . isTemplated ( ) ) linkTemplates . put ( header . getRel ( ) , header . getHref ( ) ) ; 
else getOrAdd ( links , header . getRel ( ) ) . put ( uri . resolve ( header . getHref ( ) ) , header . getTitle ( ) ) ; 
} 
) ; 
} 
} 

public class AbstractEndpoint { 
protected void handleBodyLinks ( JsonNode jsonBody , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { 
if ( jsonBody . getNodeType ( ) != JsonNodeType . OBJECT ) return ; 
JsonNode linksNode = jsonBody . get ( "_links" ) ; 
if ( linksNode == null ) linksNode = jsonBody . get ( "links" ) ; 
if ( linksNode == null ) return ; 
linksNode . fields ( ) . forEachRemaining ( x -> { 
String rel = x . getKey ( ) ; 
Map < URI , String > linksForRel = getOrAdd ( links , rel ) ; 
switch ( x . getValue ( ) . getNodeType ( ) ) { 
case ARRAY : x . getValue ( ) . forEach ( subobj -> { 
if ( subobj . getNodeType ( ) == JsonNodeType . OBJECT ) parseLinkObject ( rel , ( ObjectNode ) subobj , linksForRel , linkTemplates ) ; 
} 
) ; 
break ; 
case OBJECT : parseLinkObject ( rel , ( ObjectNode ) x . getValue ( ) , linksForRel , linkTemplates ) ; 
break ; 
} 
} 
) ; 
} 
} 

public class AbstractEndpoint { 
private void parseLinkObject ( String rel , ObjectNode obj , Map < URI , String > linksForRel , Map < String , String > linkTemplates ) { 
JsonNode href = obj . findValue ( "href" ) ; 
if ( href == null ) return ; 
JsonNode templated = obj . findValue ( "templated" ) ; 
if ( templated != null && templated . isBoolean ( ) && templated . asBoolean ( ) ) linkTemplates . put ( rel , href . asText ( ) ) ; 
else { 
JsonNode title = obj . findValue ( "title" ) ; 
linksForRel . put ( uri . resolve ( href . asText ( ) ) , ( title != null && title . getNodeType ( ) == JsonNodeType . STRING ) ? title . asText ( ) : null ) ; 
} 
} 
} 

public class AbstractEndpoint { 
private static Map < URI , String > getOrAdd ( Map < String , Map < URI , String > > map , String key ) { 
Map < URI , String > value = map . get ( key ) ; 
if ( value == null ) map . put ( key , value = new HashMap < > ( ) ) ; 
return value ; 
} 
} 

public class AbstractEndpoint { 
protected Optional < Boolean > isMethodAllowed ( String method ) { 
if ( allowedMethods . isEmpty ( ) ) return Optional . empty ( ) ; 
return Optional . of ( allowedMethods . contains ( method ) ) ; 
} 
} 

public class Container { 
protected void registerInstanceFactory ( InstanceType instanceType , InstanceFactory instanceFactory ) { 
log . debug ( "Register instance factory |%s| to |%s|." , instanceFactory . getClass ( ) , instanceType ) ; 
if ( instanceFactories . put ( instanceType , instanceFactory ) != null ) throw new BugError ( "Attempt to override instance type |%s|." , instanceType ) ; 
} 
} 

public class Container { 
protected void registerInstanceProcessor ( InstanceProcessor instanceProcessor ) { 
for ( InstanceProcessor existingInstanceProcessoor : instanceProcessors ) { 
if ( existingInstanceProcessoor . getClass ( ) . equals ( instanceProcessor . getClass ( ) ) ) throw new BugError ( "Attempt to override instance processor |%s|." , instanceProcessor . getClass ( ) ) ; 
} 
log . debug ( "Register instance processor |%s|." , instanceProcessor . getClass ( ) ) ; 
instanceProcessors . add ( instanceProcessor ) ; 
} 
} 

public class Container { 
protected void registerClassProcessor ( ClassProcessor classProcessor ) { 
for ( ClassProcessor existingClassProcessoor : classProcessors ) { 
if ( existingClassProcessoor . getClass ( ) . equals ( classProcessor . getClass ( ) ) ) throw new BugError ( "Attempt to override class processor |%s|." , classProcessor . getClass ( ) ) ; 
} 
log . debug ( "Register class processor |%s|." , classProcessor . getClass ( ) ) ; 
classProcessors . add ( classProcessor ) ; 
} 
} 

public class Container { 
@ Override public < T > T getInstance ( Class < ? super T > interfaceClass , Object ... args ) { 
Params . notNull ( interfaceClass , "Interface class" ) ; 
ManagedClassSPI managedClass = classesPool . get ( interfaceClass ) ; 
if ( managedClass == null ) throw new BugError ( "No managed class associated with interface class |%s|." , interfaceClass ) ; 
InstanceKey instanceKey = new InstanceKey ( managedClass . getKey ( ) ) ; 
return getInstance ( managedClass , instanceKey , args ) ; 
} 
} 

public class ParameterizedTemplateModel { 
public final void addArgument ( @ NotNull final Argument argument ) { 
if ( arguments == null ) arguments = new ArrayList < Argument > ( ) ; 
arguments . add ( argument ) ; 
} 
} 

public class ParameterizedTemplateModel { 
public final void init ( final SrcGen4JContext context , final Map < String , String > vars ) { 
if ( template != null ) template = Utils4J . replaceVars ( template , vars ) ; 
if ( arguments != null ) for ( final Argument argument : arguments ) { 
argument . init ( vars ) ; 
} 
if ( targetFiles != null ) for ( final TargetFile targetFile : targetFiles ) { 
targetFile . init ( vars ) ; 
} 
if ( tflProducerConfig != null ) tflProducerConfig . init ( context , this , vars ) ; 
} 
} 

public class MultipartMixedArgumentsReader { 
@ Override public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { 
try { 
Object [ ] arguments = new Object [ formalParameters . length ] ; 
int argumentIndex = 0 ; 
ServletFileUpload multipart = new ServletFileUpload ( ) ; 
FileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; 
FileItemStream fileItemStream = null ; 
while ( iterator . hasNext ( ) ) { 
fileItemStream = iterator . next ( ) ; 
String contentType = fileItemStream . getContentType ( ) ; 
Type parameterType = formalParameters [ argumentIndex ] ; 
ArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; 
boolean streamArgument = StreamFactory . isStream ( parameterType ) ; 
ArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; 
InputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; 
arguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; 
++ argumentIndex ; 
if ( streamArgument ) { 
threadLocal . set ( inputStream ) ; 
break ; 
} 
inputStream . close ( ) ; 
} 
if ( argumentIndex != formalParameters . length ) throw new IllegalArgumentException ( "Not all parameters processed due to stream argument that is not the last on arguments list." ) ; 
return arguments ; 
} 
catch ( FileUploadException e ) { 
throw new IOException ( e . getMessage ( ) ) ; 
} 
} 
} 

public class AbstractEMFParser { 
protected final void parseModel ( ) { 
if ( ( fileExtensions == null ) || ( fileExtensions . size ( ) == 0 ) ) throw new IllegalStateException ( "No file extensions for EMF model files set!" ) ; 
resourceSet = new ResourceSetImpl ( ) ; 
error = false ; 
parseDirs ( ) ; 
parseResources ( ) ; 
} 
} 

public class AbstractEMFParser { 
protected final void resolveProxies ( ) { 
final List < String > unresolved = new ArrayList < String > ( ) ; 
if ( ! resolvedAllProxies ( unresolved , 0 ) ) { 
LOG . warn ( "Could not resolve the following proxies ({}):" , unresolved . size ( ) ) ; 
for ( final String ref : unresolved ) { 
LOG . warn ( "Not found: {}" , ref ) ; 
} 
final Iterator < Notifier > it = resourceSet . getAllContents ( ) ; 
while ( it . hasNext ( ) ) { 
final Notifier next = it . next ( ) ; 
if ( next instanceof EObject ) { 
final EObject obj = ( EObject ) next ; 
if ( obj . eIsProxy ( ) ) try { 
it . remove ( ) ; 
} 
catch ( final UnsupportedOperationException ex ) { 
LOG . error ( "Could not remove proxy: " + obj , ex ) ; 
} 
} 
} 
} 
} 
} 

public class AbstractEMFParser { 
private void parseDir ( final File dir ) { 
LOG . debug ( "Parse: {}" , dir ) ; 
final File [ ] files = getFiles ( dir ) ; 
if ( ( files == null ) || ( files . length == 0 ) ) LOG . debug ( "No files found in directory: {}" , dir ) ; 
else for ( final File file : files ) { 
if ( file . isFile ( ) ) { 
final Resource resource = resourceSet . getResource ( URI . createFileURI ( Utils4J . getCanonicalPath ( file ) ) , true ) ; 
final EList < Diagnostic > diagnostics = resource . getErrors ( ) ; 
if ( diagnostics . size ( ) == 0 ) LOG . debug ( "Parsed {}" , file ) ; 
else { 
error = true ; 
LOG . error ( "Parsed {} with errors: {}" , file , diagnostics ) ; 
} 
} 
else parseDir ( file ) ; 
} 
} 
} 

public class AbstractEMFParser { 
private static Set < EObject > findAllEObjects ( final ResourceSet resourceSet ) { 
final Set < EObject > list = new HashSet < EObject > ( ) ; 
for ( final Iterator < Notifier > i = resourceSet . getAllContents ( ) ; 
i . hasNext ( ) ; 
) { 
final Notifier next = i . next ( ) ; 
if ( next instanceof EObject ) list . add ( ( EObject ) next ) ; 
} 
return list ; 
} 
} 

public class AbstractEMFParser { 
protected final void setModelDirs ( final File ... modelDirs ) { 
if ( modelDirs == null ) this . modelDirs = null ; 
else { 
this . modelDirs = new ArrayList < File > ( ) ; 
this . modelDirs . addAll ( Arrays . asList ( modelDirs ) ) ; 
} 
} 
} 

public class AbstractEMFParser { 
protected final void setFileExtensions ( final String ... fileExtensions ) { 
if ( fileExtensions == null ) this . fileExtensions = null ; 
else { 
this . fileExtensions = new ArrayList < String > ( ) ; 
this . fileExtensions . addAll ( Arrays . asList ( fileExtensions ) ) ; 
} 
} 
} 

public class AbstractEMFParser { 
protected final void setModelResources ( final URI ... modelResources ) { 
if ( modelResources == null ) this . modelResources = null ; 
else { 
this . modelResources = new ArrayList < URI > ( ) ; 
this . modelResources . addAll ( Arrays . asList ( modelResources ) ) ; 
} 
} 
} 

public class StatementImpl { 
public void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { 
int arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; 
AssertUtils . assertTrue ( values . length <= arrayLen ) ; 
for ( int i = 0 ; 
i < arrayLen ; 
i ++ ) setString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; 
} 
} 

public class StatementImpl { 
public void setBoolean2 ( String parameterName , Boolean value ) throws java . sql . SQLException { 
if ( value == null ) setNull ( parameterName , Types . BIT ) ; 
else setBoolean ( parameterName , value ) ; 
} 
} 

public class VelocityGenerator { 
protected final void merge ( final VelocityContext context , final String artifactName , final String templateName , final String filename ) throws GenerateException { 
final GeneratedFile genFile = getTargetFile ( artifactName , filename , templateName ) ; 
if ( genFile . isSkip ( ) ) LOG . debug ( "Omitted already existing file: {} [{}]" , genFile , templateName ) ; 
else { 
LOG . debug ( "Start merging velocity template: {} [{}]" , genFile , templateName ) ; 
try { 
final Writer writer = new FileWriter ( genFile . getTmpFile ( ) ) ; 
try { 
final Template template = ve . getTemplate ( templateName ) ; 
template . merge ( context , writer ) ; 
} 
finally { 
writer . close ( ) ; 
} 
genFile . persist ( ) ; 
} 
catch ( final IOException ex ) { 
throw new GenerateException ( "Error merging template '" + templateName + "' to '" + filename + "'!" , ex ) ; 
} 
} 
} 
} 

public class ParameterizedTemplateParserConfig { 
public final File getModelDir ( ) { 
if ( ( modelDir == null ) && ( modelPath != null ) ) modelDir = Utils4J . getCanonicalFile ( new File ( modelPath ) ) ; 
return modelDir ; 
} 
} 

public class ParameterizedTemplateParserConfig { 
public final File getTemplateDir ( ) { 
if ( ( templateDir == null ) && ( templatePath != null ) ) try { 
templateDir = new File ( templatePath ) . getCanonicalFile ( ) ; 
} 
catch ( final IOException ex ) { 
throw new RuntimeException ( "Couldn't determine canonical template file: " + templatePath , ex ) ; 
} 
return templateDir ; 
} 
} 

public class WebViewFactory { 
private void configureWindow ( WebWindow web ) { 
if ( m_fullscreen ) { 
m_width = web . width ( ) ; 
m_height = web . height ( ) ; 
web . showFullScreen ( ) ; 
} 
else { 
web . showNormal ( ) ; 
if ( ! m_resizable ) web . setFixedSize ( new QSize ( m_width , m_height ) ) ; 
else web . setBaseSize ( new QSize ( m_width , m_height ) ) ; 
web . resize ( m_width , m_height ) ; 
} 
if ( ! m_bar ) web . menuBar ( ) . setVisible ( false ) ; 
else { 
web . menuBar ( ) . setVisible ( true ) ; 
if ( m_icon != null ) { 
QIcon icon = new QIcon ( m_icon ) ; 
web . setWindowIcon ( icon ) ; 
} 
web . setWindowTitle ( m_appName ) ; 
} 
if ( ! m_contextMenu ) web . setContextMenuPolicy ( ContextMenuPolicy . PreventContextMenu ) ; 
else web . setContextMenuPolicy ( ContextMenuPolicy . DefaultContextMenu ) ; 
} 
} 

public class WebViewFactory { 
public void print ( QWebView view ) { 
if ( m_print ) { 
QPrinter printer = new QPrinter ( ) ; 
QPrintDialog printDialog = new QPrintDialog ( printer , view ) ; 
if ( printDialog . exec ( ) == QDialog . DialogCode . Accepted . value ( ) ) view . print ( printer ) ; 
} 
else m_logger . warn ( "Print disabled" ) ; 
} 
} 

public class WebViewFactory { 
public static void write ( InputStream in , OutputStream out ) throws IOException { 
byte [ ] b = new byte [ 4096 ] ; 
for ( int n ; 
( n = in . read ( b ) ) != - 1 ; 
) out . write ( b , 0 , n ) ; 
in . close ( ) ; 
out . close ( ) ; 
} 
} 

public class RequestContext { 
public void attach ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) { 
if ( requestURL == null ) requestURL = httpRequest . getRequestURI ( ) ; 
if ( locale == null ) locale = httpRequest . getLocale ( ) ; 
if ( requestPath == null ) requestPath = httpRequest . getRequestURI ( ) . substring ( httpRequest . getContextPath ( ) . length ( ) ) ; 
this . httpRequest = httpRequest ; 
this . httpResponse = httpResponse ; 
this . attached = true ; 
} 
} 

public class RequestContext { 
public Cookies getCookies ( ) { 
assertAttached ( ) ; 
if ( cookies == null ) cookies = new Cookies ( httpRequest , httpResponse ) ; 
return cookies ; 
} 
} 

public class RequestContext { 
public void dump ( ) { 
if ( ! attached ) return ; 
StringBuilder message = new StringBuilder ( ) ; 
message . append ( "Request context |" ) ; 
message . append ( httpRequest . getRequestURI ( ) ) ; 
message . append ( "|:" ) ; 
message . append ( System . lineSeparator ( ) ) ; 
message . append ( "\t- remote-address: " ) ; 
message . append ( httpRequest . getRemoteHost ( ) ) ; 
message . append ( System . lineSeparator ( ) ) ; 
message . append ( "\t- method: " ) ; 
message . append ( httpRequest . getMethod ( ) ) ; 
message . append ( System . lineSeparator ( ) ) ; 
message . append ( "\t- query-string: " ) ; 
if ( httpRequest . getQueryString ( ) != null ) message . append ( httpRequest . getQueryString ( ) ) ; 
Enumeration < String > headerNames = httpRequest . getHeaderNames ( ) ; 
while ( headerNames . hasMoreElements ( ) ) { 
message . append ( System . lineSeparator ( ) ) ; 
String headerName = headerNames . nextElement ( ) ; 
message . append ( "\t- " ) ; 
message . append ( headerName ) ; 
message . append ( ": " ) ; 
message . append ( httpRequest . getHeader ( headerName ) ) ; 
} 
log . error ( message . toString ( ) ) ; 
} 
} 

public class EventStream { 
protected void config ( EventStreamConfig config ) { 
if ( config . hasSecretKey ( ) ) secretKey = config . getSecretKey ( ) ; 
if ( config . hasKeepAlivePeriod ( ) ) keepAlivePeriod = config . getKeepAlivePeriod ( ) ; 
parameters = config . getParameters ( ) ; 
} 
} 

public class EventStream { 
protected void setRemoteHost ( String remoteHost ) { 
if ( string == null ) string = Strings . concat ( '#' , STREAM_ID ++ , ':' , remoteHost ) ; 
} 
} 

public class EventStream { 
protected < T > T getParameter ( String name , Class < T > type ) { 
if ( parameters == null ) throw new BugError ( "Event stream |%s| parameters not configured." , this ) ; 
String value = parameters . get ( name ) ; 
if ( value == null ) throw new BugError ( "Missing event stream parameter |%s| of expected type |%s|." , name , type ) ; 
return ConverterRegistry . getConverter ( ) . asObject ( value , type ) ; 
} 
} 

public class FileSystemDirectoryHelper { 
public String removePrefix ( final String path , final String prefix ) { 
String pathWithoutPrefix = path ; 
if ( pathWithoutPrefix . startsWith ( prefix ) ) { 
pathWithoutPrefix = pathWithoutPrefix . substring ( prefix . length ( ) ) ; 
while ( pathWithoutPrefix . startsWith ( "/" ) || pathWithoutPrefix . startsWith ( "\\" ) ) pathWithoutPrefix = pathWithoutPrefix . substring ( 1 ) ; 
} 
return pathWithoutPrefix ; 
} 
} 

public class FileSystemDirectoryHelper { 
public File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { 
List < File > parts1 = getParentDirs ( dir1 ) ; 
List < File > parts2 = getParentDirs ( dir2 ) ; 
File matched = null ; 
final int maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; 
for ( int i = 0 ; 
i < maxCommonSize ; 
++ i ) if ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) matched = parts1 . get ( i ) ; 
else break ; 
return matched ; 
} 
} 

public class FileSystemDirectoryHelper { 
public String abs2rel ( final String basePath , final String absPath ) { 
if ( ! isAbsolutePath ( absPath ) ) return absPath ; 
if ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) return absPath ; 
StringBuilder result = new StringBuilder ( ) ; 
String [ ] baseParts = getParts ( basePath ) ; 
String [ ] absParts = getParts ( absPath ) ; 
int start = 0 ; 
for ( int i = 0 ; 
i < Math . min ( baseParts . length , absParts . length ) ; 
++ i ) if ( baseParts [ i ] . equals ( absParts [ i ] ) ) start = i + 1 ; 
for ( int i = start ; 
i < baseParts . length ; 
++ i ) { 
if ( result . length ( ) > 0 ) result . append ( File . separator ) ; 
result . append ( ".." ) ; 
} 
for ( int i = start ; 
i < absParts . length ; 
++ i ) { 
if ( result . length ( ) > 0 ) result . append ( File . separator ) ; 
result . append ( absParts [ i ] ) ; 
} 
return result . toString ( ) ; 
} 
} 

public class FileSystemDirectoryHelper { 
public File rel2abs ( final String basePath , final String relPath ) { 
String [ ] baseParts = getParts ( basePath ) ; 
String [ ] relParts = getParts ( relPath ) ; 
if ( isAbsolutePath ( relPath ) ) return new File ( relPath ) ; 
List < String > parts = new ArrayList < > ( ) ; 
for ( int i = 0 ; 
i < baseParts . length ; 
++ i ) if ( i > 0 || ! isWindowsDrive ( basePath ) ) parts . add ( baseParts [ i ] ) ; 
for ( String part : relParts ) { 
if ( part . equals ( ".." ) && parts . size ( ) > 0 ) parts . remove ( parts . size ( ) - 1 ) ; 
else if ( ! part . equals ( "." ) && ! part . equals ( ".." ) ) parts . add ( part ) ; 
} 
StringBuilder result = new StringBuilder ( ) ; 
if ( isWindowsDrive ( basePath ) ) result . append ( baseParts [ 0 ] ) ; 
for ( String part : parts ) { 
result . append ( File . separator ) ; 
result . append ( part ) ; 
} 
return new File ( result . toString ( ) ) ; 
} 
} 

public class ParameterizedTemplateModels { 
public final void addParamTemplate ( final ParameterizedTemplateModel paramTemplate ) { 
if ( paramTemplates == null ) paramTemplates = new ArrayList < ParameterizedTemplateModel > ( ) ; 
paramTemplates . add ( paramTemplate ) ; 
} 
} 

public class ParameterizedTemplateModels { 
public final void addParamTemplates ( final List < ParameterizedTemplateModel > list ) { 
if ( list != null ) for ( final ParameterizedTemplateModel template : list ) { 
addParamTemplate ( template ) ; 
} 
} 
} 

public class ParameterizedTemplateModels { 
public final void init ( final SrcGen4JContext context , final Map < String , String > vars ) { 
if ( paramTemplates != null ) for ( final ParameterizedTemplateModel paramTemplate : paramTemplates ) { 
paramTemplate . init ( context , vars ) ; 
} 
} 
} 

public class ParameterizedTemplateModels { 
public final List < ParameterizedTemplateModel > findReferencesTo ( final File templateDir , final File templateFile ) { 
final List < ParameterizedTemplateModel > result = new ArrayList < ParameterizedTemplateModel > ( ) ; 
if ( ( paramTemplates != null ) && Utils4J . fileInsideDirectory ( templateDir , templateFile ) ) for ( final ParameterizedTemplateModel paramTemplate : paramTemplates ) { 
if ( paramTemplate . hasReferenceTo ( templateDir , templateFile ) ) result . add ( paramTemplate ) ; 
} 
return result ; 
} 
} 

public class ElementView { 
protected void delete ( ) { 
String question = "Are you sure you want to delete " + getCaption ( ) + "?" ; 
ConfirmDialog . show ( getUI ( ) , question , ( ConfirmDialog cd ) -> { 
if ( cd . isConfirmed ( ) ) try { 
onDelete ( ) ; 
close ( ) ; 
} 
catch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { 
onError ( ex ) ; 
} 
catch ( RuntimeException ex ) { 
getUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; 
} 
} 
) ; 
} 
} 

public class LocalInstanceFactory { 
@ SuppressWarnings ( "unchecked" ) @ Override public < T > T newInstance ( ManagedClassSPI managedClass , Object ... args ) { 
Constructor < ? > constructor = managedClass . getConstructor ( ) ; 
if ( constructor == null ) throw new BugError ( "Local instance factory cannot instantiate |%s|. Missing constructor." , managedClass ) ; 
Object instance = null ; 
try { 
instance = constructor . newInstance ( args ) ; 
} 
catch ( IllegalArgumentException e ) { 
log . error ( "Wrong number of arguments or bad types for |%s|: [%s]." , constructor , Strings . join ( Classes . getParameterTypes ( args ) ) ) ; 
throw e ; 
} 
catch ( InstantiationException e ) { 
throw new BugError ( e ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new BugError ( e ) ; 
} 
catch ( InvocationTargetException e ) { 
log . error ( "Managed instance constructor |%s| fail due to: %s." , constructor , e . getCause ( ) ) ; 
throw new InvocationException ( e ) ; 
} 
if ( managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { 
ManagedProxyHandler handler = null ; 
if ( managedClass . isTransactional ( ) ) { 
TransactionalResource transactionalResource = managedClass . getContainer ( ) . getInstance ( TransactionalResource . class ) ; 
handler = new ManagedProxyHandler ( transactionalResource , managedClass , instance ) ; 
} 
else handler = new ManagedProxyHandler ( managedClass , instance ) ; 
final ClassLoader classLoader = managedClass . getImplementationClass ( ) . getClassLoader ( ) ; 
final Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; 
return ( T ) Proxy . newProxyInstance ( classLoader , interfaceClasses , handler ) ; 
} 
return ( T ) instance ; 
} 
} 

public class FitResultTable { 
public Counts getSummary ( ) { 
Counts result = new Counts ( ) ; 
for ( FileCount fileCount : results ) { 
if ( fileCount . getCounts ( ) != null ) result . tally ( fileCount . getCounts ( ) ) ; 
} 
return result ; 
} 
} 

public class ServiceInstanceFactory { 
@ SuppressWarnings ( "unchecked" ) @ Override public < I > I newInstance ( ManagedClassSPI managedClass , Object ... args ) { 
if ( args . length > 0 ) throw new IllegalArgumentException ( "Service instances factory does not support arguments." ) ; 
Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; 
if ( interfaceClasses == null ) throw new BugError ( "Invalid managed class. Null interface classes." ) ; 
if ( interfaceClasses . length != 1 ) throw new BugError ( "Invalid managed class. It should have exactly one interface class." ) ; 
return ( I ) Classes . loadService ( interfaceClasses [ 0 ] ) ; 
} 
} 

public class XtextParserConfig { 
public final Class < ? > getSetupClass ( ) { 
if ( setupClass != null ) return setupClass ; 
LOG . info ( "Creating setup class: {}" , setupClassName ) ; 
try { 
setupClass = Class . forName ( setupClassName , true , context . getClassLoader ( ) ) ; 
} 
catch ( final ClassNotFoundException ex ) { 
throw new RuntimeException ( "Couldn't load setup class: " + setupClassName , ex ) ; 
} 
return setupClass ; 
} 
} 

public class XtextParserConfig { 
public final List < File > getModelDirs ( ) { 
if ( ( modelDirs == null ) && ( modelPath != null ) ) modelDirs = paths ( ) . stream ( ) . filter ( XtextParserConfig :: isFile ) . map ( XtextParserConfig :: asFile ) . collect ( Collectors . toList ( ) ) ; 
return modelDirs ; 
} 
} 

public class QueryParametersParser { 
private static boolean isObject ( Type [ ] formalParameters ) { 
if ( formalParameters . length != 1 ) return false ; 
final Type type = formalParameters [ 0 ] ; 
if ( ! ( type instanceof Class ) ) return false ; 
if ( Types . isPrimitive ( type ) ) return false ; 
if ( Types . isArrayLike ( type ) ) return false ; 
if ( Types . isMap ( type ) ) return false ; 
if ( ConverterRegistry . hasType ( type ) ) return false ; 
return true ; 
} 
} 

public class FitUtils { 
public static String extractCellParameter ( FitCell cell ) { 
final Matcher matcher = PARAMETER_PATTERN . matcher ( cell . getFitValue ( ) ) ; 
if ( matcher . matches ( ) ) { 
cell . setFitValue ( matcher . group ( 1 ) ) ; 
return matcher . group ( 2 ) ; 
} 
else return null ; 
} 
} 

public class AbstractCollectionView { 
@ Subscribe public void handle ( ElementEvent < TEntity > message ) { 
if ( message . getEndpoint ( ) . getEntityType ( ) == this . endpoint . getEntityType ( ) ) refresh ( ) ; 
} 
} 

public class BeanUtils { 
public static < TAnnotation extends Annotation > List < PropertyDescriptor > getPropertiesWithAnnotation ( Class < ? > beanType , Class < TAnnotation > annotationType ) { 
LinkedList < PropertyDescriptor > result = new LinkedList < > ( ) ; 
getProperties ( beanType ) . forEach ( property -> { 
if ( property . getReadMethod ( ) != null && property . getReadMethod ( ) . getAnnotation ( annotationType ) != null || isFieldAnnotated ( beanType , property . getName ( ) , annotationType ) ) result . add ( property ) ; 
} 
) ; 
return result ; 
} 
} 

public class JRubyWhois { 
public WhoisResult lookup ( String domain , int timeout ) { 
container . put ( "domain" , domain ) ; 
container . put ( "timeout_param" , timeout ) ; 
try { 
return ( WhoisResult ) container . runScriptlet ( JRubyWhois . class . getResourceAsStream ( "jruby-whois.rb" ) , "jruby-whois.rb" ) ; 
} 
catch ( EvalFailedException e ) { 
if ( e . getMessage ( ) . startsWith ( "(ServerNotFound)" ) ) throw new ServerNotFoundException ( e ) ; 
if ( e . getMessage ( ) . startsWith ( "(WebInterfaceError" ) ) throw new WebInterfaceErrorException ( e ) ; 
throw e ; 
} 
} 
} 

public class LogEventAnalyzer { 
public void processNotContainsException ( Map < String , String > parameters ) { 
LoggingEvent match = getMessageWithException ( parameters ) ; 
if ( match == null ) cell . right ( ) ; 
else cell . wrong ( match . getThrowableInformation ( ) . getThrowableStrRep ( ) [ 0 ] ) ; 
} 
} 

public class LogEventAnalyzer { 
public void processNotContains ( Map < String , String > parameters ) { 
LoggingEvent match = getMessageWithString ( parameters ) ; 
if ( match == null ) cell . right ( ) ; 
else cell . wrong ( match . getMessage ( ) . toString ( ) ) ; 
} 
} 

public class Cookies { 
public String get ( String name ) { 
Params . notNullOrEmpty ( name , "Cookie name" ) ; 
if ( cookies == null ) return null ; 
for ( Cookie cookie : cookies ) { 
if ( name . equals ( cookie . getName ( ) ) ) return cookie . getValue ( ) ; 
} 
return null ; 
} 
} 

public class Cookies { 
public void remove ( String name ) { 
Params . notNullOrEmpty ( name , "Cookie name" ) ; 
if ( cookies == null ) return ; 
for ( Cookie cookie : cookies ) { 
if ( name . equals ( cookie . getName ( ) ) ) { 
cookie . setMaxAge ( 0 ) ; 
cookie . setValue ( "" ) ; 
cookie . setPath ( "/" ) ; 
httpResponse . addCookie ( cookie ) ; 
break ; 
} 
} 
} 
} 

public class Cookies { 
public Iterator < Cookie > iterator ( ) { 
if ( cookies == null ) return Collections . emptyIterator ( ) ; 
return Arrays . asList ( cookies ) . iterator ( ) ; 
} 
} 

public class TargetFileListProducerConfig { 
public final TargetFileListProducer getTargetFileListProducer ( ) { 
if ( tflProducer != null ) return tflProducer ; 
final Object obj = Utils4J . createInstance ( className ) ; 
if ( ! ( obj instanceof TargetFileListProducer ) ) throw new IllegalStateException ( "Expected class to be of type '" + TargetFileListProducer . class . getName ( ) + "', but was: " + className ) ; 
tflProducer = ( TargetFileListProducer ) obj ; 
return tflProducer ; 
} 
} 

public class DynamicObjectFactory { 
public void add ( final Class < ? > type , final String name ) throws ClassNotFoundException { 
FieldGen fg ; 
if ( result != null ) throw new IllegalStateException ( "Class already generated" ) ; 
fg = new FieldGen ( Constants . ACC_PUBLIC | Constants . ACC_SUPER , Type . getType ( type ) , name , cg . getConstantPool ( ) ) ; 
cg . addField ( fg . getField ( ) ) ; 
} 
} 

public class Challenge { 
private static String getValue ( File file ) throws NullPointerException { 
if ( file == null ) return null ; 
return file . getName ( ) . toLowerCase ( ) . replaceAll ( EXTENSION_REX , "" ) . replaceAll ( NOT_LETTERS_REX , " " ) ; 
} 
} 

public class URIUtils { 
@ SneakyThrows public static URI ensureTrailingSlash ( URI uri ) { 
URIBuilder builder = new URIBuilder ( uri ) ; 
if ( ! builder . getPath ( ) . endsWith ( "/" ) ) builder . setPath ( builder . getPath ( ) + "/" ) ; 
return builder . build ( ) ; 
} 
} 

public class TinyContainer { 
private HttpServletRequest getHttpServletRequest ( ) { 
RequestContext context = getInstance ( RequestContext . class ) ; 
HttpServletRequest request = context . getRequest ( ) ; 
if ( request == null ) throw new BugError ( "Attempt to use not initialized HTTP request." ) ; 
return request ; 
} 
} 

public class ManagedProxyHandler { 
@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { 
final ManagedMethodSPI managedMethod = managedClass . getManagedMethod ( method ) ; 
log . trace ( "Invoke |%s|." , managedMethod ) ; 
if ( ! managedMethod . isTransactional ( ) ) try { 
return managedMethod . invoke ( managedInstance , args ) ; 
} 
catch ( Throwable t ) { 
throw throwable ( t , "Non transactional method |%s| invocation fails." , managedMethod ) ; 
} 
if ( managedMethod . isImmutable ( ) ) return executeImmutableTransaction ( managedMethod , args ) ; 
return executeMutableTransaction ( managedMethod , args ) ; 
} 
} 

public class ManagedProxyHandler { 
private Object executeMutableTransaction ( ManagedMethodSPI managedMethod , Object [ ] args ) throws Throwable { 
Transaction transaction = transactionalResource . createTransaction ( ) ; 
transactionalResource . storeSession ( transaction . getSession ( ) ) ; 
try { 
Object result = managedMethod . invoke ( managedInstance , args ) ; 
transaction . commit ( ) ; 
if ( transaction . unused ( ) ) log . debug ( "Method |%s| superfluously declared transactional." , managedMethod ) ; 
return result ; 
} 
catch ( Throwable throwable ) { 
transaction . rollback ( ) ; 
throw throwable ( throwable , "Mutable transactional method |%s| invocation fail." , managedMethod ) ; 
} 
finally { 
if ( transaction . close ( ) ) transactionalResource . releaseSession ( ) ; 
} 
} 
} 

public class ManagedProxyHandler { 
private Object executeImmutableTransaction ( ManagedMethodSPI managedMethod , Object [ ] args ) throws Throwable { 
Transaction transaction = transactionalResource . createReadOnlyTransaction ( ) ; 
transactionalResource . storeSession ( transaction . getSession ( ) ) ; 
try { 
Object result = managedMethod . invoke ( managedInstance , args ) ; 
if ( transaction . unused ( ) ) log . debug ( "Method |%s| superfluously declared transactional." , managedMethod ) ; 
return result ; 
} 
catch ( Throwable throwable ) { 
throw throwable ( throwable , "Immutable transactional method |%s| invocation fail." , managedMethod ) ; 
} 
finally { 
if ( transaction . close ( ) ) transactionalResource . releaseSession ( ) ; 
} 
} 
} 

public class FileSelector { 
public File [ ] getFiles ( ) { 
final File [ ] files = directory . listFiles ( filter ) ; 
if ( files == null ) return new File [ 0 ] ; 
else return files ; 
} 
} 

public class FileSelector { 
public File getLastFile ( ) throws FileNotFoundException { 
File [ ] files = directory . listFiles ( filter ) ; 
if ( files == null || files . length == 0 ) throw new FileNotFoundException ( ) ; 
return files [ files . length - 1 ] ; 
} 
} 

public class AbstractParser { 
@ SuppressWarnings ( "unchecked" ) protected final CONFIG_TYPE getConcreteConfig ( final ParserConfig config ) { 
final Config < ParserConfig > cfg = config . getConfig ( ) ; 
if ( cfg == null ) throw new IllegalStateException ( "The configuration is expected to be of type '" + concreteConfigClass . getName ( ) + "', but was: null" ) ; 
else if ( ! ( concreteConfigClass . isAssignableFrom ( cfg . getConfig ( ) . getClass ( ) ) ) ) throw new IllegalStateException ( "The configuration is expected to be of type '" + concreteConfigClass . getName ( ) + "', but was: " + cfg . getConfig ( ) . getClass ( ) . getName ( ) + " - Did you add the configuration class to the JXB context?" ) ; 
return ( CONFIG_TYPE ) cfg . getConfig ( ) ; 
} 
} 

public class RequestPreprocessor { 
private static boolean startsWith ( String requestPath , String pathComponent ) { 
if ( requestPath . charAt ( 0 ) != '/' ) return false ; 
int i = 1 ; 
for ( int j = 0 ; 
i < requestPath . length ( ) ; 
++ i , ++ j ) { 
if ( requestPath . charAt ( i ) == '/' ) return j == pathComponent . length ( ) ; 
if ( j == pathComponent . length ( ) ) return false ; 
if ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) return false ; 
} 
return false ; 
} 
} 

public class EMFGeneratorConfig { 
@ SuppressWarnings ( "unchecked" ) @ NotNull public final < MODEL > List < ArtifactFactory < MODEL > > getFactories ( final Class < MODEL > modelType ) { 
final List < ArtifactFactory < MODEL > > list = new ArrayList < ArtifactFactory < MODEL > > ( ) ; 
if ( factories == null ) { 
factories = new ArrayList < ArtifactFactory < ? > > ( ) ; 
if ( factoryConfigs != null ) for ( final ArtifactFactoryConfig factoryConfig : factoryConfigs ) { 
factories . add ( factoryConfig . getFactory ( ) ) ; 
} 
} 
for ( final ArtifactFactory < ? > factory : factories ) { 
if ( modelType . isAssignableFrom ( factory . getModelType ( ) ) ) list . add ( ( ArtifactFactory < MODEL > ) factory ) ; 
} 
return list ; 
} 
} 

public class SessionScopeFactory { 
private HttpSession getSession ( InstanceKey instanceKey ) { 
RequestContext requestContext = appFactory . getInstance ( RequestContext . class ) ; 
HttpServletRequest httpRequest = requestContext . getRequest ( ) ; 
if ( httpRequest == null ) throw new BugError ( "Invalid web context due to null HTTP request. Cannot create managed instance for |%s| with scope SESSION." , instanceKey ) ; 
return httpRequest . getSession ( true ) ; 
} 
} 

public class ResourceServlet { 
@ Override protected void handleRequest ( RequestContext context ) throws ServletException , IOException { 
final HttpServletRequest httpRequest = context . getRequest ( ) ; 
final HttpServletResponse httpResponse = context . getResponse ( ) ; 
ArgumentsReader argumentsReader = null ; 
Resource resource = null ; 
try { 
ManagedMethodSPI method = resourceMethods . get ( key ( context . getRequestPath ( ) ) ) ; 
if ( method == null ) throw new NoSuchMethodException ( httpRequest . getRequestURI ( ) ) ; 
final Type [ ] formalParameters = method . getParameterTypes ( ) ; 
argumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; 
Object [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; 
Object controller = container . getInstance ( method . getDeclaringClass ( ) ) ; 
resource = method . invoke ( controller , arguments ) ; 
if ( resource == null ) throw new BugError ( "Null resource |%s|." , httpRequest . getRequestURI ( ) ) ; 
} 
catch ( AuthorizationException e ) { 
String loginPage = container . getLoginPage ( ) ; 
if ( loginPage != null ) httpResponse . sendRedirect ( loginPage ) ; 
else httpRequest . authenticate ( httpResponse ) ; 
return ; 
} 
catch ( NoSuchMethodException | IllegalArgumentException e ) { 
dumpError ( context , e ) ; 
httpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; 
return ; 
} 
catch ( InvocationException e ) { 
dumpError ( context , e ) ; 
if ( e . getCause ( ) instanceof NoSuchResourceException ) httpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; 
else httpResponse . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getCause ( ) . getMessage ( ) ) ; 
return ; 
} 
finally { 
if ( argumentsReader != null ) argumentsReader . clean ( ) ; 
} 
httpResponse . setStatus ( HttpServletResponse . SC_OK ) ; 
resource . serialize ( httpResponse ) ; 
} 
} 

public class EventStreamManagerImpl { 
@ Override public void preDestroy ( ) { 
if ( eventStreams . isEmpty ( ) ) return ; 
for ( EventStream eventStream : eventStreams . toArray ( new EventStream [ 0 ] ) ) { 
log . debug ( "Force close stale event stream |%s|." , eventStream ) ; 
eventStream . close ( ) ; 
} 
} 
} 

public class AbstractBlobView { 
protected void delete ( ) { 
String question = "Are you sure you want to delete the data from the server?" ; 
ConfirmDialog . show ( getUI ( ) , question , new ConfirmDialog . Listener ( ) { 
@ Override public void onClose ( ConfirmDialog cd ) { 
if ( cd . isConfirmed ( ) ) try { 
endpoint . delete ( ) ; 
close ( ) ; 
} 
catch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { 
onError ( ex ) ; 
} 
catch ( RuntimeException ex ) { 
getUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; 
} 
} 
} 
) ; 
} 
} 

public class Fixture { 
protected String [ ] getArgNames ( ) { 
if ( args == null ) return new String [ ] { 
} 
; 
return args . keySet ( ) . toArray ( new String [ args . keySet ( ) . size ( ) ] ) ; 
} 
} 

public class ViewManagerImpl { 
@ Override public void config ( Config config ) throws ConfigException , IOException { 
for ( Config repositorySection : config . findChildren ( "repository" ) ) { 
String className = repositorySection . getAttribute ( "class" , DEF_IMPLEMENTATION ) ; 
Class < ? > implementation = Classes . forOptionalName ( className ) ; 
if ( implementation == null ) throw new ConfigException ( "Unable to load view implementation |%s|." , className ) ; 
if ( ! Types . isKindOf ( implementation , View . class ) ) throw new ConfigException ( "View implementation |%s| is not of proper type." , className ) ; 
if ( ! Classes . isInstantiable ( implementation ) ) throw new ConfigException ( "View implementation |%s| is not instantiable. Ensure is not abstract or interface and have default constructor." , implementation ) ; 
@ SuppressWarnings ( "unchecked" ) Class < ? extends View > viewImplementation = ( Class < ? extends View > ) implementation ; 
String repositoryPath = repositorySection . getAttribute ( "path" ) ; 
if ( repositoryPath == null ) throw new ConfigException ( "Invalid views repository configuration. Missing <path> attribute." ) ; 
String filesPattern = repositorySection . getAttribute ( "files-pattern" ) ; 
if ( filesPattern == null ) throw new ConfigException ( "Invalid views repository configuration. Missing <files-pattern> attribute." ) ; 
ConfigBuilder builder = new I18nRepository . ConfigBuilder ( repositoryPath , filesPattern ) ; 
I18nRepository repository = new I18nRepository ( builder . build ( ) ) ; 
if ( viewsMetaPool == null ) viewsMetaPool = repository . getPoolInstance ( ) ; 
Properties properties = repositorySection . getProperties ( ) ; 
for ( I18nFile template : repository ) { 
ViewMeta meta = new ViewMeta ( template . getFile ( ) , viewImplementation , properties ) ; 
if ( viewsMetaPool . put ( meta . getName ( ) , meta , template . getLocale ( ) ) ) log . warn ( "Override view |%s|" , meta ) ; 
else log . debug ( "Register view |%s|" , meta ) ; 
} 
} 
} 
} 

public class RecursiveFileSelector { 
@ Override public final File next ( ) { 
if ( files == null || fileIndex >= files . length ) if ( ! cacheNext ( ) ) throw new NoSuchElementException ( ) ; 
return files [ fileIndex ++ ] ; 
} 
} 

public class Launcher { 
private static void configureApplication ( ) { 
File file = new File ( "chameria.props" ) ; 
if ( file . exists ( ) ) { 
Properties props = new Properties ( ) ; 
InputStream is = null ; 
try { 
is = new FileInputStream ( file ) ; 
props . load ( is ) ; 
String n = props . getProperty ( "application.name" ) ; 
if ( n != null ) QApplication . setApplicationName ( n ) ; 
else QApplication . setApplicationName ( "akquinet ChameRIA" ) ; 
n = props . getProperty ( "application.version" ) ; 
if ( n != null ) QApplication . setApplicationVersion ( n ) ; 
n = props . getProperty ( "application.icon" ) ; 
if ( n != null ) { 
QIcon icon = new QIcon ( n ) ; 
QApplication . setWindowIcon ( icon ) ; 
} 
} 
catch ( Exception e ) { 
System . err . println ( "Cannot read the application configuration " + e . getMessage ( ) ) ; 
e . printStackTrace ( ) ; 
} 
finally { 
if ( is != null ) try { 
is . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
} 
QApplication . setOrganizationName ( "akquinet A.G." ) ; 
} 
} 

public class Launcher { 
public static ChameRIA createChameleon ( String [ ] args ) throws Exception { 
boolean debug = isDebugModeEnabled ( args ) ; 
String core = getCore ( args ) ; 
String app = getApp ( args ) ; 
String runtime = getRuntime ( args ) ; 
String fileinstall = getDeployDirectory ( args ) ; 
String config = getProps ( args ) ; 
if ( config == null || ! new File ( config ) . exists ( ) ) return new ChameRIA ( core , debug , app , runtime , fileinstall , null ) ; 
else return new ChameRIA ( core , debug , app , runtime , fileinstall , config ) ; 
} 
} 

public class FitParseResult { 
public void insertAndReplace ( final FitRow row ) { 
if ( results . isEmpty ( ) ) return ; 
int index = row . getIndex ( ) ; 
FitTable table = row . getTable ( ) ; 
table . remove ( index ) ; 
addRows ( table , index ) ; 
} 
} 

public class BlockLocks { 
public int nextClearBit ( int index ) { 
int i = index >> 6 ; 
if ( i >= wlen ) return - 1 ; 
int subIndex = index & 0x3f ; 
long word = ~ bits . get ( i ) >> subIndex ; 
if ( word != 0 ) return ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; 
while ( ++ i < wlen ) { 
word = ~ bits . get ( i ) ; 
if ( word != 0 ) return ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; 
} 
return - 1 ; 
} 
} 

public class BlockLocks { 
public boolean set ( int index ) { 
int wordNum = index >> 6 ; 
int bit = index & 0x3f ; 
long bitmask = 1L << bit ; 
long word , oword ; 
do { 
word = bits . get ( wordNum ) ; 
if ( ( word & bitmask ) != 0 ) return false ; 
oword = word ; 
word |= bitmask ; 
} 
while ( ! bits . compareAndSet ( wordNum , oword , word ) ) ; 
return true ; 
} 
} 

public class BlockCache { 
protected void freeBuffer ( final ByteBuffer buffer ) throws IOException { 
if ( buffer == null ) return ; 
if ( UNMAP_SUPPORTED ) try { 
AccessController . doPrivileged ( new PrivilegedExceptionAction < Void > ( ) { 
@ Override public Void run ( ) throws Exception { 
final Method getCleanerMethod = buffer . getClass ( ) . getMethod ( "cleaner" ) ; 
getCleanerMethod . setAccessible ( true ) ; 
final Object cleaner = getCleanerMethod . invoke ( buffer ) ; 
if ( cleaner != null ) cleaner . getClass ( ) . getMethod ( "clean" ) . invoke ( cleaner ) ; 
return null ; 
} 
} 
) ; 
} 
catch ( PrivilegedActionException e ) { 
final IOException ioe = new IOException ( "unable to unmap the mapped buffer" ) ; 
ioe . initCause ( e . getCause ( ) ) ; 
throw ioe ; 
} 
} 
} 

public class SlimSet { 
private static Object [ ] rehash ( final Object [ ] values , final int newSize ) { 
Object [ ] newArray = new Object [ newSize ] ; 
for ( Object value : values ) { 
if ( value == null ) continue ; 
newArray [ predictedPosition ( newArray , value , value . hashCode ( ) ) ] = value ; 
} 
return newArray ; 
} 
} 

public class PolymerElements { 
public String toHELM2 ( ) { 
StringBuilder notation = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < listMonomerNotations . size ( ) ; 
i ++ ) notation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + "." ) ; 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class AnnotationsParser { 
private boolean checkBracketsParenthesis ( ) { 
LOG . debug ( "Check of brackets in the annotation section:" ) ; 
if ( bracketCounterOpen == bracketCounterClose && parenthesisCounterOpen == parenthesisCounterClose && curlyBracketCounterOpen == curlyBracketCounterClose ) return true ; 
return false ; 
} 
} 

public class ConnectionNotation { 
private void addDetails ( String str ) throws NotationException { 
String [ ] parts = str . split ( "-" ) ; 
sourceUnit = parts [ 0 ] . split ( ":" ) [ 0 ] . toUpperCase ( ) ; 
targetUnit = parts [ 1 ] . split ( ":" ) [ 0 ] . toUpperCase ( ) ; 
rGroupSource = parts [ 0 ] . split ( ":" ) [ 1 ] ; 
rGroupTarget = parts [ 1 ] . split ( ":" ) [ 1 ] ; 
Pattern r = Pattern . compile ( "R\\d" , Pattern . CASE_INSENSITIVE ) ; 
Pattern pair = Pattern . compile ( "pair" , Pattern . CASE_INSENSITIVE ) ; 
Matcher mR = r . matcher ( rGroupSource ) ; 
Matcher mPair = pair . matcher ( rGroupTarget ) ; 
if ( mR . matches ( ) ) rGroupSource = rGroupSource . toUpperCase ( ) ; 
else rGroupSource = rGroupSource . toLowerCase ( ) ; 
if ( mPair . matches ( ) ) rGroupTarget = rGroupTarget . toLowerCase ( ) ; 
else rGroupTarget = rGroupTarget . toUpperCase ( ) ; 
} 
} 

public class ConnectionNotation { 
public String toHELM2 ( ) { 
if ( isAnnotationTrue ( ) ) return sourceId . getId ( ) + "," + targetId . getId ( ) + "," + sourceUnit + ":" + rGroupSource + "-" + targetUnit + ":" + rGroupTarget + "\"" + annotation + "\"" ; 
else return sourceId . getId ( ) + "," + targetId . getId ( ) + "," + sourceUnit + ":" + rGroupSource + "-" + targetUnit + ":" + rGroupTarget ; 
} 
} 

public class StartHELM2Parser { 
public static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { 
Options options = new Options ( ) ; 
options . addOption ( "inputHELM" , true , "HELM1 or HELM2 string in a file" ) ; 
options . addOption ( "output" , true , "output can be in JSON- or HELM2-format" ) ; 
options . addOption ( "translate" , false , "translate HELM1 to HELM2" ) ; 
CommandLineParser parameter = new DefaultParser ( ) ; 
try { 
CommandLine cmd = parameter . parse ( options , args ) ; 
String filename = cmd . getOptionValue ( "inputHELM" ) ; 
ParserHELM2 parser = new ParserHELM2 ( ) ; 
FileReader in = new FileReader ( filename ) ; 
BufferedReader br = new BufferedReader ( in ) ; 
String line ; 
String helm ; 
try { 
while ( ( line = br . readLine ( ) ) != null ) { 
helm = line ; 
if ( cmd . hasOption ( "translate" ) ) { 
ConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; 
helm = converter . doConvert ( helm ) ; 
LOG . info ( "HELM1 is translated to HELM2" ) ; 
} 
parser . parse ( helm ) ; 
String output = "" ; 
if ( cmd . getOptionValue ( "output" ) . equals ( "HELM2" ) ) output = parser . getHELM2Notation ( ) . toHELM2 ( ) ; 
else if ( cmd . getOptionValue ( "output" ) . equals ( "JSON" ) ) output = parser . getJSON ( ) ; 
System . out . println ( output ) ; 
} 
} 
finally { 
br . close ( ) ; 
} 
} 
catch ( NullPointerException e ) { 
System . out . println ( "Please call the program with the following arguments: " + "\n" + "-inputHELM  <" + options . getOption ( "inputHELM" ) . getDescription ( ) + ">\n" + "-output <" + options . getOption ( "output" ) . getDescription ( ) + ">\n-translate(optional) <" + options . getOption ( "translate" ) . getDescription ( ) + ">" ) ; 
} 
catch ( ParseException exp ) { 
System . out . println ( "Unexpected exception: " + exp . getMessage ( ) ) ; 
} 
} 
} 

public class StateMachineParser { 
public boolean checkRepeating ( String str ) { 
String pattern = "\\d+|\\d+-\\d+" ; 
if ( str . matches ( pattern ) ) return true ; 
return false ; 
} 
} 

public class StateMachineParser { 
public boolean isPeptideOrRna ( ) throws SimplePolymerSectionException { 
if ( polymerElements . size ( ) >= 1 ) { 
if ( polymerElements . get ( polymerElements . size ( ) - 1 ) . matches ( "(PEPTIDE[1-9][0-9]*+|RNA[1-9][0-9]*)" ) ) return true ; 
return false ; 
} 
else throw new SimplePolymerSectionException ( "No Polymer Id is found" ) ; 
} 
} 

public class HELM2Notation { 
public PolymerNotation getSimplePolymer ( String string ) { 
for ( PolymerNotation polymer : listOfPolymers ) { 
if ( polymer . getPolymerID ( ) . getId ( ) . equals ( string ) ) return polymer ; 
} 
return null ; 
} 
} 

public class HELM2Notation { 
@ JsonIgnore public GroupingNotation getCurrentGroupingNotation ( ) { 
if ( listOfGroupings . size ( ) == 0 ) return null ; 
return listOfGroupings . get ( listOfGroupings . size ( ) - 1 ) ; 
} 
} 

public class HELM2Notation { 
public String polymerToHELM2 ( ) { 
StringBuilder notation = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < listOfPolymers . size ( ) ; 
i ++ ) if ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) notation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + "{" + listOfPolymers . get ( i ) . toHELM2 ( ) + "}\"" + listOfPolymers . get ( i ) . getAnnotation ( ) + "\"|" ) ; 
else notation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + "{" + listOfPolymers . get ( i ) . toHELM2 ( ) + "}" + "|" ) ; 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String connectionToHELM2 ( ) { 
if ( listOfConnections . size ( ) == 0 ) return "" ; 
StringBuilder notation = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < listOfConnections . size ( ) ; 
i ++ ) notation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + "|" ) ; 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String groupingToHELM2 ( ) { 
if ( listOfGroupings . size ( ) == 0 ) return "" ; 
StringBuilder notation = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < listOfGroupings . size ( ) ; 
i ++ ) notation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + "|" ) ; 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String annotationToHELM2 ( ) { 
if ( ! ( annotationSection . isEmpty ( ) ) ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( int i = 0 ; 
i < annotationSection . size ( ) ; 
i ++ ) sb . append ( annotationSection . get ( i ) . toHELM2 ( ) + "|" ) ; 
sb . setLength ( sb . length ( ) - 1 ) ; 
return sb . toString ( ) ; 
} 
return "" ; 
} 
} 

public class HELM2Notation { 
@ JsonIgnore public PolymerNotation getPolymerNotation ( String id ) { 
for ( PolymerNotation polymer : listOfPolymers ) { 
if ( polymer . getPolymerID ( ) . getId ( ) . equals ( id ) ) return polymer ; 
} 
return null ; 
} 
} 

public class PolymerNotation { 
private void setPolymerElements ( ) { 
if ( polymerID instanceof RNAEntity || polymerID instanceof PeptideEntity ) this . polymerElements = new PolymerListElements ( polymerID ) ; 
else this . polymerElements = new PolymerSingleElements ( polymerID ) ; 
} 
} 

public class ConverterHELM1ToHELM2 { 
public String doConvert ( String str ) { 
ParserHELM2 parser = new ParserHELM2 ( ) ; 
try { 
parser . parse ( str + "V2.0" ) ; 
return str + "V2.0" ; 
} 
catch ( Exception e ) { 
String helm1 = str + "f" ; 
StringBuilder helm2 = new StringBuilder ( ) ; 
String [ ] sections = helm1 . split ( "}\\$" ) ; 
helm2 . append ( sections [ 0 ] + "}$" ) ; 
StringBuilder sb = new StringBuilder ( ) ; 
for ( int i = 1 ; 
i < sections . length ; 
i ++ ) sb . append ( sections [ i ] + "}$" ) ; 
helm1 = "$" + sb . toString ( ) ; 
sections = helm1 . split ( "\\$" ) ; 
if ( sections . length >= 2 ) if ( ! ( sections [ 1 ] . isEmpty ( ) ) ) helm2 . append ( sections [ 1 ] ) ; 
if ( sections . length >= 3 ) { 
if ( ! ( sections [ 2 ] . isEmpty ( ) ) ) if ( ! ( sections [ 1 ] . isEmpty ( ) ) ) helm2 . append ( "|" + sections [ 2 ] ) ; 
else helm2 . append ( sections [ 2 ] ) ; 
helm2 . append ( "$" ) ; 
helm2 . append ( "$" ) ; 
if ( sections . length >= 4 ) if ( ! ( sections [ 3 ] . isEmpty ( ) ) ) helm2 . append ( sections [ 3 ] ) ; 
} 
helm2 . append ( "$V2.0" ) ; 
return helm2 . toString ( ) ; 
} 
} 
} 

public class MonomerNotation { 
public void setCount ( String str ) { 
isDefault = false ; 
if ( str . equals ( "1" ) ) isDefault = true ; 
count = str ; 
} 
} 

public class ValidationMethod { 
public static MonomerNotation decideWhichMonomerNotation ( String str , String type ) throws NotationException { 
MonomerNotation mon ; 
if ( str . startsWith ( "(" ) && str . endsWith ( ")" ) ) { 
String str2 = str . substring ( 1 , str . length ( ) - 1 ) ; 
Pattern patternAND = Pattern . compile ( "\\+" ) ; 
Pattern patternOR = Pattern . compile ( "," ) ; 
if ( patternAND . matcher ( str ) . find ( ) ) mon = new MonomerNotationGroupMixture ( str2 , type ) ; 
else if ( patternOR . matcher ( str ) . find ( ) ) mon = new MonomerNotationGroupOr ( str2 , type ) ; 
else if ( str . contains ( "." ) ) mon = new MonomerNotationList ( str2 , type ) ; 
else if ( type == "RNA" ) mon = new MonomerNotationUnitRNA ( str2 , type ) ; 
else { 
if ( str2 . length ( ) > 1 ) if ( ! ( str2 . startsWith ( "[" ) && str2 . endsWith ( "]" ) ) ) throw new NotationException ( "Monomers have to be in brackets: " + str ) ; 
mon = new MonomerNotationUnit ( str2 , type ) ; 
} 
} 
else if ( type == "RNA" ) mon = new MonomerNotationUnitRNA ( str , type ) ; 
else if ( type != "BLOB" ) { 
if ( str . length ( ) > 1 ) if ( ! ( str . startsWith ( "[" ) && str . endsWith ( "]" ) ) ) throw new NotationException ( "Monomers have to be in brackets: " + str ) ; 
mon = new MonomerNotationUnit ( str , type ) ; 
} 
else mon = new MonomerNotationUnit ( str , type ) ; 
return mon ; 
} 
} 

public class ValidationMethod { 
public static MonomerNotationGroupElement decideWhichMonomerNotationInGroup ( String str , String type , double one , double two , boolean interval , boolean isDefault ) throws NotationException { 
MonomerNotation element ; 
element = decideWhichMonomerNotation ( str , type ) ; 
if ( interval ) return new MonomerNotationGroupElement ( element , one , two ) ; 
else return new MonomerNotationGroupElement ( element , one , isDefault ) ; 
} 
} 

public class ValidationMethod { 
public static HELMEntity decideWhichEntity ( String str ) throws NotationException { 
HELMEntity item ; 
if ( str . toUpperCase ( ) . matches ( "PEPTIDE[1-9][0-9]*" ) ) item = new PeptideEntity ( str . toUpperCase ( ) ) ; 
else if ( str . toUpperCase ( ) . matches ( "RNA[1-9][0-9]*" ) ) item = new RNAEntity ( str . toUpperCase ( ) ) ; 
else if ( str . toUpperCase ( ) . matches ( "BLOB[1-9][0-9]*" ) ) item = new BlobEntity ( str . toUpperCase ( ) ) ; 
else if ( str . toUpperCase ( ) . matches ( "CHEM[1-9][0-9]*" ) ) item = new ChemEntity ( str . toUpperCase ( ) ) ; 
else if ( str . toUpperCase ( ) . matches ( "G[1-9][0-9]*" ) ) item = new GroupEntity ( str . toUpperCase ( ) ) ; 
else throw new NotationException ( "ID is wrong: " + str ) ; 
return item ; 
} 
} 

public class MonomerNotationGroupElement { 
public List < Double > getValue ( ) { 
if ( this . isInterval ) return new ArrayList < Double > ( Arrays . asList ( numberOne , numberTwo ) ) ; 
else return new ArrayList < Double > ( Arrays . asList ( numberOne ) ) ; 
} 
} 

public class ParserHELM2 { 
public void parse ( String test ) throws ExceptionState { 
parser = new StateMachineParser ( ) ; 
test = test . trim ( ) ; 
if ( test . substring ( test . length ( ) - 4 ) . matches ( "V2\\.0" ) || test . substring ( test . length ( ) - 4 ) . matches ( "v2\\.0" ) ) { 
for ( int i = 0 ; 
i < test . length ( ) - 4 ; 
i ++ ) parser . doAction ( test . charAt ( i ) ) ; 
if ( ! ( parser . getState ( ) instanceof FinalState ) ) { 
LOG . error ( "Invalid input: Final State was not reached:" ) ; 
throw new FinalStateException ( "Invalid input: Final State was not reached" ) ; 
} 
} 
else { 
LOG . error ( "Invalid input: HELM2 standard is missing:" ) ; 
throw new NotValidHELM2Exception ( "Invalid input: HELM2 standard is missing" ) ; 
} 
} 
} 

public class MonomerNotationUnitRNA { 
private void setRNAContents ( String str ) throws NotationException { 
String [ ] list ; 
List < String > items = extractContents ( str ) ; 
for ( String item : items ) { 
if ( item . length ( ) > 1 ) if ( ! ( item . startsWith ( "[" ) && item . endsWith ( "]" ) ) ) throw new NotationException ( "Monomers have to be in brackets " + item ) ; 
contents . add ( new MonomerNotationUnit ( item , type ) ) ; 
} 
} 
} 

public class GroupingNotation { 
private void defineAmbiguity ( String a ) throws NotationException { 
Pattern patternAND = Pattern . compile ( "\\+" ) ; 
Matcher m = patternAND . matcher ( a ) ; 
if ( m . find ( ) ) setAmbiguity ( new GroupingMixture ( a ) ) ; 
else setAmbiguity ( new GroupingOr ( a ) ) ; 
} 
} 

public class ADiGraph { 
private void initPathsInternal ( ) { 
synchronized ( LOCK ) { 
if ( _incomingPathsInternal == null ) { 
AMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; 
incomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; 
AMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; 
outgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; 
AList < AEdgePath < N , E > > cycles = AList . nil ( ) ; 
for ( N curNode : nodes ( ) ) { 
final Iterable < E > curIncoming = incomingEdges ( curNode ) ; 
List < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; 
for ( E incomingEdge : curIncoming ) { 
unfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; 
} 
AList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; 
while ( unfinishedBusiness . size ( ) > 0 ) { 
final List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; 
for ( AEdgePath < N , E > p : unfinishedBusiness ) { 
if ( ! p . hasCycle ( ) || p . isMinimalCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; 
if ( p . isMinimalCycle ( ) ) cycles = cycles . cons ( p ) ; 
} 
unfinishedBusiness = new ArrayList < > ( ) ; 
for ( AEdgePath < N , E > curPath : curBusiness ) { 
final Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; 
for ( E newEdge : l ) { 
final AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; 
if ( ! pathCandidate . hasNonMinimalCycle ( ) ) unfinishedBusiness . add ( pathCandidate ) ; 
} 
} 
} 
incomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; 
for ( AEdgePath < N , E > p : nonCycles ) { 
outgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; 
} 
} 
_incomingPathsInternal = incomingPaths ; 
_outgoingPathsInternal = outgoingPaths ; 
_cyclesInternal = cycles ; 
} 
} 
} 
} 

public class ADiGraph { 
public List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { 
if ( hasCycles ( ) ) throw new AGraphCircularityException ( ) ; 
final Object [ ] result = new Object [ nodes . length ] ; 
int nextIdx = 0 ; 
final Set < N > unprocessed = new HashSet < > ( ) ; 
for ( Object node : nodes ) { 
unprocessed . add ( ( N ) node ) ; 
} 
while ( ! unprocessed . isEmpty ( ) ) { 
final Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { 
@ Override public boolean apply ( N n ) { 
for ( E e : incomingEdges ( n ) ) { 
if ( unprocessed . contains ( e . getFrom ( ) ) ) return false ; 
} 
return true ; 
} 
} 
) ; 
unprocessed . removeAll ( nextBatch ) ; 
for ( N n : nextBatch ) { 
result [ nextIdx ] = n ; 
nextIdx += 1 ; 
} 
} 
return new ArrayIterable < > ( result ) ; 
} 
} 

public class API { 
public void unsubscribe ( final String pattern ) throws InvalidInputException { 
final String s = this . prefix + pattern ; 
LinkedList < FunctionInterface9 > callback_list = this . callbacks . get ( s ) ; 
if ( callback_list == null ) throw new InvalidInputException ( ) ; 
else { 
callback_list . removeFirst ( ) ; 
if ( callback_list . isEmpty ( ) ) this . callbacks . remove ( s ) ; 
} 
OtpOutputStream unsubscribe = new OtpOutputStream ( ) ; 
unsubscribe . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { 
new OtpErlangAtom ( "unsubscribe" ) , new OtpErlangString ( pattern ) } 
; 
unsubscribe . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( unsubscribe ) ; 
} 
} 

public class AExceptionFilter { 
public static < T extends Throwable > T forLocalHandling ( T th ) { 
if ( requiresNonLocalHandling ( th ) ) AUnchecker . throwUnchecked ( th ) ; 
return th ; 
} 
} 

public class ForkJoinPool { 
final WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { 
UncaughtExceptionHandler handler ; 
wt . setDaemon ( true ) ; 
if ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; 
WorkQueue w = new WorkQueue ( this , wt ) ; 
int i = 0 ; 
int mode = config & MODE_MASK ; 
int rs = lockRunState ( ) ; 
try { 
WorkQueue [ ] ws ; 
int n ; 
if ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { 
int s = indexSeed += SEED_INCREMENT ; 
int m = n - 1 ; 
i = ( ( s << 1 ) | 1 ) & m ; 
if ( ws [ i ] != null ) { 
int probes = 0 ; 
int step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; 
while ( ws [ i = ( i + step ) & m ] != null ) if ( ++ probes >= n ) { 
workQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; 
m = n - 1 ; 
probes = 0 ; 
} 
} 
w . hint = s ; 
w . config = i | mode ; 
w . scanState = i ; 
ws [ i ] = w ; 
} 
} 
finally { 
unlockRunState ( rs , rs & ~ RSLOCK ) ; 
} 
wt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; 
return w ; 
} 
} 

public class ForkJoinPool { 
final void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { 
WorkQueue w = null ; 
if ( wt != null && ( w = wt . workQueue ) != null ) { 
WorkQueue [ ] ws ; 
int idx = w . config & SMASK ; 
int rs = lockRunState ( ) ; 
if ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; 
unlockRunState ( rs , rs & ~ RSLOCK ) ; 
} 
long c ; 
do { 
} 
while ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; 
if ( w != null ) { 
w . qlock = - 1 ; 
w . transferStealCount ( this ) ; 
w . cancelAll ( ) ; 
} 
for ( ; 
; 
) { 
WorkQueue [ ] ws ; 
int m , sp ; 
if ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; 
if ( ( sp = ( int ) ( c = ctl ) ) != 0 ) if ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; 
else if ( ex != null && ( c & ADD_WORKER ) != 0L ) { 
tryAddWorker ( c ) ; 
break ; 
} 
else break ; 
} 
if ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; 
else ForkJoinTask . rethrow ( ex ) ; 
} 
} 

public class ForkJoinPool { 
private boolean awaitWork ( WorkQueue w , int r ) { 
if ( w == null || w . qlock < 0 ) return false ; 
for ( int pred = w . stackPred , spins = SPINS , ss ; 
; 
) if ( ( ss = w . scanState ) >= 0 ) break ; 
else if ( spins > 0 ) { 
r ^= r << 6 ; 
r ^= r >>> 21 ; 
r ^= r << 7 ; 
if ( r >= 0 && -- spins == 0 ) { 
WorkQueue v ; 
WorkQueue [ ] ws ; 
int s , j ; 
AtomicLong sc ; 
if ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; 
} 
} 
else if ( w . qlock < 0 ) return false ; 
else if ( ! Thread . interrupted ( ) ) { 
long c , prevctl , parkTime , deadline ; 
int ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; 
if ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; 
if ( ac <= 0 && ss == ( int ) c ) { 
prevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; 
int t = ( short ) ( c >>> TC_SHIFT ) ; 
if ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; 
parkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; 
deadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; 
} 
else prevctl = parkTime = deadline = 0L ; 
Thread wt = Thread . currentThread ( ) ; 
U . putObject ( wt , PARKBLOCKER , this ) ; 
w . parker = wt ; 
if ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; 
U . putOrderedObject ( w , QPARKER , null ) ; 
U . putObject ( wt , PARKBLOCKER , null ) ; 
if ( w . scanState >= 0 ) break ; 
if ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; 
} 
return true ; 
} 
} 

public class ForkJoinPool { 
private static ForkJoinPool makeCommonPool ( ) { 
int parallelism = - 1 ; 
ForkJoinWorkerThreadFactory factory = null ; 
UncaughtExceptionHandler handler = null ; 
try { 
String pp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.parallelism" ) ; 
String fp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.threadFactory" ) ; 
String hp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.exceptionHandler" ) ; 
String mp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.maximumSpares" ) ; 
if ( pp != null ) parallelism = Integer . parseInt ( pp ) ; 
if ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; 
if ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; 
if ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; 
} 
catch ( Exception ignore ) { 
} 
if ( factory == null ) if ( System . getSecurityManager ( ) == null ) factory = defaultForkJoinWorkerThreadFactory ; 
else factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; 
if ( parallelism < 0 && ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) parallelism = 1 ; 
if ( parallelism > MAX_CAP ) parallelism = MAX_CAP ; 
return new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , "ForkJoinPool.commonPool-worker-" ) ; 
} 
} 

public class ForkJoinTask { 
public final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { 
int s ; 
long nanos = unit . toNanos ( timeout ) ; 
if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; 
if ( ( s = status ) >= 0 && nanos > 0L ) { 
long d = System . nanoTime ( ) + nanos ; 
long deadline = ( d == 0L ) ? 1L : d ; 
Thread t = Thread . currentThread ( ) ; 
if ( t instanceof ForkJoinWorkerThread ) { 
ForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; 
s = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; 
} 
else if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { 
long ns , ms ; 
while ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) if ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) synchronized ( this ) { 
if ( status >= 0 ) wait ( ms ) ; 
else notifyAll ( ) ; 
} 
} 
} 
if ( s >= 0 ) s = status ; 
if ( ( s &= DONE_MASK ) != NORMAL ) { 
Throwable ex ; 
if ( s == CANCELLED ) throw new CancellationException ( ) ; 
if ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; 
if ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; 
} 
return getRawResult ( ) ; 
} 
} 

public class AThreadPoolImpl { 
@ Override public AThreadPoolStatistics getStatistics ( ) { 
final AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; 
for ( int i = 0 ; 
i < localQueues . length ; 
i ++ ) workerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; 
final ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; 
for ( int i = 0 ; 
i < sharedQueues . length ; 
i ++ ) sharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; 
return new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; 
} 
} 

public class ACollectionHelper { 
public static < T , E extends Throwable > boolean forAll ( Iterable < T > coll , APredicate < ? super T , E > pred ) throws E { 
for ( T o : coll ) { 
if ( ! pred . apply ( o ) ) return false ; 
} 
return true ; 
} 
} 

public class ACollectionHelper { 
public static < T , R , E extends Throwable > R foldRight ( List < T > coll , R startValue , AFunction2 < R , ? super T , R , E > f ) throws E { 
R result = startValue ; 
ListIterator < T > i = coll . listIterator ( coll . size ( ) ) ; 
while ( i . hasPrevious ( ) ) result = f . apply ( result , i . previous ( ) ) ; 
return result ; 
} 
} 

public class LocalQueue { 
void push ( Runnable task ) { 
final long _base = UNSAFE . getLongVolatile ( this , OFFS_BASE ) ; 
final long _top = top ; 
if ( _top == _base + mask ) throw new RejectedExecutionExceptionWithoutStacktrace ( "local queue overflow" ) ; 
tasks [ asArrayindex ( _top ) ] = task ; 
UNSAFE . putLongVolatile ( this , OFFS_TOP , _top + 1 ) ; 
if ( _top - _base <= 1 ) pool . onAvailableTask ( ) ; 
} 
} 

public class UriLoader { 
private String normalizeResourceName ( String name ) { 
if ( name . startsWith ( "//" ) ) return "classpath:" + name ; 
final int firstProtocol = name . indexOf ( "://" ) ; 
final int secondProtocol = name . indexOf ( "://" , firstProtocol + 1 ) ; 
final int protocol = secondProtocol < 0 ? firstProtocol : secondProtocol ; 
final int endOfFirst = name . lastIndexOf ( "/" , protocol ) ; 
if ( endOfFirst >= 0 ) return name . substring ( endOfFirst + 1 ) ; 
return name ; 
} 
} 

public class ValueTypeXmlAdapter { 
@ Override public String marshal ( BoundType v ) throws Exception { 
Class < ? extends Object > type = v . getClass ( ) ; 
if ( ! Types . isUserDefinedValueType ( type ) ) throw new IllegalArgumentException ( "Type [" + type + "] must be an user-defined value type; " + "@XmlJavaTypeAdapter(ValueTypeXmlAdapter.class) " + "can be annotated to user-defined value type and field only" ) ; 
Converter converter = ConvertUtils . lookup ( type ) ; 
if ( ( converter != null && converter instanceof AbstractConverter ) ) { 
String string = ( String ) ConvertUtils . convert ( v , String . class ) ; 
if ( string != null ) return string ; 
} 
return v . toString ( ) ; 
} 
} 

public class EMail { 
public static Future < Boolean > sendMessage ( final Email msg ) { 
if ( asynchronousSend ) return executor . submit ( new Callable < Boolean > ( ) { 
public Boolean call ( ) { 
try { 
msg . setSentDate ( new Date ( ) ) ; 
msg . send ( ) ; 
return true ; 
} 
catch ( Throwable e ) { 
MailException me = new MailException ( "Error while sending email" , e ) ; 
logger . error ( "The email has not been sent" , me ) ; 
return false ; 
} 
} 
} 
) ; 
else { 
final StringBuffer result = new StringBuffer ( ) ; 
try { 
msg . setSentDate ( new Date ( ) ) ; 
msg . send ( ) ; 
} 
catch ( Throwable e ) { 
MailException me = new MailException ( "Error while sending email" , e ) ; 
logger . error ( "The email has not been sent" , me ) ; 
result . append ( "oops" ) ; 
} 
return new Future < Boolean > ( ) { 
public boolean cancel ( boolean mayInterruptIfRunning ) { 
return false ; 
} 
public boolean isCancelled ( ) { 
return false ; 
} 
public boolean isDone ( ) { 
return true ; 
} 
public Boolean get ( ) throws InterruptedException , ExecutionException { 
return result . length ( ) == 0 ; 
} 
public Boolean get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { 
return result . length ( ) == 0 ; 
} 
} 
; 
} 
} 
} 

public class ApplicationRouter { 
public void bind ( final RouteBinding handler ) { 
final Method method = handler . getMethod ( ) ; 
logger . info ( "Using appId: {} and default version: {}" , appAcceptId , defaultVersion ) ; 
List < String > versions = handler . getVersions ( ) ; 
if ( versions == null || versions . isEmpty ( ) ) versions = Collections . singletonList ( defaultVersion ) ; 
for ( final String version : versions ) { 
final Set < Method > methods = new HashSet < > ( ) ; 
if ( method == Method . ANY ) for ( final Method m : Method . values ( ) ) { 
methods . add ( m ) ; 
} 
else methods . add ( method ) ; 
for ( final Method m : methods ) { 
final BindingKey key = new BindingKey ( m , version ) ; 
List < PatternRouteBinding > b = routeBindings . get ( key ) ; 
if ( b == null ) { 
b = new ArrayList < > ( ) ; 
routeBindings . put ( key , b ) ; 
} 
logger . info ( "ADD: {}, Pattern: {}, Route: {}\n" , key , handler . getPath ( ) , handler ) ; 
addPattern ( handler , b ) ; 
} 
} 
} 
} 

public class ApplicationRouter { 
public void bind ( final FilterBinding handler ) { 
final Method method = handler . getMethod ( ) ; 
final String path = handler . getPath ( ) ; 
logger . info ( "Using appId: {} and default version: {}" , appAcceptId , defaultVersion ) ; 
List < String > versions = handler . getVersions ( ) ; 
if ( versions == null || versions . isEmpty ( ) ) versions = Collections . singletonList ( defaultVersion ) ; 
for ( final String version : versions ) { 
final Set < Method > methods = new HashSet < > ( ) ; 
if ( method == Method . ANY ) for ( final Method m : Method . values ( ) ) { 
methods . add ( m ) ; 
} 
else methods . add ( method ) ; 
for ( final Method m : methods ) { 
final BindingKey key = new BindingKey ( m , version ) ; 
logger . info ( "ADD: {}, Pattern: {}, Filter: {}\n" , key , path , handler ) ; 
List < PatternFilterBinding > allFilterBindings = this . filterBindings . get ( key ) ; 
if ( allFilterBindings == null ) { 
allFilterBindings = new ArrayList < > ( ) ; 
this . filterBindings . put ( key , allFilterBindings ) ; 
} 
boolean found = false ; 
for ( final PatternFilterBinding binding : allFilterBindings ) { 
if ( binding . getPattern ( ) . pattern ( ) . equals ( handler . getPath ( ) ) ) { 
binding . addFilter ( handler ) ; 
found = true ; 
break ; 
} 
} 
if ( ! found ) { 
final PatternFilterBinding binding = new PatternFilterBinding ( handler . getPath ( ) , handler ) ; 
allFilterBindings . add ( binding ) ; 
} 
} 
} 
} 
} 

public class HasAnyRolesTag { 
@ Override protected boolean showTagBody ( String roleName ) { 
boolean hasAnyRole = false ; 
Subject subject = getSubject ( ) ; 
if ( subject != null ) for ( String role : roleName . split ( StringPool . COMMA ) ) { 
if ( subject . hasRole ( role . trim ( ) ) ) { 
hasAnyRole = true ; 
break ; 
} 
} 
return hasAnyRole ; 
} 
} 

public class Strs { 
public static String [ ] removeDuplicateStrings ( String [ ] array ) { 
if ( ObjectKit . isEmpty ( array ) ) return array ; 
Set < String > set = new TreeSet < String > ( ) ; 
for ( String element : array ) { 
set . add ( element ) ; 
} 
return toStringArray ( set ) ; 
} 
} 

public class PeriodicService { 
public void doRun ( ) throws Exception { 
if ( inProgress . compareAndSet ( false , true ) ) try { 
run ( ) ; 
} 
finally { 
inProgress . set ( false ) ; 
} 
else throw new IllegalStateException ( "Another run is already in progress" ) ; 
} 
} 

public class SecurityKit { 
public static < T extends Model > boolean login ( T user , String password , boolean remember , HttpServletRequest request , HttpServletResponse response ) { 
boolean matcher = SecurityKit . checkPassword ( user . getStr ( "salt" ) , user . getStr ( "password" ) , password ) ; 
if ( matcher ) SecurityKit . setLoginMember ( request , response , user , remember ) ; 
return matcher ; 
} 
} 

public class SecurityKit { 
public static < T extends Model > T getLoginWithDb ( HttpServletRequest req , HttpServletResponse response , Function < Long , T > function ) { 
T loginUser = getLoginUser ( req ) ; 
if ( loginUser == null ) { 
CookieUser cookie_user = getUserFromCookie ( req ) ; 
if ( cookie_user == null ) return null ; 
T user = CacheKit . get ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) ) ; 
if ( user == null ) { 
user = function . apply ( cookie_user . getId ( ) ) ; 
CacheKit . put ( LOGIN_CACHE_SESSION , LOGIN_CACHE_SESSION + cookie_user . getId ( ) , user ) ; 
} 
if ( user != null && StringUtils . equalsIgnoreCase ( user . getStr ( "password" ) , cookie_user . getPassword ( ) ) ) { 
setLoginMember ( req , response , user , true ) ; 
return user ; 
} 
else return null ; 
} 
else return loginUser ; 
} 
} 

public class SecurityKit { 
private static CookieUser userForCookie ( String uuid , HttpServletRequest request ) { 
if ( StringUtils . isBlank ( uuid ) ) return null ; 
String ck = decrypt ( uuid ) ; 
final String [ ] items = StringUtils . split ( ck , '|' ) ; 
if ( items . length == 5 ) { 
String ua = request . getHeader ( "user-agent" ) ; 
int ua_code = ( ua == null ) ? 0 : ua . hashCode ( ) ; 
int old_ua_code = Integer . parseInt ( items [ 3 ] ) ; 
if ( ua_code == old_ua_code ) return new CookieUser ( NumberUtils . toLong ( items [ 0 ] , - 1L ) , items [ 1 ] , false ) ; 
} 
return null ; 
} 
} 

public class FileRenamePolicyWrapper { 
public String appendFileSeparator ( String path ) { 
if ( null == path ) return File . separator ; 
if ( ! path . startsWith ( StringPool . SLASH ) && ! path . startsWith ( StringPool . BACK_SLASH ) ) path = File . separator + path ; 
if ( ! path . endsWith ( StringPool . SLASH ) && ! path . endsWith ( StringPool . BACK_SLASH ) ) path = path + File . separator ; 
return path ; 
} 
} 

public class Logger { 
public static void debug ( String message , Object ... args ) { 
if ( recordCaller ) LoggerFactory . getLogger ( getCallerClassName ( ) ) . debug ( message , args ) ; 
else slf4j . debug ( message , args ) ; 
} 
} 

public class CharKit { 
public static byte [ ] toSimpleByteArray ( char [ ] carr ) { 
byte [ ] barr = new byte [ carr . length ] ; 
for ( int i = 0 ; 
i < carr . length ; 
i ++ ) barr [ i ] = ( byte ) carr [ i ] ; 
return barr ; 
} 
} 

public class CharKit { 
public static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { 
byte [ ] barr = new byte [ charSequence . length ( ) ] ; 
for ( int i = 0 ; 
i < barr . length ; 
i ++ ) barr [ i ] = ( byte ) charSequence . charAt ( i ) ; 
return barr ; 
} 
} 

public class CharKit { 
public static char [ ] toSimpleCharArray ( byte [ ] barr ) { 
char [ ] carr = new char [ barr . length ] ; 
for ( int i = 0 ; 
i < barr . length ; 
i ++ ) carr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; 
return carr ; 
} 
} 

public class Images { 
public static void crop ( File originalImage , File to , int x1 , int y1 , int x2 , int y2 ) { 
try { 
BufferedImage source = ImageIO . read ( originalImage ) ; 
String mimeType = "image/jpeg" ; 
if ( to . getName ( ) . endsWith ( ".png" ) ) mimeType = "image/png" ; 
if ( to . getName ( ) . endsWith ( ".gif" ) ) mimeType = "image/gif" ; 
int width = x2 - x1 ; 
int height = y2 - y1 ; 
BufferedImage dest = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; 
Image croppedImage = source . getSubimage ( x1 , y1 , width , height ) ; 
Graphics graphics = dest . getGraphics ( ) ; 
graphics . setColor ( Color . WHITE ) ; 
graphics . fillRect ( 0 , 0 , width , height ) ; 
graphics . drawImage ( croppedImage , 0 , 0 , null ) ; 
ImageWriter writer = ImageIO . getImageWritersByMIMEType ( mimeType ) . next ( ) ; 
ImageWriteParam params = writer . getDefaultWriteParam ( ) ; 
writer . setOutput ( new FileImageOutputStream ( to ) ) ; 
IIOImage image = new IIOImage ( dest , null , null ) ; 
writer . write ( null , image , params ) ; 
writer . dispose ( ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class Invoker { 
public static void invokeInThread ( DirectInvocation invocation ) { 
boolean retry = true ; 
while ( retry ) { 
invocation . run ( ) ; 
if ( invocation . retry == null ) retry = false ; 
else { 
try { 
if ( invocation . retry . task != null ) invocation . retry . task . get ( ) ; 
else Thread . sleep ( invocation . retry . timeout ) ; 
} 
catch ( Exception e ) { 
throw new UnexpectedException ( e ) ; 
} 
retry = true ; 
} 
} 
} 
} 

public class Controller { 
protected String parsePath ( String currentActionPath , String url ) { 
if ( url . startsWith ( SLASH ) ) return url . split ( "\\?" ) [ 0 ] ; 
else if ( ! url . contains ( SLASH ) ) return SLASH + currentActionPath . split ( SLASH ) [ 1 ] + SLASH + url . split ( "\\?" ) [ 0 ] ; 
else if ( url . contains ( "http:" ) || url . contains ( "https:" ) ) return null ; 
return currentActionPath + SLASH + url . split ( "\\?" ) [ 0 ] ; 
} 
} 

public class Redirect { 
public void to ( WebContext context ) { 
HttpServletResponse response = context . response ( ) ; 
if ( ! mediaType . isEmpty ( ) ) response . setHeader ( "Content-Type" , mediaType ) ; 
if ( status > 0 ) response . setStatus ( status ) ; 
try { 
response . sendRedirect ( response . encodeRedirectURL ( url ) ) ; 
} 
catch ( IOException e ) { 
throw new UncheckedException ( e ) ; 
} 
} 
} 

public class ExtensionList { 
public List < T > list ( Injector injector ) { 
List < T > r = new ArrayList < T > ( ) ; 
for ( Injector i = injector ; 
i != null ; 
i = i . getParent ( ) ) for ( Entry < Key < ? > , Binding < ? > > e : i . getBindings ( ) . entrySet ( ) ) { 
if ( e . getKey ( ) . getTypeLiteral ( ) . equals ( type ) ) r . add ( ( T ) e . getValue ( ) . getProvider ( ) . get ( ) ) ; 
} 
return r ; 
} 
} 

public class RuntimeKit { 
public static void compactMemory ( ) { 
try { 
final byte [ ] [ ] unused = new byte [ 128 ] [ ] ; 
for ( int i = unused . length ; 
i -- != 0 ; 
) unused [ i ] = new byte [ 2000000000 ] ; 
} 
catch ( OutOfMemoryError ignore ) { 
} 
System . gc ( ) ; 
} 
} 

public class LogUtil { 
@ Nullable public static MetricsCollection propagate ( Metrics metrics ) { 
final MetricsCollection metricsCollection = getLocalMetricsCollection ( ) ; 
if ( metricsCollection != null ) metricsCollection . add ( metrics ) ; 
return metricsCollection ; 
} 
} 

public class LogUtil { 
public static String encodeString ( String value ) { 
int estimatedSize = 0 ; 
final int len = value . length ( ) ; 
for ( int i = 0 ; 
i < len ; 
++ i ) { 
final char ch = value . charAt ( i ) ; 
if ( ch <= ' ' || ch == ',' ) { 
estimatedSize += 3 ; 
continue ; 
} 
++ estimatedSize ; 
} 
if ( value . length ( ) == estimatedSize ) return value ; 
final StringBuilder builder = new StringBuilder ( estimatedSize ) ; 
for ( int i = 0 ; 
i < len ; 
++ i ) { 
final char ch = value . charAt ( i ) ; 
if ( ch <= ' ' ) { 
builder . append ( "%20" ) ; 
continue ; 
} 
if ( ch == ',' ) { 
builder . append ( "%2c" ) ; 
continue ; 
} 
builder . append ( ch ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class StreamUtil { 
public static int copy ( InputStream input , OutputStream output ) throws IOException { 
byte [ ] buffer = new byte [ ioBufferSize ] ; 
int count = 0 ; 
int read ; 
while ( true ) { 
read = input . read ( buffer , 0 , ioBufferSize ) ; 
if ( read == - 1 ) break ; 
output . write ( buffer , 0 , read ) ; 
count += read ; 
} 
return count ; 
} 
} 

public class StreamUtil { 
public static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { 
byte buffer [ ] = new byte [ ioBufferSize ] ; 
int count = 0 ; 
int read ; 
while ( byteCount > 0 ) { 
if ( byteCount < ioBufferSize ) read = input . read ( buffer , 0 , byteCount ) ; 
else read = input . read ( buffer , 0 , ioBufferSize ) ; 
if ( read == - 1 ) break ; 
byteCount -= read ; 
count += read ; 
output . write ( buffer , 0 , read ) ; 
} 
return count ; 
} 
} 

public class StreamUtil { 
public static int copy ( Reader input , Writer output , int charCount ) throws IOException { 
char buffer [ ] = new char [ ioBufferSize ] ; 
int count = 0 ; 
int read ; 
while ( charCount > 0 ) { 
if ( charCount < ioBufferSize ) read = input . read ( buffer , 0 , charCount ) ; 
else read = input . read ( buffer , 0 , ioBufferSize ) ; 
if ( read == - 1 ) break ; 
charCount -= read ; 
count += read ; 
output . write ( buffer , 0 , read ) ; 
} 
return count ; 
} 
} 

public class StreamUtil { 
public static boolean compare ( InputStream input1 , InputStream input2 ) throws IOException { 
if ( ! ( input1 instanceof BufferedInputStream ) ) input1 = new BufferedInputStream ( input1 ) ; 
if ( ! ( input2 instanceof BufferedInputStream ) ) input2 = new BufferedInputStream ( input2 ) ; 
int ch = input1 . read ( ) ; 
while ( ch != - 1 ) { 
int ch2 = input2 . read ( ) ; 
if ( ch != ch2 ) return false ; 
ch = input1 . read ( ) ; 
} 
int ch2 = input2 . read ( ) ; 
return ( ch2 == - 1 ) ; 
} 
} 

public class StreamUtil { 
public static boolean compare ( Reader input1 , Reader input2 ) throws IOException { 
if ( ! ( input1 instanceof BufferedReader ) ) input1 = new BufferedReader ( input1 ) ; 
if ( ! ( input2 instanceof BufferedReader ) ) input2 = new BufferedReader ( input2 ) ; 
int ch = input1 . read ( ) ; 
while ( ch != - 1 ) { 
int ch2 = input2 . read ( ) ; 
if ( ch != ch2 ) return false ; 
ch = input1 . read ( ) ; 
} 
int ch2 = input2 . read ( ) ; 
return ( ch2 == - 1 ) ; 
} 
} 

public class Pipeline { 
@ SuppressWarnings ( "unchecked" ) public T apply ( T io ) { 
logger . debug ( "Pipeline began" ) ; 
try { 
for ( int i = 0 ; 
i < stages . size ( ) ; 
i ++ ) { 
Object stage = stages . get ( i ) ; 
String name = names . get ( stage ) ; 
logger . debug ( "Stage-" + i + ( ( name != null && ! name . isEmpty ( ) ) ? " [" + name + "] " : " " ) + "processing" ) ; 
if ( stage instanceof Function ) if ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) return io ; 
else if ( stage instanceof Predicate ) if ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) return io ; 
} 
return io ; 
} 
finally { 
logger . debug ( "Pipeline ended" ) ; 
} 
} 
} 

public class ZipKit { 
public static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { 
ZipFile zip = new ZipFile ( zipFile ) ; 
Enumeration zipEntries = zip . entries ( ) ; 
while ( zipEntries . hasMoreElements ( ) ) { 
ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; 
String entryName = entry . getName ( ) ; 
if ( patterns != null && patterns . length > 0 ) if ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) continue ; 
File file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; 
if ( entry . isDirectory ( ) ) if ( ! file . mkdirs ( ) ) if ( ! file . isDirectory ( ) ) throw new IOException ( "Failed to create directory: " + file ) ; 
else { 
File parent = file . getParentFile ( ) ; 
if ( parent != null && ! parent . exists ( ) ) if ( ! parent . mkdirs ( ) ) if ( ! file . isDirectory ( ) ) throw new IOException ( "Failed to create directory: " + parent ) ; 
InputStream in = zip . getInputStream ( entry ) ; 
OutputStream out = null ; 
try { 
out = new FileOutputStream ( file ) ; 
StreamUtil . copy ( in , out ) ; 
} 
finally { 
StreamUtil . close ( out ) ; 
StreamUtil . close ( in ) ; 
} 
} 
} 
close ( zip ) ; 
} 
} 

public class Validator { 
public static boolean isBirthDay ( String value ) { 
String check = "(\\d{4})(/|-|\\.)(\\d{1,2})(/|-|\\.)(\\d{1,2})$" ; 
if ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { 
int year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; 
int month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; 
int day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; 
if ( month < 1 || month > 12 ) return false ; 
if ( day < 1 || day > 31 ) return false ; 
if ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) return false ; 
if ( month == 2 ) { 
boolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; 
if ( day > 29 || ( day == 29 && ! isleap ) ) return false ; 
} 
return true ; 
} 
else return false ; 
} 
} 

public class IO { 
public static String readContentAsString ( File file , String encoding ) { 
InputStream is = null ; 
try { 
is = new FileInputStream ( file ) ; 
StringWriter result = new StringWriter ( ) ; 
PrintWriter out = new PrintWriter ( result ) ; 
BufferedReader reader = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; 
String line = null ; 
while ( ( line = reader . readLine ( ) ) != null ) out . println ( line ) ; 
return result . toString ( ) ; 
} 
catch ( IOException e ) { 
throw new UnexpectedException ( e ) ; 
} 
finally { 
if ( is != null ) try { 
is . close ( ) ; 
} 
catch ( Exception e ) { 
} 
} 
} 
} 

public class IO { 
public static void copyDirectory ( File source , File target ) { 
if ( source . isDirectory ( ) ) { 
if ( ! target . exists ( ) ) target . mkdir ( ) ; 
for ( String child : source . list ( ) ) { 
copyDirectory ( new File ( source , child ) , new File ( target , child ) ) ; 
} 
} 
else try { 
write ( new FileInputStream ( source ) , new FileOutputStream ( target ) ) ; 
} 
catch ( IOException e ) { 
throw new UnexpectedException ( e ) ; 
} 
} 
} 

public class ClassKit { 
public static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { 
Preconditions . checkNotNull ( clazz , "Class must not be null" ) ; 
try { 
ClassLoader target = clazz . getClassLoader ( ) ; 
if ( target == null ) return true ; 
ClassLoader cur = classLoader ; 
if ( cur == target ) return true ; 
while ( cur != null ) { 
cur = cur . getParent ( ) ; 
if ( cur == target ) return true ; 
} 
return false ; 
} 
catch ( SecurityException ex ) { 
return true ; 
} 
} 
} 

public class ClassKit { 
public static boolean isAssignable ( Class < ? > lhsType , Class < ? > rhsType ) { 
Preconditions . checkNotNull ( lhsType , "Left-hand side type must not be null" ) ; 
Preconditions . checkNotNull ( rhsType , "Right-hand side type must not be null" ) ; 
if ( lhsType . isAssignableFrom ( rhsType ) ) return true ; 
if ( lhsType . isPrimitive ( ) ) { 
Class < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( rhsType ) ; 
if ( resolvedPrimitive != null && lhsType . equals ( resolvedPrimitive ) ) return true ; 
} 
else { 
Class < ? > resolvedWrapper = primitiveTypeToWrapperMap . get ( rhsType ) ; 
if ( resolvedWrapper != null && lhsType . isAssignableFrom ( resolvedWrapper ) ) return true ; 
} 
return false ; 
} 
} 

public class URITemplate { 
public Map < String , String > variables ( String uri ) { 
Map < String , String > variables = new HashMap < String , String > ( ) ; 
Matcher matcher = pattern . matcher ( uri ) ; 
if ( matcher . matches ( ) ) for ( int i = 0 ; 
i < matcher . groupCount ( ) ; 
i ++ ) variables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; 
return variables ; 
} 
} 

public class DruidDbIntializer { 
public static DruidPlugin druidPlugin ( Properties dbProp ) { 
String dbUrl = dbProp . getProperty ( GojaPropConst . DBURL ) , username = dbProp . getProperty ( GojaPropConst . DBUSERNAME ) , password = dbProp . getProperty ( GojaPropConst . DBPASSWORD ) ; 
if ( ! Strings . isNullOrEmpty ( dbUrl ) ) { 
String dbtype = JdbcUtils . getDbType ( dbUrl , StringUtils . EMPTY ) ; 
String driverClassName ; 
try { 
driverClassName = JdbcUtils . getDriverClassName ( dbUrl ) ; 
} 
catch ( SQLException e ) { 
throw new DatabaseException ( e . getMessage ( ) , e ) ; 
} 
final DruidPlugin druidPlugin = new DruidPlugin ( dbUrl , username , password , driverClassName ) ; 
setValidatorQuery ( dbtype , druidPlugin ) ; 
druidPlugin . addFilter ( new StatFilter ( ) ) ; 
final String initialSize = dbProp . getProperty ( GojaPropConst . DB_INITIAL_SIZE ) ; 
if ( ! Strings . isNullOrEmpty ( initialSize ) ) druidPlugin . setInitialSize ( MoreObjects . firstNonNull ( Ints . tryParse ( initialSize ) , 6 ) ) ; 
final String initial_minidle = dbProp . getProperty ( GojaPropConst . DB_INITIAL_MINIDLE ) ; 
if ( ! Strings . isNullOrEmpty ( initial_minidle ) ) druidPlugin . setMinIdle ( MoreObjects . firstNonNull ( Ints . tryParse ( initial_minidle ) , 5 ) ) ; 
final String initial_maxwait = dbProp . getProperty ( GojaPropConst . DB_INITIAL_MAXWAIT ) ; 
if ( ! Strings . isNullOrEmpty ( initial_maxwait ) ) druidPlugin . setMaxWait ( MoreObjects . firstNonNull ( Ints . tryParse ( initial_maxwait ) , 5 ) ) ; 
final String initial_active = dbProp . getProperty ( GojaPropConst . DB_INITIAL_ACTIVE ) ; 
if ( ! Strings . isNullOrEmpty ( initial_active ) ) druidPlugin . setMaxActive ( MoreObjects . firstNonNull ( Ints . tryParse ( initial_active ) , 5 ) ) ; 
final String timeBetweenEvictionRunsMillis = dbProp . getProperty ( GojaPropConst . DB_TIME_BETWEEN_EVICTION_RUNS_MILLIS ) ; 
if ( ! Strings . isNullOrEmpty ( timeBetweenEvictionRunsMillis ) ) { 
final Integer millis = MoreObjects . firstNonNull ( Ints . tryParse ( timeBetweenEvictionRunsMillis ) , 10000 ) ; 
druidPlugin . setTimeBetweenEvictionRunsMillis ( millis ) ; 
} 
final String minEvictableIdleTimeMillis = dbProp . getProperty ( GojaPropConst . DB_MIN_EVICTABLE_IDLE_TIME_MILLIS ) ; 
if ( ! Strings . isNullOrEmpty ( minEvictableIdleTimeMillis ) ) { 
final Integer idleTimeMillis = MoreObjects . firstNonNull ( Ints . tryParse ( minEvictableIdleTimeMillis ) , 10000 ) ; 
druidPlugin . setMinEvictableIdleTimeMillis ( idleTimeMillis ) ; 
} 
final WallFilter wall = new WallFilter ( ) ; 
wall . setDbType ( dbtype ) ; 
druidPlugin . addFilter ( wall ) ; 
if ( GojaConfig . getPropertyToBoolean ( GojaPropConst . DBLOGFILE , false ) ) druidPlugin . addFilter ( new Slf4jLogFilter ( ) ) ; 
return druidPlugin ; 
} 
return null ; 
} 
} 

public class AbstractRequest { 
protected Object builtin ( Type type ) { 
Class < ? > rawType = Types . getRawType ( type ) ; 
if ( rawType . equals ( WebContext . class ) ) return context ; 
else if ( rawType . equals ( HttpServletRequest . class ) ) return context . request ( ) ; 
else if ( rawType . equals ( HttpServletResponse . class ) ) return context . response ( ) ; 
else if ( rawType . equals ( HttpSession . class ) ) return context . session ( ) ; 
else if ( rawType . equals ( ServletContext . class ) ) return context . application ( ) ; 
else return this ; 
} 
} 

public class AbstractRequest { 
protected Object primitive ( Type type ) { 
Class < ? > rawType = Types . getRawType ( type ) ; 
if ( rawType . equals ( Boolean . TYPE ) ) return ( boolean ) false ; 
else if ( rawType . equals ( Character . TYPE ) ) return ( char ) 0 ; 
else if ( rawType . equals ( Byte . TYPE ) ) return ( byte ) 0 ; 
else if ( rawType . equals ( Double . TYPE ) ) return ( double ) 0.0 ; 
else if ( rawType . equals ( Float . TYPE ) ) return ( float ) 0.0 ; 
else if ( rawType . equals ( Integer . TYPE ) ) return ( int ) 0 ; 
else return ( short ) 0 ; 
} 
} 

public class AbstractRequest { 
protected Object convertUserDefinedValueType ( Object object , Class < ? > type ) { 
if ( type . isAssignableFrom ( object . getClass ( ) ) ) return object ; 
else if ( object instanceof String ) { 
try { 
Constructor < ? > constructor = type . getConstructor ( String . class ) ; 
return constructor . newInstance ( object ) ; 
} 
catch ( Exception e ) { 
logger . debug ( "Cannot invoke [public " + type . getName ( ) + "(String.class)] constrcutor on [" + type + "]" , e ) ; 
} 
try { 
return type . getMethod ( "valueOf" , String . class ) . invoke ( null , object ) ; 
} 
catch ( Exception e1 ) { 
logger . debug ( "Cannot invoke [public static " + type . getName ( ) + ".valueOf(String.class)]" + "method on [" + type + "]" , e1 ) ; 
} 
} 
else logger . warn ( "Parameter [" + object + "] cannot be converted to [" + type + "]" ) ; 
return null ; 
} 
} 

public class AbstractRequest { 
protected Object query ( Type type , String name ) { 
return parameter ( type , name , new Function < String , Object > ( ) { 
public Object apply ( String name ) { 
return context . request ( ) . getParameter ( name ) ; 
} 
} 
, new Function < String , Collection < Object > > ( ) { 
@ SuppressWarnings ( "unchecked" ) public Collection < Object > apply ( String name ) { 
HttpServletRequest request = context . request ( ) ; 
Map < String , Object > map = new TreeMap < String , Object > ( ) ; 
for ( Object object : Collections . list ( request . getParameterNames ( ) ) ) { 
String key = ( String ) object ; 
if ( key . startsWith ( name + "[" ) ) map . put ( key , request . getParameter ( key ) ) ; 
} 
return ( map . isEmpty ( ) ) ? null : map . values ( ) ; 
} 
} 
) ; 
} 
} 

public class AbstractRequest { 
protected Object cookie ( Type type , String name ) { 
return parameter ( type , name , new Function < String , Object > ( ) { 
public Object apply ( String name ) { 
Cookie [ ] cookies = context . request ( ) . getCookies ( ) ; 
if ( cookies != null ) for ( Cookie cookie : cookies ) { 
if ( cookie . getName ( ) . equals ( name ) ) return cookie . getValue ( ) ; 
} 
return null ; 
} 
} 
, new Function < String , Collection < Object > > ( ) { 
public Collection < Object > apply ( String name ) { 
HttpServletRequest request = context . request ( ) ; 
Map < String , Object > map = new TreeMap < String , Object > ( ) ; 
Cookie [ ] cookies = request . getCookies ( ) ; 
if ( cookies != null ) for ( Cookie cookie : cookies ) { 
String key = cookie . getName ( ) ; 
if ( key . startsWith ( name + "[" ) ) map . put ( key , cookie . getValue ( ) ) ; 
} 
return ( map . isEmpty ( ) ) ? null : map . values ( ) ; 
} 
} 
) ; 
} 
} 

public class AbstractRequest { 
protected Object session ( Type type , String name ) { 
return parameter ( type , name , new Function < String , Object > ( ) { 
public Object apply ( String name ) { 
return context . session ( ) . getAttribute ( name ) ; 
} 
} 
, new Function < String , Collection < Object > > ( ) { 
@ SuppressWarnings ( "unchecked" ) public Collection < Object > apply ( String name ) { 
HttpSession session = context . session ( ) ; 
Object attribute = session . getAttribute ( name ) ; 
if ( attribute instanceof Collection < ? > ) return ( Collection < Object > ) attribute ; 
Map < String , Object > map = new TreeMap < String , Object > ( ) ; 
for ( Object object : Collections . list ( session . getAttributeNames ( ) ) ) { 
String key = ( String ) object ; 
if ( key . startsWith ( name + "[" ) ) map . put ( key , session . getAttribute ( key ) ) ; 
} 
return ( map . isEmpty ( ) ) ? null : map . values ( ) ; 
} 
} 
) ; 
} 
} 

public class Goja { 
private void initDataSource ( final Plugins plugins ) { 
final Map < String , Properties > dbConfig = GojaConfig . loadDBConfig ( GojaConfig . getConfigProps ( ) ) ; 
for ( String db_config : dbConfig . keySet ( ) ) { 
final Properties db_props = dbConfig . get ( db_config ) ; 
if ( db_props != null && ! db_props . isEmpty ( ) ) DruidDbIntializer . init ( db_config , plugins , db_props ) ; 
} 
if ( GojaConfig . getPropertyToBoolean ( GojaPropConst . DB_SQLINXML , true ) ) plugins . add ( new SqlInXmlPlugin ( ) ) ; 
} 
} 

public class Goja { 
private void setFtlSharedVariable ( ) { 
final Configuration config = FreeMarkerRender . getConfiguration ( ) ; 
config . setSharedVariable ( "block" , new BlockDirective ( ) ) ; 
config . setSharedVariable ( "extends" , new ExtendsDirective ( ) ) ; 
config . setSharedVariable ( "override" , new OverrideDirective ( ) ) ; 
config . setSharedVariable ( "super" , new SuperDirective ( ) ) ; 
config . setSharedVariable ( "prettytime" , new PrettyTimeDirective ( ) ) ; 
if ( GojaConfig . isSecurity ( ) ) config . setSharedVariable ( "shiro" , new ShiroTags ( config . getObjectWrapper ( ) ) ) ; 
} 
} 

public class RequestPermission { 
private static boolean anyValueDenied ( Object [ ] values , HashMap < Permission , Result > resultMap ) { 
if ( values instanceof Permission [ ] ) { 
Set < Permission > valueSet = new LinkedHashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; 
if ( resultMap . keySet ( ) . containsAll ( valueSet ) ) for ( Object value : values ) { 
if ( Result . DENIED == resultMap . get ( ( Permission ) value ) ) { 
mLog . i ( TAG , "denied - " + value . toString ( ) ) ; 
return true ; 
} 
} 
} 
else if ( values instanceof String [ ] ) { 
Set < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; 
Set < String > permissionSet = new HashSet < > ( ) ; 
for ( Permission perm : resultMap . keySet ( ) ) { 
permissionSet . add ( perm . toString ( ) ) ; 
} 
if ( permissionSet . containsAll ( valueSet ) ) for ( Object value : values ) { 
if ( Result . DENIED == resultMap . get ( Permission . get ( ( String ) value ) ) ) { 
mLog . i ( TAG , "denied - " + value ) ; 
return true ; 
} 
} 
} 
return false ; 
} 
} 

public class ReflectionKit { 
public static boolean declaresException ( Method method , Class < ? > exceptionType ) { 
Preconditions . checkNotNull ( method , "Method must not be null" ) ; 
Class < ? > [ ] declaredExceptions = method . getExceptionTypes ( ) ; 
for ( Class < ? > declaredException : declaredExceptions ) { 
if ( declaredException . isAssignableFrom ( exceptionType ) ) return true ; 
} 
return false ; 
} 
} 

public class ConcurrentSoftHashMap { 
private void processQueue ( ) { 
SoftValue < ? , ? > sv ; 
while ( ( sv = ( SoftValue < ? , ? > ) queue . poll ( ) ) != null ) map . remove ( sv . key ) ; 
} 
} 

public class WildcharUtils { 
public static boolean match ( String string , String pattern ) { 
if ( string . equals ( pattern ) ) return true ; 
return match ( string , pattern , 0 , 0 ) ; 
} 
} 

public class ArgumentHandler { 
public static < A > A readArguments ( Class < A > interfaceClass , String [ ] args ) { 
A result = null ; 
try { 
final ArgumentHandler argumentHandler = new ArgumentHandler ( args ) ; 
result = argumentHandler . getInstance ( interfaceClass ) ; 
argumentHandler . processArguments ( new ArgumentProcessor ( ) { 
@ Override public void process ( List < String > remaining ) throws InvalidArgumentsException { 
if ( remaining . size ( ) > 0 ) throw new InvalidArgumentsException ( "The following arguments could not be understood: " + remaining ) ; 
} 
} 
) ; 
} 
catch ( InvalidArgumentsException e ) { 
System . out . println ( e . getMessage ( ) ) ; 
showUsage ( interfaceClass ) ; 
result = null ; 
} 
if ( result instanceof ArgumentsWithHelp ) if ( ( ( ArgumentsWithHelp ) result ) . getHelp ( ) ) { 
showUsage ( interfaceClass ) ; 
result = null ; 
} 
return result ; 
} 
} 

public class ProtobufSerializerUtils { 
public static final ProtobufEntity getProtobufEntity ( Class < ? > clazz ) { 
final ProtobufEntity protoBufEntity = clazz . getAnnotation ( ProtobufEntity . class ) ; 
if ( protoBufEntity != null ) return protoBufEntity ; 
return null ; 
} 
} 

public class ProtobufSerializerUtils { 
public static final boolean isProtbufEntity ( Class < ? > clazz ) { 
final ProtobufEntity protoBufEntity = getProtobufEntity ( clazz ) ; 
if ( protoBufEntity != null ) return true ; 
return false ; 
} 
} 

public class ProtobufSerializerUtils { 
public static final Map < Field , ProtobufAttribute > getAllProtbufFields ( Class < ? extends Object > fromClazz ) { 
Map < Field , ProtobufAttribute > protoBufFields = CLASS_TO_FIELD_MAP_CACHE . get ( fromClazz . getCanonicalName ( ) ) ; 
if ( protoBufFields != null ) return protoBufFields ; 
else protoBufFields = new HashMap < > ( ) ; 
final List < Field > fields = JReflectionUtils . getAllFields ( new ArrayList < Field > ( ) , fromClazz ) ; 
for ( Field field : fields ) { 
final Annotation annotation = field . getAnnotation ( ProtobufAttribute . class ) ; 
if ( annotation == null ) continue ; 
final ProtobufAttribute gpbAnnotation = ( ProtobufAttribute ) annotation ; 
protoBufFields . put ( field , gpbAnnotation ) ; 
} 
CLASS_TO_FIELD_MAP_CACHE . put ( fromClazz . getCanonicalName ( ) , protoBufFields ) ; 
return protoBufFields ; 
} 
} 

public class ProtobufSerializerUtils { 
public static final String getProtobufGetter ( ProtobufAttribute protobufAttribute , Field field ) { 
final String fieldName = field . getName ( ) ; 
final String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; 
Map < String , String > map = CLASS_TO_FIELD_GETTERS_MAP_CACHE . get ( upperClassName ) ; 
if ( map != null ) if ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) return map . get ( fieldName ) ; 
else map = new ConcurrentHashMap < > ( ) ; 
final String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; 
String getter = "get" + upperCaseFirstFieldName ; 
if ( Collection . class . isAssignableFrom ( field . getType ( ) ) ) getter += "List" ; 
if ( ! protobufAttribute . protobufGetter ( ) . isEmpty ( ) ) return protobufAttribute . protobufGetter ( ) ; 
map . put ( fieldName , getter ) ; 
CLASS_TO_FIELD_GETTERS_MAP_CACHE . put ( upperClassName , map ) ; 
return getter ; 
} 
} 

public class ProtobufSerializerUtils { 
public static final String getPojoSetter ( ProtobufAttribute protobufAttribute , Field field ) { 
final String fieldName = field . getName ( ) ; 
final String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; 
Map < String , String > map = CLASS_TO_FIELD_SETTERS_MAP_CACHE . get ( upperClassName ) ; 
if ( map != null ) if ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) return map . get ( fieldName ) ; 
else map = new ConcurrentHashMap < > ( ) ; 
final String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; 
String setter = "set" + upperCaseFirstFieldName ; 
if ( ! protobufAttribute . pojoSetter ( ) . isEmpty ( ) ) return protobufAttribute . pojoSetter ( ) ; 
map . put ( fieldName , setter ) ; 
CLASS_TO_FIELD_SETTERS_MAP_CACHE . put ( upperClassName , map ) ; 
return setter ; 
} 
} 

public class JsonUtil { 
public static < T > String toJson ( T obj ) { 
StringWriter writer = new StringWriter ( ) ; 
String jsonStr = "" ; 
JsonGenerator gen = null ; 
try { 
gen = getJsonFactory ( ) . createGenerator ( writer ) ; 
getMapper ( ) . writeValue ( gen , obj ) ; 
writer . flush ( ) ; 
jsonStr = writer . toString ( ) ; 
} 
catch ( IOException e ) { 
log . error ( "{}" , e . getMessage ( ) , e ) ; 
} 
finally { 
if ( gen != null ) try { 
gen . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
return jsonStr ; 
} 
} 

public class AttributeInjector { 
protected void copyOutAttributes ( Object target , List < Attribute > jmxAttributeValues , Map < String , Method > attributeSetters , String identifierKey , Object identifier ) { 
for ( Attribute oneAttribute : jmxAttributeValues ) { 
String attributeName = oneAttribute . getName ( ) ; 
Method setter = attributeSetters . get ( attributeName ) ; 
Object value = oneAttribute . getValue ( ) ; 
try { 
if ( ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( Integer . class ) ) || ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( int . class ) ) ) if ( value instanceof Long ) value = ( ( Long ) value ) . intValue ( ) ; 
setter . invoke ( target , value ) ; 
} 
catch ( InvocationTargetException invocationExc ) { 
this . log . info ( "invocation exception storing mbean results: {}={}; attributeName={}" , identifierKey , identifier , attributeName , invocationExc ) ; 
} 
catch ( IllegalAccessException illegalAccessExc ) { 
this . log . info ( "illegal access exception storing mbean results: {}={}; attributeName={}" , identifierKey , identifier , attributeName , illegalAccessExc ) ; 
} 
catch ( IllegalArgumentException illegalArgumentExc ) { 
this . log . info ( "illegal argument exception storing mbean results: {}={}; attributeName={}" , identifierKey , identifier , attributeName , illegalArgumentExc ) ; 
} 
} 
} 
} 

public class ClassLoaderUtils { 
public static ClassLoader getDefault ( ) { 
ClassLoader loader = null ; 
try { 
loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
} 
catch ( Exception e ) { 
} 
if ( loader == null ) { 
loader = ClassLoaderUtils . class . getClassLoader ( ) ; 
if ( loader == null ) loader = ClassLoader . getSystemClassLoader ( ) ; 
} 
return loader ; 
} 
} 

public class ClassLoaderUtils { 
public static URL getResource ( String name , ClassLoader classLoader ) { 
Validate . notNull ( name , "resourceName must be not null" ) ; 
if ( name . startsWith ( "/" ) ) name = name . substring ( 1 ) ; 
if ( classLoader != null ) { 
URL url = classLoader . getResource ( name ) ; 
if ( url != null ) return url ; 
} 
ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
if ( loader != null && loader != classLoader ) { 
URL url = loader . getResource ( name ) ; 
if ( url != null ) return url ; 
} 
return ClassLoader . getSystemResource ( name ) ; 
} 
} 

public class ClassLoaderUtils { 
public static InputStream getResourceAsStream ( String name , ClassLoader classLoader ) throws IOException { 
URL url = getResource ( name , classLoader ) ; 
if ( url != null ) return url . openStream ( ) ; 
return null ; 
} 
} 

public class URI { 
private void initializePath ( String p_uriSpec ) throws MalformedURIException { 
if ( p_uriSpec == null ) throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; 
int index = 0 ; 
int start = 0 ; 
int end = p_uriSpec . length ( ) ; 
char testChar = '\0' ; 
while ( index < end ) { 
testChar = p_uriSpec . charAt ( index ) ; 
if ( testChar == '?' || testChar == '#' ) break ; 
if ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) throw new MalformedURIException ( "Path contains invalid escape sequence!" ) ; 
else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) throw new MalformedURIException ( "Path contains invalid character: " + testChar ) ; 
index ++ ; 
} 
m_path = p_uriSpec . substring ( start , index ) ; 
if ( testChar == '?' ) { 
index ++ ; 
start = index ; 
while ( index < end ) { 
testChar = p_uriSpec . charAt ( index ) ; 
if ( testChar == '#' ) break ; 
if ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; 
else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; 
index ++ ; 
} 
m_queryString = p_uriSpec . substring ( start , index ) ; 
} 
if ( testChar == '#' ) { 
index ++ ; 
start = index ; 
while ( index < end ) { 
testChar = p_uriSpec . charAt ( index ) ; 
if ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; 
else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; 
index ++ ; 
} 
m_fragment = p_uriSpec . substring ( start , index ) ; 
} 
} 
} 

public class URI { 
private void setScheme ( String p_scheme ) throws MalformedURIException { 
if ( p_scheme == null ) throw new MalformedURIException ( "Cannot set scheme from null string!" ) ; 
if ( ! isConformantSchemeName ( p_scheme ) ) throw new MalformedURIException ( "The scheme is not conformant." ) ; 
m_scheme = p_scheme ; 
} 
} 

public class URI { 
private void setUserinfo ( String p_userinfo ) throws MalformedURIException { 
if ( p_userinfo == null ) m_userinfo = null ; 
else { 
if ( m_host == null ) throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; 
int index = 0 ; 
int end = p_userinfo . length ( ) ; 
char testChar = '\0' ; 
while ( index < end ) { 
testChar = p_userinfo . charAt ( index ) ; 
if ( testChar == '%' ) if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; 
else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; 
index ++ ; 
} 
} 
m_userinfo = p_userinfo ; 
} 
} 

public class URI { 
private void setHost ( String p_host ) throws MalformedURIException { 
if ( p_host == null || p_host . length ( ) == 0 ) { 
m_host = p_host ; 
m_userinfo = null ; 
m_port = null ; 
n_port = - 1 ; 
} 
else if ( ! isWellFormedAddress ( p_host ) ) throw new MalformedURIException ( "Host is not a well formed address!" ) ; 
m_host = p_host ; 
} 
} 

public class URI { 
private void setPort ( int p_port ) throws MalformedURIException { 
if ( p_port >= 0 && p_port <= 65535 ) if ( m_host == null ) throw new MalformedURIException ( "Port cannot be set when host is null!" ) ; 
else if ( p_port != - 1 ) throw new MalformedURIException ( "Invalid port number!" ) ; 
n_port = p_port ; 
} 
} 

public class URI { 
private void appendPath ( String p_addToPath ) throws MalformedURIException { 
if ( p_addToPath == null || p_addToPath . length ( ) == 0 ) return ; 
if ( ! isURIString ( p_addToPath ) ) throw new MalformedURIException ( "Path contains invalid character!" ) ; 
if ( m_path == null || m_path . length ( ) == 0 ) if ( p_addToPath . startsWith ( "/" ) ) m_path = p_addToPath ; 
else m_path = "/" + p_addToPath ; 
else if ( m_path . endsWith ( "/" ) ) if ( p_addToPath . startsWith ( "/" ) ) m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; 
else m_path = m_path . concat ( p_addToPath ) ; 
else if ( p_addToPath . startsWith ( "/" ) ) m_path = m_path . concat ( p_addToPath ) ; 
else m_path = m_path . concat ( "/" + p_addToPath ) ; 
} 
} 

public class URI { 
private void setQueryString ( String p_queryString ) throws MalformedURIException { 
if ( p_queryString == null ) m_queryString = null ; 
else if ( ! isGenericURI ( ) ) throw new MalformedURIException ( "Query string can only be set for a generic URI!" ) ; 
else if ( getPath ( ) == null ) throw new MalformedURIException ( "Query string cannot be set when path is null!" ) ; 
else if ( ! isURIString ( p_queryString ) ) throw new MalformedURIException ( "Query string contains invalid character!" ) ; 
else m_queryString = p_queryString ; 
} 
} 

public class URI { 
public void setFragment ( String p_fragment ) throws MalformedURIException { 
if ( p_fragment == null ) m_fragment = null ; 
else if ( ! isGenericURI ( ) ) throw new MalformedURIException ( "Fragment can only be set for a generic URI!" ) ; 
else if ( getPath ( ) == null ) throw new MalformedURIException ( "Fragment cannot be set when path is null!" ) ; 
else if ( ! isURIString ( p_fragment ) ) throw new MalformedURIException ( "Fragment contains invalid character!" ) ; 
else m_fragment = p_fragment ; 
} 
} 

public class PreparedStatementCreator { 
protected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { 
PreparedStatement ps = conn . prepareStatement ( sql ) ; 
if ( parameters != null ) { 
int index = 1 ; 
while ( parameters . hasNext ( ) ) { 
Object parameter = parameters . next ( ) ; 
if ( parameter == null ) ps . setObject ( index , null ) ; 
else ps . setObject ( index , parameter ) ; 
index ++ ; 
} 
} 
return ps ; 
} 
} 

public class MuffinManager { 
public Transferable getClipboardContents ( ) { 
if ( ( clipboardReadStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) return null ; 
clipboardReadStatus = CLIPBOARD_DISABLED ; 
if ( cs == null ) try { 
cs = ( ClipboardService ) ServiceManager . lookup ( "javax.jnlp.ClipboardService" ) ; 
} 
catch ( UnavailableServiceException e ) { 
cs = null ; 
} 
if ( cs != null ) { 
Transferable tr = cs . getContents ( ) ; 
if ( tr != null ) clipboardReadStatus = CLIPBOARD_ENABLED ; 
return tr ; 
} 
return null ; 
} 
} 

public class MuffinManager { 
public boolean setClipboardContents ( Transferable data ) { 
if ( data == null ) return false ; 
if ( ( clipboardWriteStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) return false ; 
clipboardWriteStatus = CLIPBOARD_ENABLED ; 
if ( cs == null ) try { 
cs = ( ClipboardService ) ServiceManager . lookup ( "javax.jnlp.ClipboardService" ) ; 
} 
catch ( UnavailableServiceException e ) { 
cs = null ; 
} 
if ( cs != null ) try { 
cs . setContents ( data ) ; 
clipboardWriteStatus = CLIPBOARD_ENABLED ; 
return true ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
} 
return false ; 
} 
} 

public class MuffinManager { 
public InputStream openFileStream ( String pathHint , String [ ] extensions ) { 
if ( fos == null ) try { 
fos = ( FileOpenService ) ServiceManager . lookup ( "javax.jnlp.FileOpenService" ) ; 
} 
catch ( UnavailableServiceException e ) { 
fos = null ; 
} 
if ( fos != null ) try { 
FileContents fc = fos . openFileDialog ( pathHint , extensions ) ; 
return fc . getInputStream ( ) ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
} 
return null ; 
} 
} 

public class ServiceManager { 
public static void setServiceParams ( ParametrizedOperation op , Map < String , Object > params ) { 
if ( params != null ) for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { 
op . setParam ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
} 
} 

public class FastBuffer { 
@ Override public Iterator < E > iterator ( ) { 
return new Iterator < E > ( ) { 
int iteratorIndex ; 
int iteratorBufferIndex ; 
int iteratorOffset ; 
@ Override public boolean hasNext ( ) { 
return iteratorIndex < size ; 
} 
@ Override public E next ( ) { 
if ( iteratorIndex >= size ) throw new NoSuchElementException ( ) ; 
E [ ] buf = buffers [ iteratorBufferIndex ] ; 
E result = buf [ iteratorOffset ] ; 
iteratorIndex ++ ; 
iteratorOffset ++ ; 
if ( iteratorOffset >= buf . length ) { 
iteratorOffset = 0 ; 
iteratorBufferIndex ++ ; 
} 
return result ; 
} 
@ Override public void remove ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
} 
} 

public class JdbcLogDriver { 
@ Override public java . util . logging . Logger getParentLogger ( ) throws SQLFeatureNotSupportedException { 
if ( drivers . size ( ) == 1 ) return getFirstDriver ( ) . getParentLogger ( ) ; 
return null ; 
} 
} 

public class StringEnumeratedMap { 
protected Map < String , V > getAsMap ( ) { 
Map < String , V > result = map ; 
if ( result == null ) synchronized ( this ) { 
result = map ; 
if ( result == null ) map = ( result = initialize ( ) ) ; 
} 
return result ; 
} 
} 

public class ReflexUtil { 
public static < T > void makeAccessible ( final Constructor < T > constructor ) { 
if ( ! Modifier . isPublic ( constructor . getModifiers ( ) ) || ! Modifier . isPublic ( constructor . getDeclaringClass ( ) . getModifiers ( ) ) ) constructor . setAccessible ( true ) ; 
} 
} 

public class ObjectQueryPreparer { 
public ObjectQueryInfo prepareObjectQuery ( Object obj ) throws MalformedObjectNameException { 
ObjectQueryInfo result ; 
String onamePattern = MBeanAnnotationUtil . getLocationONamePattern ( obj ) ; 
if ( onamePattern != null ) { 
Map < String , Method > attributeSetters = MBeanAnnotationUtil . getAttributes ( obj ) ; 
if ( attributeSetters . size ( ) > 0 ) { 
String onameString ; 
if ( obj instanceof MBeanLocationParameterSource ) onameString = this . parameterReplacer . replaceObjectNameParameters ( onamePattern , ( MBeanLocationParameterSource ) obj ) ; 
else onameString = onamePattern ; 
ObjectName oname = new ObjectName ( onameString ) ; 
result = new ObjectQueryInfo ( obj , oname , attributeSetters ) ; 
} 
else { 
this . logNoAttributeThrottle . warn ( log , "ignoring attempt to prepare to poll an MBean object with no attributes: onamePattern={}" , onamePattern ) ; 
result = null ; 
} 
} 
else { 
log . warn ( "ignoring attempt to prepare to poll object that has no MBeanLocation" ) ; 
result = null ; 
} 
return result ; 
} 
} 

public class Util { 
public static String replaceSlashWithHyphen ( String origin ) { 
char [ ] resulltChars = origin . toCharArray ( ) ; 
for ( int i = 0 ; 
i < resulltChars . length - 1 ; 
i ++ ) if ( resulltChars [ i ] == '/' ) resulltChars [ i ] = '-' ; 
return new String ( resulltChars , 0 , resulltChars . length - 1 ) ; 
} 
} 

public class Util { 
public static String bytes2HexString ( byte [ ] bytes ) { 
StringBuffer resultBuffer = new StringBuffer ( ) ; 
for ( int i = 0 ; 
i < bytes . length ; 
i ++ ) resultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; 
return resultBuffer . toString ( ) ; 
} 
} 

public class NamedParameterStatement { 
private List < Integer > getIndexes ( String name ) { 
List < Integer > indexes = nameIndexMap . get ( name ) ; 
if ( indexes == null ) throw new IllegalArgumentException ( "Parameter not found: " + name ) ; 
return indexes ; 
} 
} 

public class NamedParameterStatement { 
private static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { 
int length = sql . length ( ) ; 
StringBuffer parsedSql = new StringBuffer ( length ) ; 
boolean inSingleQuote = false ; 
boolean inDoubleQuote = false ; 
int index = 1 ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) { 
char c = sql . charAt ( i ) ; 
if ( inSingleQuote ) if ( c == '\'' ) inSingleQuote = false ; 
else if ( inDoubleQuote ) if ( c == '"' ) inDoubleQuote = false ; 
else if ( c == '\'' ) inSingleQuote = true ; 
else if ( c == '"' ) inDoubleQuote = true ; 
else if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { 
int j = i + 2 ; 
while ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) j ++ ; 
String name = sql . substring ( i + 1 , j ) ; 
c = '?' ; 
i += name . length ( ) ; 
List < Integer > indexList = nameIndexMap . get ( name ) ; 
if ( indexList == null ) { 
indexList = new LinkedList < Integer > ( ) ; 
nameIndexMap . put ( name , indexList ) ; 
} 
indexList . add ( index ) ; 
index ++ ; 
} 
parsedSql . append ( c ) ; 
} 
return parsedSql . toString ( ) ; 
} 
} 

public class ProtobufSerializer { 
private static final Object convertCollectionToProtobufs ( Collection < Object > collectionOfNonProtobufs ) throws JException { 
if ( collectionOfNonProtobufs . isEmpty ( ) ) return collectionOfNonProtobufs ; 
final Object first = collectionOfNonProtobufs . toArray ( ) [ 0 ] ; 
if ( ! ProtobufSerializerUtils . isProtbufEntity ( first ) ) return collectionOfNonProtobufs ; 
final Collection < Object > newCollectionValues ; 
if ( collectionOfNonProtobufs instanceof Set ) newCollectionValues = new HashSet < > ( ) ; 
else newCollectionValues = new ArrayList < > ( ) ; 
for ( Object iProtobufGenObj : collectionOfNonProtobufs ) { 
newCollectionValues . add ( serializeToProtobufEntity ( iProtobufGenObj ) ) ; 
} 
return newCollectionValues ; 
} 
} 

public class FileExtensionFilter { 
public boolean accept ( File pathname ) { 
String name = pathname . getName ( ) ; 
int iLastDot = name . lastIndexOf ( '.' ) ; 
String strExtension = "" ; 
if ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; 
if ( m_rgstrIncludeExtensions != null ) { 
for ( int i = 0 ; 
i < m_rgstrIncludeExtensions . length ; 
i ++ ) if ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; 
return false ; 
} 
if ( m_rgstrExcludeExtensions != null ) for ( int i = 0 ; 
i < m_rgstrExcludeExtensions . length ; 
i ++ ) if ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; 
return true ; 
} 
} 

public class StateParser { 
private static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { 
final Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; 
final List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; 
for ( int index = 0 ; 
index < labels . size ( ) ; 
index ++ ) { 
final String next = labels . get ( index ) ; 
ExpectedLabels labelValue ; 
try { 
labelValue = ExpectedLabels . valueOf ( next ) ; 
unusedLabels . remove ( labelValue ) ; 
if ( map . containsKey ( labelValue ) ) LOGGER . warn ( "Duplicate state label: {} ({})" , next , labels ) ; 
map . put ( labelValue , index ) ; 
} 
catch ( final IllegalArgumentException e ) { 
LOGGER . warn ( "Unexpected state label: {}" , next ) ; 
} 
} 
for ( final ExpectedLabels label : unusedLabels ) { 
LOGGER . warn ( "Unused label: {}" , label ) ; 
} 
return map ; 
} 
} 

public class JmxAttributePoller { 
public void poll ( ) throws IOException { 
synchronized ( this ) { 
if ( shutdownInd ) return ; 
pollActiveInd = true ; 
} 
try { 
this . checkConnection ( ) ; 
this . concurrencyTestHooks . beforePollProcessorStart ( ) ; 
if ( this . mBeanAccessConnection instanceof MBeanBatchCapableAccessConnection ) this . batchPollProcessor . pollBatch ( ( MBeanBatchCapableAccessConnection ) this . mBeanAccessConnection , this . polledObjects ) ; 
else this . pollIndividually ( ) ; 
} 
catch ( IOException ioExc ) { 
this . safeClose ( this . mBeanAccessConnection ) ; 
this . mBeanAccessConnection = null ; 
throw ioExc ; 
} 
finally { 
this . concurrencyTestHooks . afterPollProcessorFinish ( ) ; 
synchronized ( this ) { 
pollActiveInd = false ; 
this . notifyAll ( ) ; 
} 
} 
} 
} 

public class JmxAttributePoller { 
protected boolean pollIndividually ( ) throws IOException { 
this . concurrencyTestHooks . onStartPollIndividually ( ) ; 
List < SchedulerProcessExecutionSlip > processExecutionSlipList = new LinkedList < > ( ) ; 
for ( final Object onePolledObject : this . polledObjects ) { 
if ( shutdownInd ) return true ; 
SchedulerProcess process = new PollOneObjectSchedulerProcess ( onePolledObject ) ; 
SchedulerProcessExecutionSlip executionSlip = this . scheduler . startProcess ( process ) ; 
processExecutionSlipList . add ( executionSlip ) ; 
} 
for ( SchedulerProcessExecutionSlip oneExecutionSlip : processExecutionSlipList ) { 
try { 
oneExecutionSlip . waitUntilComplete ( ) ; 
PollOneObjectSchedulerProcess process = ( PollOneObjectSchedulerProcess ) oneExecutionSlip . getSchedulerProcess ( ) ; 
Exception exc = process . getFailureException ( ) ; 
if ( exc != null ) { 
log . warn ( "failed to poll object" , exc ) ; 
if ( exc instanceof IOException ) throw ( IOException ) exc ; 
} 
} 
catch ( InterruptedException intExc ) { 
log . info ( "interrupted while polling object" ) ; 
} 
} 
return false ; 
} 
} 

public class ClassUtil { 
public static Field getDeclaredField ( Class < ? > clazz , String fieldName , boolean recursively ) { 
try { 
return clazz . getDeclaredField ( fieldName ) ; 
} 
catch ( NoSuchFieldException e ) { 
Class < ? > superClass = clazz . getSuperclass ( ) ; 
if ( superClass != null && recursively ) return getDeclaredField ( superClass , fieldName , true ) ; 
} 
catch ( SecurityException e ) { 
log . error ( "{}" , e . getMessage ( ) , e ) ; 
} 
return null ; 
} 
} 

public class ClassUtil { 
public static Method getDeclaredMethod ( Class < ? > clazz , boolean recursively , String methodName , Class < ? > ... parameterTypes ) { 
try { 
return clazz . getDeclaredMethod ( methodName , parameterTypes ) ; 
} 
catch ( NoSuchMethodException e ) { 
Class < ? > superClass = clazz . getSuperclass ( ) ; 
if ( superClass != null && recursively ) return getDeclaredMethod ( superClass , true , methodName , parameterTypes ) ; 
} 
catch ( SecurityException e ) { 
log . error ( "{}" , e . getMessage ( ) , e ) ; 
} 
return null ; 
} 
} 

public class DebugOutputStream { 
protected void dumpByte ( int b ) { 
if ( passThrough == true ) System . out . print ( '\t' ) ; 
if ( b < 0 ) b += 128 ; 
if ( b < 0x10 ) System . out . print ( '0' ) ; 
System . out . print ( ' ' ) ; 
System . out . print ( Integer . toHexString ( b ) . toUpperCase ( ) ) ; 
} 
} 

public class StringUtils { 
public static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { 
if ( startIndex < 0 ) startIndex = 0 ; 
int srclen = s . length ( ) ; 
if ( endIndex > srclen ) endIndex = srclen ; 
int sublen = substr . length ( ) ; 
if ( sublen == 0 ) return startIndex > srclen ? srclen : startIndex ; 
substr = substr . toLowerCase ( ) ; 
int total = endIndex - sublen + 1 ; 
char c = substr . charAt ( 0 ) ; 
mainloop : for ( int i = startIndex ; 
i < total ; 
i ++ ) { 
if ( Character . toLowerCase ( s . charAt ( i ) ) != c ) continue ; 
int j = 1 ; 
int k = i + 1 ; 
while ( j < sublen ) { 
char source = Character . toLowerCase ( s . charAt ( k ) ) ; 
if ( substr . charAt ( j ) != source ) continue mainloop ; 
j ++ ; 
k ++ ; 
} 
return i ; 
} 
return - 1 ; 
} 
} 

public class StringUtils { 
public static String removeChars ( String s , String chars ) { 
int i = s . length ( ) ; 
StringBuilder sb = new StringBuilder ( i ) ; 
for ( int j = 0 ; 
j < i ; 
j ++ ) { 
char c = s . charAt ( j ) ; 
if ( chars . indexOf ( c ) == - 1 ) sb . append ( c ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class PasswordLoginModule { 
@ SuppressWarnings ( "PMD.ConfusingTernary" ) private void initAudit ( final CommonProperties commonProps ) { 
try { 
final String auditClassName = commonProps . getAuditClassName ( ) ; 
if ( ! commonProps . isAuditEnabled ( ) ) { 
final String error = "Auditing has been disabled in the JAAS configuration" ; 
LOG . info ( error ) ; 
} 
else if ( auditClassName == null ) { 
final String error = "Auditing has been enabled in the JAAS configuration, but no audit class has been configured" ; 
LOG . error ( error ) ; 
throw new IllegalStateException ( error ) ; 
} 
else if ( commonProps . isAuditSingleton ( ) ) { 
LOG . debug ( "Requesting singleton audit class instance of '" + auditClassName + "' from the audit factory" ) ; 
this . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; 
} 
else { 
LOG . debug ( "Requesting non-singleton audit class instance of '" + auditClassName + "' from the audit factory" ) ; 
this . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; 
} 
} 
catch ( FactoryException e ) { 
final String error = "The audit class cannot be instantiated. This is most likely a configuration" + " problem. Is the configured class available in the classpath?" ; 
LOG . error ( error , e ) ; 
throw new IllegalStateException ( error , e ) ; 
} 
} 
} 

public class PasswordLoginModule { 
@ SuppressWarnings ( "PMD.ConfusingTernary" ) private void initMessageQueue ( final CommonProperties commonProps ) { 
try { 
final String messageClassName = commonProps . getMessageQueueClassName ( ) ; 
if ( ! commonProps . isMessageQueueEnabled ( ) ) { 
final String error = "Message queue has been disabled in the JAAS configuration" ; 
LOG . info ( error ) ; 
} 
else if ( messageClassName == null ) { 
final String error = "Message queue has been enabled in the JAAS configuration, " + "but no message queue class has been configured" ; 
LOG . error ( error ) ; 
throw new IllegalStateException ( error ) ; 
} 
else if ( commonProps . isMessageQueueSingleton ( ) ) { 
LOG . debug ( "Requesting singleton message class instance of '" + messageClassName + "' from the message factory" ) ; 
this . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; 
} 
else { 
LOG . debug ( "Requesting non-singleton message class instance of '" + messageClassName + "' from the message factory" ) ; 
this . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; 
} 
} 
catch ( FactoryException e ) { 
final String error = "The message class cannot be instantiated. This is most likely a configuration" + " problem. Is the configured class available in the classpath?" ; 
LOG . error ( error , e ) ; 
throw new IllegalStateException ( error , e ) ; 
} 
} 
} 

public class PasswordLoginModule { 
private void initPwValidator ( final CommonProperties commonProps ) { 
try { 
final String validatorClass = commonProps . getPasswordValidatorClassName ( ) ; 
if ( validatorClass == null ) { 
final String error = "No password validator class has been configured in the JAAS configuration" ; 
LOG . error ( error ) ; 
throw new IllegalStateException ( error ) ; 
} 
else if ( commonProps . isPasswordValidatorSingleton ( ) ) { 
LOG . debug ( "Requesting singleton validator class instance of '" + validatorClass + "' from the validator factory" ) ; 
this . pwValidator = PasswordValidatorFactory . getSingleton ( validatorClass , commonProps ) ; 
} 
else { 
LOG . debug ( "Requesting non-singleton validator class instance of '" + validatorClass + "' from the validator factory" ) ; 
this . pwValidator = PasswordValidatorFactory . getInstance ( validatorClass , commonProps ) ; 
} 
} 
catch ( FactoryException e ) { 
final String error = "The validator class cannot be instantiated. This is most likely a configuration" + " problem. Is the configured class available in the classpath?" ; 
LOG . error ( error , e ) ; 
throw new IllegalStateException ( error , e ) ; 
} 
} 
} 

public class PasswordLoginModule { 
private void initPwAuthenticator ( final CommonProperties commonProps ) { 
try { 
final String authNticatorClass = commonProps . getPasswordAuthenticatorClassName ( ) ; 
if ( authNticatorClass == null ) { 
final String error = "No password authenticator class has been configured in the JAAS configuration" ; 
LOG . error ( error ) ; 
throw new IllegalStateException ( error ) ; 
} 
else if ( commonProps . isPasswordAuthenticatorSingleton ( ) ) { 
LOG . debug ( "Requesting singleton authenticator class instance of '" + authNticatorClass + "' from the authenticator factory" ) ; 
this . pwAuthenticator = PasswordAuthenticatorFactory . getSingleton ( authNticatorClass , commonProps ) ; 
} 
else { 
LOG . debug ( "Requesting non-singleton authenticator class instance of '" + authNticatorClass + "' from the authenticator factory" ) ; 
this . pwAuthenticator = PasswordAuthenticatorFactory . getInstance ( authNticatorClass , commonProps ) ; 
} 
} 
catch ( FactoryException e ) { 
final String error = "The validator class cannot be instantiated. This is most likely a configuration" + " problem. Is the configured class available in the classpath?" ; 
LOG . error ( error , e ) ; 
throw new IllegalStateException ( error , e ) ; 
} 
} 
} 

public class ArrayStack { 
public void clear ( ) { 
int i = size ; 
Object [ ] els = elements ; 
while ( i -- > 0 ) els [ i ] = null ; 
this . size = 0 ; 
} 
} 

public class ArrayStack { 
public T push ( T element ) { 
int i ; 
Object [ ] els ; 
if ( ( i = size ++ ) >= ( els = elements ) . length ) System . arraycopy ( els , 0 , els = elements = new Object [ i << 1 ] , 0 , i ) ; 
els [ i ] = element ; 
return element ; 
} 
} 

public class WildcharPathUtils { 
protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { 
int patNdxStart = 0 ; 
int patNdxEnd = patterns . length - 1 ; 
int tokNdxStart = 0 ; 
int tokNdxEnd = tokens . length - 1 ; 
while ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { 
String patDir = patterns [ patNdxStart ] ; 
if ( patDir . equals ( PATH_MATCH ) ) break ; 
if ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) return false ; 
patNdxStart ++ ; 
tokNdxStart ++ ; 
} 
if ( tokNdxStart > tokNdxEnd ) { 
for ( int i = patNdxStart ; 
i <= patNdxEnd ; 
i ++ ) if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) return false ; 
return true ; 
} 
if ( patNdxStart > patNdxEnd ) return false ; 
while ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { 
String patDir = patterns [ patNdxEnd ] ; 
if ( patDir . equals ( PATH_MATCH ) ) break ; 
if ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) return false ; 
patNdxEnd -- ; 
tokNdxEnd -- ; 
} 
if ( tokNdxStart > tokNdxEnd ) { 
for ( int i = patNdxStart ; 
i <= patNdxEnd ; 
i ++ ) if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) return false ; 
return true ; 
} 
while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { 
int patIdxTmp = - 1 ; 
for ( int i = patNdxStart + 1 ; 
i <= patNdxEnd ; 
i ++ ) if ( patterns [ i ] . equals ( PATH_MATCH ) ) { 
patIdxTmp = i ; 
break ; 
} 
if ( patIdxTmp == patNdxStart + 1 ) { 
patNdxStart ++ ; 
continue ; 
} 
int patLength = ( patIdxTmp - patNdxStart - 1 ) ; 
int strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; 
int ndx = - 1 ; 
strLoop : for ( int i = 0 ; 
i <= strLength - patLength ; 
i ++ ) { 
for ( int j = 0 ; 
j < patLength ; 
j ++ ) { 
String subPat = patterns [ patNdxStart + j + 1 ] ; 
String subStr = tokens [ tokNdxStart + i + j ] ; 
if ( ! WildcharUtils . match ( subStr , subPat ) ) continue strLoop ; 
} 
ndx = tokNdxStart + i ; 
break ; 
} 
if ( ndx == - 1 ) return false ; 
patNdxStart = patIdxTmp ; 
tokNdxStart = ndx + patLength ; 
} 
for ( int i = patNdxStart ; 
i <= patNdxEnd ; 
i ++ ) if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) return false ; 
return true ; 
} 
} 

public class Rectangular { 
public Rectangular intersection ( Rectangular other ) { 
if ( this . intersects ( other ) ) return new Rectangular ( Math . max ( x1 , other . x1 ) , Math . max ( y1 , other . y1 ) , Math . min ( x2 , other . x2 ) , Math . min ( y2 , other . y2 ) ) ; 
else return new Rectangular ( ) ; 
} 
} 

public class AreaGrid { 
private void calculateRows ( ) { 
GridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; 
int pi = 0 ; 
for ( Area area : areas ) { 
points [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; 
points [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; 
pi += 2 ; 
} 
Arrays . sort ( points ) ; 
int cnt = 0 ; 
int last = abspos . getY1 ( ) ; 
for ( int i = 0 ; 
i < points . length ; 
i ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { 
last = points [ i ] . value ; 
cnt ++ ; 
} 
if ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; 
height = cnt ; 
rows = new int [ height ] ; 
cnt = 0 ; 
last = abspos . getY1 ( ) ; 
for ( int i = 0 ; 
i < points . length ; 
i ++ ) { 
if ( ! theSame ( points [ i ] . value , last ) ) { 
rows [ cnt ] = points [ i ] . value - last ; 
last = points [ i ] . value ; 
cnt ++ ; 
} 
if ( points [ i ] . begin ) target . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; 
else { 
Rectangular pos = target . getPosition ( points [ i ] . area ) ; 
pos . setY2 ( cnt - 1 ) ; 
if ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; 
} 
} 
if ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; 
} 
} 

public class JdbcLogSupport { 
protected Throwable unwrapThrowable ( Throwable t ) { 
Throwable e = t ; 
while ( true ) if ( e instanceof InvocationTargetException ) e = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; 
else if ( t instanceof UndeclaredThrowableException ) e = ( ( UndeclaredThrowableException ) t ) . getUndeclaredThrowable ( ) ; 
else return e ; 
} 
} 

public class ByteCodeMonitor { 
private void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { 
for ( WAMInstruction instruction : instructions ) { 
WAMLabel label = instruction . getLabel ( ) ; 
labeledTable . put ( ADDRESS , row , String . format ( "%08X" , address ) ) ; 
labeledTable . put ( LABEL , row , ( label == null ) ? "" : ( label . toPrettyString ( ) + ":" ) ) ; 
labeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; 
int fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; 
String arg = "" ; 
for ( int i = 2 ; 
i < 32 ; 
i = i * 2 ) if ( ( fieldMask & i ) != 0 ) { 
if ( ! "" . equals ( arg ) ) arg += ", " ; 
switch ( i ) { 
case 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; 
break ; 
case 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; 
break ; 
case 8 : FunctorName fn = instruction . getFn ( ) ; 
if ( fn != null ) arg += fn . getName ( ) + "/" + fn . getArity ( ) ; 
break ; 
case 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; 
if ( target1 != null ) arg += target1 . getName ( ) + "/" + target1 . getArity ( ) + "_" + target1 . getId ( ) ; 
break ; 
} 
} 
labeledTable . put ( ARG_1 , row , arg ) ; 
row ++ ; 
address += instruction . sizeof ( ) ; 
} 
} 
} 

public class QueryParameter { 
public QueryParameter partialCopy ( final QueryParameterKind ... excludedElements ) { 
List < QueryParameterKind > excludedList = Arrays . asList ( excludedElements ) ; 
QueryParameter returnValue = new QueryParameter ( ) ; 
if ( ! excludedList . contains ( QueryParameterKind . CONSTRAINTS ) ) returnValue . rawConstraints = this . rawConstraints ; 
if ( ! excludedList . contains ( QueryParameterKind . GROUPS ) ) returnValue . groups = this . groups ; 
if ( ! excludedList . contains ( QueryParameterKind . ORDERS ) ) returnValue . orders = this . orders ; 
if ( ! excludedList . contains ( QueryParameterKind . PAGE ) ) { 
returnValue . pageSize = this . pageSize ; 
returnValue . page = this . page ; 
} 
if ( ! excludedList . contains ( QueryParameterKind . TIMEZONE ) ) returnValue . timezoneName = this . timezoneName ; 
return returnValue ; 
} 
} 

public class SequenceIterator { 
private E nextInternal ( ) { 
if ( nextSolution != null ) return nextSolution ; 
nextSolution = nextInSequence ( ) ; 
if ( nextSolution == null ) exhausted = true ; 
return nextSolution ; 
} 
} 

public class WAMCompiledClause { 
private void addInstructionsAndThisToParent ( SizeableList < WAMInstruction > instructions ) { 
if ( ! addedToParent ) { 
parent . addInstructions ( this , instructions ) ; 
addedToParent = true ; 
} 
else parent . addInstructions ( instructions ) ; 
} 
} 

public class BigDecimalTypeImpl { 
public static Type createInstance ( String name , int precision , int scale , String min , String max ) { 
synchronized ( DECIMAL_TYPES ) { 
BigDecimalTypeImpl newType = new BigDecimalTypeImpl ( name , precision , scale , min , max ) ; 
BigDecimalTypeImpl oldType = DECIMAL_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
DECIMAL_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class LexicographicalCollectionComparator { 
public int compare ( Collection < T > c1 , Collection < T > c2 ) { 
Iterator < T > i1 = c1 . iterator ( ) ; 
Iterator < T > i2 = c2 . iterator ( ) ; 
while ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { 
T t1 = i1 . next ( ) ; 
T t2 = i2 . next ( ) ; 
int comp = comparator . compare ( t1 , t2 ) ; 
if ( comp < 0 ) return - 1 ; 
else if ( comp > 0 ) return 1 ; 
} 
if ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) return - 1 ; 
if ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) return 1 ; 
return 0 ; 
} 
} 

public class DataStreamServlet { 
public void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { 
log . fine ( "void service(HttpServletRequest, HttpServletResponse): called" ) ; 
String contentType = ( String ) request . getAttribute ( "contentType" ) ; 
String contentDisposition = ( String ) request . getAttribute ( "contentDisposition" ) ; 
InputStream inputStream = ( InputStream ) request . getAttribute ( "inputStream" ) ; 
if ( contentType != null ) response . setContentType ( contentType ) ; 
if ( contentDisposition != null ) response . addHeader ( "Content-disposition" , contentDisposition ) ; 
BufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; 
int length = - 1 ; 
byte [ ] chunk = new byte [ 8192 ] ; 
while ( ( length = inputStream . read ( chunk ) ) != - 1 ) outputStream . write ( chunk , 0 , length ) ; 
outputStream . flush ( ) ; 
inputStream . close ( ) ; 
} 
} 

public class PageControlTag { 
public int doStartTag ( ) throws JspException { 
log . fine ( "public int doStartTag(): called" ) ; 
TagUtils tagUtils = TagUtils . getInstance ( ) ; 
PagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; 
log . fine ( "list = " + list ) ; 
String url ; 
try { 
url = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; 
} 
catch ( MalformedURLException e ) { 
throw new JspException ( "Got malformed URL exception: " , e ) ; 
} 
renderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; 
renderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; 
int from = list . getCurrentIndex ( ) ; 
int to = list . getCurrentIndex ( ) + maxPages ; 
for ( int i = from ; 
( i < list . size ( ) ) && ( i < to ) ; 
i ++ ) renderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , "" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; 
renderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; 
renderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; 
renderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; 
return SKIP_BODY ; 
} 
} 

public class PageControlTag { 
private void renderButton ( boolean render , int page , int index , String openDelim , String url , String text , boolean active ) throws JspException { 
log . fine ( "private void renderButton(boolean render, int page, int index, String openDelim, String url, String text, boolean active): called" ) ; 
log . fine ( "render = " + render ) ; 
log . fine ( "page = " + page ) ; 
log . fine ( "index = " + index ) ; 
log . fine ( "openDelim = " + openDelim ) ; 
log . fine ( "url = " + url ) ; 
log . fine ( "text = " + text ) ; 
log . fine ( "active = " + active ) ; 
TagUtils tagUtils = TagUtils . getInstance ( ) ; 
if ( render ) { 
tagUtils . write ( pageContext , openDelim ) ; 
if ( active ) tagUtils . write ( pageContext , "<a href=\"" + url + "?varName=" + name + "&number=" + page + "&index=" + index + "\">" + text + "</a>" ) ; 
else tagUtils . write ( pageContext , text ) ; 
tagUtils . write ( pageContext , closeDelim ) ; 
} 
} 
} 

public class AbstractLearningMethod { 
protected void initialize ( ) throws LearningFailureException { 
if ( inputExamples . isEmpty ( ) ) throw new LearningFailureException ( "No training examples to learn from." , null ) ; 
if ( ! outputPropertiesSet ) addGoalProperty ( "goal" ) ; 
if ( ! inputPropertiesSet ) { 
State example = inputExamples . iterator ( ) . next ( ) ; 
Set < String > allProperties = example . getComponentType ( ) . getAllPropertyNames ( ) ; 
inputProperties = new HashSet < String > ( allProperties ) ; 
inputProperties . removeAll ( outputProperties ) ; 
inputPropertiesSet = true ; 
} 
for ( State example : inputExamples ) { 
Set < String > properties = example . getComponentType ( ) . getAllPropertyNames ( ) ; 
String errorMessage = "" ; 
for ( String inputProperty : inputProperties ) { 
if ( ! properties . contains ( inputProperty ) ) errorMessage += "The training example, " + example + " does not contain the specified input property, " + inputProperty + "\n" ; 
} 
for ( String outputProperty : outputProperties ) { 
if ( ! properties . contains ( outputProperty ) ) errorMessage += "The training example, " + example + " does not contain the specified output property, " + outputProperty + "\n" ; 
} 
if ( ! "" . equals ( errorMessage ) ) throw new LearningFailureException ( errorMessage , null ) ; 
} 
} 
} 

public class HashArray { 
public V get ( Object key ) { 
Integer index = keyToIndex . get ( key ) ; 
if ( index == null ) return null ; 
return data . get ( index . intValue ( ) ) ; 
} 
} 

public class HashArray { 
public int getIndexOf ( Object key ) { 
Integer index = keyToIndex . get ( key ) ; 
if ( index == null ) return - 1 ; 
return index ; 
} 
} 

public class HashArray { 
public V set ( int index , V value ) throws IndexOutOfBoundsException { 
if ( index >= data . size ( ) ) throw new IndexOutOfBoundsException ( ) ; 
return data . set ( index , value ) ; 
} 
} 

public class HashArray { 
public V remove ( Object key ) { 
Integer index = keyToIndex . get ( key ) ; 
if ( index == null ) return null ; 
keyToIndex . remove ( key ) ; 
keySet . remove ( key ) ; 
V removedValue = data . remove ( index . intValue ( ) ) ; 
for ( K nextKey : keyToIndex . keySet ( ) ) { 
Integer nextIndex = keyToIndex . get ( nextKey ) ; 
if ( nextIndex > index ) keyToIndex . put ( nextKey , nextIndex - 1 ) ; 
} 
return removedValue ; 
} 
} 

public class HashArray { 
public V remove ( int index ) throws IndexOutOfBoundsException { 
if ( index >= data . size ( ) ) throw new IndexOutOfBoundsException ( ) ; 
for ( K nextKey : keyToIndex . keySet ( ) ) { 
int nextIndex = keyToIndex . get ( nextKey ) ; 
if ( index == nextIndex ) return remove ( nextKey ) ; 
} 
throw new IndexOutOfBoundsException ( ) ; 
} 
} 

public class PropertyIntrospectorBase { 
protected void setProperty ( Object callee , String property , Object value ) { 
if ( ! initialized ) initialize ( callee ) ; 
Method [ ] setterMethods = setters . get ( property ) ; 
if ( ( setterMethods == null ) || ( setterMethods . length == 0 ) ) throw new IllegalArgumentException ( "No setter method for the property " + property + " exists." ) ; 
Method setterMethod = null ; 
Class valueType = ( value == null ) ? null : value . getClass ( ) ; 
if ( value == null ) setterMethod = setterMethods [ 0 ] ; 
else { 
for ( Method method : setterMethods ) { 
Class argType = method . getParameterTypes ( ) [ 0 ] ; 
if ( argType . isAssignableFrom ( valueType ) ) { 
setterMethod = method ; 
break ; 
} 
else if ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) { 
setterMethod = method ; 
break ; 
} 
else if ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) && isAssignableFromPrimitive ( argType , valueType ) ) { 
setterMethod = method ; 
break ; 
} 
} 
if ( setterMethod == null ) { 
Class calleeType = ( callee == null ) ? null : callee . getClass ( ) ; 
throw new IllegalArgumentException ( "No setter method for property " + property + ", of type, " + calleeType + " will accept the type of value specified, " + valueType + "." ) ; 
} 
} 
try { 
Object [ ] args = new Object [ ] { 
value } 
; 
setterMethod . invoke ( callee , args ) ; 
} 
catch ( InvocationTargetException e ) { 
throw new IllegalArgumentException ( "The setter method for the property " + property + " threw an invocation target exception." , e ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( "The setter method for the property " + property + " cannot be accessed." , e ) ; 
} 
} 
} 

public class PropertyIntrospectorBase { 
protected Object getProperty ( Object callee , String property ) { 
if ( ! initialized ) initialize ( callee ) ; 
Method getterMethod = getters . get ( property ) ; 
if ( getterMethod == null ) throw new IllegalArgumentException ( "No getter method for the property " + property + " exists." ) ; 
Object result ; 
try { 
result = getterMethod . invoke ( callee ) ; 
} 
catch ( InvocationTargetException e ) { 
throw new IllegalStateException ( "The getter method for the property " + property + " threw an invocation target exception." , e ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( "The getter method for the property " + property + " cannot be accessed." , e ) ; 
} 
return result ; 
} 
} 

public class PropertyIntrospectorBase { 
private boolean isAssignableFromPrimitive ( Class wrapperType , Class primitiveType ) { 
boolean result = false ; 
if ( primitiveType . equals ( boolean . class ) && wrapperType . equals ( Boolean . class ) ) result = true ; 
else if ( primitiveType . equals ( byte . class ) && wrapperType . equals ( Byte . class ) ) result = true ; 
else if ( primitiveType . equals ( char . class ) && wrapperType . equals ( Character . class ) ) result = true ; 
else if ( primitiveType . equals ( short . class ) && wrapperType . equals ( Short . class ) ) result = true ; 
else if ( primitiveType . equals ( int . class ) && wrapperType . equals ( Integer . class ) ) result = true ; 
else if ( primitiveType . equals ( long . class ) && wrapperType . equals ( Long . class ) ) result = true ; 
else if ( primitiveType . equals ( float . class ) && wrapperType . equals ( Float . class ) ) result = true ; 
else if ( primitiveType . equals ( double . class ) && wrapperType . equals ( Double . class ) ) result = true ; 
else result = false ; 
return result ; 
} 
} 

public class PrologUnifier { 
public boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { 
if ( left == right ) return true ; 
if ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) return true ; 
else if ( left . isVar ( ) ) return unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; 
else if ( right . isVar ( ) ) return unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; 
else if ( left . isFunctor ( ) && right . isFunctor ( ) ) { 
Functor leftFunctor = ( Functor ) left ; 
Functor rightFunctor = ( Functor ) right ; 
if ( ! left . equals ( right ) ) return false ; 
int arity = leftFunctor . getArity ( ) ; 
for ( int i = 0 ; 
i < arity ; 
i ++ ) { 
Term leftArgument = leftFunctor . getArgument ( i ) ; 
Term rightArgument = rightFunctor . getArgument ( i ) ; 
boolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; 
if ( ! result ) return false ; 
} 
return true ; 
} 
else return false ; 
} 
} 

public class PrologUnifier { 
protected boolean unifyVar ( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { 
if ( leftVar . isBound ( ) ) return unifyInternal ( leftVar . getValue ( ) , rightTerm , leftTrail , rightTrail ) ; 
else if ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) return unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; 
else { 
leftVar . setSubstitution ( rightTerm ) ; 
leftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; 
return true ; 
} 
} 
} 

public class InstructionCompiler { 
private void compileQuery ( Clause clause ) throws SourceCodeException { 
WAMCompiledQuery result ; 
Map < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; 
seenRegisters = new TreeSet < Integer > ( ) ; 
lastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; 
numPermanentVars = 0 ; 
cutLevelVarSlot = - 1 ; 
SizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; 
SizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; 
Set < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; 
Set < Integer > freeVarNames = new TreeSet < Integer > ( ) ; 
for ( Variable var : freeVars ) { 
freeVarNames . add ( var . getName ( ) ) ; 
} 
allocatePermanentQueryRegisters ( clause , varNames ) ; 
gatherPositionAndOccurrenceInfo ( clause ) ; 
result = new WAMCompiledQuery ( varNames , freeVarNames ) ; 
preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; 
if ( cutLevelVarSlot >= 0 ) preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; 
result . addInstructions ( preFixInstructions ) ; 
Functor [ ] expressions = clause . getBody ( ) ; 
FunctorName fn = new FunctorName ( "tq" , 0 ) ; 
for ( int i = 0 ; 
i < expressions . length ; 
i ++ ) { 
Functor expression = expressions [ i ] ; 
boolean isFirstBody = i == 0 ; 
BuiltIn builtIn ; 
if ( expression instanceof BuiltIn ) builtIn = ( BuiltIn ) expression ; 
else builtIn = this ; 
SizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; 
result . addInstructions ( expression , instructions ) ; 
instructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; 
result . addInstructions ( expression , instructions ) ; 
} 
postFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; 
postFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; 
result . addInstructions ( postFixInstructions ) ; 
result = optimizer . apply ( result ) ; 
displayCompiledQuery ( result ) ; 
observer . onQueryCompilation ( result ) ; 
} 
} 

public class InstructionCompiler { 
private int findMaxArgumentsInClause ( Clause clause ) { 
int result = 0 ; 
Functor head = clause . getHead ( ) ; 
if ( head != null ) result = head . getArity ( ) ; 
Functor [ ] body = clause . getBody ( ) ; 
if ( body != null ) for ( int i = 0 ; 
i < body . length ; 
i ++ ) { 
int arity = body [ i ] . getArity ( ) ; 
result = ( arity > result ) ? arity : result ; 
} 
return result ; 
} 
} 

public class ByteBufferUtils { 
public static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { 
int charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; 
length = ( charsRequired < length ) ? length : charsRequired ; 
int index = buffer . position ( ) + length - 1 ; 
int start = buffer . position ( ) ; 
buffer . position ( buffer . position ( ) + length ) ; 
if ( value < 0 ) { 
buffer . put ( MINUS_ASCII ) ; 
start ++ ; 
} 
else value = - value ; 
do { 
int remainder = value % 10 ; 
value = value / 10 ; 
buffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; 
} 
while ( value != 0 ) ; 
while ( index >= start ) buffer . put ( index -- , ZERO_ASCII ) ; 
return buffer ; 
} 
} 

public class ByteBufferUtils { 
public static String asString ( ByteBuffer buffer , int length ) { 
char [ ] chars = new char [ length ] ; 
for ( int i = 0 ; 
i < length ; 
i ++ ) chars [ i ] = ( char ) buffer . get ( i ) ; 
return String . valueOf ( chars ) ; 
} 
} 

public class EnumeratedStringAttribute { 
public String getStringValue ( ) { 
if ( attributeClass . finalized ) return attributeClass . lookupValue [ value ] . label ; 
else return attributeClass . lookupValueList . get ( value ) . label ; 
} 
} 

public class EnumeratedStringAttribute { 
public void setStringValue ( String value ) throws IllegalArgumentException { 
Byte b = attributeClass . lookupByte . get ( value ) ; 
if ( b == null ) if ( attributeClass . finalized ) throw new IllegalArgumentException ( "The value to set, " + value + ", is not already a member of the finalized EnumeratedStringType, " + attributeClass . attributeClassName + "." ) ; 
else { 
EnumeratedStringAttribute newAttribute = attributeClass . createStringAttribute ( value ) ; 
b = newAttribute . value ; 
} 
this . value = b ; 
} 
} 

public class LojixTermReader { 
private void read ( Term term ) { 
if ( term . isNumber ( ) ) { 
NumericType numericType = ( NumericType ) term ; 
if ( numericType . isInteger ( ) ) { 
IntLiteral jplInteger = ( IntLiteral ) term ; 
getContentHandler ( ) . startIntegerTerm ( jplInteger . longValue ( ) ) ; 
} 
else if ( numericType . isFloat ( ) ) { 
FloatLiteral jplFloat = ( FloatLiteral ) term ; 
getContentHandler ( ) . startFloatTerm ( jplFloat . doubleValue ( ) ) ; 
} 
} 
else if ( term . isVar ( ) ) { 
Variable var = ( Variable ) term ; 
getContentHandler ( ) . startVariable ( interner . getVariableName ( var . getName ( ) ) ) ; 
} 
else if ( term . isAtom ( ) ) { 
Functor atom = ( Functor ) term ; 
getContentHandler ( ) . startAtom ( interner . getFunctorName ( atom . getName ( ) ) ) ; 
} 
else if ( term . isCompound ( ) ) { 
Functor functor = ( Functor ) term ; 
getContentHandler ( ) . startCompound ( ) ; 
getContentHandler ( ) . startAtom ( interner . getFunctorName ( functor . getName ( ) ) ) ; 
for ( com . thesett . aima . logic . fol . Term child : functor . getArguments ( ) ) { 
read ( child ) ; 
} 
getContentHandler ( ) . endCompound ( ) ; 
} 
else throw new IllegalStateException ( "Unrecognized Lojix term: " + term ) ; 
} 
} 

public class ReflectionUtils { 
public static Object callMethod ( Object o , String method , Object [ ] params ) { 
Class cls = o . getClass ( ) ; 
Class [ ] paramClasses = new Class [ params . length ] ; 
for ( int i = 0 ; 
i < params . length ; 
i ++ ) paramClasses [ i ] = params [ i ] . getClass ( ) ; 
try { 
Method m = cls . getMethod ( method , paramClasses ) ; 
return m . invoke ( o , params ) ; 
} 
catch ( NoSuchMethodException e ) { 
throw new IllegalStateException ( e ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( e ) ; 
} 
catch ( InvocationTargetException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class ReflectionUtils { 
public static Set < Class > findMatchingSetters ( Class obClass , String propertyName ) { 
Set < Class > types = new HashSet < Class > ( ) ; 
String upperPropertyName = Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; 
Method [ ] methods = obClass . getMethods ( ) ; 
for ( Method nextMethod : methods ) { 
String methodName = nextMethod . getName ( ) ; 
if ( methodName . equals ( "set" + upperPropertyName ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) types . add ( nextMethod . getParameterTypes ( ) [ 0 ] ) ; 
} 
return types ; 
} 
} 

public class TypeHelper { 
public static Type getTypeFromObject ( Object o ) { 
if ( o == null ) return new UnknownType ( ) ; 
if ( o instanceof Attribute ) return ( ( Attribute ) o ) . getType ( ) ; 
return new JavaType ( o ) ; 
} 
} 

public class BaseQueueSearch { 
public void reset ( ) { 
startStates . clear ( ) ; 
enqueuedOnce = false ; 
queue = createQueue ( ) ; 
goalPredicate = null ; 
maxSteps = 0 ; 
searchSteps = 0 ; 
if ( repeatedStateFilter != null ) repeatedStateFilter . reset ( ) ; 
searchAlgorithm . reset ( ) ; 
} 
} 

public class BaseQueueSearch { 
public T search ( ) throws SearchNotExhaustiveException { 
SearchNode < O , T > path = findGoalPath ( ) ; 
if ( path != null ) return path . getState ( ) ; 
else return null ; 
} 
} 

public class IntRangeType { 
public static Type createInstance ( String name , int min , int max ) { 
if ( min > max ) throw new IllegalArgumentException ( "'min' must be less than or equal to 'max'." ) ; 
synchronized ( INT_RANGE_TYPES ) { 
IntRangeType newType = new IntRangeType ( name , min , max ) ; 
IntRangeType oldType = INT_RANGE_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
INT_RANGE_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class SchemaDefinitionImpl { 
public void addSupportedTZ ( String tzName ) { 
if ( ! StringUtils . isBlank ( tzName ) && ! tzNamesAliases . containsKey ( tzName . trim ( ) ) ) { 
tzNamesAliases . put ( tzName . trim ( ) , tzName . trim ( ) ) ; 
if ( LOG . isInfoEnabled ( ) ) LOG . info ( "Endpoint " + this . getEndPointName ( ) + " - add support of TZ: " + tzName ) ; 
} 
} 
} 

public class SchemaDefinitionImpl { 
public void addTZAlternateDimension ( String orignalDimensionName , DimensionTable alternateDimension , String tzName ) { 
addSupportedTZ ( tzName ) ; 
if ( tzNamesAliases . containsValue ( tzName ) ) { 
sqlTables . put ( alternateDimension . getTableName ( ) , alternateDimension ) ; 
alternateDimensions . put ( Pair . of ( orignalDimensionName . toUpperCase ( ) , tzName ) , alternateDimension ) ; 
} 
else LOG . error ( "Unsuported timezone: " + tzName ) ; 
} 
} 

public class SchemaDefinitionImpl { 
public void addDimension ( DimensionTable table , boolean mandatory ) { 
sqlTables . put ( table . getTableName ( ) , table ) ; 
dimensions . put ( table . getDimensionName ( ) . toUpperCase ( ) , table ) ; 
if ( mandatory ) mandatoryDimensionNames . add ( table . getDimensionName ( ) . toUpperCase ( Locale . ENGLISH ) ) ; 
} 
} 

public class TraceIndenter { 
public String generateTraceIndent ( int delta ) { 
if ( ! useIndent ) return "" ; 
else { 
if ( delta >= 1 ) indentStack . push ( delta ) ; 
else if ( delta < 0 ) indentStack . pop ( ) ; 
StringBuffer result = new StringBuffer ( ) ; 
traceIndent += ( delta < 0 ) ? delta : 0 ; 
for ( int i = 0 ; 
i < traceIndent ; 
i ++ ) result . append ( " " ) ; 
traceIndent += ( delta > 0 ) ? delta : 0 ; 
return result . toString ( ) ; 
} 
} 
} 

public class ProtoDTLearningMethod { 
private OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { 
Map < OrdinalAttribute , Integer > countMap = null ; 
int biggestCount = 0 ; 
OrdinalAttribute biggestAttribute = null ; 
for ( State example : examples ) { 
OrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; 
if ( countMap == null ) countMap = new HashMap < OrdinalAttribute , Integer > ( ) ; 
int count ; 
if ( ! countMap . containsKey ( nextAttribute ) ) { 
count = 1 ; 
countMap . put ( nextAttribute , count ) ; 
} 
else { 
count = countMap . get ( nextAttribute ) ; 
countMap . put ( nextAttribute , count ++ ) ; 
} 
if ( count > biggestCount ) { 
biggestCount = count ; 
biggestAttribute = nextAttribute ; 
} 
} 
return biggestAttribute ; 
} 
} 

public class ProtoDTLearningMethod { 
private boolean allHaveSameClassification ( String property , Iterable < State > examples ) { 
OrdinalAttribute firstAttribute = null ; 
boolean success = true ; 
for ( State example : examples ) { 
OrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; 
if ( firstAttribute == null ) firstAttribute = nextAttribute ; 
else if ( ! nextAttribute . equals ( firstAttribute ) ) { 
success = false ; 
break ; 
} 
} 
if ( success ) allClassification = firstAttribute ; 
return success ; 
} 
} 

public class PagedList { 
public List < E > get ( int index ) { 
int originalSize = original . size ( ) ; 
int size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; 
if ( ( index == 0 ) && ( originalSize == 0 ) ) return new ArrayList < E > ( ) ; 
if ( ( index >= size ) || ( index < 0 ) ) throw new IndexOutOfBoundsException ( "Index " + index + " is less than zero or more than the number of pages: " + size ) ; 
List < E > result = original . subList ( pageSize * index , ( ( pageSize * ( index + 1 ) ) >= originalSize ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; 
return result ; 
} 
} 

public class Surface { 
public void setTexture ( Paint obj ) { 
if ( obj instanceof GradientPaint ) texture = new GradientPaint ( 0 , 0 , Color . white , getSize ( ) . width * 2 , 0 , Color . green ) ; 
else texture = obj ; 
} 
} 

public class Surface { 
public void paintImmediately ( int x , int y , int w , int h ) { 
RepaintManager repaintManager = null ; 
boolean save = true ; 
if ( ! isDoubleBuffered ( ) ) { 
repaintManager = RepaintManager . currentManager ( this ) ; 
save = repaintManager . isDoubleBufferingEnabled ( ) ; 
repaintManager . setDoubleBufferingEnabled ( false ) ; 
} 
super . paintImmediately ( x , y , w , h ) ; 
if ( repaintManager != null ) repaintManager . setDoubleBufferingEnabled ( save ) ; 
} 
} 

public class Surface { 
protected BufferedImage createBufferedImage ( int w , int h , int imgType ) { 
BufferedImage bi = null ; 
if ( imgType == 0 ) bi = ( BufferedImage ) createImage ( w , h ) ; 
else if ( ( imgType > 0 ) && ( imgType < 14 ) ) bi = new BufferedImage ( w , h , imgType ) ; 
else if ( imgType == 14 ) bi = createBinaryImage ( w , h , 2 ) ; 
else if ( imgType == 15 ) bi = createBinaryImage ( w , h , 4 ) ; 
else if ( imgType == 16 ) bi = createSGISurface ( w , h , 32 ) ; 
else if ( imgType == 17 ) bi = createSGISurface ( w , h , 16 ) ; 
biw = w ; 
bih = h ; 
return bi ; 
} 
} 

public class Surface { 
protected Graphics2D createGraphics2D ( int width , int height , BufferedImage bi , Graphics g ) { 
Graphics2D g2 = null ; 
if ( bi != null ) g2 = bi . createGraphics ( ) ; 
else g2 = ( Graphics2D ) g ; 
g2 . setBackground ( getBackground ( ) ) ; 
g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , antiAlias ) ; 
g2 . setRenderingHint ( RenderingHints . KEY_RENDERING , rendering ) ; 
if ( clearSurface || clearOnce ) { 
g2 . clearRect ( 0 , 0 , width , height ) ; 
clearOnce = false ; 
} 
if ( texture != null ) { 
g2 . setComposite ( AlphaComposite . SrcOver ) ; 
g2 . setPaint ( texture ) ; 
g2 . fillRect ( 0 , 0 , width , height ) ; 
} 
if ( composite != null ) g2 . setComposite ( composite ) ; 
return g2 ; 
} 
} 

public class Surface { 
private BufferedImage createBinaryImage ( int w , int h , int pixelBits ) { 
int bytesPerRow = w * pixelBits / 8 ; 
if ( ( w * pixelBits % 8 ) != 0 ) bytesPerRow ++ ; 
byte [ ] imageData = new byte [ h * bytesPerRow ] ; 
IndexColorModel cm = null ; 
switch ( pixelBits ) { 
case 1 : { 
cm = new IndexColorModel ( pixelBits , lut1Arr . length , lut1Arr , lut1Arr , lut1Arr ) ; 
break ; 
} 
case 2 : { 
cm = new IndexColorModel ( pixelBits , lut2Arr . length , lut2Arr , lut2Arr , lut2Arr ) ; 
break ; 
} 
case 4 : { 
cm = new IndexColorModel ( pixelBits , lut4Arr . length , lut4Arr , lut4Arr , lut4Arr ) ; 
break ; 
} 
default : { 
new Exception ( "Invalid # of bit per pixel" ) . printStackTrace ( ) ; 
} 
} 
DataBuffer db = new DataBufferByte ( imageData , imageData . length ) ; 
WritableRaster r = Raster . createPackedRaster ( db , w , h , pixelBits , null ) ; 
return new BufferedImage ( cm , r , false , null ) ; 
} 
} 

public class IterativeBoundAlgorithm { 
public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { 
for ( float bound = startBound ; 
; 
) { 
maxBound = bound ; 
try { 
int numStepsSoFar = initSearch . getStepsTaken ( ) ; 
initSearch . resetEnqueuedOnceFlag ( ) ; 
SearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; 
if ( node != null ) return node ; 
else return null ; 
} 
catch ( MaxBoundException e ) { 
e = null ; 
} 
if ( useEpsilon ) bound = bound + epsilon ; 
else bound = getMinBeyondBound ( ) ; 
} 
} 
} 

public class MaxStepsAlgorithm { 
public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { 
Queue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; 
UnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; 
while ( ! queue . isEmpty ( ) ) { 
SearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; 
if ( ! headNode . isExpanded ( ) ) headNode . expandSuccessors ( queue , reverseEnqueue ) ; 
SearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; 
if ( currentNode . isExpanded ( ) ) { 
currentNode = peekAtHead ? queue . remove ( ) : headNode ; 
if ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) return currentNode ; 
} 
if ( maxSteps > 0 ) { 
searchSteps ++ ; 
initSearch . setStepsTaken ( searchSteps ) ; 
if ( searchSteps >= maxSteps ) if ( queue . isEmpty ( ) ) return null ; 
else throw new SearchNotExhaustiveException ( "Maximum number of steps reached." , null ) ; 
} 
} 
return null ; 
} 
} 

public class PrologParser { 
public Clause clause ( ) throws SourceCodeException { 
variableContext . clear ( ) ; 
Term term = term ( ) ; 
Clause clause = TermUtils . convertToClause ( term , interner ) ; 
if ( clause == null ) throw new SourceCodeException ( "Only queries and clauses are valid sentences in Prolog, not " + term + "." , null , null , null , term . getSourceCodePosition ( ) ) ; 
return clause ; 
} 
} 

public class PrologParser { 
public Term listFunctor ( ) throws SourceCodeException { 
int nilId = interner . internFunctorName ( "nil" , 0 ) ; 
int consId = interner . internFunctorName ( "cons" , 2 ) ; 
Token leftDelim = consumeToken ( LSQPAREN ) ; 
Term [ ] args = null ; 
Token nextToken = tokenSource . peek ( ) ; 
switch ( nextToken . kind ) { 
case LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; 
break ; 
default : } 
Term accumulator ; 
if ( tokenSource . peek ( ) . kind == CONS ) { 
if ( args == null ) throw new SourceCodeException ( "Was expecting one of " + BEGIN_TERM_TOKENS + " but got " + tokenImage [ nextToken . kind ] + "." , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; 
consumeToken ( CONS ) ; 
accumulator = term ( ) ; 
} 
else accumulator = new Nil ( nilId , null ) ; 
Token rightDelim = consumeToken ( RSQPAREN ) ; 
if ( args != null ) for ( int i = args . length - 1 ; 
i >= 0 ; 
i -- ) { 
Term previousAccumulator = accumulator ; 
accumulator = new Cons ( consId , new Term [ ] { 
args [ i ] , previousAccumulator } 
) ; 
} 
SourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; 
accumulator . setSourceCodePosition ( position ) ; 
return ( Functor ) accumulator ; 
} 
} 

public class PrologParser { 
public Term variable ( ) throws SourceCodeException { 
Token name = consumeToken ( VAR ) ; 
int nameId = interner . internVariableName ( name . image ) ; 
Variable var = null ; 
if ( ! "_" . equals ( name . image ) ) var = variableContext . get ( nameId ) ; 
if ( var != null ) return var ; 
else { 
var = new Variable ( nameId , null , name . image . equals ( "_" ) ) ; 
variableContext . put ( nameId , var ) ; 
return var ; 
} 
} 
} 

public class PrologParser { 
public Directive peekAndConsumeDirective ( ) throws SourceCodeException { 
if ( peekAndConsumeTrace ( ) ) return Directive . Trace ; 
if ( peekAndConsumeInfo ( ) ) return Directive . Info ; 
if ( peekAndConsumeUser ( ) ) return Directive . User ; 
return null ; 
} 
} 

public class PrologParser { 
public void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { 
int arity ; 
if ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) arity = 2 ; 
else arity = 1 ; 
int name = interner . internFunctorName ( operatorName , arity ) ; 
operatorTable . setOperator ( name , operatorName , priority , associativity ) ; 
} 
} 

public class PrologParser { 
protected Token consumeToken ( int kind ) throws SourceCodeException { 
Token nextToken = tokenSource . peek ( ) ; 
if ( nextToken . kind != kind ) throw new SourceCodeException ( "Was expecting " + tokenImage [ kind ] + " but got " + tokenImage [ nextToken . kind ] + "." , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; 
else { 
nextToken = tokenSource . poll ( ) ; 
return nextToken ; 
} 
} 
} 

public class PrologParser { 
private boolean peekAndConsume ( int kind ) { 
Token nextToken = tokenSource . peek ( ) ; 
if ( nextToken . kind == kind ) { 
try { 
consumeToken ( kind ) ; 
} 
catch ( SourceCodeException e ) { 
throw new IllegalStateException ( e ) ; 
} 
return true ; 
} 
else return false ; 
} 
} 

public class TxSessionImpl { 
public void bind ( ) { 
if ( ( txId == null ) || ! txId . isValid ( ) ) txId = TxManager . createTxId ( ) ; 
TxManager . assignTxIdToThread ( txId ) ; 
threadSession . set ( this ) ; 
} 
} 

public class Filterators { 
public static < T > Collection < T > collectIterator ( Iterator < T > iterator , Collection < T > targetCollection ) { 
while ( iterator . hasNext ( ) ) targetCollection . add ( iterator . next ( ) ) ; 
return targetCollection ; 
} 
} 

public class TimeUtils { 
public static int ticksToYears ( long ticks ) { 
long unitMillis = MILLIS_PER_YEAR / 2 ; 
long i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; 
if ( i2 < 0 ) i2 = i2 - unitMillis + 1 ; 
int year = ( int ) ( i2 / unitMillis ) ; 
long yearStart = millisToYearStart ( year ) ; 
long diff = ticks - yearStart ; 
if ( diff < 0 ) year -- ; 
else if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { 
long oneYear ; 
if ( isLeapYear ( year ) ) oneYear = MILLIS_PER_DAY * 366L ; 
else oneYear = MILLIS_PER_DAY * 365L ; 
yearStart += oneYear ; 
if ( yearStart <= ticks ) year ++ ; 
} 
return year ; 
} 
} 

public class TimeUtils { 
public static long millisToYearStart ( int year ) { 
int leapYears = year / 100 ; 
if ( year < 0 ) leapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; 
else { 
leapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; 
if ( isLeapYear ( year ) ) leapYears -- ; 
} 
return ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; 
} 
} 

public class SequentialCuckooFunction { 
private Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { 
Entry < K > uninsertedEntry = entry ; 
boolean createdNewEntry = false ; 
Entry < K > existingEntry = entryForKey ( key ) ; 
Integer result = null ; 
if ( existingEntry != null ) result = existingEntry . seq ; 
else { 
if ( uninsertedEntry == null ) { 
uninsertedEntry = new Entry < K > ( ) ; 
uninsertedEntry . key = key ; 
uninsertedEntry . seq = nextSequenceNumber ; 
nextSequenceNumber ++ ; 
count ++ ; 
createdNewEntry = true ; 
result = uninsertedEntry . seq ; 
} 
while ( true ) { 
int keyHashCode = uninsertedEntry . key . hashCode ( ) ; 
uninsertedEntry . hash1 = hash1 ( keyHashCode ) ; 
uninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; 
uninsertedEntry = cuckoo ( uninsertedEntry ) ; 
if ( uninsertedEntry == null ) { 
result = createdNewEntry ? result : - 1 ; 
break ; 
} 
if ( tryRehashing ) rehash ( ) ; 
else { 
result = null ; 
break ; 
} 
} 
} 
return result ; 
} 
} 

public class SequentialCuckooFunction { 
private Entry < K > entryForKey ( K key ) { 
int keyHashCode = key . hashCode ( ) ; 
int hash1 = hash1 ( keyHashCode ) ; 
Entry < K > entry = hashTable [ indexFor ( hash1 ) ] ; 
if ( ( entry != null ) && key . equals ( entry . key ) ) return entry ; 
int hash2 = hash2 ( hash1 , keyHashCode ) ; 
entry = hashTable [ indexFor ( hash2 ) ] ; 
if ( ( entry != null ) && key . equals ( entry . key ) ) return entry ; 
return null ; 
} 
} 

public class SequentialCuckooFunction { 
private Entry < K > cuckoo ( Entry < K > entry ) { 
Entry < K > currentEntry = entry ; 
int hash = entry . hash1 ; 
int index = indexFor ( hash ) ; 
Entry < K > nextEntry = hashTable [ index ] ; 
int previousFlag = 0 ; 
int [ ] previousIndex = new int [ 2 ] ; 
int [ ] previousSeq = new int [ 2 ] ; 
for ( int i = 0 ; 
i < hashTableSize ; 
i ++ ) { 
if ( nextEntry == null ) { 
hashTable [ index ] = currentEntry ; 
return null ; 
} 
hashTable [ index ] = currentEntry ; 
currentEntry = nextEntry ; 
int firstPosition = indexFor ( currentEntry . hash1 ) ; 
hash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; 
index = indexFor ( hash ) ; 
previousIndex [ previousFlag ] = index ; 
previousSeq [ previousFlag ] = nextEntry . seq ; 
previousFlag = ( previousFlag == 1 ) ? 0 : 1 ; 
nextEntry = hashTable [ index ] ; 
if ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) break ; 
} 
return currentEntry ; 
} 
} 

public class SequentialCuckooFunction { 
private void rehash ( ) { 
int newSize = hashTableSize ; 
if ( hashTableSize < ( count * 2 ) ) { 
newSize = hashTableSize * 2 ; 
if ( newSize > maxSize ) throw new IllegalStateException ( "'newSize' of " + newSize + " would put the table over the maximum size limit of " + maxSize ) ; 
} 
Entry < K > [ ] oldTable = hashTable ; 
hashTableSize = newSize ; 
length = hashTable . length ; 
boolean rehashedOk ; 
do { 
rehashedOk = true ; 
changeHashFunctions ( ) ; 
hashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; 
for ( Entry < K > entry : oldTable ) { 
if ( entry != null ) if ( applyWithEntry ( entry . key , entry , false ) == null ) { 
rehashedOk = false ; 
break ; 
} 
} 
} 
while ( ! rehashedOk ) ; 
} 
} 

public class WorkPanel { 
public void actionPerformed ( ActionEvent event ) { 
String action = event . getActionCommand ( ) ; 
if ( "OK" . equals ( action ) ) if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) saveWork ( ) ; 
else if ( "Cancel" . equals ( action ) ) if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) discardWork ( ) ; 
else if ( "Apply" . equals ( action ) ) if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) saveWork ( ) ; 
} 
} 

public class WAMResolvingNativeMachine { 
public static WAMResolvingNativeMachine getInstance ( SymbolTableImpl < Integer , String , Object > symbolTable ) throws ImplementationUnavailableException { 
try { 
if ( ! libraryLoadAttempted ) { 
libraryLoadAttempted = true ; 
System . loadLibrary ( "aima_native" ) ; 
libraryFound = true ; 
} 
if ( libraryFound ) return new WAMResolvingNativeMachine ( symbolTable ) ; 
else throw new ImplementationUnavailableException ( "The native library could not be found." , null , null , null ) ; 
} 
catch ( UnsatisfiedLinkError e ) { 
libraryFound = false ; 
throw new ImplementationUnavailableException ( "The native library could not be found." , e , null , null ) ; 
} 
} 
} 

public class InformationTheory { 
public static double expectedI ( double [ ] probabilities ) { 
double result = 0.0d ; 
for ( double p : probabilities ) { 
if ( p > 0.0d ) result -= p * Math . log ( p ) ; 
} 
return result / LN2 ; 
} 
} 

public class InformationTheory { 
public static double [ ] pForDistribution ( int [ ] counts ) { 
double [ ] probabilities = new double [ counts . length ] ; 
int total = 0 ; 
for ( int c : counts ) { 
total += c ; 
} 
for ( int i = 0 ; 
i < probabilities . length ; 
i ++ ) if ( total > 0 ) probabilities [ i ] = ( ( double ) counts [ i ] ) / total ; 
else probabilities [ i ] = 0.0d ; 
return probabilities ; 
} 
} 

public class SortAction { 
public ActionForward perform ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { 
log . fine ( "perform: called" ) ; 
SortForm sortForm = ( SortForm ) form ; 
HttpSession session = request . getSession ( ) ; 
ServletContext application = session . getServletContext ( ) ; 
log . fine ( "variables in the servlet context: " ) ; 
for ( Enumeration e = application . getAttributeNames ( ) ; 
e . hasMoreElements ( ) ; 
) log . fine ( e . nextElement ( ) . toString ( ) ) ; 
List list = ( List ) session . getAttribute ( sortForm . getList ( ) ) ; 
Comparator comparator = ( Comparator ) application . getAttribute ( sortForm . getComparator ( ) ) ; 
log . fine ( "comparator = " + comparator ) ; 
SortStateBean sortStateBean = ( SortStateBean ) session . getAttribute ( sortForm . getSortState ( ) ) ; 
if ( sortStateBean == null ) { 
log . fine ( "There is no sort state bean" ) ; 
sortStateBean = new SortStateBean ( ) ; 
} 
if ( ! sortStateBean . getState ( ) . equals ( SortStateBean . FORWARD ) || ! sortStateBean . getSortProperty ( ) . equals ( sortForm . getSortStateProperty ( ) ) ) { 
Collections . sort ( list , comparator ) ; 
sortStateBean . setState ( SortStateBean . FORWARD ) ; 
} 
else { 
Collections . sort ( list , comparator ) ; 
Collections . reverse ( list ) ; 
sortStateBean . setState ( SortStateBean . REVERSE ) ; 
} 
session . setAttribute ( sortForm . getList ( ) , list ) ; 
sortStateBean . setSortProperty ( sortForm . getSortStateProperty ( ) ) ; 
session . setAttribute ( sortForm . getSortState ( ) , sortStateBean ) ; 
return ( mapping . findForward ( "success" ) ) ; 
} 
} 

public class DebugTag { 
public String getHeaders ( ) { 
Map info = new TreeMap ( ) ; 
HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; 
Enumeration names = req . getHeaderNames ( ) ; 
while ( names . hasMoreElements ( ) ) { 
String name = ( String ) names . nextElement ( ) ; 
Enumeration values = req . getHeaders ( name ) ; 
StringBuffer sb = new StringBuffer ( ) ; 
boolean first = true ; 
while ( values . hasMoreElements ( ) ) { 
if ( ! first ) sb . append ( " | " ) ; 
first = false ; 
sb . append ( values . nextElement ( ) ) ; 
} 
info . put ( name , sb . toString ( ) ) ; 
} 
return toHTMLTable ( "headers" , info ) ; 
} 
} 

public class DebugTag { 
public String getCookies ( ) { 
Map info = new TreeMap ( ) ; 
HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; 
Cookie [ ] cookies = req . getCookies ( ) ; 
if ( cookies != null ) for ( int i = 0 ; 
i < cookies . length ; 
i ++ ) { 
Cookie cooky = cookies [ i ] ; 
info . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; 
} 
return toHTMLTable ( "cookies" , info ) ; 
} 
} 

public class DebugTag { 
public String getParameters ( ) { 
Map info = new TreeMap ( ) ; 
ServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; 
Enumeration names = req . getParameterNames ( ) ; 
while ( names . hasMoreElements ( ) ) { 
String name = ( String ) names . nextElement ( ) ; 
String [ ] values = req . getParameterValues ( name ) ; 
StringBuffer sb = new StringBuffer ( ) ; 
for ( int i = 0 ; 
i < values . length ; 
i ++ ) { 
if ( i != 0 ) sb . append ( " | " ) ; 
sb . append ( values [ i ] ) ; 
} 
info . put ( name , sb . toString ( ) ) ; 
} 
return toHTMLTable ( "request parameters" , info ) ; 
} 
} 

public class DebugTag { 
public String getUserPrincipal ( ) { 
Map info = new TreeMap ( ) ; 
HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; 
Principal principal = request . getUserPrincipal ( ) ; 
if ( principal != null ) info . put ( "principal name" , principal . getName ( ) ) ; 
else info . put ( "principal name" , "no principal" ) ; 
return toHTMLTable ( "container security" , info ) ; 
} 
} 

public class BoundedAlgorithm { 
public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { 
Queue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; 
UnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; 
boolean beyondFringe = false ; 
minBeyondBound = Float . POSITIVE_INFINITY ; 
while ( ! queue . isEmpty ( ) ) { 
SearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; 
Queue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; 
headNode . expandSuccessors ( successors , reverseEnqueue ) ; 
for ( SearchNode < O , T > successor : successors ) { 
float boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; 
if ( boundProperty <= maxBound ) queue . offer ( successor ) ; 
else { 
beyondFringe = true ; 
minBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; 
} 
} 
SearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; 
if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) return currentNode ; 
if ( maxSteps > 0 ) { 
searchSteps ++ ; 
initSearch . setStepsTaken ( searchSteps ) ; 
if ( searchSteps >= maxSteps ) if ( queue . isEmpty ( ) ) return null ; 
else throw new SearchNotExhaustiveException ( "Maximum number of steps reached." , null ) ; 
} 
} 
if ( beyondFringe ) throw new MaxBoundException ( "Max bound reached." , null ) ; 
else return null ; 
} 
} 

public class TermWalker { 
public void walk ( Term term ) { 
term . setTermTraverser ( traverser ) ; 
search . reset ( ) ; 
if ( goalPredicate != null ) search . setGoalPredicate ( goalPredicate ) ; 
search . addStartState ( term ) ; 
Iterator < Term > treeWalker = Searches . allSolutions ( search ) ; 
if ( traverser instanceof TermVisitor ) term . accept ( ( TermVisitor ) traverser ) ; 
while ( treeWalker . hasNext ( ) ) { 
Term nextTerm = treeWalker . next ( ) ; 
nextTerm . accept ( visitor ) ; 
} 
term . setTermTraverser ( null ) ; 
} 
} 

public class InternalRegisterBean { 
private void notifyChanges ( Iterable < PropertyChangeEvent > changes ) { 
List < PropertyChangeListener > activeListeners = listeners . getActiveListeners ( ) ; 
if ( activeListeners != null ) for ( PropertyChangeListener listener : activeListeners ) { 
for ( PropertyChangeEvent event : changes ) { 
listener . propertyChange ( event ) ; 
} 
} 
} 
} 

public class AbstractHeap { 
public < T > T [ ] toArray ( T [ ] a ) { 
int size = size ( ) ; 
if ( a . length < size ) a = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; 
Iterator < E > it = iterator ( ) ; 
Object [ ] result = a ; 
for ( int i = 0 ; 
i < size ; 
i ++ ) result [ i ] = it . next ( ) ; 
if ( a . length > size ) a [ size ] = null ; 
return a ; 
} 
} 

public class OpSymbol { 
public void setArguments ( Term [ ] arguments ) { 
if ( ( arguments == null ) || ( arguments . length < 1 ) || ( arguments . length > 2 ) ) throw new IllegalArgumentException ( "An operator has minimum 1 and maximum 2 arguments." ) ; 
this . arguments = arguments ; 
this . arity = arguments . length ; 
} 
} 

public class WorkFlowButtonsPanel { 
public void propertyChange ( PropertyChangeEvent event ) { 
Object source = event . getSource ( ) ; 
Object oldValue = event . getOldValue ( ) ; 
String propertyName = event . getPropertyName ( ) ; 
if ( source instanceof WorkFlowScreenState ) { 
WorkFlowScreenState wfsState = ( WorkFlowScreenState ) source ; 
updateButtonsForScreen ( wfsState ) ; 
} 
if ( source instanceof WorkFlowState ) { 
WorkFlowState wfState = ( WorkFlowState ) source ; 
if ( "currentScreenState" . equals ( propertyName ) ) { 
WorkFlowScreenState newScreenState = wfState . getCurrentScreenState ( ) ; 
WorkFlowScreenState oldScreenState = ( WorkFlowScreenState ) oldValue ; 
if ( oldScreenState != null ) oldScreenState . removePropertyChangeListener ( this ) ; 
if ( newScreenState != null ) newScreenState . addPropertyChangeListener ( this ) ; 
updateButtonsForScreen ( newScreenState ) ; 
} 
else if ( "state" . equals ( propertyName ) ) updateButtonsForWorkFlow ( wfState ) ; 
} 
} 
} 

public class WorkFlowButtonsPanel { 
public void registerWorkFlowController ( WorkFlowController controller ) { 
backButton . addActionListener ( controller ) ; 
nextButton . addActionListener ( controller ) ; 
finishButton . addActionListener ( controller ) ; 
cancelButton . addActionListener ( controller ) ; 
controller . getWorkFlowState ( ) . addPropertyChangeListener ( this ) ; 
WorkFlowScreenState currentScreenState = controller . getWorkFlowState ( ) . getCurrentScreenState ( ) ; 
if ( currentScreenState != null ) currentScreenState . addPropertyChangeListener ( this ) ; 
} 
} 

public class EnumAttribute { 
public static EnumAttributeFactory getFactoryForClass ( Class cls ) { 
if ( ! cls . isEnum ( ) ) throw new IllegalArgumentException ( "Can only create enum attribute factories for classes that are enums." ) ; 
return EnumClassImpl . getInstance ( cls ) ; 
} 
} 

public class StackVariable { 
public Variable getStorageCell ( Variable variable ) { 
VariableBindingContext < Variable > context = getBindingContext ( ) ; 
if ( context == null ) return null ; 
else return context . getStorageCell ( this ) ; 
} 
} 

public class AttributeGridImpl { 
private void setColumnAttribute ( AttributeSet attributes , int c ) { 
if ( c >= columnAttributes . size ( ) ) for ( int i = columnAttributes . size ( ) ; 
i <= c ; 
i ++ ) columnAttributes . add ( null ) ; 
columnAttributes . set ( c , attributes ) ; 
} 
} 

public class AttributeGridImpl { 
private void setRowAttribute ( AttributeSet attributes , int r ) { 
if ( r >= rowAttributes . size ( ) ) for ( int i = rowAttributes . size ( ) ; 
i <= r ; 
i ++ ) rowAttributes . add ( null ) ; 
rowAttributes . set ( r , attributes ) ; 
} 
} 

public class AttributeGridImpl { 
private AttributeSet getColumnAttributeOrNull ( int c ) { 
if ( ( c >= 0 ) && ( c < columnAttributes . size ( ) ) ) return columnAttributes . get ( c ) ; 
else return null ; 
} 
} 

public class AttributeGridImpl { 
private AttributeSet getRowAttributeOrNull ( int r ) { 
if ( ( r >= 0 ) && ( r < rowAttributes . size ( ) ) ) return rowAttributes . get ( r ) ; 
else return null ; 
} 
} 

public class TimeRangeType { 
public static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { 
if ( ( min != null ) && ( max != null ) && ( min . compareTo ( max ) > 0 ) ) throw new IllegalArgumentException ( "'min' must be less than or equal to 'max'." ) ; 
synchronized ( INT_RANGE_TYPES ) { 
TimeRangeType newType = new TimeRangeType ( name , min , max ) ; 
TimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
INT_RANGE_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class StringPatternType { 
public static Type createInstance ( String name , int maxLength , String pattern ) { 
synchronized ( STRING_PATTERN_TYPES ) { 
StringPatternType newType = new StringPatternType ( name , maxLength , pattern ) ; 
StringPatternType oldType = STRING_PATTERN_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
STRING_PATTERN_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class VariableReferenceNode { 
public String getValue ( ) { 
for ( ScopeNode scope = NodeTreeUtils . getParentScope ( this ) ; 
scope != null ; 
scope = NodeTreeUtils . getParentScope ( scope ) ) { 
ExpressionGroupNode value = scope . getVariable ( _name ) ; 
if ( value == null ) continue ; 
return value . toString ( ) ; 
} 
return _name ; 
} 
} 

public class BaseBiDirectionalQueueSearch { 
public SearchNode < O , T > findGoalPath ( ) throws SearchNotExhaustiveException { 
while ( ! forwardQueue . isEmpty ( ) || ! reverseQueue . isEmpty ( ) ) { 
if ( ! forwardQueue . isEmpty ( ) ) { 
SearchNode < O , T > currentForwardNode = forwardQueue . remove ( ) ; 
forwardFringe . remove ( currentForwardNode . getState ( ) ) ; 
if ( reverseFringe . containsKey ( currentForwardNode . getState ( ) ) ) return joinBothPaths ( currentForwardNode , reverseFringe . get ( currentForwardNode . getState ( ) ) ) ; 
else { 
Queue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; 
currentForwardNode . expandSuccessors ( newStates , false ) ; 
forwardQueue . addAll ( newStates ) ; 
for ( SearchNode < O , T > nextSearchNode : newStates ) { 
forwardFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; 
} 
} 
} 
if ( ! reverseQueue . isEmpty ( ) ) { 
SearchNode < O , T > currentReverseNode = reverseQueue . remove ( ) ; 
reverseFringe . remove ( currentReverseNode . getState ( ) ) ; 
if ( forwardFringe . containsKey ( currentReverseNode . getState ( ) ) ) return joinBothPaths ( forwardFringe . get ( currentReverseNode . getState ( ) ) , currentReverseNode ) ; 
else { 
Queue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; 
currentReverseNode . expandSuccessors ( newStates , false ) ; 
reverseQueue . addAll ( newStates ) ; 
for ( SearchNode < O , T > nextSearchNode : newStates ) { 
reverseFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; 
} 
} 
} 
} 
return null ; 
} 
} 

public class BaseBiDirectionalQueueSearch { 
private SearchNode < O , T > joinBothPaths ( SearchNode < O , T > forwardPath , SearchNode < O , T > reversePath ) throws SearchNotExhaustiveException { 
if ( pathJoiner != null ) return pathJoiner . joinBothPaths ( forwardPath , reversePath ) ; 
else { 
SearchNode < O , T > currentReverseNode = reversePath ; 
SearchNode < O , T > currentForwardNode = forwardPath ; 
while ( ! goalPredicate . evaluate ( currentReverseNode . getState ( ) ) ) { 
SearchNode < O , T > reverseParentNode = currentReverseNode . getParent ( ) ; 
T state = currentReverseNode . getParent ( ) . getState ( ) ; 
Operator < O > operation = currentReverseNode . getAppliedOp ( ) ; 
float cost = currentReverseNode . getPathCost ( ) - reverseParentNode . getPathCost ( ) ; 
currentForwardNode = currentForwardNode . makeNode ( new Successor < O > ( state , operation , cost ) ) ; 
currentReverseNode = reverseParentNode ; 
} 
return currentForwardNode ; 
} 
} 
} 

public class DefaultPropertyReader { 
public static synchronized Properties getProperties ( String resourceName ) { 
PropertyReaderBase propertyReader = ( PropertyReaderBase ) propertyReaders . get ( resourceName ) ; 
if ( propertyReader != null ) return propertyReader . getProperties ( ) ; 
propertyReader = new DefaultPropertyReader ( resourceName ) ; 
propertyReaders . put ( resourceName , propertyReader ) ; 
return propertyReader . getProperties ( ) ; 
} 
} 

public class TreeSearchState { 
public Iterator < Operator < Tree < E > > > validOperators ( boolean reverse ) { 
if ( tree . isLeaf ( ) ) return new ArrayList < Operator < Tree < E > > > ( ) . iterator ( ) ; 
else { 
Tree . Node < E > node = tree . getAsNode ( ) ; 
return new TreeSearchOperatorIterator < E > ( node . getChildIterator ( ) ) ; 
} 
} 
} 

public class IdAttribute { 
public long getId ( ) { 
if ( attributeClass . finalized ) return attributeClass . lookupValue [ value ] . id ; 
else return attributeClass . lookupValueList . get ( value ) . id ; 
} 
} 

public class IdAttribute { 
public T getValue ( ) { 
if ( attributeClass . finalized ) return attributeClass . lookupValue [ value ] . label ; 
else return attributeClass . lookupValueList . get ( value ) . label ; 
} 
} 

public class IdAttribute { 
public void setValue ( T value ) throws IllegalArgumentException { 
Integer b = attributeClass . lookupInt . get ( value ) ; 
if ( b == null ) if ( attributeClass . finalized ) throw new IllegalArgumentException ( "The value to set, " + value + ", is not already a member of the finalized IdType, " + attributeClass . attributeClassName + "." ) ; 
else { 
IdAttribute newAttribute = attributeClass . createIdAttribute ( value ) ; 
b = newAttribute . value ; 
} 
this . value = b ; 
} 
} 

public class StringUtils { 
public static String [ ] listToArray ( String value , String delim ) { 
List < String > result = new ArrayList < String > ( ) ; 
StringTokenizer tokenizer = new StringTokenizer ( value , delim ) ; 
while ( tokenizer . hasMoreTokens ( ) ) result . add ( tokenizer . nextToken ( ) ) ; 
return result . toArray ( new String [ result . size ( ) ] ) ; 
} 
} 

public class StringUtils { 
public static String arrayToList ( String [ ] array , String delim ) { 
String result = "" ; 
for ( int i = 0 ; 
i < array . length ; 
i ++ ) result += array [ i ] + ( ( i == ( array . length - 1 ) ) ? "" : delim ) ; 
return result ; 
} 
} 

public class StringUtils { 
public static String toCamelCase ( String name ) { 
String [ ] parts = name . split ( "_" ) ; 
String result = parts [ 0 ] ; 
for ( int i = 1 ; 
i < parts . length ; 
i ++ ) if ( parts [ i ] . length ( ) > 0 ) result += upperFirstChar ( parts [ i ] ) ; 
return result ; 
} 
} 

public class StringUtils { 
public static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { 
final StringBuffer result = new StringBuffer ( ) ; 
boolean firstWord = true ; 
boolean firstLetter = true ; 
boolean upper = false ; 
WordMachineState state = WordMachineState . Initial ; 
Function2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { 
public StringBuffer apply ( Character nextChar , Boolean upper ) { 
if ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; 
else result . append ( Character . toLowerCase ( nextChar ) ) ; 
return result ; 
} 
} 
; 
for ( int i = 0 ; 
i < value . length ( ) ; 
i ++ ) { 
char nextChar = value . charAt ( i ) ; 
if ( Character . isUpperCase ( nextChar ) ) { 
switch ( state ) { 
case Initial : state = WordMachineState . StartWord ; 
upper = firstLetterOfWordUpper ; 
if ( ! firstWord ) result . append ( separator ) ; 
firstWord = false ; 
break ; 
case StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; 
upper = false ; 
break ; 
case ContinueWordLower : state = WordMachineState . StartWord ; 
upper = firstLetterOfWordUpper ; 
result . append ( separator ) ; 
break ; 
} 
writeChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; 
firstLetter = false ; 
} 
else if ( Character . isLetterOrDigit ( nextChar ) ) { 
switch ( state ) { 
case Initial : state = WordMachineState . StartWord ; 
upper = firstLetterOfWordUpper ; 
if ( ! firstWord ) result . append ( separator ) ; 
firstWord = false ; 
break ; 
case StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; 
upper = false ; 
break ; 
} 
writeChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; 
firstLetter = false ; 
} 
else { 
switch ( state ) { 
case Initial : state = WordMachineState . Initial ; 
break ; 
case StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; 
break ; 
} 
upper = false ; 
} 
} 
return result . toString ( ) ; 
} 
} 

public class LoggingDiagnostic { 
public static String currentConfiguration ( ) { 
StringBuffer rtn = new StringBuffer ( 1024 ) ; 
String loggingConfigClass = System . getProperty ( "java.util.logging.config.class" ) ; 
String loggingConfigFile = System . getProperty ( "java.util.logging.config.file" ) ; 
boolean configClassOK = false ; 
if ( loggingConfigClass == null ) rtn . append ( "No java.util.logging.config.class class is set.\n" ) ; 
else { 
rtn . append ( "java.util.logging.config.class is set to '" ) . append ( loggingConfigClass ) . append ( "'\n" ) ; 
try { 
Class c = Class . forName ( loggingConfigClass ) ; 
c . newInstance ( ) ; 
rtn . append ( "This class was loaded and a new instance was sucessfully created.\n" ) ; 
configClassOK = true ; 
} 
catch ( ClassNotFoundException e ) { 
e = null ; 
rtn . append ( loggingConfigClass ) . append ( " could not be found." ) ; 
} 
catch ( InstantiationException e ) { 
e = null ; 
rtn . append ( loggingConfigClass ) . append ( " could not be instantiated." ) ; 
} 
catch ( IllegalAccessException e ) { 
e = null ; 
rtn . append ( loggingConfigClass ) . append ( " could not be accessed." ) ; 
} 
} 
if ( loggingConfigFile == null ) rtn . append ( "No java.util.logging.config.file file is set.\n" ) ; 
else { 
rtn . append ( "java.util.logging.config.file is set to '" ) . append ( loggingConfigFile ) . append ( "'\n" ) ; 
File loggingFile = new File ( loggingConfigFile ) ; 
rtn . append ( loggingFile . getAbsolutePath ( ) ) . append ( "\n" ) ; 
if ( ! loggingFile . exists ( ) || ! loggingFile . isFile ( ) ) rtn . append ( "This file does NOT EXIST.\n" ) ; 
if ( loggingConfigClass != null ) if ( configClassOK ) rtn . append ( "This file is ignored because java.util.logging.config.class is set.\n" ) ; 
} 
Handler [ ] handlers = Logger . getLogger ( "" ) . getHandlers ( ) ; 
listHandlers ( handlers , rtn ) ; 
return rtn . toString ( ) ; 
} 
} 

public class LoggingDiagnostic { 
private static StringBuffer listHandlers ( Handler [ ] handlers , StringBuffer buffer ) { 
for ( Handler handler : handlers ) { 
Class < ? extends Handler > handlerClass = handler . getClass ( ) ; 
Formatter formatter = handler . getFormatter ( ) ; 
buffer . append ( "Handler:" ) . append ( handlerClass . getName ( ) ) . append ( "\n" ) ; 
buffer . append ( "Level:" ) . append ( handler . getLevel ( ) . toString ( ) ) . append ( "\n" ) ; 
if ( formatter != null ) buffer . append ( "Formatter:" ) . append ( formatter . getClass ( ) . getName ( ) ) . append ( "\n" ) ; 
} 
return buffer ; 
} 
} 

public class WAMBaseMachine { 
public WAMCallPoint resolveCallPoint ( int functorName ) { 
WAMCallPoint result = ( WAMCallPoint ) symbolTable . get ( functorName , SYMKEY_CALLPOINTS ) ; 
if ( result == null ) result = new WAMCallPoint ( - 1 , 0 , functorName ) ; 
return result ; 
} 
} 

public class HierarchyAttribute { 
public boolean isSubCategory ( HierarchyAttribute comp ) { 
if ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) return false ; 
List < String > otherPath = comp . getPathValue ( ) ; 
List < String > path = getPathValue ( ) ; 
if ( otherPath . size ( ) <= path . size ( ) ) return false ; 
boolean subcat = true ; 
for ( int i = 0 ; 
i < path . size ( ) ; 
i ++ ) if ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { 
subcat = false ; 
break ; 
} 
return subcat ; 
} 
} 

public class HierarchyAttribute { 
public String getValueAtLevel ( String level ) { 
int index = attributeClass . levels . indexOf ( level ) ; 
if ( index == - 1 ) throw new IllegalArgumentException ( "Level name " + level + " is not known to this hierarchy attribute type." ) ; 
return getValueAtLevel ( index ) ; 
} 
} 

public class ManhattanHeuristic { 
public float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { 
HeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; 
if ( parentNode == null ) { 
int h = 0 ; 
for ( int j = 0 ; 
j < 3 ; 
j ++ ) for ( int i = 0 ; 
i < 3 ; 
i ++ ) { 
char nextTile = state . getTileAt ( i , j ) ; 
int goalX = state . getGoalXForTile ( nextTile ) ; 
int goalY = state . getGoalYForTile ( nextTile ) ; 
int diffX = goalX - i ; 
diffX = ( diffX < 0 ) ? - diffX : diffX ; 
int diffY = goalY - j ; 
diffY = ( diffY < 0 ) ? - diffY : diffY ; 
h += diffX + diffY ; 
} 
return ( float ) h ; 
} 
else { 
EightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; 
float h = parentNode . getH ( ) ; 
char playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; 
int emptyX = parentState . getEmptyX ( ) ; 
int emptyY = parentState . getEmptyY ( ) ; 
char movedTile = state . getTileAt ( emptyX , emptyY ) ; 
int oldX = 0 ; 
int oldY = 0 ; 
switch ( playedMove ) { 
case 'L' : { 
oldX = emptyX - 1 ; 
break ; 
} 
case 'R' : { 
oldX = emptyX + 1 ; 
break ; 
} 
case 'U' : { 
oldY = emptyY - 1 ; 
break ; 
} 
case 'D' : { 
oldY = emptyY + 1 ; 
break ; 
} 
default : { 
throw new IllegalStateException ( "Unkown operator: " + playedMove + "." ) ; 
} 
} 
int change = 0 ; 
switch ( playedMove ) { 
case 'L' : case 'R' : { 
int goalX = state . getGoalXForTile ( movedTile ) ; 
int newX = emptyX ; 
int oldDiffX = oldX - goalX ; 
oldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; 
int newDiffX = newX - goalX ; 
newDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; 
change = newDiffX - oldDiffX ; 
break ; 
} 
case 'U' : case 'D' : { 
int goalY = state . getGoalYForTile ( movedTile ) ; 
int newY = emptyY ; 
int oldDiffY = oldY - goalY ; 
oldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; 
int newDiffY = newY - goalY ; 
newDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; 
change = newDiffY - oldDiffY ; 
break ; 
} 
default : { 
throw new IllegalStateException ( "Unkown operator: " + playedMove + "." ) ; 
} 
} 
return ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; 
} 
} 
} 

public class ErrorHandler { 
public static void handleErrors ( Throwable exception , ActionErrors errors ) { 
log . log ( Level . SEVERE , exception . getMessage ( ) , exception ) ; 
if ( exception . getCause ( ) == null ) log . fine ( "Exception.getCause() is null" ) ; 
if ( ( exception instanceof WrappedStrutsServletException ) && ( exception . getCause ( ) != null ) ) { 
exception = exception . getCause ( ) ; 
log . fine ( "Unwrapped WrappedStrutsServletException" ) ; 
} 
Writer stackTrace = new StringWriter ( ) ; 
exception . printStackTrace ( new PrintWriter ( new HTMLFilter ( stackTrace ) ) ) ; 
errors . add ( "exception" , new ActionError ( "error.general" , stackTrace ) ) ; 
if ( exception instanceof UserReadableError ) { 
UserReadableError userError = ( UserReadableError ) exception ; 
if ( userError . isUserReadable ( ) ) { 
if ( userError . getUserMessageKey ( ) != null ) errors . add ( "generalerror" , new ActionError ( userError . getUserMessageKey ( ) , userError . getUserMessageKey ( ) ) ) ; 
else errors . add ( "generalerror" , new ActionError ( "error.general" , userError . getUserMessage ( ) ) ) ; 
return ; 
} 
} 
errors . add ( "generalerror" , new ActionError ( "error.internalerror" ) ) ; 
} 
} 

public class HTMLFilter { 
public void write ( String str , int off , int len ) throws IOException { 
String inputString = str . substring ( off , off + len ) ; 
StringBuffer outputString = new StringBuffer ( ) ; 
for ( StringTokenizer tokenizer = new StringTokenizer ( inputString , "\n" , true ) ; 
tokenizer . hasMoreTokens ( ) ; 
) { 
String nextToken = tokenizer . nextToken ( ) ; 
if ( "\n" . equals ( nextToken ) ) outputString . append ( "<br>" ) ; 
else outputString . append ( nextToken ) ; 
} 
out . write ( outputString . toString ( ) ) ; 
} 
} 

public class ProtoDTMachine { 
public Map < String , OrdinalAttribute > classify ( State state ) throws ClassifyingFailureException { 
DecisionTree currentNode = dt ; 
while ( true ) { 
DecisionTreeElement element = currentNode . getElement ( ) ; 
if ( element instanceof Decision ) { 
Decision decision = ( Decision ) element ; 
currentNode = decision . decide ( state ) ; 
} 
else if ( element instanceof Assignment ) { 
Assignment assignment = ( Assignment ) element ; 
Map < String , OrdinalAttribute > assignmentMap = new HashMap < String , OrdinalAttribute > ( ) ; 
assignmentMap . put ( assignment . getPropertyName ( ) , assignment . getAttribute ( ) ) ; 
return assignmentMap ; 
} 
else throw new ClassifyingFailureException ( "A node which is not a decision was encountered." , null ) ; 
} 
} 
} 

public class PartialOrdering { 
public int compare ( T a , T b ) { 
boolean aRb = partialOrdering . evaluate ( a , b ) ; 
if ( ! aRb ) return - 1 ; 
boolean bRa = partialOrdering . evaluate ( b , a ) ; 
return ( aRb && bRa ) ? 0 : 1 ; 
} 
} 

public class BitHackUtils { 
public static int intLogBase2v2 ( int value ) { 
int temp ; 
if ( ( temp = value >> 24 ) > 0 ) return 24 + LOG_TABLE_256 [ temp ] ; 
else if ( ( temp = value >> 16 ) > 0 ) return 16 + LOG_TABLE_256 [ temp ] ; 
else if ( ( temp = value >> 8 ) > 0 ) return 8 + LOG_TABLE_256 [ temp ] ; 
else return LOG_TABLE_256 [ value ] ; 
} 
} 

public class BitHackUtils { 
public static int getCharacterCountInt32 ( int value ) { 
if ( value >= 0 ) return getCharacterCountUInt32 ( value ) ; 
else if ( value == Integer . MIN_VALUE ) return getCharacterCountUInt32 ( Integer . MAX_VALUE ) + 1 ; 
else return getCharacterCountUInt32 ( - value ) + 1 ; 
} 
} 

public class BitHackUtils { 
public static int getCharacterCountInt64 ( long value ) { 
if ( value >= 0 ) return getCharacterCountUInt64 ( value ) ; 
else if ( value == Long . MIN_VALUE ) return getCharacterCountUInt64 ( Long . MAX_VALUE ) + 1 ; 
else return getCharacterCountUInt64 ( - value ) + 1 ; 
} 
} 

public class BitHackUtils { 
public static int getCharacterCountDecimal ( long integerValue , int scale ) { 
boolean isNeg = integerValue < 0 ; 
int totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; 
int totalLength = totalDigits ; 
if ( isNeg ) totalDigits -- ; 
if ( scale > 0 ) { 
totalLength ++ ; 
if ( scale >= totalDigits ) totalLength += ( scale - totalDigits ) + 1 ; 
} 
else totalLength -= scale ; 
return totalLength ; 
} 
} 

public class WAMCompiledQuery { 
public void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { 
if ( sizeof ( ) > Integer . MAX_VALUE ) throw new IllegalStateException ( "The instruction listing size exceeds Integer.MAX_VALUE." ) ; 
int length = 0 ; 
for ( WAMInstruction instruction : instructions ) { 
instruction . emmitCode ( buffer , machine ) ; 
length += instruction . sizeof ( ) ; 
} 
this . machine = machine ; 
this . callPoint = callPoint ; 
this . status = LinkStatus . Linked ; 
} 
} 

public class WorkFlowController { 
protected void setCurrentScreen ( WorkFlowScreenPanel screen ) { 
panel . removeAll ( ) ; 
panel . add ( screen ) ; 
if ( ! accessedScreens . contains ( screen ) ) accessedScreens . push ( screen ) ; 
state . setCurrentScreenState ( screen . getState ( ) ) ; 
currentScreen = screen ; 
screen . initialize ( ) ; 
panel . validate ( ) ; 
} 
} 

public class ContextualProperties { 
protected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { 
return new Iterator ( ) { 
private int i ; 
public boolean hasNext ( ) { 
return ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; 
} 
public Object next ( ) { 
if ( ! hasNext ( ) ) return null ; 
int o = ORDER [ i ] ; 
String result = ( ( ( o & E ) != 0 ) ? ( environment + "." ) : "" ) + ( ( ( o & B ) != 0 ) ? ( base + "." ) : "" ) + ( ( ( o & M ) != 0 ) ? ( modifier + "." ) : "" ) + key ; 
i ++ ; 
return result ; 
} 
public void remove ( ) { 
throw new UnsupportedOperationException ( "remove() is not supported on this key order iterator as " + "the ordering cannot be changed" ) ; 
} 
} 
; 
} 
} 

public class BaseThrottle { 
public void setRate ( float hertz ) { 
if ( hertz <= 0.0f ) throw new IllegalArgumentException ( "The throttle rate must be above zero." ) ; 
cycleTimeNanos = ( long ) ( 1000000000f / hertz ) ; 
firstCall = false ; 
firstCheckCall = false ; 
} 
} 

public class UMinus { 
protected NumericType evaluate ( NumericType firstNumber ) { 
if ( firstNumber . isInteger ( ) ) return new IntLiteral ( - firstNumber . intValue ( ) ) ; 
else return new DoubleLiteral ( - firstNumber . doubleValue ( ) ) ; 
} 
} 

public class PropertyReaderBase { 
protected void findProperties ( ) { 
properties = getPropertiesUsingSystemProperty ( ) ; 
if ( properties != null ) return ; 
properties = getPropertiesUsingClasspath ( ) ; 
if ( properties != null ) return ; 
properties = getPropertiesUsingCWD ( ) ; 
if ( properties != null ) return ; 
} 
} 

public class PropertyReaderBase { 
protected Properties getPropertiesUsingClasspath ( ) { 
InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( getPropertiesResourceName ( ) ) ; 
if ( is != null ) try { 
return PropertiesHelper . getProperties ( is ) ; 
} 
catch ( IOException e ) { 
e = null ; 
} 
return null ; 
} 
} 

public class Variable { 
public Term getValue ( ) { 
Term result = this ; 
Term assignment = this . substitution ; 
while ( assignment != null ) { 
result = assignment ; 
if ( ! assignment . isVar ( ) ) break ; 
else assignment = ( ( Variable ) assignment ) . substitution ; 
} 
return result ; 
} 
} 

public class SilentFailSocketAppender { 
public void append ( LoggingEvent event ) { 
if ( event == null ) return ; 
if ( address == null ) { 
errorHandler . error ( "No remote host is set for SocketAppender named \"" + this . name + "\"." ) ; 
return ; 
} 
if ( oos != null ) try { 
if ( locationInfo ) event . getLocationInformation ( ) ; 
oos . writeObject ( event ) ; 
oos . flush ( ) ; 
if ( ++ counter >= RESET_FREQUENCY ) { 
counter = 0 ; 
oos . reset ( ) ; 
} 
} 
catch ( IOException e ) { 
oos = null ; 
LogLog . warn ( "Detected problem with connection: " + e ) ; 
if ( reconnectionDelay > 0 ) fireConnector ( ) ; 
} 
} 
} 

public class GlobalWriteLockWithWriteBehindTxMethod { 
public void rollback ( ) { 
TxId txId = null ; 
if ( ! getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { 
txId = TxManager . getTxIdFromThread ( ) ; 
List < TxOperation > alterations = txWrites . get ( txId ) ; 
if ( alterations != null ) for ( TxOperation nextAlteration : alterations ) { 
nextAlteration . cancel ( false ) ; 
} 
txWrites . remove ( txId ) ; 
} 
} 
} 

public class GlobalWriteLockWithWriteBehindTxMethod { 
public void requestWriteOperation ( TxOperation op ) { 
TxId txId = null ; 
if ( getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) > 0 ) { 
txId = TxManager . getTxIdFromThread ( ) ; 
enlistWithSession ( ) ; 
} 
if ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) op . execute ( ) ; 
else addCachedOperation ( txId , op ) ; 
} 
} 

public class GlobalWriteLockWithWriteBehindTxMethod { 
private void acquireGlobalWriteLock ( TxId txId ) throws InterruptedException { 
globalLock . writeLock ( ) . lock ( ) ; 
try { 
if ( ! txId . equals ( globalWriteLockTxId ) ) { 
while ( globalWriteLockTxId != null ) globalWriteLockFree . await ( ) ; 
globalWriteLockTxId = txId ; 
} 
} 
finally { 
globalLock . writeLock ( ) . unlock ( ) ; 
} 
} 
} 

public class GlobalWriteLockWithWriteBehindTxMethod { 
private void enlistWithSession ( ) { 
TxSession session = TxSessionImpl . getCurrentSession ( ) ; 
if ( session == null ) throw new IllegalStateException ( "Cannot access transactional resource outside of a session." ) ; 
session . enlist ( this ) ; 
} 
} 

public class NestedMediaQueries { 
@ Override public boolean enter ( RuleSetNode ruleSetNode ) { 
ScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; 
SelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; 
if ( selectorGroupNode == null ) return true ; 
List < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; 
if ( selectorNodes . size ( ) < 0 ) return true ; 
List < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; 
for ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { 
ScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; 
List < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; 
if ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { 
RuleSetNode newRuleSetNode = new RuleSetNode ( ) ; 
ScopeNode newScopeNode = new ScopeNode ( ) ; 
newRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; 
newRuleSetNode . addChild ( newScopeNode ) ; 
NodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; 
mediaScopeNode . clearChildren ( ) ; 
mediaScopeNode . addChild ( newRuleSetNode ) ; 
} 
for ( RuleSetNode nestedRuleSet : nestedRuleSets ) { 
List < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; 
for ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { 
List < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; 
NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; 
for ( SelectorNode selectorNode : selectorNodes ) { 
for ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { 
if ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) if ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { 
SelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; 
selectorSegmentNode . setCombinator ( " " ) ; 
} 
for ( int j = selectorNode . getChildren ( ) . size ( ) - 1 ; 
j >= 0 ; 
j -- ) if ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { 
SelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; 
nestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; 
} 
nestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; 
nestedSelectorGroupNode . addChild ( new SpacingNode ( " " ) ) ; 
} 
} 
} 
mediaScopeNode . addChild ( nestedRuleSet ) ; 
} 
if ( ruleSetNode . getParent ( ) != null ) { 
ruleSetNode . getParent ( ) . addChild ( new SpacingNode ( "\n" ) ) ; 
ruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; 
} 
} 
return true ; 
} 
} 

public class BatchSynchQueueBase { 
public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { 
if ( e == null ) throw new IllegalArgumentException ( "The 'e' parameter may not be null." ) ; 
ReentrantLock lock = this . lock ; 
lock . lockInterruptibly ( ) ; 
long nanos = unit . toNanos ( timeout ) ; 
try { 
do { 
if ( insert ( e , false ) ) return true ; 
try { 
nanos = notFull . awaitNanos ( nanos ) ; 
} 
catch ( InterruptedException ie ) { 
notFull . signal ( ) ; 
throw ie ; 
} 
} 
while ( nanos > 0 ) ; 
return false ; 
} 
finally { 
lock . unlock ( ) ; 
} 
} 
} 

public class BatchSynchQueueBase { 
public E poll ( long timeout , TimeUnit unit ) throws InterruptedException { 
ReentrantLock lock = this . lock ; 
lock . lockInterruptibly ( ) ; 
try { 
long nanos = unit . toNanos ( timeout ) ; 
do { 
if ( count != 0 ) return extract ( true , true ) . getElement ( ) ; 
try { 
nanos = notEmpty . awaitNanos ( nanos ) ; 
} 
catch ( InterruptedException ie ) { 
notEmpty . signal ( ) ; 
throw ie ; 
} 
} 
while ( nanos > 0 ) ; 
return null ; 
} 
finally { 
lock . unlock ( ) ; 
} 
} 
} 

public class BatchSynchQueueBase { 
protected boolean insert ( E element , boolean unlockAndBlock ) { 
SynchRecordImpl < E > record = new SynchRecordImpl < E > ( element ) ; 
boolean result = buffer . offer ( record ) ; 
if ( result ) { 
count ++ ; 
notEmpty . signal ( ) ; 
if ( unlockAndBlock ) { 
lock . unlock ( ) ; 
record . waitForConsumer ( ) ; 
} 
return true ; 
} 
else return false ; 
} 
} 

public class ScopeNode { 
public ScopeNode callMixin ( String name , ArgumentsNode arguments ) { 
List < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; 
if ( argumentList . size ( ) > _parameterDefinitions . size ( ) ) throw new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; 
ScopeNode mixinScope = clone ( ) ; 
NodeTreeUtils . filterLineBreaks ( mixinScope ) ; 
for ( int i = 0 ; 
i < argumentList . size ( ) ; 
i ++ ) { 
ExpressionGroupNode argument = argumentList . get ( i ) ; 
VariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; 
parameter . clearChildren ( ) ; 
parameter . addChild ( argument ) ; 
} 
getParent ( ) . setVisible ( false ) ; 
return mixinScope ; 
} 
} 

public class ScopeNode { 
private void setAdditionVisitor ( ) { 
setAdditionVisitor ( new InclusiveNodeVisitor ( ) { 
@ Override public boolean add ( ParametersNode node ) { 
for ( VariableDefinitionNode variable : NodeTreeUtils . getChildren ( node , VariableDefinitionNode . class ) ) { 
_parameterDefinitions . add ( variable ) ; 
add ( variable ) ; 
} 
return super . add ( node ) ; 
} 
@ Override public boolean add ( RuleSetNode node ) { 
SelectorGroupNode selectorGroup = NodeTreeUtils . getFirstChild ( node , SelectorGroupNode . class ) ; 
for ( SelectorNode selectorNode : NodeTreeUtils . getChildren ( selectorGroup , SelectorNode . class ) ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( Node selectorChild : selectorNode . getChildren ( ) ) { 
sb . append ( selectorChild . toString ( ) ) ; 
} 
String selector = sb . toString ( ) ; 
if ( ! _selectorToRuleSetMap . containsKey ( selector ) ) _selectorToRuleSetMap . put ( selector , node ) ; 
} 
return super . add ( node ) ; 
} 
@ Override public boolean add ( ScopeNode node ) { 
NodeTreeUtils . moveChildren ( node , ScopeNode . this ) ; 
return false ; 
} 
@ Override public boolean add ( VariableDefinitionNode node ) { 
String name = node . getName ( ) ; 
if ( ! _variableNameToValueMap . containsKey ( name ) ) _variableNameToValueMap . put ( name , NodeTreeUtils . getFirstChild ( node , ExpressionGroupNode . class ) ) ; 
return super . add ( node ) ; 
} 
@ Override public boolean add ( PropertyNode node ) { 
String name = node . getName ( ) ; 
if ( name . equals ( FILTER_PROPERTY ) ) return super . add ( node ) ; 
if ( node . getChildren ( ) . get ( 0 ) . toString ( ) . startsWith ( "-" ) ) return super . add ( node ) ; 
if ( _propertyNameToNodeMap . containsKey ( name ) ) { 
PropertyNode oldPropertyNode = _propertyNameToNodeMap . get ( name ) ; 
int oldPropertyIndex = getChildren ( ) . indexOf ( oldPropertyNode ) ; 
if ( oldPropertyNode . isVisible ( ) ) { 
oldPropertyNode . setVisible ( false ) ; 
if ( ! hideWhiteSpaceNode ( oldPropertyIndex - 1 ) ) hideWhiteSpaceNode ( oldPropertyIndex + 1 ) ; 
} 
} 
_propertyNameToNodeMap . put ( name , node ) ; 
return super . add ( node ) ; 
} 
} 
) ; 
} 
} 

public class WAMResolvingMachine { 
protected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { 
Term result = null ; 
int addr = deref ( start ) ; 
byte tag = getDerefTag ( ) ; 
int val = getDerefVal ( ) ; 
switch ( tag ) { 
case REF : { 
Variable var = variableContext . get ( val ) ; 
if ( var == null ) { 
var = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; 
variableContext . put ( val , var ) ; 
} 
result = var ; 
break ; 
} 
case STR : { 
int fn = getHeap ( val ) ; 
int f = fn & 0x00ffffff ; 
FunctorName functorName = getDeinternedFunctorName ( f ) ; 
int arity = functorName . getArity ( ) ; 
Term [ ] arguments = new Term [ arity ] ; 
for ( int i = 0 ; 
i < arity ; 
i ++ ) arguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; 
result = new Functor ( f , arguments ) ; 
break ; 
} 
case WAMInstruction . CON : { 
int f = val & 0x3fffffff ; 
result = new Functor ( f , null ) ; 
break ; 
} 
case WAMInstruction . LIS : { 
FunctorName functorName = new FunctorName ( "cons" , 2 ) ; 
int f = internFunctorName ( functorName ) ; 
int arity = functorName . getArity ( ) ; 
Term [ ] arguments = new Term [ arity ] ; 
for ( int i = 0 ; 
i < arity ; 
i ++ ) arguments [ i ] = decodeHeap ( val + i , variableContext ) ; 
result = new Functor ( f , arguments ) ; 
break ; 
} 
default : throw new IllegalStateException ( "Encountered unknown tag type on the heap." ) ; 
} 
return result ; 
} 
} 

public class DirectMemento { 
public void capture ( ) { 
Class cls = ob . getClass ( ) ; 
while ( ! cls . equals ( Object . class ) ) { 
Field [ ] attrs = cls . getDeclaredFields ( ) ; 
HashMap map = new HashMap ( ) ; 
values . put ( cls , map ) ; 
for ( Field attr : attrs ) { 
attr . setAccessible ( true ) ; 
if ( shouldBeSaved ( attr ) ) try { 
map . put ( attr . getName ( ) , attr . get ( ob ) ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( "Field '" + attr . getName ( ) + "' could not be accessed but the 'setAccessible(true)' method was invoked on it." , e ) ; 
} 
} 
cls = cls . getSuperclass ( ) ; 
} 
} 
} 

public class DirectMemento { 
public Object get ( Class cls , String attr ) { 
HashMap map ; 
if ( ! values . containsKey ( cls ) ) return null ; 
map = ( HashMap ) values . get ( cls ) ; 
return map . get ( attr ) ; 
} 
} 

public class DirectMemento { 
public void put ( Class cls , String attr , Object val ) { 
HashMap map ; 
if ( values . containsKey ( cls ) ) map = ( HashMap ) values . get ( cls ) ; 
else { 
map = new HashMap ( ) ; 
values . put ( cls , map ) ; 
} 
map . put ( attr , val ) ; 
} 
} 

public class DirectMemento { 
public Collection getAllFieldNames ( Class cls ) { 
if ( ! values . containsKey ( cls ) ) return null ; 
Map map = ( HashMap ) values . get ( cls ) ; 
return map . keySet ( ) ; 
} 
} 

public class LockFreeNQueue { 
public boolean offer ( E o ) { 
if ( o == null ) throw new IllegalArgumentException ( "The 'o' parameter may not be null." ) ; 
int level = priorityToLevel ( p . apply ( o ) ) ; 
Node < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; 
while ( true ) { 
Node < E > t = markers [ level + 1 ] . getTail ( ) ; 
Node < E > s = t . getNext ( ) ; 
if ( t == markers [ level + 1 ] . getTail ( ) ) if ( s == markers [ level + 1 ] ) if ( t . casNext ( s , newNode ) ) { 
markers [ level + 1 ] . casTail ( t , newNode ) ; 
count . incrementAndGet ( ) ; 
return true ; 
} 
else markers [ level + 1 ] . casTail ( t , s ) ; 
} 
} 
} 

public class LockFreeNQueue { 
public E poll ( ) { 
int currentLevel = 0 ; 
while ( true ) { 
Marker < E > h = null ; 
Node < E > first = null ; 
Node < E > second = null ; 
for ( ; 
currentLevel < n ; 
currentLevel ++ ) { 
h = markers [ currentLevel ] ; 
first = h . getNext ( ) ; 
second = first . getNext ( ) ; 
if ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) break ; 
else if ( currentLevel == ( n - 1 ) ) return null ; 
} 
Node < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; 
if ( first == h . getNext ( ) ) if ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) if ( first == null ) return null ; 
else markers [ currentLevel + 1 ] . casTail ( t , first ) ; 
else if ( h . casNext ( first , second ) ) { 
DataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; 
E item = firstDataNode . getItem ( ) ; 
if ( item != null ) { 
firstDataNode . setItem ( null ) ; 
count . decrementAndGet ( ) ; 
return item ; 
} 
} 
} 
} 
} 

public class PropertiesHelper { 
public static Properties getProperties ( String pathname ) throws IOException { 
if ( pathname == null ) return null ; 
if ( isURL ( pathname ) ) return getProperties ( new URL ( pathname ) ) ; 
else return getProperties ( new File ( pathname ) ) ; 
} 
} 

public class BaseState { 
public void addPropertyChangeListener ( PropertyChangeListener l ) { 
if ( listeners == null ) listeners = new ArrayList ( ) ; 
synchronized ( listeners ) { 
listeners . add ( l ) ; 
} 
} 
} 

public class BaseState { 
public void addPropertyChangeListener ( String p , PropertyChangeListener l ) { 
if ( listeners == null ) listeners = new ArrayList ( ) ; 
synchronized ( listeners ) { 
listeners . add ( l ) ; 
} 
} 
} 

public class BaseState { 
public void removePropertyChangeListener ( String p , PropertyChangeListener l ) { 
if ( listeners == null ) return ; 
synchronized ( listeners ) { 
listeners . remove ( l ) ; 
} 
} 
} 

public class BaseState { 
protected void firePropertyChange ( PropertyChangeEvent evt ) { 
final PropertyChangeEvent finalEvent = evt ; 
Iterator it ; 
if ( listeners == null ) return ; 
synchronized ( listeners ) { 
it = listeners . iterator ( ) ; 
while ( it . hasNext ( ) ) { 
final PropertyChangeListener l = ( PropertyChangeListener ) it . next ( ) ; 
Runnable r = new Runnable ( ) { 
public void run ( ) { 
l . propertyChange ( finalEvent ) ; 
} 
} 
; 
SwingUtilities . invokeLater ( r ) ; 
} 
} 
} 
} 

public class DoubleRangeType { 
public static Type createInstance ( String name , double min , double max ) { 
if ( min > max ) throw new IllegalArgumentException ( "'min' must be less than or equal to 'max'." ) ; 
synchronized ( DOUBLE_RANGE_TYPES ) { 
DoubleRangeType newType = new DoubleRangeType ( name , min , max ) ; 
DoubleRangeType oldType = DOUBLE_RANGE_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
DOUBLE_RANGE_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class JsoupMicrodataDocument { 
private static void sanitizeRadioControls ( FormElement form ) { 
Map < String , Element > controlsByName = new HashMap < String , Element > ( ) ; 
for ( Element control : form . elements ( ) ) { 
if ( "radio" . equals ( control . attr ( "type" ) ) && control . hasAttr ( "checked" ) ) { 
String name = control . attr ( "name" ) ; 
if ( controlsByName . containsKey ( name ) ) controlsByName . get ( name ) . attr ( "checked" , false ) ; 
controlsByName . put ( name , control ) ; 
} 
} 
} 
} 

public class BaseUnaryCondition { 
public boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { 
synchronized ( monitor ) { 
long expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; 
long waitNanos = evaluateWithWaitTimeNanos ( t ) ; 
while ( waitNanos > 0 ) { 
long remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; 
if ( remainingTimeNanos <= 0 ) return false ; 
long timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; 
long milliPause = timeToPauseNanos / 1000000 ; 
int nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; 
monitor . wait ( milliPause , nanoPause ) ; 
waitNanos = evaluateWithWaitTimeNanos ( t ) ; 
} 
} 
return true ; 
} 
} 

public class DateRangeType { 
public static Type createInstance ( String name , DateOnly from , DateOnly to ) { 
if ( ( from != null ) && ( to != null ) && ( from . compareTo ( to ) > 0 ) ) throw new IllegalArgumentException ( "'min' must be less than or equal to 'max'." ) ; 
synchronized ( DATE_RANGE_TYPES ) { 
DateRangeType newType = new DateRangeType ( name , from , to ) ; 
DateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
DATE_RANGE_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class ResolutionInterpreter { 
private void evaluateQuery ( ) { 
Iterator < Set < Variable > > i = engine . iterator ( ) ; 
if ( ! i . hasNext ( ) ) { 
System . out . println ( "false. " ) ; 
return ; 
} 
for ( ; 
i . hasNext ( ) ; 
) { 
Set < Variable > solution = i . next ( ) ; 
if ( solution . isEmpty ( ) ) System . out . print ( "true" ) ; 
else for ( Iterator < Variable > j = solution . iterator ( ) ; 
j . hasNext ( ) ; 
) { 
Variable nextVar = j . next ( ) ; 
String varName = engine . getVariableName ( nextVar . getName ( ) ) ; 
System . out . print ( varName + " = " + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; 
if ( j . hasNext ( ) ) System . out . println ( ) ; 
} 
if ( ! i . hasNext ( ) ) { 
System . out . println ( "." ) ; 
break ; 
} 
try { 
int key = consoleReader . readVirtualKey ( ) ; 
if ( key == SEMICOLON ) System . out . println ( " ;" ) ; 
else { 
System . out . println ( ) ; 
break ; 
} 
} 
catch ( IOException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 
} 

public class TypeConverter { 
public static Object convert ( MultiTypeData d , Class c ) { 
if ( ( ( d . typeFlags & BOOLEAN ) != 0 ) && ( Boolean . TYPE . equals ( c ) || Boolean . class . equals ( c ) ) ) return d . booleanValue ; 
else if ( ( ( d . typeFlags & INT ) != 0 ) && ( Integer . TYPE . equals ( c ) || Integer . class . equals ( c ) ) ) return d . intValue ; 
else if ( ( ( d . typeFlags & CHAR ) != 0 ) && ( Character . TYPE . equals ( c ) || Character . class . equals ( c ) ) ) return d . charValue ; 
else if ( ( ( d . typeFlags & BYTE ) != 0 ) && ( Byte . TYPE . equals ( c ) || Byte . class . equals ( c ) ) ) return d . byteValue ; 
else if ( ( ( d . typeFlags & SHORT ) != 0 ) && ( Short . TYPE . equals ( c ) || Short . class . equals ( c ) ) ) return d . shortValue ; 
else if ( ( ( d . typeFlags & LONG ) != 0 ) && ( Long . TYPE . equals ( c ) || Long . class . equals ( c ) ) ) return d . longValue ; 
else if ( ( ( d . typeFlags & FLOAT ) != 0 ) && ( Float . TYPE . equals ( c ) || Float . class . equals ( c ) ) ) return d . floatValue ; 
else if ( ( ( d . typeFlags & DOUBLE ) != 0 ) && ( Double . TYPE . equals ( c ) || Double . class . equals ( c ) ) ) return d . doubleValue ; 
else if ( ( ( d . typeFlags & STRING ) != 0 ) && String . class . equals ( c ) ) return d . stringValue ; 
else if ( ( ( d . typeFlags & OBJECT ) != 0 ) && d . objectValue . getClass ( ) . equals ( c ) ) return d . objectValue ; 
else throw new ClassCastException ( "The multi data type, " + d + ", cannot be converted to the class, " + c + "." ) ; 
} 
} 

public class CircularArrayMap { 
public void clearUpTo ( int key ) { 
if ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { 
int newStart ; 
for ( newStart = start ; 
( newStart <= end ) && ( newStart <= key ) ; 
newStart ++ ) { 
int offset = offset ( newStart ) ; 
if ( data [ offset ] != null ) { 
data [ offset ] = null ; 
count -- ; 
} 
} 
for ( ; 
newStart <= end ; 
newStart ++ ) if ( data [ offset ( newStart ) ] != null ) break ; 
start = newStart ; 
} 
else { 
int newStart ; 
for ( newStart = start ; 
( newStart <= end ) ; 
newStart ++ ) { 
int offset = offset ( newStart ) ; 
if ( data [ offset ] != null ) { 
data [ offset ] = null ; 
count -- ; 
} 
} 
start = newStart ; 
offset = - start ; 
} 
} 
} 

public class CircularArrayMap { 
private void expand ( int key ) { 
int newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; 
int newSpaceSize = spaceRequired ( key ) ; 
int newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; 
Object [ ] oldData = data ; 
data = new Object [ newSize ] ; 
int offsetStart = offset ( start ) ; 
int offsetEnd = offset ( end ) ; 
if ( offsetStart < offsetEnd ) System . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; 
else { 
System . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; 
System . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; 
} 
offset = - start ; 
length = newSize ; 
} 
} 

public class DynamicOperatorParser { 
public Term parseOperators ( Term [ ] terms ) throws SourceCodeException { 
stack . offer ( 0 ) ; 
state = 0 ; 
position = 0 ; 
nextTerm = null ; 
for ( position = 0 ; 
position <= terms . length ; 
) { 
Symbol nextSymbol ; 
if ( position < terms . length ) { 
nextTerm = terms [ position ] ; 
if ( nextTerm instanceof CandidateOpSymbol ) nextSymbol = Symbol . Op ; 
else nextSymbol = Symbol . Term ; 
} 
else nextSymbol = Symbol . Final ; 
Action action = actionTable [ state ] [ nextSymbol . ordinal ( ) ] ; 
action . apply ( ) ; 
} 
return ( Functor ) outputStack . poll ( ) ; 
} 
} 

public class DynamicOperatorParser { 
protected static OpSymbol checkAndResolveToFixity ( CandidateOpSymbol candidate , OpSymbol . Fixity ... fixities ) throws SourceCodeException { 
OpSymbol result = null ; 
for ( OpSymbol . Fixity fixity : fixities ) { 
result = candidate . getPossibleOperators ( ) . get ( fixity ) ; 
if ( result != null ) break ; 
} 
if ( result == null ) throw new SourceCodeException ( "Operator " + candidate + " must be one of " + Arrays . toString ( fixities ) + ", but does not have the required form." , null , null , null , candidate . getSourceCodePosition ( ) ) ; 
return result ; 
} 
} 

public class SearchNode { 
public SearchNode < O , T > makeNode ( Successor successor ) throws SearchNotExhaustiveException { 
SearchNode newNode ; 
try { 
newNode = getClass ( ) . newInstance ( ) ; 
newNode . state = successor . getState ( ) ; 
newNode . parent = this ; 
newNode . appliedOp = successor . getOperator ( ) ; 
newNode . depth = depth + 1 ; 
newNode . pathCost = pathCost + successor . getCost ( ) ; 
if ( repeatedStateFilter != null ) newNode . setRepeatedStateFilter ( repeatedStateFilter ) ; 
return newNode ; 
} 
catch ( InstantiationException e ) { 
throw new IllegalStateException ( "InstantiationException during creation of new search node." , e ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( "IllegalAccessException during creation of new search node." , e ) ; 
} 
} 
} 

public class CommandLineParser { 
public static String rightPad ( String stringToPad , String padder , int size ) { 
if ( padder . length ( ) == 0 ) return stringToPad ; 
StringBuffer strb = new StringBuffer ( stringToPad ) ; 
CharacterIterator sci = new StringCharacterIterator ( padder ) ; 
while ( strb . length ( ) < size ) for ( char ch = sci . first ( ) ; 
ch != CharacterIterator . DONE ; 
ch = sci . next ( ) ) if ( strb . length ( ) < size ) strb . append ( String . valueOf ( ch ) ) ; 
return strb . toString ( ) ; 
} 
} 

public class CommandLineParser { 
public String getErrors ( ) { 
if ( parsingErrors . isEmpty ( ) ) return "" ; 
String result = "" ; 
for ( String s : parsingErrors ) { 
result += s ; 
} 
return result ; 
} 
} 

public class CommandLineParser { 
public String getOptionsInForce ( ) { 
if ( parsedProperties == null ) return "" ; 
String result = "Options in force:\n" ; 
for ( Map . Entry < Object , Object > property : parsedProperties . entrySet ( ) ) { 
result += property . getKey ( ) + " = " + property . getValue ( ) + "\n" ; 
} 
return result ; 
} 
} 

public class CommandLineParser { 
public void addTrailingPairsToProperties ( Properties properties ) { 
if ( trailingProperties != null ) for ( Object propKey : trailingProperties . keySet ( ) ) { 
String name = ( String ) propKey ; 
String value = trailingProperties . getProperty ( name ) ; 
properties . setProperty ( name , value ) ; 
} 
} 
} 

public class CommandLineParser { 
public void addOptionsToProperties ( Properties properties ) { 
if ( parsedProperties != null ) for ( Object propKey : parsedProperties . keySet ( ) ) { 
String name = ( String ) propKey ; 
String value = parsedProperties . getProperty ( name ) ; 
if ( ! name . matches ( "^[0-9]+$" ) ) properties . setProperty ( name , value ) ; 
} 
} 
} 

public class CommandLineParser { 
private Properties takeFreeArgsAsProperties ( Properties properties , int from ) { 
Properties result = new Properties ( ) ; 
for ( int i = from ; 
true ; 
i ++ ) { 
String nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; 
if ( nextFreeArg == null ) break ; 
String [ ] nameValuePair = nextFreeArg . split ( "=" ) ; 
if ( nameValuePair . length == 2 ) result . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; 
} 
return result ; 
} 
} 

public class CommandLineParser { 
private void checkArgumentFormat ( CommandLineOption optionInfo , CharSequence matchedArg ) { 
if ( optionInfo . argumentFormatRegexp != null ) { 
Pattern pattern = Pattern . compile ( optionInfo . argumentFormatRegexp ) ; 
Matcher argumentMatcher = pattern . matcher ( matchedArg ) ; 
if ( ! argumentMatcher . matches ( ) ) parsingErrors . add ( "The argument to option " + optionInfo . option + " does not meet its required format.\n" ) ; 
} 
} 
} 

public class Comparisons { 
public static < T , U > String compareIterators ( Iterator < U > iterator , Iterator < T > expectedIterator , Function < U , T > mapping ) { 
String errorMessage = "" ; 
while ( iterator . hasNext ( ) ) { 
U next = iterator . next ( ) ; 
T nextMapped = mapping . apply ( next ) ; 
T nextExpected = expectedIterator . next ( ) ; 
if ( ! nextMapped . equals ( nextExpected ) ) errorMessage += "Expecting " + nextExpected + " but got " + nextMapped ; 
} 
return errorMessage ; 
} 
} 

public class FloatRangeType { 
public static Type createInstance ( String name , float min , float max ) { 
if ( min > max ) throw new IllegalArgumentException ( "'min' must be less than or equal to 'max'." ) ; 
synchronized ( FLOAT_RANGE_TYPES ) { 
FloatRangeType newType = new FloatRangeType ( name , min , max ) ; 
FloatRangeType oldType = FLOAT_RANGE_TYPES . get ( name ) ; 
if ( ( oldType != null ) && ! oldType . equals ( newType ) ) throw new IllegalArgumentException ( "The type '" + name + "' already exists and cannot be redefined." ) ; 
else if ( ( oldType != null ) && oldType . equals ( newType ) ) return oldType ; 
else { 
FLOAT_RANGE_TYPES . put ( name , newType ) ; 
return newType ; 
} 
} 
} 
} 

public class WAMResolvingJavaMachine { 
public void reset ( ) { 
data = ByteBuffer . allocateDirect ( TOP << 2 ) . order ( ByteOrder . LITTLE_ENDIAN ) . asIntBuffer ( ) ; 
codeBuffer = ByteBuffer . allocateDirect ( CODE_SIZE ) ; 
codeBuffer . order ( ByteOrder . LITTLE_ENDIAN ) ; 
hp = HEAP_BASE ; 
hbp = HEAP_BASE ; 
sp = HEAP_BASE ; 
ep = 0 ; 
bp = 0 ; 
b0 = 0 ; 
trp = TRAIL_BASE ; 
up = TOP ; 
writeMode = false ; 
ip = 0 ; 
derefTag = 0 ; 
derefVal = 0 ; 
suspended = false ; 
super . reset ( ) ; 
setInternalCodeAddress ( internFunctorName ( "call" , 1 ) , CALL_1_ID ) ; 
setInternalCodeAddress ( internFunctorName ( "execute" , 1 ) , EXECUTE_1_ID ) ; 
if ( monitor != null ) monitor . onReset ( this ) ; 
} 
} 

public class WAMResolvingJavaMachine { 
protected String traceChoiceFrame ( ) { 
if ( bp == 0 ) return "" ; 
int n = data . get ( bp ) ; 
return "choice: [ n = " + data . get ( bp ) + ", ep = " + data . get ( bp + n + 1 ) + ", cp = " + data . get ( bp + n + 2 ) + ", bp = " + data . get ( bp + n + 3 ) + ", l = " + data . get ( bp + n + 4 ) + ", trp = " + data . get ( bp + n + 5 ) + ", hp = " + data . get ( bp + n + 6 ) + ", b0 = " + data . get ( bp + n + 7 ) ; 
} 
} 

public class WAMResolvingJavaMachine { 
private int nextStackFrame ( ) { 
if ( ep == bp ) return STACK_BASE ; 
else if ( ep > bp ) return ep + data . get ( ep + 2 ) + 3 ; 
else return bp + data . get ( bp ) + 8 ; 
} 
} 

public class WAMResolvingJavaMachine { 
private boolean backtrack ( ) { 
if ( bp == 0 ) return true ; 
else { 
b0 = data . get ( bp + data . get ( bp ) + 7 ) ; 
ip = data . get ( bp + data . get ( bp ) + 4 ) ; 
return false ; 
} 
} 
} 

public class WAMResolvingJavaMachine { 
private void tidyTrail ( ) { 
int i ; 
if ( bp == 0 ) i = TRAIL_BASE ; 
else i = data . get ( bp + data . get ( bp ) + 5 ) ; 
while ( i < trp ) { 
int addr = data . get ( i ) ; 
if ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) i ++ ; 
else { 
data . put ( i , data . get ( trp - 1 ) ) ; 
trp -- ; 
} 
} 
} 
} 

public class WAMResolvingJavaMachine { 
private boolean unify ( int a1 , int a2 ) { 
uPush ( a1 ) ; 
uPush ( a2 ) ; 
boolean fail = false ; 
while ( ! uEmpty ( ) && ! fail ) { 
int d1 = deref ( uPop ( ) ) ; 
int t1 = derefTag ; 
int v1 = derefVal ; 
int d2 = deref ( uPop ( ) ) ; 
int t2 = derefTag ; 
int v2 = derefVal ; 
if ( d1 != d2 ) if ( ( t1 == WAMInstruction . REF ) ) bind ( d1 , d2 ) ; 
else if ( t2 == WAMInstruction . REF ) bind ( d1 , d2 ) ; 
else if ( t2 == WAMInstruction . STR ) { 
int fn1 = data . get ( v1 ) ; 
int fn2 = data . get ( v2 ) ; 
byte n1 = ( byte ) ( fn1 >>> 24 ) ; 
if ( fn1 == fn2 ) for ( int i = 1 ; 
i <= n1 ; 
i ++ ) { 
uPush ( v1 + i ) ; 
uPush ( v2 + i ) ; 
} 
else fail = true ; 
} 
else if ( t2 == WAMInstruction . CON ) if ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) fail = true ; 
else if ( t2 == WAMInstruction . LIS ) if ( t1 != WAMInstruction . LIS ) fail = true ; 
else { 
uPush ( v1 ) ; 
uPush ( v2 ) ; 
uPush ( v1 + 1 ) ; 
uPush ( v2 + 1 ) ; 
} 
} 
return ! fail ; 
} 
} 

public class EightPuzzleState { 
public static boolean isSolvable ( EightPuzzleState state ) { 
EightPuzzleState checkState ; 
try { 
checkState = ( EightPuzzleState ) state . clone ( ) ; 
} 
catch ( CloneNotSupportedException e ) { 
throw new IllegalStateException ( "Puzzle state could not be cloned." , e ) ; 
} 
EightPuzzleState goalState = getGoalState ( ) ; 
int illegalSwaps = 0 ; 
for ( int j = 0 ; 
j < 3 ; 
j ++ ) for ( int i = 0 ; 
i < 3 ; 
i ++ ) { 
char t = goalState . getTileAt ( i , j ) ; 
illegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; 
} 
return ( illegalSwaps % 2 ) == 0 ; 
} 
} 

public class EightPuzzleState { 
public Iterator < Operator < String > > validOperators ( boolean reverse ) { 
List < Operator < String > > moves = new ArrayList < Operator < String > > ( 4 ) ; 
if ( emptyY != 0 ) moves . add ( new OperatorImpl < String > ( "U" ) ) ; 
if ( emptyY != 2 ) moves . add ( new OperatorImpl < String > ( "D" ) ) ; 
if ( emptyX != 0 ) moves . add ( new OperatorImpl < String > ( "L" ) ) ; 
if ( emptyX != 2 ) moves . add ( new OperatorImpl < String > ( "R" ) ) ; 
return moves . iterator ( ) ; 
} 
} 

public class EightPuzzleState { 
public String prettyPrint ( ) { 
String result = "" ; 
for ( int j = 0 ; 
j < 3 ; 
j ++ ) result += new String ( board [ j ] ) + "\n" ; 
result = result . replace ( 'E' , ' ' ) ; 
return result ; 
} 
} 

public class EightPuzzleState { 
protected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { 
int illegal = 0 ; 
int tileX = getXForTile ( t ) ; 
int tileY = getYForTile ( t ) ; 
while ( tileX != x ) if ( ( tileX - x ) > 0 ) { 
if ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) illegal ++ ; 
tileX -- ; 
} 
else { 
if ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) illegal ++ ; 
tileX ++ ; 
} 
while ( tileY != y ) { 
if ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) illegal ++ ; 
tileY -- ; 
} 
return illegal ; 
} 
} 

public class EightPuzzleState { 
private static List < Character > stringToCharList ( String boardString ) { 
char [ ] chars = new char [ 9 ] ; 
boardString . getChars ( 0 , 9 , chars , 0 ) ; 
List < Character > charList = new ArrayList < Character > ( ) ; 
for ( int l = 0 ; 
l < 9 ; 
l ++ ) charList . add ( chars [ l ] ) ; 
return charList ; 
} 
} 

public class EightPuzzleState { 
private static EightPuzzleState charListToState ( List < Character > charList ) { 
EightPuzzleState newState = new EightPuzzleState ( ) ; 
Iterator < Character > k = charList . iterator ( ) ; 
for ( int j = 0 ; 
j < 3 ; 
j ++ ) for ( int i = 0 ; 
i < 3 ; 
i ++ ) { 
char nextChar = k . next ( ) ; 
if ( nextChar == 'E' ) { 
newState . emptyX = i ; 
newState . emptyY = j ; 
} 
newState . board [ j ] [ i ] = nextChar ; 
} 
return newState ; 
} 
} 

public class LoggingToLog4JHandler { 
private String toLog4jMessage ( LogRecord record ) { 
String message = record . getMessage ( ) ; 
Object [ ] parameters = record . getParameters ( ) ; 
if ( ( parameters != null ) && ( parameters . length != 0 ) ) if ( ( message . indexOf ( "{0}" ) >= 0 ) || ( message . indexOf ( "{1}" ) >= 0 ) || ( message . indexOf ( "{2}" ) >= 0 ) || ( message . indexOf ( "{3}" ) >= 0 ) ) message = MessageFormat . format ( message , parameters ) ; 
return message ; 
} 
} 

public class LoggingToLog4JHandler { 
private org . apache . log4j . Level toLog4j ( Level level ) { 
if ( Level . SEVERE == level ) return org . apache . log4j . Level . ERROR ; 
else if ( Level . WARNING == level ) return org . apache . log4j . Level . WARN ; 
else if ( Level . INFO == level ) return org . apache . log4j . Level . INFO ; 
else if ( Level . FINE == level ) return org . apache . log4j . Level . DEBUG ; 
else if ( Level . FINER == level ) return org . apache . log4j . Level . TRACE ; 
else if ( Level . OFF == level ) return org . apache . log4j . Level . OFF ; 
return org . apache . log4j . Level . OFF ; 
} 
} 

public class WrapperQueue { 
private void incrementSizeAndCount ( E record ) { 
if ( atomicallyCounted ) count . incrementAndGet ( ) ; 
if ( sizeable && ( record instanceof Sizeable ) ) dataSize . addAndGet ( ( ( Sizeable ) record ) . sizeof ( ) ) ; 
else if ( sizeable ) dataSize . incrementAndGet ( ) ; 
} 
} 

public class WrapperQueue { 
private void decrementSizeAndCount ( E record ) { 
if ( atomicallyCounted ) count . decrementAndGet ( ) ; 
if ( sizeable && ( record instanceof Sizeable ) ) { 
long recordSize = - ( ( Sizeable ) record ) . sizeof ( ) ; 
long oldSize = dataSize . getAndAdd ( recordSize ) ; 
long newSize = oldSize + recordSize ; 
signalOnSizeThresholdCrossing ( oldSize , newSize ) ; 
} 
else if ( sizeable ) { 
long oldSize = dataSize . getAndDecrement ( ) ; 
long newSize = oldSize - 1 ; 
signalOnSizeThresholdCrossing ( oldSize , newSize ) ; 
} 
} 
} 

public class WrapperQueue { 
private void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { 
if ( signalable != null ) if ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) signalable . signalAll ( ) ; 
else if ( ( oldSize >= highWaterSizeThreshold ) && ( newSize < highWaterSizeThreshold ) ) signalable . signal ( ) ; 
} 
} 

public class SimpleContext { 
public NamingEnumeration list ( String name ) throws NamingException { 
if ( "" . equals ( name ) ) return new FlatNames ( bindings . keys ( ) ) ; 
Object target = lookup ( name ) ; 
if ( target instanceof Context ) return ( ( Context ) target ) . list ( "" ) ; 
throw new NotContextException ( name + " cannot be listed" ) ; 
} 
} 

public class SimpleContext { 
public NamingEnumeration listBindings ( String name ) throws NamingException { 
if ( "" . equals ( name ) ) return new FlatBindings ( bindings . keys ( ) ) ; 
Object target = lookup ( name ) ; 
if ( target instanceof Context ) return ( ( Context ) target ) . listBindings ( "" ) ; 
throw new NotContextException ( name + " cannot be listed" ) ; 
} 
} 

public class SimpleContext { 
public Object addToEnvironment ( String propName , Object propVal ) { 
if ( myEnv == null ) myEnv = new Hashtable ( 5 , 0.75f ) ; 
return myEnv . put ( propName , propVal ) ; 
} 
} 

public class SimpleContext { 
public Object removeFromEnvironment ( String propName ) { 
if ( myEnv == null ) return null ; 
return myEnv . remove ( propName ) ; 
} 
} 

public class Parser { 
boolean resolveMixinReference ( String name , ArgumentsNode arguments ) { 
if ( ! isParserTranslationEnabled ( ) ) return push ( new PlaceholderNode ( new SimpleNode ( name ) ) ) ; 
for ( Node node : getContext ( ) . getValueStack ( ) ) { 
if ( ! ( node instanceof ScopeNode ) ) continue ; 
ScopeNode scope = ( ScopeNode ) node ; 
RuleSetNode ruleSet = scope . getRuleSet ( name ) ; 
if ( ruleSet == null ) continue ; 
ScopeNode ruleSetScope = NodeTreeUtils . getFirstChild ( ruleSet , ScopeNode . class ) . callMixin ( name , arguments ) ; 
return push ( ruleSetScope ) ; 
} 
throw new UndefinedMixinException ( name ) ; 
} 
} 

public class Parser { 
boolean pushVariableReference ( String name ) { 
if ( ! isParserTranslationEnabled ( ) ) return push ( new SimpleNode ( name ) ) ; 
for ( Node node : getContext ( ) . getValueStack ( ) ) { 
if ( ! ( node instanceof ScopeNode ) ) continue ; 
ScopeNode scope = ( ScopeNode ) node ; 
if ( ! scope . isVariableDefined ( name ) ) continue ; 
return push ( new VariableReferenceNode ( name ) ) ; 
} 
throw new UndefinedVariableException ( name ) ; 
} 
} 

public class TextTableImpl { 
public void setMaxRowHeight ( int row , int height ) { 
Integer previousValue = maxRowSizes . get ( row ) ; 
if ( previousValue == null ) maxRowSizes . put ( row , height ) ; 
else if ( previousValue < height ) maxRowSizes . put ( row , height ) ; 
} 
} 

public class TextTableImpl { 
private void updateMaxColumnWidth ( int column , int width ) { 
Integer previousValue = maxColumnSizes . get ( column ) ; 
if ( previousValue == null ) maxColumnSizes . put ( column , width ) ; 
else if ( previousValue < width ) maxColumnSizes . put ( column , width ) ; 
} 
} 

public class PageAction { 
public ActionForward executeWithErrorHandling ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response , ActionErrors errors ) throws Exception { 
HttpSession session = request . getSession ( false ) ; 
DynaActionForm pageForm = ( DynaActionForm ) form ; 
log . fine ( "pageForm = " + pageForm ) ; 
String listingVarName = pageForm . getString ( VAR_NAME_PARAM ) ; 
log . fine ( "listingVarName = " + listingVarName ) ; 
PagedList pagedList = ( PagedList ) session . getAttribute ( listingVarName ) ; 
pagedList . setCurrentPage ( ( Integer ) pageForm . get ( NUMBER_PARAM ) ) ; 
Integer index = ( Integer ) pageForm . get ( INDEX_PARAM ) ; 
if ( index != null ) pagedList . setCurrentIndex ( index ) ; 
return mapping . findForward ( SUCCESS_FORWARD ) ; 
} 
} 

public class Cons { 
private String listToString ( VariableAndFunctorInterner interner , boolean isFirst , boolean printVarName , boolean printBindings ) { 
String result = "" ; 
if ( isFirst ) result += "[" ; 
result += arguments [ 0 ] . toString ( interner , printVarName , printBindings ) ; 
Term consArgument = arguments [ 1 ] . getValue ( ) ; 
if ( consArgument instanceof Cons ) result += ", " + ( ( Cons ) consArgument ) . listToString ( interner , false , printVarName , printBindings ) ; 
if ( isFirst ) result += "]" ; 
return result ; 
} 
} 

public class LessThan { 
protected boolean evaluate ( NumericType firstNumber , NumericType secondNumber ) { 
if ( firstNumber . isInteger ( ) && secondNumber . isInteger ( ) ) return firstNumber . intValue ( ) < secondNumber . intValue ( ) ; 
else return firstNumber . doubleValue ( ) < secondNumber . doubleValue ( ) ; 
} 
} 

public class FibonacciHeap { 
private static int ceilingLog2 ( int n ) { 
int oa ; 
int i ; 
int b ; 
oa = n ; 
b = 32 / 2 ; 
i = 0 ; 
while ( b != 0 ) { 
i = ( i << 1 ) ; 
if ( n >= ( 1 << b ) ) { 
n /= ( 1 << b ) ; 
i = i | 1 ; 
} 
else n &= ( 1 << b ) - 1 ; 
b /= 2 ; 
} 
if ( ( 1 << i ) == oa ) return i ; 
else return i + 1 ; 
} 
} 

public class FibonacciHeap { 
private void updateMinimum ( Node node ) { 
if ( entryComparator != null ) if ( entryComparator . compare ( node . element , minNode . element ) < 0 ) minNode = node ; 
else if ( ( ( Comparable ) node . element ) . compareTo ( minNode . element ) < 0 ) minNode = node ; 
} 
} 

public class FibonacciHeap { 
private int compare ( Node node1 , Node node2 ) { 
if ( entryComparator != null ) return entryComparator . compare ( node1 . element , node2 . element ) ; 
else return ( ( Comparable ) node1 . element ) . compareTo ( node2 . element ) ; 
} 
} 

public class Filterator { 
public T nextInSequence ( ) { 
T result = null ; 
while ( source . hasNext ( ) ) { 
S next = source . next ( ) ; 
result = mapping . apply ( next ) ; 
if ( result != null ) break ; 
} 
return result ; 
} 
} 

public class BeanMemento { 
public Object get ( Class cls , String property ) throws NoSuchFieldException { 
if ( ! values . containsKey ( property ) ) throw new NoSuchFieldException ( "The property, " + property + ", does not exist on the underlying class." ) ; 
return values . get ( property ) ; 
} 
} 

public class BeanMemento { 
private void capture ( boolean ignoreNull ) { 
Class cls = ob . getClass ( ) ; 
Method [ ] methods = cls . getMethods ( ) ; 
for ( Method nextMethod : methods ) { 
String methodName = nextMethod . getName ( ) ; 
if ( methodName . startsWith ( "get" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { 
String propName = Character . toLowerCase ( methodName . charAt ( 3 ) ) + methodName . substring ( 4 ) ; 
try { 
Object [ ] params = new Object [ ] { 
} 
; 
Object value = nextMethod . invoke ( ob , params ) ; 
if ( ! ignoreNull || ( value != null ) ) values . put ( propName , value ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( e ) ; 
} 
catch ( InvocationTargetException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 
} 
} 

public class FifoStack { 
public E pop ( ) { 
E ob ; 
if ( size ( ) == 0 ) return null ; 
ob = get ( 0 ) ; 
remove ( 0 ) ; 
return ob ; 
} 
} 

public class SwingKeyCombinationBuilder { 
private String modifiersToString ( int modifiers ) { 
String result = "" ; 
if ( ( modifiers & InputEvent . SHIFT_MASK ) != 0 ) result += "shift " ; 
if ( ( modifiers & InputEvent . CTRL_MASK ) != 0 ) result += "ctrl " ; 
if ( ( modifiers & InputEvent . META_MASK ) != 0 ) result += "meta " ; 
if ( ( modifiers & InputEvent . ALT_MASK ) != 0 ) result += "alt " ; 
if ( ( modifiers & InputEvent . ALT_GRAPH_MASK ) != 0 ) result += "altGraph " ; 
return result ; 
} 
} 

public class OptimizeInstructions { 
public boolean isConstant ( WAMInstruction instruction ) { 
Integer name = instruction . getFunctorNameReg1 ( ) ; 
if ( name != null ) { 
FunctorName functorName = interner . getDeinternedFunctorName ( name ) ; 
if ( functorName . getArity ( ) == 0 ) return true ; 
} 
return false ; 
} 
} 

public class OptimizeInstructions { 
private boolean isVoidVariable ( WAMInstruction instruction ) { 
SymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; 
if ( symbolKey != null ) { 
Integer count = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_OCCURRENCE_COUNT ) ; 
Boolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_NON_ARG ) ; 
Integer allocation = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_ALLOCATION ) ; 
boolean singleton = ( count != null ) && count . equals ( 1 ) ; 
boolean nonArgPosition = ( nonArgPositionOnly != null ) && TRUE . equals ( nonArgPositionOnly ) ; 
boolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & 0xff00 ) >> 8 ) == WAMInstruction . STACK_ADDR ) ; 
if ( singleton && nonArgPosition && ! permanent ) return true ; 
} 
return false ; 
} 
} 

public class OptimizeInstructions { 
private boolean isNonArg ( WAMInstruction instruction ) { 
SymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; 
if ( symbolKey != null ) { 
Boolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_FUNCTOR_NON_ARG ) ; 
if ( TRUE . equals ( nonArgPositionOnly ) ) return true ; 
} 
return false ; 
} 
} 

public class Clause { 
public Iterator < Operator < Term > > getChildren ( boolean reverse ) { 
if ( ( traverser != null ) && ( traverser instanceof ClauseTraverser ) ) return ( ( ClauseTraverser ) traverser ) . traverse ( this , reverse ) ; 
else { 
LinkedList < Operator < Term > > resultList = null ; 
if ( ! reverse ) resultList = new LinkedList < Operator < Term > > ( ) ; 
else resultList = new StackQueue < Operator < Term > > ( ) ; 
if ( head != null ) resultList . add ( head ) ; 
if ( body != null ) for ( Term bodyTerm : body ) { 
resultList . add ( bodyTerm ) ; 
} 
return resultList . iterator ( ) ; 
} 
} 
} 

public class Functor { 
public Term getArgument ( int index ) { 
if ( ( arguments == null ) || ( index > ( arguments . length - 1 ) ) ) return null ; 
else return arguments [ index ] ; 
} 
} 

public class Functor { 
public Iterator < Operator < Term > > getChildren ( boolean reverse ) { 
if ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) return ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; 
else if ( arguments == null ) return new LinkedList < Operator < Term > > ( ) . iterator ( ) ; 
else if ( ! reverse ) return Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; 
else { 
List < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; 
for ( int i = arity - 1 ; 
i >= 0 ; 
i -- ) argList . add ( arguments [ i ] ) ; 
return argList . iterator ( ) ; 
} 
} 
} 

public class SqlQueryEngine { 
public < T extends MeasureAppender > T retrieveSummary ( SchemaDefinition schemaDefinition , Class < T > resultClazz , QueryParameter queryParameter ) throws NovieRuntimeException { 
final SqlQueryBuilder < T > sqlQueryBuilder = new SqlQueryBuilder < T > ( schemaDefinition , resultClazz , queryParameter . partialCopy ( QueryParameterKind . GROUPS , QueryParameterKind . PAGE ) ) ; 
List < T > result = executeQuery ( sqlQueryBuilder ) ; 
if ( result . isEmpty ( ) ) throw new NovieRuntimeException ( "Summary doesn't return any result." ) ; 
if ( result . size ( ) > 1 ) throw new NovieRuntimeException ( "Summary returns more than one result." ) ; 
return result . get ( 0 ) ; 
} 
} 

public class SqlQueryEngine { 
private < T extends MeasureAppender > List < T > executeQuery ( final SqlQueryBuilder < T > sqlQueryBuilder ) throws NovieRuntimeException { 
sqlQueryBuilder . buildQuery ( ) ; 
final String queryString = sqlQueryBuilder . getQueryString ( ) ; 
LOG . debug ( queryString ) ; 
long beforeQuery = System . currentTimeMillis ( ) ; 
List < T > returnValue = jdbcTemplate . query ( queryString , sqlQueryBuilder . getMapSqlParameterSource ( ) , sqlQueryBuilder ) ; 
if ( LOG . isInfoEnabled ( ) ) LOG . info ( "SQL query successfully ran in " + ( System . currentTimeMillis ( ) - beforeQuery ) + "ms." ) ; 
if ( LOG . isDebugEnabled ( ) ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( Entry < String , Object > e : sqlQueryBuilder . getMapSqlParameterSource ( ) . getValues ( ) . entrySet ( ) ) { 
if ( sb . length ( ) > 0 ) sb . append ( "," ) ; 
sb . append ( e . getKey ( ) ) ; 
sb . append ( "=" ) ; 
sb . append ( e . getValue ( ) ) ; 
} 
sb . insert ( 0 , "Parameters [" ) ; 
sb . append ( "]" ) ; 
LOG . debug ( sb . toString ( ) ) ; 
} 
return returnValue ; 
} 
} 

public class JavaType { 
private void setBasicType ( Class c ) { 
if ( Boolean . class . equals ( c ) ) type = BasicTypes . BOOLEAN ; 
else if ( Character . class . equals ( c ) ) type = BasicTypes . CHARACTER ; 
else if ( Byte . class . equals ( c ) ) type = BasicTypes . BYTE ; 
else if ( Short . class . equals ( c ) ) type = BasicTypes . SHORT ; 
else if ( Integer . class . equals ( c ) ) type = BasicTypes . INTEGER ; 
else if ( Long . class . equals ( c ) ) type = BasicTypes . LONG ; 
else if ( Float . class . equals ( c ) ) type = BasicTypes . FLOAT ; 
else if ( Double . class . equals ( c ) ) type = BasicTypes . DOUBLE ; 
else type = BasicTypes . OTHER ; 
} 
} 

public class ResolutionEngine { 
public void consultInputStream ( InputStream stream ) throws SourceCodeException { 
Source < Token > tokenSource = TokenSource . getTokenSourceForInputStream ( stream ) ; 
getParser ( ) . setTokenSource ( tokenSource ) ; 
while ( true ) { 
Sentence < S > sentence = getParser ( ) . parse ( ) ; 
if ( sentence == null ) break ; 
getCompiler ( ) . compile ( sentence ) ; 
} 
} 
} 

public class SocketReadThread { 
private void readStream ( ) throws Exception { 
while ( ! shutdown ) { 
Element doc = reader . parseDocument ( ) . getRootElement ( ) ; 
if ( doc == null ) return ; 
Packet packet ; 
String tag = doc . getName ( ) ; 
if ( "message" . equals ( tag ) ) packet = new Message ( doc ) ; 
else if ( "presence" . equals ( tag ) ) packet = new Presence ( doc ) ; 
else if ( "iq" . equals ( tag ) ) packet = getIQ ( doc ) ; 
else throw new XmlPullParserException ( "Unknown packet type was read: " + tag ) ; 
component . processPacket ( packet ) ; 
} 
} 
} 

public class Player { 
@ Override public void renderFinalOutput ( List < T > data , EventModel eventModel ) { 
if ( StartMusicRequest . verify ( eventModel , capabilities , this , activators ) ) if ( isOutputRunning ( ) ) playerError ( PlayerError . ERROR_ALREADY_PLAYING , eventModel . getSource ( ) ) ; 
else handleEventRequest ( eventModel ) ; 
else if ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( MusicUsageResource . ID ) ) ) if ( isOutputRunning ( ) ) eventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . forEach ( resourceModel -> playerError ( PlayerError . ERROR_ALREADY_PLAYING , resourceModel . getProvider ( ) ) ) ; 
else handleResourceRequest ( eventModel ) ; 
else handleCommands ( eventModel ) ; 
} 
} 

public class Player { 
private void handleEventRequest ( EventModel eventModel ) { 
playingThread = submit ( ( Runnable ) ( ) -> { 
if ( runsInPlay ) isRunning = false ; 
else isRunning = true ; 
isPlaying = true ; 
fireStartMusicRequest ( eventModel ) ; 
} 
) . thenRun ( ( ) -> play ( eventModel ) ) . thenRun ( ( ) -> { 
if ( runsInPlay ) { 
isRunning = false ; 
isPlaying = false ; 
endedSound ( ) ; 
} 
} 
) ; 
} 
} 

public class PacketReader { 
synchronized public void startup ( ) throws XMPPException { 
final List < Exception > errors = new LinkedList < Exception > ( ) ; 
AbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { 
@ Override public void connectionClosedOnError ( Exception e ) { 
errors . add ( e ) ; 
} 
} 
; 
connection . addConnectionListener ( connectionErrorListener ) ; 
readerThread . start ( ) ; 
try { 
int waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; 
wait ( 3 * waitTime ) ; 
} 
catch ( InterruptedException ie ) { 
} 
connection . removeConnectionListener ( connectionErrorListener ) ; 
if ( connectionID == null ) throw new XMPPException ( "Connection failed. No response from server." ) ; 
else if ( ! errors . isEmpty ( ) ) throw new XMPPException ( errors . iterator ( ) . next ( ) ) ; 
else connection . connectionID = connectionID ; 
} 
} 

public class PacketReader { 
public void shutdown ( ) { 
if ( ! done ) for ( ConnectionListener listener : connection . getConnectionListeners ( ) ) { 
try { 
listener . connectionClosed ( ) ; 
} 
catch ( Exception e ) { 
LOGGER . log ( Level . ERROR , "Error in listener while closing connection" , e ) ; 
} 
} 
done = true ; 
listenerExecutor . shutdown ( ) ; 
} 
} 

public class PacketReader { 
private void parsePackets ( Thread thread ) { 
try { 
while ( ! done ) { 
if ( reset ) { 
startStream ( ) ; 
LOGGER . debug ( "Started xmlstream..." ) ; 
reset = false ; 
continue ; 
} 
Element doc = innerReader . parseDocument ( ) . getRootElement ( ) ; 
if ( doc == null ) { 
connection . disconnect ( ) ; 
LOGGER . debug ( "End of xmlstream." ) ; 
continue ; 
} 
Packet packet = null ; 
LOGGER . debug ( "Processing packet " + doc . asXML ( ) ) ; 
packet = parseFromPlugins ( doc , packet ) ; 
if ( packet == null ) packet = parseFromCore ( doc ) ; 
if ( packet != null ) processPacket ( packet ) ; 
} 
} 
catch ( Exception e ) { 
if ( ! done && ! connection . isSocketClosed ( ) ) { 
connection . notifyConnectionError ( e ) ; 
if ( ! connection . isConnected ( ) ) releaseConnectionIDLock ( ) ; 
} 
} 
} 
} 

public class PacketReader { 
private void processPacket ( Packet packet ) { 
if ( packet == null ) return ; 
for ( PacketCollector collector : connection . getPacketCollectors ( ) ) { 
collector . processPacket ( packet ) ; 
} 
listenerExecutor . submit ( new ListenerNotification ( packet ) ) ; 
} 
} 

public class AbstractApplicationOption { 
protected final void setCliOption ( Option option ) { 
if ( option != null ) this . cliOption = option ; 
if ( this . cliOption . getDescription ( ) != null ) this . descr = this . cliOption . getDescription ( ) ; 
else this . cliOption . setDescription ( this . descr ) ; 
} 
} 

public class InternalContent { 
public void setProperty ( String key , Object value ) { 
if ( readOnly ) return ; 
if ( value == null ) throw new IllegalArgumentException ( "value must not be null" ) ; 
Object o = content . get ( key ) ; 
if ( ! value . equals ( o ) ) { 
updatedContent . put ( key , value ) ; 
updated = true ; 
} 
else if ( updatedContent . containsKey ( key ) && ! value . equals ( updatedContent . get ( key ) ) ) { 
updatedContent . put ( key , value ) ; 
updated = true ; 
} 
} 
} 

public class OrFilter { 
public void addFilter ( PacketFilter filter ) { 
if ( filter == null ) throw new IllegalArgumentException ( "Parameter cannot be null." ) ; 
if ( size == filters . length ) { 
PacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; 
for ( int i = 0 ; 
i < filters . length ; 
i ++ ) newFilters [ i ] = filters [ i ] ; 
filters = newFilters ; 
} 
filters [ size ] = filter ; 
size ++ ; 
} 
} 

public class ModificationRequest { 
public void processRequest ( HttpServletRequest request ) throws IOException , FileUploadException , StorageClientException , AccessDeniedException { 
boolean debug = LOGGER . isDebugEnabled ( ) ; 
if ( ServletFileUpload . isMultipartContent ( request ) ) { 
if ( debug ) LOGGER . debug ( "Multipart POST " ) ; 
feedback . add ( "Multipart Upload" ) ; 
ServletFileUpload upload = new ServletFileUpload ( ) ; 
FileItemIterator iterator = upload . getItemIterator ( request ) ; 
while ( iterator . hasNext ( ) ) { 
FileItemStream item = iterator . next ( ) ; 
if ( debug ) LOGGER . debug ( "Got Item {}" , item ) ; 
String name = item . getFieldName ( ) ; 
InputStream stream = item . openStream ( ) ; 
if ( item . isFormField ( ) ) { 
ParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; 
String propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; 
RequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; 
feedback . add ( pt . feedback ( propertyName ) ) ; 
} 
else if ( streamProcessor != null ) feedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; 
} 
if ( debug ) LOGGER . debug ( "No More items " ) ; 
} 
else { 
if ( debug ) LOGGER . debug ( "Trad Post " ) ; 
@ SuppressWarnings ( "unchecked" ) Map < String , String [ ] > parameters = request . getParameterMap ( ) ; 
if ( debug ) LOGGER . debug ( "Traditional POST {} " , parameters ) ; 
Set < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; 
for ( Entry < String , String [ ] > param : entries ) { 
String name = ( String ) param . getKey ( ) ; 
ParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; 
String propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; 
RequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; 
feedback . add ( pt . feedback ( propertyName ) ) ; 
} 
} 
} 
} 

public class PacketWriter { 
private Packet nextPacket ( ) { 
Packet packet = null ; 
while ( ! done && ( packet = queue . poll ( ) ) == null ) try { 
synchronized ( queue ) { 
queue . wait ( ) ; 
} 
} 
catch ( InterruptedException ie ) { 
} 
return packet ; 
} 
} 

public class StringUtils { 
private static String xmlAttribEncodeBinary ( String value ) { 
StringBuilder s = new StringBuilder ( ) ; 
char buf [ ] = value . toCharArray ( ) ; 
for ( char c : buf ) { 
switch ( c ) { 
case '<' : s . append ( "&lt;" ) ; 
break ; 
case '>' : s . append ( "&gt;" ) ; 
break ; 
case '&' : s . append ( "&amp;" ) ; 
break ; 
case '"' : s . append ( "&quot;" ) ; 
break ; 
case '\'' : s . append ( "&apos;" ) ; 
break ; 
default : if ( c <= 0x1f || ( 0x7f <= c && c <= 0x9f ) ) { 
s . append ( "&#x" ) ; 
s . append ( String . format ( "%X" , ( int ) c ) ) ; 
s . append ( ';' ) ; 
} 
else s . append ( c ) ; 
} 
} 
return s . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String encodeHex ( byte [ ] bytes ) { 
StringBuilder hex = new StringBuilder ( bytes . length * 2 ) ; 
for ( byte aByte : bytes ) { 
if ( ( ( int ) aByte & 0xff ) < 0x10 ) hex . append ( "0" ) ; 
hex . append ( Integer . toString ( ( int ) aByte & 0xff , 16 ) ) ; 
} 
return hex . toString ( ) ; 
} 
} 

public class CommandHandler { 
private void handleVolume ( EventModel eventModel , ResourceModel < String > resourceModel ) { 
Optional < Volume > volumeResource = VolumeResource . getVolume ( eventModel ) ; 
if ( ! volumeResource . isPresent ( ) ) musicHelper . playerError ( PlayerError . ERROR_ILLEGAL + "command: " + resourceModel . getResource ( ) + "missing resource" , resourceModel . getProvider ( ) ) ; 
changeVolume . accept ( volumeResource . get ( ) ) ; 
} 
} 

public class CommandHandler { 
private void handleJump ( EventModel eventModel , ResourceModel < String > resourceModel ) { 
Optional < Progress > progress = ProgressResource . getProgress ( eventModel ) ; 
if ( ! progress . isPresent ( ) ) musicHelper . playerError ( PlayerError . ERROR_ILLEGAL + "command: " + resourceModel . getResource ( ) + "missing resource" , resourceModel . getProvider ( ) ) ; 
jumpProgress . accept ( progress . get ( ) ) ; 
} 
} 

public class CommandHandler { 
private void handleSelectTrack ( EventModel eventModel , ResourceModel < String > resourceModel ) { 
Optional < TrackInfo > trackInfo = TrackInfoResource . getTrackInfo ( eventModel ) ; 
if ( ! trackInfo . isPresent ( ) ) musicHelper . playerError ( PlayerError . ERROR_ILLEGAL + "command: " + resourceModel . getResource ( ) + "missing resource" , resourceModel . getProvider ( ) ) ; 
selectTrack . accept ( trackInfo . get ( ) ) ; 
} 
} 

public class StorageClientUtils { 
public static String getAltField ( String field , String streamId ) { 
if ( streamId == null ) return field ; 
return field + "/" + streamId ; 
} 
} 

public class StorageClientUtils { 
@ SuppressWarnings ( "unchecked" ) public static < K , V > Map < K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { 
if ( ( modified == null || modified . size ( ) == 0 ) && ( include == null ) && ( exclude == null || exclude . size ( ) == 0 ) ) if ( source instanceof ImmutableMap ) return source ; 
else return ImmutableMap . copyOf ( source ) ; 
Builder < K , V > filteredMap = new ImmutableMap . Builder < K , V > ( ) ; 
for ( Entry < K , V > e : source . entrySet ( ) ) { 
K k = e . getKey ( ) ; 
if ( include == null || include . contains ( k ) ) if ( exclude == null || ! exclude . contains ( k ) ) if ( modified != null && modified . containsKey ( k ) ) { 
V o = modified . get ( k ) ; 
if ( o instanceof Map ) filteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; 
else if ( includingRemoveProperties ) filteredMap . put ( k , o ) ; 
else if ( ! ( o instanceof RemoveProperty ) ) filteredMap . put ( k , o ) ; 
} 
else { 
Object o = e . getValue ( ) ; 
if ( o instanceof Map ) filteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; 
else filteredMap . put ( k , e . getValue ( ) ) ; 
} 
} 
if ( modified != null ) for ( Entry < K , V > e : modified . entrySet ( ) ) { 
K k = e . getKey ( ) ; 
if ( ! source . containsKey ( k ) ) { 
V v = e . getValue ( ) ; 
if ( ! ( v instanceof RemoveProperty ) && v != null ) filteredMap . put ( k , v ) ; 
} 
} 
return filteredMap . build ( ) ; 
} 
} 

public class StorageClientUtils { 
public static Session adaptToSession ( Object source ) { 
if ( source instanceof SessionAdaptable ) return ( ( SessionAdaptable ) source ) . getSession ( ) ; 
else { 
Object userManager = safeMethod ( source , "getUserManager" , new Object [ 0 ] , new Class [ 0 ] ) ; 
if ( userManager != null ) return ( Session ) safeMethod ( userManager , "getSession" , new Object [ 0 ] , new Class [ 0 ] ) ; 
return null ; 
} 
} 
} 

public class StorageClientUtils { 
private static Object safeMethod ( Object target , String methodName , Object [ ] args , @ SuppressWarnings ( "rawtypes" ) Class [ ] argsTypes ) { 
if ( target != null ) try { 
Method m = target . getClass ( ) . getMethod ( methodName , argsTypes ) ; 
if ( ! m . isAccessible ( ) ) m . setAccessible ( true ) ; 
return m . invoke ( target , args ) ; 
} 
catch ( Throwable e ) { 
LOGGER . info ( "Failed to invoke method " + methodName + " " + target , e ) ; 
} 
return null ; 
} 
} 

public class StorageClientUtils { 
public static void deleteTree ( ContentManager contentManager , String path ) throws AccessDeniedException , StorageClientException { 
Content content = contentManager . get ( path ) ; 
if ( content != null ) for ( String childPath : content . listChildPaths ( ) ) { 
deleteTree ( contentManager , childPath ) ; 
} 
contentManager . delete ( path ) ; 
} 
} 

public class AbstractDao { 
@ Override public void updateOne ( E object , String ... properties ) { 
if ( object . getId ( ) == null ) throw new RuntimeException ( "Not a Persisted entity" ) ; 
if ( properties == null || properties . length == 0 ) { 
entityManager . merge ( object ) ; 
return ; 
} 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( "Update " + clazz . getName ( ) + " SET " ) ; 
Map < String , Object > cache = new HashMap < String , Object > ( ) ; 
for ( String prop : properties ) { 
try { 
Field field = object . getClass ( ) . getDeclaredField ( prop ) ; 
field . setAccessible ( true ) ; 
Object value = field . get ( object ) ; 
if ( value instanceof Collection ) throw new RuntimeException ( "Collection property is not suppotred." ) ; 
cache . put ( prop , value ) ; 
if ( cache . size ( ) > 1 ) sb . append ( " ," ) ; 
sb . append ( prop ) ; 
sb . append ( " = :" ) ; 
sb . append ( prop ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
if ( cache . size ( ) == 0 ) return ; 
sb . append ( " WHERE id = " + object . getId ( ) ) ; 
Query query = entityManager . createQuery ( sb . toString ( ) ) ; 
for ( Entry < String , Object > entry : cache . entrySet ( ) ) { 
query . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
query . executeUpdate ( ) ; 
} 
} 

public class KeepAliveManager { 
public void setPingInterval ( long newPingInterval ) { 
if ( pingInterval == newPingInterval ) return ; 
if ( newPingInterval > 0 ) enableExecutorService ( ) ; 
pingInterval = newPingInterval ; 
if ( pingInterval < 0 ) stopPinging ( ) ; 
else schedulePingServerTask ( ) ; 
} 
} 

public class KeepAliveManager { 
private synchronized void schedulePingServerTask ( ) { 
enableExecutorService ( ) ; 
stopPingServerTask ( ) ; 
if ( pingInterval > 0 ) periodicPingTask = periodicPingExecutorService . schedule ( new Runnable ( ) { 
@ Override public void run ( ) { 
Ping ping = new Ping ( ) ; 
PacketFilter responseFilter = new PacketIDFilter ( ping . getID ( ) ) ; 
Connection connection = weakRefConnection . get ( ) ; 
final PacketCollector response = pingFailedListeners . isEmpty ( ) ? null : connection . createPacketCollector ( responseFilter ) ; 
connection . sendPacket ( ping ) ; 
if ( response != null ) periodicPingExecutorService . schedule ( new Runnable ( ) { 
@ Override public void run ( ) { 
Packet result = response . nextResult ( 1 ) ; 
response . cancel ( ) ; 
if ( result == null ) for ( PingFailedListener listener : pingFailedListeners ) { 
listener . pingFailed ( ) ; 
} 
} 
} 
, SmackConfiguration . getPacketReplyTimeout ( ) , TimeUnit . MILLISECONDS ) ; 
} 
} 
, getPingInterval ( ) , TimeUnit . MILLISECONDS ) ; 
} 
} 

public class ExecS_CliParser { 
public ExecS_CliParser addAllOptions ( ApplicationOption < ? > [ ] options ) { 
if ( options != null ) for ( ApplicationOption < ? > option : options ) { 
this . addOption ( option ) ; 
} 
return this ; 
} 
} 

public class ExecS_CliParser { 
public boolean hasOption ( Option option ) { 
if ( option == null ) return false ; 
if ( this . usedOptions . contains ( option . getOpt ( ) ) ) return true ; 
if ( this . usedOptions . contains ( option . getLongOpt ( ) ) ) return true ; 
return false ; 
} 
} 

public class XMPPConnection { 
private void initConnection ( ) throws XMPPException { 
boolean isFirstInitialization = packetReader == null || packetWriter == null ; 
compressionHandler = null ; 
serverAckdCompression = false ; 
initReaderAndWriter ( ) ; 
try { 
if ( isFirstInitialization ) { 
packetWriter = new PacketWriter ( this ) ; 
packetReader = new PacketReader ( this ) ; 
if ( config . isDebuggerEnabled ( ) ) { 
addPacketListener ( debugger . getReaderListener ( ) , null ) ; 
if ( debugger . getWriterListener ( ) != null ) addPacketSendingListener ( debugger . getWriterListener ( ) , null ) ; 
} 
} 
else { 
packetWriter . init ( ) ; 
packetReader . init ( ) ; 
} 
packetWriter . startup ( ) ; 
packetReader . startup ( ) ; 
connected = true ; 
if ( isFirstInitialization ) for ( ConnectionCreationListener listener : getConnectionCreationListeners ( ) ) { 
listener . connectionCreated ( this ) ; 
} 
} 
catch ( XMPPException ex ) { 
if ( packetWriter != null ) { 
try { 
packetWriter . shutdown ( ) ; 
} 
catch ( Throwable ignore ) { 
} 
packetWriter = null ; 
} 
if ( packetReader != null ) { 
try { 
packetReader . shutdown ( ) ; 
} 
catch ( Throwable ignore ) { 
} 
packetReader = null ; 
} 
if ( reader != null ) { 
try { 
reader . close ( ) ; 
} 
catch ( Throwable ignore ) { 
} 
reader = null ; 
} 
if ( writer != null ) { 
try { 
writer . close ( ) ; 
} 
catch ( Throwable ignore ) { 
} 
writer = null ; 
} 
if ( socket != null ) { 
try { 
socket . close ( ) ; 
} 
catch ( Exception e ) { 
} 
socket = null ; 
} 
this . setWasAuthenticated ( authenticated ) ; 
authenticated = false ; 
connected = false ; 
throw ex ; 
} 
} 
} 

public class XMPPConnection { 
void startTLSReceived ( boolean required ) { 
if ( required && config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) { 
notifyConnectionError ( new IllegalStateException ( "TLS required by server but not allowed by connection configuration" ) ) ; 
return ; 
} 
if ( config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) return ; 
try { 
writer . write ( "<starttls xmlns=\"urn:ietf:params:xml:ns:xmpp-tls\"/>" ) ; 
writer . flush ( ) ; 
} 
catch ( IOException e ) { 
notifyConnectionError ( e ) ; 
} 
} 
} 

public class XMPPConnection { 
private XMPPInputOutputStream maybeGetCompressionHandler ( ) { 
if ( compressionMethods != null ) for ( XMPPInputOutputStream handler : compressionHandlers ) { 
if ( ! handler . isSupported ( ) ) continue ; 
String method = handler . getCompressionMethod ( ) ; 
if ( compressionMethods . contains ( method ) ) return handler ; 
} 
return null ; 
} 
} 

public class NakamuraMain { 
private static void log ( PrintStream out , String prefix , String message , Throwable t ) { 
final StringBuilder linePrefixBuilder = new StringBuilder ( ) ; 
synchronized ( fmt ) { 
linePrefixBuilder . append ( fmt . format ( new Date ( ) ) ) ; 
} 
linePrefixBuilder . append ( prefix ) ; 
linePrefixBuilder . append ( " [" ) ; 
linePrefixBuilder . append ( Thread . currentThread ( ) . getName ( ) ) ; 
linePrefixBuilder . append ( "] " ) ; 
final String linePrefix = linePrefixBuilder . toString ( ) ; 
out . print ( linePrefix ) ; 
out . println ( message ) ; 
if ( t != null ) t . printStackTrace ( new PrintStream ( out ) { 
@ Override public void println ( String x ) { 
synchronized ( this ) { 
print ( linePrefix ) ; 
super . println ( x ) ; 
flush ( ) ; 
} 
} 
} 
) ; 
} 
} 

public class StartEvent { 
public static Optional < StartEvent > createStartEvent ( Identification source , boolean isUsingJava ) { 
try { 
StartEvent startEvent ; 
if ( isUsingJava ) startEvent = new StartEvent ( source ) ; 
else startEvent = new StartEvent ( source , IS_USING_NON_JAVA_OUTPUT ) ; 
return Optional . of ( startEvent ) ; 
} 
catch ( IllegalArgumentException e ) { 
return Optional . empty ( ) ; 
} 
} 
} 

public class ObservableWriter { 
private void notifyListeners ( String str ) { 
WriterListener [ ] writerListeners = null ; 
synchronized ( listeners ) { 
writerListeners = new WriterListener [ listeners . size ( ) ] ; 
listeners . toArray ( writerListeners ) ; 
} 
for ( int i = 0 ; 
i < writerListeners . length ; 
i ++ ) writerListeners [ i ] . write ( str ) ; 
} 
} 

public class CachingManagerImpl { 
protected Map < String , Object > getCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { 
Map < String , Object > m = null ; 
String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; 
CacheHolder cacheHolder = getFromCacheInternal ( cacheKey ) ; 
if ( cacheHolder != null ) { 
m = cacheHolder . get ( ) ; 
if ( m != null ) LOGGER . debug ( "Cache Hit {} {} {} " , new Object [ ] { 
cacheKey , cacheHolder , m } 
) ; 
} 
if ( m == null ) { 
m = client . get ( keySpace , columnFamily , key ) ; 
if ( m != null ) LOGGER . debug ( "Cache Miss, Found Map {} {}" , cacheKey , m ) ; 
putToCacheInternal ( cacheKey , new CacheHolder ( m ) , true ) ; 
} 
return m ; 
} 
} 

public class CachingManagerImpl { 
private String getCacheKey ( String keySpace , String columnFamily , String key ) throws StorageClientException { 
if ( client instanceof RowHasher ) return ( ( RowHasher ) client ) . rowHash ( keySpace , columnFamily , key ) ; 
return keySpace + ":" + columnFamily + ":" + key ; 
} 
} 

public class CachingManagerImpl { 
protected void removeCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { 
if ( sharedCache != null ) { 
final String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; 
putToCacheInternal ( cacheKey , new CacheHolder ( null , managerId ) , false ) ; 
LOGGER . debug ( "Marked as deleted in Cache {} " , cacheKey ) ; 
if ( client instanceof Disposer ) ( ( Disposer ) client ) . registerDisposable ( new Disposable ( ) { 
@ Override public void setDisposer ( Disposer disposer ) { 
} 
@ Override public void close ( ) { 
CacheHolder ch = sharedCache . get ( cacheKey ) ; 
if ( ch != null && ch . wasLockedTo ( managerId ) ) { 
sharedCache . remove ( cacheKey ) ; 
LOGGER . debug ( "Removed deleted marker from Cache {} " , cacheKey ) ; 
} 
} 
} 
) ; 
} 
client . remove ( keySpace , columnFamily , key ) ; 
} 
} 

public class CachingManagerImpl { 
protected void putCached ( String keySpace , String columnFamily , String key , Map < String , Object > encodedProperties , boolean probablyNew ) throws StorageClientException { 
String cacheKey = null ; 
if ( sharedCache != null ) cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; 
if ( sharedCache != null && ! probablyNew ) { 
CacheHolder ch = getFromCacheInternal ( cacheKey ) ; 
if ( ch != null && ch . isLocked ( this . managerId ) ) { 
LOGGER . debug ( "Is Locked {} " , ch ) ; 
return ; 
} 
} 
LOGGER . debug ( "Saving {} {} {} {} " , new Object [ ] { 
keySpace , columnFamily , key , encodedProperties } 
) ; 
client . insert ( keySpace , columnFamily , key , encodedProperties , probablyNew ) ; 
if ( sharedCache != null ) sharedCache . remove ( cacheKey ) ; 
} 
} 

public class CF_Locator { 
protected final void include ( String name , File file ) { 
if ( ! file . exists ( ) ) return ; 
if ( ! file . isDirectory ( ) ) { 
if ( this . jarFilter . size ( ) > 0 ) { 
boolean ok = false ; 
for ( String s : this . jarFilter ) { 
if ( file . getName ( ) . startsWith ( s ) ) ok = true ; 
} 
if ( ok == false ) return ; 
} 
this . includeJar ( file ) ; 
return ; 
} 
if ( name == null ) name = "" ; 
else name += "." ; 
File [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; 
for ( int i = 0 ; 
i < dirs . length ; 
i ++ ) { 
try { 
this . locationMap . put ( new URI ( "file://" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; 
} 
catch ( IOException ignore ) { 
return ; 
} 
catch ( URISyntaxException ignore ) { 
return ; 
} 
this . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; 
} 
} 
} 

public class CF_Locator { 
private void includeJar ( File file ) { 
if ( file . isDirectory ( ) ) return ; 
URL jarURL = null ; 
JarFile jar = null ; 
try { 
jarURL = new URL ( "jar:" + new URL ( "file:/" + file . getCanonicalPath ( ) ) . toExternalForm ( ) + "!/" ) ; 
JarURLConnection conn = ( JarURLConnection ) jarURL . openConnection ( ) ; 
jar = conn . getJarFile ( ) ; 
} 
catch ( MalformedURLException ignore ) { 
return ; 
} 
catch ( IOException ignore ) { 
return ; 
} 
if ( jar == null ) return ; 
try { 
this . locationMap . put ( jarURL . toURI ( ) , "" ) ; 
} 
catch ( URISyntaxException ignore ) { 
} 
for ( Enumeration < JarEntry > e = jar . entries ( ) ; 
e . hasMoreElements ( ) ; 
) { 
JarEntry entry = e . nextElement ( ) ; 
if ( this . pkgFilter != null && entry . getName ( ) . startsWith ( this . pkgFilter ) ) continue ; 
if ( entry . isDirectory ( ) ) { 
if ( entry . getName ( ) . toUpperCase ( Locale . ENGLISH ) . equals ( "META-INF/" ) ) continue ; 
try { 
this . locationMap . put ( new URI ( jarURL . toExternalForm ( ) + entry . getName ( ) ) , CF_Utils . getPkgName ( entry ) ) ; 
} 
catch ( URISyntaxException ignore ) { 
continue ; 
} 
} 
} 
} 
} 

public class SmackConfiguration { 
public static void addSaslMech ( String mech ) { 
initialize ( ) ; 
if ( ! defaultMechs . contains ( mech ) ) defaultMechs . add ( mech ) ; 
} 
} 

public class ConsoleDebugger { 
private void createDebug ( ) { 
ObservableReader debugReader = new ObservableReader ( reader ) ; 
readerListener = new ReaderListener ( ) { 
public void read ( String str ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " RCV  (" + connection . hashCode ( ) + "): " + str ) ; 
} 
} 
; 
debugReader . addReaderListener ( readerListener ) ; 
ObservableWriter debugWriter = new ObservableWriter ( writer ) ; 
writerListener = new WriterListener ( ) { 
public void write ( String str ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " SENT (" + connection . hashCode ( ) + "): " + str ) ; 
} 
} 
; 
debugWriter . addWriterListener ( writerListener ) ; 
reader = debugReader ; 
writer = debugWriter ; 
listener = new PacketListener ( ) { 
public void processPacket ( Packet packet ) { 
if ( printInterpreted ) System . out . println ( dateFormatter . format ( new Date ( ) ) + " RCV PKT (" + connection . hashCode ( ) + "): " + packet . toXML ( ) ) ; 
} 
} 
; 
connListener = new ConnectionListener ( ) { 
public void connectionClosed ( ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " Connection closed (" + connection . hashCode ( ) + ")" ) ; 
} 
public void connectionClosedOnError ( Exception e ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " Connection closed due to an exception (" + connection . hashCode ( ) + ")" ) ; 
e . printStackTrace ( ) ; 
} 
public void reconnectionFailed ( Exception e ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " Reconnection failed due to an exception (" + connection . hashCode ( ) + ")" ) ; 
e . printStackTrace ( ) ; 
} 
public void reconnectionSuccessful ( ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " Connection reconnected (" + connection . hashCode ( ) + ")" ) ; 
} 
public void reconnectingIn ( int seconds ) { 
System . out . println ( dateFormatter . format ( new Date ( ) ) + " Connection (" + connection . hashCode ( ) + ") will reconnect in " + seconds ) ; 
} 
} 
; 
} 
} 

public class ProxyClientServiceImpl { 
protected void activate ( Map < String , Object > properties ) throws Exception { 
configProperties = properties ; 
String [ ] safePostProcessorNames = ( String [ ] ) configProperties . get ( SAFE_POSTPROCESSORS ) ; 
if ( safePostProcessorNames == null ) { 
safeOpenProcessors . add ( "rss" ) ; 
safeOpenProcessors . add ( "trustedLoginTokenProxyPostProcessor" ) ; 
} 
else for ( String pp : safePostProcessorNames ) { 
safeOpenProcessors . add ( pp ) ; 
} 
String proxyHost = System . getProperty ( "http.proxyHost" , "" ) ; 
if ( ! proxyHost . equals ( "" ) ) useJreProxy = true ; 
} 
} 

public class EventPropertiesAssistant { 
public void registerEventID ( String description , String key , String value ) { 
BufferedWriter bufferedWriter ; 
FileOutputStream out = null ; 
try { 
out = new FileOutputStream ( eventPropertiesPath , true ) ; 
bufferedWriter = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; 
doWithLock ( out . getChannel ( ) , lock -> { 
unlockedReloadFile ( ) ; 
if ( getEventID ( key ) != null ) return ; 
try { 
bufferedWriter . write ( "\n\n" + key + "_DESCRIPTION = " + description + "\n" + key + " = " + value ) ; 
bufferedWriter . flush ( ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
} 
) ; 
} 
catch ( FileNotFoundException e ) { 
error ( "Unable find file" , e ) ; 
} 
finally { 
try { 
if ( out != null ) out . close ( ) ; 
} 
catch ( IOException e ) { 
error ( "Unable to close lock" , e ) ; 
} 
} 
} 
} 

public class EventPropertiesAssistant { 
private void doWithLock ( FileChannel channel , Consumer < FileLock > consumer ) { 
FileLock lock = null ; 
try { 
while ( lock == null ) try { 
lock = channel . tryLock ( ) ; 
} 
catch ( OverlappingFileLockException e ) { 
Thread . sleep ( 500 ) ; 
} 
consumer . accept ( lock ) ; 
} 
catch ( IOException | InterruptedException e ) { 
error ( "Unable to write" , e ) ; 
} 
finally { 
try { 
if ( lock != null ) lock . release ( ) ; 
} 
catch ( IOException e ) { 
error ( "Unable to close lock" , e ) ; 
} 
} 
} 
} 

public class EventPropertiesAssistant { 
public void unregisterEventID ( String eventKey ) { 
properties . remove ( eventKey + "_DESCRIPTION" ) ; 
properties . remove ( eventKey ) ; 
FileOutputStream out = null ; 
BufferedReader reader = null ; 
BufferedWriter writer = null ; 
try { 
out = new FileOutputStream ( eventPropertiesPath , true ) ; 
final File tempFile = new File ( eventPropertiesPath + "temp.properties" ) ; 
final BufferedReader readerFinal = new BufferedReader ( new FileReader ( eventPropertiesPath ) ) ; 
final BufferedWriter writerFinal = new BufferedWriter ( new FileWriter ( tempFile ) ) ; 
doWithLock ( out . getChannel ( ) , lock -> { 
unlockedReloadFile ( ) ; 
if ( getEventID ( eventKey ) != null ) return ; 
try { 
String currentLine = readerFinal . readLine ( ) ; 
while ( currentLine != null ) { 
String trimmedLine = currentLine . trim ( ) ; 
if ( trimmedLine . equals ( eventKey + "_DESCRIPTION" ) || trimmedLine . equals ( eventKey ) ) continue ; 
writerFinal . write ( currentLine + System . getProperty ( "line.separator" ) ) ; 
currentLine = readerFinal . readLine ( ) ; 
} 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
} 
) ; 
reader = readerFinal ; 
writer = writerFinal ; 
tempFile . renameTo ( new File ( eventPropertiesPath ) ) ; 
} 
catch ( IOException e ) { 
error ( "Unable find file" , e ) ; 
} 
finally { 
try { 
if ( out != null ) out . close ( ) ; 
if ( writer != null ) writer . close ( ) ; 
if ( reader != null ) reader . close ( ) ; 
} 
catch ( IOException e ) { 
error ( "Unable to close lock" , e ) ; 
} 
} 
} 
} 

public class OutputExtensionArgument { 
@ Override public boolean canRun ( EventModel event ) { 
if ( event != null ) return event . getListResourceContainer ( ) . providesResource ( getResourceIdWishList ( ) ) ; 
return false ; 
} 
} 

public class PlayerController { 
public void command ( String command , Playlist playlist , Progress progress , TrackInfo trackInfo , Volume volume ) { 
Optional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; 
Optional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; 
if ( ! ownIdentification . isPresent ( ) || ! playerIdentification . isPresent ( ) ) { 
error ( "unable to obtain id" ) ; 
return ; 
} 
Optional < PlayerCommand > playerCommand = PlayerCommand . createPlayerCommand ( ownIdentification . get ( ) , playerIdentification . get ( ) , command , player . getCapabilities ( ) , getContext ( ) ) ; 
if ( playlist != null ) playerCommand . get ( ) . addResource ( new PlaylistResource ( ownIdentification . get ( ) , playlist ) ) ; 
if ( progress != null ) playerCommand . get ( ) . addResource ( new ProgressResource ( ownIdentification . get ( ) , progress ) ) ; 
if ( trackInfo != null ) playerCommand . get ( ) . addResource ( new TrackInfoResource ( ownIdentification . get ( ) , trackInfo ) ) ; 
if ( volume != null ) playerCommand . get ( ) . addResource ( new VolumeResource ( ownIdentification . get ( ) , volume ) ) ; 
fire ( playerCommand . get ( ) , 5 ) ; 
} 
} 

public class UrlBuilder { 
public UrlBuilder append ( boolean encode , String ... postFix ) { 
for ( String part : postFix ) { 
if ( StringUtils . isNotBlank ( part ) ) { 
if ( url . charAt ( url . length ( ) - 1 ) != '/' && ! part . startsWith ( "/" ) ) url . append ( '/' ) ; 
if ( encode ) try { 
url . append ( URLEncoder . encode ( part , "UTF-8" ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new IllegalStateException ( e ) ; 
} 
else url . append ( part ) ; 
} 
} 
return this ; 
} 
} 

public class UrlBuilder { 
public UrlBuilder queryParam ( String name , Boolean value ) { 
if ( value != null ) return queryParam ( name , value . toString ( ) ) ; 
else return null ; 
} 
} 

public class UrlBuilder { 
public UrlBuilder queryParam ( String name , Number value ) { 
if ( value != null ) return queryParam ( name , value . toString ( ) ) ; 
else return null ; 
} 
} 

public class UrlBuilder { 
public UrlBuilder queryParam ( String name , String value , boolean encode ) { 
if ( StringUtils . isNotEmpty ( value ) ) { 
if ( encode ) try { 
value = URLEncoder . encode ( value , "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new IllegalStateException ( e ) ; 
} 
params . add ( new EntryImpl ( name , value ) ) ; 
} 
return this ; 
} 
} 

public class PlaylistResource { 
public static Optional < Playlist > getPlaylist ( EventModel eventModel ) { 
if ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . findAny ( ) . flatMap ( Playlist :: importResource ) ; 
else return Optional . empty ( ) ; 
} 
} 

public class LaunchNakamura { 
private void launchButtonActionPerformed ( java . awt . event . ActionEvent evt ) { 
if ( runStatus == APP_NOT_RUNNING ) { 
System . setSecurityManager ( null ) ; 
try { 
NakamuraMain . main ( savedArgs ) ; 
statusLabel . setText ( "Nakamura is starting..." ) ; 
JOptionPane . showMessageDialog ( this , "Nakamura has been started.\nPlease allow 30-60 seconds for it to be ready." , "Information" , JOptionPane . INFORMATION_MESSAGE ) ; 
runStatus = APP_RUNNING ; 
isStartupFinished ( ) ; 
} 
catch ( IOException e ) { 
statusLabel . setText ( "Nakamura is startup failed " + e . getMessage ( ) ) ; 
} 
} 
else JOptionPane . showMessageDialog ( this , "Nakamura is already running." , "Warning" , JOptionPane . WARNING_MESSAGE ) ; 
} 
} 

public class LaunchNakamura { 
protected ImageIcon createImageIcon ( String path , String description ) { 
java . net . URL imgURL = getClass ( ) . getResource ( path ) ; 
if ( imgURL != null ) return new ImageIcon ( imgURL , description ) ; 
else { 
System . err . println ( "Couldn't find file: " + path ) ; 
return null ; 
} 
} 
} 

public class JSONResult { 
public JSONResult get ( int index ) { 
if ( value instanceof JSONArray ) { 
JSONArray array = ( JSONArray ) value ; 
Object result = array . get ( index ) ; 
return new JSONResult ( result ) ; 
} 
else if ( value instanceof JSONObject ) return get ( String . valueOf ( index ) ) ; 
return new JSONResult ( null ) ; 
} 
} 

public class JSONResult { 
public JSONResult get ( String key ) { 
if ( value instanceof JSONObject ) { 
JSONObject obj = ( JSONObject ) value ; 
Object result = obj . get ( key ) ; 
return new JSONResult ( result ) ; 
} 
else if ( value instanceof JSONArray ) try { 
int index = Integer . parseInt ( key ) ; 
return get ( index ) ; 
} 
catch ( NumberFormatException e ) { 
throw createException ( "Excpected JSONObject " + key + ":" ) ; 
} 
return new JSONResult ( null ) ; 
} 
} 

public class JSONResult { 
public Integer getInt ( Integer defaultValue ) { 
if ( value instanceof Number ) return ( ( Number ) value ) . intValue ( ) ; 
if ( value instanceof String ) { 
String s = ( String ) value ; 
return Integer . parseInt ( s ) ; 
} 
if ( value == null ) return defaultValue ; 
throw createException ( "Expected integer:" ) ; 
} 
} 

public class JSONResult { 
public Double getDouble ( Double defaultValue ) { 
if ( value instanceof Number ) return ( ( Number ) value ) . doubleValue ( ) ; 
if ( value instanceof String ) { 
String s = ( String ) value ; 
return Double . parseDouble ( s ) ; 
} 
if ( value == null ) return defaultValue ; 
throw createException ( "Expected number:" ) ; 
} 
} 

public class JSONResult { 
public String getString ( String defaultValue ) { 
if ( value instanceof String || value instanceof Number ) return value . toString ( ) ; 
if ( value == null ) return null ; 
if ( value instanceof JSONArray ) return ( ( JSONArray ) value ) . toJSONString ( ) ; 
if ( value instanceof JSONObject ) return ( ( JSONObject ) value ) . toJSONString ( ) ; 
if ( value == null ) return defaultValue ; 
throw createException ( "Expected string:" ) ; 
} 
} 

public class SessionManager { 
public void executeBatchAsync ( FutureCallback < ResultSet > callback , Statement ... statements ) throws ExceedMaxAsyncJobsException { 
if ( ! asyncSemaphore . tryAcquire ( ) ) if ( callback == null ) throw new ExceedMaxAsyncJobsException ( maxSyncJobs ) ; 
else callback . onFailure ( new ExceedMaxAsyncJobsException ( maxSyncJobs ) ) ; 
else try { 
ResultSetFuture rsf = CqlUtils . executeBatchAsync ( getSession ( ) , statements ) ; 
if ( callback != null ) Futures . addCallback ( rsf , wrapCallbackResultSet ( callback ) , asyncExecutor ) ; 
} 
catch ( Exception e ) { 
asyncSemaphore . release ( ) ; 
LOGGER . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class CF { 
public Set < Class < ? > > getSubclasses ( Class < ? > clazz ) { 
Set < Class < ? > > ret = new HashSet < Class < ? > > ( ) ; 
Set < Class < ? > > w = null ; 
if ( clazz != null ) { 
this . clear ( ) ; 
Map < URI , String > locations = this . locator . getCfLocations ( ) ; 
for ( Entry < URI , String > entry : locations . entrySet ( ) ) { 
try { 
w = search ( clazz , entry . getKey ( ) , locations . get ( entry . getKey ( ) ) ) ; 
if ( w != null && ( w . size ( ) > 0 ) ) ret . addAll ( w ) ; 
} 
catch ( MalformedURLException ex ) { 
} 
} 
} 
return ret ; 
} 
} 

public class CF { 
public Set < Class < ? > > getSubclasses ( String fqcn ) { 
if ( fqcn == null ) return new HashSet < Class < ? > > ( ) ; 
else if ( StringUtils . startsWith ( fqcn , "." ) || StringUtils . endsWith ( fqcn , "." ) ) return new HashSet < Class < ? > > ( ) ; 
Class < ? > clazz = null ; 
try { 
clazz = Class . forName ( fqcn ) ; 
} 
catch ( ClassNotFoundException ex ) { 
this . clear ( ) ; 
this . errors . add ( ex ) ; 
return new HashSet < Class < ? > > ( ) ; 
} 
return getSubclasses ( clazz ) ; 
} 
} 

public class CF { 
private final Set < Class < ? > > search ( Class < ? > clazz , URI location , String packageName ) throws MalformedURLException { 
if ( clazz == null || location == null ) return new HashSet < Class < ? > > ( ) ; 
File directory = new File ( location . toURL ( ) . getFile ( ) ) ; 
if ( directory . exists ( ) ) return this . searchDirectory ( clazz , directory , location , packageName ) . keySet ( ) ; 
else return this . searchJar ( clazz , location ) . keySet ( ) ; 
} 
} 

public class CF { 
protected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { 
Map < Class < ? > , URI > ret = new HashMap < > ( ) ; 
String [ ] files = directory . list ( ) ; 
for ( int i = 0 ; 
i < files . length ; 
i ++ ) if ( files [ i ] . endsWith ( ".class" ) ) { 
String classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; 
try { 
Class < ? > c = Class . forName ( packageName + "." + classname ) ; 
if ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + "." + classname ) ) ret . put ( c , location ) ; 
} 
catch ( Exception ex ) { 
errors . add ( ex ) ; 
} 
} 
return ret ; 
} 
} 

public class CF { 
protected final Map < Class < ? > , URI > searchJar ( Class < ? > clazz , URI location ) { 
Map < Class < ? > , URI > ret = new HashMap < > ( ) ; 
try { 
JarURLConnection conn = ( JarURLConnection ) location . toURL ( ) . openConnection ( ) ; 
JarFile jarFile = conn . getJarFile ( ) ; 
for ( Enumeration < JarEntry > e = jarFile . entries ( ) ; 
e . hasMoreElements ( ) ; 
) { 
JarEntry entry = e . nextElement ( ) ; 
String entryname = entry . getName ( ) ; 
if ( this . processed . contains ( entryname ) ) continue ; 
this . processed . add ( entryname ) ; 
if ( ! entry . isDirectory ( ) && entryname . endsWith ( ".class" ) ) { 
String classname = entryname . substring ( 0 , entryname . length ( ) - 6 ) ; 
if ( classname . startsWith ( "/" ) ) classname = classname . substring ( 1 ) ; 
classname = classname . replace ( '/' , '.' ) ; 
if ( ! StringUtils . startsWithAny ( classname , this . excludedNames ) ) try { 
Class < ? > c = Class . forName ( classname ) ; 
if ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( classname ) ) ret . put ( c , location ) ; 
} 
catch ( Exception exception ) { 
errors . add ( exception ) ; 
} 
catch ( Error error ) { 
errors . add ( error ) ; 
} 
} 
} 
} 
catch ( IOException ignore ) { 
errors . add ( ignore ) ; 
} 
return ret ; 
} 
} 

public class PacketCollector { 
protected void processPacket ( Packet packet ) { 
if ( packet == null ) return ; 
if ( packetFilter == null || packetFilter . accept ( packet ) ) while ( ! resultQueue . offer ( packet ) ) resultQueue . poll ( ) ; 
} 
} 

public class VolumeResource { 
public static Optional < Volume > getVolume ( EventModel eventModel ) { 
if ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Integer ) . map ( ob -> ( Integer ) ob ) . findAny ( ) . flatMap ( Volume :: createVolume ) ; 
else return Optional . empty ( ) ; 
} 
} 

public class XMPPUtils { 
public static IQ createErrorResponse ( final IQ request , final String message , Condition condition , Type type ) { 
final IQ result = request . createCopy ( ) ; 
result . setID ( request . getID ( ) ) ; 
result . setFrom ( request . getTo ( ) ) ; 
result . setTo ( request . getFrom ( ) ) ; 
PacketError e = new PacketError ( condition , type ) ; 
if ( message != null ) e . setText ( message ) ; 
result . setError ( e ) ; 
return result ; 
} 
} 

public class SelectorResource { 
public static Optional < Boolean > isTarget ( EventModel eventModel , Identifiable identifiable ) { 
if ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( SelectorResource . RESOURCE_ID ) ) ) return Optional . of ( eventModel . getListResourceContainer ( ) . provideResource ( SelectorResource . RESOURCE_ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( resource -> resource instanceof Identification ) . map ( object -> ( Identification ) object ) . anyMatch ( identifiable :: isOwner ) ) ; 
else return Optional . empty ( ) ; 
} 
} 

public class User { 
public void setLoginEnabled ( long from , long to , boolean day , TimeZone timeZone ) { 
String enabledSetting = EnabledPeriod . getEnableValue ( from , to , day , timeZone ) ; 
if ( enabledSetting == null ) removeProperty ( LOGIN_ENABLED_PERIOD_FIELD ) ; 
else setProperty ( LOGIN_ENABLED_PERIOD_FIELD , enabledSetting ) ; 
} 
} 

public class RosterEntry { 
public void setName ( String name ) { 
if ( name != null && name . equals ( this . name ) ) return ; 
this . name = name ; 
Roster packet = new Roster ( ) ; 
packet . setType ( IQ . Type . set ) ; 
packet . addItem ( new JID ( user ) , name , ask , subscription , getGroupNames ( ) ) ; 
connection . sendPacket ( packet ) ; 
} 
} 

public class RosterEntry { 
public Collection < RosterGroup > getGroups ( ) { 
List < RosterGroup > results = new ArrayList < RosterGroup > ( ) ; 
for ( RosterGroup group : roster . getGroups ( ) ) { 
if ( group . contains ( this ) ) results . add ( group ) ; 
} 
return Collections . unmodifiableCollection ( results ) ; 
} 
} 

public class RSMUtils { 
public static RSM parseRSM ( Element queryElement ) { 
RSM rsm = new RSM ( ) ; 
Element setElement = queryElement . element ( "set" ) ; 
if ( setElement == null ) return rsm ; 
Element after = setElement . element ( "after" ) ; 
if ( after != null ) rsm . setAfter ( after . getText ( ) ) ; 
Element before = setElement . element ( "before" ) ; 
if ( before != null ) { 
String beforeText = before . getText ( ) ; 
rsm . setBefore ( beforeText == null ? "" : beforeText ) ; 
} 
Element index = setElement . element ( "index" ) ; 
if ( index != null ) rsm . setIndex ( Integer . parseInt ( index . getText ( ) ) ) ; 
Element max = setElement . element ( "max" ) ; 
if ( max != null ) rsm . setMax ( Integer . parseInt ( max . getText ( ) ) ) ; 
return rsm ; 
} 
} 

public class RSMUtils { 
public static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { 
String after = rsm . getAfter ( ) ; 
String before = rsm . getBefore ( ) ; 
int initialIndex = rsm . getIndex ( ) ; 
int lastIndex = objects . size ( ) ; 
if ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { 
boolean afterItemFound = false ; 
boolean beforeItemFound = false ; 
int i = 0 ; 
for ( Identifiable object : objects ) { 
if ( after != null && after . equals ( object . getId ( ) ) ) { 
initialIndex = i + 1 ; 
afterItemFound = true ; 
} 
if ( before != null && before . equals ( object . getId ( ) ) ) { 
lastIndex = i ; 
beforeItemFound = true ; 
} 
i ++ ; 
} 
if ( after != null && ! afterItemFound ) throw new IllegalArgumentException ( ) ; 
if ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) throw new IllegalArgumentException ( ) ; 
} 
if ( rsm . getMax ( ) != null ) if ( before != null ) initialIndex = lastIndex - rsm . getMax ( ) ; 
else lastIndex = initialIndex + rsm . getMax ( ) ; 
boolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; 
List < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; 
rsm . setCount ( objects . size ( ) ) ; 
rsm . setIndex ( initialIndex ) ; 
if ( ! filteredList . isEmpty ( ) ) { 
rsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; 
rsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; 
} 
return filteredList ; 
} 
} 

public class LeavingEvent { 
public static Optional < LeavingEvent > createLeavingEvent ( Identification source , boolean strict , List < String > descriptors ) { 
try { 
if ( strict ) descriptors . add ( STRICT_DESCRIPTOR ) ; 
else descriptors . add ( GENERAL_DESCRIPTOR ) ; 
descriptors . add ( ID ) ; 
descriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; 
LeavingEvent stopRequest = new LeavingEvent ( source , descriptors ) ; 
return Optional . of ( stopRequest ) ; 
} 
catch ( IllegalArgumentException e ) { 
return Optional . empty ( ) ; 
} 
} 
} 

public class UserRoster { 
public void reload ( ) { 
if ( ! connection . isAuthenticated ( ) ) throw new IllegalStateException ( "Not logged in to server." ) ; 
if ( connection . isAnonymous ( ) ) throw new IllegalStateException ( "Anonymous users can't have a roster." ) ; 
Roster packet = new Roster ( ) ; 
if ( rosterStore != null && connection . isRosterVersioningSupported ( ) ) { 
packet . getElement ( ) . element ( "query" ) . addAttribute ( "ver" , rosterStore . getRosterVersion ( ) ) ; 
PacketFilter filter = new PacketIDFilter ( packet . getID ( ) ) ; 
connection . addPacketListener ( new RosterResultListener ( ) , filter ) ; 
} 
connection . sendPacket ( packet ) ; 
} 
} 

public class UserRoster { 
public void createEntry ( String user , String name , String [ ] groups ) throws XMPPException { 
if ( ! connection . isAuthenticated ( ) ) throw new IllegalStateException ( "Not logged in to server." ) ; 
if ( connection . isAnonymous ( ) ) throw new IllegalStateException ( "Anonymous users can't have a roster." ) ; 
Roster rosterPacket = new Roster ( ) ; 
rosterPacket . setType ( IQ . Type . set ) ; 
rosterPacket . addItem ( new JID ( user ) , name , null , null , Arrays . asList ( groups ) ) ; 
PacketCollector collector = connection . createPacketCollector ( new PacketIDFilter ( rosterPacket . getID ( ) ) ) ; 
connection . sendPacket ( rosterPacket ) ; 
IQ response = ( IQ ) collector . nextResult ( SmackConfiguration . getPacketReplyTimeout ( ) ) ; 
collector . cancel ( ) ; 
if ( response == null ) throw new XMPPException ( "No response from the server." ) ; 
else if ( response . getType ( ) == IQ . Type . error ) throw new XMPPException ( response . getError ( ) ) ; 
Presence presencePacket = new Presence ( Presence . Type . subscribe ) ; 
presencePacket . setTo ( user ) ; 
connection . sendPacket ( presencePacket ) ; 
} 
} 

public class UserRoster { 
public Presence getPresenceResource ( String userWithResource ) { 
String key = getPresenceMapKey ( userWithResource ) ; 
String resource = StringUtils . parseResource ( userWithResource ) ; 
Map < String , Presence > userPresences = presenceMap . get ( key ) ; 
if ( userPresences == null ) { 
Presence presence = new Presence ( Presence . Type . unavailable ) ; 
presence . setFrom ( userWithResource ) ; 
return presence ; 
} 
else { 
Presence presence = userPresences . get ( resource ) ; 
if ( presence == null ) { 
presence = new Presence ( Presence . Type . unavailable ) ; 
presence . setFrom ( userWithResource ) ; 
return presence ; 
} 
else return presence ; 
} 
} 
} 

public class UserRoster { 
private void setOfflinePresences ( ) { 
Presence packetUnavailable ; 
for ( String user : presenceMap . keySet ( ) ) { 
Map < String , Presence > resources = presenceMap . get ( user ) ; 
if ( resources != null ) for ( String resource : resources . keySet ( ) ) { 
packetUnavailable = new Presence ( Presence . Type . unavailable ) ; 
packetUnavailable . setFrom ( user + "/" + resource ) ; 
presencePacketListener . processPacket ( packetUnavailable ) ; 
} 
} 
} 
} 

public class UserRoster { 
private void fireRosterChangedEvent ( Collection < String > addedEntries , Collection < String > updatedEntries , Collection < String > deletedEntries ) { 
for ( RosterListener listener : rosterListeners ) { 
if ( ! addedEntries . isEmpty ( ) ) listener . entriesAdded ( addedEntries ) ; 
if ( ! updatedEntries . isEmpty ( ) ) listener . entriesUpdated ( updatedEntries ) ; 
if ( ! deletedEntries . isEmpty ( ) ) listener . entriesDeleted ( deletedEntries ) ; 
} 
} 
} 

public class LastEncountered { 
@ SuppressWarnings ( "unused" ) public static Optional < Long > getTimePassed ( EventModel eventModel ) { 
if ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . map ( ResourceModel :: getResource ) . filter ( ob -> ob instanceof Long ) . map ( ob -> ( Long ) ob ) . findAny ( ) ; 
else return Optional . empty ( ) ; 
} 
} 

public class PropertiesAssistant { 
private void reloadProperties ( ) { 
Properties temp = new Properties ( ) ; 
BufferedReader bufferedReader = null ; 
try { 
File properties = new File ( propertiesPath ) ; 
bufferedReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( properties ) , "UTF8" ) ) ; 
temp . load ( bufferedReader ) ; 
this . properties = temp ; 
listeners . removeIf ( weakReference -> weakReference . get ( ) == null ) ; 
listeners . forEach ( weakReference -> { 
Consumer < PropertiesAssistant > consumer = weakReference . get ( ) ; 
if ( consumer != null ) consumer . accept ( this ) ; 
} 
) ; 
} 
catch ( IOException e ) { 
error ( "Error while trying to load the Properties-File: " + propertiesPath , e ) ; 
} 
finally { 
if ( bufferedReader != null ) try { 
bufferedReader . close ( ) ; 
} 
catch ( IOException e ) { 
error ( "Unable to close input stream" , e ) ; 
} 
} 
} 
} 

public class PacketParserUtils { 
public static StreamError parseStreamError ( Element el ) throws IOException , XmlPullParserException { 
String code = null ; 
Element condEl = ( Element ) el . elements ( ) . iterator ( ) . next ( ) ; 
if ( condEl . getNamespace ( ) . getURI ( ) . equals ( StreamError . NAMESPACE ) ) code = condEl . getName ( ) ; 
String text = condEl . elementText ( "text" ) ; 
return new StreamError ( code , text ) ; 
} 
} 

public class PacketParserUtils { 
public static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { 
DefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; 
boolean done = false ; 
while ( ! done ) { 
int eventType = parser . next ( ) ; 
if ( eventType == XmlPullParser . START_TAG ) { 
String name = parser . getName ( ) ; 
if ( parser . isEmptyElementTag ( ) ) extension . setValue ( name , "" ) ; 
else { 
eventType = parser . next ( ) ; 
if ( eventType == XmlPullParser . TEXT ) { 
String value = parser . getText ( ) ; 
extension . setValue ( name , value ) ; 
} 
} 
} 
else if ( eventType == XmlPullParser . END_TAG ) if ( parser . getName ( ) . equals ( elementName ) ) done = true ; 
} 
return extension ; 
} 
} 

public class PacketParserUtils { 
private static Object decode ( Class < ? > type , String value ) throws Exception { 
if ( type . getName ( ) . equals ( "java.lang.String" ) ) return value ; 
if ( type . getName ( ) . equals ( "boolean" ) ) return Boolean . valueOf ( value ) ; 
if ( type . getName ( ) . equals ( "int" ) ) return Integer . valueOf ( value ) ; 
if ( type . getName ( ) . equals ( "long" ) ) return Long . valueOf ( value ) ; 
if ( type . getName ( ) . equals ( "float" ) ) return Float . valueOf ( value ) ; 
if ( type . getName ( ) . equals ( "double" ) ) return Double . valueOf ( value ) ; 
if ( type . getName ( ) . equals ( "java.lang.Class" ) ) return Class . forName ( value ) ; 
return null ; 
} 
} 

public class StartMusicRequest { 
public static boolean verify ( EventModel eventModel , Capabilities capabilities , Identifiable player , List < Identifiable > activators ) { 
if ( ! eventModel . containsDescriptor ( StartMusicRequest . ID ) ) return false ; 
if ( ! capabilities . handlesPlayRequestFromOutside ( ) ) if ( activators . stream ( ) . noneMatch ( identifiable -> identifiable . isOwner ( eventModel . getSource ( ) ) ) ) return false ; 
if ( ! PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> playlist . verify ( capabilities ) ) . orElse ( true ) ) return false ; 
return SelectorResource . isTarget ( eventModel , player ) . orElse ( false ) ; 
} 
} 

public class PlaybackStateResource { 
public static Optional < PlaybackState > getPlaybackStateFromResource ( ResourceModel x ) { 
if ( ! x . getResourceID ( ) . equals ( ID ) ) return Optional . empty ( ) ; 
Object resource = x . getResource ( ) ; 
if ( resource instanceof String ) { 
String state = ( String ) resource ; 
try { 
return Optional . of ( PlaybackState . valueOf ( state ) ) ; 
} 
catch ( IllegalArgumentException e ) { 
return Optional . empty ( ) ; 
} 
} 
else return Optional . empty ( ) ; 
} 
} 

public class ExternalComponentManager { 
public String getSecretKey ( String subdomain ) { 
String secretKey = secretKeys . get ( subdomain ) ; 
if ( secretKey == null ) secretKey = defaultSecretKey ; 
return secretKey ; 
} 
} 

public class AbstractReferenceMap { 
public V put ( K key , V value ) { 
if ( key == null ) throw new NullPointerException ( "null keys not allowed" ) ; 
if ( value == null ) throw new NullPointerException ( "null values not allowed" ) ; 
purgeBeforeWrite ( ) ; 
return super . put ( key , value ) ; 
} 
} 

public class AbstractReferenceMap { 
public Set < K > keySet ( ) { 
if ( keySet == null ) keySet = new ReferenceKeySet < K , V > ( this ) ; 
return keySet ; 
} 
} 

public class AbstractReferenceMap { 
public Collection < V > values ( ) { 
if ( values == null ) values = new ReferenceValues < K , V > ( this ) ; 
return values ; 
} 
} 

public class AbstractReferenceMap { 
protected void purge ( Reference ref ) { 
int hash = ref . hashCode ( ) ; 
int index = hashIndex ( hash , data . length ) ; 
HashEntry < K , V > previous = null ; 
HashEntry < K , V > entry = data [ index ] ; 
while ( entry != null ) { 
if ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { 
if ( previous == null ) data [ index ] = entry . next ; 
else previous . next = entry . next ; 
this . size -- ; 
return ; 
} 
previous = entry ; 
entry = entry . next ; 
} 
} 
} 

public class AbstractReferenceMap { 
protected HashEntry < K , V > getEntry ( Object key ) { 
if ( key == null ) return null ; 
else return super . getEntry ( key ) ; 
} 
} 

public class PresenceConstant { 
@ Override public boolean controlEvents ( EventModel eventModel ) { 
if ( level . compareTo ( PresenceIndicatorLevel . WEAK ) >= 0 ) return present ; 
else if ( level . compareTo ( PresenceIndicatorLevel . WEAK ) < 0 && mostVague . get ( ) ) return present ; 
else return true ; 
} 
} 

public class PresenceConstant { 
public void setPresence ( boolean present ) { 
if ( this . present == present ) return ; 
this . present = present ; 
updateVague ( ) ; 
if ( present ) firePresence ( true ) ; 
else fireLeaving ( ) ; 
} 
} 

public class Gen_RunScripts { 
protected final Properties loadProperties ( String filename ) { 
Properties ret = new Properties ( ) ; 
URL url = null ; 
File f = new File ( filename . toString ( ) ) ; 
if ( f . exists ( ) ) try { 
url = f . toURI ( ) . toURL ( ) ; 
} 
catch ( Exception ignore ) { 
} 
else { 
ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
url = loader . getResource ( filename ) ; 
if ( url == null ) { 
loader = Gen_RunScripts . class . getClassLoader ( ) ; 
url = loader . getResource ( filename ) ; 
} 
} 
try { 
ret . load ( url . openStream ( ) ) ; 
} 
catch ( IOException e ) { 
System . err . println ( this . getAppName ( ) + ": cannot load property file <" + filename + ">, IO exception\n--><" + e + ">" ) ; 
} 
catch ( Exception e ) { 
System . err . println ( this . getAppName ( ) + ": cannot load property file <" + filename + ">, general exception\n--><" + e + ">" ) ; 
} 
return ret ; 
} 
} 

public class ProgressResource { 
public static Optional < Progress > getProgress ( EventModel eventModel ) { 
if ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( ID ) . stream ( ) . findAny ( ) . flatMap ( Progress :: importResource ) ; 
else return Optional . empty ( ) ; 
} 
} 

public class ServiceResolver { 
public static Collection < ServiceResolver > discover ( InetAddress start , int count , int msTimeout ) { 
Collection < ServiceResolver > result = new ArrayList < ServiceResolver > ( ) ; 
Collection < InetAddress > hosts = IPv4Scanner . scanRange ( start , count , msTimeout ) ; 
for ( InetAddress host : hosts ) { 
ServiceResolver resolver = new ServiceResolver ( host ) ; 
logger . info ( "resolving {} {}" , host . getHostAddress ( ) , host . getCanonicalHostName ( ) ) ; 
JSONResult config = resolver . getConfig ( ) ; 
if ( config != null ) result . add ( resolver ) ; 
} 
return result ; 
} 
} 

public class ServiceResolver { 
public JSONResult getConfig ( ) { 
if ( attempts == 0 ) try { 
resolve ( ) ; 
} 
catch ( Exception e ) { 
} 
if ( config == null ) { 
logger . info ( "{} => no response" , url ) ; 
return null ; 
} 
logger . info ( "{} => {}" , url , config . get ( "FireREST" ) . getString ( ) ) ; 
return config ; 
} 
} 

public class Connection { 
public void addConnectionListener ( ConnectionListener connectionListener ) { 
if ( connectionListener == null ) return ; 
if ( ! connectionListeners . contains ( connectionListener ) ) connectionListeners . add ( connectionListener ) ; 
} 
} 

public class Connection { 
public void addPacketListener ( PacketListener packetListener , PacketFilter packetFilter ) { 
if ( packetListener == null ) throw new NullPointerException ( "Packet listener is null." ) ; 
ListenerWrapper wrapper = new ListenerWrapper ( packetListener , packetFilter ) ; 
recvListeners . put ( packetListener , wrapper ) ; 
} 
} 

public class Connection { 
public void addPacketSendingListener ( PacketListener packetListener , PacketFilter packetFilter ) { 
if ( packetListener == null ) throw new NullPointerException ( "Packet listener is null." ) ; 
ListenerWrapper wrapper = new ListenerWrapper ( packetListener , packetFilter ) ; 
sendListeners . put ( packetListener , wrapper ) ; 
} 
} 

public class Connection { 
public void addPacketInterceptor ( PacketInterceptor packetInterceptor , PacketFilter packetFilter ) { 
if ( packetInterceptor == null ) throw new NullPointerException ( "Packet interceptor is null." ) ; 
interceptors . put ( packetInterceptor , new InterceptorWrapper ( packetInterceptor , packetFilter ) ) ; 
} 
} 

public class Connection { 
protected void firePacketInterceptors ( Packet packet ) { 
if ( packet != null ) for ( InterceptorWrapper interceptorWrapper : interceptors . values ( ) ) { 
interceptorWrapper . notifyListener ( packet ) ; 
} 
} 
} 

public class RequestUtils { 
public static Object toValue ( String name , Object value ) { 
String [ ] parts = StringUtils . split ( name , "@" , 2 ) ; 
String fieldName = null ; 
String fieldType = "String" ; 
if ( parts . length == 2 ) { 
fieldType = parts [ 1 ] ; 
fieldName = parts [ 0 ] ; 
} 
else if ( parts . length == 1 ) fieldName = parts [ 0 ] ; 
else throw new IllegalArgumentException ( "Invalid property name" ) ; 
try { 
int l = Array . getLength ( value ) ; 
RequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; 
if ( rpt == null ) rpt = TYPES . get ( RequestParameterType . STRING ) ; 
if ( ! fieldName . endsWith ( "[]" ) && l == 1 ) return rpt . newInstance ( Array . get ( value , 0 ) ) ; 
Class < ? > componentType = rpt . getComponentType ( ) ; 
Object [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; 
for ( int i = 0 ; 
i < l ; 
i ++ ) a [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; 
return a ; 
} 
catch ( IllegalArgumentException e ) { 
RequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; 
if ( rpt == null ) rpt = TYPES . get ( RequestParameterType . STRING ) ; 
return rpt . newInstance ( value ) ; 
} 
} 
} 

public class ExternalComponent { 
public void connectionLost ( ) { 
synchronized ( this ) { 
if ( reconnecting ) return ; 
reconnecting = true ; 
} 
readerThread = null ; 
boolean isConnected = false ; 
if ( ! shutdown ) component . shutdown ( ) ; 
while ( ! isConnected && ! shutdown ) try { 
connect ( host , port , subdomain ) ; 
isConnected = true ; 
if ( shutdown ) disconnect ( ) ; 
else start ( ) ; 
} 
catch ( ComponentException e ) { 
manager . getLog ( ) . error ( "Error trying to reconnect with the server" , e ) ; 
try { 
Thread . sleep ( 5000 ) ; 
} 
catch ( InterruptedException e1 ) { 
} 
} 
reconnecting = false ; 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > lookup ( final Object data , final int index ) { 
Node < K , V > rval = null ; 
Node < K , V > node = rootNode [ index ] ; 
while ( node != null ) { 
int cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; 
if ( cmp == 0 ) { 
rval = node ; 
break ; 
} 
else node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; 
} 
return rval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private int compare ( final int o1_status , final Object o1 , final int o2_status , final Object o2 , final int index ) { 
if ( comparators [ index ] == null ) if ( o1 instanceof TransactionalComparable ) return ( ( TransactionalComparable ) o1 ) . compareTo ( o1_status , o2 , o2_status ) ; 
else return ( ( Comparable ) o1 ) . compareTo ( o2 ) ; 
else return comparators [ index ] . compare ( o1 , o2 ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > leastNode ( final Node < K , V > node , final int index ) { 
Node < K , V > lval = node ; 
if ( lval != null ) while ( lval . getLeft ( index ) != null ) lval = lval . getLeft ( index ) ; 
return lval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > mostNode ( final Node < K , V > node , final int index ) { 
Node < K , V > rval = node ; 
if ( rval != null ) while ( rval . getRight ( index ) != null ) rval = rval . getRight ( index ) ; 
return rval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > nextGreater ( final Node < K , V > node , final int index ) { 
Node < K , V > rval ; 
if ( node == null ) rval = null ; 
else if ( node . getRight ( index ) != null ) rval = leastNode ( node . getRight ( index ) , index ) ; 
else { 
Node < K , V > parent = node . getParent ( index ) ; 
Node < K , V > child = node ; 
while ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { 
child = parent ; 
parent = parent . getParent ( index ) ; 
} 
rval = parent ; 
} 
return rval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > mostValidNode ( final Node < K , V > node , final int index , final String thread_id ) { 
Node < K , V > rval = node ; 
while ( rval != null && ! validNode ( rval , thread_id ) ) rval = nextGreater ( rval , index ) ; 
return rval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > leastValidNode ( final Node < K , V > node , final int index , final String thread_id ) { 
Node < K , V > lval = node ; 
while ( lval != null && ! validNode ( lval , thread_id ) ) lval = nextSmaller ( lval , index ) ; 
return lval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private static < K , V > void copyColor ( final Node < K , V > from , final Node < K , V > to , final int index ) { 
if ( to != null ) if ( from == null ) to . setBlack ( index ) ; 
else to . copyColor ( from , index ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void rotateLeft ( final Node < K , V > node , final int index ) { 
Node < K , V > rightChild = node . getRight ( index ) ; 
node . setRight ( rightChild . getLeft ( index ) , index ) ; 
if ( rightChild . getLeft ( index ) != null ) rightChild . getLeft ( index ) . setParent ( node , index ) ; 
rightChild . setParent ( node . getParent ( index ) , index ) ; 
if ( node . getParent ( index ) == null ) rootNode [ index ] = rightChild ; 
else if ( node . getParent ( index ) . getLeft ( index ) == node ) node . getParent ( index ) . setLeft ( rightChild , index ) ; 
else node . getParent ( index ) . setRight ( rightChild , index ) ; 
rightChild . setLeft ( node , index ) ; 
node . setParent ( rightChild , index ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void rotateRight ( final Node < K , V > node , final int index ) { 
Node < K , V > leftChild = node . getLeft ( index ) ; 
node . setLeft ( leftChild . getRight ( index ) , index ) ; 
if ( leftChild . getRight ( index ) != null ) leftChild . getRight ( index ) . setParent ( node , index ) ; 
leftChild . setParent ( node . getParent ( index ) , index ) ; 
if ( node . getParent ( index ) == null ) rootNode [ index ] = leftChild ; 
else if ( node . getParent ( index ) . getRight ( index ) == node ) node . getParent ( index ) . setRight ( leftChild , index ) ; 
else node . getParent ( index ) . setLeft ( leftChild , index ) ; 
leftChild . setRight ( node , index ) ; 
node . setParent ( leftChild , index ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void doRedBlackInsert ( final Node < K , V > insertedNode , final int index ) { 
Node < K , V > currentNode = insertedNode ; 
makeRed ( currentNode , index ) ; 
while ( ( currentNode != null ) && ( currentNode != rootNode [ index ] ) && ( isRed ( currentNode . getParent ( index ) , index ) ) ) if ( isLeftChild ( getParent ( currentNode , index ) , index ) ) { 
Node < K , V > y = getRightChild ( getGrandParent ( currentNode , index ) , index ) ; 
if ( isRed ( y , index ) ) { 
makeBlack ( getParent ( currentNode , index ) , index ) ; 
makeBlack ( y , index ) ; 
makeRed ( getGrandParent ( currentNode , index ) , index ) ; 
currentNode = getGrandParent ( currentNode , index ) ; 
} 
else { 
if ( isRightChild ( currentNode , index ) ) { 
currentNode = getParent ( currentNode , index ) ; 
rotateLeft ( currentNode , index ) ; 
} 
makeBlack ( getParent ( currentNode , index ) , index ) ; 
makeRed ( getGrandParent ( currentNode , index ) , index ) ; 
if ( getGrandParent ( currentNode , index ) != null ) rotateRight ( getGrandParent ( currentNode , index ) , index ) ; 
} 
} 
else { 
Node < K , V > y = getLeftChild ( getGrandParent ( currentNode , index ) , index ) ; 
if ( isRed ( y , index ) ) { 
makeBlack ( getParent ( currentNode , index ) , index ) ; 
makeBlack ( y , index ) ; 
makeRed ( getGrandParent ( currentNode , index ) , index ) ; 
currentNode = getGrandParent ( currentNode , index ) ; 
} 
else { 
if ( isLeftChild ( currentNode , index ) ) { 
currentNode = getParent ( currentNode , index ) ; 
rotateRight ( currentNode , index ) ; 
} 
makeBlack ( getParent ( currentNode , index ) , index ) ; 
makeRed ( getGrandParent ( currentNode , index ) , index ) ; 
if ( getGrandParent ( currentNode , index ) != null ) rotateLeft ( getGrandParent ( currentNode , index ) , index ) ; 
} 
} 
makeBlack ( rootNode [ index ] , index ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void doRedBlackDelete ( final Node < K , V > deletedNode ) { 
for ( int index = FIRST_INDEX ; 
index < NUMBER_OF_INDICES ; 
index ++ ) { 
if ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) swapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; 
Node < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; 
if ( replacement != null ) { 
replacement . setParent ( deletedNode . getParent ( index ) , index ) ; 
if ( deletedNode . getParent ( index ) == null ) rootNode [ index ] = replacement ; 
else if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) deletedNode . getParent ( index ) . setLeft ( replacement , index ) ; 
else deletedNode . getParent ( index ) . setRight ( replacement , index ) ; 
deletedNode . setLeft ( null , index ) ; 
deletedNode . setRight ( null , index ) ; 
deletedNode . setParent ( null , index ) ; 
if ( isBlack ( deletedNode , index ) ) doRedBlackDeleteFixup ( replacement , index ) ; 
} 
else if ( deletedNode . getParent ( index ) == null ) rootNode [ index ] = null ; 
else { 
if ( isBlack ( deletedNode , index ) ) doRedBlackDeleteFixup ( deletedNode , index ) ; 
if ( deletedNode . getParent ( index ) != null ) { 
if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) deletedNode . getParent ( index ) . setLeft ( null , index ) ; 
else deletedNode . getParent ( index ) . setRight ( null , index ) ; 
deletedNode . setParent ( null , index ) ; 
} 
} 
} 
shrink ( ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void checkNonNullComparable ( final Object o , final int index ) { 
if ( o == null ) throw new NullPointerException ( dataName [ index ] + " cannot be null" ) ; 
if ( comparators [ index ] == null && ! ( o instanceof Comparable ) ) throw new ClassCastException ( dataName [ index ] + " must be Comparable" ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { 
Node < K , V > node = rootNode [ VALUE ] ; 
while ( true ) { 
int cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; 
if ( cmp == 0 ) { 
if ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { 
String debug_message = "Cannot store a duplicate value (\"" + newNode . getData ( VALUE ) + "\") in this Map. Value already exists for key " + node . getKey ( ) ; 
log . debug ( debug_message ) ; 
throw new IllegalArgumentException ( debug_message ) ; 
} 
if ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; 
if ( node . getRight ( VALUE ) != null ) node = node . getRight ( VALUE ) ; 
else if ( node . getLeft ( VALUE ) != null ) node = node . getLeft ( VALUE ) ; 
else { 
node . setRight ( newNode , VALUE ) ; 
newNode . setParent ( node , VALUE ) ; 
doRedBlackInsert ( newNode , VALUE ) ; 
break ; 
} 
} 
else if ( cmp < 0 ) if ( node . getLeft ( VALUE ) != null ) node = node . getLeft ( VALUE ) ; 
else { 
node . setLeft ( newNode , VALUE ) ; 
newNode . setParent ( node , VALUE ) ; 
doRedBlackInsert ( newNode , VALUE ) ; 
break ; 
} 
else if ( node . getRight ( VALUE ) != null ) node = node . getRight ( VALUE ) ; 
else { 
node . setRight ( newNode , VALUE ) ; 
newNode . setParent ( node , VALUE ) ; 
doRedBlackInsert ( newNode , VALUE ) ; 
break ; 
} 
} 
} 
} 

public class TransactionalBidiTreeMap { 
@ Override public void clear ( ) { 
if ( auto_commit ) { 
modify ( ) ; 
nodeCount = 0 ; 
rootNode [ KEY ] = null ; 
rootNode [ VALUE ] = null ; 
} 
else { 
String thread_id = getCurrentThreadId ( ) ; 
ArrayList < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( entrySet ( ) ) ; 
for ( Iterator < Entry < K , V > > i = list . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
Node < K , V > node = ( Node < K , V > ) i . next ( ) ; 
if ( node . is ( Node . ADDED , thread_id ) ) doRedBlackDelete ( node ) ; 
else node . setStatus ( Node . DELETED , thread_id ) ; 
} 
} 
} 
} 

public class TransactionalBidiTreeMap { 
@ Override public Set < K > keySet ( ) { 
if ( setOfKeysByKey == null ) setOfKeysByKey = new AbstractFilterableSet < K > ( ) { 
@ Override public Iterator < K > iterator ( ) { 
return new TransactionalBidiTreeMapIterator < K > ( KEY ) { 
@ Override protected K doGetNext ( ) { 
return ( K ) lastReturnedNode . getData ( KEY ) ; 
} 
} 
; 
} 
@ Override public int size ( ) { 
return TransactionalBidiTreeMap . this . size ( ) ; 
} 
@ Override public boolean contains ( Object o ) { 
return containsKey ( o ) ; 
} 
@ Override public boolean remove ( Object o ) { 
int oldNodeCount = nodeCount ; 
TransactionalBidiTreeMap . this . remove ( o ) ; 
return nodeCount != oldNodeCount ; 
} 
@ Override public void clear ( ) { 
TransactionalBidiTreeMap . this . clear ( ) ; 
} 
} 
; 
return setOfKeysByKey ; 
} 
} 

public class TransactionalBidiTreeMap { 
@ Override public Collection < V > values ( ) { 
if ( collectionOfValuesByKey == null ) collectionOfValuesByKey = new AbstractFilterableCollection < V > ( ) { 
@ Override public Iterator < V > iterator ( ) { 
return new TransactionalBidiTreeMapIterator < V > ( KEY ) { 
@ Override protected V doGetNext ( ) { 
return ( V ) lastReturnedNode . getData ( VALUE ) ; 
} 
} 
; 
} 
@ Override public int size ( ) { 
return TransactionalBidiTreeMap . this . size ( ) ; 
} 
@ Override public boolean contains ( Object o ) { 
return containsValue ( o ) ; 
} 
@ Override public boolean remove ( Object o ) { 
int oldNodeCount = nodeCount ; 
removeValue ( o ) ; 
return nodeCount != oldNodeCount ; 
} 
@ Override public boolean removeAll ( Collection < ? > c ) { 
boolean modified = false ; 
Iterator < ? > iter = c . iterator ( ) ; 
while ( iter . hasNext ( ) ) if ( removeValue ( iter . next ( ) ) != null ) modified = true ; 
return modified ; 
} 
@ Override public void clear ( ) { 
TransactionalBidiTreeMap . this . clear ( ) ; 
} 
} 
; 
return collectionOfValuesByKey ; 
} 
} 

public class TransactionalBidiTreeMap { 
public FilterableSet < Entry < K , V > > allEntrySet ( ) { 
if ( setOfAllEntries == null ) setOfAllEntries = new AbstractFilterableSet < Entry < K , V > > ( ) { 
@ Override public Iterator < Entry < K , V > > iterator ( ) { 
return new TransactionalBidiTreeMapIterator < Entry < K , V > > ( KEY ) { 
@ Override protected Entry < K , V > doGetNext ( ) { 
return lastReturnedNode ; 
} 
@ Override protected Node < K , V > getNextValidNode ( Node < K , V > node , String thread_id ) { 
return node ; 
} 
} 
; 
} 
@ Override public boolean contains ( Object o ) { 
throw new UtilsjException ( "method not supported" ) ; 
} 
@ Override public boolean remove ( Object o ) { 
throw new UtilsjException ( "method not supported" ) ; 
} 
@ Override public int size ( ) { 
return TransactionalBidiTreeMap . this . size ( true ) ; 
} 
@ Override public void clear ( ) { 
TransactionalBidiTreeMap . this . clear ( ) ; 
} 
} 
; 
return setOfAllEntries ; 
} 
} 

public class TransactionalBidiTreeMap { 
public final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { 
K key ; 
V val ; 
int transaction_status ; 
String transaction_id ; 
new_map . setAutoCommit ( isAutoCommit ( ) ) ; 
if ( ! isAutoCommit ( ) ) { 
for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
TransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; 
key = entry . getKey ( ) ; 
val = entry . getValue ( ) ; 
transaction_status = entry . getStatus ( ) ; 
transaction_id = entry . getTransactionId ( ) ; 
if ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { 
try { 
new_map . put ( key , val ) ; 
new_map . commit ( ) ; 
} 
catch ( Exception e ) { 
} 
try { 
if ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { 
new_map . attach ( transaction_id ) ; 
new_map . remove ( key ) ; 
} 
} 
catch ( Exception e ) { 
} 
new_map . detach ( ) ; 
} 
} 
for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
TransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; 
key = entry . getKey ( ) ; 
val = entry . getValue ( ) ; 
transaction_status = entry . getStatus ( ) ; 
transaction_id = entry . getTransactionId ( ) ; 
if ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { 
new_map . attach ( transaction_id ) ; 
try { 
new_map . put ( key , val ) ; 
} 
catch ( Exception e ) { 
} 
new_map . detach ( ) ; 
} 
} 
} 
else for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
TransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; 
key = entry . getKey ( ) ; 
val = entry . getValue ( ) ; 
try { 
new_map . put ( key , val ) ; 
} 
catch ( Exception e ) { 
} 
} 
} 
} 

public class Cache { 
protected synchronized void deleteExpiredEntries ( ) { 
if ( maxLifetime <= 0 ) return ; 
LinkedListNode node = ageList . getLast ( ) ; 
if ( node == null ) return ; 
long expireTime = System . currentTimeMillis ( ) - maxLifetime ; 
while ( expireTime > node . timestamp ) { 
if ( remove ( node . object , true ) == null ) { 
log . warn ( "Error attempting to remove(" + node . object . toString ( ) + ") - cacheObject not found in cache!" ) ; 
node . remove ( ) ; 
} 
node = ageList . getLast ( ) ; 
if ( node == null ) return ; 
} 
} 
} 

public class Cache { 
protected synchronized void cullCache ( ) { 
if ( maxCacheSize < 0 ) return ; 
if ( map . size ( ) > maxCacheSize ) { 
deleteExpiredEntries ( ) ; 
int desiredSize = ( int ) ( maxCacheSize * .90 ) ; 
for ( int i = map . size ( ) ; 
i > desiredSize ; 
i -- ) if ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { 
log . warn ( "Error attempting to cullCache with remove(" + lastAccessedList . getLast ( ) . object . toString ( ) + ") - cacheObject not found in cache!" ) ; 
lastAccessedList . getLast ( ) . remove ( ) ; 
} 
} 
} 
} 

public class DefaultRosterStore { 
public static DefaultRosterStore init ( final File baseDir ) { 
DefaultRosterStore store = new DefaultRosterStore ( baseDir ) ; 
if ( store . setRosterVersion ( "" ) ) return store ; 
else return null ; 
} 
} 

public class DefaultRosterStore { 
public static DefaultRosterStore open ( final File baseDir ) { 
DefaultRosterStore store = new DefaultRosterStore ( baseDir ) ; 
String s = store . readFile ( store . getVersionFile ( ) ) ; 
if ( s != null && s . startsWith ( STORE_ID + "\n" ) ) return store ; 
else return null ; 
} 
} 

public class IPv4Scanner { 
public static Collection < InetAddress > scanRange ( InetAddress addr , int count , int msTimeout ) { 
Collection < InetAddress > addresses = new ArrayList < InetAddress > ( ) ; 
Collection < InetAddress > result = new ArrayList < InetAddress > ( ) ; 
if ( addr == null ) try { 
addresses . addAll ( localhostNetworkAddresses ( ) ) ; 
} 
catch ( Exception e ) { 
throw new FireRESTException ( e ) ; 
} 
else addresses . add ( addr ) ; 
for ( InetAddress a : addresses ) { 
if ( a instanceof Inet4Address ) { 
InetAddress start = subnetAddress0 ( a , 24 ) ; 
result . addAll ( scanRangeCore ( start , count , msTimeout ) ) ; 
} 
} 
return result ; 
} 
} 

public class IPv4Scanner { 
public static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { 
if ( subnetBits < 1 || 32 <= subnetBits ) throw new FireRESTException ( "Expected subnetBits 1..31" ) ; 
long mask = 1 ; 
for ( int i = 0 ; 
i < 32 ; 
i ++ ) { 
mask <<= 1 ; 
mask |= i < subnetBits ? 1 : 0 ; 
} 
long host0 = asLongAddress ( addr ) & mask ; 
try { 
return asInetAddress ( host0 ) ; 
} 
catch ( UnknownHostException e ) { 
throw new FireRESTException ( e ) ; 
} 
} 
} 

public class ExecS { 
protected final void addAllApplications ( Set < Class < ? > > set ) { 
for ( Class < ? > cls : set ) { 
if ( ! cls . isInterface ( ) && ! Modifier . isAbstract ( cls . getModifiers ( ) ) ) if ( ! this . classmap . containsValue ( cls ) ) this . classNames . add ( cls . getName ( ) ) ; 
} 
} 
} 

public class ExecS { 
protected int executeApplication ( Object svc , String [ ] args , String orig ) { 
if ( svc != null && ( svc instanceof ExecS_Application ) ) { 
if ( svc instanceof Gen_RunScripts ) ( ( Gen_RunScripts ) svc ) . setClassMap ( this . classmap ) ; 
if ( svc instanceof Gen_ExecJarScripts ) ( ( Gen_ExecJarScripts ) svc ) . setClassMap ( this . classmap ) ; 
return ( ( ExecS_Application ) svc ) . executeApplication ( ArrayUtils . remove ( args , 0 ) ) ; 
} 
else if ( svc == null ) { 
System . err . println ( "could not create object for class or application name <" + orig + ">" ) ; 
return - 1 ; 
} 
else if ( ! ( svc instanceof ExecS_Application ) ) { 
System . err . println ( "given class or application name <" + orig + "> is not instance of " + ExecS_Application . class . getName ( ) ) ; 
return - 2 ; 
} 
else { 
System . err . println ( "unexpected error processing for class or application name <" + orig + ">" ) ; 
return - 3 ; 
} 
} 
} 

public class Gen_ExecJarScripts { 
public boolean writeFile ( File file , List < String > lines ) { 
if ( file . exists ( ) ) file . delete ( ) ; 
try { 
FileWriter out = new FileWriter ( file ) ; 
for ( String s : lines ) { 
out . write ( s ) ; 
out . write ( System . getProperty ( "line.separator" ) ) ; 
} 
out . close ( ) ; 
file . setExecutable ( true ) ; 
} 
catch ( IOException ex ) { 
System . err . println ( this . getAppName ( ) + ": IO exception while writing to file - " + file + " with message: " + ex . getMessage ( ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class GoodwillSchema { 
public GoodwillSchemaField getFieldByName ( final String name ) { 
for ( final GoodwillSchemaField field : thriftItems . values ( ) ) { 
if ( field . getName ( ) . equals ( name ) ) return field ; 
} 
return null ; 
} 
} 

public class CF_Utils { 
public final static String getPkgName ( JarEntry entry ) { 
if ( entry == null ) return "" ; 
String s = entry . getName ( ) ; 
if ( s == null ) return "" ; 
if ( s . length ( ) == 0 ) return s ; 
if ( s . startsWith ( "/" ) ) s = s . substring ( 1 , s . length ( ) ) ; 
if ( s . endsWith ( "/" ) ) s = s . substring ( 0 , s . length ( ) - 1 ) ; 
return s . replace ( '/' , '.' ) ; 
} 
} 

public class IterativeCallback { 
public R iterate ( final FilterableCollection < ? extends T > c ) { 
initState ( ) ; 
checkUsed ( ) ; 
if ( c instanceof SynchronizedFilterableCollection ) return SyncUtils . synchronizeRead ( c , new Callback < R > ( ) { 
@ Override protected void doAction ( ) { 
_return ( doIteration ( c . iterator ( ) ) ) ; 
} 
} 
) ; 
return doIteration ( c . iterator ( ) ) ; 
} 
} 

public class TrackInfoResource { 
public static Optional < TrackInfo > getTrackInfo ( EventModel eventModel ) { 
if ( eventModel . getListResourceContainer ( ) . containsResourcesFromSource ( RESOURCE_ID ) ) return eventModel . getListResourceContainer ( ) . provideResource ( RESOURCE_ID ) . stream ( ) . findAny ( ) . flatMap ( TrackInfo :: importFromResource ) ; 
else return Optional . empty ( ) ; 
} 
} 

public class FireREST { 
public BufferedImage errorImage ( String ... lines ) { 
if ( imageBuffer == null || imageBuffer . getWidth ( ) != imageWidth || imageBuffer . getHeight ( ) != imageHeight ) imageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; 
Graphics2D g = ( Graphics2D ) imageBuffer . getGraphics ( ) ; 
g . setBackground ( new Color ( 64 , 32 , 32 ) ) ; 
g . setColor ( new Color ( 255 , 64 , 64 ) ) ; 
g . clearRect ( 0 , 0 , imageWidth , imageHeight ) ; 
int maxLen = 0 ; 
for ( String line : lines ) { 
if ( line != null ) for ( String innerLine : line . split ( "\n" ) ) { 
maxLen = Math . max ( innerLine . length ( ) , maxLen ) ; 
} 
} 
int padding = 20 ; 
float sizeForWidth = 1.8f * ( imageWidth - padding - padding ) / maxLen ; 
float sizeForHeight = ( imageHeight - padding - padding ) / lines . length ; 
float lineHeight = Math . min ( 80 , Math . max ( 12 , Math . min ( sizeForWidth , sizeForHeight ) ) ) ; 
float fontSize = 0.8f * lineHeight ; 
Font font = g . getFont ( ) . deriveFont ( fontSize ) ; 
g . setFont ( font ) ; 
float y = fontSize + padding ; 
for ( String line : lines ) { 
if ( line != null ) { 
g . drawString ( line , padding , y ) ; 
y += lineHeight ; 
} 
} 
return imageBuffer ; 
} 
} 

public class FireREST { 
public BufferedImage getImage ( URL url ) { 
String now = new Date ( ) . toString ( ) ; 
if ( url == null ) return errorImage ( now , "(No image url)" ) ; 
try { 
HttpURLConnection urlconn = ( HttpURLConnection ) url . openConnection ( ) ; 
urlconn . setReadTimeout ( msTimeout ) ; 
urlconn . setConnectTimeout ( msTimeout ) ; 
urlconn . setRequestMethod ( "GET" ) ; 
urlconn . connect ( ) ; 
BufferedImage image = ImageIO . read ( urlconn . getInputStream ( ) ) ; 
if ( image == null ) return errorImage ( now , "(Null image read)" ) ; 
imageWidth = image . getWidth ( ) ; 
imageHeight = image . getHeight ( ) ; 
return image ; 
} 
catch ( SocketTimeoutException e ) { 
logger . warn ( "getImage({}) => {} {}" , url , e . getClass ( ) . getCanonicalName ( ) , e . getMessage ( ) ) ; 
return errorImage ( now , msTimeout + "ms TIMEOUT" ) ; 
} 
catch ( Exception e ) { 
logger . warn ( "getImage({}) => {} {}" , url , e . getClass ( ) . getCanonicalName ( ) , e . getMessage ( ) ) ; 
return errorImage ( now , "(No image)" , url . toString ( ) , e . getMessage ( ) ) ; 
} 
} 
} 

public class FireREST { 
public JSONResult getJSON ( URL url ) { 
try { 
logger . debug ( "Requesting {}" , url ) ; 
StringBuilder text = new StringBuilder ( ) ; 
String line ; 
HttpURLConnection urlconn = ( HttpURLConnection ) url . openConnection ( ) ; 
urlconn . setReadTimeout ( msTimeout ) ; 
urlconn . setConnectTimeout ( msTimeout ) ; 
urlconn . setRequestMethod ( "GET" ) ; 
urlconn . connect ( ) ; 
BufferedReader br = new BufferedReader ( new InputStreamReader ( urlconn . getInputStream ( ) ) ) ; 
while ( ( line = br . readLine ( ) ) != null ) text . append ( line ) ; 
return new JSONResult ( text . toString ( ) ) ; 
} 
catch ( Throwable e ) { 
throw new FireRESTException ( url . toString ( ) , e ) ; 
} 
} 
} 

public class CartesianProduct { 
private Set < R > multiplication ( ) { 
final Set < R > answer = new LinkedHashSet < > ( this . one . size ( ) * this . two . size ( ) ) ; 
for ( final A left : this . one ) { 
for ( final B right : this . two ) { 
final R element = this . function . apply ( left , right ) ; 
if ( answer . contains ( element ) ) throw new IllegalStateException ( String . format ( "Cartesian product result contains duplicated element %s" , element ) ) ; 
answer . add ( element ) ; 
} 
} 
return ImmutableSet . copyOf ( answer ) ; 
} 
} 

public class Playlist { 
public boolean verify ( Capabilities capabilities ) { 
for ( PlaybackMode playbackMode : playbackModes ) { 
switch ( playbackMode ) { 
case REPEAT : if ( ! capabilities . canRepeatPlayback ( ) ) return false ; 
else break ; 
case REPEAT_SONG : if ( ! capabilities . canRepeatPlaybackOfSong ( ) ) return false ; 
else break ; 
case SHUFFLE : if ( ! capabilities . canShufflePlayback ( ) ) return false ; 
else break ; 
} 
} 
return true ; 
} 
} 

public class Playlist { 
public HashMap < String , Object > export ( ) { 
HashMap < String , Object > data = new HashMap < > ( ) ; 
for ( int i = 0 ; 
i < queue . size ( ) ; 
i ++ ) data . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; 
for ( int i = 0 ; 
i < playbackModes . size ( ) ; 
i ++ ) data . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; 
data . put ( NAME_DESCRIPTOR , name ) ; 
data . put ( POSITION_DESCRIPTOR , position ) ; 
data . put ( DATA_DESCRIPTOR , this . data ) ; 
return data ; 
} 
} 

public class StringUtils { 
public static final String escapeForXML ( String string ) { 
if ( string == null ) return null ; 
char ch ; 
int i = 0 ; 
int last = 0 ; 
char [ ] input = string . toCharArray ( ) ; 
int len = input . length ; 
StringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; 
for ( ; 
i < len ; 
i ++ ) { 
ch = input [ i ] ; 
if ( ch > '>' ) continue ; 
else if ( ch == '<' ) { 
if ( i > last ) out . append ( input , last , i - last ) ; 
last = i + 1 ; 
out . append ( LT_ENCODE ) ; 
} 
else if ( ch == '>' ) { 
if ( i > last ) out . append ( input , last , i - last ) ; 
last = i + 1 ; 
out . append ( GT_ENCODE ) ; 
} 
else if ( ch == '&' ) { 
if ( i > last ) out . append ( input , last , i - last ) ; 
if ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { 
last = i + 1 ; 
out . append ( AMP_ENCODE ) ; 
} 
} 
else if ( ch == '"' ) { 
if ( i > last ) out . append ( input , last , i - last ) ; 
last = i + 1 ; 
out . append ( QUOTE_ENCODE ) ; 
} 
} 
if ( last == 0 ) return string ; 
if ( i > last ) out . append ( input , last , i - last ) ; 
return out . toString ( ) ; 
} 
} 

public class SASLMechanism { 
public void challengeReceived ( String challenge ) throws IOException { 
byte response [ ] ; 
if ( challenge != null ) response = sc . evaluateChallenge ( StringUtils . decodeBase64 ( challenge ) ) ; 
else response = sc . evaluateChallenge ( new byte [ 0 ] ) ; 
Packet responseStanza ; 
if ( response == null ) responseStanza = new Response ( ) ; 
else responseStanza = new Response ( StringUtils . encodeBase64 ( response , false ) ) ; 
getSASLAuthentication ( ) . send ( responseStanza ) ; 
} 
} 

public class ContentEventListener { 
public void handleEvent ( Event event ) { 
String topic = event . getTopic ( ) ; 
LOGGER . debug ( "Got Event {} {} " , event , handlers ) ; 
Collection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; 
if ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) try { 
int ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; 
for ( IndexingHandler indexingHandler : contentIndexHandler ) { 
if ( indexingHandler instanceof QoSIndexHandler ) ttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; 
} 
QueueManager q = null ; 
if ( ttl < queues [ 0 ] . batchDelay ) { 
LOGGER . warn ( "Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. " + "If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. " + "Filling the highest priority queue is counter productive. " , ttl , event ) ; 
queues [ 0 ] . saveEvent ( event ) ; 
} 
else { 
for ( QueueManager qm : queues ) { 
if ( ttl < qm . batchDelay ) { 
q . saveEvent ( event ) ; 
q = null ; 
break ; 
} 
q = qm ; 
} 
if ( q != null ) q . saveEvent ( event ) ; 
} 
} 
catch ( IOException e ) { 
LOGGER . warn ( e . getMessage ( ) , e ) ; 
} 
} 
} 

public class ContentEventListener { 
protected void joinAll ( ) throws InterruptedException { 
if ( queues != null ) for ( QueueManager q : queues ) { 
q . getQueueDispatcher ( ) . join ( ) ; 
} 
} 
} 

public class Authorizable { 
public void setProperty ( String name , Object value ) { 
if ( ! readOnly && ! FILTER_PROPERTIES . contains ( name ) ) { 
Object cv = authorizableMap . get ( name ) ; 
if ( value == null ) if ( cv != null && ! ( cv instanceof RemoveProperty ) ) modifiedMap . put ( name , new RemoveProperty ( ) ) ; 
else if ( ! value . equals ( cv ) ) modifiedMap . put ( name , value ) ; 
else if ( modifiedMap . containsKey ( name ) && ! value . equals ( modifiedMap . get ( name ) ) ) modifiedMap . put ( name , value ) ; 
} 
} 
} 

public class Authorizable { 
public void removeProperty ( String key ) { 
if ( ! readOnly && ( authorizableMap . containsKey ( key ) || modifiedMap . containsKey ( key ) ) ) modifiedMap . put ( key , new RemoveProperty ( ) ) ; 
} 
} 

public class PresenceNonConstant { 
@ SuppressWarnings ( "unused" ) public void userEncountered ( ) { 
List < String > descriptors = new ArrayList < > ( ) ; 
descriptors . add ( CommonEvents . Descriptors . NOT_INTERRUPT ) ; 
boolean known = ! fireUnknownIfNotPresent || present ; 
boolean firstPresent = ( ! strict && ! present ) || ( strict && ! strictPresent ) ; 
long lastSeen = this . lastSeen . until ( LocalDateTime . now ( ) , ChronoUnit . SECONDS ) ; 
Optional < Event > presenceEvent = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( id -> PresenceEvent . createPresenceEvent ( id , strict , known , firstPresent , descriptors , lastSeen ) ) . map ( event -> event . addEventLifeCycleListener ( EventLifeCycle . APPROVED , lifeCycle -> { 
if ( known ) { 
this . lastSeen = LocalDateTime . now ( ) ; 
if ( strict ) this . strictPresent = true ; 
present = true ; 
} 
} 
) ) ; 
if ( ! presenceEvent . isPresent ( ) ) error ( "unable to create PresenceEvent" ) ; 
else fire ( presenceEvent . get ( ) , 5 ) ; 
} 
} 

public class PresenceNonConstant { 
@ Override public void eventFired ( EventModel event ) { 
if ( event . containsDescriptor ( LeavingEvent . ID ) || event . containsDescriptor ( PresenceEvent . ID ) ) { 
if ( event . containsDescriptor ( LeavingEvent . ID ) ) if ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { 
present = false ; 
strictPresent = false ; 
} 
else if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) nonStrictAvailable ( ) . thenAccept ( available -> { 
if ( ! available ) present = false ; 
strictPresent = false ; 
} 
) ; 
else { 
present = true ; 
if ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; 
} 
if ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; 
} 
} 
} 

public class AbstractHashedMap { 
public boolean containsKey ( Object key ) { 
int hashCode = hash ( ( key == null ) ? NULL : key ) ; 
HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; 
while ( entry != null ) { 
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) return true ; 
entry = entry . next ; 
} 
return false ; 
} 
} 

public class AbstractHashedMap { 
public boolean containsValue ( Object value ) { 
if ( value == null ) for ( int i = 0 , isize = data . length ; 
i < isize ; 
i ++ ) { 
HashEntry entry = data [ i ] ; 
while ( entry != null ) { 
if ( entry . getValue ( ) == null ) return true ; 
entry = entry . next ; 
} 
} 
else for ( int i = 0 , isize = data . length ; 
i < isize ; 
i ++ ) { 
HashEntry entry = data [ i ] ; 
while ( entry != null ) { 
if ( isEqualValue ( value , entry . getValue ( ) ) ) return true ; 
entry = entry . next ; 
} 
} 
return false ; 
} 
} 

public class AbstractHashedMap { 
public void clear ( ) { 
modCount ++ ; 
HashEntry [ ] data = this . data ; 
for ( int i = data . length - 1 ; 
i >= 0 ; 
i -- ) data [ i ] = null ; 
size = 0 ; 
} 
} 

public class AbstractHashedMap { 
protected void ensureCapacity ( int newCapacity ) { 
int oldCapacity = data . length ; 
if ( newCapacity <= oldCapacity ) return ; 
if ( size == 0 ) { 
threshold = calculateThreshold ( newCapacity , loadFactor ) ; 
data = new HashEntry [ newCapacity ] ; 
} 
else { 
HashEntry < K , V > oldEntries [ ] = data ; 
HashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; 
modCount ++ ; 
for ( int i = oldCapacity - 1 ; 
i >= 0 ; 
i -- ) { 
HashEntry < K , V > entry = oldEntries [ i ] ; 
if ( entry != null ) { 
oldEntries [ i ] = null ; 
do { 
HashEntry < K , V > next = entry . next ; 
int index = hashIndex ( entry . hashCode , newCapacity ) ; 
entry . next = newEntries [ index ] ; 
newEntries [ index ] = entry ; 
entry = next ; 
} 
while ( entry != null ) ; 
} 
} 
threshold = calculateThreshold ( newCapacity , loadFactor ) ; 
data = newEntries ; 
} 
} 
} 

public class AbstractHashedMap { 
protected int calculateNewCapacity ( int proposedCapacity ) { 
int newCapacity = 1 ; 
if ( proposedCapacity > MAXIMUM_CAPACITY ) newCapacity = MAXIMUM_CAPACITY ; 
else { 
while ( newCapacity < proposedCapacity ) newCapacity <<= 1 ; 
if ( newCapacity > MAXIMUM_CAPACITY ) newCapacity = MAXIMUM_CAPACITY ; 
} 
return newCapacity ; 
} 
} 

public class AbstractHashedMap { 
protected Iterator < Map . Entry < K , V > > createEntrySetIterator ( ) { 
if ( size ( ) == 0 ) return EmptyIterator . INSTANCE ; 
return new EntrySetIterator < K , V > ( this ) ; 
} 
} 

public class Types { 
public static void loadFromStream ( String key , Map < String , Object > output , InputStream binaryStream , String type ) throws IOException { 
DataInputStream dis = new DataInputStream ( binaryStream ) ; 
String ckey = dis . readUTF ( ) ; 
if ( ! key . equals ( ckey ) ) throw new IOException ( "Body Key does not match row key, unable to read" ) ; 
readMapFromStream ( output , dis ) ; 
String cftype = null ; 
try { 
cftype = dis . readUTF ( ) ; 
} 
catch ( IOException e ) { 
LOGGER . debug ( "No type specified" ) ; 
} 
if ( cftype != null && ! cftype . equals ( type ) ) throw new IOException ( "Object is not of expected column family, unable to read expected [" + type + "] was [" + cftype + "]" ) ; 
LOGGER . debug ( "Finished Reading" ) ; 
dis . close ( ) ; 
binaryStream . close ( ) ; 
} 
} 

public class AddOn { 
@ Override public void register ( ) { 
prepare ( ) ; 
ContentGenerator [ ] contentGenerators = registerContentGenerator ( ) ; 
if ( contentGenerators != null ) for ( ContentGenerator contentGenerator : contentGenerators ) { 
try { 
getContext ( ) . getContentGenerators ( ) . registerContentGenerator ( contentGenerator ) ; 
} 
catch ( IllegalIDException e ) { 
context . getLogger ( ) . fatal ( "Illegal Id for Module: " + contentGenerator . getID ( ) , e ) ; 
} 
} 
EventsControllerModel [ ] eventsControllerModels = registerEventController ( ) ; 
if ( eventsControllerModels != null ) for ( EventsControllerModel eventsController : eventsControllerModels ) { 
try { 
getContext ( ) . getEvents ( ) . distributor ( ) . registerEventsController ( eventsController ) ; 
} 
catch ( IllegalIDException e ) { 
context . getLogger ( ) . fatal ( "Illegal Id for Module: " + eventsController . getID ( ) , e ) ; 
} 
} 
OutputPluginModel [ ] outputPluginModels = registerOutputPlugin ( ) ; 
if ( outputPluginModels != null ) for ( OutputPluginModel outputPlugin : outputPluginModels ) { 
try { 
getContext ( ) . getOutput ( ) . addOutputPlugin ( outputPlugin ) ; 
} 
catch ( IllegalIDException e ) { 
context . getLogger ( ) . fatal ( "Illegal Id for Module: " + outputPlugin . getID ( ) , e ) ; 
} 
} 
OutputExtensionModel [ ] outputExtensionModels = registerOutputExtension ( ) ; 
if ( outputExtensionModels != null ) for ( OutputExtensionModel outputExtension : outputExtensionModels ) { 
try { 
getContext ( ) . getOutput ( ) . addOutputExtension ( outputExtension ) ; 
} 
catch ( IllegalIDException e ) { 
context . getLogger ( ) . fatal ( "Illegal Id for Module: " + outputExtension . getID ( ) , e ) ; 
} 
} 
OutputControllerModel [ ] outputControllerModels = registerOutputController ( ) ; 
if ( outputControllerModels != null ) for ( OutputControllerModel outputController : outputControllerModels ) { 
try { 
getContext ( ) . getOutput ( ) . addOutputController ( outputController ) ; 
} 
catch ( IllegalIDException e ) { 
context . getLogger ( ) . fatal ( "Illegal Id for Module: " + outputController . getID ( ) , e ) ; 
} 
} 
ActivatorModel [ ] activatorModels = registerActivator ( ) ; 
getContext ( ) . getSystem ( ) . registerInitializedListener ( ( ) -> { 
if ( activatorModels != null ) for ( ActivatorModel activator : activatorModels ) { 
try { 
getContext ( ) . getActivators ( ) . addActivator ( activator ) ; 
} 
catch ( IllegalIDException e ) { 
context . getLogger ( ) . fatal ( "Illegal Id for Module: " + activator . getID ( ) , e ) ; 
} 
} 
} 
) ; 
} 
} 

public class ReconnectionManager { 
protected void notifyReconnectionFailed ( Exception exception ) { 
if ( isReconnectionAllowed ( ) ) for ( ConnectionListener listener : connection . connectionListeners ) { 
listener . reconnectionFailed ( exception ) ; 
} 
} 
} 

public class ReconnectionManager { 
protected void notifyAttemptToReconnectIn ( int seconds ) { 
if ( isReconnectionAllowed ( ) ) for ( ConnectionListener listener : connection . connectionListeners ) { 
listener . reconnectingIn ( seconds ) ; 
} 
} 
} 

